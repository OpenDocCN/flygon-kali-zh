- en: '*Chapter 13*: Files, Streams, and Serialization'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章：文件、流和序列化
- en: 'Programming is all about processing data that could come from various sources,
    such as local memory, disk files, or from a remote server over the network. Most
    data has to be persisted for either a long time or indefinitely. It has to be
    available between different application restarts or shared between multiple applications.
    Whether the storage is plain text files or various types of databases, whether
    they are local, from the network, or a cloud, whether the physical location is
    hard disk drives, solid state drives, or USB sticks, all data is preserved in
    a filesystem. Different platforms have different types of filesystems, but they
    all work with the same abstractions: paths, files, and directories.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程主要涉及处理可能来自各种来源的数据，例如本地内存、磁盘文件或通过网络从远程服务器获取的数据。大多数数据必须被持久化，以供长时间或无限期使用。它必须在不同应用程序重新启动之间可用，或在多个应用程序之间共享。无论存储是纯文本文件还是各种类型的数据库，无论它们是本地的、来自网络的还是云端的，无论物理位置是硬盘驱动器、固态驱动器还是USB存储设备，所有数据都保存在文件系统中。不同的平台具有不同类型的文件系统，但它们都使用相同的抽象：路径、文件和目录。
- en: 'In this chapter, we look at the functionalities that .NET provides for working
    with filesystems. The main topics that will be covered in this chapter are as
    follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨.NET为处理文件系统提供的功能。本章将涵盖的主要主题如下：
- en: Overview of the `System.IO` namespace
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: System.IO命名空间概述
- en: Working with paths
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理路径
- en: Working with files and directories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文件和目录
- en: Working with streams
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理流
- en: Serializing and deserializing XML
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化和反序列化XML
- en: Serializing and deserializing JSON
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化和反序列化JSON
- en: By the end of this chapter, you will have learned how to create, modify, and
    delete files and directories. You will have also learned how to read from and
    write to files with different kinds of data (including binary and text). Lastly,
    you will have learned how to serialize objects to XML and JSON.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将学会如何创建、修改和删除文件和目录。您还将学会如何读取和写入不同类型的数据文件（包括二进制和文本）。最后，您将学会如何将对象序列化为XML和JSON。
- en: Let's begin by exploring the `System.IO` namespace.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索`System.IO`命名空间开始。
- en: Overview of the System.IO namespace
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: System.IO命名空间概述
- en: The .NET frameworks provide classes as well as other helper types such as enumerations,
    interfaces, and delegates that help us work with the `System.IO` namespace in
    the Base Class Library. The complete list of types is rather long, but the following
    tables show the most important of these grouped into several categories.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: .NET框架提供了类以及其他辅助类型，如枚举、接口和委托，帮助我们在基类库中使用`System.IO`命名空间。类型的完整列表相当长，但以下表格显示了其中最重要的类型，分成几个类别。
- en: 'The most important classes for working with *filesystem objects* are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 用于处理*文件系统对象*的最重要的类如下：
- en: '![](img/Chapter_13_Table_01_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_01_01.jpg)'
- en: 'The most important classes for working with *streams* are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用于处理*流*的最重要的类如下：
- en: '![](img/Chapter_13_Table_02_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_02_01.jpg)'
- en: 'As you can see in the previous table, the concrete classes in this list come
    in pairs: a reader and a writer. Typically, these are used as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，此列表中的具体类是成对出现的：一个读取器和一个写入器。通常，它们的使用方式如下：
- en: '`BinaryReader` and `BinaryWriter` are used to explicitly serialize and deserialize
    primitive data types to or from binary files.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BinaryReader`和`BinaryWriter`用于显式地将原始数据类型序列化和反序列化到二进制文件中。'
- en: '`StreamReader` and `StreamWriter` are used for handling character-based data,
    with different encodings, from text files.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StreamReader`和`StreamWriter`用于处理来自文本文件的具有不同编码的基于字符的数据。'
- en: '`StringReader` and `StringWriter` have similar interfaces and purposes as the
    previous pair, although they work on strings and string buffers and not streams.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StringReader`和`StringWriter`具有与前一对类似的接口和目的，尽管它们在字符串和字符串缓冲区上工作，而不是流。'
- en: 'The relationship between the classes in the previous table is shown in the
    following simplified class diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前表中类之间的关系如下简化的类图所示：
- en: '![Figure 13.1 – A class diagram of stream classes as well as reader and writer
    classes mentioned previously'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.1 - 流类和先前提到的读取器和写入器类的类图'
- en: '](img/Figure_13.1_B12346.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.1_B12346.jpg)'
- en: Figure 13.1 – A class diagram of stream classes as well as reader and writer
    classes mentioned previously
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 - 流类以及先前提到的读取器和写入器类的类图
- en: From this diagram, you can see that only `FileStream` and `MemoryStream` are
    actually stream classes. `BinaryReader` and `StreamReader` are adapters that read
    data from a stream, while `BinaryWriter` and `StreamWriter` write data to a stream.
    All these classes require a stream to create an instance (the stream is passed
    as an argument to the constructor). On the other hand, `StringReader` and `StringWriter`
    don't work on streams at all; instead, they read and write from a string or string
    buffer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个图表中，您可以看到只有`FileStream`和`MemoryStream`实际上是流类。`BinaryReader`和`StreamReader`是适配器，从流中读取数据，而`BinaryWriter`和`StreamWriter`向流中写入数据。所有这些类都需要一个流来创建实例（流作为参数传递给构造函数）。另一方面，`StringReader`和`StringWriter`根本不使用流；相反，它们从字符串或字符串缓冲区中读取和写入。
- en: 'Most operations with the filesystem objects or streams throw exceptions when
    errors occur. The most important of these exceptions are listed here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统对象或流的大多数操作在发生错误时会抛出异常。其中最重要的异常如下所列：
- en: '![](img/Chapter_13_Table_03_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_03_01.jpg)'
- en: In the following sections of this chapter, we will look at some of these classes
    in detail. For now, we will start with the `Path` class.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，我们将详细介绍其中一些类。现在，我们将从`Path`类开始。
- en: Working with paths
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理路径
- en: '`System.IO.Path` is a static class that performs operations on strings, representing
    the path of a filesystem object (a file or a directory). None of the class methods
    verify whether the string represents the path of a valid file or directory. However,
    members that accept an input path verify that the path is well formed; otherwise,
    they throw an exception. This class can handle paths for different platforms.
    The format of a path such as the presence of a root element or the path separator
    is platform-dependent and is determined by the platform that the application is
    running on.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.IO.Path`是一个静态类，对表示文件系统对象（文件或目录）的路径执行操作。该类的方法都不验证字符串是否表示有效文件或目录的路径。但是，接受输入路径的成员会验证路径是否格式良好；否则，它们会抛出异常。该类可以处理不同平台的路径。路径的格式，如根元素的存在或路径分隔符，取决于平台，并由应用程序运行的平台确定。'
- en: A path can be *relative* or *absolute*. An absolute path is one that fully specifies
    the location. On the other hand, a relative path is a partial location determined
    by the current location, which can be retrieved with a call to the `Directory.GetCurrentDirector()`
    method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 路径可以是*相对的*或*绝对的*。绝对路径是完全指定位置的路径。另一方面，相对路径是由当前位置确定的部分位置，可以通过调用`Directory.GetCurrentDirector()`方法检索。
- en: 'All the members of the `Path` class are static. The most important ones are
    listed in the following table:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`类的所有成员都是静态的。最重要的成员列在下表中：'
- en: '![](img/Chapter_13_Table_04_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_04_01.jpg)'
- en: 'To see how this works, we can consider the following example, where we''re
    using various methods of the `Path` class to print information about the `c:\Windows\System32\mmc.exe`
    path:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这是如何工作的，我们可以考虑以下示例，其中我们使用`Path`类的各种方法打印有关`c:\Windows\System32\mmc.exe`路径的信息：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of this program is shown in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出如下屏幕截图所示：
- en: '![Figure 13.2 – A screenshot of executing the previous sample that prints information
    about a path'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 - 执行前面示例的屏幕截图，打印有关路径的信息
- en: '](img/Figure_13.2_B12346.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.2_B12346.jpg)'
- en: Figure 13.2 – A screenshot of executing the previous sample that prints information
    about a path
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 - 执行前面示例的屏幕截图，打印有关路径的信息
- en: 'The `Path` class contains a method called `Combine()` and it is recommended
    to use it for composing a new path from two or more paths. There are four overloads
    of this method; these overloads take two, three, four paths, or an array of paths
    as input arguments. To understand how this works, we will look at the following
    examples, where we are concatenating two paths:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`类包含一个名为`Combine()`的方法，建议使用它来从两个或多个路径组合新路径。该方法有四个重载；这些重载接受两个、三个、四个路径或路径数组作为输入参数。为了理解这是如何工作的，我们将看一下以下示例，其中我们正在连接两个路径：'
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first example, the result of the concatenation is `c:\temp\sub\data.txt`,
    which properly includes a path separator between `temp` and `sub`, which was not
    present in any of the two input paths. In the second example, the result of the
    concatenation of the three paths is `c:\temp\sub\..\log.txt`. Notice that the
    path is properly composed, but not resolved to the actual path, that is, `c:\temp\log.txt`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，连接的结果是`c:\temp\sub\data.txt`，这在`temp`和`sub`之间正确地包括了路径分隔符，而这两个输入路径中都没有。在第二个例子中，连接三个路径的结果是`c:\temp\sub\..\log.txt`。请注意，路径被正确组合，但未解析为实际路径，即`c:\temp\log.txt`。
- en: 'In addition to the methods listed earlier, there are several other static methods
    in the `Path` class, a few of them intended for working with temporary files.
    These are listed here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面列出的方法之外，`Path`类中还有几个其他静态方法，其中一些用于处理临时文件。这些在这里列出：
- en: '![](img/Chapter_13_Table_05_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_05_01.jpg)'
- en: 'Let''s look at an example of working with temporary paths:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个处理临时路径的例子：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As shown in the following screenshot, `path1` will contain a path such as `C:\Users\Marius\AppData\Local\Temp\w22fbbqw.y34`,
    although the file name (including extension) will change with each execution.
    Also, this path is not created on disk, unlike the second example, where the `C:\Users\Marius\AppData\Local\Temp\tmp8D5A.tmp`
    path is actually representing a newly created file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如下屏幕截图所示，`path1`将包含一个路径，例如`C:\Users\Marius\AppData\Local\Temp\w22fbbqw.y34`，尽管文件名（包括扩展名）会随着每次执行而改变。此外，这个路径不会在磁盘上创建，不像第二个例子，其中`C:\Users\Marius\AppData\Local\Temp\tmp8D5A.tmp`路径实际上代表一个新创建的文件：
- en: '![Figure 13.3 – Screenshot of the sample demonstrating the use of the GetRandomFileName()'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 - 屏幕截图，演示了使用GetRandomFileName()方法
- en: '](img/Figure_13.3_B12346.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.3_B12346.jpg)'
- en: Figure 13.3 – Screenshot of the sample demonstrating the use of the GetRandomFileName()
    and GetTempFileName() methods
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 - 屏幕截图，演示了使用GetRandomFileName()和GetTempFileName()方法
- en: There are two important differences between these two temporary paths—the first
    one uses a cryptographically strong method for generating the name, while the
    second uses a much simpler algorithm. On the other hand, `GetRandomFileName()`
    returns a name with a random extension, while `GetTempFileName()` always returns
    a path with a filename with the `.TMP` extension.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个临时路径之间有两个重要的区别——第一个使用了加密强大的方法来生成名称，而第二个使用了一个更简单的算法。另一方面，`GetRandomFileName()`返回一个带有随机扩展名的名称，而`GetTempFileName()`总是返回一个带有`.TMP`扩展名的文件名。
- en: To verify whether a path exists and perform operations such as creating, moving,
    deleting, or opening a directory or file, we must use other classes from the `System.IO`
    namespace. We'll look at these classes in the following section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证路径是否存在并执行创建、移动、删除或打开目录或文件等操作，我们必须使用`System.IO`命名空间中的其他类。我们将在下一节中看到这些类。
- en: Working with files and directories
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件和目录
- en: The `System.IO` namespace contains two classes for working with directories
    (`Directory` and `DirectoryInfo`), and two for working with files (`File` and
    `FileInfo`). `Directory` and `File` are `DirectoryInfo` and `FileInfo`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.IO`命名空间包含两个用于处理目录的类（`Directory`和`DirectoryInfo`），以及两个用于处理文件的类（`File`和`FileInfo`）。`Directory`和`File`是`DirectoryInfo`和`FileInfo`。'
- en: 'The latter two are derived from the `FileSystemInfo` base abstract class, which
    provides members that are common for manipulating both files and directories.
    The most important of these members are the properties listed in the following
    table:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 后两者都是从`FileSystemInfo`基类派生的，该基类提供了对文件和目录进行操作的常用成员。其中最重要的成员是以下表中列出的属性：
- en: '![](img/Chapter_13_Table_06_01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_06_01.jpg)'
- en: 'The most important members of the `DirectoryInfo` class, excluding the ones
    inherited from the base class, which were listed in the preceding table, are as
    follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirectoryInfo`类的最重要成员（不包括在前面的表中列出的从基类继承的成员）如下：'
- en: '![](img/Chapter_13_Table_07_01.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_07_01.jpg)'
- en: 'Similarly, the most important members of the `FileInfo` class, excluding the
    ones inherited from the base class, are as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`FileInfo`类的最重要成员（不包括从基类继承的成员）如下：
- en: '![](img/Chapter_13_Table_08_01.jpg)![](img/Chapter_13_Table_08_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_08_01.jpg)![](img/Chapter_13_Table_08_02.jpg)'
- en: Now that we have looked at the classes available for handling filesystem objects
    and their most important members, let's look at some examples of using them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了用于处理文件系统对象及其最重要成员的类，让我们看一些使用它们的示例。
- en: 'In the first example, we will use an instance of `DirectoryInfo` to print information
    about a directory (in this example, `C:\Program Files (x86)\Microsoft SDKs\Windows\`),
    such as name, parent, root, creation time, and attributes, as well as the names
    of all its subdirectories:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们将使用`DirectoryInfo`的实例来打印有关目录（在本例中为`C:\Program Files (x86)\Microsoft
    SDKs\Windows\`）的信息，如名称、父级、根、创建时间和属性，以及所有子目录的名称：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output from executing this code is as follows (notice this will differ
    on each machine that executes the code):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码的输出如下（请注意，每台执行代码的机器都会有所不同）：
- en: '![Figure 13.4 – Screenshot of the previous sample displaying directory information'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.4 - 屏幕截图显示先前示例的目录信息'
- en: '](img/Figure_13.4_B12346.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.4_B12346.jpg)'
- en: Figure 13.4 – Screenshot of the previous sample displaying directory information
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 - 屏幕截图显示先前示例的目录信息
- en: '`DirectoryInfo` also allows us to create and delete directories, which is what
    we will do in the next example. First, we create the `C:\Temp\Dir\Sub` directory.
    Second, we create the subdirectory hierarchy, `sub1\sub2\sub3`, relative to the
    previously directory. Lastly, we delete the most inner directory, `sub3`, from
    the `C:\Temp\Dir\Sub\sub1\sub2` directory:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`DirectoryInfo`还允许我们创建和删除目录，这是我们将在下一个示例中做的事情。首先，我们创建`C:\Temp\Dir\Sub`目录。其次，我们相对于先前的目录创建子目录层次结构`sub1\sub2\sub3`。最后，我们从`C:\Temp\Dir\Sub\sub1\sub2`目录中删除最内部的目录`sub3`：'
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the `CreateSubdirectory()` method returns a `DirectoryInfo` instance
    that represents the most inner subdirectory created, which, in this case, is `C:\Temp\Dir\Sub\sub1\sub2\sub3`.
    Therefore, when invoking `Delete()` on this instance, only the `sub3` subdirectory
    is deleted.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`CreateSubdirectory()`方法返回一个表示创建的最内部子目录的`DirectoryInfo`实例，在这种情况下是`C:\Temp\Dir\Sub\sub1\sub2\sub3`。因此，在此实例上调用`Delete()`时，只会删除`sub3`子目录。
- en: 'We can write the same functionality using the `Directory` static class and
    its `CreateDirectory()` and `Delete()` methods, as shown in the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Directory`静态类及其`CreateDirectory()`和`Delete()`方法来编写相同的功能，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first call to `Delete()` will delete the `C:\Temp\Dir\Sub\sub1\sub2\sub3`
    subdirectory, but only if it is empty. The second call will delete the `C:\Temp\Dir\Sub`
    subdirectory and all its content (files and subdirectories) in a recursive manner.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`Delete()`将删除`C:\Temp\Dir\Sub\sub1\sub2\sub3`子目录，但仅当它为空时。第二次调用将以递归方式删除`C:\Temp\Dir\Sub`子目录及其所有内容（文件和子目录）。
- en: 'In the next example, we will list all the executable files that start with
    the letter `T` from a given directory (in this case, `C:\Program Files (x86)\Microsoft
    SDKs\Windows\v10.0A\bin\NETFX 4.8 Tools\`). For this, we''ll use the `GetFiles()`
    method providing the proper filter. This method returns an array of `FileInfo`
    objects and we print information about the file using different properties of
    this class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将列出从给定目录（在本例中为`C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX
    4.8 Tools\`）开始以字母`T`开头的所有可执行文件。为此，我们将使用`GetFiles()`方法提供适当的过滤器。该方法返回一个`FileInfo`对象数组，我们使用该类的不同属性打印有关文件的信息：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output from executing this code sample could be as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码示例的输出可能如下所示：
- en: '![Figure 13.5 – A screenshot of the program listing executables that start
    with the letter T from a given directory'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.5 - 屏幕截图显示从给定目录中以字母T开头的可执行文件列表'
- en: '](img/Figure_13.5_B12346.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.5_B12346.jpg)'
- en: Figure 13.5 – A screenshot of the program listing executables that start with
    the letter T from a given directory
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 - 屏幕截图显示从给定目录中以字母T开头的可执行文件列表
- en: 'To print the information about the file, we used the `FileInfo` class, as mentioned
    previously. `Name`, `Length`, and `Attributes` are only some of the properties
    this class provides. Others include the extension and file times. An example of
    using them is shown in the following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印有关文件的信息，我们使用了之前提到的`FileInfo`类。`Name`、`Length`和`Attributes`只是该类提供的一些属性。其他包括扩展名和文件时间。下面的代码片段显示了使用它们的示例：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Although the output will vary on each machine, it should look as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管输出在每台机器上会有所不同，但应如下所示：
- en: '![Figure 13.6 – Detailed file information displayed with the help of the FileInfo
    class'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6 - 利用FileInfo类显示详细文件信息'
- en: '](img/Figure_13.6_B12346.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.6_B12346.jpg)'
- en: Figure 13.6 – Detailed file information displayed with the help of the FileInfo
    class
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 - 使用FileInfo类显示的详细文件信息
- en: 'We can use what we have learned so far to create a function that writes the
    content of a directory recursively to the console and while doing so, also indents
    the names of the files and directories as it navigates deeper in the directory
    hierarchy. Such a function could look as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用到目前为止学到的知识来创建一个函数，将目录的内容递归地写入控制台，并在这样做的同时，随着在目录层次结构中的深入导航，也缩进文件和目录的名称。这样的函数可能如下所示：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When executed with the path of the project directory as input, it prints the
    following output to the console (the following screenshot is a snippet of the
    complete output):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当以项目目录的路径作为输入执行时，它会将以下输出打印到控制台（以下截图是完整输出的一部分）：
- en: '![Figure 13.7 – Partial output of the program that prints, recursively, the
    content of a specified directory'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.7 - 打印指定目录内容的程序的部分输出'
- en: '](img/Figure_13.7_B12346.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.7_B12346.jpg)'
- en: Figure 13.7 – Partial output of the program that prints, recursively, the content
    of a specified directory
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 - 打印指定目录内容的程序的部分输出
- en: As you may have noticed, we used both `GetFiles()` and `EnumerateFile()`, as
    well as `EnumerateDirectories()`. These two sets of methods, the ones prefixed
    with `Get` and the ones prefixed with `Enumerate`, are similar in the sense that
    they return a collection of files or directories.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们同时使用了`GetFiles()`和`EnumerateFile()`，以及`EnumerateDirectories()`。这两组方法，以`Get`和`Enumerate`为前缀的方法，在返回文件或目录的集合方面是相似的。
- en: However, they differ in one key aspect—the `Get` methods return an array of
    objects, while the `Enumerate` methods return an `IEnumerable<T>` that allows
    clients to start iterating before all the filesystem objects are retrieved and
    also consume only what they want. These methods could, therefore, be a better
    alternative in many cases.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们在一个关键方面有所不同——`Get`方法返回一个对象数组，而`Enumerate`方法返回一个`IEnumerable<T>`，允许客户端在检索到所有文件系统对象之前开始迭代，并且只消耗他们想要的。因此，在许多情况下，这些方法可能是一个更好的选择。
- en: 'Most of the examples so far were focused on getting file and directory information,
    although we did create and delete directories. We can use the `File` and `FileInfo`
    classes to create and delete files. For instance, we can use `File.Create()` to
    create a new file or open and overwrite an existing file, as shown in the following
    example:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大多数示例都集中在获取文件和目录信息上，尽管我们确实创建和删除了目录。我们可以使用`File`和`FileInfo`类来创建和删除文件。例如，我们可以使用`File.Create()`来创建一个新文件或打开并覆盖现有文件，如下例所示：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`File.Create()` returns a `FileStream` that, in this example, is then used
    to create a `StreamWriter` that allows us to write the text `This is a demo` to
    the file. The stream is then disposed and the file handle is properly closed.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`File.Create()`返回一个`FileStream`，在这个例子中，然后用它来创建一个`StreamWriter`，允许我们向文件写入文本`This
    is a demo`。然后流被处理，文件句柄被正确关闭。'
- en: If you are interested only in writing text or binary data, you can use static
    members of the `File` class, such as `WriteAllText()`, `WriteAllLines()`, or `WriteAllBytes()`.
    These have multiple overloads, allowing you, for instance, to specify text encoding.
    There are also asynchronous counterparts, `WriteAllTextAsync()`, `WriteAllLinesAsync()`,
    and `WriteAllBytesAsync()`. All these methods overwrite the current content of
    the file if it already exists. If you are interested in preserving the content
    and appending to its end, then you can use the `AppendAllText()` and `AppendAllLines()`
    methods and their asynchronous counterparts, `AppendAllTextAsync()` and `AppendAllLinesAsync()`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只对写入文本或二进制数据感兴趣，可以使用`File`类的静态成员，如`WriteAllText()`、`WriteAllLines()`或`WriteAllBytes()`。这些方法有多个重载，允许您指定文本编码，例如。还有异步对应方法，`WriteAllTextAsync()`、`WriteAllLinesAsync()`和`WriteAllBytesAsync()`。所有这些方法都会覆盖文件的当前内容（如果文件已经存在）。如果您希望保留内容并追加到文件的末尾，那么可以使用`AppendAllText()`和`AppendAllLines()`方法及其异步对应方法`AppendAllTextAsync()`和`AppendAllLinesAsync()`。
- en: 'The following example shows how to write and append text to an existing file
    using some of the methods mentioned here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用这里提到的一些方法向现有文件写入和追加文本：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first call, `WriteAllText()`, will write `This is a demo` to the file,
    overwriting any content. The second call, `AppendAllText()`, will append `1st
    line` without adding any new lines. The third call, `AppendAllLines()`, will write
    each string to the file, adding a new line after each. Therefore, after executing
    this code, the content of the file will be as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`WriteAllText()`将`This is a demo`写入文件，覆盖任何内容。第二次调用`AppendAllText()`将`1st
    line`追加到文件中，而不添加任何新行。第三次调用`AppendAllLines()`将每个字符串写入文件，并在每个字符串后添加一个新行。因此，执行此代码后，文件的内容将如下所示：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similar to writing content to a file, reading is also possible using the `File`
    class and its `ReadAllText()`, `ReadAllLines()`, and `ReadAllBytes()` methods.
    As with the write methods, there are also asynchronous versions, `ReadAllTextAsync()`,
    `ReadAllLinesAsync()`, and `ReadAllBytesAsync()`. An example of using some of
    these methods is shown in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与向文件写入内容类似，使用`File`类及其`ReadAllText()`、`ReadAllLines()`和`ReadAllBytes()`方法也可以进行读取。与写入方法一样，还有异步版本，`ReadAllTextAsync()`、`ReadAllLinesAsync()`和`ReadAllBytesAsync()`。下面的代码示例展示了如何使用其中一些方法：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After executing this code, the `text` variable will contain the entire text
    read from the file. On the other hand, `lines` will be an array with two elements,
    the first being `This is a demo1st line2nd line` and the second being `3rd line`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码后，`text`变量将包含从文件中读取的整个文本。另一方面，`lines`将是一个包含两个元素的数组，第一个是`This is a demo1st
    line2nd line`，第二个是`3rd line`。
- en: Plain text is not the only kind of data we would usually write to a file, and
    files are not the only storage systems for data. Sometimes, we might be interested
    in reading and writing from and to pipes, networks, local memory, or others. To
    handle all of this, .NET provides *streams*, which is the topic of the next section.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 纯文本并不是我们通常会写入文件的唯一类型的数据，文件也不是数据的唯一存储系统。有时，我们可能对从管道、网络、本地内存或其他地方读取和写入感兴趣。为了处理所有这些，.NET提供了*流*，这是下一节的主题。
- en: Working with streams
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理流
- en: 'A `Stream`, which provides support for reading from and writing to a stream.
    On the other hand, the streams are conceptually grouped into three categories:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`，提供了对流进行读取和写入的支持。另一方面，流在概念上分为三类：'
- en: '`FileStream`, `MemoryStream`, and `NetworkStream` to implement backing stores.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileStream`、`MemoryStream`和`NetworkStream`来实现后备存储。'
- en: '`BufferedStream`, `CryptoStream`, `DeflateStream`, and `GZipStream`.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BufferedStream`、`CryptoStream`、`DeflateStream`和`GZipStream`。'
- en: '`bool`, `int`, `double`, etc.), text, XML data, and so on. Adaptors provided
    by .NET include `BinaryReader` and `BinaryWriter`, `StreamReader` and `StreamWriter`,
    and `XmlReader` and `XmlWriter`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool`、`int`、`double`等）、文本、XML数据等。.NET提供的适配器包括`BinaryReader`和`BinaryWriter`、`StreamReader`和`StreamWriter`，以及`XmlReader`和`XmlWriter`。'
- en: 'The following diagram shows, conceptually, the stream architecture:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表概念上展示了流架构：
- en: '![Figure 13.8 – A conceptual diagram of the stream''s architecture'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.8 - 流架构的概念图'
- en: '](img/Figure_13.8_B12346.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.8_B12346.jpg)'
- en: Figure 13.8 – A conceptual diagram of the stream's architecture
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 - 流架构的概念图
- en: Discussing all the stream classes pictured in the preceding diagram is beyond
    the scope of this book. However, in this section, we will focus on the `BinaryReader`/`BinaryWriter`
    and `StreamReader`/`StreamWriter` adapters, as well as the `FileStream` and `MemoryStream`
    backing store streams.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论前面图中显示的所有流类超出了本书的范围。然而，在本节中，我们将重点关注`BinaryReader`/`BinaryWriter`和`StreamReader`/`StreamWriter`适配器，以及`FileStream`和`MemoryStream`后备存储流。
- en: Overview of the stream classes
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流类的概述
- en: 'As I mentioned earlier, the base class for all stream classes is the `System.IO.Stream`
    class. This is an abstract class that provides methods and properties for reading
    and writing from and to a stream. Many of these are abstract and are implemented
    in derived classes. The following are the most important methods of the class:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，所有流类的基类是`System.IO.Stream`类。这是一个提供从流中读取和写入的方法和属性的抽象类。其中许多是抽象的，并且在派生类中实现。以下是该类的最重要的方法：
- en: '![](img/Chapter_13_Table_09_01.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_09_01.jpg)'
- en: Some of the operations listed have asynchronous companions, which are suffixed
    with the word `Async` (such as `ReadAsync()` or `WriteAsync()`). The read and
    write operations advance the pointer that indicates the position in the current
    stream with the number of bytes read or written.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的一些操作有异步伴侣，其后缀为`Async`（例如`ReadAsync()`或`WriteAsync()`）。读取和写入操作会使指示当前流位置的指针前进读取或写入的字节数。
- en: 'The `Stream` class also provides several useful properties that are listed
    in the following table:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`类还提供了几个有用的属性，列在下表中：'
- en: '![](img/Chapter_13_Table_10_01.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_10_01.jpg)'
- en: The class that represents a backing store stream for a file is called `FileStream`.
    This class is derived from the abstract `Stream` class and implements the abstract
    members. It supports both synchronous and asynchronous operations and can be used
    for opening, reading, writing, and closing not only disk files but other operating
    system objects, such as pipes and the standard input and output. The asynchronous
    methods are useful for performing time-consuming operations without blocking the
    main thread.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代表文件的后备存储流的类称为`FileStream`。这个类是从抽象的`Stream`类派生而来的，并实现了抽象成员。它支持同步和异步操作，并且不仅可以用于打开、读取、写入和关闭磁盘文件，还可以用于其他操作系统对象，比如管道和标准输入和输出。异步方法对于执行耗时操作而不阻塞主线程非常有用。
- en: The `FileStream` class supports random access to a file. The `Seek()` method
    allows us to move the position of the current pointer for reading/writing within
    the stream. When changing the position, you must specify a byte offset and a seek
    origin. The byte offset is relative to the seek origin, which can be the beginning,
    the current position, or the end of the stream.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream`类支持对文件的随机访问。`Seek()`方法允许我们在流内移动当前指针的位置进行读取/写入。在改变位置时，必须指定一个字节偏移量和一个查找原点。字节偏移量是相对于查找原点的，查找原点可以是流的开头、当前位置或者末尾。'
- en: The class provides many constructors for creating an instance of the class.
    You can supply a file handle (either as an `IntPtr` or a `SafeFileHandle`) or
    a file path, as well as a file mode (which determines how the file should be opened),
    file access (which determines how the file should be accessed – for reading, writing,
    or both), and file share (which determines how other file streams can access the
    same file) in various combinations. Listing all these constructors is impractical
    here but we will see several examples throughout this chapter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该类提供了许多构造函数来创建类的实例。您可以以各种组合提供文件句柄（作为`IntPtr`或`SafeFileHandle`）、文件路径、文件模式（确定文件应该如何打开）、文件访问（确定文件应该如何访问
    - 读取、写入或两者）、以及文件共享（确定其他文件流如何访问相同的文件）。在这里列出所有这些构造函数是不切实际的，但我们将在本章中看到几个示例。
- en: The class that represents a backing store for memory is called `MemoryStream`
    and is also derived from `Stream`. Most of the members of this class are implementations
    of the abstract members of the base class. However, the class features several
    constructors that allow us to create either a **resizable stream** (initially
    empty or with a specified capacity) or a **non-resizable stream** from an array
    of bytes. Memory streams created from an array of bytes cannot be expanded or
    shrunk and can be writeable or read-only.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 表示内存备份存储的类称为`MemoryStream`，也是从`Stream`派生而来的。该类的大多数成员都是基类的抽象成员的实现。但是，该类具有几个构造函数，允许我们创建**可调整大小的流**（初始为空或具有指定容量）或从字节数组创建**不可调整大小的流**。从字节数组创建的内存流不能扩展或收缩，可以是可写的或只读的。
- en: Working with file streams
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文件流
- en: 'The `FileStream` class allows us to read and write a sequence of bytes from/to
    a file. It operates with raw data such as `byte[]`, `Span<byte>`, or `Memory<byte>`.
    We can obtain a `FileStream` object using static methods of the `File` class or
    non-static methods of the `FileInfo` class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileStream`类允许我们从文件中读取和写入一系列字节。它可以操作原始数据，如`byte[]`、`Span<byte>`或`Memory<byte>`。我们可以使用`File`类的静态方法或`FileInfo`类的非静态方法来获取`FileStream`对象：'
- en: '![](img/Chapter_13_Table_11_01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_11_01.jpg)'
- en: 'We can see how this works using the following example, where we write four
    bytes to the file located at `C:\Temp\data.raw` and then we read the entire content
    of the file and print it to the console:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下示例看到这是如何工作的，我们将四个字节写入到位于`C:\Temp\data.raw`的文件中，然后读取文件的整个内容并将其打印到控制台上：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the first part, we use `File.Create()` to open a file for writing. If the
    file does not exist, then it is created. If the file exists, then its content
    will be overwritten. The `FileStream.Write()` method is used to write the content
    of the byte array to the file. The stream will be flushed to the file and the
    file handle will be closed when the `FileStream` object is disposed of at the
    end of the `using` statement.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，我们使用`File.Create()`打开一个文件进行写入。如果文件不存在，则会创建文件。如果文件存在，则其内容将被覆盖。使用`FileStream.Write()`方法将字节数组的内容写入文件。当`FileStream`对象在`using`语句结束时被处理时，流将被刷新到文件，并关闭文件句柄。
- en: 'In the second part, we use `File.OpenRead()` to open the file that was previously
    written, but this time for reading. We allocate an array large enough to receive
    the entire content of the file and use `FileStream.Read()` to read its content.
    The output of this code is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分中，我们使用`File.OpenRead()`打开先前写入的文件，但这次是用于读取。我们分配了一个足够大的数组来接收文件的整个内容，并使用`FileStream.Read()`来读取其内容。这段代码的输出如下：
- en: '![Figure 13.9 – The content of created binary file displayed to the console'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.9 - 显示在控制台上创建的二进制文件的内容'
- en: '](img/Figure_13.9_B12346.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.9_B12346.jpg)'
- en: Figure 13.9 – The content of created binary file displayed to the console
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 - 显示在控制台上创建的二进制文件的内容
- en: 'Handling raw data can be cumbersome. For this reason, .NET provides stream
    adapters that allow us to handle higher-level data. The first pair of adapters
    is `BinaryReader` and `BinaryWriter`, which provide support for reading and writing
    primitive types and strings in binary format. An example of using these two is
    shown here:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 处理原始数据可能很麻烦。因此，.NET提供了流适配器，允许我们处理更高级别的数据。第一对适配器是`BinaryReader`和`BinaryWriter`，它们提供了对二进制格式中的原始类型和字符串的读取和写入支持。以下是使用这两个适配器的示例：
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We first open a file with `File.Create()` that returns `FileStream`. This stream
    is used as an argument for the constructor of the `BinaryWriter` stream adapter.
    The `Write()` method is overloaded for all the primitive types (`char`, `bool`,
    `sbyte`, `byte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`,
    and `decimal`), as well as for `byte[]`, `char[]`, and `string`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`File.Create()`打开一个文件，返回`FileStream`。这个流被用作`BinaryWriter`流适配器的构造函数的参数。`Write()`方法对所有原始类型（`char`、`bool`、`sbyte`、`byte`、`short`、`ushort`、`int`、`uint`、`long`、`ulong`、`float`、`double`和`decimal`）以及`byte[]`、`char[]`和`string`进行了重载。
- en: Secondly, we reopen the same file, but for reading using `File.OpenRead()`.
    The `FileStream` object returned by this method is used as an argument to the
    constructor of the `BinaryReader` stream adapter. This class has a set of reading
    methods, one for each primitive type, such as `ReadBoolean()`, `ReadChar()`, `ReadInt16()`,
    `ReadInt32()`, `ReadDouble()`, and `ReadDecimal()`, as well as methods for reading
    a `byte[]` – `ReadBytes()`, a `char[]` - `ReadChars()`, and strings—R`eadString()`.
    You can see some of these methods used in the previous example.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们重新打开相同的文件，但这次是用于读取，使用`File.OpenRead()`。这个方法返回的`FileStream`对象被用作`BinaryReader`流适配器的构造函数的参数。该类有一组读取方法，每种原始类型都有一个，比如`ReadBoolean()`、`ReadChar()`、`ReadInt16()`、`ReadInt32()`、`ReadDouble()`和`ReadDecimal()`，以及用于读取`byte[]`的方法
    - `ReadBytes()`，`char[]` - `ReadChars()`，和字符串 - `ReadString()`。你可以在前面的示例中看到其中一些方法的使用。
- en: By default, both `BinaryReader` and `BinaryWriter` handle strings using the
    *UTF-8 encoding*. However, they both have overloaded constructors that allow us
    to specify another encoding using the `System.Text.Encoding` class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`BinaryReader`和`BinaryWriter`都使用*UTF-8编码*处理字符串。但是，它们都有重载的构造函数，允许我们使用`System.Text.Encoding`类指定另一种编码。
- en: 'Although these two adapters can be used for processing strings, using them
    for reading and writing text files can be cumbersome because of a lack of support
    for features such as line handling. To handle text files, the `StreamReader` and
    `StreamWriter` adapters should be used. By default, they process text as UTF-8
    encoded, but their constructors allow us to specify a different encoding. In the
    following example, we write text to a file and then read it back and print it
    to the console:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个适配器可以用于处理字符串，但由于缺乏对诸如行处理之类的功能的支持，因此使用它们来读写文本文件可能会很麻烦。为了处理文本文件，应该使用`StreamReader`和`StreamWriter`适配器。默认情况下，它们将文本处理为UTF-8编码，但它们的构造函数允许我们指定不同的编码。在以下示例中，我们将文本写入文件，然后将其读取并打印到控制台：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `File.CreateText()` method opens a file for writing (either creating or
    overwriting it) and returns an instance of the `StreamWriter` class that uses
    UTF-8 encoding. The `WriteLine()` method writes a string to the file and then
    adds a new line. There are overloaded versions of `WriteLine()` but also overloaded
    `Write()` methods that can write a `char`, `char[]`, or `string` without adding
    a new line after.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`File.CreateText()`方法打开一个文件进行写入（创建或覆盖），并返回一个使用UTF-8编码的`StreamWriter`类的实例。`WriteLine()`方法将字符串写入文件，然后添加一个新行。`WriteLine()`有重载版本，还有重载的`Write()`方法，可以在不添加新行的情况下写入`char`、`char[]`或`string`。'
- en: In the second part, we use the `File.OpenText()` method to open the previously
    written text file for reading. This returns a `StreamReader` object that reads
    UTF-8 text. The `ReadLine()` method is used to read the content line by line in
    a loop until the end of the stream. The `EndOfStream` property is used to check
    whether the current stream position reached the end of the stream.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分中，我们使用`File.OpenText()`方法打开先前写入的文本文件进行读取。这会返回一个读取UTF-8文本的`StreamReader`对象。`ReadLine()`方法用于在循环中逐行读取内容，直到流的末尾。`EndOfStream`属性用于检查当前流位置是否达到流的末尾。
- en: 'Instead of using the `File.OpenText()` method, we could use `File.Open()`,
    which allows us to specify the opening mode, file access, and sharing. We could
    rewrite the reading part shown earlier as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`File.Open()`方法，而不是使用`File.OpenText()`方法，这允许我们指定打开模式、文件访问和共享。我们可以将之前显示的读取部分重写如下：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Sometimes, we need a stream to handle temporary data. Using files can be cumbersome
    and also adds unnecessary overhead to the I/O operations. For this purpose, memory
    streams are the most suitable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要一个流来处理临时数据。使用文件可能很麻烦，也会给I/O操作增加不必要的开销。为此，内存流是最合适的。
- en: Working with memory streams
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内存流
- en: A **memory stream** is a backing store for local memory. Such a stream is useful
    for operations when we need temporary storage for transforming data. Examples
    can include XML serialization or data compression and decompression. We will look
    at these two operations in the upcoming code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存流**是本地内存的后备存储。这样的流在需要临时存储转换数据时非常有用。示例可以包括XML序列化或数据压缩和解压缩。我们将在接下来的代码中看到这两个操作。'
- en: 'The static `Serializer<T>` class shown in the following code contains two methods—`Serialize()`
    and `Deserialize()`. The former takes a `T` object, uses `XmlSerializer` to generate
    an XML representation of it, and returns the XML data as a string. The latter
    takes a string containing XML data and uses `XmlSerializer` to read it and create
    a new object of type `T` from it. Here is the code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码中显示的静态`Serializer<T>`类包含两个方法——`Serialize()`和`Deserialize()`。前者接受一个`T`对象，使用`XmlSerializer`生成其XML表示，并将XML数据作为字符串返回。后者接受包含XML数据的字符串，并使用`XmlSerializer`读取它并从中创建一个新的`T`类型对象。以下是代码：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The memory stream created in the `Serialize()` method is resizable. It is initially
    empty and grows as needed. However, the one created in the `Deserialize()` method
    is non-resizable because it is initialized from an array of bytes. This stream
    is used for read-only purposes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Serialize()`方法中创建的内存流是可调整大小的。它最初是空的，根据需要增长。然而，在`Deserialize()`方法中创建的内存流是不可调整大小的，因为它是从字节数组初始化的。这个流用于只读目的。
- en: The `MemoryStream` class implements the `IDisposable` interface because it derives
    from `Stream`, which implements `IDisposable`. However, `MemoryStream` has no
    resources to dispose of and, therefore, the `Dispose()` method does nothing. Calling
    it explicitly has no effect on the stream. Therefore, it is not necessary to wrap
    a memory stream variable in a `using` statement, as we did in the previous example.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`MemoryStream`类实现了`IDisposable`接口，因为它继承自`Stream`，而`Stream`实现了`IDisposable`。然而，`MemoryStream`没有需要处理的资源，因此`Dispose()`方法什么也不做。显式调用对流没有影响。因此，不需要像前面的例子中那样将内存流变量包装在`using`语句中。'
- en: 'Let''s consider the following implementation of an `Employee` class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个`Employee`类的以下实现：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can serialize and deserialize instances of this class as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式对这个类的实例进行序列化和反序列化：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The result of executing this code is shown in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码的结果显示在以下屏幕截图中：
- en: '![Figure 13.10 – An XML-serialized Employee object displayed to the console'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.10 – 在控制台上显示的XML序列化的Employee对象'
- en: '](img/Figure_13.10_B12346.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.10_B12346.jpg)'
- en: Figure 13.10 – An XML-serialized Employee object displayed to the console
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 – 在控制台上显示的XML序列化的Employee对象
- en: 'The other example we mentioned when a memory stream is handy is in the *compression
    and decompression of data*. The `GZipStream` class from the `System.IO.Compression`
    namespace is a stream decorator that supports compression and decompression of
    streams using the GZip data format specification. A `MemoryStream` object is used
    as a backing store for the `GZipStream` decorator. The static `Compression` class
    shown here provides two methods that compress and decompress an array of bytes:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到的另一个内存流很方便的例子是*数据的压缩和解压缩*。`System.IO.Compression`命名空间中的`GZipStream`类是一个流装饰器，支持使用GZip数据格式规范对流进行压缩和解压缩。`MemoryStream`对象被用作`GZipStream`装饰器的后备存储。这里显示的静态`Compression`类提供了压缩和解压缩字节数组的两个方法：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can use this helper class to compress a string to an array of bytes and
    then decompress it back to a string. Such an example is shown in the following
    code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个辅助类将字符串压缩为字节数组，然后将其解压缩为字符串。以下代码显示了这样一个例子：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output from executing this sample code is shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此示例代码的输出显示在以下屏幕截图中：
- en: '![Figure 13.11 – A screenshot with the result of compressing and decompressing
    a text'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.11 – 一个屏幕截图，显示了压缩和解压文本的结果'
- en: '](img/Figure_13.11_B12346.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.11_B12346.jpg)'
- en: Figure 13.11 – A screenshot with the result of compressing and decompressing
    a text
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 – 一个屏幕截图，显示了压缩和解压文本的结果
- en: In this section, we have seen how to simply serialize and deserialize XML. We
    will elaborate on this topic in the next section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经看到了如何简单地序列化和反序列化XML。我们将在下一节详细介绍这个主题。
- en: Serializing and deserializing XML
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化和反序列化XML
- en: In the previous section, we have seen how we can use the `XmlSerializer` class,
    from the `System.Xml.Serialization` namespace, to serialize and deserialize data.
    This class is handy for serializing objects to XML and deserializing XML to objects.
    Although, in the previous example, we used a memory stream to serialize, it actually
    works with any stream; moreover, it also works with the `TextWriter` and `XmlWriter`
    adapters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们已经看到了如何使用`System.Xml.Serialization`命名空间中的`XmlSerializer`类对数据进行序列化和反序列化。这个类对于将对象序列化为XML和将XML反序列化为对象非常方便。尽管在前面的示例中，我们使用了内存流进行序列化，但它实际上可以与任何流一起使用；此外，它还可以与`TextWriter`和`XmlWriter`适配器一起使用。
- en: 'The following sample shows a modified `Serializer<T>` class, where we specify
    the path of a file where the XML document is to be written to or read from:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个修改后的`Serializer<T>`类，其中我们指定了要将XML文档写入或从中读取的文件的路径：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can use this new implementation as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像下面这样使用这个新的实现：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The result of XML serialization using this code is a document with the following
    content:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码进行XML序列化的结果是具有以下内容的文档：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`XmlSerializer` works by serializing all the public properties and fields of
    a type to XML. It uses some default settings such as types becoming nodes and
    properties and fields becoming elements. The name of a type, property, or field
    becomes the name of the node or element and the value of a field or property its
    text. It also adds default namespaces (which you can see in the preceding code).
    However, it is possible to control the way serialization is performed using attributes
    on types and members. Such an example is shown in the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`XmlSerializer`通过将类型的所有公共属性和字段序列化为XML来工作。它使用一些默认设置，例如类型变为节点，属性和字段变为元素。类型、属性或字段的名称成为节点或元素的名称，字段或属性的值成为其文本。它还添加了默认命名空间（您可以在前面的代码中看到）。但是，可以使用类型和成员上的属性来控制序列化的方式。下面的代码示例中显示了这样一个示例：'
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Serializing an instance of this `Employee` class implementation would produce
    an XML document such as the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个`Employee`类实现的实例进行序列化将产生以下XML文档：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have used several attributes here, `XmlType`, `XmlAttribute`, and `XmlElement`,
    but the list is long. The following table lists the most important XML attributes
    and what they do. These attributes are available in the `System.Xml.Serialization`
    namespace:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了几个属性，`XmlType`、`XmlAttribute`和`XmlElement`，但列表很长。以下表列出了最重要的XML属性及其作用。这些属性位于`System.Xml.Serialization`命名空间中：
- en: '![](img/Chapter_13_Table_12_01.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_12_01.jpg)'
- en: The way the `XmlSerializer` class works is that, at runtime, it generates serialization
    code for each type in a temporary serialization assembly every time the application
    runs. In some cases, this can be a performance issue that can be avoided by generating
    these assemblies in advance. The `Sgen.exe`) can be used to generate these assemblies.
    If your assembly that contains serialization code is called `MyAssembly.dll`,
    the generated serializing assembly will be called `MyAssembly.XmlSerializer.dll`.
    This tool is deployed as part of the Windows SDK.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`XmlSerializer`类的工作方式是，在运行时，每次应用程序运行时，为临时序列化程序集中的每种类型生成序列化代码。在某些情况下，这可能是一个性能问题，可以通过预先生成这些程序集来避免。`Sgen.exe`可以用来生成这些程序集。如果包含序列化代码的程序集称为`MyAssembly.dll`，则生成的序列化程序集将被称为`MyAssembly.XmlSerializer.dll`。该工具作为Windows
    SDK的一部分部署。'
- en: You can also generate an XML schema (an XSD document) from classes or classes
    from an existing XML schema using the `xsd.exe`). This tool is distributed as
    part of the Windows SDK or with Visual Studio.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`xsd.exe`从类生成XML模式（XSD文档）或从现有XML模式生成类。该工具作为Windows SDK的一部分或与Visual Studio一起分发。
- en: 'A possible issue with `XmlSerializer` is that it serializes a single .NET object
    to an XML document (of course, the object can be complex and contain other objects
    and arrays of objects). If you have two separate objects that you want to write
    to the same document, it does not work properly. Let''s imagine that we also have
    the following class, representing a department in a company:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`XmlSerializer`可能存在的问题是，它将单个.NET对象序列化为XML文档（当然，该对象可以是复杂的，并包含其他对象和对象数组）。如果您有两个要写入同一文档的单独对象，则无法正常工作。假设我们还有以下类，表示公司中的一个部门：'
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We might want to write an XML document containing an employee and a department.
    Using `XmlSerializer` will not work properly. This is shown in the following example:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望编写一个包含员工和部门的XML文档。使用`XmlSerializer`将无法正常工作。这在以下示例中显示：
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We could try to use the following code for serializing an employee and a department
    to the same XML document:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用以下代码将员工和部门序列化到同一个XML文档中：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The XML document that is generated to the disk file will have the content shown
    in the following code. This is not valid XML because it has multiple document
    declarations and does not have a single root element:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 生成到磁盘文件的XML文档将具有以下代码中显示的内容。这不是有效的XML，因为它具有多个文档声明，并且没有单个根元素：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To make it work, we''d have to create an additional type that would contain
    an employee and a department, and we would have to serialize an instance of this
    type. This extra object will be serialized as the root element of the XML document.
    We will demonstrate this with the following example (notice that we have an extra
    property called `Version` here):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其工作，我们必须创建一个额外的类型，该类型将包含一个员工和一个部门，并且我们必须序列化此类型的实例。此额外对象将作为XML文档的根元素进行序列化。我们将通过以下示例进行演示（请注意，这里有一个额外的名为`Version`的属性）：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This time, the output is a well-formed XML document that is listed in the following
    code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，输出是一个格式良好的XML文档，列在以下代码中：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To allow further control for reading and writing XML, the .NET base class library
    contains two classes called `XmlReader` and `XmlWriter` that provide a fast, non-cached,
    forward-only way to read or generate XML data from or to a stream or file.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步控制读取和写入XML，.NET基类库包含两个名为`XmlReader`和`XmlWriter`的类，它们提供了一种快速、非缓存、仅向前的方式来从流或文件读取或生成XML数据。
- en: 'The `XmlWriter` class can be used to write XML data to a stream, file, text
    reader, or string. It provides features such as the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`XmlWriter`类可用于将XML数据写入流、文件、文本读取器或字符串。它提供了以下功能：'
- en: Validating characters and XML names
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证字符和XML名称
- en: Verifying that an XML document is well-formed
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证XML文档是否格式良好
- en: Support for CLR types so that you don't need to manually convert everything
    to a string
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持CLR类型，这样您就不需要手动将所有内容转换为字符串
- en: Base64 and BaseHex encoding for binary data to be written in the XML document
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在XML文档中写入二进制数据的Base64和BaseHex编码
- en: 'The `XmlWriter` class contains many methods; some of these methods are listed
    in the following table. Although this list only includes the synchronous method,
    all of them have asynchronous companions such as `WriteElementStringAsync()` for
    `WriteElementString()`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`XmlWriter`类包含许多方法；其中一些方法列在下表中。尽管此列表仅包括同步方法，但它们都有异步伴侣，比如`WriteElementStringAsync()`对应于`WriteElementString()`：'
- en: '![](img/Chapter_13_Table_13_01.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_13_01.jpg)'
- en: While using `XmlWriter`, it is possible to specify various settings such as
    encoding, indentation, how attributes should be written (on a new or the same
    line), omitting the XML declaration, and others. These settings are controlled
    using an instance of the `XmlWriterSettings` class.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`XmlWriter`时，可以指定各种设置，如编码、缩进、属性应该如何写入（在新行上还是同一行上）、省略XML声明等。这些设置由`XmlWriterSettings`类控制。
- en: 'The following listing shows an example of using `XmlWriter` to create an XML
    document that contains an employee and a department as a part of a root element
    called `Data`. In fact, the result is the same as from the previous example, except
    that no namespaces are created:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单显示了使用`XmlWriter`创建包含员工和部门的XML文档的示例，作为名为`Data`的根元素的一部分。实际上，结果与前一个示例相同，只是没有创建命名空间：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this example, we have used the following components:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了以下组件：
- en: An instance of `XmlWriterSettings` to set encoding to UTF-8 and enable indentation
    of the output.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlWriterSettings`的一个实例，用于将编码设置为UTF-8并启用输出的缩进。'
- en: '`XmlWriter.Create()` to create an instance of an implementation of the `XmlWriter`
    class.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlWriter.Create()`用于创建`XmlWriter`类的实现的实例。'
- en: Various methods of the `XmlWriter` class to write XML data.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlWriter`类的各种方法来写入XML数据。'
- en: An instance of `XmlSerializerNamespaces` to control the generated namespaces.
    In this example, we added an empty scheme and namespace, which results in no namespaces
    written to the XML document.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlSerializerNamespaces`的实例，用于控制生成的命名空间。在这个例子中，我们添加了一个空的方案和命名空间，这导致XML文档中没有命名空间。'
- en: Instances of the `XmlSerializer` class to simplify the serialization of the
    `Employee` and `Department` objects to the XML document. This is possible because
    the `Serialize()` method can take an `XmlWriter` as a destination for the XML
    document it generates.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlSerializer`类的实例，用于简化`Employee`和`Department`对象到XML文档的序列化。这是可能的，因为`Serialize()`方法可以将`XmlWriter`作为生成的XML文档的目的地。'
- en: The companion class for `XmlWriter` is `XmlReader`. This class allows us to
    move through XML data and read its content but in a forward-only manner, which
    means you cannot go back from a given point. The `XmlReader` class is an abstract
    one, just like `XmlWriter`, and there are concrete implementations such as `XmlTextReader`,
    `XmlNodeReader`, or `XmlValidatingReader`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`XmlWriter`的伴侣类是`XmlReader`。这个类允许我们在XML数据中移动并读取其内容，但是以一种只能向前的方式，这意味着您不能从给定点返回。`XmlReader`类是一个抽象类，就像`XmlWriter`一样，有具体的实现，比如`XmlTextReader`、`XmlNodeReader`或`XmlValidatingReader`。'
- en: 'However, for most scenarios, you should use `XmlReader`n. To create an instance
    of it, use the static `XmlReader.Create()` method. The class contains a long list
    of methods and properties, a few of them listed in the following table. Just like
    in the case of `XmlWriter`, `XmlReader` has both synchronous and asynchronous
    methods. Only some from the first category are listed here:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于大多数情况，您应该使用`XmlReader`。要创建它的实例，请使用静态的`XmlReader.Create()`方法。该类包含一长串的方法和属性，以下表格列出了其中的一些。就像在`XmlWriter`的情况下一样，`XmlReader`也有同步和异步方法。这里只列出了一些同步方法：
- en: '![](img/Chapter_13_Table_14_01.jpg)![](img/Chapter_13_Table_14_02.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_14_01.jpg)![](img/Chapter_13_Table_14_02.jpg)'
- en: When creating an instance of `XmlReader`, you can specify a set of features
    that you want to enable, such as schemas that should be used to perform validation,
    ignoring comments or white spaces, validation of type assignment, and others.
    The `XmlReaderSettings` class is used for this purpose.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`XmlReader`的实例时，您可以指定要启用的一组功能，例如应使用的模式、忽略注释或空格、类型分配的验证等。`XmlReaderSettings`类用于此目的。
- en: 'In the following example, we use `XmlReader` to read the content of the XML
    document written earlier and display a representation of its content to the console:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们使用`XmlReader`来读取先前写入的XML文档的内容，并在控制台上显示其内容的表示：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of executing this code is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码的输出如下：
- en: '![Figure 13.12 – A screenshot with the content of the XML document read from
    disk and displayed on the console'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.12 - 从磁盘读取的XML文档内容的屏幕截图并显示在控制台上'
- en: '](img/Figure_13.12_B12346.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_13.12_B12346.jpg)'
- en: Figure 13.12 – A screenshot with the content of the XML document read from disk
    and displayed on the console
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.12 - 从磁盘读取的XML文档内容的屏幕截图并显示在控制台上
- en: 'Here are several key points from this sample:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此示例的几个关键点：
- en: We created an instance of `XmlReaderSettings` to tell `XmlReader` to ignore
    comments and white spaces.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个`XmlReaderSettings`的实例，告诉`XmlReader`忽略注释和空格。
- en: We used `XmlReader.Create()` to create a new instance of an implementation of
    `XmlReader` that reads XML data from a file with the specified path..
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`XmlReader.Create()`创建了一个新的`XmlReader`实现的实例，用于从指定路径的文件中读取XML数据。
- en: The `Read()` method is used in a loop to read the XML document node by node.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Read()`方法用于循环读取XML文档的每个节点。'
- en: We use properties such as `NodeType`, `Name`, and `Value` to check the type
    of each node, its name, and its value.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用属性，如`NodeType`，`Name`和`Value`来检查每个节点的类型，名称和值。
- en: There are many details concerning handling XML data with `XmlReader` and `XmlWriter`,
    as well as serialization using `XmlSerializer`. Discussing all these here would
    take too much time. We recommend that you use additional resources, such as the
    official documentation, to learn more about these classes.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用`XmlReader`和`XmlWriter`处理XML数据以及使用`XmlSerializer`进行序列化的许多细节。在这里讨论所有这些内容将花费太多时间。我们建议您使用其他资源，如官方文档，来了解更多关于这些类的信息。
- en: Now that we have seen how to handle XML data, let's look at JSON.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何处理XML数据，让我们来看看JSON。
- en: Serializing and deserializing JSON
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化和反序列化JSON
- en: In recent times, **JavaScript Object Notation (JSON)** has become the de facto
    standard for data serialization, not only for web and mobile but also for desktop.
    .NET did not provide a proper library for serializing and deserializing JSON;
    therefore, developers have resorted to third-party libraries. One of these libraries
    is **Json.NET** (also known as **Newtonsoft.Json**, after its creator, Newton-King).
    This has become the preferred library for most .NET developers and a dependency
    of ASP.NET Core. However, with the release of .NET Core 3.0, Microsoft is providing
    its own JSON serializer, known as **System.Text.Json**, after the namespace where
    it is available. In this last part of this chapter, we will look at these two
    libraries and see some of their capabilities and how they compare to each other.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，**JavaScript对象表示法（JSON）**已成为数据序列化的事实标准，不仅用于Web和移动端，也用于桌面端。.NET没有提供适当的库来序列化和反序列化JSON；因此，开发人员转而使用第三方库。其中一个库是**Json.NET**（也称为**Newtonsoft.Json**，以其创建者Newton-King命名）。这已成为大多数.NET开发人员的首选库，并且是ASP.NET
    Core的依赖项。然而，随着.NET Core 3.0的发布，微软提供了自己的JSON序列化器，称为**System.Text.Json**，根据其可用的命名空间命名。在本章的最后部分，我们将看看这两个库，并了解它们的一些功能以及它们之间的比较。
- en: Using Json.NET
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Json.NET
- en: 'Json.NET is currently the most widely used .NET library for JSON serialization
    and deserialization. It''s a high-performance, easy-to-use, open source library,
    available as a NuGet package called **Newtonsoft.Json**. This is, in fact, by
    far, the most downloaded package on NuGet. Some of the features it provides are
    listed here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Json.NET目前是最广泛使用的.NET库，用于JSON序列化和反序列化。它是一个高性能、易于使用的开源库，可作为名为**Newtonsoft.Json**的NuGet包使用。事实上，这是迄今为止在NuGet上下载量最大的包。它提供的一些功能列在这里：
- en: Simple APIs for most common serialization and deserialization scenarios with
    `JsonConvert`, which is a wrapper over `JsonSerializer`.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数常见序列化和反序列化场景的简单API，使用`JsonConvert`，它是`JsonSerializer`的包装器。
- en: More fine-grained control over the serialization/deserialization process with
    `JsonSerializer`. This class can write text to or read text from a stream, directly
    via `JsonTextWriter` and `JsonTextReader`.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`JsonSerializer`对序列化/反序列化过程进行更精细的控制。该类可以通过`JsonTextWriter`和`JsonTextReader`直接向流中写入文本或从流中读取文本。
- en: The possibility to create, modify, parse, and query JSON using `JObject`, `JArray`,
    and `JValue`.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`JObject`，`JArray`和`JValue`创建，修改，解析和查询JSON的可能性。
- en: The possibility to convert between XML and JSON.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在XML和JSON之间进行转换的可能性。
- en: The possibility to query JSON with JSON Path, an XPath-like query language.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON Path查询JSON的可能性，这是一种类似于XPath的查询语言。
- en: Validation of JSON with JSON Schema.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JSON模式验证JSON。
- en: Support for `BsonReader` and `BsonWriter`. This is a binary-encoded serialization
    of JSON-like documents.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持`BsonReader`和`BsonWriter`。这是一种类似于JSON的文档的二进制编码序列化。
- en: 'In this section, we will explore several common serialization and deserialization
    scenarios using Json.NET. For this purpose, we will use the following implementation
    of an `Employee` class:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用以下`Employee`类的实现来探索几种常见的序列化和反序列化场景：
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Although the library is rich in functionalities, covering them all here is beyond
    the scope of this book. We recommend reading the online documentation for Json.NET
    that'[s available at https://www.newt](https://www.newtonsoft.com/json)onsoft.com/json.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管该库功能丰富，但在这里涵盖所有功能超出了本书的范围。我们建议阅读Json.NET的在线文档，网址为https://www.newt](https://www.newtonsoft.com/json)onsoft.com/json。
- en: 'Getting a string that contains the JSON serialization of an `Employee` object
    is straightforward, as shown in the following example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 获取包含`Employee`对象的JSON序列化的字符串非常简单，如下例所示：
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'By default, `JsonConvert.SerializeObject()` will produce minified JSON, which
    does not contain indentation and white spaces. The result of the preceding code
    is the following JSON:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`JsonConvert.SerializeObject()`将生成缩小的JSON，不包含缩进和空格。上述代码的结果是以下JSON：
- en: '[PRE37]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Although this is suitable for transferring data over a network, such as when
    communicating with a web service, because the size is smaller, it''s harder to
    read by a human. If you want the JSON document to be readable, you should use
    indentation. This can be specified by providing formatting options, available
    with the `Formatting` enumeration. An example of this is shown here:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这适用于在网络上传输数据，比如与web服务通信时，因为大小较小，它更难以被人类阅读。如果您希望JSON文档可读性强，应该使用缩进。这可以通过提供格式选项来指定，该选项可用于`Formatting`枚举。这里显示了一个示例：
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This time, the result is the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，结果如下：
- en: '[PRE39]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Indentation is not the only serialization option we can specify. In fact, there
    are many options you can set using the `JsonSerializerSettings` class, which can
    be provided as an argument to the `SerializeObject()` method. For instance, we
    might want to skip serializing properties or fields of reference, or nullable
    types that are set to `null`. Examples include `HireDate` and `Telephones`, which
    are of the `DateTime?` and `List<string>` types, respectively. This can be done
    as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进不是我们可以指定的唯一序列化选项。实际上，您可以使用`JsonSerializerSettings`类设置许多选项，该类可以作为`SerializeObject()`方法的参数提供。例如，我们可能希望跳过序列化引用的属性或字段，或者将设置为`null`的可空类型。例如，`HireDate`和`Telephones`分别是`DateTime?`和`List<string>`类型。可以按以下方式完成：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The result of serializing the `employee` object we used in the previous examples
    is shown in the following listing. You will notice that `HireDate` and `Telephones`
    are no longer present in the resulting JSON:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用的`employee`对象序列化的结果如下所示。您会注意到`HireDate`和`Telephones`不再出现在生成的JSON中：
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Another option that can be specified for serialization controls how default
    values are handled. `DefaultValueHandling` is an enumeration that specifies how
    members with default values should be serialized or deserialized. By specifying
    `Ignore`, you enable the serializer to skip from the output the members whose
    value is the same as their type''s default value (`0` for numeric types, `false`
    for `bool`, and `null` for reference and nullable types). The default value that
    is ignored can actually be changed with the use of an attribute, called `DefaultValueAttribute`,
    being specified on the member. Let''s consider the following example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为序列化指定的另一个选项控制默认值的处理方式。`DefaultValueHandling`是一个枚举，指定了默认值的成员应该如何被序列化或反序列化。通过指定`Ignore`，您可以使序列化器跳过输出中值与其类型的默认值相同的成员（对于数字类型为`0`，对于`bool`为`false`，对于引用和可空类型为`null`）。实际上可以使用一个名为`DefaultValueAttribute`的属性来更改被忽略的默认值，该属性被指定在成员上。让我们考虑以下示例：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This time, the resulting JSON is even simpler, as shown in the following listing.
    This is because the `IsOnLeave` and `Status` properties are set to their default
    value, which is `false` and `EmployeeStatus.Active`, respectively:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，生成的JSON更加简单，如下所示。这是因为`IsOnLeave`和`Status`属性分别设置为它们的默认值，即`false`和`EmployeeStatus.Active`：
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We mentioned earlier the attribute called `DefaultValueAttribute`. You may
    have noticed a couple of other attributes, `JsonIgnoreAttribute` and `JsonConverterAttribute`,
    being used in the declaration of the `Employee` class. The serialization can be
    controlled with attributes, and the library supports both standard .NET serialization
    attributes (such as `SerializableAttribute`, `DataContractAttribute`, `DataMemberAttribute`,
    and `NonSerializedAttributes`) and built-in Json.NET attributes. When both are
    present, the built-in Json.NET attributes take precedence over the others. The
    built-in Json.NET attributes are shown in the following table:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到了一个叫做`DefaultValueAttribute`的属性。您可能已经注意到在`Employee`类的声明中使用了另外两个属性，`JsonIgnoreAttribute`和`JsonConverterAttribute`。序列化可以通过属性进行控制，该库支持标准的.NET序列化属性（如`SerializableAttribute`、`DataContractAttribute`、`DataMemberAttribute`和`NonSerializedAttributes`）和内置的Json.NET属性。当两者同时存在时，内置的Json.NET属性优先于其他属性。内置的Json.NET属性如下表所示：
- en: '![](img/Chapter_13_Table_15_01.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_15_01.jpg)'
- en: Of these attributes, we have used `JsonIgnoreAttribute` to indicate that the
    `LastModified` property of the `Employee` class should not be serialized and `JsonConverterAttribute`
    to indicate that the `Status` property should be serialized using the `StringEnumConverter`
    class. The result is that this property will be serialized as a string (with the
    values `Active` or `Inactive`) and not as a number (with the values `0` or `1`).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些属性中，我们使用了`JsonIgnoreAttribute`来指示`Employee`类的`LastModified`属性不应该被序列化，并使用了`JsonConverterAttribute`来指示`Status`属性应该使用`StringEnumConverter`类进行序列化。结果是该属性将被序列化为一个字符串（值为`Active`或`Inactive`），而不是一个数字（值为`0`或`1`）。
- en: 'The `JsonConvert.SerializeObject()` method returns a string. It is possible
    to serialize and deserialize using streams, such as a file or a memory stream.
    To do so, however, we must use the `JsonSerializer` class. This class has overloaded
    methods called `Serialize()` and `Deserialize()`, as well as a series of properties
    that allow us to customize the serialization. The following example shows how
    we can use the class to serialize the employee object we used so far to a text
    file on disk:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`JsonConvert.SerializeObject()`方法返回一个字符串。可以使用流（如文件或内存流）进行序列化和反序列化。但是，为此我们必须使用`JsonSerializer`类。该类具有重载的`Serialize()`和`Deserialize()`方法，以及一系列属性，允许我们自定义序列化。以下示例显示了如何使用该类将迄今为止使用的员工对象序列化到磁盘上的文本文件中：'
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We specified that we want to use indentation and skip the members that are
    `null` or have a value that is the type''s default value. The result of serialization
    is a text file with the following content:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了我们想要使用缩进并跳过`null`或具有类型默认值的成员。序列化的结果是一个文本文件，内容如下：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The opposite process of deserialization is also straightforward. Using `JsonSerializer`,
    we can read from the text file we created earlier. For this purpose, we use `JsonTextReader`,
    which is a companion class for `JsonTextWriter`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化的相反过程也是直接的。使用`JsonSerializer`，我们可以从之前创建的文本文件中读取。为此，我们使用`JsonTextReader`，这是`JsonTextWriter`的伴侣类：
- en: '[PRE46]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Deserialization from a string is also possible and straightforward using the
    `JsonConvert` class. The overloaded `DeserializeObject()` method is used for this
    purpose, as shown here:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 从字符串反序列化也是可能且直接的，使用`JsonConvert`类。为此目的使用了重载的`DeserializeObject()`方法，如下所示：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Although widely used, the Json.NET library has some drawbacks:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管被广泛使用，Json.NET库也有一些缺点：
- en: The .NET `string` type uses UTF-16 encoding, yet most network protocols, including
    HTTP, use UTF-8\. Json.NET converts between these two, which affects performance.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET的`string`类型使用UTF-16编码，然而大多数网络协议，包括HTTP，使用UTF-8。Json.NET在这两者之间进行转换，这会影响性能。
- en: As a third-party library, and not a component of the Base Class Library (or
    the Foundation Class Library), you may have projects with dependencies on different
    versions. ASP.NET Core used Json.NET as a dependency, which sometimes leads to
    version conflicts.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为第三方库，而不是基类库（或基础类库）的组件，您可能有依赖于不同版本的项目。ASP.NET Core使用Json.NET作为依赖项，这有时会导致版本冲突。
- en: It does not leverage new .NET types such as `Span<T>`, which are designed to
    increase performance in some scenarios, such as when parsing text.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有利用新的.NET类型，比如`Span<T>`，这些类型旨在增加某些情况下的性能，比如解析文本时。
- en: To overcome these issues, Microsoft has provided its own implementation of a
    JSON serializer, which we will look at in the following section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，微软提供了自己的JSON序列化程序的实现，我们将在下一节中看到。
- en: Using System.Text.Json
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用System.Text.Json
- en: This is the new JSON serializer shipped with .NET Core. It replaces Json.NET
    in ASP.NET Core, for which an integration package is now available. If you are
    targeting .NET Framework or .NET Standard, you can still use **System.Text.Json**,
    which is available as a NuGet package, also called **System.Text.Json**.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是.NET Core随附的新JSON序列化程序。它取代了ASP.NET Core中的Json.NET，现在提供了一个集成包。如果您的目标是.NET Framework或.NET
    Standard，您仍然可以使用**System.Text.Json**，它作为一个NuGet包可用，也称为**System.Text.Json**。
- en: 'The new serializer performs better than Json.NET mainly for two reasons: it
    uses `Span<T>` and UTF-8 natively (therefore avoiding transcoding between UTF-8
    and UTF-16). According to Microsoft, this serializer offers speed-ups of 1.3x
    to 5x over Json.NET, depending on the scenario.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 新的序列化程序的性能优于Json.NET，主要有两个原因：它使用`Span<T>`和UTF-8本地化（因此避免了UTF-8和UTF-16之间的转码）。根据微软的说法，这个序列化程序在不同情况下可以提供1.3倍到5倍的加速。
- en: 'However, the APIs were inspired by Json.NET and the transition from Json.NET
    is seamless for simple scenarios, like the ones we saw in the previous section
    of this chapter. The following example shows how we can serialize an `Employee`
    object into a `string`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些API受到了Json.NET的启发，对于简单的情况，如我们在本章的前一节中看到的情况，从Json.NET过渡是无缝的。以下示例显示了如何将`Employee`对象序列化为`string`：
- en: '[PRE48]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This looks very similar to Json.NET and it also produces minified JSON, which
    you can see in the following code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与Json.NET非常相似，它也生成了压缩的JSON，您可以在以下代码中看到：
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'However, serialization can be customized by providing various options, such
    as indentation, handling of null values, naming policy, trailing commas, ignoring
    read-only properties, and others. Such options are provided with the `JsonSerializerOptions`
    class. An example with indentation and skipping null values is shown here:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可以通过提供各种选项来自定义序列化，例如缩进、处理空值、命名策略、尾随逗号、忽略只读属性等。这些选项由`JsonSerializerOptions`类提供。这里展示了一个缩进和跳过空值的示例：
- en: '[PRE50]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output, in this case, is as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，输出如下：
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The implementation of the `Employee` class used in these examples is almost
    identical to the one from the previous section. Let''s take a look at the following
    code and try to spot the difference:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中使用的`Employee`类的实现几乎与上一节中的实现相同。让我们看一下以下代码，试着找出区别：
- en: '[PRE52]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We again used the `JsonIgnoreAttribute` and `JsonConverterAttribute` attributes
    to specify that the `LastModified` property should be skipped and that the `Status`
    property should be serialized as a string and not a number. The only difference
    is the type of converter that we used here, which is called `JsonStringEnumConverter`
    (while with Json.NET it was called `StringEnumConverter`). However, these are
    not the `System.Text.Json.Serialization` namespace. These attributes are listed
    in the following table:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用了`JsonIgnoreAttribute`和`JsonConverterAttribute`属性，指定`LastModified`属性应该被跳过，`Status`属性应该被序列化为字符串而不是数字。唯一的区别是我们在这里使用的转换器类型，称为`JsonStringEnumConverter`（而在Json.NET中称为`StringEnumConverter`）。然而，这些都不是`System.Text.Json.Serialization`命名空间。这些属性列在下表中：
- en: '![](img/Chapter_13_Table_16_01.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_13_Table_16_01.jpg)'
- en: From this table, we can see that the **System.Text.Json** serializer does not
    support serializing and deserializing fields, which is something Json.NET does.
    If this is something that you need, you must either change the field to a property,
    provide a property for the field, or resort to a serializer that supports fields.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个表中，我们可以看到**System.Text.Json**序列化程序不支持序列化和反序列化字段，这是Json.NET支持的功能。如果这是您需要的功能，您必须将字段更改为属性，为字段提供属性，或者使用支持字段的序列化程序。
- en: 'If you want more control over what is written or read, you can use the `Utf8JsonWriter`
    and `Utf8JsonReader` classes. These provide high-performance APIs for forward-only,
    no-cached, writing, or read-only reading of UTF-8 encoded JSON text. In the following
    example, we will use `Utf8JsonWriter` to write a JSON document to a file on disk
    containing an employee:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想对写入或读取的内容有更多控制，可以使用`Utf8JsonWriter`和`Utf8JsonReader`类。这些类提供了高性能的API，用于仅向前、无缓存的写入或只读读取UTF-8编码的JSON文本。在下面的示例中，我们将使用`Utf8JsonWriter`将JSON文档写入到磁盘上的文件中，其中包含一个员工：
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The result of executing this code is a text file with the following content:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码的结果是一个文本文件，内容如下：
- en: '[PRE54]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To read the JSON document generated here, we can use `Utf8JsonReader`. However,
    this reader does not work with streams but with views of raw data in the form
    of `ReadOnlySpan<byte>` or `ReadOnlySequence<byte>`. This reader allows us to
    read the data token by token and process it accordingly. An example is shown in
    the following snippet:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取此处生成的JSON文档，我们可以使用`Utf8JsonReader`。但是，这个阅读器不适用于流，而是适用于原始数据的视图，以`ReadOnlySpan<byte>`或`ReadOnlySequence<byte>`的形式。这个阅读器允许我们逐个令牌地读取数据并相应地处理它。下面的代码段中显示了一个示例：
- en: '[PRE55]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The output of executing this code is as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码的输出如下：
- en: '[PRE56]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The **System.Text.Json** serializer is more complex than what the examples here
    may show. We recommend that you read the online documentation to better familiarize
    yourself with its APIs.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**System.Text.Json**序列化器比这里的示例所展示的要复杂。我们建议您阅读在线文档，以更好地熟悉其API。'
- en: '**Json.NET** and **System.Text.Json** are not the only JSON serializers for
    .NET, nor the most performant. If JSON performance is key for your application,
    you might want to use either **Utf8Json** (available [at https://github.com/neuecc/Utf8](https://github.com/neuecc/Utf8Json)Json)
    or **Jil** (available [at https://github.com/kevin-montrose](https://github.com/kevin-montrose/Jil)/Jil),
    which outperform both serializers that we looked at in this chapter.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**Json.NET**和**System.Text.Json**并不是.NET中唯一的JSON序列化器，也不是性能最好的。如果JSON性能对您的应用程序很重要，您可能希望使用**Utf8Json**（可在[https://github.com/neuecc/Utf8](https://github.com/neuecc/Utf8Json)Json）或**Jil**（可在[https://github.com/kevin-montrose](https://github.com/kevin-montrose/Jil)/Jil）这两个序列化器，它们的性能优于本章中介绍的两个序列化器。'
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter with an overview of the `System.IO` namespace and looked
    at the capabilities it provides for working with the filesystem. We then learned
    about handling paths and filesystem objects. We saw how we can create, edit, move,
    delete, or enumerate files and directories.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`System.IO`命名空间的概述开始本章，并了解了它为处理文件系统提供的功能。然后我们学习了处理路径和文件系统对象。我们看到了如何创建、编辑、移动、删除或枚举文件和目录。
- en: We have also seen how to read and write data from and to disk files with the
    help of streams. We looked at different kinds of streams and learned about writing
    and reading to and from file and memory streams using different stream adapters.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何使用流从磁盘文件读取和写入数据。我们研究了不同类型的流，并学习了如何使用不同的流适配器向文件和内存流写入和读取数据。
- en: In the last part of this chapter, we looked at data serialization and learned
    how to serialize and deserialize XML and JSON. For the latter, we explored the
    Json.NET serializer, which is the most popular .NET library for JSON, and `System.Text.Json`,
    the new .NET library for JSON.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们学习了数据序列化，学会了如何序列化和反序列化XML和JSON。对于后者，我们探讨了Json.NET序列化器，这是最流行的.NET
    JSON库，以及`System.Text.Json`，这是新的.NET JSON库。
- en: In the next chapter, we will address a different topic called error handling.
    You will learn about error codes and exceptions and what best practices for handling
    errors are.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一个名为错误处理的不同主题。您将学习有关错误代码和异常以及处理错误的最佳实践。
- en: Test what you learned
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你所学到的知识
- en: What are the most important classes in the `System.IO` namespace for working
    with filesystem objects?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`System.IO`命名空间中用于处理文件系统对象的最重要的类是什么？'
- en: What is the recommended method for concatenating paths?
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是连接路径的推荐方法？
- en: How can you retrieve the path for the temporary folder of the current user?
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何获取当前用户临时文件夹的路径？
- en: What is the difference between the `File` and `FileInfo` classes? What about
    the difference between `Directory` and `DirectoryInfo`?
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`File`和`FileInfo`类之间有什么区别？`Directory`和`DirectoryInfo`之间的区别呢？'
- en: What methods can you use to create directories? What about enumerating directories?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用哪些方法来创建目录？枚举目录呢？
- en: What are the three categories of streams in .NET?
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET中流的三个类别是什么？
- en: What is the base class for the stream classes in .NET and what functionalities
    does it provide?
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET中流类的基类是什么，它提供了哪些功能？
- en: What encoding do `BinaryReader` and `BinaryWriter` assume by default for strings?
    How can this be changed?
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BinaryReader`和`BinaryWriter`默认假定使用什么编码来处理字符串？如何更改这个设置？'
- en: How do you serialize objects of the `T` type to XML?
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将`T`类型的对象序列化为XML？
- en: What is the JSON serializer shipped with .NET Core and how do you use it to
    serialize objects of a `T` type?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Core附带的JSON序列化器是什么，如何使用它来序列化`T`类型的对象？
