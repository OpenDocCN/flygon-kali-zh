- en: Operators, Expressions, and Statements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符、表达式和语句
- en: In this chapter, the three core elements of Java programming—operators, expressions,
    and statements—will be defined and explained in detail. The discussion will be
    supported by specific examples that illustrate the key aspects of these elements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将详细定义和解释Java编程的三个核心元素-运算符、表达式和语句。讨论将通过具体示例来支持，以说明这些元素的关键方面。
- en: 'The following topics will be covered:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 将涵盖以下主题：
- en: What are the core elements of Java programming?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java编程的核心元素是什么？
- en: Java operators, expressions, and statements
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java运算符、表达式和语句
- en: Operator precedence and evaluation order of operands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符优先级和操作数的求值顺序
- en: Widening and narrowing the conversion of primitive types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型的扩展和缩小转换
- en: Boxing and unboxing between primitive and reference types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型和引用类型之间的装箱和拆箱
- en: The `equals()` method of reference types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型的equals()方法
- en: Exercise – Naming the statements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-命名语句
- en: What are the core elements of Java programming?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java编程的核心元素是什么？
- en: In [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java Language Basics*,
    we had an overview of many aspects of Java as a language, and even defined what
    statements are. Now, we will look closer into the core elements of Java more systematically.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中，*Java语言基础*，我们概述了Java作为一种语言的许多方面，甚至定义了语句是什么。现在，我们将更系统地研究Java的核心元素。
- en: 'The word "elements" is quite overloaded (playing on the analogy with method
    overload). In [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language
    Elements and Types*, we introduced input elements, those that are identified by
    the Java specification: whitespace, comment, and token. That is how the Java compiler
    parses the source code and makes sense of it. The list of tokens includes identifiers,
    keywords, separators, literals, and operators. That is how the Java compiler adds
    more meaning to the tokens it encounters.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “元素”这个词有点过载（玩弄方法重载的类比）。在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中，*Java语言元素和类型*，我们介绍了输入元素，这些元素是由Java规范标识的：空格、注释和标记。这就是Java编译器解析源代码并理解其含义的方式。标记列表包括标识符、关键字、分隔符、文字和运算符。这就是Java编译器如何为其遇到的标记添加更多含义。
- en: While discussing the input elements, we explained that they are used to build
    more complex elements of language. In this chapter, we will start with the operator token and
    show how an expression—a more complex Java element—is constructed with it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论输入元素时，我们解释了它们用于构建语言的更复杂元素。在本章中，我们将从运算符标记开始，展示如何使用表达式-更复杂的Java元素来构建它。
- en: But, not all Java operators are tokens. The `instanceof` and `new` operators are
    keywords, while the `.` operator (field access or method invocation), the `::` method
    reference operator, and the `( type )` cast operator are separators.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非所有Java运算符都是标记。`instanceof`和`new`运算符是关键字，而`.`运算符（字段访问或方法调用）、`::`方法引用运算符和`(
    type )`强制转换运算符是分隔符。
- en: As we said in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*, a statement in Java plays a role similar to a sentence in the
    English language, which expresses a complete thought.  In a programming language,
    a statement is a complete line of code that performs some action.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中所说的，*Java语言基础*，在Java中，语句的作用类似于英语中的句子，它表达了一个完整的思想。在编程语言中，语句是一行完整的代码，执行某些操作。
- en: An expression, on the other hand, is a part of a statement that evaluates to
    a value. Every expression can be a statement (if the resulting value is ignored),
    while most statements do not include expressions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，表达式是语句的一部分，它求值为一个值。每个表达式都可以是一个语句（如果结果值被忽略），而大多数语句不包括表达式。
- en: That is how the three core elements of Java—operator, expression, and statement—are
    related.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Java的三个核心元素-运算符、表达式和语句的关系。
- en: Operators
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: 'Here is the list of all 44 operators in Java:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Java中所有44个运算符的列表：
- en: '| **Operators** | **Description** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '**运算符** **描述**'
- en: '| `+`, `-`, `*`, `/`, `%` | Arithmetic unary and binary operators |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: 算术一元和二元运算符
- en: '| `++`, `--` | Increment and decrement unary operators |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: 递增和递减一元运算符
- en: '| `==`, `!=` | Equality operators |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: 相等运算符
- en: '| `<`, `>`, `<=`, `>=` | Relational operators |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: 关系运算符
- en: '| `!`, `&`, `&#124;` | Logical operators |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: 逻辑运算符
- en: '| `&&`, `&#124;&#124;`, `?`, `:` | Conditional operators |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: 条件运算符
- en: '| `=`, `+=`, `-=`, `*=`, `/=`, `%=` | Assignment operators |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: 赋值运算符
- en: '| `&=`, `&#124;=`, `^=`, `<<=`, `>>=`, `>>>=` | Assignment operators |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: 赋值运算符
- en: '| `&`, `&#124;`, `~`, `^`, `<<`, `>>`, `>>>` | Bitwise operators |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: 按位运算符
- en: '| `->`, `::` | Arrow and method reference operators |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: 箭头和方法引用运算符
- en: '| `new` | Instance creation operator |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: 实例创建运算符
- en: '| `.` | Field access/method invocation operator |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: 字段访问/方法调用运算符
- en: '| `instanceof` | Type comparison operator |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: 类型比较运算符
- en: '| `( target type )` | Cast operator |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: （目标类型）强制转换运算符
- en: Unary means used with a single operand, while binary means it requires two operands.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一元意味着与单个操作数一起使用，而二元意味着它需要两个操作数。
- en: In the following subsections, we will define and demonstrate most of the operators,
    except the rarely used assignment operators `&=`,  `|=`,  `^=`,  `<<=`,  `>>=`,
    and  `>>>=`, and the bitwise operators.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将定义并演示大多数运算符，除了很少使用的赋值运算符`&=`、`|=`、`^=`、`<<=`、`>>=`和`>>>=`，以及按位运算符。
- en: Also, please notice that the `&` and `|` operators behave differently if applied
    to integer (bitwise) and Boolean (logical) values. In this book, we will discuss
    these operators only as logical operators.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，如果应用于整数（按位）和布尔值（逻辑），`&`和`|`运算符的行为是不同的。在本书中，我们将仅讨论这些运算符作为逻辑运算符。
- en: The arrow operator `->` and the method reference operator `::` will be defined
    and discussed in [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml), *Lambda
    Expressions and Functional Programming*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头运算符`->`和方法引用运算符`::`将在[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)中定义和讨论，*Lambda表达式和函数式编程*。
- en: Arithmetic unary (+  -) and binary operators:  +   -   *   /   %
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 算术一元（+ -）和二进制运算符：+  -  *  /  %
- en: 'The best way to understand operators is to see them in action. Here is our
    demo application code (with results captured in comments) that explains the unary
    operators `+` and `-`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 理解运算符的最佳方法是看它们的实际应用。以下是我们的演示应用程序代码（其中包含在注释中捕获的结果），解释了一元运算符`+`和`-`：
- en: '```java'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Ch09DemoApp {
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: public class Ch09DemoApp {
- en: public static void main(String[] args) {
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: int i = 2;   //unary "+" is assumed by default
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 2;   //默认情况下假定为一元“+”
- en: int x = -i;  //unary "-" makes positive become negative
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: int x = -i;  //一元“-”使正数变为负数
- en: 'System.out.println(x);   //prints: -2'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x);   //输出：-2
- en: int y = -x;  //unary "-" makes negative become positive
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: int y = -x;  //一元“-”使负数变为正数
- en: 'System.out.println(y);   //prints: 2'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(y);   //输出：2
- en: '}'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And the following code demonstrates the binary operators  `+`, `-`, `*`, `/`,
    and `%`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了二进制运算符`+`、`-`、`*`、`/`和`%`：
- en: '```java'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int z = x + y;              //binary "+" means "add"
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: int z = x + y;              //二进制“+”表示“相加”
- en: 'System.out.println(z);      //prints: 0'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z);      //输出：0
- en: z = x - y;                  //binary "-" means "subtract"
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: z = x - y;                  //二进制“-”表示“减去”
- en: 'System.out.println(z);      //prints: -4'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z);      //输出：-4
- en: 'System.out.println(y - x);  //prints: 4'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(y - x);  //输出：4
- en: z = x * y;
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: z = x * y;
- en: 'System.out.println(z);      //prints: -4'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z);      //输出：-4
- en: z = x / y;
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: z = x / y;
- en: 'System.out.println(z);      //prints: -1'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z);      //输出：-1
- en: z = x * y;
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: z = x * y;
- en: 'System.out.println(z % 3);  //prints: -1'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z % 3);  //输出：-1
- en: 'System.out.println(z % 2);  //prints: 0'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z % 2);  //输出：0
- en: 'System.out.println(z % 4);  //prints: 0'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(z % 4);  //输出：0
- en: '```'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you have probably guessed, the `%` operator (called modulus) divides the
    left-hand operand by the right-hand operand and returns the remainder.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，`%`运算符（称为模数）将左操作数除以右操作数，并返回余数。
- en: 'Everything looks logical and as expected. But, then we try to divide one integer
    by another integer with the remainder and do not get what was expected:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一切看起来都很合乎逻辑和预期。但是，当我们尝试用余数除以另一个整数时，却没有得到预期的结果：
- en: '```java'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i1 = 11;
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: int i1 = 11;
- en: int i2 = 3;
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: int i2 = 3;
- en: 'System.out.println(i1 / i2); //prints: 3 instead of 3.66...'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i1 / i2); //输出：3 而不是3.66...
- en: 'System.out.println(i1 % i2); //prints remainder: 2'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i1 % i2); //输出余数：2
- en: '```'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The result, `i1/i2`, should be bigger than `3`. It has to be `3.66...` or something
    similar. The problem is caused by the fact that all the numbers involved in the
    operation are integers. In such a case, Java assumes that the result should also
    be expressed as an integer and drops (without rounding) the fractional part.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 结果`i1/i2`应该大于`3`。它必须是`3.66...`或类似的值。问题是由于操作中涉及的所有数字都是整数引起的。在这种情况下，Java假设结果也应该表示为整数，并丢弃（不四舍五入）小数部分。
- en: 'Now, let''s declare one of the operands as the `double` type, with the same
    value of 11, and try the division again:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将操作数之一声明为`double`类型，值为11，并再次尝试除法：
- en: '```java'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double d1 = 11;
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: double d1 = 11;
- en: 'System.out.println(d1/i2);    //prints: 3.6666666666666665'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(d1/i2);    //输出：3.6666666666666665
- en: '```'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'This time, we got what was expected, and there are other ways to achieve the
    same result:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们得到了预期的结果，还有其他方法可以实现相同的结果：
- en: '```java'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println((float)i1 / i2);  //prints: 3.6666667'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println((float)i1 / i2);  //输出：3.6666667
- en: 'System.out.println(i1 / (double)i2); //prints: 3.6666666666666665'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i1 / (double)i2); //输出：3.6666666666666665
- en: 'System.out.println(i1 * 1.0 / i2);   //prints: 3.6666666666666665'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i1 * 1.0 / i2);   //输出：3.6666666666666665
- en: 'System.out.println(i1 * 1f / i2);    //prints: 3.6666667'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i1 * 1f / i2);    //输出：3.6666667
- en: 'System.out.println(i1 * 1d / i2);    //prints: 3.6666666666666665'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i1 * 1d / i2);    //输出：3.6666666666666665
- en: '```'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, you can cast any of the operands to the `float` or `double`
    types (depending on the precision you need), or you can include the `float` or
    `double` type number. You might remember from [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*, that a value with a fractional part is `double`
    by default. Or, you can explicitly select a type of the value added, as we did
    in the last two lines of the preceding code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以将任何操作数转换为`float`或`double`类型（取决于你需要的精度），或者你可以包含`float`或`double`类型的数字。你可能还记得[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中所述，带有小数部分的值默认为`double`。或者，你可以明确选择要添加的值的类型，就像我们在前面代码的最后两行中所做的那样。
- en: 'Whatever you do, just be careful while dividing two integers. If you do not
    want the fractional part to be dropped, cast at least one operand to `float` or
    `double` just in case (more about the cast operator in the *Cast operator: ( target
    type )* section later. Then, if you need, you can round up the result to any precision
    you prefer or cast it back to `int`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '无论你做什么，只要小心两个整数相除。如果你不希望小数部分被丢弃，至少将一个操作数转换为`float`或`double`（稍后在*Cast operator:
    ( target type )*部分详细了解转换运算符）。然后，如果需要，你可以将结果四舍五入到任何你喜欢的精度，或者将其转换回`int`：'
- en: '```java'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i1 = 11;
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: int i1 = 11;
- en: int i2 = 3;
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: int i2 = 3;
- en: float r = (float)i1 / i2;
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: float r = (float)i1 / i2;
- en: 'System.out.println(r);                 //prints: 3.6666667'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(r);                 //输出：3.6666667
- en: float f = Math.round(r * 100f) / 100f;
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: float f = Math.round(r * 100f) / 100f;
- en: 'System.out.println(f);                 //prints: 3.67'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(f);                 //输出：3.67
- en: int i3 = (int)f;
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: int i3 = (int)f;
- en: 'System.out.println(i3);                //prints: 3'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i3);                //输出：3
- en: '```'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Java integer division: if in doubt, make one of the operands `double` or `float`,
    or simply add a `1.0` multiplier to one of them.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Java整数除法：如果不确定，将其中一个操作数设为`double`或`float`，或者简单地给其中一个添加`1.0`的乘数。
- en: 'In case of `String`, the binary operator  `+` means concatenate and the operator
    is often called the concatenation operator:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`String`的情况下，二进制运算符`+`表示连接，这个运算符通常被称为连接运算符：
- en: '```java'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String s1 = "Nick";
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: String s1 = "Nick";
- en: String s2 = "Samoylov";
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: String s2 = "Samoylov";
- en: 'System.out.println(s1 + " " + s2);  //prints: Nick Samoylov'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(s1 + " " + s2);  //prints: Nick Samoylov'
- en: String s3 = s1 + " " + s2;
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: String s3 = s1 + " " + s2;
- en: 'System.out.println(s3);             //prints: Nick Samoylov'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(s3);             //prints: Nick Samoylov'
- en: '```'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And just as a reminder, in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*, we demonstrated that an arithmetic operation
    applied to the primitive type `char` uses the character''s code point – a numeric
    value of the character:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 并且只是作为提醒，在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中，*Java语言元素和类型*，我们演示了应用于原始类型`char`的算术运算使用字符的代码点-字符的数值：
- en: '```java'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: char c1 = 'a';
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: char c1 = 'a';
- en: char c2 = '$';
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: char c2 = '$';
- en: 'System.out.println(c1 + c2);       //prints: 133'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c1 + c2);       //prints: 133'
- en: 'System.out.println(c1/c2);         //prints: 2'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c1/c2);         //prints: 2'
- en: 'System.out.println((float)c1/c2);  //prints: 2.6944444'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println((float)c1/c2);  //prints: 2.6944444'
- en: '```'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: These results make sense only if you remember that the code point of the symbol
    `a` is 97, while the code point of the symbol `$` is 36.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在记住符号`a`的代码点是97，而符号`$`的代码点是36时，这些结果才有意义。
- en: 'Most of the time, the arithmetic operations in Java are quite intuitive and
    cause no confusion, except in two cases:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，Java中的算术运算都相当直观，不会引起混淆，除了两种情况：
- en: When all operands of the division are integral
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当除法的所有操作数都是整数时
- en: When `char` variables are used as the operands of an arithmetic operator
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`char`变量用作算术运算符的操作数时
- en: Incrementing and decrementing unary operators:  ++   --
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递增和递减一元运算符：++ --
- en: 'The following code shows how the `++` and `--` operators work, depending on
    their position, before the variable (prefix) or after the variable (postfix):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了`++`和`--`运算符的工作原理，取决于它们的位置，变量之前（前缀）还是变量之后（后缀）：
- en: '```java'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i = 2;
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 2;
- en: 'System.out.println(++i);        //prints: 3'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(++i);        //prints: 3'
- en: 'System.out.println("i=" + i);   //prints: i=3'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("i=" + i);   //prints: i=3'
- en: 'System.out.println(--i);        //prints: 2'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(--i);        //prints: 2'
- en: 'System.out.println("i=" + i);   //prints: i=2'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("i=" + i);   //prints: i=2'
- en: 'System.out.println(i++);        //prints: 2'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i++);        //prints: 2'
- en: 'System.out.println("i=" + i);   //prints: i=3'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("i=" + i);   //prints: i=3'
- en: 'System.out.println(i--);        //prints: 3'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i--);        //prints: 3'
- en: 'System.out.println("i=" + i);   //prints: i=2'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("i=" + i);   //prints: i=2'
- en: '```'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: If placed as a prefix, it changes its value by 1 before the variable's value
    is returned. But when placed as a postfix, it changes its value by 1 after the
    variable's value is returned.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果放在前缀位置，它会在返回变量的值之前将其值减1。但是当放在后缀位置时，它会在返回变量的值之后将其值减1。
- en: The `++x` expression increments the `x` variable before returning the result,
    while the `x++` expression returns the result first and increments the `x` variable afterward.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`++x`表达式在返回结果之前增加`x`变量的值，而`x++`表达式在返回结果后增加`x`变量的值。'
- en: 'It takes time to get used to this. But once you do, it feels easy to write
    `++x;` or `x++`, instead of `x = x + 1;`. Using prefix or postfix increments,
    in this case, does not make a difference because each of them increases `x` eventually:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯这需要时间。但一旦你习惯了，写`++x;`或`x++`会感觉很容易，而不是`x = x + 1;`。在这种情况下使用前缀或后缀递增没有区别，因为它们都最终会增加`x`：
- en: '```java'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x = 0;
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 0;
- en: ++x;
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ++x;
- en: 'System.out.println(x);   //prints: 1'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(x);   //prints: 1'
- en: x = 0;
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: x = 0;
- en: x++;
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: x++;
- en: 'System.out.println(x);   //prints: 1'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(x);   //prints: 1'
- en: '```'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The difference between prefix and postfix appears only when the returned value
    is used, not the value of the variable that will have after the postfix returns,
    for example. Here is the demonstration code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀和后缀之间的区别只有在使用返回值而不是后缀返回后变量的值时才会出现。例如，这是演示代码：
- en: '```java'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x = 0;
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 0;
- en: int y = x++ + x++;
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: int y = x++ + x++;
- en: 'System.out.println(y);   //prints: 1'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y);   //prints: 1'
- en: 'System.out.println(x);   //prints: 2'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(x);   //prints: 2'
- en: '```'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The value of `y` is formed by the first `x++` returning 0 and then increasing `x` by
    1\. The second `x++` gets 1 as the current `x` value and returns it, so the `y` value
    becomes 1\. Meanwhile, the second `x++` increases the value of `x` by 1 again,
    so the value of `x` becomes 2.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`y`的值由第一个`x++`返回0形成，然后将`x`增加1。第二个`x++`得到1作为当前的`x`值并返回它，所以`y`的值变为1。同时，第二个`x++`再次增加`x`的值1，所以`x`的值变为2。'
- en: 'This functionality makes more sense if we include it in an expression:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种功能在表达式中更有意义：
- en: '```java'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int n = 0;
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: int n = 0;
- en: int m = 5*n++;
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: int m = 5*n++;
- en: 'System.out.println(m);   //prints: 0'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(m);   //prints: 0'
- en: 'System.out.println(n);   //prints: 1'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(n);   //prints: 1'
- en: '```'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It allows us to use the current value of the variable first and then increase
    it by 1\. So, the postfix increment (decrement) operator has the side effect of
    incrementing (decrementing) the variable value. As we have mentioned already,
    it is especially beneficial for array element access:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许我们首先使用变量的当前值，然后将其增加1。因此，后缀递增（递减）运算符具有增加（递减）变量值的副作用。正如我们已经提到的，这对于数组元素访问特别有益：
- en: '```java'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int k = 0;
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: int k = 0;
- en: int[] arr = {88, 5, 42};
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arr = {88, 5, 42};
- en: 'System.out.println(arr[k++]);  //prints: 88'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arr[k++]);  //prints: 88'
- en: 'System.out.println(k);         //prints: 1'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(k);         //prints: 1'
- en: 'System.out.println(arr[k++]);  //prints: 5'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arr[k++]);  //prints: 5'
- en: 'System.out.println(k);         //prints: 2'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(k);         //prints: 2'
- en: 'System.out.println(arr[k++]);  //prints: 42'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arr[k++]);  //prints: 42'
- en: 'System.out.println(k);         //prints: 3'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(k);         //prints: 3'
- en: '```'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The same result can be achieved by setting `k` to `-1` and moving `++` to the
    front:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`k`设置为`-1`并将`++`移到前面也可以实现相同的结果：
- en: '```java'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int k = -1;
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: int k = -1;
- en: int[] arr = {88, 5, 42};
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arr = {88, 5, 42};
- en: 'System.out.println(arr[k++]);  //prints: 88'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arr[k++]);  //prints: 88'
- en: 'System.out.println(k);         //prints: 1'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(k);         //prints: 1'
- en: 'System.out.println(arr[++k]);  //prints: 5'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arr[++k]);  //prints: 5'
- en: 'System.out.println(k);         //prints: 2'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(k);         //prints: 2'
- en: 'System.out.println(arr[++k]);  //prints: 42'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arr[++k]);  //prints: 42'
- en: 'System.out.println(k);         //prints: 3'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(k);         //prints: 3'
- en: '```'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But, using `k=0` and `k++` reads better and thus became a typical way to access
    the array components. However, it is only useful if you need to access the array
    elements by index. For example, if you need to access the array starting with
    index `2`, then you need to use the index:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用`k=0`和`k++`读起来更好，因此成为访问数组组件的典型方式。但是，只有在需要按索引访问数组元素时才有用。例如，如果需要从索引`2`开始访问数组，则需要使用索引：
- en: '```java'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[] arr = {1,2,3,4};
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arr = {1,2,3,4};
- en: int j = 2;
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: int j = 2;
- en: 'System.out.println(arr[j++]);  //prints: 3'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arr[j++]);  //prints: 3'
- en: 'System.out.println(arr[j++]);  //prints: 4'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arr[j++]);  //prints: 4'
- en: '```'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But if you are going to access the array sequentially, starting from index 0,
    then there are more economical ways to do it. See [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control
    Flow Statements*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您要按顺序访问数组，从索引0开始，那么有更经济的方法。请参见[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)，*控制流语句*。
- en: Equality operators:  ==   !=
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相等运算符：  ==   !=
- en: 'The equality operators `==` (means equals) and `!=` (means not equals) compare
    values of the same type and return the `Boolean` value `true` if the operand''s
    values are equal, or `false` otherwise. The integral and Boolean primitive type''s
    equality is straightforward:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 等号运算符`==`（表示相等）和`!=`（表示不相等）比较相同类型的值，并返回`Boolean`值`true`，如果操作数的值相等，则返回`false`。整数和布尔原始类型的相等性很简单：
- en: '```java'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: char a = 'a';
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: char a = 'a';
- en: char b = 'b';
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: char b = 'b';
- en: char c = 'a';
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: char c = 'a';
- en: 'System.out.println(a == b);  //prints: false'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(a == b);  //prints: false'
- en: 'System.out.println(a != b);  //prints: true'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(a != b);  //prints: true'
- en: 'System.out.println(a == c);  //prints: true'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(a == c);  //prints: true'
- en: 'System.out.println(a != c);  //prints: false'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(a != c);  //prints: false'
- en: int i1 = 1;
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: int i1 = 1;
- en: int i2 = 2;
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: int i2 = 2;
- en: int i3 = 1;
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: int i3 = 1;
- en: 'System.out.println(i1 == i2);  //prints: false'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 == i2);  //prints: false'
- en: 'System.out.println(i1 != i2);  //prints: true'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 != i2);  //prints: true'
- en: 'System.out.println(i1 == i3);  //prints: true'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 == i3);  //prints: true'
- en: 'System.out.println(i1 != i3);  //prints: false'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 != i3);  //prints: false'
- en: boolean b1 = true;
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: boolean b1 = true;
- en: boolean b2 = false;
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: boolean b2 = false;
- en: boolean b3 = true;
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: boolean b3 = true;
- en: 'System.out.println(b1 == b2);  //prints: false'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(b1 == b2);  //prints: false'
- en: 'System.out.println(b1 != b2);  //prints: true'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(b1 != b2);  //prints: true'
- en: 'System.out.println(b1 == b3);  //prints: true'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(b1 == b3);  //prints: true'
- en: 'System.out.println(b1 != b3);  //prints: false'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(b1 != b3);  //prints: false'
- en: '```'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In this code, the `char` type, as in the case of arithmetic operations, is
    treated as a numeric value that is equal to its code point. Otherwise, it is not
    easy to understand the results of the following line:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`char`类型与算术运算一样，被视为等于其代码点的数值。否则，很难理解以下行的结果：
- en: '```java'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println((a + 1) == b); //prints: true'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println((a + 1) == b); //prints: true'
- en: '```'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But the explanation for this line is obvious from the following results:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，从以下结果可以明显看出这行的解释：
- en: '```java'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println(b - a);        //prints: 1'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(b - a);        //prints: 1'
- en: 'System.out.println((int)a);       //prints: 97'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println((int)a);       //prints: 97'
- en: 'System.out.println((int)b);       //prints: 98'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println((int)b);       //prints: 98'
- en: '```'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The code point of `a` is `97` and the code point of `b` is `98`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`的代码点是`97`，`b`的代码点是`98`。'
- en: 'For the primitive types `float` and `double`, the equality operator seems to
    work in the same way. Here is an example of `double` type equality:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本类型`float`和`double`，等号运算符似乎以相同的方式工作。以下是`double`类型相等的示例：
- en: '```java'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double d1 = 0.42;
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: double d1 = 0.42;
- en: double d2 = 0.43;
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: double d2 = 0.43;
- en: double d3 = 0.42;
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: double d3 = 0.42;
- en: 'System.out.println(d1 == d2);  //prints: false'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1 == d2);  //prints: false'
- en: 'System.out.println(d1 != d2);  //prints: true'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1 != d2);  //prints: true'
- en: 'System.out.println(d1 == d3);  //prints: true'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1 == d3);  //prints: true'
- en: 'System.out.println(d1 != d3);  //prints: false'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1 != d3);  //prints: false'
- en: '```'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But, that is because we compare numbers created as literals, with fixed fractional
    parts. If we compare the results of the following calculations, there is a good
    chance that the resulting value would never be equal to the expected result, because
    some numbers (such as `1/3`, for example) cannot be represented exactly. And what
    is it exactly in the case of `1/3`? Expressed as a decimal, it has a never-ending
    fractional part:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这是因为我们比较的是作为文字创建的数字，带有固定小数部分。如果我们比较以下计算的结果，很有可能得到的值永远不会等于预期的结果，因为有些数字（例如`1/3`）无法准确表示。那么`1/3`的情况是什么？以小数表示，它有一个永无止境的小数部分：
- en: '```java'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println((double)1/3);    //prints: 0.3333333333333333'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println((double)1/3);    //prints: 0.3333333333333333'
- en: '```'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: That is why when comparing values of types `float` and `double`, it is much
    more reliable to use the relational operators `<`,  `>`, `<=`, or `=>` (see the
    next subsection).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为什么在比较`float`和`double`类型的值时，使用关系运算符`<`、`>`、`<=`或`=>`更可靠（请参见下一小节）。
- en: 'In the case of object references, an equality operator compares the references
    themselves, not the objects and their values:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象引用的情况下，等号运算符比较的是引用本身，而不是对象及其值：
- en: '```java'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: SomeClass c1 = new SomeClass();
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass c1 = new SomeClass();
- en: SomeClass c2 = new SomeClass();
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass c2 = new SomeClass();
- en: SomeClass c3 = c1;
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass c3 = c1;
- en: 'System.out.println(c1 == c2);     //prints: false'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c1 == c2);     //prints: false'
- en: 'System.out.println(c1 != c2);     //prints: true'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c1 != c2);     //prints: true'
- en: 'System.out.println(c1 == c3);     //prints: true'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c1 == c3);     //prints: true'
- en: 'System.out.println(c1 != c3);     //prints: false'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(c1 != c3);     //prints: false'
- en: 'System.out.println(new SomeClass() == new SomeClass());  //prints: false'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(new SomeClass() == new SomeClass());  //prints: false'
- en: '```'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Object equality based on the values they contain has to be performed using the `equals()` method.
    We talked about it in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml),
    *Java Language Basics*, and will discuss it more in the *Method equals() of reference
    types* section later.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Object equality based on the values they contain has to be performed using the `equals()` method.
    We talked about it in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml),
    *Java Language Basics*, and will discuss it more in the *Method equals() of reference
    types* section later.
- en: Relational operators:  <  >  <=  >=
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Relational operators:  <  >  <=  >=
- en: 'Relational operators can only be used with primitive types:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 'Relational operators can only be used with primitive types:'
- en: '```java'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i1 = 1;
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: int i1 = 1;
- en: int i2 = 2;
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: int i2 = 2;
- en: int i3 = 1;
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: int i3 = 1;
- en: 'System.out.println(i1 > i2);    //prints: false'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 > i2);    //prints: false'
- en: 'System.out.println(i1 >= i2);   //prints: false'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 >= i2);   //prints: false'
- en: 'System.out.println(i1 >= i3);   //prints: true'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 >= i3);   //prints: true'
- en: 'System.out.println(i1 < i2);    //prints: true'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 < i2);    //prints: true'
- en: 'System.out.println(i1 <= i2);   //prints: true'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 <= i2);   //prints: true'
- en: 'System.out.println(i1 <= i3);   //prints: true'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i1 <= i3);   //prints: true'
- en: 'System.out.println(''a'' >= ''b'');  //prints: false'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(''a'' >= ''b'');  //prints: false'
- en: 'System.out.println(''a'' <= ''b'');  //prints: true'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(''a'' <= ''b'');  //prints: true'
- en: double d1 = 1/3;
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: double d1 = 1/3;
- en: double d2 = 0.34;
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: double d2 = 0.34;
- en: double d3 = 0.33;
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: double d3 = 0.33;
- en: 'System.out.println(d1 < d2);  //prints: true'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1 < d2);  //prints: true'
- en: 'System.out.println(d1 >= d3); //prints: false'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1 >= d3); //prints: false'
- en: '```'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the preceding code, we see that `int` type values compare to each other as
    expected, and `char` type values compare to each other based on their numeric
    code point values.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: In the preceding code, we see that `int` type values compare to each other as
    expected, and `char` type values compare to each other based on their numeric
    code point values.
- en: Variables of the primitive type `char`, when used as operands with arithmetic,
    equality, or relational operators, assign numeric values equal to the code points
    of the characters they represent.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当将原始类型`char`的变量用作算术、相等或关系运算符的操作数时，它们分配的数值等于它们表示的字符的代码点。
- en: 'So far, nothing unexpected, except the last line. We have established that
    `1/3` expressed as a decimal should be `0.3333333333333333`, which is bigger than
    `0.33`. Why then does `d1 >= d3` return `false`? If you said that it is because
    of integer division, you are correct. Even when assigned to a variable of type
    `double`, the result is 0.0 because the integer division `1/3` happens first,
    before the result is assigned to `d1`. Here is the code that demonstrates it:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，除了最后一行之外，没有什么意外。我们已经确定，作为小数表示的`1/3`应该是`0.3333333333333333`，这比`0.33`大。为什么`d1
    >= d3`返回`false`？如果你说这是因为整数除法，那么你是正确的。即使赋值给`double`类型的变量，结果也是0.0，因为整数除法`1/3`先发生，然后才将结果赋给`d1`。以下是演示它的代码：
- en: '```java'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double d1 = 1/3;
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: double d1 = 1/3;
- en: double d2 = 0.34;
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: double d2 = 0.34;
- en: double d3 = 0.33;
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: double d3 = 0.33;
- en: 'System.out.println(d1 < d2);   //prints: true'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1 < d2);   //prints: true'
- en: 'System.out.println(d1 >= d3);  //prints: false'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1 >= d3);  //prints: false'
- en: 'System.out.println(d1);        //prints: 0.0'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d1);        //prints: 0.0'
- en: double d4 = 1/3d;
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: double d4 = 1/3d;
- en: 'System.out.println(d4);        //prints: 0.3333333333333333'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d4);        //prints: 0.3333333333333333'
- en: 'System.out.println(d4 >= d3);  //prints: true'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(d4 >= d3);  //prints: true'
- en: '```'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But other than that, using `float` and `double` types with relational operators
    yields more predictable results than using them with equality operators.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 但除此之外，使用关系运算符与等式运算符相比，使用`float`和`double`类型的值会产生更可预测的结果。
- en: While comparing values of types `float` and `double`, use the relational operators `<`,  `>`, `<=`,
    or `=>` instead of the equality operators `==` and `!=`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较`float`和`double`类型的值时，请使用关系运算符`<`、`>`、`<=`或`=>`，而不是等式运算符`==`和`!=`。
- en: Like in experimental physics, think about precision while comparing values of
    `float` and `double` types.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在实验物理学中一样，在比较`float`和`double`类型的值时，请考虑精度。
- en: Logical operators:  !  &  |
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Logical operators:  !  &  |
- en: 'Let''s define each of the logical operators first:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们定义每个逻辑运算符：
- en: The unary operator `!` returns `true` if the operand is `false` and returns
    `false` otherwise
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元运算符`!`如果操作数为`false`则返回`true`，否则返回`false`
- en: The binary operator `&` returns `true` if both of the operands are `true`
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制运算符`&`如果两个操作数都为`true`，则返回`true`
- en: The binary operator `|` returns true if at least one of the operands is true
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制运算符`|`如果两个操作数中至少有一个为`true`，则返回`true`
- en: 'Here is the demo code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是演示代码：
- en: '```java'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: boolean x = false;
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: boolean x = false;
- en: 'System.out.println(!x);  //prints: true'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(!x);  //prints: true'
- en: 'System.out.println(!!x); //prints: false'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(!!x); //prints: false'
- en: boolean y = !x;
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: boolean y = !x;
- en: 'System.out.println(y & x); //prints: false'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y & x); //prints: false'
- en: 'System.out.println(y | x); //prints: true'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y | x); //prints: true'
- en: boolean z = true;
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: boolean z = true;
- en: 'System.out.println(y & z); //prints: true'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y & z); //prints: true'
- en: 'System.out.println(y | z); //prints: true'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y | z); //prints: true'
- en: '```'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that the `!` operator can be applied to the same value several times.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`!`运算符可以多次应用于同一个值。
- en: 'Conditional operators:  &&   ||    ? : (ternary)'
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '条件运算符：  &&   ||    ? : (三元)'
- en: 'We can reuse the previous code example, but with the `&&` and `||` operators instead
    of the `&` and `|` operators:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重用先前的代码示例，但使用`&&`和`||`运算符，而不是`&`和`|`运算符：
- en: '```java'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: boolean x = false;
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: boolean x = false;
- en: boolean y = !x;
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: boolean y = !x;
- en: 'System.out.println(y && x); //prints: false'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y && x); //prints: false'
- en: 'System.out.println(y || x); //prints: true'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y || x); //prints: true'
- en: boolean z = true;
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: boolean z = true;
- en: 'System.out.println(y && z); //prints: true'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y && z); //prints: true'
- en: 'System.out.println(y || z); //prints: true'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(y || z); //prints: true'
- en: '```'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The results are not different, but there is a difference in the execution.
    The operators `&` and `|` always check values of both operands. Meanwhile, in
    the case of `&&`, if the operand on the left returns `false`, the `&&` operator returns
    `false` without evaluating the operand on the right. And, in the case of `||`,
    if the operand on the left returns `true`, the `||` operator returns `true` without
    evaluating the operand on the right. Here is the code that demonstrates this difference:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 结果并没有不同，但执行上有区别。运算符`&`和`|`总是检查两个操作数的值。与此同时，在`&&`的情况下，如果左操作数返回`false`，`&&`运算符会在不评估右操作数的情况下返回`false`。而在`||`的情况下，如果左操作数返回`true`，`||`运算符会在不评估右操作数的情况下返回`true`。以下是演示这种差异的代码：
- en: '```java'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i = 1, j = 3, k = 10;
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: int i = 1, j = 3, k = 10;
- en: 'System.out.println(i > j & i++ < k);  //prints: false'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i > j & i++ < k);  //prints: false'
- en: 'System.out.println("i=" + i);         //prints: i=2'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("i=" + i);         //prints: i=2'
- en: 'System.out.println(i > j && i++ < k); //prints: false'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(i > j && i++ < k); //prints: false'
- en: 'System.out.println("i=" + i);         //prints: i=2'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println("i=" + i);         //prints: i=2'
- en: '```'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Both operators—`&` and `&&`—return `false`. But in the case of `&&`, the second
    operand, `i++ < k`, is not checked and the value of the variable `i` does not
    change. Such optimization saves time if the second operand takes time to evaluate.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`和`&&`两个运算符都返回`false`。但是在`&&`的情况下，第二个操作数`i++ < k`不会被检查，变量`i`的值也不会改变。如果第二个操作数需要花费时间来评估，这样的优化可以节省时间。'
- en: The `&&` and `||` operators do not evaluate the right-hand condition if the
    left-hand condition already failed the test (returned `false`) in the case of
    `&&`, or succeeded (returned `true`) in the case of `||`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`和`||`运算符在`&&`的情况下，如果左操作数返回`false`，则不评估右操作数；在`||`的情况下，如果左操作数返回`true`，则不评估右操作数。'
- en: Yet, the `&` operator is useful when it is necessary to always check the second
    operand. For example, the second operand might be a method that may throw an exception
    and change the flow of the logic under some rare condition.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`&`运算符在需要始终检查第二个操作数时是有用的。例如，第二个操作数可能是一个可能抛出异常并在某些罕见条件下改变逻辑流程的方法。
- en: 'The third conditional operator is called a ternary operator. Here''s how it
    works:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个条件运算符称为三元运算符。它的工作原理如下：
- en: '```java'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int n = 1, m = 2;
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: int n = 1, m = 2;
- en: 'System.out.println(n > m ? "n > m" : "n <= m"); //prints: n <= m'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(n > m ? "n > m" : "n <= m"); //prints: n <= m'
- en: 'System.out.println(n > m ? true : false);       //prints: false'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(n > m ? true : false);       //prints: false'
- en: 'int max = n > m ? n : m;'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 'int max = n > m ? n : m;'
- en: 'System.out.println(max);                        //prints: 2'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(max);                        //prints: 2'
- en: '```'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'It evaluates the condition and, if it is true, returns the first entry (after
    the question mark, `?`); otherwise, it returns the second entry (after the colon
    sign, `:`). It is a very convenient and compact way to select between two options
    instead of using the full `if-else` statement construct:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 它评估条件，如果条件为真，则返回第一个条目（问号后面的内容，`?`）；否则，返回第二个条目（冒号后面的内容，`:`）。这是一种非常方便和紧凑的方式，可以选择两个选项，而不是使用完整的`if-else`语句结构：
- en: '```java'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String result;
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: String result;
- en: if(n > m){
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: if(n > m){
- en: result = "n > m";
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: result = "n > m";
- en: '} else {'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: result = "n <= m";
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: result = "n <= m";
- en: '}'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We will discuss such statements (called conditional statements) in [Chapter
    10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml), *Control Flow Statements*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)中讨论这样的语句（称为条件语句），*控制流语句*。
- en: Assignment operators (most popular):  =   +=   -=   *=   /=   %=
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 赋值运算符（最受欢迎的）： =  +=  -=  *=  /=  %=
- en: Although we discuss them not the first, these are the most often used operators,
    especially the `=` simple assignment operator, which just assigns a value to a
    variable (also phrased as *assigns a variable a value*). We have seen examples
    of simple assignment usage many times already.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不是第一次讨论它们，但这些是最常用的运算符，特别是`=`简单赋值运算符，它只是将一个值赋给一个变量（也可以说是*给变量赋值*）。我们已经多次看到了简单赋值的用法示例。
- en: The only possible caveat in using simple assignment is when the type of the
    variable on the left is not the same as the value or variable type on the right.
    The difference in types can lead to the *narrowing* or *widening* of the value
    in the case of primitive types, or to *boxing* or *unboxing* when one type is
    a primitive type and another type is a reference type. We will discuss such assignments
    in the *Widening and narrowing conversion of primitive types* and *Boxing and
    unboxing between a primitive and reference types* sections later.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用简单赋值时唯一可能的注意事项是，当左侧的变量类型与右侧的值或变量类型不同时。类型的差异可能导致原始类型的值*变窄*或*变宽*，或者在一个类型是原始类型而另一个类型是引用类型时导致*装箱*或*拆箱*。我们将在稍后的*原始类型的扩宽和变窄转换*和*原始类型和引用类型之间的装箱和拆箱*部分讨论这样的赋值。
- en: 'The rest of the assignment operators (`+=`  `-=`  `*=`  `/=`  `%=`) are called
    compound assignment operators:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的赋值运算符（`+=` `-=` `*=` `/=` `%=`）称为复合赋值运算符：
- en: '`x += 2;` assigns the result of this addition: `x = x + 2;`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x += 2;` 分配这个加法的结果：`x = x + 2;`'
- en: '`x -= 2;` assigns the result of this subtraction: `x = x - 2;`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x -= 2;` 分配这个减法的结果：`x = x - 2;`'
- en: '`x *= 2;` assigns the result of this multiplication: `x = x * 2;`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x *= 2;` 分配这个乘法的结果：`x = x * 2;`'
- en: '`x /= 2;` assigns the result of this division: `x = x / 2;`'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x /= 2;` 分配这个除法的结果：`x = x / 2;`'
- en: '`x %= 2;` assigns the remainder of this division: `x = x + x % 2;`'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x %= 2;` 分配这个除法的余数：`x = x + x % 2;`'
- en: 'The operation `x = x + x % 2;` is based on the operator precedence rules, which
    we are going to discuss in the *Operator precedence and evaluation order of operands* section later.
    According to these rules, the `%` operator (modulus) is executed first, then the `+` operator (addition),
    and then the result is assigned to the left-hand operand variable `x`. Here is
    the demonstration code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 操作`x = x + x % 2;`是基于运算符优先级规则的，我们将在稍后的*运算符优先级和操作数的评估顺序*部分讨论这些规则。根据这些规则，`%`运算符（取模）首先执行，然后是`+`运算符（加法），然后将结果分配给左操作数变量`x`。这是演示代码：
- en: '```java'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x = 1;
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 1;
- en: x += 2;
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: x += 2;
- en: 'System.out.println(x);    //prints: 3'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x);    //打印：3
- en: x -= 1;
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: x -= 1;
- en: 'System.out.println(x);    //prints: 2'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x);    //打印：2
- en: x *= 2;
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: x *= 2;
- en: 'System.out.println(x);    //prints: 4'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x);    //打印：4
- en: x /= 2;
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: x /= 2;
- en: 'System.out.println(x);    //prints: 2'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x);    //打印：2
- en: x %= 2;
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: x %= 2;
- en: 'System.out.println(x);    //prints: 0'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x);    //打印：0
- en: '```'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Again, every time we encounter integer division, we had better convert it to
    a `float` or `double` division, then round it if necessary or just cast it to
    an integer. In our example, we do not have any loss of the fractional part. But
    if we do not know the value of `x`, the code may look as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，每当遇到整数除法时，最好将其转换为`float`或`double`除法，然后根据需要四舍五入或将其转换为整数。在我们的例子中，我们没有任何小数部分的损失。但是，如果我们不知道`x`的值，代码可能如下所示：
- en: '```java'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: x = 11;
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: x = 11;
- en: double y = x;
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: double y = x;
- en: y /= 3;          //That's the operation we wanted to do on x
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: y /= 3;          //这是我们想要在x上执行的操作
- en: 'System.out.println(y);        //prints: 3.6666666666666665'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(y);        //打印：3.6666666666666665
- en: x = (int)y;
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: x = (int)y;
- en: 'System.out.println(x);        //prints: 3'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x);        //打印：3
- en: '//or, if we need to round up the result:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: //或者，如果我们需要四舍五入结果：
- en: 'double d = Math.round(y);     //prints: 4.0'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: double d = Math.round(y);     //打印：4.0
- en: System.out.println(d);
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(d);
- en: x = (int) d;
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: x = (int) d;
- en: 'System.out.println(x);        //prints: 4'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x);        //打印：4
- en: '```'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In this code, we have assumed that we do not know the value of `x`, so we switched
    to the `double` type to avoid the loss of the fractional part. After the result
    is calculated, we either cast it to `int` (and the fractional part is lost) or
    round it to the nearest integer.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们假设我们不知道`x`的值，所以我们切换到`double`类型以避免失去小数部分。计算结果后，我们要么将其转换为`int`（小数部分丢失），要么四舍五入到最接近的整数。
- en: In this simple division, we could lose the fractional part and get `3`, even
    without converting to the `double` type. But in real-life calculations, the formula
    is usually not that simple, so one might never know exactly where the integer
    division might happen. That's why it is a good practice just to convert the values
    to `float` and `double` before starting the calculations.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的除法中，我们可能会失去小数部分并得到`3`，即使不转换为`double`类型。但在现实生活中的计算中，公式通常不会那么简单，所以人们可能永远不知道整数除法可能发生的确切位置。这就是为什么在开始计算之前最好将值转换为`float`和`double`的良好做法。
- en: 'Instance creation operator: new'
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例创建运算符：new
- en: 'By now, we have seen examples of the `new` operator being used many times. It
    instantiates (creates an object of) a class by allocating memory for the new object
    and returning a reference to that memory. This reference is then typically assigned
    to a variable of the same type as the class used to create the object or the type
    of its parent, although we have also seen a case when the reference was never
    assigned. In [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Object Construction*, for example, we used this code to demonstrate
    how the constructors are called:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到`new`运算符被使用了很多次。它通过为新对象分配内存并返回对该内存的引用来实例化（创建）一个类。然后，这个引用通常被分配给与用于创建对象的类相同类型的变量，或者它的父类型，尽管我们也看到过一个情况，即引用从未被分配。在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)中，*接口、类和对象构造*，例如，我们使用这段代码来演示构造函数是如何被调用的：
- en: '```java'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: new Child();
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: new Child();
- en: new Child("The Blows");
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: new Child("The Blows");
- en: '```'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But such cases are very rare and most of the time we need a reference to the
    newly created object in order to invoke its methods:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种情况非常罕见，大多数时候我们需要一个对新创建的对象的引用，以便调用它的方法：
- en: '```java'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: SomeClass obj = new SomeClass();
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass obj = new SomeClass();
- en: obj.someMethod();
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: obj.someMethod();
- en: '```'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: After the `new` operator is called and the memory is allocated, the corresponding
    (explicit or default) constructor initializes the state of the new object. We
    talked extensively about this [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml),
    *Interfaces, Classes, and Object Construction*.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`new`运算符并分配内存后，相应的（显式或默认）构造函数初始化新对象的状态。我们在[第6章](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml)中对此进行了广泛讨论，*接口、类和对象构造*。
- en: 'Since arrays are objects too, they can also be created using the `new` operator and
    any Java type:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组也是对象，因此也可以使用`new`运算符和任何Java类型来创建数组：
- en: '```java'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[] arrInt = new int[42];
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arrInt = new int[42];
- en: '```'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `[]` notation allows us to set the array length (max number of components,
    also called elements) – `42` in the preceding code. One potential source of confusion
    may come from the fact that at compile time, Java allows assigning values to components
    with indexes bigger than the array length:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '`[]`符号允许我们设置数组长度（最大组件数，也称为元素）-在前面的代码中是`42`。可能会产生混淆的一个潜在来源是，在编译时，Java允许将值分配给大于数组长度的索引的组件：'
- en: '```java'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[] arrInt = new int[42];
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arrInt = new int[42];
- en: arrInt[43] = 22;
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: arrInt[43] = 22;
- en: '```'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'But when the program is run, the line `arrInt[43] = 22` will throw an exception:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 但当程序运行时，行`arrInt[43] = 22`将抛出异常：
- en: '![](img/4fbc4c0a-5e3a-4788-a04c-fa205a28259a.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4fbc4c0a-5e3a-4788-a04c-fa205a28259a.png)'
- en: 'It is also possible to create an array without using the `new` operator and
    using the array initializer instead:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用数组初始化程序而不使用`new`运算符来创建数组：
- en: '```java'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[] arrInt = {1,2,3,4};
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arrInt = {1,2,3,4};
- en: '```'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: A class instance can only be created using the `new` operator. An array can
    be created using the `new` operator or the `{}` initializer.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 只能使用`new`运算符创建类实例。数组可以使用`new`运算符或`{}`初始化程序创建。
- en: 'We discussed this extensively in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*. If not initialized explicitly, the values
    of an array are set to default values that depend on the type (we described them
    in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language Elements
    and Types*, too).  Here is a code example:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中对此进行了广泛讨论，*Java语言元素和类型*。如果没有明确初始化，则数组的值将设置为取决于类型的默认值（我们在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中也描述了它们，*Java语言元素和类型*）。以下是一个代码示例：
- en: '```java'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[] arrInt = new int[42];
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arrInt = new int[42];
- en: //arrInt[43] = 22;
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: //arrInt[43] = 22;
- en: 'System.out.println(arrInt[2]);      //prints: 0'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arrInt[2]);      //prints: 0'
- en: 'System.out.println(arrInt.length);  //prints: 42'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arrInt.length);  //prints: 42'
- en: int[] arrInit = {1,2,3,4};
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arrInit = {1,2,3,4};
- en: 'System.out.println(arrInit[2]);      //prints: 3'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arrInit[2]);      //prints: 3'
- en: 'System.out.println(arrInit.length);  //prints: 4'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arrInit.length);  //prints: 4'
- en: '```'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: And, just to remind you, the index of the first element of an array is 0.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，只是为了提醒你，数组的第一个元素的索引是0。
- en: Type comparison operator:  instanceof
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型比较运算符:  instanceof
- en: 'The `instanceof` operator requires two operands of a reference type. That is
    because it checks the parent-child relation of an object, including implementation
    of interfaces. It evaluates to `true` if the left-hand operand (an object reference)
    extends or implements the type on the right, and `false` otherwise. Obviously,
    every reference `instanceof Object` returns `true` because in Java, every class
    implicitly inherits the `Object` class. When `instanceof` is applied to an array
    of any type, it returns `true` for the right-hand operand `Object` only.  And,
    since `null` is not an instance of any type, `null instanceof` returns `false`
    for any type. Here is the demo code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`运算符需要两个引用类型的操作数。这是因为它检查对象的父子关系，包括接口的实现。如果左操作数（对象引用）扩展或实现右侧的类型，则求值为`true`，否则为`false`。显然，每个引用`instanceof
    Object`都返回`true`，因为在Java中，每个类都隐式继承了`Object`类。当`instanceof`应用于任何类型的数组时，它仅对右操作数`Object`返回`true`。而且，由于`null`不是任何类型的实例，所以`null
    instanceof`对于任何类型都返回`false`。以下是演示代码：'
- en: '```java'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface IntrfA{}
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: interface IntrfA{}
- en: class ClassA implements IntrfA {}
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: class ClassA implements IntrfA {}
- en: class ClassB extends ClassA {}
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: class ClassB extends ClassA {}
- en: class ClassX implements IntrfA {}
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: class ClassX implements IntrfA {}
- en: private void instanceofOperator() {
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: private void instanceofOperator() {
- en: ClassA classA = new ClassA();
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ClassA classA = new ClassA();
- en: ClassB classB = new ClassB();
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ClassB classB = new ClassB();
- en: ClassX classX = new ClassX();
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: ClassX classX = new ClassX();
- en: int[] arrI = {1,2,3};
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arrI = {1,2,3};
- en: ClassA[] arrA = {new ClassA(), new ClassA()};
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: ClassA[] arrA = {new ClassA(), new ClassA()};
- en: 'System.out.println(classA instanceof Object); //prints: true'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(classA instanceof Object); //prints: true'
- en: 'System.out.println(arrI instanceof Object);   //prints: true'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arrI instanceof Object);   //prints: true'
- en: 'System.out.println(arrA instanceof Object);   //prints: true'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(arrA instanceof Object);   //prints: true'
- en: //System.out.println(arrA instanceof ClassA);   //error
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: //System.out.println(arrA instanceof ClassA);   //error
- en: 'System.out.println(classA instanceof IntrfA); //prints: true'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(classA instanceof IntrfA); //prints: true'
- en: 'System.out.println(classB instanceof IntrfA); //prints: true'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(classB instanceof IntrfA); //prints: true'
- en: 'System.out.println(classX instanceof IntrfA); //prints: true'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(classX instanceof IntrfA); //prints: true'
- en: 'System.out.println(classA instanceof ClassA); //prints: true'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(classA instanceof ClassA); //prints: true'
- en: 'System.out.println(classB instanceof ClassA); //prints: true'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(classB instanceof ClassA); //prints: true'
- en: 'System.out.println(classA instanceof ClassB); //prints: false'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(classA instanceof ClassB); //prints: false'
- en: //System.out.println(classX instanceof ClassA); //error
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: //System.out.println(classX instanceof ClassA); //error
- en: 'System.out.println(null instanceof ClassA);   //prints: false'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(null instanceof ClassA);   //prints: false'
- en: //System.out.println(classA instanceof null);   //error
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: //System.out.println(classA instanceof null);   //error
- en: 'System.out.println(classA == null);           //prints: false'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(classA == null);           //prints: false'
- en: 'System.out.println(classA != null);           //prints: true'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(classA != null);           //prints: true'
- en: '}'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Most of the results are straightforward and were probably expected. The only
    one that might have been expected is `classX instanceof ClassA`. Both `ClassX`
    and `ClassA` implement the same interface, `IntrfA`, so there is some affinity
    between them – each can be cast to the `IntrfA` interface:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数结果都是直接的，可能是预期的。唯一可能预期的是`classX instanceof ClassA`。`ClassX`和`ClassA`都实现了相同的接口`IntrfA`，所以它们之间有一些亲和力-每个都可以转换为`IntrfA`接口：
- en: '```java'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: IntrfA intA = (IntrfA)classA;
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: IntrfA intA = (IntrfA)classA;
- en: intA = (IntrfA)classX;
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: intA = (IntrfA)classX;
- en: '```'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But that relation is not of parent-child type, so the `instanceof` operator
    cannot even be applied to them.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这种关系不是父子类型的，所以`instanceof`运算符甚至不能应用于它们。
- en: The `instanceof` operator allows us to check whether the class instance (object)
    has a certain class as a parent or a certain interface implemented.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`运算符允许我们检查类实例（对象）是否具有某个类作为父类或实现了某个接口。 '
- en: We see a similar problem with `classA instanceof null` because `null` does not
    refer to any object at all, although `null` is a literal of the reference type.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了`classA instanceof null`的类似问题，因为`null`根本不引用任何对象，尽管`null`是引用类型的文字。
- en: In the last two statements in the preceding code, we showed how the object reference
    can be compared to `null`. Such a comparison is often used before calling a method
    on the reference to make sure that the reference is not `null`. It helps to avoid
    the dreaded `NullPointerException`, which breaks the execution flow. We will talk more
    about exceptions in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码的最后两个语句中，我们展示了如何将对象引用与`null`进行比较。在调用引用之前，通常会使用此类比较，以确保引用不是`null`。它有助于避免令人恐惧的`NullPointerException`，它会中断执行流程。我们将在[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)中更多地讨论异常，*控制流语句*。
- en: Preferring polymorphism over the instanceof operator
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更喜欢多态而不是 instanceof 运算符
- en: The `instance of` operator is very helpful. We have used it several times in
    this book. But, there are situations that may require us to revisit the decision
    to use it.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`instance of` 运算符 非常有帮助。我们在本书中多次使用它。但是，有些情况可能需要我们重新考虑使用它的决定。'
- en: Every time you think about using the `instanceof` operator, try to see if you
    can avoid it by using polymorphism.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你考虑使用`instanceof`运算符时，试着看看是否可以通过多态来避免它。
- en: 'To illustrate this tip, here is some code that can benefit from polymorphism
    instead of using the `intanceof` operator:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个提示，这里有一些代码可以从多态中受益，而不是使用`intanceof`运算符：
- en: '```java'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class ClassBase {
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: class ClassBase {
- en: '}'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class ClassY extends ClassBase {
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: class ClassY extends ClassBase {
- en: void method(){
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: void method(){
- en: System.out.println("ClassY.method() is called");
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("ClassY.method() is called");
- en: '}'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class ClassZ extends ClassBase {
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: class ClassZ extends ClassBase {
- en: void method(){
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: void method(){
- en: System.out.println("ClassZ.method() is called");
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("ClassZ.method() is called");
- en: '}'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class SomeClass{
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: class SomeClass{
- en: public void doSomething(ClassBase object) {
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: public void doSomething(ClassBase object) {
- en: if(object instanceof ClassY){
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: if(object instanceof ClassY){
- en: ((ClassY)object).method();
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: ((ClassY)object).method();
- en: '} else if(object instanceof ClassZ){'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if(object instanceof ClassZ){'
- en: ((ClassZ)object).method();
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: ((ClassZ)object).method();
- en: '}'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //other code
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: //other code
- en: '}'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run the following code snippet:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行以下代码片段：
- en: '```java'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: SomeClass cl = new SomeClass();
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass cl = new SomeClass();
- en: cl.doSomething(new ClassY());
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: cl.doSomething(new ClassY());
- en: '```'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We will see this:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到这个：
- en: '![](img/4b39a48b-3c7e-4adf-81a8-ca3ddd69c988.png)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b39a48b-3c7e-4adf-81a8-ca3ddd69c988.png)'
- en: Then, we notice that the methods in `ClassY` and `ClassZ` have the same signature,
    so we may add the same method to the base class, `ClassBase:`
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们注意到`ClassY`和`ClassZ`中的方法具有相同的签名，因此我们可以将相同的方法添加到基类`ClassBase`中：
- en: '```java'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class ClassBase {
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: class ClassBase {
- en: void method(){
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: void method(){
- en: System.out.println("ClassBase.method() is called");
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("ClassBase.method() is called");
- en: '}'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And simplify the `SomeClass` implementation:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 并简化`SomeClass`的实现：
- en: '```java'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class SomeClass{
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: class SomeClass{
- en: public void doSomething(ClassBase object) {
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: public void doSomething(ClassBase object) {
- en: object.method();
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: object.method();
- en: //other code
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: //other code
- en: '}'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'After calling `new SomeClass().doSomething(new ClassY())`, we still get the
    same result:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`new SomeClass().doSomething(new ClassY())`之后，我们仍然会得到相同的结果：
- en: '![](img/2a6f5a08-0855-4ced-b30a-b4cf0c925523.png)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a6f5a08-0855-4ced-b30a-b4cf0c925523.png)'
- en: That is because `method()` is overridden in the child. The method implemented
    in `ClassBase` can do something or nothing. It does not matter because it is never
    going to be executed (unless you specifically call it by casting it from the child
    class using the `super` keyword).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`method()`在子类中被重写。在`ClassBase`中实现的方法可以做一些事情或什么都不做。这并不重要，因为它永远不会被执行（除非你使用`super`关键字从子类中将其强制转换来特别调用它）。
- en: 'And, while overriding, do not forget to use the `@Override` annotation:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在重写时，不要忘记使用`@Override`注解：
- en: '```java'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class ClassZ extends ClassBase {
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: class ClassZ extends ClassBase {
- en: '@Override'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: void method(){
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: void method(){
- en: System.out.println("ClassY.method() is called");
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("ClassY.method() is called");
- en: '}'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The annotation will help you to verify that you are not mistaken and the method
    in each of the child classes has the same signature as the one in the parent class.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 注解将帮助您验证您没有错误，并且每个子类中的方法与父类中的方法具有相同的签名。
- en: Field access or method invocation operator:  .
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字段访问或方法调用运算符：  .
- en: 'Inside the class or interface, a field or a method of this class or interface
    can be accessed just by the name. But from outside the class or interface, the
    non-private field or method can be accessed using the dot (`.`) operator and:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在类或接口内部，可以通过名称访问该类或接口的字段或方法。但是从类或接口外部，非私有字段或方法可以使用点（`.`）运算符访问和：
- en: If the field or method is non-static (instance member), the object name
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字段或方法是非静态的（实例成员），则对象名称
- en: If the field or method is static, the interface or class name
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字段或方法是静态的，则接口或类名
- en: A dot operator (`.`) can be used to access a non-private field or method. If
    the field or method is static, the dot operator is applied to the interface or
    class name. If the field or method is non-static, the dot operator is applied
    to the object reference.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 点运算符（`.`）可以用于访问非私有字段或方法。如果字段或方法是静态的，则点运算符应用于接口或类名。如果字段或方法是非静态的，则点运算符应用于对象引用。
- en: 'We have seen many such examples already. So, we just summarize all the cases
    in one interface and the class that implements it. Let''s assume that we have
    the following interface called `InterfaceM`:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多这样的例子。因此，我们将所有情况总结在一个接口和实现它的类中。假设我们有以下名为`InterfaceM`的接口：
- en: '```java'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface InterfaceM {
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: interface InterfaceM {
- en: String INTERFACE_FIELD = "interface field";
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: String INTERFACE_FIELD = "interface field";
- en: static void staticMethod1(){
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: static void staticMethod1(){
- en: System.out.println("interface static method 1");
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("interface static method 1");
- en: '}'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: static void staticMethod2(){
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: static void staticMethod2(){
- en: System.out.println("interface static method 2");
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("interface static method 2");
- en: '}'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: default void method1(){
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: default void method1(){
- en: System.out.println("interface default method 1");
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("interface default method 1");
- en: '}'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: default void method2(){
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: default void method2(){
- en: System.out.println("interface default method 2");
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("interface default method 2");
- en: '}'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void method3();
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: void method3();
- en: '}'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can use a dot operator (`.`) with it as follows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用点运算符（`.`）来访问非私有字段或方法，如下所示：
- en: '```java'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println(InterfaceM.INTERFACE_FIELD);    //1: interface field'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(InterfaceM.INTERFACE_FIELD);    //1: interface field'
- en: 'InterfaceM.staticMethod1();               //2: interface static method'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 'InterfaceM.staticMethod1();               //2: interface static method'
- en: 'InterfaceM.staticMethod2();               //3: interface static method'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 'InterfaceM.staticMethod2();               //3: interface static method'
- en: '//InterfaceM.method1();                         //4: compilation error'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '//InterfaceM.method1();                         //4: compilation error'
- en: '//InterfaceM.method2();                         //5: compilation error'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '//InterfaceM.method2();                         //5: compilation error'
- en: '//InterfaceM.method3();                         //6: compilation error'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '//InterfaceM.method3();                         //6: compilation error'
- en: 'System.out.println(ClassM.INTERFACE_FIELD);       //7: interface field'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(ClassM.INTERFACE_FIELD);       //7：接口字段
- en: '```'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Cases 1, 2, and 3 are straightforward. Cases 4, 5, and 6 generate a compilation
    error because non-static methods can be accessed only via an instance (object)
    of a class that implements the interface. Case 7 is possible, but is not a recommended
    way to access interface fields (also called constants). Accessing them using the
    interface name (as in case 1) makes the code easier to understand.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 案例1、2和3很简单。案例4、5和6会生成编译错误，因为非静态方法只能通过实现接口的类的实例（对象）访问。案例7是可能的，但不是访问接口字段（也称为常量）的推荐方式。使用接口名称访问它们（如案例1中）使代码更易于理解。
- en: 'Now let''s create a `ClassM` class that implements the `InterfaceM` interface:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个实现`InterfaceM`接口的`ClassM`类：
- en: '```java'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class ClassM implements InterfaceM {
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: class ClassM implements InterfaceM {
- en: public static String CLASS_STATIC_FIELD = "class static field";
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: public static String CLASS_STATIC_FIELD = "类静态字段";
- en: public static void staticMethod2(){
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: public static void staticMethod2(){
- en: System.out.println("class static method 2");
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("类静态方法2");
- en: '}'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public static void staticMethod3(){
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: public static void staticMethod3(){
- en: System.out.println("class static method 3");
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("类静态方法3");
- en: '}'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String instanceField = "instance field";
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: public String instanceField = "实例字段";
- en: public void method2(){
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: public void method2(){
- en: System.out.println("class instance method 2");
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("类实例方法2");
- en: '}'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void method3(){
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: public void method3(){
- en: System.out.println("class instance method 3");
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("类实例方法3");
- en: '}'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And here are all possible cases of using the dot operator (`.`) for the class
    field and method access:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用点运算符（`。）访问类字段和方法的所有可能情况：
- en: '```java'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '//ClassM.staticMethod1();                       //8: compilation error'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: //ClassM.staticMethod1();                       //8：编译错误
- en: 'ClassM.staticMethod2();                     //9: class static method 2'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: ClassM.staticMethod2();                     //9：类静态方法2
- en: 'ClassM.staticMethod3();                    //10: class static method 3'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: ClassM.staticMethod3();                    //10：类静态方法3
- en: ClassM classM = new ClassM();
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: ClassM classM = new ClassM();
- en: 'System.out.println(ClassM.CLASS_STATIC_FIELD);//11: class static field'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(ClassM.CLASS_STATIC_FIELD);//11：类静态字段
- en: 'System.out.println(classM.CLASS_STATIC_FIELD);//12: class static field'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(classM.CLASS_STATIC_FIELD);//12：类静态字段
- en: '//System.out.println(ClassM.instanceField);    //13: compilation error'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: //System.out.println(ClassM.instanceField);    //13：编译错误
- en: 'System.out.println(classM.instanceField);         //14: instance field'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(classM.instanceField);         //14：实例字段
- en: '//classM.staticMethod1();                      //15: compilation error'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: //classM.staticMethod1();                      //15：编译错误
- en: 'classM.staticMethod2();                   //16: class static method  2'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: classM.staticMethod2();                   //16：类静态方法2
- en: 'classM.staticMethod3();                    //17: class static method 3'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: classM.staticMethod3();                    //17：类静态方法3
- en: 'classM.method1();                     //18: interface default method 1'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: classM.method1();                     //18：接口默认方法1
- en: 'classM.method2();                        //19: class instance method 2'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: classM.method2();                        //19：类实例方法2
- en: 'classM.method3();                        //20: class instance method 3'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: classM.method3();                        //20：类实例方法3
- en: '}'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Case 8 generates a compilation error because a static method belongs to the
    class or interface (in this case) where it is implemented.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 案例8会生成编译错误，因为静态方法属于实现它的类或接口（在这种情况下）。
- en: Case 9 is an example of a static method hiding. A method with the same signature
    is implemented in the interface but hidden by the class implementation.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 案例9是静态方法隐藏的一个例子。接口中实现了具有相同签名的方法，但被类实现隐藏了。
- en: Cases 10 and 11 are straightforward.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 案例10和11很简单。
- en: Case 12 is possible but not recommended. Accessing a static class field using
    the class name makes the code easier to understand.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 案例12是可能的，但不建议。使用类名访问静态类字段使代码更易于理解。
- en: Class 13 is an obvious error because an instance field can be accessed only
    via an instance (object).
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 案例13显然是一个错误，因为只能通过实例（对象）访问实例字段。
- en: Class 14 is a correct version of case 13.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 案例14是案例13的正确版本。
- en: Class 15 is an error because a static method belongs to the class or interface
    (in this case) where it is implemented, not to the class instance.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 类15是一个错误，因为静态方法属于实现它的类或接口（在这种情况下），而不是类实例。
- en: Cases 16 and 17 are possible but are not recommended ways to access a static
    method. Using the class name (instead of the instance identifier) to access static
    method makes code easier to understand.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 案例16和17是可能的，但不是访问静态方法的推荐方式。使用类名（而不是实例标识符）访问静态方法使代码更易于理解。
- en: Case 18 demonstrates how an interface can provide a default implementation to
    a class. That is possible because `ClassM implements InterfaceM` effectively inherits
    all the methods and fields of the interface. We say effectively because the legally
    correct terminology is class *implements* interface. But in fact, a class that
    implements an interface acquires all the fields and methods of the interface in
    the same manner a child class inherits them.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 案例18演示了接口如何为类提供默认实现。这是可能的，因为`ClassM implements InterfaceM`有效地继承了接口的所有方法和字段。我们说有效地是因为在法律上正确的术语是类*implements*接口。但事实上，实现接口的类以与子类继承它们相同的方式获得接口的所有字段和方法。
- en: Case 19 is an example of the class overriding the default implementation of
    the interface.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 案例19是类覆盖接口默认实现的一个例子。
- en: 'Case 20 is an example of the classic interface implementation. That was the
    original idea of an interface: to provide an abstraction of the API.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 案例20是经典接口实现的一个例子。这是接口的最初想法：提供API的抽象。
- en: Cast operator:  (target type)
  id: totrans-614
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制转换运算符：（目标类型）
- en: 'The cast operator is used for type casting, assigning a value of one type to
    a variable of another type. Usually, it is used to enable conversions that would
    otherwise not be allowed by the compiler. We used type casting, for example, when
    we discussed integer division, the `char` type as a numeric type, and assigning
    a class reference to a variable that has a type of one of the implemented interfaces:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 强制转换运算符用于类型转换，将一个类型的值分配给另一个类型的变量。通常，它用于启用编译器否则不允许的转换。例如，我们在讨论整数除法、`char`类型作为数值类型以及将类引用分配给一个已实现接口类型的变量时，我们使用了类型转换：
- en: '```java'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int i1 = 11;
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: int i1 = 11;
- en: int i2 = 3;
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: int i2 = 3;
- en: 'System.out.println((float)i1 / i2);  //prints: 3.6666667'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println((float)i1 / i2);  //输出：3.6666667
- en: 'System.out.println((int)a);          //prints: 97'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println((int)a);          //输出：97
- en: IntrfA intA = (IntrfA)classA;
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: IntrfA intA = (IntrfA)classA;
- en: '```'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'There are two potential issues to watch while casting:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行强制转换时，有两个潜在的问题需要注意：
- en: In the case of primitive types, the value should be smaller than the maximum
    value the target type can hold (we will talk about this in detail in the *Widening
    and narrowing conversion of  primitive types* section later)
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于原始类型，值应该小于目标类型可以容纳的最大值（我们将在*原始类型的扩展和缩小转换*部分中详细讨论这一点）
- en: 'In the case of reference types, the left-hand operand should be a parent (even
    if indirect) of the right-hand operand, or the left-hand operand should be an
    interface implemented (even if indirectly) by the class represented by the right-hand
    operand:'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于引用类型，左操作数应该是右操作数的父类（即使是间接的），或者左操作数应该是右操作数所代表的类实现的接口（即使是间接的）：
- en: '```java'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: interface I1{}
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 接口I1{}
- en: interface I2{}
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 接口I2{}
- en: interface I3{}
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 接口I3{}
- en: class A implements I1, I2 {}
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 类A实现I1, I2 {}
- en: class B extends A implements I3{}
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 类B扩展自A并实现I3{}
- en: class C extends B {}
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 类C扩展自B{}
- en: class D {}
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 类D{}
- en: public static void main(String[] args) {
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: C c = new C();    //1
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: C c = new C();    //1
- en: A a = (A)c;       //2
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: A a = (A)c;       //2
- en: I1 i1 = (I1)c;    //3
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: I1 i1 = (I1)c;    //3
- en: I2 i2 = (I2)c;    //4
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: I2 i2 = (I2)c;    //4
- en: I3 i3 = (I3)c;    //5
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: I3 i3 = (I3)c;    //5
- en: c = (C)a;         //6
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: c = (C)a;         //6
- en: D d = new D();    //7
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: D d = new D();    //7
- en: //a = (A)d;       //8 compilation error
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: //a = (A)d;       //8 编译错误
- en: i1 = (I1)d;       //9 run-time error
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: i1 = (I1)d;       //9 运行时错误
- en: '}'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In this code, case 6 is possible because we know that object `a` was originally
    cast based on object `c`, so we can cast it back to type `C` and expect it to
    be fully functional as an object of class `C`.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，第6种情况是可能的，因为我们知道对象`a`最初是基于对象`c`进行转换的，所以我们可以将其转换回类型`C`并期望它能够完全作为类`C`的对象正常运行。
- en: Case 8 does not compile because its parent-child relations can be verified by
    the compiler.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 第8种情况不会编译，因为其父子关系可以由编译器验证。
- en: 'Case 9 is not so easy for the compiler for reasons that are outside the scope
    of this book. So, while writing code, the IDE will not give you a hint and you
    may think everything will work as you expect. But then at run-time, you can get
    `ClassCastException`:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第9种情况，由于超出了本书范围的原因，编译器并不容易。因此，在编写代码时，IDE不会给出提示，你可能认为一切都会按照你的期望工作。但是在运行时，你可能会得到`ClassCastException`：
- en: '![](img/c7514f1c-0e5b-4e2e-8520-35b894fdcf81.png)'
  id: totrans-649
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7514f1c-0e5b-4e2e-8520-35b894fdcf81.png)'
- en: Programmers are as happy to see it as much as they like to see the `NullPointerException` or
    `ArrayOutOfBoundException` we demonstrated before. That's why casting to an interface
    has to be done with more care than to a class.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员们看到这种情况就像看到`NullPointerException`或`ArrayOutOfBoundException`一样高兴。这就是为什么与类的强制转换相比，对接口的强制转换必须更加小心。
- en: Typecasting is assigning a value of one type to a variable of another type.
    While doing it, make sure that the target type can hold the value and check it
    against the maximum target type value if necessary.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 类型转换是将一个类型的值分配给另一个类型的变量。在执行此操作时，请确保目标类型可以容纳该值，并在必要时检查其是否超过最大目标类型值。
- en: 'It is also possible to cast a primitive type to a matching reference type:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将原始类型转换为匹配的引用类型：
- en: '```java'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Integer integer1 = 3;                  //line 1
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: Integer integer1 = 3;                  //行1
- en: 'System.out.println(integer1);          //prints: 3'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(integer1);          //输出：3
- en: Integer integer2 = Integer.valueOf(4);
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: Integer integer2 = Integer.valueOf(4);
- en: int i = integer2;                      //line 4
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: int i = integer2;                      //行4
- en: 'System.out.println(i);                 //prints: 4'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(i);                 //输出：4
- en: '```'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In line 1 and line 4, casting is done implicitly. We will discuss such a casting
    (also called conversion, or boxing and unboxing) in more detail in the *Boxing
    and unboxing between a primitive and reference types* section later.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行和第4行，强制转换是隐式进行的。我们将在*原始类型和引用类型之间的装箱和拆箱*部分中更详细地讨论这种转换（也称为转换或装箱和拆箱）。
- en: Expressions
  id: totrans-661
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: As we said at the beginning of this section, an expression exists only as a
    part of a statement, the latter being the complete action (we will discuss it
    in the next subsection). This means that an expression can be a building block
    of an action. Some expressions can even become a full action (an expression statement)
    after adding a semicolon to them.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节开头所说的，表达式只存在于语句的一部分，后者是完整的动作（我们将在下一小节中讨论）。这意味着表达式可以是一个动作的构建块。一些表达式甚至可以在添加分号后成为一个完整的动作（表达式语句）。
- en: 'The distinguishing feature of an expression is that it can be evaluated, which
    means it can produce something as the result of its execution. This something
    can be one of three things:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的区别特征在于它可以被评估，这意味着它可以产生执行结果。这个结果可以是三种之一：
- en: A variable, such as `i = 2`
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个变量，比如`i = 2`
- en: A value, such as `2*2`
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个值，比如`2*2`
- en: Nothing, when the expression is an invocation of a method that returns nothing
    (void). Such an expression can only be the full action—an expression statement—with
    a semicolon at the end.
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当表达式是返回空（void）的方法的调用时，什么都没有。这样的表达式只能是完整的动作——带有分号的表达式语句。
- en: An expression typically includes one or more operators and is evaluated. It
    can produce a variable, a value (that is included in further evaluation), or can
    invoke a method that returns nothing (void).
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式通常包括一个或多个运算符并进行求值。它可以产生一个变量，一个值（包含在进一步的求值中），或者可以调用一个返回空（void）的方法。
- en: 'An evaluation of an expression can also produce a side effect. That is, in
    addition to the variable assignment or returning a value, it can do something
    else, for example:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的求值也可能产生副作用。也就是说，除了变量赋值或返回值之外，它还可以执行其他操作，例如：
- en: '```java'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x = 0, y;
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 0, y;
- en: y = x++;                  //line 2
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: y = x++;                  //第2行
- en: 'System.out.println(y);    //prints: 0'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(y);    //输出：0
- en: 'System.out.println(x);    //prints: 1'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(x);    //输出：1
- en: '```'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The expression in line 2 assigns a value to variable `y`, but also has the side
    effect of adding `1` to the value of variable `x`.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 第2行的表达式给变量`y`赋值，但也具有将`1`添加到变量`x`的值的副作用。
- en: 'By its form, the expression can be:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其形式，表达式可以是：
- en: 'A primary expression:'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主表达式：
- en: A literal (some value)
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面量（某个值）
- en: Object creation (with the `new` operator or with the `{}` array initializer)
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象创建（使用`new`运算符或`{}`数组初始化器）
- en: Field access (with the dot operator for an external class or without it for
    this instance)
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段访问（使用外部类的点运算符或者不使用该运算符来访问此实例）
- en: A method invocation (with the dot operator for an external class or without
    it for this instance)
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用（使用外部类的点运算符或者不使用该运算符来调用此实例）
- en: A method reference (with the `::` operator, in lambda expressions)
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法引用（在lambda表达式中使用`::`运算符）
- en: Array access (with the `[]` notation, which carries an index of the element
    to be accessed)
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组访问（使用`[]`符号，其中包含要访问的元素的索引）
- en: A unary operator expression (`x++` or `-y`, for example)
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元运算符表达式（`x++`或`-y`，例如）
- en: A binary operator expression (`x+y` or `x*y`, for example)
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二元运算符表达式（`x+y`或`x*y`，例如）
- en: 'A ternary operator expression (`x > y ? "x>y" : "x<=y"`, for example)'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '三元运算符表达式（例如`x > y ? "x>y" : "x<=y"`）'
- en: A lambda expression `i -> i + 1` (see [Chapter 17](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml),
    *Lambda Expressions and Functional Programming*)
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个lambda表达式 `i -> i + 1`（见[第17章](e5647937-f76b-46eb-ba4a-c9ad65c2c63a.xhtml)，*Lambda表达式和函数式编程*）
- en: 'The expressions are named according to the action they produce: an object creation
    expression, a cast expression, a method invocation expression, an array access
    expression, an assignment expression, and so on.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表达式根据它们产生的动作命名：对象创建表达式、强制类型转换表达式、方法调用表达式、数组访问表达式、赋值表达式等等。
- en: An expression that consists of other expressions is called a complex expression.
    Parentheses are often used to clearly identify each of the sub-expressions, instead
    of relying on the operator precedence (see the *Operators precedence and evaluation
    order of operands* section later).
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 由其他表达式组成的表达式称为复杂表达式。通常使用括号来清楚地标识每个子表达式，而不是依赖于运算符优先级（参见稍后的*运算符优先级和操作数的求值顺序*部分）。
- en: Statements
  id: totrans-690
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语句
- en: We actually defined a statement once in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics.* It is a complete action that can be executed. It can include
    one or more expressions and ends with a semicolon `;`.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)，*Java语言基础*中定义了一条语句。它是一个可以执行的完整动作。它可以包括一个或多个表达式，并以分号`;`结束。
- en: A Java statement describes an action. It is a minimal construct that can be
    executed. It may or may not include one or more expressions.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: Java语句描述一个动作。它是一个可以执行的最小结构。它可能包括一个或多个表达式，也可能不包括。
- en: 'The possible kinds of Java statements are:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: Java语句的可能种类有：
- en: A class or interface declaration statement, such as `class A {...}`
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类或接口声明语句，比如`class A {...}`
- en: An empty statement that consists of only one symbol, `;`
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只包含一个符号的空语句，`;`
- en: A local variable declaration statement, `int x;`
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量声明语句，`int x;`
- en: A synchronized statement – outside the scope of this book
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步语句-超出本书范围
- en: 'An expression statement, which can be one of the following:'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式语句，可以是以下之一：
- en: A method invocation statement, such as `method();`
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用语句，比如`method();`
- en: An assignment statement, such as `x = 3;`
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值语句，比如`x = 3;`
- en: An object creation statement, such as `new SomeClass();`
  id: totrans-701
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象创建语句，比如`new SomeClass();`
- en: A unary increment or decrement statement, such as `++x ;`  `--x;`  `x++;`  `x--;`
  id: totrans-702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个一元递增或递减语句，比如`++x ;` `--x;` `x++;` `x--;`
- en: 'A control flow statement (see [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*):'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流语句（见[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)，*控制流语句*）：
- en: A selection statement: `if-else` or `switch-case`
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择语句：`if-else`或`switch-case`
- en: 'An iteration statement: `for`, `while`, or `do-while`'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代语句：`for`、`while`或`do-while`
- en: An exception handling statement, such as `try-catch-finally` or `throw`
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理语句，比如`try-catch-finally`或`throw`
- en: A branching statement, such as `break`, `continue`, `label:`, `return`, `assert`
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支语句，比如`break`、`continue`、`label:`、`return`、`assert`
- en: A statement can be *labeled *by placing an identifier and colon `:` in front
    of it. This label can be used by the branching statements `break` and `continue`
    to redirect the control flow. In [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*, we will show you how to do it.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在语句前面放置标识符和冒号`:`来*标记*语句。这个标签可以被分支语句`break`和`continue`使用来重定向控制流。在[第10章](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml)，*控制流语句*中，我们将向您展示如何做到这一点。
- en: Most often, statements compose a method body, and that is how programs are written.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，语句组成一个方法体，这就是程序的编写方式。
- en: Operator precedence and evaluation order of operands
  id: totrans-710
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符优先级和操作数的求值顺序
- en: 'When several operators are used in the same expression, it might not be obvious
    how to execute them without established rules. For example, what is the value
    that is going to be assigned to variable `x` after the following right-hand expression
    is evaluated:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 当在同一个表达式中使用多个运算符时，如果没有已建立的规则，可能不明显如何执行它们。例如，在评估以下右侧表达式后，将分配给变量`x`的值是什么：
- en: '```java'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x = 2 + 4 * 5 / 6 + 3 + 7 / 3 * 11 - 4;
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 2 + 4 * 5 / 6 + 3 + 7 / 3 * 11 - 4;
- en: '```'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We know how to do it because we have learned operator precedence in school—just
    apply the multiplication and division operators first from left to right, then
    addition and subtraction from left to right too. But, it turned out that the author
    actually wanted this sequence of operator execution:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何做，因为我们在学校学习了运算符优先级-从左到右首先应用乘法和除法运算符，然后从左到右进行加法和减法。但是，事实证明作者实际上想要这个运算符执行顺序：
- en: '```java'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x = 2 + 4 * 5 / 6 + ( 3 + 7 / 3 * (11 - 4));
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 2 + 4 * 5 / 6 + ( 3 + 7 / 3 * (11 - 4));
- en: '```'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It yields a different result.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生不同的结果。
- en: Operator precedence and parentheses determines the sequence in which parts of
    an expression are evaluated. The evaluation order of operands defines for each
    operation the sequence in which its operands are evaluated.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符优先级和括号决定了表达式的各部分的计算顺序。操作数的评估顺序为每个操作定义了其操作数的计算顺序。
- en: The parentheses help to identify the structure of a complex expression and establish
    the sequence of evaluation, which overrides the operator precedence.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 括号有助于识别复杂表达式的结构并建立评估顺序，这将覆盖运算符优先级。
- en: Operator precedence
  id: totrans-722
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符优先级
- en: The Java specification does not provide operator precedence in one place. One
    has to pull it together from various sections. That's why different sources on
    the internet sometimes have a bit of a different sequence of operator execution,
    so do not be surprised, and if in doubt, experiment or just set the parentheses
    to guide the calculations in the sequence you need to.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: Java规范没有在一个地方提供运算符优先级。必须从各个部分整理出来。这就是为什么互联网上的不同来源有时对运算符执行顺序有点不同，所以不要感到惊讶，如果有疑问，可以进行实验或者只需设置括号以指导所需的计算顺序。
- en: 'The following list shows the operator precedence from the highest (the first
    executed) as the first in the list, to the lowest precedence at the end. Operators
    of the same level of precedence are executed by their position in the expression
    while moving from left to right (provided no parentheses are used):'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了从最高（第一个执行）到最低优先级（最后）的运算符优先级。具有相同优先级的运算符按其在表达式中的位置从左到右执行（如果没有使用括号）：
- en: An expression that calculates the index of an array element inside the `[]` notation,
    such as `x = 4* arr[i+1]`; the field access and method invocation dot operator `.`,
    such as in `x = 3*someClass.COUNT` or `x = 2*someClass.method(2, "b")`
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算数组元素的索引的表达式，如`x = 4* arr[i+1]`；字段访问和方法调用点运算符`.`，如`x = 3*someClass.COUNT`或`x
    = 2*someClass.method(2, "b")`
- en: Unary postfix increment `++` and decrement `--` operators, such as `x++` or
    `x--`, as in `int m = 5*n++`; notice that such an operator returns the old value
    of the variable before it increments/decrements its value, thus having the side
    effect of incrementing the value
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元后缀递增`++`和递减`--`运算符，如`x++`或`x--`，如`int m = 5*n++`; 请注意，这种运算符返回变量在递增/递减其值之前的旧值，因此具有递增值的副作用
- en: A unary prefix with the `++` and `--` operators, such as `++x` or `--x`; unary
    `+` and `-` operators, such as in `+x` or `-x`; the logical operator NOT, such
    as in `!b`, where b is a Boolean variable; unary bitwise NOT `~` (outside the
    scope of this book)
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一元前缀与`++`和`--`运算符，如`++x`或`--x`；一元`+`和`-`运算符，如`+x`或`-x`；逻辑运算符NOT，如`!b`，其中b是布尔变量；一元位NOT
    `~`（超出本书范围）
- en: A cast operator `()`, such as `double x = (double)11/3`, where 11 is cast to
    `double` first, thus avoiding the integer division problem of losing the fractional
    part; the instance creation operator `new`, such as in `new SomeClass()`
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换运算符`()`，如`double x = (double)11/3`，其中11首先转换为`double`，从而避免了整数除法丢失小数部分的问题；实例创建运算符`new`，如`new
    SomeClass()`
- en: Multiplicative operators `*`, `/`, `%`
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法运算符`*`, `/`, `%`
- en: Additive operators `+`, `-`, string concatention `+`
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加法运算符`+`, `-`, 字符串连接`+`
- en: Bitwise shift operators `<<`, `>>`, `>>>`;
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位移运算符`<<`, `>>`, `>>>`;
- en: Relational operators `<`, `>`, `>=`, `<=`, `instanceof`
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系运算符`<`, `>`, `>=`, `<=`, `instanceof`
- en: Equality operators `==`, `!=`
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相等运算符`==`, `!=`
- en: The logical and bitwise operator `&`
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑和位运算符`&`
- en: The bitwise operator `^`
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位运算符`^`
- en: The logical and bitwise operator `|`
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑和位运算符`|`
- en: The conditional operator `&&`
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件运算符`&&`
- en: The conditional operator `||`
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件运算符`||`
- en: The conditional operator `?:` (ternary)
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件运算符`?:`（三元）
- en: The arrow operator `->`
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头运算符`->`
- en: Assignment operators `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `>>=`, `<<=`, `>>>=`,
    `&=`, `^=`, `|=`
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符`=`, `+=`, `-=`, `*=`, `/=`, `%=`, `>>=`, `<<=`, `>>>=`, `&=`, `^=`, `|=`
- en: 'If parentheses are present, then the expression inside the innermost parentheses
    is calculated first. For example, look at this code snippet:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在括号，则首先计算最内层括号内的表达式。例如，看一下这段代码片段：
- en: '```java'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int p1 = 10, p2 = 1;
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: int p1 = 10, p2 = 1;
- en: int q = (p1 += 3)  +  (p2 += 3);
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: int q = (p1 += 3)  +  (p2 += 3);
- en: 'System.out.println(q);         //prints: 17'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(q);         //prints: 17'
- en: 'System.out.println(p1);        //prints: 13'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(p1);        //prints: 13'
- en: 'System.out.println(p2);        //prints: 4'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(p2);        //prints: 4'
- en: '```'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The assignment operators have the lowest precedence, but they are executed
    first if inside the parentheses, as in the preceding code. To prove this point,
    we can remove the first set of parentheses and run the same code again:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符的优先级最低，但如果在括号内，它们将首先执行，如前面的代码。为了证明这一点，我们可以删除第一组括号，然后再次运行相同的代码：
- en: '```java'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: p1 = 10;
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: p1 = 10;
- en: p2 = 1;
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: p2 = 1;
- en: q = p1 += 3  +  (p2 += 3);
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: q = p1 += 3  +  (p2 += 3);
- en: 'System.out.println(q);         //prints: 17'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(q);         //prints: 17'
- en: 'System.out.println(p1);        //prints: 17'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(p1);        //prints: 17'
- en: 'System.out.println(p2);        //prints: 4'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(p2);        //prints: 4'
- en: '```'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, now the first operator assignment `+=` was executed last in
    the right-hand expression.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，现在第一个操作符赋值`+=`在右侧表达式中最后执行。
- en: Using parentheses increases the readability of a complex expression.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 使用括号可以增加复杂表达式的可读性。
- en: You can take advantage of operator precedence and write an expression with very
    few parentheses, if any at all. But the quality of code is defined not only by
    its correctness. Being easy to understand, so that other programmers—maybe not
    so well versed in operator precedence—can maintain it is also one of the criteria
    for well-written code. Besides, even the code's author, after some time, may have
    difficulty trying to understand not-clearly-structured expressions.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以利用运算符优先级并编写一个表达式，其中几乎没有括号，如果有的话。但是，代码的质量不仅取决于其正确性。易于理解，以便其他程序员（也许不太熟悉运算符优先级）可以维护它也是良好编写代码的标准之一。此外，即使是代码的作者，在一段时间后，也可能难以理解结构不清晰的表达式。
- en: Evaluation order of operands
  id: totrans-762
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作数的评估顺序
- en: While evaluating an expression, parentheses and operator precedence are taken
    into account first. Then, those parts of the expression that have the same level
    of execution priority are evaluated as they appear when moving from left to right.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估表达式时，首先考虑括号和运算符优先级。然后，评估具有相同执行优先级的表达式部分，因为它们在从左到右移动时出现。
- en: Using parentheses improves the understanding of a complex expression, but too
    many nested parentheses can obscure it. If in doubt, consider breaking the complex
    expression into several statements.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 使用括号可以改善对复杂表达式的理解，但太多嵌套的括号可能会使其变得模糊。如果有疑问，考虑将复杂表达式分解为几个语句。
- en: 'Eventually, the evaluation comes down to each operator and its operands. Operands
    of a binary operator are evaluated from left to right so that left-hand operand
    is fully evaluated before the evaluation of the right-hand operator starts. As
    we have seen, the left-hand operand can have a side effect that affects the right-hand
    operator''s behavior. Here is a simplistic example:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，评估归结为每个运算符及其操作数。二元运算符的操作数从左到右进行评估，以便在右操作数的评估开始之前完全评估左操作数。正如我们所见，左操作数可能具有影响右操作数行为的副作用。这里是一个简单的例子：
- en: '```java'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int a = 0, b = 0;
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: int a = 0, b = 0;
- en: 'int c = a++ + (a * ++b);       //evaluates to: 0 + (1 * 1);'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: int c = a++ + (a * ++b);       //计算结果为：0 + (1 * 1);
- en: 'System.out.println(c);         //prints: 1'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(c);         //输出：1
- en: '```'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In real-life examples, the expression can include methods with complex functionality
    behind and wide-reaching side effects. The left-hand operand can even throw an
    exception, so the right-hand operand will never be evaluated. But if the left-hand
    evaluation completes without exceptions, Java guarantees that both operands are
    fully evaluated before the operator is executed.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中的例子中，表达式可以包括具有复杂功能和广泛副作用的方法。左操作数甚至可以抛出异常，因此右操作数永远不会被评估。但是，如果左操作数的评估在没有异常的情况下完成，Java保证在执行运算符之前会完全评估两个操作数。
- en: 'This rule does not apply though to conditional operators `&&`, `||`, and `?:` (see
    the *Conditional operators: && || ? : (ternary)* section).'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '这个规则不适用于条件运算符`&&`、`||`和`?:`（参见*条件运算符：&& || ? : (三元)*部分）。'
- en: Widening and narrowing reference types
  id: totrans-773
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展和缩小引用类型
- en: In the case of reference types, assigning a child object reference to the variable
    of the parent class type is called widening reference conversion or upcasting.
    The assigning of a parent class type reference to the variable of a child class
    type is called narrowing reference conversion or downcasting.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用类型的情况下，将子对象引用分配给父类类型的变量称为扩展引用转换或向上转换。将父类类型引用分配给子类类型的变量称为缩小引用转换或向下转换。
- en: Widening
  id: totrans-775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: 'For example, if a class, `SomeClass`, extends `SomeBaseClass`, the following
    declaration and initialization are possible:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个类`SomeClass`扩展了`SomeBaseClass`，则以下声明和初始化也是可能的：
- en: '```java'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: SomeBaseClass someBaseClass = new SomeBaseClass();
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: SomeBaseClass someBaseClass = new SomeBaseClass();
- en: someBaseClass = new SomeClass();
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: someBaseClass = new SomeClass();
- en: '```'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And, since every class extends the `java.lang.Object` class by default, the
    following declarations and initializations are possible too:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，由于每个类默认都扩展了`java.lang.Object`类，因此以下声明和初始化也是可能的：
- en: '```java'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Object someBaseClass = new SomeBaseClass();
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: Object someBaseClass = new SomeBaseClass();
- en: someBaseClass = new SomeClass();             //line 2
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们将子类实例引用分配给了超类类型的变量。子类中存在但在超类中不存在的方法无法通过超类类型的引用访问。第2行的赋值被称为引用的扩展，因为它变得不太专业化。
- en: '```'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In line 2, we assigned a subclass instance reference to a variable of a superclass
    type. Methods present in a subclass but not in the superclass are not accessible
    via the reference of the superclass type. The assignment in line 2 is called a
    widening of the reference because it becomes less specialized.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们将子类实例引用分配给了超类类型的变量。子类中存在但在超类中不存在的方法无法通过超类类型的引用访问。第2行的赋值被称为引用的扩展，因为它变得不太专业化。
- en: Narrowing
  id: totrans-787
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩小
- en: Assigning a parent object reference to the variable of the child class type
    is called narrowing reference conversion or downcasting. It is possible only after
    widening reference conversion has been applied first.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 将父对象引用分配给子类类型的变量称为缩小引用转换或向下转换。只有在应用了扩展引用转换之后才可能发生。
- en: 'Here is a code example that demonstrates the case:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个演示情况的代码示例：
- en: '```java'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class SomeBaseClass{
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: class SomeBaseClass{
- en: void someMethod(){
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: void someMethod(){
- en: '...'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class SomeClass extends SomeBaseClass{
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: class SomeClass extends SomeBaseClass{
- en: void someOtherMethod(){
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: void someOtherMethod(){
- en: '...'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '}'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: SomeBaseClass someBaseClass = new SomeBaseClass();
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: SomeBaseClass someBaseClass = new SomeBaseClass();
- en: someBaseClass = new SomeClass();
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: someBaseClass = new SomeClass();
- en: someBaseClass.someMethod();                  //works just fine
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: someBaseClass.someMethod();                  //完全正常工作
- en: //someBaseClass.someOtherMethod();           //compilation error
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: //someBaseClass.someOtherMethod();           //编译错误
- en: ((SomeClass)someBaseClass).someOtherMethod(); //works just fine
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: ((SomeClass)someBaseClass).someOtherMethod(); //完全正常工作
- en: '//The following methods are available as they come from Object:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: //以下方法可用，因为它们来自Object：
- en: int h = someBaseClass.hashCode();
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: int h = someBaseClass.hashCode();
- en: Object o = someBaseClass.clone();
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: Object o = someBaseClass.clone();
- en: //All other public Object's methods are accessible too
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: //所有其他公共Object的方法也是可访问的
- en: '```'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The narrowing conversion requires casting, and we discussed this in great detail
    when we talked about the cast operator (see the *Cast operator* section), including
    casting to an interface, which is another form of upcasting.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小转换需要转换，当我们讨论转换运算符时，我们已经详细讨论过这一点（参见*转换运算符*部分），包括转换为接口，这是另一种向上转换的形式。
- en: Widening and narrowing conversion of primitive types
  id: totrans-812
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型的扩展和缩小转换
- en: When a value (or variable) of one numeric type is assigned to a variable of
    another numeric type, the new type may hold a bigger number or smaller maximum
    number. If the target type can hold a bigger number, the conversion is widening.
    If otherwise, it is a narrowing conversion, which usually requires a typecasting
    using a cast operator.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个数值类型的值（或变量）被赋给另一个数值类型的变量时，新类型可能包含一个更大的数字或更小的最大数字。如果目标类型可以容纳更大的数字，则转换是扩展的。否则，它是一个缩小的转换，通常需要使用转换运算符进行类型转换。
- en: Widening
  id: totrans-814
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: 'The maximum number a numeric type can hold is determined by the number of bits
    allocated to this type. To remind you, here is the number of bits for each numeric
    type representation:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 数值类型可以容纳的最大数字由分配给该类型的位数确定。为了提醒您，这里是每种数值类型表示的位数：
- en: '`byte`: 8 bit'
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte`：8位'
- en: '`char`: 16 bit'
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`：16位'
- en: '`short`: 16 bit'
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`：16位'
- en: '`int`: 32 bit'
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：32位'
- en: '`long`: 64 bit'
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`：64位'
- en: '`float`: 32 bit'
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：32位'
- en: '`double`: 64 bit'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`：64位'
- en: 'The Java Specification defines 19 widening primitive conversions:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: Java规范定义了19种扩展原始转换：
- en: '`byte` to `short`, `int`, `long`, `float`, or `double`'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byte` 到 `short`，`int`，`long`，`float`，或 `double`'
- en: '`short` to `int`, `long`, `float`, or `double`'
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short` 到 `int`，`long`，`float`，或 `double`'
- en: '`char` to `int`, `long`, `float`, or `double`'
  id: totrans-826
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 到 `int`，`long`，`float`，或 `double`'
- en: '`int` to `long`, `float`, or `double`'
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 到 `long`，`float`，或 `double`'
- en: '`long` to `float` or `double`'
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long` 到 `float` 或 `double`'
- en: '`float` to `double`'
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float` 到 `double`'
- en: 'In widening conversions between integral types and some conversions from integral
    types to floating-point values, the resulting value remains the same as the original
    one. But conversion from `int` to `float`, or from `long` to `float`, or from
    `long` to `double`, may result, according to the specification:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 在整数类型之间的扩展转换和一些整数类型到浮点值的一些转换中，结果值保持与原始值相同。但是，从 `int` 到 `float`，或从 `long` 到 `float`，或从
    `long` 到 `double`，根据规范可能会导致：
- en: '"in loss of precision - that is, the result may lose some of the least significant
    bits of the value. In this case, the resulting floating-point value will be a
    correctly rounded version of the integer value, using IEEE 754 round-to-nearest
    mode."'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: “在精度损失方面 - 也就是说，结果可能会丢失一些值的最低有效位。在这种情况下，得到的浮点值将是整数值的正确舍入版本，使用IEEE 754最接近模式。”
- en: 'Let''s look at this effect through code examples and start with `int` type
    conversion to `float` and `double`:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码示例来看一下这种效果，首先从 `int` 类型转换到 `float` 和 `double` 开始：
- en: '```java'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int n = 1234567899;
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: int n = 1234567899;
- en: float f = (float)n;
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: float f = (float)n;
- en: int r = n - (int)f;
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: int r = n - (int)f;
- en: 'System.out.println(r);    //prints: -46'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(r);    //输出：-46
- en: double d = (double)n;
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: double d = (double)n;
- en: r = n - (int)d;
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: r = n - (int)d;
- en: 'System.out.println(r);    //prints: 0'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(r);    //输出：0
- en: '```'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As the specification stated, only the conversion from `int` to `float` has
    lost precision. Conversion from `int` to `double` was just fine. Now, let''s convert `long` type:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 正如规范所述，只有从 `int` 到 `float` 的转换丢失了精度。从 `int` 到 `double` 的转换很好。现在，让我们转换 `long`
    类型：
- en: '```java'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: long l = 1234567899123456L;
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: long l = 1234567899123456L;
- en: float f = (float)l;
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数 f = (float)l;
- en: long rl = l - (long)f;
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: long rl = l - (long)f;
- en: 'System.out.println(rl);    //prints: -49017088'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(rl);    //输出：-49017088
- en: double d = (double)l;
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: double d = (double)l;
- en: rl = l - (long)d;
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: rl = l - (long)d;
- en: 'System.out.println(rl);    //prints: 0'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(rl);    //输出：0
- en: l = 12345678991234567L;
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: l = 12345678991234567L;
- en: d = (double)l;
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: d = (double)l;
- en: rl = l - (long)d;
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: rl = l - (long)d;
- en: 'System.out.println(rl);    //prints: -1'
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(rl);    //输出：-1
- en: '```'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Conversion from `long` to `float` lost precision big time. Well, the specification
    warned us about it. But conversion from `long` to `double` looked fine at first.
    Then, we increased the `long` value approximately ten times and got a precision
    loss of `-1`. So, it depends on how big the value is too.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `long` 到 `float` 的转换严重丢失了精度。规范警告了我们。但是从 `long` 到 `double` 的转换一开始看起来很好。然后，我们将
    `long` 值增加了大约十倍，得到了 `-1` 的精度损失。所以，这也取决于值有多大。
- en: Despite that, the Java specification does not allow any runtime exceptions caused
    by widening conversion. In our examples, we did not encounter an exception either.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Java规范不允许由扩展转换引起的任何运行时异常。在我们的例子中，我们也没有遇到异常。
- en: Narrowing
  id: totrans-858
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩小
- en: 'The narrowing conversion of numeric primitive types occurs in the opposite
    direction—from the wider type to the narrower one—and typically requires casting.
    The Java specification identifies 22 narrowing primitive conversions:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 数值原始类型的缩小转换是相反的，从更宽的类型到更窄的类型，通常需要转换。Java规范确定了22种缩小的原始转换：
- en: '`short` to `byte` or `char`'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short` 到 `byte` 或 `char`'
- en: '`char` to `byte` or `short`'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char` 到 `byte` 或 `short`'
- en: '`int` to `byte`, `short`, or `char`'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 到 `byte`，`short`，或 `char`'
- en: '`long` to `byte`, `short`, `char`, or `int`'
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long` 到 `byte`，`short`，`char`，或 `int`'
- en: '`float` to `byte`, `short`, `char`, `int`, or `long`'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float` 到 `byte`，`short`，`char`，`int`，或 `long`'
- en: '`double` to `byte`, `short`, `char`, `int`, `long`, or `float`'
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double` 到 `byte`，`short`，`char`，`int`，`long`，或 `float`'
- en: 'It can result in a loss of magnitude of the value and possibly in loss of precision
    too. The narrowing procedure is more complicated than the widening one and discussion
    of it is beyond the scope of an introductory course. The least one can do is to
    make sure that the original value is smaller than the maximum value of the target
    type:'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能导致值的大小和可能导致精度的损失。缩小过程比扩展过程更复杂，讨论它超出了入门课程的范围。至少可以做的是确保原始值小于目标类型的最大值：
- en: '```java'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: double dd = 1234567890.0;
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: double dd = 1234567890.0;
- en: 'System.out.println(Integer.MAX_VALUE); //prints: 2147483647'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Integer.MAX_VALUE); //输出：2147483647
- en: if(dd < Integer.MAX_VALUE){
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 dd < Integer.MAX_VALUE：
- en: int nn = (int)dd;
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: int nn = (int)dd;
- en: 'System.out.println(nn);              //prints: 1234567890'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(nn); //输出：1234567890
- en: '} else {'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: System.out.println(dd - Integer.MAX_VALUE);
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(dd - Integer.MAX_VALUE);
- en: '}'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: dd = 2234567890.0;
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: dd = 2234567890.0;
- en: 'System.out.println(Integer.MAX_VALUE); //prints: 2147483647'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(Integer.MAX_VALUE); //输出：2147483647
- en: if(dd < Integer.MAX_VALUE){
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: if(dd < Integer.MAX_VALUE){
- en: int nn = (int)dd;
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: int nn = (int)dd;
- en: System.out.println(nn);
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(nn);
- en: '} else {'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: 'System.out.println(dd - Integer.MAX_VALUE); //prints: 8.7084243E7'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(dd - Integer.MAX_VALUE); //输出：8.7084243E7
- en: '}'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see from these examples, the narrowing conversion happens just fine
    when the number fits the target type, but we even do not try to convert if the
    original value is bigger than the maximum value of the target type.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些示例中可以看出，当数字适合目标类型时，缩小转换就可以很好地进行，但是如果原始值大于目标类型的最大值，我们甚至不会尝试进行转换。
- en: Before casting, think about the maximum value the target type can hold, especially
    while narrowing the value type.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行强制转换之前，考虑一下目标类型可以容纳的最大值，特别是在缩小值类型时。
- en: But there is more to it than just avoiding complete loss of value. Things get
    especially complicated with the conversion between type `char` and types `byte`
    or `short`. The reason for this is that type `char` is an unsigned numeric type,
    while types byte and short are signed numeric types, so some loss of information
    is possible.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，避免完全丢失值并不是全部。在`char`类型和`byte`或`short`类型之间的转换中，事情变得特别复杂。其原因在于`char`类型是无符号数值类型，而`byte`和`short`类型是有符号数值类型，因此可能会丢失一些信息。
- en: Methods of primitive type conversion
  id: totrans-888
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型转换的方法
- en: Casting is not the only way to convert one primitive type to another. Each of
    the primitive types has a corresponding reference type – a class called a wrapper
    class of a primitive type.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 强制转换并不是将一个原始类型转换为另一个类型的唯一方法。每种原始类型都有一个对应的引用类型 - 称为原始类型的包装类的类。
- en: 'All wrapper classes are located in the `java.lang` package:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 所有包装类都位于`java.lang`包中：
- en: '`java.lang.Boolean`'
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Boolean`'
- en: '`java.lang.Byte`'
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Byte`'
- en: '`java.lang.Character`'
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Character`'
- en: '`java.lang.Short`'
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Short`'
- en: '`java.lang.Integer`'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Integer`'
- en: '`java.lang.Long`'
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Long`'
- en: '`java.lang.Float`'
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Float`'
- en: '`java.lang.Double`'
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang.Double`'
- en: 'Most of them—except the `Boolean` and `Character` classes—extend the `java.lang.Number` class, which
    has the following abstract method declarations:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 它们中的大多数（除了`Boolean`和`Character`类）都扩展了`java.lang.Number`类，该类具有以下抽象方法声明：
- en: '`byteValue()`'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`byteValue()`'
- en: '`shortValue()`'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shortValue()`'
- en: '`intValue()`'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`intValue()`'
- en: '`longValue()`'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`longValue()`'
- en: '`floatValue()`'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`floatValue()`'
- en: '`doubleValue()`'
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doubleValue()`'
- en: This means that every `Number` class child has to implement all of them. Such
    methods are implemented in the `Character` class too, while the `Boolean` class
    has the `booleanValue()` method. These methods can be used to widen and narrow primitive
    types too.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个`Number`类子类都必须实现所有这些方法。这些方法也在`Character`类中实现，而`Boolean`类具有`booleanValue()`方法。这些方法也可以用于扩大和缩小原始类型。
- en: 'In addition, each of the wrapper classes has methods that allow the conversion
    of `String` representation of a numeric value to the corresponding primitive numeric
    type or reference type, for example:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个包装类都有方法，允许将数值的`String`表示转换为相应的原始数值类型或引用类型，例如：
- en: '```java'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: byte b = Byte.parseByte("3");
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: byte b = Byte.parseByte("3");
- en: Byte bt = Byte.decode("3");
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: Byte bt = Byte.decode("3");
- en: boolean boo = Boolean.getBoolean("true");
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: boolean boo = Boolean.getBoolean("true");
- en: Boolean bool = Boolean.valueOf("false");
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: Boolean bool = Boolean.valueOf("false");
- en: int n = Integer.parseInt("42");
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: int n = Integer.parseInt("42");
- en: Integer integer = Integer.getInteger("42");
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: Integer integer = Integer.getInteger("42");
- en: double d1 = Double.parseDouble("3.14");
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: double d1 = Double.parseDouble("3.14");
- en: Double d2 = Double.valueOf("3.14");
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: Double d2 = Double.valueOf("3.14");
- en: '```'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: After that, the previously listed methods (`byteValue()`, `shortValue()`, and
    so on) can be used to convert the value to another primitive type.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，可以使用先前列出的方法（`byteValue()`，`shortValue()`等）将值转换为另一种原始类型。
- en: 'And each of the wrapper classes has the static method `toString(primitive value)`
    to convert the primitive type value to its `String` representation:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包装类都有静态方法`toString(原始值)`，将原始类型值转换为其`String`表示：
- en: '```java'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String s1 = Integer.toString(42);
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: String s1 = Integer.toString(42);
- en: String s2 = Double.toString(3.14);
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: String s2 = Double.toString(3.14);
- en: '```'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The wrapper classes have many other useful methods of conversion from one primitive
    type to another, and to different formats and representations. So, if you need
    to something like that, look in the `java.lang` package at its numeric type class
    wrappers first.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 包装类有许多其他有用的方法，可以将一种原始类型转换为另一种原始类型，以及不同的格式和表示形式。因此，如果需要这样的功能，请首先查看`java.lang`包中的其数值类型类包装器。
- en: One of the type conversions allows for creating a wrapper class object from
    the corresponding primitive type and vice versa. We will discuss such conversions
    in the next section.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种类型转换允许从相应的原始类型创建包装类对象，反之亦然。我们将在下一节讨论这样的转换。
- en: Boxing and unboxing between primitive and reference types
  id: totrans-926
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型和引用类型之间的装箱和拆箱
- en: Boxing converts the value of a primitive type to an object of a corresponding
    wrapper class. Unboxing converts the object of a wrapper class to a value of the
    corresponding primitive type.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 装箱将原始类型的值转换为相应包装类的对象。拆箱将包装类的对象转换为相应原始类型的值。
- en: Boxing
  id: totrans-928
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装箱
- en: 'Boxing a primitive type can be done either automatically (called autoboxing)
    or explicitly using the `valueOf()` method available in each wrapper type:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 装箱原始类型可以通过自动方式（称为自动装箱）或显式地使用每个包装类型中可用的`valueOf()`方法来完成：
- en: '```java'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int n = 12;
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: int n = 12;
- en: Integer integer = n; //an example of autoboxing
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: Integer integer = n; //自动装箱的示例
- en: 'System.out.println(integer);      //prints: 12'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(integer); //输出：12
- en: integer = Integer.valueOf(n);
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: integer = Integer.valueOf(n);
- en: 'System.out.println(integer);      //prints: 12'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(integer); //输出：12
- en: Byte b = Byte.valueOf((byte)n);
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: Byte b = Byte.valueOf((byte)n);
- en: Short s = Short.valueOf((short)n);
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: Short s = Short.valueOf((short)n);
- en: Long l = Long.valueOf(n);
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: Long l = Long.valueOf(n);
- en: Float f = Float.valueOf(n);
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: Float f = Float.valueOf(n);
- en: Double d = Double.valueOf(n);
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: Double d = Double.valueOf（n）;
- en: '```'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that the input value of the `valueOf()` method of the `Byte` and `Short`
    wrappers required casting because it was a narrowing of a primitive type, which
    we discussed in the previous section.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Byte`和`Short`包装器的`valueOf()`方法的输入值需要转换，因为它是原始类型的缩小，这是我们在上一节中讨论的。
- en: Unboxing
  id: totrans-943
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆箱
- en: 'Unboxing can be accomplished using the methods of the `Number` class implemented
    in each wrapper class:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 拆箱可以使用每个包装类中实现的`Number`类的方法来完成：
- en: '```java'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Integer integer = Integer.valueOf(12);
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: Integer integer = Integer.valueOf（12）;
- en: 'System.out.println(integer.intValue());    //prints: 12'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（integer.intValue（））; //打印：12
- en: 'System.out.println(integer.byteValue());   //prints: 12'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（integer.byteValue（））; //打印：12
- en: 'System.out.println(integer.shortValue());  //prints: 12'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（integer.shortValue（））; //打印：12
- en: 'System.out.println(integer.longValue());   //prints: 12'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（integer.longValue（））; //打印：12
- en: 'System.out.println(integer.floatValue());  //prints: 12.0'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（integer.floatValue（））; //打印：12.0
- en: 'System.out.println(integer.doubleValue()); //prints: 12.0'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（integer.doubleValue（））; //打印：12.0
- en: '```'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Similar to autoboxing, automatic unboxing is possible too:'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于自动装箱，也可以自动拆箱：
- en: '```java'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Long longWrapper = Long.valueOf(12L);
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: Long longWrapper = Long.valueOf（12L）;
- en: long lng = longWrapper;    //implicit unboxing
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: long lng = longWrapper; //隐式拆箱
- en: 'System.out.println(lng);   //prints: 12'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（lng）; //打印：12
- en: '```'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But, it is not called autounboxing. The term implicit unboxing is used instead.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它不被称为自动装箱。而是使用隐式拆箱这个术语。
- en: Method equals() of reference types
  id: totrans-961
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型的equals()方法
- en: 'The equality operator, when applied to reference types, compares the reference
    values, not the content of the objects. It returns `true` only when both references
    (variable values) point to the same object. We have demonstrated it several times
    already:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于引用类型时，等式运算符比较引用值，而不是对象的内容。只有当两个引用（变量值）指向同一个对象时，它才返回`true`。我们已经多次证明了这一点：
- en: '```java'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: SomeClass o1 = new SomeClass();
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass o1 = new SomeClass（）;
- en: SomeClass o2 = new SomeClass();
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: SomeClass o2 = new SomeClass（）;
- en: 'System.out.println(o1 == o2);  //prints: false'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（o1 == o2）; //打印：false
- en: 'System.out.println(o1 == o1);  //prints: true'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（o1 == o1）; //打印：true
- en: o2 = o1;
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: o2 = o1;
- en: 'System.out.println(o1 == o2);  //prints: true'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（o1 == o2）; //打印：真
- en: '```'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: This means that the equality operator returns `false` even when two objects
    of the same class with the same field values are compared. That is often not what
    programmers need. Instead, we usually need to consider two objects to be equal
    when they have the same type and the same field values. Sometimes, we even do
    not want to consider all the fields, but only those that identify the object as
    unique in our program logic. For example, if a person changes their hairstyle
    or dress, we still identify him or her as the same person, even if an object that
    describes the person has the field `hairstyle` or `dress`.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着即使比较具有相同字段值的相同类的两个对象时，等式运算符也会返回`false`。这通常不是程序员所需要的。相反，我们通常需要在两个对象具有相同类型和相同字段值时将它们视为相等。有时，我们甚至不想考虑所有字段，而只想考虑那些在程序逻辑中唯一标识对象的字段。例如，如果一个人改变了发型或服装，我们仍然认为他或她是同一个人，即使描述该人的对象具有字段`hairstyle`或`dress`。
- en: Using the implementation of the base class Object
  id: totrans-972
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用基类Object的实现
- en: 'For such a comparison of objects—by the value of their fields—the `equals()` method is
    to be used. In [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml), *Java
    Language Basics*, we already established that all reference types extend (implicitly)
    the `java.lang.Object` class, which has the `equals()` method implemented:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种对象的比较-按照它们的字段值-应使用`equals()`方法。在[第2章](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml)中，*Java语言基础*，我们已经确定所有引用类型都扩展（隐式）`java.lang.Object`类，该类已实现了`equals()`方法：
- en: '```java'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public boolean equals(Object obj) {
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 公共布尔equals（Object obj）{
- en: return (this == obj);
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 返回（this == obj）;
- en: '}'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, it compares only references using the equality operator, which
    means that if a class or one of its parents does not implement the `equals()` method (which
    overrides the implementation of the `Object` class), the result of using the `equals()` method will
    be the same as using the equality operator `==`. Let''s demonstrate this. The
    following class does not implement the `equals()` method:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它只使用相等运算符比较引用，这意味着如果一个类或其父类没有实现`equals()`方法（覆盖`Object`类的实现），使用`equals()`方法的结果将与使用相等运算符`==`相同。让我们来演示一下。以下类没有实现`equals()`方法：
- en: '```java'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class PersonNoEquals {
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 类PersonNoEquals {
- en: private int age;
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 私有int年龄;
- en: private String name;
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字符串名称;
- en: public PersonNoEquals(int age, String name) {
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: public PersonNoEquals（int age，String name）{
- en: this.age = age;
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 这个年龄=年龄;
- en: this.name = name;
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名字 = 名字;
- en: '}'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we use it and compare the results of the `equals()` method and the `==` operator,
    we will see the following:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用它并比较`equals()`方法和`==`运算符的结果，我们将看到以下结果：
- en: '```java'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: PersonNoEquals p1 = new PersonNoEquals(42, "Nick");
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: PersonNoEquals p1 = new PersonNoEquals（42，“Nick”）;
- en: PersonNoEquals p2 = new PersonNoEquals(42, "Nick");
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: PersonNoEquals p2 = new PersonNoEquals（42，“Nick”）;
- en: PersonNoEquals p3 = new PersonNoEquals(25, "Nick");
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: PersonNoEquals p3 = new PersonNoEquals（25，“Nick”）;
- en: System.out.println(p1.equals(p2));     //false
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（p1.equals（p2））; //假
- en: System.out.println(p1.equals(p3));     //false
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（p1.equals（p3））; //假
- en: System.out.println(p1 == p2);          //false
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（p1 == p2）; //假
- en: p1 = p2;
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: p1 = p2;
- en: System.out.println(p1.equals(p2));     //true
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（p1.equals（p2））; //真
- en: System.out.println(p1 == p2);          //true
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println（p1 == p2）; //真
- en: '```'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As we expected, the results are the same, whether we use the `equals()` method or
    the `==` operator.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，无论我们使用`equals()`方法还是`==`运算符，结果都是相同的。
- en: Overriding the equals() method
  id: totrans-1003
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖equals()方法
- en: 'Now, let''s implement the `equals()` method:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现`equals()`方法：
- en: '```java'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class PersonWithEquals{
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 类PersonWithEquals{
- en: private int age;
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 私有int年龄;
- en: private String name;
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字符串名称;
- en: private String hairstyle;
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字符串发型;
- en: public PersonWithEquals(int age, String name, String hairstyle) {
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: public PersonWithEquals(int age, String name, String hairstyle) {
- en: this.age = age;
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 这个年龄=年龄；
- en: this.name = name;
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名字=名字；
- en: this.hairstyle = hairstyle;
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 这个发型=发型；
- en: '}'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public boolean equals(Object o) {
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean equals(Object o) {
- en: if (this == o) return true;
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 如果(this == o)返回true；
- en: if (o == null || getClass() != o.getClass()) return false;
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 如果(o == null || getClass() != o.getClass())返回false；
- en: PersonWithEquals person = (PersonWithEquals) o;
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: PersonWithEquals person = (PersonWithEquals) o;
- en: return age == person.age && Objects.equals(name, person.name);
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 返回年龄==人.年龄&&对象.equals(名字，人.名字)；
- en: '}'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Notice that, while establishing the objects'' equality, we ignore the `hairstyle` field.
    Another aspect that requires comments is the use of the `equals()` method of the `java.utils.Objects` class.
    Here is its implementation:'
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当建立对象的相等性时，我们忽略了“发型”字段。需要评论的另一个方面是使用“java.utils.Objects”类的“equals()”方法。以下是它的实现：
- en: '```java'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public static boolean equals(Object a, Object b) {
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: public static boolean equals(Object a, Object b) {
- en: return (a == b) || (a != null && a.equals(b));
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 返回(a == b) || (a != null && a.equals(b));
- en: '}'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, it compares references first, then makes sure that one is not
    `null` (to avoid `NullPointerException`), then uses the `equals()` method of the `java.lang.Object` base
    class or the overriding implementation that might be present in a child passed
    in as a parameter value.  In our case, we pass in parameter objects of type `String`
    that do have the `equals()` method implemented, which compares `String` type values,
    not just references (we will talk about it shortly). So, any difference in any
    field of objects, `PersonWithEquals`, will cause the method to return `false`.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它首先比较引用，然后确保一个不是“null”（以避免“NullPointerException”），然后使用“java.lang.Object”基类的“equals()”方法或可能存在的子类中的重写实现作为参数值传递。在我们的情况下，我们传递了类型为“String”的参数对象，它们已经实现了“equals()”方法，用于比较“String”类型的值，而不仅仅是引用（我们将很快讨论它）。因此，“PersonWithEquals”对象的任何字段的任何差异都将导致该方法返回false。
- en: 'If we run the test again, we will see this:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行测试，我们将看到这个：
- en: '```java'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: PersonWithEquals p11 = new PersonWithEquals(42, "Kelly", "Ponytail");
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: PersonWithEquals p11 = new PersonWithEquals(42，"Kelly"，"Ponytail");
- en: PersonWithEquals p12 = new PersonWithEquals(42, "Kelly", "Pompadour");
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: PersonWithEquals p12 = new PersonWithEquals(42，"Kelly"，"Pompadour");
- en: PersonWithEquals p13 = new PersonWithEquals(25, "Kelly", "Ponytail");
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: PersonWithEquals p13 = new PersonWithEquals(25，"Kelly"，"Ponytail");
- en: System.out.println(p11.equals(p12));    //true
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p11.equals(p12)); //true
- en: System.out.println(p11.equals(p13));    //false
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p11.equals(p13)); //false
- en: System.out.println(p11 == p12);         //false
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p11 == p12); //false
- en: p11 = p12;
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: p11 = p12;
- en: System.out.println(p11.equals(p12));    //true
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p11.equals(p12)); //true
- en: System.out.println(p11 == p12);         //true
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p11 == p12); //true
- en: '```'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Now, the `equals()` method returns `true` not only when references are equal
    (so they point to the same object), but also when the references are different
    but the objects they refer to have the same type and the same values of certain
    fields that are included in the object identification.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，“equals()”方法不仅在引用相等时返回true（因此它们指向相同的对象），而且在引用不同但它们引用的对象具有相同类型和包含在对象标识中的某些字段的相同值时也返回true。
- en: Using the identification implemented in the parent class
  id: totrans-1044
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用在父类中实现的标识
- en: 'We could create a base class, `Person`, that has only the two fields `age`
    and `name` and the `equals()` method, as implemented previously. Then, we could
    extend it with the `PersonWithHair` class (which has the additional field `hairstyle`):'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个基类“Person”，它只有两个字段“年龄”和“名字”，以及“equals()”方法，如前所述实现。然后，我们可以用“PersonWithHair”类扩展它（它有额外的字段“发型”）：
- en: '```java'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class Person{
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 类Person{
- en: private int age;
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 私人年龄；
- en: private String name;
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 私人名字；
- en: public Person(int age, String name) {
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: public Person(int age, String name) {
- en: this.age = age;
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 这个年龄=年龄；
- en: this.name = name;
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名字=名字；
- en: '}'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@Override'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public boolean equals(Object o) {
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean equals(Object o) {
- en: if (this == o) return true;
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: if (this == o) return true;
- en: if (o == null || getClass() != o.getClass()) return false;
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 如果(o == null || getClass() != o.getClass())返回false；
- en: Person person = (Person) o;
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 人=（人）o；
- en: return age == person.age && Objects.equals(name, person.name);
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 返回年龄==人.年龄&&对象.equals(名字，人.名字)；
- en: '}'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: class PersonWithHair extends Person{
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 类PersonWithHair扩展自Person{
- en: private String hairstyle;
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 私人发型；
- en: public PersonWithHair(int age, String name, String hairstyle) {
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: public PersonWithHair(int age, String name, String hairstyle) {
- en: super(age, name);
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 超级(年龄，名字)；
- en: this.hairstyle = hairstyle;
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 这个发型=发型；
- en: '}'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The objects of the `PersonWithHair` class would compare the same way as in
    the previous test of `PersonWithEquals`:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: “PersonWithHair”的对象将与“PersonWithEquals”的先前测试中的方式进行比较。
- en: '```java'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: PersonWithHair p21 = new PersonWithHair(42, "Kelly", "Ponytail");
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: PersonWithHair p21 = new PersonWithHair(42，"Kelly"，"Ponytail");
- en: PersonWithHair p22 = new PersonWithHair(42, "Kelly", "Pompadour");
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: PersonWithHair p22 = new PersonWithHair(42，"Kelly"，"Pompadour");
- en: PersonWithHair p23 = new PersonWithHair(25, "Kelly", "Ponytail");
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: PersonWithHair p23 = new PersonWithHair(25，"Kelly"，"Ponytail");
- en: System.out.println(p21.equals(p22));    //true
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p21.equals(p22)); //true
- en: System.out.println(p21.equals(p23));    //false
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p21.equals(p23)); //false
- en: System.out.println(p21 == p22);         //false
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p21 == p22); //false
- en: p21 = p22;
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: p21 = p22;
- en: System.out.println(p21.equals(p22));    //true
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p21.equals(p22)); //true
- en: System.out.println(p21 == p22);         //true
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p21 == p22); //true
- en: '```'
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'That is possible because an object of `PersonWithHair` is of a type `Person`
    too, so take this line:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可能的，因为“PersonWithHair”的对象也是“Person”的类型，所以接受这一行：
- en: '```java'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person person = (Person) o;
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 人=（人）o；
- en: '```'
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The preceding line in the `equals()` method does not throw `ClassCastException`.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: “equals()”方法中的前一行不会抛出“ClassCastException”。
- en: 'We can then create the `PersonWithHairDresssed` class:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以创建“PersonWithHairDresssed”类：
- en: '```java'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: PersonWithHairDressed extends PersonWithHair{
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: PersonWithHairDressed扩展自PersonWithHair{
- en: private String dress;
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 私人穿着；
- en: public PersonWithHairDressed(int age, String name,
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: public PersonWithHairDressed(int age, String name,
- en: String hairstyle, String dress) {
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 发型，穿着) {
- en: super(age, name, hairstyle);
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 超级(年龄，名字，发型)；
- en: this.dress = dress;
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: this.dress = dress;
- en: '}'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'If we run the same test again, it will yield the same results. But we think
    that dress and hairstyle are not part of the identification, so we can run the
    test to compare the children of `Person`:'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行相同的测试，结果将是一样的。但我们认为服装和发型不是身份识别的一部分，所以我们可以运行测试来比较`Person`的孩子们：
- en: '```java'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person p31 = new PersonWithHair(42, "Kelly", "Ponytail");
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: Person p31 = new PersonWithHair(42, "Kelly", "Ponytail");
- en: Person p32 = new PersonWithHairDressed(42, "Kelly", "Pompadour", "Suit");
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: Person p32 = new PersonWithHairDressed(42, "Kelly", "Pompadour", "Suit");
- en: Person p33 = new PersonWithHair(25, "Kelly", "Ponytail");
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: Person p33 = new PersonWithHair(25, "Kelly", "Ponytail");
- en: System.out.println(p31.equals(p32));    //false
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p31.equals(p32));    //false
- en: System.out.println(p31.equals(p33));    //false
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p31.equals(p33));    //false
- en: System.out.println(p31 == p32);         //false
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p31 == p32);         //false
- en: '```'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'That was not what we expected! The children were considered not equal because
    of this line in the `equals()` method of the `Person` base class:'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们期望的！孩子们被认为不相等，因为在`Person`基类的`equals()`方法中有这行：
- en: '```java'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: if (o == null || getClass() != o.getClass()) return false;
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: if (o == null || getClass() != o.getClass()) return false;
- en: '```'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The preceding line failed because the `getClass()` and `o.getClass()` methods return
    the child class name – the one that was instantiated with the `new` operator.
    To get out of this jam, we use the following logic:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行失败了，因为`getClass()`和`o.getClass()`方法返回的是子类名 - 使用`new`操作符实例化的类。为了摆脱这个困境，我们使用以下逻辑：
- en: Our implementation of the `equals()` method is located in the `Person` class,
    so we know that the current object is of type `Person`
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`equals()`方法的实现位于`Person`类中，所以我们知道当前对象是`Person`类型
- en: To compare classes, all we need to do is to make sure that the other object
    is of type `Person` too
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要比较类，我们只需要确保另一个对象也是`Person`类型
- en: 'If we replace this line:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们替换这行：
- en: '```java'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: if (o == null || getClass() != o.getClass()) return false;
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: if (o == null || getClass() != o.getClass()) return false;
- en: '```'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'With the following code:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码：
- en: '```java'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: if (o == null) return false;
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: if (o == null) return false;
- en: if(!(o instanceof Person)) return false;
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: if(!(o instanceof Person)) return false;
- en: '```'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result will be this:'
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是这样的：
- en: '```java'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person p31 = new PersonWithHair(42, "Kelly", "Ponytail");
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: Person p31 = new PersonWithHair(42, "Kelly", "Ponytail");
- en: Person p32 = new PersonWithHairDressed(42, "Kelly", "Pompadour", "Suit");
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: Person p32 = new PersonWithHairDressed(42, "Kelly", "Pompadour", "Suit");
- en: Person p33 = new PersonWithHair(25, "Kelly", "Ponytail");
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: Person p33 = new PersonWithHair(25, "Kelly", "Ponytail");
- en: System.out.println(p31.equals(p32));    //true
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p31.equals(p32));    //true
- en: System.out.println(p31.equals(p33));    //false
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p31.equals(p33));    //false
- en: System.out.println(p31 == p32);         //false
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(p31 == p32);         //false
- en: '```'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: That is what we wanted, didn't we? This way, we have achieved the original idea
    of not including hairstyle and dress in the person's identification.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们想要的，不是吗？这样，我们已经实现了最初的想法，即不包括发型和服装在人的身份识别中。
- en: In the case of object references, the equality operators `==` and `!=` compare
    the references themselves - not the values of the objects' fields (states). If
    you need to compare object states, use the `equals()` method that has overridden
    the one in the `Object` class.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象引用的情况下，等号运算符`==`和`!=`比较的是引用本身 - 而不是对象字段（状态）的值。如果需要比较对象状态，请使用重写了`Object`类中的`equals()`方法。
- en: The `String` class and the wrapper classes of primitive types override the `equals()` method too.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类和原始类型的包装类也重写了`equals()`方法。'
- en: The equals() method of the String class
  id: totrans-1135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: String类的equals()方法
- en: 'In [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java Language
    Elements and Types*, we have already discussed this and even reviewed the source
    code. Here it is:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中，*Java语言元素和类型*，我们已经讨论过这个问题，甚至审查了源代码。这里是源代码：
- en: '```java'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public boolean equals(Object anObject) {
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean equals(Object anObject) {
- en: if (this == anObject) {
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: if (this == anObject) {
- en: return true;
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: return true;
- en: '}'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: if (anObject instanceof String) {
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: if (anObject instanceof String) {
- en: String aString = (String)anObject;
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: String aString = (String)anObject;
- en: if (coder() == aString.coder()) {
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: if (coder() == aString.coder()) {
- en: return isLatin1() ?
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: return isLatin1() ?
- en: StringLatin1.equals(value, aString.value)
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: StringLatin1.equals(value, aString.value)
- en: ': StringUTF16.equals(value, aString.value);'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: ：StringUTF16.equals(value, aString.value);
- en: '}'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return false;
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: return false;
- en: '}'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, it overrides the `Object` class implementation in order to
    compare values, not just references. This code proves it:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它重写了`Object`类的实现，以便比较值，而不仅仅是引用。这段代码证明了这一点：
- en: '```java'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String sl1 = "test1";
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: String sl1 = "test1";
- en: String sl2 = "test2";
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: String sl2 = "test2";
- en: String sl3 = "test1";
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: String sl3 = "test1";
- en: 'System.out.println(sl1 == sl2);              //1: false'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(sl1 == sl2);              //1: false'
- en: 'System.out.println(sl1.equals(sl2));         //2: false'
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(sl1.equals(sl2));         //2: false'
- en: 'System.out.println(sl1 == sl3);              //3: true'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(sl1 == sl3);              //3: true'
- en: 'System.out.println(sl1.equals(sl3));         //4: true'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(sl1.equals(sl3));         //4: true'
- en: String s1 = new String("test1");
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: String s1 = new String("test1");
- en: String s2 = new String("test2");
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: String s2 = new String("test2");
- en: String s3 = new String("test1");
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: String s3 = new String("test1");
- en: 'System.out.println(s1 == s2);                //5: false'
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(s1 == s2);                //5: false'
- en: 'System.out.println(s1.equals(s2));           //6: false'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(s1.equals(s2));           //6: false'
- en: 'System.out.println(s1 == s3);                //7: false'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(s1 == s3);                //7: false'
- en: 'System.out.println(s1.equals(s3));           //8: true'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(s1.equals(s3));           //8: true'
- en: 'System.out.println(sl1 == s1);               //9: false'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(sl1 == s1);               //9: false'
- en: 'System.out.println(sl1.equals(s1));          //10: true'
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(sl1.equals(s1));          //10: true'
- en: '```'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You can see that the equality operator `==` sometimes compares the `String`
    object values correctly and sometimes doesn't. The `equal()` method, though, always compares
    the values correctly, even if they are wrapped in different objects, not just
    refer literals.
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到等号运算符`==`有时会正确比较`String`对象的值，有时则不会。然而，`equal()`方法总是正确比较值，即使它们被包装在不同的对象中，而不仅仅是引用文字。
- en: We included the equality operator in the test in order to clarify the cases
    of incorrect explanation of `String` values one can read on the internet more
    often than one might expect. The incorrect explanation is based on the JVM implementation
    that supports `String` instance immutability (read about `String` immutability
    and the motivation for it in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml), *Java
    Language Elements and Types*). The JVM does not store the same `String` value
    twice and reuses the value already stored in the area called the **string pool** in
    the process called **strings interning**.  After learning about that, some people
    assume that using the `equals()` method with `String` values is unnecessary because
    the same value will have the same reference value anyway. Our test proves that,
    in the case of a `String` value wrapped in the class `String`, its value cannot
    be compared correctly by the equality operator and one must use the `equals()` method instead.
    There are also other cases when a `String` value is not stored in the string pool.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试中包含了等号运算符，以澄清在互联网上经常读到的关于`String`值的不正确解释的情况。这种不正确的解释基于支持`String`实例不可变性的JVM实现（在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中阅读关于`String`不可变性及其动机的内容）。JVM不会两次存储相同的`String`值，并且会重用已存储在称为**字符串池**的区域中的值，这个过程称为**字符串池化**。了解了这一点后，有些人认为使用`equals()`方法与`String`值是不必要的，因为相同的值无论如何都会有相同的引用值。我们的测试证明，在`String`类中包装的`String`值的情况下，等号运算符无法正确比较其值，必须使用`equals()`方法。还有其他情况，`String`值没有存储在字符串池中。
- en: To compare two `String` objects by value, always use the `equals()` method,
    not the equality operator `==`.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较两个`String`对象的值，总是使用`equals()`方法，而不是等号`==`。
- en: In general, the `equals()`method is not as fast as the  `== `operator. But,
    as we already pointed out in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types,* the `equals()` method of class String compares
    references first, which means there is no need to try to save performance time and
    compare references in the code before calling the `equals()` method. Just call
    the `equals()` method.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，`equals()`方法不如`==`运算符快。但是，正如我们在[第5章](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml)中指出的那样，*Java语言元素和类型*，String类的`equals()`方法首先比较引用，这意味着在调用`equals()`方法之前没有必要尝试节省性能时间并比较引用。只需调用`equals()`方法。
- en: The ambiguity of `String` type behavior—sometimes like a primitive type, other
    times like a reference type—reminds me of the double nature of elementary particles
    in physics. Particles sometimes behave like small concentrated objects, but other
    times like waves. What is really going on behind the scenes, deep in the guts
    of the matter? Is something is immutable there too?
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类型行为的模糊性 - 有时像原始类型，有时像引用类型 - 让我想起了物理学中基本粒子的双重性质。粒子有时表现得像小而集中的物体，但有时像波。背后到底发生了什么？那里也是不可变的吗？'
- en: The equals() method in wrapper classes of primitive types
  id: totrans-1177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型的包装类中的equals()方法
- en: 'If we run the test for a wrapper class, the results will be:'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对包装类运行测试，结果将是：
- en: '```java'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: long ln = 42;
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: long ln = 42;
- en: Integer n = 42;
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: Integer n = 42;
- en: System.out.println(n.equals(42));      //true
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(n.equals(42));      //true
- en: System.out.println(n.equals(ln));      //false
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(n.equals(ln));      //false
- en: System.out.println(n.equals(43));      //false
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(n.equals(43));      //false
- en: System.out.println(n.equals(Integer.valueOf(42)));  //true
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(n.equals(Integer.valueOf(42)));  //true
- en: System.out.println(n.equals(Long.valueOf(42)));     //false
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(n.equals(Long.valueOf(42)));     //false
- en: '```'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Based on our experience with the children of `Person`, we can quite confidently
    assume that the `equals()` methods of the wrapper classes include the comparison
    of class names. Let''s look at the source code. Here is the `equals()` method
    of the `Integer` class:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对`Person`的子类的经验，我们可以相当自信地假设包装类的`equals()`方法包括类名的比较。让我们看看源代码。这是`Integer`类的`equals()`方法：
- en: '```java'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public boolean equals(Object obj) {
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean equals(Object obj) {
- en: if (obj instanceof Integer) {
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: if (obj instanceof Integer) {
- en: return value == ((Integer)obj).intValue();
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值等于((Integer)obj).intValue()。
- en: '}'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return false;
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 返回false。
- en: '}'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: That is exactly what we expected. If an object is not an instance of the `Integer` class,
    it can never be considered equal to an object of another class, even if it carries
    exactly the same numeric value. It looks like the system of social classes in
    the olden days, doesn't it?
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们所期望的。如果一个对象不是`Integer`类的实例，即使它携带完全相同的数值，也永远不能被认为等于另一个类的对象。这看起来就像古代社会阶级制度一样，不是吗？
- en: Exercise – Naming the statements
  id: totrans-1198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习 - 命名语句
- en: What are the following statements called?
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句称为什么？
- en: '`i++;`'
  id: totrans-1200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i++;`'
- en: '`String s;`'
  id: totrans-1201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String s;`'
- en: '`s = "I am a string";`'
  id: totrans-1202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s = "I am a string";`'
- en: '`doSomething(1, "23");`'
  id: totrans-1203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doSomething(1, "23");`'
- en: Answer
  id: totrans-1204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'The following statements are called:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句称为：
- en: 'Increment statement: `i++;`'
  id: totrans-1206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递增语句：`i++;`
- en: 'Variable declaration statement: `String s;  `'
  id: totrans-1207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量声明语句：`String s;`
- en: 'Assignment statement: `s = "I am a string";`'
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值语句：`s = "I am a string";`
- en: 'Method invocation statement: `doSomething(1, "23");`'
  id: totrans-1209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法调用语句：`doSomething(1, "23");`
- en: Summary
  id: totrans-1210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we learned what the three core elements of Java programming
    are—operators, expressions, and statements—and how they are related to each other.
    We walked you through all the Java operators, discussed the most popular ones
    with examples, and explained the potential issues with using them. A substantial
    part of this chapter was dedicated to data type conversion: widening and narrowing,
    boxing, and unboxing. The `equals()` method of reference types was also demonstrated
    and tested on specific examples for a variety of classes and implementations.
    The `String` class was used prominently and the popular incorrect explanation
    of its behavior was resolved.'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Java编程的三个核心元素——运算符、表达式和语句——以及它们之间的关系。我们为您介绍了所有的Java运算符，讨论了一些最受欢迎的运算符，并通过示例解释了它们的潜在问题。本章的相当部分专门讨论了数据类型转换：扩宽和缩窄、装箱和拆箱。还演示了引用类型的`equals()`方法，并针对各种类和实现进行了具体示例的测试。`String`类被广泛使用，并解决了关于其行为的流行错误解释。
- en: 'In the next chapter, we will start writing the program logic—the backbone of
    any execution flow—using control flow statements, which are going to be defined,
    explained, and demonstrated in many examples: conditional statements, iterative
    statements, branching statements, and exceptions.'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始编写程序逻辑——任何执行流程的支柱——使用控制流语句，这些语句将被定义、解释并通过许多示例进行演示：条件语句、迭代语句、分支语句和异常。
