- en: '*Chapter 8*: Securing Kubernetes Pods'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：保护Kubernetes Pods'
- en: 'Even though a pod is the most fine-grained unit that serves as a placeholder
    to run microservices, securing Kubernetes pods is a vast topic as it should cover
    the entire DevOps flow: build, deployment, and runtime.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管pod是作为运行微服务的最细粒度单位，保护Kubernetes pods是一个广泛的主题，因为它应该涵盖整个DevOps流程：构建、部署和运行。
- en: In this chapter, we choose to narrow our focus to the build and runtime stages.
    To secure Kubernetes pods in the build stage, we will talk about how to harden
    a container image and configure the security attributes of pods (or pod templates)
    to reduce the attack surface. Although some of the security attributes of workloads,
    such as AppArmor and SELinux labels, take effect in the runtime stage, security
    control has already been defined for the workload. To clarify matters further,
    we're trying to secure Kubernetes workloads by configuring the runtime effect
    security attributes in the build stage. To secure Kubernetes pods in the runtime
    stage, we will introduce a PodSecurityPolicy with examples along with the facilitating
    tool, `kube-psp-advisor`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们选择将焦点缩小到构建和运行阶段。为了在构建阶段保护Kubernetes pods，我们将讨论如何加固容器镜像并配置pod（或pod模板）的安全属性，以减少攻击面。虽然一些工作负载的安全属性，如AppArmor和SELinux标签，会在运行阶段生效，但安全控制已经为工作负载定义好了。为了进一步澄清问题，我们试图通过在构建阶段配置运行效果的安全属性来保护Kubernetes工作负载。为了在运行阶段保护Kubernetes
    pods，我们将介绍一个带有示例的PodSecurityPolicy以及辅助工具`kube-psp-advisor`。
- en: Later chapters will go into more detail regarding runtime security and response.
    Also note that exploitation of the application may lead to pods getting compromised.
    However, we don't intend to cover application in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节将更详细地讨论运行时安全和响应。还要注意，应用程序的利用可能导致pod被 compromise。但是，我们不打算在本章中涵盖应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Hardening container images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像的加固
- en: Configuring the security attributes of pods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置pod的安全属性
- en: The power of PodSecurityPolicy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PodSecurityPolicy的威力
- en: Hardening container images
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器镜像的加固
- en: Container image hardening means to follow security best practices or baselines
    to configure a container image in order to reduce the attack surface. Image scanning
    tools only focus on finding publicly disclosed issues in applications bundled
    inside the image. But, following the best practices along with secure configuration
    while building the image ensures that the application has a minimal attack surface.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的加固意味着遵循安全最佳实践或基线，以配置容器镜像，以减少攻击面。镜像扫描工具只关注在镜像内捆绑的应用程序中找到的公开披露的问题。但是，在构建镜像时遵循最佳实践以及安全配置，可以确保应用程序具有最小的攻击面。
- en: Before we start talking about the secure configuration baseline, let's look
    at what a container image is, as well as a Dockerfile, and how it is used to build
    an image.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论安全配置基线之前，让我们看看容器镜像是什么，以及Dockerfile是什么，以及它是如何用来构建镜像的。
- en: Container images and Dockerfiles
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器镜像和Dockerfile
- en: A **container image** is a file that bundles the microservice binary, its dependencies,
    and configurations of the microservice, and so on. A container is a running instance
    of an image. Nowadays, application developers not only write code to build microservices;
    they also need to build the Dockerfile to containerize the microservice. To help
    build a container image, Docker offers a standardized approach, known as a Dockerfile.
    A **Dockerfile** contains a series of instructions, such as copy files, configure
    environment variables, configure open ports, and container entry points, which
    can be understood by the Docker daemon to construct the image file. Then, the
    image file will be pushed to the image registry from where the image is then deployed
    in Kubernetes clusters. Each Dockerfile instruction will create a file layer in
    the image.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**容器镜像**是一个文件，它捆绑了微服务二进制文件、它的依赖项和微服务的配置等。一个容器是镜像的运行实例。如今，应用程序开发人员不仅编写代码来构建微服务；他们还需要构建Dockerfile来将微服务容器化。为了帮助构建容器镜像，Docker提供了一种标准化的方法，称为Dockerfile。一个**Dockerfile**包含一系列的指令，比如复制文件、配置环境变量、配置开放端口和容器入口点，这些指令可以被Docker守护进程理解以构建镜像文件。然后，镜像文件将被推送到镜像注册表，然后从那里部署到Kubernetes集群中。每个Dockerfile指令都会在镜像中创建一个文件层。
- en: 'Before we look at an example of a Dockerfile, let''s understand some basic
    Dockerfile instructions:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看一个Dockerfile的例子之前，让我们先了解一些基本的Dockerfile指令：
- en: '**FROM**: Initialize a new build stage from the base image or parent image.
    Both mean the foundation or the file layer on which you''re bundling your own
    image.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FROM**：从基础镜像或父镜像初始化一个新的构建阶段。两者都意味着你正在捆绑自己的镜像的基础或文件层。'
- en: '**RUN**: Execute commands and commit the results on top of the previous file
    layer.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RUN**：执行命令并将结果提交到上一个文件层之上。'
- en: '**ENV**: Set environment variables for the running containers.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ENV**：为运行的容器设置环境变量。'
- en: '**CMD**: Specify the default commands that the containers will run.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CMD**：指定容器将运行的默认命令。'
- en: '**COPY/ADD**: Both commands copy files or directories from the local (or remote)
    URL to the filesystem of the image.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**COPY/ADD**：这两个命令都是将文件或目录从本地（或远程）URL复制到镜像的文件系统中。'
- en: '**EXPOSE**: Specify the port that the microservice will be listening on during
    container runtime.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EXPOSE**：指定微服务在容器运行时将监听的端口。'
- en: '**ENTRYPOINT**: Similar to `CMD`, the only difference is that `ENTRYPOINT`
    makes a container that will run as an executable.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ENTRYPOINT**：类似于`CMD`，唯一的区别是`ENTRYPOINT`会使容器作为可执行文件运行。'
- en: '**WORKDIR**: Sets the working directory for the instructions that follow.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WORKDIR**：为接下来的指令设置工作目录。'
- en: '**USER**: Sets the user and group ID for any `CMD`/`ENTRYPOINT` of containers.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**USER**：为容器的`CMD`/`ENTRYPOINT`设置用户和组ID。'
- en: 'Now, let''s take a look at an example of a Dockerfile:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个Dockerfile的例子：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the preceding Dockerfile, we can tell that the image was built on top of
    `ubuntu`. Then, it ran a bunch of `apt-get` commands to install the dependencies,
    and created a directory called `/var/www`. Next, copy the `app.js` file from the
    current directory to `/var/www/app.js` in the filesystem of the image. Finally,
    configure the default command to run this `Node.js` application. I believe you
    will see how straightforward and powerful Dockerfile is when it comes to helping
    you build an image.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的Dockerfile中，我们可以看出这个镜像是基于`ubuntu`构建的。然后，它运行了一系列的`apt-get`命令来安装依赖，并创建了一个名为`/var/www`的目录。接下来，将`app.js`文件从当前目录复制到镜像文件系统中的`/var/www/app.js`。最后，配置默认命令来运行这个`Node.js`应用程序。我相信当你开始构建镜像时，你会看到Dockerfile是多么简单和强大。
- en: The next question is any security concern, as it looks like you're able to build
    any kind of image. Next, let's talk about CIS Docker benchmarks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是安全问题，因为看起来您可以构建任何类型的图像。接下来，让我们谈谈CIS Docker基准。
- en: CIS Docker benchmarks
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CIS Docker基准
- en: '**Center for Internet Security** (**CIS**) put together a guideline regarding
    Docker container administration and management. Now, let''s take a look at the
    security recommendations from CIS Docker benchmarks regarding container images:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网安全中心（CIS）制定了有关Docker容器管理和管理的指南。现在，让我们来看看CIS Docker基准关于容器图像的安全建议：
- en: '**Create a user for a container image to run a microservice**: It is good practice
    to run a container as non-root. Although user namespace mapping is available,
    it is not enabled by default. Running as root means that if an attacker were to
    successfully escape from the container, they would gain root access to the host.
    Use the `USER` instruction to create a user in the Dockerfile.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为容器图像创建一个用户来运行微服务：以非root用户运行容器是一个好的做法。虽然用户命名空间映射是可用的，但默认情况下未启用。以root身份运行意味着如果攻击者成功逃离容器，他们将获得对主机的root访问权限。在Dockerfile中使用`USER`指令创建一个用户。
- en: '**Use trusted base images to build your own image**: Images downloaded from
    public repositories cannot be fully trusted. It is well known that images from
    public repositories may contain malware or crypto miners. Hence, it is recommended
    that you build your image from scratch or use minimal trusted images, such as
    Alpine. Also, perform the image scan after your image has been built. Image scanning
    will be covered in the next chapter.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用受信任的基础图像构建您自己的图像：从公共存储库下载的图像不能完全信任。众所周知，来自公共存储库的图像可能包含恶意软件或加密货币挖矿程序。因此，建议您从头开始构建图像或使用最小的受信任图像，如Alpine。此外，在构建图像后执行图像扫描。图像扫描将在下一章节中介绍。
- en: '**Do not install unnecessary packages in your image**: Installing unnecessary
    packages will increase the attack surface. It is recommended that you keep your
    image slim. Occasionally, you will probably need to install some tools during
    the process of building an image. Do remember to remove them at the end of the
    Dockerfile.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在图像中安装不必要的软件包：安装不必要的软件包会增加攻击面。建议保持图像的精简。在构建图像的过程中，您可能需要安装一些工具。请记住在Dockerfile的末尾将它们删除。
- en: '**Scan and rebuild an image in order to apply security patches**: It is highly
    likely that new vulnerabilities will be discovered in your base image or in the
    packages you install in your image. It is good practice to scan your image frequently.
    Once you identify any vulnerabilities, try to patch the security fixes by rebuilding
    the image. Image scanning is a critical mechanism for identifying vulnerabilities
    at the build stage. We will cover image scanning in more detail in the next chapter.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描并重建图像以应用安全补丁：很可能会在基础图像或图像中安装的软件包中发现新的漏洞。经常扫描图像是一个好的做法。一旦发现任何漏洞，尝试通过重建图像来修补安全漏洞。图像扫描是在构建阶段识别漏洞的关键机制。我们将在下一章节详细介绍图像扫描。
- en: '**Enable content trust for Docker**: Content trust uses digital signatures
    to ensure data integrity between the client and the Docker registry. It ensures
    the provenance of the container image. However, it is not enabled by default.
    You can turn it on by setting the environment variable, `DOCKER_CONTENT_TRUST`,
    to `1`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Docker启用内容信任：内容信任使用数字签名确保客户端和Docker注册表之间的数据完整性。它确保容器图像的来源。但默认情况下未启用。您可以通过将环境变量`DOCKER_CONTENT_TRUST`设置为`1`来启用它。
- en: '**Add a HEALTHCHECK instruction to the container image**: A `HEALTHCHECK` instruction
    defines a command to ask Docker Engine to check the health status of the container
    periodically. Based on the health status check result, Docker Engine then exits
    the non-healthy container and initiates a new one.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**向容器图像添加HEALTHCHECK指令**：`HEALTHCHECK`指令定义了一个命令，要求Docker引擎定期检查容器的健康状态。根据健康状态检查结果，Docker引擎然后退出不健康的容器并启动一个新的容器。'
- en: '**Ensure that updates are not cached in Dockerfile**: Depending on the base
    image you choose, you may need to update the package repository before installing
    new packages. However, if you specify `RUN apt-get update``(Debian)` in a single
    line in the Dockerfile, Docker Engine will cache this file layer, so, when you
    build your image again, it will still use the old package repository information
    that is cached. This will prevent you from using the latest packages in your image.
    Therefore, either use `update` along with `install` in a single Dockerfile instruction
    or use the `--no-cache` flag in the Docker `build` command.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保Dockerfile中的更新不被缓存**：根据您选择的基础镜像，您可能需要在安装新软件包之前更新软件包存储库。但是，如果您在Dockerfile中的单行中指定`RUN
    apt-get update``(Debian)`，Docker引擎将缓存此文件层，因此，当您再次构建图像时，它仍将使用缓存的旧软件包存储库信息。这将阻止您在图像中使用最新的软件包。因此，要么在单个Dockerfile指令中同时使用`update`和`install`，要么在Docker`build`命令中使用`--no-cache`标志。'
- en: '**Remove setuid and setgid permission from files in the image**: `setuid` and
    `setgid` permissions can be used for privilege escalation as files with such permissions
    are allowed to be executed with owners'' privileges instead of launchers'' privileges.
    You should carefully review the files with `setuid` and `setgid` permissions and
    remove those files that don''t require such permissions.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从图像中删除setuid和setgid权限**：`setuid`和`setgid`权限可用于特权升级，因为具有这些权限的文件允许以所有者特权而不是启动器特权执行。您应该仔细审查具有`setuid`和`setgid`权限的文件，并删除不需要此类权限的文件。'
- en: '**Use COPY instead of ADD in the Dockerfile**: The `COPY` instruction can only
    copy files from the local machine to the filesystem of the image, while the `ADD`
    instruction can not only copy files from the local machine but also retrieve files
    from the remote URL to the filesystem of the image. Using `ADD` may introduce
    the risk of adding malicious files from the internet to the image.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在Dockerfile中使用COPY而不是ADD**：`COPY`指令只能将文件从本地计算机复制到图像的文件系统，而`ADD`指令不仅可以从本地计算机复制文件，还可以从远程URL检索文件到图像的文件系统。使用`ADD`可能会引入从互联网添加恶意文件的风险。'
- en: '**Do not store secrets in the Dockerfile**: There are many tools that are able
    to extract image file layers. If there are any secrets stored in the image, secrets
    are no longer secrets. Storing secrets in the Dockerfile renders containers potentially
    exploitable. A common mistake is to use the `ENV` instruction to store secrets
    in environment variables.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要在Dockerfile中存储机密信息**：有许多工具可以提取图像文件层。如果图像中存储了任何机密信息，那么这些机密信息就不再是机密信息。在Dockerfile中存储机密信息会使容器有潜在的可利用性。一个常见的错误是使用`ENV`指令将机密信息存储在环境变量中。'
- en: '**Install verified packages only**: This is similar to using the trusted base
    image only. Observe caution as regards the packages you are going to install within
    your image. Make sure they are from trusted package repositories.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅安装经过验证的软件包**：这类似于仅使用受信任的基础镜像。在安装图像内的软件包时要小心，确保它们来自受信任的软件包存储库。'
- en: If you follow the security recommendations from the preceding CIS Docker benchmarks,
    you will be successful in hardening your container image. This is the first step
    in securing pods in the build stage. Now, let's look at the security attributes
    we need to pay attention to in order to secure a pod.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循前述CIS Docker基准的安全建议，您将成功地加固容器镜像。这是在构建阶段保护pod的第一步。现在，让我们看看我们需要注意的安全属性，以确保pod的安全。
- en: Configuring the security attributes of pods
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置pod的安全属性
- en: As we mentioned in the previous chapter, application developers should be aware
    of what privileges a microservice must have in order to perform tasks. Ideally,
    application developers and security engineers work together to harden the microservice
    at the pod and container level by configuring the security context provided by
    Kubernetes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一章中提到的，应用程序开发人员应该知道微服务必须具有哪些特权才能执行任务。理想情况下，应用程序开发人员和安全工程师应该共同努力，通过配置Kubernetes提供的安全上下文来加固pod和容器级别的微服务。
- en: 'We classify the major security attributes into four categories:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要的安全属性分为四类：
- en: Setting host namespaces for pods
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为pod设置主机命名空间
- en: Security context at the container level
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器级别的安全上下文
- en: Security context at the pod level
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod级别的安全上下文
- en: AppArmor profile
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AppArmor配置文件
- en: By employing such a means of classification, you will find them easy to manage.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用这种分类方式，您会发现它们易于管理。
- en: Setting host-level namespaces for pods
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为pod设置主机级别的命名空间
- en: 'The following attributes in the pod specification are used to configure the
    use of host namespaces:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在pod规范中使用以下属性来配置主机命名空间的使用：
- en: '**hostPID**: By default, this is `false`. Setting it to `true` allows the pod
    to have visibility on all the processes in the worker node.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hostPID**：默认情况下为`false`。将其设置为`true`允许pod在工作节点上看到所有进程。'
- en: '**hostNetwork**: By default, this is `false`. Setting it to `true` allows the
    pod to have visibility on all the network stacks in the worker node.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hostNetwork**：默认情况下为`false`。将其设置为`true`允许pod在工作节点上看到所有网络堆栈。'
- en: '**hostIPC**: By default, this is `false`. Setting it to `true` allows the pod
    to have visibility on all the IPC resources in the worker node.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hostIPC**：默认情况下为`false`。将其设置为`true`允许pod在工作节点上看到所有IPC资源。'
- en: 'The following is an example of how to configure the use of host namespaces
    at the pod level in an `ubuntu-1` pod `YAML` file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在`ubuntu-1` pod的`YAML`文件中配置在pod级别使用主机命名空间的示例：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding workload YAML configured the `ubuntu-1` pod to use a host-level
    PID namespace, network namespace, and IPC namespace. Keep in mind that you shouldn't
    set these attributes to `true` unless necessary. Setting these attributes to `true`
    also disarms the security boundaries of other workloads in the same worker node,
    as has already been mentioned in [*Chapter 5*](B15566_05_Final_ASB_ePub.xhtml#_idTextAnchor144),
    *Configuring Kubernetes Security Boundaries*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的工作负载YAML配置了`ubuntu-1` pod以使用主机级PID命名空间、网络命名空间和IPC命名空间。请记住，除非必要，否则不应将这些属性设置为`true`。将这些属性设置为`true`还会解除同一工作节点上其他工作负载的安全边界，正如在[*第5章*](B15566_05_Final_ASB_ePub.xhtml#_idTextAnchor144)中已经提到的，*配置Kubernetes安全边界*。
- en: Security context for containers
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器的安全上下文
- en: Multiple containers can be grouped together inside the same pod. Each container
    can have its own security context, which defines privileges and access controls.
    The design of a security context at a container level provides a more fine-grained
    security control for Kubernetes workloads. For example, you may have three containers
    running inside the same pod and one of them has to run in privileged mode, while
    the others run in non-privileged mode. This can be done by configuring a security
    context for individual containers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 多个容器可以被分组放置在同一个Pod中。每个容器可以拥有自己的安全上下文，定义特权和访问控制。在容器级别设计安全上下文为Kubernetes工作负载提供了更精细的安全控制。例如，您可能有三个容器在同一个Pod中运行，其中一个必须以特权模式运行，而其他的以非特权模式运行。这可以通过为各个容器配置安全上下文来实现。
- en: 'The following are the principal attributes of a security context for containers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是容器安全上下文的主要属性：
- en: '**privileged**: By default, this is `false`. Setting it to `true` essentially
    makes the processes inside the container equivalent to the root user on the worker
    node.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**privileged**: 默认情况下为`false`。将其设置为`true`实质上使容器内的进程等同于工作节点上的root用户。'
- en: '**capabilities**: There is a default set of capabilities granted to the container
    by the container runtime. The default capabilities granted are as follows: `CAP_SETPCAP`,
    `CAP_MKNOD`, `CAP_AUDIT_WRITE`, `CAP_CHOWN`, `CAP_NET_RAW`, `CAP_DAC_OVERRIDE`,
    `CAP_FOWNER`, `CAP_FSETID`, `CAP_KILL`, `CAP_SETGID`, `CAP_SETUID`, `CAP_NET_BIND_SERVICE`,
    `CAP_SYS_CHROOT`, and `CAP_SETFCAP`.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**能力**: 容器运行时默认授予容器的一组能力。默认授予的能力包括：`CAP_SETPCAP`、`CAP_MKNOD`、`CAP_AUDIT_WRITE`、`CAP_CHOWN`、`CAP_NET_RAW`、`CAP_DAC_OVERRIDE`、`CAP_FOWNER`、`CAP_FSETID`、`CAP_KILL`、`CAP_SETGID`、`CAP_SETUID`、`CAP_NET_BIND_SERVICE`、`CAP_SYS_CHROOT`和`CAP_SETFCAP`。'
- en: You may add extra capabilities or drop some of the defaults by configuring this
    attribute. Capabilities such as `CAP_SYS_ADMIN` and `CAP_NETWORK_ADMIN` should
    be added with caution. For the default capabilities, you should also drop those
    that are unnecessary.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过配置此属性添加额外的能力或删除一些默认的能力。诸如`CAP_SYS_ADMIN`和`CAP_NETWORK_ADMIN`之类的能力应谨慎添加。对于默认的能力，您还应该删除那些不必要的能力。
- en: '**allowPrivilegeEscalation**: By default, this is `true`. Setting it directly
    controls the `no_new_privs` flag, which will be set to the processes in the container.
    Basically, this attribute controls whether the process can gain more privileges
    than its parent process. Note that if the container runs in privileged mode, or
    has the `CAP_SYS_ADMN` capability added, this attribute will be set to `true`
    automatically. It is good practice to set it to `false`.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**allowPrivilegeEscalation**: 默认情况下为`true`。直接设置此属性可以控制`no_new_privs`标志，该标志将设置为容器中的进程。基本上，此属性控制进程是否可以获得比其父进程更多的特权。请注意，如果容器以特权模式运行，或者添加了`CAP_SYS_ADMN`能力，此属性将自动设置为`true`。最好将其设置为`false`。'
- en: '**readOnlyRootFilesystem**: By default, this is `false`. Setting it to `true`
    makes the root filesystem of the container read-only, which means that the library
    files, configuration files, and so on are read-only and cannot be tampered with.
    It is a good security practice to set it to `true`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**readOnlyRootFilesystem**: 默认情况下为`false`。将其设置为`true`会使容器的根文件系统变为只读，这意味着库文件、配置文件等都是只读的，不能被篡改。将其设置为`true`是一个良好的安全实践。'
- en: '**runAsNonRoot**: By default, this is `false`. Setting it to `true` enables
    validation that the processes in the container cannot run as a root user (UID=0).
    Validation is done by `kubelet`. With `runAsNonRoot` set to `true`, `kubelet`
    will prevent the container from starting if run as a root user. It is a good security
    practice to set it to `true`. This attribute is also available in `PodSecurityContext`,
    which takes effect at pod level. If this attribute is set in both `SecurityContext`
    and `PodSecurityContext`, the value specified at the container level takes precedence.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: runAsNonRoot：默认情况下为`false`。将其设置为`true`可以启用验证，以确保容器中的进程不能以root用户（UID=0）身份运行。验证由`kubelet`执行。将`runAsNonRoot`设置为`true`后，如果以root用户身份运行，`kubelet`将阻止容器启动。将其设置为`true`是一个良好的安全实践。这个属性也可以在`PodSecurityContext`中使用，在Pod级别生效。如果在`SecurityContext`和`PodSecurityContext`中都设置了这个属性，那么在容器级别指定的值优先。
- en: '**runAsUser**: This is designed to specify to the UID to run the entrypoint
    process of the container image. The default setting is the user specified in the
    image''s metadata (for example, the `USER` instruction in the Dockerfile). This
    attribute is also available in `PodSecurityContext`, which takes effect at the
    pod level. If this attribute is set in both `SecurityContext` and `PodSecurityContext`,
    the value specified at the container level takes precedence.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: runAsUser：这是用来指定容器镜像入口进程运行的UID。默认设置是镜像元数据中指定的用户（例如，Dockerfile中的`USER`指令）。这个属性也可以在`PodSecurityContext`中使用，在Pod级别生效。如果在`SecurityContext`和`PodSecurityContext`中都设置了这个属性，那么在容器级别指定的值优先。
- en: '**runAsGroup**: Similar to `runAsUser`, this is designed to specify the **Group
    ID** or **GID** to run the entrypoint process of the container. This attribute
    is also available in `PodSecurityContext`, which takes effect at the pod level.
    If this attribute is set in both `SecurityContext` and `PodSecurityContext`, the
    value specified at the container level takes precedence.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: runAsGroup：类似于`runAsUser`，这是用来指定容器入口进程运行的**Group ID**或**GID**。这个属性也可以在`PodSecurityContext`中使用，在Pod级别生效。如果在`SecurityContext`和`PodSecurityContext`中都设置了这个属性，那么在容器级别指定的值优先。
- en: '**seLinuxOptions**: This is designed to specify the SELinux context to the
    container. By default, the container runtime will assign a random SELinux context
    to the container if not specified. This attribute is also available in `PodSecurityContex`,
    which takes effect at the pod level. If this attribute is set in both `SecurityContext`
    and `PodSecurityContext`, the value specified at the container level takes precedence.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: seLinuxOptions：这是用来指定容器的SELinux上下文的。默认情况下，如果未指定，容器运行时将为容器分配一个随机的SELinux上下文。这个属性也可以在`PodSecurityContex`中使用，在Pod级别生效。如果在`SecurityContext`和`PodSecurityContext`中都设置了这个属性，那么在容器级别指定的值优先。
- en: 'Since you now understand what these security attributes are, you may come up
    with your own hardening strategy aligned with your business requirements. In general,
    the security best practices are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你现在了解了这些安全属性是什么，你可以根据自己的业务需求提出自己的加固策略。一般来说，安全最佳实践如下：
- en: Do not run in privileged mode unless necessary.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非必要，不要以特权模式运行。
- en: Do not add extra capabilities unless necessary.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非必要，不要添加额外的能力。
- en: Drop unused default capabilities.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 丢弃未使用的默认能力。
- en: Run containers as a non-root user.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以非root用户身份运行容器。
- en: Enable a `runAsNonRoot` check.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用`runAsNonRoot`检查。
- en: Set the container root filesystem as read-only.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器根文件系统设置为只读。
- en: 'Now, let''s take a look at an example of configuring `SecurityContext` for
    containers:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个为容器配置`SecurityContext`的示例：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `nginx` container inside `nginx-pod` runs as a user with a UID of `100`
    and a GID of `1000`. In addition to this, the `nginx` container gains extra `NETWORK_ADMIN`
    capability and the root filesystem is set to read-only. The YAML file here only
    shows an example of how to configure the security context. Note that adding `NETWORK_ADMIN`
    is not recommended for containers running in production environments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: nginx-pod内的`nginx`容器以UID为`100`和GID为`1000`的用户身份运行。除此之外，`nginx`容器还获得了额外的`NETWORK_ADMIN`权限，并且根文件系统被设置为只读。这里的YAML文件只是展示了如何配置安全上下文的示例。请注意，在生产环境中运行的容器中不建议添加`NETWORK_ADMIN`。
- en: Security context for pods
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod的安全上下文
- en: A security context is used at the pod level, which means that security attributes
    will be applied to all the containers inside the pod.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 安全上下文是在pod级别使用的，这意味着安全属性将应用于pod内的所有容器。
- en: 'The following is a list of the principal security attributes at the pod level:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是pod级别的主要安全属性列表：
- en: '**fsGroup**: This is a special supplemental group applied to all containers.
    The effectiveness of this attribute depends on the volume type. Essentially, it
    allows `kubelet` to set the ownership of the mounted volume to the pod with the
    supplemental GID.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fsGroup**：这是一个应用于所有容器的特殊辅助组。这个属性的有效性取决于卷类型。基本上，它允许`kubelet`将挂载卷的所有权设置为具有辅助GID的pod。'
- en: '**sysctls**: `sysctls` is used to configure kernel parameters at runtime. In
    such a context, `sysctls` and kernel parameters are used interchangeably. These
    `sysctls` commands are namespaced kernel parameters that apply to the pod. The
    following `sysctls` commands are known to be namespaced: `kernel.shm*`, `kernel.msg*`,
    `kernel.sem`, and `kernel.mqueue.*`. Unsafe `sysctls` are disabled by default
    and should not be enabled in production environments.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sysctls**：`sysctls`用于在运行时配置内核参数。在这样的上下文中，`sysctls`和内核参数是可以互换使用的。这些`sysctls`命令是命名空间内的内核参数，适用于pod。以下`sysctls`命令已知是命名空间内的：`kernel.shm*`、`kernel.msg*`、`kernel.sem`和`kernel.mqueue.*`。不安全的`sysctls`默认情况下是禁用的，不应在生产环境中启用。'
- en: '**runAsUser**: This is designed to specify the UID to run the entrypoint process
    of the container image. The default setting is the user specified in the image''s
    metadata (for example, the `USER` instruction in the Dockerfile). This attribute
    is also available in `SecurityContext`, which takes effect at the container level.
    If this attribute is set in both `SecurityContext` and `PodSecurityContext`, the
    value specified at the container level takes precedence.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**runAsUser**：这是用来指定容器镜像的入口进程运行的UID的。默认设置是镜像元数据中指定的用户（例如，Dockerfile中的`USER`指令）。这个属性也可以在`SecurityContext`中使用，它在容器级别生效。如果在`SecurityContext`和`PodSecurityContext`中都设置了这个属性，那么在容器级别指定的值会优先生效。'
- en: '**runAsGroup**: Similar to `runAsUser`, this is designed to specify the GID
    to run the entrypoint process of the container. This attribute is also available
    in `SecurityContext`, which takes effect at the container level. If this attribute
    is set in both `SecurityContext` and `PodSecurityContext`, the value specified
    at the container level takes precedence.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**runAsGroup**：类似于`runAsUser`，这是用来指定容器的入口进程运行的GID的。这个属性也可以在`SecurityContext`中使用，它在容器级别生效。如果在`SecurityContext`和`PodSecurityContext`中都设置了这个属性，那么在容器级别指定的值会优先生效。'
- en: '**runAsNonRoot**: Set to `false` by default, setting it to `true` enables validation
    that the processes in the container cannot run as a root user (UID=0). Validation
    is done by `kubelet`. By setting it to `true`, `kubelet` will prevent the container
    from starting if run as a root user. It is a good security practice to set it
    to `true`. This attribute is also available in `SecurityContext`, which takes
    effect at the container level. If this attribute is set in both `SecurityContext`
    and `PodSecurityContext`, the value specified at the container level takes precedence.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**runAsNonRoot**：默认情况下设置为`false`，将其设置为`true`可以启用验证，即容器中的进程不能以root用户（UID=0）身份运行。验证由`kubelet`执行。将其设置为`true`，`kubelet`将阻止以root用户身份运行的容器启动。将其设置为`true`是一个很好的安全实践。此属性也可在`SecurityContext`中使用，其在容器级别生效。如果在`SecurityContext`和`PodSecurityContext`中都设置了此属性，则以容器级别指定的值优先。'
- en: '**seLinuxOptions**: This is designed to specify the SELinux context to the
    container. By default, the container runtime will assign a random SELinux context
    to the container if not specified. This attribute is also available in `SecurityContext`,
    which takes effect at the container level. If this attribute is set in both `SecurityContext`
    and `PodSecurityContext`, the value specified at the container level takes precedence.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**seLinuxOptions**：这是用来指定容器的SELinux上下文的。如果未指定，默认情况下，容器运行时会为容器分配一个随机的SELinux上下文。此属性也可在`SecurityContext`中使用，其在容器级别生效。如果在`SecurityContext`和`PodSecurityContext`中都设置了此属性，则以容器级别指定的值优先。'
- en: Notice that the attributes `runAsUser`, `runAsGroup`, `runAsNonRoot`, and `seLinuxOptions`
    are available both in `SecurityContext` at the container level and `PodSecurityContext`
    at the pod level. This gives users both the flexibility and extreme importance
    of security control. `fsGroup` and `sysctls` are not as commonly used as the others,
    so only use them when you have to.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`runAsUser`、`runAsGroup`、`runAsNonRoot`和`seLinuxOptions`属性在容器级别的`SecurityContext`和pod级别的`PodSecurityContext`中都可用。这为用户提供了灵活性和极其重要的安全控制。`fsGroup`和`sysctls`不像其他属性那样常用，所以只有在必要时才使用它们。
- en: AppArmor profiles
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AppArmor配置文件
- en: 'An AppArmor profile usually defines what Linux capabilities the process owns,
    what network resources and files can be accessed by the container, and so on.
    In order to use an AppArmor profile to protect pods or containers, you will need
    to update the annotation of the pod. Let''s look at an example, assuming you have
    an AppArmor profile to block any file write activities:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor配置文件通常定义了进程拥有的Linux功能，容器可以访问的网络资源和文件等。为了使用AppArmor配置文件保护pod或容器，您需要更新pod的注释。让我们看一个例子，假设您有一个AppArmor配置文件来阻止任何文件写入活动。
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that AppArmor is not a Kubernetes object, like a pod, deployment, and so
    on. It can't be operated through `kubectl`. You will have to SSH to each node
    and load the AppArmor profile into the kernel so that the pod may be able to use
    it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，AppArmor不是Kubernetes对象，如pod、部署等。它不能通过`kubectl`操作。您需要SSH到每个节点，并将AppArmor配置文件加载到内核中，以便pod可以使用它。
- en: 'The following is the command for loading the AppArmor profile:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是加载AppArmor配置文件的命令：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, put the profile into `enforce` mode:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将配置文件放入`enforce`模式：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the AppArmor profile is loaded, you can update the annotation of the pod
    to use the AppArmor profile to protect your container. Here is an example of applying
    an AppArmor profile to containers:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了AppArmor配置文件，您可以更新pod的注释，以使用AppArmor配置文件保护您的容器。以下是将AppArmor配置文件应用于容器的示例：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The container inside `hello-apparmor` does nothing but sleep after echoing the
    `Hello AppArmor!` message. When it is running, if you launch a shell from a container
    and write to any file, it will be blocked by AppArmor. Even though writing a robust
    AppArmor profile is not easy, you can still create some basic restrictions, such
    as denying writing to certain directories, denying accepting raw packets, and
    making certain files read-only. Also, test the profile first before applying it
    to the production cluster. Open source tools such as bane can help create AppArmor
    profiles for containers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello-apparmor`内的容器除了在回显“Hello AppArmor！”消息后进入睡眠状态外，什么也不做。当它运行时，如果您从容器中启动一个
    shell 并写入任何文件，AppArmor 将会阻止。尽管编写健壮的 AppArmor 配置文件并不容易，但您仍然可以创建一些基本的限制，比如拒绝写入到某些目录，拒绝接受原始数据包，并使某些文件只读。此外，在将配置应用到生产集群之前，先测试配置文件。开源工具如
    bane 可以帮助为容器创建 AppArmor 配置文件。'
- en: We do not intend to dive into the seccomp profile in this book since writing
    a seccomp profile for a microservice is not easy. Even an application developer
    doesn't have knowledge of what system calls are legitimate for the microservice
    they developed. Although you can turn the audit mode on to avoid breaking the
    microservice's functionality, building a robust seccomp profile is still a long
    way off. Another reason is that this feature is still in the alpha stage up to
    version 1.17\. According to Kubernetes' official documentation, being alpha means
    it is disabled by default, perhaps buggy, and only recommended to run in a short-lived
    testing cluster. When there are any new updates on seccomp, we may come back to
    introduce seccomp in more detail at a later date.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算在本书中深入讨论 seccomp 配置文件，因为为微服务编写 seccomp 配置文件并不容易。即使是应用程序开发人员也不知道他们开发的微服务有哪些系统调用是合法的。尽管您可以打开审计模式以避免破坏微服务的功能，但构建健壮的
    seccomp 配置文件仍然任重道远。另一个原因是，这个功能在版本 1.17 之前仍处于 alpha 阶段。根据 Kubernetes 的官方文档，alpha
    表示默认情况下禁用，可能存在错误，并且只建议在短期测试集群中运行。当 seccomp 有任何新的更新时，我们可能会在以后更详细地介绍 seccomp。
- en: We've covered how to secure Kubernetes pods in the build time. Next, let's look
    at how we can secure Kubernetes pods during runtime.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了如何在构建时保护 Kubernetes Pod。接下来，让我们看看如何在运行时保护 Kubernetes Pod。
- en: The power of PodSecurityPolicy
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PodSecurityPolicy 的力量
- en: A Kubernetes PodSecurityPolicy is a cluster-level resource that controls security-sensitive
    aspects of the pod specification through which the access privileges of a Kubernetes
    pod are limited. As a DevOps engineer, you may want to use a PodSecurityPolicy
    to restrict most of the workloads run in limited access privileges, while only
    allowing a few workloads to be run with extra privileges.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes PodSecurityPolicy 是一个集群级资源，通过它可以控制 pod 规范的安全敏感方面，从而限制 Kubernetes
    pod 的访问权限。作为一名 DevOps 工程师，您可能希望使用 PodSecurityPolicy 来限制大部分工作负载以受限访问权限运行，同时只允许少数工作负载以额外权限运行。
- en: In this section, we will first take a closer look at a PodSecurityPolicy, and
    then we will introduce an open source tool, `kube-psp-advisor`, which can help
    build an adaptive PodSecurityPolicy for the running Kubernetes cluster.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先仔细研究 PodSecurityPolicy，然后介绍一个名为 `kube-psp-advisor` 的开源工具，它可以帮助为运行中的
    Kubernetes 集群构建一个自适应的 PodSecurityPolicy。
- en: Understanding PodSecurityPolicy
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 PodSecurityPolicy
- en: You can think of a PodSecurityPolicy as a policy to evaluate the security attributes
    defined in the pod's specification. Only those pods whose security attributes
    meet the requirements of PodSecurityPolicy will be admitted to the cluster. For
    example, PodSecurityPolicy can be used to block the launch of most privileged
    pods, while only allowing those necessary or limited pods access to the host filesystem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将PodSecurityPolicy视为评估Pod规范中定义的安全属性的策略。只有那些安全属性符合PodSecurityPolicy要求的Pod才会被允许进入集群。例如，PodSecurityPolicy可以用于阻止启动大多数特权Pod，同时只允许那些必要或受限制的Pod访问主机文件系统。
- en: 'The following are the principal security attributes that are controlled by
    PodSecurityPolicy:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由PodSecurityPolicy控制的主要安全属性：
- en: '**privileged**: Determines whether a pod can run in privileged mode.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**privileged**: 确定Pod是否可以以特权模式运行。'
- en: '**hostPID**: Determines whether a pod can use a host PID namespace.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hostPID**: 确定Pod是否可以使用主机PID命名空间。'
- en: '**hostNetwork**: Determines whether a pod can use a host network namespace.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hostNetwork**: 确定Pod是否可以使用主机网络命名空间。'
- en: '**hostIPC**: Determines whether a pod can use a host IPC namespace. The default
    setting is `true`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hostIPC**: 确定Pod是否可以使用主机IPC命名空间。默认设置为`true`。'
- en: '**allowedCapabilities**: Specifies a list of capabilities that could be added
    to containers. The default setting is empty.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**allowedCapabilities**: 指定可以添加到容器中的功能列表。默认设置为空。'
- en: '**defaultAddCapabilities**: Specifies a list of capabilities that will be added
    to containers by default. The default setting is empty.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**defaultAddCapabilities**: 指定默认情况下将添加到容器中的功能列表。默认设置为空。'
- en: '**requiredDropCapabilities**: Specifies a list of capabilities that will be
    dropped from containers. Note that a capability cannot be specified in both the
    `allowedCapabilities` and `requiredDropCapabilities` fields. The default setting
    is empty.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**requiredDropCapabilities**: 指定将从容器中删除的功能列表。请注意，功能不能同时在`allowedCapabilities`和`requiredDropCapabilities`字段中指定。默认设置为空。'
- en: '**readOnlyRootFilesystem**: When set to `true`, the PodSecurityPolicy will
    force containers to run with a read-only root filesystem. If the attribute is
    set to `false` explicitly in the security context of the container, the pod will
    be denied from running. The default setting is `false`.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**readOnlyRootFilesystem**: 当设置为`true`时，PodSecurityPolicy将强制容器以只读根文件系统运行。如果容器的安全上下文中明确将属性设置为`false`，则将拒绝Pod运行。默认设置为`false`。'
- en: '**runAsUser**: Specifies the allowable user IDs that may be set in the security
    context of pods and containers. The default setting allows all.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**runAsUser**: 指定可以在Pod和容器的安全上下文中设置的允许用户ID列表。默认设置允许所有。'
- en: '**runAsGroup**: Specifies the allowable group IDs that may be set in the security
    context of pods and containers. The default setting allows all.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**runAsGroup**: 指定可以在Pod和容器的安全上下文中设置的允许组ID列表。默认设置允许所有。'
- en: '**allowPrivilegeEscalation**: Determines whether a pod can submit a request
    to allow privilege escalation. The default setting is `true`.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**allowPrivilegeEscalation**: 确定Pod是否可以提交请求以允许特权升级。默认设置为`true`。'
- en: '**allowedHostPaths**: Specifies a list of host paths that could be mounted
    by the pod. The default setting allows all.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**allowedHostPaths**: 指定Pod可以挂载的主机路径列表。默认设置允许所有。'
- en: '**volumes**: Specifies a list of volume types that can be mounted by the pod.
    For example, `secret`, `configmap`, and `hostpath` are the valid volume types.
    The default setting allows all.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷**: 指定可以由Pod挂载的卷类型列表。例如，`secret`、`configmap`和`hostpath`是有效的卷类型。默认设置允许所有。'
- en: '**seLinux**: Specifies the allowable `seLinux` labels that may be set in the
    security context of pods and containers. The default setting allows all.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**seLinux**: 指定可以在Pod和容器的安全上下文中设置的允许`seLinux`标签列表。默认设置允许所有。'
- en: '**allowedUnsafeSysctl**: Allows unsafe `sysctls` to run. The default setting
    allows none.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**allowedUnsafeSysctl**：允许运行不安全的`sysctls`。默认设置不允许任何。'
- en: 'Now, let''s take a look at an example of a PodSecurityPolicy:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个PodSecurityPolicy的例子：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This PodSecurityPolicy allows the `NET_ADMIN` and `IPC_LOCK` capabilities, mounts
    `/`, `/dev`, and `/run` from the host and Kubernetes' secret volumes. It doesn't
    enforce any filesystem group ID or supplemental groups and it also allows the
    container to run as any user, access the host network namespace, and run as a
    privileged container. No SELinux policy is enforced in the policy.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个PodSecurityPolicy允许`NET_ADMIN`和`IPC_LOCK`的权限，从主机和Kubernetes的秘密卷挂载`/`，`/dev`和`/run`。它不强制执行任何文件系统组ID或辅助组，也允许容器以任何用户身份运行，访问主机网络命名空间，并以特权容器运行。策略中没有强制执行SELinux策略。
- en: 'To enable this Pod Security Policy, you can run the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用此Pod安全策略，您可以运行以下命令：
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s verify that the Pod Security Policy has been created successfully:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们验证Pod安全策略是否已成功创建：
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output will appear as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After you have created the Pod Security Policy, there is one more step required
    in order to enforce it. You will have to grant the privilege of using the `PodSecurityPolicy`
    object to the users, groups, or service accounts. By doing so, the pod security
    policies are entitled to evaluate the workloads based on the associated service
    account. Here is an example of how to enforce a PodSecurityPolicy. First, you
    will need to create a cluster role that uses the PodSecurityPolicy:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了Pod安全策略后，还需要另一步来强制执行它。您将需要授予用户、组或服务帐户使用`PodSecurityPolicy`对象的特权。通过这样做，Pod安全策略有权根据关联的服务帐户评估工作负载。以下是如何强制执行PodSecurityPolicy的示例。首先，您需要创建一个使用PodSecurityPolicy的集群角色：
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, create a `RoleBinding` or `ClusterRoleBinding` object to associate the
    preceding `ClusterRole` object created with the service accounts, users, or groups:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个`RoleBinding`或`ClusterRoleBinding`对象，将之前创建的`ClusterRole`对象与服务帐户、用户或组关联起来：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding `use-example-pspbinding.yaml` file created a `RoleBinding` object
    to associate the `use-example-psp` cluster role with the `test-sa` service account
    in the `psp-test` namespace. With all of these set up, any workloads in the `psp-test`
    namespace whose service account is `test-sa` will run through the PodSecurityPolicy
    example's evaluation. And only those that meet the requirements will be admitted
    to the cluster.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 之前创建的`use-example-pspbinding.yaml`文件创建了一个`RoleBinding`对象，将`use-example-psp`集群角色与`psp-test`命名空间中的`test-sa`服务帐户关联起来。通过所有这些设置，`psp-test`命名空间中其服务帐户为`test-sa`的任何工作负载将通过PodSecurityPolicy示例的评估。只有符合要求的工作负载才能被允许进入集群。
- en: From the preceding example, think of there being different types of workloads
    running in your Kubernetes cluster, and each of them may require different privileges
    to access different types of resources. It would be a challenge to create and
    manage pod security policies for different workloads. Now, let's take a look at
    `kube-psp-advisor` and see how it can help create pod security policies for you.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的例子中，想象一下在您的Kubernetes集群中运行不同类型的工作负载，每个工作负载可能需要不同的特权来访问不同类型的资源。为不同的工作负载创建和管理Pod安全策略将是一个挑战。现在，让我们来看看`kube-psp-advisor`，看看它如何帮助您创建Pod安全策略。
- en: Kubernetes PodSecurityPolicy Advisor
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes PodSecurityPolicy Advisor
- en: Kubernetes PodSecurityPolicy Advisor (also known as `kube-psp-advisor`) is an
    open source tool from Sysdig. It scans the security attributes of running workloads
    in the cluster and then, on this basis, recommends pod security policies for your
    cluster or workloads.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes PodSecurityPolicy Advisor（也称为`kube-psp-advisor`）是来自Sysdig的开源工具。它扫描集群中运行的工作负载的安全属性，然后基于此推荐您的集群或工作负载的Pod安全策略。
- en: 'First, let''s install `kube-psp-advisor` as a `kubectl` plugin. If you haven''t
    installed `krew`, a `kubectl` plugin management tool, please follow the instructions
    (https://github.com/kubernetes-sigs/krew#installation) in order to install it.
    Then, install `kube-psp-advisor` with `krew` as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将“kube-psp-advisor”作为“kubectl”插件进行安装。如果您还没有安装“krew”，请按照说明（https://github.com/kubernetes-sigs/krew#installation）安装它。然后，使用“krew”安装“kube-psp-advisor”如下：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, you should be able to run the following command to verify the installation:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您应该能够运行以下命令来验证安装：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To generate pod security policies for workloads in a namespace, you can run
    the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要为命名空间中的工作负载生成Pod安全策略，可以运行以下命令：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding command generates pod security policies for workloads running
    inside the `psp-test` namespace. If the workload uses a default service account,
    no PodSecurityPolicy will be generated for it. This is because the default service
    account will be assigned to the workload that does not have a dedicated service
    account associated with it. And you certainly don't want to have a default service
    account that is able to use a PodSecurityPolicy for privileged workloads.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令为在“psp-test”命名空间内运行的工作负载生成了Pod安全策略。如果工作负载使用默认服务账户，则不会为其生成PodSecurityPolicy。这是因为默认服务账户将被分配给没有专用服务账户关联的工作负载。当然，您肯定不希望默认服务账户能够使用特权工作负载的PodSecurityPolicy。
- en: 'Here is an example of output generated by `kube-psp-advisor` for workloads
    in the `psp-test` namespace, including Role, RoleBinding, and PodSecurityPolicy
    in a single `YAML` file with multiple pod security policies. Let''s take a look
    at one of the recommended PodSecurityPolicy:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是“kube-psp-advisor”为“psp-test”命名空间中的工作负载生成的输出示例，包括Role、RoleBinding和PodSecurityPolicy在一个单独的YAML文件中，其中包含多个Pod安全策略。让我们来看一个推荐的PodSecurityPolicy：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Following is the Role generated by `kube-psp-advisor`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由“kube-psp-advisor”生成的Role：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Following is the RoleBinding generated by `kube-psp-advisor`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由“kube-psp-advisor”生成的RoleBinding：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding section is the recommended PodSecurityPolicy, `psp-for-psp-test-sa-1`,
    for the `busy-rs` and `busy-pod` workloads, since these two workloads share the
    same service account, `sa-1`. Hence, `Role` and `RoleBinding` are created to use
    the Pod Security Policy, `psp-for-psp-test-sa-1`, respectively. The PodSecurityPolicy
    is generated based on the aggregation of the security attributes of workloads
    using the `sa-1` service account:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分是推荐的PodSecurityPolicy，“psp-for-psp-test-sa-1”，适用于“busy-rs”和“busy-pod”工作负载，因为这两个工作负载共享相同的服务账户“sa-1”。因此，分别创建了“Role”和“RoleBinding”来使用Pod安全策略“psp-for-psp-test-sa-1”。PodSecurityPolicy是基于使用“sa-1”服务账户的工作负载的安全属性的聚合生成的：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding section mentions that the `busy-rc` workload uses a `default`
    service account, so there is no Pod Security Policy created for it. This is a
    reminder that if you want to generate pod security policies for workloads, don't
    use the default service account.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分提到“busy-rc”工作负载使用“default”服务账户，因此不会为其创建Pod安全策略。这是一个提醒，如果要为工作负载生成Pod安全策略，请不要使用默认服务账户。
- en: Building a Kubernetes PodSecurityPolicy is not straightforward, although it
    would be ideal if a single restricted PodSecurityPolicy was to apply to the entire
    cluster and all workloads complied with it. DevOps engineers need to be creative
    in order to build restricted pod security policies while not breaking workloads'
    functionalities. `kube-psp-advisor` makes the implementation of Kubernetes pod
    security policies simple, adapts to your application requirements and, specifically,
    is fine-grained for each one to allow only the privilege of least access.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Kubernetes PodSecurityPolicy并不是一件简单的事情，尽管如果一个受限的PodSecurityPolicy适用于整个集群，并且所有工作负载都符合它将是理想的。DevOps工程师需要有创造力，以便构建受限的Pod安全策略，同时不破坏工作负载的功能。`kube-psp-advisor`使得实施Kubernetes
    Pod安全策略变得简单，适应您的应用程序要求，并且特别为每个应用程序提供了细粒度的权限，只允许最少访问权限的特权。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered how to harden a container image with CIS Docker
    benchmarks, and then we gave a detailed introduction to the security attributes
    of Kubernetes workloads. Next, we looked at the PodSecurityPolicy in detail and
    introduced the `kube-psp-advisor` open source tool, which facilitates the establishment
    of pod security policies.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了如何使用CIS Docker基准来加固容器镜像，然后详细介绍了Kubernetes工作负载的安全属性。接下来，我们详细介绍了PodSecurityPolicy，并介绍了`kube-psp-advisor`开源工具，该工具有助于建立Pod安全策略。
- en: Securing Kubernetes workloads is not a one-shot thing. Security controls need
    to be applied from the build, deployment, and runtime stages. It starts with hardening
    container images, and then configuring security attributes of Kubernetes workloads
    in a secure way. This happens at the build stage. It is also important to build
    adaptive pod security policies for different Kubernetes workloads. The goal is
    to restrict most of the workloads to run with limited privileges, while allowing
    only a few workloads to run with extra privileges, and without breaking workload
    availability. This happens at the runtime stage. `kube-psp-advisor` is able to
    help build adaptive pod security policies.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 保护Kubernetes工作负载不是一蹴而就的事情。安全控制需要从构建、部署和运行阶段应用。它始于加固容器镜像，然后以安全的方式配置Kubernetes工作负载的安全属性。这发生在构建阶段。为不同的Kubernetes工作负载构建自适应的Pod安全策略也很重要。目标是限制大多数工作负载以受限权限运行，同时只允许少数工作负载以额外权限运行，而不会破坏工作负载的可用性。这发生在运行时阶段。`kube-psp-advisor`能够帮助构建自适应的Pod安全策略。
- en: In the next chapter, we will talk about image scanning. It is critical in helping
    to secure Kubernetes workloads in the DevOps workflow.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论图像扫描。在DevOps工作流程中，这对于帮助保护Kubernetes工作负载至关重要。
- en: Questions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does `HEALTHCHECK` do in a Dockerfile?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Dockerfile中，`HEALTHCHECK`是做什么的？
- en: Why use `COPY` instead of `ADD` in a Dockerfile?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在Dockerfile中使用`COPY`而不是`ADD`？
- en: If your application doesn't listen on any port, which default capabilities can
    be dropped?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的应用程序不监听任何端口，可以丢弃哪些默认功能？
- en: What does the `runAsNonRoot` attribute control?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`runAsNonRoot`属性控制什么？'
- en: When you create a `PodSecurityPolicy` object, what else do you need to do in
    order to enforce that Pod Security Policy on workloads?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您创建一个`PodSecurityPolicy`对象时，为了强制执行该Pod安全策略，您还需要做什么？
- en: Further reading
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下链接，了解本章涵盖的主题的更多信息：
- en: 'To learn more about `kube-psp-advisor`, please visit the following link: [https://github.com/sysdiglabs/kube-psp-advisor](https://github.com/sysdiglabs/kube-psp-advisor)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关`kube-psp-advisor`的更多信息，请访问以下链接：[https://github.com/sysdiglabs/kube-psp-advisor](https://github.com/sysdiglabs/kube-psp-advisor)
- en: 'To learn more about AppArmor, please visit the following link: [https://gitlab.com/apparmor/apparmor/-/wikis/Documentation](https://gitlab.com/apparmor/apparmor/-/wikis/Documentation)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关AppArmor的更多信息，请访问以下链接：[https://gitlab.com/apparmor/apparmor/-/wikis/Documentation](https://gitlab.com/apparmor/apparmor/-/wikis/Documentation)
- en: 'To learn more about bane, please visit the following link: [https://github.com/genuinetools/bane](https://github.com/genuinetools/bane)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关bane的更多信息，请访问以下链接：[https://github.com/genuinetools/bane](https://github.com/genuinetools/bane)
