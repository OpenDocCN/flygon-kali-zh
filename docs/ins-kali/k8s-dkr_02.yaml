- en: '*Chapter 1*: Docker and Container Essentials'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：Docker和容器基础知识'
- en: Containers are one of the most transformational technologies that we have seen
    in years. Technology companies, corporations, and end users have all adopted it
    to handle everyday workloads. Increasingly, **common off-the-shelf** (**COTS**)
    applications are transforming from traditional installations into fully containerized
    deployments. With such a large technology shift, it is essential for anyone in
    the Information Technology realm to learn about containers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是我们多年来见过的最具变革性的技术之一。技术公司、企业和最终用户都采用它来处理日常工作负载。越来越多的**通用现成**（**COTS**）应用程序正在从传统安装转变为完全容器化的部署。随着这样一个巨大的技术转变，任何信息技术领域的人都有必要了解容器。
- en: In this chapter, we will introduce the problems that containers address. After
    an introduction to why containers are important, we will introduce the runtime
    that launched the modern container frenzy, Docker. By the end of this chapter,
    you will understand how to install Docker and how to use the most common Docker
    CLI commands.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将介绍容器解决的问题。在介绍容器的重要性之后，我们将介绍引发现代容器狂热的运行时，Docker。通过本章的学习，您将了解如何安装Docker以及如何使用最常见的Docker
    CLI命令。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Understanding the need for containerization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解容器化的需求
- en: Understanding Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Docker
- en: Installing Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Docker
- en: Using the Docker CLI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker CLI
- en: Let's get started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following technical requirements:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章有以下技术要求：
- en: An Ubuntu 18.04 server with a minimum of 4 GB of RAM, though 8 GB is suggested
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Ubuntu 18.04服务器，至少需要4GB的RAM，建议使用8GB
- en: 'You can access the code for this chapter by going to the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问以下GitHub存储库获取本章的代码：[https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide)。
- en: Understanding the need for containerization
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器化的需求
- en: 'You may have experienced a conversation like this at your office or school:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能在办公室或学校经历过这样的对话：
- en: '**Developer**: *"Here''s the new application. It went through weeks of testing
    and you are the first to get the new release."*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发者**：“这是新的应用程序。经过数周的测试，你是第一个获得新版本的人。”'
- en: '*….. A little while later ….*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*….. 过了一会儿 ….*'
- en: '**User**: *"It''s not working. When I click the submit button, it shows an
    error about a missing dependency."*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户**：“它不工作。当我点击提交按钮时，它显示了一个缺少依赖项的错误。”'
- en: '**Developer**: *"That''s weird; it''s working fine on my machine."*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发者**：“这很奇怪；在我的机器上一切都正常。”'
- en: This is one of the most frustrating things a developer can encounter when delivering
    an application. Often, the issues that creep up are related to a library that
    the developer had on their machine, but it wasn't included in the distribution
    of the package. It may seem like an easy fix for this would be to include all
    the libraries alongside the release, but what if this release contains a newer
    library that overwrites the older version, which may be required for a different
    application?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这是开发者交付应用程序时可能遇到的最令人沮丧的事情之一。经常出现的问题与开发者在他们的机器上使用的库有关，但这些库并未包含在软件包的分发中。似乎一个简单的解决方法是将所有的库都包含在发布中，但如果这个发布包含一个新的库，它会覆盖旧版本，而这可能是其他应用程序所需要的。
- en: Developers need to consider their new releases, as well as any potential conflicts
    with any existing software on the user's workstations. This often becomes a careful
    balancing act that requires larger deployment teams to test the application on
    different system configurations. It can also lead to additional rework for the
    developer or, in some extreme cases, full incompatibility with an existing application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员需要考虑他们的新发布，以及与用户工作站上任何现有软件可能存在的冲突。这经常成为一个需要更大的部署团队在不同的系统配置上测试应用程序的谨慎平衡行为。这可能会导致开发人员需要额外的重做，或者在一些极端情况下，与现有应用程序完全不兼容。
- en: There have been various attempts to make application delivery easier over the
    years. First, there are solutions such as **VMware**'s **Thinapp**, which virtualize
    san application (not to be confused with virtualizing an operating system). It
    allows you to package the application and its dependencies into a single executable
    package. This packaging eliminates the issues of an application's dependencies
    conflicting with another application's dependencies since the application is in
    a self-contained package. This provided application isolation not only eliminates
    dependency issues but also provides an enhanced level of security and eases the
    burden of operating system migrations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，已经有各种尝试使应用程序交付变得更加容易。首先，有诸如VMware的Thinapp之类的解决方案，它们虚拟化了一个应用程序（不要与虚拟化操作系统混淆）。它允许您将应用程序及其依赖项打包到一个单个可执行包中。这种打包消除了应用程序依赖项与另一个应用程序的依赖项发生冲突的问题，因为应用程序在一个自包含的包中。这种打包提供的应用程序隔离不仅消除了依赖性问题，还提供了更高级别的安全性，并减轻了操作系统迁移的负担。
- en: You may or may not have heard of application streaming before reading this book.
    It sounds like a great solution to the "it worked on my machine" issue. There
    are many reasons it hasn't taken off as expected, though. For starters, most offerings
    are paid solutions that require a substantial investment. Besides licensing, they
    require a "clean PC," which means that for every application you want to virtualize,
    you need to start with a base system. The package you want to create uses the
    differences between the base installation and anything that was added after the
    initial system snapshot. The differences are then packaged into your distribution
    file, which can be executed on any workstation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本书之前，您可能已经听说过应用程序流式传输，这听起来像是解决“在我的机器上可以运行”的问题的一个很好的解决方案。尽管有许多原因导致它没有如预期般成功。首先，大多数提供的解决方案都是需要大量投资的付费解决方案。除了许可证，它们还需要一个“干净的PC”，这意味着对于您想要虚拟化的每个应用程序，您都需要从一个基本系统开始。您想要创建的软件包使用了基本安装和初始系统快照后添加的任何内容之间的差异。然后，这些差异被打包到您的分发文件中，可以在任何工作站上执行。
- en: We've mentioned application virtualization to highlight that application issues
    such as "It works on my machine" have had different solutions over the years.
    Products such as **Thinapp** are just one attempt at solving the problem. Other
    attempts include running the application on a server running **Citrix** or **Remote
    Desktop**, **Linux containers**, and even **virtual machines**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到应用程序虚拟化是为了突出多年来“在我的机器上可以运行”的应用程序问题已经有了不同的解决方案。像Thinapp这样的产品只是解决这个问题的一种尝试。其他尝试包括在运行Citrix或远程桌面的服务器上运行应用程序，Linux容器，甚至虚拟机。
- en: Introducing Docker
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入Docker
- en: The industry and even end users needed something that was easier and cheaper
    – enter Docker containers. Containers are not a new technology; they have been
    used in various forms for years. What Docker did was make them accessible to the
    average developer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 行业甚至最终用户需要更简单、更便宜的东西——Docker容器应运而生。容器并不是一种新技术；多年来它们以各种形式被使用。Docker所做的是让它们对普通开发人员可访问。
- en: Docker brought an abstraction layer to the masses. It was easy to use and didn't
    require a clean PC for every application before creating a package, thus offering
    a solution for dependency issues, but most attractive of all, it was *free*. Docker
    became a standard for many projects on GitHub, where teams would often create
    a Docker container and distribute the Docker image or **Dockerfile** to team members,
    providing a standard testing or development environment. This adoption by end
    users is what eventually brought Docker to the enterprise and, ultimately, what
    made it the standard it has become today.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Docker为大众带来了一个抽象层。它易于使用，并且在创建软件包之前不需要为每个应用程序清理PC，因此提供了解决依赖问题的解决方案，但最吸引人的是它是*免费*的。
    Docker成为GitHub上许多项目的标准，团队经常会创建Docker容器并向团队成员分发Docker镜像或**Dockerfile**，提供标准的测试或开发环境。最终，最终用户的采用是最终将Docker引入企业并最终使其成为标准的原因。
- en: While there are many books on Docker, this book focuses on the base topics of
    Docker that are used to interact with containers. This book will be focusing on
    what you will need to know when trying to use a local Kubernetes environment.
    There is a long and interesting history of Docker and how it evolved into the
    standard container image format that we use today. We encourage you to read about
    the company and how they ushered in the container world we know today.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有很多关于Docker的书，但本书侧重于与容器交互所使用的Docker的基本主题。本书将侧重于在尝试使用本地Kubernetes环境时需要了解的内容。Docker有一个悠久而有趣的历史，以及它是如何演变成我们今天使用的标准容器镜像格式的。我们鼓励你阅读有关这家公司以及他们是如何引领我们今天所知的容器世界的历史。
- en: While our focus is not to teach Docker inside-out, we felt that those of you
    who are new to Docker would benefit from a quick primer on general container concepts.
    If you have some Docker experience and understand terminology such as ephemeral
    and stateless, feel free to continue to the *Installing Docker* section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的重点不是全面教授Docker，但我们认为那些对Docker新手会受益于对一般容器概念的快速入门。如果您有一些Docker经验并且了解临时和无状态等术语，请继续阅读*安装Docker*部分。
- en: Understanding Docker
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Docker
- en: This book was created with the assumption that you have some basic knowledge
    of Docker and container concepts. We realize that not everyone may have played
    with Docker or containers in the past, so we wanted to present a crash course
    on container concepts and using Docker.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设您对Docker和容器概念有一些基本的了解。我们意识到并非每个人都可能以前使用过Docker或容器，因此我们希望对容器概念和使用Docker进行快速入门。
- en: Important Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you are new to containers, we suggest reading the documentation that can
    be found on Docker''s website for additional information: [https://docs.docker.com/](https://docs.docker.com/).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是容器的新手，我们建议阅读Docker网站上可以找到的文档以获取更多信息：[https://docs.docker.com/](https://docs.docker.com/)。
- en: Containers are ephemeral
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器是临时的
- en: The first topic to understand is that container images are ephemeral.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首要理解的主题是容器镜像是临时的。
- en: For those of you who are new to Docker, the term ephemeral means short-lived.
    By design, a container can be destroyed at any time and brought back up with no
    interaction from a user. In the preceding example, someone interactively added
    files to a web server. These added files are only temporary since the base image
    does not have these files included in it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对Docker新手来说，临时的意思是短暂的。按设计，容器可以随时被销毁，并在没有用户干预的情况下重新启动。在前面的例子中，有人交互地向web服务器添加了文件。这些添加的文件只是临时的，因为基础镜像中并不包含这些文件。
- en: 'This means that once a container is created and running, any changes that are
    made to the image *will not* be saved once the container is removed, or destroyed,
    from the Docker host. Let''s look at an example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一旦创建并运行容器，对镜像进行的任何更改在容器从Docker主机中删除或销毁时都不会被保存。让我们看一个例子：
- en: You start a container running a web server using **NGINX** on your host without
    any base **HTML** pages.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在主机上启动一个使用**NGINX**运行的web服务器的容器，而没有任何基本的**HTML**页面。
- en: Using a Docker command, you execute a **copy** command to copy some web files
    into the container's filesystem.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Docker命令，您执行**copy**命令将一些web文件复制到容器的文件系统中。
- en: To test that the copy was successful, you browse to the website and confirm
    that it is serving the correct web pages.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试复制是否成功，您浏览网站并确认它正在提供正确的网页。
- en: Happy with the results, you stop the container and remove it from the host.
    Later that day, you want to show a co-worker the website and you start your NGINX
    container. You browse to the website again, but when the site opens, you receive
    a 404 error (page not found error).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对结果感到满意后，您停止容器并从主机中删除它。当天晚些时候，您想向同事展示网站，然后启动NGINX容器。您再次浏览网站，但当网站打开时，您收到404错误（页面未找到错误）。
- en: What happened to the files you uploaded before you stopped and removed the container
    from the host?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在您停止并从主机中删除容器之前上传的文件发生了什么？
- en: The reason your web pages cannot be found after the container was restarted
    is because all containers are **ephemeral**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 容器重新启动后无法找到您上传的网页的原因是因为所有容器都是**短暂的**。
- en: Whatever is in the base container image is all that will be included each time
    the container is initially started. Any changes that you make inside a container
    are short-lived.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基本容器镜像中的内容是每次容器最初启动时都会包含的内容。您在容器内部进行的任何更改都是短暂的。
- en: If you needed to add permanent files to the existing image, you would need to
    rebuild the image with the files included or, as we will explain in the *Persistent
    data* section later in this chapter, you could mount a Docker volume in your container.
    At this point, the main concept to understand is that containers are ephemeral.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要向现有镜像添加永久文件，则需要使用包含文件的镜像重新构建镜像，或者，正如我们将在本章后面的*持久数据*部分中解释的那样，您可以在容器中挂载Docker卷。在这一点上，要理解的主要概念是容器是短暂的。
- en: But wait! You may be wondering, *"If containers are ephemeral, how did I add
    web pages to the server?"*. Ephemeral just means that changes will not be saved;
    it doesn't stop you from making changes to a running container.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！您可能会想，*"如果容器是短暂的，那我是如何向服务器添加网页的呢？"*。短暂只是意味着更改不会被保存；这并不妨碍您对正在运行的容器进行更改。
- en: Any changes made to a running container will be written to a temporary layer,
    called the **container layer**, which is a directory on the local host filesystem.
    The Docker storage driver is in charge of handling requests that use the container
    layer. This location will store any changes in the container's filesystem so that
    when you added the HTML pages to the container, they will be stored on the local
    host. The container layer is tied to the container ID of the running image and
    it will remain on the host system until the container is removed from Docker,
    either by using the CLI or by running a Docker prune job.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对正在运行的容器进行的任何更改都将被写入临时层，称为**容器层**，这是本地主机文件系统上的一个目录。Docker存储驱动程序负责处理使用容器层的请求。此位置将存储容器文件系统中的任何更改，因此当您将HTML页面添加到容器时，它们将存储在本地主机上。容器层与正在运行的镜像的容器ID相关联，并且将保留在主机系统上，直到通过使用CLI或运行Docker清理作业从Docker中删除容器。
- en: If a container is ephemeral and the image cannot be written to, how can you
    modify data in the container? Docker uses image layering to create multiple linked
    layers that appear as a single filesystem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个容器是临时的，镜像无法被写入，你如何修改容器中的数据呢？Docker使用镜像分层来创建多个链接的层，看起来像是一个单一的文件系统。
- en: Docker images
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker镜像
- en: At a high level, a Docker image is a collection of image layers, each with a
    JSON file that contains metadata for the layer. These are all combined to create
    the running application that you interact with when a container image is started.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，Docker镜像是一组镜像层，每个层都有一个包含该层元数据的JSON文件。这些都被组合在一起，创建了当容器镜像启动时你与之交互的运行应用程序。
- en: You can read more about the contents of an image on Docker's GitHub at [https://github.com/moby/moby/blob/master/image/spec/v1.md](https://github.com/moby/moby/blob/master/image/spec/v1.md).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Docker的GitHub上阅读更多关于镜像内容的信息 [https://github.com/moby/moby/blob/master/image/spec/v1.md](https://github.com/moby/moby/blob/master/image/spec/v1.md)。
- en: Image layers
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像层
- en: 'As we mentioned in the previous section, a running container uses a container
    layer that is "on top" of the base image layer, as shown in the following diagram:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中提到的，运行中的容器使用一个位于基础镜像层“之上”的容器层，如下图所示：
- en: '![Figure 1.1 – Docker image layers'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 – Docker镜像层'
- en: '](image/Fig_1.1_B15514.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_1.1_B15514.jpg)'
- en: Figure 1.1 – Docker image layers
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – Docker镜像层
- en: The image layers cannot be written to since they are in a read-only state, but
    the temporary container layer is in a writeable state. Any data that you add to
    the container is stored in this layer and will be retained as long as the container
    is running.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像层无法被写入，因为它们处于只读状态，但是临时的容器层是可写的。你添加到容器中的任何数据都存储在这个层中，并且只要容器在运行，它就会被保留。
- en: To deal with multiple layers efficiently, Docker implements copy-on-write, which
    means that if a file already exists, it will not be created. However, if a file
    is required that does not exist in the current image, it will be written. In the
    container world, if a file exists in a lower layer, the layers above it do not
    need to include it. For example, if layer 1 had a file called **/opt/nginx/index.html**
    in it, layer 2 does not need the same file in its layer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效处理多个层，Docker实现了写时复制，这意味着如果文件已经存在，它将不会被创建。但是，如果当前镜像中需要一个不存在的文件，它将被写入。在容器世界中，如果一个文件存在于较低的层中，它上面的层就不需要包含它。例如，如果第一层中有一个名为
    **/opt/nginx/index.html** 的文件，第二层就不需要在它的层中包含相同的文件。
- en: This explains how the system handles files that either exist or do not exist,
    but what about a file that has been modified? There will be times where you'll
    need to "replace" a file that is in a lower layer. You may need to do this when
    you are building an image or as a temporary fix to a running container issue.
    The copy-on-write system knows how to deal with these issues. Since images read
    from the top down, the container uses only the highest layer file. If your system
    had a **/opt/nginx/index.html** file in layer 1 and you modified and saved the
    file, the running container would store the new file in the container layer. Since
    the container layer is the topmost layer, the new copy of **index.html** would
    always be read before the older version in the image layer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了系统如何处理已经存在或不存在的文件，但是对于已经被修改的文件呢？有时候你需要“替换”一个位于较低层的文件。当你构建一个镜像或者临时修复一个运行中的容器问题时，你可能需要这样做。写时复制系统知道如何处理这些问题。由于镜像是自上而下读取的，容器只使用最高层的文件。如果你的系统在第一层有一个
    **/opt/nginx/index.html** 文件，并且你修改并保存了这个文件，运行中的容器会将新文件存储在容器层中。由于容器层是最顶层的层，所以镜像层中旧版本的
    **index.html** 总是会在新版本之前被读取。
- en: Persistent data
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久数据
- en: We will talk about how to use persistent disks in [*Chapter 2*](B15514_02_Final_ASB_ePub.xhtml#_idTextAnchor044),
    *Working with Docker Data*. For now, we will just provide a brief introduction.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第2章*](B15514_02_Final_ASB_ePub.xhtml#_idTextAnchor044)中讨论如何使用持久磁盘，*使用Docker数据*。现在，我们只提供一个简要介绍。
- en: Being limited to ephemeral-only containers would severely limit the use cases
    for Docker. It is very likely that you will have some use cases that will require
    persistent storage, or data that will remain if you stop a container.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 仅限于短暂容器将严重限制Docker的用例。很可能您会有一些用例需要持久存储，或者数据会在停止容器后保留。
- en: This may seem like we are contradicting our earlier statement that containers
    are ephemeral, but that is still true. When you store data in the container image
    layer, the base image does not change. When the container is removed from the
    host, the container layer is also removed. If the same image is used to start
    a new container, a new container image layer is also created. So, the container
    is ephemeral, but by adding a Docker volume to the container, you can store data
    outside of the container, thus gaining data persistency.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来与我们之前关于容器是短暂的说法相矛盾，但这仍然是真的。当您将数据存储在容器镜像层中时，基础镜像不会改变。当容器从主机中移除时，容器层也会被移除。如果使用相同的镜像来启动一个新的容器，也会创建一个新的容器镜像层。因此，容器是短暂的，但通过向容器添加Docker卷，您可以在容器之外存储数据，从而获得数据持久性。
- en: Docker provides persistency through a few methods, which we will discuss in
    more detail in [*Chapter 2*](B15514_02_Final_ASB_ePub.xhtml#_idTextAnchor044),
    *Working with Docker Data*, but for now, know that Docker does provide a method
    to persist your data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Docker通过几种方法提供持久性，我们将在[*第2章*](B15514_02_Final_ASB_ePub.xhtml#_idTextAnchor044)中更详细地讨论，*使用Docker数据*，但现在知道Docker确实提供了一种持久化数据的方法。
- en: Accessing services running in containers
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问运行在容器中的服务
- en: We will talk about how to expose containers in [*Chapter 3*](B15514_03_Final_ASB_ePub.xhtml#_idTextAnchor062),
    *Understanding Docker Networking*. For now, we will just provide a brief introduction.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第3章*](B15514_03_Final_ASB_ePub.xhtml#_idTextAnchor062)中讨论如何暴露容器，*理解Docker网络*。现在，我们只提供一个简要介绍。
- en: Unlike a physical machine or a virtual machine, containers do not connect to
    a network directly. When a container needs to send or receive traffic, it goes
    through the Docker host system using a bridged **NAT network** connection. This
    means that when you run a container and you want to receive incoming traffic requests,
    you need to expose the ports for each of the containers that you wish to receive
    traffic on. On a Linux-based system, **iptables** has rules to forward traffic
    to the Docker daemon, which will service the assigned ports for each container.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与物理机或虚拟机不同，容器不直接连接到网络。当容器需要发送或接收流量时，它通过Docker主机系统使用桥接**NAT网络**连接。这意味着当您运行一个容器并且希望接收传入的流量请求时，您需要为希望接收流量的每个容器公开端口。在基于Linux的系统上，**iptables**有规则来将流量转发到Docker守护程序，它将为每个容器服务分配的端口。
- en: That completes the introduction to base containers and Docker. In the next section,
    we will explain how to install Docker on a host.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了对基本容器和Docker的介绍。在下一节中，我们将解释如何在主机上安装Docker。
- en: Installing Docker
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: The hands-on exercises in this book will require that you have a working Docker
    host. You can follow the steps in this book, or you can execute the script located
    in this book's GitHub repository, in the **chapter1** directory, called **install-docker.sh**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的实践练习将需要您拥有一个可用的Docker主机。您可以按照本书中的步骤操作，或者您可以执行本书GitHub存储库中位于**chapter1**目录下的脚本**install-docker.sh**。
- en: Today, you can install Docker on just about every hardware platform out there.
    Each version of Docker acts and looks the same on each platform, making development
    and using Docker easy for people who need to develop cross-platform applications.
    By making the functions and commands the same between different platforms, developers
    do not need to learn a different container runtime to run images.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，你几乎可以在所有硬件平台上安装Docker。每个版本的Docker在每个平台上的操作和外观都是相同的，这使得需要开发跨平台应用程序的人们可以轻松开发和使用Docker。通过在不同平台之间使功能和命令相同，开发人员不需要学习不同的容器运行时来运行图像。
- en: 'The following is a table of Docker''s available platforms. As you can see,
    there are installations for multiple operating systems, as well as multiple CPU
    architectures:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Docker可用平台的表格。你可以看到，有多个操作系统的安装，以及多个CPU架构的安装：
- en: '![Figure 1.2 – Available Docker platforms'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 - 可用的Docker平台'
- en: '](image/Fig_1.2_B15514.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_1.2_B15514.jpg)'
- en: Figure 1.2 – Available Docker platforms
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 - 可用的Docker平台
- en: Important Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Images that are created using one architecture cannot run on a different architecture.
    This means that you cannot create an image based on x86 hardware and expect that
    same image to run on your Raspberry Pi running an ARM processor. It's also important
    to note that while you can run a Linux container on a Windows machine, you cannot
    run a Windows container on a Linux machine.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一种架构创建的图像无法在不同的架构上运行。这意味着你不能基于x86硬件创建图像，然后期望同样的图像在运行ARM处理器的树莓派上运行。同样重要的是要注意，虽然你可以在Windows机器上运行Linux容器，但你不能在Linux机器上运行Windows容器。
- en: 'The installation procedures that are used to install Docker vary between platforms.
    Luckily, Docker has documented many of the installation procedures on their website:
    [https://docs.docker.com/install/](https://docs.docker.com/install/).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 用于安装Docker的安装程序在不同平台之间有所不同。幸运的是，Docker已经在他们的网站上记录了许多安装程序：[https://docs.docker.com/install/](https://docs.docker.com/install/)。
- en: In this chapter, we will install Docker on an Ubuntu 18.04 system. If you do
    not have an Ubuntu machine to install on, you can still read about the installation
    steps, as each step will be explained and does not require that you have a running
    system to understand the process. If you have a different Linux installation,
    you can use the installation procedures outlined on Docker's site at [https://docs.docker.com/](https://docs.docker.com/).
    Steps are provided for CentOS, Debian, Fedora, Ubuntu, and there are generic steps
    for other Linux distributions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在Ubuntu 18.04系统上安装Docker。如果你没有Ubuntu机器可以安装，你仍然可以阅读安装步骤，因为每个步骤都将得到解释，不需要你有一个运行的系统来理解这个过程。如果你有不同的Linux安装，你可以使用Docker网站上概述的安装程序[https://docs.docker.com/](https://docs.docker.com/)。为CentOS、Debian、Fedora、Ubuntu提供了步骤，并为其他Linux发行版提供了通用步骤。
- en: Preparing to install Docker
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备安装Docker
- en: Before we start the installation, we need to consider what storage driver to
    use. The storage driver is what provides the union filesystem, which manage the
    layers of the container and how the writeable layer of the container is accessed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始安装之前，我们需要考虑使用什么存储驱动程序。存储驱动程序提供了联合文件系统，管理容器的层以及容器的可写层是如何访问的。
- en: In most installations, you won't need to change the default storage driver since
    a default option will be selected. If you are running a Linux kernel that is at
    least version 4.0 or above, your Docker installation will use the **overlay2**
    storage driver; earlier kernels will install the **AUFS** storage driver.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数安装中，你不需要更改默认的存储驱动程序，因为会选择默认选项。如果你运行的是至少4.0或更高版本的Linux内核，你的Docker安装将使用**overlay2**存储驱动程序；较早的内核将安装**AUFS**存储驱动程序。
- en: For reference, along with the **overlay2** and **AUFS** drivers, Docker supports
    the **devicemapper**, **btrfs**, **zfs**, and **vfs** storage drivers. However,
    these are rarely used in new systems and are only mentioned here as a reference.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 供参考，除了**overlay2**和**AUFS**驱动程序外，Docker还支持**devicemapper**、**btrfs**、**zfs**和**vfs**存储驱动程序。但是，这些在新系统中很少使用，这里仅作为参考提到。
- en: 'If you would like to learn about each storage driver, take a look at the following
    Docker web page, which details each driver and their use cases: [https://docs.docker.com/storage/storagedriver/select-storage-driver/](https://docs.docker.com/storage/storagedriver/select-storage-driver/).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解每个存储驱动程序，请查看以下Docker网页，该网页详细介绍了每个驱动程序及其用例：[https://docs.docker.com/storage/storagedriver/select-storage-driver/](https://docs.docker.com/storage/storagedriver/select-storage-driver/)。
- en: 'Now that you understand the storage driver requirements, the next step is to
    select an installation method. You can install Docker using one of three methods:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了存储驱动程序的要求，下一步是选择安装方法。您可以使用三种方法之一安装Docker：
- en: Add the Docker repositories to your host system.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Docker存储库添加到您的主机系统中。
- en: Install the package manually.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动安装软件包。
- en: Use a supplied installation script from Docker.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker提供的安装脚本。
- en: The first option is considered the best option since it allows for easy installation
    and making updates to the Docker engine. The second option is useful for enterprises
    that do not have internet access to servers, also known as "air-gapped" servers.
    The third option is used to install edge and testing versions of Docker and is
    not suggested for production use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种选项被认为是最佳选项，因为它允许轻松安装和更新Docker引擎。第二个选项适用于没有互联网访问服务器的企业，也称为“空隙”服务器。第三个选项用于安装Docker的边缘和测试版本，不建议用于生产环境。
- en: Since the preferred method is to add Docker's repository to our host, we will
    use that option and explain the process we should use to add the repository and
    install Docker.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于首选方法是将Docker的存储库添加到我们的主机，我们将使用该选项并解释应该使用的过程来添加存储库并安装Docker。
- en: Installing Docker on Ubuntu
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Ubuntu上安装Docker
- en: 'Now that we have finished preparing everything, let''s install Docker:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了一切，让我们安装Docker：
- en: 'The first step is to update the package index by executing **apt-get update**:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是通过执行**apt-get update**来更新软件包索引：
- en: '**sudo apt-get update**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo apt-get update**'
- en: 'Next, we need to add any packages that may be missing on the host system to
    allow HTTPS apt access:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加可能在主机系统上缺失的任何软件包，以允许HTTPS apt访问：
- en: '**sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent
    software-properties-common**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo apt-get install apt-transport-https ca-certificates curl gnupg-agent
    software-properties-common**'
- en: 'To pull packages from Docker''s repository, we need to add their keys. You
    can add keys by using the following command, which will download the gpg key and
    add it to your system:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从Docker的存储库中拉取软件包，我们需要添加它们的密钥。您可以使用以下命令添加密钥，该命令将下载gpg密钥并将其添加到您的系统中：
- en: '**curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add
    –**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add
    –**'
- en: 'Now, add Docker''s repository to your host system:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将Docker的存储库添加到您的主机系统中：
- en: '**sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu
    $(lsb_release -cs) stable"**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu
    $(lsb_release -cs) stable"**'
- en: 'With all the prerequisites completed, you can install Docker on your server:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成所有先决条件后，您可以在服务器上安装Docker：
- en: '**sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io**'
- en: 'Docker is now installed on your host, but like most new services, Docker is
    not currently running and has not been configured to start with the system. To
    start Docker and enable it on startup, use the following command:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker现在已安装在您的主机上，但与大多数新服务一样，Docker目前未运行，并且尚未配置为随系统启动。要启动Docker并在启动时启用它，请使用以下命令：
- en: '**sudo systemctl enable docker && systemctl start docker**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**sudo systemctl enable docker && systemctl start docker**'
- en: Now that we have Docker installed, let's get some configuration out of the way.
    First, we'll grant permissions to Docker.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了Docker，让我们先进行一些配置。首先，我们将授予Docker权限。
- en: Granting Docker permissions
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授予Docker权限
- en: In a default installation, Docker requires root access, so you will need to
    run all Docker commands as root. Rather than using **sudo** with every Docker
    command, you can add your user account to a new group on the server that provides
    Docker access without requiring **sudo** for every command.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认安装中，Docker需要root访问权限，因此您需要以root身份运行所有Docker命令。您可以将您的用户帐户添加到服务器上的一个新组，以便在不需要对每个命令使用sudo的情况下提供Docker访问权限。
- en: 'If you are logged on as a standard user and try to run a Docker command, you
    will receive an error:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以标准用户身份登录并尝试运行Docker命令，您将收到一个错误：
- en: 'Got permission denied while trying to connect to the Docker daemon socket at
    unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/images/json:
    dial unix /var/run/docker.sock: connect: permission denied'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试连接到Docker守护程序套接字unix:///var/run/docker.sock时，出现了权限被拒绝的情况：获取http://%2Fvar%2Frun%2Fdocker.sock/v1.40/images/json:拨号unix
    /var/run/docker.sock:连接：权限被拒绝
- en: 'To allow your user, or any other user you may want to add to execute Docker
    commands, you need to create a new group and add the users to that group. The
    following is an example command you can use to add the currently logged on user:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许您的用户或任何其他您想要添加的用户执行Docker命令，您需要创建一个新的组并将用户添加到该组中。以下是一个示例命令，您可以使用它来添加当前登录的用户：
- en: sudo groupadd docker sudo usermod -aG docker $USER
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用sudo groupadd docker命令和sudo usermod -aG docker $USER命令
- en: The first command creates the **docker** group, while the second command adds
    the user account that you are currently logged in with to the **docker** group.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令创建了docker组，而第二个命令将您当前登录的用户帐户添加到docker组中。
- en: To add the new membership to your account, you need to log off from the system
    and log back on, which will update your groups.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新成员添加到您的帐户，您需要注销系统并重新登录，这将更新您的组。
- en: 'Finally, you can test that it works by running the standard hello world image
    (note that we do not require **sudo** to run the Docker command):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过运行标准的hello world镜像来测试它是否有效（请注意，我们不需要sudo来运行Docker命令）：
- en: docker run hello-world
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: docker run hello-world
- en: 'If you see the following output, then you have successfully installed Docker
    and granted your non-root account access to Docker:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到以下输出，则已成功安装Docker并授予非root帐户对Docker的访问权限：
- en: '![Figure 1.3 – Output for hello-world'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3- hello-world的输出'
- en: '](image/Fig_1.3_B15514.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_1.3_B15514.jpg)'
- en: Figure 1.3 – Output for hello-world
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3- hello-world的输出
- en: Now that we've granted Docker permission to run without **sudo**, we can start
    unlocking the commands at our disposal by learning how to use the Docker CLI.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经授予了Docker无需sudo运行的权限，我们可以通过学习如何使用Docker CLI来开始解锁我们可以使用的命令。
- en: Using the Docker CLI
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker CLI
- en: 'You used the Docker CLI when you ran the **hello-world** container to test
    your installation. The Docker command is what you will use to interact with the
    Docker daemon. Using this single executable, you can do the following, and more:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行hello-world容器来测试您的安装时，您使用了Docker CLI。Docker命令是您将用于与Docker守护程序交互的命令。使用这个单个可执行文件，您可以执行以下操作，以及更多：
- en: Start and stop containers
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和停止容器
- en: Pull and push images
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取和推送镜像
- en: Run a shell in an active container
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在活动容器中运行shell
- en: Look at container logs
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看容器日志
- en: Create Docker volumes
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Docker卷
- en: Create Docker networks
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Docker网络
- en: Prune old images and volumes
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理旧的镜像和卷
- en: This chapter is not meant to include an exhaustive explanation of every Docker
    command; instead, we will explain some of the common commands that you will need
    to use to interact with the Docker daemon and containers. Since we consider volumes
    and networking to be very important to understand for this book, we will go into
    additional details on those topics.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不打算详尽解释每个Docker命令；相反，我们将解释一些您需要用来与Docker守护程序和容器交互的常见命令。由于我们认为卷和网络对于本书非常重要，我们将对这些主题进行更详细的介绍。
- en: 'You can break down Docker commands into two categories: general Docker commands
    and Docker management commands. The standard Docker commands allow you to manage
    containers, while management commands allow you to manage Docker options such
    as managing volumes and networking.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将Docker命令分为两类：通用Docker命令和Docker管理命令。标准的Docker命令允许您管理容器，而管理命令允许您管理Docker选项，如管理卷和网络。
- en: docker help
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker帮助
- en: It's common to forget an option or the syntax for a command, and Docker realizes
    this. Whenever you get stuck trying to remember a command, you can always use
    the **docker help** command to refresh your memory.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记选项或命令的语法是很常见的，Docker意识到了这一点。每当您在尝试记住一个命令时遇到困难，您总是可以使用**docker help**命令来刷新您的记忆。
- en: docker run
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker运行
- en: To run a container, use the **docker run** command with the provided image name.
    Before executing a **docker run** command, you should understand the options you
    can supply when starting a container.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个容器，使用提供的镜像名称**docker run**命令。在执行**docker run**命令之前，您应该了解在启动容器时可以提供的选项。
- en: 'In its simplest form, an example command you can use to run a NGINX web server
    would be **docker run bitnami/nginx:latest**. While this will start a container
    running NGINX, it will run in the foreground:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的形式中，您可以用来运行NGINX Web服务器的示例命令是**docker run bitnami/nginx:latest**。虽然这将启动一个运行NGINX的容器，但它将在前台运行：
- en: '![Figure 1.4 – NGINX container startup'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4 – NGINX容器启动'
- en: '](image/Fig_1.4_B15514.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_1.4_B15514.jpg)'
- en: Figure 1.4 – NGINX container startup
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – NGINX容器启动
- en: 'To run a container as a background process, you need to add the **-d** option
    to your Docker command, which will run your container in detached mode. Now, when
    you run a detached container, you will only see the container ID, instead of the
    interactive, or attached, screen:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要将容器作为后台进程运行，您需要在Docker命令中添加**-d**选项，这将以分离模式运行容器。现在，当您运行一个分离的容器时，您只会看到容器ID，而不是交互式或附加的屏幕：
- en: '![Figure 1.5 – Docker run output'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5 – Docker运行输出'
- en: '](image/Fig_1.5_B15514.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_1.5_B15514.jpg)'
- en: Figure 1.5 – Docker run output
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – Docker运行输出
- en: 'By default, containers will be given a random name once they are started. In
    our previous detached example, the container has been given the name **silly_keldysh**:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，容器启动后将被赋予一个随机名称。在我们之前的分离示例中，容器被赋予了名称**silly_keldysh**：
- en: '![](image/Fig_1.6_B15514.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Fig_1.6_B15514.jpg)'
- en: Figure 1.6 – Docker naming example
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – Docker命名示例
- en: 'If you do not assign a name to your container, it can quickly get confusing
    as you start to run multiple containers on a single host. To make management easier,
    you should always start your container with a name that will make it easier to
    manage. Docker provides another option with the **run** command: the **--name**
    option. Building on our previous example, we will name our container **nginx-test**.
    Our new **docker run** command will be as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有为容器分配名称，当您开始在单个主机上运行多个容器时，很快就会变得混乱。为了使管理更容易，您应该始终使用一个易于管理的名称启动容器。Docker提供了另一个选项，即**run**命令：**--name**选项。在我们之前的示例基础上，我们将命名我们的容器为**nginx-test**。我们的新**docker
    run**命令将如下所示：
- en: docker run --name nginx-test -d bitnami/nginx:latest
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: docker run --name nginx-test -d bitnami/nginx:latest
- en: Just like running any detached image, this will return the containers ID, but
    not the name you provided. In order to verify the container ran with the name
    **nginx-test**, we can list the containers using the **docker ps** command.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 就像运行任何分离的镜像一样，这将返回容器的ID，但不会返回您提供的名称。为了验证容器是否以名称**nginx-test**运行，我们可以使用**docker
    ps**命令列出容器。
- en: docker ps
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker ps
- en: 'Every day, you will need to retrieve a list of running containers or a list
    of containers that have been stopped. The Docker CLI has an option called **ps**
    that will list all running containers, or if you add an extra option to the **ps**
    command, all containers that are running and have been stopped. The output will
    list the containers, including their container ID, image tag, entry command, the
    creation date, status, ports, and the container name. The following is an example
    of containers that are currently running:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每天，您都需要检索正在运行的容器的列表或已停止的容器的列表。Docker CLI有一个名为**ps**的选项，它将列出所有正在运行的容器，或者如果您向**ps**命令添加额外选项，还会列出所有正在运行和已停止的容器。输出将列出容器，包括它们的容器ID、镜像标签、入口命令、创建日期、状态、端口和容器名称。以下是当前正在运行的容器的示例：
- en: '![](image/Fig_1.7_B15514.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Fig_1.7_B15514.jpg)'
- en: Figure 1.7 – Currently running containers
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 当前正在运行的容器
- en: This is helpful if the container you are looking for is currently running. What
    if the container was stopped, or even worse, what if you started the container
    and it failed to start and then stopped? You can view the status of all containers,
    including previously run containers, by adding the **-a** option to the **docker
    ps** command. When you execute **docker ps -a**, you will see the same output
    from a standard **ps** command, but you will notice that the list may include
    additional containers.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要查找的容器当前正在运行，这将很有帮助。如果容器已停止，或者更糟糕的是，如果您启动了容器但未能启动然后停止了呢？您可以通过向**docker ps**命令添加**-a**选项来查看所有容器的状态，包括先前运行的容器。当您执行**docker
    ps -a**时，您将看到与标准**ps**命令相同的输出，但您会注意到列表可能包括其他容器。
- en: How can you tell what containers are running versus which ones have stopped?
    If you look at the **STATUS** field of the list, the running containers will show
    a running time; for example, **Up xx hours**, or **Up xx days**. However, if the
    container has been stopped for any reason, the status will show when it stopped;
    for example, **Exited (1) 3 days ago**.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何区分正在运行的容器和已停止的容器？如果您查看列表的**STATUS**字段，正在运行的容器将显示运行时间；例如，**Up xx hours**或**Up
    xx days**。但是，如果由于任何原因容器已停止，状态将显示停止的时间；例如，**Exited (1) 3 days ago**。
- en: '![Figure 1.8 – Docker PS output'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8 – Docker PS输出'
- en: '](image/Fig_1.8_B15514.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_1.8_B15514.jpg)'
- en: Figure 1.8 – Docker PS output
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – Docker PS输出
- en: A stopped container does not mean there was an issue running the image. There
    are containers that may execute a single task and, once completed, the container
    may stop gracefully. One way to determine whether an exit was graceful or if it
    was due to a failed startup is to check the logs of the container.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 停止的容器并不意味着运行镜像时出现问题。有些容器可能执行单个任务，一旦完成，容器可能会正常停止。确定退出是正常的还是由于启动失败的一种方法是检查容器的日志。
- en: docker start and stop
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker start和stop
- en: To stop a running container, use the **docker stop** option with the name of
    the container you want to stop. You may wish to stop a container due to the resources
    on the host since you may have limited resources and can only run a few containers
    simultaneously.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止运行的容器，请使用**docker stop**选项加上要停止的容器的名称。您可能希望停止容器，因为主机上的资源可能有限，只能同时运行几个容器。
- en: If you need to start that container at a future time for additional testing
    or development, execute **docker start container name**, which will start the
    container with all of the options that it was originally started with, including
    any networks or volumes that were assigned.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在将来的某个时间启动该容器进行额外的测试或开发，请执行**docker start容器名称**，这将使用最初启动时的所有选项启动容器，包括分配的任何网络或卷。
- en: docker attach
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker attach
- en: You may need to access a container interactively to troubleshoot an issue or
    to look at a log file. One method to connect to a running container is to use
    the **docker attach container name** command. When you attach to a running container,
    you will connect to the running containers process, so if you attach to a container
    running a process, you are not likely to just see a command prompt of any kind.
    In fact, you may see nothing but a blank screen for some time until the container
    outputs some data to the screen.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要交互式地访问容器来解决问题或查看日志文件。连接到正在运行的容器的一种方法是使用**docker attach容器名称**命令。当您连接到正在运行的容器时，您将连接到正在运行的容器进程，因此如果您连接到运行进程的容器，您不太可能只看到任何一种命令提示符。实际上，您可能会在一段时间内什么都看不到，直到容器向屏幕输出一些数据。
- en: 'You must be careful once you attach to the container – you may accidentally
    stop the running process and, in turn, stop the container. Let''s use an example
    of attaching to a web server running NGINX. First, we need to verify that the
    container is running using **docker ps**:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您连接到容器，您必须小心 - 您可能会意外停止运行的进程，从而停止容器。让我们以连接到运行NGINX的Web服务器为例。首先，我们需要使用**docker
    ps**来验证容器是否正在运行：
- en: '![Figure 1.9 – docker ps output'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.9 - docker ps 输出'
- en: '](image/Fig_1.9_B15514.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_1.9_B15514.jpg)'
- en: Figure 1.9 – docker ps output
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 - docker ps 输出
- en: 'Using the **attach** command, we execute **docker attach bbadb2bddaab**:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**attach**命令，我们执行**docker attach bbadb2bddaab**：
- en: '![Figure 1.10 – docker attach output'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.10 - docker attach 输出'
- en: '](image/Fig_1.10_B15514.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_1.10_B15514.jpg)'
- en: Figure 1.10 – docker attach output
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 - docker attach 输出
- en: 'As shown in the preceding screenshot, once you attach to the running container
    process, it appears that nothing is happening. When you attach to a process, you
    will only be able to interact with the process, and the only output you will see
    is data being sent to standard output. In the case of the NGINX container, the
    **attach** command has attached to the NGINX process. To show this, we will leave
    the attachment and curl to the web server from another session. Once we curl to
    the container port, you will see logs outputted to the attached console:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，一旦您连接到正在运行的容器进程，似乎什么都没有发生。当您连接到一个进程时，您只能与该进程进行交互，并且您将看到的唯一输出是发送到标准输出的数据。在NGINX容器的情况下，**attach**命令已连接到NGINX进程。为了证明这一点，我们将离开附件并从另一个会话中curl到Web服务器。一旦我们curl到容器端口，您将看到日志输出到附加的控制台：
- en: '![Figure 1.11 – STDOUT output from the container'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.11 - 容器的标准输出'
- en: '](image/Fig_1.11_B15514.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_1.11_B15514.jpg)'
- en: Figure 1.11 – STDOUT output from the container
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11 - 容器的标准输出
- en: Attaching to a running container has varying benefits, depending on what is
    running in the container.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到运行的容器具有不同的好处，这取决于容器中运行的内容。
- en: 'We mentioned that you need to be careful once you attach to the container.
    Those who are new to Docker may attach to the NGINX image and assume that nothing
    is happening on the server or the attach failed. Since they think that there may
    be an issue, since it''s just sitting there, they may decide to break out of the
    container using the standard *Ctrl + C* keyboard command. This will send them
    back to a bash prompt, where they may run **docker ps** to look at the running
    containers:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到一旦附加到容器中，您需要小心。对Docker不熟悉的人可能会附加到NGINX图像并假设服务器上没有任何操作或附加失败。由于他们认为可能存在问题，因为它只是坐在那里，他们可能决定使用标准的*Ctrl
    + C*键盘命令跳出容器。这将把他们送回到bash提示符，他们可以运行**docker ps**来查看运行的容器：
- en: '![Figure 1.12 – docker ps output'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.12 - docker ps输出'
- en: '](image/Fig_1.12_B15514.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_1.12_B15514.jpg)'
- en: Figure 1.12 – docker ps output
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.12 - docker ps输出
- en: Where is the NGINX container? We didn't execute a **docker stop** command, and
    the container was running until we attached to the container. Why did the container
    stop after the attachment?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX容器在哪里？我们没有执行**docker stop**命令，容器在我们附加到容器之前一直在运行。为什么容器在附加后停止了？
- en: When an attachment is made to a container, you are attached to the running process.
    All keyboard commands will act in the same way as if you were at a physical server
    that was running NGINX in an interactive shell. This means that when the user
    used *Ctrl + C* to return to a prompt, they stopped the running NGINX process.
    If a container's running process stops, the container will also stop, and that's
    why the **docker ps** command does not show a running container.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当附加到容器时，您附加到正在运行的进程。所有键盘命令将以与在交互式shell中运行NGINX的物理服务器相同的方式起作用。这意味着当用户使用*Ctrl
    + C*返回到提示符时，他们停止了运行的NGINX进程。如果容器的运行进程停止，容器也将停止，这就是为什么**docker ps**命令不显示运行的容器的原因。
- en: Rather than use *ctrl-c* to return to a prompt, the user should have used *Ctrl
    + P*, followed by *Ctrl + Q*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不是使用*ctrl-c*返回提示符，用户应该使用*Ctrl + P*，然后是*Ctrl + Q*。
- en: 'There is an alternative to the **attach** command: the **docker exec** command.
    The **exec** command differs from an **attach** command since you supply the process
    to execute on the container.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个**attach**命令的替代方法：**docker exec**命令。**exec**命令不同于**attach**命令，因为您提供要在容器上执行的进程。
- en: docker exec
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker exec
- en: A better option when it comes to interacting with a running container is the
    **exec** command. Rather than attach to the container, you can use the **docker
    exec** command to execute a process in the container. You need to supply the container
    name and the process you want to execute in the image. Of course, the process
    must be included in the running image – if you do not have the bash executable
    in the image, you will receive an error when trying to execute bash in the container.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与附加到容器相比，与运行的容器进行交互的更好选择是**exec**命令。您可以使用**docker exec**命令在容器中执行进程，而不是附加到容器。您需要提供容器名称和要在图像中执行的进程。当然，该进程必须包含在运行的图像中
    - 如果图像中没有bash可执行文件，则在尝试在容器中执行bash时将收到错误。
- en: 'We will use a NGINX container as an example again. We will verify that NGINX
    is running using **docker ps** and then using the container ID or the name, we
    execute into the container. The command syntax is **docker exec <options> <container
    name> <process>**:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次以NGINX容器为例。我们将使用**docker ps**验证NGINX是否正在运行，然后使用容器ID或名称，我们进入容器。命令语法是**docker
    exec <选项> <容器名称> <进程>**：
- en: '![Figure 1.13 – docker exec example'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.13 – docker exec示例'
- en: '](image/Fig_1.13_B15514.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_1.13_B15514.jpg)'
- en: Figure 1.13 – docker exec example
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 – docker exec示例
- en: The option we included is **-it**, which tells **exec** to run in an interactive
    TTY session. Here, the process we want to execute is bash. Notice how the name
    changed from the original user and hostname. The host name is **Blade**, while
    the container name is **0a7c916e7411**. You may also have noticed that the current
    working directory changed from **~** to **/app** and that the prompt is not running
    as a root user, as shown by the **$** prompt.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含的选项是**-it**，它告诉**exec**在交互式TTY会话中运行。在这里，我们要执行的进程是bash。请注意名称已从原始用户和主机名更改。主机名是**Blade**，而容器名称是**0a7c916e7411**。您可能还注意到当前工作目录已从**~**更改为**/app**，提示不是以root用户身份运行，如**$**提示所示。
- en: You can use this session the same way you would a standard **SSH** connection;
    you are running bash in the container.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像使用标准**SSH**连接一样使用此会话；您正在容器中运行bash。
- en: 'Since we are not attached to the container, *ctrl-c* will not stop any process
    from running. To exit an interactive session, you only need to type in **exit**,
    followed by *Enter*, to exit the container. If you then run **docker ps**, you
    will notice that the container is still in a running state:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有连接到容器，*ctrl-c*不会停止任何进程运行。要退出交互式会话，您只需输入**exit**，然后按*Enter*，即可退出容器。然后运行**docker
    ps**，您会注意到容器仍处于运行状态：
- en: '![Figure 1.14 – docker ps output'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.14 – docker ps输出'
- en: '](image/Fig_1.14_B15514.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_1.14_B15514.jpg)'
- en: Figure 1.14 – docker ps output
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 – docker ps输出
- en: Next, let's see what we can learn about Docker log files.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看关于Docker日志文件我们能学到什么。
- en: docker logs
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker logs
- en: The **docker logs** command allows you to retrieve logs from a container using
    the container name or container ID that you retrieved using the **docker ps**
    command. You can view the logs from any container that was listed in your **ps**
    command; it doesn't matter if it's currently running or stopped.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker logs**命令允许您使用使用**docker ps**命令检索的容器名称或容器ID检索容器的日志。您可以查看**ps**命令中列出的任何容器的日志；无论它当前是否正在运行或已停止。'
- en: Log files are often the only way to troubleshoot why a container may not be
    starting up, or why a container is in an exited state. For example, if you attempted
    to run an image and the image starts and suddenly stops, you may find the answer
    by looking at the logs for that container.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件通常是排除容器启动失败或容器处于退出状态的唯一方法。例如，如果您尝试运行一个镜像，镜像启动后突然停止，您可以通过查看该容器的日志找到答案。
- en: To look at the logs for a container, you can use the **docker logs <container
    ID or name>** command.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看容器的日志，可以使用**docker logs <容器ID或名称>**命令。
- en: 'To view the logs for a container with a container ID of **7967c50b260f**, you
    would use the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看容器ID为**7967c50b260f**的容器的日志，您将使用以下命令：
- en: docker logs 7967c50b260f
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: docker logs 7967c50b260f
- en: 'This will output the logs from the container to your screen, which may be very
    long and verbose. Since many logs may contain a lot of information, you can limit
    the output by supplying the **logs** command with additional options. The following
    table lists the options available for viewing logs:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把容器的日志输出到您的屏幕上，这可能非常长且冗长。由于许多日志可能包含大量信息，您可以通过为**logs**命令提供附加选项来限制输出。以下表列出了查看日志的可用选项：
- en: '![](image/B15514_Table_1.1.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](image/B15514_Table_1.1.jpg)'
- en: docker rm
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker rm
- en: 'Once you name a container, the assigned name cannot be used to start a different
    container unless you remove it using the **docker rm** command. If you had a container
    running called **nginx-test** that was stopped and you attempted to start another
    container with the name **nginx-test**, the Docker daemon would return an error,
    stating that the name is in use:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您为容器命名，除非使用**docker rm**命令将其删除，否则无法使用分配的名称启动不同的容器。如果您有一个名为**nginx-test**的正在运行的容器，它已停止，并且您尝试使用名称**nginx-test**启动另一个容器，Docker守护程序将返回错误，指出该名称正在使用中：
- en: '![Figure 1.15 – Docker naming conflict error'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.15 – Docker命名冲突错误'
- en: '](image/Fig_1.15_B15514.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_1.15_B15514.jpg)'
- en: Figure 1.15 – Docker naming conflict error
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15 – Docker命名冲突错误
- en: This container is not running, but the daemon knows that the container name
    was used previously and that it's still in the list of previously run containers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器没有在运行，但守护进程知道该容器名称先前已被使用，并且仍在先前运行的容器列表中。
- en: If you want to reuse the same name, you need to remove the container before
    starting another container with that name. This is a common scenario when you
    are testing container images. You may start a container only to discover an issue
    with the application or image. You stop the container, fix the image/application
    issue, and want to redeploy using the same name. Since the name was in use previously
    and is still part of the Docker history, you will need to remove the image before
    reusing the name.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想重复使用相同的名称，您需要在启动另一个具有该名称的容器之前删除容器。这是在测试容器映像时经常发生的情况。您可能启动一个容器，只是发现应用程序或映像存在问题。您停止容器，修复映像/应用程序问题，并希望重新部署使用相同的名称。由于该名称先前已被使用并且仍然是Docker历史的一部分，您需要在重用名称之前删除映像。
- en: We haven't discussed volumes yet, but when removing a container that has a volume,
    or volumes, attached, it's a good practice to add the **-v** option to your remove
    command. Adding the **-v** option to the **docker rm** command will remove any
    volumes that were attached to the container.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论卷，但是在删除具有附加卷的容器时，最好在删除命令中添加**-v**选项。将**-v**选项添加到**docker rm**命令将删除附加到容器的任何卷。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how Docker can be used to solve common development
    issues, including the dreaded "It works on my machine" problem. We also presented
    an introduction to the most commonly used Docker CLI commands that you will use
    on a daily basis. We closed out this chapter by looking and how to handle persistent
    data for a container and customizing container networking.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Docker如何解决常见的开发问题，包括令人头痛的“在我的机器上可以运行”问题。我们还介绍了您将在日常使用中使用的最常用的Docker
    CLI命令。我们通过查看如何处理容器的持久数据和自定义容器网络来结束本章。
- en: In the next chapter, we will cover why, and how, containers use persistent data.
    We will explain each data type that can be attached to a container, including
    volumes, bind mounts, and tmpfs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍容器为什么以及如何使用持久数据。我们将解释可以附加到容器的每种数据类型，包括卷、绑定挂载和tmpfs。
- en: Questions
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: A single Docker image can be used on any Docker host, regardless of the architecture
    used.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单个Docker映像可以在任何Docker主机上使用，而不管使用的架构如何。
- en: A. True
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: A. 真
- en: B. False
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: B. 假
- en: What does Docker use to merge multiple image layers into a single filesystem?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker使用什么来将多个镜像层合并成单个文件系统？
- en: A. Merged filesystem
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: A. 合并文件系统
- en: B. NTFS filesystem
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: B. NTFS文件系统
- en: C. EXT4 filesystem
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: C. EXT4文件系统
- en: D. Union filesystem
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: D. 联合文件系统
- en: What is the most commonly used Docker storage driver when using a Kernel that
    is above version 4.0?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用版本高于4.0的内核时，最常用的Docker存储驱动是什么？
- en: A. AUFS
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: A. AUFS
- en: B. ZFS
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: B. ZFS
- en: C. VFS
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: C. VFS
- en: D. Overlay2
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: D. Overlay2
- en: When you edit a container's filesystem interactively, what layer are the changes
    written to?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您交互式地编辑容器的文件系统时，更改会写入哪一层？
- en: A. Operating system layer
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: A. 操作系统层
- en: B. Bottom-most layer
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: B. 最底层
- en: C. Container layer
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: C. 容器层
- en: D. Ephemeral layer
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: D. 临时层
- en: Assuming the image contains the required binaries, what Docker command allows
    you to gain access to a container's bash prompt?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设镜像包含所需的二进制文件，哪个Docker命令允许您访问容器的bash提示符？
- en: A. **docker shell -it <container> /bin/bash**
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: A. **docker shell -it <container> /bin/bash**
- en: B. **docker run -it <container> /bin/bash**
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: B. **docker run -it <container> /bin/bash**
- en: C. **docker exec -it <container> /bin/bash**
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: C. **docker exec -it <container> /bin/bash**
- en: D. **docker spawn -it <container> /bin/bash**
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: D. **docker spawn -it <container> /bin/bash**
- en: When a container is stopped, the Docker daemon will delete all traces of the
    container.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当容器停止时，Docker守护程序将删除容器的所有痕迹。
- en: A. True
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: A. 真
- en: B. False
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: B. 假
- en: What command will show you a list of all containers, including any stopped containers?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令会显示所有容器的列表，包括任何已停止的容器？
- en: A. **docker ps -all**
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: A. **docker ps -all**
- en: B. **docker ps -a**
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: B. **docker ps -a**
- en: C. **docker ps -list**
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: C. **docker ps -list**
- en: D. **docker list all**
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: D. **docker list all**
