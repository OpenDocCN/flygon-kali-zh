- en: Automated Acceptance Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动验收测试
- en: We already configured the commit phase of the Continuous Delivery process and
    now it's time to address the acceptance testing phase, which is usually the most
    challenging part. By gradually extending the pipeline, we will see different aspects
    of a well-done acceptance testing automation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经配置了持续交付过程的提交阶段，现在是时候解决验收测试阶段了，这通常是最具挑战性的部分。通过逐渐扩展流水线，我们将看到验收测试自动化的不同方面。
- en: 'This chapter covers the following points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: Introducing the acceptance testing process and its difficulties
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍验收测试过程及其困难
- en: Explaining the idea of the artifact repository
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释工件存储库的概念
- en: Creating the Docker registry on Docker Hub
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker Hub上创建Docker注册表
- en: Installing and securing private Docker registry
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和保护私有Docker注册表
- en: Implementing acceptance testing in the Jenkins pipeline
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jenkins流水线中实施验收测试
- en: Introducing and exploring Docker Compose
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍和探索Docker Compose
- en: Using Docker Compose in the acceptance testing process
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在验收测试过程中使用Docker Compose
- en: Writing acceptance tests with users
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与用户一起编写验收测试
- en: Introducing acceptance testing
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍验收测试
- en: Acceptance testing is a test performed to determine if the business requirements
    or contracts are met. It involves black-box testing against a complete system
    from a user perspective and its positive result should imply the acceptance of
    the software delivery. Sometimes, also called **UAT** (**user acceptance testing**),
    end user testing, or beta testing, it is a phase of the development process when
    software meets the *real-world* audience.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试是为了确定业务需求或合同是否得到满足而进行的测试。它涉及对完整系统进行黑盒测试，从用户的角度来看，其积极的结果应意味着软件交付的验收。有时也称为用户验收测试（UAT）、最终用户测试或测试版测试，这是开发过程中软件满足*真实世界*受众的阶段。
- en: Many projects rely on manual steps performed by QAs or users to verify the functional
    and nonfunctional requirements, but still, it's way more reasonable to run them
    as programmed repeatable operations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目依赖于由质量保证人员或用户执行的手动步骤来验证功能和非功能要求，但是，以编程可重复操作的方式运行它们要合理得多。
- en: 'Automated acceptance tests, however, can be considered difficult due to their
    specifics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，自动验收测试可能被认为是困难的，因为它们具有特定的特点：
- en: '**User-facing**: They need to be written together with a user, which requires
    an understanding between two worlds, technical and non-technical.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向用户：它们需要与用户一起编写，这需要技术和非技术两个世界之间的理解。
- en: '**Dependencies integration**: The tested application should be run together
    with its dependencies in order to check whether the system as a whole works properly.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖集成：被测试的应用程序应该与其依赖一起运行，以检查整个系统是否正常工作。
- en: '**Environment identity**: Staging (testing) and production environments should
    be identical to ensure that when run in production, the application also behaves
    as expected.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境身份：暂存（测试）和生产环境应该是相同的，以确保在生产环境中运行时，应用程序也能如预期般运行。
- en: '**Application identity**: Application should be built only once and the same
    binary should be transferred to production. That guarantees no changes in code
    between testing and releasing and eliminates the risk of different building environments.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序身份：应用程序应该只构建一次，并且相同的二进制文件应该被传输到生产环境。这保证了在测试和发布之间没有代码更改，并消除了不同构建环境的风险。
- en: '**Relevance and consequences**: If acceptance test passes, it should be clear
    that the application is ready for release from the user perspective.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关性和后果：如果验收测试通过，应该清楚地表明应用程序从用户角度来看已经准备好发布。
- en: We address all these difficulties in different sections of this chapter. Application
    identity can be achieved by building the Docker image only once and using Docker
    registry for its storage and versioning. Docker Compose helps with the dependencies
    integration providing a way to build a group of containerized applications working
    together. Creating tests in a user-facing manner is explained in the *Writing
    acceptance tests* section, and the environment identity is addressed by the Docker
    tool itself and can be also improved by other tools described in the next chapter.
    Concerning the relevance and consequences, the only good answer is to keep in
    mind that acceptance tests must always be of a high quality.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的不同部分解决了所有这些困难。通过仅构建一次Docker镜像并使用Docker注册表进行存储和版本控制，可以实现应用程序身份。Docker Compose有助于集成依赖项，提供了一种构建一组容器化应用程序共同工作的方式。在“编写验收测试”部分解释了以用户为中心创建测试的方法，而环境身份则由Docker工具本身解决，并且还可以通过下一章描述的其他工具进行改进。关于相关性和后果，唯一的好答案是要记住验收测试必须始终具有高质量。
- en: Acceptance testing can have multiple meanings; in this book, we treat acceptance
    testing as a complete integration test from a user perspective, excluding nonfunctional
    testing, such as performance, load, and recovery.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试可能有多重含义；在本书中，我们将验收测试视为从用户角度进行的完整集成测试，不包括性能、负载和恢复等非功能性测试。
- en: Docker registry
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker注册表
- en: Docker registry is a storage for Docker images. To be precise, it is a stateless
    server application that allows the images to be published (pushed) and later retrieved
    (pulled) when needed. We have already seen an example of the registry while running
    the official Docker images, such as `jenkins`. We pulled the images from Docker
    Hub, which is an official cloud-based Docker registry. Having a separate server
    to store, load, and search software packages is a more general concept called
    the software repository or, even more general, the artifact repository. Let's
    look closer at this idea.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Docker注册表是用于存储Docker镜像的存储库。确切地说，它是一个无状态的服务器应用程序，允许在需要时发布（推送）和检索（拉取）镜像。我们已经在运行官方Docker镜像时看到了注册表的示例，比如`jenkins`。我们从Docker
    Hub拉取了这些镜像，这是一个官方的基于云的Docker注册表。使用单独的服务器来存储、加载和搜索软件包是一个更一般的概念，称为软件存储库，甚至更一般的是构件存储库。让我们更仔细地看看这个想法。
- en: Artifact repository
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构件存储库
- en: While the source control management stores the source code, the artifact repository
    is dedicated for storing software binary artifacts, for example, compiled libraries
    or components, later used to build a complete application. Why do we need to store
    binaries on a separate server using a separate tool?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然源代码管理存储源代码，但构件存储库专门用于存储软件二进制构件，例如编译后的库或组件，以后用于构建完整的应用程序。为什么我们需要使用单独的工具在单独的服务器上存储二进制文件？
- en: '**File size**: Artifact files can be large, so the systems need to be optimized
    for their download and upload.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件大小：构件文件可能很大，因此系统需要针对它们的下载和上传进行优化。
- en: '**Versions**: Each uploaded artifact needs to have a version that makes it
    easy to browse and use. Not all versions, however, have to be stored forever;
    for example, if there was a bug detected, we may not be interested in the related
    artifact and remove it.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本：每个上传的构件都需要有一个版本，这样可以方便浏览和使用。然而，并不是所有的版本都需要永久存储；例如，如果发现了一个bug，我们可能对相关的构件不感兴趣并将其删除。
- en: '**Revision mapping**: Each artifact should point to exactly one revision of
    the source control and, what''s more, the binary creation process should be repeatable.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修订映射：每个构件应该指向源代码的一个确切修订版本，而且二进制创建过程应该是可重复的。
- en: '**Packages**: Artifacts are stored in the compiled and compressed form so that
    these time-consuming steps need not be repeated.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包**：构件以编译和压缩的形式存储，因此这些耗时的步骤不需要重复进行。'
- en: '**Access control**: Users can be restricted differently to the source code
    and artifact binary access.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问控制**：用户可以以不同方式限制对源代码和构件二进制文件的访问。'
- en: '**Clients**: Users of the artifact repository can be developers outside the
    team or organization, who want to use the library via its public API.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：构件存储库的用户可以是团队或组织外的开发人员，他们希望通过其公共API使用库。'
- en: '**Use cases**: Artifact binaries are used to guarantee that exactly the same
    built version is deployed to every environment to ease the rollback procedure
    in case of failure.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：构件二进制文件用于保证部署到每个环境的确切相同的构建版本，以便在失败情况下简化回滚过程。'
- en: The most popular artifact repositories are JFrog Artifactory and Sonatype Nexus.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最受欢迎的构件存储库是JFrog Artifactory和Sonatype Nexus。
- en: The artifact repository plays a special role in the Continuous Delivery process
    because it guarantees that the same binary is used throughout all pipeline steps.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 构件存储库在持续交付过程中扮演着特殊的角色，因为它保证了相同的二进制文件在所有流水线步骤中被使用。
- en: 'Let''s look at the following figure presenting how it works:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的图，展示了它是如何工作的：
- en: '![](assets/60334691-bdc8-4953-9758-40f5983827d8.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/60334691-bdc8-4953-9758-40f5983827d8.png)'
- en: The **Developer** pushes a change to the **source code repository**, which triggers
    the pipeline build. As the last step of the **Commit Stage**, a binary is created
    and stored in the artifact repository. Afterward, during all other stages of the
    delivery process, the same binary is pulled and used.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发人员**将更改推送到**源代码存储库**，这会触发流水线构建。作为**提交阶段**的最后一步，会创建一个二进制文件并存储在构件存储库中。之后，在交付过程的所有其他阶段中，都会拉取并使用相同的二进制文件。'
- en: The built binary is often called the **release candidate** and the process of
    moving binary to the next stage is called **promotion**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 构建的二进制文件通常被称为**发布候选版本**，将二进制文件移动到下一个阶段的过程称为**提升**。
- en: Depending on the programming language and technologies, the binary formats can
    differ.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 根据编程语言和技术的不同，二进制格式可能会有所不同。
- en: For example, in the case of Java, usually, JAR files are stored and, in the
    case of Ruby, gem files. We work with Docker, so we will store Docker images as
    artifacts, and the tool to store Docker images is called Docker registry.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Java的情况下，通常会存储JAR文件，在Ruby的情况下会存储gem文件。我们使用Docker，因此我们将Docker镜像存储为构件，并且用于存储Docker镜像的工具称为Docker注册表。
- en: Some teams maintain two repositories at the same time, artifact repository for
    JAR files and Docker registry for Docker images. While it may be useful during
    the first phase of the Docker introduction, there is no good reason to maintain
    both forever.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一些团队同时维护两个存储库，一个是用于JAR文件的构件存储库，另一个是用于Docker镜像的Docker注册表。虽然在Docker引入的第一阶段可能会有用，但没有理由永远维护两者。
- en: Installing Docker registry
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker注册表
- en: First, we need to install a Docker registry. There are a number of options available,
    but two of them are more common than others, cloud-based Docker Hub registry and
    your own private Docker registry. Let's dig into them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装一个Docker注册表。有许多选项可用，但其中两个比其他更常见，一个是基于云的Docker Hub注册表，另一个是您自己的私有Docker注册表。让我们深入了解一下。
- en: Docker Hub
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Hub
- en: 'Docker Hub is a cloud-based service that provides Docker registry and other
    features such as building images, testing them, and pulling code directly from
    the code repository. Docker Hub is cloud-hosted, so it does not really need any
    installation process. All you need to do is create a Docker Hub account:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub是一个提供Docker注册表和其他功能的基于云的服务，例如构建镜像、测试它们以及直接从代码存储库中拉取代码。Docker Hub是云托管的，因此实际上不需要任何安装过程。你需要做的就是创建一个Docker
    Hub账户：
- en: Open [https://hub.docker.com/](https://hub.docker.com/) in a browser.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开[https://hub.docker.com/](https://hub.docker.com/)。
- en: Fill in the password, email address, and Docker ID.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写密码、电子邮件地址和Docker ID。
- en: After receiving an email and clicking the activation link, the account is created.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收到电子邮件并点击激活链接后，帐户已创建。
- en: Docker Hub is definitely the simplest option to start with, and it allows storing
    both private and public images.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub绝对是开始使用的最简单选项，并且允许存储私有和公共图像。
- en: Private Docker registry
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有Docker注册表
- en: Docker Hub may not always be acceptable. It is not free for enterprises and,
    what's even more important, a lot of companies have policies not to store their
    software outside their own network. In this case, the only option is to install
    a private Docker registry.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub可能并不总是可接受的。对于企业来说，它并不免费，更重要的是，许多公司有政策不在其自己的网络之外存储其软件。在这种情况下，唯一的选择是安装私有Docker注册表。
- en: 'The Docker registry installation process is quick and simple, however, making
    it secure and available in public requires setting up access restriction and the
    domain certificate. This is why we split this section into three parts:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Docker注册表安装过程快速简单，但是要使其在公共环境中安全可用，需要设置访问限制和域证书。这就是为什么我们将这一部分分为三个部分：
- en: Installing the Docker registry application
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Docker注册表应用程序
- en: Adding domain certificate
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加域证书
- en: Adding access restriction
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加访问限制
- en: Installing the Docker registry application
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker注册表应用程序
- en: 'Docker registry is available as a Docker image. To start this, we can run the
    following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Docker注册表可用作Docker镜像。要启动它，我们可以运行以下命令：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: By default, the registry data is stored as a docker volume in the default host
    filesystem's directory. To change it, you can add `-v <host_directory>:/var/lib/registry`.
    Another alternative is to use a volume container.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，注册表数据存储为默认主机文件系统目录中的docker卷。要更改它，您可以添加`-v <host_directory>:/var/lib/registry`。另一种选择是使用卷容器。
- en: The command starts the registry and makes it accessible via port 5000\. The
    `registry` container is started from the registry image (version 2). The `--restart=always` option
    causes the container to automatically restart whenever it's down.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令启动注册表并使其通过端口5000可访问。`registry`容器是从注册表镜像（版本2）启动的。`--restart=always`选项导致容器在关闭时自动重新启动。
- en: Consider setting up a load balancer and starting a few Docker registry containers
    in case of a large number of users.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑设置负载均衡器，并在用户数量较大的情况下启动几个Docker注册表容器。
- en: Adding a domain certificate
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加域证书
- en: If the registry is run on the localhost, then everything works fine and no other
    installation steps are required. However, in most cases, we want to have a dedicated
    server for the registry, so that the images are widely available. In that case,
    Docker requires securing the registry with SSL/TLS. The process is very similar
    to the public web server configuration and, similarly, it's highly recommended
    having the certificate signed by CA (certificate authority). If obtaining the
    CA-signed certificate is not an option, then we can self-sign a certificate or
    use the `--insecure-registry` flag.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注册表在本地主机上运行，则一切正常，不需要其他安装步骤。但是，在大多数情况下，我们希望为注册表设置专用服务器，以便图像广泛可用。在这种情况下，Docker需要使用SSL/TLS保护注册表。该过程与公共Web服务器配置非常相似，并且强烈建议使用CA（证书颁发机构）签名证书。如果获取CA签名的证书不是一个选项，那么我们可以自签名证书或使用`--insecure-registry`标志。
- en: You can read about creating and using self-signed certificates at [https://docs.docker.com/registry/insecure/#using-self-signed-certificates](https://docs.docker.com/registry/insecure/#using-self-signed-certificates).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.docker.com/registry/insecure/#using-self-signed-certificates](https://docs.docker.com/registry/insecure/#using-self-signed-certificates)阅读有关创建和使用自签名证书的信息。
- en: Having the certificates either signed by CA or self-signed, we can move `domain.crt` and
    `domain.key` to the `certs` directory and start the registry.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 无论证书是由CA签名还是自签名，我们都可以将`domain.crt`和`domain.key`移动到`certs`目录并启动注册表。
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In case of a self-signed certificate, clients have to explicitly trust the certificate.
    In order to do this, they can copy the `domain.crt` file to `/etc/docker/certs.d/<docker_host_domain>:5000/ca.crt`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用自签名证书的情况下，客户端必须明确信任该证书。为了做到这一点，他们可以将`domain.crt`文件复制到`/etc/docker/certs.d/<docker_host_domain>:5000/ca.crt`。
- en: Using the `--insecure-registry` flag is not recommended since it provides no
    security at all.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议使用`--insecure-registry`标志，因为它根本不提供安全性。
- en: Adding an access restriction
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加访问限制
- en: Unless we use the registry inside a well-secured private network, we should
    configure the authentication.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除非我们在一个良好安全的私人网络中使用注册表，否则我们应该配置认证。
- en: 'The simplest way to do this is to create a user with a password using the `htpasswd`
    tool from the `registry` image:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的最简单方法是使用`registry`镜像中的`htpasswd`工具创建具有密码的用户：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The command runs the `htpasswd` tool to create the `auth/passwords` file (with
    one user inside). Then, we can run the registry with that one user authorized
    to access it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令运行`htpasswd`工具来创建`auth/passwords`文件（其中包含一个用户）。然后，我们可以使用一个授权访问它的用户来运行注册表：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The command, in addition to setting the certificates, creates the access restriction
    limited to the users specified in the `auth/passwords` file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令除了设置证书外，还创建了仅限于`auth/passwords`文件中指定的用户的访问限制。
- en: As a result, before using the registry, a client needs to specify the username
    and password.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用注册表之前，客户端需要指定用户名和密码。
- en: Access restriction doesn't work in the case of the `--insecure-registry` flag.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`--insecure-registry`标志的情况下，访问限制不起作用。
- en: Other Docker registries
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Docker注册表
- en: Docker Hub and private registry are not the only possibilities when it comes
    to Docker-based artifact repositories.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及基于Docker的工件存储库时，Docker Hub和私有注册表并不是唯一的选择。
- en: 'The other options are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项如下：
- en: '**General-purpose repositories**: Widely-used general-purpose repositories,
    such as JFrog Artifactory or Sonatype Nexus, implement the Docker registry API.
    Their advantage is that one server can store both Docker images and other artifacts
    (for example, JAR files). These systems are also mature and provide enterprise
    integration.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用存储库：广泛使用的通用存储库，如JFrog Artifactory或Sonatype Nexus，实现了Docker注册表API。它们的优势在于一个服务器可以存储Docker镜像和其他工件（例如JAR文件）。这些系统也是成熟的，并提供企业集成。
- en: '**Cloud-based registries**: Docker Hub is not the only cloud provider. Most
    cloud-oriented services offer Docker registries in the cloud, for example, Google
    Cloud or AWS.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于云的注册表：Docker Hub并不是唯一的云提供商。大多数面向云的服务都在云中提供Docker注册表，例如Google Cloud或AWS。
- en: '**Custom registries**: The Docker registry API is open, so it''s possible to
    implement custom solutions. What''s more, images can be exported to files, so
    it''s feasible to store images simply as files.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义注册表：Docker注册表API是开放的，因此可以实现自定义解决方案。而且，镜像可以导出为文件，因此可以简单地将镜像存储为文件。
- en: Using Docker registry
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker注册表
- en: 'When the registry is configured, we can show how to work with it in three steps:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当注册表配置好后，我们可以展示如何通过三个步骤与其一起工作：
- en: Building an image
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建镜像
- en: Pushing the image to the registry
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将镜像推送到注册表
- en: Pulling the image from the registry
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从注册表中拉取镜像
- en: Building an image
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建镜像
- en: 'Let''s use the example from [Chapter 2](aa58c16d-41c0-4364-9eae-26b60a05c510.xhtml),
    *Introducing Docker*, and build an image with Ubuntu and the Python interpreter
    installed. In a new directory, we need to create a Dockerfile:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用[第2章](aa58c16d-41c0-4364-9eae-26b60a05c510.xhtml)中的示例，*介绍Docker*，并构建一个安装了Ubuntu和Python解释器的图像。在一个新目录中，我们需要创建一个Dockerfile：
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can build the image:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建图像：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Pushing the image
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送图像
- en: 'In order to push the created image, we need to tag it according to the naming
    convention:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了推送创建的图像，我们需要根据命名约定对其进行标记：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The "`registry_address`" can be:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '"`registry_address`"可以是：'
- en: User name in case of Docker Hub
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker Hub的情况下的用户名
- en: Domain name or IP address with port for a private registry (for example, `localhost:5000`)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有注册表的域名或IP地址和端口（例如，`localhost:5000`）
- en: In most cases, `<tag>` is in the form of image/application version.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，`<tag>`的形式是图像/应用程序版本。
- en: 'Let''s tag the image to use Docker Hub:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们标记图像以使用Docker Hub：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We could have also tagged the image in the `build` command: `"docker`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在`build`命令中标记图像：`"docker`
- en: '`build -t leszko/ubuntu_with_python:1 . "`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`build -t leszko/ubuntu_with_python:1 . "`.'
- en: 'If the repository has access restriction configured, we need to authorize it
    first:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存储库配置了访问限制，我们需要首先授权它：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It's possible to use the `docker login` command without parameters and Docker
    would ask interactively for the username and password.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`docker login`命令而不带参数，并且Docker会交互式地要求用户名和密码。
- en: 'Now, we can store the image in the registry using the `push` command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`push`命令将图像存储在注册表中：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that there is no need to specify the registry address because Docker uses
    the naming convention to resolve it. The image is stored, and we can check it
    using the Docker Hub web interface available at [https://hub.docker.com](https://hub.docker.com).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无需指定注册表地址，因为Docker使用命名约定来解析它。图像已存储，我们可以使用Docker Hub Web界面进行检查，该界面可在[https://hub.docker.com](https://hub.docker.com)上找到。
- en: Pulling the image
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉取图像
- en: 'To demonstrate how the registry works, we can remove the image locally and
    retrieve it from the registry:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示注册表的工作原理，我们可以在本地删除图像并从注册表中检索它：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can see that the image has been removed using the `docker images` command.
    Then, let''s retrieve the image back from the registry:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker images`命令看到图像已被删除。然后，让我们从注册表中检索图像：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you use the free Docker Hub account, you may need to change the `ubuntu_with_python` repository
    to public before pulling it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用免费的Docker Hub帐户，您可能需要在拉取之前将`ubuntu_with_python`存储库更改为公共。
- en: We can confirm the image is back with the `docker images` command.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker images`命令确认图像已经恢复。
- en: When we have the registry configured and understand how it works, we can see
    how to use it inside the Continuous Delivery pipeline and build the acceptance
    testing stage.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们配置了注册表并了解了它的工作原理后，我们可以看到如何在持续交付流水线中使用它并构建验收测试阶段。
- en: Acceptance test in pipeline
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流水线中的验收测试
- en: We already understood the idea behind acceptance testing and know how to configure
    Docker registry, so we are ready for its first implementation inside the Jenkins
    pipeline.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经理解了验收测试的概念，并知道如何配置Docker注册表，因此我们已经准备好在Jenkins流水线中进行第一次实现。
- en: 'Let''s look at the figure that presents the process we will use:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下呈现我们将使用的过程的图表：
- en: '![](assets/0a20aa8e-7116-4a9b-97ef-d619265b0725.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0a20aa8e-7116-4a9b-97ef-d619265b0725.png)'
- en: 'The process goes as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程如下：
- en: The developer pushes a code change to GitHub.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员将代码更改推送到GitHub。
- en: Jenkins detects the change, triggers the build, and checks out the current code.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins检测到更改，触发构建并检出当前代码。
- en: Jenkins executes the commit phase and builds the Docker image.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins执行提交阶段并构建Docker图像。
- en: Jenkins pushes the image to Docker registry.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins将图像推送到Docker注册表。
- en: Jenkins runs the Docker container in the staging environment.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins在暂存环境中运行Docker容器。
- en: Staging the Docker host needs to pull the image from the Docker registry.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署Docker主机需要从Docker注册表中拉取镜像。
- en: Jenkins runs the acceptance test suite against the application running in the
    staging environment.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins对运行在暂存环境中的应用程序运行验收测试套件。
- en: For the sake of simplicity, we will run the Docker container locally (and not
    on a separate staging server). In order to run it remotely, we need to use the
    `-H` option or to configure the `DOCKER_HOST` environment variable. We will cover
    this part in the next chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将在本地运行Docker容器（而不是在单独的暂存服务器上）。为了远程运行它，我们需要使用`-H`选项或配置`DOCKER_HOST`环境变量。我们将在下一章中介绍这部分内容。
- en: 'Let''s continue the pipeline we started in the previous chapter and add three
    more stages:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续上一章开始的流水线，并添加三个更多的阶段：
- en: '`Docker build`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docker构建`'
- en: '`Docker push`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Docker push`'
- en: '`Acceptance test`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`验收测试`'
- en: Keep in mind that you need to have the Docker tool installed on the Jenkins
    executor (agent slave or master, in the case of slave-less configuration) so that
    it is able to build Docker images.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您需要在Jenkins执行器（代理从属节点或主节点，在无从属节点配置的情况下）上安装Docker工具，以便它能够构建Docker镜像。
- en: If you use dynamically provisioned Docker slaves, then there is no mature Docker
    image provided yet. You can build it yourself or use the `leszko/jenkins-docker-slave` image.
    You also need to mark the `privileged` option in the Docker agent configuration.
    This solution, however, has some drawbacks, so before using it in production,
    read the [http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用动态配置的Docker从属节点，那么目前还没有提供成熟的Docker镜像。您可以自行构建，或者使用`leszko/jenkins-docker-slave`镜像。您还需要在Docker代理配置中标记`privileged`选项。然而，这种解决方案有一些缺点，因此在生产环境中使用之前，请阅读[http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)。
- en: The Docker build stage
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker构建阶段
- en: We would like to run the calculator project as a Docker container, so we need
    to create Dockerfile and add the `"Docker build"` stage to Jenkinsfile.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将计算器项目作为Docker容器运行，因此我们需要创建Dockerfile，并在Jenkinsfile中添加`"Docker构建"`阶段。
- en: Adding Dockerfile
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Dockerfile
- en: 'Let''s create Dockerfile in the root directory of the calculator project:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在计算器项目的根目录中创建Dockerfile：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The default build directory for Gradle is `build/libs/`, and `calculator-0.0.1-SNAPSHOT.jar` is
    the complete application packaged into one JAR file. Note that Gradle automatically
    versioned the application using the Maven-style version `0.0.1-SNAPSHOT`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle的默认构建目录是`build/libs/`，`calculator-0.0.1-SNAPSHOT.jar`是打包成一个JAR文件的完整应用程序。请注意，Gradle自动使用Maven风格的版本`0.0.1-SNAPSHOT`对应用程序进行了版本化。
- en: 'Dockerfile uses a base image that contains JDK 8 (`frolvlad/alpine-oraclejdk8:slim`).
    It also copies the application JAR (created by Gradle) and runs it. Let''s check
    if the application builds and runs:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile使用包含JDK 8的基础镜像（`frolvlad/alpine-oraclejdk8:slim`）。它还复制应用程序JAR（由Gradle创建）并运行它。让我们检查应用程序是否构建并运行：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using the preceding commands, we've built the application, built the Docker
    image, and run the Docker container. After a while, we should be able to open
    the browser to `http://localhost:8080/sum?a=1&b=2` and see `3` as a result.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述命令，我们已经构建了应用程序，构建了Docker镜像，并运行了Docker容器。过一会儿，我们应该能够打开浏览器，访问`http://localhost:8080/sum?a=1&b=2`，并看到`3`作为结果。
- en: 'We can stop the container and push the Dockerfile to the GitHub repository:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以停止容器，并将Dockerfile推送到GitHub存储库：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Adding the Docker build to the pipeline
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Docker构建添加到流水线
- en: 'The last step we need is adding the `"Docker build"` stage to Jenkinsfile. Usually,
    the JAR packaging is also declared as a separate `Package` stage:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一步是在Jenkinsfile中添加“Docker构建”阶段。通常，JAR打包也被声明为一个单独的“Package”阶段：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We don't explicitly version the image, but each image has a unique hash ID.
    We will cover the explicit versioning in the next chapter.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有明确为镜像版本，但每个镜像都有一个唯一的哈希ID。我们将在下一章中介绍明确的版本控制。
- en: Note that we used the Docker registry name in the image tag. There is no need
    to have the image tagged twice `calculator `and `leszko/calculator`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在镜像标签中使用了Docker注册表名称。没有必要将镜像标记两次为“calculator”和“leszko/calculator”。
- en: When we commit and push Jenkinsfile, the pipeline build should start automatically
    and we should see all boxes green. This means that the Docker image has been built
    successfully.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们提交并推送Jenkinsfile时，流水线构建应该会自动开始，我们应该看到所有的方框都是绿色的。这意味着Docker镜像已经成功构建。
- en: There is also a Gradle plugin for Docker that allows executing the Docker operations
    within Gradle scripts. You can see an example at: [https://spring.io/guides/gs/spring-boot-docker/](https://spring.io/guides/gs/spring-boot-docker/).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个适用于Docker的Gradle插件，允许在Gradle脚本中执行Docker操作。您可以在以下链接中看到一个示例：[https://spring.io/guides/gs/spring-boot-docker/](https://spring.io/guides/gs/spring-boot-docker/)。
- en: The Docker push stage
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker push阶段
- en: 'When the image is ready, we can store it in the registry. The `Docker push`
    stage is very simple. It''s enough to add the following code to Jenkinsfile:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当镜像准备好后，我们可以将其存储在注册表中。“Docker push”阶段非常简单。只需在Jenkinsfile中添加以下代码即可：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If Docker registry has the access restricted, then first we need to log in using
    the `docker login` command. Needless to say, the credentials must be well secured,
    for example, using a dedicated credential store as described on the official Docker
    page: [https://docs.docker.com/engine/reference/commandline/login/#credentials-store](https://docs.docker.com/engine/reference/commandline/login/#credentials-store).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Docker注册表受到访问限制，那么首先我们需要使用“docker login”命令登录。不用说，凭据必须得到很好的保护，例如，使用专用凭据存储，如官方Docker页面上所述：[https://docs.docker.com/engine/reference/commandline/login/#credentials-store](https://docs.docker.com/engine/reference/commandline/login/#credentials-store)。
- en: As always, pushing changes to the GitHub repository triggers Jenkins to start
    the build and, after a while, we should have the image automatically stored in
    the registry.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，将更改推送到GitHub存储库会触发Jenkins开始构建，过一段时间后，我们应该会看到镜像自动存储在注册表中。
- en: Acceptance testing stage
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验收测试阶段
- en: To perform acceptance testing, first, we need to deploy the application to the
    staging environment and then run the acceptance test suite against it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行验收测试，首先需要将应用程序部署到暂存环境，然后针对其运行验收测试套件。
- en: Adding a staging deployment to the pipeline
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向流水线添加一个暂存部署
- en: 'Let''s add a stage to run the `calculator` container:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个阶段来运行“calculator”容器：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After running this stage, the `calculator` container is running as a daemon,
    publishing its port as `8765` and being removed automatically when stopped.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此阶段后，“calculator”容器将作为守护程序运行，将其端口发布为“8765”，并在停止时自动删除。
- en: Adding an acceptance test to the pipeline
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向流水线添加一个验收测试
- en: Acceptance testing usually requires running a dedicated black-box test suite
    that checks the behavior of the system. We will cover it in the *Writing acceptance
    tests *section. At the moment, for the sake of simplicity, let's perform acceptance
    testing simply by calling the web service endpoint with the `curl` tool and checking
    the result using the `test` command.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试通常需要运行一个专门的黑盒测试套件，检查系统的行为。我们将在“编写验收测试”部分进行介绍。目前，为了简单起见，让我们通过使用“curl”工具调用Web服务端点并使用“test”命令检查结果来执行验收测试。
- en: 'In the root directory of the project, let''s create the `acceptance_test.sh` file:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录中，让我们创建`acceptance_test.sh`文件：
- en: '[PRE18]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We call the `sum` endpoint with parameters `a=1` and `b=2` and expect to receive
    `3` in response.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用参数`a=1`和`b=2`调用`sum`端点，并期望收到`3`的响应。
- en: 'Then, the `Acceptance test` stage can look as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Acceptance test`阶段可以如下所示：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the `docker run -d` command is asynchronous, we need to wait using the
    `sleep` operation to make sure the service is already running.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`docker run -d`命令是异步的，我们需要使用`sleep`操作来确保服务已经在运行。
- en: There is no good way to check if the service is already running. An alternative
    to sleeping could be a script checking every second whether the service has already
    started.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 没有好的方法来检查服务是否已经在运行。睡眠的替代方法可能是一个脚本，每秒检查服务是否已经启动。
- en: Adding a cleaning stage environment
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个清理阶段环境
- en: 'As the last step of acceptance testing, we can add the staging environment
    cleanup. The best place to do this is in the `post` section, to make sure it executes
    even in case of failure:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 作为验收测试的最后一步，我们可以添加分段环境清理。这样做的最佳位置是在`post`部分，以确保即使失败也会执行：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This statement makes sure that the `calculator` container is no longer running
    on the Docker host.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明确保`calculator`容器不再在Docker主机上运行。
- en: Docker Compose
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Life is easy without dependencies. In real-life, however, almost every application
    links to a database, cache, messaging system, or another application. In the case
    of a (micro) service architecture, each service needs a bunch of other services
    to do its work. The monolithic architecture does not eliminate the issue, an application
    usually has some dependencies, at least to the database.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 没有依赖关系的生活是轻松的。然而，在现实生活中，几乎每个应用程序都链接到数据库、缓存、消息系统或另一个应用程序。在（微）服务架构的情况下，每个服务都需要一堆其他服务来完成其工作。单片架构并没有消除这个问题，一个应用程序通常至少有一些依赖，至少是数据库。
- en: Imagine a newcomer joining your development team; how much time does it take
    to set up the entire development environment and run the application with all
    its dependencies?
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一位新人加入你的开发团队；设置整个开发环境并运行带有所有依赖项的应用程序需要多长时间？
- en: When it comes to automated acceptance testing, the dependencies issue is no
    longer only a matter of convenience, but it becomes a necessity. While, during
    unit testing, we could mock the dependencies, the acceptance testing suite requires
    a complete environment. How do we set it up quickly and in a repeatable manner?
    Luckily, Docker Compose is a tool that can help.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到自动化验收测试时，依赖问题不再仅仅是便利的问题，而是变成了必要性。虽然在单元测试期间，我们可以模拟依赖关系，但验收测试套件需要一个完整的环境。我们如何快速设置并以可重复的方式进行？幸运的是，Docker
    Compose是一个可以帮助的工具。
- en: What is Docker Compose?
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Docker Compose？
- en: Docker Compose is a tool for defining, running, and managing multi-container
    Docker applications. Services are defined in a configuration file (a YAML format)
    and can be created and run all together with a single command.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose是一个用于定义、运行和管理多容器Docker应用程序的工具。服务在配置文件（YAML格式）中定义，并可以使用单个命令一起创建和运行。
- en: Docker Compose orchestrates containers using standard Docker mechanisms and
    provides a convenient way to specify the entire environment.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose使用标准的Docker机制来编排容器，并提供了一种方便的方式来指定整个环境。
- en: 'Docker Compose comes with a lot of features, the most interesting are:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose具有许多功能，最有趣的是：
- en: Building a set of services
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一组服务
- en: Launching a set of services together
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一起启动一组服务
- en: Managing the state of individual services
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理单个服务的状态
- en: Preserving volume data between runs
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行之间保留卷数据
- en: Scaling services up and down
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展服务的规模
- en: Showing logs of individual services
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示单个服务的日志
- en: Caching configuration and recreating changed containers between runs
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行之间缓存配置和重新创建更改的容器
- en: A detailed description of Docker Compose and its features can be found on the
    official page at: [https://docs.docker.com/compose/](https://docs.docker.com/compose/).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Docker Compose及其功能的详细描述，请参阅官方页面：[https://docs.docker.com/compose/](https://docs.docker.com/compose/)。
- en: We present the Docker Compose tool starting with the installation process, going
    through the docker-compose.yml configuration file and the `docker-compose` command,
    to end up with the building and scaling features.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从安装过程开始介绍Docker Compose工具，然后介绍docker-compose.yml配置文件和`docker-compose`命令，最后介绍构建和扩展功能。
- en: Installing Docker Compose
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker Compose
- en: 'The simplest method to install Docker Compose is to use the pip package manager:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker Compose的最简单方法是使用pip软件包管理器：
- en: You can find the pip tool installation guide at [https://pip.pypa.io/en/stable/installing/](https://pip.pypa.io/en/stable/installing/),
    or for Ubuntu, at `sudo apt-get install python-pip`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://pip.pypa.io/en/stable/installing/](https://pip.pypa.io/en/stable/installing/)找到pip工具的安装指南，或者在Ubuntu上使用`sudo
    apt-get install python-pip`。
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To check that Docker Compose is installed, we can run:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查Docker Compose是否已安装，我们可以运行：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Installation guidelines for all operating systems can be found at [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作系统的安装指南都可以在[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)找到。
- en: Defining docker-compose.yml
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义docker-compose.yml
- en: The `docker-compose.yml` file is used to define the configuration for containers,
    their relations, and runtime properties.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yml`文件用于定义容器的配置、它们之间的关系和运行时属性。'
- en: In other words, when Dockerfile specifies how to create a single Docker image,
    then `docker-compose.yml` specifies how to set up the entire environment out of
    Docker images.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当Dockerfile指定如何创建单个Docker镜像时，`docker-compose.yml`指定了如何在Docker镜像之外设置整个环境。
- en: There are three versions of the `docker-compose.yml` file format. In this book,
    we use version 3, which is the most current and recommended. Read more at: [https://docs.docker.com/compose/compose-file/compose-versioning/](https://docs.docker.com/compose/compose-file/compose-versioning/).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yml`文件格式有三个版本。在本书中，我们使用的是最新和推荐的版本3。更多信息请阅读：[https://docs.docker.com/compose/compose-file/compose-versioning/](https://docs.docker.com/compose/compose-file/compose-versioning/)。'
- en: The `docker-compose.yml` file has a lot of features and all of them can be found
    at the official page: [https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/).
    We will cover the most important ones in the context of the Continuous Delivery
    process.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yml`文件具有许多功能，所有这些功能都可以在官方页面找到：[https://docs.docker.com/compose/compose-file/](https://docs.docker.com/compose/compose-file/)。我们将在持续交付过程的上下文中介绍最重要的功能。'
- en: Let's start with an example and imagine that our calculator project uses the
    Redis server for caching. In this case, we need an environment with two containers, `calculator` and
    `redis`. In a new directory, let's create the `docker-compose.yml` file.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个例子开始，假设我们的计算器项目使用Redis服务器进行缓存。在这种情况下，我们需要一个包含两个容器`calculator`和`redis`的环境。在一个新目录中，让我们创建`docker-compose.yml`文件。
- en: '[PRE23]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The environment configuration is presented in the following figure:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 环境配置如下图所示：
- en: '![](assets/dc2fb242-79fe-404e-bce6-e057c0f11a62.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dc2fb242-79fe-404e-bce6-e057c0f11a62.png)'
- en: 'Let''s see the definition of the two containers:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这两个容器的定义：
- en: '**redis**: A container from the latest version of the `redis` image pulled
    from the official Docker Hub.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**redis**：来自官方Docker Hub最新版本的`redis`镜像的容器。'
- en: '**calculator**: A container from the latest version of the `calculator` image
    built locally. It publishes the `8080` port to the Docker host (which is a substitute
    for the `-p` option of the `docker` command). The container links to the `redis` container,
    which means that they share the same network and the `redis` IP address is visible
    under the `redis` hostname from inside the `calculator` container.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**calculator**：来自本地构建的`calculator`镜像的最新版本的容器。它将`8080`端口发布到Docker主机（这是`docker`命令的`-p`选项的替代）。该容器链接到`redis`容器，这意味着它们共享相同的网络，`redis`
    IP地址在`calculator`容器内部的`redis`主机名下可见。'
- en: If we like a service to be addressed by a different hostname than its service
    name (for example, by redis-cache apart from redis), then we can create aliases
    using the links keyword.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望通过不同的主机名来访问服务（例如，通过redis-cache而不是redis），那么我们可以使用链接关键字创建别名。
- en: Using the docker-compose command
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用docker-compose命令
- en: 'The `docker-compose` command reads the definition file and creates the environment:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`命令读取定义文件并创建环境：'
- en: '[PRE24]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The command started two containers, `calculator` and `redis` in the background
    (`-d` option). We can check that the containers are running:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令在后台启动了两个容器，`calculator`和`redis`（使用`-d`选项）。我们可以检查容器是否在运行：
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The container names are prefixed with the project name `project`, which is
    taken from the name of the directory in which the `docker-compose.yml` file is
    placed. We could specify the project name manually using the `-p <project_name>` option.
    Since Docker Compose is run on top of Docker, we can also use the `docker` command
    to confirm that the containers are running:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 容器名称以项目名称`project`为前缀，该名称取自放置`docker-compose.yml`文件的目录的名称。我们可以使用`-p <project_name>`选项手动指定项目名称。由于Docker
    Compose是在Docker之上运行的，我们也可以使用`docker`命令来确认容器是否在运行：
- en: '[PRE26]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When we''re done, we can tear down the environment:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们可以拆除环境：
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The example is very simple, but the tool itself is extremely powerful. With
    a short configuration and a bunch of commands, we control the orchestration of
    all services. Before we use Docker Compose for acceptance testing, let''s look
    at two other Docker Compose features: building images and scaling containers.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子非常简单，但这个工具本身非常强大。通过简短的配置和一堆命令，我们可以控制所有服务的编排。在我们将Docker Compose用于验收测试之前，让我们看看另外两个Docker
    Compose的特性：构建镜像和扩展容器。
- en: Building images
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建镜像
- en: In the preceding example, we had to first build the `calculator` image using
    the `docker build` command, and then it could be specified inside docker-compose.yml.
    There is also another approach to let Docker Compose build the image. In that
    case, we need to specify the `build` property instead of `image` in the configuration.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先使用`docker build`命令构建了`calculator`镜像，然后可以在docker-compose.yml中指定它。还有另一种方法让Docker
    Compose构建镜像。在这种情况下，我们需要在配置中指定`build`属性而不是`image`。
- en: 'Let''s put the `docker-compose.yml` file in the calculator project''s directory.
    When Dockerfile and Docker Compose configurations are in the same directory, the
    former can look as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把`docker-compose.yml`文件放在计算器项目的目录中。当Dockerfile和Docker Compose配置在同一个目录中时，前者可以如下所示：
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `docker-compose build` command builds the image. We can also ask Docker
    Compose to build images before running the containers with the use of the `docker-compose
    --build up` command.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose build`命令构建镜像。我们还可以要求Docker Compose在运行容器之前构建镜像，使用`docker-compose
    --build up`命令。'
- en: Scaling services
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展服务
- en: 'Docker Compose provides the functionality to automatically create multiple
    instances of the same container. We can either specify the `replicas: <number>` parameter
    inside `docker-compose.yml` or use the `docker-compose scale` command.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 'Docker Compose提供了自动创建多个相同容器实例的功能。我们可以在`docker-compose.yml`中指定`replicas: <number>`参数，也可以使用`docker-compose
    scale`命令。'
- en: 'As an example, let''s run the environment again and replicate the `calculator` container:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们再次运行环境并复制`calculator`容器：
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can check which containers are running:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查正在运行的容器：
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Five `calculator` containers are exactly the same, apart from the container
    ID, container name, and published port numbers.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 五个`calculator`容器完全相同，除了容器ID、容器名称和发布端口号。
- en: 'They all use the same instance of the Redis container. We can now stop and
    remove all the containers:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都使用相同的Redis容器实例。现在我们可以停止并删除所有容器：
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Scaling containers is one of the most impressive Docker Compose features. With
    one command, we can scale up and down the number of clone instances. Docker Compose
    takes care of cleaning up the containers that are no longer used.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展容器是Docker Compose最令人印象深刻的功能之一。通过一个命令，我们可以扩展克隆实例的数量。Docker Compose负责清理不再使用的容器。
- en: We have seen the most interesting functionalities of the Docker Compose tool.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Docker Compose工具最有趣的功能。
- en: In the next section, we will focus on how to use it in the context of automated
    acceptance testing.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将重点介绍如何在自动验收测试的情境中使用它。
- en: Acceptance testing with Docker Compose
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose进行验收测试
- en: Docker Compose fits the acceptance testing process perfectly because it enables
    setting up the entire environment with one command. What's more, after the testing
    is performed, the environment can also be cleaned up with one command. If we decide
    to use Docker Compose on production, then the other benefit is that the acceptance
    test uses exactly the same configuration, tools, and commands as the released
    application.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose非常适合验收测试流程，因为它可以通过一个命令设置整个环境。更重要的是，在测试完成后，也可以通过一个命令清理环境。如果我们决定在生产环境中使用Docker
    Compose，那么另一个好处是验收测试使用的配置、工具和命令与发布的应用程序完全相同。
- en: 'To see how to apply Docker Compose for the Jenkins acceptance testing stage,
    let''s continue the calculator project example and add the Redis-based caching
    to the application. Then, we will see two different approaches to run acceptance
    testing: the Jenkins-first method and the Docker-first method.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在Jenkins验收测试阶段应用Docker Compose，让我们继续计算器项目示例，并将基于Redis的缓存添加到应用程序中。然后，我们将看到两种不同的方法来运行验收测试：先Jenkins方法和先Docker方法。
- en: Using a multi-container environment
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多容器环境
- en: Docker Compose provides dependencies between the containers; in other words,
    it links one container to another container. Technically, this means that containers
    share the same network and that one container is visible from the other. To continue
    our example, we need to add this dependency in the code, and we will do this in
    a few steps.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose提供了容器之间的依赖关系；换句话说，它将一个容器链接到另一个容器。从技术上讲，这意味着容器共享相同的网络，并且一个容器可以从另一个容器中看到。为了继续我们的示例，我们需要在代码中添加这个依赖关系，我们将在几个步骤中完成。
- en: Adding a Redis client library to Gradle
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Gradle添加Redis客户端库
- en: 'In the `build.gradle` file, add the following configuration to the `dependencies` section:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build.gradle`文件中，在`dependencies`部分添加以下配置：
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It adds the Java libraries that take care of the communication with Redis.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 它添加了负责与Redis通信的Java库。
- en: Adding a Redis cache configuration
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Redis缓存配置
- en: 'Add a new file `src/main/java/com/leszko/calculator/CacheConfig.java`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新文件`src/main/java/com/leszko/calculator/CacheConfig.java`：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This a standard Spring cache configuration. Note that for the Redis server address,
    we use the `redis` hostname that is automatically available thanks to the Docker
    Compose linking mechanism.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的Spring缓存配置。请注意，对于Redis服务器地址，我们使用`redis`主机名，这是由于Docker Compose链接机制自动可用。
- en: Adding Spring Boot caching
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Spring Boot缓存
- en: 'When the cache is configured, we can finally add caching to our web service.
    In order to do this, we need to change the `src/main/java/com/leszko/calculator/Calculator.java` file
    to look as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当缓存配置好后，我们最终可以将缓存添加到我们的网络服务中。为了做到这一点，我们需要更改`src/main/java/com/leszko/calculator/Calculator.java`文件如下：
- en: '[PRE34]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: From now on, the sum calculations are cached in Redis, and when we call the
    `/sum` endpoint of the `calculator` web service, it will first try to retrieve
    the result from the cache.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，求和计算将被缓存在Redis中，当我们调用`calculator`网络服务的`/sum`端点时，它将首先尝试从缓存中检索结果。
- en: Checking the caching environment
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查缓存环境
- en: 'Assuming that we have our docker-compose.yml in the calculator project''s directory,
    we can now start the containers:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的docker-compose.yml在计算器项目的目录中，我们现在可以启动容器了：
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can check the port on which the calculator service is published:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查计算器服务发布的端口：
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we open the browser on `localhost:32783/sum?a=1&b=2`, the calculator service
    should reply `3` and, in the meantime, access the `redis` service and store the
    cached value there. To see that the cache value was really stored in Redis, we
    can access the `redis` container and look inside the Redis database:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`localhost:32783/sum?a=1&b=2`上打开浏览器，计算器服务应该回复`3`，同时访问`redis`服务并将缓存值存储在那里。为了查看缓存值是否真的存储在Redis中，我们可以访问`redis`容器并查看Redis数据库内部：
- en: '[PRE37]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `docker-compose exec` command executed the `redis-cli` (the Redis client
    to browse its database content) command inside the `redis` container. Then, we
    can run `keys *` to print everything that is stored in Redis.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose exec`命令在`redis`容器内执行了`redis-cli`（Redis客户端以浏览其数据库内容）命令。然后，我们可以运行`keys
    *`来打印Redis中存储的所有内容。'
- en: You can play more with the calculator application and open the browser with
    different values to see that the Redis service content increases. After this,
    it's important to tear down the environment with the `docker-compose down` command.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过计算器应用程序进行更多操作，并使用不同的值在浏览器中打开，以查看Redis服务内容增加。之后，重要的是使用`docker-compose down`命令拆除环境。
- en: In the next sections, we will see two methods of acceptance tests for the multi-container
    project. Obviously, before we take any action on Jenkins, we need to commit and
    push all the changed files (including `docker-compose.yml`) to GitHub.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看到多容器项目的两种验收测试方法。显然，在Jenkins上采取任何行动之前，我们需要提交并推送所有更改的文件（包括`docker-compose.yml`）到GitHub。
- en: Note that, for further steps, Docker Compose has to be installed on Jenkins
    executors.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于进一步的步骤，Jenkins执行器上必须安装Docker Compose。
- en: Method 1 – Jenkins-first acceptance testing
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法1 - 首先进行Jenkins验收测试
- en: 'The first method is to perform acceptance testing in the same way we did in
    the case of a single container application. The only difference is that now we
    have two containers running as presented in the following figure:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是以与单容器应用程序相同的方式执行验收测试。唯一的区别是现在我们有两个容器正在运行，如下图所示：
- en: '![](assets/4d652e64-a061-46a8-ac71-e7dbaa9b6960.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4d652e64-a061-46a8-ac71-e7dbaa9b6960.png)'
- en: The `redis` container is not visible from a user perspective, so as a result,
    the only difference between single-container and multi-container acceptance testing
    is that we use the `docker-compose up` command instead of `docker run`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户角度来看，`redis`容器是不可见的，因此单容器和多容器验收测试之间唯一的区别是我们使用`docker-compose up`命令而不是`docker
    run`。
- en: 'Other Docker commands can be also replaced with their Docker Compose equivalents:
    `docker-compose build` for `docker build` and `docker-compose push` for `docker
    push`. Nevertheless, if we build just one image, then leaving Docker commands
    is fine as well.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 其他Docker命令也可以用它们的Docker Compose等效命令替换：`docker-compose build` 替换 `docker build`，`docker-compose
    push` 替换 `docker push`。然而，如果我们只构建一个镜像，那么保留Docker命令也是可以的。
- en: Changing the staging deployment stage
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变暂存部署阶段
- en: 'Let''s change the `Deploy to staging` stage to use Docker Compose:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变 `部署到暂存` 阶段来使用Docker Compose：
- en: '[PRE38]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We must change the clean up in exactly the same way:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须以完全相同的方式改变清理：
- en: '[PRE39]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Changing the acceptance test stage
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变验收测试阶段
- en: For the purpose of using `docker-compose scale`, we didn't specify the port
    number under which our web service would be published. If we did, then the scaling
    process would fail because all clones would try to publish under the same port
    number. On the contrary, we let Docker choose the port. Therefore, we need to
    change the `acceptance_test.sh` script to first find what the port number is and
    then run `curl` with the correct port number.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 `docker-compose scale`，我们没有指定我们的web服务将发布在哪个端口号下。如果我们这样做了，那么扩展过程将失败，因为所有克隆将尝试在相同的端口号下发布。相反，我们让Docker选择端口。因此，我们需要改变
    `acceptance_test.sh` 脚本，首先找出端口号是多少，然后使用正确的端口号运行 `curl`。
- en: '[PRE40]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s figure out how we found the port number:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出我们是如何找到端口号的：
- en: The `docker-compose port calculator 8080` command checks under which IP and
    port address the web service is published (it returns, for example, `127.0.0.1:57648`).
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker-compose port calculator 8080` 命令检查web服务发布在哪个IP和端口地址下（例如返回 `127.0.0.1:57648`）。'
- en: '`cut -d: -f2` selects only port (for example, for `127.0.0.1:57648`, it returns
    `57648`).'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cut -d: -f2` 选择只有端口（例如，对于 `127.0.0.1:57648`，它返回 `57648`）。'
- en: We can push the change to GitHub and observe the Jenkins results. The idea is
    still the same as with the single-container application, set up the environment,
    run the acceptance test suite, and tear down the environment. Even though this
    acceptance testing method is good and works well, let's look at the alternative
    solution.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将更改推送到GitHub并观察Jenkins的结果。这个想法和单容器应用程序的想法是一样的，设置环境，运行验收测试套件，然后拆除环境。尽管这种验收测试方法很好并且运行良好，让我们看看另一种解决方案。
- en: Method 2 – Docker-first acceptance testing
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法2 – 先Docker验收测试
- en: 'In the Docker-first approach, we create an additional `test` container that
    performs testing from inside the Docker host, as presented in the following figure:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker-first方法中，我们创建了一个额外的 `test` 容器，它从Docker主机内部执行测试，如下图所示：
- en: '![](assets/78c8fd68-b33a-41f8-9d5a-a8ae5998f5aa.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/78c8fd68-b33a-41f8-9d5a-a8ae5998f5aa.png)'
- en: This approach facilitates the acceptance test script in terms of retrieving
    the port number and can be easily run without Jenkins. It's also much more in
    the Docker style.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在检索端口号方面简化了验收测试脚本，并且可以在没有Jenkins的情况下轻松运行。它也更符合Docker的风格。
- en: The drawback is that we need to create a separate Dockerfile and Docker Compose
    configuration for the purpose of testing.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是我们需要为测试目的创建一个单独的Dockerfile和Docker Compose配置。
- en: Creating a Dockerfile for acceptance test
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为验收测试创建一个Dockerfile
- en: 'We will start by creating a separate Dockerfile for acceptance testing. Let''s
    create a new directory `acceptance` in the calculator project and a Dockerfile
    inside:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为验收测试创建一个单独的Dockerfile。让我们在计算器项目中创建一个新目录 `acceptance` 和一个Dockerfile。
- en: '[PRE41]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It creates an image that runs the acceptance test.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建一个运行验收测试的镜像。
- en: Creating docker-compose.yml for acceptance test
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为验收测试创建一个docker-compose.yml
- en: 'In the same directory, let''s create `docker-compose-acceptance.yml` to provide
    the testing orchestration:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个目录下，让我们创建 `docker-compose-acceptance.yml` 来提供测试编排：
- en: '[PRE42]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It creates a new container that is linked to the container being tested: `calculator`.
    What''s more, internally it''s always 8080 so that eliminates the need for the
    tricky part of port finding.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建一个新的容器，链接到被测试的容器：`calculator`。而且，内部始终是8080，这就消除了端口查找的麻烦部分。
- en: Creating an acceptance test script
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建验收测试脚本
- en: 'The last missing part is the test script. In the same directory, let''s create
    the `test.sh` file that represents the acceptance test:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 最后缺失的部分是测试脚本。在同一目录下，让我们创建代表验收测试的`test.sh`文件：
- en: '[PRE43]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It's very similar to the previous acceptance test script, the only difference
    is that we can address the calculator service by the `calculator` hostname and
    that the port number is always `8080`. Also, in this case, we wait inside the
    script, not in the Jenkinsfile.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 它与之前的验收测试脚本非常相似，唯一的区别是我们可以通过`calculator`主机名来访问计算器服务，端口号始终是`8080`。此外，在这种情况下，我们在脚本内等待，而不是在Jenkinsfile中等待。
- en: Running the acceptance test
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行验收测试
- en: 'We can run the test locally using the Docker Compose command from the root
    project directory:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用根项目目录下的Docker Compose命令在本地运行测试：
- en: '[PRE44]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The command uses two Docker Compose configurations to run the `acceptance` project.
    One of the started containers should be called `acceptance_test_1` and be interested
    in its result. We can check its logs with the following command:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令使用两个Docker Compose配置来运行`acceptance`项目。其中一个启动的容器应该被称为`acceptance_test_1`，并对其结果感兴趣。我们可以使用以下命令检查其日志：
- en: '[PRE45]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The log shows that the `curl` command has been successfully called. If we want
    to check whether the test succeeded or failed, we can check the exit code of the
    container:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 日志显示`curl`命令已成功调用。如果我们想要检查测试是成功还是失败，可以检查容器的退出代码：
- en: '[PRE46]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `0` exit code means that the test succeeded. Any code other than `0` would
    mean that the test failed. After the test is done, we should, as always, tear
    down the environment:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`0`退出代码表示测试成功。除了`0`之外的任何代码都意味着测试失败。测试完成后，我们应该像往常一样清理环境：'
- en: '[PRE47]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Changing the acceptance test stage
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改验收测试阶段
- en: 'As the last step, we can add the acceptance test execution to the pipeline.
    Let''s replace the last three stages in Jenkinsfile with one new **Acceptance
    test** stage:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步，我们可以将验收测试执行添加到流水线中。让我们用一个新的**验收测试**阶段替换Jenkinsfile中的最后三个阶段：
- en: '[PRE48]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This time, we first build the `test` service. There is no need to build the
    `calculator` image; it''s already done by the previous stages. In the end, we
    should clean up the environment:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们首先构建`test`服务。不需要构建`calculator`镜像；它已经在之前的阶段完成了。最后，我们应该清理环境：
- en: '[PRE49]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After adding this to Jenkinsfile, we're done with the second method. We can
    test this by pushing all the changes to GitHub.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkinsfile中添加了这个之后，我们就完成了第二种方法。我们可以通过将所有更改推送到GitHub来测试这一点。
- en: Comparing method 1 and method 2
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较方法1和方法2
- en: To sum up, let's compare both solutions. The first approach is the real black-box
    testing from the user perspective in which Jenkins plays the role of a user. The
    advantage is that it's very close to what will be done in production; in the end,
    we will access containers via its Docker host. The second approach tests the application
    from the inside of another container. The solution is somehow more elegant and
    can be run locally in a simple way; however, it requires more files to create
    and does not call the application via its Docker host like it will be later done
    in production.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，让我们比较两种解决方案。第一种方法是从用户角度进行真正的黑盒测试，Jenkins扮演用户的角色。优点是它非常接近于在生产中将要做的事情；最后，我们将通过其Docker主机访问容器。第二种方法是从另一个容器的内部测试应用程序。这种解决方案在某种程度上更加优雅，可以以简单的方式在本地运行；但是，它需要创建更多的文件，并且不像在生产中将来要做的那样通过其Docker主机调用应用程序。
- en: In the next section, we step away from Docker and Jenkins and take a closer
    look at the process of writing the acceptance tests themselves.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将远离Docker和Jenkins，更仔细地研究编写验收测试的过程。
- en: Writing acceptance tests
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写验收测试
- en: 'So far, we used the `curl` command to perform a suite of acceptance tests.
    That is obviously a considerable simplification. Technically speaking, if we write
    a REST web service, then we could write all black-box tests as a big script with
    a number of "curl" calls. This solution would be, however, very difficult to read,
    understand, and maintain. What''s more, the script would be completely incomprehensible
    by non-technical, business-related users. How to address this issue and create
    tests with a good structure, readable by users, and meet its fundamental goal:
    automatically checking if the system is as expected? I will answer this question
    throughout this section.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用`curl`命令执行一系列验收测试。这显然是一个相当简化的过程。从技术上讲，如果我们编写一个REST Web服务，那么我们可以将所有黑盒测试写成一个大脚本，其中包含多个“curl”调用。然而，这种解决方案非常难以阅读、理解和维护。而且，这个脚本对非技术的业务相关用户来说完全无法理解。如何解决这个问题，创建具有良好结构、可读性强的测试，并满足其基本目标：自动检查系统是否符合预期？我将在本节中回答这个问题。
- en: Writing user-facing tests
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写面向用户的测试
- en: Acceptance tests are written with users and should be comprehensible to users.
    This is why the choice of a method for writing them depends on who the customer
    is.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试是为用户编写的，应该让用户能够理解。这就是为什么编写它们的方法取决于客户是谁。
- en: For example, imagine a purely technical person. If you write a web service that
    optimizes the database storing, and your system is used only by other systems
    and read only by other developers, then your tests can be expressed in the same
    way as unit tests. As a rule, the test is good if understood by both, developer
    and user.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一个纯粹的技术人员。如果你编写了一个优化数据库存储的Web服务，而你的系统只被其他系统使用，并且只被其他开发人员读取，那么你的测试可以以与单元测试相同的方式表达。通常情况下，测试是好的，如果开发人员和用户都能理解。
- en: 'In real life, most software is written to deliver a specific business value,
    and that business value is defined by non-developers. Therefore, we need a common
    language to collaborate. On one side, there is the business who understands what
    is needed but not how to do it; on the other side, the development team who knows
    how but doesn''t know what. Luckily, there are a number of frameworks that help
    to connect these two worlds, for instance, Cucumber, FitNesse, JBehave, Capybara,
    and many more. They differ from each other, and each of them may be a subject
    for a separate book; however, the general idea of writing acceptance tests is
    the same and can be presented in the following figure:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，大多数软件都是为了提供特定的业务价值而编写的，而这个业务价值是由非开发人员定义的。因此，我们需要一种共同的语言来合作。一方面，业务了解需要什么，但不知道如何做；另一方面，开发团队知道如何做，但不知道需要什么。幸运的是，有许多框架可以帮助连接这两个世界，例如Cucumber、FitNesse、JBehave、Capybara等等。它们彼此之间有所不同，每一个都可能成为一本单独的书的主题；然而，编写验收测试的一般思想是相同的，并且可以用以下图表来表示：
- en: '![](assets/8b572c5e-b2b1-4f86-90b2-a2d60f6f42fc.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8b572c5e-b2b1-4f86-90b2-a2d60f6f42fc.png)'
- en: 'The **Acceptance Criteria** are written by users (or a product owner as their
    representative) with the help of developers. They are usually written in the form
    of the following scenarios:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**验收标准**由用户（或其代表产品所有者）与开发人员的帮助下编写。它们通常以以下场景的形式编写：'
- en: '[PRE50]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Developers write the testing implementation called **fixtures** or **step definitions** that
    integrates the human-friendly DSL specification with the programming language.
    As a result, we have an automated test that can be well-integrated into the Continuous
    Delivery pipeline.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员编写称为**fixtures**或**步骤定义**的测试实现，将人性化的DSL规范与编程语言集成在一起。因此，我们有了一个可以很好集成到持续交付管道中的自动化测试。
- en: Needless to add, writing acceptance tests is a continuous agile process, not
    a waterfall one. It requires constant collaboration during which the test specifications
    are improved and maintained by both, developers and business.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 不用说，编写验收测试是一个持续的敏捷过程，而不是瀑布式过程。这需要开发人员和业务方的不断协作，以改进和维护测试规范。
- en: In the case of an application with a user interface, it can be tempting to perform
    the acceptance testing directly via the interface (for example, by recording Selenium
    scripts); however, this approach when not done properly can lead to tests that
    are slow and tightly coupled to the interface layer.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有用户界面的应用程序，直接通过界面执行验收测试可能很诱人（例如，通过记录Selenium脚本）；然而，如果没有正确执行，这种方法可能导致测试速度慢且与界面层紧密耦合的问题。
- en: Let's see how writing acceptance tests look in practice and how to bind them
    to the Continuous Delivery pipeline.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实践中编写验收测试的样子，以及如何将它们绑定到持续交付管道中。
- en: Using the acceptance testing framework
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用验收测试框架
- en: 'Let''s use the Cucumber framework and create an acceptance test for the calculator
    project. As previously described, we will do this in three steps:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用黄瓜框架为计算器项目创建一个验收测试。如前所述，我们将分三步完成这个过程：
- en: Creating acceptance criteria
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建验收标准
- en: Creating step definitions
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建步骤定义
- en: Running an automated acceptance test
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行自动化验收测试
- en: Creating acceptance criteria
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建验收标准
- en: 'Let''s put the business specification in `src/test/resources/feature/calculator.feature`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将业务规范放在`src/test/resources/feature/calculator.feature`中：
- en: '[PRE51]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This file should be created by users with the help of developers. Note that
    it is written in a way that non-technical people can understand it.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件应该由用户在开发人员的帮助下创建。请注意，它是以非技术人员可以理解的方式编写的。
- en: Creating step definitions
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建步骤定义
- en: 'The next step is to create the Java bindings so that the feature specification
    would be executable. In order to do this, we create a new file `src/test/java/acceptance/StepDefinitions.java`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建Java绑定，以便特性规范可以被执行。为了做到这一点，我们创建一个新文件`src/test/java/acceptance/StepDefinitions.java`：
- en: '[PRE52]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Each line (`Given`, `When`, and `Then`) from the feature specification file
    is matched by regular expressions with the corresponding method in the Java code.
    The wildcards `(.*)` are passed as parameters. Note that the server address is
    passed as the Java property `calculator.url`. The method performs the following
    actions:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 特性规范文件中的每一行（`Given`，`When`和`Then`）都与Java代码中相应的方法匹配。通配符`(.*)`作为参数传递。请注意，服务器地址作为Java属性`calculator.url`传递。该方法执行以下操作：
- en: '`i_have_two_numbers`: Saves parameters as fields'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i_have_two_numbers`：将参数保存为字段'
- en: '`the_calculator_sums_them`: Calls the remote calculator service and stores
    the result in a field'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`the_calculator_sums_them`：调用远程计算器服务并将结果存储在字段中'
- en: '`i_receive_as_a_result`: Asserts that the result is as expected'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i_receive_as_a_result`：断言结果是否符合预期'
- en: Running an automated acceptance test
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行自动化验收测试
- en: 'To run an automated test, we need to make a few configurations:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行自动化测试，我们需要进行一些配置：
- en: '**Add Java cucumber libraries**: In the `build.gradle` file, add the following
    code to the `dependencies` section:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加Java黄瓜库**：在`build.gradle`文件中，将以下代码添加到`dependencies`部分：'
- en: '[PRE53]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Add Gradle target**: In the same file, add the following code:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加Gradle目标**：在同一文件中，添加以下代码：'
- en: '[PRE54]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This splits the tests into unit (run with `./gradlew test`) and acceptance (run
    with `./gradlew acceptanceTest`).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这将测试分为单元测试（使用`./gradlew test`运行）和验收测试（使用`./gradlew acceptanceTest`运行）。
- en: '**Add JUnit runner**: Add a new file `src/test/java/acceptance/AcceptanceTest.java`:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加JUnit运行器**：添加一个新文件`src/test/java/acceptance/AcceptanceTest.java`：'
- en: '[PRE55]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is the entry point to the acceptance test suite.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这是验收测试套件的入口点。
- en: 'After this configuration, if the server is running on the localhost, we can
    test it by executing the following code:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行此配置之后，如果服务器正在本地主机上运行，我们可以通过执行以下代码来测试它：
- en: '[PRE56]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Obviously, we can add this command to our `acceptance_test.sh` instead of the
    `curl` command. This would make the Cucumber acceptance test run in the Jenkins
    pipeline.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可以将此命令添加到我们的`acceptance_test.sh`中，而不是`curl`命令。这将使Cucumber验收测试在Jenkins流水线中运行。
- en: Acceptance test-driven development
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验收测试驱动开发
- en: Acceptance tests, like most aspects of the Continuous Delivery process, are
    less about technology and more about people. The test quality depends on, of course,
    the engagement of users and developers, but also, what is maybe less intuitive,
    the time when the tests are created.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 与持续交付过程的大多数方面一样，验收测试更多地关乎人而不是技术。测试质量当然取决于用户和开发人员的参与，但也取决于测试创建的时间，这可能不太直观。
- en: The last question to ask is, during which phase of the software development
    life cycle should the acceptance tests be prepared? Or to rephrase it, should
    we create acceptance tests before or after writing the code?
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个问题是，在软件开发生命周期的哪个阶段应准备验收测试？或者换句话说，我们应该在编写代码之前还是之后创建验收测试？
- en: 'Technically speaking, the result is the same; the code is well-covered with
    both, unit and acceptance tests. However, it''s tempting to consider writing tests
    first. The idea of TDD (test-driven development) can be well adapted for acceptance
    testing. If unit tests are written before the code, the result code is cleaner
    and better structured. Analogously, if acceptance tests are written before the
    system feature, the resulting feature corresponds better to the customer''s requirements.
    This process, often called acceptance test-driven development, is presented in
    the following figure:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，结果是一样的；代码既有单元测试，也有验收测试覆盖。然而，考虑先编写测试的想法是很诱人的。TDD（测试驱动开发）的理念可以很好地适用于验收测试。如果在编写代码之前编写单元测试，结果代码会更清洁、结构更好。类似地，如果在系统功能之前编写验收测试，结果功能将更符合客户的需求。这个过程，通常称为验收测试驱动开发，如下图所示：
- en: '![](assets/432d2a13-c759-4399-b9c4-452689af60fe.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/432d2a13-c759-4399-b9c4-452689af60fe.png)'
- en: Users, with developers, write the acceptance criteria specification in the human-friendly
    DSL format. Developers write the fixtures and the tests fail. Then, the feature
    development starts using the TDD methodology internally. After the feature is
    completed, the acceptance test should pass, and this is a sign that the feature
    is completed.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 用户与开发人员以人性化的DSL格式编写验收标准规范。开发人员编写固定装置，测试失败。然后，使用TDD方法进行内部功能开发。功能完成后，验收测试应该通过，这表明功能已完成。
- en: A very good practice is to attach the Cucumber feature specification to the
    request ticket in the issue tracking tool (for example, JIRA) so that the feature
    would be always requested together with its acceptance test. Some development
    teams take an even more radical approach and refuse to start the development process
    if no acceptance tests are prepared. There is a lot of sense in that, after all, *how
    can you develop something that the client can't test?*
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常好的做法是将Cucumber功能规范附加到问题跟踪工具（例如JIRA）中的请求票据上，以便功能总是与其验收测试一起请求。一些开发团队采取了更激进的方法，拒绝在没有准备验收测试的情况下开始开发过程。毕竟，这是有道理的，*你怎么能开发客户无法测试的东西呢？*
- en: Exercises
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'We covered a lot of new material throughout this chapter, so to better understand,
    we recommend doing the exercises and creating your own project with acceptance
    tests:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多新材料，为了更好地理解，我们建议做练习，并创建自己的验收测试项目：
- en: 'Create a Ruby-based web service `book-library` to store books:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于Ruby的Web服务“book-library”来存储书籍：
- en: 'The acceptance criteria is delivered in the form of the following Cucumber
    feature:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 验收标准以以下Cucumber功能的形式交付：
- en: '[PRE57]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Write step definitions for the Cucumber test
  id: totrans-378
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Cucumber测试编写步骤定义
- en: Write the web service (the simplest is to use the Sinatra framework: [http://www.sinatrarb.com/](http://www.sinatrarb.com/),
    but you can also use Ruby on Rails).
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Web服务（最简单的方法是使用Sinatra框架：[http://www.sinatrarb.com/](http://www.sinatrarb.com/)，但您也可以使用Ruby
    on Rails）。
- en: 'The book should have the following attributes: name, author, and ISBN.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书应具有以下属性：名称，作者和ISBN。
- en: 'The web service should have the following endpoints:'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务应具有以下端点：
- en: POST "`/books/`" to add a book
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POST“/books/”以添加书籍
- en: GET "`books/<isbn>`" to retrieve the book
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GET“books/<isbn>”以检索书籍
- en: The data can be stored in the memory.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可以存储在内存中。
- en: In the end, check if the acceptance test is green.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，检查验收测试是否通过。
- en: 'Add "book-library" as a Docker image to the Docker registry:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“book-library”添加为Docker注册表中的Docker图像：
- en: Create an account on Docker Hub.
  id: totrans-387
  prefs:
  - PREF_OL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker Hub上创建一个帐户。
- en: Create Dockerfile for the application.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为应用程序创建Dockerfile。
- en: Build the Docker image and tag it according to the naming convention.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Docker图像并根据命名约定对其进行标记。
- en: Push the image to Docker Hub.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将图像推送到Docker Hub。
- en: 'Create the Jenkins pipeline to build Docker image, push it to the Docker registry,
    and perform acceptance testing:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Jenkins流水线以构建Docker图像，将其推送到Docker注册表并执行验收测试：
- en: Create a `"Docker build"` stage.
  id: totrans-392
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个“Docker构建”阶段。
- en: Create the `Docker login` and `Docker push` stages.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建“Docker登录”和“Docker推送”阶段。
- en: Create a `test` container that performs acceptance testing and use Docker Compose
    to perform the test.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个执行验收测试的“测试”容器，并使用Docker Compose执行测试。
- en: Add an `Acceptance test` stage to the pipeline.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在流水线中添加“验收测试”阶段。
- en: Run the pipeline and observe the result.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行流水线并观察结果。
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned how to build a complete and functional acceptance
    test stage, which is an essential part of the Continuous Delivery process. The
    key takeaway from the chapter:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何构建完整和功能齐全的验收测试阶段，这是持续交付过程的重要组成部分。本章的关键要点：
- en: Acceptance tests can be difficult to create because they combine technical challenges
    (application dependencies, environment set up) with personal challenges (developers-business
    collaboration).
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受测试可能很难创建，因为它们结合了技术挑战（应用程序依赖关系，环境设置）和个人挑战（开发人员与业务的合作）。
- en: Acceptance testing frameworks provide a way to write tests in a human-friendly
    language that makes them comprehensible to non-technical people.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试框架提供了一种以人类友好的语言编写测试的方法，使非技术人员能够理解。
- en: Docker registry is an artifact repository for Docker images.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker注册表是Docker镜像的工件存储库。
- en: Docker registry fits well with the Continuous Delivery process because it provides
    a way to use exactly the same Docker image throughout the stages and environments.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker注册表与持续交付流程非常匹配，因为它提供了一种在各个阶段和环境中使用完全相同的Docker镜像的方式。
- en: Docker Compose orchestrates a group of Docker container interacting together.
    It can also build images and scale containers.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose编排一组相互交互的Docker容器。它还可以构建镜像和扩展容器。
- en: Docker Compose can help with setting up a complete environment before running
    a suite of acceptance tests.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose可以帮助在运行一系列验收测试之前设置完整的环境。
- en: Acceptance tests can be written as a Docker image, and Docker Compose can run
    the complete environment together with the tests and provide the results.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试可以编写为Docker镜像，Docker Compose可以运行完整的环境以及测试，并提供结果。
- en: In the next chapter, we will cover the missing stages necessary to complete
    the Continuous Delivery pipeline.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍完成持续交付流水线所需的缺失阶段。
