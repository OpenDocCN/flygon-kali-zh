- en: Spring Microservices on Cloud Platforms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云平台上的Spring微服务
- en: Pivotal defines Spring Cloud as a framework that accelerates cloud-native application
    development. Today, when we talk about cloud-native applications, the first thing that
    comes to mind is the ability to deliver software quickly. To meet these demands,
    we should be able to quickly build new applications and design architectures that
    are scalable, portable, and prepared to be frequently updated. The tools that
    provide the mechanisms for containerization and orchestration help us in setting
    up and maintaining such an architecture. In fact, tools such as Docker or Kubernetes,
    which we have looked at in previous chapters, allow us to create our own private
    cloud and run Spring Cloud microservices on it. Although an application does not
    have to be deployed on a public cloud, it contains all of the most important characteristics
    of cloud software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Pivotal将Spring Cloud定义为加速云原生应用程序开发的框架。今天，当我们谈论云原生应用程序时，首先想到的是能够快速交付软件。为了满足这些需求，我们应该能够快速构建新的应用程序，并设计可扩展、可移植且准备好经常更新的架构。提供容器化和编排机制的工具帮助我们建立和维护这样的架构。事实上，像Docker或Kubernetes这样的工具，我们在之前的章节中已经看过，允许我们在其上创建自己的私有云并运行Spring
    Cloud微服务。尽管一个应用程序不必部署在公共云上，但它包含云软件的所有最重要的特征。
- en: Deploying your Spring application on a public cloud is just a possibility, not
    a necessity. However, there are some really interesting cloud platforms that allow
    you to easily run microservices and expose them on the web in just a few minutes.
    One of those platforms is **Pivotal Cloud Foundry** (**PCF**); its advantage over
    other platforms is its native support for Spring Cloud services, including discovery
    with Eureka, Config Server, and circuit breaker with Hystrix. You can also easily
    set up a full microservices environment just by enabling brokered services provided
    by Pivotal.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在公共云上部署您的Spring应用程序只是一种可能性，而不是必要性。然而，有一些非常有趣的云平台可以让您在几分钟内轻松运行微服务并将其暴露在网络上。其中一个平台是Pivotal
    Cloud Foundry（PCF）；它相对于其他平台的优势在于对Spring Cloud服务的本地支持，包括Eureka的发现、Config Server和Hystrix的断路器。您还可以通过启用Pivotal提供的经纪服务轻松设置完整的微服务环境。
- en: Another cloud platform that we should mention is Heroku. In contrast to PCF,
    it does not favor any programming framework. Heroku is a fully-managed, multi-language
    platform that allows you to quickly deliver software. It can build and run applications
    automatically once you have pushed changes in the source code stored on the GitHub
    repository. It also offers many add-on services that can be provisioned and scaled
    with a single command.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该提到的另一个云平台是Heroku。与PCF相比，它不偏爱任何编程框架。Heroku是一个完全托管的多语言平台，可以让您快速交付软件。一旦您将更改推送到GitHub存储库中的源代码，它就可以自动构建和运行应用程序。它还提供许多附加服务，可以通过单个命令进行配置和扩展。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Introduction to Pivotal Web Services platform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pivotal Web Services平台简介
- en: Deploying and managing applications on Pivotal Cloud Foundry using CLI, the
    Maven plugin, and the UI dashboard
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CLI、Maven插件和UI仪表板在Pivotal Cloud Foundry上部署和管理应用程序
- en: Using Spring Cloud Foundry libraries to prepare an application to work properly
    on the platform
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Foundry库来准备应用程序在平台上正常工作
- en: Deploying Spring Cloud microservices on the Heroku platform
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Heroku平台上部署Spring Cloud微服务
- en: Managing brokered services
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理经纪服务
- en: Pivotal Cloud Foundry
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pivotal Cloud Foundry
- en: 'Although the Pivotal platform can run applications written in many languages,
    including Java, .NET, Ruby, JavaScript, Python, PHP, and Go, it has the best support
    for Spring Cloud Services and Netflix OSS tools. It makes perfect sense because
    they are the ones who developed Spring Cloud. Take a look at the following diagram,
    which is also available on Pivotal''s official website. The following diagram
    illustrates the microservices-based architecture provided by the Pivotal Cloud
    platform. You can use Spring Cloud on Cloud Foundry to quickly leverage common
    microservice patterns, including distributed configuration management, service
    discovery, dynamic routing, load balancing, and fault tolerance:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Pivotal平台可以运行用多种语言编写的应用程序，包括Java、.NET、Ruby、JavaScript、Python、PHP和Go，但它对Spring
    Cloud Services和Netflix OSS工具的支持最好。这是非常合理的，因为它们是开发Spring Cloud的人。看一下下面的图表，这也可以在Pivotal的官方网站上找到。下面的图表说明了Pivotal
    Cloud平台提供的基于微服务的架构。您可以在Cloud Foundry上使用Spring Cloud快速利用常见的微服务模式，包括分布式配置管理、服务发现、动态路由、负载平衡和容错：
- en: '![](img/5b400ae4-44d3-4476-9425-dfe2194be84e.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b400ae4-44d3-4476-9425-dfe2194be84e.png)'
- en: Usage models
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模型
- en: 'You can use the Pivotal platform in three different models. Models are distinguished
    based on the host, which is where the applications are deployed. The following
    is a list of the available solutions:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Pivotal平台的三种不同模型。模型是根据主机来区分的，即应用程序部署的地方。以下是可用解决方案的列表：
- en: '**PCF Dev**: This instance of the Pivotal platform can be run locally on a
    single virtual machine. It is designed for experimental and developmental needs.
    It does not offer all possible features and services. For example, there are only
    some built-in services, such as Redis, MySQL, and RabbitMQ. However, PCF Dev also
    supports **Spring Cloud Services** (**SCS**), as well as all the languages supported
    in the full version of PCF. It is worth noting that if you want to run PCF Dev
    locally with SCS, you need more than 6 GB of RAM available.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PCF Dev：这个Pivotal平台的实例可以在单个虚拟机上本地运行。它专为实验和开发需求而设计。它并不提供所有可能的功能和服务。例如，只有一些内置服务，如Redis、MySQL和RabbitMQ。然而，PCF
    Dev也支持Spring Cloud Services（SCS），以及PCF完整版本支持的所有语言。值得注意的是，如果您想在本地运行带有SCS的PCF Dev，您需要超过6GB的可用RAM。
- en: '**Pivotal Web Services**: This is a cloud-native platform available online
    at  [https://run.pivotal.io/](https://run.pivotal.io/).  It''s like Pivotal Cloud
    Foundry with hosted, pay-by-the-hour pricing. It does not offer all the features
    and services available in Pivotal Cloud Foundry. For example, we may only enable
    services offered by SaaS partners of Pivotal. Pivotal Web Services is best suited
    for startups or individual teams. We will use this model of Pivotal platform hosting
    for presentation purposes in upcoming sections of this chapter.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pivotal Web Services：这是一个云原生平台，可以在线访问[https://run.pivotal.io/](https://run.pivotal.io/)。它类似于Pivotal
    Cloud Foundry，采用按小时计费的托管方式。它并不提供Pivotal Cloud Foundry中所有的功能和服务。例如，我们可能只能启用Pivotal的SaaS合作伙伴提供的服务。Pivotal
    Web Services最适合初创公司或个人团队。我们将在本章的后续部分中使用这种Pivotal平台托管模式进行演示。
- en: '**Pivotal Cloud Foundry**: This is a full-featured cloud-native platform that
    runs on any major public IaaS, including AWS, Azure, and Google Cloud Platform,
    or on a private cloud based on OpenStack or VMware vSphere. It''s a commercial
    solution for large enterprise environments.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pivotal Cloud Foundry：这是一个功能齐全的云原生平台，可以在任何主要的公共IaaS上运行，包括AWS、Azure和Google Cloud
    Platform，或者在基于OpenStack或VMware vSphere的私有云上运行。这是一个针对大型企业环境的商业解决方案。
- en: Preparing the application
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备应用程序
- en: 'Since Pivotal Web Services has native support for Spring Cloud applications,
    the deployment process is very straightforward. However, it does require specific
    dependencies and configuration on the application side—especially if your microservices
    have to integrate with built-in services provided by Pivotal platforms such as
    Service Registry, Config Server, or Circuit Breaker. Besides standard dependency
    management for Spring Cloud, we should also include `spring-cloud-services-dependencies`
    in `pom.xml` with the newest version working with the `Edgware.SR2` release train,
    shown as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Pivotal Web Services原生支持Spring Cloud应用程序，部署过程非常简单。但是，它确实需要应用程序端的特定依赖和配置，特别是如果您的微服务需要与Pivotal平台提供的内置服务集成，如服务注册表、配置服务器或断路器。除了Spring
    Cloud的标准依赖管理外，我们还应该在`pom.xml`中包含`spring-cloud-services-dependencies`，与`Edgware.SR2`版本一起使用，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Depending on the chosen services for integration you may want to include the
    following artifacts in your project. We decided to use all of the Spring Cloud
    features provided by the Pivotal platform, so our microservices fetch properties
    for a configuration server, register themselves in Eureka, and wrap inter-service
    communication with Hystrix commands. Here are the dependencies required for enabling
    discovery client, config client, and circuit breaker for an application deployed
    on the Pivotal platform:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据所选择的集成服务，您可能希望在项目中包含以下工件。我们决定使用Pivotal平台提供的所有Spring Cloud功能，因此我们的微服务会从配置服务器获取属性，在Eureka中注册自己，并使用Hystrix命令封装服务间通信。以下是在Pivotal平台部署的应用程序中启用发现客户端、配置客户端和断路器所需的依赖项：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will provide one more integration for our sample microservices. All of them
    will store data in MongoDB, which is also available as a service on the Pivotal
    platform. To achieve it, we should first include starter `spring-boot-starter-data-mongodb`
    in the project dependencies:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的示例微服务提供更多的集成。它们都将使用MongoDB存储数据，MongoDB也作为Pivotal平台上的一个服务可用。为了实现这一点，我们应该首先在项目依赖项中包含starter
    `spring-boot-starter-data-mongodb`：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A MongoDB address should be provided in configuration settings using the `spring.data.mongodb.uri`
    property. In order to allow an application to connect with MongoDB, we have to
    create a Pivotal''s service mLab and then bind it to the application. By default,
    metadata related to the bound services are exposed to the application as the environment
    variable `$VCAP_SERVICES`. The main motivation for such an approach is that Cloud
    Foundry has been designed to be a polyglot, meaning that any language and platform
    can be supported as a buildpack. All Cloud Foundry properties may be injected
    using the `vcap` prefix. If you would like to access Pivotal''s service, you should
    use the `vcap.services` prefix and then pass the service''s name shown as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在配置设置中提供MongoDB地址，使用`spring.data.mongodb.uri`属性。为了允许应用程序连接MongoDB，我们必须创建一个Pivotal的mLab服务，然后将其绑定到应用程序上。默认情况下，与绑定服务相关的元数据会作为环境变量`$VCAP_SERVICES`暴露给应用程序。这种方法的主要动机是，Cloud
    Foundry被设计为多语言的，意味着任何语言和平台都可以作为构建包支持。所有Cloud Foundry属性都可以使用`vcap`前缀注入。如果您想访问Pivotal的服务，您应该使用`vcap.services`前缀，然后按照以下所示传递服务的名称：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In fact, this is all that needs to be done on the application side to make
    them work properly with the components created on the Pivotal platform. Now we
    just have to enable Spring Cloud features in the same way as we did for a standard
    microservice written in Spring, as shown in the following example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就是应用程序端需要做的一切，以使它们能够与在Pivotal平台上创建的组件正常工作。现在我们只需要以与标准Spring编写的微服务相同的方式启用Spring
    Cloud功能，如下例所示：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Deploying the application
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: Applications can be managed on the **Pivotal Web Service** (**PWS**) platform
    in three different ways. The first is through a web console available at [https://console.run.pivotal.io](https://console.run.pivotal.io).
    We may monitor, scale, restart deployed applications, enable and disable services,
    define new quotas, and change account settings in this way. However, it is not
    possible to do this using a web console—in other words, an initial application
    deployment. It may be performed using a **CLI** (**command-line interface**).
    You can download the required installer from the [pivotal.io](https://pivotal.io) website.
    After installation, you should be able to invoke the Cloud Foundry CLI on your
    machine by typing `cf`, for example, `cf help`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以以三种不同的方式在**Pivotal Web Service**（**PWS**）平台上进行管理。第一种是通过[https://console.run.pivotal.io](https://console.run.pivotal.io)上可用的Web控制台。我们可以通过这种方式监视、扩展、重新启动部署的应用程序，启用和禁用服务，定义新的配额，并更改帐户设置。但是，无法使用Web控制台进行初始应用程序部署。可以使用**CLI**（**命令行界面**）来执行。您可以从[pivotal.io](https://pivotal.io)网站下载所需的安装程序。安装后，您应该能够通过在您的计算机上键入`cf`来调用Cloud
    Foundry CLI，例如`cf help`。
- en: Using CLI
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CLI
- en: 'CLI provides a set of commands that allows you to manage your applications,
    brokered services, spaces, domains, and other components on Cloud Foundry. Let
    me show you the most important commands you should know to be able to run your
    application on PWS:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: CLI提供了一组命令，允许您在Cloud Foundry上管理应用程序、经纪服务、空间、域和其他组件。让我向您展示一些最重要的命令，以便能够在PWS上运行您的应用程序：
- en: 'In order to deploy the application, you must first navigate to its directory.
    You should then sign in to PWS using the `cf login` command as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了部署应用程序，您必须首先导航到其目录。然后，您应该使用`cf login`命令登录PWS，如下所示：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next step is to push the application to PWS with the `cf push` command,
    passing the service''s name:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是使用`cf push`命令将应用程序推送到PWS，传递服务的名称：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Alternatively, you can provide `manifest.yml` in the application''s root directory
    with all the required deployment settings. In that case, all you need is to run
    the `cf push` command without any additional parameters, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以在应用程序的根目录中提供`manifest.yml`，其中包含所有所需的部署设置。在这种情况下，您只需要运行`cf push`命令，而无需任何其他参数，如下所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Deployment with the configuration settings provided in `manifest.yml` as shown
    in the preceding example will fail. To see why, run the command `cf logs`. The
    reason is an insufficient memory limit for heap:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`manifest.yml`中提供的配置设置进行部署，如前面的示例所示，将失败。要查看原因，请运行命令`cf logs`。原因是堆的内存限制不足。
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By default, the platform allocates 240 MB for the code cache, 140 MB for metaspace,
    and 1 MB for every thread, with an assumption that there is a maximum of 200 threads
    for the Tomcat connector. It is easy to calculate that, with these settings, every
    application needs around 650 MB of allocated memory. We may change these settings
    by calling the `cf set-env` command and passing the `JAVA_OPTS` parameter, as
    you can see in the following sample. Such a memory limit would not be enough in
    production mode but would be okay for testing purposes. To ensure that these changes
    take affect, use the `cf restage` command as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，平台为代码缓存分配240MB，为元空间分配140MB，并为每个线程分配1MB，假设Tomcat连接器的最大线程数为200。很容易计算出，使用这些设置，每个应用程序需要大约650MB的分配内存。我们可以通过调用`cf
    set-env`命令并传递`JAVA_OPTS`参数来更改这些设置，如下面的示例所示。这样的内存限制在生产模式下是不够的，但对于测试目的来说是可以的。为了确保这些更改生效，请使用`cf
    restage`命令，如下所示：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Allocated memory is important, especially if there is only 2 GB RAM available
    for a free account. With the default memory settings applied, we can only deploy
    two applications on the Pivotal platform, as each of them takes up 1 GB of RAM.
    Although we have fixed the problems described previously, our application still
    does not work properly.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 分配的内存很重要，特别是对于免费帐户只有2GB RAM可用的情况。使用默认内存设置，我们只能在Pivotal平台上部署两个应用程序，因为每个应用程序占用1GB的RAM。尽管我们已经解决了之前描述的问题，但我们的应用程序仍然无法正常工作。
- en: Binding to services
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定到服务
- en: 'During boot, the applications were not able to connect with the required services.
    The problem occurs because services are not bound by default to the applications.
    You can display all of the services created in your space by running the command
    `cf services`, and bind each of them to a given microservice by invoking the command
    `cf bind-service`. In the following example command''s executions, we have bound
    Eureka, configuration server, and MongoDB to `account-service`. Finally, we can
    run `cf restage` once more and everything should work fine, shown as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动期间，应用程序无法连接所需的服务。问题出在服务默认情况下未绑定到应用程序。您可以通过运行命令`cf services`来显示在您的空间中创建的所有服务，并通过调用命令`cf
    bind-service`将每个服务绑定到给定的微服务。在以下示例命令的执行中，我们已经将Eureka、配置服务器和MongoDB绑定到`account-service`。最后，我们可以再次运行`cf
    restage`，一切应该正常工作，如下所示：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using the Maven plugin
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven插件
- en: As we have mentioned before, CLI and the web console are not the only ways to
    manage your application on the Pivotal platform. The Cloud Foundry team has implemented
    the Maven plugin in order to facilitate and speed up application deployment. What's
    interesting is that the same plugin can be used to manage pushes and updates to
    any Cloud Foundry instance, not only those provided by Pivotal.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，CLI和Web控制台并不是在Pivotal平台上管理应用程序的唯一方式。Cloud Foundry团队已经实现了Maven插件，以便简化和加快应用程序的部署。有趣的是，同一个插件可以用来管理对任何Cloud
    Foundry实例的推送和更新，而不仅仅是Pivotal提供的实例。
- en: 'When using Cloud Foundry''s Maven plugin you can easily integrate cloud deployments
    into their Maven projects'' life cycles. This allows you to push, remove, and
    update projects in Cloud Foundry. If you would like to push your project together
    with Maven, just run the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cloud Foundry的Maven插件，您可以轻松地将云部署集成到其Maven项目的生命周期中。这使您可以在Cloud Foundry中推送、删除和更新项目。如果您想要与Maven一起推送您的项目，只需运行以下命令：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Generally, the commands provided by the Maven plugin are pretty similar to
    the commands offered by CLI. For example, you can display a list of applications
    by executing the command `mvn cf:apps`. In order to delete an application, run
    the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，Maven插件提供的命令与CLI提供的命令非常相似。例如，通过执行命令`mvn cf:apps`可以显示应用程序列表。为了删除一个应用程序，运行以下命令：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you would like to upload some changes to the existing application, use the `cf:update`
    command as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要上传一些更改到现有的应用程序，可以使用`cf:update`命令，如下所示：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Before running any commands, we have to configure the plugin properly. First,
    it is required to pass Cloud Foundry login credentials. It is recommended to store
    them separately in Maven''s `settings.xml`. A typical entry inside a server tag
    might look like the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行任何命令之前，我们必须正确配置插件。首先，需要传递Cloud Foundry登录凭据。建议将它们单独存储在Maven的`settings.xml`中。服务器标签内的典型条目可能如下所示：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Using the Maven plugin instead of CLI commands has one important advantage:
    you can configure all the necessary configuration settings in one place and can
    apply them using a single command during application build. The full configuration
    of the plugin is shown in the following snippet. Besides some basic settings including
    space, memory, and a number of instances, it''s also possible to change memory
    limits with the `JAVA_OPTS` environment variable and by binding the required services
    to the application. After running the `cf:push` command, `product-service` is
    ready to use at the address `https://product-service-piomin.cfapps.io/`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Maven插件而不是CLI命令有一个重要的优势：您可以在一个地方配置所有必要的配置设置，并在应用程序构建期间使用单个命令应用它们。插件的完整配置如下所示。除了一些基本设置，包括空间、内存和实例数量，还可以使用`JAVA_OPTS`环境变量更改内存限制，并通过将所需服务绑定到应用程序来更改内存限制。运行`cf:push`命令后，`product-service`已准备在地址`https://product-service-piomin.cfapps.io/`上使用：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Maintenance
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护
- en: Assuming all of the applications forming our example microservices-based system
    have been successfully deployed, we can easily manage and monitor them using the
    Pivotal Web Services dashboard, or even just CLI commands. The free trial provided
    by the Pivotal platform gives us a lot of possibilities and tools for maintaining
    applications, so let's discover some of its most interesting features.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们示例微服务系统中的所有应用程序都已成功部署，我们可以使用Pivotal Web Services仪表板轻松管理和监控它们，甚至只需使用CLI命令。Pivotal平台提供的免费试用版为我们提供了许多维护应用程序的可能性和工具，让我们发现一些最有趣的功能。
- en: Accessing deployment details
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问部署详情
- en: 'We can list all of the deployed applications by running the command `cf apps`
    or by navigating to the main site of our space in the web console. You can see
    that list in the following screenshot. Each row of the table represents a single
    application. Besides its name, there is also information about its status, the
    number of instances, allocated memory, deployment time, and a URL at which a service
    is available outside the platform. If you didn''t specify a URL address during
    application deployment, it is automatically generated:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行命令`cf apps`或导航到Web控制台中我们空间的主站点来列出所有已部署的应用程序。您可以在下面的屏幕截图中看到该列表。表的每一行代表一个单独的应用程序。除了它的名称，还有关于它的状态、实例数量、分配的内存、部署时间以及服务在平台外部可用的URL的信息。如果在应用程序部署期间没有指定URL地址，它将自动生成：
- en: '![](img/d7008b6a-1a4a-48f7-ae30-e023ba2cdea5.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d7008b6a-1a4a-48f7-ae30-e023ba2cdea5.png)'
- en: 'You can click each row in order to discover details about the application.
    Similar information can be accessed using the CLI commands `cf app <app-name> `or  `cf
    app order-service`. The following screenshot shows the main panel of an application''s
    detailed view that contains the history of events, summary, as well as memory,
    disk, and CPU usage of every instance. In this panel, you may scale an application
    by clicking the Scale button. There are also several other tabs available. By
    switching to one of them, you can check out all bounded services (Services), external
    URLs assigned (Rules), display logs (Logs), and incoming requests history (Trace):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以单击每一行以发现有关应用程序的详细信息。使用CLI命令`cf app <app-name>`或`cf app order-service`也可以访问类似的信息。下面的屏幕截图显示了应用程序详细视图的主面板，其中包含事件历史、摘要以及每个实例的内存、磁盘和CPU使用情况。在此面板中，您可以通过单击“缩放”按钮来扩展应用程序。还有其他几个选项卡可用。切换到其中一个，您可以查看所有绑定的服务（服务）、分配的外部URL（规则）、显示日志（日志）和传入请求历史（跟踪）：
- en: '![](img/c7138419-e97b-4074-ba2a-8d63462ee396.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7138419-e97b-4074-ba2a-8d63462ee396.png)'
- en: 'Of course, you can always use the CLI to collect the same details as shown
    in the previous example. If you execute the command `cf logs <app-name>`, you
    would be attached to `stdout` , which is generated by the application. You can
    also display the list of activated Pivotal managed services with the list of bound
    applications, as shown in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以使用CLI收集与前面示例中显示的相同的详细信息。如果执行命令`cf logs <app-name>`，您将附加到应用程序生成的`stdout`。您还可以显示已激活的Pivotal托管服务列表和绑定应用程序列表，如下面的屏幕截图所示：
- en: '![](img/49fb545e-aaf7-4097-ac10-3b696d072ac7.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/49fb545e-aaf7-4097-ac10-3b696d072ac7.png)'
- en: Managing application life cycles
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理应用程序生命周期
- en: 'Another really helpful feature provided by Pivotal Web Services is the ability
    to manage an application''s life cycle. In other words, we can easily stop, start,
    and restart an application with just one click. Before executing the requested
    command, you will be prompted for confirmation, as shown in the following screenshot:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Pivotal Web Services提供的另一个非常有用的功能是管理应用程序的生命周期。换句话说，我们可以轻松地停止、启动和重新启动一个应用程序，只需点击一下。在执行请求的命令之前，将提示您进行确认，如下面的屏幕截图所示：
- en: '![](img/39623686-56f6-4fc7-896d-fdea0b62651c.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39623686-56f6-4fc7-896d-fdea0b62651c.png)'
- en: 'The same result can be achieved by running one of the following CLI commands:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下CLI命令之一也可以实现相同的结果：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Scaling
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: 'One of the most important reasons for using cloud solutions is the ability
    to scale your applications easily. The Pivotal platform deals with these issues
    in a very intuitive way. Firstly, you may decide how many instances of an application
    are started at each stage of deployment. For example, if you decided to use `manifest.yml`
    and deploy it with the `cf push` command, the number of created instances will
    be determined by field instances, as shown in the following code snippet:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云解决方案的一个最重要的原因是能够轻松扩展您的应用程序。Pivotal平台以一种非常直观的方式处理这些问题。首先，您可以决定在部署的每个阶段启动应用程序的实例数量。例如，如果您决定使用`manifest.yml`并使用`cf
    push`命令部署它，创建的实例数量将由字段实例确定，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The number of running instances, as well as memory and CPU limits, can be modified
    on the started application. In fact, there are two available approaches to scaling.
    You can either manually set how many instances should be launched or enable autoscaling,
    where you only need to define a criteria based on a selected metric''s thresholds.
    Autoscaling on the Pivotal platform is realized by a tool called **PCF App Autoscaler**.
    We can choose from the following five available rules, and they are as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行实例的数量，以及内存和CPU限制，可以在启动的应用程序上进行修改。实际上，有两种可用的扩展方法。您可以手动设置要启动多少个实例，或者启用自动缩放，只需要根据所选指标的阈值定义一个标准。Pivotal平台上的自动缩放是由一个名为**PCF
    App Autoscaler**的工具实现的。我们可以从以下五个可用规则中选择，它们如下：
- en: CPU utilization
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU利用率
- en: Memory utilization
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存利用率
- en: HTTP latency
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP延迟
- en: HTTP throughput
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP吞吐量
- en: RabbitMQ depth
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ深度
- en: 'You can define more than one active rule. Each of these rules has a minimum
    value per every single metric for scaling down and a maximum value for scaling
    up. Autoscale settings for `customer-service` are shown in the following screenshot.
    Here, we decided to apply HTTP throughput and HTTP latency rules. If latency for
    99% of traffic is lower than `20` ms, one instance of an application should be
    disabled in case there is more than one instance. Analogously, if a latency is
    greater than `200` ms, the platform should attach one more instance:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义多个活动规则。每个规则对于缩小的每个度量标准都有一个最小值，对于扩大则有一个最大值。`customer-service`的自动缩放设置如下所示。在这里，我们决定应用HTTP吞吐量和HTTP延迟规则。如果99%的流量的延迟低于`20`毫秒，那么如果有多个实例，则应禁用一个应用程序实例。类似地，如果延迟大于`200`毫秒，则平台应该附加一个实例：
- en: '![](img/f2434974-9f83-409d-a93e-9c1aec8cc445.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2434974-9f83-409d-a93e-9c1aec8cc445.png)'
- en: 'We can also control the number of running instances manually. Autoscaling has
    many advantages but a manual approach gives you more control over that process.
    Thanks to limited memory for each application, there is still space for other
    instances. The most overloaded application in our example system is `account-service`,
    because it is called during an order''s creation as well as order''s confirmation.
    So, let''s add one more instance of that microservice. To do so, go to the `account-service`
    details panel and click on Scale under Processes and Instances. You should then
    increase the number of instances and apply the necessary changes; you should then
    see two instances of `account-service` available, as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以手动控制运行实例的数量。自动缩放有很多优点，但手动方法可以让您更好地控制这个过程。由于每个应用程序的内存有限，仍然有空间可以用于其他实例。在我们的示例系统中，最负载的应用程序是`account-service`，因为它在订单创建和订单确认时被调用。因此，让我们再添加一个`account-service`微服务的实例。要这样做，转到`account-service`的详细信息面板，然后在进程和实例下点击“Scale”。然后增加实例数量并应用必要的更改；然后您应该看到两个`account-service`的实例可用，如下面的屏幕截图所示：
- en: '![](img/869909e6-33a2-4151-84d1-ecfae35dad37.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/869909e6-33a2-4151-84d1-ecfae35dad37.png)'
- en: Provisioning brokered services
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供经纪服务
- en: We have already looked at how to bind an application to a service using the `cf
    bind-service` command and the Maven plugin. However, we should now look at how
    to enable and configure our service. You can easily display a list of all the
    available services and then enable them using Pivotal's dashboard; this can be
    found under Marketplace.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过如何使用`cf bind-service`命令和Maven插件将应用程序绑定到服务。然而，现在我们应该看看如何启用和配置我们的服务。您可以轻松地显示所有可用服务的列表，然后使用Pivotal的仪表板启用它们；这可以在“Marketplace”下找到。
- en: 'The provisioning of a brokered service with Pivotal Web Services is very easy.
    After installation, some services are already available to use without any additional
    configuration. All we have to do is to bind them to selected applications and
    properly pass their network addresses in the application''s settings. Every application
    can be easily bound to a service using the UI dashboard. First, navigate to the
    main page of the service. There, you will see a list of the currently bound applications.
    You can bind a new application to the service by clicking BIND APP and then choosing
    one from the list displayed, as shown in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Pivotal Web Services提供经纪服务非常容易。安装后，一些服务已经可以在没有任何额外配置的情况下使用。我们所要做的就是将它们绑定到选定的应用程序，并在应用程序的设置中正确传递它们的网络地址。每个应用程序都可以使用UI仪表板轻松地绑定到一个服务。首先，导航到服务的主页。在那里，您将看到当前绑定的应用程序列表。您可以通过单击BIND
    APP然后从显示的列表中选择一个来将新的应用程序绑定到服务，如下面的屏幕截图所示：
- en: '![](img/035ead31-9dd9-40a4-9da5-ba408e11c627.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/035ead31-9dd9-40a4-9da5-ba408e11c627.png)'
- en: 'You don''t have to do anything more than enable the registry service in the
    marketplace and bind it to the application in order to enable the discovery feature
    on Pivotal Web Services. Of course, you can override some configuration settings
    on the client-side if needed. A full list of registered applications can be displayed
    in the Eureka dashboard under Manage in the main configuration panel of the service.
    There are two running instances of `account-service` because we scaled it up in
    the previous section; the other microservices however have only one running instance,
    shown as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需在市场中启用注册表服务并将其绑定到应用程序，即可在Pivotal Web Services上启用发现功能。当然，如果需要，您可以在客户端覆盖一些配置设置。在服务的主配置面板中的“管理”下，可以在Eureka仪表板中显示所有已注册的应用程序的完整列表。`account-service`有两个运行实例，因为我们在上一节中对其进行了扩展；然而，其他微服务只有一个运行实例，如下所示：
- en: '![](img/ef76969f-c91d-408d-806f-f8a65b90e841.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ef76969f-c91d-408d-806f-f8a65b90e841.png)'
- en: 'In contrast to a discovery service, a configuration server needs to include
    additional settings. As before, you should navigate to its main panel and then
    select Manage. Here, you will be redirected to the configuration form. The configuration
    parameters have to be provided there as a JSON object. The `count` parameter specifies
    the number of nodes needed for provision, upgrade options if an instance can be
    upgraded, and `force` forces that upgrade even if the instance is already the
    latest available version. Other configuration parameters are dependent on a type
    of backend used to store property sources. As you may remember from [Chapter 5](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml), *Distributed
    Configuration with Spring Cloud Config*, the most popular solution for Spring
    Cloud Config Server is based on the Git repository. We have created an example
    repository on GitHub, where all the required sources have been committed. The
    following are the parameters in a JSON format that should be provided for a Config
    Server on Pivotal Web Services:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与发现服务相反，配置服务器需要包括额外的设置。与以前一样，您应该导航到其主面板，然后选择“管理”。在这里，您将被重定向到配置表单。配置参数必须以JSON对象的形式提供。`count`参数指定所需的节点数量，升级选项如果实例可以升级，`force`强制即使实例已经是最新可用版本也要升级。其他配置参数取决于用于存储属性源的后端类型。正如您可能记得的来自[第5章](37142825-02d0-48a0-99df-1a1a88a1bbd4.xhtml)，*使用Spring
    Cloud Config进行分布式配置*，Spring Cloud Config Server的最受欢迎的解决方案基于Git存储库。我们在GitHub上创建了一个示例存储库，其中已提交了所有所需的源。以下是应为Pivotal
    Web Services上的Config Server提供的JSON格式的参数：
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The last brokered service used by the example application provided hosted an
    instance of MongoDB. After navigating to Manage on the main panel of that service,
    you should be redirected to [https://mlab.com/home](https://mlab.com/home) , where
    you will be able to use the database's node.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序使用的最后一个经纪服务托管了一个MongoDB实例。在该服务的主面板上导航到“管理”，您将被重定向到[https://mlab.com/home](https://mlab.com/home)，在那里您将能够使用数据库的节点。
- en: The Heroku platform
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Heroku平台
- en: Heroku is one of the oldest cloud platforms created using the **PaaS** (**Platform
    as a Service**) model. In comparison to Pivotal Cloud Foundry, Heroku doesn't
    have built-in support for Spring Cloud applications. It complicates our model
    a little because we can't use a platform's services to enable typical microservices
    components, including service discovery, a configuration server, or a circuit
    breaker. In spite of this, Heroku contains some really interesting features that
    are not provided by Pivotal Web Services.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku是使用**PaaS**（**平台即服务**）模型创建的最古老的云平台之一。与Pivotal Cloud Foundry相比，Heroku没有内置对Spring
    Cloud应用程序的支持。这使我们的模型变得有些复杂，因为我们无法使用平台的服务来启用典型的微服务组件，包括服务发现、配置服务器或断路器。尽管如此，Heroku包含一些Pivotal
    Web Services未提供的非常有趣的功能。
- en: Deployment methods
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署方法
- en: We can manage our application using the CLI, web console or a dedicated Maven
    plugin. Deploying Heroku is pretty similar to deploying the Pivotal platform,
    however, the methods are slightly different. The main approach assumes that you
    deploy the application by building it from the source code stored in your local
    Git repository or on GitHub. The build is executed by the Heroku platform automatically
    after you have pushed some changes in a branch to a repository, or on demand from
    the newest version of the code in the selected branch. Another interesting way
    to deploy an application is by pushing your Docker image to Heroku's container
    registry.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用CLI、Web控制台或专用的Maven插件来管理我们的应用程序。部署Heroku与部署Pivotal平台非常相似，但方法略有不同。主要方法假定您通过从本地Git存储库或GitHub中存储的源代码构建应用程序来部署应用程序。在您将一些更改推送到存储库的分支上后，Heroku平台会自动执行构建，或者根据所选分支中的最新代码版本按需执行构建。另一种有趣的部署应用程序的方法是将Docker镜像推送到Heroku的容器注册表。
- en: Using the CLI
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CLI
- en: 'You can begin by installing **Heroku Command Line Interface** (**CLI**) available
    at [https://cli-assets.heroku.com/heroku-cli/channels/stable/heroku-cli-x64.exe](https://cli-assets.heroku.com/heroku-cli/channels/stable/heroku-cli-x64.exe) (for
    Windows). In order to deploy and run your application on Heroku using CLI you
    have to perform the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://cli-assets.heroku.com/heroku-cli/channels/stable/heroku-cli-x64.exe](https://cli-assets.heroku.com/heroku-cli/channels/stable/heroku-cli-x64.exe)（Windows）安装**Heroku命令行界面**（**CLI**）。要使用CLI在Heroku上部署和运行应用程序，您必须执行以下步骤：
- en: 'After installation, you can use the command `Heroku` from your shell. First,
    log in to Heroku using your credentials, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装后，您可以在shell中使用`Heroku`命令。首先，使用您的凭据登录Heroku，如下所示：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, navigate to the application''s `root` directory and create an application
    on Heroku. After running the following command, not only will the application
    be created, but a Git remote called `heroku` will as well. This is associated
    with your local Git repository, shown as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，导航到应用程序的`root`目录并在Heroku上创建一个应用程序。运行以下命令后，不仅将创建应用程序，还将创建一个名为`heroku`的Git远程。这与您的本地Git存储库相关联，如下所示：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now you can deploy your application by pushing the code to Heroku''s Git remote.
    Heroku will then do all the work for you, as follows:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以通过将代码推送到Heroku的Git远程来部署您的应用程序。然后，Heroku将为您完成所有工作，如下所示：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the application is started successfully, you will be able to manage it using
    some basic commands. In accordance with the order presented as follows, you can
    display logs, change the number of running dynos (in other words, scale the application),
    assign new add-ons, and list all of the enabled add-ons:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序成功启动，您将能够使用一些基本命令来管理它。根据以下顺序，您可以显示日志，更改运行的dynos数量（换句话说，扩展应用程序），分配新的附加组件，并列出所有已启用的附加组件：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Connecting to the GitHub repository
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到GitHub存储库
- en: 'Personally, I prefer to deploy my applications to Heroku by connecting to the
    projects using the GitHub repository. There are two possible approaches related
    to this deployment method: manual and automatic. You can choose either by navigating
    to the **Deploy** tab on the application''s details panel and then connect it
    to the specified GitHub repository, as you can see in the following screenshot.
    If you click the Deploy Branch button, the building of and the deployment to Heroku
    would immediately start on the given Git branch. Alternatively, you can also enable
    automatic deploys on the chosen branch by clicking **Enable Automatic Deploys**.
    Additionally, you can configure Heroku to wait for a Continuous Integration build
    result if it is enabled for your GitHub repository; this is a really helpful feature
    because it allows you to run automated tests on your project and ensure they have
    passed before it is pushed:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我更喜欢通过连接到GitHub存储库来部署我的应用程序到Heroku。与此部署方法相关的有两种可能的方法：手动和自动。您可以通过导航到应用程序详细信息面板上的**部署**选项卡，然后将其连接到指定的GitHub存储库来选择其中一种，如下屏幕截图所示。如果单击**部署分支**按钮，则将立即开始在给定的Git分支上构建和部署到Heroku。或者，您还可以通过单击**启用自动部署**在所选分支上启用自动部署。此外，如果为您的GitHub存储库启用了持续集成构建结果，您还可以配置Heroku等待持续集成构建结果；这是一个非常有用的功能，因为它允许您在推送之前对项目运行自动化测试并确保它们已通过：
- en: '![](img/af757b79-ef60-441e-8b89-735019c51cf2.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af757b79-ef60-441e-8b89-735019c51cf2.png)'
- en: Docker Container Registry
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker容器注册表
- en: 'Following the newest trends, Heroku allows you to deploy a containerized application
    using Docker. In order to be able to do that, you should have Docker and the Heroku
    CLI installed on your local machine:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循最新的趋势，Heroku允许您使用Docker部署容器化应用程序。为了能够做到这一点，您应该在本地机器上安装Docker和Heroku CLI：
- en: 'First, log in to Heroku Cloud by running the command `heroku login`. The next
    step is to log in to the Container Registry:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过运行命令`heroku login`登录Heroku Cloud。下一步是登录到容器注册表：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, make sure that your current directory contains `Dockerfile`. If present,
    you can proceed to building and pushing the image to Heroku''s Container Registry
    by executing the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，请确保您的当前目录包含`Dockerfile`。如果存在，您可以执行以下命令构建并将图像推送到Heroku的容器注册表：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you have an existing built image, you may only be interested in tagging
    and pushing it to Heroku. In order to do that, you need to use Docker''s command
    line by executing the following commands (assuming your application''s name is `piomin-order-service`):'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您有一个现有的构建图像，您可能只对标记和推送到Heroku感兴趣。为了做到这一点，您需要使用Docker的命令行，执行以下命令（假设您的应用程序名称是`piomin-order-service`）：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After the image has been successfully pushed, the new application should be
    visible in the Heroku dashboard.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图像成功推送后，新应用程序应该在Heroku仪表板上可见。
- en: Preparing an application
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备应用程序
- en: 'When deploying an application based on Spring Cloud components to Heroku, we
    no longer have to perform any extra changes in its source code or add any additional
    libraries, which we do when running it locally. The only difference here is in
    the configuration settings, where we should set an address in order to integrate
    the application with service discovery, databases, or any other add-on that can
    be enabled for your microservice. The current example, which is the same as the
    examples provided for Pivotal''s deployment, is to store data in MongoDB that
    is assigned to the application as an mLab service. Additionally, here, each client
    registers itself on the Eureka server, which is deployed as `piomin-discovery-service`.
    The following screenshot displays a list of the applications deployed on Heroku
    for our examples:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当将基于Spring Cloud组件的应用程序部署到Heroku时，我们不再需要在其源代码中执行任何额外更改或添加任何额外的库，这是我们在本地运行时所做的。唯一的区别在于配置设置，我们应该在其中设置一个地址，以便将应用程序与服务发现、数据库或任何其他可以为您的微服务启用的附加组件集成。当前示例与Pivotal部署提供的示例相同，是将数据存储在分配给应用程序的MongoDB中，作为mLab服务。此外，在这里，每个客户端都在部署为`piomin-discovery-service`的Eureka服务器上注册自己。以下屏幕截图显示了我们示例在Heroku上部署的应用程序列表：
- en: '![](img/1493f39a-d047-4aea-82b9-a8f65138f866.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1493f39a-d047-4aea-82b9-a8f65138f866.png)'
- en: I deployed the previous applications on Heroku by connecting them with the GitHub
    repository. This, in turn, requires you to create a separate repository per microservice.
    For example, the repository of `order-service` is available at [https://github.com/piomin/sample-heroku-order-service.git;](https://clicktime.symantec.com/a/1/T35T4GHVxyO3_yEnmgYJzEOMwTYVoyfmLx2ONL0JOmM=?d=Em-4WZBG8KjUF8i64GiOj94xj1zxN6a1uB0eVZ0nPiAMBASzKXYmiNLpRNEcgxEQ7bHQ6AzvMbnrWHqhusJvYyZqTNMHlShDuReFC57yByy3O9bujQaWuS_jFkuW-GXlbAc9l9L2CmOU0k0c7iCbz4TP6gxYzTpi3F2ZhiR4yOGU_aIfM0-ImE4VjE3Zwu5hcRLW6fRjQIpA00TbvIfq03qKyXpN4rOeSy-uW8xOD3AifhkEun4HB33yo6UpNlLAVK45YxrUxZn2iT_VdnO336VCgrUe4QGzCEoQEtzN_eTC5eSH0FHDXyXwW0Aj4Px9YTY5asaj9oWluYR6xuKHwLEyHqyAWSKmRhRVXDNsi3pF13hLo94F&u=https%3A%2F%2Fgithub.com%2Fpiomin%2Fsample-heroku-order-service.git)
    other microservices may be at under similar addresses. You can easily fork these
    microservices and deploy them on your Heroku account in order to perform tests.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过将它们与GitHub存储库连接在Heroku上部署了先前的应用程序。这又要求您为每个微服务创建一个单独的存储库。例如，`order-service`的存储库位于https://github.com/piomin/sample-heroku-order-service.git；其他微服务可能位于类似的地址下。您可以轻松地fork这些微服务并部署到您的Heroku帐户以进行测试。
- en: 'Now let''s take a look at the configuration settings provided for one of our
    example applications: `account-service`. First, we have to override the auto-configured
    address of MongoDB using the `MONGODB_URI` environment variable provided by the
    Heroku platform. There is also a necessity to provide the correct address of a
    Eureka server, as well as override the hostname and port sent by a discovery client
    during registration. This is required because, by default, each application will
    try to register using an internal address that is not available for other applications.
    Without overriding these values, inter-service communication with the Feign client
    would be unsuccessful:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下为我们的示例应用程序之一`account-service`提供的配置设置：首先，我们必须使用Heroku平台提供的`MONGODB_URI`环境变量覆盖MongoDB的自动配置地址。还需要提供正确的Eureka服务器地址，并在注册期间覆盖发现客户端发送的主机名和端口。这是必需的，因为默认情况下，每个应用程序都会尝试使用对其他应用程序不可用的内部地址进行注册。如果不覆盖这些值，使用Feign客户端进行的服务间通信将失败。
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Notice that the environment variable `HEROKU_APP_NAME` is the name of the current
    application deployed on Heroku, as seen in the preceding snippet. This is not
    available by default. To enable a variable for your application, for example,
    `customer-service`, run the following command with the experimental add-on `runtime-dyno-metadata`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，环境变量`HEROKU_APP_NAME`是部署在Heroku上的当前应用程序的名称，如前面的片段所示。这不是默认可用的。要为您的应用程序启用变量，例如`customer-service`，请使用实验性附加组件`runtime-dyno-metadata`运行以下命令：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Testing deployments
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试部署
- en: 'After deployment, every application is available at an address made up of its
    name and a platform''s domain name, for example, [http://piomin-order-service.herokuapp.com](http://piomin-order-service.herokuapp.com).
    You are able to call the Eureka dashboard exposes using the URL, [http://piomin-discovery-service.herokuapp.com/](http://piomin-discovery-service.herokuapp.com/),
    which will allow you to check whether our example microservices have been registered.
    If everything worked correctly, you should see something similar to the following
    screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 部署后，每个应用程序都可以通过其名称和平台域名组成的地址进行访问，例如，http://piomin-order-service.herokuapp.com。您可以使用URL调用Eureka仪表板，http://piomin-discovery-service.herokuapp.com/，这将允许您检查我们的示例微服务是否已注册。如果一切正常，您应该看到类似以下截图的内容：
- en: '![](img/bb34151b-5ecb-4d64-a7da-81f5952e4964.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb34151b-5ecb-4d64-a7da-81f5952e4964.png)'
- en: 'Each microservice exposes API documentation automatically generated by Swagger2,
    so you can easily test every endpoint by calling it from the Swagger UI dashboard,
    available on `/swagger-ui.html`; for example, [http://piomin-order-service.herokuapp.com/swagger-ui.html](http://piomin-order-service.herokuapp.com/swagger-ui.html).
    The HTTP API visualization for `order-service` is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都会自动生成Swagger2的API文档，因此您可以通过在/swagger-ui.html上调用Swagger UI仪表板轻松测试每个端点，例如，http://piomin-order-service.herokuapp.com/swagger-ui.html。`order-service`的HTTP
    API可视化如下：
- en: '![](img/60d46f83-d38c-463b-ba49-0b43c99810e9.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60d46f83-d38c-463b-ba49-0b43c99810e9.png)'
- en: 'Each microservice stores data in MongoDB. This database can be enabled for
    your project by adding add-ons provided by Heroku, for example, mLab. As you may
    remember, we have already used an example of the same service for storing data
    in applications deployed on the Pivotal platform. Add-ons can be enabled for an
    application by provisioning it with the selected plan in the Resources tab of
    every application''s details panel. Once done, you can manage every plugin by
    simply clicking on it. For mLab, you will be redirected to the mLab ([mlab.com](https://mlab.com/))
    site, where you are able to see a list of all the collections, users, and generated
    statistics. The following screenshot illustrates the mLab dashboard for our examples:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都将数据存储在MongoDB中。可以通过添加Heroku提供的附加组件（例如mLab）为您的项目启用此数据库。您可能还记得，我们已经在Pivotal平台上部署的应用程序中使用了相同服务的示例来存储数据。可以通过在每个应用程序详细信息面板的“资源”选项卡中为应用程序提供所选计划来启用附加组件。完成后，您可以通过简单点击来管理每个插件。对于mLab，您将被重定向到mLab（mlab.com）网站，在那里您可以查看所有集合、用户和生成的统计信息的列表。以下截图展示了我们示例的mLab仪表板：
- en: '![](img/d791eac0-4a61-4ca2-a7a2-016a446821af.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d791eac0-4a61-4ca2-a7a2-016a446821af.png)'
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have reached the end of our Spring Cloud microservices journey! Our exercises
    began with simple deployments on the local machine, but in the last chapter we
    deployed our microservices in an environment fully-managed by the cloud vendor,
    which also automatically built, started, and exposed HTTP APIs on specified domains.
    I personally think that it is amazing how easily we can run, scale, and expose
    data outside an application using any of the most popular programming languages
    or third-party tools, such as a database or a message broker. In fact, each one
    of us can now implement and launch a production-ready application to the web within
    a few hours without worrying about the software that has to be installed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了Spring Cloud微服务之旅！我们的练习从在本地机器上进行简单部署开始，但在最后一章中，我们将我们的微服务部署在由云供应商完全管理的环境中，该环境还会自动构建、启动并在指定域上公开HTTP
    API。我个人认为，我们可以如此轻松地运行、扩展和在应用程序外部公开数据，使用任何最流行的编程语言或第三方工具，如数据库或消息代理，这是令人惊讶的。事实上，我们每个人现在都可以在几个小时内实现并启动一个适用于生产的Web应用程序，而不必担心必须安装的软件。
- en: This chapter has shown you how easily you can run Spring Cloud microservices
    on different platforms. The given examples illustrate the real power of cloud-native
    applications. No matter whether you launch an application locally on your laptop,
    inside a Docker Container, using Kubernetes, or on an online cloud platform such
    as Heroku or Pivotal Web Services, you don't have to change anything in the application's
    source code; the modifications have to be performed only in its properties. (Assuming
    you use Config Server in your architecture, these changes are not invasive.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示了如何轻松地在不同平台上运行Spring Cloud微服务。给定的示例说明了云原生应用程序的真正力量。无论您是在笔记本电脑上本地启动应用程序，还是在Docker容器内部，使用Kubernetes，或者在Heroku或Pivotal
    Web Services等在线云平台上启动应用程序，您都不需要更改应用程序的源代码；修改只需在其属性中进行。（假设您在架构中使用配置服务器，这些更改不会对系统造成影响。）
- en: In the last two chapters, we looked at some of the most recent trends seen in
    the IT world. Such topics as CI and CD, containerization with Docker, orchestration
    using Kubernetes, and cloud platforms are increasingly used by many organizations.
    In fact, these solutions are partly responsible for the increasing popularity
    of microservices. Currently, there is one leader in this area of programming—Spring
    Cloud. There is no other Java framework with as many features, or that can implement
    so many patterns related to microservices, as Spring Cloud. I hope this book will
    help you to use this framework effectively when building and honing your microservice-based
    enterprise system.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两章中，我们看到了IT世界中一些最新的趋势。诸如CI和CD、Docker容器化、Kubernetes编排和云平台等主题正被许多组织越来越多地使用。事实上，这些解决方案在一定程度上促成了微服务的日益流行。目前，在这个编程领域有一个领导者——Spring
    Cloud。没有其他Java框架具有如此多的功能，也没有其他框架能够实现与微服务相关的如此多的模式，如Spring Cloud。我希望这本书能帮助您在构建和完善基于微服务的企业系统时有效地使用这个框架。
