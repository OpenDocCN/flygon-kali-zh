- en: Developing Reactive Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发响应式微服务
- en: In this chapter, we will learn how to develop reactive microservices, that is,
    how to develop non-blocking synchronous REST APIs and asynchronous event-driven
    services using Spring. We will also learn about how to choose between these two
    alternatives. Finally, we will see how to create and run manual and automated
    tests of a reactive microservice landscape.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何开发响应式微服务，即如何使用Spring开发非阻塞同步REST API和异步事件驱动服务。我们还将学习如何在这两种选择之间进行选择。最后，我们将看到如何创建和运行响应式微服务景观的手动和自动化测试。
- en: As already described in the *Reactive microservices* section in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml),
    *Introduction to Microservices*, the foundations for reactive systems is that
    they are message-driven—they use asynchronous communication. This enables them
    to be elastic, that is, scalable and resilient, meaning that they will be tolerant
    to failures. Elasticity and resilience together will enable a reactive system
    to be responsive; they will be able to respond in a timely fashion.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)中*微服务*部分所述，响应式系统的基础是它们是消息驱动的
    - 它们使用异步通信。这使它们能够是弹性的，即可伸缩和具有韧性，意味着它们将容忍故障。弹性和韧性将使响应式系统能够做出响应；它们将能够及时做出响应。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Choosing between non-blocking synchronous APIs and event-driven asynchronous
    services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非阻塞同步API和事件驱动的异步服务之间进行选择
- en: Developing non-blocking synchronous REST APIs using Spring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring开发非阻塞同步REST API
- en: Developing event-driven asynchronous services
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发事件驱动的异步服务
- en: Running manual tests of the reactive microservice landscape
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行响应式微服务景观的手动测试
- en: Running automated tests of the reactive microservice landscape
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行响应式微服务景观的自动化测试
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the commands described in this book are run on a MacBook Pro using macOS
    Mojave but should be straightforward to modify so that they can run on another
    platform such as Linux or Windows.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都在使用macOS Mojave的MacBook Pro上运行，但应该很容易修改，以便它们可以在其他平台（如Linux或Windows）上运行。
- en: No new tools need to be installed in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章无需安装新工具。
- en: The source code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter07).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter07](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter07)。
- en: 'To be able to run the commands as described in the book, download the source
    code to a folder and set up an environment variable, `$BOOK_HOME`, that points
    to that folder. Some sample commands are as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够按照书中描述的方式运行命令，请将源代码下载到一个文件夹中，并设置一个环境变量`$BOOK_HOME`，指向该文件夹。一些示例命令如下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1.0 (also known as the **Greenwich** release), Spring Boot
    2.1.2, and Spring 5.1.4, which are the latest available versions of the Spring
    components at the time of writing this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是针对Java 8编写并在Java 12上进行了测试。本章使用Spring Cloud 2.1.0（也称为**Greenwich**发布），Spring
    Boot 2.1.2和Spring 5.1.4，这是编写本章时Spring组件的最新可用版本。
- en: 'The source code contains the following Gradle projects:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含以下Gradle项目：
- en: '`api`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`'
- en: '`util`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`'
- en: '`microservices/product-service`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-service`'
- en: '`microservices/review-service`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/review-service`'
- en: '`microservices/recommendation-service`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/recommendation-service`'
- en: '`microservices/product-composite-service`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-composite-service`'
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter07`,
    but are edited in many cases in order to remove irrelevant parts of the source
    code, such as comments and import and log statements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例都来自`$BOOK_HOME/Chapter07`中的源代码，但在许多情况下进行了编辑，以删除源代码的无关部分，如注释和导入和日志语句。
- en: In this chapter*,* you can take a look at the changes that ware applied to the
    source code and what it took to make the microservices reactive. This code can
    be compared to the source code for [Chapter 6](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml),
    *Adding Persistence*. You can use your favorite `diff`-tool and compare the two
    folders – `$BOOK_HOME/Chapter06` and `$BOOK_HOME/Chapter07`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您可以查看应用于源代码的更改以及使微服务变得响应式所需的步骤。此代码可以与[第6章](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml)的源代码进行比较，即*添加持久性*。您可以使用您喜欢的`diff`工具比较两个文件夹
    - `$BOOK_HOME/Chapter06`和`$BOOK_HOME/Chapter07`。
- en: Choosing between non-blocking synchronous APIs and event-driven asynchronous
    services
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在非阻塞同步API和事件驱动的异步服务之间进行选择
- en: When developing reactive microservices, it is not always obvious when to use
    non-blocking synchronous APIs and when to use event-driven asynchronous services.
    In general, to make a microservice robust and scalable, it is important to make
    it as autonomous as possible, for example, minimizing its runtime dependencies.
    This is also known as **loose** **coupling**. Therefore, asynchronous message
    passing of events, is preferable over synchronous APIs. This is because the microservice
    will only depend on access to the messaging system at runtime instead of being
    dependent on synchronous access to a number of other microservices.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发响应式微服务时，不总是明显何时使用非阻塞同步API和何时使用事件驱动的异步服务。一般来说，为了使微服务健壮和可伸缩，将其尽可能地自主化是很重要的，例如，最小化其运行时依赖关系。这也被称为**松耦合**。因此，事件的异步消息传递优于同步API。这是因为微服务只会在运行时依赖于对消息系统的访问，而不是依赖于对其他多个微服务的同步访问。
- en: 'There are, however, a number of cases where non-blocking synchronous APIs could
    be favorable to use, for example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些情况下，非阻塞同步API可能更有利于使用，例如：
- en: For read operations where an end user is waiting for a response
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于需要等待响应的读取操作的终端用户
- en: Where the client platforms are more suitable for consuming synchronous APIs,
    for example, mobile apps or SPA web applications
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端平台更适合消费同步API，例如移动应用程序或SPA Web应用程序
- en: Where the clients will connect to the service from other organizations—where
    it might be hard to agree over a common messaging system to use across organizations
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户将从其他组织连接到服务的地方——在跨组织之间可能很难就要使用的共同消息系统达成一致
- en: 'For the system landscape used in this book, we will use the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中使用的系统景观，我们将使用以下内容：
- en: The create, read, and delete services exposed by the product composite microservice
    will be based on synchronous APIs. The composite microservice is assumed to have
    clients on both web and mobile platforms, as well as clients coming from other
    organizations rather than the ones that operate the system landscape. Therefore,
    synchronous APIs seem like a natural match.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品组合微服务暴露的创建、读取和删除服务将基于同步API。组合微服务假定在Web和移动平台上都有客户端，并且客户端来自于操作系统环境而不是系统景观的组织。因此，同步API似乎是一个自然的选择。
- en: The read services provided by the core microservices will also be developed
    as non-blocking synchronous APIs since there is an end user waiting for their
    responses.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心微服务提供的读取服务也将作为非阻塞同步API开发，因为有终端用户在等待它们的响应。
- en: The create and delete services provided by the core microservices will be developed
    as event-driven asynchronous services. The synchronous APIs provided by the composite
    microservices to create and delete aggregated product information will simply
    publish, create, and delete events on the topics that the core services listen
    on and then return with a 200 (OK) response.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心微服务提供的创建和删除服务将作为事件驱动的异步服务开发。组合微服务提供的同步API用于创建和删除聚合产品信息，只需在核心服务监听的主题上发布、创建和删除事件，然后返回200（OK）响应。
- en: 'This is illustrated by the following diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了这一点：
- en: '![](img/a8f1c5bd-e29b-4f4d-a527-a0f86fd863b1.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a8f1c5bd-e29b-4f4d-a527-a0f86fd863b1.png)'
- en: First, let's learn how we can develop non-blocking synchronous REST APIs, and
    thereafter, we will look at how to develop event-driven asynchronous services.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们学习如何开发非阻塞同步REST API，然后我们将看看如何开发事件驱动的异步服务。
- en: Developing non-blocking synchronous REST APIs using Spring
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring开发非阻塞同步REST API
- en: 'In this section, we will learn how to develop non-blocking versions of the
    read APIs. The composite service will make reactive, that is, non-blocking, calls
    in parallel to the three core services. When the composite service has received
    responses from the core services, it will create a composite response and send
    it back to the caller. This is illustrated in the following diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何开发读取API的非阻塞版本。组合服务将以并行的方式对三个核心服务进行反应式，即非阻塞的调用。当组合服务收到来自核心服务的响应时，它将创建一个组合响应并将其发送回调用者。下图说明了这一点：
- en: '![](img/676c4d79-653b-438c-b8ff-7ffe0477644d.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/676c4d79-653b-438c-b8ff-7ffe0477644d.png)'
- en: 'We will cover the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下内容：
- en: An introduction to Spring Reactor
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Reactor简介
- en: Non-blocking persistence using Spring Data for MongoDB
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Data为MongoDB进行非阻塞持久化
- en: Non-blocking REST APIs in the core services, including how to handle blocking
    code for the JPA-based persistence layer
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心服务中的非阻塞REST API，包括如何处理基于JPA的持久化层的阻塞代码
- en: Non-blocking REST APIs in the composite service
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合服务中的非阻塞REST API
- en: An introduction to Spring Reactor
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Reactor简介
- en: As we mentioned in the *Beginning with Spring WebFlux* section in [Chapter 2](9878a36a-5760-41a4-a132-1a2387b61037.xhtml),
    *Introduction to Spring Boot*, the reactive support in Spring 5 is based on **Project
    Reactor** ([https://projectreactor.io](https://projectreactor.io)).  Project Reactor
    is based on the *Reactive Streams specification* ([http://www.reactive-streams.org](http://www.reactive-streams.org)),
    a standard for building reactive applications. Spring Reactor is fundamental and
    it is what Spring WebFlux, Spring WebClient, and Spring Data rely on to provide
    their reactive and non-blocking features.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](9878a36a-5760-41a4-a132-1a2387b61037.xhtml)中的*开始使用Spring WebFlux*部分中提到的，Spring
    5中的响应式支持基于**Project Reactor** ([https://projectreactor.io](https://projectreactor.io))。Project
    Reactor基于*Reactive Streams规范* ([http://www.reactive-streams.org](http://www.reactive-streams.org))，这是构建响应式应用程序的标准。Spring
    Reactor是基础，Spring WebFlux、Spring WebClient和Spring Data依赖于它来提供它们的响应式和非阻塞特性。
- en: 'The programming model is based on processing streams of data, and the core
    data types in Project Reactor are `Flux` and `Mono`. A `Flux` object is used to
    process a stream of *0*...*n* elements and a `Mono` object is used to process
    *0*...*1* elements. We will see numerous examples of its usage in this chapter.
    As a short introduction, let''s look at the following test:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 编程模型基于处理数据流，Project Reactor中的核心数据类型是`Flux`和`Mono`。`Flux`对象用于处理*0*...*n*个元素的流，`Mono`对象用于处理*0*...*1*个元素。我们将在本章中看到其使用的许多示例。作为一个简短的介绍，让我们看一下以下测试：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is an explanation of the preceding source code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面源代码的解释：
- en: We initiate the stream with the integers `1`, `2`, `3`, and `4`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们用整数`1`、`2`、`3`和`4`初始化流。
- en: Next, we `filter` out the odd numbers—we only allow even numbers to proceed
    through the stream—in this test, these are `2` and `4`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们过滤出奇数——只允许偶数通过流——在这个测试中，这些是`2`和`4`。
- en: Next, we transform (or `map`) the values in the stream by multiplying them by
    `2`, that is, to `4` and `8`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过将流中的值乘以`2`来转换（或`map`），即为`4`和`8`。
- en: Then, we `log` the data that flows through the stream after the `map` operation.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在`map`操作之后记录流经流的数据。
- en: So far, we have only declared the processing of a stream. To actually get the
    stream processed, we need someone to subscribe to it. The final call to the `subscribe`
    method will register a subscriber and the subscriber will apply the lambda function
    specified in the call to the `subscribe` method on each element it gets from the
    stream. Thereafter, it will add them to the `list` element.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们只声明了流的处理。要实际处理流，我们需要有人订阅它。对`subscribe`方法的最终调用将注册一个订阅者，并且订阅者将对它从流中获取的每个元素应用在`subscribe`方法调用中指定的lambda函数。此后，它将把它们添加到`list`元素中。
- en: Finally, we can assert that `list` after the processing of the stream contains
    the expected result—the integers `4` and `8`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以断言在流的处理之后，`list`中包含预期的结果——整数`4`和`8`。
- en: 'The log output will look like the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 日志输出将如下代码所示：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is an explanation of the preceding source code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面源代码的解释：
- en: The processing of the stream is started by a subscriber that subscribes to the
    stream and requests its content.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流的处理是由订阅者启动的，订阅者订阅流并请求其内容。
- en: Next, the integers `4` and `8` pass through the `log` operation.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，整数`4`和`8`通过`log`操作。
- en: The processing concludes with a call to the `onComplete` method on the subscriber,
    notifying it that the stream has come to an end.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理过程以对订阅者的`onComplete`方法的调用结束，通知它流已经结束。
- en: For the full source code, see the `se.magnus.util.reactor.ReactorTests` test
    class in the `util` project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请查看`util`项目中的`se.magnus.util.reactor.ReactorTests`测试类。
- en: Normally, we don't initiate the processing of the stream. Instead, we will only
    define how it shall be processed, and it will be the responsibility of an infrastructure
    component, such as Spring WebFlux, to initiate the processing, for example, as
    a response to an incoming HTTP request. An exception to this rule of thumb is
    the case where blocking code needs a response from the reactive stream. In these
    cases, the blocking code can call the `block()` method on the `Flux` or `Mono`
    object to get the response from the `Flux` or `Mono` object in a blocking way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不会启动流的处理。相反，我们只会定义它应该如何处理，而由基础设施组件（例如Spring WebFlux）负责启动处理，例如作为对传入HTTP请求的响应。这个规则的一个例外是阻塞代码需要从响应式流中获取响应的情况。在这些情况下，阻塞代码可以调用`Flux`或`Mono`对象上的`block()`方法以阻塞方式获取来自`Flux`或`Mono`对象的响应。
- en: Non-blocking persistence using Spring Data for MongoDB
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Data进行非阻塞持久化的MongoDB
- en: 'Making the MongoDB-based repositories for the `product` and `recommendation`
    services reactive is very simple:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使`product`和`recommendation`服务的基于MongoDB的存储库变为响应式非常简单：
- en: Change to the `ReactiveCrudRepository` base class for the repositories
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改为`ReactiveCrudRepository`基类用于存储库
- en: Change the custom finder methods to return a `Mono` or `Flux` object
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改自定义查找方法以返回`Mono`或`Flux`对象
- en: 'The `ProductRepository` and `RecommendationRepository` look like the following
    after the change:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改后，`ProductRepository`和`RecommendationRepository`如下所示：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: No changes are applied to the persistence code for the `review` service, it
    will remain blocking using the JPA repository!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`review`服务的持久化代码不做任何更改，它将继续使用JPA存储库进行阻塞！
- en: 'For the full source code, take a look at the following classes:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请查看以下类：
- en: '`se.magnus.microservices.core.product.persistence.ProductRepository` in the `product` project.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.core.product.persistence.ProductRepository`在`product`项目中。'
- en: '`se.magnus.microservices.core.recommendation.persistence.RecommendationRepository`
    in the `recommendation` project.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommendation`项目中的`se.magnus.microservices.core.recommendation.persistence.RecommendationRepository`。'
- en: Changes in the test code
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码中的更改
- en: When it comes to testing the persistence layer, we have to make some changes.
    Since our persistence methods now return a `Mono` or `Flux` object, the test methods
    have to wait for the response to be available in the returned reactive objects.
    The test methods can either use an explicit call to the `block()` method on the
    `Mono`/`Flux` object to wait until a response is available or use the `StepVerifier` helper
    class from Project Reactor to declare a verifiable sequence of asynchronous events.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试持久层时，我们必须进行一些更改。由于我们的持久化方法现在返回`Mono`或`Flux`对象，测试方法必须等待响应在返回的响应式对象中可用。测试方法可以使用`Mono`/`Flux`对象上的`block()`方法的显式调用来等待响应可用，也可以使用Project
    Reactor中的`StepVerifier`辅助类声明可验证的异步事件序列。
- en: 'The following example shows how to change the test code to work for the reactive
    version of the repository:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示如何更改测试代码以适用于存储库的响应式版本：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use the `block()` method on the `Mono` object returned by the `repository.findById()`
    method and keep the imperative programming style, as shown here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`repository.findById()`方法返回的`Mono`对象上使用`block()`方法，并保持命令式编程风格，如下所示：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternatively, we can use the `StepVerifier` class to set up a sequence of
    processing steps that both execute the repository find operation and also verifies
    the result. The sequence is initialized by the final call to the `verifyComplete()`
    method like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`StepVerifier`类来设置一系列处理步骤，这些步骤既执行存储库查找操作，又验证结果。序列是通过对`verifyComplete()`方法的最终调用来初始化的，如下所示：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For examples of using the `StepVerifier` class to write tests, see the `se.magnus.microservices.core.product.PersistenceTests` test
    class in the `product` project.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用`StepVerifier`类编写测试的示例，请参阅`product`项目中的`se.magnus.microservices.core.product.PersistenceTests`测试类。
- en: For corresponding examples of using the `block()` method to write tests, see
    the `se.magnus.microservice.core.recommendation.PersistenceTests` test class in
    the `recommendation` project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用`block()`方法编写测试的相应示例，请参阅`recommendation`项目中的`se.magnus.microservice.core.recommendation.PersistenceTests`测试类。
- en: Non-blocking REST APIs in the core services
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心服务中的非阻塞REST API
- en: 'With a non-blocking persistence layer in place, it''s time to make the APIs
    in the core services non-blocking as well. We need to make the following changes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在非阻塞持久层就位后，是时候将核心服务中的API也改为非阻塞了。我们需要进行以下更改：
- en: Change the APIs so that they only return reactive data types
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改API，使其仅返回响应式数据类型
- en: Change the service implementations so they don't contain any blocking code
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改服务实现，使其不包含任何阻塞代码
- en: Change our tests so that they can test the reactive services
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改我们的测试，以便它们可以测试响应式服务
- en: Deal with blocking code—isolate the code that still needs to be blocking from
    the non-blocking code
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理阻塞代码-将仍然需要阻塞的代码与非阻塞代码隔离开来
- en: Changes in the APIs
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API的更改
- en: To make the APIs of the core services reactive, we need to update their methods
    so that they return either a `Mono` or `Flux` object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要使核心服务的API变为响应式，我们需要更新它们的方法，使其返回`Mono`或`Flux`对象。
- en: 'For example, `getProduct()` in the `product` service now returns `Mono<Product>`
    instead of a `Product` object:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`product`服务中的`getProduct()`现在返回`Mono<Product>`而不是`Product`对象：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the full source code, take a look at the following classes in the `api`
    project:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请查看`api`项目中的以下类：
- en: '`se.magnus.api.core.product.ProductService`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.product.ProductService`'
- en: '`se.magnus.api.core.recommendation.RecommendationService`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.recommendation.RecommendationService`'
- en: '`se.magnus.api.core.review.ReviewService`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.api.core.review.ReviewService`'
- en: Changes in the service implementations
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务实现的更改
- en: 'For the implementations of the services in the `product` and `recommendation`
    services that use a reactive persistence layer, we can use the fluent API in Project
    Reactor. For example, the implementation of the `getProduct()` method looks like
    the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用响应式持久性层的`product`和`recommendation`服务的服务实现，我们可以使用Project Reactor中的流畅API。例如，`getProduct()`方法的实现如下所示：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is an explanation of the preceding source code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是先前源代码的解释：
- en: The method will return a `Mono` object; the processing here is declared, not
    triggered. It is triggered by the web framework, `WebFlux`, once it receives a
    request to this service!
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法将返回一个`Mono`对象；这里声明处理，而不是触发。一旦Web框架`WebFlux`接收到对该服务的请求，它就会触发！
- en: A product will be retrieved using its `productId` from the underlying database
    using the `findByProductId()` method in the persistence repository.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将使用持久性存储库中的`findByProductId()`方法从底层数据库中检索产品。
- en: If no product is found for the given `productId`, `NotFoundException` will be
    thrown.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找不到给定`productId`的产品，将抛出`NotFoundException`。
- en: The `log` method will produce log output.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`log`方法将产生日志输出。'
- en: The `mapper.entityToApi()` method will be called to transform the returned entity
    from the persistence layer to an API model object.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将调用`mapper.entityToApi()`方法将返回的实体从持久性层转换为API模型对象。
- en: The final `map` method will set the DNS name and IP address of the microservices
    that processed the request in the `serviceAddress` field of the model object.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终的`map`方法将在模型对象的`serviceAddress`字段中设置处理请求的微服务的DNS名称和IP地址。
- en: 'Some sample log output for successful processing is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 成功处理的一些示例日志输出如下：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is a sample of failed processing (throwing a not found exception):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理失败的示例（抛出未找到异常）：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For the full source code, see the following classes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见以下类：
- en: '`se.magnus.microservices.core.product.services.ProductServiceImpl` in the `product`
    project'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`项目中的`se.magnus.microservices.core.product.services.ProductServiceImpl`'
- en: '`se.magnus.microservices.core.recommendation.services.RecommendationServiceImpl` in
    the `recommendation` project'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommendation`项目中的`se.magnus.microservices.core.recommendation.services.RecommendationServiceImpl`'
- en: Changes in the test code
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码的更改
- en: The test code for service implementations has been changed in the same way as
    the tests for the persistence layer we described previously. To handle the asynchronous
    behavior of the reactive return types, `Mono` and `Flux`, the tests use a mix
    of calling the `block()` method and using the `StepVerifier` helper class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 服务实现的测试代码已经以与我们之前描述的持久性层测试相同的方式进行了更改。为了处理响应式返回类型`Mono`和`Flux`的异步行为，测试使用了调用`block()`方法和使用`StepVerifier`辅助类的混合。
- en: 'For the full source code, see the following test classes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见以下测试类：
- en: '`se.magnus.microservices.core.product.ProductServiceApplicationTests` in the `product` project'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`项目中的`se.magnus.microservices.core.product.ProductServiceApplicationTests`'
- en: '`se.magnus.microservices.core.recommendation.RecommendationServiceApplicationTests` in
    the `recommendation` project'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommendation`项目中的`se.magnus.microservices.core.recommendation.RecommendationServiceApplicationTests`'
- en: Dealing with blocking code
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理阻塞代码
- en: In the case of the `review` service, which uses JPA to access its data in a
    relational database, we don't have support for a non-blocking programming model.
    Instead, we can run the blocking code using `Scheduler`, which is capable of running
    the blocking code on a thread from a dedicated thread pool with a limited number
    of threads. Using a thread pool for the blocking code avoids draining the available
    threads in the microservice (avoids affecting the non-blocking processing in the
    microservice).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用JPA在关系数据库中访问其数据的`review`服务，我们没有支持非阻塞编程模型。相反，我们可以使用`Scheduler`来运行阻塞代码，`Scheduler`能够在专用线程池中的线程上运行阻塞代码，线程数有限。使用线程池来处理阻塞代码可以避免耗尽微服务中的可用线程（避免影响微服务中的非阻塞处理）。
- en: 'Let''s see how this process works, as laid out in the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个过程是如何进行的，按照以下步骤进行：
- en: 'Firstly, we configure the thread pool in the `main` `ReviewServiceApplication` class,
    as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`main`的`ReviewServiceApplication`类中配置线程池，如下所示：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can configure the size of the thread pool using the `spring.datasource.maximum-pool-size` parameter.
    If it is not set, it will default to 10 threads. For the full source code, see
    the `se.magnus.microservices.core.review.ReviewServiceApplication` class in the `review`
    project.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`spring.datasource.maximum-pool-size`参数配置线程池的大小。如果未设置，它将默认为10个线程。有关完整的源代码，请参见`review`项目中的`se.magnus.microservices.core.review.ReviewServiceApplication`类。
- en: 'Next, we inject the scheduler into the `review` service implementation class,
    as shown here:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将调度程序注入`review`服务实现类中，如下所示：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we use the thread pool in the reactive implementation of the `getReviews()`
    method, like so:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在`getReviews()`方法的响应式实现中使用线程池，如下所示：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here is an explanation of the preceding code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的解释：
- en: The blocking code is placed in the `getByProductId()` method
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻塞代码放在`getByProductId()`方法中
- en: The `getReviews()` method uses the `asyncFlux()` method to run the blocking
    code in a thread from the thread pool
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getReviews()`方法使用`asyncFlux()`方法在线程池中运行阻塞代码'
- en: For the full source code, see the `se.magnus.microservices.core.review.services.ReviewServiceImpl` class in
    the `review` project.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见`review`项目中的`se.magnus.microservices.core.review.services.ReviewServiceImpl`类。
- en: Non-blocking REST APIs in the composite services
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合服务中的非阻塞REST API
- en: 'To make our REST API in the composite service non-blocking, we need to do the
    following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的复合服务中的REST API非阻塞，我们需要执行以下操作：
- en: Change the APIs so that they only return reactive datatypes
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改API，使其只返回响应式数据类型
- en: Change the integration layer so it uses a non-blocking HTTP client
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改集成层，使其使用非阻塞HTTP客户端
- en: Change the service implementation so it calls the core services APIs in parallel
    and non-blocking
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改服务实现，使其以并行和非阻塞的方式调用核心服务API
- en: Change our tests so that they can test the reactive service
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改我们的测试，以便测试响应式服务
- en: Changes in the API
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API的更改
- en: To make the API of the composite service reactive, we need to apply the same
    type of change that we applied for the APIs of the core services we described
    previously. This means that the return type of the `getCompositeProduct` method,
    `ProductAggregate`, needs to be replaced with `Mono<ProductAggregate>`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使复合服务的API具有响应性，我们需要应用与之前描述的核心服务API相同类型的更改。这意味着`getCompositeProduct`方法的返回类型`ProductAggregate`需要替换为`Mono<ProductAggregate>`。
- en: For the full source code, see the `se.magnus.api.composite.product.ProductCompositeService` class
    in the `api` project.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见`api`项目中的`se.magnus.api.composite.product.ProductCompositeService`类。
- en: Changes in the integration layer
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成层的更改
- en: In the `ProductCompositeIntegration` integration class, we have replaced the
    `RestTemplate` blocking HTTP client with the `WebClient` non-blocking HTTP client that
    comes with Spring 5.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ProductCompositeIntegration`集成类中，我们用Spring 5提供的`WebClient`非阻塞HTTP客户端替换了`RestTemplate`阻塞HTTP客户端。
- en: 'A builder for the `WebClient` is auto-injected in to the constructor. If customization
    is required, for example, in setting up common headers or filters, it can be done
    in the constructor. For the available configuration options, see [https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client-builder](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client-builder).
    Please have a look at the following steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`WebClient`的构建器被自动注入到构造函数中。如果需要自定义，例如设置常见标头或过滤器，可以在构造函数中完成。有关可用的配置选项，请参阅[https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client-builder](https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html#webflux-client-builder)。请查看以下步骤：'
- en: 'Here, we simply build the `WebClient` instance that we will use in our integration
    class, without any configuration:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们只是构建了我们在集成类中使用的`WebClient`实例，没有任何配置：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we use the `webClient` instance to make our non-blocking requests for
    calling the `product` service:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`webClient`实例来进行非阻塞请求，调用`product`服务：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the API call to the `product` service fails, the whole request will fail.
    The `WebClient onErrorMap()` method will call our `handleException(ex)` method,
    which maps the exceptions thrown previously by the HTTP layer to our own exceptions,
    for example, `NotFoundException` and `InvalidInputException`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对“product”服务的API调用失败，整个请求将失败。`WebClient onErrorMap()`方法将调用我们的`handleException(ex)`方法，将之前由HTTP层抛出的异常映射到我们自己的异常，例如`NotFoundException`和`InvalidInputException`。
- en: 'However, if calls to the `product` service succeed but the call to either the recommendation
    or review API fails, we don''t want to let the whole request fail. Instead, we
    want to return as much information that is available, back to the caller. Therefore,
    instead of propagating an exception in these cases, we will instead return an
    empty list of recommendations or reviews using the `WebClient onErrorResume(error
    -> empty())` method. For this, consider the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果对“product”服务的调用成功，但对“recommendation”或“review”API的调用失败，我们不希望让整个请求失败。相反，我们希望将尽可能多的信息返回给调用者。因此，在这些情况下，我们不会传播异常，而是使用`WebClient
    onErrorResume(error -> empty())`方法返回一个空的推荐或评论列表。为此，请考虑以下代码：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For the full source code, see the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class in
    the `product-composite` project.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见`product-composite`项目中的`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`类。
- en: Changes in the service implementation
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务实现的更改
- en: 'To be able to call the three APIs in parallel, the service implementation uses
    the static `zip()`  method on the `Mono` class. The `zip` method is capable of
    handling a number of parallel requests and zipping them together once they all
    are complete. The code looks like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够并行调用三个API，服务实现使用`Mono`类上的静态`zip()`方法。`zip`方法能够处理多个并行请求，并在它们全部完成后将它们一起压缩。代码如下：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is an explanation of the preceding source code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面源代码的解释：
- en: The first parameter of the `zip` method is a lambda function that will receive
    the responses in an array. The actual aggregation of the responses from the three
    API calls is handled by the same helper method as before, `createProductAggregate`,
    without any changes.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`zip`方法的第一个参数是一个lambda函数，将在数组中接收响应。来自三个API调用的响应的实际聚合由相同的辅助方法`createProductAggregate`处理，没有任何更改。'
- en: The parameters after the lambda function are a list of the requests that the
    `zip` method will call in parallel, one `Mono` object per request. In our case,
    we send in three `Mono` objects that were created by the methods in the integration
    class, one for each request that's sent to each core microservice.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: lambda函数后的参数是`zip`方法将并行调用的请求列表，每个请求一个`Mono`对象。在我们的情况下，我们发送了三个由集成类中的方法创建的`Mono`对象，每个请求发送到每个核心微服务。
- en: For the full source code, see the `se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` class
    in the `product-composite` project.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参阅`product-composite`项目中的`se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl`类。
- en: Changes in the test code
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码的更改
- en: 'The only change that''s required in the test classes is to update the setup
    of the mock of the integration class so that the `Mono` and `Flux` objects are
    returned using the  `Mono.just()` helper methods and `Flux.fromIterable()`, as
    shown in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 测试类中唯一需要更改的是更新集成类的模拟设置，以便使用`Mono.just()`和`Flux.fromIterable()`返回`Mono`和`Flux`对象，如下所示：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For the full source code, see the `se.magnus.microservices.composite.product.ProductCompositeServiceApplicationTests` test
    class in the `product-composite` project.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参阅`product-composite`项目中的`se.magnus.microservices.composite.product.ProductCompositeServiceApplicationTests`测试类。
- en: Now that we have developed non-blocking REST APIs with Spring, it is time to
    develop an event-driven synchronous service.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用Spring开发了非阻塞REST API，是时候开发事件驱动的同步服务了。
- en: Developing event-driven asynchronous services
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发事件驱动的异步服务
- en: 'In this section, we will learn how to develop event-driven and asynchronous
    versions of the create and delete services. The composite service will publish create
    and delete events on each core service topic and then return a OK response back
    to the caller without waiting for processing to take place in the core services.
    This is illustrated in the following diagram:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何开发事件驱动和异步版本的创建和删除服务。复合服务将在每个核心服务主题上发布创建和删除事件，然后立即向调用者返回OK响应，而不必等待核心服务中的处理完成。如下图所示：
- en: '![](img/6a55381b-4a64-4aa4-84fb-02f258aca361.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/6a55381b-4a64-4aa4-84fb-02f258aca361.png)
- en: 'We will cover the following topics:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Configuring Spring Cloud Stream to handle challenges with messaging
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Spring Cloud Stream以处理消息传递中的挑战
- en: Defining topics and events
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义主题和事件
- en: Changes in Gradle build files
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle构建文件的更改
- en: Publishing events in the composite service
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在复合服务中发布事件
- en: Consuming events in the core services
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在核心服务中消费事件
- en: Configuring Spring Cloud Stream to handle challenges with messaging
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Spring Cloud Stream以处理消息传递中的挑战
- en: To implement the event-driven create and delete services, we will use Spring
    Cloud Stream. In [Chapter 2](9878a36a-5760-41a4-a132-1a2387b61037.xhtml), *Introduction
    to Spring Boot*, in the *Spring Cloud Stream* section, we have already seen how
    easy it is to publish and consume messages on a topic using Spring Cloud Stream.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现事件驱动的创建和删除服务，我们将使用Spring Cloud Stream。在[第2章](9878a36a-5760-41a4-a132-1a2387b61037.xhtml)中，*Spring
    Boot简介*，*Spring Cloud Stream*部分，我们已经看到使用Spring Cloud Stream在主题上发布和消费消息是多么简单。
- en: 'For example, to publish a message on a topic defined by `mysource`, we only
    have to write the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在由`mysource`定义的主题上发布消息，我们只需编写以下内容：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For consuming a message, we write the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消费消息，我们编写以下代码：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This programming model can be used independently of the messaging system used,
    for example, RabbitMQ or Apache Kafka!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程模型可以独立于所使用的消息系统，例如RabbitMQ或Apache Kafka！
- en: 'Even though sending asynchronous messages is preferred over synchronous API
    calls, it comes with challenges. We will see how we can use Spring Cloud Stream
    to handle some of them. The following features in Spring Cloud Stream will be
    covered:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管发送异步消息优于同步API调用，但也伴随着挑战。我们将看到如何使用Spring Cloud Stream来处理其中一些挑战。将涵盖Spring Cloud
    Stream中的以下功能：
- en: Consumer groups
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者组
- en: Retries and dead-letter queues
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重试和死信队列
- en: Guaranteed orders and partitions
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保证顺序和分区
- en: We'll study each of these in the following sections.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下各节中学习每个内容。
- en: Consumer groups
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费者组
- en: 'The problem here is, if we scale up the number of instances of a message consumer,
    for example, start two instances of the product microservice, both instances of
    the product microservice will consume the same messages, as illustrated by the
    following diagram:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，如果我们扩展消息消费者的实例数量，例如，启动产品微服务的两个实例，产品微服务的两个实例都将消费相同的消息，如下图所示：
- en: '![](img/37c34a80-a777-4301-b2dd-c36e1ac8b50d.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/37c34a80-a777-4301-b2dd-c36e1ac8b50d.png)
- en: 'The solution to this is that we only want one instance per consumer to process
    each message. This can be solved by introducing a *consumer group*, as illustrated
    by the following diagram:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是我们只希望每个消费者实例处理每条消息。这可以通过引入*消费者组*来解决，如下图所示：
- en: '![](img/e4713a81-9342-4fa1-a32d-ea3f544a7596.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/e4713a81-9342-4fa1-a32d-ea3f544a7596.png)
- en: 'In Spring Cloud Stream, a consumer group can be configured on the consumer
    side, for example, for the product microservice, as shown here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Cloud Stream中，可以在消费者端配置消费者组，例如，对于产品微服务，如下所示：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding configuration, Spring Cloud Stream will use the value of the `group`
    field to add instances of the `product` microservice to the consumer group called `productsGroup`.
    This means that messages sent to the `products` topic will only be delivered by
    Spring Cloud Stream to one of the instances of the product microservice.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置中，Spring Cloud Stream将使用`group`字段的值将`product`微服务的实例添加到名为`productsGroup`的消费者组中。这意味着发送到`products`主题的消息将只被Spring
    Cloud Stream传递给`product`微服务的一个实例。
- en: Retries and dead-letter queues
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试和死信队列
- en: In this section, we will learn how retries and dead-letter queues are used by
    message consumers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习消息消费者如何使用重试和死信队列。
- en: If a consumer fails to process a message, it may lost or be requeued for the
    failing consumer until it is successfully processed. If the content of the message
    is invalid, also known as a **poisoned message**, it will block the consumer from
    processing other messages until it is manually removed. If the failure is due
    to a temporary problem, for example, the database can't be reached due to a temporary
    network error, the processing will probably succeed after a number of retries.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消费者无法处理消息，它可能会丢失或重新排队给失败的消费者，直到成功处理为止。如果消息的内容无效，也称为**有毒消息**，它将阻止消费者处理其他消息，直到手动删除为止。如果失败是由于临时问题引起的，例如由于临时网络错误无法访问数据库，处理可能会在多次重试后成功。
- en: It must be possible to specify the number of retries until a message is moved
    to another storage for fault analysis and correction. A failing message is typically
    moved to a dedicated queue called a dead-letter queue. To avoid overloading the
    infrastructure during temporary failure, for example, a network error, it must
    be possible to configure how often retries are performed and preferably with increasing
    time between each retry.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 必须能够指定重试次数，直到消息被移动到另一个存储进行故障分析和纠正。通常，失败的消息会被移动到一个专用队列，称为死信队列。为了避免在临时故障期间（例如网络错误）过载基础设施，必须能够配置重试的频率，并最好在每次重试之间增加时间。
- en: 'In Spring Cloud Stream, this can be configured on the consumer side, for example,
    for the product microservice, as shown here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Cloud Stream中，这可以在消费者端进行配置，例如，对于产品微服务，如下所示：
- en: '[PRE22]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, we specify that Spring Cloud Stream shall perform
    `3` retries before placing a message on the dead-letter queue. The first retry
    shall be attempted after `500` ms and the two other attempts after `1000` ms.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们指定Spring Cloud Stream在将消息放入死信队列之前将执行`3`次重试。第一次重试将在`500`毫秒后尝试，另外两次重试将在`1000`毫秒后尝试。
- en: Enabling the use of dead-letter queues is binding-specific; therefore, we have
    one configuration for RabbitMQ and one for Kafka.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 启用死信队列的使用是与绑定相关的；因此，我们为RabbitMQ和Kafka各自有一个配置。
- en: Guaranteed order and partitions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保证顺序和分区
- en: We can use partitions to ensure that messages are delivered in the same order
    as they were sent but without losing performance and scalability.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用分区来确保消息以与发送时相同的顺序传递，但不会丢失性能和可伸缩性。
- en: If the business logic requires that messages are consumed and processed in the
    same order as they were sent, we cannot use multiple instances per consumer to
    increase processing performance; for example, we cannot use consumer groups. This
    might, in some cases, lead to an unacceptable latency in the processing of incoming
    messages.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果业务逻辑要求消息按照发送时的顺序被消费和处理，我们不能使用多个实例来增加处理性能，例如，我们不能使用消费者组。在某些情况下，这可能导致处理传入消息的延迟不可接受。
- en: In most cases, strict order in the processing of messages is only required for
    messages that affect the same business entities, for example, products.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，消息处理中严格的顺序只对影响相同业务实体的消息是必需的，例如产品。
- en: For example, messages affecting the product with product ID `1` can, in many
    cases, be processed independently of messages that affect the product with product
    ID `2`. This means that the order only needs to be guaranteed for messages that
    have the same product ID.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，影响产品ID为`1`的产品的消息在许多情况下可以独立于影响产品ID为`2`的产品的消息进行处理。这意味着只需要对具有相同产品ID的消息保证顺序。
- en: 'The solution to this is to make it possible to specify a key for each message
    that the messaging system can use in order to guarantee that the order is kept
    between messages with the same key. This can be solved by introducing sub-topics,
    also known as **partitions**, in a topic. The messaging system places messages
    in a specific partition based on its key. Messages with the same key are always
    placed in the same partition. The messaging system only needs to guarantee the
    delivery order for messages in one and the same partition. To ensure the order
    of the messages, we configure one consumer instance per partition within a consumer
    group. By increasing the number of partitions, we can allow a consumer to increase
    its number of instances. This increases its processing message performance without
    losing the delivery order. This is illustrated in the following  diagram:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是使每条消息都能指定一个键，消息系统可以使用这个键来保证具有相同键的消息之间的顺序保持一致。这可以通过引入子主题，也称为**分区**，在一个主题中解决。消息系统根据其键将消息放入特定的分区。具有相同键的消息始终放置在同一个分区中。消息系统只需要保证同一分区中消息的传递顺序。为了确保消息的顺序，我们在消费者组内为每个分区配置一个消费者实例。通过增加分区的数量，我们可以允许消费者增加其实例数量。这可以提高消息处理性能，而不会丢失传递顺序。如下图所示：
- en: '![](img/2962fb3e-d606-4550-8328-c846114f8965.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2962fb3e-d606-4550-8328-c846114f8965.png)'
- en: 'In Spring Cloud Stream, this needs to be configured on both the publisher and
    consumer side. On the publisher side, the key and number of partitions must be
    specified. For example, for the `product-composite` service, we have the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spring Cloud Stream中，这需要在发布者和消费者两侧进行配置。在发布者端，必须指定键和分区数。例如，对于`product-composite`服务，我们有以下配置：
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding configuration means that the key will be taken from the payload
    in the message using a field named `key` and that two partitions will be used.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置意味着键将从消息中的有效载荷中使用名为`key`的字段获取，并且将使用两个分区。
- en: 'Each consumer can specify which partition it wants to consume messages from. For
    example, for the `product` microservice, we have the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 每个消费者可以指定它要从哪个分区中消费消息。例如，对于`product`微服务，我们有以下配置：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding configuration tells Spring Cloud Stream that this consumer will
    only consume messages from partition number `0`, that is, the first partition.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置告诉Spring Cloud Stream，这个消费者只会从分区号为`0`的分区中消费消息，也就是第一个分区。
- en: Defining topics and events
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义主题和事件
- en: As we already mentioned in the *Spring Cloud Stream* section in [Chapter 2](7d969006-ea94-4bbb-858d-30dce8177a2c.xhtml),
    *Introduction to Spring Boot*, Spring Cloud Stream is based on the publishing
    and subscribe pattern, where a publisher publishes messages to topics and subscribers
    subscribe to topics they are interested in to receive messages.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](7d969006-ea94-4bbb-858d-30dce8177a2c.xhtml)中的*Spring Cloud Stream*部分中已经提到的，Spring
    Cloud Stream基于发布和订阅模式，其中发布者将消息发布到主题，订阅者订阅他们感兴趣的主题以接收消息。
- en: We will use one **topic** per type of entity: `products`, `recommendations`, and `reviews`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每种类型的实体使用一个**主题**：`products`，`recommendations`和`reviews`。
- en: Messaging systems handle **messages** that typically consist of headers and
    a body. An **event** is a message that describes something that has happened.
    For events, the message body can be used to describe the type of event, the event
    data, and a timestamp for when the event occurred.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 消息系统处理通常由标头和正文组成的**消息**。**事件**是描述已发生事情的消息。对于事件，消息正文可用于描述事件类型、事件数据以及事件发生的时间戳。
- en: 'An event is, for the scope of this book, defined by the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的范围内，事件由以下内容定义：
- en: The **type** of event, for example, create or delete an event
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件的**类型**，例如，创建或删除事件
- en: A **key**, that identifies the data, for example, a product ID
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**键**，用于标识数据，例如产品ID
- en: A **data** element, that is, the actual data in the event
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**数据**元素，即事件中的实际数据
- en: A **timestamp**, which describes when the event occurred
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**时间戳**，描述事件发生的时间
- en: 'The event class we will use looks as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的事件类如下所示：
- en: '[PRE25]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s explain the preceding source code in detail:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细解释上述源代码：
- en: The `Event` class is a generic class parameterized over the types of its `key`
    and `data` field, `K` and `T`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Event`类是一个通用类，参数化为其`key`和`data`字段的类型，`K`和`T`。'
- en: The event type is declared as an enumerator with the allowed values, that is, `CREATE`
    and `DELETE`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件类型被声明为一个枚举器，其允许的值为`CREATE`和`DELETE`。
- en: The class defines two constructors, one empty and one that can be used to initialize
    the type, key, and value members.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类定义了两个构造函数，一个是空的，一个可以用于初始化类型、键和值成员。
- en: Finally, the class defines getter methods for its member variables.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，该类为其成员变量定义了getter方法。
- en: For the full source code, see the `se.magnus.api.event.Event` class in the `api`
    project.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见`api`项目中的`se.magnus.api.event.Event`类。
- en: Changes in the Gradle build files
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle构建文件中的更改
- en: 'To bring in Spring Cloud Stream and its binders for RabbitMQ and Kafka, we
    need to add the two starter dependencies known as `spring-cloud-starter-stream-rabbit`
    and `spring-cloud-starter-stream-kafka`. We also need a test dependency, `spring-cloud-stream-test-support`,
    to bring in the test support. The following code shows this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引入Spring Cloud Stream及其RabbitMQ和Kafka的绑定器，我们需要添加两个称为`spring-cloud-starter-stream-rabbit`和`spring-cloud-starter-stream-kafka`的启动依赖项。我们还需要一个测试依赖项`spring-cloud-stream-test-support`，以引入测试支持。以下代码显示了这一点：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To specify what version of Spring Cloud that we want to use, we first declare
    a variable for the version:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定我们要使用的Spring Cloud的版本，我们首先声明一个版本变量：
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To wrap up setting up dependency management for that version, we use the following
    code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成该版本的依赖管理设置，我们使用以下代码：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For the full source code, see the `build.gradle` build file in the `product-composite`
    project.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见`product-composite`项目中的`build.gradle`构建文件。
- en: Publishing events in the composite service
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在复合服务中发布事件
- en: 'When the composite service receives requests for the creation or deletion of
    products, it shall publish the corresponding events to the core services on their
    topics. To be able to publish events in the composite service, we need to perform
    the following steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当复合服务接收到有关创建或删除产品的请求时，它将向核心服务发布相应的事件到它们的主题上。为了能够在复合服务中发布事件，我们需要执行以下步骤：
- en: Declare message sources and publish events in the integration layer.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在集成层声明消息源并发布事件。
- en: Add configuration for publishing events.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加配置以发布事件。
- en: Change our tests so that they can test the publishing of events.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改我们的测试，以便它们可以测试事件的发布。
- en: No changes are required in the composite service implementation class!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 复合服务实现类不需要进行任何更改！
- en: Declaring message sources and publishing events in the integration layer
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在集成层声明消息源并发布事件
- en: 'To be able to publish events to different topics, we need to declare one `MessageChannel` per
    topic in a Java interface and also declare that we want to use it with an `EnableBinding` annotation.
    Let''s us see how to do this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够向不同的主题发布事件，我们需要在Java接口中声明一个`MessageChannel`，并且还要声明我们要使用它的`EnableBinding`注解。让我们看看如何做到这一点：
- en: 'We declare our message channels in the `MessageSources` interface in the `ProductCompositeIntegration` class
    and ask Spring to inject an instance of it in the constructor, as follows:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`ProductCompositeIntegration`类的`MessageSources`接口中声明我们的消息通道，并要求Spring在构造函数中注入其实例，如下所示：
- en: '[PRE29]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When we want to publish an event on a topic, we use the injected `messageSources` object.
    For example, to send a delete event for a product, we can use the `outputProducts()` method
    to get a message channel for the product's topic and then use its `send()` method
    to publish an event.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要在某个主题上发布事件时，我们使用注入的`messageSources`对象。例如，要发送有关产品的删除事件，我们可以使用`outputProducts()`方法获取产品主题的消息通道，然后使用其`send()`方法发布事件。
- en: 'To create the message that contains the event, we can use the built-in `MessageBuilder` class,
    as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建包含事件的消息，我们可以使用内置的`MessageBuilder`类，如下所示：
- en: '[PRE30]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For the full source code, see the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class
    in the `product-composite` project.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见`product-composite`项目中的`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`类。
- en: Adding configuration for publishing events
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加配置以发布事件
- en: 'We also need to set up a configuration for the messaging system to be able
    to publish events. To do this, we need to complete the following steps:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置消息系统的配置，以便能够发布事件。为此，我们需要完成以下步骤：
- en: 'We declare that RabbitMQ is the default messaging system and that the default
    content type is JSON:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明RabbitMQ是默认的消息系统，默认内容类型为JSON：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we bind our output channels to specific topic names, as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将输出通道绑定到特定的主题名称，如下所示：
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we declare connectivity information for both Kafka and RabbitMQ:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们声明了Kafka和RabbitMQ的连接信息：
- en: '[PRE33]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the default Spring profile, we specify hostnames to be used when we run our
    system landscape without Docker on `localhost` with the IP address `127.0.0.1`.
    In the `docker` Spring profile, we specify the hostnames we will use when running
    in Docker and using Docker Compose, that is, `rabbitmq` and `kafka`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的Spring配置文件中，我们指定在`localhost`上运行系统时要使用的主机名，IP地址为`127.0.0.1`。在`docker`的Spring配置文件中，我们指定在Docker中运行并使用Docker
    Compose时要使用的主机名，即`rabbitmq`和`kafka`。
- en: For the full source code, see the `src/main/resources/application.yml` configuration
    file in the `product-composite` project.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见`product-composite`项目中的`src/main/resources/application.yml`配置文件。
- en: Changes in the test code
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码的更改
- en: Testing asynchronous event-driven microservices is, by their nature, difficult.
    Tests typically need to synchronize on the asynchronous background processing
    in some way to be able to verify its result. Spring Cloud Stream comes with support,
    in terms of `TestSupportBinder`, for verifying what messages have been sent without
    using any messaging system during the tests!
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 测试异步事件驱动的微服务在性质上是困难的。测试通常需要以某种方式同步异步后台处理，以便能够验证其结果。Spring Cloud Stream提供了支持，即`TestSupportBinder`，用于在测试期间验证已发送的消息，而无需使用任何消息系统！
- en: 'The test support includes a  `MessageCollector` helper class that can be used
    to get all the messages that were sent during a test. To see how it is done, check
    out these steps:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 测试支持包括一个`MessageCollector`辅助类，可用于在测试期间获取发送的所有消息。要了解如何操作，请查看以下步骤：
- en: 'In the `MessagingTests` test class, we set up a queue that can be used to inspect
    the messages that are sent to each topic, as follows:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MessagingTests`测试类中，我们设置了一个队列，用于检查发送到每个主题的消息，如下所示：
- en: '[PRE34]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'An actual test can verify the content in the queue like the following test
    can for the creation of a product:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际测试可以验证队列中的内容，就像以下测试可以验证产品的创建一样：
- en: '[PRE35]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `receivesPayloadThat()` method is a static method in another test support
    class in Spring Cloud Stream, `MessageQueueMatcher`. This class contains a set
    of methods that simplify the verification of messages in a queue.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`receivesPayloadThat()`方法是Spring Cloud Stream中另一个测试支持类`MessageQueueMatcher`中的静态方法。该类包含一组简化队列中消息验证的方法。'
- en: The `sameEventExceptCreatedAt()` method is a static method in the `IsSameEvent`
    class that compares `Event` objects and treats them as equal if all the fields
    are equal, except for the `eventCreatedAt` field.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`sameEventExceptCreatedAt()`方法是`IsSameEvent`类中的静态方法，用于比较`Event`对象，如果所有字段都相等，除了`eventCreatedAt`字段。'
- en: 'For the full source code, see the following test classes in the `product-composite`
    project:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见`product-composite`项目中的以下测试类：
- en: '`se.magnus.microservices.composite.product.MessagingTests`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.composite.product.MessagingTests`'
- en: '`se.magnus.microservices.composite.product.IsSameEvent`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`se.magnus.microservices.composite.product.IsSameEvent`'
- en: Consuming events in the core services
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在核心服务中消费事件
- en: 'To be able to consume events in the core services, we need to do the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在核心服务中消费事件，我们需要执行以下操作：
- en: Declare message processors that listen for events on its topic.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明监听其主题上事件的消息处理器。
- en: Change our service implementations so it uses the reactive persistence layer
    correctly.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改我们的服务实现，使其正确使用响应式持久层。
- en: Add configuration for consuming events.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加用于消费事件的配置。
- en: Change our tests so that they can test the asynchronous processing of the events.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改我们的测试，以便测试事件的异步处理。
- en: Declaring message processors
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明消息处理器
- en: 'The REST APIs for creating and deleting entities have been replaced with a
    message processor in each core microservice that listens for creating and deleting
    events on each entity''s topic. To be able to consume messages that have been
    published to a topic, we need to bind to `SubscribableChannel`, similar to how
    we bind to `MessageChannel` when we want to publish messages. Since each message
    processor only listens to one topic, we can use the built-in `Sink` interface
    to bind to that topic. We use the `EnableBinding` annotation to declare the use
    of the `Sink` interface, as shown in the following source code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建和删除实体的REST API已被替换为每个核心微服务中监听每个实体主题上创建和删除事件的消息处理器。要能够消费已发布到主题的消息，我们需要绑定到`SubscribableChannel`，类似于我们在想要发布消息时绑定到`MessageChannel`。由于每个消息处理器只监听一个主题，我们可以使用内置的`Sink`接口来绑定到该主题。我们使用`EnableBinding`注解来声明使用`Sink`接口，如下面的源代码所示：
- en: '[PRE36]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To actually consume and process messages, we can annotate a method with the
    `StreamListener` annotation, where we specify what channel we shall listen to:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际消费和处理消息，我们可以使用`StreamListener`注解标记一个方法，指定我们将监听哪个通道：
- en: '[PRE37]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The implementation of the `process()` method uses a `switch` statement to call
    the create method in the service component for creating events and the delete
    method for deleting events. The source code looks as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`process()`方法的实现使用`switch`语句调用服务组件中的create方法来创建事件，调用delete方法来删除事件。源代码如下：'
- en: '[PRE38]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s explain the preceding source code in detail:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细解释前面的源代码：
- en: The `switch` statement expects an event type that is either a `CREATE` or a
    `DELETE` event.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`switch`语句期望的事件类型是`CREATE`或`DELETE`事件。'
- en: The `productService.createProduct()` method is called for create events.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`productService.createProduct()`方法用于创建事件。'
- en: The `productService.deleteProduct()` method is called for delete events.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`productService.deleteProduct()`方法用于删除事件。'
- en: If the event type is neither a  `CREATE` or a `DELETE` event; an exception of
    the `EventProcessingException` type is thrown.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果事件类型既不是`CREATE`也不是`DELETE`事件，则抛出`EventProcessingException`类型的异常。
- en: 'The service component is injected as usual using constructor injection, as
    shown here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 服务组件像往常一样使用构造函数注入，如下所示：
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For the full source code, see the following classes:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见以下类：
- en: '`se.magnus.microservices.core.product.services.MessageProcessor` in the `product`
    project'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`项目中的`se.magnus.microservices.core.product.services.MessageProcessor`'
- en: '`se.magnus.microservices.core.recommendation.services.MessageProcessor` in
    the `recommendation` project'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommendation`项目中的`se.magnus.microservices.core.recommendation.services.MessageProcessor`'
- en: '`se.magnus.microservices.core.review.services.MessageProcessor` in the `review`
    project'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`review`项目中的`se.magnus.microservices.core.review.services.MessageProcessor`'
- en: Changes in the service implementations
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务实现的更改
- en: 'The service implementations of the create and delete methods for the `product`
    and `recommendation` service have been rewritten to use the non-blocking reactive
    persistence layer for MongoDB. For example, creating product entities is done
    as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`和`recommendation`服务的创建和删除方法的服务实现已重写为使用非阻塞的反应式MongoDB持久化层。例如，创建产品实体的方法如下：'
- en: '[PRE40]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `onErrorMap()` method is used to map the `DuplicateKeyException` persistence
    exception to our own `InvalidInputException` exception.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`onErrorMap()`方法用于将`DuplicateKeyException`持久化异常映射到我们自己的`InvalidInputException`异常。'
- en: Since our message processor is based on a blocking programming model, we need
    to call the `block()` method on the returned `Mono` object from the persistence
    layer before we return it to the message processor. If we don't call the `block()` method,
    we won't be able to trigger the error handling in the messaging system if the
    processing in the service implementation fails; the event will not be requeued,
    and eventually, it will be moved to the dead-letter queue, as expected.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的消息处理器是基于阻塞编程模型的，我们需要在将返回的`Mono`对象从持久化层返回给消息处理器之前调用`block()`方法。如果我们不调用`block()`方法，如果服务实现中的处理失败，我们将无法触发消息系统中的错误处理；事件将不会被重新排队，最终将被移至死信队列，这是预期的。
- en: The `review` service that uses the blocking persistence layer for JPA, as before,
    does not need to be updated.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用阻塞持久化层进行JPA的`review`服务，与以前一样，无需更新。
- en: 'For the full source code, see the following classes:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见以下类：
- en: '`se.magnus.microservices.core.product.services.ProductServiceImpl` in the `product`
    project'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`项目中的`se.magnus.microservices.core.product.services.ProductServiceImpl`'
- en: '`se.magnus.microservices.core.recommendation.services.RecommendationServiceImpl` in
    the `recommendation` project'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommendation`项目中的`se.magnus.microservices.core.recommendation.services.RecommendationServiceImpl`'
- en: Adding configuration for consuming events
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用于消费事件的配置
- en: We also need to set up the configuration for the messaging system, to be able
    to consume events; this is similar to what we did for the publisher. Declaring
    RabbitMQ as the default messaging system, JSON as the default content type, and
    Kafka and RabbitMQ for connectivity information is the same as for the publisher.
    Added to the common parts, the consumer configuration specifies consumer groups;
    retry handling and dead-letter queues are as they were described earlier in the
    *Configuring Spring Cloud Stream to handle challenges with messaging* section.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置消息系统的配置，以便能够消费事件；这与我们为发布者所做的类似。声明RabbitMQ为默认消息系统，JSON为默认内容类型，以及Kafka和RabbitMQ的连接信息与发布者的配置相同。除了公共部分外，消费者配置还指定了消费者组；重试处理和死信队列与之前在*配置Spring
    Cloud Stream以处理消息挑战*部分中描述的一样。
- en: 'For the full source code, see the following configuration files:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见以下配置文件：
- en: '`src/main/resources/application.yml` in the `product` project'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`项目中的`src/main/resources/application.yml`'
- en: '`src/main/resources/application.yml` in the `recommendation` project'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommendation`项目中的`src/main/resources/application.yml`'
- en: '`src/main/resources/application.yml` in the `review` project'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`review`项目中的`src/main/resources/application.yml`'
- en: Changes in the test code
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试代码的更改
- en: 'Since the core services now receive events for creating and deleting their
    entities, the tests need to be updated so that they send events instead of calling
    REST APIs, like they did previously. In the following source code, we can see
    how the `send()` method on the `input` method channel is used to send an event:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于核心服务现在接收用于创建和删除其实体的事件，因此需要更新测试，以便它们发送事件而不是调用REST API，就像它们以前所做的那样。在以下源代码中，我们可以看到`input`方法通道上的`send()`方法是如何用于发送事件的：
- en: '[PRE41]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `input` channel is set up by the test class before any tests are run. It
    is based on the same built-in `Sink` interface that the message processor uses.
    In the following source code, we can see how the `input` channel is created in
    the `setupDb()` method. Since the `setupDb()` method is annotated with `@Before`,
    it will run before any tests are executed:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`input`通道在运行任何测试之前由测试类设置。它基于消息处理器使用的相同内置`Sink`接口。在以下源代码中，我们可以看到`input`通道是如何在`setupDb()`方法中创建的。由于`setupDb()`方法带有`@Before`注解，它将在执行任何测试之前运行：'
- en: '[PRE42]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This construction shortcuts the messaging system and the call to the `send()`
    method in the `input` channel will be processed synchronously by the message processor,
    that is, like a normal method call its `process()` method. This means that the
    test code doesn't need to implement any synchronization or *wait logic* for the
    asynchronous processing of an event. Instead, the test code can apply validation
    logic directly after calls to the `sendCreateProductEvent` and `sendDeleteProductEvent` send
    helper methods return.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这种构造方式绕过了消息系统，并且在`input`通道中对`send()`方法的调用将由消息处理器同步处理，就像普通方法调用它的`process()`方法一样。这意味着测试代码不需要为事件的异步处理实现任何同步或等待逻辑。相反，测试代码可以在调用`sendCreateProductEvent`和`sendDeleteProductEvent`发送辅助方法后直接应用验证逻辑。
- en: 'For the full source code, see the following test classes:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见以下测试类：
- en: '`se.magnus.microservices.core.product.ProductServiceApplicationTests` in the `product`
    project'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`product`项目中的`se.magnus.microservices.core.product.ProductServiceApplicationTests`'
- en: '`se.magnus.microservices.core.recommendation.RecommendationServiceApplicationTests` in
    the `recommendation` project'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommendation`项目中的`se.magnus.microservices.core.recommendation.RecommendationServiceApplicationTests`'
- en: '`se.magnus.microservices.core.review.ReviewServiceApplicationTests` in the `review`
    project'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`review`项目中的`se.magnus.microservices.core.review.ReviewServiceApplicationTests`'
- en: Running manual tests of the reactive microservice landscape
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行响应式微服务系统架构的手动测试
- en: Now, we have fully reactive microservices, both in terms of non-blocking synchronous
    REST APIs and event-driven asynchronous services. Let's try them out!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们拥有了完全响应式的微服务，无论是非阻塞的同步REST API还是事件驱动的异步服务。让我们来试试它们吧！
- en: 'Three different configurations are prepared as follows, each in a separate
    Docker Compose file:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 准备了三种不同的配置，每种配置都在单独的Docker Compose文件中：
- en: Using RabbitMQ without the use of partitions
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不使用分区的情况下使用RabbitMQ
- en: Using RabbitMQ with two partitions per topic
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个主题中使用两个分区的RabbitMQ
- en: Using Kafka with two partitions per topic
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个主题中使用两个分区的Kafka
- en: However, before testing these three configurations, we first need to simplify
    testing of the reactive microservice landscape. Once simplified, we can proceed
    with testing the microservices.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在测试这三种配置之前，我们首先需要简化对响应式微服务系统架构的测试。简化后，我们可以继续测试微服务。
- en: 'So accordingly, the following two features need to be checked:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，需要检查以下两个功能：
- en: Saving events for later inspection when using RabbitMQ
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用RabbitMQ时保存事件以供以后检查
- en: A health API that can be used to monitor the state of the landscape
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用于监视系统状态的健康API
- en: Saving events
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存事件
- en: After running some tests on event-driven asynchronous services, it might be
    of interest to see what event was actually sent. When using Spring Cloud Stream
    with Kafka, events are retained in the topics, even after consumers have processed
    them. However, when using Spring Cloud Stream with RabbitMQ, the events are removed
    after they have been processed successfully.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在对事件驱动的异步服务进行一些测试后，可能有兴趣查看实际发送了哪些事件。在使用Spring Cloud Stream和Kafka时，事件会保留在主题中，即使消费者已经处理了它们。但是，在使用Spring
    Cloud Stream和RabbitMQ时，事件在成功处理后会被删除。
- en: 'To be able to see what events have been published on each topic, Spring Cloud
    Stream is configured to save published events in a separate `auditGroup` consumer
    group per topic. For the `products` topic, the configuration looks like the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够查看每个主题上发布了哪些事件，Spring Cloud Stream被配置为将已发布的事件保存在每个主题的单独的`auditGroup`消费者组中。对于`products`主题，配置如下：
- en: '[PRE43]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When using RabbitMQ, this will result in extra queues being created where the
    events are stored for later inspection.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用RabbitMQ时，这将导致创建额外的队列，事件将存储在其中以供以后检查。
- en: For the full source code, see the `src/main/resources/application.yml` configuration
    file in the `product-composite` project.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见`product-composite`项目中的`src/main/resources/application.yml`配置文件。
- en: Adding a health API
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加健康API
- en: Testing a system landscape of microservices that use a combination of synchronous
    APIs and asynchronous messaging is challenging. For example, how do we know when
    a newly started landscape of microservices, together with their databases and
    messaging system, are ready to process requests and messages?
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用同步API和异步消息传递的微服务系统架构是具有挑战性的。例如，我们如何知道新启动的微服务系统架构以及它们的数据库和消息系统何时准备好处理请求和消息？
- en: To make it easier to know when all the microservices are ready to process requests
    and messages, we have added a health API in all the microservices. They are based
    on the support for health endpoints that comes with the Spring Boot module known
    as the Actuator. By default, a `health` endpoint based on the Actuator answers
    `UP` (and gives 200 as the HTTP return status) if the microservice itself and
    all the dependencies Spring Boot knows about are available, for example, dependencies
    to databases and messaging systems; otherwise, the health endpoint answers `DOWN` (and
    returns 500 as the HTTP return status).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易知道所有微服务何时准备好处理请求和消息，我们在所有微服务中添加了一个健康API。它们基于Spring Boot模块Actuator提供的健康端点的支持。默认情况下，基于Actuator的`health`端点会在微服务本身和Spring
    Boot知道的所有依赖项可用时回答`UP`（并将200作为HTTP返回状态），例如，对数据库和消息系统的依赖项；否则，健康端点会回答`DOWN`（并返回500作为HTTP返回状态）。
- en: We can also extend the `health` endpoint to cover dependencies that Spring Boot
    is not aware of. We will use this feature to extend to the product composite's
    `health` endpoint, which will also include the health of the three core services.
    This means that the product composite `health` endpoint will only respond with
    `UP` if itself and the three core microservices are healthy. This can be used
    either manually or automatically by the `test-em-all.bash` script to find out
    when all the microservices and their dependencies are up and running.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以扩展`health`端点以覆盖Spring Boot不知道的依赖项。我们将使用此功能来扩展产品组合的`health`端点，其中还将包括三个核心服务的健康状况。这意味着产品组合的`health`端点只有在自身和三个核心微服务健康时才会响应`UP`。这可以通过`test-em-all.bash`脚本手动或自动使用，以找出所有微服务及其依赖项何时处于运行状态。
- en: 'In the `ProductCompositeIntegration` integration class, we have added helper
    methods for checking the health of the three core microservices, as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ProductCompositeIntegration`集成类中，我们添加了用于检查三个核心微服务健康状况的辅助方法，如下：
- en: '[PRE44]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This code is similar to the code we used previously to call the core services
    to read APIs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们之前使用的代码类似，用于调用核心服务来读取API。
- en: For the full source code, see the `se.magnus.microservices.composite.product.services.ProductCompositeIntegration` class
    in the `product-composite` project.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见`product-composite`项目中的`se.magnus.microservices.composite.product.services.ProductCompositeIntegration`类。
- en: 'In the main `ProductCompositeServiceApplication` application class, we use
    these helper methods to register three health checks, one for each core microservice:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在主`ProductCompositeServiceApplication`应用类中，我们使用这些辅助方法注册三个健康检查，每个核心微服务一个：
- en: '[PRE45]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: For the full source code, see the `se.magnus.microservices.composite.product.ProductCompositeServiceApplication` class
    in the `product-composite` project.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整源代码，请参见`product-composite`项目中的`se.magnus.microservices.composite.product.ProductCompositeServiceApplication`类。
- en: 'Finally, in the `application.yml` file of all four microservices, we configure
    the Spring Boot Actuator so that it does the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在所有四个微服务的`application.yml`文件中，我们配置Spring Boot执行器，使其执行以下操作：
- en: Show details about the state of health, which not only includes `UP` or `DOWN`,
    but also information about its dependencies
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示有关健康状态的详细信息，不仅包括`UP`或`DOWN`，还包括其依赖项的信息
- en: Expose all its endpoints over HTTP
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTP公开其所有端点
- en: 'The configuration for these two settings looks as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个设置的配置如下：
- en: '[PRE46]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: For an example of the full source code, see the `src/main/resources/application.yml` configuration
    file in the `product-composite` project.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整源代码的示例，请参见`product-composite`项目中的`src/main/resources/application.yml`配置文件。
- en: '**WARNING**: These configuration settings are good during development, but
    it can be a security issue to reveal too much information in actuator endpoints
    in production systems. Therefore, plan for minimizing the information exposed
    by the actuator endpoints in production!'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**：这些配置设置在开发过程中很好，但在生产系统中过多地暴露信息可能会成为安全问题。因此，在生产中，计划最小化由执行器端点暴露的信息！'
- en: 'For details regarding the endpoints that are exposed by Spring Boot Actuator,
    see [https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Spring Boot执行器公开的端点的详细信息，请参见[https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html)：
- en: 'Try it out (when you have all the microservices up and running using Docker
    Compose, as described in the next section):'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试它（当您使用Docker Compose运行所有微服务并使其运行时，请参见下一节）：
- en: '[PRE47]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will result in the following response:'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将导致以下响应：
- en: '![](img/2ae85fa6-c021-4370-9850-fb6daec78d0c.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ae85fa6-c021-4370-9850-fb6daec78d0c.png)'
- en: In the preceding output, we can see that the composite service reports that
    it is healthy, that is, its status is `UP`. At the end of the response, we can
    see that all three core microservices are also reported as healthy.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到复合服务报告说它是健康的，也就是说，它的状态是`UP`。在响应的末尾，我们可以看到所有三个核心微服务也被报告为健康。
- en: With a health API in place, we are ready to test our reactive microservices.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 有了健康API，我们准备测试我们的响应式微服务。
- en: Using RabbitMQ without using partitions
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不使用分区的情况下使用RabbitMQ
- en: In this section, we will test the reactive microservices together with RabbitMQ
    but without using partitions.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将测试响应式微服务以及RabbitMQ，但不使用分区。
- en: 'The default `docker-compose.yml` Docker Compose file is used in this configuration.
    The following changes have been applied to the file:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中使用默认的`docker-compose.yml` Docker Compose文件。对文件进行了以下更改：
- en: 'RabbitMQ has been added, as shown here:'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ已添加，如下所示：
- en: '[PRE48]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The microservices now have a dependency declared to the RabbitMQ service. This
    means that Docker will not start the microservice containers until the RabbitMQ
    service is reported to be healthy:'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，微服务已声明对RabbitMQ服务的依赖关系。这意味着Docker在报告RabbitMQ服务健康之前不会启动微服务容器：
- en: '[PRE49]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To run our tests, perform the following steps:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的测试，请执行以下步骤：
- en: 'Build and start the system landscape with the following commands:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建和启动系统架构：
- en: '[PRE50]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, we have to wait for the microservice landscape to be up and running.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们必须等待微服务架构启动并运行。
- en: 'Try running the following command a few times:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行以下命令几次：
- en: '[PRE51]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When it returns `UP`, we are ready to run our tests!
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 当它返回`UP`时，我们准备运行我们的测试！
- en: 'First, create a composite product with the following commands:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令创建一个复合产品：
- en: '[PRE52]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When using Spring Cloud Stream together with RabbitMQ, it will create one RabbitMQ
    exchange per topic and a set of queues, depending on our configuration.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Spring Cloud Stream与RabbitMQ一起时，它将为每个主题创建一个RabbitMQ交换和一组队列，具体取决于我们的配置。
- en: Let's see what queues that Spring Cloud Stream has created for us!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Spring Cloud Stream为我们创建了哪些队列！
- en: 'Open the following URL in a web browser: `http://localhost:15672/#/queues`.
    You should see the following queues:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Web浏览器中打开以下URL：`http://localhost:15672/#/queues`。您应该会看到以下队列：
- en: '![](img/00372e65-3efd-4733-8c3a-773b383cde7e.png)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00372e65-3efd-4733-8c3a-773b383cde7e.png)'
- en: For each topic, we can see one queue for auditGroup, one for the consumer group
    that's used by the corresponding core microservice, and one dead-letter queue.
    We can also see that the auditGroup queues contain messages, as expected!
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个主题，我们可以看到一个用于auditGroup的队列，一个用于相应核心微服务的消费者组，以及一个死信队列。我们还可以看到auditGroup队列包含消息，正如预期的那样！
- en: 'Click on the products.auditGroup queue and scroll down to Get Message(s), expand
    it, and click on the button named Get Message(s) to see the message in the queue:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`products.auditGroup`队列，滚动到“获取消息”，展开它，然后点击名为“获取消息”的按钮以查看队列中的消息：
- en: '![](img/1ce813e3-39eb-4b9a-a69e-b2d4f0a6be85.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ce813e3-39eb-4b9a-a69e-b2d4f0a6be85.png)'
- en: 'Next, try to get the product composite using the following code:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，尝试使用以下代码获取产品组合：
- en: '[PRE53]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, delete it, like so:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，像这样删除它：
- en: '[PRE54]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Trying to get the deleted product again should result in a `404 - "NotFound"`
    response!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试再次获取已删除的产品应该会导致`404 - "NotFound"`的响应！
- en: If you look in the RabbitMQ audit queues again, you should be able to find new
    messages containing delete events.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次查看RabbitMQ审计队列，你应该能够找到包含删除事件的新消息。
- en: 'Wrap up the test by bringing down the microservice landscape with the following
    command:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令结束测试，关闭微服务架构：
- en: '[PRE55]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This completes the tests where we use RabbitMQ without partitions. Now, let's
    move on and test RabbitMQ with partitions.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们在没有分区的情况下使用RabbitMQ的测试。现在，让我们继续测试带有分区的RabbitMQ。
- en: Using RabbitMQ with two partitions per topic
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RabbitMQ每个主题两个分区
- en: Now, let's try out the partitioning support in Spring Cloud Stream!
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试Spring Cloud Stream中的分区支持！
- en: 'We have a separate Docker Compose file prepared for using RabbitMQ with two
    partitions per topic: `docker-compose-partitions.yml`. It will also start two
    instances per core microservice, one for each partition. For example, a second
    `product` instance is configured as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备了一个单独的Docker Compose文件，用于使用RabbitMQ每个主题两个分区：`docker-compose-partitions.yml`。它还将为每个核心微服务启动两个实例，每个分区一个实例。例如，第二个`product`实例配置如下：
- en: '[PRE56]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here is an explanation of the preceding source code:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面源代码的解释：
- en: We use the same source code and Dockerfile that we did for the first `product`
    instance but configure them differently.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用与第一个`product`实例相同的源代码和Dockerfile，但进行不同的配置。
- en: Specifically, we assign the two `product` instances to different partitions
    using the `instance-index` property we described earlier in this chapter.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体地，我们使用我们在本章前面描述的`instance-index`属性将两个`product`实例分配给不同的分区。
- en: When using system environment variables to specify Spring properties, we must
    use an uppercase format where dots are replaced with underscores.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用系统环境变量指定Spring属性时，我们必须使用大写格式，其中点被下划线替换。
- en: This `product` instance will only process asynchronous events; it will not respond
    to API calls. Since it has a different name, `product-p1` (also used as its DNS
    name), it will not respond to calls to a URL starting with `http://product:8080`.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个`product`实例将只处理异步事件；它不会响应API调用。由于它有一个不同的名称`product-p1`（也用作其DNS名称），它不会响应以`http://product:8080`开头的URL调用。
- en: 'Start up the microservice landscape with the following command:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动微服务景观：
- en: '[PRE57]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Repeat the tests from the previous section but also create a product with the
    product ID set to `2`. If you take a look into the queues set up by Spring Cloud
    Stream, you will see one queue per partition and that the product audit queues
    now contain one message each, that is, the event for product ID `1` was placed
    in one partition and the event for product ID `2` was placed in the other partition.
    If you go back to `http://localhost:15672/#/queues` in your web browser, you should
    see something like the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 重复上一节的测试，但同时创建一个产品，产品ID设置为`2`。如果你查看Spring Cloud Stream设置的队列，你会看到每个分区有一个队列，并且产品审计队列现在每个都包含一个消息，也就是说，产品ID为`1`的事件被放置在一个分区中，产品ID为`2`的事件被放置在另一个分区中。如果你回到`http://localhost:15672/#/queues`在你的浏览器中，你应该会看到以下内容：
- en: '![](img/4d333160-75e8-4a56-87f6-aeee8765402e.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d333160-75e8-4a56-87f6-aeee8765402e.png)'
- en: 'To end the test with RabbitMQ using partitions, bring down the microservice
    landscape with the following command:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 结束使用分区的RabbitMQ测试，使用以下命令关闭微服务景观：
- en: '[PRE58]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We are now done with tests using RabbitMQ, both with and without partitions.
    The final test configuration we shall try out is testing the microservices together
    with Kafka.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了使用RabbitMQ进行测试，包括有和没有分区的情况。我们将尝试使用Kafka测试微服务的最终测试配置。
- en: Using Netflix Eureka as a discovery service
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Netflix Eureka作为发现服务
- en: A discovery service is probably the most important support function required
    to make a landscape of cooperating microservices production-ready. As we already
    described in [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction
    to Microservices*, in the *Service discovery* section, a discovery service can
    be used to keep track of existing microservices and their instances. The first discovery
    service that Spring Cloud supported was *Netflix Eureka***.**
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 发现服务可能是使合作微服务景观达到生产就绪状态所需的最重要的支持功能。正如我们在[第1章](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml)中已经描述的那样，*微服务简介*，在*服务发现*部分，发现服务可以用于跟踪现有微服务及其实例。Spring
    Cloud支持的第一个发现服务是*Netflix Eureka*。
- en: We will use this in [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml),
    *Adding Service Discovery Using Netflix Eureka and Ribbon**,* along with aload
    balancer and the new Spring Cloud load balancer.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)中使用它，*使用Netflix Eureka和Ribbon添加服务发现*，以及负载均衡器和新的Spring
    Cloud负载均衡器。
- en: We will see how easy it is to register microservices with Netflix Eureka when
    using Spring Cloud, and as a client sends HTTP requests such as a call to a RESTful
    API to one of the instances registered in Netflix Eureka. We will also see how
    to scale up the number of instances of a microservice, and how requests to a microservice
    will be load-balanced over its available instances (based on, by default, round-robin
    scheduling).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到使用Spring Cloud时，将微服务注册到Netflix Eureka有多么容易，以及当客户端发送HTTP请求时，例如调用RESTful
    API到Netflix Eureka中注册的实例之一。我们还将看到如何扩展微服务的实例数量，以及对微服务的请求将如何在其可用实例上进行负载均衡（默认情况下是轮询调度）。
- en: 'The following screenshot demonstrates the web UI from Eureka, where we can
    see what microservices we have registered:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了Eureka的Web UI，我们可以看到我们注册了哪些微服务：
- en: '![](img/9d6bf02d-f466-40cf-9bf1-140cbf7d1766.png)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d6bf02d-f466-40cf-9bf1-140cbf7d1766.png)'
- en: The review service has three instances available, while the other two services
    only have one instance each.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 审查服务有三个可用实例，而其他两个服务只有一个实例。
- en: With Netflix Eureka introduced, let's introduce how to use Spring Cloud Gateway
    as an edge server.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 引入Netflix Eureka后，让我们介绍如何使用Spring Cloud Gateway作为边缘服务器。
- en: Using Kafka with two partitions per topic
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kafka每个主题两个分区
- en: 'Now, we shall try out a very cool feature of Spring Cloud Stream: changing
    the messaging system from RabbitMQ to Apache Kafka!'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试Spring Cloud Stream的一个非常酷的功能：将消息系统从RabbitMQ更改为Apache Kafka！
- en: 'This can be done simply by changing the value of the `spring.cloud.stream.defaultBinder` property
    from `rabbit` to `kafka`. This is handled by the `docker-compose-kafka.yml` Docker
    Compose file that has also replaced RabbitMQ with Kafka and Zookeeper. The configuration
    of Kafka and Zookeeper looks as follows:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将`spring.cloud.stream.defaultBinder`属性的值从`rabbit`更改为`kafka`即可完成。这由`docker-compose-kafka.yml`
    Docker Compose文件处理，该文件还将RabbitMQ替换为Kafka和Zookeeper。Kafka和Zookeeper的配置如下：
- en: '[PRE59]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Kafka is also configured to use two partitions per topic, and like before, we
    start up two instances per core microservice, one for each partition. See the
    Docker Compose file, `docker-compose-kafka.yml`, for details!
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka也配置为每个主题使用两个分区，与之前一样，我们为每个分区的核心微服务启动两个实例，每个分区一个。有关详细信息，请参阅Docker Compose文件`docker-compose-kafka.yml`！
- en: 'Start up the microservice landscape with the following command:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动微服务景观：
- en: '[PRE60]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Repeat the tests from the previous section, for example, create two products,
    one with the product ID set to `1`, and one with the product ID set to `2`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 重复上一节的测试，例如，创建两个产品，一个产品ID设置为`1`，另一个产品ID设置为`2`。
- en: Unfortunately, Kafka doesn't come with any graphical tools that can be used
    to inspect topics, partitions, and the messages that are placed within them. Instead,
    we can run CLI commands in the Kafka Docker container.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Kafka没有任何可以用于检查主题、分区和其中放置的消息的图形工具。相反，我们可以在Kafka Docker容器中运行CLI命令。
- en: 'To see a list of topics, run the following command:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看主题列表，请运行以下命令：
- en: '[PRE61]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Expect an output like the one shown here:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 期望输出如下所示：
- en: '![](img/824bee38-2547-4e15-9c1f-d4a7550eb6a0.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](img/824bee38-2547-4e15-9c1f-d4a7550eb6a0.png)'
- en: 'Here is an explanation of the preceding source code:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面源代码的解释：
- en: The topics prefixed with `error` are the topics corresponding to dead-letter
    queues.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`error`为前缀的主题是对应死信队列的主题。
- en: You will not find any `auditGroup` in the case of RabbitMQ; instead, all messages
    the are available in the topics for any consumer to process.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在RabbitMQ的情况下，您将找不到`auditGroup`，而是所有消息都可以在任何消费者处理的主题中找到。
- en: 'To see the partitions in a specific topic, for example, the `products` topic,
    run the following command:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看特定主题中的分区，例如`products`主题，请运行以下命令：
- en: '[PRE62]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Expect an output like the one shown here:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 期望输出如下所示：
- en: '![](img/0ba3ea90-0eb6-49b9-94f2-71b377357e60.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ba3ea90-0eb6-49b9-94f2-71b377357e60.png)'
- en: 'To see all the messages in a specific topic, for example, the `products` topic, run
    the following command:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看特定主题中的所有消息，例如`products`主题，请运行以下命令：
- en: '[PRE63]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Expect an output like the one shown here:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 期望输出如下所示：
- en: '![](img/7570391d-189e-4c89-b544-547f054cfc71.png)'
  id: totrans-447
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7570391d-189e-4c89-b544-547f054cfc71.png)'
- en: 'To see all the messages in a specific partition, for example, partition `1`
    in the `products` topic, run the following command:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看特定分区中的所有消息，例如`products`主题中的分区`1`，请运行以下命令：
- en: '[PRE64]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Expect an output like the one shown here:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 期望输出如下所示：
- en: '![](img/9dd71100-be1f-4d1c-b3aa-06094d47fe58.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9dd71100-be1f-4d1c-b3aa-06094d47fe58.png)'
- en: The output will end with a timeout exception since we stop the command by specifying
    a timeout for the command of `1000` ms.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将以超时异常结束，因为我们通过指定命令的超时为`1000`毫秒来停止命令。
- en: 'Bring down the microservice landscape with the following command:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令关闭微服务景观：
- en: '[PRE65]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, we have learned how Spring Cloud Stream can be used to switch a message
    broker from RabbitMQ to Kafka without requiring any changes in the source code.
    It just requires a few changes in the Docker Compose file.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学会了如何使用Spring Cloud Stream将消息代理从RabbitMQ切换到Kafka，而不需要对源代码进行任何更改。它只需要在Docker
    Compose文件中进行一些更改。
- en: Running automated tests of the reactive microservice landscape
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行反应式微服务景观的自动化测试
- en: 'To be able to run tests of the reactive microservice landscape automatically
    instead of manually, the automated `test-em-all.bash` test script has been enhanced.
    The most important changes are as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够自动运行反应式微服务景观的测试而不是手动运行，已增强了自动化的`test-em-all.bash`测试脚本。最重要的更改如下：
- en: 'The script uses the new `health` endpoint to know when the microservice landscape
    is operational, as shown here:'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本使用新的`health`端点来知道微服务景观何时可操作，如下所示：
- en: '[PRE66]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The script has a new `waitForMessageProcessing()` function, which is called
    after the test data is set up. Its purpose is simply to wait for the creation
    of the test data to be completed by the asynchronous create services.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本有一个新的`waitForMessageProcessing()`函数，在设置完测试数据后调用。它的目的只是等待异步创建服务完成测试数据的创建。
- en: 'To use the test script to automatically run the tests with RabbitMQ and Kafka,
    perform the following steps:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用测试脚本自动运行带有RabbitMQ和Kafka的测试，请执行以下步骤：
- en: 'Run the tests using the default Docker Compose file, that is, with RabbitMQ
    without partitions, with the following commands:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用默认的Docker Compose文件运行测试，即使用RabbitMQ而不使用分区，使用以下命令：
- en: '[PRE67]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Run the tests for RabbitMQ with two partitions per topic using the Docker Compose `docker-compose-partitions.yml` file
    with the following commands:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Docker Compose的`docker-compose-partitions.yml`文件运行RabbitMQ的每个主题两个分区的测试，使用以下命令：
- en: '[PRE68]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, run the tests with Kafka and two partitions per topic using the Docker
    Compose `docker-compose-kafka.yml` file with the following commands:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下命令使用Docker Compose的`docker-compose-kafka.yml`文件运行带有Kafka和每个主题两个分区的测试：
- en: '[PRE69]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this section, we have learned how to use the `test-em-all.bash` test script
    to automatically run tests of the reactive microservice landscape that have been
    either configured to use RabbitMQ or Kafka as its message broker.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用`test-em-all.bash`测试脚本自动运行对反应式微服务景观的测试，这些微服务被配置为使用RabbitMQ或Kafka作为其消息代理。
- en: Summary
  id: totrans-469
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how we can develop reactive microservices!
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了如何开发反应式微服务！
- en: Using Spring WebFlux and Spring WebClient, we can develop non-blocking synchronous
    APIs that can handle incoming HTTP requests and send outgoing HTTP requests without
    blocking any threads. Using Spring Data's reactive support for MongoDB, we can
    also access MongoDB databases in a non-blocking way, that is, without blocking
    any threads while waiting for responses from the database. Spring WebFlux, Spring
    WebClient, and Spring Data rely on Spring Reactor to provide their reactive and
    non-blocking features. When we must use blocking code, for example, when using
    Spring Data for JPA, we can encapsulate the processing of the blocking code by
    scheduling the processing of it in a dedicated thread pool.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring WebFlux和Spring WebClient，我们可以开发非阻塞的同步API，可以处理传入的HTTP请求并发送传出的HTTP请求，而不会阻塞任何线程。使用Spring
    Data对MongoDB的响应式支持，我们也可以以非阻塞的方式访问MongoDB数据库，即在等待数据库响应时不会阻塞任何线程。Spring WebFlux、Spring
    WebClient和Spring Data依赖于Spring Reactor来提供它们的响应式和非阻塞特性。当我们必须使用阻塞代码时，例如在使用Spring
    Data进行JPA时，我们可以通过在专用线程池中调度其处理来封装阻塞代码的处理。
- en: We have also seen how Spring Data Stream can be used to develop event-driven
    asynchronous services that work on both RabbitMQ and Kafka as messing systems
    without requiring any changes in the code. By doing some configuration, we can
    use features in Spring Cloud Stream such as consumer groups, retries, dead-letter
    queues, and partitions to handle the various challenges of asynchronous messaging.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了Spring Data Stream如何用于开发基于事件驱动的异步服务，可以在RabbitMQ和Kafka上作为消息系统工作，而不需要对代码进行任何更改。通过进行一些配置，我们可以使用Spring
    Cloud Stream中的功能，如消费者组、重试、死信队列和分区来处理异步消息传递的各种挑战。
- en: We have also learned how to manually and automatically test a system landscape
    consisting of reactive microservices.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何手动和自动测试由响应式微服务组成的系统架构。
- en: This was the final chapter on how to use fundamental features in Spring Boot
    and Spring Framework.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于如何使用Spring Boot和Spring Framework的基本特性的最后一章。
- en: Next up is an introduction to Spring Cloud and how it can be used to make our
    services production-ready, scalable, robust, configurable, secure, and resilient!
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是关于Spring Cloud的介绍，以及如何使用它使我们的服务具备生产就绪、可扩展、健壮、可配置、安全和弹性的特性！
- en: Questions
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why is it important to know how to develop reactive microservices?
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么了解如何开发响应式微服务很重要？
- en: How do you choose between non-blocking synchronous APIs and event/message-driven
    asynchronous services?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在非阻塞同步API和事件/消息驱动的异步服务之间进行选择？
- en: What makes a message different from an event?
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息和事件有什么不同？
- en: Name some challenges with message-driven asynchronous services. How do we handle
    them?
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一些使用基于消息驱动的异步服务的挑战。我们如何处理它们？
- en: Why is the following test failing?
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么以下测试失败了？
- en: '[PRE70]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: What are the challenges of writing tests with reactive code using JUnit, and
    how can we handle them?
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JUnit编写具有响应式代码的测试存在哪些挑战，我们如何处理它们？
