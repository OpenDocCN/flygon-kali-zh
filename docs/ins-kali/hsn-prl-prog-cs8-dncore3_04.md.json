["```cs\nforeach (var trade in trades)\n{\n    Book(trade);\n}\n```", "```cs\nParallel.ForEach(trades, trade => Book(trade));\n```", "```cs\npublic static void Invoke(\n  params Action[] actions\n)\n```", "```cs\ntry\n{\n    Parallel.Invoke(() => Console.WriteLine(\"Action 1\"),\n    new Action(() => Console.WriteLine(\"Action 2\")));\n}\ncatch(AggregateException aggregateException)\n{\n    foreach (var ex in aggregateException.InnerExceptions)\n    {\n        Console.WriteLine(ex.Message);\n    }\n}\nConsole.WriteLine(\"Unblocked\");\nConsole.ReadLine();         \n```", "```cs\nTask.Factory.StartNew(() => {\n     Task.Factory.StartNew(() => Console.WriteLine(\"Action 1\"),        \n     TaskCreationOptions.AttachedToParent);\n     Task.Factory.StartNew(new Action(() => Console.WriteLine(\"Action 2\"))\n                        , TaskCreationOptions.AttachedToParent);\n                        });\n```", "```cs\npublic static ParallelLoopResult For\n{\n    Int fromIncalme,\n    Int toExclusiveme,            \n    Action<int> action\n}\n```", "```cs\nParallel.For (1, 100, (i) => Console.WriteLine(i));\n```", "```cs\nint totalFiles = 0;\nvar files = Directory.GetFiles(\"C:\\\\\");\nParallel.For(0, files.Length, (i) =>\n     {\n       FileInfo fileInfo = new FileInfo(files[i]);\n       if (fileInfo.CreationTime.Day == DateTime.Now.Day)                                                                          \n        Interlocked.Increment(ref totalFiles);\n     });\nConsole.WriteLine($\"Total number of files in C: drive are {files.Count()} and  {totalFiles} files were created today.\");\n```", "```cs\nParallel.ForEach<TSource>(\n    IEnumerable<TSource> Source,                                     \n    Action<TSource> body\n)\n```", "```cs\nList<string> urls = new List<string>() {\"www.google.com\" , \"www.yahoo.com\",\"www.bing.com\" };\nParallel.ForEach(urls, url =>\n{\n    Ping pinger = new Ping();\n     Console.WriteLine($\"Ping Url {url} status is {pinger.Send(url).Status} \n      by Task {Task.CurrentId}\");\n});\n```", "```cs\npublic static ParallelLoopResult For(\n        int fromInclusive,\n        int toExclusive,\n        ParallelOptions parallelOptions,\n        Action<int> body\n)\n```", "```cs\npublic static ParallelLoopResult ForEach<TSource>(\n        IEnumerable<TSource> source,\n        ParallelOptions parallelOptions,\n        Action<TSource> body\n)\n```", "```cs\nParallel.For(1, 20, new ParallelOptions { MaxDegreeOfParallelism = 4 }, index =>\n             {\n                 Console.WriteLine($\"Index {index} executing on Task Id \n                  {Task.CurrentId}\");\n             });\n```", "```cs\nvar items = Enumerable.Range(1, 20); \nParallel.ForEach(items, new ParallelOptions { MaxDegreeOfParallelism = 4 }, item =>\n           {\n               Console.WriteLine($\"Index {item} executing on Task Id \n                {Task.CurrentId}\");\n           });\n```", "```cs\nvar source = Enumerable.Range(1, 100).ToList();\nOrderablePartitioner<Tuple<int,int>> orderablePartitioner= Partitioner.Create(1, 100);\nParallel.ForEach(orderablePartitioner, (range, state) =>\n            {\n              var startIndex = range.Item1;\n              var endIndex = range.Item2;\n              Console.WriteLine($\"Range execution finished on task \n               {Task.CurrentId} with range \n               {startRange}-{endRange}\");\n            });\n```", "```cs\n     var numbers = Enumerable.Range(1, 1000);\n     int numToFind = 2;\n     Parallel.ForEach(numbers, (number, parallelLoopState) =>\n     {\n           Console.Write(number + \"-\");\n           if (number == numToFind)\n           {\n                Console.WriteLine($\"Calling Break at {number}\");\n                parallelLoopState.Break();\n           }\n      });       \n```", "```cs\n            var numbers = Enumerable.Range(1, 1000);\n            Parallel.ForEach(numbers, (i, parallelLoopState) =>\n            {\n                Console.WriteLine($\"For i={i} LowestBreakIteration =     \n                  {parallelLoopState.LowestBreakIteration} and \n                  Task id ={Task.CurrentId}\");\n                if (i >= 10)\n                {\n                    parallelLoopState.Break();\n                }\n            });\n```", "```cs\nvar numbers = Enumerable.Range(1, 1000);\nParallel.ForEach(numbers, (i, parallelLoopState) =>\n         {\n                Console.Write(i + \" \");\n                if (i % 4 == 0)\n                {\n                    Console.WriteLine($\"Loop Stopped on {i}\");\n                    parallelLoopState.Stop();\n                }\n         });\n```", "```cs\nCancellationTokenSource cancellationTokenSource = new CancellationTokenSource();\n```", "```cs\nTask.Factory.StartNew(() =>\n{\n    Thread.Sleep(5000);\n    cancellationTokenSource.Cancel();\n    Console.WriteLine(\"Token has been cancelled\");\n});\n```", "```cs\nParallelOptions loopOptions = new ParallelOptions()\n{\n    CancellationToken = cancellationTokenSource.Token\n};\n```", "```cs\ntry\n{\n    Parallel.For(0, Int64.MaxValue, loopOptions, index =>\n    {\n        Thread.Sleep(3000);\n        double result = Math.Sqrt(index);\n        Console.WriteLine($\"Index {index}, result {result}\");\n    });\n}\ncatch (OperationCanceledException)\n{\n    Console.WriteLine(\"Cancellation exception caught!\");\n}\n```", "```cs\nvar numbers = Enumerable.Range(1, 60);\n```", "```cs\nlong sumOfNumbers = 0;\nAction<long> taskFinishedMethod = (taskResult) => \n{\n    Console.WriteLine($\"Sum at the end of all task iterations for task \n     {Task.CurrentId} is {taskResult}\");\n    Interlocked.Add(ref sumOfNumbers, taskResult);\n};\n```", "```cs\nParallel.For(0,numbers.Count(), \n                         () => 0,\n                         (j, loop, subtotal) =>\n                         {\n                              subtotal += j;\n                              return subtotal;\n                         },\n                         taskFinishedMethod\n);\nConsole.WriteLine($\"The total of 60 numbers is {sumOfNumbers}\");\n```", "```cs\nParallel.ForEach<int, long>(numbers,\n    () => 0, // method to initialize the local variable\n    (j, loop, subtotal) => // Action performed on each iteration\n    {\n        subtotal += j; //Subtotal is Thread local variable\n        return subtotal; // value to be passed to next iteration\n    },\n    taskFinishedMethod);\nConsole.WriteLine($\"The total of 60 numbers is {sumOfNumbers}\");\n```"]