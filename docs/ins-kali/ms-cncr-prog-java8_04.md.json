["```java\npublic class ExecutorStatistics {\n    private AtomicLong executionTime = new AtomicLong(0L);\n    private AtomicInteger numTasks = new AtomicInteger(0);\n```", "```java\n    public void addExecutionTime(long time) {\n        executionTime.addAndGet(time);\n    }\n    public void addTask() {\n        numTasks.incrementAndGet();\n    }\n```", "```java\n    @Override\n    public String toString() {\n        return \"Executed Tasks: \"+getNumTasks()+\". Execution Time: \"+getExecutionTime();\n    }\n```", "```java\npublic class RejectedTaskController implements RejectedExecutionHandler {\n\n    @Override\n    public void rejectedExecution(Runnable task, ThreadPoolExecutor executor) {\n        ConcurrentCommand command=(ConcurrentCommand)task;\n        Socket clientSocket=command.getSocket();\n        try {\n            PrintWriter out = new PrintWriter(clientSocket.getOutputStream(),true);\n\n            String message=\"The server is shutting down.\"\n                +\" Your request can not be served.\"\n                +\" Shutting Down: \"\n                +String.valueOf(executor.isShutdown())\n                +\". Terminated: \"\n                +String.valueOf(executor.isTerminated())\n                +\". Terminating: \"\n                +String.valueOf(executor.isTerminating());\n            out.println(message);\n            out.close();\n            clientSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n```", "```java\npublic class ServerTask<V> extends FutureTask<V> implements Comparable<ServerTask<V>>{\n```", "```java\n    private ConcurrentCommand command;\n```", "```java\n    public ServerTask(ConcurrentCommand command) {\n        super(command, null);\n        this.command=command;\n    }\n\n    public ConcurrentCommand getCommand() {\n        return command;\n    }\n\n    public void setCommand(ConcurrentCommand command) {\n        this.command = command;\n    }\n```", "```java\n    @Override\n    public int compareTo(ServerTask<V> other) {\n        return command.compareTo(other.getCommand());\n    }\n```", "```java\npublic class ServerExecutor extends ThreadPoolExecutor {\n    private ConcurrentHashMap<Runnable, Date> startTimes;\n    private ConcurrentHashMap<String, ExecutorStatistics> executionStatistics;\n    private static int CORE_POOL_SIZE = Runtime.getRuntime().availableProcessors();\n    private static int MAXIMUM_POOL_SIZE = Runtime.getRuntime().availableProcessors();\n    private static long KEEP_ALIVE_TIME = 10;\n\n    private static RejectedTaskController REJECTED_TASK_CONTROLLER = new RejectedTaskController();\n\n    public ServerExecutor() {\n        super(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, new PriorityBlockingQueue<>(), REJECTED_TASK_CONTROLLER);\n\n        startTimes = new ConcurrentHashMap<>();\n        executionStatistics = new ConcurrentHashMap<>();\n    }\n```", "```java\n    protected void beforeExecute(Thread t, Runnable r) {\n        super.beforeExecute(t, r);\n        startTimes.put(r, new Date());\n    }\n```", "```java\n        @Override\n        protected void afterExecute(Runnable r, Throwable t) {\n            super.afterExecute(r, t);\n            ServerTask<?> task=(ServerTask<?>)r;\n            ConcurrentCommand command=task.getCommand();\n\n            if (t==null) {\n                if (!task.isCancelled()) {\n                    Date startDate = startTimes.remove(r);\n                    Date endDate=new Date();\n                    long executionTime= endDate.getTime() - startDate.getTime();\n                                ;\n                    ExecutorStatistics statistics = executionStatistics.computeIfAbsent (command.getUsername(), n -> new ExecutorStatistics());\n                    statistics.addExecutionTime(executionTime);\n                    statistics.addTask();\n                    ConcurrentServer.finishTask (command.getUsername(), command);\n                }\n                else {\n\n                    String message=\"The task\" + command.hashCode() + \"of user\" + command.getUsername() + \"has been cancelled.\";\n                    Logger.sendMessage(message);\n                }\n\n            } else {\n\n                String message=\"The exception \"\n                        +t.getMessage()\n                        +\" has been thrown.\";\n                Logger.sendMessage(message);\n            }\n        }\n    ```", "```java\n    @Override\n    protected <T> RunnableFuture<T> newTaskFor(Runnable runnable, T value) {\n        return new ServerTask<T>(runnable);\n    }\n```", "```java\n    public void writeStatistics() {\n\n        for(Entry<String, ExecutorStatistics> entry: executionStatistics.entrySet()) {\n             String user = entry.getKey();\n             ExecutorStatistics stats = entry.getValue(); Logger.sendMessage(user+\":\"+stats);\n        }\n    }\n```", "```java\npublic abstract class ConcurrentCommand extends Command implements Comparable<ConcurrentCommand>, Runnable{\n```", "```java\n    private String username;\n    private byte priority;\n    private Socket socket;\n\n    public ConcurrentCommand(Socket socket, String[] command) {\n        super(command);\n        username=command[1];\n        priority=Byte.parseByte(command[2]);\n        this.socket=socket;\n\n    }\n```", "```java\n    @Override\n    public abstract String execute();\n\n    @Override\n    public void run() {\n\n        String message=\"Running a Task: Username: \"\n                +username\n                +\"; Priority: \"\n                +priority;\n        Logger.sendMessage(message);\n\n        String ret=execute();\n\n        ParallelCache cache = ConcurrentServer.getCache();\n\n        if (isCacheable()) {\n            cache.put(String.join(\";\",command), ret);\n        }\n\n        try {\n            PrintWriter out = new PrintWriter(socket.getOutputStream(),true);\n            out.println(ret);\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.out.println(ret);\n    }\n```", "```java\n    @Override\n    public int compareTo(ConcurrentCommand o) {\n        return Byte.compare(o.getPriority(), this.getPriority());\n    }\n```", "```java\n    @Override\n    public String execute() {\n        ConcurrentServer.cancelTasks(getUsername());\n\n        String message = \"Tasks of user \"\n                +getUsername()\n                +\" has been cancelled.\";\n        Logger.sendMessage(message);\n        return message;\n    }\n```", "```java\n    @Override\n    public String execute() {\n\n        WDIDAO dao=WDIDAO.getDAO();\n\n        if (command.length==5) {\n            return dao.query(command[3], command[4]);\n        } else if (command.length==6) {\n            try {\n                return dao.query(command[3], command[4], Short.parseShort(command[5]));\n            } catch (NumberFormatException e) {\n                return \"ERROR;Bad Command\";\n            }\n        } else {\n            return \"ERROR;Bad Command\";\n        }\n    }\n```", "```java\n    @Override\n    public String execute() {\n\n        WDIDAO dao=WDIDAO.getDAO();\n        return dao.report(command[3]);\n    }\n```", "```java\npublic class ConcurrentServer {\n    private static ParallelCache cache;\n    private static volatile boolean stopped=false;\n    private static LinkedBlockingQueue<Socket> pendingConnections;\n    private static ConcurrentMap<String, ConcurrentMap<ConcurrentCommand, ServerTask<?>>> taskController;\n    private static Thread requestThread;\n    private static RequestTask task;\n```", "```java\n    public static void main(String[] args) {\n\n        WDIDAO dao=WDIDAO.getDAO();\n        cache=new ParallelCache();\n        Logger.initializeLog();\n        pendingConnections = new LinkedBlockingQueue<Socket>();\n        taskController = new ConcurrentHashMap<String, ConcurrentHashMap<Integer, Future<?>>>();\n        task=new RequestTask(pendingConnections, taskController);\n        requestThread=new Thread(task);\n        requestThread.start();\n\n        System.out.println(\"Initialization completed.\");\n\n        serverSocket= new ServerSocket(Constants.CONCURRENT_PORT);\n        do {\n            try {\n                Socket clientSocket = serverSocket.accept();\n                pendingConnections.put(clientSocket);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } while (!stopped);\n        finishServer();\n        System.out.println(\"Shutting down cache\");\n        cache.shutdown();\n        System.out.println(\"Cache ok\" + new Date());\n\n    }\n```", "```java\n    public static void shutdown() {\n        stopped=true;\n        try {\n            serverSocket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void finishServer() {\n        System.out.println(\"Shutting down the server...\");\n        task.shutdown();\n        System.out.println(\"Shutting down Request task\");\n        requestThread.interrupt();\n        System.out.println(\"Request task ok\");\n        System.out.println(\"Closing socket\");\n        System.out.println(\"Shutting down logger\");\n        Logger.sendMessage(\"Shutting down the logger\");\n        Logger.shutdown();\n        System.out.println(\"Logger ok\");\n        System.out.println(\"Main server thread ended\");\n    }\n```", "```java\n    public static void cancelTasks(String username) {\n\n        ConcurrentMap<ConcurrentCommand, ServerTask<?>> userTasks = taskController.get(username);\n        if (userTasks == null) {\n            return;\n        }\n        int taskNumber = 0;\n\n        Iterator<ServerTask<?>> it = userTasks.values().iterator();\n        while(it.hasNext()) {\n            ServerTask<?> task = it.next();\n             ConcurrentCommand command = task.getCommand();\n              if(!(command instanceof ConcurrentCancelCommand) && task.cancel(true)) {\n                    taskNumber++;\n                    Logger.sendMessage(\"Task with code \"+command.hashCode()+\"cancelled: \"+command.getClass().getSimpleName());\n                    it.remove();\n              }\n        }\n        String message=taskNumber+\" tasks has been cancelled.\";\n        Logger.sendMessage(message);\n    }\n```", "```java\n    public static void finishTask(String username, ConcurrentCommand command) {\n\n        ConcurrentMap<ConcurrentCommand, ServerTask<?>> userTasks = taskController.get(username);\n        userTasks.remove(command);\n        String message = \"Task with code \"+command.hashCode()+\" has finished\";\n        Logger.sendMessage(message);\n\n    }\n```", "```java\npublic class RequestTask implements Runnable {\n    private LinkedBlockingQueue<Socket> pendingConnections;\n    private ServerExecutor executor = new ServerExecutor();\n    private ConcurrentMap<String, ConcurrentMap<ConcurrentCommand, ServerTask<?>>> taskController;\n    public RequestTask(LinkedBlockingQueue<Socket> pendingConnections, ConcurrentHashMap<String, ConcurrentHashMap<Integer, Future<?>>> taskController) {\n        this.pendingConnections = pendingConnections;\n        this.taskController = taskController;\n    }\n```", "```java\n    public void run() {\n        try {\n            while (!Thread.currentThread().interrupted()) {\n                try {\n                    Socket clientSocket = pendingConnections.take();\n                    BufferedReader in = new BufferedReader(new InputStreamReader (clientSocket.getInputStream()));\n                    String line = in.readLine();\n\n                    Logger.sendMessage(line);\n\n                    ConcurrentCommand command;\n\n                    ParallelCache cache = ConcurrentServer.getCache();\n                    String ret = cache.get(line);\n                    if (ret == null) {\n                        String[] commandData = line.split(\";\");\n                        System.out.println(\"Command: \" + commandData[0]);\n                        switch (commandData[0]) {\n                        case \"q\":\n                            System.out.println(\"Query\");\n                            command = new ConcurrentQueryCommand(clientSocket, commandData);\n                            break;\n                        case \"r\":\n                            System.out.println(\"Report\");\n                            command = new ConcurrentReportCommand (clientSocket, commandData);\n                            break;\n                        case \"s\":\n                            System.out.println(\"Status\");\n                            command = new ConcurrentStatusCommand(executor, clientSocket, commandData);\n                            break;\n                        case \"z\":\n                            System.out.println(\"Stop\");\n                            command = new ConcurrentStopCommand(clientSocket, commandData);\n                            break;\n                        case \"c\":\n                            System.out.println(\"Cancel\");\n                            command = new ConcurrentCancelCommand (clientSocket, commandData);\n                            break;\n                        default:\n                            System.out.println(\"Error\");\n                            command = new ConcurrentErrorCommand(clientSocket, commandData);\n                            break;\n                        }\n\n                        ServerTask<?> controller = (ServerTask<?>)executor.submit(command);\n                        storeContoller(command.getUsername(), controller, command);\n                    } else {\n                        PrintWriter out = new PrintWriter (clientSocket.getOutputStream(),true);\n                        out.println(ret);\n                        clientSocket.close();\n                    }\n\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        } catch (InterruptedException e) {\n            // No Action Required\n        }\n    }\n```", "```java\n    private void storeContoller(String userName, ServerTask<?> controller, ConcurrentCommand command) {\n        taskController.computeIfAbsent(userName, k -> new ConcurrentHashMap<>()).put(command, controller);\n    }\n```", "```java\n    public void shutdown() {\n\n        String message=\"Request Task: \"\n                +pendingConnections.size()\n                +\" pending connections.\";\n        Logger.sendMessage(message);\n        executor.shutdown();\n    }\n\n    public void terminate() {\n        try {\n            executor.awaitTermination(1,TimeUnit.DAYS);\n            executor.writeStatistics();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n    }\n```", "```java\npublic class NewsBuffer {\n    private LinkedBlockingQueue<CommonInformationItem> buffer;\n    private ConcurrentHashMap<String, String> storedItems;\n\n    public NewsBuffer() {\n        buffer=new LinkedBlockingQueue<>();\n        storedItems=new ConcurrentHashMap<String, String>();\n    }\n```", "```java\n    public void add (CommonInformationItem item) {\n        storedItems.compute(item.getId(), (id, oldSource) -> {\n              if(oldSource == null) {\n                buffer.add(item);\n                return item.getSource();\n              } else {\n                System.out.println(\"Item \"+item.getId()+\" has been processed before\");\n                return oldSource;\n              }\n            });\n    }\n\n    public CommonInformationItem get() throws InterruptedException {\n        return buffer.take();\n    }\n```", "```java\npublic class NewsWriter implements Runnable {\n    private NewsBuffer buffer;\n    public NewsWriter(NewsBuffer buffer) {\n        this.buffer=buffer;\n    }\n```", "```java\n    public void run() {\n        try {\n            while (!Thread.currentThread().interrupted()) {\n                CommonInformationItem item=buffer.get();\n\n                Path path=Paths.get (\"output\\\\\"+item.getFileName());\n\n                try (BufferedWriter fileWriter = Files.newBufferedWriter(path, StandardOpenOption.CREATE)) {\n                    fileWriter.write(item.toString());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n\n            }\n        } catch (InterruptedException e) {\n            //Normal execution\n        }\n    }\n```", "```java\npublic class NewsTask implements Runnable {\n    private String name;\n    private String url;\n    private NewsBuffer buffer;\n\n    public NewsTask (String name, String url, NewsBuffer buffer) {\n        this.name=name;\n        this.url=url;\n        this.buffer=buffer;\n    }\n```", "```java\n    @Override\n    public void run() {\n        System.out.println(name+\": Running. \" + new Date());\n        RSSDataCapturer capturer=new RSSDataCapturer(name);\n        List<CommonInformationItem> items=capturer.load(url);\n\n        for (CommonInformationItem item: items) {\n            buffer.add(item);\n        }\n    }\n```", "```java\npublic class NewsSystem implements Runnable {\n    private String route;\n    private ScheduledThreadPoolExecutor executor;\n    private NewsBuffer buffer;\n    private CountDownLatch latch=new CountDownLatch(1);\n\n    public NewsSystem(String route) {\n        this.route = route;\n        executor = new ScheduledThreadPoolExecutor (Runtime.getRuntime().availableProcessors());\n        buffer=new NewsBuffer();\n    }\n```", "```java\n    @Override\n    public void run() {\n        Path file = Paths.get(route);\n        NewsWriter newsWriter=new NewsWriter(buffer);\n        Thread t=new Thread(newsWriter);\n        t.start();\n\n        try (InputStream in = Files.newInputStream(file);\n                BufferedReader reader = new BufferedReader(\n                        new InputStreamReader(in))) {\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                String data[] = line.split(\";\");\n\n                NewsTask task = new NewsTask(data[0], data[1], buffer);\n                System.out.println(\"Task \"+task.getName());\n                executor.scheduleWithFixedDelay(task,0, 1, TimeUnit.MINUTES);\n            }\n        }  catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        synchronized (this) {\n            try {\n                latch.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n        System.out.println(\"Shutting down the executor.\");\n        executor.shutdown();\n        t.interrupt();\n        System.out.println(\"The system has finished.\");\n\n    }\n```", "```java\n    public void shutdown() {\n        latch.countDown();\n    }\n```", "```java\npublic class Main {\n\n    public static void main(String[] args) {\n\n        // Creates the System an execute it as a Thread\n        NewsSystem system=new NewsSystem(\"data\\\\sources.txt\");\n\n        Thread t=new Thread(system);\n\n        t.start();\n\n        // Waits 10 minutes\n        try {\n            TimeUnit.MINUTES.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // Notifies the finalization of the System\n         (\n        system.shutdown();\n    }\n```", "```java\npublic class Timer {\n    public static long getPeriod() {\n        Calendar calendar = Calendar.getInstance();\n        int hour = calendar.get(Calendar.HOUR_OF_DAY);\n\n        if ((hour >= 6) && (hour <= 8)) {\n            return TimeUnit.MILLISECONDS.convert(1, TimeUnit.MINUTES);\n        }\n\n        if ((hour >= 13) && (hour <= 14)) {\n            return TimeUnit.MILLISECONDS.convert(1, TimeUnit.MINUTES);\n        }\n\n        if ((hour >= 20) && (hour <= 22)) {\n            return TimeUnit.MILLISECONDS.convert(1, TimeUnit.MINUTES);\n        }\n        return TimeUnit.MILLISECONDS.convert(2, TimeUnit.MINUTES);\n    }\n}\n```", "```java\npublic class ExecutorTask<V> extends FutureTask<V> implements RunnableScheduledFuture<V> {\n    private RunnableScheduledFuture<V> task;\n\n    private NewsExecutor executor;\n\n    private long startDate;\n\n    private String name;\n\n    public ExecutorTask(Runnable runnable, V result, RunnableScheduledFuture<V> task, NewsExecutor executor) {\n        super(runnable, result);\n        this.task = task;\n        this.executor = executor;\n        this.name=((NewsTask)runnable).getName();\n        this.startDate=new Date().getTime();\n    }\n```", "```java\n    @Override\n    public long getDelay(TimeUnit unit) {\n        long delay;\n        if (!isPeriodic()) {\n            delay = task.getDelay(unit);\n        } else {\n            if (startDate == 0) {\n                delay = task.getDelay(unit);\n            } else {\n                Date now = new Date();\n                delay = startDate - now.getTime();\n                delay = unit.convert(delay, TimeUnit.MILLISECONDS);\n            }\n\n        }\n\n        return delay;\n    }\n```", "```java\n    @Override\n    public int compareTo(Delayed object) {\n        return Long.compare(this.getStartDate(), ((ExecutorTask<V>)object).getStartDate());\n    }\n```", "```java\n    @Override\n    public boolean isPeriodic() {\n        return task.isPeriodic();\n    }\n```", "```java\n    @Override\n    public void run() {\n        if (isPeriodic() && (!executor.isShutdown())) {\n            super.runAndReset();\n            Date now=new Date();\n            startDate=now.getTime()+Timer.getPeriod();\n            executor.getQueue().add(this);\n            System.out.println(\"Start Date: \"+new Date(startDate));\n        }\n    }\n```", "```java\npublic class NewsExecutor extends ScheduledThreadPoolExecutor {\u2029\n    public NewsExecutor(int corePoolSize) {\n        super(corePoolSize);\n    }\n\n    @Override\n    protected <V> RunnableScheduledFuture<V> decorateTask(Runnable runnable,\n            RunnableScheduledFuture<V> task) {\n        ExecutorTask<V> myTask = new ExecutorTask<>(runnable, null, task, this);\n        return myTask;\n    }\n}\n```"]