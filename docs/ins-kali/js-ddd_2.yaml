- en: Chapter 2. Finding the Core Problem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。找到核心问题
- en: Every piece of software is written to solve a problem, and in turn is a perfectly
    valid solution for this exact problem. Sadly, the problem a piece of software
    solves so perfectly is not always the problem the software was created for in
    the first place or even the problem the programmer had in mind when the software
    was written. The history of programming is full of examples where developers tried
    various ways to come up with a way to be able to perfectly state a problem first,
    and then implement a solution. Developing software based on the waterfall model
    is a great example of having a nice idea that failed to deliver on the promise.
    When you ask the parties involved about the failure, the reason will most likely
    be that the problem diverged from the specification, or the specification was
    misunderstood in—according to one party—a very obvious way. So, why is this?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每一段软件都是为了解决一个问题而编写的，并且反过来也是这个确切问题的一个完全有效的解决方案。遗憾的是，一段软件完美解决的问题并不总是软件最初创建时的问题，甚至不是程序员在编写软件时所考虑的问题。编程的历史充满了开发人员尝试各种方法来完美陈述问题并实施解决方案的例子。基于瀑布模型开发软件是一个很好的例子，它未能兑现承诺。当你询问参与方失败的原因时，最有可能的原因是问题偏离了规范，或者规范被误解了——根据一方的说法，这是非常明显的。那么，为什么会这样呢？
- en: When starting a software project, especially one motivated by a business need,
    we set out to model a part of the real world and apply a set of constraints and
    algorithms to it, to ease the job of one or more parties involved in the business.
    The problem is that the party that has the issue the developer is trying to solve
    is most likely not the developer. This means that the developer first has to get
    an understanding of what the request really is to actually know what is supposed
    to be developed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始软件项目时，特别是一个由业务需求驱动的项目，我们着手建模现实世界的一部分，并对其应用一组约束和算法，以便简化业务中一个或多个参与方的工作。问题在于，遇到问题的一方很可能不是开发人员。这意味着开发人员首先必须了解请求的真正内容，才能知道应该开发什么。
- en: How can we get a deep enough understanding of a certain part of the business
    without the (most likely) years of experience our clients have ahead of us? The
    solution to this, and the most likely problem, is communication. We need to find
    a way to explore the problem deeply enough, and backed with our knowledge of how
    to model a world in software, to be able to ask the right questions. We need to
    do this in such a way we don't lose the non-technical people so that we can draw
    from their understanding. This comes back to the language mismatch between developers
    and business people, and it is probably the biggest obstacle to overcome. In domain-driven
    design, this is referred to as the **ubiquitous language** of the project, a language
    shared by all parties involved in the project. Establishing this kind of language
    allow us to communicated clearly across team boundaries, and as mentioned before,
    this is one of the core ideas in domain-driven design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在没有客户多年经验的情况下，对业务的某个部分有足够深入的理解？解决这个问题，也是最可能的问题，就是沟通。我们需要找到一种方式，足够深入地探索问题，并结合我们如何在软件中建模世界的知识，以便能够提出正确的问题。我们需要以一种不失去非技术人员的方式来做到这一点，这样我们就可以从他们的理解中汲取经验。这又回到了开发人员和业务人员之间的语言不匹配，这可能是要克服的最大障碍。在领域驱动设计中，这被称为项目的**普遍语言**，这是所有参与项目的各方共享的语言。建立这种语言允许我们在团队边界之间清晰地进行沟通，正如前面提到的，这是领域驱动设计中的核心思想之一。
- en: Coming back to our example of the orcs running a dungeon, we don't know how
    this is done; we don't even completely understand the constraints that cultural
    aspects involve or apply. The world of the orcs is one in which we are an outsider
    who can only watch, ask questions, and model it according to our understanding.
    We naturally have to trust the local experts. Even though we aren't as much of
    an outsider in real-world problems, we should always try to view the problem from
    the outside as much as possible because, in a business that has taken years to
    grow, our own assumptions are probably wrong anyway.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子，兽人在地牢中奔跑，我们不知道这是如何做到的；我们甚至完全不了解文化方面涉及或应用的约束条件。兽人的世界是一个我们只能观察、提问并根据我们的理解来建模的外部世界。我们自然必须信任当地的专家。即使在现实世界的问题中，我们也应该尽可能地从外部视角来看待问题，因为在一个经过多年发展的业务中，我们自己的假设可能是错误的。
- en: 'In the following, we are going to explore the problem and introduce a set of
    tools that will help to do this. We will cover several aspects, but most importantly
    the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨问题并介绍一套工具，这将有助于解决问题。我们将涵盖几个方面，但最重要的是以下几点：
- en: Using pen and paper for programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纸和笔进行编程
- en: Code spikes and throwaway code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码尖峰和一次性代码
- en: Mapping our actors out—creating a dependency graph for our domain
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制我们的角色——为我们的领域创建一个依赖图
- en: Exploring a problem
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索问题
- en: 'There are not many problems in software development that can be fully specified
    easily. Even the few that seem like it leave some room for interpretation. When
    working on a project to implement a database adapter, I recently faced exactly
    this. There was a specification that needed to be implemented, and a set of unit
    tests making sure the implementation conforms to the specification. However, as
    I implemented it, I found myself asking questions along the way. The main question
    was very similar to what I would have asked if I hadn''t had the specification:
    How are people going to use this piece of code? In a lot of cases, there are multiple
    ways to implement a certain feature, but picking one often means weighing different
    tradeoffs against each other, such as speed, extensibility, and readability.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，很少有问题可以很容易地完全规定。即使有些问题看起来可以，也会留下一些解释的空间。最近在实施数据库适配器项目时，我遇到了这个问题。有一个需要实施的规范，以及一组单元测试，确保实施符合规范。然而，在实施过程中，我发现自己一路上提出了一些问题。主要问题与如果没有规范，我会问的问题非常相似：人们将如何使用这段代码？在许多情况下，有多种实现某个特定功能的方法，但选择一种方法通常意味着权衡不同的折衷方案，比如速度、可扩展性和可读性。
- en: 'In our orc dungeon, we have to ask the same basic question: How is the client
    going to use our software? Sadly, this question by itself will not yield the results
    we have in mind. The problem is that our users don''t know our software. Basically,
    our future users have the same problem we do: they don''t know what the software
    is going to look like when it is finished but can only guess its usage. This really
    is the *catch 22* of software development; thus, so to be successful, we need
    to find a way around this. We as developers need to find a way to make the process
    of development possible to grasp for our future users, and our future users need
    to adapt concepts of the highly descriptive language we use to state intentions
    as clearly as possible.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的兽人地牢中，我们必须问同样的基本问题：客户将如何使用我们的软件？遗憾的是，单凭这个问题本身不会得到我们心目中的结果。问题在于我们的用户不了解我们的软件。基本上，我们的未来用户和我们一样有同样的问题：他们不知道软件完成后会是什么样子，只能猜测它的用途。这真的是软件开发的*进退两难*；因此，为了成功，我们需要找到一个解决办法。作为开发人员，我们需要找到一种方法，使未来用户能够理解开发过程，而我们的未来用户需要适应高度描述性语言的概念，以尽可能清晰地陈述意图。
- en: Software is really an abstract concept, and most people are not used to talking
    about abstract things. So, the first step toward a better understanding is to
    make it more approachable for the users. We need to make the concepts *touchable*;
    this can be done in various ways, but the more haptic the better.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 软件实际上是一个抽象的概念，大多数人不习惯谈论抽象的东西。因此，更好理解的第一步是使其对用户更加可接近。我们需要使概念变得*可触摸*；这可以通过各种方式实现，但越触觉越好。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Use paper. As developers, we often prefer to go paperless, but writing things
    on paper makes it easier for most people to understand concepts, so writing things
    down can be immensely helpful.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纸张。作为开发人员，我们经常更喜欢无纸化，但将事物写在纸上可以使大多数人更容易理解概念，因此写下来可以极大地帮助。
- en: Outlining the problem
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述问题
- en: As far as techniques to illustrate and organize pieces of information go, *outlining*
    proves useful in many cases. But, how can we outline software? The idea is to
    keep all the information that comes up when talking to the business experts in
    an easily searchable format. In a lot of places, this is a *wiki*, but it can
    also just be a set of shared text files that are readily accessible whenever information
    needs to be added or retrieved. Outlining here means to store information nested
    by topic and drill down as needed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就说明和组织信息的技术而言，*大纲*在许多情况下都很有用。但是，我们如何为软件制定大纲呢？这个想法是将与业务专家交谈时出现的所有信息以易于搜索的格式保存下来。在许多地方，这是一个*维基*，但也可以只是一组共享的文本文件，可以随时添加或检索信息。这里的大纲意味着按主题嵌套存储信息，并根据需要进行深入。
- en: Tracking knowledge
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 知识跟踪
- en: When starting with collecting information, the most important part is to collect
    as much information as possible, and to do this it needs to be made seamless.
    It is also important to keep the information organized to be added to as well
    as to be restructured as needed. As with our software, we don't know the structure
    of the outline to start out with, so we just add a new piece whenever we identify
    a new entity, actor, or any important piece of the system. Therefore, don't invest
    too much time making the current structure perfect, but rather make it just good
    enough for now.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始收集信息时，最重要的部分是尽可能收集尽可能多的信息，为此需要使其无缝。保持信息有序添加和根据需要重组也很重要。与我们的软件一样，我们不知道大纲的结构从何开始，所以每当我们识别出一个新的实体、角色或系统的任何重要部分时，我们就添加一个新的部分。因此，不要花太多时间使当前结构完美，而是使其足够好。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make a habit of collecting any information that you come across, and keep the
    application outline at hand. In a lot of companies, the hallway track is often
    an immensely valuable source of information, so make sure to use it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 养成收集所遇到的任何信息的习惯，并随时保持应用程序大纲。在许多公司，走廊交流通常是一个非常宝贵的信息来源，所以一定要好好利用它。
- en: What makes an outline so useful is that you will be able to restructure it easily,
    and this is also what you should aim for when deciding on the tool to keep these
    outlined notes. Reordering notes needs to be quick and intuitive. The goal right
    now is to keep the cost of change as low as possible, so we can easily explore
    different paths.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大纲如此有用的原因在于你可以轻松地重新构建它，这也是你在决定保留这些大纲笔记的工具时应该追求的目标。重新排序笔记需要快速和直观。目前的目标是尽可能降低变更成本，这样我们就可以轻松地探索不同的路径。
- en: 'Our dungeon information that we collected so far can be represented like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们收集的地牢信息可以这样表示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The important part is that this structure is very easy to modify and keep up-to-date
    as new information arrives, and we can already see that a new entity emerges from
    the outline—the prisoner. With this new information, we now add this to the outline
    to have a place to hold more information about prisoners, since they are obviously
    a vital concept to our dungeon application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，这种结构非常容易修改和随着新信息的到来保持最新，我们已经可以看到大纲中出现了一个新的实体——囚犯。有了这些新信息，我们现在将其添加到大纲中，以便有一个地方来保存更多关于囚犯的信息，因为他们显然是我们地牢应用程序中的一个重要概念。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is essentially what the outline is about, recording information and drawing
    quick conclusions.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上就是大纲的内容，记录信息并得出快速结论。
- en: The medium
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 媒介
- en: Depending on the situation, different mediums are possible or preferable to
    hold the information. This can stretch from a piece of paper up to a full-blown
    wiki system. The format I prefer to use for my outlines is **Markdown**, which
    has the advantage of being stored as plain text and being very readable without
    being processed. Also, to generate some documentation to print out, it is useful
    to process it to HTML first. This is by no means the ultimate choice, and you
    should choose whatever feels the most natural, as long as it is simple to edit
    and readily available in as many places as possible. The one thing that is important,
    is to choose a system that does not lock you in to its way of doing things or
    as into a data format that is hard to export or change.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 根据情况，可能或者更好的是使用不同的媒介来保存信息。这可以从一张纸到一个完整的维基系统。我喜欢用于大纲的格式是Markdown，它的优势在于以纯文本形式存储，并且在未经处理的情况下非常易读。此外，为了生成一些要打印的文档，将其先处理成HTML是很有用的。这绝不是最终选择，你应该选择任何感觉最自然的东西，只要它简单易编辑，并且在尽可能多的地方都可以读取。重要的是选择一个不会将你限制在其做事方式或难以导出或更改的数据格式中的系统。
- en: Paper programming
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纸上编程
- en: In our quest to involve non-programmers in the process of software creations,
    it is important to make concepts approachable. We need to illustrate interactions
    as well as actors of the system and make them ready to be moved around. Often,
    it helps to have something people can actually hold in their hand and move across
    a table when talking about a subject. The best way to achieve this is to create
    paper representations of the elements of the system. Create a paper-based, hand-operated
    version to touch and interact with right there and then. This is often known from
    UI design, where paper prototypes are a common thing, but it also works well to
    create a version of non-UI parts of the application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们努力让非程序员参与软件创建的过程中，重要的是让概念易于理解。我们需要说明系统的交互以及参与者，并使它们准备好被移动。通常，当谈论一个主题时，让人们实际拿在手上并在桌子上移动的东西是有帮助的。实现这一点的最佳方法是创建系统元素的纸质表示。创建一个基于纸张、手动操作的版本，可以立即触摸和交互。这通常是UI设计中所知的，纸质原型是一件常见的事情，但它也很适合创建应用程序非UI部分的版本。
- en: The idea is to draw out any pieces of the system on cards to be combined, separated,
    and added to. When this is done, it often ends up being pretty close to the entity
    representation we will later have in the system. When starting out using this
    technique, it is important to note that the end result will always be in a certain
    state. As things get moved across the table, and elements are modified, we need
    to keep track of the information that is generated. Make sure to keep notes along
    the lines of how certain actions evolved during the discussion as a single picture
    of the end result is just reflecting one state.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是将系统的任何部分绘制在卡片上，以便组合、分离和添加。当这样做时，它通常最终会非常接近我们将来在系统中拥有的实体表示。开始使用这种技术时，重要的是要注意最终结果总是处于某种状态。当事物在桌子上移动，元素被修改时，我们需要跟踪生成的信息。确保记下在讨论过程中某些行动是如何发展的，因为最终结果的单一图片只是反映了一个状态。
- en: So how does such a paper program work?
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 那么这样的纸质程序是如何工作的？
- en: 'When starting out, we lay out all the information we currently have, drawing
    out boxes for all the elements, and name them. In our case, we will draw out the
    dungeon, prisoners, cells, and a transport. For now, these are the entities we
    interact with. At this point, we think about a specific interaction and try to
    represent it with the entities and other objects we currently have. Let''s transfer
    a prisoner from our dungeon into another; to do this, we need to think what we
    have to do:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，我们列出我们目前拥有的所有信息，为所有元素绘制出方框，并为它们命名。在我们的情况下，我们将绘制地牢、囚犯、牢房和一个运输工具。目前，这些是我们要交互的实体。在这一点上，我们考虑一个具体的交互，并尝试用我们目前拥有的实体和其他对象来表示它。让我们将一个囚犯从我们的地牢转移到另一个地牢；为了做到这一点，我们需要考虑我们必须做什么：
- en: The dungeon keeper notifies the other dungeon
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地牢管理员通知其他地牢
- en: The prisoner is transferred from a cell onto the transport
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 囚犯从牢房转移到运输工具上
- en: An orc is assigned to guard the transport
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个兽人被指派守卫运输
- en: The transport travels to the other dungeon
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运输到达其他地牢
- en: 'When drawn it out on a sheet of paper, the result may look a little like this,
    where the numbers are the order in which the steps appeared:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当在一张纸上绘制出来时，结果可能看起来有点像这样，其中数字是步骤出现的顺序：
- en: '![So how does such a paper program work?](graphics/B03704_02_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![那么这样的纸质程序是如何工作的？](graphics/B03704_02_01.jpg)'
- en: At this point, we already notice that multiple pieces are missing, mainly the
    dungeon keeper and some way to notify the other dungeon. So, how can these be
    added? The dungeon keeper clearly is an entity that manages the dungeon, so a
    separate card should be added. Also, the notification is done via messages, so
    we add a messaging system. This is a new subsystem, but we can for now consider
    it a black box we can drop messages into have them arrive at the other side.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经注意到缺少多个部分，主要是地牢管理员和通知其他地牢的方式。那么，如何添加这些呢？地牢管理员显然是管理地牢的实体，因此应该添加一个单独的卡片。此外，通知是通过消息完成的，因此我们添加一个消息系统。这是一个新的子系统，但我们现在可以将其视为一个黑匣子，我们可以将消息放入其中，让它们到达另一侧。
- en: 'Now that the systems are in place, we can add the needed methods to the actors
    of our system: The dungeon keeper, to request a transfer, needs a way to send
    a message; the cell needs to give up the *ownership* of the prisoner; the transport
    needs to take ownership; and so on. As we move through this interaction we can
    clearly see one possible way this can be modeled and this is also more approachable
    for non-developers as they see actual boxes moving across the table. As this model
    is in constant flux, make sure to keep notes in your outline along the way, to
    not lose any of the newly acquired information.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在系统已经就位，我们可以为系统的参与者添加所需的方法：地牢管理员需要一种发送消息的方式来请求转移；单元需要放弃囚犯的*所有权*；运输需要接管；等等。随着我们进行这种交互，我们可以清楚地看到这可以被建模的一种可能方式，这对非开发人员来说也更容易接近，因为他们可以看到实际的盒子在桌子上移动。由于这个模型不断变化，请确保在沿途保留大纲中的注释，以免丢失任何新获得的信息。
- en: Not so scary UML
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不那么可怕的UML
- en: Our paper, a prototype, gives us a nice picture of the interaction, and our
    outline captures a lot of information about how the program should behave in various
    cases. It also captures details on the naming side of things from a business perspective.
    All in all, this gives us a lot of good insight, but there is still a part missing.
    This makes the information out of our paper prototype durable enough, so we can
    more easily reference it as we move along. The prototype we drew earlier is missing
    some information that is important to the implementation. We need to capture more
    of the structure of the application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的论文原型为我们提供了交互的良好图像，我们的大纲捕捉了关于程序在各种情况下应该如何行为的大量信息。它还从业务角度捕捉了命名方面的细节。总的来说，这给了我们很多有益的见解，但仍然有一部分缺失。这使得我们的纸质原型的信息足够持久，因此我们可以更容易地在移动过程中参考它。我们之前绘制的原型缺少了一些对实施重要的信息。我们需要捕捉更多应用程序结构的信息。
- en: 'This is the point where **Unified Modelling Language** (**UML**) comes into
    play, yes this scary piece of waterfall-infused practice that most of us never
    thought of as being useful. When talking about UML is it often referenced as the
    idea to encode all modeling information in a diagram; so ultimately code could
    be generated and filled out by basically everybody with some amount of coding
    skills. Of course, this does not work, but UML still has some interesting properties
    that make it useful. What we are setting out to do is leveraging one property
    of UML, and this is the ability to capture interactions in a concise form. UML
    defines multiple categories of diagrams:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是**统一建模语言**（**UML**）发挥作用的地方，是的，这个充满瀑布注入实践的可怕东西，大多数人从未想过它有用。谈论UML时，通常会提到将所有建模信息编码在图表中的想法；因此，最终可以由基本上具有一定编码技能的每个人生成代码并填写。当然，这是行不通的，但UML仍具有一些有趣的属性，使其有用。我们要做的是利用UML的一个属性，即捕捉交互的能力。UML定义了多个类别的图表：
- en: Structure diagrams
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构图
- en: Behavior diagrams
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为图
- en: Interaction diagrams
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互图
- en: A **structure diagram** focuses mostly on the actors in the system and their
    relationships. In our case, it would express the relationship of the keeper toward
    the dungeon and other orcs for example. This can be helpful when many actors are
    involved, but is not necessarily the most important information to start out with.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构图**主要关注系统中的参与者及其关系。在我们的情况下，它将表达管理员与地牢和其他兽人之间的关系。当涉及许多参与者时，这可能会有所帮助，但不一定是开始时最重要的信息。'
- en: '![Not so scary UML](graphics/B03704_02_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![不那么可怕的UML](graphics/B03704_02_02.jpg)'
- en: A use case diagram gives a slightly more detailed picture of the actors in the
    system, and their interaction with each other. A use case diagram is part of the
    behavior diagram family and therefore focuses on the behaviors of the actors.
    This is not only useful information for our system, but also too coarse grained
    at the moment to express the flow of information and actions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 用例图提供了系统中参与者的略微更详细的图像，以及他们之间的互动。用例图是行为图系列的一部分，因此侧重于参与者的行为。这不仅是对我们的系统有用的信息，而且在目前来说也太粗粒度，无法表达信息和行动的流程。
- en: '![Not so scary UML](graphics/B03704_02_03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![不那么可怕的UML](graphics/B03704_02_03.jpg)'
- en: 'As our feature does involve interaction between the defined actors of our system,
    a useful thing to explore is the sequence of events as they happen in our system.
    For this, we can use a sequence diagram, which is a type of interaction diagram
    in UML. This kind of diagram focuses on the sequence of events that need to happen
    to achieve a certain goal. Some of this may be asynchronous, some needs to await
    a response; all this is captured in a single diagram:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的功能涉及系统中定义的参与者之间的交互，一个有用的探索对象是事件在系统中发生的顺序。为此，我们可以使用序列图，这是UML中的一种交互图。这种图表侧重于实现特定目标所需的事件顺序。其中一些可能是异步的，有些需要等待响应；所有这些都在一个图表中捕捉到：
- en: '![Not so scary UML](graphics/B03704_02_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![不那么可怕的UML](graphics/B03704_02_04.jpg)'
- en: With this kind of illustration, it is easy to distinguish between synchronous
    and asynchronous messaging, so we can be sure to model the methods accordingly.
    Also, naming things is known as one of the hardest problems of computer science,
    so be sure to show this to your domain experts to draw from their language to
    name the now exposed messages and methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种插图，很容易区分同步和异步消息，因此我们可以确保相应地对方法进行建模。此外，命名事物被认为是计算机科学中最困难的问题之一，因此一定要向领域专家展示这一点，以便从他们的语言中命名现在暴露出来的消息和方法。
- en: So far, the idea of every part has been to have the tools to explore the problem
    from different view perspectives, but don't drink too much of the Kool-Aid! We
    don't try to create a complete description of the whole system, but rather explore
    one part just deeply enough so that we can get a sense of what its core functionality
    is going to be and how it makes sense to implement it. We can then remove the
    uncertainties, by asking the right questions as we know the domain well enough
    so that we are able to explore the business domain together with the experts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，每个部分的想法都是拥有工具来从不同的视角探索问题，但不要过分相信！我们不试图创建整个系统的完整描述，而是深入探索一个部分，以便我们能够了解其核心功能以及如何实现它。然后，通过提出正确的问题来消除不确定性，因为我们对领域了解足够，以便与专家一起探索业务领域。
- en: Involving the experts
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涉及专家
- en: As we explore the domain from every angle, it is important to talk to the people
    who know as much as one can about it. One of the core ideas of domain-driven design
    is to create a language around the domain that can be spoken by each party involved.
    When talking about the tools, we set out to create them in such a way developers
    as well as domain experts can take part on an equal footing, so each can draw
    from the other's knowledge to approach a problem.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从各个角度探索领域时，与尽可能多了解它的人交谈是很重要的。领域驱动设计的核心思想之一是创建一个可以被每个参与方使用的领域语言。在谈论工具时，我们设定了以这样一种方式来创建它们，使得开发人员和领域专家都能够平等参与，这样每个人都可以从对方的知识中解决问题。
- en: The spoken language is a problem in itself, so for developers it needs to be
    as unambiguous as possible, because very concrete and specific ideas need to be
    expressed. There should be no room for misinterpretation. For business people,
    on the other hand, it needs to be understandable for such a non-technical audience.
    Now comes the important part, where we actually are going to see whether we have
    achieved this goal so far, and how we are able to communicate the ideas of the
    domain back and forth.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 口语本身就是一个问题，因此对于开发人员来说，它需要尽可能明确，因为需要表达非常具体和具体的想法。不应该有误解的余地。另一方面，对于业务人员来说，它需要对非技术观众来说是可理解的。现在来到了重要的部分，我们实际上将看到我们迄今为止是否已经实现了这个目标，以及我们如何能够来回沟通领域的想法。
- en: When involving the experts of a domain, we should first have a clear idea of
    what we are trying to achieve, such as gaining knowledge about the system we are
    currently developing. It is a natural tendency for developers to make their system
    shine in the best light, but our goal is to expose misunderstandings and uncertainties
    in our design and understanding so far. We actually want to get caught *off-guard*,
    so to speak. For the current stage of the project, this should be considered an
    achievement. Right now, change is as cheap as it is going to get, so if we expose
    a certain gap in our knowledge, we make our lives easier down the road. Getting
    a misunderstanding exposed right now also means that we were able to ask all the
    right questions such that we were able to communicate this abstract idea of a
    software system successfully; thus, the business side was able to dive into our
    system and correct the flaws. If we get to this point, non-developers are actually
    involved in the development and we can move forward developing a very well-suited
    system. So, how do we get there?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及领域专家时，我们应该首先清楚地知道我们试图实现什么，比如获取关于我们目前正在开发的系统的知识。开发人员往往会让他们的系统展现出最好的一面，但我们的目标是暴露我们设计和理解中的误解和不确定性。实际上，我们希望被“出其不意”，可以这么说。对于项目当前阶段来说，这应该被视为一个成就。现在，改变的成本是最低的，所以如果我们暴露了我们知识中的某个空白，我们以后的生活会更轻松。现在暴露一个误解也意味着我们能够提出所有正确的问题，以便成功地沟通这个软件系统的抽象概念；因此，业务方面能够深入了解我们的系统并纠正缺陷。如果我们达到了这一点，非开发人员实际上参与了开发，我们可以继续开发一个非常合适的系统。那么，我们如何才能做到这一点呢？
- en: Finding the gaps
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 找到空白
- en: The first thing we now have to do is to start the conversation flowing. As with
    most problems, it is best to think about them in a diverse group, so we get the
    most viewpoints. To get there, we want to create an environment where the business
    domain experts can explain to us what is going on. We can use all the different
    techniques now to talk about our software in an accessible fashion. The idea of
    paper programming can come in very handy at this stage.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在要做的第一件事是开始对话。与大多数问题一样，最好是在一个多元化的团队中思考，这样我们可以得到最多的观点。为了达到这个目标，我们希望创造一个环境，让业务领域的专家向我们解释发生了什么。我们现在可以使用各种不同的技术来以易于理解的方式谈论我们的软件。纸上编程的想法在这个阶段非常有用。
- en: So first we need to prepare, make sure all the units that have been identified
    are prepared. Have cards ready for everybody to move around and write on them
    as the actions are illustrated and gaps are identified in the knowledge. It is
    also helpful to take a picture of the current state with notes attached to save
    the state for later reference as the ideas evolve. The conversation can start
    out with the developers explaining how they think the system works, encouraging
    the business experts to interject whenever there is something unclear or just
    plain wrong. This can really become a kind of game. How can an action we want
    to express be expressed with the pieces available? Of course, this is not a puzzle,
    so you are able to create new pieces at will and change them as needed. Being
    guided through the process in such a way will most likely expose several valuable
    properties in the system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所以首先我们需要准备，确保所有已经确定的单位都做好准备。为每个人准备好卡片，让他们四处移动并在上面写下行动，同时识别出知识中的空白。将当前状态拍照并附上注释以保存状态以供以后参考，因为想法在演变。对话可以从开发者解释他们认为系统如何工作开始，鼓励业务专家在有不清楚或错误的地方插话。这可能真的成为一种游戏。我们如何用现有的部分表达我们想要表达的行动？当然，这不是一个拼图游戏，所以你可以随意创建新的部分并根据需要更改它们。以这种方式引导通过过程很可能会暴露出系统中的几个有价值的属性。
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Being precise is what it is all about; make sure to ask questions such as *And
    this is how it is done 100% of the time?* as often as possible.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 准确是最重要的；务必尽可能多地提出诸如“这是100%的时间都是这样做的吗？”这样的问题。
- en: 'So, let''s walk through an example feature of our software: transferring a
    prisoner to another dungeon.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过一个软件功能的示例来走一遍：将囚犯转移到另一个地牢。
- en: Talking business
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谈论业务
- en: 'The process of transferring a prisoner has been described in three steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 囚犯转移的过程已经被描述为三个步骤：
- en: The dungeon keeper notifies the other dungeon.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地牢管理员通知另一个地牢。
- en: The prisoner is transferred from a cell onto the transport.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 囚犯从牢房转移到运输工具上。
- en: The transport travels to the other dungeon.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运输到达另一个地牢。
- en: 'So, we have some cards prepared:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们准备了一些卡片：
- en: The notification service identified by an envelope
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由信封识别的通知服务
- en: The dungeon cell
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地牢牢房
- en: The prisoner
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 囚犯
- en: The transport
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运输工具
- en: With the available cards, we can let the orc master describe precisely what
    needs to happen when a prisoner is transferred.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有了可用的卡片，我们可以让兽人大师准确描述囚犯转移时需要发生的事情。
- en: The orc master identifies the problem, as follows, and sends out a raven with
    the notification of the transfer request to the dungeon. He then goes to the cell
    to move the prisoner out and on to the transport, assigning an orc to guard the
    transport and sending it off to the other dungeon.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 兽人大师确定了问题，并发送了一只乌鸦通知地牢转移请求。然后他去牢房将囚犯移出并送上运输工具，指派一名兽人守卫运输工具并将其送往另一个地牢。
- en: In this short description, we see multiple differences from our model that need
    to be addressed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的描述中，我们看到了与我们的模型有多处不同之处需要解决。
- en: The order of one and two does not actually matter, as long as there is at least
    one prisoner in the dungeon, which we can check at notification time.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1和2的顺序实际上并不重要，只要地牢中至少有一个囚犯，我们就可以在通知时进行检查。
- en: There is going to be another scarce resource involved, and these are the guards
    to man the transport; they need to be available, and their flow in and out will
    need to be tracked.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还会涉及到另一个稀缺资源，那就是押送囚犯的卫兵；他们需要可用，并且他们的进出需要被跟踪。
- en: Given the new insights, we can now model this event as actors in our system
    pretty accurately. It is important to note that our system of course does not
    need to represent the flow directly in code but, from a high-level point of view,
    having a consistent flow makes sense since it has established itself through (possibly)
    years of practical use. Thus, it is at least a good point to start after all.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有了新的见解，我们现在可以相当准确地将这个事件建模为我们系统中的演员。重要的是要注意，当然，我们的系统不需要直接在代码中表示流程，但从高层次来看，有一个一致的流程是有意义的，因为它可能已经通过（可能）多年的实际使用而被确立。因此，至少从某种程度上来说，这是一个很好的起点。
- en: Talking about the actors
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谈论演员
- en: When talking about how to implement a certain feature, several forms of objects
    are involved, all of which have certain distinct roles in the system. A lot of
    these roles exist in many systems, even though they may be named differently.
    In a domain-driven design, the classification of these roles makes a big difference.
    The reason is that, if we classify something, there is a certain set of patterns
    that can be applied right away, since it has proven itself to be useful. This
    is very similar to the idea of naming the patterns that have emerged in enterprise
    applications and are by now almost basic knowledge to most application developers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论如何实现某个功能时，涉及到多种形式的对象，它们在系统中扮演着不同的角色。许多系统中存在这些角色，尽管它们可能有不同的名称。在领域驱动设计中，对这些角色的分类有很大的影响。原因在于，如果我们对某物进行分类，就可以立即应用一定的模式，因为它已经被证明是有用的。这与命名企业应用程序中出现的模式的想法非常相似，现在几乎已经成为大多数应用程序开发人员的基本知识。
- en: 'In domain-driven design, we have multiple building blocks to choose from:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域驱动设计中，我们有多个可供选择的构建模块：
- en: Entity
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体
- en: Value object
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 价值对象
- en: Aggregate
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合
- en: Domain event
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域事件
- en: Service
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Repository
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库
- en: Factory
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂
- en: 'Most of the elements in this list probably make sense to you as a developer
    already but, if not, we are going to define each of these more explicitly later.
    For now, let''s focus on the ones we need and we are already using in the system:
    aggregate, value-object, and domain events.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表中的大部分元素可能对开发者来说已经很清楚了，但如果不清楚，我们稍后会更明确地定义每一个。现在，让我们专注于我们需要的并且已经在系统中使用的部分：聚合、值对象和领域事件。
- en: One important distinction is the difference between an entity and a value object.
    While an entity is defined by its identity, a value object is defined by its properties.
    Going back to our prisoners and cells, we can see that it is possible to use either
    classification, but it changes the focus. If a prisoner is an entity, each prisoner
    is clearly defined, and two prisoners will always be different. Classifying them
    like this makes prisoners traceable throughout the system, as they move from dungeon
    to dungeon and cell to cell. This may be really useful, but may be an overkill
    as well. This is what the current stage is all about—finding the focus of the
    project from a domain point of view. So let's walk through the whole process step
    by step.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的区别是实体和值对象之间的区别。实体由其身份定义，而值对象由其属性定义。回到我们的囚犯和牢房，我们可以看到可以使用任一分类，但它会改变焦点。如果囚犯是一个实体，每个囚犯都清楚地定义，两个囚犯将始终不同。这样对他们进行分类使得囚犯在整个系统中可追踪，因为他们从一个地牢到另一个地牢，从一个牢房到另一个牢房。这可能非常有用，但也可能过度。这就是当前阶段的全部内容——从领域角度找到项目的焦点。所以让我们一步一步地走完整个过程。
- en: 'Starting from the outside in, we first have to think about our domain event.
    As the name suggests, this is the event that triggers a certain reaction by the
    domain; in our case, this is the transfer of prisoners. To handle the events,
    we have to move one level down and think about the parts of our system that handle
    the transactions on our resources, the aggregates. They are, so to speak, the
    actors in the system as they aggregate all the needed entities, value objects,
    and everything else needed to present a consistent view to the outside world.
    Aggregates are also responsible for changing the state of the world in our system
    according to the domain''s need. As far as aggregates go, there are multiple ones
    that are responsible for the action: the dungeon keeper managing cells, prisoners,
    and keepers, as well as the transport being a mobile cell, the prisoner, and the
    keeper. Notifications to other dungeon live somewhat outside the system, so classifying
    these as a service seems like the natural thing to do. OK, this wasn''t too hard,
    and thinking about the classification of different object is quite natural.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从外到内开始，我们首先要考虑我们的领域事件。顾名思义，这是触发领域特定反应的事件；在我们的情况下，这是囚犯的转移。为了处理这些事件，我们必须向下移动一级，考虑处理我们资源交易的系统部分，即聚合。它们可以说是系统中的行为者，因为它们聚合了所有需要的实体、值对象和其他一切，以向外界呈现一致的视图。聚合还负责根据领域的需要改变系统中的世界状态。就聚合而言，有多个聚合负责这个动作：管理牢房、囚犯和看守的地牢管理员，以及作为移动牢房的交通工具，囚犯和看守。通知其他地牢的服务有点超出系统范围，因此将其分类为服务似乎是自然的事情。好吧，这并不太难，思考不同对象的分类是相当自然的。
- en: Using the provided domain terms lets us state the intended focus and level of
    the parts clearly. Other developers, even if they are unfamiliar with the system,
    are now able to assume a given feature set from each named entity. For us, the
    naming is a form of documentation that allows us to notice quickly when we start
    to intermix concepts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用提供的领域术语让我们清楚地说明部分的关注和级别。其他开发人员，即使他们对系统不熟悉，现在也能够假定每个命名实体的特定功能集。对我们来说，命名是一种文档形式，可以让我们在开始混合概念时迅速注意到。
- en: Identifying the hard problem
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定难题
- en: Over the last sections, we started to gain a solid understanding of the interactions
    in the system. Now it is time to leverage this understanding and move on to implementing
    our software solution. So, what should we start with when developing the software?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几节中，我们开始对系统中的交互有了很清晰的理解。现在是时候利用这种理解，继续实施我们的软件解决方案。那么，在开发软件时我们应该从哪里开始呢？
- en: Often when a project is started, we like to start with the easy part, maybe
    create a project from a template—for example, running a framework code generator,
    such as Node.js Express, in a new folder to set us up with the scaffold structure
    for our project. At first, this seems like a really good option as it creates
    a lot of the boilerplate code we would have to write to create an Express project
    otherwise. But, does it move use closer to solving a business problem? We now
    have a code base to explore but, as it is auto-generated, we don't have any domain-specific
    code obviously. On the other hand, we have locked ourselves in a fixed structure.
    For some projects, this is a good thing; it means that there are fewer things
    to think about. However, if we try to solve a lower-level problem, it is arguably
    bad to lock yourself into a certain mindset.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在启动项目时，我们喜欢从简单的部分开始，也许从模板创建一个项目——例如，在一个新文件夹中运行一个框架代码生成器，比如Node.js Express，为我们的项目设置脚手架结构。起初，这似乎是一个非常好的选择，因为它创建了大量我们必须编写的样板代码，以便创建一个Express项目。但是，这是否让我们更接近解决业务问题？现在我们有一个代码库可以探索，但是，由于它是自动生成的，显然没有任何特定于领域的代码。另一方面，我们已经将自己锁定在一个固定的结构中。对于一些项目来说，这是一件好事；这意味着要考虑的事情更少。然而，如果我们试图解决一个较低级别的问题，将自己锁定在某种思维方式中可能是不好的。
- en: We need to identify the problem and determine how to deliver value to the business
    as fast as possible. This will drive user adoption and development of the software
    further. So far, we explored one part of the domain, which seemed important enough
    to our business to explore implementing it as our first feature. Now, it is time
    to drill down into it to see where the core problem lies, seeing the objects that
    will be involved and their interaction with our software.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确定问题，并确定如何尽快为业务提供价值。这将推动用户采用和进一步开发软件。到目前为止，我们已经探索了领域的一部分，这对我们的业务来说似乎很重要，我们探索实施它作为我们的第一个特性。现在，是时候深入研究它，看看核心问题所在，看看将涉及的对象及其与我们的软件的交互。
- en: Mapping the dependencies
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 映射依赖关系
- en: 'From our previous work, we have a pretty clear understanding of the objects
    involved, at least on a high level:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过之前的工作，我们对涉及的对象有了相当清晰的理解，至少在高层次上：
- en: Notification Service
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知服务
- en: Cell
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元
- en: Prisoner
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 囚犯
- en: Keeper
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看守
- en: Orc master
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兽人大师
- en: Transport
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运输
- en: 'With these in mind, our task is now to find a place to start. When laying out
    these objects, it is clear that they all have some dependency on other parts,
    and we can leverage this. We draw up each object, using arrows to demonstrate
    which objects it depends on. This is known as a **dependency graph**:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些想法，我们现在的任务是找到一个开始的地方。当布置这些对象时，很明显它们都与其他部分有一些依赖，我们可以利用这一点。我们绘制每个对象，使用箭头来展示它依赖的对象。这就是所谓的**依赖图**：
- en: '![Mapping the dependencies](graphics/B03704_02_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![映射依赖关系](graphics/B03704_02_05.jpg)'
- en: The graph shows us the dependencies for each of the actors we identified. The
    keeper, for example, is a necessary dependency for the transport as well as the
    orc master. On the other hand, the orc master depends not only on the keeper,
    but also on the transport, prisoner, and cell as well. Looking at the graph, we
    can see in which order the elements need to be implemented. Elements we identified
    as aggregates before are of course going to have the most dependencies. They,
    as their name suggest, aggregate multiple objects into one unit for common access
    and modification.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该图向我们展示了我们确定的每个角色的依赖关系。例如，看守对于运输和兽人大师来说是必要的依赖。另一方面，兽人大师不仅依赖于看守，还依赖于运输、囚犯和牢房。通过查看图表，我们可以看出元素需要以哪种顺序实现。我们之前确定为聚合物的元素当然会有最多的依赖关系。正如它们的名字所暗示的那样，它们将多个对象聚合成一个单元，以便进行共同访问和修改。
- en: 'One way to attack the problem is to start out in the following order:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的一种方法是按以下顺序开始：
- en: Keeper.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看守。
- en: Cell.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 牢房。
- en: Prisoner.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 囚犯。
- en: Transport.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运输。
- en: Notification service.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通知服务。
- en: Orc Master.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 兽人大师。
- en: The nice thing is that, along the way, we can present an intermediate state
    back as soon as one of the aggregates is in working order. We can talk about our
    idea of a transport, and align it with the expected feature for example. The working
    condition is an important point here, since it is really hard for people to judge
    a certain piece if it does not satisfy the requirements in multiple ways. Of course,
    "working condition" does not mean that we actually see something but, as the software
    gets more complex, we are able to use those aggregates to play the role in the
    operations they are designed for. We may, for example, create a quick prototype
    that replays some interactions specified by the business team. This of course
    goes hand in hand with testing and feature acceptance tests or behavior-driven
    development.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好处是，一路上，我们可以在其中一个聚合物处于工作状态时立即呈现中间状态。我们可以谈论我们对运输的想法，并将其与预期的功能对齐。工作状态在这里是一个重要的点，因为如果某个部分在多个方面不满足要求，人们很难判断某个特定部分。当然，“工作状态”并不意味着我们实际上看到了什么，但随着软件变得更加复杂，我们能够使用这些聚合物来发挥它们设计用途中的作用。例如，我们可以创建一个快速原型，重播业务团队指定的一些交互。当然，这与测试和功能验收测试或行为驱动开发是相辅相成的。
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Presenting an intermediate state to the domain experts needs to involve guidance
    on the feature, as well as asking questions along the way. Throwing partially
    implemented software *over the fence* is hardly of any use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 向领域专家展示中间状态需要涉及对功能的指导，以及沿途提出问题。把部分实现的软件“扔过围墙”几乎没有任何用处。
- en: Drawing with code – spiking
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用代码绘制-尖峰
- en: After we now have an idea where to start developing, we can finally explore
    how to actually do it. When we think about the problem, we may have some idea
    how it works, but there are also going to be pieces where, though we know how
    the high level operates, we are unclear about the lower levels. When a developer
    does not know how something will work in reality, the best way to figure out what
    to do is by actually trying it and exploring the libraries and tools that are
    deemed useful along the way.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个开始开发的想法，我们最终可以探索如何实际做到这一点。当我们思考问题时，我们可能对它的运作方式有一些想法，但也会有一些地方，尽管我们知道高层是如何运作的，但我们对低层仍然不清楚。当开发人员不知道某件事在现实中如何运作时，找出该怎么做的最佳方法就是实际尝试并探索在其中途中被认为有用的库和工具。
- en: This approach is referred to as **spiking**. We create a throwaway code, which
    is just there to explore a certain difficult part, without the intention of having
    this code ever make it into production. This frees us from a lot of the intricacies
    that are often involved in creating production-ready code. The code is there just
    to solve a specific case and help us gain knowledge about how to solve the same
    problem later. Most developers know that the first approach is hardly ever the
    perfect solution to a problem, so let's just deal with this fact by creating a
    first version that we intend to throw away. A spike is all about the knowledge
    gain and not about the code, so be ready to write something quick and dirty just
    to make it work. This can actually be a really fun exercise, by the way!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被称为**尖峰**。我们创建一段一次性的代码，只是为了探索某个困难的部分，没有打算让这段代码进入生产。这使我们摆脱了通常涉及创建生产就绪代码的复杂性。代码只是为了解决特定情况并帮助我们获得有关如何以后解决同样问题的知识。大多数开发人员都知道，第一种方法几乎从来都不是问题的完美解决方案，所以让我们通过创建一个打算丢弃的第一个版本来处理这个事实。尖峰是关于知识的获取，而不是关于代码，所以准备好写一些快速而肮脏的东西来让它工作。顺便说一句，这实际上可以是一个非常有趣的练习！
- en: A common area to spike is the interaction with external services, such as our
    notification service where the interface is known on a high level but the developer
    has actually never worked with it. Since we don't have any idea how to interface
    with a Raven, I'm going to leave this for now. We will need to revisit this when
    the situation comes up but, as we learned from our UML diagram, the process is
    asynchronous anyway. Therefore, we don't expect that a response can hide behind
    a *Mock* in our first prototype.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的试验领域是与外部服务的交互，比如我们的通知服务，其中界面在高层次上是已知的，但开发人员实际上从未使用过。由于我们不知道如何与Raven进行接口，我现在打算暂时搁置这个问题。当情况出现时，我们需要重新审视这个问题，但正如我们从UML图中学到的，这个过程本身是异步的。因此，我们不指望在我们的第一个原型中，响应可以隐藏在*Mock*后面。
- en: The other interesting problem is going to be creating the interface between
    our code and the users. We can't be sure how the users want to interact with the
    software, since there is no experience in using anything like it. Interfaces tend
    to give us more insight into what the users want out of the software as well.
    The way a user wants to use a software teaches a lot about his focus and expected
    features, so spiking it is a great way to learn more about the system. This spike
    can be done in multiple ways, but it is actually useful to have real interface
    elements to build on and that can later be filled with more interactions. One
    way of doing this is to create the interface in HTML, which provides the basic
    structure but without the interactivity and fill in the gaps with JavaScript as
    we move along. For the sake of brevity, the code is omitted. If you are interested,
    visit the code repository for the book and check it out.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的问题将是创建我们的代码和用户之间的接口。我们无法确定用户希望如何与软件交互，因为他们没有使用类似软件的经验。接口往往能更好地帮助我们了解用户对软件的需求。用户希望如何使用软件会告诉我们很多关于他们关注的重点和期望的功能，因此进行试验是了解系统的好方法。这种试验可以通过多种方式进行，但实际上，有真实的界面元素可以构建，并且以后可以填充更多的交互，这是非常有用的。其中一种方法是使用HTML创建界面，它提供了基本的结构，但没有交互性，随着我们的进展，可以用JavaScript填补空白。为了简洁起见，代码被省略了。如果您感兴趣，请访问本书的代码存储库并查看。
- en: Keep in mind that this is not actually an interface we intend to keep, but we
    can now show something to our users and explain how they will interact.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这实际上并不是我们打算保留的界面，但现在我们可以向用户展示一些东西，并解释他们将如何进行交互。
- en: Getting started, it's about time
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始吧，现在是时候了
- en: With the previous work done, we are now at a point where we can start to work
    on the first feature of the application. We explored our ideas as far as we needed,
    and are in a position where we can actually talk about the details with our domain
    experts. I simplified the steps to get here a bit in the sense that we only talked
    about one iteration. In reality, this process most likely takes several iterations
    where your own understanding of the problem evolves. Sometimes not only your understanding
    changes, but often the business side also refines its own understanding along
    the way as well.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过之前的工作，我们现在可以开始着手应用程序的第一个功能了。我们已经探索了我们的想法，现在可以与我们的领域专家讨论细节了。我在这里稍微简化了到达这一点的步骤，实际上，这个过程很可能需要多次迭代，你对问题的理解也会不断发展。有时不仅是你的理解发生变化，而且业务方在这个过程中也会不断完善他们自己的理解。
- en: Creating value without creating code
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不创建代码的情况下创造价值
- en: As programmers, we often feel that the value we create is tied to the code we
    create, but this is not true, I will even go as far as to say that our value lies
    in the code we don't create. The simpler we can make a problem, the easier it
    is to move the project forward, and simplicity is based on a solid understanding
    of working together with the business as a team.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们经常觉得我们创造的价值与我们创建的代码有关，但事实并非如此，我甚至会说我们的价值在于我们没有创建的代码。我们能够简化问题，项目推进就会更容易，简单是基于与业务团队合作的坚实理解。
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There is nothing easier to create than complexity, so watch out! Solving a problem
    in the simplest way possible is what every piece of software should aim to do.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 没有比创造复杂性更容易的事情了，所以要小心！以最简单的方式解决问题是每个软件都应该努力做到的。
- en: When we walk through the process as we have done earlier and let people explain
    what they do each day, it is not rare to discover how something can be simplified
    and improved. It is part of the software development process to try to improve
    the process itself as well. As we explore the idea behind a feature, and let the
    business side talk about its own actions, it is common that they themselves notice
    unnecessary overhead or even process inherit complications that don't need to
    exist. This is the reason why we try to explore in the way we have done earlier
    in a textual format. Don't begrudge the time it takes to explore, but keep in
    mind that right now you are already creating value for the business, and an improvement
    at this stage is a great success.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们像之前那样走过流程，让人们解释他们每天做什么，很容易发现如何简化和改进某些事情。试图改进流程本身是软件开发过程的一部分。当我们探索一个功能的想法，并让业务方讨论他们自己的行动时，他们通常会注意到不必要的开销，甚至是不需要存在的过程继承复杂性。这就是为什么我们试图以文本格式进行之前所做的探索。不要嫌探索需要花费的时间，但要记住，现在你已经为业务创造了价值，这个阶段的改进是一个巨大的成功。
- en: Deciding on the first feature
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定第一个功能
- en: Even though we have already been moving the business forward, it is now time
    to actually do what developers do best—write code. The exploration we performed
    now points us towards starting out with the following feature set.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经在推动业务发展，但现在是时候真正做开发人员最擅长的事情了——编写代码。我们现在所做的探索指引我们开始以下功能集。
- en: We want to automate the process of moving prisoners out of our dungeon and keep
    a record of the prisoners moved at the same time. This seems really valuable,
    since an overflowing dungeon is a major problem for the orc master. This is also
    a part of the larger problem of keeping a record of the prisoners inside the dungeon
    and that we saw as part of our outline. Ultimately, this is what we set out to
    do. After this first feature is done, the moving of prisoners will be almost completely
    automated and will therefore save time we can invest into other elements of running
    the dungeon.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要自动化将囚犯从地牢中移出并同时记录移动的囚犯。这似乎非常有价值，因为地牢溢出是兽人大师的主要问题。这也是保持地牢内囚犯记录的更大问题的一部分，我们将其视为我们大纲的一部分。最终，这就是我们要做的事情。完成了这个第一个功能后，囚犯的移动将几乎完全自动化，因此可以节省时间，我们可以投入到地牢运营的其他元素中。
- en: We flushed out a basic interface to handle this, and it seems to be great to
    work with. So, let's start coding and set up a project using the techniques of
    domain-driven design to move the project along.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计了一个基本的界面来处理这个问题，看起来很容易使用。所以，让我们开始编码，并使用领域驱动设计的技术来设置项目，推动项目的进展。
- en: Summary
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how we can get started with a project prior to writing
    code. We focused on the interaction with the business experts, providing them
    with feedback by illustrating our thinking. We covered the importance of gathering
    knowledge and how to organize that knowledge so we can leverage it later on in
    the project to understand the goals of the application we are building.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在编写代码之前开始项目。我们专注于与业务专家的互动，通过阐明我们的思路向他们提供反馈。我们讨论了收集知识的重要性，以及如何组织这些知识，以便在项目后期利用它，以了解我们正在构建的应用程序的目标。
- en: As we moved forward, we looked into how to identify the core feature set and
    choose a good starting point to not only provide value to the business early on,
    but also to help us further understand the business domain. This process is similar
    to the goals of agile methodologies, trying to cover the core problems early on
    and provide quick value and feedback to the business.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的前进，我们研究了如何确定核心功能集，并选择一个良好的起点，不仅可以为业务提供早期价值，还可以帮助我们进一步了解业务领域。这个过程类似于敏捷方法的目标，试图尽早解决核心问题，并为业务提供快速价值和反馈。
- en: In the next chapter, we are going to get started setting up the project and
    covering the important details to get a good grip on managing the process throughout
    development.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始设置项目，并涵盖重要细节，以便在整个开发过程中对管理过程有一个良好的把握。
