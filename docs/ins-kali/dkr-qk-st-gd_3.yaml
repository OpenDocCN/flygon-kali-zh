- en: Creating Docker Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Docker镜像
- en: In this chapter, we will learn how to create enterprise-grade Docker images.
    We will start off by learning about the main building block of Docker images,
    specifically the Dockerfile. Then, we will explore all the instructions available
    to use in a Dockerfile. There are some instructions that on the surface seem very
    similar. We will uncover what the differences are between the `COPY` and `ADD`
    instructions, the `ENV` and `ARG` instructions, and most importantly between the
    `CMD` and `ENTRYPOINT` instructions. Next, we will find out what the build context
    is and why it is important. Finally, we will cover the actual image build command.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何创建企业级的Docker镜像。我们将首先学习Docker镜像的主要构建块，具体来说是Dockerfile。然后，我们将探索Dockerfile中可用的所有指令。有一些指令在表面上看起来非常相似。我们将揭示`COPY`和`ADD`指令之间的区别，`ENV`和`ARG`指令之间的区别，以及最重要的是`CMD`和`ENTRYPOINT`指令之间的区别。接下来，我们将了解构建上下文是什么以及为什么它很重要。最后，我们将介绍实际的镜像构建命令。
- en: If well-maintained, the average shipping container has a lifespan of around
    20 years, whereas the average lifespan of a Docker container is 2.5 days. – [https://www.tintri.com/blog/2017/03/tintri-supports-containers-advanced-storage-features](https://www.tintri.com/blog/2017/03/tintri-supports-containers-advanced-storage-features)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果得到良好维护，普通的集装箱的平均寿命约为20年，而Docker容器的平均寿命为2.5天。- [https://www.tintri.com/blog/2017/03/tintri-supports-containers-advanced-storage-features](https://www.tintri.com/blog/2017/03/tintri-supports-containers-advanced-storage-features)
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is a Dockerfile?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Dockerfile？
- en: All of the instructions that can be used in a Dockerfile
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile中可以使用的所有指令
- en: When to use either the `COPY` or the `ADD` instruction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用`COPY`或`ADD`指令
- en: The difference between the `ENV` and `ARG` variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`和`ARG`变量之间的区别'
- en: Why you use the `CMD` and `ENTRYPOINT` instructions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么要使用`CMD`和`ENTRYPOINT`指令
- en: The importance of the build context
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建上下文的重要性
- en: Building Docker images using a Dockerfile
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建Docker镜像
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be pulling Docker images from Docker's public repository, so basic
    internet access is required to execute the examples within this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从Docker的公共存储库中拉取Docker镜像，因此需要基本的互联网访问权限来执行本章中的示例。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter03](https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter03)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter03](https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter03)'
- en: 'Check out the following video to see the code in action: [http://bit.ly/2rbHvwC](http://bit.ly/2rbHvwC)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[http://bit.ly/2rbHvwC](http://bit.ly/2rbHvwC)
- en: What is a Dockerfile?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Dockerfile？
- en: You learned in [Chapter 2](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml), *Learning
    Docker Commands*, that you can run a Docker container, make modifications to that
    running container, and then using the docker commit command, save those changes,
    effectively creating a new Docker image. Although this method works, it is not
    the preferred way to create Docker containers. The best way to create Docker images
    is to use the Docker image build command with a Dockerfile that describes your
    desired image.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您在[第2章](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml)中学到，您可以运行Docker容器，对正在运行的容器进行修改，然后使用`docker
    commit`命令保存这些更改，从而有效地创建一个新的Docker镜像。尽管这种方法有效，但不是创建Docker容器的首选方式。创建Docker镜像的最佳方式是使用具有描述所需镜像的Dockerfile的Docker镜像构建命令。
- en: A Dockerfile (yes, the correct spelling is all one word, with a capital *D*)
    is a text file that contains instructions used by the Docker daemon to create
    a Docker image. The instructions are defined using a type of value pair syntax.
    Each one has an instruction word followed by the parameters for that instruction.
    Every command gets its own line in the Dockerfile. Although the Dockerfile instructions
    are not case-sensitive, there is a well-used convention that the instruction word
    is always uppercase.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile（是的，正确的拼写是一个词，首字母大写*D*）是一个文本文件，其中包含Docker守护程序用来创建Docker镜像的指令。指令使用一种键值对语法进行定义。每个指令都在Dockerfile中占据一行。虽然Dockerfile指令不区分大小写，但有一个常用的约定，即指令单词始终大写。
- en: The order of the instructions in the Dockerfile is significant. Instructions
    are evaluated in sequential order, starting at the top of the Dockerfile and finishing
    at the bottom of the file. If you recall from [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml), *Setting
    up a Docker Development Environment*, Docker images are made up of layers. All
    of the instructions found in the Dockerfile will result in a new layer being generated
    as the Docker image is built, however, some instructions will only add a zero-byte-sized
    metadata layer to the created image. Since it is a best practice to keep Docker
    images as small as possible, you will want to use instructions that create non-zero-byte-sized
    layers as efficiently as possible. In the following sections, we'll note where
    using an instruction creates a non-zero-byte-sized layer, and how to best use
    that instruction to minimize the number and size of layers. Another important
    consideration is the ordering of the instructions. Certain instructions must be
    used before others, but with those exceptions, you can place the other instructions
    in any order you please. The best practice is to use instructions that change
    least early in the Dockerfile, and instructions that change more frequently in
    the later part of the Dockerfile. The reason is that when you need to rebuild
    an image, the only layers that get rebuilt are the ones that are at, or after,
    the first line changed in the Dockerfile. If you don't understand this yet, don't
    worry, it will make more sense once we see some examples.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile中指令的顺序很重要。指令按顺序评估，从Dockerfile的顶部开始，直到文件的底部结束。如果您还记得[第1章](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml)中的内容，Docker镜像由层组成。Dockerfile中的所有指令都会导致生成一个新的层，因此在构建Docker镜像时，但是，某些指令只会向创建的镜像添加一个大小为零的元数据层。由于最佳实践是尽可能保持Docker镜像尽可能小，因此您将希望尽可能高效地使用创建非零字节大小层的指令。在接下来的部分中，我们将注意到使用指令创建非零字节大小层的地方，以及如何最好地使用该指令来最小化层数量和大小。另一个重要的考虑因素是指令的顺序。某些指令必须在其他指令之前使用，但除了这些例外情况，您可以按任何顺序放置其他指令。最佳实践是在Dockerfile的早期使用变化最小的指令，在Dockerfile的后期使用变化更频繁的指令。原因是当您需要重新构建镜像时，只有在Dockerfile中第一行更改的位置或之后的层才会被重新构建。如果您还不理解这一点，不用担心，一旦我们看到一些例子，它就会更有意义。
- en: 'We will review the build command at the end of this section, but we will start
    with the instructions available to the Dockerfile first, beginning with the instruction
    that has to be the first instruction in your Dockerfile: the `FROM` instruction.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节末尾回顾构建命令，但我们将从Dockerfile可用的指令开始，首先是必须是Dockerfile中的第一个指令的指令：`FROM`指令。
- en: The FROM instruction
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FROM指令
- en: Every Dockerfile must have a `FROM` instruction, and it must be the first instruction
    in the file. (Actually, the ARG instruction can be used before a `FROM` instruction,
    but it is not a required instruction. We will talk more about that in the ARG
    instruction section.)
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Dockerfile必须有一个`FROM`指令，并且它必须是文件中的第一个指令。（实际上，`FROM`指令之前可以使用ARG指令，但这不是必需的指令。我们将在ARG指令部分更多地讨论这个。）
- en: 'The `FROM` instruction sets the base for the image being created and instructs
    the Docker daemon that the base of the new image should be the existing Docker
    image specified as the parameter. The specified image can be described using the
    same syntax we saw in the Docker `container run` command from [Chapter 2](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml),
    *Learning Docker Commands*. Here, it''s a `FROM` instruction that specifies using
    the official `nginx` image with a version of 1.15.2:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`指令设置正在创建的镜像的基础，并指示Docker守护程序新镜像的基础应该是指定为参数的现有Docker镜像。指定的镜像可以使用与我们在[第2章](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml)中看到的Docker
    `container run`命令相同的语法来描述。在这里，它是一个`FROM`指令，指定使用官方的`nginx`镜像，版本为1.15.2：'
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that in this example, there is no repository specified that indicates that
    the specified image is the official nginx image. If no tag is specified, the `latest`
    tag will be assumed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，没有指定指示指定的镜像是官方nginx镜像的存储库。如果没有指定标签，将假定为`latest`标签。
- en: 'The `FROM` instruction will create the first layer in our new image. That layer
    will be the size of the image specified in the instruction''s parameter so it
    is best to specify the smallest image that meets the criteria needed for your
    new image. An application-specific image, such as `nginx`, is going to be smaller
    than an OS image, such as ubuntu. And, the OS image for `alpine` will be much
    smaller than images of other OSes, such as Ubuntu, CentOS, or RHEL. There is a
    special keyword that can be used as the parameter to the `FROM` instruction. It
    is `scratch`. Scratch is not an image that you can pull or run, it just a signal
    to the Docker daemon that you want to build an image with an empty base-image
    layer. The FROM scratch instruction is used as the base layer for many other base
    images, or for specialized app-specific images. You have already seen an example
    of such a specialized app image: hello-world. The full Dockerfile for the hello-world
    image looks like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`指令将创建我们新镜像中的第一层。该层将是指令参数中指定的镜像大小，因此最好指定满足新镜像所需条件的最小镜像。一个特定于应用程序的镜像，比如`nginx`，会比一个操作系统镜像，比如ubuntu，要小。而`alpine`的操作系统镜像会比其他操作系统的镜像，比如Ubuntu、CentOS或RHEL，要小得多。`FROM`指令可以使用一个特殊的关键字作为参数。它是`scratch`。Scratch不是一个可以拉取或运行的镜像，它只是向Docker守护程序发出信号，表明你想要构建一个带有空基础镜像层的镜像。`FROM
    scratch`指令被用作许多其他基础镜像的基础层，或者用于专门的应用程序特定镜像。你已经看到了这样一个专门的应用程序镜像的例子：hello-world。hello-world镜像的完整Dockerfile如下：'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will discuss the `COPY` and `CMD` instructions shortly, but you should get
    a sense of how small the hello-world image is based on its Dockerfile. In the
    world of Docker images, smaller is definitely better. Take a look at the size
    of some images for reference:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快讨论`COPY`和`CMD`指令，但是你应该根据它的Dockerfile来感受一下hello-world镜像有多小。在Docker镜像的世界中，越小越好。参考一下一些镜像的大小：
- en: '![](Images/3e91115f-6c8d-4634-8638-b0c8e051a85b.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3e91115f-6c8d-4634-8638-b0c8e051a85b.png)'
- en: The LABEL instruction
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标签指令
- en: 'The `LABEL` instruction is a way to add metadata to your Docker image. This
    instruction adds embedded key-value pairs to the image. The `LABEL` instruction
    adds a zero-byte-sized layer to the image when it is created. An image can have
    more than one `LABEL`, and each `LABEL` instruction can provide one or more LABELs.
    The most common use for the `LABEL` instruction is to provide information about
    the image maintainer. This data used to have its own instruction. See the following
    tip box about the now-deprecated `MAINTAINER` instruction. Here are some examples
    of valid `LABEL` instructions:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: LABEL指令是向Docker镜像添加元数据的一种方法。当创建镜像时，此指令会向镜像添加嵌入式键值对。一个镜像可以有多个LABEL，并且每个LABEL指令可以提供一个或多个标签。LABEL指令最常见的用途是提供有关镜像维护者的信息。这些数据以前有自己的指令。请参阅有关现在已弃用的MAINTAINER指令的下面提示框。以下是一些有效的LABEL指令示例：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `LABEL` instruction is one of the instructions that can be used multiple
    times in a Dockerfile. You will learn later that some instructions that can be
    used multiple times will result in only the last use being significant, thus ignoring
    all previous uses. The `LABEL` instruction is different. Every use of the `LABEL`
    instruction adds an additional label to the resulting image. However, if two or
    more uses of `LABEL` have the same key, the label will get the value provided
    in the last matching `LABEL` instruction. That looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: LABEL指令是Dockerfile中可以多次使用的指令之一。你将会在后面学到，一些可以多次使用的指令只会保留最后一次使用的内容，忽略之前的所有使用。但是LABEL指令不同。每次使用LABEL指令都会向生成的镜像添加一个额外的标签。然而，如果两次或更多次使用LABEL具有相同的键，标签将获得最后一个匹配的LABEL指令中提供的值。就像这样：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is important to know that the base image specified in your `FROM` instruction
    may include labels created with the `LABEL` instruction and that they will automatically
    be included in the metadata of the image you are building. If a `LABEL` instruction
    in your Dockerfile uses the same key as a `LABEL` instruction used in the FROM
    image''s Dockerfile, your (later) value will override the one in the FROM image.
    You can view all of the labels for an image by using the `inspect` command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，在你的FROM指令中指定的基础镜像可能包含使用LABEL指令创建的标签，并且它们将自动包含在你正在构建的镜像的元数据中。如果你的Dockerfile中的LABEL指令使用与FROM镜像的Dockerfile中使用的LABEL指令相同的键，你（后来的）值将覆盖FROM镜像中的值。你可以使用inspect命令查看镜像的所有标签：
- en: '![](Images/c01d1aab-1110-46c5-9623-cad509812cc6.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c01d1aab-1110-46c5-9623-cad509812cc6.png)'
- en: 'The MAINTAINER instruction There is a Dockerfile instruction specifically for
    providing the info about the image maintainer, however, this instruction has been
    deprecated. Still, you will probably see it used in a Dockerfile at some point.
    The syntax goes like this: `"maintainer": "Earl Waud <earlwaud@mycompany.com>"`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 'MAINTAINER指令有一个专门用于提供有关镜像维护者信息的Dockerfile指令，但是这个指令已经被弃用。不过，你可能会在某个时候看到它在Dockerfile中被使用。语法如下：`"maintainer":
    "Earl Waud <earlwaud@mycompany.com>"`。'
- en: The COPY instruction
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: COPY指令
- en: 'You have already seen an example of using the `COPY` instruction in the hello-world
    Dockerfile shown in *The FROM instruction* section. The `COPY` instruction is
    used to copy files and folders into the Docker image being built. The syntax for
    the `COPY` instruction is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在“FROM指令”部分的hello-world Dockerfile中看到了使用COPY指令的示例。COPY指令用于将文件和文件夹复制到正在构建的Docker镜像中。COPY指令的语法如下：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that the `--chown` parameter is only valid for Linux-based containers.
    Without the `--chown` parameter, the owner ID and group ID will both be set to
    0.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，--chown参数仅适用于基于Linux的容器。如果没有--chown参数，所有者ID和组ID都将设置为0。
- en: The `<src>` or source is a filename or folder path and is interpreted to be
    relative to the context of the build. We will talk more about the build context later
    in this chapter, but for now, think of it as where the build command is run. The
    source may include wildcards.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`<src>`或源是文件名或文件夹路径，并且被解释为相对于构建的上下文。我们稍后会在本章中更多地讨论构建上下文，但现在，将其视为构建命令运行的位置。源可能包括通配符。'
- en: The `<dest>` or destination is a filename or path inside of the image being
    created. The destination is relative to the root of the image's filesystem unless
    there is a preceding `WORKDIR` instruction. We will discuss the `WORKDIR` instruction
    later, but for now, just think of it as a way to set the current working directory.
    When the COPY command comes after a `WORKDIR` instruction in a Dockerfile, the
    file or folders being copied into the image will be placed in the destination
    relative to the current working directory. If the destination includes a path
    with one or more folders, all of the folders will be created if they don't already
    exist.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`<dest>`或目标是正在创建的图像中的文件名或路径。目标是相对于图像文件系统的根目录，除非有一个前置的`WORKDIR`指令。我们稍后会讨论`WORKDIR`指令，但现在，只需将其视为设置当前工作目录的一种方式。当`COPY`命令在Dockerfile中的`WORKDIR`指令之后出现时，复制到图像中的文件或文件夹将被放置在相对于当前工作目录的目标中。如果目标包括一个或多个文件夹的路径，如果它们不存在，所有文件夹都将被创建。'
- en: 'In our earlier hello-world Dockerfile example, you saw a `COPY` instruction
    that copied an executable file, named `hello`, into the image at the filesystem''s
    root location. It looked like this: `COPY hello /`. That is about as basic a `COPY`
    instruction as can be used. Here are some other examples:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的hello-world Dockerfile示例中，您看到了一个`COPY`指令，它将一个名为`hello`的可执行文件复制到图像的文件系统根位置。它看起来像这样：`COPY
    hello /`。这是一个基本的`COPY`指令。以下是一些其他示例：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see what the resulting image''s filesystem would get using the preceding
    Dockerfile by running a container from the image, and executing an `ls` command,
    which would look like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从图像运行容器并执行`ls`命令，我们可以看到使用前面的Dockerfile得到的图像文件系统会是什么样子：
- en: '![](Images/442d213e-eea8-4ca6-bee4-253d64e84aa5.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/442d213e-eea8-4ca6-bee4-253d64e84aa5.png)'
- en: You can see that folders specified in the destination path were created during
    the COPY. You will also notice that providing the `--chown` parameter sets the
    owner and group on the destination files. An important distinction is that when
    the source is a folder, the contents of the folder are copied but not the folder
    itself. Notice that using a `WORKDIR` instruction changes the path in the image
    filesystem and following `COPY` instructions will now be relative to the new current
    working directory. In this example, we returned the current working directory
    to `/` so that commands executed in containers will run relative to `/`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到在目标路径中指定的文件夹在复制期间被创建。您还会注意到提供`--chown`参数会设置目标文件的所有者和组。一个重要的区别是当源是一个文件夹时，文件夹的内容会被复制，但文件夹本身不会被复制。请注意，使用`WORKDIR`指令会更改图像文件系统中的路径，并且随后的`COPY`指令现在将相对于新的当前工作目录。在这个例子中，我们将当前工作目录返回到`/`，以便在容器中执行的命令将相对于`/`运行。
- en: The ADD instruction
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ADD指令
- en: 'The `ADD` instruction is used to copy files and folders into the Docker image
    being built. The syntax for the `ADD` instruction is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`指令用于将文件和文件夹复制到正在构建的Docker图像中。`ADD`指令的语法如下：'
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: About now, you are thinking that the `ADD` instruction seems to be just like
    the `COPY` instruction that we just reviewed. Well, you are not wrong. Basically,
    all of the things we saw the `COPY` instruction do, the `ADD` instruction can
    do as well. It uses the same syntax as the `COPY` instruction and the effects
    of `WORKDIR` instructions are the same between the two. So, why do we have two
    commands that do the same thing?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能会认为`ADD`指令似乎就像我们刚刚审查的`COPY`指令一样。嗯，你没错。基本上，我们看到`COPY`指令所做的所有事情，`ADD`指令也可以做。它使用与`COPY`指令相同的语法，两者之间的`WORKDIR`指令的效果也是相同的。那么，为什么我们有两个执行相同操作的命令呢？
- en: The difference between COPY and ADD
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: COPY和ADD之间的区别
- en: The answer is that the `ADD` instruction can actually do more than the `COPY`
    instruction. The more is dependent upon the values used for the source input.
    With the `COPY` instruction, the source can be files or folders. However, with
    the `ADD` instruction, the source can be files, folders, a local `.tar` file,
    or a URL.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是`ADD`指令实际上可以比`COPY`指令做更多。更多取决于用于源输入的值。使用`COPY`指令时，源可以是文件或文件夹。然而，使用`ADD`指令时，源可以是文件、文件夹、本地`.tar`文件或URL。
- en: When the `ADD` instruction has a source value that is a `.tar` file, the contents
    of that TAR file are extracted into a corresponding folder inside the image.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ADD`指令的源值是`.tar`文件时，该TAR文件的内容将被提取到镜像中的相应文件夹中。
- en: When you use a `.tar` file as the source in an `ADD` instruction and include
    the `--chown` parameter, you might expect the owner and group in the image to
    be set on the files extracted from the archive. This is currently not the way
    it works. Unfortunately, the owner, group, and permissions on the extracted contents
    will match what is contained within the archive in spite of the `--chown` parameter.
    When you use a `.tar` file, you will probably want to include `RUN chown -R X:X`
    after the ADD.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在`ADD`指令中使用`.tar`文件作为源并包括`--chown`参数时，您可能期望在从存档中提取的文件上设置图像中的所有者和组。目前情况并非如此。不幸的是，尽管使用了`--chown`参数，提取内容的所有者、组和权限将与存档中包含的内容相匹配。当您使用`.tar`文件时，您可能希望在ADD之后包含`RUN
    chown -R X:X`。
- en: 'As mentioned, the `ADD` instruction can use a URL as the source value. Here
    is an example Dockerfile that includes an `ADD` instruction using a URL:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ADD`指令可以使用URL作为源值。以下是一个包含使用URL的`ADD`指令的示例Dockerfile：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While using a URL in an `ADD` instruction works, downloading the file into
    the image, this feature is not recommended, even by Docker. Here is what the Docker
    documentation has to say about using `ADD`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ADD`指令中使用URL是有效的，将文件下载到镜像中，但是这个功能并不被Docker推荐。以下是Docker文档对使用`ADD`的建议：
- en: '![](Images/f457493e-9d04-4f9f-8892-4eb6466b159d.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f457493e-9d04-4f9f-8892-4eb6466b159d.png)'
- en: So, generally speaking, whenever you can get the desired content into the image
    using a `COPY` instruction, then you should choose to use `COPY` instead of `ADD`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一般来说，每当您可以使用`COPY`指令将所需内容放入镜像时，您应该选择使用`COPY`而不是`ADD`。
- en: The ENV instruction
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ENV指令
- en: 'As you may guess, the `ENV` instruction is used to define environment variables
    that will be set in the running containers created from the image being built.
    The variables are defined using typical key-value pairs. A Dockerfile can have
    one or more `ENV` instructions. Here is the `ENV` instruction syntax:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能猜到的那样，`ENV`指令用于定义将在从正在构建的镜像创建的运行容器中设置的环境变量。使用典型的键值对定义变量。Dockerfile可以有一个或多个`ENV`指令。以下是`ENV`指令的语法：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Each `ENV` instruction will create one or more environment variables (unless
    the key name is repeated). Let''s take a look at some `ENV` instructions in a
    Dockerfile:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`ENV`指令将创建一个或多个环境变量（除非键名重复）。让我们看一下Dockerfile中的一些`ENV`指令：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After building the image using this Dockerfile, you can inspect the image metadata
    and see the environment variables that have been created:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此Dockerfile构建镜像后，您可以检查镜像元数据，并查看已创建的环境变量：
- en: '![](Images/e98f6d2e-906f-4c99-8a98-7fd5aceb10fc.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e98f6d2e-906f-4c99-8a98-7fd5aceb10fc.png)'
- en: 'Environment variables can be set (or overridden) when a container is run using
    the `--env` parameter. Here, we see this feature in action:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量可以在运行容器时使用`--env`参数进行设置（或覆盖）。在这里，我们看到了这个功能的实际应用：
- en: '![](Images/572af022-9c53-496a-96e1-7e1c23a14b24.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/572af022-9c53-496a-96e1-7e1c23a14b24.png)'
- en: It is important to know that using `ENV` instructions create a zero-byte-sized
    additional layer in the resulting image. If you are adding more than one environment
    variable to your image and can use the form of the instruction that supports setting
    multiple variables with one instruction, doing so will only create a single additional
    image layer, so that is the way to go.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，使用`ENV`指令会在生成的镜像中创建一个大小为零字节的额外层。如果要向镜像添加多个环境变量，并且可以使用支持一次设置多个变量的指令形式，那么只会创建一个额外的镜像层，因此这是一个好方法。
- en: The ARG instruction
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARG指令
- en: 'Sometimes when building Docker images, you may need to use variable data to
    customize the build. The `ARG` instruction is the tool to handle that situation.
    To use it, you add `ARG` instructions to your Dockerfile, and then when you execute
    the build command, you pass in the variable data with a `--build-arg` parameter.
    The `--build-arg` parameter uses the now familiar key-value pair format:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在构建Docker镜像时，您可能需要使用变量数据来自定义构建。`ARG`指令是处理这种情况的工具。要使用它，您需要将`ARG`指令添加到Dockerfile中，然后在执行构建命令时，通过`--build-arg`参数传入变量数据。`--build-arg`参数使用现在熟悉的键值对格式：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can use multiple `ARG` instructions in your Dockerfile with corresponding
    `--build-arg` parameters on the docker image build commands. You have to include
    an `ARG` instruction for every use of the `--build-arg` parameter. Without the
    `ARG` instruction, the `--build-arg` parameter will not be set during the build,
    and you will get a warning message. If you do not provide a `--build-arg` parameter
    or you do not provide the value part of the key-value pair for a `--build-arg` parameter for
    an existing `ARG` instruction, and that `ARG` instruction includes a default value,
    then the variable will be assigned the default value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Dockerfile中使用多个`ARG`指令，并在docker image build命令上使用相应的`--build-arg`参数。对于每个`--build-arg`参数的使用，都必须包括一个`ARG`指令。如果没有`ARG`指令，则在构建过程中`--build-arg`参数将不会被设置，并且您将收到警告消息。如果您没有提供`--build-arg`参数，或者没有为现有的`ARG`指令提供`--build-arg`参数的值部分，并且该`ARG`指令包括默认值，那么变量将被分配默认值。
- en: Be aware that during the image build, even though `--build-arg` is included
    as a parameter of the docker image build command, the corresponding variable does
    not get set until the `ARG` instruction is reached in the Dockerfile. Said another
    way, the value of the key-value pair of a `--build-arg` parameter will never be
    set until after its corresponding `ARG` line in the Dockerfile.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在镜像构建过程中，即使`--build-arg`被包括为docker image build命令的参数，相应的变量也不会在Dockerfile中的`ARG`指令到达之前设置。换句话说，`--build-arg`参数的键值对的值在其对应的`ARG`行之后才会被设置。
- en: 'The parameters defined in `ARG` instructions do not persist into containers
    run from the created image, however, ARG instructions create new zero-byte-sized
    layers in the resulting images. Here is an educational example of using the `ARG`
    instruction:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ARG` 指令中定义的参数不会持续到从创建的镜像运行的容器中，但是 ARG 指令会在生成的镜像中创建新的零字节大小的层。以下是使用 `ARG` 指令的教育示例：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a Dockerfile with the contents shown in the preceding code block and
    run the following build command to see how the scope of the `ENV` and `ARG` instructions
    play out:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含上述代码块中显示的内容的 Dockerfile，并运行以下构建命令，以查看 `ENV` 和 `ARG` 指令的范围如何发挥作用：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You will see by the first `echo ${key1}` that even though there is a `--build-arg` parameter
    for `key1`, it will not be stored as `key1` because there is an `ENV` instruction
    that has the same key name. This still holds true for the second `echo ${key1}`,
    which is after the ARG `key1` instruction. The ENV variable values will always
    be the winner when there are both `ARG` and `EVN` instructions with the same key
    name.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `echo ${key1}` 会让你看到，即使有一个 `--build-arg` 参数用于 `key1`，它也不会被存储为 `key1`，因为有一个相同键名的
    `ENV` 指令。这对于第二个 `echo ${key1}` 仍然成立，这是在 ARG `key1` 指令之后。当 `ARG` 和 `EVN` 指令具有相同的键名时，ENV
    变量值总是获胜。
- en: Then, you will see that the first `echo ${key2}` is empty even though there
    is a `--build-arg` parameter for it. It is empty because we have not reached the
    `ARG key2` instruction yet. The second `echo ${key2}` will contain the value from
    the corresponding `--build-arg` parameter even though there is a default value
    provided in the `ARG key2` instruction. The final `echo ${key2}` will show the
    value provided in the `ENV key2` instruction in spite of there being both a default
    value in the `ARG` and a value passed in via the `--build-arg` parameter. Again,
    this is because `ENV` always trumps ARG.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你会看到第一个 `echo ${key2}` 是空的，即使有一个 `--build-arg` 参数。这是因为我们还没有达到 `ARG key2`
    指令。第二个 `echo ${key2}` 将包含相应 `--build-arg` 参数的值，即使在 `ARG key2` 指令中提供了默认值。最终的 `echo
    ${key2}` 将显示在 `ENV key2` 指令中提供的值，尽管在 `ARG` 中有默认值，并且通过 `--build-arg` 参数传递了一个值。同样，这是因为
    `ENV` 总是胜过 ARG。
- en: The difference between ENV and ARG
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ENV 和 ARG 之间的区别
- en: 'Again, here is a pair of instructions that have a similar functionality. They
    both can be used during the build of an image, setting parameters to be available
    to use within other Dockerfile instructions. The other Dockerfile instructions
    that can use these parameters are `FROM`, `LABEL`, `COPY`, `ADD`, `ENV`, `USER`,
    `WORKDIR`, `RUN`, `VOLUME`, `EXPOSE`, `STOPSIGNAL`, and `ONBUILD`. Here is an
    example of using the `ARG` and `ENV` variables in other Docker commands:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一对具有类似功能的指令。它们都可以在构建镜像时使用，设置参数以便在其他 Dockerfile 指令中使用。可以使用这些参数的其他 Dockerfile
    指令包括 `FROM`、`LABEL`、`COPY`、`ADD`、`ENV`、`USER`、`WORKDIR`、`RUN`、`VOLUME`、`EXPOSE`、`STOPSIGNAL`
    和 `ONBUILD`。以下是在其他 Docker 命令中使用 `ARG` 和 `ENV` 变量的示例：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With this Dockerfile, you would want to provide `--build-arg` parameters for
    the `appdir` `ARG` instruction, and the username (if you want to override the
    default) to the build command. You could also provide an `--env` parameter at
    runtime to override the lifecycle variable. Here are possible build and run commands
    you could use:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 Dockerfile，你会想为 `appdir` `ARG` 指令提供 `--build-arg` 参数，并且在构建命令中提供用户名（如果你想要覆盖默认值）。你也可以在运行时提供一个
    `--env` 参数来覆盖生命周期变量。以下是可能使用的构建和运行命令：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While the `ENV` and `ARG` instructions might seem similar, they are actually
    quite different. Here are the key differences to remember between the parameters
    created by the `ENV` and `ARG` instructions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `ENV` 和 `ARG` 指令可能看起来相似，但它们实际上是非常不同的。以下是记住 `ENV` 和 `ARG` 指令创建的参数之间的关键区别：
- en: ENVs persist into running containers, ARGs do not.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ENV持续存在于运行中的容器中，ARG不会。
- en: ARGs use corresponding build parameters, ENVs do not.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ARG使用相应的构建参数，ENV不使用。
- en: '`ENV` instructions must include both a key and a value, `ARG` instructions
    have a key but the (default) value is optional.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`指令必须包括键和值，`ARG`指令有一个键，但（默认）值是可选的。'
- en: ENVs are more significant than ARGs.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ENV比ARG更重要。
- en: You should never use either `ENV` or `ARG` instructions to provide secret data
    to the build command or resulting containers because the values are always visible
    in clear text to any user that runs the docker history command.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要使用`ENV`或`ARG`指令向构建命令或生成的容器提供秘密数据，因为这些值对于运行docker history命令的任何用户都是明文可见的。
- en: The USER instruction
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: USER指令
- en: 'The USER instruction allows you to set the current user (and group) for all
    of the instructions that follow in the Dockerfile, and for the containers that
    are run from the built image. The syntax for the `USER` instruction is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: USER指令允许您为Dockerfile中接下来的所有指令和从构建图像运行的容器设置当前用户（和组）。`USER`指令的语法如下：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If a named user (or group) is provided as parameters to the `USER` instruction,
    that user (and group) must already exist in the passwd file (or group file) of
    the system, or a build error will occur. If you provide the `UID` (or `GID`) as
    the parameter to the `USER` command, the check to see whether the user (or group)
    exists is not performed. Consider the following Dockerfile:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将命名用户（或组）作为`USER`指令的参数提供，则该用户（和组）必须已经存在于系统的passwd文件（或组文件）中，否则将发生构建错误。如果将`UID`（或`GID`）作为`USER`命令的参数提供，则不会执行检查用户（或组）是否存在。考虑以下Dockerfile：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When the image build starts, the current user is root or `UID=0` `GID=0`. Then,
    the `USER` instruction is executed to set the current user and group to `games:games`.
    Since this is the last use of the `USER` instruction in the Dockerfile, all containers
    run using the built image will have the current user (and group) set to games.
    Here is what the build and run look like:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像构建开始时，当前用户是root或`UID=0` `GID=0`。然后，执行`USER`指令将当前用户和组设置为`games:games`。由于这是Dockerfile中`USER`指令的最后一次使用，所有使用构建图像运行的容器将具有当前用户（和组）设置为games。构建和运行如下所示：
- en: '![](Images/0aca2a20-ee07-4b3b-ba94-bc58b78b8deb.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0aca2a20-ee07-4b3b-ba94-bc58b78b8deb.png)'
- en: Notice that the output from Step 3/6:RUN id shows the current user as root,
    and then in Step 5/6 (which is after the `USER` instruction) it shows the current
    user as games. Finally, notice that the container run from the image has the current
    user games. The `USER` instruction creates a zero-byte-sized layer in the image.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，步骤3/6的RUN id的输出显示当前用户为root，然后在步骤5/6（在`USER`指令之后）中显示当前用户为games。最后，请注意，从图像运行的容器具有当前用户games。`USER`指令在图像中创建了一个大小为零字节的层。
- en: The WORKDIR instruction
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WORKDIR指令
- en: 'We have seen the `WORKDIR` instruction used in some of the examples used to
    demonstrate other instructions. It is sort of like a combination of the Linux
    `cd` and `mkdir` commands. The `WORKDIR` instruction will change the current working
    directory in the image to the value provided in the instruction. If any segment
    of the path in the parameter of the `WORKDIR` instruction does not yet exist,
    it will be created as part of the execution of the instruction. The syntax for
    the `WORKDIR` instruction is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在一些示例中看到了`WORKDIR`指令的使用，用于演示其他指令。它有点像Linux的`cd`和`mkdir`命令的组合。`WORKDIR`指令将把图像中的当前工作目录更改为指令中提供的值。如果参数中路径的任何部分尚不存在，则将作为执行指令的一部分创建它。`WORKDIR`指令的语法如下：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `WORKDIR` instruction can use `ENV` or `ARG` parameter values for all or
    part of its parameter. A Dockerfile can have more than one `WORKDIR` instruction,
    and each subsequent `WORKDIR` instruction will be relative to the previous one
    (if a relative path is used). Here is an example that demonstrates this possibility:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`指令可以使用`ENV`或`ARG`参数值作为其参数的全部或部分。Dockerfile可以有多个`WORKDIR`指令，每个后续的`WORKDIR`指令将相对于前一个（如果使用相对路径）。以下是演示此可能性的示例：'
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Building the image from this Dockerfile will result in the image having three
    levels of nested folders. Running a container from the image and listing the files
    and folders will look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个Dockerfile构建镜像将导致镜像具有三层嵌套的文件夹。从镜像运行容器并列出文件和文件夹将如下所示：
- en: '![](Images/c1c550ed-5793-45d4-a4d7-a9f8c4c60f81.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c1c550ed-5793-45d4-a4d7-a9f8c4c60f81.png)'
- en: The `WORKDIR` instruction will create a zero-byte-sized layer in the resulting
    image.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`指令将在生成的镜像中创建一个大小为零字节的层。'
- en: The VOLUME instruction
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VOLUME指令
- en: You should remember that a Docker image is made up of a series of read-only
    layers built upon one another, and that when you run a container from a Docker
    image, it creates a new read-write layer that you can think of as being on top
    of the read-only layers. All the changes to the container are applied to the read-write
    layer. If you make a change to a file found in one of the read-only layers, a
    copy of that file is made and added to the read-write layer. Then, all the changes
    are applied to the copy. The copy hides the version found in the read-only layer
    so, from the point of view of the running container, there is only one version
    of the file, and it is the one that has been changed. This is roughly how the
    Unified File System works.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该记住，Docker镜像由一系列相互叠加的只读层组成，当您从Docker镜像运行容器时，它会创建一个新的读写层，您可以将其视为位于只读层之上。所有对容器的更改都应用于读写层。如果对只读层中的文件进行更改，将会创建该文件的副本并将其添加到读写层。然后，所有更改都将应用于该副本。该副本隐藏了只读层中找到的版本，因此从运行的容器的角度来看，文件只有一个版本，即已更改的版本。这大致是统一文件系统的工作原理。
- en: This is actually a great thing. However, it presents a challenge, this being
    that when the running container exits and is removed, all of the changes are removed
    with it. This is normally OK until you want to have some data that persists after
    the life of the container, or when you want to share data between containers.
    Docker has an instruction to help you solve this issue, the `VOLUME` instruction.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一件好事。但是，它也带来了一个挑战，即当运行的容器退出并被删除时，所有更改也将被删除。这通常是可以接受的，直到您希望在容器的生命周期之后保留一些数据，或者希望在容器之间共享数据时。Docker有一条指令可以帮助您解决这个问题，那就是`VOLUME`指令。
- en: 'The `VOLUME` instruction will create a storage location that is outside of
    the United File System, and by so doing, allow storage to persist beyond the life
    of your container. Here is the syntax of the `VOLUME` instruction:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME`指令将创建一个存储位置，该位置位于美国文件系统之外，并且通过这样做，允许存储在容器的生命周期之外持久存在。以下是`VOLUME`指令的语法：'
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Other ways to create volumes are to add volume parameters to the docker `container
    run` command or to use the docker volume create command. We will cover those methods
    in detail in [Chapter 4](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml), *Docker
    Volumes*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 创建卷的其他方法是向docker `container run`命令添加卷参数，或者使用docker volume create命令。我们将在[第4章](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml)
    *Docker Volumes*中详细介绍这些方法。
- en: 'Here is a simple example Dockerfile. It creates a volume at `/myvol` that will
    have a file named `greeting`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的示例Dockerfile。它在`/myvol`创建了一个卷，其中将有一个名为`greeting`的文件：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running a container based on an image made from this Dockerfile will create
    a mount point on the host system that initially contains the `greeting` file.
    When the container exits, the mount point will remain. Be careful with the use
    of the `--rm` parameter when running a container that has mount points you wish
    to persist. Using `--rm`, with no other volume parameters, will cause the mount
    points to be cleaned up along with the container when it exits. Here is what that
    looks like:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基于从此Dockerfile创建的镜像运行容器将在主机系统上创建一个挂载点，最初包含`greeting`文件。当容器退出时，挂载点将保留。在运行具有要持久保存的挂载点的容器时，使用`--rm`参数要小心。使用`--rm`，没有其他卷参数，将导致容器退出时清理挂载点。看起来是这样的：
- en: '![](Images/b5f7a39c-bbc2-4ed6-96a3-96327e0839af.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b5f7a39c-bbc2-4ed6-96a3-96327e0839af.png)'
- en: We start out with no volumes. Then, we run a container based on the image made
    from the preceding Dockerfile in detached mode. We check the volumes again, and
    we see the volume created by running the container. Then, we stop the container
    and check for volumes again, and the volume is now gone. Usually, the purpose
    of using a `VOLUME` instruction is to have data in a mount point that persists
    after the container is gone. So, if you are going to use `--rm` when you run a
    container, you should include the `--mount` run parameter, which we will cover
    in detail in [Chapter 4](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml), *Docker
    Volumes*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始时没有卷。然后，我们以分离模式运行了一个基于前面的Dockerfile创建的镜像的容器。我们再次检查卷，看到了通过运行容器创建的卷。然后，我们停止容器并再次检查卷，现在卷已经消失了。通常，使用`VOLUME`指令的目的是在容器消失后保留挂载点中的数据。因此，如果您要在运行容器时使用`--rm`，您应该包括`--mount`运行参数，我们将在[第4章](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml)
    *Docker Volumes*中详细介绍。
- en: 'You can interact with the data on the host using the mount point for a volume.
    Here is an example that demonstrates this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用卷的挂载点与主机上的数据进行交互。以下是一个演示这一点的示例：
- en: '![](Images/bd92fd61-ea21-4375-850c-4e759713d89e.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bd92fd61-ea21-4375-850c-4e759713d89e.png)'
- en: In this demo, we run a container that is based on an image created with the
    preceding Dockerfile. Then, we list the volumes and see the myvolsrc volume (we
    already knew the name since we provided it in the run command, but you can use
    the `ls` command to find volume names that you might not otherwise know). Using
    the volume's name, we inspect the volume to find its mount point on the host.
    To verify the contents of the volume in the container, we use an exec command
    to do an ls of the folder. Next, using the mount point path, we create a new file
    using the touch command. Finally, we use the same exec command and see that inside
    the container the volume has been changed (from actions outside of the container).
    Similarly, if the container makes changes to the contents of the volume, they
    are reflected instantly on the host mount point.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示中，我们运行了一个基于前面的Dockerfile创建的镜像的容器。然后，我们列出了卷，并查看了myvolsrc卷（我们已经知道了名称，因为我们在运行命令中提供了它，但您可以使用`ls`命令来查找您可能不知道的卷名称）。使用卷的名称，我们检查卷以找到它在主机上的挂载点。为了验证容器中卷的内容，我们使用exec命令来列出文件夹。接下来，使用挂载点路径，我们使用touch命令创建一个新文件。最后，我们使用相同的exec命令，并看到容器内的卷已经改变（来自容器外的操作）。同样，如果容器更改卷的内容，这些更改将立即反映在主机挂载点上。
- en: The preceding example will not work on OS X directly as shown. It requires some
    extra work. Don't panic though! We'll show you how to deal with the extra work
    required for OS X in [Chapter 4](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml),
    *Docker Volumes*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例在OS X上直接显示不起作用。它需要一些额外的工作。不过不要惊慌！我们将向您展示如何处理OS X所需的额外工作，在[第4章](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml)
    *Docker Volumes*中。
- en: Using the `VOLUME` instruction is both powerful and dangerous. It is powerful
    in that it lets you have data that will persist beyond the life of your containers.
    It is dangerous because data is passed instantaneously from the container to the
    host, and if the container is ever compromised, that can spell trouble. That is
    why, for security purposes, it is best practice to *not* include host-based VOLUME
    mounts in your Dockerfiles. We will cover some safer alternatives in [Chapter
    4](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml), *Docker Volumes*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`VOLUME`指令既强大又危险。它之所以强大，是因为它让您拥有超出容器生命周期的数据。它之所以危险，是因为数据会立即从容器传递到主机，如果容器被攻击，可能会带来麻烦。出于安全考虑，最佳实践是*不*在Dockerfile中包含基于主机的VOLUME挂载。我们将在[第4章](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml)中介绍一些更安全的替代方法，*Docker
    Volumes*。
- en: The `VOLUME` instruction will add a zero-bytes sized layer to your resulting
    Docker image.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME`指令将在生成的Docker镜像中添加一个大小为零字节的层。'
- en: The EXPOSE instruction
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EXPOSE指令
- en: 'The `EXPOSE` instruction is a way to document what network ports the image
    expects to be opened when a container is run from the image built using the Dockerfile.
    The syntax for the `EXPOSE` instruction is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`指令是记录镜像期望在使用Dockerfile构建的镜像运行容器时打开的网络端口的一种方式。`EXPOSE`指令的语法如下：'
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is important to understand that including the `EXPOSE` instruction in the
    Dockerfile does not actually open network ports in containers. When containers
    are run from the images with the `EXPOSE` instruction in their Dockerfile, it
    is still necessary to include the `-p` or `-P` parameters to actually open the
    network ports to the container.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，在Dockerfile中包含`EXPOSE`指令实际上并不会在容器中打开网络端口。当从具有`EXPOSE`指令的Dockerfile中的镜像运行容器时，仍然需要包括`-p`或`-P`参数来实际打开网络端口到容器。
- en: You can include multiple `EXPOSE` instructions in your Dockerfile as needed. Including
    the `-P` parameter at runtime is a shortcut way to automatically open ports for
    all of the `EXPOSE` instructions included in the Dockerfile. The corresponding
    host ports will be randomly assigned when using the `-P` parameter on the run
    command.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 根据需要在Dockerfile中包含多个`EXPOSE`指令。在运行时包括`-P`参数是一种快捷方式，可以自动打开Dockerfile中包含的所有`EXPOSE`指令的端口。在运行命令时使用`-P`参数时，相应的主机端口将被随机分配。
- en: Think of the `EXPOSE` instruction as a message from the image developer telling
    you that the application in the image is expecting you to open the indicated port(s)
    when you run your containers. The `EXPOSE` instruction creates a zero-byte-sized layer
    in the resulting image.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 将`EXPOSE`指令视为镜像开发者向您传达的信息，告诉您在运行容器时，镜像中的应用程序期望您打开指定的端口。`EXPOSE`指令在生成的镜像中创建一个大小为零字节的层。
- en: The RUN instruction
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RUN指令
- en: 'The `RUN` instruction is the real workhorse of the Dockerfile. It is the tool
    by which you affect the most change in the resulting docker image. Basically,
    it allows you to execute any command in the image. There are two forms of the
    `RUN` instruction. Here is the syntax:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令是Dockerfile的真正工作马。这是您对生成的Docker镜像产生最大变化的工具。基本上，它允许您在镜像中执行任何命令。`RUN`指令有两种形式。以下是语法：'
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Every `RUN` instruction creates a new layer in the image, and the layers for
    each instruction that follow will be built on the results of the `RUN` instruction''s
    layer. The shell form of the instruction will use the default shell unless it
    is overridden using a `SHELL` instruction, which we will discuss in *The SHELL
    instruction* section. If you are building a container that does not include a
    shell, you will need to use the exec form of the `RUN` instruction. You can also
    use the exec form of the instruction to use a different shell. For example, to
    run a command using the bash shell, you could add a `RUN` instruction, like so:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`RUN`指令在镜像中创建一个新的层，随后的每个指令的层都将建立在`RUN`指令的层的结果之上。除非使用`SHELL`指令覆盖，默认情况下，shell形式的指令将使用默认shell。如果您正在构建一个不包含shell的容器，您将需要使用`RUN`指令的exec形式。您还可以使用exec形式的指令来使用不同的shell。例如，要使用bash
    shell运行命令，您可以添加一个`RUN`指令，如下所示：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The uses for the `RUN` command are limited only by the imagination, so providing
    an exhaustive list of `RUN` instruction samples would be impossible, but here
    are a few using both forms of the instruction, just to give you some ideas:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`命令的用途仅受想象力的限制，因此提供`RUN`指令示例的详尽列表是不可能的，但以下是一些使用两种形式的指令的示例，只是为了给您一些想法：'
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There is a fun and useful `RUN` instruction you can add when you know your
    image will include bash. This idea was shared with me by my colleague *Marcello
    de Sales* after he learned of it at Dockercon 16.You can use the following code
    to create a custom prompt displayed when you shell into your containers. If you
    don''t like the whale graphic, you can switch it up and use anything you like
    better. I''ve included some of my favorite options. Here''s the code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当您知道您的镜像将包含bash时，可以添加一个有趣且有用的`RUN`指令。这个想法是我在Dockercon 16上得知的，由我的同事*Marcello
    de Sales*与我分享。您可以使用以下代码在shell进入容器时创建自定义提示。如果您不喜欢鲸鱼图形，可以更改并使用任何您喜欢的东西。我包括了一些我喜欢的选项。以下是代码：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The resulting prompt looks like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的提示如下：
- en: '![](Images/2d0c1502-1539-4012-9e25-d472c87bea18.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2d0c1502-1539-4012-9e25-d472c87bea18.png)'
- en: The CMD instruction
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`CMD`指令'
- en: 'The `CMD` instruction is used to define the default action taken when containers
    are run from images built with their Dockerfile. While it is possible to include
    more than one `CMD` instruction in a Dockerfile, only the last one will be significant.
    Essentially, the final `CMD` instruction provides the default action for the image.
    This allows you to either override or use the `CMD` in the image used in the `FROM`
    instruction of your Dockerfile. Here is an example where a trivial Dockerfile
    does not contain a `CMD` instruction and relies on the one found in the ubuntu
    image used in the `FROM` instruction:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`指令用于定义从使用其Dockerfile构建的镜像运行容器时采取的默认操作。虽然在Dockerfile中可以包含多个`CMD`指令，但只有最后一个才会有意义。基本上，最后一个`CMD`指令为镜像提供了默认操作。这允许您在Dockerfile的`FROM`指令中覆盖或使用镜像中的`CMD`。以下是一个示例，其中一个微不足道的Dockerfile不包含`CMD`指令，并依赖于在`FROM`指令中使用的ubuntu镜像中找到的指令：'
- en: '![](Images/2c1f6b2e-a069-432c-a891-fb4eb69f7bab.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2c1f6b2e-a069-432c-a891-fb4eb69f7bab.png)'
- en: You can see from the output of the history command that the ubuntu image includes
    the `CMD ["/bin/bash"]` instruction. You will also see that our Dockerfile does
    not have its own `CMD` instruction. When we run the container, the default action
    is to run `"/bin/bash"`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从history命令的输出中看到，ubuntu镜像包括`CMD ["/bin/bash"]`指令。您还会看到我们的Dockerfile没有自己的`CMD`指令。当我们运行容器时，默认操作是运行`"/bin/bash"`。
- en: There are three forms of the `CMD` instruction. The first is a shell form. The
    second is an exec form, which is the best practice form to use. And, the third
    is a special exec form that has exactly two parameters, and it is used in conjunction
    with the `ENTRYPOINT` instruction, which we will talk about in *The ENTRYPOINT*
    *instruction* section. Here is the syntax for the `CMD` instruction.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`指令有三种形式。第一种是shell形式。第二种是exec形式，这是最佳实践形式。第三种是特殊的exec形式，它有两个参数，并且与`ENTRYPOINT`指令一起使用，我们将在*ENTRYPOINT指令*部分讨论它。以下是`CMD`指令的语法。'
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here are a few `CMD` instruction examples for your enjoyment:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些`CMD`指令的示例供您参考：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Like the `RUN` instruction, the shell form of the `CMD` instruction will use
    the `["/bin/sh", "-c"]` shell command (or `["cmd", "/S", "/C"]` for Windows) by
    default unless it is overridden with a `SHELL` instruction. However, unlike the
    `RUN` instruction, the `CMD` instruction does not execute anything during the
    building of the image but instead is executed when containers built from the image
    are run. If the container image being built will not have a shell, then the exec
    form of the instruction can be used as it does not invoke a shell. The `CMD` instruction
    adds a zero-byte-sized layer to the image.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与`RUN`指令一样，`CMD`指令的shell形式默认使用`["/bin/sh", "-c"]` shell命令（或`["cmd", "/S", "/C"]`用于Windows），除非它被`SHELL`指令覆盖。然而，与`RUN`指令不同，`CMD`指令在构建镜像时不执行任何操作，而是在从镜像构建的容器运行时执行。如果正在构建的容器镜像没有shell，则可以使用指令的exec形式，因为它不会调用shell。`CMD`指令向镜像添加了一个大小为零字节的层。
- en: The ENTRYPOINT instruction
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ENTRYPOINT指令
- en: 'The `ENTRYPOINT` instruction is used to configure a docker image to run like
    an application or a command. For example, we can use the `ENTRYPOINT` instruction
    to make an image that displays help for the `curl` command. Consider this Dockerfile:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`指令用于配置docker镜像以像应用程序或命令一样运行。例如，我们可以使用`ENTRYPOINT`指令制作一个显示`curl`命令帮助信息的镜像。考虑这个Dockerfile：'
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can run the container image with no overriding `CMD` parameter and it will
    show help for the `curl` command. However, when we run the container with a `CMD`
    override parameter, in this case, a URL, the response will be to `curl` the URL.
    Take a look:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行容器镜像，不覆盖`CMD`参数，它将显示`curl`命令的帮助信息。然而，当我们用`CMD`覆盖参数运行容器时，在这种情况下是一个URL，响应将是`curl`该URL。看一下：
- en: '![](Images/71810ef5-9fe0-439d-963f-7a03c6b758df.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/71810ef5-9fe0-439d-963f-7a03c6b758df.png)'
- en: 'When run parameters are provided to a container that has the exec form of the
    `ENTRYPOINT` command, those parameters will be appended to the `ENTRYPOINT` instruction,
    overriding anything provided in a `CMD` instruction. In this example, `--help` is
    overridden with the `google.com` run parameter, so the resulting instruction is
    `curl google.com`. Here is the actual syntax for the `ENTRYPOINT` instruction:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当为具有`ENTRYPOINT`指令的exec形式的容器提供运行参数时，这些参数将附加到`ENTRYPOINT`指令，覆盖`CMD`指令中提供的任何内容。在这个例子中，`--help`被`google.com`运行参数覆盖，所以结果指令是`curl
    google.com`。以下是`ENTRYPOINT`指令的实际语法：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Like the `CMD` instruction, only the last `ENTRYPOINT` instruction is significant.
    Again, this allows you to either use or override the `ENTRYPOINT` instruction
    in the `FROM` image used. Like both the `RUN` and `CMD` instructions, using the
    shell form will invoke a shell as `["/bin/sh", "-c"]` (or `["cmd", "/S", "/C"]`
    on Windows). This is not the case when using the exec form of the instruction.
    This is key if you have an image that does not have a shell or if the shell is
    not available to the active user context. However, you will not get shell processing,
    so any shell environment variables will not get substituted when using the exec
    form of the instruction. It is generally considered best practice to use the exec
    form of the `ENTRYPOINT` instruction whenever possible.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与`CMD`指令一样，只有最后一个`ENTRYPOINT`指令是重要的。同样，这允许您在使用`FROM`镜像时使用或覆盖`ENTRYPOINT`指令。与`RUN`和`CMD`指令一样，使用shell形式将调用`["/bin/sh",
    "-c"]`（或在Windows上为`["cmd", "/S", "/C"]`）。当使用指令的exec形式时，情况并非如此。这对于没有shell或shell不可用于活动用户上下文的镜像非常重要。但是，您将不会获得shell处理，因此在使用指令的exec形式时，任何shell环境变量都不会被替换。通常最好尽可能使用`ENTRYPOINT`指令的exec形式。
- en: The difference between CMD and ENTRYPOINT
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMD和ENTRYPOINT之间的区别
- en: Here again, we have two instructions that on the surface seem to be very much
    the same. It is true that there is some overlap of functionality between the two.
    Both instructions provide a way to define a default application that is executed
    when containers are run. However, they each serve their own unique purpose, and
    in some cases work together to provide greater functionality than either instruction
    alone.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次有两个表面上看起来非常相似的指令。事实上，它们之间确实有一些功能重叠。这两个指令都提供了一种定义在运行容器时执行的默认应用程序的方法。然而，它们各自有其独特的目的，并且在某些情况下共同工作，以提供比任何一条指令单独提供的更大的功能。
- en: The best practice is to use the `ENTRYPOINT` instruction when you want a container
    to execute as an application, providing a specific (developer) defined function,
    and to use `CMD` when you want to give the user more flexibility in what function
    the container will serve.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是在希望容器作为应用程序执行、提供特定（开发者）定义的功能时使用`ENTRYPOINT`指令，并在希望为用户提供更多灵活性以确定容器将提供的功能时使用`CMD`。
- en: 'Both of these instructions have two forms: a shell form and an exec form. It
    is best practice to use the exec form of either whenever possible. The reason
    for this is that the shell form, by definition, will run `["/bin/sh", "-c"]` (or `["cmd",
    "/S", "/C"]` on Windows) to launch the application in the parameter of the instruction.
    Because of this, the primary process running in the container is not the application.
    Instead, it is the shell. This affects how the container exits, it affects how
    signals are processed, and it can really cause problems for images that do not
    include `"/bin/sh"`. One use case where you might need to use the shell form is
    if you require shell-environment-variable substitution.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个指令都有两种形式：shell形式和exec形式。最佳实践是尽可能使用任何一种的exec形式。原因是，shell形式将运行`["/bin/sh",
    "-c"]`（或在Windows上为`["cmd", "/S", "/C"]`）来启动指令参数中的应用程序。由于这个原因，运行在容器中的主要进程不是应用程序，而是shell。这会影响容器的退出方式，影响信号的处理方式，并且可能会对不包括`"/bin/sh"`的镜像造成问题。您可能需要使用shell形式的一个用例是如果您需要shell环境变量替换。
- en: There is also a use case for using both instructions in your Dockerfile. When
    you use both, you can define a specific application that gets executed when the
    container is run, and allow the user to easily provide the parameters that get
    used with the defined application. In this scenario, you would use the `ENTRYPOINT`
    instruction to set the application being executed and provide a default set of
    parameters for the application using the `CMD` instruction. With this configuration,
    the user of the container can benefit from the default parameters supplied in
    the `CMD` instruction, or they can easily override those parameters used in the
    application by supplying them as arguments in the `container run` command. It
    is highly recommended that you use the exec form of both instructions when you
    use them together.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dockerfile中还有一个使用两个指令的用例。当您同时使用两者时，可以定义在运行容器时执行的特定应用程序，并允许用户轻松提供与定义的应用程序一起使用的参数。在这种情况下，您将使用`ENTRYPOINT`指令设置要执行的应用程序，并使用`CMD`指令为应用程序提供一组默认参数。通过这种配置，容器的用户可以从`CMD`指令中提供的默认参数中受益，或者他们可以通过在`container
    run`命令中提供参数作为参数轻松覆盖应用程序中使用的这些参数。强烈建议在同时使用两个指令时使用它们的exec形式。
- en: The HEALTHCHECK instruction
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`HEALTHCHECK`指令'
- en: 'The `HEALTHCHECK` instruction, which is a fairly new addition to the Dockerfile,
    is used to define the command to run inside a container to test the container''s
    application health. When a container has a `HEALTHCHECK`, it gets a special status
    variable. Initially, that variable will be set to `starting`. Any time a `HEALTHCHECK`
    is performed successfully, the status will be set to `healthy`. When a `HEALTHCHECK`
    is performed and fails, the fail count value will be incremented and then checked
    against a retries value. If the fail count equals or exceeds the retries value,
    the status is set to `unhealthy`. The syntax of the `HEALTHCHECK` instruction
    is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEALTHCHECK`指令是Dockerfile中相对较新的添加，用于定义在容器内运行的命令，以测试容器的应用程序健康状况。当容器具有`HEALTHCHECK`时，它会获得一个特殊的状态变量。最初，该变量将被设置为`starting`。每当成功执行`HEALTHCHECK`时，状态将被设置为`healthy`。当执行`HEALTHCHECK`并失败时，失败计数值将被递增，然后与重试值进行比较。如果失败计数等于或超过重试值，则状态将被设置为`unhealthy`。`HEALTHCHECK`指令的语法如下：'
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There are four options that can be used when setting the `HEALTHCHECK`, and
    these options are as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置`HEALTHCHECK`时有四个选项可用，这些选项如下：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `--interval` option allows you to define the amount of time between the
    `HEALTHCHECK` tests. The `--timeout` option allows you to define the amount of
    time that is considered too long for a `HEALTHCHECK` test. If the timeout is exceeded,
    the test is automatically considered a failure. The `--start-period` option allows
    for the definition of a no-fail time period during the container startup. Finally,
    the `--retries` option allows you to define how many consecutive failures it takes
    to update the `HEALTHCHECK` status to `unhealthy`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`--interval`选项允许您定义`HEALTHCHECK`测试之间的时间间隔。`--timeout`选项允许您定义被视为`HEALTHCHECK`测试时间过长的时间量。如果超过超时时间，测试将自动视为失败。`--start-period`选项允许在容器启动期间定义一个无失败时间段。最后，`--retries`选项允许您定义多少连续失败才能将`HEALTHCHECK`状态更新为`unhealthy`。'
- en: 'The `CMD` part of the `HEALTHCHECK` instruction follows the same rules as the
    `CMD` instruction. Please review the preceding section regarding the `CMD` instruction
    for complete details. The `CMD` that is used will provide a status when it exits,
    which will be either a 0 for success or a 1 for fail. Here is a Dockerfile example
    that uses the `HEALTHCHECK` instruction:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEALTHCHECK`指令的`CMD`部分遵循与`CMD`指令相同的规则。有关`CMD`指令的完整详情，请参阅前面的部分。使用的`CMD`在退出时将提供一个状态，该状态要么是成功的0，要么是失败的1。以下是使用`HEALTHCHECK`指令的Dockerfile示例：'
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Running a container from an image built with the preceding Dockerfile looks
    like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述Dockerfile构建的镜像运行容器如下：
- en: '![](Images/5a4d6561-c20e-4f21-94d0-0de027616a41.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5a4d6561-c20e-4f21-94d0-0de027616a41.png)'
- en: You can see that the `HEALTHCHECK` initially reported a status of `starting`,
    but once the `HEALTHCHECK` `CMD` reported success, the status updated to `healthy`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`HEALTHCHECK`最初报告状态为`starting`，但一旦`HEALTHCHECK` `CMD`报告成功，状态就会更新为`healthy`。
- en: The ONBUILD instruction
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ONBUILD指令
- en: 'The `ONBUILD` instruction is a tool used when creating images that will become
    the parameter to the `FROM` instructions in another Dockerfile. The `ONBUILD`
    instruction just adds metadata to your image, specifically a trigger that is stored
    in the image and not otherwise used. However, that metadata trigger does get used
    when your image is supplied as the parameter in the `FROM` command of another
    Dockerfile. Here is the `ONBUILD` instruction syntax:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令是在创建将成为另一个Dockerfile中`FROM`指令参数的镜像时使用的工具。`ONBUILD`指令只是向您的镜像添加元数据，具体来说是存储在镜像中而不被其他方式使用的触发器。然而，当您的镜像作为另一个Dockerfile中`FROM`命令的参数提供时，该元数据触发器会被使用。以下是`ONBUILD`指令的语法：'
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `ONBUILD` instruction is kind of like a Docker time machine used to send
    instructions into the future. (You might laugh if you knew how many times I just
    typed *Doctor time machine*!) Let''s demonstrate the use of the `ONBUILD` instruction
    with a simple example. First, we will build an image named `my-base` using the
    following Dockerfile:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令有点像Docker时间机器，用于将指令发送到未来。（如果您知道我刚刚输入*Doctor time machine*多少次，您可能会笑！）让我们用一个简单的例子来演示`ONBUILD`指令的使用。首先，我们将使用以下Dockerfile构建一个名为`my-base`的镜像：'
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, let''s build an image named `my-app` that is built `FROM` the `my-base`
    image, like so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们构建一个名为`my-app`的镜像，该镜像是从`my-base`镜像构建的，如下所示：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Inspecting the resulting `my-app` image shows us that the LABEL commands provided
    in the `ONBUILD` instructions were sent forward in time, arriving at the `my-app`
    image:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 检查生成的`my-app`镜像，我们可以看到`ONBUILD`指令中提供的LABEL命令被发送到未来，到达`my-app`镜像：
- en: '![](Images/a1594a9a-5813-48bd-ae3e-0c40d9ed65b3.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a1594a9a-5813-48bd-ae3e-0c40d9ed65b3.png)'
- en: If you did a similar inspect of the `my-base` image, you would find that it
    does *not* contain the version and support labels. Note also that the `ONBUILD`
    instruction is a one-time-use time machine. If you were to build a new image using
    the `my-app` in the `FROM` instruction, the new image would *not* get the labels
    that were provided in the ONBUILD instructions of the `my-base` image.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对`my-base`镜像进行类似的检查，您会发现它*不*包含版本和支持标签。还要注意，`ONBUILD`指令是一次性使用的时间机器。如果您使用`FROM`指令中的`my-app`构建一个新的镜像，新的镜像将*不*获得`my-base`镜像的ONBUILD指令中提供的标签。
- en: The STOPSIGNAL instruction
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STOPSIGNAL指令
- en: 'The `STOPSIGNAL` instruction is used to set the system call signal that will
    be sent to the container to tell it to exit. The parameter used in the instruction
    can be an unsigned number, which equals a position in the kernel''s syscall table,
    or it can be an actual signal name in uppercase. Here is the syntax for the instruction:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`STOPSIGNAL`指令用于设置系统调用信号，该信号将被发送到容器，告诉它退出。指令中使用的参数可以是无符号数字，等于内核系统调用表中的位置，也可以是大写的实际信号名称。以下是该指令的语法：'
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Examples of the `STOPSIGNAL` instruction include the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`STOPSIGNAL`指令的示例包括以下内容：'
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The parameter supplied to the `STOPSIGNAL` instruction is used when a `docker
    container stop` command is issued. Remember that it is vital to use the exec form
    of your `ENTRYPOINT` and/or `CMD` instructions so that the application is PID
    1, and will receive the signals directly. Here is a link to an excellent blog
    post on using signals with Docker: [https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86](https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86).
    The article provides an excellent example of using a node.js app to handle the
    signals, complete with code and Dockerfile.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`STOPSIGNAL`指令提供的参数在发出`docker container stop`命令时使用。请记住，使用`ENTRYPOINT`和/或`CMD`指令的执行形式非常重要，以便应用程序成为PID
    1，并直接接收信号。以下是有关在Docker中使用信号的出色博客文章链接：[https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86](https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86)。该文章提供了使用node.js应用程序处理信号的出色示例，包括代码和Dockerfile。'
- en: The SHELL instruction
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`SHELL`指令'
- en: 'As you have read in many sections throughout this chapter, there are several
    instructions that take two forms, the exec form or the shell form. As mentioned,
    the default used by all of the shell forms is `["/bin/sh", "-c"]` for Linux containers,
    and `["cmd", "/S", "/C"]` for Windows containers. The `SHELL` instruction allows
    you to change that default. Here is the syntax for the `SHELL` instruction:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本章的许多部分中所阅读的，有几个指令有两种形式，即执行形式或shell形式。如前所述，所有shell形式默认使用`["/bin/sh", "-c"]`用于Linux容器，以及`["cmd",
    "/S", "/C"]`用于Windows容器。`SHELL`指令允许您更改该默认设置。以下是`SHELL`指令的语法：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `SHELL` instruction can be used more than once in a Dockerfile. All instructions
    that use a shell, and that come after a `SHELL` instruction, will use the new
    shell. Thus, you can change the shell multiple times in a single Dockerfile as
    needed. This can be especially powerful when creating Windows containers since
    it allows you to switch back and forth between using `cmd.exe` and `powershell.exe`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`SHELL`指令可以在Dockerfile中使用多次。所有使用shell的指令，并且在`SHELL`指令之后，将使用新的shell。因此，根据需要可以在单个Dockerfile中多次更改shell。在创建Windows容器时，这可能特别有用，因为它允许您在`cmd.exe`和`powershell.exe`之间来回切换。'
- en: The Docker image build command
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker镜像构建命令
- en: 'OK, so the image build command is not a Dockerfile instruction. Instead, it
    is the docker command that is used to turn your Dockerfile into a docker image.
    The Docker image build command sends the docker build context, including the Dockerfile,
    to the docker daemon, which parses the Dockerfile and builds the image layer by
    layer. We will discuss the build context shortly, but for now, consider it to
    be everything that is needed to build the Docker image based on the content found
    in the Dockerfile. The build command syntax is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，镜像构建命令不是Dockerfile指令。相反，它是用于将Dockerfile转换为docker镜像的docker命令。Docker镜像构建命令将docker构建上下文，包括Dockerfile，发送到docker守护程序，它解析Dockerfile并逐层构建镜像。我们将很快讨论构建上下文，但现在可以将其视为根据Dockerfile中的内容构建Docker镜像所需的一切。构建命令的语法如下：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There are many options for the image build command. We will not be covering
    all of the options now, but let''s take a look at a few of the most common:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图像构建命令有许多选项。我们现在不会涵盖所有选项，但让我们看一下一些最常见的选项：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The Docker daemon builds the image by creating a new image from each command
    in the Dockerfile. Each new image is built upon the previous. Using the optional
    `--rm` parameter will instruct the daemon to delete all the intermediate images
    when the build completes successfully. Using this will slow the build process
    when you rebuild a successfully built image, but will keep the local image cache
    cleaner.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护程序通过从Dockerfile中的每个命令创建新的图像来构建图像。每个新图像都是在前一个图像的基础上构建的。使用可选的`--rm`参数将指示守护程序在构建成功完成时删除所有中间图像。当重新构建成功构建的图像时，使用此选项将减慢构建过程，但会保持本地图像缓存的清洁。
- en: We have already talked about build args when we covered the `ARG` instruction.
    Remember that the `--build-arg` option is how you provide a value to the `ARG`
    instruction in the Dockerfile.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论`ARG`指令时，我们已经谈到了构建参数。请记住，`--build-arg`选项是您如何为Dockerfile中的`ARG`指令提供值。
- en: The `--tag` option allows you to give your images a more human-readable name
    and version. We have seen this option used in several of the earlier examples
    as well.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`--tag`选项允许您为图像指定一个更易读的名称和版本。我们在之前的几个示例中也看到了这个选项的使用。'
- en: The `--file` option allows you to use a filename other than Dockerfile, and
    to keep the Dockerfile in a path other than the build context folder.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`--file`选项允许您使用文件名而不是Dockerfile，并将Dockerfile保留在构建上下文文件夹之外的路径中。'
- en: 'Here are some image build commands for reference:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些图像构建命令供参考：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You will notice the trailing `.` in each of the preceding examples. This period
    is indicating that the current working directory is the root of the build context
    for the image build.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到前面每个示例中都有一个尾随的`。`。这个句号表示当前工作目录是图像构建的构建上下文的根目录。
- en: Parser Directives
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析指令
- en: 'Parser Directives are a special subset of optional comment lines in the Dockerfile.
    Any parser directives must occur before the first normal comment line. They must
    also precede any blank lines or other build instructions, including the `FROM`
    instruction. Basically, all parser directives must be at the very top of the Dockerfile. By
    the way, if you haven''t figured it out yet, you can create a normal comment line
    in a Dockerfile by starting that line with a `#` character. The syntax for a parser
    directive is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 解析指令是Dockerfile中可选注释行的一个特殊子集。任何解析指令必须出现在第一个正常注释行之前。它们还必须出现在任何空行或其他构建指令之前，包括`FROM`指令。基本上，所有解析指令必须位于Dockerfile的顶部。顺便说一句，如果你还没有弄清楚，你可以通过以`#`字符开头来创建一个普通的注释行。解析指令的语法如下：
- en: '[PRE42]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So, what can you do with a parser directive? Well right now, the only one supported
    is `escape`. The `escape` parser directive is used to change what character is
    used to indicate that the next character in the instruction is to be treated as
    a character and not as the special character it represents. The default value
    if no parser directive is used is `\`. You have seen this used in several examples
    throughout this chapter to escape the newline character, allowing for instructions
    to be continued onto the next line in the Dockerfile. If it is necessary to use
    a different `escape` character, you can use the `escape` parser directive to handle
    that. You can set the `escape` character to one of two choices:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，您可以使用解析器指令做什么呢？目前，唯一支持的是`escape`。`escape`解析器指令用于更改用于指示下一个字符在指令中被视为字符而不是表示的特殊字符的字符。如果不使用解析器指令，则默认值为`\`。在本章的几个示例中，您已经看到了它用于转义换行符，允许在Dockerfile中将指令继续到下一行。如果需要使用不同的`escape`字符，可以使用`escape`解析器指令来处理。您可以将`escape`字符设置为两种选择之一：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: One example where you might want to change the character used as the `escape`
    character is when you are creating a Dockerfile on Windows systems. As you know,
    the `\` is used to distinguish folder levels in path strings, such as `c:\windows\system32
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是当您在Windows系统上创建Dockerfile时可能需要更改用作`escape`字符的字符。如您所知，`\`用于区分路径字符串中的文件夹级别，例如`c:\windows\system32`。
- en: '\drivers`. Switching to the backtick for the `escape` character will avoid
    needing to escape such strings as this: `c:\\windows\\system32\\drivers`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: \drivers`。切换到使用`escape`字符的反引号将避免需要转义此类字符串，例如：`c:\\windows\\system32\\drivers`。
- en: The build context
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建上下文
- en: The build context is everything that gets sent to the Docker daemon when using
    the build image command. This includes the Dockerfile and the contents of the
    current working directory when the build command is issued, including all subdirectories
    that the current working directory may contain. It is possible to have the Dockerfile
    in a directory other than the current working directory by using a `-f` or `--file` option,
    but the Dockerfile still gets sent with the build context. Using the `.dockerignore`
    file, you can exclude files and folders from the build context when it gets sent
    to the Docker daemon.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 构建上下文是在使用构建镜像命令时发送到Docker守护程序的所有内容。这包括Dockerfile和发出构建命令时当前工作目录的内容，包括当前工作目录可能包含的所有子目录。可以使用`-f`或`--file`选项将Dockerfile放在当前工作目录以外的目录中，但Dockerfile仍然会随构建上下文一起发送。使用`.dockerignore`文件，可以在发送到Docker守护程序的构建上下文中排除文件和文件夹。
- en: 'When building Docker images, it is very important to keep the build context
    as small as possible. This is because the entire build context is sent to the
    Docker daemon for building the image. If you have unnecessary files and folders
    in the build context, then it will slow the build process, and depending on the
    contents of the Dockerfile, can result in bloated images. This is such an important
    consideration, that every image build command displays the size of the build context
    as the first line of the command''s output. It looks like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Docker镜像时，非常重要的是尽可能保持构建上下文的大小。这是因为整个构建上下文都会发送到Docker守护程序以构建镜像。如果构建上下文中有不必要的文件和文件夹，那么它将减慢构建过程，并且根据Dockerfile的内容，可能会导致膨胀的镜像。这是一个如此重要的考虑因素，以至于每个镜像构建命令都会在命令输出的第一行显示构建上下文的大小。它看起来像这样：
- en: '![](Images/b0300473-f75d-45ad-8bb7-c37fd77987bf.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b0300473-f75d-45ad-8bb7-c37fd77987bf.png)'
- en: 'The build context becomes the filesystem root for the commands in the Dockerfile.
    For example, consider using the following `COPY` instruction:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 构建上下文成为Dockerfile中命令的文件系统根。例如，考虑使用以下`COPY`指令：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This tells the Docker daemon to copy the `hello` file from the root of the build
    context into the root of the container image.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Docker守护程序将`hello`文件从构建上下文的根目录复制到容器镜像的根目录。
- en: 'If the command completes successfully, the image ID will be displayed, and
    if a `--tag` option is provided, the new tag and version will be shown as well:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令成功完成，将显示镜像ID，如果提供了`--tag`选项，则还将显示新的标签和版本：
- en: '![](Images/a22a41a4-e7bb-47ec-8112-2e22153de989.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a22a41a4-e7bb-47ec-8112-2e22153de989.png)'
- en: One of the keys to keeping the build context small is the use of a `.dockerignore`
    file.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 保持构建上下文小的关键之一是使用`.dockerignore`文件。
- en: The .dockerignore file
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .dockerignore文件
- en: If you are familiar with using `.gitignore` files, then you will already have
    a basic understanding of the purpose for the `.dockerignore` file. The `.dockerignore`
    file is used to exclude files that you do not want to be included with the build
    context during a docker image build. Using it helps to prevent sensitive and other
    unwanted files from being included in the build context, and potentially in the
    docker image. It is an excellent tool to help keep your Docker images small.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉使用`.gitignore`文件，那么您已经基本了解了`.dockerignore`文件的目的。`.dockerignore`文件用于排除在docker镜像构建过程中不想包含在构建上下文中的文件。使用它有助于防止敏感和其他不需要的文件被包含在构建上下文中，可能最终出现在docker镜像中。这是一个帮助保持Docker镜像小的绝佳工具。
- en: The `.dockerignore` file needs to be in the root folder of the build context.
    Like a `.gitignore` file, it uses a newline-separated list of patterns. Comments
    in the `.dockerignore` file are denoted by a `#` as the first character of a line.
    You can override a pattern by including an exception line. An exception line is
    denoted with a `!` as the first character of the line. All other lines are considered
    patterns to use to exclude files and/or folders.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dockerignore`文件需要位于构建上下文的根文件夹中。与`.gitignore`文件类似，它使用一个以换行符分隔的模式列表。`.dockerignore`文件中的注释以`#`作为行的第一个字符。您可以通过包含一个例外行来覆盖模式。例外行以`!`作为行的第一个字符。所有其他行都被视为用于排除文件和/或文件夹的模式。'
- en: 'Line order in the `.dockerignore` file is significant. Matching patterns of
    lines later in the file will override matching lines earlier in the file. If you
    add a pattern that matches the `.dockerignore` file or the Dockerfile file, they
    will still be sent to the docker daemon with the build context, but they will
    not be available to any `ADD` or `COPY` instructions, and therefore cannot end
    up in the resulting image. Here is an example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dockerignore`文件中的行顺序很重要。文件后面的匹配模式将覆盖文件前面的匹配模式。如果您添加一个与`.dockerignore`文件或Dockerfile文件匹配的模式，它们仍将与构建上下文一起发送到docker守护程序，但它们将不可用于任何`ADD`或`COPY`指令，因此不能出现在生成的镜像中。这是一个例子：'
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: OK! That was an adventure. You should now be able to build any type of Docker
    image that your heart desires. You know when to use `COPY` versus `ADD`, when
    to use `ENV` versus `ARG`, and perhaps most importantly, when to use `CMD` versus
    `ENTERYPOINT`. You even learned how to travel through time! This information is
    really a great foundation for getting started with Docker and will serve as a
    great reference as you develop more complex Docker images.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！那是一次冒险。现在您应该能够构建任何类型的Docker镜像。您知道何时使用`COPY`而不是`ADD`，何时使用`ENV`而不是`ARG`，也许最重要的是何时使用`CMD`而不是`ENTERYPOINT`。您甚至学会了如何穿越时间！这些信息对于开始使用Docker来说真的是一个很好的基础，并且在您开发更复杂的Docker镜像时将作为一个很好的参考。
- en: I hope you have learned a lot from this chapter, but we still have more to learn,
    so let's turn our attention to the next topic. In [Chapter 4](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml), *Docker
    Volumes*, we are going to learn more about Docker volumes. Turn the page and let's
    continue our quick-start journey.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你从这一章学到了很多，但我们还有更多要学习，所以让我们把注意力转向下一个主题。在[第4章](6e908793-3bc0-45f3-bcb5-af85ac6aecab.xhtml)
    *Docker Volumes*中，我们将学习更多关于Docker卷的知识。翻页，让我们继续我们的快速入门之旅。
- en: References
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Check out the following links for information about topics discussed in this
    chapter:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下链接，获取本章讨论的主题信息：
- en: The hello-world GitHub repository: [https://github.com/docker-library/hello-world](https://github.com/docker-library/hello-world)
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: hello-world GitHub存储库：[https://github.com/docker-library/hello-world](https://github.com/docker-library/hello-world)
- en: Docker volumes: [https://docs.docker.com/storage/volumes/](https://docs.docker.com/storage/volumes/)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker卷：[https://docs.docker.com/storage/volumes/](https://docs.docker.com/storage/volumes/)
- en: Using signals with Docker: [https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86](https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86)
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker的信号：[https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86](https://medium.com/@gchudnov/trapping-signals-in-docker-containers-7a57fdda7d86)
- en: The `.dockerignore` reference document: [https://docs.docker.com/engine/reference/builder/#dockerignore-file](https://docs.docker.com/engine/reference/builder/#dockerignore-file)
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.dockerignore`参考文档：[https://docs.docker.com/engine/reference/builder/#dockerignore-file](https://docs.docker.com/engine/reference/builder/#dockerignore-file)'
- en: Best practices for the Dockerfile: [https://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/](https://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile的最佳实践：[https://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/](https://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/)
