- en: '*Chapter 14*: Error Handling'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：错误处理'
- en: Historically, managing runtime errors has always been a hard problem to solve
    because of their complex and different natures, spanning from hardware failures
    to business logic errors.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，管理运行时错误一直是一个难题，因为它们的性质复杂而不同，涵盖了从硬件故障到业务逻辑错误的各种情况。
- en: Some of these errors, such as *division by zero* and *null dereferencing*, are
    generated by the CPU itself as an exception, while others are generated at the
    software level and propagated either as an exception or as an error code, depending
    on the runtime and programming language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些错误，如*除以零*和*空指针解引用*，是由CPU本身作为异常生成的，而其他一些是在软件级别生成的，并根据运行时和编程语言作为异常或错误代码传播。
- en: The .NET platform has been designed to manage an error condition through an
    exception strategy, which has the big advantage of dramatically simplifying the
    handling code. This means that any property or method may throw an exception and
    communicate the error condition through exception objects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: .NET平台已经设计了通过异常策略来管理错误条件，这具有极大的优势，可以大大简化处理代码。这意味着任何属性或方法都可能抛出异常，并通过异常对象传达错误条件。
- en: Throwing exceptions raises an important question—*is the exception part of the
    contract between the library implementor and its consumer, or is it, rather, an
    implementation detail?*
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出异常引发了一个重要问题——*异常是库实现者和其使用者之间的契约的一部分，还是实现细节？*
- en: 'In this chapter, we will start analyzing the language syntax needed to participate
    in the exception model either from a producer or consumer perspective. However,
    we will also need to go beyond the syntax, analyzing the implications for the
    developer seeking to debug the causes and the design problems related to both
    the error-throwing and error-handling sides. The following three sections of this
    chapter will cover these topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始分析语言语法，以便从生产者或消费者的角度参与异常模型。然而，我们还需要超越语法，分析开发人员寻求调试原因和与错误抛出和错误处理相关的设计问题的影响。本章的以下三个部分将涵盖这些主题：
- en: Errors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误
- en: Exceptions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常
- en: Debugging and monitoring exceptions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试和监控异常
- en: At the end of this chapter, you will be able to catch exceptions from existing
    libraries, understand whether a method should return a failure code or throw an
    exception, and create custom exception types whenever it makes sense to.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够捕获现有库中的异常，了解方法是否应返回失败代码或抛出异常，并在有意义时创建自定义异常类型。
- en: Errors
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误
- en: In software development, the two strategies used to manage errors are `winerror.h`
    file, even if they are both parts of the Windows operating system. In other words,
    error codes are not part of a standard and they need to be translated when the
    call traverses a boundary, such as a different operating system or runtime environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，用于管理错误的两种策略是`winerror.h`文件，即使它们都是Windows操作系统的一部分。换句话说，错误代码不是标准的一部分，当调用穿越边界时（如不同的操作系统或运行时环境），它们需要被转换。
- en: 'Another important aspect of error codes is that they are part of the method
    declaration. For example, it feels very natural defining the division method as
    follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 错误代码的另一个重要方面是它们是方法声明的一部分。例如，定义除法方法如下会感觉非常自然：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But if the denominator is `0`, we should communicate the invalid parameter
    error to the caller. Adopting error codes has a direct impact on the method signature,
    which in this case would be the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果分母是`0`，我们应该向调用者传达无效参数错误。采用错误代码对方法签名有直接影响，在这种情况下将是以下内容：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This last signature (which returns an error code of type integer) is not as
    neat as any library user would expect. Also, the calling code has the responsibility
    of determining whether the operation was successful or not, which opens up multiple
    issues.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最后的签名（返回整数类型的错误代码）并不像任何库用户所期望的那样整洁。此外，调用代码有责任确定操作是否成功，这会引发多个问题。
- en: 'The first problem is the complexity of the code checking for the error code,
    as in this example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是代码检查错误代码的复杂性，就像这个例子：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Assuming that `0` is the success code, the code inside each block must be indented,
    creating an annoying and confusing triangle as large as the number of called methods.
    Even by reversing the logic and checking the failure condition, the situation
    does not improve because of the number of `if` statements that must be in place
    to avoid nasty bugs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`0`是成功代码，每个块内部的代码都必须缩进，创建一个烦人且令人困惑的三角形，其大小与调用方法的数量一样大。即使通过逆转逻辑并检查失败条件，情况也不会改善，因为必须放置大量的`if`语句以避免讨厌的错误。
- en: The preceding code also shows a common situation where the `api.End()` method
    returns an apparently useless error code as it *ends* the sequence of calls while
    it could be required to handle it. This problem arises because the error codes
    leave the caller the responsibility to decide on the importance of the error severity.
    One of the advantages of the exceptions model is that it instead gives this power
    to the called method, which can *enforce* the severity of the error. This definitely
    makes more sense, as the severity is likely to be implementation-specific.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码还显示了一个常见情况，即`api.End()`方法返回一个看似无用的错误代码，因为它*结束*了调用序列，而实际上可能需要处理它。这个问题的根源在于错误代码将决定错误严重性的责任留给了调用者。异常模型的一个优点是它将这种权力交给了被调用的方法，它可以*强制执行*错误的严重性。这绝对更有意义，因为严重性很可能是特定于实现的。
- en: The preceding code also hides a potential performance issue due to the characteristic
    of modern CPUs providing a feature known as **branch prediction**, which is a
    sort of guess made by the CPU when pre-loading the instructions following a jump.
    Depending on many factors, the CPU may pre-load *one* path, making the others
    run slower because their code was not prefetched.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码也隐藏了一个潜在的性能问题，这是由于现代CPU的特性，提供了一种称为**分支预测**的功能，这是CPU在预加载跳转后的指令时所做的一种猜测。根据许多因素，CPU可能预加载*一条*路径，使其他路径运行得更慢，因为它们的代码没有被预取。
- en: Finally, as far as the type member properties are designed in all modern languages,
    they don't fit with the error codes because there is no syntax allowing the caller
    to be made aware of the error and so using an exception is the only way to communicate
    the problem.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就所有现代语言中设计的类型成员属性而言，它们与错误代码不匹配，因为没有语法允许调用者了解错误，因此使用异常是沟通问题的唯一方式。
- en: For all these reasons, when the .NET runtime was initially designed, the team
    decided to embrace the exception paradigm, which treats any error condition as
    *out-of-band information* and not a part of the method signature.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 出于所有这些原因，当.NET运行时最初设计时，团队决定采用异常范例，将任何错误条件视为*带外信息*，而不是方法签名的一部分。
- en: Exceptions
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: Exceptions are a mechanism provided by the runtime to make the execution suddenly
    interrupt and jump to the code handling the error. Since the handler may have
    been declared by any caller in the calling path, the runtime takes care of restoring
    the stack and any other outstanding `finally` block, which we will examine in
    the *The finally block* section of this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是运行时提供的一种机制，可以使执行突然中断并跳转到处理错误的代码。由于处理程序可能由调用路径中的任何调用者声明，运行时负责恢复堆栈和任何其他未完成的`finally`块，我们将在本章的*finally块*部分进行讨论。
- en: The calling code may want to handle the exception and if it does, it may decide
    to resume normal execution or just let the exception continue to the other handlers
    (if any). Whenever no handling code is provided by the application, the runtime
    catches the error condition and does the only reasonable thing—it terminates the
    application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 调用代码可能希望处理异常，如果是这样，它可以决定恢复正常执行，或者只是让异常继续传递给其他处理程序（如果有的话）。每当应用程序没有提供处理代码时，运行时都会捕获错误条件，并做唯一合理的事情——终止应用程序。
- en: This brings us back to the original question that we asked in the introduction—*is
    the exception part of the contract between the library implementor and its consumer,
    or is it rather an implementation detail?*
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们回到了我们在介绍中提出的最初问题——*异常是否是库实现者与其消费者之间的契约的一部分，还是一个实现细节？*
- en: Since the implementor communicates an anomaly to its callers through exceptions,
    it looks like the exception is a part of the contract. At least this has been
    the conclusion of other languages' implementors, including Java and C++, which
    gave the ability to specify the list of possible exceptions generated in the method.
    Anyway, the most recent C++ standards deprecated and later removed the exception
    specification in the declaration, leaving just the ability to specify whether
    a method may throw an exception or not.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实现者通过异常向其调用者传达异常情况，看起来异常是契约的一部分。至少这是其他语言实现者的结论，包括Java和C++，它们都具有指定方法生成的可能异常列表的能力。无论如何，最近的C++标准已经废弃并后来删除了声明中的异常规范，只留下了指定方法是否可能抛出异常的能力。
- en: The .NET platform decided not to tie exceptions to the method signature because
    it is considered an implementation detail. In fact, multiple implementations of
    the same interface or base class may use different technologies throwing different
    exceptions. For example, when you create a proxy to an object, you may require
    different types of exceptions to be thrown in addition to the ones declared in
    the proxied object.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: .NET平台决定不将异常与方法签名绑定在一起，因为它被认为是一个实现细节。事实上，同一个接口或基类的多个实现可能使用不同的技术抛出不同的异常。例如，当你创建一个对象的代理时，你可能需要抛出不同类型的异常，除了代理对象中声明的异常。
- en: Since exceptions are not a part of the signature, the .NET platform defines
    a base class called `System.Exception` for all the possible exceptions. This type
    is effectively part of the contract bounding the consumers (the callers) to the
    producers (the called methods).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异常不是签名的一部分，.NET平台为所有可能的异常定义了一个名为`System.Exception`的基类。这种类型实际上是约束消费者（调用者）与生产者（被调用方法）之间的契约的一部分。
- en: The .NET runtime is, of course, the subject hooking the exception and taking
    care of executing the matching handler. For this reason, the exceptions are only
    valid in the .NET context and every time you cross the boundary, either with a
    `Win32Exception` and `COMException`, derived from `Exception`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，.NET运行时是捕获异常并负责执行匹配处理程序的主体。因此，异常只在.NET上下文中有效，每次跨越边界时，都会有`Win32Exception`和`COMException`，它们都是从`Exception`派生而来。
- en: Apparently, the exception model is the universal panacea for managing errors,
    but there's still a very important aspect to consider—the *performance aspect*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，异常模型是管理错误的普遍良药，但仍有一个非常重要的方面需要考虑——*性能方面*。
- en: The whole process of capturing the exception, unwinding the stack, calling the
    relevant `finally` block, and the execution of other necessary infrastructural
    code takes time. From this perspective, there is no doubt the error codes are
    far more performant, but this is payback for all the advantages we already mentioned.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获异常、展开堆栈、调用相关的`finally`块以及执行其他必要的基础设施代码的整个过程需要时间。从这个角度来看，毫无疑问，错误代码的性能要好得多，但这是我们已经提到的所有优势的回报。
- en: When we talk about performance, it must be measured, which in turn depends on
    whether the given performance-impacting code is run often or not. In other words,
    if the use of exceptions is *exceptional*, it will not affect the overall performance.
    For example, the `System.IO.File.Exists` method returns a Boolean telling us whether
    the file exists on the filesystem. However, this does not throw an exception because
    not finding a file is not an exceptional case and throwing an exception could
    severely hit performance when called repeatedly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论性能时，必须进行测量，这又取决于影响性能的代码是否经常运行。换句话说，如果异常使用是*异常的*，它不会影响整体性能。例如，`System.IO.File.Exists`方法返回一个布尔值，告诉我们文件是否存在于文件系统中。但是，这不会抛出异常，因为找不到文件不是一个异常情况，在重复调用时抛出异常可能会严重影响性能。
- en: Let's now get our hands on the code by examining the statements needed to handle
    exceptions. As you go through the following sections, you will notice that we
    briefly introduced some of these concepts in [*Chapter 3*](B12346_03_Final_JC_ePub.xhtml#_idTextAnchor074),
    *Control Statements and Exceptions*, when we talked about exception handling.
    In this chapter, we will cover these topics in more depth.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过检查处理异常所需的语句来动手编写代码。当您阅读以下各节时，您会注意到我们在[*第3章*](B12346_03_Final_JC_ePub.xhtml#_idTextAnchor074)中简要介绍了一些这些概念，*控制语句和异常*，当我们谈论异常处理时。在本章中，我们将更深入地涵盖这些主题。
- en: Catching exceptions
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获异常
- en: As a general rule, it is always better to avoid errors before an exception gets
    thrown. For example, validating input parameters from the presentation layer is
    your best chance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，最好在异常被抛出之前避免错误。例如，验证来自表示层的输入参数是您最好的机会。
- en: 'Before trying to open and read a file, you may want to check for its existence:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试打开和读取文件之前，您可能希望检查其是否存在：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But this check does not protect the code from other possible errors because
    the filename may contain a forward slash (`/`), which is forbidden in both Windows
    and Linux operating systems. It would not make sense to try sanitizing the filename
    because other errors may happen while accessing the filesystem, such as a wrong
    path or damaged media.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这个检查并不能保护代码免受其他可能的错误，因为文件名可能包含在Windows和Linux操作系统中都被禁止的斜杠(`/`)。尝试对文件名进行消毒是没有意义的，因为在访问文件系统时可能会发生其他错误，比如错误的路径或损坏的媒体。
- en: 'Whenever the error occurs and cannot be easily prevented, the code must be
    protected with the proposition offered by the C# language: the `try` and `catch`
    block statements.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每当错误发生且无法轻易预防时，代码必须受到C#语言提供的建议的保护：`try`和`catch`块语句。
- en: 'The following snippet demonstrates how to protect `File.ReadAllText` from any
    possible error:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段演示了如何保护`File.ReadAllText`免受任何可能的错误：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `try` block surrounds the code we want to protect. Therefore, any exception
    thrown by `File.ReadAllText` would cause the execution to immediately stop (`content.Length`
    would not be executed) and jump to the matching catch handler.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`块包围了我们想要保护的代码。因此，`File.ReadAllText`抛出的任何异常都会导致执行立即停止（`content.Length`不会被执行），并跳转到匹配的catch处理程序。'
- en: The `catch` block must immediately follow a `try` block and specify the code
    that must be executed only in case the exception being thrown matches the type
    specified inside the round brackets.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`块必须紧随`try`块之后，并指定只有在抛出的异常与圆括号内指定的类型匹配时才必须执行的代码。'
- en: The preceding example is able to catch any error in the `catch` block since
    `Exception` is the *base class for the hierarchy* of all the exceptions. But this
    is not necessarily a good thing because you may want to recover from specific
    exceptions while leaving the responsibility for other failures to the caller.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例能够在`catch`块中捕获任何错误，因为`Exception`是所有异常的*基类层次结构*。但这未必是一件好事，因为您可能希望从特定异常中恢复，同时将其他失败的责任留给调用者。
- en: Information box
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: Most of the problems related to the filename can be avoided by adding a check
    with `File.Exists`, but we omitted it on purpose in order to have a wider choice
    of possible exceptions in our sample.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数与文件名相关的问题可以通过添加`File.Exists`的检查来避免，但我们故意省略了它，以便在我们的示例中有更多可能的异常选择。
- en: The preceding snippet may fail with providing different values for the filename.
    For example, if `filename` is null, `ArgumentNullException` is thrown from the
    `File.ReadAllText` method. If instead `filename` is `/`, then it gets interpreted
    as an access to the root drive, which requires administrative privileges and so
    the exception would be `System.UnauthorizedAccessException`. When the value is
    `//`, then `System.IO.IOException` is thrown because the path is invalid.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段可能会因为为文件名提供不同的值而失败。例如，如果`filename`为null，则从`File.ReadAllText`方法抛出`ArgumentNullException`。如果相反，`filename`为`/`，那么它会被解释为对根驱动器的访问，这需要管理员权限，因此异常将是`System.UnauthorizedAccessException`。当值为`//`时，会抛出`System.IO.IOException`，因为路径无效。
- en: 'Since it can be useful for making different decisions depending on the exception
    types, the C# syntax provides the ability to specify multiple `catch` blocks,
    as in the following example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于根据异常类型做出不同决策可能很有用，C#语法提供了指定多个`catch`块的能力，如下例所示：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The official .NET class library documentation contains an *Exceptions* section
    for any member that can throw an exception. If you use Visual Studio and hover
    over an API with your mouse cursor, you will see a tooltip showing a list of all
    the possible exceptions. The following screenshot shows the tooltip for the `File.ReadAllText`
    method:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的.NET类库文档包含了可以抛出异常的任何成员的*异常*部分。如果您使用Visual Studio并将鼠标悬停在API上，您将看到一个工具提示显示所有可能的异常的列表。以下截图显示了`File.ReadAllText`方法的工具提示：
- en: '![Figure 14.1 – A tooltip showing the exceptions for the File.ReadAllText method'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.1 - 显示File.ReadAllText方法的异常的工具提示'
- en: '](img/Figure_14.1_B12346.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.1_B12346.jpg)'
- en: Figure 14.1 – A tooltip showing the exceptions for the File.ReadAllText method
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 - 显示File.ReadAllText方法的异常的工具提示
- en: 'Let''s now imagine that `filename` specifies a nonexistent file: what is going
    to happen in this code? According to the tooltip exception list, we can easily
    guess that a `FileNotFoundException` exception will be thrown. The class hierarchy
    for this exception is `IOException`, `SystemException`, and of course `Exception`,
    respectively.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们想象一下，`filename`指定了一个不存在的文件：在这段代码中会发生什么？根据工具提示异常列表，我们可以很容易地猜到会抛出`FileNotFoundException`异常。这个异常的类层次结构分别是`IOException`、`SystemException`，当然还有`Exception`。
- en: 'There are two catch blocks satisfying the match—`IOException` and `Exception`—but
    the first wins because the `catch` block order is very important. If you try to
    reverse the order of those blocks, you will get a compilation error and get feedback
    in the editor because this would result in unreachable `catch` blocks. The following
    example shows the red squiggle generated by the Visual Studio editor when a `catch(Exception)`
    is specified as the first one:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个catch块满足匹配——`IOException`和`Exception`——但第一个获胜，因为`catch`块的顺序非常重要。如果尝试颠倒这些块的顺序，将会得到编译错误，并在编辑器中得到反馈，因为这将导致无法访问的`catch`块。下面的例子显示了当指定`catch(Exception)`作为第一个时，Visual
    Studio编辑器生成的红色波浪线：
- en: '![Figure 14.2 – The editor complains when catch (Exception) is the first exception
    used'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.2 - 当catch(Exception)是第一个使用的异常时，编辑器会抱怨'
- en: '](img/Figure_14.2_B12346.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.2_B12346.jpg)'
- en: Figure 14.2 – The editor complains when catch (Exception) is the first exception
    used
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 - 当catch(Exception)是第一个使用的异常时，编辑器会抱怨
- en: 'The error emitted by the compiler is `CS0160`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器发出的错误是`CS0160`：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The examples we have seen show how to catch an exception in the same method.
    But the power of the exception model is its ability to walk back through the call
    chain to find the most appropriate handler.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在同一个方法中捕获异常。但异常模型的强大之处在于它能够沿着调用链向后查找最合适的处理程序。
- en: 'In the following example, we have two different methods where we appropriately
    handled `ArgumentNullException`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们有两个不同的方法，其中我们适当地处理了`ArgumentNullException`：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Even if the `try..catch` blocks are already declared in these two methods, whenever
    `IOException` occurs, those handlers are not invoked. The runtime instead starts
    looking for a compatible handler in the caller chain. This process, entirely managed
    by the .NET runtime, is called **stack unwinding** and consists of jumping away
    from the call to the first compatible handler in the callers, whose return address
    is retrieved from the stack.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 即使这两个方法中已经声明了`try..catch`块，但无论何时发生`IOException`，这些处理程序都不会被调用。相反，运行时会开始在调用者链中寻找兼容的处理程序。这个完全由.NET运行时管理的过程称为**堆栈展开**，它包括从堆栈中检索的第一个兼容处理程序的调用处跳转。
- en: 'In the following example, the `try..catch` blocks intercept `IOException`,
    which could be thrown by the `ReadAllText` or `WriteAllText` APIs used by the
    `ReadTextFile` and `WriteTextFile` methods:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`try..catch`块拦截了可能由`ReadAllText`或`WriteAllText`API引发的`IOException`，这些API被`ReadTextFile`和`WriteTextFile`方法使用：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Regardless of how deep the call stack is, the `try..catch` blocks will protect
    this code from any case of `IOException`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 无论调用堆栈有多深，`try..catch`块都将保护这段代码免受任何`IOException`的影响。
- en: Through all the preceding examples, we have learned how to distinguish the exception
    type, but the `catch` block receives an object of that type providing contextual
    information about the nature of the exception. Let's now take a look at the exception
    objects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的所有例子，我们已经学会了如何区分异常类型，但`catch`块接收到该类型的对象，提供了关于异常性质的上下文信息。现在让我们来看看异常对象。
- en: The exception objects
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常对象
- en: 'In addition to the exception type, the `catch` block syntax may specify the
    name of the variable, referencing the caught exception. The following example
    shows a method for computing the length of the content string for all the specified
    files:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了异常类型之外，`catch`块语法还可以指定变量的名称，引用被捕获的异常。下面的例子展示了一个计算所有指定文件的内容字符串长度的方法：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Every time we open a file without previously using `File.Exists` to avoid the
    exception, we may receive `FileNotFoundException`. This object is a specialization
    of `IOException` and exposes a `Filename` property, providing the filename that
    can't be found. I cannot even remember the number of times I wished to get such
    feedback from faulty applications!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们打开一个文件而没有先使用`File.Exists`来避免异常时，我们可能会收到`FileNotFoundException`。这个对象是`IOException`的一个特例，并暴露了一个`Filename`属性，提供了找不到的文件名。我甚至记不清有多少次我希望从有故障的应用程序中获得这样的反馈！
- en: Information box
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: We will see in more detail the base exception members in the *Debugging and
    monitoring* section, but you can already start investigating the properties exposed
    by the multitude of exceptions thrown in the base class library.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*调试和监控*部分更详细地了解基本异常成员，但您现在可以开始调查基类库中抛出的众多异常所暴露的属性。
- en: 'The following code shows another interesting example while catching `ArgumentException`—an
    exception occurring when the argument fails the validation from the method that
    is using it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了另一个有趣的例子，同时捕获`ArgumentException`——当参数未通过使用它的方法的验证时发生的异常：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `catch` block intercepts the fault for both the `source` and `target` parameters.
    Any error related to the `source` parameter validation should bounce back to the
    caller, while the `target` parameter is computed locally.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`块拦截了`source`和`target`参数的故障。与`source`参数验证相关的任何错误都应该反弹到调用者，而`target`参数在本地计算。'
- en: How can we just catch the ones we are interested in? The answer lies in a language
    feature that was introduced in C# 6.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何只捕获我们感兴趣的异常？答案在于C# 6中引入的一种语言特性。
- en: Conditional catch
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件捕获
- en: The `catch` block may optionally specify a `when` clause to restrict the scope
    of the handler.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`块可以选择性地指定一个`when`子句来限制处理程序的范围。'
- en: 'The following example is very similar to the previous one, but it restricts
    the `catch` block to just hook `ArgumentException`, whose `ParamName` is `"destFileName"`,
    which is the name of the second parameter of the `File.Copy` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例与前一个示例非常相似，但将`catch`块限制为只钩住`ArgumentException`，其`ParamName`为`"destFileName"`，这是`File.Copy`方法的第二个参数的名称：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `when` clause accepts any valid Boolean expression and should not necessarily
    use the exception object specified in the `catch` block.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`子句接受任何有效的布尔表达式，不一定要使用`catch`块中指定的异常对象。'
- en: 'Please note that in this example, we have used the `"destFileName"` string
    to specify the second argument of `File.Copy`. If you use Visual Studio, you can
    see the argument names by positioning the caret over the desired parameter and
    using the shortcut *Ctrl* + *Shift* + *spacebar*, which shows the following suggestion
    window:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此示例中，我们使用了`"destFileName"`字符串来指定`File.Copy`的第二个参数。如果您使用Visual Studio，可以将光标放在所需的参数上，然后使用快捷键*Ctrl*
    + *Shift* + *空格键*来查看参数名称，会显示以下建议窗口：
- en: '![Figure 14.3 – The suggestion window shown by the editor'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.3 - 编辑器显示的建议窗口'
- en: '](img/Figure_14.3_B12346.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.3_B12346.jpg)'
- en: Figure 14.3 – The suggestion window shown by the editor
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 - 编辑器显示的建议窗口
- en: It is now time to jump to the producer side to see how we can throw an exception.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候转到生产者方面，看看我们如何抛出异常。
- en: Throwing exceptions
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出异常
- en: 'When we use an API that already provides the required parameter''s validation,
    you may decide not to validate the parameter and eventually throw an exception.
    In the following example, we open a log file, giving its name specified by `logName`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用已经提供所需参数验证的API时，您可以决定不验证参数，并最终抛出异常。在下面的示例中，我们打开一个日志文件，给定其名称由`logName`指定：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The decision to validate `logName` for a null or empty string does not provide
    any value because the called method already provides a validation that takes into
    consideration more cases, such as invalid paths or nonexistent files.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 验证`logName`是否为null或空字符串的决定并没有提供任何价值，因为被调用的方法已经提供了考虑更多情况的验证，比如无效路径或不存在的文件。
- en: 'But the `logName` parameter may express different semantics, specifying the
    name of the log rather than the filename to write on disk (if any). The solution
    for reconciling the two possible meanings is to add the `".log"` extension if
    it is not already there:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但`logName`参数可能表达不同的语义，指定日志的名称而不是要写入磁盘的文件名（如果有的话）。协调两种可能含义的解决方案是，如果尚未存在，则添加`".log"`扩展名：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This makes more sense, but `logName` can be `null`, causing a `NullReferenceException`
    exception on the highlighted code, which would make troubleshooting harder.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这更有意义，但`logName`可能为`null`，导致在突出显示的代码上引发`NullReferenceException`异常，这将使故障排除变得更加困难。
- en: 'To overcome this problem, we can add the `null` parameter validation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以添加`null`参数验证：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `throw` statement accepts any object derived from an exception and immediately
    interrupts the execution of the method. The runtime hooks the exception and dispatches
    it to the appropriate handler, as we have already investigated in the previous
    sections.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`语句接受任何继承自异常的对象，并立即中断方法的执行。运行时会钩住异常并将其分派到适当的处理程序，正如我们在前面的章节中已经调查过的那样。'
- en: Tip
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Please note the use of `nameof(logName)` to specify the name of the offending
    argument. We used this parameter in the previous section while catching the exceptions
    from the `File.Copy` method. Make sure to never specify the name of the argument
    as a literal. Using `nameof()` guarantees that the name is always *valid* and
    avoids problems during refactoring.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用`nameof(logName)`来指定有问题的参数的名称。我们在前一节中使用了这个参数来捕获`File.Copy`方法中的异常。确保永远不要将参数名称指定为文字。使用`nameof()`可以保证名称始终有效，并避免重构时出现问题。
- en: 'The `throw` statement is very simple but please remember to use it only for
    exceptional cases; otherwise, you may incur performance problems. In the following
    example, we compare two loops using the popular `Benchmark.NET` micro-benchmark
    library. The one in the `LoopNop` method executes code that never throws while
    the other one inside `LoopEx` throws at each iteration:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`语句非常简单，但请记住只在异常情况下使用它；否则，您可能会遇到性能问题。在下面的示例中，我们使用流行的`Benchmark.NET`微基准库比较了两个循环。`LoopNop`方法中的一个执行永远不会抛出异常的代码，而`LoopEx`中的另一个在每次迭代时都会抛出异常：'
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `LoopNop` method just loops over the `Nop` empty method 1,000 times. The
    `Nop` method is marked as `NoInlining` to avoid any compiler optimization in removing
    the call.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoopNop`方法只是循环执行`Nop`空方法1,000次。`Nop`方法被标记为`NoInlining`，以避免编译器优化删除调用。'
- en: 'The second method performs the same loop 1,000 times, but calls the `Crash`
    method, which just throws at each iteration:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法执行相同的循环1,000次，但调用`Crash`方法，该方法在每次迭代时都会抛出异常：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `Crash` method creates a new exception every time, which is a realistic
    usage of the exception object. But even when reusing the same object every time,
    the performance hit of the exception model is huge.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Crash`方法每次都创建一个新的异常对象，这是异常对象的实际用法。但即使每次重复使用相同的对象，异常模型的性能损失也是巨大的。'
- en: The outcome of the benchmark is to get an idea about the *orders of magnitude*
    affecting the use of exceptions, which in our example is four orders.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试的结果是了解影响异常使用的数量级的想法，我们的示例中是四个数量级。
- en: 'The following output shows the outcome of the benchmark:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出显示了基准测试的结果：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This benchmark just demonstrated that throwing exceptions must be only used
    for exceptional cases and should not raise any doubts on the validity of the exception
    model.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基准测试只是证明了抛出异常必须只用于异常情况，并不应该对异常模型的有效性产生任何疑问。
- en: We have seen some of the exception types provided in the base class library.
    Now, we will take a look at the most common exceptions and when to use them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了基类库中提供的一些异常类型。现在，我们将看一下最常见的异常以及何时使用它们。
- en: Common exception types
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的异常类型
- en: 'The exceptions available in the base class library express the semantics for
    the most popular categories of faults. Among all the exceptions provided in the
    base class library, it is worth mentioning the ones that are most often used by
    developers. Throughout this chapter, we have already seen other popular exceptions,
    such as `NullReferenceException`, but they are generally only thrown by the runtime:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基类库中提供的异常表达了最流行的故障类别的语义。在基类库中提供的所有异常中，值得一提的是开发人员最常使用的异常。在本章中，我们已经看到其他流行的异常，比如`NullReferenceException`，但它们通常只会由运行时抛出：
- en: '`ArgumentNullException`: This is generally used at the beginning of a method
    when validating the method parameters. Since reference types may assume the null
    value, it is used to inform the caller that null is not an acceptable value for
    the method.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArgumentNullException`：通常在方法开头验证方法参数时使用。由于引用类型可能假定空值，因此用于通知调用者空值不是方法的可接受值。'
- en: '`ArgumentException`: This is another exception used at the beginning of a method.
    Its meaning is wider and is thrown when the parameter value is not valid.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ArgumentException`：这是另一个在方法开头使用的异常。它的含义更广泛，当参数值无效时抛出。'
- en: '`InvalidOperationException`: This is commonly used to reject the method invocation
    every time the state of the object is not valid for the action requested.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvalidOperationException`：通常用于拒绝方法调用，每当对象的状态对于所请求的操作无效时。'
- en: '`FormatException`: This is used by the class library to signal a badly formatted
    string. It can also be used in user code that is parsing text for any other purpose.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormatException`：类库使用它来表示格式错误的字符串。它也可以用于解析文本以进行任何其他目的的用户代码。'
- en: '`IndexOutOfRangeException`: This is used every time a parameter points outside
    of the expected range of a container, such as an array or a collection.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IndexOutOfRangeException`：每当参数指向容器的预期范围之外时使用，比如数组或集合。'
- en: '`NotImplementedException`: This is used to inform the caller that no implementation
    is available for the called method. For example, when you ask Visual Studio to
    implement an interface inside the class body, the code generator generates the
    properties and methods throwing this exception.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotImplementedException`：用于通知调用者所调用的方法没有可用的实现。例如，当您要求Visual Studio在类主体内实现一个接口时，代码生成器会生成抛出此异常的属性和方法。'
- en: '`TypeLoadException`: You may rarely need to throw this exception. It usually
    occurs when a type cannot be loaded in memory. It is common whenever an exception
    occurs inside a static constructor and, unless you happen to remember this note,
    you may have a hard time diagnosing it.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TypeLoadException`：您可能很少需要抛出此异常。它通常发生在无法将类型加载到内存中时。每当在静态构造函数中发生异常时，通常会发生，并且除非您记得这个说明，否则可能很难诊断。'
- en: An exhaustive list of all the exceptions of the base class library can be found
    in the `Exception` class documentation ([https://docs.microsoft.com/en-us/dotnet/api/system.exception?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.exception?view=netcore-3.1)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 基类库的所有异常的详尽列表可以在`Exception`类文档中找到（[https://docs.microsoft.com/en-us/dotnet/api/system.exception?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.exception?view=netcore-3.1)）。
- en: When deciding to throw an exception, it is very important to use one that fully
    expresses the semantics of the error. Every time you cannot find an appropriate
    class in .NET, it is more appropriate to define a custom exception type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定抛出异常时，非常重要的是使用完全表达错误语义的异常。每当在.NET中找不到合适的类时，最好定义一个自定义异常类型。
- en: Creating a custom exception type
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义异常类型
- en: Defining an exception type is as easy as writing a simple class; the only requirement
    is inheriting from an exception type such as `Exception`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 定义异常类型就像编写一个简单的类一样简单；唯一的要求是继承自`Exception`等异常类型。
- en: 'The following code declares a custom exception used to express a failure in
    the data layer of the application:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码声明了一个用于表示应用程序数据层中的失败的自定义异常：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding custom exception class defines three constructors because they
    are meant to provide a homogeneous experience when the developer constructs them:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的自定义异常类定义了三个构造函数，因为它们旨在在开发人员构造它们时提供一致的体验：
- en: The default constructor might exist whenever you don't need to build an exception
    with additional parameters. In our case, we allow the building of the exception
    object with a null `QueryKeyword` by default.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认构造函数可能存在，每当您不需要使用额外参数构建异常时。在我们的情况下，默认情况下允许使用空的`QueryKeyword`构建异常对象。
- en: The constructor taking the `message` parameter is important in expressing any
    human information that may simplify the diagnostics. The message should provide
    diagnostic information only and is never intended to be shown to the end user.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受`message`参数的构造函数在表达可能简化诊断的任何人类信息时非常重要。消息应该只提供诊断信息，永远不应该显示给最终用户。
- en: The constructor taking the inner exception is valuable in providing additional
    information about the underlying exception, if any, that caused the current error
    situation.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受内部异常的构造函数在提供有关导致当前错误情况的任何底层异常的额外信息方面非常有价值。
- en: 'Once the new custom exception is defined, it can be used in conjunction with
    the `throw` statement. In the following example, we see some hypothetical code
    making a query to a repository and converting the underlying error condition into
    our custom exception:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了新的自定义异常，它就可以与`throw`语句一起使用。在下面的示例中，我们看到一些假设的代码向存储库发出查询并将底层错误条件转换为我们的自定义异常：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The exception being caught is passed to the constructor as an argument in order
    to preserve the original cause of the error, while still throwing the custom exception
    that better represents the nature of the error.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 被捕获的异常作为参数传递给构造函数，以保留错误的原始原因，同时抛出更好地表示错误性质的自定义异常。
- en: Throwing inside the `catch` block brings to light an architectural issue on
    the semantics of the error. In the previous example, we can't recover the error,
    but we still want to catch it because the repository being queried may be very
    different depending on the installation of our application. For example, if the
    repository is a database, the inner exception would be related to *SQL Server*,
    while if it was the filesystem, it would be `IOException`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`catch`块内部抛出异常揭示了关于错误语义的架构问题。在前面的例子中，我们无法恢复错误，但仍然希望捕获它，因为我们的应用程序的安装可能会导致被查询的存储库非常不同。例如，如果存储库是数据库，内部异常将与*SQL
    Server*相关，而如果是文件系统，它将是`IOException`。
- en: If we want the higher levels of the application to be able to treat the error
    appropriately and give them a chance to recover the error, we need to abstract
    the underlying error and provide a business-logic exception such as the `DataLayerException`
    that we defined.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望应用程序的更高级别能够适当地处理错误并有机会恢复错误，我们需要抽象底层错误并提供业务逻辑异常，例如我们定义的`DataLayerException`。
- en: Information box
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: '.NET Framework originally defined `ApplicationException` as the base class
    for all the custom exceptions. Since there was no enforcing, the base class library
    itself never adopted this best practice widely. For this reason, the current best
    practice is deriving all the custom exceptions from `Exception`, as you can read
    in the official documentation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework最初将`ApplicationException`定义为所有自定义异常的基类。由于没有强制执行，基类库本身从未广泛采用这种最佳实践。因此，当前的最佳实践是从`Exception`派生所有自定义异常，正如您可以在官方文档中阅读的那样：
- en: '[https://docs.microsoft.com/en-us/dotnet/api/system.applicationexception?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.applicationexception?view=netcore-3.1)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/api/system.applicationexception?view=netcore-3.1](https://docs.microsoft.com/en-us/dotnet/api/system.applicationexception?view=netcore-3.1)'
- en: The ability to throw from inside the `catch` block is not limited to custom
    exceptions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`catch`块内部抛出异常的能力并不局限于自定义异常。
- en: Rethrowing an exception
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新抛出异常
- en: We have just seen how to throw a new exception within a `catch` block, but there
    is an important shortcut that rethrows the same exception.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何在`catch`块内部抛出一个新的异常，但是有一个重要的快捷方式可以重新抛出相同的异常。
- en: 'The `catch` block is typically used to try to recover the error or just to
    log it. In both cases, we may want to let the exception continue as if it were
    not caught at all. The C# language provides a simple use of the `throw` statement
    for this case, as we can see in the following example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`块通常用于尝试恢复错误或仅仅记录它。在这两种情况下，我们可能希望让异常继续，就好像根本没有被捕获一样。C#语言为这种情况提供了`throw`语句的简单用法，如下例所示：'
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `throw` statement is not followed by any parameter, but it is the equivalent
    of specifying the same exception received in the `catch` block:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`语句后面没有任何参数，但它相当于在`catch`块中指定相同的异常：'
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Unless the `err` reference is changed to point to a different object, the two
    statements are equivalent and have the big advantage of preserving the original
    stack that caused the error. Anyway, we are still able to add more information
    to that exception object (the `HelpLink` property is a typical example).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除非`err`引用被更改以指向不同的对象，否则这两个语句是等价的，并且具有保留导致错误的原始堆栈的重大优势。无论如何，我们仍然能够向异常对象添加更多信息（`HelpLink`属性是一个典型的例子）。
- en: If we throw a different exception object, the original stack is not a part of
    the exception being thrown, and this is the reason why `innerException` exists.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们抛出一个不同的异常对象，原始堆栈不是被抛出的异常的一部分，这就是为什么`innerException`存在的原因。
- en: 'In certain cases, you may want to save the exception captured by the `catch`
    block and rethrow it later. By simply throwing the captured exception, the captured
    stack would be different and less useful. If you need to preserve the stack where
    the exception was initially captured, you can use the `ExceptionDispatchInfo`
    class, which provides two simple methods. The `Capture` static method takes an
    exception and returns an instance of `ExceptionDispatchInfo` that includes all
    the stack information at the moment of the `Capture` call. You can save this object
    and later throw the exception along with the original stack information using
    its `Throw` method. This pattern is shown in the following sample:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望保存`catch`块捕获的异常，并稍后重新抛出它。通过简单地抛出捕获的异常，捕获的堆栈将会不同且不太有用。如果您需要保留最初捕获异常的堆栈，可以使用`ExceptionDispatchInfo`类，该类提供了两个简单的方法。`Capture`静态方法接受一个异常并返回一个包含`Capture`调用时刻的所有堆栈信息的`ExceptionDispatchInfo`实例。您可以保存这个对象，然后使用它的`Throw`方法抛出异常以及原始堆栈信息。这种模式在以下示例中显示：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we are calling a method that throws an exception, which is then caught
    in the `catch` clause. We store a reference to this exception captured with a
    call to the static `ExceptionDispatchInfo.Capture` method, which helps preserve
    the call stack. At the end of the method, we rethrow the exception with a call
    to the `Throw` method of `ExceptionDispatchInfo`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用一个抛出异常的方法，然后在`catch`子句中捕获它。我们使用静态的`ExceptionDispatchInfo.Capture`方法存储对这个异常的引用，这有助于保留调用堆栈。在方法的最后，我们使用`ExceptionDispatchInfo`的`Throw`方法重新抛出异常。
- en: The finally block
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最后的块
- en: The `finally` block is the last C# statement related to *exception management*.
    It is extremely important because it allows expression of the portion of code
    that must be invoked after the `try` block, regardless of whether an exception
    has occurred or not.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块是与*异常管理*相关的最后一个C#语句。它非常重要，因为它允许表达在`try`块之后必须被调用的代码部分，无论是否发生异常。'
- en: Over the previous sections, we have seen how the execution of code behaves depending
    on whether an exception occurs or not. The execution of the code inside a `try`
    block may be interrupted by an outstanding exception skipping portions of that
    code. As soon as an error occurs, we have the guarantee that a matching `catch`
    block will be executed, giving it the opportunity to write the problem to the
    log and maybe execute some recovery logic.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经看到了代码执行的行为，具体取决于是否发生异常。`try`块中的代码执行可能会被未决的异常中断，跳过该代码的部分。一旦发生错误，我们保证将执行匹配的`catch`块，使其有机会将问题写入日志，可能执行一些恢复逻辑。
- en: The `finally` block can be specified even without any `catch` block, meaning
    that any exception will be bounced back to the call chain, but the code specified
    inside the `finally` block will be executed in any case right after the `try`
    block.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块甚至可以在没有任何`catch`块的情况下指定，这意味着任何异常都将反弹到调用链，但是`finally`块中指定的代码将在`try`块之后的任何情况下执行。'
- en: 'The following example shows three methods whose calls are *nested*. The first
    method, `M1`, calls `M2`, which calls `M3`, which calls `Crash`, which finally
    throws an exception, as shown in the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了三个方法，它们的调用是*嵌套*的。第一个方法`M1`调用`M2`，`M2`调用`M3`，`M3`调用`Crash`，最终抛出异常，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we invoke `M1` and the call chain reaches `Crash`, there is no `catch`
    block in `M3` to handle the exception, but its `finally` block is invoked *before*
    leaving the method. At this point, the runtime bounces back to the `M2` caller,
    which catches the exception but also invokes its `finally` code. Lastly, as the
    exception has been handled, `M2` naturally returns the control to `M1` and its
    `finally` code is executed as well, as in the following output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`M1`并且调用链到达`Crash`时，在`M3`中没有`catch`块来处理异常，但是在离开方法之前它的`finally`块被调用。此时，运行时会反弹到`M2`的调用者，它捕获了异常，但也调用了它的`finally`代码。最后，由于异常已经被处理，`M2`自然地将控制返回给`M1`，并且它的`finally`代码也被执行，如下面的输出所示：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can repeat this experiment by adding extra-verbose logging to the `try`
    blocks if you wish, but the point here is that the `finally` block is *always
    executed* right *before leaving* the method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意，您可以通过向`try`块添加额外详细的日志记录来重复此实验，但这里的重点是`finally`块总是在离开方法之前*始终执行*。
- en: 'Another common use for the `try..finally` combo is to ensure that a resource
    has been correctly disposed, and C# has made of this pattern a keyword, which
    is the `using` statement. The following example shows two equivalent snippets.
    The IL code generated by the C# compiler is substantially the same, as you can
    test for yourself using the `ILSpy` tool by decompiling in IL language:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`try..finally`组合的另一个常见用途是确保资源已被正确释放，C#已经将这种模式作为关键字，即`using`语句。以下示例显示了两个等效的代码片段。C#编译器生成的IL代码基本相同，您可以使用`ILSpy`工具自行测试IL语言的反编译结果：'
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Of course, the `using` statement limits its usage to objects implementing the
    `IDisposable` interface, but it generates the same pattern. This is a topic that
    we looked at in depth in [*Chapter 9*](B12346_09_Final_JC_ePub.xhtml#_idTextAnchor173),
    *Resource Management*.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`using`语句将其使用限制在实现`IDisposable`接口的对象上，但它生成相同的模式。这是我们在[*第9章*](B12346_09_Final_JC_ePub.xhtml#_idTextAnchor173)中深入研究的一个主题，*资源管理*。
- en: Now that we have seen all the aspects of exceptions, both from a consumer and
    producer perspective, we will discuss the diagnostic investigation of problems
    related to exceptions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从消费者和生产者的角度看到了异常的所有方面，我们将讨论与异常相关的问题的诊断调查。
- en: Debugging and monitoring exceptions
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和监视异常
- en: Debugging exceptions is a bit different compared to debugging normal code because
    the natural flow gets interrupted and handled by the runtime. Unless you put a
    breakpoint on the code that handles the exception, there is a risk of not understanding
    where exactly the problem started. This can happen when an exception is caught
    and not re-thrown or if the method does not re-throw within the `catch` block.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 调试异常与调试普通代码有些不同，因为自然流程被运行时中断和处理。除非在处理异常的代码上设置断点，否则有可能不理解问题从何处开始。当捕获异常并且没有重新抛出或者方法在`catch`块内没有重新抛出时，就会发生这种情况。
- en: This may seem like an important downside of the exception model, but the .NET
    runtime provides all the necessary support to overcome this issue. In fact, the
    runtime has built-in support for the debuggers, providing valuable hooks to the
    debugger willing to intercept the exceptions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是异常模型的一个重要缺点，但.NET运行时提供了克服这个问题的所有必要支持。事实上，运行时内置了对调试器的支持，为愿意拦截异常的调试器提供了有价值的钩子。
- en: 'From a debugger perspective, you have two possibilities, or *chances*, to intercept
    any exception being thrown:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从调试器的角度来看，您有两种可能性，或者*机会*，来拦截任何被抛出的异常：
- en: '**First-chance** **exceptions** represent the exceptions at a very early stage,
    as soon as they are thrown and before jumping to their handlers, if any. The advantage
    of intercepting an exception (in a first-chance state) is that we can identify
    precisely which code has caused an exception. Conversely, the intercepted exception
    may be legitimate and handled correctly. In other words, the debugger will stop
    any exception occurring, even those that are not causing any trouble. By default,
    the debugger never stops when a first-chance exception occurs, but it prints a
    trace in the debugger output window.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**First-chance** **exceptions**代表异常在非常早期阶段的状态，即它们被抛出并在跳转到其处理程序之前。拦截异常（在第一次出现时）的优势在于我们可以精确地确定是哪段代码导致了异常。相反，被拦截的异常可能是合法的并且被正确处理。换句话说，调试器将停止任何发生的异常，即使那些没有引起麻烦的异常。默认情况下，调试器在第一次出现异常时不会停止，但会在调试器输出窗口中打印跟踪。'
- en: '**Second-chance** or **unhandled** **exceptions** are the fatal ones. These
    mean that the .NET runtime did not find any suitable handler to manage them and
    calls the debugger before forcibly closing the application that is crashing. The
    debugger always stops when a second-chance exception occurs, which always represents
    a bug condition. Second-chance exceptions are printed in the output window and
    presented in the exception dialog as unhandled exceptions.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二次机会**或**未处理**的**异常**是致命的。这意味着.NET运行时没有找到任何合适的处理程序来管理它们，并在强制关闭崩溃的应用程序之前调用调试器。当发生第二次机会异常时，调试器总是会停止，这总是代表一个错误条件。第二次机会异常会在输出窗口中打印，并在异常对话框中呈现为未处理的异常。'
- en: With the default settings, the Visual Studio debugger will break, showing the
    last line of code that could run before crashing the application. This code is
    not necessarily responsible for crashing the application; therefore, you may need
    to modify those settings to get a better understanding of the cause.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认设置，Visual Studio调试器将中断，显示在崩溃应用程序之前可能运行的最后一行代码。这段代码不一定是导致应用程序崩溃的原因；因此，您可能需要修改这些设置以更好地理解原因。
- en: Debugging second-chance exceptions
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试第二次机会异常
- en: 'When the exception being thrown is available in our source code, the default
    settings of the debugger are sufficient to understand the cause of the problem,
    as the following example shows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出的异常在我们的源代码中可用时，调试器的默认设置足以理解问题的原因，如下例所示：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The Visual Studio debugger will stop at the highlighted code showing the infamous
    exception dialog:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio调试器将在突出显示的代码处停止，显示臭名昭著的异常对话框：
- en: '![Figure 14.4 – The dialog showing the exception type, message, and links to
    get more information'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.4 - 显示异常类型、消息和获取更多信息的链接的对话框'
- en: '](img/Figure_14.4_B12346.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.4_B12346.jpg)'
- en: Figure 14.4 – The dialog showing the exception type, message, and links to get
    more information
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 - 显示异常类型、消息和获取更多信息的链接的对话框
- en: 'Additional information is also provided in the output window:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出窗口还提供了其他信息：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The Visual Studio debugger keeps improving the diagnostic output version after
    version. In many cases, it is able to print a message that fully represents the
    origin of the problem. In the following example code, the exception is caused
    by a `null` reference:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio调试器不断改进诊断输出版本。在许多情况下，它能够打印出完全代表问题起源的消息。在以下示例代码中，异常是由`null`引用引起的：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The dialog shows an **str was null** message, which tells us precisely what
    happened:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框显示了一个**str was null**消息，告诉我们发生了什么：
- en: '![Figure 14.5 – The exception dialog showing the details seen before the variable
    is null'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.5 - 在变量为null之前看到的异常对话框显示细节'
- en: '](img/Figure_14.5_B12346.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.5_B12346.jpg)'
- en: Figure 14.5 – The exception dialog showing the details seen before the variable
    is null
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 - 在变量为null之前看到的异常对话框显示细节
- en: 'Similarly, the output window shows a similar message:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，输出窗口显示了类似的消息：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now that we have seen the default behavior of the debugger, let's take into
    consideration a scenario that's a bit more complex.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了调试器的默认行为，让我们考虑一个稍微复杂一点的场景。
- en: Debugging first-chance exceptions
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试首次机会异常
- en: 'In this chapter, we have underlined the value of trying to recover from an
    exception or rethrowing a different exception in order to give the calling code
    better semantics. There are cases where this adds some difficulty in debugging,
    as in the following code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们强调了尝试从异常中恢复或重新抛出不同异常的价值，以便为调用代码提供更好的语义。在以下代码中，这增加了一些调试的困难：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Since the `catch` block does not rethrow, the exception is simply swallowed
    and so the debugger will not break at all. But this situation may reveal the real
    cause of the issue. *How can we ask the debugger to stop at this exception?*
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`catch`块没有重新抛出，异常被简单地吞噬，因此调试器根本不会中断。但这种情况可能会揭示问题的真正原因。*我们如何要求调试器在这个异常处停止？*
- en: 'The answer lies in the exception window of Visual Studio (or other debuggers
    exposing the same feature). From the **Debug** | **Window** | **Exception Settings**
    menu, Visual Studio will show the following window:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在Visual Studio（或其他暴露相同功能的调试器）的异常窗口中。从**调试** | **窗口** | **异常设置**菜单，Visual Studio将显示以下窗口：
- en: '![Figure 14.6 – The Exception Settings window'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.6 - 异常设置窗口'
- en: '](img/Figure_14.6_B12346.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.6_B12346.jpg)'
- en: Figure 14.6 – The Exception Settings window
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 - 异常设置窗口
- en: 'The relevant exceptions for the .NET runtime are those under the **Common Language
    Runtime Exceptions** item:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: .NET运行时的相关异常是**公共语言运行时异常**项下的异常：
- en: '![Figure 14.7 – A portion of the Exception Settings window showing the selectable
    exceptions'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.7 - 显示可选择异常的异常设置窗口的一部分'
- en: '](img/Figure_14.7_B12346.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.7_B12346.jpg)'
- en: Figure 14.7 – A portion of the Exception Settings window showing the selectable
    exceptions
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 - 显示可选择异常的异常设置窗口的一部分
- en: Most of those exceptions are unchecked, meaning that, as we already said, the
    debugger will *not* stop at a first-chance exception unless that checkbox is selected.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 其中大多数异常都未选中，这意味着，正如我们已经说过的，调试器*不会*在首次机会异常处中断，除非选中该复选框。
- en: For example, if we want to break on the `throw` statement of the last example,
    we just select `System.Exception` from the list.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在上一个示例的`throw`语句处中断，我们只需从列表中选择`System.Exception`。
- en: Tip
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Please note that every exception in this list only includes the exact type and
    not the hierarchy of the derived types. In other words, `System.Exception` will
    not hook the whole hierarchy.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此列表中的每个异常只包括确切的类型，而不包括派生类型的层次结构。换句话说，`System.Exception`不会挂钩整个层次结构。
- en: By scrolling through the list, you may notice that `System.NullReferenceException`
    and others are checked by default as those exceptions are reasonably considered
    bugs that should always be avoided by validating the arguments in the code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过浏览列表，您可能会注意到`System.NullReferenceException`和其他异常默认已被选中，因为这些异常通常被认为是应该通过在代码中验证参数来避免的错误。
- en: Since the list of exceptions is very long, the **Common Language Runtime Exceptions**
    root item is a three-state toggle that selects either all items, none, or resets
    to the default settings.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于异常列表非常长，**Common Language Runtime Exceptions**根项目是一个三状态切换器，可以选择所有项目、无项目或重置为默认设置。
- en: AppDomain exception events
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AppDomain异常事件
- en: 'The first- and second-chance exceptions can also be monitored, but not intercepted,
    thanks to two events provided by the `AppDomain` object. You can subscribe to
    those events by using the following code in your application:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次和第二次机会异常也可以通过`AppDomain`对象提供的两个事件进行监视，但不能拦截。您可以通过在应用程序中使用以下代码订阅这些事件：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Most of the time, you will not want to monitor the first-chance exceptions as
    they may not cause any trouble to the application. Anyway, it can be useful to
    get rid of them any time you believe they might cause performance issues due to
    legitimately handled exceptions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您不会希望监视第一次机会异常，因为它们可能不会对应用程序造成任何麻烦。无论如何，当您认为它们可能由于合理处理的异常而导致性能问题时，摆脱它们可能是有用的。
- en: The second-chance (unhandled) exceptions are useful for providing a log for
    any exceptions that could not be caught or that were unexpected. Beyond that,
    in a desktop-application context, the typical use case is showing a custom crash
    dialog box.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次机会（未处理）异常对于提供任何无法捕获或意外的异常的日志非常有用。此外，在桌面应用程序环境中，典型的用例是显示自定义崩溃对话框。
- en: Tip
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Please be aware that .NET Core always has a single app domain while .NET Framework
    may have more than one, which is often true in ASP.NET applications when **Internet
    Information** **Services** (**IIS**) recycles the host process.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，.NET Core始终只有一个应用程序域，而.NET Framework可能有多个，这在**Internet Information** **Services**（**IIS**）在重新启动主机进程时通常是真实的，特别是在ASP.NET应用程序中。
- en: We have seen how we can get detailed information about the exception to happen
    during a debugging session and what the best options are to log them. We will
    now see the kind of debugging information provided in the exception object that
    can be used after the application has crashed.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在调试会话期间如何获取关于异常的详细信息以及记录它们的最佳选项。现在我们将看到异常对象中提供的调试信息的类型，这些信息可以在应用程序崩溃后使用。
- en: Logging exceptions
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录异常
- en: After creating the exception object, the runtime enriches its state in order
    to provide the most detailed diagnostic information that can be used to identify
    the fault. Regardless of the way you get access to the exception object, either
    from the `catch` block or the `AppDomain` events, there is additional information
    that you can access.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 创建异常对象后，运行时会丰富其状态，以提供最详细的诊断信息，以便识别故障。无论您如何访问异常对象，无论是从`catch`块还是`AppDomain`事件，都有额外的信息可以访问。
- en: 'We already discussed the `InnerException` property, which recursively provides
    access to all the inner exceptions of the chain. The following example shows how
    to iterate the whole chain:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了`InnerException`属性，它递归地提供了对链中所有内部异常的访问。以下示例显示了如何迭代整个链：
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Accessing the inner exceptions to create a dump is not really needed when creating
    a log because the `ToString` method of the exception object provides the dump
    of the whole chain even if it is very verbose.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 创建转储时访问内部异常并不是真正需要的，因为异常对象的`ToString`方法即使非常冗长也提供了整个链的转储。
- en: The `ToString` method prints the `StackTrace` string property provided by the
    runtime to capture the whole method chain where the exception happened.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString`方法打印了运行时提供的`StackTrace`字符串属性，以捕获异常发生的整个方法链。'
- en: Since `StackTrace` is a string assembled from the runtime, the exception object
    also provides the `TargetSite` property of the `MethodBase` type, which is the
    reflection object representing the faulting method. This object exposes, among
    others, the `Name` property with the method name.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`StackTrace`是从运行时组装的字符串，异常对象还提供了`TargetSite`属性，它是`MethodBase`类型的反射对象，表示出错的方法。该对象公开了`Name`属性和方法名。
- en: Finally, the `GetBaseException` method returns the first exception that originally
    generated the fault, provided that any re-throw statement preserves the inner
    exception or specifies no argument, as we have already discussed in the *Rethrowing
    an exception* section. If you instead need to know whether there has been an exception
    that has been swallowed by some handler, you will need to hook the first-chance
    exceptions event.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`GetBaseException`方法返回最初生成故障的第一个异常，前提是任何重新抛出语句都保留了内部异常或未指定参数，正如我们已经在*重新抛出异常*部分讨论过的那样。如果您需要知道是否有异常被某个处理程序吞没，您将需要挂钩第一次机会异常事件。
- en: There are more advanced debugging techniques that you may want to investigate
    using the links provided in the *Further reading* section. They include the creation
    of a dump, which is a binary file containing the memory of the application process
    at the moment of the crash. The dump can be investigated with the debugging tools
    at a later moment. Another powerful and very advanced tool is the `dotnet-dump
    analyze` .NET Core tool.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更高级的调试技术，您可能希望使用“进一步阅读”部分提供的链接进行调查。它们包括创建转储文件，这是一个包含应用程序进程在崩溃时刻的内存的二进制文件。转储文件可以在以后使用调试工具进行调查。另一个强大且非常高级的工具是`dotnet-dump
    analyze` .NET Core工具。
- en: These are low-level tools, typically used in so-called `dotnet-dump` is to provide
    .NET-specific information in addition to the standard elements offered by the
    native debuggers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是低级工具，通常用于所谓的`dotnet-dump`，它提供了.NET特定的信息，除了本机调试器提供的标准元素。
- en: For example, with these tools, you may get information on the current stack
    state for each thread, the most recent exception data, how each object in memory
    is referenced or references other objects, the memory used by each object, and
    other information related to the application metadata and the .NET runtime.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用这些工具，您可以获取有关每个线程的当前堆栈状态、最近的异常数据、内存中每个对象是如何引用或被其他对象引用的、每个对象使用的内存以及与应用程序元数据和
    .NET 运行时相关的其他信息。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we first understood why .NET embraced the exception model,
    in contrast to the error codes used by many other technologies.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先了解了为什么 .NET 采用了异常模型，而不是许多其他技术所使用的错误代码。
- en: The exception model has demonstrated that it is very powerful, providing an
    efficient and clean way to report errors to the call chain. It avoids polluting
    the code with additional parameters and error-checking conditionals, which may
    cause a loss of efficiency in certain cases. We also verified with a benchmark
    that the exception model must only be used for exceptional cases because otherwise,
    it may severely affect the application's performance.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 异常模型已经证明它非常强大，提供了一种高效而干净的方式来向调用链报告错误。它避免了用额外的参数和错误检查条件来污染代码，这可能在某些情况下导致效率损失。我们还通过基准测试验证了异常模型只能用于异常情况，否则可能严重影响应用程序的性能。
- en: We have also seen in detail the syntax of the `try`, `catch`, and `finally`
    statements that allow us to intercept and handle the exceptions and provide a
    deterministic disposal of any outstanding resource.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还详细看了 `try`、`catch` 和 `finally` 语句的语法，这些语句允许我们拦截和处理异常，并对任何未决资源进行确定性处理。
- en: Finally, we examined the diagnostics and logging options, which are extremely
    useful in providing all the necessary information to fix the bugs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还研究了诊断和日志记录选项，这些选项在提供所有必要信息以修复错误方面非常有用。
- en: In the next chapter, we will be learning about the new features of C# 8, which
    enhance the language by giving us more expressivity and power in terms of performance
    and robustness.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习 C# 8 的新功能，这些功能通过在性能和健壮性方面提供更多的表达能力和功能来增强语言。
- en: Test what you learned
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你所学到的知识
- en: Which `block` statement can be used to surround some code that may potentially
    throw an exception?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 `block` 语句可以用来包围可能引发异常的一些代码？
- en: What is the typical task inside any `catch` block?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何 `catch` 块内的典型任务是什么？
- en: When specifying multiple `catch` blocks, what order should be respected and
    why?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在指定多个 `catch` 块时，应该遵守什么顺序，为什么？
- en: Should we specify the exception variable name in the `catch` statement? Why?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `catch` 语句中应该指定异常变量名吗？为什么？
- en: You just caught an exception in a `catch` block. Why should you want to rethrow
    it?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你在 `catch` 块中捕获了一个异常。为什么你要重新抛出它？
- en: What is the role of the `finally` block?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`finally` 块的作用是什么？'
- en: Can you specify a `finally` block without a `catch` block?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以指定一个没有 `catch` 块的 `finally` 块吗？
- en: What are first-chance exceptions?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是第一次机会异常？
- en: How can you break the Visual Studio debugger into a first-chance exception?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将 Visual Studio 调试器中的第一次机会异常中断？
- en: When would you want to hook the `UnhandledException` event of the AppDomain?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时需要挂钩 AppDomain 的 `UnhandledException` 事件？
- en: Further reading
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '**The** **dotnet-dump** **tool** (**only** **for** **.NET** **Core**): [https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-dump](https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-dump)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dotnet-dump** **工具**（**仅适用于** **.NET** **Core**）：[https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-dump](https://docs.microsoft.com/en-us/dotnet/core/diagnostics/dotnet-dump)'
- en: '**The** **WinDbg** **debugger**: [https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WinDbg** **调试器**：[https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools)'
- en: '**Using** **the** **SOS** **debugging** **extension** **in** **WinDbg** (**only**
    **for** **.NET** **Framework**): [https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-managed-code](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-managed-code)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用** **WinDbg** **中的** **SOS** **调试** **扩展**（**仅适用于** **.NET** **Framework**）：[https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-managed-code](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugging-managed-code)'
