- en: Chapter 2. Real-World Objects to UML Diagrams and Java 9 via JShell
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。通过JShell识别UML图表和Java 9中的现实世界对象
- en: 'In this chapter, we will learn how to recognize objects from real-life situations.
    We will understand that working with objects makes it simpler to write code that
    is easier to understand and reuse. We will learn how to recognize real-world elements
    and translate them into the different components of the object-oriented paradigm
    supported in Java 9\. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何从现实生活中的情况中识别对象。我们将了解，使用对象使得编写更易于理解和重用的代码变得更简单。我们将学习如何识别现实世界的元素，并将它们转化为Java
    9中支持的面向对象范式的不同组件。我们将：
- en: Identify objects from applications requirements
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从应用程序需求中识别对象
- en: Capture objects from the real world
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现实世界中捕捉对象
- en: Generate classes to create objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成类以创建对象
- en: Recognize variables and constants to create fields
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别变量和常量以创建字段
- en: Identify actions to create methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别创建方法的动作
- en: Organize classes with UML diagrams
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用UML图表组织类
- en: Use feedback from domain experts to improve our classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用领域专家的反馈来改进我们的类
- en: Work with Java objects in JShell
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JShell中使用Java对象
- en: Identifying objects from applications requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从应用程序需求中识别对象
- en: Whenever you have to solve a problem in the real world, you use elements and
    interact with them. For example, when you are thirsty, you take a glass, fill
    it up with water, soda, or your favorite juice, and then you drink. Similarly,
    you can easily recognize elements, known as objects, from real-world scenarios
    and then translate them into object-oriented code. We will start learning the
    principles of object-oriented programming to use them in the Java 9 programming
    language to develop any kind of applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你在现实世界中解决问题时，你都会使用元素并与它们互动。例如，当你口渴时，你拿起一个玻璃杯，倒满水、苏打水或你最喜欢的果汁，然后喝掉。同样，你可以轻松地从现实世界的场景中识别称为对象的元素，然后将它们转化为面向对象的代码。我们将开始学习面向对象编程的原则，以便在Java
    9编程语言中开发任何类型的应用程序。
- en: Now, we will imagine we have to develop a RESTful Web Service that will be consumed
    by mobile apps and a web application. These apps and applications will have different
    user interfaces and diverse user experiences. However, we don't have to worry
    about these differences because we will be focused on the Web Service, that is,
    we will be backend developers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将想象我们需要开发一个RESTful Web服务，这个服务将被移动应用程序和网络应用程序所使用。这些应用程序将具有不同的用户界面和多样化的用户体验。然而，我们不必担心这些差异，因为我们将专注于Web服务，也就是说，我们将成为后端开发人员。
- en: Artists use different combinations of geometric shapes and organic shapes to
    create art. Of course, creating art is a bit more complex than this simple definition,
    but our goal is to learn object-oriented programming and not to become experts
    in art.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术家使用不同的几何形状和有机形状的组合来创作艺术品。当然，创作艺术比这个简单的定义要复杂一些，但我们的目标是学习面向对象编程，而不是成为艺术专家。
- en: 'Geometric shapes are made of points and lines, and they are precise. The following
    are examples of geometric shapes: circles, triangles, squares, rectangles.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 几何形状由点和线组成，它们是精确的。以下是几何形状的例子：圆形、三角形、正方形、长方形。
- en: Organic shapes are shapes that have a natural look and have a curving appearance.
    These shapes are usually irregular or asymmetrical. We usually associate things
    from the natural world, such as animals and plants, with organic shapes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有机形状是具有自然外观和弯曲外观的形状。这些形状通常是不规则的或不对称的。我们通常将来自自然界的事物，如动物和植物，与有机形状联系在一起。
- en: 'When artists want to create abstract interpretations of things that would normally
    require organic shapes, they use geometric shapes. Imagine that Vanessa Pitstop
    is a painter and craftswoman. She started uploading videos about her artwork to
    Instagram and YouTube a few years ago and reaches a great milestone in her artistic
    career: San Francisco Museum of Modern Art prepares an exhibition of her most
    important artwork. This special event generated a huge impact on social networking
    sites and, as usually happens, there is a new software development task related
    to this important boost in popularity.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当艺术家想要创造通常需要有机形状的事物的抽象解释时，他们使用几何形状。想象一下，Vanessa Pitstop是一位画家和手工艺品制作人。几年前，她开始在Instagram和YouTube上上传关于她的艺术作品的视频，并在她的艺术生涯中取得了重要的里程碑：旧金山现代艺术博物馆准备举办她最重要艺术作品的展览。这一特别事件在社交网络网站上产生了巨大的影响，正如通常发生的那样，与这一重要的知名度提升相关的新软件开发任务也随之而来。
- en: Pitstop is an extremely popular YouTuber and her channel has more than four
    million followers. Many Hollywood actresses bought their artwork and uploaded
    selfies on Instagram with her artwork as a background. Her exhibition generated
    a huge additional interest in her creations and one of the sponsors wants to create
    mobile apps and a web application that reproduce her artwork based on geometric
    shapes and provide details about the all the tools and the acrylic paint that
    the user needs to buy to produce the artwork.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Pitstop是一位非常受欢迎的YouTuber，她的频道拥有超过四百万的粉丝。许多好莱坞女演员购买了她的艺术品，并在Instagram上上传了自拍照，背景是她的艺术作品。她的展览引起了对她作品的巨大额外兴趣，其中一位赞助商想要创建基于几何形状的移动应用程序和网络应用程序，并提供关于所有工具和丙烯颜料的细节，用户需要购买这些工具和颜料来制作艺术品。
- en: Pitstop sketches basic shapes and then paints them with acrylic paint to build
    geometric patterns. The mobile app and the web application will use our Web Service
    to build Pitstop's predefined patterns, based on the canvas size and some predefined
    color schemes selected by the user. Our Web Service will receive the canvas size
    and the color scheme to generate the pattern and a bill of materials. Specifically,
    the Web Service will provide a list of the different tools and the acrylic paint
    tubes, jars, or bottles that the user must buy to paint the drawn pattern. Finally,
    the user will be able to place an online order to request all of some of the suggested
    materials.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Pitstop草图基本形状，然后用丙烯颜料涂抹它们以构建几何图案。移动应用程序和Web应用程序将使用我们的Web服务来构建Pitstop的预定义图案，基于用户选择的画布大小和一些预定义的颜色方案。我们的Web服务将接收画布大小和颜色方案，以生成图案和材料清单。具体来说，Web服务将提供用户必须购买的不同工具和丙烯颜料管、罐或瓶的清单，以绘制所绘制的图案。最后，用户将能够下订单请求所有或部分建议的材料。
- en: The following image shows a first example of Pitstop's artwork with geometric
    patterns. Let's take a look at the image and extract the objects that compose
    the pattern.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了Pitstop的艺术作品的第一个例子，其中包含几何图案。让我们看一下图片，并提取组成图案的物体。
- en: '![Identifying objects from applications requirements](img/00010.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![从应用需求中识别对象](img/00010.jpeg)'
- en: 'The following objects compose the geometric pattern, specifically, the following
    2D shapes from top to bottom:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下对象组成了几何图案，具体来说，从上到下的以下2D形状：
- en: 12 equilateral triangles
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 12个等边三角形
- en: 6 squares
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6个正方形
- en: 6 rectangles
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6个矩形
- en: 28 circles
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28个圆
- en: 4 ellipses
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4个椭圆
- en: 28 circles
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 28个圆
- en: 6 rectangles
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6个矩形
- en: 6 squares
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6个正方形
- en: 12 equilateral triangles
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 12个等边三角形
- en: It is fairly simple to describe 108 objects or 2D shapes that compose the pattern.
    We were able to recognize all these objects and to indicate the specific 2D shape
    for each of them. If we measure each triangle, we will realize they are equilateral
    triangles.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 相当简单地描述组成图案的108个物体或2D形状。我们能够识别所有这些物体，并指出每个物体的具体2D形状。如果我们测量每个三角形，我们会意识到它们是等边三角形。
- en: The following image shows a second example of Pitstop's artwork with geometric
    patterns. Let's take a look at the image and extract the objects that compose
    the pattern.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了Pitstop的艺术作品的第二个例子，其中包含几何图案。让我们看一下图片，并提取组成图案的物体。
- en: '![Identifying objects from applications requirements](img/00011.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![从应用需求中识别对象](img/00011.jpeg)'
- en: 'The following objects compose the geometric pattern, specifically, the following
    2D shapes from top to bottom:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下对象组成了几何图案，具体来说，从上到下的以下2D形状：
- en: 12 equilateral triangles
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 12个等边三角形
- en: 6 regular pentagons
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6个正五边形
- en: 6 rectangles
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6个矩形
- en: 24 regular hexagons
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 24个正六边形
- en: 4 ellipses
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4个椭圆
- en: 24 regular hexagons
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 24个正六边形
- en: 6 rectangles
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6个矩形
- en: 6 regular pentagons
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 6个正五边形
- en: 12 equilateral triangles
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 12个等边三角形
- en: This time, we could describe 100 objects or 2D shapes that compose the pattern.
    We were able to recognize all these objects and indicate the specific 2D shape
    for each of them. If we measure each pentagon and hexagon, we will realize they
    are regular pentagons and hexagons.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们可以描述组成图案的100个物体或2D形状。我们能够识别所有这些物体，并指出每个物体的具体2D形状。如果我们测量每个五边形和六边形，我们会意识到它们是正五边形和六边形。
- en: The following image shows a third example of Pitstop's artwork with geometric
    patterns. In this case, we have a huge number of 2D shapes. Let's take a look
    at the image and just extract the different 2D shapes included in the pattern.
    This time, we won't count the number of objects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了Pitstop的艺术作品的第三个例子，其中包含几何图案。在这种情况下，我们有大量的2D形状。让我们看一下图片，只提取图案中包含的不同2D形状。这一次，我们不会计算物体的数量。
- en: '![Identifying objects from applications requirements](img/00012.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![从应用需求中识别对象](img/00012.jpeg)'
- en: 'The pattern includes the following 2D shapes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该图案包括以下2D形状：
- en: Equilateral triangles
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等边三角形
- en: Squares
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正方形
- en: Regular pentagons
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正五边形
- en: Regular hexagons
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正六边形
- en: Regular heptagons
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正七边形
- en: Regular octagons
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正八边形
- en: Regular decagons
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正十边形
- en: The following image shows a fourth example of Pitstop's artwork with geometric
    patterns. In this case, we also have a huge number of 2D shapes and some of them
    intersect with each other. However, we will still be able to recognize the different
    2D shapes if we pay some attention. Let's take a look at the image and just extract
    the different 2D shapes included in the pattern. We won't count the number of
    objects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了Pitstop的艺术作品的第四个例子，其中包含几何图案。在这种情况下，我们也有大量的2D形状，其中一些与彼此相交。然而，如果我们留意，我们仍然能够识别不同的2D形状。让我们看一下图片，只提取图案中包含的不同2D形状。我们不会计算物体的数量。
- en: '![Identifying objects from applications requirements](img/00013.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![从应用需求中识别对象](img/00013.jpeg)'
- en: 'The pattern includes the following 2D shapes:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该图案包括以下2D形状：
- en: Regular pentagons
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正五边形
- en: Regular decagons
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正十边形
- en: Circles
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形
- en: Equilateral triangles
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等边三角形
- en: Squares
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正方形
- en: Regular octagons
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正八边形
- en: The following image shows a fifth example of Pitstop's artwork with geometric
    patterns. In this case, we will recognize the shapes from left to right because
    the pattern has a different orientation. We have many shapes that intersect with
    each other. Let's take a look at the image and just extract the different 2D shapes
    included in the pattern. We won't count the number of objects.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了Pitstop的艺术作品的第五个例子，其中包含几何图案。在这种情况下，我们将从左到右识别形状，因为图案有不同的方向。我们有许多形状相互交叉。让我们看一下图片，只提取图案中包含的不同2D形状。我们不会计算物体的数量。
- en: '![Identifying objects from applications requirements](img/00014.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![从应用需求中识别对象](img/00014.jpeg)'
- en: 'The pattern includes the following 2D shapes:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该图案包括以下2D形状：
- en: Circles
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形
- en: Regular octagons
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正八边形
- en: Equilateral triangles
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等边三角形
- en: Squares
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正方形
- en: Regular octagons
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正八边形
- en: Capturing real-world objects
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕捉现实世界的物体
- en: 'We could easily recognize objects from Pitstop''s artwork. We understood that
    each pattern is composed of many 2D geometric shapes and we recognized the different
    shapes that she used in all the examples we analyzed. Now, let''s focus on one
    of the core requirements for the Web Service, which is calculating the required
    amounts of acrylic paint to produce the artwork. We must take into account the
    following data for each 2D shape included in the pattern in order to calculate
    the required materials and the amount of acrylic paint to produce each shape:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地从Pitstop的艺术品中识别出对象。我们了解到每个模式由许多二维几何形状组成，并且我们在分析的所有示例中识别出了她使用的不同形状。现在，让我们专注于Web服务的核心需求之一，即计算所需的丙烯酸漆量以制作艺术品。我们必须考虑每个模式中包含的每种二维形状的以下数据，以便计算所需的材料和生产每种形状所需的丙烯酸漆的数量：
- en: The line color
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线颜色
- en: The perimeter
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 周长
- en: The fill color
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充颜色
- en: The area
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面积
- en: It is possible to use a specific color for the line that draws the borders of
    each shape, and therefore, we have to calculate the perimeter to use it as one
    of the values that will allow us to estimate the amount of acrylic paint that
    the user must buy to paint the border of each 2D shape. Then, we have to calculate
    the area to use it as one of the values that will allow us to estimate the amount
    of acrylic paint that the user must buy to fill the area of each 2D shape.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用特定颜色来绘制每个形状的边界线，因此，我们必须计算周长，以便将其用作估算用户必须购买的丙烯酸漆的数量之一，以绘制每个二维形状的边界。然后，我们必须计算面积，以便将其用作估算用户必须购买的丙烯酸漆的数量之一，以填充每个二维形状的区域。
- en: 'We have to start working on the backend code for our Web Service that calculates
    areas and perimeters for the different 2D shapes we have recognized in all the
    sample artwork we have analyzed so far. We conclude that the Web Service must
    support patterns with the following nine shapes:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须开始为我们的Web服务后端代码进行工作，该代码计算我们在迄今为止分析的所有示例艺术品中识别出的不同二维形状的面积和周长。我们得出结论，Web服务必须支持以下九种形状的模式：
- en: Circles
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆
- en: Ellipses
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 椭圆
- en: Equilateral triangles
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等边三角形
- en: Squares
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正方形
- en: Rectangles
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形
- en: Regular pentagons
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正五边形
- en: Regular hexagons
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正六边形
- en: Regular octagons
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正八边形
- en: Regular decagons
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正十边形
- en: After doing some research to refresh our minds about 2D geometry, we can start
    writing Java 9 code. Specifically, we might write nine methods that calculate
    the areas of the previously enumerated 2D shapes and another nine to calculate
    their perimeters. Note that we are talking about methods that would return the
    calculated value, also known as functions. We stopped thinking about objects,
    and therefore, we will face some problems with this path, which we will solve
    with an object-oriented approach.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行一些关于二维几何的研究后，我们可以开始编写Java 9代码。具体来说，我们可能会编写九种方法来计算先前列举的二维形状的面积，另外九种方法来计算它们的周长。请注意，我们正在谈论将返回计算值的方法，也就是函数。我们停止了对对象的思考，因此，我们将在这条路上遇到一些问题，我们将用面向对象的方法来解决这些问题。
- en: 'For example, if we start thinking about methods to solve the problem, one possible
    solution is to code the following eighteen functions to do the job:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们开始考虑解决问题的方法，一个可能的解决方案是编写以下十八个函数来完成工作：
- en: '`calculateCircleArea`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateCircleArea`'
- en: '`calculateEllipseArea`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateEllipseArea`'
- en: '`calculateEquilateralTriangleArea`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateEquilateralTriangleArea`'
- en: '`calculateSquareArea`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateSquareArea`'
- en: '`calculateRectangleArea`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateRectangleArea`'
- en: '`calculateRegularPentagonArea`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateRegularPentagonArea`'
- en: '`calculateRegularHexagonArea`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateRegularHexagonArea`'
- en: '`calculateRegularOctagonArea`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateRegularOctagonArea`'
- en: '`calculateRegularDecagonArea`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateRegularDecagonArea`'
- en: '`calculateCirclePerimeter`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateCirclePerimeter`'
- en: '`calculateEllipsePerimeter`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateEllipsePerimeter`'
- en: '`calculateEquilateralTrianglePerimeter`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateEquilateralTrianglePerimeter`'
- en: '`calculateSquarePerimeter`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateSquarePerimeter`'
- en: '`calculateRectanglePerimeter`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateRectanglePerimeter`'
- en: '`calculateRegularPentagonPerimeter`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateRegularPentagonPerimeter`'
- en: '`calculateRegularHexagonPerimeter`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateRegularHexagonPerimeter`'
- en: '`calculateRegularOctagonPerimeter`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateRegularOctagonPerimeter`'
- en: '`calculateRegularDecagonPerimeter`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateRegularDecagonPerimeter`'
- en: Each of the previously enumerated methods has to receive the necessary parameters
    of each shape and return either its calculated area or perimeter. These functions
    do not have side effects, that is, they do not make changes to the parameters
    they receive and they just return the results of the calculated areas or perimeters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 先前列举的每种方法都必须接收每种形状的必要参数，并返回其计算出的面积或周长。这些函数没有副作用，也就是说，它们不会改变接收到的参数，并且只返回计算出的面积或周长的结果。
- en: Now, let's forget about methods or functions for one moment. Let's go back to
    the real-world objects from the Web Service requirements that we were assigned.
    We have to calculate the areas and perimeters of nine elements, which are nine
    nouns in the requirements that represent real-life objects, specifically 2D shapes.
    We have already built a list with nine real-world objects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们暂时忘记方法或函数。让我们回到我们被分配的Web服务需求中的真实世界对象。我们必须计算九个元素的面积和周长，这些元素是需求中代表真实物体的九个名词，具体来说是二维形状。我们已经建立了一个包含九个真实世界对象的列表。
- en: After recognizing the real-life objects and thinking a bit about them, we can
    start designing our Web Service by following an object-oriented paradigm. Instead
    of creating a set of methods that perform the required tasks, we can create software
    objects that represent the state and behavior of each of the enumerated 2D shapes.
    This way, the different objects mimic the real-world 2D shapes. We can work with
    the objects to specify the different attributes required to calculate the area
    and perimeter. Then, we can extend these objects to include the additional data
    required to calculate other required values, such as the quantity of acrylic paint
    required to paint the borders.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别了现实生活中的对象并对其进行了一些思考之后，我们可以通过遵循面向对象的范例来开始设计我们的Web服务。我们可以创建代表列举的2D形状的状态和行为的软件对象，而不是创建一组执行所需任务的方法。这样，不同的对象模拟了现实世界的2D形状。我们可以使用这些对象来指定计算面积和周长所需的不同属性。然后，我们可以扩展这些对象以包括计算其他所需值所需的附加数据，例如绘制边界所需的丙烯酸漆的数量。
- en: Now, let's move to the real world and think about each of the previously enumerated
    nine shapes. Imagine that we have to draw each of the shapes on paper and calculate
    their areas and perimeters. After we draw each shape, which values will we use
    to calculate their areas and perimeters? Which formulas will we use?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入现实世界，思考之前列举的九种形状中的每一种。想象一下，我们必须在纸上绘制每种形状并计算它们的面积和周长。在我们绘制每种形状之后，我们将使用哪些值来计算它们的面积和周长？我们将使用哪些公式？
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We started working on an object-oriented design before we started coding, and
    therefore, we will work as if we didn't know many concepts of geometry. For example,
    we can easily generalize the formulas that we use to calculate the perimeters
    and areas of regular polygons. However, in most cases we won't be experts on the
    subject and we have to gain some knowledge on the application domain before we
    can generalize behavior with an object-oriented approach. Thus, we will dive deeper
    into the subject as if we had little knowledge on the topic.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在开始编码之前就开始了面向对象的设计，因此，我们将像不了解几何学的许多概念一样工作。例如，我们可以很容易地推广我们用来计算正多边形周长和面积的公式。然而，在大多数情况下，我们不会是该主题的专家，我们必须在可以用面向对象的方法概括行为之前获得一些应用领域的知识。因此，我们将深入研究这个主题，就好像我们对这个主题知之甚少。
- en: The following figure shows a drawn circle and the formulas that we will use
    to calculate its perimeter and area. We just need the radius value, usually identified
    as **r**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个绘制的圆和我们将用来计算其周长和面积的公式。我们只需要半径值，通常标识为**r**。
- en: '![Capturing real-world objects](img/00015.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![捕捉现实世界的对象](img/00015.jpeg)'
- en: The following figure shows a drawn ellipse and the formulas that we will use
    to calculate its perimeter and area. We need the values for the semimajor axis
    (usually labelled as **a**) and semiminor axis (usually labelled as **b**). Notice
    that the formula provided for the perimeter provides an approximation that is
    not very accurate. We will dive deeper on this specific problem later.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个绘制的椭圆和我们将用来计算其周长和面积的公式。我们需要半长轴（通常标记为**a**）和半短轴（通常标记为**b**）的值。请注意，提供的周长公式提供了一个不太精确的近似值。我们将稍后更深入地研究这个特定问题。
- en: '![Capturing real-world objects](img/00016.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![捕捉现实世界的对象](img/00016.jpeg)'
- en: The following figure shows a drawn equilateral triangle and the formulas that
    we will use to calculate its perimeter and area. This type of triangle has equal
    sides, and the three internal angles are equal to 60 degrees. We just need the
    length of side value, usually identified as **a**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个绘制的等边三角形和我们将用来计算其周长和面积的公式。这种三角形的三条边相等，三个内角相等于60度。我们只需要边长值，通常标识为**a**。
- en: '![Capturing real-world objects](img/00017.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![捕捉现实世界的对象](img/00017.jpeg)'
- en: The following figure shows a drawn square and the formulas that we will use
    to calculate its perimeter and area. We just need the length of side value, usually
    identified as **a**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个绘制的正方形和我们将用来计算其周长和面积的公式。我们只需要边长值，通常标识为**a**。
- en: '![Capturing real-world objects](img/00018.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![捕捉现实世界的对象](img/00018.jpeg)'
- en: The following figure shows a drawn rectangle and the formulas that we will use
    to calculate its perimeter and area. We need the width and height values, usually
    identified as **w** and **h**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个绘制的矩形和我们将用来计算其周长和面积的公式。我们需要宽度和高度值，通常标识为**w**和**h**。
- en: '![Capturing real-world objects](img/00019.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![捕捉现实世界的对象](img/00019.jpeg)'
- en: The following figure shows a drawn regular pentagon and the formulas that we
    will use to calculate its perimeter and area. We just need the length of the side
    value, usually labelled as **a**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个绘制的正五边形和我们将用来计算其周长和面积的公式。我们只需要边长值，通常标记为**a**。
- en: '![Capturing real-world objects](img/00020.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![捕捉现实世界的对象](img/00020.jpeg)'
- en: The following figure shows a drawn regular hexagon and the formulas that we
    will use to calculate its perimeter and area. We just need the length of the side
    value, usually labelled as **a**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个绘制的正六边形和我们将用来计算其周长和面积的公式。我们只需要边长值，通常标记为**a**。
- en: '![Capturing real-world objects](img/00021.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![捕捉现实世'
- en: The following figure shows a drawn regular octagon and the formulas that we
    will use to calculate its perimeter and area. We just need the length of the side
    value, usually labelled as **a**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个绘制的正八边形和我们将用来计算其周长和面积的公式。我们只需要边长值，通常标记为**a**。
- en: '![Capturing real-world objects](img/00022.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![捕捉现实世界的对象](img/00022.jpeg)'
- en: The following figure shows a drawn regular decagon and the formulas that we
    will use to calculate its perimeter and area. We just need the length of the side
    value, usually labelled as **a**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个绘制的正十边形和我们将用来计算其周长和面积的公式。我们只需要边长值，通常标记为**a**。
- en: '![Capturing real-world objects](img/00023.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![捕捉现实世界的对象](img/00023.jpeg)'
- en: 'The following table summarizes the data required for each shape to calculate
    its perimeter and area:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了计算每种形状的周长和面积所需的数据：
- en: '| Shape | Required data |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 形状 | 所需数据 |'
- en: '| --- | --- |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Circle | Radius |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 圆 | 半径 |'
- en: '| Ellipse | Semimajor and semiminor axes |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 椭圆 | 半长轴和半短轴 |'
- en: '| Equilateral triangle | Length of a side |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 等边三角形 | 边长 |'
- en: '| Square | Length of a side |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 正方形 | 边长 |'
- en: '| Rectangle | Width and height |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 矩形 | 宽度和高度 |'
- en: '| Regular pentagon | Length of a side |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 正五边形 | 边长 |'
- en: '| Regular hexagon | Length of a side |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 正六边形 | 边长 |'
- en: '| Regular octagon | Length of a side |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 正八边形 | 边长 |'
- en: '| Regular decagon | Length of a side |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 正十边形 | 边长 |'
- en: Each object that represents a specific shape encapsulates the required data
    that we identified. For example, an object that represents an ellipse will encapsulate
    the ellipse's semimajor and semiminor axes values, while an object that represents
    a rectangle will encapsulate the rectangle's width and height values.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 每个代表特定形状的对象都封装了我们确定的所需数据。例如，代表椭圆的对象将封装椭圆的半长轴和半短轴值，而代表矩形的对象将封装矩形的宽度和高度值。
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Data encapsulation** is one of the major pillars of object-oriented programming.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据封装**是面向对象编程的重要支柱之一。'
- en: Generating classes to create objects
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成类以创建对象
- en: Imagine that we have to draw and calculate the perimeters and areas of three
    different rectangles. You will end up with three rectangles drawn with their widths
    and height values and their calculated perimeters and areas. It would be great
    to have a blueprint to simplify the process of drawing each rectangle with their
    different width and height values.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须绘制和计算三个不同矩形的周长和面积。你最终会得到三个矩形，它们的宽度和高度值以及计算出的周长和面积。有一个蓝图来简化绘制每个具有不同宽度和高度值的矩形的过程将是很好的。
- en: In object-oriented programming, a **class** is a template definition or blueprint
    from which objects are created. Classes are models that define the state and behavior
    of an object. After declaring a class that defines the state and behavior of a
    rectangle, we can use it to generate objects that represent the state and behavior
    of each real-world rectangle.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，**类**是创建对象的模板定义或蓝图。类是定义对象状态和行为的模型。声明了定义矩形状态和行为的类之后，我们可以使用它来生成代表每个真实世界矩形状态和行为的对象。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Objects are also known as instances. For example, we can say each `rectangle`
    object is an instance of the `Rectangle` class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对象也被称为实例。例如，我们可以说每个`矩形`对象是`Rectangle`类的一个实例。
- en: The following picture shows two rectangle instances named `rectangle1` and `rectangle2`.
    These instances are drawn with their width and height values specified. We can
    use a `Rectangle` class as a blueprint to generate the two different `Rectangle`
    instances. Note that `rectangle1` has the width and height values of `36` and
    `20`, and `rectangle2` has the width and height values of `22` and `41`. Each
    instance has different values for their width and height. It is very important
    to understand the difference between a class and the objects or instances generated
    through its usage. The object-oriented programming features supported in Java
    9 allow us to discover which blueprint we used to generate a specific object.
    We will use these features in many examples in the upcoming chapters. Thus, we
    can determine whether each object is an instance of the `Rectangle` class or not.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了两个名为`rectangle1`和`rectangle2`的矩形实例。这些实例是根据它们指定的宽度和高度值绘制的。我们可以使用`Rectangle`类作为蓝图来生成这两个不同的`Rectangle`实例。请注意，`rectangle1`的宽度和高度值为`36`和`20`，`rectangle2`的宽度和高度值为`22`和`41`。每个实例的宽度和高度值都不同。理解类和通过其使用生成的对象或实例之间的区别非常重要。Java
    9支持的面向对象编程特性允许我们发现我们用来生成特定对象的蓝图。我们将在接下来的章节中使用这些特性。因此，我们可以确定每个对象是否是`Rectangle`类的实例。
- en: '![Generating classes to create objects](img/00024.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![生成类以创建对象](img/00024.jpeg)'
- en: The following picture shows two regular pentagon instances named `pentagon1`
    and `pentagon2`. These instances are drawn with their length of side values specified.
    We can use a `RegularPentagon` class as a blueprint to generate the two different
    `RegularPentagon` instances. Note that `pentagon1` has the length of a side value
    of `20`, and `pentagon2` has the length of a side value of `16`. Each instance
    has different values for its length of a side.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了两个名为`pentagon1`和`pentagon2`的正五边形实例。这些实例是根据它们指定的边长值绘制的。我们可以使用`RegularPentagon`类作为蓝图来生成这两个不同的`RegularPentagon`实例。请注意，`pentagon1`的边长值为`20`，`pentagon2`的边长值为`16`。每个实例的边长值都不同。
- en: '![Generating classes to create objects](img/00025.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![生成类以创建对象](img/00025.jpeg)'
- en: The following picture shows four ellipse instances named `ellipse1`, `ellipse2`,
    `ellipse3`, and `ellipse4`. These instances are drawn with their semimajor axis
    and semiminor axis values specified. We can use an `Ellipse` class as a blueprint
    to generate the four different `Ellipse` instances. Note that each ellipse has
    its own specific values for the semimajor and semiminor axes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了四个名为`ellipse1`、`ellipse2`、`ellipse3`和`ellipse4`的椭圆实例。这些实例是根据它们指定的半长轴和半短轴值绘制的。我们可以使用`Ellipse`类作为蓝图来生成这四个不同的`Ellipse`实例。请注意，每个椭圆都有其自己特定的半长轴和半短轴值。
- en: '![Generating classes to create objects](img/00026.jpeg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![生成类以创建对象](img/00026.jpeg)'
- en: 'We recognized nine completely different real-world objects from the Web Service
    requirements, and therefore, we can generate the following nine classes to create
    the necessary objects:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Web服务需求中识别出了九个完全不同的真实世界对象，因此，我们可以生成以下九个类来创建必要的对象：
- en: '`Circle`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`圆`'
- en: '`Ellipse`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`椭圆`'
- en: '`EquilateralTriangle`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`等边三角形`'
- en: '`Square`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`正方形`'
- en: '`Rectangle`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`矩形`'
- en: '`RegularPentagon`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`正五边形`'
- en: '`RegularHexagon`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`正六边形`'
- en: '`RegularOctagon`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`正八边形`'
- en: '`RegularDecagon`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`正十边形`'
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note the usage of **Pascal case** for class names. Pascal case means that the
    first letter of each word that composes the name is capitalized, while the other
    letters are in lowercase. This is a coding convention in Java. For example, we
    use the `EquilateralTriangle` name for the class that will be the blueprint that
    will allow us to generate multiple equilateral triangles.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意类名使用**Pascal case**。Pascal case意味着组成名称的每个单词的第一个字母大写，而其他字母小写。这是Java中的编码约定。例如，我们使用`EquilateralTriangle`名称来命名将允许我们生成多个等边三角形的蓝图类。
- en: Recognizing variables and constants
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别变量和常量
- en: We know the information required for each of the shapes to achieve our goals.
    Now, we have to design the classes to include the necessary fields that provide
    the required data to each instance. We have to make sure that each class has the
    necessary fields that encapsulate all the data required by the objects to perform
    all the tasks based on our application domain.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道每个形状所需的信息以实现我们的目标。现在，我们必须设计类，包括提供所需数据给每个实例的必要字段。我们必须确保每个类都有必要的字段，封装了对象执行基于我们应用领域的所有任务所需的所有数据。
- en: Let's start with the `Circle` class. We need to know the radius for each instance
    of this class, that is, for each circle object. Thus, we need an encapsulated
    variable that allows each instance of the `Circle` class to specify the value
    for the radius.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Circle`类开始。我们需要为该类的每个实例，也就是每个圆形对象，知道半径。因此，我们需要一个封装的变量，允许`Circle`类的每个实例指定半径的值。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The variables defined in a class to encapsulate the data for each instance of
    the class in Java 9 are known as **fields**. Each instance has its own independent
    value for the fields defined in the class. The fields allow us to define the characteristics
    for an instance of the class. In other programming languages that support object-oriented
    principles, these variables defined in a class are known as **attributes**.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，用于封装每个类实例的数据的变量被称为**字段**。每个实例都有其自己独立的字段值。字段允许我们为类的实例定义特征。在其他支持面向对象原则的编程语言中，这些在类中定义的变量被称为**属性**。
- en: The `Circle` class defines a floating point field named `radius`, whose initial
    value is equal to `0` for any new instance of the class. After we create an instance
    of the `Circle` class, it is possible to change the value of the `radius` attribute.
    Thus, our circle can become smaller or larger after we created it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`类定义了一个名为`radius`的浮点字段，其初始值对于该类的任何新实例都等于`0`。创建`Circle`类的实例后，可以更改`radius`属性的值。因此，我们创建后的圆形可以变得更小或更大。'
- en: Tip
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note the usage of **Camel case** for field names. Camel case means that the
    first letter is lowercase, and then, the first letter for each word that composes
    the name is capitalized, while the other letters are in lowercase. It is a coding
    convention in Java for both variables and fields. For example, we use the name
    `radius` for the field that stores the value of the radius and we will use `lengthOfSide`
    for the property that stores the value of the length of side in other classes
    that require this data.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意字段名称使用**Camel case**。Camel case意味着第一个字母小写，然后组成名称的每个单词的第一个字母大写，而其他字母小写。这是Java中的编码约定，适用于变量和字段。例如，我们使用`radius`名称来存储半径的字段值，而在其他需要这些数据的类中，我们将使用`lengthOfSide`来存储边长的属性值。
- en: Imagine that we create two instances of the `Circle` class. One of the instances
    is named `circle1` and the other `circle2`. The instance names allow us to access
    the encapsulated data for each object, and therefore, we can use them to change
    the values of the exposed fields.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们创建了`Circle`类的两个实例。一个实例名为`circle1`，另一个实例名为`circle2`。实例名称允许我们访问每个对象的封装数据，因此，我们可以使用它们来更改暴露字段的值。
- en: Java 9 uses a dot (`.`) to allow us to access the properties of instances. So,
    `circle1.radius` provides access to the radius for the `Circle` instance named
    `circle1`, and `circle2.radius` does the same for the `Circle` instance named
    `circle2`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9使用点（`.`）来允许我们访问实例的属性。因此，`circle1.radius`提供了对名为`circle1`的`Circle`实例的半径的访问，`circle2.radius`对名为`circle2`的`Circle`实例也是如此。
- en: Tip
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that the naming convention makes it easy for us to differentiate an instance
    name, that is, a variable, from a class name. Whenever we see the first letter
    in uppercase or capitalized, it means that we are talking about a class, as in
    `Circle` or `Rectangle`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，命名约定使我们能够区分实例名称（即变量）和类名称。每当我们看到大写字母或首字母大写时，这意味着我们正在谈论一个类，如`Circle`或`Rectangle`。
- en: We can assign `14` to `circle1.radius` and `39` to `circle2.radius`. This way,
    each `Circle` instance will have a different value for the `radius` field.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`14`分配给`circle1.radius`，将`39`分配给`circle2.radius`。这样，每个`Circle`实例将对`radius`字段有不同的值。
- en: 'Now, let''s move to the `Rectangle` class. We have to define two floating point
    fields for this class: `width` and `height`. Their initial values will also be
    `0`. Then, we can create four instances of the `Rectangle` class named `rectangle1`,
    `rectangle2`, `rectangle3`, and `rectangle4`.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到`Rectangle`类。我们必须为该类定义两个浮点字段：`width`和`height`。它们的初始值也将为`0`。然后，我们可以创建四个`Rectangle`类的实例，分别命名为`rectangle1`，`rectangle2`，`rectangle3`和`rectangle4`。
- en: 'We can assign the values summarized in the following table to the four instances
    of the `Rectangle` class:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将下表总结的值分配给`Rectangle`类的四个实例：
- en: '| Instance name | `width` | `height` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 实例名称 | `width` | `height` |'
- en: '| --- | --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `rectangle1` | `141` | `281` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `rectangle1` | `141` | `281` |'
- en: '| `rectangle2` | `302` | `162` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `rectangle2` | `302` | `162` |'
- en: '| `rectangle3` | `283` | `73` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `rectangle3` | `283` | `73` |'
- en: '| `rectangle4` | `84` | `214` |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `rectangle4` | `84` | `214` |'
- en: This way, `rectangle1.width` will be equal to `141`, while `rectangle4.width`
    will be equal to `84`. The `rectangle1` instance represents a rectangle with `width`
    of `141` and `height` of `281`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`rectangle1.width` 将等于 `141`，而 `rectangle4.width` 将等于 `84`。`rectangle1` 实例表示宽度为
    `141`，高度为 `281` 的矩形。
- en: 'The following table summarizes the floating point fields defined for each of
    the nine classes that we need for our Web Service backend code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了我们需要用于Web服务后端代码的九个类中定义的浮点字段：
- en: '| Class name | Fields list |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 类名 | 字段列表 |'
- en: '| --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Circle` | `radius` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `圆` | `半径` |'
- en: '| `Ellipse` | `semiMinorAxis` and `semiMajorAxis` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `椭圆` | `半短轴` 和 `半长轴` |'
- en: '| `EquilateralTriangle` | `lengthOfSide` |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `等边三角形` | `边长` |'
- en: '| `Square` | `lengthOfSide` |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `正方形` | `边长` |'
- en: '| `Rectangle` | `width` and `height` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `矩形` | `宽度` 和 `高度` |'
- en: '| `RegularPentagon` | `lengthOfSide` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `正五边形` | `边长` |'
- en: '| `RegularHexagon` | `lengthOfSide` |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `正六边形` | `边长` |'
- en: '| `RegularOctagon` | `lengthOfSide` |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `正八边形` | `边长` |'
- en: '| `RegularDecagon` | `lengthOfSide` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `正十边形` | `边长` |'
- en: Tip
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The fields are members of their respective classes. However, fields aren't the
    only members that classes can have.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段是各自类的成员。然而，字段并不是类可以拥有的唯一成员。
- en: 'Note that six of these classes have the same field: `lengthOfSide`, specifically,
    the following six classes: `EquilateralTriangle`, `Square`, `RegularPentagon`,
    `RegularHexagon`, `RegularOctagon`, and `RegularDecagon`. We will dive deep into
    what these six classes have in common later and take advantage of object-oriented
    features to reuse code and simplify our Web Service maintenance. However, we are
    just starting our journey, and we will make improvements as we learn additional
    object-oriented features included in Java 9\. In fact, let''s remember we are
    learning about the application domain and that we are still not experts in 2D
    shapes.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这六个类中有六个具有相同字段：`边长`，具体来说，以下六个类：`等边三角形`，`正方形`，`正五边形`，`正六边形`，`正八边形`和`正十边形`。我们稍后将深入研究这六个类的共同之处，并利用面向对象的特性来重用代码并简化我们的Web服务维护。然而，我们刚刚开始我们的旅程，随着我们学习Java
    9中包含的其他面向对象特性，我们将进行改进。实际上，让我们记住我们正在学习应用领域，并且我们还不是2D形状的专家。
- en: The following image shows a **UML** (**Unified Modeling Language**) class diagram
    with the nine classes and their fields. This diagram is very easy to understand.
    The class name appears on the top of the rectangle that identifies each class.
    A rectangle below the same shape that holds the class name displays all the field
    names exposed by the class with a plus sign (**+**) as a prefix. This prefix indicates
    that what follows it is an attribute name in UML and a field name in Java 9\.
    Take into account that the next UML diagram doesn't represent the best organization
    for our classes. It is just the first sketch.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个带有九个类及其字段的**UML**（**统一建模语言**）类图。这个图非常容易理解。类名出现在标识每个类的矩形的顶部。与类名相同形状下方的矩形显示了类暴露的所有字段名称，并以加号（**+**）作为前缀。这个前缀表示其后是UML中的属性名称和Java
    9中的字段名称。请注意，下一个UML图并不代表我们类的最佳组织。这只是第一个草图。
- en: '![Recognizing variables and constants](img/00027.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![识别变量和常量](img/00027.jpeg)'
- en: Identifying actions to create methods
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别创建方法的操作
- en: So far, we designed nine classes and identified the necessary fields for each
    of them. Now, it is time to add the necessary pieces of code that work with the
    previously defined fields to perform all the necessary tasks, that is, to calculate
    perimeters and areas. We have to make sure that each class has the necessary encapsulated
    functions that process the property values specified in the objects to perform
    all the tasks.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们设计了九个类，并确定了每个类所需的字段。现在，是时候添加与先前定义的字段一起工作的必要代码片段，以执行所有必要的任务，即计算周长和面积。我们必须确保每个类都有必要的封装函数，以处理对象中指定的属性值来执行所有任务。
- en: Let's forget a bit about similarities between the different classes. We will
    work with them individually as if we didn't have the necessary knowledge of geometric
    formulas. We will start with the `Circle` class. We need pieces of code that allow
    each instance of this class to use the value of the `radius` property to calculate
    the area and perimeter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时忘记不同类之间的相似之处。我们将分别处理它们，就好像我们对几何公式没有必要的了解一样。我们将从`圆`类开始。我们需要一些代码片段，允许该类的每个实例使用`半径`属性的值来计算面积和周长。
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The functions defined in a class to encapsulate the behavior of each instance
    of the class are known as **methods**. Each instance can access the set of methods
    exposed by the class. The code specified in a method can work with the fields
    specified in the class. When we execute a method, it will use the fields of the
    specific instance. Whenever we define methods, we must make sure that we define
    them in a logical place, that is, in the place where the required data is kept.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 类中定义的用于封装类的每个实例行为的函数称为**方法**。每个实例都可以访问类暴露的方法集。方法中指定的代码可以使用类中指定的字段。当我们执行一个方法时，它将使用特定实例的字段。每当我们定义方法时，我们必须确保我们将它们定义在一个逻辑的地方，也就是所需数据所在的地方。
- en: When a method doesn't require parameters, we can say that it is a **parameterless**
    method. In this case, all the methods we will initially define for the classes
    will be parameterless methods that just work with the values of the previously
    defined fields and use the formulas previously shown in the figures when we analyzed
    each 2D shape in detail. Thus, we will be able to call these methods without arguments.
    We will start creating methods, but we will be able to explore additional options
    based on specific Java 9 features later.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个方法不需要参数时，我们可以说它是一个**无参数**方法。在这种情况下，我们最初为类定义的所有方法都将是无参数方法，它们只是使用先前定义的字段的值，并使用先前在详细分析每个2D形状时显示的公式。因此，我们将能够在不带参数的情况下调用这些方法。我们将开始创建方法，但稍后我们将能够根据特定的Java
    9功能探索其他选项。
- en: 'The `Circle` class defines the following two parameterless methods. We will
    declare the code for both methods within the definition of the `Circle` class
    so that they can access the `radius` property value, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`类定义了以下两个无参数方法。我们将在`Circle`类的定义中声明这两个方法的代码，以便它们可以访问`radius`属性的值，如下所示：'
- en: '`calculateArea`: This method returns a floating point value with the calculated
    area for the circle. It returns Pi (`π`) multiplied by the square of the `radius`
    field value (*π * radius*² or *π * (radius ^ 2)*).'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateArea`：此方法返回一个浮点值，表示圆的计算面积。它返回Pi（`π`）乘以`radius`字段值的平方（*π * radius*²或*π
    * (radius ^ 2)*）。'
- en: '`calculatePerimeter`: This method returns a floating point value with the calculated
    perimeter for the circle. It returns Pi (`π`) multiplied by 2 times the `radius`
    field value (*π * 2 * radius*).'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculatePerimeter`：此方法返回一个浮点值，表示圆的计算周长。它返回Pi（`π`）乘以2倍的`radius`字段值（*π * 2
    * radius*）。'
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In Java 9, `Math.PI` provides us with the value for Pi. The `Math.pow` method
    allows us to calculate the value of a first argument raised to the power of the
    second argument. We will learn how to code these methods in Java 9 later.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，`Math.PI`为我们提供了Pi的值。`Math.pow`方法允许我们计算第一个参数的值的幂。我们将在以后学习如何在Java 9中编写这些方法。
- en: These methods do not have side effects, that is, they do not make changes to
    the related instance. The methods just return the calculated values, and therefore,
    we consider them non-mutating methods. Their operation is naturally described
    by the `calculate` verb.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法没有副作用，也就是说，它们不会对相关实例进行更改。这些方法只是返回计算的值，因此我们认为它们是非变异方法。它们的操作自然由`calculate`动词描述。
- en: 'Java 9 uses a dot (`.`) to allow us to execute the methods of the instances.
    Imagine that we have two instances of the `Circle` class: `circle1` with the `radius`
    property equal to `5` and `circle2` with the `radius` property equal to `10`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9使用点（`.`）允许我们执行实例的方法。假设我们有两个`Circle`类的实例：`circle1`，`radius`属性为`5`，`circle2`，`radius`属性为`10`。
- en: If we call `circle1.calculateArea()`, it will return the result of *π * 5*²,
    which is approximately `78.54`. If we call `square2.calculateArea()`, it will
    return the result of *π * 10*², which is approximately `314.16`. Each instance
    has a diverse value for the `radius` attribute, and therefore, the results of
    executing the `calculateArea` method are different for each of them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`circle1.calculateArea()`，它将返回*π * 5*²的结果，约为`78.54`。如果我们调用`square2.calculateArea()`，它将返回*π
    * 10*²的结果，约为`314.16`。每个实例的`radius`属性值不同，因此执行`calculateArea`方法的结果也不同。
- en: If we call `circle1.calculatePerimeter()`, it will return the result of *π *
    2 * 5*, which is approximately `31.41`. On the other hand, if we call `circle2.calculatePerimeter()`,
    it will return the result of *π *2 * 10*, which is approximately `62.83`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`circle1.calculatePerimeter()`，它将返回*π * 2 * 5*的结果，约为`31.41`。另一方面，如果我们调用`circle2.calculatePerimeter()`，它将返回*π
    *2 * 10*的结果，约为`62.83`。
- en: 'Now, let''s move to the `Rectangle` class. We need exactly two methods with
    the same names specified for the `Circle` class: `calculateArea` and `calculatePerimeter`.
    In addition, the methods return the same type and don''t need parameters, so we
    can declare both of them as parameterless methods, as we did in the `Circle` class.
    However, these methods have to calculate the results in a different way; that
    is, they have to use the appropriate formulas for a rectangle and take into account
    the values for the `width` and `height` fields. The other classes also need the
    same two methods. However, each of them will use the appropriate formulas for
    the related shape.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到`Rectangle`类。我们需要两个与`Circle`类指定的相同名称的方法：`calculateArea`和`calculatePerimeter`。此外，这些方法返回相同的类型，不需要参数，因此我们可以像在`Circle`类中一样将它们都声明为无参数方法。然而，这些方法必须以不同的方式计算结果；也就是说，它们必须使用矩形的适当公式，并考虑`width`和`height`字段的值。其他类也需要相同的两个方法。但是，它们每个都将使用相关形状的适当公式。
- en: We have a specific problem with the `calculatePerimeter` method that the `Ellipse`
    class generates. Perimeters are extremely complex to calculate for ellipses, so
    there are many formulas that provide approximations. An exact formula requires
    an infinite series of calculations. We will use an initial formula that isn't
    very accurate but we will find a workaround for this situation later and we will
    improve the results. The initial formula will allow us to return a floating point
    value with the calculated approximation of the perimeter for the ellipse.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Ellipse`类生成的`calculatePerimeter`方法中遇到了特定的问题。对于椭圆来说，周长计算非常复杂，因此有许多提供近似值的公式。精确的公式需要无限系列的计算。我们将使用一个初始公式，它并不是非常精确，但我们以后会找到解决这个问题的方法，并改进结果。初始公式将允许我们返回一个浮点值，该值是椭圆周长的计算近似值。
- en: 'The following diagram shows an updated version of the UML diagram with the
    nine classes, their attributes, and their methods. It shows the results of the
    second round:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了更新后的UML图表，其中包括九个类、它们的属性和方法。它显示了第二轮的结果：
- en: '![Identifying actions to create methods](img/00028.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![识别创建方法的操作](img/00028.jpeg)'
- en: Organizing classes with UML diagrams
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用UML图表组织类
- en: 'So far, our object-oriented solution includes nine classes with their fields
    and methods. However, if we take another look at these nine classes, we will notice
    that all of them have the same two methods: `calculateArea` and `calculatePerimeter`.
    The code for the methods in each class is different because each shape uses a
    special formula to calculate either the area or perimeter. However, the declarations,
    contracts, interfaces, or protocols for the methods are the same. Both methods
    have the same name, are always parameterless, and return a floating point value.
    Thus, all of them return the same type.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的面向对象的解决方案包括九个类及其字段和方法。然而，如果我们再看看这九个类，我们会注意到它们都有相同的两个方法：`calculateArea`和`calculatePerimeter`。每个类中方法的代码是不同的，因为每个形状使用特殊的公式来计算面积或周长。然而，方法的声明、契约、接口或协议是相同的。这两个方法都有相同的名称，始终没有参数，并返回一个浮点值。因此，它们都返回相同的类型。
- en: When we talked about the nine classes, we said we were talking about nine different
    geometrical 2D shapes or simply shapes. Thus, we can generalize the required behavior,
    protocol, or interface for these nine shapes. The nine shapes must define the
    `calculateArea` and `calculatePerimeter` methods with the previously explained
    declarations. We can create an interface to make sure that the nine classes provide
    the required behavior.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论这九个类时，我们说我们在谈论九种不同的几何2D形状或简单的形状。因此，我们可以概括这九种形状的所需行为、协议或接口。这九种形状必须定义具有先前解释的声明的`calculateArea`和`calculatePerimeter`方法。我们可以创建一个接口来确保这九个类提供所需的行为。
- en: 'The interface is a special class named `Shape`, and it generalizes the requirements
    for the geometrical 2D shapes in our application. In this case, we will work with
    a special class that we won''t use to create instances, but in the future, we
    will use interfaces for the same goal. The `Shape` class declares two parameterless
    methods that return a floating point value: `calculateArea` and `calculatePerimeter`.
    Then, we will declare the nine classes as subclasses of the `Shape` class, which
    will inherit these definitions, and provide the specific code for each of these
    methods.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一个名为`Shape`的特殊类，它概括了我们应用程序中的几何2D形状的要求。在这种情况下，我们将使用一个特殊的类来工作，我们不会用它来创建实例，但将来我们会使用接口来实现相同的目标。`Shape`类声明了两个没有参数的方法，返回一个浮点值：`calculateArea`和`calculatePerimeter`。然后，我们将这九个类声明为`Shape`类的子类，它们将继承这些定义，并为这些方法的每一个提供特定的代码。
- en: Tip
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The subclasses of `Shape` (`Circle`, `Ellipse`, `EquilateralTriangle`, `Square`,
    `Rectangle`, `RegularPentagon`, `RegularHexagon`, `RegularOctagon`, and `RegularDecagon`)
    implement the methods because they provide code while maintaining the same method
    declarations specified in the `Shape` superclass. **Abstraction** and **hierarchy**
    are two major pillars of object-oriented programming. We are just making our first
    steps in this topic.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Shape`的子类（`Circle`、`Ellipse`、`EquilateralTriangle`、`Square`、`Rectangle`、`RegularPentagon`、`RegularHexagon`、`RegularOctagon`和`RegularDecagon`）实现这些方法，因为它们提供了代码，同时保持了`Shape`超类中指定的相同方法声明。**抽象**和**层次结构**是面向对象编程的两个主要支柱。我们只是在这个主题上迈出了第一步。'
- en: Object-oriented programming allows us to discover whether an object is an instance
    of a specific superclass. After we change the organization of the nine classes
    and they become subclasses of `Shape`, any instance of `Circle`, `Ellipse`, `EquilateralTriangle`,
    `Square`, `Rectangle`, `RegularPentagon`, `RegularHexagon`, `RegularOctagon`,
    or `RegularDecagon` is also an instance of the `Shape` class.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程允许我们发现一个对象是否是特定超类的实例。当我们改变这九个类的组织结构，它们成为`Shape`的子类后，`Circle`、`Ellipse`、`EquilateralTriangle`、`Square`、`Rectangle`、`RegularPentagon`、`RegularHexagon`、`RegularOctagon`或`RegularDecagon`的任何实例也是`Shape`类的实例。
- en: In fact, it isn't difficult to explain the abstraction because we speak the
    truth about the object-oriented model when we say that it represents the real
    world.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，解释抽象并不难，因为当我们说它代表现实世界时，我们说的是面向对象模型的真相。
- en: It makes sense to say that a regular decagon is indeed a shape, and therefore,
    an instance of `RegularDecagon` is also an instance of the `Shape` class. An instance
    of `RegularDecagon` is both a `Shape` (the superclass of `RegularDecagon`) and
    a `RegularDecagon` (the class that we used to create the object).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 说一个正十边形是一个形状是有道理的，因此，`RegularDecagon`的一个实例也是`Shape`类的一个实例。`RegularDecagon`的一个实例既是`Shape`（`RegularDecagon`的超类）又是`RegularDecagon`（我们用来创建对象的类）。
- en: 'The following figure shows an updated version of the UML diagram with the superclass
    or base class (`Shape`), its nine subclasses, and their attributes and methods.
    Note that the diagram uses a line that ends in an arrow that connects each subclass
    to its superclass. You can read the line that ends in an arrow as the following:
    the class where the line begins *is a subclass of* the class that has the line
    ending with an arrow. For example, `Circle` is a subclass of `Shape`, and `Rectangle`
    is a subclass of `Shape`. The diagram shows the results of the third round.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了UML图的更新版本，包括超类或基类（`Shape`）、它的九个子类以及它们的属性和方法。请注意，图中使用一条线以箭头结束，将每个子类连接到其超类。您可以将以箭头结束的线读作：线开始的类*是*线结束的类的子类。例如，`Circle`是`Shape`的子类，`Rectangle`是`Shape`的子类。该图显示了第三轮的结果。
- en: '![Organizing classes with UML diagrams](img/00029.jpeg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![使用UML图组织类](img/00029.jpeg)'
- en: Note
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A single class can be the superclass of many subclasses.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以是多个子类的超类。
- en: Using feedback from domain experts
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用领域专家的反馈
- en: 'Now, it is time to have a meeting with our domain expert, that is, someone
    that has an excellent knowledge of 2D geometry. We can use the UML diagram to
    explain the object-oriented design for the solution. After we explain the different
    classes that we will use for abstracting the behavior, the domain expert explains
    to us that there are many shapes that have something in common and that we can
    generalize the behavior even further. The following six shapes are regular polygons:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候与我们的领域专家进行会议了，也就是那些对二维几何有着出色知识的人。我们可以使用UML图来解释解决方案的面向对象设计。在我们解释了用于抽象行为的不同类之后，领域专家向我们解释了许多形状都有共同之处，并且我们可以进一步概括行为。以下六种形状都是正多边形：
- en: An equilateral triangle (the `EquilateralTriangle` class) has three sides
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个等边三角形（`EquilateralTriangle`类）有三条边
- en: A square (the `Square` class) has four sides
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正方形（`Square`类）有四条边
- en: A regular pentagon (the `RegularPentagon` class) has five sides
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正五边形（`RegularPentagon`类）有五条边
- en: A regular hexagon (the `RegularHexagon` class) has six sides
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正六边形（`RegularHexagon`类）有六条边
- en: A regular octagon (the `RegularOctagon` class) has eight sides
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正八边形（`RegularOctagon`类）有八条边
- en: A regular decagon (the `RegularDecagon` class) has ten sides
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正十边形（`RegularDecagon`类）有十条边
- en: Regular polygons are polygons that are both equiangular and equilateral. All
    the sides that compose a regular polygon have the same length and are placed around
    a common center. This way, all the angles between any two sides are equal.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 正多边形是既等角又等边的多边形。组成正多边形的所有边都具有相同的长度，并围绕一个共同的中心放置。这样，任意两条边之间的所有角度都是相等的。
- en: The following picture shows the six regular polygons and the generalized formulas
    that we can use to calculate their perimeters and areas. The generalized formula
    to calculate the area requires us to calculate a cotangent, which is abbreviated
    as **cot** in the formula.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了六个正多边形和我们可以用来计算它们周长和面积的通用公式。计算面积的通用公式要求我们计算余切，该余切在公式中缩写为**cot**。
- en: '![Using feedback from domain experts](img/00030.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![使用领域专家的反馈](img/00030.jpeg)'
- en: Tip
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'In Java 9, the `Math` class doesn''t provide a method to directly calculate
    a cotangent. However, it provides a method to calculate a tangent: `Math.tan`.
    The cotangent of `x` is equal to `1` divided by the tangent of `x`: `1/ Math.tan(x)`.
    Thus, we can easily calculate the cotangent with this formula.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，`Math`类没有提供直接计算余切的方法。但是，它提供了计算正切的方法：`Math.tan`。`x`的余切等于`x`的正切的倒数：`1/
    Math.tan(x)`。因此，我们可以用这个公式轻松计算余切。
- en: 'As the three shapes use the same formula with just a different value for the
    number of sides (**n**) parameter, we can generalize the required interface for
    the six regular polygons. The interface is a special class named `RegularPolygon`
    that defines a new `getSidesCount` method that returns the number of sides with
    an integer value. The `RegularPolygon` class is a subclass of the previously defined
    `Shape` class. It makes sense because a regular polygon is indeed a shape. The
    six classes that represent regular polygons become subclasses of `RegularPolygon`.
    However, both the `calculateArea` and `calculatePerimeter` methods are coded in
    the `RegularPolygon` class using the generalized formulas. The subclasses code
    the `getSidesCount` method to return the right value, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这三种形状使用相同的公式，只是参数（**n**）的值不同，我们可以为这六个正多边形概括所需的接口。该接口是一个名为`RegularPolygon`的特殊类，它定义了一个新的`getSidesCount`方法，返回一个整数值作为边数。`RegularPolygon`类是先前定义的`Shape`类的子类。这是有道理的，因为正多边形确实是一种形状。代表正多边形的六个类成为`RegularPolygon`的子类。然而，`RegularPolygon`类中编写了`calculateArea`和`calculatePerimeter`方法，使用了通用公式。子类编写了`getSidesCount`方法以返回正确的值，如下所示：
- en: '`EquilateralTriangle`: 3'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EquilateralTriangle`: 3'
- en: '`Square`: 4'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Square`: 4'
- en: '`RegularPentagon`: 5'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegularPentagon`: 5'
- en: '`RegularHexagon`: 6'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegularHexagon`: 6'
- en: '`RegularOctagon`: 8'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegularOctagon`: 8'
- en: '`RegularDecagon`: 10'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegularDecagon`: 10'
- en: The `RegularPolygon` class also defines the `lengthOfSide` property that was
    previously defined in the three classes that represent regular polygons. Now,
    the six classes become subclasses of `RegularPolygon` and inherit the `lengthOfSide`
    property. The following figure shows an updated version of the UML diagram with
    the new `RegularPolygon` class and the changes in the six classes that represent
    regular polygons. The six classes that represent regular polygons do not declare
    either the `calculateArea` or `calculatePerimeter` methods because these classes
    inherit them from the `RegularPolygon` superclass and don't need to make changes
    to these methods that apply a general formula.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegularPolygon`类还定义了`lengthOfSide`属性，该属性先前在代表正多边形的三个类中定义。现在，这六个类成为`RegularPolygon`的子类，并继承了`lengthOfSide`属性。以下图显示了UML图的更新版本，其中包括新的`RegularPolygon`类和代表正多边形的六个类的更改。代表正多边形的六个类不声明`calculateArea`或`calculatePerimeter`方法，因为这些类从`RegularPolygon`超类继承了这些方法，并且不需要对应用通用公式的这些方法进行更改。'
- en: The diagram shows the results of the fourth round.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了第四轮的结果。
- en: '![Using feedback from domain experts](img/00031.jpeg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![使用领域专家的反馈](img/00031.jpeg)'
- en: 'When we analyzed ellipses, we mentioned that there was a problem when calculating
    its perimeter. We talked with our domain expert and he provided us with detailed
    information about the issue. There are many formulas that provide approximations
    of the perimeter value for this shape. It makes sense to add additional methods
    that calculate the perimeter using other formulas. He suggested us to make it
    possible to calculate the perimeters with the following formulas:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们分析椭圆时，我们提到在计算其周长时存在问题。我们与我们的领域专家交谈，他为我们提供了有关该问题的详细信息。有许多公式可以提供该形状周长的近似值。添加使用其他公式计算周长的附加方法是有意义的。他建议我们使得可以使用以下公式计算周长：
- en: A formula proposed by *David W. Cantrell*
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*David W. Cantrell*提出的一个公式'
- en: A second version of the formula developed by *Srinivasa Aiyangar Ramanujan*
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由 *Srinivasa Aiyangar Ramanujan* 开发的公式的第二个版本
- en: 'We will define the following two additional parameterless methods to the `Ellipse`
    class. The new methods will return a floating point value and solve the specific
    problem of the ellipse shape:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`Ellipse`类定义以下两个额外的无参数方法。新方法将返回一个浮点值，并解决椭圆形状的特定问题：
- en: '`calculatePerimeterWithRamanujanII`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculatePerimeterWithRamanujanII`'
- en: '`calculatePerimeterWithCantrell`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculatePerimeterWithCantrell`'
- en: This way, the `Ellipse` class will implement the methods specified in the `Shape`
    superclass and also add two specific methods that aren't included in any of the
    other subclasses of `Shape`. The following figure shows an updated version of
    the UML diagram with the new methods for the `Ellipse` class.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`Ellipse`类将实现`Shape`超类中指定的方法，并添加两个特定方法，这些方法不包括在`Shape`的任何其他子类中。下图显示了更新后的
    UML 图中`Ellipse`类的新方法。
- en: 'The diagram shows the results of the fifth round:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了第五轮的结果：
- en: '![Using feedback from domain experts](img/00032.jpeg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![使用领域专家的反馈](img/00032.jpeg)'
- en: Test your knowledge
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的知识
- en: 'Objects are also known as:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象也被称为：
- en: Subclasses.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子类。
- en: Fields.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段。
- en: Instances.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例。
- en: 'Which of the following class names follows the Pascal case convention and would
    be an appropriate name for a class in Java 9:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个类名遵循帕斯卡命名约定，并且是 Java 9 中类的适当名称：
- en: '`regularDecagon`'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`regularDecagon`'
- en: '`RegularDecagon`'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RegularDecagon`'
- en: '`Regulardecagon`'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Regulardecagon`'
- en: 'The code specified in a method within a class:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的方法中指定的代码：
- en: Can access the fields specified in the class.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以访问类中指定的字段。
- en: Cannot interact with other members of the class.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法与类的其他成员交互。
- en: Cannot access the fields specified in the class.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法访问类中指定的字段。
- en: 'The functions defined in a class to encapsulate behavior for each instance
    of the class are known as:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个类中定义的函数，用于封装类的每个实例的行为，被称为：
- en: Subclasses.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子类。
- en: Fields.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段。
- en: Methods.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法。
- en: 'A subclass:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子类：
- en: Inherits only methods from its superclass.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅从其超类继承方法。
- en: Inherits only fields from its superclass.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅从其超类继承字段。
- en: Inherits all members from its superclass.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承其超类的所有成员。
- en: 'The variables defined in a class to encapsulate data for each instance of the
    class in Java 9 are known as:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Java 9 中，用于封装类的每个实例的数据的变量被称为：
- en: Fields.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段。
- en: Methods.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法。
- en: Subclasses.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子类。
- en: 'The variables defined in a class to encapsulate data for each instance of the
    class in Java 9 are known as:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Java 9 中，用于封装类的每个实例的数据的变量被称为：
- en: Fields.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字段。
- en: Methods.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法。
- en: Subclasses.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子类。
- en: 'Which of the following field names follows the Camel case convention and would
    be an appropriate name for a field in Java 9:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个字段名称遵循驼峰命名约定，并且是 Java 9 中字段的适当名称：
- en: '`SemiMinorAxis`'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SemiMinorAxis`'
- en: '`semiMinorAxis`'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`semiMinorAxis`'
- en: '`semiminoraxis`'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`semiminoraxis`'
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned how to recognize real-world elements and translate
    them into the different components of the object-oriented paradigm supported in
    Java 9: classes, fields, methods, and instances. You understood that the classes
    represent blueprints or templates to generate the objects, also known as instances.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何识别现实世界的元素，并将它们转化为 Java 9 中支持的面向对象范式的不同组件：类、字段、方法和实例。您了解到类代表了生成对象的蓝图或模板，也被称为实例。
- en: We designed a few classes with fields and methods that represent blueprints
    for real-life objects, specifically, 2D shapes. Then, we improved the initial
    design by taking advantage of the power of abstraction and specialized different
    classes. We generated many versions of the initial UML diagram as we added superclasses
    and subclasses. We understood the application domain and we made changes to the
    original design as our knowledge increased and we realized we were able to generalize
    behavior.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计了一些具有字段和方法的类，这些类代表了现实生活中的蓝图，具体来说是 2D 形状。然后，我们通过利用抽象的力量和专门化不同的类来改进了初始设计。随着我们添加了超类和子类，我们生成了初始
    UML 图的许多版本。我们了解了应用领域，并随着知识的增加和我们意识到能够概括行为，我们对原始设计进行了更改。
- en: Now that you have learned some of the basics of the object-oriented paradigm,
    we are ready to start creating classes and instances in Java 9 with JShell, which
    is what we are going to discuss in the next chapter. It is time to start object-oriented
    coding!
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了面向对象范式的一些基础知识，我们准备在 Java 9 中使用 JShell 创建类和实例，这是我们将在下一章讨论的内容。是时候开始面向对象编码了！
