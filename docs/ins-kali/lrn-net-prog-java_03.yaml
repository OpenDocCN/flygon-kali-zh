- en: Chapter 3. NIO Support for Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。NIO对网络的支持
- en: In this chapter, we will focus on the Java **New IO** (**NIO**) package's `Buffer`
    and `Channels` classes. NIO is an alternative for the earlier Java IO API and
    parts of the network API. While NIO is a broad and complex topic, our interest
    is how it provides support for network applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注Java **New IO** (**NIO**)包的`Buffer`和`Channels`类。NIO是早期Java IO API和部分网络API的替代品。虽然NIO是一个广泛而复杂的主题，但我们感兴趣的是它如何为网络应用程序提供支持。
- en: 'We will explore several topics, including the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨几个主题，包括以下内容：
- en: The nature and relationship between buffers, channels, and selectors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区，通道和选择器之间的性质和关系
- en: The use of NIO techniques to build a client/server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NIO技术构建客户端/服务器
- en: The process of handling multiple clients
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理多个客户端的过程
- en: Support for asynchronous socket channels
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持异步套接字通道
- en: Basic buffer operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本缓冲区操作
- en: The NIO package provides extensive support to build efficient network applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: NIO包提供了广泛的支持，用于构建高效的网络应用程序。
- en: Java NIO
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java NIO
- en: 'Java NIO uses three core classes:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Java NIO使用三个核心类：
- en: '`Buffer`: This holds information that is read or written to a channel'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Buffer`: 保存读取或写入通道的信息'
- en: '`Channel`: This is a stream-like technique that supports asynchronous read/write
    operations to a data source/sink'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Channel`: 这是一种类似流的技术，支持对数据源/汇的异步读/写操作'
- en: '`Selector`: This is a mechanism to handle multiple channels in a single thread'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selector`: 这是处理单个线程中的多个通道的机制'
- en: 'Conceptually, buffers and channels work together to process data. As shown
    in the next figure, data can be moved in either direction between a buffer and
    a channel:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念上，缓冲区和通道一起处理数据。如下图所示，数据可以在缓冲区和通道之间的任一方向移动：
- en: '![Java NIO](img/B04915_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Java NIO](img/B04915_03_01.jpg)'
- en: The channel is connected to some external data source, while the buffer is used
    internally to process the data. There are several types of channels and buffers.
    A few of these are listed in the following tables.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通道连接到某个外部数据源，而缓冲区在内部用于处理数据。有几种类型的通道和缓冲区。以下是其中一些列在下表中。
- en: 'The table for channels is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通道表如下：
- en: '| Channel class | Purpose |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 通道类 | 目的 |'
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `FileChannel` | This connects to a file |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `FileChannel` | 这连接到文件 |'
- en: '| `DatagramChannel` | This supports datagram sockets |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `DatagramChannel` | 这支持数据报套接字 |'
- en: '| `SocketChannel` | This supports streaming sockets |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `SocketChannel` | 这支持流式套接字 |'
- en: '| `ServerSocketChannel` | This listens for socket requests |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `ServerSocketChannel` | 这用于监听套接字请求 |'
- en: '| `NetworkChannel` | This supports a network socket |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `NetworkChannel` | 这支持网络套接字 |'
- en: '| `AsynchronousSocketChannel` | This supports asynchronous streaming sockets
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `AsynchronousSocketChannel` | 这支持异步流式套接字 |'
- en: 'The table for buffers is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区表如下：
- en: '| Buffer class | Data type supported |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 缓冲区类 | 支持的数据类型 |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ByteBuffer` | `byte` |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `ByteBuffer` | `byte` |'
- en: '| `CharBuffer` | `char` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `CharBuffer` | `char` |'
- en: '| `DoubleBuffer` | `double` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `DoubleBuffer` | `double` |'
- en: '| `FloatBuffer` | `float` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `FloatBuffer` | `float` |'
- en: '| `IntBuffer` | `int` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `IntBuffer` | `int` |'
- en: '| `LongBuffer` | `long` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `LongBuffer` | `long` |'
- en: '| `ShortBuffer` | `short` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `ShortBuffer` | `short` |'
- en: The `Selector` class is useful when an application uses many low-traffic connections
    that can be handled using a single thread. This is more efficient than creating
    a thread for each connection. This is also a technique that is used to make an
    application more scalable, something that we will discuss in [Chapter 7](ch07.html
    "Chapter 7. Network Scalability"), *Network Scalability*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序使用许多低流量连接时，`Selector`类非常有用，可以使用单个线程处理这些连接。这比为每个连接创建一个线程更有效。这也是一种用于使应用程序更具可伸缩性的技术，这是我们将在[第7章](ch07.html
    "第7章。网络可伸缩性")中讨论的内容，*网络可伸缩性*。
- en: In this chapter, we will create client/server applications to illustrate the
    interaction between channels and buffers. This includes a simple time server,
    a chat server to demonstrate variable length messages, a parts server to illustrate
    one technique to handle multiple clients, and an asynchronous server. We will
    also examine specialized buffer techniques, including bulk transfers and views.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建客户端/服务器应用程序，以说明通道和缓冲区之间的交互。这包括一个简单的时间服务器，一个聊天服务器来演示可变长度消息，一个部件服务器来说明处理多个客户端的一种技术，以及一个异步服务器。我们还将研究专门的缓冲区技术，包括批量传输和视图。
- en: We will begin our discussion with an overview of buffers, and how they work
    with channels.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从缓冲区的概述和它们与通道的工作方式开始讨论。
- en: Introduction to buffers
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲区介绍
- en: Buffers hold data temporarily because it is being moved to and from channels.
    When a buffer is created, it is created with a fixed size or capacity. Part or
    all of a buffer's memory can be used with several `Buffer` class fields available
    to manage the data in a buffer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区临时保存数据，因为数据正在通道之间移动。当创建缓冲区时，它是以固定大小或容量创建的。可以使用缓冲区中的一部分或全部内存，有几个`Buffer`类字段可用于管理缓冲区中的数据。
- en: 'The `Buffer` class is abstract. However, it possesses the basic methods used
    to manipulate a buffer, including:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`Buffer`类是抽象的。但是，它具有用于操作缓冲区的基本方法，包括：'
- en: '`capacity`: This returns the number of elements in the buffer'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`capacity`: 返回缓冲区中的元素数量'
- en: '`limit`: This returns the first index of the buffer that should not be accessed'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`: 返回不应被访问的缓冲区的第一个索引'
- en: '`position`: This returns the index of the next element to be read or written'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position`: 返回下一个要读取或写入的元素的索引'
- en: The element depends on the buffer type.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 元素取决于缓冲区类型。
- en: 'The `mark` and `reset` methods also control the position within a buffer. The
    `mark` method will set the buffer''s mark to its position. The `reset` method
    restores the mark position to the previously marked position. The following code
    shows the relationships between various buffer terms:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`mark`和`reset`方法还控制缓冲区内的位置。`mark`方法将缓冲区的标记设置为其位置。`reset`方法将标记位置恢复到先前标记的位置。以下代码显示了各种缓冲区术语之间的关系：'
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A buffer can be either **direct** or **non-direct**. A direct buffer will attempt
    to use the native IO methods whenever possible. The creation of a direct buffer
    tends to be more expensive but will perform more efficiently for larger buffers,
    which reside in the memory longer. The `allocateDirect` method is used to create
    a direct buffer and accepts an integer specifying the size of the buffer. The
    `allocate` method also accepts an integer size argument but creates a non-direct
    buffer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区可以是**直接**或**非直接**。直接缓冲区将尝试在可能的情况下使用本机IO方法。直接缓冲区的创建成本较高，但对于驻留在内存中时间较长的较大缓冲区，性能更高。使用“allocateDirect”方法创建直接缓冲区，并接受一个指定缓冲区大小的整数。“allocate”方法也接受一个整数大小参数，但创建一个非直接缓冲区。
- en: A non-direct buffer will not be as efficient as a direct buffer for most operations.
    However, memory used by the non-direct buffer will be reclaimed by the JVM garbage
    collector, whereas direct memory buffers may be outside the control of the JVM.
    This makes the management of memory more predictable with non-direct buffers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数操作，非直接缓冲区的效率不如直接缓冲区。但是，非直接缓冲区使用的内存将被JVM垃圾收集器回收，而直接内存缓冲区可能不受JVM控制。这使得非直接缓冲区的内存管理更加可预测。
- en: 'There are several methods that are used to transfer data between a channel
    and a buffer. These can be classified as either of the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法用于在通道和缓冲区之间传输数据。这些可以分类为以下两种：
- en: Absolute or relative
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对或相对
- en: Bulk transfers
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量传输
- en: Using primitive data types
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原始数据类型
- en: Supporting a view
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持视图
- en: Compacting, duplicating, and slicing a byte buffer
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩、复制和切片字节缓冲区
- en: Many `Buffer` class's methods support invocation chaining. A put type method
    will transfer data to a buffer, while a get type method retrieves information
    from a buffer. We will be using the get and put methods extensively in our examples.
    These methods will transfer a single byte at a time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 许多“Buffer”类的方法支持调用链接。put类型的方法将数据传输到缓冲区，而get类型的方法从缓冲区检索信息。我们将在我们的示例中广泛使用get和put方法。这些方法将一次传输一个字节。
- en: These get and put methods are relative to the current location of the position
    within a buffer. There are also several absolute methods that use an index in
    the buffer to isolate a specific buffer element.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些get和put方法是相对于缓冲区内位置的当前位置。还有几种绝对方法，它们使用缓冲区中的索引来隔离特定的缓冲区元素。
- en: Bulk data transfers contiguous blocks of data. These get and put methods use
    an array of bytes as one of their arguments to hold the data. These are discussed
    in the *Bulk data transfer* section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 批量数据传输连续的数据块。这些get和put方法使用字节数组作为它们的参数之一来保存数据。这些在“批量数据传输”部分讨论。
- en: When all of the data in a `Buffer` class is of the same type, a **view** can
    be created permitting convenient access to the data using a specific data type
    such as `Float`. We will demonstrate this buffer in the *Using a view* section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当“Buffer”类中的所有数据都是相同类型时，可以创建一个**视图**，以便使用特定的数据类型（如`Float`）方便地访问数据。我们将在*使用视图*部分演示这个缓冲区。
- en: Compacting, duplicating, and slicing type operations are supported. The compacting
    operation will shift the contents of a buffer to eliminate data that has already
    been processed. Duplication will make a copy of a buffer, while slicing creates
    a new buffer that is based on the all or part of the original buffer. Changes
    to either buffer will be reflected in the other. However, the position, limit,
    and mark values of each buffer are independent.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 支持压缩、复制和切片类型操作。压缩操作将移动缓冲区的内容，以消除已经处理过的数据。复制将复制一个缓冲区，而切片将创建一个基于原始缓冲区的全部或部分的新缓冲区。对任一缓冲区的更改将反映在另一个缓冲区中。但是，每个缓冲区的位置、限制和标记值是独立的。
- en: Let's see a buffer in action starting with the creation of a buffer.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个缓冲区的创建。
- en: Using channels with a time server
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用时间服务器的通道
- en: The time server and client that were introduced in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Network Programming"), *Getting Started with Network Programming*,
    will be implemented here to demonstrate the use of buffers and channels. These
    applications are simple, but they illustrate how buffers and channels can be used
    together. We will start by creating a server and then create a client that uses
    the server.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章。开始网络编程")中介绍的时间服务器和客户端，*开始网络编程*，将在这里实现，以演示缓冲区和通道的使用。这些应用程序很简单，但它们说明了缓冲区和通道如何一起使用。我们将首先创建一个服务器，然后创建一个使用该服务器的客户端。
- en: Creating a time server
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建时间服务器
- en: 'The following code is the initial declaration of the `ServerSocketChannelTimeServer`
    class, which will be our time server. The `ServerSocketChannel` class''s `open`
    method creates a `ServerSocketChannel` instance. The `socket` method retrieves
    the `ServerSocket` instance for the channel. The `bind` method then associates
    this server socket with port `5000`. While the `ServerSocketChannel` class has
    a `close` method, it is easier to use the try-with-resources block:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是“ServerSocketChannelTimeServer”类的初始声明，它将成为我们的时间服务器。“ServerSocketChannel”类的“open”方法创建一个“ServerSocketChannel”实例。“socket”方法检索通道的“ServerSocket”实例。“bind”方法将此服务器套接字与端口“5000”关联。虽然“ServerSocketChannel”类有一个“close”方法，但使用try-with-resources块更容易：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The server will enter an infinite loop where the `accept` methods blocks until
    a request is received from a client. When this happens, a `SocketChannel` instance
    is returned:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将进入一个无限循环，其中“accept”方法会一直阻塞，直到从客户端接收到请求。当这种情况发生时，将返回一个“SocketChannel”实例：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Assuming this instance is not null, a string containing the current date and
    time is created:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设此实例不为空，则创建包含当前日期和时间的字符串：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A `ByteBuffer` instance is created with a size of 64 bytes. This is more than
    enough for most messages. The `put` method moves the data into the buffer. This
    is a bulk data transfer operation. If the buffer not large enough, then a `BufferOverflowException`
    exception is thrown:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个大小为64字节的`ByteBuffer`实例。这对于大多数消息来说已经足够了。`put`方法将数据移入缓冲区。这是一个批量数据传输操作。如果缓冲区不够大，则会抛出`BufferOverflowException`异常：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to invoke the `flip` method so that we can use it with the channel''s
    write operation. This has the effect of setting; the limit is set to the current
    position and the position to zero. A while loop is used to write out each byte
    and is terminated when there are no more bytes to write as determined by the `hasRemaining`
    method. The last action is to display the message that is sent to the client:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调用`flip`方法，以便可以将其与通道的写操作一起使用。这将设置限制为当前位置，并将位置设置为零。使用while循环来写出每个字节，并在`hasRemaining`方法确定没有更多字节可写时终止。最后一个动作是显示发送给客户端的消息：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When the server is started, it will produce an output that is similar to the
    following one:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器启动时，它将产生类似于以下的输出：
- en: '**Time Server started**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间服务器已启动**'
- en: '**Waiting for request ...**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待请求...**'
- en: We are now ready to create our client.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备创建我们的客户端。
- en: Creating a time client
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个时间客户端
- en: 'The client is implemented in the `SocketChannelTimeClient` class, as defined
    next. To simplify the example, the client is assumed to be on the same machine
    as the server. A `SocketAddress` instance is created using the IP address `127.0.0.1`
    and is associated with port `5000`. The `SocketChannel` class''s `open` method
    returns a `SocketChannel` instance, which will be used to handle the response
    from the server within the try-with-resources block:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在`SocketChannelTimeClient`类中实现，如下所定义。为了简化示例，假定客户端与服务器在同一台机器上。使用IP地址`127.0.0.1`创建一个`SocketAddress`实例，并与端口`5000`关联。`SocketChannel`类的`open`方法返回一个`SocketChannel`实例，该实例将在try-with-resources块中用于处理来自服务器的响应：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the body of the try block, a `ByteBuffer` instance of size 64 is created.
    Using a size smaller than the actual message will complicate this example. In
    the *Handling variable length messages* section, we will re-examine buffer sizes.
    The message is read from the channel and placed into the `ByteBuffer` instance
    using the `read` method. This buffer is then flipped to prepare it for processing.
    Each byte is read and then displayed:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在try块的主体中，创建一个大小为64的`ByteBuffer`实例。使用比实际消息更小的大小将使这个示例变得复杂。在*处理可变长度的消息*部分，我们将重新检查缓冲区大小。使用`read`方法从通道中读取消息，并将其放入`ByteBuffer`实例中。然后翻转此缓冲区以准备处理。读取每个字节，然后显示：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When client is started, its output will be similar to the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端启动时，其输出将类似于以下内容：
- en: '**Date: Tue Aug 18 21:36:25 CDT 2015**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**日期：2015年8月18日星期二21:36:25 CDT**'
- en: 'The server''s output will now appear similar to this one:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的输出现在将类似于这样：
- en: '**Time Server started**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间服务器已启动**'
- en: '**Waiting for request ...**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待请求...**'
- en: '**Sent: Date: Tue Aug 18 21:36:25 CDT 2015**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送：日期：2015年8月18日星期二21:36:25 CDT**'
- en: '**Waiting for request ...**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待请求...**'
- en: We are now ready to examine the details of channel and buffer interaction.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备检查通道和缓冲区交互的细节。
- en: The chat server/client applications
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聊天服务器/客户端应用程序
- en: The intent of this section is to demonstrate how buffers and channels work together
    in more depth. We will use client and server applications that pass messages back
    and forth. Specifically, we will create a simple version of a chat server.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目的是更深入地演示缓冲区和通道如何一起工作。我们将使用客户端和服务器应用程序来来回传递消息。具体来说，我们将创建一个简单版本的聊天服务器。
- en: 'We will perform the following actions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将执行以下操作：
- en: Create a server and a client that send messages back and forth
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个服务器和一个客户端，它们来回发送消息。
- en: Demonstrate how to handle variable length messages
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示如何处理可变长度的消息
- en: First, we will demonstrate using a fixed size message using the `sendFixedLengthMessage`
    and `receiveFixedLengthMessage` methods. Then we will use the `sendMessage` and
    `receiveMessage` methods to handle variable length messages. Fixed length messages
    are easier to handle but will not work if the length of a message exceeds the
    size of the buffer. Variable length messages require more careful handling than
    what we have seen in previous examples. These methods have been placed in a class
    called `HelperMethods` to enable their use in multiple applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将演示使用`sendFixedLengthMessage`和`receiveFixedLengthMessage`方法来处理固定大小的消息。然后我们将使用`sendMessage`和`receiveMessage`方法来处理可变长度的消息。固定长度的消息更容易处理，但如果消息的长度超过缓冲区的大小，则无法工作。可变长度的消息需要比我们在以前的示例中看到的更谨慎的处理。这些方法已放置在名为`HelperMethods`的类中，以便在多个应用程序中使用它们。
- en: The chat server
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聊天服务器
- en: 'Let''s start with the server. The server is defined in the `ChatServer` class
    as defined next. A `ServerSocketChannel` instance is created and bound to port
    `5000`. It will be used in the body of the while loop. The `running` variable
    controls the lifetime of the server. Exceptions are caught as needed. As in the
    previous server, the server will block at the `accept` method until a client connects
    to the server:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从服务器开始。服务器在`ChatServer`类中定义如下。创建一个`ServerSocketChannel`实例并绑定到端口`5000`。它将在while循环的主体中使用。`running`变量控制服务器的生命周期。根据需要捕获异常。与之前的服务器一样，服务器将在`accept`方法处阻塞，直到客户端连接到服务器：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this chat/server application, communication is restricted. Once a connection
    is made, the server will prompt the user for a message to send to the client.
    The client will wait until this message is received, and then it will prompt its
    user for a reply. The reply is sent back to the server. This sequence is limited
    to simplify the interaction to focus on the channel/buffer interaction.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个聊天/服务器应用程序中，通信是受限制的。一旦建立连接，服务器将提示用户发送消息给客户端。客户端将等待接收此消息，然后提示用户回复。回复将发送回服务器。这个顺序被限制在简化交互以便专注于通道/缓冲区交互。
- en: 'When a connection is made, the server displays a message to that effect and
    then enters a loop as shown next. The user is prompted for a message. The `sendFixedLengthMessage`
    method is invoked. If the user entered `quit`, then a terminating message is sent
    to the server, and the server terminates. Otherwise, the message is sent to the
    server and then the server blocks at the `receiveFixedLengthMessage` method waiting
    for the client to respond:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当建立连接时，服务器会显示一条相应的消息，然后进入下面显示的循环。用户会被提示输入一条消息。调用`sendFixedLengthMessage`方法。如果用户输入了`quit`，那么会向服务器发送一条终止消息，然后服务器终止。否则，消息会被发送到服务器，然后服务器会在`receiveFixedLengthMessage`方法处阻塞，等待客户端的响应：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the server starts, its output will appear as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器启动时，它的输出将如下所示：
- en: '**Chat Server started**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**聊天服务器已启动**'
- en: '**Waiting for request ...**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待请求...**'
- en: With the server created, let's examine the client application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器创建好后，让我们来看看客户端应用程序。
- en: The chat client
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聊天客户端
- en: 'The client application uses the `ChatClient` class, as defined next. Its structure
    is similar to the previous client application. The localhost (`127.0.0.1`) is
    used with a port of `5000`. Once a connection has been established, the program
    enters an infinite loop and waits for the server to send it a message:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序使用下面定义的`ChatClient`类。它的结构与之前的客户端应用程序类似。本地主机（`127.0.0.1`）与端口`5000`一起使用。一旦建立了连接，程序就会进入一个无限循环，并等待服务器发送一条消息：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Within the loop, the program blocks at the `receiveFixedLengthMessage` method
    until the server sends it a message. The message is then displayed, and the user
    is prompted for a message to send back to the server. If the message is **quit**,
    then a terminating message is sent to the server using the `sendFixedLengthMessage`
    method, and the application terminates. Otherwise the message is sent to the server,
    and the program waits for another message:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，程序会在`receiveFixedLengthMessage`方法处阻塞，直到服务器发送一条消息。然后消息会被显示出来，并提示用户发送一条消息回复给服务器。如果消息是**quit**，那么会使用`sendFixedLengthMessage`方法向服务器发送一条终止消息，并且应用程序终止。否则消息会被发送到服务器，程序会等待另一条消息：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With the client and server created, let's take a look at how they interact.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器创建好后，让我们来看看它们是如何交互的。
- en: Server/client interaction
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器/客户端交互
- en: 'With the server started, start the client application. The client''s output
    will appear as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器后，启动客户端应用程序。客户端的输出将如下所示：
- en: '**Connected to Chat Server**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**已连接到聊天服务器**'
- en: '**Waiting for message from the server ...**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待来自服务器的消息...**'
- en: 'The server output will reflect this connection:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的输出将反映这个连接：
- en: '**Chat Server started**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**聊天服务器已启动**'
- en: '**Waiting for request ...**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待请求...**'
- en: '**Connected to Client**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**已连接到客户端**'
- en: '**>**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: 'Enter the message `Hello`. You will then get the following output:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输入消息`你好`。然后你会得到以下输出：
- en: '**> Hello**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**> 你好**'
- en: '**Sent: Hello**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送：你好**'
- en: '**Waiting for message from client ...**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待来自客户端的消息...**'
- en: 'The client side will now appear as:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端现在将显示为：
- en: '**Message: Hello**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 消息：你好
- en: '**>**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: 'Enter a reply of `Hi!` The client output will appear as shown here:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个回复`嗨！`，客户端的输出将如下所示：
- en: '**> Hi!**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '> 嗨！'
- en: '**Sent: Hi!**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 发送：嗨！
- en: '**Waiting for message from the server ...**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待来自服务器的消息...**'
- en: 'The server will appear as:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将显示为：
- en: '**Message: Hi!**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 消息：嗨！
- en: '**>**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '> '
- en: We can continue this process until either side enters the `quit` command. However,
    entering a message that exceeds the 64 byte buffer limit will result in a `BufferOverflowException`
    exception being thrown. Replacing the `sendFixedLengthMessage` method with the
    `sendMessage` method and the `receiveFixedLengthMessage` method with the `receiveMessage`
    method will avoid this problem.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续这个过程，直到任何一方输入`quit`命令。然而，输入超过64字节缓冲区限制的消息将导致抛出`BufferOverflowException`异常。用`sendMessage`方法替换`sendFixedLengthMessage`方法，用`receiveMessage`方法替换`receiveFixedLengthMessage`方法将避免这个问题。
- en: Let's examine how these send and receive methods work.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些发送和接收方法是如何工作的。
- en: The HelperMethods class
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`HelperMethods`类'
- en: 'The `HelperMethods` class is defined next. It possesses the send and receive
    methods that were used previously. These methods are declared as static to allow
    them to be accessed easily:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来定义了`HelperMethods`类。它拥有之前使用过的发送和接收方法。这些方法被声明为静态的，以便能够轻松访问它们：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The fixed length message methods are shown next. They perform essentially the
    same way as the approach that was used in the *Using channels with a time server*
    section:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来显示了固定长度消息的方法。它们的执行方式基本与*使用通道与时间服务器*部分中使用的方法相同：
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Handling variable length messages
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理可变长度消息
- en: The technique to handle variable length messages is discussed in this section.
    The problem with variable length messages is that we do not know their length.
    We cannot assume that when a buffer is not completely filled that the end of the
    message has been reached. While this may be true with most messages, if the message
    length is the same size as the message buffer, then we may miss the end of a message.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了处理可变长度消息的技术。可变长度消息的问题在于我们不知道它们的长度。当缓冲区没有完全填满时，我们不能假设消息的结束已经到达。虽然对于大多数消息来说这可能是正确的，但如果消息长度与消息缓冲区的大小相同，那么我们可能会错过消息的结尾。
- en: Another approach to determining when we have reached the end of a message is
    to either send the length of a message prefixed to the message or append a special
    termination character to the end of the message. We choose the latter approach.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 确定何时已经到达消息的结尾的另一种方法是要么发送消息的长度作为消息的前缀，要么在消息的末尾附加一个特殊的终止字符。我们选择后者的方法。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example works for ASCII characters. If Unicode characters are used instead,
    then a `BufferOverflowException` exception will be generated. The `CharBuffer`
    class is used for character data and provides similar capabilities as the `ByteBuffer`
    class. The `CharBuffer` class is detailed at [http://docs.oracle.com/javase/8/docs/api/java/nio/CharBuffer.html](http://docs.oracle.com/javase/8/docs/api/java/nio/CharBuffer.html).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例适用于ASCII字符。如果使用Unicode字符，将生成`BufferOverflowException`异常。`CharBuffer`类用于字符数据，并提供与`ByteBuffer`类类似的功能。`CharBuffer`类的详细信息请参阅[http://docs.oracle.com/javase/8/docs/api/java/nio/CharBuffer.html](http://docs.oracle.com/javase/8/docs/api/java/nio/CharBuffer.html)。
- en: The value of `0x00` was used to mark the end of a message. We choose this value
    because it is not easily entered accidently by the user because it is not printable
    and happens to correspond to how strings are often terminated internally in languages,
    such as C.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`0x00`的值来标记消息的结束。我们选择这个值是因为用户不太可能意外输入它，因为它不可打印，并且恰好对应于字符串在内部通常是如何终止的，比如C语言。
- en: 'In the `sendMessage` method that follows, the `put` method adds this termination
    byte to the end of the message before it is sent. The buffer size is the length
    of the message plus one. Otherwise, the code is similar to that used to send a
    fixed length message:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的`sendMessage`方法中，`put`方法在发送消息之前将终止字节添加到消息的末尾。缓冲区大小为消息长度加一。否则，代码与用于发送固定长度消息的代码类似：
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `receiveMessage` method, each byte received is checked to see if it
    is the termination byte. If it is, then the message is returned. The `clear` method
    is applied to the `byteBuffer` variable after we have extracted part of the message.
    This method is required; otherwise, the read method will return `0`. The method
    will set the buffer''s position back to `0` and the limit to capacity:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`receiveMessage`方法中，每个接收到的字节都会被检查是否是终止字节。如果是，则返回消息。在我们提取消息的一部分之后，`byteBuffer`变量会应用`clear`方法。这个方法是必需的；否则，读取方法将返回`0`。该方法将缓冲区的位置设置回`0`，限制为容量：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We are now ready to demonstrate the application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备演示应用程序。
- en: Running the chat server/client application
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行聊天服务器/客户端应用程序
- en: 'Start the server first. The output will appear as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先启动服务器。输出将如下所示：
- en: '**Chat Server started**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**聊天服务器已启动**'
- en: '**Waiting for request ...**'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待请求...**'
- en: 'Next, start the client, which will result in the following output:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动客户端，将得到以下输出：
- en: '**Connected to Chat Server**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接到聊天服务器**'
- en: '**Waiting for message from the server ...**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待来自服务器的消息...**'
- en: 'These users interchange between the server and the client is limited with the
    current implementation. When both applications have been started, the client will
    be waiting for a message from the server. This is reflected by a server window,
    as shown here:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用户在服务器和客户端之间的交换受到当前实现的限制。当两个应用程序都启动后，客户端将等待来自服务器的消息。这在服务器窗口中反映出来，如下所示：
- en: '**Chat Server started**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**聊天服务器已启动**'
- en: '**Waiting for request ...**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待请求...**'
- en: '**Connected to Client**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接到客户端**'
- en: '**>**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**>**'
- en: 'When a message is entered, it is sent to the client. Enter the message **Hello**.
    The client window will now display the message, as shown here:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 输入消息后，将发送给客户端。输入消息**你好**。客户端窗口现在将显示消息，如下所示：
- en: '**Connected to Chat Server**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**连接到聊天服务器**'
- en: '**Waiting for message from the server ...**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待来自服务器的消息...**'
- en: '**Message: Hello**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息：你好**'
- en: '**>**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**>**'
- en: 'On the server side, the following output will appear:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，将出现以下输出：
- en: '**Sent: Hello**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**已发送：你好**'
- en: '**Waiting for message from client ...**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待来自客户端的消息...**'
- en: We can now send a message from the client to the server. Messages can be interchanged
    in this manner until the `quit` message is sent from either application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从客户端向服务器发送消息。可以以这种方式交换消息，直到从任一应用程序发送`quit`消息为止。
- en: Handling multiple clients
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理多个客户端
- en: Handling multiple clients can be achieved using threads. In this section, we
    will develop a simple parts server and client applications. The server will use
    a separate thread to handle each client. This technique is simple to implement,
    but it will not always be suitable for more demanding applications. We will introduce
    alternate techniques to multitask in [Chapter 7](ch07.html "Chapter 7. Network
    Scalability"), *Network Scalability*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程可以实现处理多个客户端。在本节中，我们将开发一个简单的零件服务器和客户端应用程序。服务器将使用单独的线程来处理每个客户端。这种技术简单易行，但并不总是适用于更苛刻的应用程序。我们将介绍在[第7章](ch07.html
    "第7章 网络可扩展性")*网络可扩展性*中多任务处理的替代技术。
- en: The parts server is implemented in the `PartsServer` class, and the client is
    implemented in the `PartsClient` class. A new instance of a `ClientHandler` class
    will be created for each client. This handler will accept requests for the price
    of a part. The client will send the name of the part to the handler. The handler
    will look up the price of the part using the `getPrice` method of `PartsServer`.
    It will then return the price to the client.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 部件服务器实现在`PartsServer`类中，客户端实现在`PartsClient`类中。每个客户端将创建一个`ClientHandler`类的新实例。此处理程序将接受有关零件价格的请求。客户端将向处理程序发送零件的名称。处理程序将使用`PartsServer`的`getPrice`方法查找零件的价格。然后将价格返回给客户端。
- en: The parts server
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部件服务器
- en: 'The parts server uses a `HashMap` variable to hold information about parts.
    The name of the part is used as a key, and the value is stored as a `Float` object.
    The `PartsServer` class is declared here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 部件服务器使用`HashMap`变量来保存有关零件的信息。零件的名称用作键，值存储为`Float`对象。`PartsServer`类在此处声明：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once the server has started, the `initializeParts` method is called:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，将调用`initializeParts`方法：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This method follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是这个方法：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The handler will use the `getPrice` method to retrieve the price of a part,
    as shown next:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序将使用`getPrice`方法来检索零件的价格，如下所示：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After the `initializeParts` method has been called, a try block is used to
    open a connection to a client as shown here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`initializeParts`方法后，使用try块打开与客户端的连接，如下所示：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Next, an infinite loop will create a new handler for each client. While there
    are several ways of creating a thread in Java, the approach that is used next
    creates a new instance of the `ClientHandler` class, passing the client's socket
    to the class's constructor. This approach does not limit the number of threads
    created by the application, which makes it susceptible to a denial of service
    attack. In [Chapter 7](ch07.html "Chapter 7. Network Scalability"), *Network Scalability*,
    we will examine several alternate threading approaches.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，无限循环将为每个客户端创建一个新的处理程序。虽然在Java中有几种创建线程的方法，但下面使用的方法会创建“ClientHandler”类的新实例，并将客户端的套接字传递给类的构造函数。这种方法不限制应用程序创建的线程数量，这使得它容易受到拒绝服务攻击的影响。在[第7章](ch07.html
    "第7章。网络可扩展性")“网络可扩展性”中，我们将研究几种替代的线程方法。
- en: 'The `ClientHandler` instance is used as the argument of the `Thread` class.
    The class will create a new thread that will execute the `ClientHandler` class''s
    `run` method. However, the `run` method should not be called directly, but instead
    the `start` method is invoked. This method will create the program stack that
    is needed for the thread:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: “ClientHandler”实例用作“Thread”类的参数。该类将创建一个新线程，该线程将执行“ClientHandler”类的“run”方法。但是，“run”方法不应直接调用，而应调用“start”方法。此方法将创建线程所需的程序堆栈：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When the server is started, it will display the following output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器启动时，将显示以下输出：
- en: '**Part Server Started**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 零件服务器已启动
- en: '**Waiting for client ...**'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 等待客户端...
- en: Let's examine how the handler works.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看处理程序是如何工作的。
- en: The parts client handler
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 零件客户端处理程序
- en: The `ClientHandler` class is defined in the following code. The `socketChannel`
    instance variable is used to connect to the client. In the `run` method, a message
    indicating the start of the handler will be displayed. It is not required, but
    it will help us look at how the server, client, and handler interact.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: “ClientHandler”类在以下代码中定义。使用“socketChannel”实例变量连接到客户端。在“run”方法中，将显示处理程序开始的消息。虽然不是必需的，但它将帮助我们查看服务器、客户端和处理程序之间的交互。
- en: 'An infinite loop is entered where the `receiveMessage` method, developed in
    the *The HelperMethods class* section, is used to get the name of the part. A
    `quit` message will terminate the handler. Otherwise, the `getPrice` method is
    called, which is returned back to the client using the `sendMessage` method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 进入无限循环，使用在“HelperMethods类”部分中开发的“receiveMessage”方法获取零件的名称。“quit”消息将终止处理程序。否则，将调用“getPrice”方法，该方法使用“sendMessage”方法将结果返回给客户端：
- en: '[PRE22]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We will observe the output of the `run` method when we demonstrate the client.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们演示客户端时，我们将观察“run”方法的输出。
- en: The parts client
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 零件客户端
- en: 'The `PartsClient` class is defined in the next code sequence. A connection
    to the server is established. Messages are displayed indicating when the client
    starts, and the server connection is made. The `Scanner` class is used in the
    while loop to get input from the user:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: “PartsClient”类在下一个代码序列中定义。与服务器建立连接。显示消息以指示客户端何时启动，并且与服务器建立了连接。在while循环中使用“Scanner”类从用户那里获取输入：
- en: '[PRE23]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The body of the loop will prompt the user for a part name. If the name is quit,
    then the client will terminate. Otherwise, the `sendMessage` method will send
    the name to the handler for processing. The client will block at the `receiveMessage`
    method invocation until the server responds. The price of this part will then
    be displayed:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的主体将提示用户输入零件名称。如果名称是退出，则客户端将终止。否则，“sendMessage”方法将发送名称给处理程序进行处理。客户端将在“receiveMessage”方法调用时阻塞，直到服务器响应。然后将显示此零件的价格：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, let's see how they all work together.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它们如何一起工作。
- en: Running the parts client/server
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行零件客户端/服务器
- en: 'Start the server first. The server will produce the following output when it
    is started:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先启动服务器。服务器启动时将产生以下输出：
- en: '**Part Server started**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 零件服务器已启动
- en: '**Waiting for client ...**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 等待客户端...
- en: 'Now, start the client application. You will get this output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动客户端应用程序。您将获得此输出：
- en: '**PartsClient Started**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: PartsClient已启动
- en: '**Connected to Parts Server**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 已连接到零件服务器
- en: '**Enter part name:**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 输入零件名称：
- en: 'Enter a part name, such as `Hammer`. The client output will now appear as shown
    next. The **Sent: Hammer** output is an artifact of the `sendMessage` method and
    can be removed by modifying the `sendMessage` method if desired:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '输入零件名称，例如“锤子”。客户端输出现在将显示如下。如果需要，可以通过修改“sendMessage”方法来删除“Sent: Hammer”输出：'
- en: '**PartsClient Started**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: PartsClient已启动
- en: '**Connected to Parts Server**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 已连接到零件服务器
- en: '**Enter part name: Hammer**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 输入零件名称：锤子
- en: '**Sent: Hammer**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 已发送：锤子
- en: '**The price is 12.55**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 价格是12.55
- en: '**Enter part name:**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 输入零件名称：
- en: 'On the server side, you will get an output similar to the following one. A
    message displaying information about the handler is seen whenever a new client
    is started:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，您将获得类似以下输出。每当启动新客户端时，都会看到显示有关处理程序的信息的消息：
- en: '**Part Server Started**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 零件服务器已启动
- en: '**Waiting for client ...**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 等待客户端...
- en: '**ClientHandler Started for java.nio.channels.SocketChannel[connected local=/127.0.0.1:5000
    remote=/127.0.0.1:51132]**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 已为java.nio.channels.SocketChannel[connected local=/127.0.0.1:5000 remote=/127.0.0.1:51132]启动ClientHandler
- en: '**Waiting for client ...**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 等待客户端...
- en: '**Sent: 12.55**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 已发送：12.55
- en: 'From the client side, we can continue checking prices until we enter the `quit`
    command. This command will terminate the client. One possible sequence of requests
    is as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端方面，我们可以继续检查价格，直到输入“quit”命令。此命令将终止客户端。一种可能的请求序列如下：
- en: '**PartsClient Started**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: PartsClient已启动
- en: '**Connected to Parts Server**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 已连接到零件服务器
- en: '**Enter part name: Hammer**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 输入零件名称：锤子
- en: '**Sent: Hammer**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 已发送：锤子
- en: '**The price is 12.55**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 价格是12.55
- en: '**Enter part name: Pliers**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 输入零件名称：钳子
- en: '**Sent: Pliers**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 已发送：钳子
- en: '**The price is 4.65**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 价格是4.65
- en: '**Enter part name: saw**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 输入零件名称：锯子
- en: '**Sent: saw**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 已发送：锯子
- en: '**The price is null**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 价格为空
- en: '**Enter part name: Saw**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 输入零件名称：电锯
- en: '**Sent: Saw**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 已发送：电锯
- en: '**The price is 8.45**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 价格是8.45
- en: '**Enter part name: quit**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入部分名称：退出**'
- en: '**Sent: quit**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送：退出**'
- en: '**PartsClient Terminated**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**PartsClient终止**'
- en: 'The server will continue running as there may be other clients seeking price
    information. Output similar to the following one will be displayed by the server
    when a client handler terminates:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能有其他客户端正在寻找价格信息，服务器将继续运行。当客户端处理程序终止时，服务器将显示类似以下的输出：
- en: '**ClientHandler Terminated for java.nio.channels.SocketChannel[connected local=/127.0.0.1:5000
    remote=/127.0.0.1: 51132]**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**为java.nio.channels.SocketChannel[connected local=/127.0.0.1:5000 remote=/127.0.0.1:
    51132]终止ClientHandler**'
- en: Start up two or more clients, and watch how they interact with the server. We
    will investigate more sophisticated ways of scaling an application in [Chapter
    7](ch07.html "Chapter 7. Network Scalability"), *Network Scalability*.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 启动两个或更多客户端，并观察它们如何与服务器交互。我们将在[第7章](ch07.html "第7章 网络可扩展性")*网络可扩展性*中研究更复杂的应用程序扩展方式。
- en: Asynchronous socket channels
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步套接字通道
- en: Asynchronous communication involves making a request, and then proceeding with
    some other operation without having to wait for the request to be completed. This
    is referred to as non-blocking.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 异步通信涉及发出请求，然后继续进行其他操作，而无需等待请求完成。这被称为非阻塞。
- en: 'There are three classes used to support asynchronous channel operations:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个类用于支持异步通道操作：
- en: '`AsynchronousSocketChannel`: This is a simple asynchronous channel to a socket'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsynchronousSocketChannel`：这是一个简单的到套接字的异步通道'
- en: '`AsynchronousServerSocketChannel`: This is an asynchronous channel to a server
    socket'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsynchronousServerSocketChannel`：这是一个到服务器套接字的异步通道'
- en: '`AsynchronousDatagramChannel`: This is a channel for a datagram-oriented socket'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsynchronousDatagramChannel`：这是一个用于数据报套接字的通道'
- en: The read/write methods of the `AsynchronousSocketChannel` class are asynchronous.
    The `AsynchronousServerSocketChannel` class possesses an `accept` method, which
    returns an `AsynchronousSocketChannel` instance. This method is also asynchronous.
    We will discuss the `AsynchronousDatagramChannel` class in [Chapter 6](ch06.html
    "Chapter 6. UDP and Multicasting"), *UDP and Multicasting*.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsynchronousSocketChannel`类的读/写方法是异步的。`AsynchronousServerSocketChannel`类具有一个`accept`方法，该方法返回一个`AsynchronousSocketChannel`实例。这个方法也是异步的。我们将在[第6章](ch06.html
    "第6章 UDP和组播")*UDP和组播*中讨论`AsynchronousDatagramChannel`类。'
- en: 'There are two ways of handling asynchronous I/O operations:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异步I/O操作有两种方法：
- en: Using the `Future` interface found in the `java.util.concurrent` package
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`java.util.concurrent`包中找到`Future`接口
- en: Using a `CompletionHandler` interface
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`CompletionHandler`接口
- en: 'The `Future` interface represents a pending result. This supports asynchronous
    operations by allowing the application to continue executing and not block. Using
    this object, you can use one of the following methods:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`Future`接口表示一个未决结果。这通过允许应用程序继续执行而不阻塞来支持异步操作。使用这个对象，您可以使用以下方法之一：'
- en: The `isDone` method
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDone`方法'
- en: The `get` method, which blocks until completion
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`方法，它会阻塞直到完成'
- en: The `get` method is overloaded with one version supporting a timeout. The `CompletionHandler`
    instance is invoked when the operation has completed. This is essentially a callback.
    We will not illustrate this approach here.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法有一个支持超时的重载版本。当操作完成时，将调用`CompletionHandler`实例。这本质上是一个回调。我们将不在这里说明这种方法。'
- en: We will develop an asynchronous server and client called `AsynchronousServerSocketChannelServer`
    and `AsynchronousSocketChannelClient`, respectively. The client/server application
    is limited and only allows messages to be sent from the client to the server.
    This will allow us to focus on the asynchronous aspects of the application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个名为`AsynchronousServerSocketChannelServer`和`AsynchronousSocketChannelClient`的异步服务器和客户端。客户端/服务器应用程序是有限的，只允许从客户端发送消息到服务器。这将使我们能够专注于应用程序的异步方面。
- en: Creating the asynchronous server socket channel server
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建异步服务器套接字通道服务器
- en: 'The `AsynchronousServerSocketChannelServer` class is defined in the next code
    sequence. A message indicating that the server has started is displayed, and a
    try-with-resources block is entered where an instance of the `AsynchronousServerSocketChannel`
    class is created and the actual work occurs:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsynchronousServerSocketChannelServer`类在下一个代码序列中定义。显示了服务器已启动的消息，并进入了一个try-with-resources块，在这个块中创建了`AsynchronousServerSocketChannel`类的一个实例，并进行了实际的工作：'
- en: '[PRE25]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `bind` method is used to associate the `serverChannel` variable, representing
    the `AsynchronousServerSocketChannel` instance, with the localhost and port `5000`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`方法用于将代表`AsynchronousServerSocketChannel`实例的`serverChannel`变量与本地主机和端口`5000`关联起来：'
- en: '[PRE26]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The server then waits for a client to connect. The `Future` instance is reference
    by the `acceptResult` variable:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器然后等待客户端连接。`Future`实例由`acceptResult`变量引用：
- en: '[PRE27]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another try block is used to handle client requests. It creates an instance
    of the `AsynchronousSocketChannel` class, which connects to the client. The `get`
    method will block until the channel is created:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个try块用于处理客户端请求。它创建了一个`AsynchronousSocketChannel`类的实例，该实例连接到客户端。`get`方法将阻塞，直到通道被创建：
- en: '[PRE28]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The body of the try block will allocate a buffer and then read from the channel
    to populate the buffer. When the buffer has been populated, the `flip` method
    is applied to the buffer and the message is processed and displayed:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: try块的主体将分配一个缓冲区，然后从通道中读取以填充缓冲区。当缓冲区被填充时，将应用`flip`方法到缓冲区，并处理和显示消息：
- en: '[PRE29]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There are three ways of determining whether the buffer is ready. The first
    technique polls the `Future` object, represented by the result variable, using
    the `isDone` method until the buffer is ready, as shown here:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种确定缓冲区是否准备就绪的方法。第一种技术使用`isDone`方法轮询`Future`对象，由结果变量表示，直到缓冲区准备就绪，如下所示：
- en: '[PRE30]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The second technique uses the `get` method, which blocks until the buffer is
    ready:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种技术使用`get`方法，该方法会阻塞直到缓冲区准备就绪：
- en: '[PRE31]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The third technique also uses the `get` method but uses a timeout to determine
    how long to wait. In this example, it waits 10 seconds before timing out:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种技术也使用`get`方法，但使用超时来确定等待的时间。在这个例子中，它在超时之前等待10秒：
- en: '[PRE32]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When this version of the `get` method is used, a catch block needs to be added
    to the enclosing try block to handle a `TimeoutException` exception.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`get`方法的这个版本时，需要在封闭的try块中添加一个catch块来处理`TimeoutException`异常。
- en: 'When the server is started, we get the following output:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器启动时，我们得到以下输出：
- en: '**Asynchronous Server Started**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步服务器已启动**'
- en: '**Waiting for client to connect...**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待客户端连接...**'
- en: Now, let's examine the client.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看客户端。
- en: Creating the asynchronous socket channel client
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建异步套接字通道客户端
- en: 'The client is implemented using the `AsynchronousSocketChannelClient` class
    in the next code snippet. A message indicating that the client has started is
    displayed, followed by a try block that creates a `AsynchronousSocketChannel`
    instance:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端是使用下一个代码片段中的`AsynchronousSocketChannelClient`类实现的。首先显示客户端已启动的消息，然后是创建`AsynchronousSocketChannel`实例的try块：
- en: '[PRE33]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'An `InetSocketAddress` instance is created specifying the address and port
    number used by the server. A `Future` object representing the connection is then
    created. The `get` method will block until the connection is made:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`InetSocketAddress`实例，指定服务器使用的地址和端口号。然后创建表示连接的`Future`对象。`get`方法将阻塞，直到连接建立：
- en: '[PRE34]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Once the connection is made, a message is displayed. An infinite loop is entered
    where the user is prompted for a message. The `wrap` method will populate the
    buffer with the message. The `write` method will start writing the message to
    the `AsynchronousSocketChannel` instance and will return a `Future` object. The
    `isDone` method is used to wait for the write to complete. If the message is **quit**,
    the client application will terminate:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接，就会显示一条消息。进入一个无限循环，提示用户输入消息。`wrap`方法将使用消息填充缓冲区。`write`方法将开始将消息写入`AsynchronousSocketChannel`实例，并返回一个`Future`对象。使用`isDone`方法等待写入完成。如果消息是**退出**，客户端应用程序将终止：
- en: '[PRE35]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Let's take a look at the asynchronous client/server in action.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看异步客户端/服务器的运行情况。
- en: 'With the server running, start the client application. This will produce the
    following output:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器运行时，启动客户端应用程序。这将产生以下输出：
- en: '**Asynchronous Client Started**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步客户端已启动**'
- en: '**Client is started: true**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**客户端已启动：true**'
- en: '**Sending messages to server:**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**向服务器发送消息：**'
- en: '**>**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**>**'
- en: 'The output for the server now appears as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器的输出如下：
- en: '**Asynchronous Server Started**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步服务器已启动**'
- en: '**Waiting for client to connect...**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待客户端连接...**'
- en: '**Messages from client:**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**来自客户端的消息：**'
- en: 'Using the client, we can enter the following messages:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用客户端，我们可以输入以下消息：
- en: '**> Hello**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**> 你好**'
- en: '**> This message is from the asynchronous client and is sent to the server**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**> 这条消息来自异步客户端，发送到服务器**'
- en: '**> quit**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**> 退出**'
- en: 'These will be sent to the server one at a time. From the server, we will get
    the following response:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将逐一发送到服务器。从服务器端，我们将得到以下响应：
- en: '**Hello**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**你好**'
- en: '**This message is from the asynchr**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**这条消息来自异步**'
- en: '**onous client and is sent to the**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步客户端发送到**'
- en: '**server**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务器**'
- en: '**quit**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**退出**'
- en: Note that the longer message has been split across multiple lines. This is the
    result of using a server buffer size of only 32 bytes. A larger buffer would have
    avoided this issue. However, unless we know the size of the largest message that
    will be sent, we need to develop a way of handling long messages. This is left
    as an exercise for the reader.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，较长的消息已分成多行。这是使用服务器缓冲区大小仅为32字节的结果。更大的缓冲区将避免此问题。但是，除非我们知道将发送的最大消息的大小，否则我们需要开发一种处理长消息的方法。这留给读者作为练习。
- en: Other buffer operations
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他缓冲区操作
- en: We will wrap up by examining several other buffer operations that can be useful.
    These include bulk data transfers between a buffer and an array using a view,
    and read-only buffers.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过检查其他几种有用的缓冲区操作来结束。这些包括使用视图在缓冲区和数组之间进行批量数据传输，以及只读缓冲区。
- en: Bulk data transfer
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量数据传输
- en: 'Bulk transfer is a way of transferring data between a buffer and an array.
    There are several get and put type methods that support bulk data transfers. They
    usually have two versions. The first version uses a single argument, which is
    the transfer array. The second version also uses an array, but it has two additional
    arguments: the starting index in the array, and the number of elements to transfer.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 批量传输是在缓冲区和数组之间传输数据的一种方式。有几种支持批量数据传输的get和put类型方法。它们通常有两个版本。第一个版本使用一个参数，即传输数组。第二个版本也使用数组，但有两个额外的参数：数组中的起始索引和要传输的元素数。
- en: 'To demonstrate these techniques, we will use an `IntBuffer` buffer. We will
    use the following `displayBuffer` method to help us understand how data transfers
    work:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些技术，我们将使用`IntBuffer`缓冲区。我们将使用以下`displayBuffer`方法来帮助我们理解数据传输的工作原理：
- en: '[PRE36]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will start by declaring an array and transferring its contents to a buffer.
    The array is declared and initialized in the following statement:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先声明一个数组，并将其内容传输到缓冲区。数组在以下语句中声明并初始化：
- en: '[PRE37]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A buffer is allocated, which is larger than the array, as shown next. The difference
    between the array size and the data available in the buffer is important. If not
    handled properly, exceptions will be thrown:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 分配了一个比数组更大的缓冲区，如下所示。数组大小与缓冲区中可用数据之间的差异很重要。如果处理不当，将抛出异常：
- en: '[PRE38]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, we will use the bulk `put` method to transfer the contents of the array
    to the buffer:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用批量`put`方法将数组的内容传输到缓冲区：
- en: '[PRE39]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The buffer is then displayed using the following statements:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用以下语句显示缓冲区：
- en: '[PRE40]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output is as follows. The entire array has been transferred, and the position
    is set to the next available index:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下。整个数组已经传输，位置设置为下一个可用的索引：
- en: '**java.nio.HeapIntBuffer[pos=4 lim=6 cap=6]**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**java.nio.HeapIntBuffer[pos=4 lim=6 cap=6]**'
- en: '**12 51 79 54**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**12 51 79 54**'
- en: 'As there is still room in the buffer, we can transfer more data into it. However,
    we have to be careful not to try to transfer too much, otherwise an exception
    will be thrown. The first step is to determine how much space is left in the buffer.
    As shown next, the `remaining` method does this. The bulk `put` statement then
    transfers the first two elements of the array to the last two positions of the
    buffer, as shown here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓冲区仍有空间，我们可以将更多数据传输到其中。但是，我们必须小心，不要尝试传输太多数据，否则将抛出异常。第一步是确定缓冲区中剩余多少空间。如下所示，`remaining`方法可以做到这一点。然后，批量`put`语句将数组的前两个元素转移到缓冲区的最后两个位置，如下所示：
- en: '[PRE41]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we display the buffer and its contents again, we get the following output:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次显示缓冲区及其内容，我们将得到以下输出：
- en: '**java.nio.HeapIntBuffer[pos=6 lim=6 cap=6]**'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**java.nio.HeapIntBuffer[pos=6 lim=6 cap=6]**'
- en: '**12 51 79 54 12 51**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**12 51 79 54 12 51**'
- en: 'The `get` method is overloaded to support bulk data transfer. We can modify
    the `displayBuffer` method to illustrate how this works, as shown next. An integer
    array is created that is the same size as the contents of the buffer. The `rewind`
    method will move the position of the buffer back to zero. The bulk `get` method
    then performs the transfer followed by a for-each loop to actually display its
    contents:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法被重载以支持批量数据传输。我们可以修改`displayBuffer`方法来说明这是如何工作的，如下所示。创建了一个与缓冲区内容大小相同的整数数组。`rewind`方法将缓冲区的位置移回零。然后批量`get`方法执行传输，然后是一个for-each循环来实际显示其内容：'
- en: '[PRE42]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using a view
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视图
- en: 'A view mirrors the data in another buffer. Modification to either buffer will
    affect the other buffer. However, the position and limit are independent. A view
    can be created with several methods, including the `duplicate` method. In the
    following example, a view is made of a buffer using the bulk `getBytes` method
    against a string. The view is then created:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 视图反映了另一个缓冲区中的数据。对任一缓冲区的修改都会影响另一个缓冲区。但是，位置和限制是独立的。可以使用多种方法创建视图，包括`duplicate`方法。在下面的示例中，使用批量`getBytes`方法针对字符串创建了一个缓冲区的视图。然后创建了一个视图：
- en: '[PRE43]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To demonstrate that the modification of one buffer will affect the other buffer,
    the first character of the duplicate is changed to the letter ''L''. The first
    byte of each buffer is then displayed to confirm the change:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明修改一个缓冲区将影响另一个缓冲区，将复制的第一个字符更改为字母“L”。然后显示每个缓冲区的第一个字节以确认更改：
- en: '[PRE44]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The output will show that the letter has been changed in both buffers. The `slice`
    method will also create a view, but it uses only a portion of the original buffer.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示字母已在两个缓冲区中更改。`slice`方法还将创建一个视图，但它仅使用原始缓冲区的一部分。
- en: Using read-only buffers
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用只读缓冲区
- en: 'A buffer, by default, is read-write. However, it can be read-only or read-write.
    To create a read-only buffer, use the buffer class''s `asReadOnlyBuffer` method.
    In the next sequence, a read-only buffer is created:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，缓冲区是读写的。但是，它可以是只读的或读写的。要创建只读缓冲区，请使用缓冲区类的`asReadOnlyBuffer`方法。在下一个序列中，创建了一个只读缓冲区：
- en: '[PRE45]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `isReadOnly` method will determine if a buffer is read-only as demonstrated
    here:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`isReadOnly`方法将确定缓冲区是否为只读，如下所示：'
- en: '[PRE46]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The read-only buffer is a different view of the original buffer. Any modifications
    to a buffer is reflected in the other buffer.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 只读缓冲区是原始缓冲区的不同视图。对缓冲区的任何修改都会反映在另一个缓冲区中。
- en: Controlling socket options
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制套接字选项
- en: The underlying socket implementation for the socket classes can be configured.
    The options available are dependent on the socket type. Frequently, the actual
    mechanism used to support an option is OS-specific. Also, sometimes the option
    is just a hint to the underlying implementation.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字类的底层套接字实现可以进行配置。可用的选项取决于套接字类型。通常，支持选项的实际机制是特定于操作系统的。而且，有时选项只是对底层实现的提示。
- en: 'The options available for each socket class shown next is adapted from the
    Java API documentation:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 下面显示的每个套接字类的可用选项是从Java API文档中获取的：
- en: '| Class | Option name | Description |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 选项名称 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `SocketChannel` | `SO_SNDBUF` | This is the size of the socket send buffer
    |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '`SocketChannel` | `SO_SNDBUF` | 这是套接字发送缓冲区的大小'
- en: '| `SO_RCVBUF` | This is the size of the socket receive buffer |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '`SO_RCVBUF` | 这是套接字接收缓冲区的大小'
- en: '| `SO_KEEPALIVE` | This keeps the connection alive |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '`SO_KEEPALIVE` | 这将保持连接活动'
- en: '| `SO_REUSEADDR` | This re-uses the address |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '`SO_REUSEADDR` | 这将重新使用地址'
- en: '| `SO_LINGER` | This lingers on close if data is present (when configured in
    blocking mode only) |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '`SO_LINGER` | 如果存在数据，则在关闭时等待（仅在配置为阻塞模式时）'
- en: '| `TCP_NODELAY` | This will disable the Nagle algorithm |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '`TCP_NODELAY` | 这将禁用Nagle算法'
- en: '| `ServerSocketChannel` | `SO_RCVBUF` | This is the size of the socket receive
    buffer |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '`ServerSocketChannel` | `SO_RCVBUF` | 这是套接字接收缓冲区的大小'
- en: '| `SO_REUSEADDR` | This re-uses address |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '`SO_REUSEADDR` | 这将重新使用地址'
- en: '| `AsynchronousSocketChannel` | `SO_SNDBUF` | This is the size of the socket
    send buffer |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '`AsynchronousSocketChannel` | `SO_SNDBUF` | 这是套接字发送缓冲区的大小'
- en: '| `SO_RCVBUF` | This is the size of the socket receive buffer |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '`SO_RCVBUF` | 这是套接字接收缓冲区的大小'
- en: '| `SO_KEEPALIVE` | This keeps the connection alive |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '`SO_KEEPALIVE` | 这将保持连接活动'
- en: '| `SO_REUSEADDR` | This re-uses address |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '`SO_REUSEADDR` | 这将重新使用地址'
- en: '| `TCP_NODELAY` | This will disable the Nagle algorithm |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '`TCP_NODELAY` | 这将禁用Nagle算法'
- en: 'Socket options are configured using the `setOption` method. The following code
    illustrates this method using a server socket channel used in *The parts server*
    section:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 套接字选项是使用`setOption`方法进行配置的。以下代码示例了在“零件服务器”部分中使用的服务器套接字通道的此方法：
- en: '[PRE47]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The first argument is an instance of the `SocketOption<T>` interface. This
    interface defines the name and type methods for an option. The `StandardSocketOptions`
    class defines a series of options, which implement this interface. For example,
    the `SO_RCVBUF` instance is defined as follows:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是`SocketOption<T>`接口的实例。该接口为选项定义了名称和类型方法。`StandardSocketOptions`类定义了一系列选项，这些选项实现了该接口。例如，`SO_RCVBUF`实例定义如下：
- en: '[PRE48]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There may be additional, implementation-specific options available.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有其他特定于实现的选项可用。
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we examined the use of the NIO's channel and buffer classes.
    A channel connects to an external source and transfers data to and from a buffer.
    We illustrated channel sockets, which connect to another socket across the network.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了NIO的通道和缓冲区类的使用。通道连接到外部源，并在缓冲区之间传输数据。我们举例说明了通道套接字，它们连接到网络中的另一个套接字。
- en: Buffers are temporary repositories for data. Using a buffer allows data to be
    accessed either sequentially or randomly. There are many buffer operations, which
    makes this a good choice for many applications.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区是数据的临时存储库。使用缓冲区可以顺序或随机访问数据。有许多缓冲区操作，这使得它成为许多应用程序的良好选择。
- en: We examined several types of channel sockets, including the `SocketChannel`,
    `ServerSocketChannel`, and `AsynchronousSocketChannel` classes. The `ServerSocketChannel`
    class supports a server and uses an `accept` method to block until a client requests
    a connection. The method will return a `SocketChannel` instance, which will be
    connected to the client's `SocketChannel`. The `AsynchronousSocketChannel` and
    `AsynchronousSocketChannel` classes support asynchronous communication enabling
    non-blocking communication between two applications. The `DatagramChannel` is
    also supported, which we will investigate in [Chapter 6](ch06.html "Chapter 6. UDP
    and Multicasting"), *UDP and Multicasting*.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了几种类型的通道套接字，包括`SocketChannel`、`ServerSocketChannel`和`AsynchronousSocketChannel`类。`ServerSocketChannel`类支持服务器，并使用`accept`方法阻塞直到客户端请求连接。该方法将返回一个`SocketChannel`实例，该实例将连接到客户端的`SocketChannel`。`AsynchronousSocketChannel`和`AsynchronousSocketChannel`类支持异步通信，实现两个应用程序之间的非阻塞通信。还支持`DatagramChannel`，我们将在[第6章](ch06.html
    "第6章. UDP和组播")中进行调查，*UDP和组播*。
- en: We explained how the buffer and channel classes work together and illustrated
    their use in several client/server applications. We also examined a simple approach
    to handle multiple clients using threads.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解释了缓冲区和通道类如何协同工作，并举例说明了它们在几个客户端/服务器应用程序中的使用。我们还研究了使用线程处理多个客户端的简单方法。
- en: We demonstrated how bulk data transfers are performed between an array and a
    buffer. Views and the use of read-only buffers were also examined. We ended with
    an introduction to how the underlying OS socket support can be configured.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们演示了如何在数组和缓冲区之间执行大容量数据传输。还研究了视图和只读缓冲区的使用。最后介绍了如何配置底层操作系统套接字支持。
- en: In the next chapter, we will use many of these classes and techniques to support
    other client/server applications.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用许多这些类和技术来支持其他客户端/服务器应用程序。
