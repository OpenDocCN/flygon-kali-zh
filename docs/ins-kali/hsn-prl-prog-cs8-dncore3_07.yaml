- en: Synchronization Primitives
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步原语
- en: In the previous chapter, we discussed the potential pitfalls of parallel programming.
    One of these was synchronization overheads. As we break down work into tasks to
    be processed by multiple work items, there arises a need to synchronize the results
    from each thread. We discussed the concept of thread-local-storage and partition-local-storage,
    which can be used to work around this synchronization issue to a certain extent.
    However, it is still necessary to synchronize threads so that we can write data
    to a shared memory location and so that we can perform I/O operations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了并行编程的潜在缺陷之一是同步开销。当我们将工作分解为由多个工作项处理的任务时，就会出现需要同步每个线程的结果的情况。我们讨论了线程本地存储和分区本地存储的概念，可以在一定程度上解决这个同步问题。然而，仍然需要同步线程，以便我们可以将数据写入共享内存位置，并执行I/O操作。
- en: In this chapter, we will discuss the synchronization primitives that are provided
    by the .NET Framework and the TPL.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论.NET Framework和TPL提供的同步原语。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Synchronization primitives
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步原语
- en: Interlocked operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子操作
- en: Locking primitives
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁原语
- en: Signaling primitives
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号原语
- en: Lightweight synchronization primitives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级同步原语
- en: Barriers and countdown events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏障和倒计时事件
- en: By the end of this chapter, you will have a good understanding of the various
    locking and signaling primitives that are provided by .NET Framework, including
    some lightweight synchronization primitives that should be used as much as possible
    wherever there are synchronization needs.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将对.NET Framework提供的各种锁定和信号原语有很好的理解，包括一些轻量级同步原语，应尽可能在需要同步的地方使用。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you should have a good understanding of TPL, primarily
    parallel loops. The source code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter05).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您应该对TPL有很好的理解，主要是并行循环。本章的源代码可在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter05)。
- en: What are synchronization primitives?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是同步原语？
- en: Before understanding synchronization primitives, we need to understand critical
    section. Critical section is part of the execution path of a thread that must
    be protected from concurrent access in order to maintain some invariants. Critical
    section is not a synchronization primitive in itself but relies on synchronization
    primitives.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解同步原语之前，我们需要了解临界区。临界区是线程执行路径的一部分，必须受到保护，以维护一些不变量。临界区本身不是同步原语，但依赖于同步原语。
- en: Synchronization primitives are simple software mechanisms that are provided
    by the underlying platform (the OS). They help in multithreading the kernel. Synchronization
    primitives internally use low-level atomic operations, as well as memory barriers.
    This means that users of synchronization primitives don't have to worry about
    implementing locks and memory barriers themselves. Some common examples of synchronization
    primitives are locks, mutexes, conditional variables, and semaphores. The monitor
    is a higher-level synchronization tool that makes use of other synchronization
    primitives internally.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同步原语是由底层平台（操作系统）提供的简单软件机制。它们有助于在内核中进行多线程处理。同步原语内部使用低级原子操作和内存屏障。这意味着同步原语的用户不必担心自己实现锁和内存屏障。一些常见的同步原语示例包括锁、互斥锁、条件变量和信号量。监视器是一种更高级的同步工具，它在内部使用其他同步原语。
- en: 'The .NET Framework provides a range of synchronization primitives to deal with
    the interaction among threads, as well as to avoid potential race conditions.
    Synchronization primitives can be broadly divided into five categories:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework提供了一系列同步原语，用于处理线程之间的交互，以及避免潜在的竞争条件。同步原语可以大致分为五类：
- en: Interlocked operations
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原子操作
- en: Locking
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定
- en: Signaling
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号
- en: Lightweight synchronization types
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级同步类型
- en: '`SpinWait`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SpinWait`'
- en: In the following sections, we will discuss each category and their respective
    low-level primitives.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论每个类别及其各自的低级原语。
- en: Interlocked operations
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子操作
- en: The interlocked class encapsulates synchronization primitives and is used to
    provide atomic operations to variables that are shared across threads. It provides
    methods such as `Increment`, `Decrement`, `Add`, `Exchange`, and `CompareExchange`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Interlocked类封装了同步原语，并用于为跨线程共享的变量提供原子操作。它提供了`Increment`、`Decrement`、`Add`、`Exchange`和`CompareExchange`等方法。
- en: 'Consider the following code, which tries to increment a counter inside a parallel
    loop:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它尝试在并行循环中递增一个计数器：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we run this code, we will see the following output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，将会看到以下输出：
- en: '![](img/02d70e3d-6df9-4fb4-824e-222489691f08.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02d70e3d-6df9-4fb4-824e-222489691f08.png)'
- en: As you can see, the expected value and the actual value do not match. This is
    because of the race condition among the threads, which has arisen because the
    thread wants to read a value from a variable to which the value has been written
    but not yet committed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，预期值和实际值不匹配。这是因为线程之间存在竞争条件，这是因为线程想要从一个变量中读取一个值，而该值尚未被提交。
- en: 'We can modify the preceding code using the `Interlocked` class to make it thread-safe,
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Interlocked`类修改上述代码，使其线程安全，如下所示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The expected output is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![](img/a3406d7f-f496-46c5-a762-0cc384cd4b01.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3406d7f-f496-46c5-a762-0cc384cd4b01.png)'
- en: Similarly, we can use `Interlocked.Decrement(ref _counter)` to decrement the
    value in a thread-safe manner.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用`Interlocked.Decrement(ref _counter)`以线程安全的方式减少值。
- en: 'The following code shows the complete list of operations:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了完整的操作列表：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Apart from the preceding methods, two new methods were added in .NET Framework
    4.5: `Interlocked.MemoryBarrier()` and `Interlocked.MemoryBarrierProcessWide()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的方法，.NET Framework 4.5中还添加了两个新方法：`Interlocked.MemoryBarrier()`和`Interlocked.MemoryBarrierProcessWide()`。
- en: In the next section, we will learn more about memory barriers in .NET.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习更多关于.NET中的内存屏障。
- en: Memory barriers in .NET
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET中的内存屏障
- en: Threading models work differently on single-core versus multicore processors.
    On single-core processors, only one thread gets a CPU slice while other threads
    wait for their turn. This ensures that whenever a thread accesses the memory (for
    loading and storing), it is in the right order. This model is also known as a
    **sequential consistency model**. In the case of multicore processor systems,
    multiple threads run concurrently. Sequential consistency is not guaranteed in
    these systems since either the hardware or the **Just in Time** (**JIT**) compiler
    might reorder the memory instructions to improve performance. The memory instructions
    may also be reordered for performance purposes for caching, load speculations,
    or delaying store operations.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 单核处理器和多核处理器上的线程模型工作方式不同。在单核处理器上，只有一个线程获得CPU时间片，而其他线程则等待它们的轮次。这确保了每当一个线程访问内存（用于加载和存储）时，它都是按正确的顺序进行的。这个模型也被称为**顺序一致性模型**。在多核处理器系统中，多个线程同时运行。在这些系统中，无法保证顺序一致性，因为硬件或**即时**（**JIT**）编译器可能会重新排序内存指令以提高性能。内存指令也可能会因为缓存、加载推测或延迟存储操作而进行重新排序以提高性能。
- en: 'An example of a load speculation is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 加载推测的示例如下：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'An example of a store operation is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 存储操作的示例如下：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Load and store statements, when encountered by the compiler, are not always
    executed in the same order as they are written. Compilers do some reordering for
    performance benefits. Let's try to understand more about reordering.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译器遇到加载和存储语句时，并不总是按照它们被编写的顺序执行。编译器会进行一些重新排序以获得性能上的好处。让我们试着更多地了解重新排序。
- en: What is reordering?
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是重新排序？
- en: 'For a given sequence of code statements, the compiler can choose to either
    execute them in the same order as they are received or reorder them to gain performance
    if multiple threads are working on the same code. For example, take a look at
    the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的代码语句序列，编译器可以选择按照接收到的顺序执行它们，或者重新排序它们以提高性能，如果多个线程正在处理相同的代码。例如，看一下以下代码：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code can be reordered and executed in the following order for
    another thread:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以被重新排序并以以下顺序执行给另一个线程：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Code reordering is a problem for multicore processors with weak memory models,
    such as Intel Itanium processors. It has no impact on single-core processors,
    however, due to the sequential consistency model. The code is restructured so
    that another thread can take advantage or store an instruction that is already
    in the memory. Code reordering can be done either by hardware or by a JIT compiler.
    To guarantee code reordering, we need some sort of **memory barrier**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有弱内存模型的多核处理器（如英特尔Itanium处理器），代码重新排序是一个问题。然而，对于单核处理器来说，由于顺序一致性模型，它没有影响。代码被重组，以便另一个线程可以利用或存储已经在内存中的指令。代码重新排序可以由硬件或JIT编译器来完成。为了保证代码重新排序，我们需要某种**内存屏障**。
- en: Types of memory barriers
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存屏障的类型
- en: 'Memory barriers ensure that any code statements above or below the barrier
    will not cross the barrier, thereby enforcing the order of the code. There are
    three types of memory barrier:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 内存屏障确保屏障上方或下方的任何代码语句都不会越过屏障，从而强制执行代码的顺序。有三种类型的内存屏障：
- en: '**Store (write) memory barrier: **A store memory barrier ensures that no store
    operations are allowed to move across the barrier. It has no effect on load operations;
    these can still be reordered. The equivalent CPU instruction to achieve this effect
    is **SFENCE**:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储（写入）内存屏障：**存储内存屏障确保不允许存储操作越过屏障。它对加载操作没有影响；这些操作仍然可以被重新排序。实现此效果的等效CPU指令是**SFENCE**：'
- en: '![](img/d03a60bd-ad17-46a1-afdc-8157aeae929d.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d03a60bd-ad17-46a1-afdc-8157aeae929d.png)'
- en: '**Load (read) memory barrier: **A load barrier ensures that no load operations
    are allowed to move across the barrier but places no such enforcement on store
    operations. The equivalent CPU instruction to achieve this effect is **LFENCE**:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载（读取）内存屏障：**加载屏障确保不允许加载操作越过屏障，但对存储操作不做任何强制。实现此效果的等效CPU指令是**LFENCE**：'
- en: '![](img/6ad7473e-6976-40c6-8282-08b4300a9bf5.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ad7473e-6976-40c6-8282-08b4300a9bf5.png)'
- en: '**Full memory barrier: **A full memory barrier ensures ordering by not allowing
    store or load operations to move across the memory barrier. The equivalent CPU
    instruction to achieve this effect is **MFENCE**. The behavior of the full memory
    barrier is often implemented by .NET synchronization constructs such as the following:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整内存屏障：**完整内存屏障通过不允许存储或加载操作越过内存屏障来确保顺序。实现此效果的等效CPU指令是**MFENCE**。完整内存屏障的行为通常由.NET同步构造实现，例如以下内容：'
- en: '`Task.Start`, `Task.Wait`, and `Task.Continuation`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task.Start`、`Task.Wait`和`Task.Continuation`'
- en: '`Thread.Sleep`, `Thread.Join`, `Thread.SpinWait`, `Thread.VolatileRead`, and `Thread.VolatileWrite`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.Sleep`、`Thread.Join`、`Thread.SpinWait`、`Thread.VolatileRead`和`Thread.VolatileWrite`'
- en: '`Thread.MemoryBarrier`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.MemoryBarrier`'
- en: '`Lock`, `Monitor.Enter`, and `Monitor.Exit`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lock`、`Monitor.Enter`和`Monitor.Exit`'
- en: '`Interlocked` class operations'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Interlocked`类的操作'
- en: Half barriers are provided by the `Volatile` keyword and the `Volatile` class
    methods. The .NET Framework provides some built-in patterns using volatile fields
    in classes such as `Lazy<T>` and `LazyInitializer`. We will discuss these further
    in [Chapter 7](584edc9a-7c38-480b-a280-b6c17008ae94.xhtml), *Improving Performance
    with Lazy Initialization*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Volatile`关键字和`Volatile`类方法提供了半屏障。.NET Framework提供了一些内置模式，使用类中的`Volatile`字段，如`Lazy<T>`和`LazyInitializer`。我们将在[第7章](584edc9a-7c38-480b-a280-b6c17008ae94.xhtml)中进一步讨论这些，*使用延迟初始化提高性能*。'
- en: Avoiding code reordering using constructs
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用构造避免代码重排序
- en: 'We can avoid reordering using `Thread.MemoryBarrier`, as shown in the following
    code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Thread.MemoryBarrier`避免重排序，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Thread.MemoryBarrier` creates a full barrier that doesn’t allow load or store
    operations to pass. It has been wrapped inside `Interlocked.MemoryBarrier`, so
    the same code can be written as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.MemoryBarrier`创建一个不允许加载或存储操作通过的完整屏障。它已经包装在`Interlocked.MemoryBarrier`中，因此可以将相同的代码编写如下：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we want to create a process- and system-wide barrier, we can make use of
    `Interlocked.MemoryBarrierProcessWide`, which was introduced in .NET Core 2.0\.
    This is a wrapper over the `FlushProcessWriteBuffer` Windows API or `sys_membarrier` on
    a Linux kernel:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想创建一个进程范围和系统范围的屏障，我们可以使用.NET Core 2.0中引入的`Interlocked.MemoryBarrierProcessWide`。这是对`FlushProcessWriteBuffer`
    Windows API或Linux内核上的`sys_membarrier`的包装：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding example shows us how we can create a process-wide barrier. Now,
    let's look at what locking primitives are.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子向我们展示了如何创建一个进程范围的屏障。现在，让我们来看看锁定原语是什么。
- en: Introduction to locking primitives
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定原语简介
- en: Locks can be used to limit access to a protected resource to only a single thread
    or group of threads. To be able to implement locking efficiently, we need to identify
    appropriate critical sections that can be protected via locking primitives.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 锁可以用来限制对受保护资源的访问，只允许单个线程或一组线程。为了能够有效地实现锁定，我们需要识别可以通过锁定原语保护的适当的临界区。
- en: How locking works
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定的工作原理
- en: 'When we apply a lock to a shared resource, the following steps are performed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对共享资源应用锁时，执行以下步骤：
- en: A thread or group of threads access a shared resource by acquiring a lock.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个线程或一组线程通过获取锁来访问共享资源。
- en: Other threads that cannot get access to a lock go into a wait state.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无法访问锁定的其他线程进入等待状态。
- en: As soon as the lock is freed by one of the threads, it is acquired by another
    thread, which starts its execution.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦锁被一个线程释放，另一个线程就会获取它，并开始执行。
- en: To understand locking primitives, we need to understand various thread states,
    as well as concepts such as blocking and spinning.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解锁定原语，我们需要了解各种线程状态，以及阻塞和自旋等概念。
- en: Thread state
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程状态
- en: 'At any point during the thread''s life cycle, we can query a thread state using
    the `ThreadState` property of the thread. A thread can be in any one of the following
    states:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在线程的生命周期的任何时刻，我们都可以使用线程的`ThreadState`属性查询线程状态。线程可以处于以下任一状态：
- en: '`Unstarted`: The thread has been created by CLR but the `System.Threading.Thread.Start`
    method hasn''t been invoked on the thread yet.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`未启动`：线程已被CLR创建，但尚未调用`System.Threading.Thread.Start`方法。'
- en: '`Running`: The thread has been started via a call to `Thread.Start`. It is
    not waiting for any pending operations.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`运行`：线程已通过调用`Thread.Start`启动。它不在等待任何未决操作。'
- en: '`WaitSleepJoin`: The thread is in a blocked state as a result of invoking the
    `Wait()`, `Sleep()`, or `Join()` methods by calling the thread.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitSleepJoin`：由于调用`Wait()`、`Sleep()`或`Join()`方法，线程处于阻塞状态。'
- en: '`StopRequested`: The thread has been requested to stop.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`停止请求`：线程已被请求停止。'
- en: '`Stopped`: The thread has stopped executing.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已停止`：线程已停止执行。'
- en: '`AbortRequested`: The `Abort()` method has been called on the thread, but the
    thread hasn''t been aborted yet as it is waiting for `ThreadAbortException`, which
    will try to terminate it.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`中止请求`：在线程上调用了`Abort()`方法，但线程尚未被中止，因为它正在等待`ThreadAbortException`来尝试终止它。'
- en: '`Aborted`: The thread has been aborted.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`中止`：线程已被中止。'
- en: '`SuspendRequested`: The thread is requested to suspend as a result of calling
    the `Suspend` method.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`暂停请求`：由于调用`Suspend`方法，线程被请求暂停。'
- en: '`Suspended`: The thread has been suspended.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已暂停`：线程已被暂停。'
- en: '`Background`: The thread is being executed in the background.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`后台`：线程在后台执行。'
- en: 'Let''s try to explore the journey of a thread from its initial state, `UnStarted`,
    to its final state, `Stopped`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试探索线程从初始状态`未启动`到最终状态`已停止`的过程：
- en: '![](img/77801852-0e65-4a02-853e-ac10b7ad47c4.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77801852-0e65-4a02-853e-ac10b7ad47c4.png)'
- en: 'When a thread is created by CLR, it is in an `Unstarted` state. It makes a
    transition from `Unstarted` to `Running` when the external thread calls the `Thread.Start()`
    method on it. From the `Running` state, a thread can transition to the following
    states:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当CLR创建线程时，它处于`未启动`状态。当外部线程调用`Thread.Start()`方法时，它从`未启动`状态转换到`运行`状态。从`运行`状态，线程可以转换到以下状态：
- en: '`WaitSleepJoin`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitSleepJoin`'
- en: '`AbortRequested`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`中止请求`'
- en: '`Stopped`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已停止`'
- en: A thread is said to be blocked when it is in the `WaitSleepJoin` state. The
    execution of a blocked thread is paused since it is waiting for some external
    conditions to be met, which may be the result of some CPU-bound I/O operation
    or some other thread. Once blocked, the thread immediately yields the CPU time
    slice and doesn't use the processor slice until the blocked condition is satisfied.
    At this point, the thread is unblocked. Blocking and unblocking constitutes a
    performance overhead as this requires the CPU to carry out context switching.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程处于`WaitSleepJoin`状态时，就说它被阻塞了。被阻塞的线程的执行被暂停，因为它正在等待一些外部条件的满足，这可能是一些CPU绑定的I/O操作或其他线程的结果。一旦被阻塞，线程立即放弃CPU时间片，并且在满足阻塞条件之前不使用处理器时间片。在这一点上，线程被解除阻塞。阻塞和解除阻塞构成了性能开销，因为这需要CPU进行上下文切换。
- en: 'A thread can be unblocked in any of the following events:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可以在以下事件中解除阻塞：
- en: If the blocking condition is satisfied
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果满足阻塞条件
- en: By calling `Thread.Interrupt` on the blocked thread
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在被阻塞的线程上调用`Thread.Interrupt`
- en: By aborting a thread using `Thread.Abort`
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`Thread.Abort`中止线程
- en: When the specified timeout is reached
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当达到指定的超时时间
- en: Blocking versus spinning
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 阻塞与自旋
- en: 'A blocked thread relinquishes the processor slice for a specified amount of
    time. This improves performance by making it available for other threads but incurs
    the overhead of context switching. It is good in a scenario where the thread has
    to be blocked for a considerable amount of time. If the waiting time is less,
    it makes sense to go for spinning without relinquishing the processor slice. For
    example, the following code simply loops infinitely:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 阻塞的线程放弃处理器时间片段一段时间。这通过使其可用于其他线程来提高性能，但会产生上下文切换的开销。在线程必须被阻塞一段时间的情况下，这是很好的。如果等待时间较短，选择自旋而不放弃处理器时间片段是有意义的。例如，以下代码简单地无限循环：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is just an empty `while` loop that checks for a Boolean variable. When
    the wait is over, the variable will be set to false and the loop can break. Although
    this is a waste of processor time, it can significantly improve performance if
    the wait isn't very long. The .NET Framework provides some special constructs,
    which we will discuss later in this chapter, such as `SpinWait` and `SpinLock`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个空的`while`循环，检查一个布尔变量。当等待结束时，变量将被设置为false，循环可以中断。虽然这会浪费处理器时间，但如果等待时间不是很长，它可以显著提高性能。.NET
    Framework提供了一些特殊的构造，我们将在本章后面讨论，比如`SpinWait`和`SpinLock`。
- en: Let’s try to understand some locking primitives with code examples.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过代码示例了解一些锁定原语。
- en: Lock, mutex, and semaphore
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁，互斥锁和信号量
- en: Lock and mutex are locking constructs that allow only one thread to access a
    protected resource. Lock is a shortcut implementation that uses another higher-level
    synchronization class called `Monitor`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 锁和互斥锁是锁定构造，只允许一个线程访问受保护的资源。锁是一个使用另一个更高级别的同步类`Monitor`的快捷实现。
- en: Semaphore is a locking construct that allows a specified number of threads to
    access a protected resource. Lock can only synchronize access inside a process,
    but if we need to access a system-level resource or shared memory, we need to
    actually synchronize access across multiple processes. A mutex allows us to synchronize
    access to resources across processes by providing a kernel-level lock.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量是一种锁定构造，允许指定数量的线程访问受保护的资源。锁只能在进程内部同步访问，但如果我们需要访问系统级资源或共享内存，我们实际上需要跨多个进程同步访问。互斥锁允许我们通过提供内核级别的锁来跨进程同步访问资源。
- en: 'The following table provides a comparison of the capabilities of these constructs:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了这些构造的功能比较：
- en: '![](img/3333def0-bb0b-4805-b86c-ca1607865494.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3333def0-bb0b-4805-b86c-ca1607865494.png)'
- en: As we can see, **Lock** and **Mutex** only allow single-thread access to shared
    resources, whereas **Semaphore** and **SemaphoreSlim** can be used to allow access
    to resources that have been shared by multiple threads. Also, where **Lock** and
    **SemaphoreSlim** only work inside a process, **Mutex** and **Semaphore** have
    a process-wide lock.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，**Lock**和**Mutex**只允许单线程访问共享资源，而**Semaphore**和**SemaphoreSlim**可以用于允许多个线程共享的资源。此外，**Lock**和**SemaphoreSlim**只能在进程内部工作，而**Mutex**和**Semaphore**具有进程范围的锁。
- en: Lock
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁
- en: 'Let''s consider the following code, which tries to write a number to a text
    file:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码，试图将一个数字写入文本文件：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output when we run the preceding code is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述代码时，输出如下：
- en: '![](img/e55e8a1f-df02-483a-80bc-a2ae13ed28d3.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e55e8a1f-df02-483a-80bc-a2ae13ed28d3.png)'
- en: As you can see, the task is composed of 1,000 work items and each work item
    takes approximately 10 milliseconds to execute. The time that's taken by the task
    is 1,000 multiplied by 10, which is 10,000 milliseconds. We also have to take
    into consideration the time taken to perform I/O, so the total time turns out
    to be 11,949.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，任务由1,000个工作项组成，每个工作项大约需要10毫秒来执行。任务所花费的时间是1,000乘以10，即10,000毫秒。我们还需要考虑执行I/O所花费的时间，因此总时间为11,949。
- en: 'Let''s try to parallelize this task using the `AsParallel()` and `AsOrdered()`
    clauses, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用`AsParallel()`和`AsOrdered()`子句并行化这个任务，如下所示：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When we try to run this code, we get the following `System.IO.IOException**:**
    'The process cannot access the file …\test.txt' because it is being used by another
    process.'`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试运行这段代码时，我们会得到以下错误信息：`System.IO.IOException**:** 'The process cannot access
    the file …\test.txt' because it is being used by another process.'`。
- en: What actually happened here is that the file is a shared resource with a critical
    section and therefore only allows atomic operations. With the parallel code, we
    have a situation where multiple threads are actually trying to write to the file
    and causing an exception. We need to make sure that the code runs in parallel
    as fast as possible but also maintains atomicity while writing to the file. We
    need to modify the preceding code using a lock statement.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 实际发生的情况是，文件是一个共享资源，具有临界区，因此只允许原子操作。在并行代码中，我们有多个线程实际上尝试写入文件并导致异常的情况。我们需要确保代码尽可能快地并行运行，但在写入文件时也保持原子性。我们需要使用锁语句修改上述代码。
- en: 'First, declare a `static` reference type variable. In our case, we take a variable
    of the `object` type. We need a reference type variable since the lock can only
    be applied on the heap memory:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明一个`static`引用类型变量。在我们的例子中，我们使用`object`类型的变量。我们需要一个引用类型变量，因为锁只能应用于堆内存：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we modify the code inside the `ForAll()` method to include a `lock`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们修改`ForAll()`方法内的代码，包括一个`lock`：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, when we run this code, we won''t get any exceptions, but the time that
    the task took was actually more than the sequential execution:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行这段代码时，不会出现任何异常，但任务所花费的时间实际上比顺序执行的时间更长：
- en: '![](img/ae6f865f-a773-43e8-80d5-9907b0703fd5.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae6f865f-a773-43e8-80d5-9907b0703fd5.png)'
- en: 'What went wrong here? Lock ensures atomicity by making sure that only one thread
    is allowed to access the vulnerable code, but this comes with the overhead of
    blocking the thread that is waiting for the lock to be freed. We call this a dumb
    lock. We can modify the program slightly to only lock the critical section to
    improve performance while maintaining atomicity, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里出了什么问题？锁通过确保只有一个线程被允许访问易受攻击的代码来确保原子性，但这会带来阻塞等待锁被释放的线程的开销。我们称之为愚蠢的锁。我们可以稍微修改程序，只锁定关键部分以提高性能，同时保持原子性，如下所示：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Following is the output of the preceding code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![](img/63589a04-4827-411e-a907-dd302daa543f.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63589a04-4827-411e-a907-dd302daa543f.png)'
- en: As you can see, we achieved significant gains by mixing synchronization along
    with parallelization. We can achieve similar results using another locking primitive,
    that is, the `Monitor` class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，通过混合同步和并行化，我们取得了显著的收益。我们可以使用另一个锁原语来实现类似的结果，即`Monitor`类。
- en: 'Lock is actually a shorthand syntax for achieving `Monitor.Enter()` and `Monitor.Exit()`
    wrapped inside a `try`-`catch` block. The same code can, therefore, be written
    as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 锁实际上是一种简写语法，用于在`try`-`catch`块中包装`Monitor.Enter()`和`Monitor.Exit()`以实现原子性。因此，可以将相同的代码编写如下：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of this code is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '![](img/5da8d712-da99-4097-804c-d9174d3951ae.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5da8d712-da99-4097-804c-d9174d3951ae.png)'
- en: Mutex
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥体
- en: The preceding code works well for a single instance application since tasks
    run inside a process and the lock actually locks a memory barrier inside the process.
    If we run multiple instances of the application, both applications will have their
    own copy of the static data members and will, therefore, lock their own memory
    barriers. This will allow one thread per process to actually enter the critical
    section and try to write the file. This causes the following `System.IO.IOException**:**
    'The process cannot access the file …\test.txt' because it is being used by another
    process.'`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码适用于单个实例应用程序，因为任务在进程内运行，锁实际上锁定了进程内的内存屏障。如果我们运行应用程序的多个实例，两个应用程序将拥有自己的静态数据成员的副本，因此将锁定自己的内存屏障。这将允许每个进程中的一个线程实际进入临界区并尝试写入文件。这将导致以下`System.IO.IOException**:**
    'The process cannot access the file …\test.txt' because it is being used by another
    process.'`。
- en: To be able to apply locks to shared resources, we can apply a lock at the kernel
    level using the `mutex` class. Like lock, mutex allows only one thread to access
    a protected resource but can work across processes as well, thereby allowing only
    one thread per system to access a protected resource, irrespective of the number
    of processes that are executing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将锁应用于共享资源，我们可以使用`mutex`类在内核级别应用锁。与锁类似，互斥体只允许一个线程访问受保护的资源，但也可以跨进程工作，因此只允许系统中的一个线程访问受保护的资源，而不管执行的进程数量如何。
- en: A mutex can be named or unnamed. An unnamed mutex works like a lock and cannot
    work across processes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥体可以是命名的或未命名的。未命名的互斥体的工作方式类似于锁，不能跨进程工作。
- en: 'First, we''ll create an unnamed `Mutex`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个未命名的`Mutex`：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we''ll modify the preceding parallel code so that we can use `Mutex`
    like a lock:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将修改前面的并行代码，以便我们可以像使用锁一样使用`Mutex`：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/063ee14e-1885-46c5-b045-59ecacdb5a61.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/063ee14e-1885-46c5-b045-59ecacdb5a61.png)'
- en: With a `Mutex` class, we can call the `WaitHandle.WaitOne()` method to lock
    the critical section and `ReleaseMutex()` to unlock the critical sections. Closing
    or disposing of a mutex automatically releases it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Mutex`类，我们可以调用`WaitHandle.WaitOne()`方法来锁定临界区，并使用`ReleaseMutex()`来解锁临界区。关闭或处理互斥体会自动释放它。
- en: 'The preceding program works well, but if we try to run it on multiple instances,
    it will throw an `IOException`. For this, we can create a `namedMutex`, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序运行良好，但如果我们尝试在多个实例上运行它，它将抛出一个`IOException`。为此，我们可以创建一个`namedMutex`，如下所示：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Optionally, we can specify a timeout while calling `WaitOne()` on the mutex
    so that it waits for a signal for a specified amount of time before unblocking
    itself. This is shown in the following example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`WaitOne()`时，我们可以选择指定一个超时，以便在等待一定时间内等待信号，然后解除阻塞。下面是一个示例：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding mutex will wait for three seconds before unblocking itself if
    it doesn't receive a signal.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未收到信号，上述互斥体将在三秒后解除阻塞。
- en: Lock and mutex can only be released from the thread that obtained them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 锁和互斥体只能从获取它们的线程中释放。
- en: Semaphore
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号量
- en: Lock, mutex, and monitor allow only one thread to access a protected resource.
    Sometimes, however, we need to allow multiple threads to be able to access a shared
    resource. Examples of these include resource pooling scenarios and throttling
    scenarios. A `semaphore`, unlike lock or mutex, is thread-agnostic, which means
    that any thread can call a release of `semaphore`. Just like a mutex, it works
    across processes as well.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 锁，互斥体和监视器只允许一个线程访问受保护的资源。然而，有时我们需要允许多个线程能够访问共享资源。这些情况包括资源池化场景和限流场景。与锁或互斥体不同，`semaphore`是线程不可知的，这意味着任何线程都可以调用`semaphore`的释放。就像互斥体一样，它也可以跨进程工作。
- en: 'A typical `semaphore` constructor is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的`semaphore`构造函数如下：
- en: '![](img/c903a4bf-5953-4af1-a3f2-7d0ae9503f5f.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c903a4bf-5953-4af1-a3f2-7d0ae9503f5f.png)'
- en: 'As you can see, it accepts two parameters: the `initialCount`, which specifies
    how many threads are initially allowed to enter, and `maximumCount`, which specifies
    the total number of threads that can enter.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它接受两个参数：`initialCount`，指定最初允许进入的线程数，以及`maximumCount`，指定可以进入的总线程数。
- en: 'Let''s say we have a remote service that only allows three concurrent connections
    per client and takes one second to process a request, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个远程服务，每个客户端只允许三个并发连接，并且需要一秒来处理一个请求，如下所示：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have a method that has 1,000 work items that need to call the service with
    parameters. We need to process a task in parallel but also make sure that there
    are no more than three calls to the service at any time. We can achieve this by
    creating a `semaphore` with a max count of `3`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个方法，其中有1,000个工作项需要使用参数调用服务。我们需要并行处理一个任务，但也要确保在任何时候最多只有三次对服务的调用。我们可以通过创建一个最大计数为`3`的`信号量`来实现这一点：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can write some code that can simulate making 1,000 requests in parallel,
    but only three at a time, using the following `semaphore`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写一些代码，可以模拟并行进行1,000次请求，但每次只能进行三次，使用以下`信号量`：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output of this is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这的输出如下：
- en: '![](img/34020bb8-f6f0-4ee6-8496-f03b46823fb5.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34020bb8-f6f0-4ee6-8496-f03b46823fb5.png)'
- en: As you can see, three threads enter and call the service while other threads
    wait for the lock to be released. As soon as a thread releases the lock, another
    thread enters but only if three threads are inside the critical section at any
    one time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，三个线程进入并调用服务，而其他线程则等待锁被释放。一旦一个线程释放锁，另一个线程进入，但只有在任何时候有三个线程在临界区内。
- en: 'There are two types of semaphores: local and global. We will discuss these
    next.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量有两种类型：本地和全局。我们将在下面讨论这些。
- en: Local semaphore
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地信号量
- en: 'A local `semaphore` is local to the application where it''s used. Any `semaphore`
    that is created without a name will be created as a local `semaphore`, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本地`信号量`是在使用的应用程序中本地的。任何没有名称创建的`信号量`都将被创建为本地`信号量`，如下所示：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Global semaphore
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局信号量
- en: 'A global `semaphore` is global to the operating system as it applies kernel-
    or system-level locking primitives. Any `semaphore` that is created with a name
    will be created as a global `semaphore`, as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 全局`信号量`是全局的，因为它应用于内核或系统级别的锁原语。任何使用名称创建的`信号量`都将被创建为全局`信号量`，如下所示：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we create a `semaphore` with only one thread, it will act like a lock.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建一个只有一个线程的`信号量`，它将起到锁的作用。
- en: ReaderWriterLock
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读写锁
- en: The `ReaderWriterLock` class defines a lock that supports multiple readers and
    a single writer at a time. This is handy in scenarios where a shared resource
    is read frequently by many threads but updated infrequently. There are two reader-writer
    lock classes that are provided by the .NET Framework: `ReaderWriterLock` and `ReaderWriterLockSlim`.
    `ReaderWriterLock` is almost outdated now since it can incur potential deadlocks,
    reduced performance, complex recursion rules, and upgrading or downgrading of
    locks. We will discuss `ReaderWriterLockSlim` in more detail later in this chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReaderWriterLock`类定义了一个支持多个读取器和一次写入器的锁。这在共享资源经常被许多线程读取但不经常更新的情况下非常方便。.NET
    Framework提供了两个读写锁类：`ReaderWriterLock`和`ReaderWriterLockSlim`。`ReaderWriterLock`现在几乎已经过时，因为它可能会导致潜在的死锁、降低性能、复杂的递归规则以及锁的升级或降级。我们将在本章后面更详细地讨论`ReaderWriterLockSlim`。'
- en: Introduction to signaling primitives
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信号量原语介绍
- en: An important aspect of parallel programming is task coordination. While creating
    tasks, you may come across a producer/consumer scenario where a thread (the consumer)
    is waiting for a shared resource to be updated by another thread (the producer).
    Since the consumer doesn't know when the producer is going to update the shared
    resource, it keeps on polling the shared resource, which can lead to race conditions.
    Polling is highly inefficient in dealing with these scenarios. It is better to
    use the signaling primitives that are provided by the .NET Framework. With signaling
    primitives, the consumer thread is paused until it receives a signal from the
    producer thread. Let's discuss some common signaling primitives, such as `Thread.Join`,
    `WaitHandles`, and `EventWaitHandlers`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程的一个重要方面是任务协调。在创建任务时，您可能会遇到生产者/消费者场景，其中一个线程（消费者）正在等待另一个线程（生产者）更新共享资源。由于消费者不知道生产者何时会更新共享资源，它不断轮询共享资源，这可能导致竞争条件。轮询在处理这些情况时效率非常低。最好使用.NET
    Framework提供的信号量原语。使用信号量原语，消费者线程暂停，直到它收到来自生产者线程的信号。让我们讨论一些常见的信号量原语，如`Thread.Join`，`WaitHandles`和`EventWaitHandlers`。
- en: Thread.Join
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程加入
- en: This is the simplest way in which we can make a thread wait for a signal from
    another thread. `Thread.Join` is blocking in nature, which means that the caller
    thread is blocked until the joined thread is complete. Optionally, we can specify
    a timeout that allows the blocked thread to come out of its blocking state once
    the timeout has been reached.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们可以使一个线程等待另一个线程的信号的最简单方法。`Thread.Join`是阻塞的，这意味着调用线程会被阻塞，直到加入的线程完成。可选地，我们可以指定一个超时，一旦超时到达，允许被阻塞的线程退出其阻塞状态。
- en: 'In the following code, we will create a child thread that simulates a long-running
    task. Once complete, it will update the output in the local variable, which is
    called `result`. The program is supposed to print the result `10` to the console.
    Let''s try to run the code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将创建一个模拟长时间运行任务的子线程。完成后，它将更新名为`result`的本地变量的输出。程序应该在控制台上打印结果`10`。让我们尝试运行代码：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![](img/f5be7850-e091-49c4-8be9-8d495b974ed5.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5be7850-e091-49c4-8be9-8d495b974ed5.png)'
- en: 'We expected the result to be `10`, but it has come out as `0`. This happened
    because the main thread that was supposed to write the value runs before the child
    thread has finished execution. We can achieve the desired behavior by blocking
    the main thread until the child thread completes. This can be done by calling
    `Join()` on the child thread, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望的结果是`10`，但实际上是`0`。这是因为主线程在子线程完成执行之前就已经运行，我们可以通过在子线程上调用`Join()`来阻塞主线程，从而实现期望的行为，如下所示：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we run the code again now, we will see the desired output after a wait of
    five seconds, during which the main thread is blocked:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在再次运行代码，我们将在等待五秒钟后看到期望的输出，主线程在此期间被阻塞：
- en: '![](img/29f82897-6ec0-4906-b64e-f59cccc732df.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29f82897-6ec0-4906-b64e-f59cccc732df.png)'
- en: EventWaitHandle
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EventWaitHandle
- en: The `System.Threading.EventWaitHandle` class represents a synchronization event
    for a thread. It serves as a base class for the `AutoResetEvent` and `ManualResetEvent`
    classes. We can signal an `EventWaitHandle` by calling `Set()` or `SignalAndWait()`.
    The `EventWaitHandle` class doesn't have any thread affinity, so it can be signaled
    by any thread. Let's learn more about `AutoResetEvent` and `ManualResetEvent`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Threading.EventWaitHandle`类表示线程的同步事件。它作为`AutoResetEvent`和`ManualResetEvent`类的基类。我们可以通过调用`Set()`或`SignalAndWait()`来发出`EventWaitHandle`的信号。`EventWaitHandle`类没有任何线程关联性，因此可以被任何线程发出信号。让我们更多地了解`AutoResetEvent`和`ManualResetEvent`。'
- en: AutoResetEvent
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AutoResetEvent
- en: This refers to `WaitHandle` classes that are automatically reset. Once they
    are reset, they allow one thread to pass through the barrier that is created.
    As soon as the thread is passed, they are set again, thereby blocking threads
    until the next signal.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指自动重置的`WaitHandle`类。一旦它们被重置，它们允许一个线程通过创建的屏障。一旦线程通过，它们会再次被设置，从而阻塞线程直到下一个信号。
- en: In the following example, we are trying to find out the sum of 10 numbers in
    a thread-safe manner, without using locks.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们试图以线程安全的方式找出10个数字的总和，而不使用锁。
- en: 'First, create an `AutoResetEvent` with the initial state as non-signaled, or
    `false`. This means that all the threads should wait until a signal is received.
    If we set the initial state to signaled, or `true`, the first thread will go through
    while the others wait for a signal:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个初始状态为非信号或`false`的`AutoResetEvent`。这意味着所有线程都应该等待直到收到信号。如果将初始状态设置为信号或`true`，第一个线程将通过，而其他线程将等待信号：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, create a signaling task that fires a signal 10 times per second using
    the `autoResetEvent.Set()` method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个发出信号的任务，使用`autoResetEvent.Set()`方法每秒发出10次信号：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Declare a variable sum and initialize it to `0`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个变量sum并将其初始化为`0`：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a parallel `for` loop that creates 10 tasks. Each task will start immediately
    and wait for a signal to enter, thereby blocking at the `autoResetEvent.WaitOne()`
    statement. After every second, a signal will be sent by the signaling task and
    one thread will enter and update the `sum`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个并行的`for`循环，创建10个任务。每个任务将立即开始并等待一个信号进入，因此在`autoResetEvent.WaitOne()`语句处阻塞。每秒钟，一个信号将被发送，一个线程将进入并更新`sum`：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/3369c0d3-6e1a-4209-a1d0-a27351c60e85.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3369c0d3-6e1a-4209-a1d0-a27351c60e85.png)'
- en: As you can see, all 10 tasks blocked initially and released one per second after
    receiving the signal.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有10个任务最初都被阻塞，每秒接收到信号后释放一个。
- en: ManualResetEvent
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ManualResetEvent
- en: This refers to wait handles that need to be reset manually. Unlike `AutoResetEvent`,
    which only allows one thread to pass per signal, `ManualResetEvent` allows threads
    to keep passing through until it is set again. Let's try to understand this using
    a simple example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是指需要手动重置的等待句柄。与`AutoResetEvent`不同，它只允许一个线程通过每个信号，`ManualResetEvent`允许线程继续通过，直到再次设置。让我们尝试使用一个简单的例子来理解这一点。
- en: 'In the following example, we need to make 15 service calls in batches of 5
    in parallel, with a 2-second delay between each batch. While making the service
    call, we need to make sure that the system is connected to the network. To simulate
    the network status, we will create two tasks: one that signals the network off
    and one that signals the network on.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们需要并行地以每批5个的方式进行15次服务调用，每批之间延迟2秒。在进行服务调用时，我们需要确保系统连接到网络。为了模拟网络状态，我们将创建两个任务：一个信号网络关闭，一个信号网络开启。
- en: 'First, we''ll create a manual reset event with the initial state *off*:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个初始状态为*关闭*的手动重置事件：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we''ll create two tasks that simulate the network turning on and off
    by firing the network *off* event every two seconds (which blocks all the network
    calls) and the network *on* event every five seconds (which allows all the network
    calls to go through):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建两个任务，通过每两秒触发一次网络*关闭*事件（阻塞所有网络调用）和每五秒触发一次网络*开启*事件（允许所有网络调用通过）来模拟网络的开启和关闭：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As you can see from the preceding code, we have signaled a manual reset event
    every five seconds using `manualResetEvent.Set()`. We turn it off every two seconds
    using `manualResetEvent.Reset()`. The following code makes the actual service
    calls:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码中看到的，我们每五秒发出一次手动重置事件的信号，使用`manualResetEvent.Set()`。我们每两秒关闭一次它，使用`manualResetEvent.Reset()`。以下代码进行实际的服务调用：
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see from the preceding code, we have created a `for` loop that creates
    five tasks in each iteration with a sleep interval of two seconds between iterations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的代码中看到的，我们创建了一个`for`循环，每次迭代创建五个任务，两次迭代之间的休眠间隔为两秒。
- en: Before making service calls, we wait for the network to be up by calling `manualResetEvent.WaitOne();`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行服务调用之前，我们通过调用`manualResetEvent.WaitOne();`等待网络启动。
- en: 'If we run the preceding code, we''ll receive the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，将收到以下输出：
- en: '![](img/3bab3114-6be3-4e91-8980-4779dac5779e.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3bab3114-6be3-4e91-8980-4779dac5779e.png)'
- en: As you can see, five tasks are started and blocked immediately to wait for the
    network to be up. After five seconds, when the network is up, we signal using
    the `Set()` method and all five threads pass through to make the service call.
    This is repeated with each iteration of the `for` loop.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，五个任务立即启动并立即阻塞等待网络启动。五秒后，当网络启动时，我们使用`Set()`方法发出信号，所有五个线程通过进行服务调用。这将在`for`循环的每次迭代中重复。
- en: WaitHandles
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WaitHandles
- en: '`System.Threading.WaitHandle` is a class that inherits from the `MarshalByRefObject`
    class and is used to synchronize threads that are running in an application. Blocking
    and signaling are used to synchronize threads using wait handles. Threads can
    be blocked by calling any of the methods of the `WaitHandle` class. They are released,
    depending on the type of signaling construct that is selected. The methods of
    the `WaitHandle` class are as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Threading.WaitHandle`是从`MarshalByRefObject`类继承的类，用于同步运行在应用程序中的线程。使用等待句柄来阻塞和发出信号以同步线程。线程可以通过调用`WaitHandle`类的任何方法来阻塞。它们根据所选的信号构造的类型而被释放。`WaitHandle`类的方法如下：'
- en: '`WaitOne`: Blocks the calling thread until it receives a signal from the wait
    handles that it''s waiting for.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitOne`：阻塞调用线程，直到它从等待的等待句柄接收到信号。'
- en: '`WaitAll`: Blocks the calling thread until it receives a signal from all of
    the wait handles it''s waiting for.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitAll`：阻塞调用线程，直到它从等待的所有等待句柄接收到信号。'
- en: 'The following is an example that shows us how `WaitAll` works:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，向我们展示了`WaitAll`的工作原理：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here is an example that makes use of two threads to simulate two different
    service calls. Both threads will execute in parallel but will wait at `WaitHandle.WaitAll(waitHandles)`
    before printing the sum to the console:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，利用两个线程模拟两个不同的服务调用。两个线程将并行执行，但在打印总和到控制台之前将在`WaitHandle.WaitAll(waitHandles)`处等待：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/e8381fd4-8d56-4b68-aeca-cd815f15d19e.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e8381fd4-8d56-4b68-aeca-cd815f15d19e.png)'
- en: '`WaitAny`: Blocks the calling thread until it receives a signal from any of
    the wait handles it''s waiting for.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaitAny`：阻塞调用线程，直到它从等待的任何等待句柄接收到信号。'
- en: 'The following is the signature of the `WaitAny` method:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`WaitAny`方法的签名：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here is an example that makes use of two threads to perform an item search.
    Both threads will execute in parallel and the program waits for any of the threads
    to finish execution at the `WaitHandle.WaitAny(waitHandles)` method before printing
    the item index to the console.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，利用两个线程执行项目搜索。两个线程将并行执行，并且程序在`WaitHandle.WaitAny(waitHandles)`方法中等待任何一个线程完成执行，然后将项目索引打印到控制台。
- en: 'We have two methods, binary search and linear search, that perform a search
    using binary and linear algorithms. We want to get a result as soon as possible
    from either of these methods. We can achieve this via signaling using `AutoResetEvent` 
    and store the results in the `findIndex` and `winnerAlgo` global variables:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法，二分搜索和线性搜索，使用二进制和线性算法执行搜索。我们希望尽快从这两种方法中获得结果。我们可以通过使用`AutoResetEvent`进行信号传递，并将结果存储在`findIndex`和`winnerAlgo`全局变量中：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following code calls both algorithms in parallel using `ThreadPool`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用`ThreadPool`并行调用两种算法：
- en: '[PRE39]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`SignalAndWait`: This method is used to call `Set()` on a wait handle and calls `WaitOne`
    for another wait handle. In a multithreaded environment, this method can be utilized
    to release one thread at a time and then resets to wait for the next thread:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SignalAndWait：此方法用于在等待句柄上调用`Set()`并为另一个等待句柄调用`WaitOne`。在多线程环境中，此方法可用于释放一个线程，然后重置以等待下一个线程：
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Lightweight synchronization primitives
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轻量级同步原语
- en: The .NET Framework also provides lightweight synchronization primitives, which
    are better in performance than their counterparts. They avoid dependency on kernel
    objects such as wait handles wherever possible, so they only work inside the process.
    These primitives should be used when the thread's wait time is short. We can divide
    them into two categories, both of which we'll look at in this section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework还提供了轻量级的同步原语，其性能优于其对应物。它们尽可能避免依赖内核对象，如等待句柄，因此只在进程内工作。当线程的等待时间较短时，应使用这些原语。我们可以将它们分为两类，在本节中我们将介绍这两类。
- en: Slim locks
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Slim锁
- en: Slim locks are slim implementations of legacy synchronization primitives that
    can improve performance by reducing overheads.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Slim锁是传统同步原语的精简实现，可以通过减少开销来提高性能。
- en: 'The following table shows the legacy synchronization primitives and their slim
    counterparts:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了传统同步原语及其精简对应物：
- en: '![](img/254c3dd1-bfc8-4e51-b3fd-0d025205ff9a.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/254c3dd1-bfc8-4e51-b3fd-0d025205ff9a.png)'
- en: Let's try to learn more about slim locks.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试更多地了解Slim锁。
- en: ReaderWriterLockSlim
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReaderWriterLockSlim
- en: '`ReaderWriterLockSlim` is a lightweight implementation of `ReaderWriterLock`.
    It represents a lock that can be used to manage protected resources in a way that
    allows multiple threads to share read access while allowing only one thread write
    access.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReaderWriterLockSlim`是`ReaderWriterLock`的轻量级实现。它表示一个锁，可用于以允许多个线程共享读取访问的方式管理受保护的资源，同时只允许一个线程写入访问。'
- en: 'The following example uses `ReaderWriterLockSlim` to protect access on a list
    that is shared by three reader threads and one writer thread:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用`ReaderWriterLockSlim`来保护由三个读取线程和一个写入线程共享的列表上的访问：
- en: '[PRE41]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output of this code is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '![](img/c8c8ea67-cbde-4075-92ef-5fba32c0e226.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8c8ea67-cbde-4075-92ef-5fba32c0e226.png)'
- en: SemaphoreSlim
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SemaphoreSlim
- en: '`SemaphoreSlim` is a lightweight implementation of `semaphore`. It throttles
    access to a protected resource to a number of threads.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`SemaphoreSlim`是`semaphore`的轻量级实现。它限制对受保护资源的访问，以供多个线程使用。'
- en: 'Here is a slim version of the `semaphore` program that we showed earlier in
    this chapter:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章前面展示的`semaphore`程序的精简版本：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The difference we can see here, apart from replacing the `Semaphore` class with `SemaphoreSlim`,
    is that we now have the `Wait()` method instead of `WaitOne()`. This makes much
    more sense as we are allowing more than one thread to pass through.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这里的区别，除了用`SemaphoreSlim`替换`Semaphore`类之外，我们现在有了`Wait()`方法，而不是`WaitOne()`。这样做更有意义，因为我们允许多个线程通过。
- en: Another important difference is that `SemaphoreSlim` is always created as a
    local `semaphore`, unlike `semaphore`, which can be created globally as well.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的区别是`SemaphoreSlim`总是作为本地`semaphore`创建，而`semaphore`可以全局创建。
- en: ManualResetEventSlim
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动重置事件Slim
- en: '`ManualResetEventSlim` is a lightweight implementation of `ManualResetEvent`.
    It has better performance and less overhead than `ManualResetEvent`.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManualResetEventSlim`是`ManualResetEvent`的轻量级实现。它比`ManualResetEvent`具有更好的性能和更少的开销。'
- en: 'We can create an object using the following syntax, just like `ManualResetEvent`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下语法创建对象，就像`ManualResetEvent`一样：
- en: '[PRE43]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Just like other slim counterparts, one major difference here is that we have
    replaced the `WaitOne()` method with `Wait()`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他slim对应物一样，这里的一个主要区别是我们用`Wait()`替换了`WaitOne()`方法。
- en: You can try running some `ManualResetEvent` demonstration code by making the
    preceding changes and see if it works.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试运行一些`ManualResetEvent`演示代码，通过进行上述更改并查看是否有效。
- en: Barrier and countdown events
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏障和倒计时事件
- en: 'The .NET Framework has some built-in signaling primitives that help us synchronize
    multiple threads without us having to write lots of synchronization logic. All
    the synchronization is handled internally by the provided data structures. In
    this section, let''s discuss two very important signaling primitives: `CountDownEvent`
    and `Barrier`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework具有一些内置的信号原语，可以帮助我们同步多个线程，而无需编写大量的同步逻辑。所有同步都由提供的数据结构在内部处理。在本节中，让我们讨论两个非常重要的信号原语：`CountDownEvent`和`Barrier`：
- en: '**CountDownEvent**: The `System.Threading.CountDownEvent` class refers to an
    event that''s signaled when its count becomes 0.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CountDownEvent**：`System.Threading.CountDownEvent`类指的是当其计数变为0时被触发的事件。'
- en: '**Barrier**: The `Barrier` class allows multiple threads to run without having
    the master thread controlling them. It creates a barrier that participating threads
    must wait in until all the threads have arrived. `Barrier` works well for cases
    where work needs to be carried out in parallel and in phases.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏障**：`Barrier`类允许多个线程在没有主线程控制它们的情况下运行。它创建了一个障碍，参与的线程必须在其中等待，直到所有线程都到达。`Barrier`非常适用于需要并行和分阶段进行工作的情况。'
- en: A case study using Barrier and CountDownEvent
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Barrier和CountDownEvent的案例研究
- en: As an example, let's say we need to fetch data from two services that are dynamically
    hosted. Before fetching the data from service one, we need to host it. Once the
    data has been fetched, it needs to be closed down. Only when service one has been
    closed down can we start service two and fetch data from it. The data needs to
    be fetched as quickly as possible. Let's create some code to meet the requirements
    of this scenario.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们需要从动态托管的两个服务中获取数据。在从服务一获取数据之前，我们需要托管它。一旦数据被获取，就需要关闭它。只有在服务一关闭后，我们才能启动服务二并从中获取数据。需要尽快获取数据。让我们创建一些代码来满足这种情况的要求。
- en: 'Create a `Barrier` with `5` participants:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个有`5`个参与者的`Barrier`：
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create two `CountdownEvents` that will trigger the start or close of services
    when six threads have passed through it. Five worker tasks will participate, along
    with a task that will manage the start or close of services:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个`CountdownEvents`，当六个线程通过它时将触发服务的启动或关闭。五个工作任务将参与其中，还有一个任务将管理服务的启动或关闭：
- en: '[PRE45]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, create another `CountdownEvent` with a count of `5`. This refers to
    the number of threads that can pass through before the event is signaled. `CountdownEvent`
    will trigger when all the worker tasks finish executing:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建另一个计数为`5`的`CountdownEvent`。这指的是在事件被触发之前可以通过的线程数。当所有工作任务执行完成时，`CountdownEvent`将被触发：
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here is our `serviceManagerTask` implementation:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`serviceManagerTask`实现：
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here is the method that is executed by the worker tasks:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是工作任务执行的方法：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/67c1de2f-4302-412d-817c-3fad0b113ae1.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/67c1de2f-4302-412d-817c-3fad0b113ae1.png)'
- en: In this section, we have looked at various built-in signaling primitives that
    help make code synchronization easier without the need to lock ourselves as a
    developer. Blocking still comes at a performance cost as it involves context switching.
    In the next section, we will look at some spinning techniques that can help remove
    that context switching overhead.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经看了一些内置的信号原语，这些原语可以帮助我们更轻松地进行代码同步，而无需作为开发人员锁定自己。阻塞仍然会带来性能成本，因为它涉及上下文切换。在下一节中，我们将看一些旋转技术，可以帮助消除上下文切换的开销。
- en: SpinWait
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpinWait
- en: At the beginning of this chapter, we mentioned that spinning is much more efficient
    than blocking for smaller waits. Spinning has fewer kernel overheads related to
    context switching and transitioning.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们提到对于较小的等待时间，旋转比阻塞更有效。旋转具有较少的与上下文切换和转换相关的内核开销。
- en: 'We can create a `SpinWait` object as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式创建`SpinWait`对象：
- en: '[PRE49]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, wherever we need to make a `spin`, we can just call the following command:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，无论我们需要进行`spin`，我们都可以调用以下命令：
- en: '[PRE50]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: SpinLock
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpinLock
- en: Locks and interlocking primitives can significantly slow down performance if
    the wait time to get a lock is very low. `SpinLock` provides a lightweight, low-level
    alternative to locking. `SpinLock` is a value type, so if we want to use the same
    object in multiple places, we need to pass it by a reference. For performance
    reasons, even when `SpinLock` hasn't even acquired the lock, it yields the time
    slice of the thread so that the garbage collector can work efficiently. By default,
    `SpinLock` doesn't support thread tracking, which refers to determining which
    thread has acquired the lock. However, this feature can be turned on. This is
    only recommended for debugging and not for production as it reduces performance.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获取锁的等待时间非常短，锁和互锁原语可能会显著降低性能。`SpinLock`提供了一种轻量级、低级别的替代锁定方法。`SpinLock`是一个值类型，因此如果我们想在多个地方使用相同的对象，我们需要通过引用传递它。出于性能原因，即使`SpinLock`甚至还没有获取锁，它也会让出线程的时间片，以便垃圾收集器可以有效工作。默认情况下，`SpinLock`不支持线程跟踪，这意味着确定哪个线程已经获取了锁。但是，这个特性可以被打开。这只建议用于调试，而不是用于生产，因为它会降低性能。
- en: 'Create a `SpinLock` object as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`SpinLock`对象如下：
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create a method that will be called by various threads and update a global
    static list:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个将被各个线程调用并更新全局静态列表的方法：
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, the lock is acquired using `_spinLock.Enter(ref lockTaken)`
    and released via `_spinLock.Exit(false)`**.** Everything between these two statements
    will be executed as synchronized between all the threads.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，锁是使用`_spinLock.Enter(ref lockTaken)`获取的，并且通过`_spinLock.Exit(false)`释放。在这两个语句之间的所有内容将在所有线程之间同步执行。
- en: 'Let''s call this method in a parallel loop:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个并行循环中调用这个方法：
- en: '[PRE53]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here is the synchronized output if we had used locking primitives:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用锁定原语，这里是同步的输出：
- en: '![](img/66d8c9c2-ca57-40d0-bd38-97c542db9ed7.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](img/66d8c9c2-ca57-40d0-bd38-97c542db9ed7.png)'
- en: As a rule of thumb, if we have small tasks, context switching can be completely
    avoided by using spinning.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，如果我们有小任务，可以通过自旋完全避免上下文切换。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the synchronization primitives that are
    provided by .NET Core. Synchronized primitives are a must if you want to write
    parallel code and ensure that it is correct, even when multiple threads are working
    on it. Synchronization primitives come with performance overheads and the use
    of their slim counterparts is advised wherever possible.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了.NET Core提供的同步原语。如果要编写并行代码并确保其正确性，同步原语是必不可少的，即使多个线程在处理它。同步原语会带来性能开销，建议尽可能使用它们的精简版本。
- en: We learned about signaling primitives as well, which can come in very handy
    when threads need to work on some external events. We also discussed the barrier
    and countdown events, which help us avoid code synchronization issues without
    the need to write additional logic. Finally, we introduced some spinning techniques,
    which take away performance overheads that arise from blocking code, that is, `SpinLock`
    and `SpinWait`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了信号原语，当线程需要处理一些外部事件时，这些原语非常有用。我们还讨论了屏障和倒计时事件，它们帮助我们避免代码同步问题，而无需编写额外的逻辑。最后，我们介绍了一些自旋技术，它们消除了由阻塞代码引起的性能开销，即`SpinLock`和`SpinWait`。
- en: In the next chapter, we will learn about the various data structures provided
    by .NET Core. These are synchronized automatically and are parallel at the same
    time.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解.NET Core提供的各种数据结构。这些数据结构是自动同步的，同时也是并行的。
- en: Questions
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of these can be used for cross-process synchronization?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些中哪个可以用于跨进程同步？
- en: '`Lock`'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁
- en: '`Interlocked.Increment`'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Interlocked.Increment`'
- en: '`Interlocked.MemoryBarrierProcessWide`'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Interlocked.MemoryBarrierProcessWide`'
- en: Which of these is not a valid memory barrier?
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个不是有效的内存屏障？
- en: Read memory barrier
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取内存屏障
- en: Half memory barrier
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 半内存屏障
- en: Full memory barrier
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整内存屏障
- en: Read and execute memory barrier
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取和执行内存屏障
- en: From which of the following states can we not resume a thread?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能从以下哪种状态恢复线程？
- en: '`WaitSleepJoin`'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待、休眠、加入
- en: '`Suspended`'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂停
- en: '`Aborted`'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`中止`'
- en: An unnamed `semaphore` can provide synchronization where?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个无名的`信号量`可以提供同步的地方？
- en: Within process
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程内部
- en: Across process
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跨进程
- en: Which of these constructs support tracking threads?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些结构中哪个支持跟踪线程？
- en: '`SpinWait`'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpinWait`'
- en: '`SpinLock`'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SpinLock`'
