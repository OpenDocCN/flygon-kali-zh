- en: Chapter 12. Connecting Our Kotlin to the UI and Nullability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。将我们的Kotlin连接到UI和可空性
- en: By the end of this chapter, the missing link between our Kotlin code and our
    XML layouts will be fully revealed, leaving us with the power to add all kinds
    of widgets and UI features to our layouts as we have done before, but this time
    we will be able to control them through our code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的结束，我们的Kotlin代码和XML布局之间的缺失链接将被完全揭示，让我们有能力像以前一样向布局添加各种小部件和UI功能，但这一次我们将能够通过我们的代码来控制它们。
- en: In this chapter, we will take control of some simple UI elements, such as `Button`
    and `TextView`, and, in the next chapter, we will take things further and manipulate
    a whole range of UI elements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将控制一些简单的UI元素，比如`Button`和`TextView`，在下一章中，我们将进一步操作一系列UI元素。
- en: To enable us to understand what is happening, we need to find out a bit more
    about the memory in an app, and two areas of it in particular – the **Stack**
    and the **Heap**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们理解发生了什么，我们需要更多地了解应用程序中的内存，特别是其中的两个区域-**堆栈**和**堆**。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Android UI elements are classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android UI元素也是类
- en: Garbage collection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Our UI is on the Heap
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的UI在堆上
- en: More polymorphism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的多态性
- en: Nullability – val and var revisited
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可空性- val和var重新审视
- en: Casting to different types
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换为不同类型
- en: Prepare to make your UI come to life.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 准备让您的UI活起来。
- en: All the Android UI elements are classes too
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有的Android UI元素也是类
- en: When our app is run and the `setContentView` function is called from the `onCreate`
    function, the layout is **inflated** from the XML UI, and is loaded into memory
    as usable objects. They are stored in a part of the memory called the Heap.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序运行并且从`onCreate`函数中调用`setContentView`函数时，布局会从XML UI中**膨胀**，并作为可用对象加载到内存中。它们存储在内存的一个部分，称为堆。
- en: But where is this Heap place? We certainly can't see the UI instances in our
    code. And how on earth do we get our hands on them?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个堆在哪里？我们在代码中肯定看不到UI实例。我们怎么才能得到它们呢？
- en: The operating system inside every Android device takes care of memory allocation
    to our apps. In addition, it stores different types of variables in different
    places.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Android设备内部的操作系统都会为我们的应用程序分配内存。此外，它还将不同类型的变量存储在不同的位置。
- en: Variables that we declare and initialize in functions are stored in an area
    of memory known as the Stack. We already know how we can manipulate variables
    on the Stack with straightforward expressions. So, let's talk about the Heap some
    more.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数中声明和初始化的变量存储在称为堆栈的内存区域。我们已经知道如何使用简单的表达式在堆栈上操作变量。所以，让我们再谈谈堆。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Important fact: all objects of classes are reference type variables and are
    just references to the actual objects that are stored on the Heap – they are not
    the actual objects.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要事实：所有类的对象都是引用类型变量，只是指向存储在堆上的实际对象的引用-它们并不是实际的对象。
- en: Think of the Heap as a separate area of the same warehouse as where our regular
    variables are stored. The Heap has lots of floor space for odd-shaped objects,
    racks for smaller objects, lots of long rows with smaller sized cubby holes, and
    so on. This is where objects are stored. The problem is that we have no direct
    access to the Heap. Think of it as a restricted access part of the warehouse.
    You can't actually go there, but you can *refer* to what is stored there. Let's
    look at what a reference variable really is.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 把堆想象成仓库的另一个区域。堆有大量的地板空间用于奇形怪状的物体，用于较小物体的货架，以及许多长排的小尺寸隔间等。这就是对象存储的地方。问题是我们无法直接访问堆。把它想象成仓库的受限区域。你实际上不能去那里，但你可以*引用*那里存储的东西。让我们看看引用变量到底是什么。
- en: It is a variable that we refer to and use via a reference. A reference can be
    loosely, but usefully, defined as an address or location. The reference (address
    or location) of the object is on the Stack.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个我们通过引用引用和使用的变量。引用可以宽松地但有用地定义为地址或位置。对象的引用（地址或位置）在堆栈上。
- en: So, when we use the dot operator, we are asking the OS to perform a task at
    a specific location, a location that is stored in the reference.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们使用点运算符时，我们正在要求操作系统在特定位置执行任务，这个位置存储在引用中。
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Reference variables are just that – a reference. They are a way to access and
    manipulate the object (properties and functions), but they are not the actual
    object itself.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 引用变量就是这样-一个引用。它们是访问和操作对象（属性和函数）的一种方式，但它们并不是实际的对象本身。
- en: Why would we ever want a system like this? Just give me my objects on the Stack,
    already! Here is why.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们会想要这样的系统？给我我的对象就放在堆栈上！这就是为什么。
- en: A quick break to throw out the trash
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速休息一下，扔掉垃圾
- en: This is what the whole Stack and Heap thing does for us.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 整个堆栈和堆的作用是什么。
- en: As we know, the operating system keeps track of all our objects for us and stores
    them in a devoted area of our warehouse called the Heap. While our app is running,
    the operating system will regularly scan the Stack, the regular racks of our warehouse,
    and match up references to objects that are on the Heap. Any objects it finds
    without a matching reference, it destroys. Or, in correct terminology, it **garbage
    collects**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，操作系统会为我们跟踪所有的对象，并将它们存储在我们仓库的一个专门区域，称为堆。在我们的应用程序运行时，操作系统会定期扫描堆栈，我们仓库的常规货架，并匹配堆上的对象的引用。它发现的任何没有匹配引用的对象，都会被销毁。或者，用正确的术语来说，它进行**垃圾回收**。
- en: Think of a very discerning refuse vehicle driving through the middle of our
    Heap, scanning objects to match up to references (on the Stack). No reference
    means it is garbage collected.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一辆非常有洞察力的垃圾车穿过我们的堆，扫描物体以匹配参考（在堆栈上）。没有参考意味着它被垃圾回收了。
- en: If an object has no related reference variable, we can't possibly do anything
    with it anyway because we have no way to access it/refer to it. This system of
    garbage collection helps our apps run more efficiently by freeing up unused memory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象没有相关的引用变量，我们无法对其进行任何操作，因为我们无法访问它/引用它。垃圾收集系统通过释放未使用的内存帮助我们的应用程序更有效地运行。
- en: If this task was left to us, our apps would be much more complicated to code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个任务留给我们来完成，我们的应用程序将会更加复杂。
- en: So, variables declared inside a function are local, on the Stack, and are only
    visible within the function where they were declared. A property (of an object)
    is on the Heap, and can be referenced from anywhere where there is a reference
    to it, and if the access modifier (encapsulation) allows.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数内声明的变量是局部的，位于堆栈上，只能在声明它们的函数内部可见。一个属性（对象的属性）位于堆上，可以在任何有引用的地方引用它，如果访问修饰符（封装）允许的话。
- en: Seven useful facts about the Stack and the Heap
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于堆栈和堆的七个有用的事实
- en: 'Let''s take a quick look at what we have learned about the Stack and the Heap:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看看我们对堆栈和堆学到了什么：
- en: You don't delete objects, but the operating system sends the garbage collector
    when it thinks it is appropriate. This is usually when there is no active reference
    to an object.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会删除对象，而是操作系统在认为合适的时候发送垃圾收集器。通常情况下，当对象没有活动引用时，垃圾收集器会进行清理。
- en: Variables are on the Stack, and are local to the specific function within which
    they were declared.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量位于堆栈上，只能在声明它们的特定函数内部可见。
- en: Properties are on the Heap (with their object/instance), but the reference to
    the object/instance (its address) is a local variable on the Stack.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性位于堆上（与其对象/实例一起），但是对象/实例的引用（其地址）是堆栈上的局部变量。
- en: We control what goes onto the Stack. We can use the objects on the Heap, but
    only by referencing them.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们控制着堆栈中的内容。我们可以使用堆上的对象，但只能通过引用它们。
- en: The Heap is kept clear and up-to-date by the garbage collector.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆由垃圾收集器保持清晰和最新。
- en: An object is garbage collected when there is no longer a valid reference to
    it. So, when a reference variable is removed from the Stack, then its related
    object becomes viable for garbage collection. And, when the operating system decides
    the time is right (usually very promptly), it will free up the RAM memory to avoid
    running out.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不再有有效引用指向对象时，对象将被垃圾收集。因此，当引用变量从堆栈中移除时，与之相关的对象就可以进行垃圾收集。当操作系统决定时机合适（通常非常迅速），它将释放RAM内存以避免耗尽。
- en: If we managed to reference an object that didn't exist, we will get a **NullPointerException**
    error, and the app will crash. One of the major features of Kotlin is that it
    protects us from this occurring. In Java, which Kotlin is trying to improve upon,
    a **NullPointerException error** is the most common cause of an app crashing.
    We will learn more about how Kotlin helps us avoid **NullPointerException** errors
    in the section near the end of this chapter called *Nullability –* `val` *and*
    `var` *revisited*.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们设法引用一个不存在的对象，我们将会得到一个**NullPointerException**错误，应用程序将崩溃。Kotlin的一个主要特性是它保护我们免受这种情况的发生。在Kotlin试图改进的Java中，**NullPointerException错误**是应用程序崩溃的最常见原因。我们将在本章末尾附近的*Nullability
    –* `val` *and* `var` *revisited*部分学习更多关于Kotlin如何帮助我们避免**NullPointerException**错误的内容。
- en: Let's move on and see exactly what this information buys us in terms of taking
    control of our UI.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看看这些信息对我们控制UI方面有什么帮助。
- en: So, how does this Heap thing help me?
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么，这个堆究竟如何帮助我？
- en: Any UI element that has its `id` attribute set in the XML layout can have its
    reference retrieved from the Heap and used, just as we can with the classes we
    wrote and declared ourselves over the previous two chapters.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML布局中设置了`id`属性的任何UI元素都可以从堆中检索其引用并使用，就像我们在前两章中编写和声明自己的类一样。
- en: 'If we create a project with a Basic Activity template (feel free to do so,
    but you don''t need to), drag a button on to the UI, infer the constraints, and
    run the app on an emulator. We will then get what we see in this next screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用基本活动模板创建一个项目（随意这样做，但你不需要这样做），将一个按钮拖到UI上，推断出约束，并在模拟器上运行应用程序。然后我们将得到下一个截图中所见的内容：
- en: '![So, how does this Heap thing help me?](img/B12806_12_01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![那么，这个堆究竟如何帮助我？](img/B12806_12_01.jpg)'
- en: 'This is what we should expect from what we have already seen in the first five
    chapters. If we added this line of code to the `onCreate` function, then something
    interesting will happen:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们应该从前五章中已经看到的内容可以期待的。如果我们将这行代码添加到`onCreate`函数中，那么将会发生一些有趣的事情：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the app again and observe the change in the button:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序并观察按钮的变化：
- en: '![So, how does this Heap thing help me?](img/B12806_12_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![那么，这个堆究竟如何帮助我？](img/B12806_12_02.jpg)'
- en: We have changed the text on the button.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经改变了按钮上的文本。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: At this point, if you have previously programmed Android using Java, you might
    want to lie down for a few minutes and contemplate how easy life will be from
    now on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果您之前使用Java编写Android应用程序，您可能想躺下几分钟，思考从现在开始生活将会变得多么容易。
- en: This is quite exciting, because it shows we can grab a reference to a whole
    bunch of stuff from our layout. We can then start using all the functions and
    properties that these objects have that are provided by the Android API.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常令人兴奋，因为它显示我们可以从我们的布局中获取一大堆东西的引用。然后我们可以开始使用这些对象由Android API提供的所有函数和属性。
- en: The `button` instance in the code refers to the `id` of the `Button` widget
    in the XML layout. The `text` instance in our code then refers to the `text` property
    of the `Button` class, and the `= "WOO HOO!"` text in our code uses the setter
    of the `text` property to change the value it holds.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的`button`实例是指XML布局中`Button`小部件的`id`。我们代码中的`text`实例然后指的是`Button`类的`text`属性，我们代码中的`=
    "WOO HOO!"`文本使用了`text`属性的setter来改变它所持有的值。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If the `Button` class (or an other UI element) had a different `id` value, then
    we would need to adjust our code accordingly.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Button`类（或其他UI元素）的`id`值不同，那么我们需要相应地调整我们的代码。
- en: If you think that after eleven chapters we are finally going to start doing
    some neat stuff with Android, you would be right!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为在十一章之后，我们终于要开始在Android上做一些好玩的事情，那么你是对的！
- en: Let's learn about another aspect of OOP, and then we will be able to build our
    most functional app so far.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解OOP的另一个方面，然后我们将能够构建迄今为止最功能强大的应用程序。
- en: Kotlin interfaces
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin接口
- en: An interface is like a class. Phew! Nothing complicated here then. But, it's
    like a class that is always abstract, and only has abstract functions.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接口就像一个类。哦！这里没有什么复杂的。但是，它就像一个始终是抽象的类，只有抽象函数。
- en: We can think of an interface as an entirely abstract class, with all its functions
    and properties being abstract. When a property is abstract, it does not hold a
    value. It has no backing field for the property. However, when another class implements
    (uses) the interface, it must override the property, and therefore provide the
    backing field for storing a value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将接口看作是一个完全抽象的类，其所有函数和属性都是抽象的。当属性是抽象的时，它不持有值。它没有属性的后备字段。然而，当另一个类实现（使用）接口时，它必须重写属性，因此提供用于存储值的后备字段。
- en: Simply put, interfaces are stateless classes. They provide an implementation
    template without any data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，接口是无状态的类。它们提供了一个没有任何数据的实现模板。
- en: OK, so you can just about wrap your head round an abstract class, because at
    least it can pass on some functionality in its functions and some state in its
    properties that are not abstract and serve as a polymorphic type.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你大概能理解抽象类，因为至少它可以在其函数中传递一些功能，并在其属性中传递一些状态，这些状态不是抽象的，并且作为多态类型。
- en: But, seriously, this interface seems a bit pointless. Let's look at the simplest
    possible example of an interface, then we can discuss it further.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，说真的，这个界面似乎有点毫无意义。让我们看一个最简单的接口示例，然后我们可以进一步讨论。
- en: 'To define an interface, we type the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 定义接口，我们输入以下内容：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The functions of an interface have no body, because they are abstract, but they
    can still have return types and parameters.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的函数没有主体，因为它们是抽象的，但它们仍然可以有返回类型和参数。
- en: 'To use an interface, we use the same `:` syntax after the class declaration:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用接口，我们在类声明后使用相同的`:`语法：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, the property and the function has been overridden in
    the class that implements the interface. The compiler forces the user of an interface
    to do this, or else the code will not compile.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，属性和函数已在实现接口的类中被重写。编译器强制接口的用户这样做，否则代码将无法编译。
- en: If you are inheriting from a class at the same time as implementing one or more
    interfaces, then the super class simply goes into the list with the interface(s).
    It is convention, to make the different relationships clear, to put the super
    class first in the list. This is, however, not required by the compiler.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您同时从一个类继承并实现一个或多个接口，那么超类就会简单地放入接口的列表中。为了清楚地表明不同的关系，惯例是将超类放在列表的第一位。然而，编译器并不要求这样做。
- en: This enables us to use polymorphism with multiple different objects that are
    from completely unrelated inheritance hierarchies. If a class implements an interface,
    the whole thing can be passed along or used as if it is that thing, because it
    is that thing. It is polymorphic (many things).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够在完全不相关的继承层次结构中使用多个不同对象的多态性。如果一个类实现了一个接口，整个东西就可以被传递或用作它就像是那个东西一样，因为它就是那个东西。它是多态的（多种形式）。
- en: We can even have a class implement multiple different interfaces at the same
    time. Just add a comma between each interface, and be sure to override all the
    necessary functions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以让一个类同时实现多个不同的接口。只需在每个接口之间添加逗号，并确保重写所有必要的函数。
- en: In this book, we will use the interfaces of the Android API more often than
    we write our own. In the next section, one such interface we will use is the `OnClickListener`
    interface.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将更频繁地使用Android API的接口，而不是编写我们自己的接口。在下一节中，我们将使用`OnClickListener`接口。
- en: Many things might like to know when they are being clicked, such as a `Button`
    widget or a `TextView` widget. So, using an interface, we don't need different
    functions for every type of UI element we might like to click.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 许多东西可能想要在被点击时知道，比如`Button`小部件或`TextView`小部件。因此，使用接口，我们不需要为每种类型的UI元素单独编写不同的函数。
- en: Let's have a look at an interface in action at the same time as connecting our
    Kotlin code with the UI.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起看看接口在同时连接我们的Kotlin代码和UI时的作用。
- en: Using buttons and TextView widgets from our layout with a little help from interfaces
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按钮和TextView小部件从我们的布局中，借助接口的一点帮助
- en: To follow along with this project, create a new Android Studio project, call
    it `Kotlin Meet UI`, and choose the **Empty Activity** template. You can find
    the code and the XML layout code in the `Chapter12``/Kotlin Meet UI` folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随这个项目，创建一个新的Android Studio项目，将其命名为`Kotlin Meet UI`，并选择**Empty Activity**模板。您可以在`Chapter12/Kotlin
    Meet UI`文件夹中找到代码和XML布局代码。
- en: 'First, let''s build a simple UI by observing the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过以下步骤构建一个简单的UI：
- en: In the editor window of Android Studio, switch to `activity_main.xml` and make
    sure you are on the **Design** tab.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio的编辑窗口中，切换到`activity_main.xml`，确保你在**Design**选项卡上。
- en: Delete the auto-generated `TextView`, the one that reads "Hello world!".
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除自动生成的`TextView`，即那个写着“Hello world!”的。
- en: Add a **TextView** widget to the top-center of the layout.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在布局的顶部中心添加一个**TextView**小部件。
- en: Set its **text** property to `0`, its `id` property to `txtValue`, and its `textSize`
    to `40sp`. Pay careful attention to the case of the `id` value. It has an uppercase
    `V`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**text**属性设置为`0`，其`id`属性设置为`txtValue`，其`textSize`设置为`40sp`。请特别注意`id`值的大小写。它的`V`是大写的。
- en: Now, drag and drop six buttons on to the layout so that it looks a bit like
    the following diagram. The exact layout isn't important:![Using buttons and TextView
    widgets from our layout with a little help from interfaces](img/B12806_12_03.jpg)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将六个按钮拖放到布局上，使其看起来有点像下面的图表。确切的布局并不重要：![使用按钮和TextView小部件从我们的布局中，借助接口的一点帮助](img/B12806_12_03.jpg)
- en: When the layout is how you want it, click the **Infer Constraints** button to
    constrain all the UI items.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当布局达到您想要的效果时，单击**Infer Constraints**按钮以约束所有UI项。
- en: 'Double left-click on each button in turn (left-to-right, and then top-to-bottom),
    and set the `text` and `id` properties, as shown in the following table:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依次双击每个按钮（从左到右，然后从上到下），并设置`text`和`id`属性，如下表所示：
- en: '| The `text` property | The `id` property |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `text`属性 | `id`属性 |'
- en: '| `add` | `btnAdd` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `add` | `btnAdd` |'
- en: '| `take` | `btnTake` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `take` | `btnTake` |'
- en: '| `grow` | `btnGrow` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `grow` | `btnGrow` |'
- en: '| `shrink` | `btnShrink` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `shrink` | `btnShrink` |'
- en: '| `hide` | `btnHide` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `hide` | `btnHide` |'
- en: '| `reset` | `btnReset` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `reset` | `btnReset` |'
- en: 'When you''re done, your layout should look like the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您的布局应如下屏幕截图所示：
- en: '![Using buttons and TextView widgets from our layout with a little help from
    interfaces](img/B12806_12_04.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![使用按钮和TextView小部件从我们的布局中，借助接口的一点帮助](img/B12806_12_04.jpg)'
- en: The precise position and text on the buttons are not very important, but the
    values given to the `id` properties must be the same. The reason for this is that
    we will be using these `id` values to get a reference to the `Button` instances
    and the `TextView` instance in this layout from our Kotlin code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮上的精确位置和文本并不是非常重要，但是给`id`属性赋予的值必须相同。原因是我们将使用这些`id`值从我们的Kotlin代码中获取对此布局中的`Button`实例和`TextView`实例的引用。
- en: 'Switch to the **MainActivity.kt** tab in the editor and find the following
    line:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到编辑器中的**MainActivity.kt**选项卡，并找到以下行：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now amend the line of code to the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将代码行修改为以下内容：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you type, you will get a pop-up list asking you to choose an interface to
    implement. Choose **OnClickListener (android.view.view)**, as shown in the next
    screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入时，将会弹出一个列表，询问您要选择要实现的接口。选择**OnClickListener (android.view.view)**，如下一屏幕截图所示：
- en: '![Using buttons and TextView widgets from our layout with a little help from
    interfaces](img/B12806_12_05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![使用按钮和TextView小部件从我们的布局中，借助接口的一点帮助](img/B12806_12_05.jpg)'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You will need to import the `View` class. Be sure to do this before continuing
    with the next step, or you will get confusing results:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要导入`View`类。确保在继续下一步之前执行此操作，否则将会得到混乱的结果：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice that the `MainActivity` declaration is underlined in red, showing an
    error. Now, because we have made `MainActivity` into `OnClickListener` by adding
    it as an interface, we must implement the abstract function of `OnClickListener`.
    The function is called `onClick`. When we add the function, the error will be
    gone.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`MainActivity`声明被红色下划线标出，显示出错误。现在，因为我们已经将`MainActivity`添加为接口`OnClickListener`，我们必须实现`OnClickListener`的抽象函数。该函数称为`onClick`。当我们添加该函数时，错误将消失。
- en: 'We can get Android Studio to add it for us by left-clicking anywhere on the
    code containing the error, and then by using the keyboard combination *Alt* +*Enter*.
    Left-click **Implement members**, as shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在包含错误的代码上任意左键单击，然后使用键盘组合*Alt* +*Enter*来让Android Studio为我们添加。左键单击**Implement
    members**，如下一屏幕截图所示：
- en: '![Using buttons and TextView widgets from our layout with a little help from
    interfaces](img/B12806_12_06.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![使用按钮和TextView小部件从我们的布局中，借助接口的一点帮助](img/B12806_12_06.jpg)'
- en: Now, left-click **OK** to confirm we want Android Studio to add the `onClick`
    method/function. The error is gone, and we can carry on adding code. We also have
    an `onClick` function, and we will soon see what we will do with that.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，左键单击**OK**以确认我们希望Android Studio添加`onClick`方法/函数。错误已经消失，我们可以继续添加代码。我们还有一个`onClick`函数，很快我们将看到我们将如何使用它。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A quick note on terminology. A **method** is a function that is implemented
    in a class. Kotlin allows programmers to implement functions independent of a
    class, so all methods are functions but not all functions are methods. I chose
    to refer to all functions/methods throughout this book as functions. There is
    an argument that method would have been a more precise term, but in the context
    of this book, either is correct. You can call functions in classes methods if
    you prefer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 术语上的一个快速说明。**方法**是在类中实现的函数。Kotlin允许程序员独立于类实现函数，因此所有方法都是函数，但并非所有函数都是方法。我选择在本书中始终将所有方法称为函数。有人认为方法可能是一个更精确的术语，但在本书的上下文中，两者都是正确的。如果您愿意，可以将类中的函数称为方法。
- en: 'Now, add the following property inside the class declaration but outside/before
    any functions:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在类声明内部但在任何函数之外/之前添加以下属性：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have declared an `Int` property called `value` and initialized it to `0`.
    Notice that it is a `var` property because we need to change it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个名为`value`的`Int`属性，并将其初始化为`0`。请注意，它是一个`var`属性，因为我们需要更改它。
- en: 'Next, inside the `onCreate` function, add the following six lines of code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`onCreate`函数内，添加以下六行代码：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Use the *Alt* +*Enter* keyboard combination to import all the `Button` and
    `TextView` instances from the `activity_main.xml` layout file. Or, manually add
    the following import statement:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*Alt* +*Enter*键组合从`activity_main.xml`布局文件中导入所有`Button`和`TextView`实例。或者，手动添加以下导入语句：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code sets up our app to listen for clicks on the buttons in the
    layout. Each line of code does the same thing but on a different button. For example,
    `btnAdd` refers to the button in our layout with the `id` property value of `btnAdd`,
    and `btnTake` refers to the button in our layout with the `id` property value
    of `btnTake`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码设置了我们的应用程序以侦听布局中按钮的点击。每行代码都执行相同的操作，但是在不同的按钮上。例如，`btnAdd`指的是我们布局中`id`属性值为`btnAdd`的按钮，`btnTake`指的是我们布局中`id`属性值为`btnTake`的按钮。
- en: Each button instance then calls the `setOnClickListener` function on itself.
    The argument passed in is `this`. Remember from [Chapter 10](ch10.html "Chapter 10. Object-Oriented
    Programming"), *Object-Oriented Programming*, `this` refers to the current class
    where the code is written. Therefore, in the preceding code, `this` refers to
    `MainActivity`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后每个按钮实例调用自身的`setOnClickListener`函数。传入的参数是`this`。从[第10章](ch10.html "第10章。面向对象编程")中记住，*面向对象编程*，`this`指的是代码所在的当前类。因此，在前面的代码中，`this`指的是`MainActivity`。
- en: The `setOnClickListener` function sets up our app to call the `onClick` function
    of the `OnClickListener` interface. Now, whenever one of our buttons gets clicked,
    the `onClick` function will be called. All this works because `MainActivity` implements
    the `OnClickListener` interface.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`setOnClickListener`函数设置我们的应用程序调用`OnClickListener`接口的`onClick`函数。现在，每当我们的按钮之一被点击，`onClick`函数将被调用。所有这些都是因为`MainActivity`实现了`OnClickListener`接口。'
- en: If you want to verify this, temporarily delete the `View.OnClickListener` code
    from the end of the class declaration, and our code will suddenly be riddled with
    a sea of red errors. This is because `this` is no longer of the `OnCLickListener`
    type, and therefore it cannot be passed to the `setOnClickListener` function of
    the various buttons, and the `onClick` function will also show an error because
    the compiler has no idea what we are trying to override. The interface is what
    makes all this functionality come together.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想验证这一点，暂时从类声明的末尾删除`View.OnClickListener`代码，我们的代码将突然充满一片红色的错误。这是因为`this`不再是`OnCLickListener`类型，因此无法传递给各个按钮的`setOnClickListener`函数，`onClick`函数也会显示错误，因为编译器不知道我们试图覆盖什么。接口是使所有这些功能结合在一起的关键。
- en: Tip
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Replace the `View.OnClickListener` at the end of the class declaration if you
    previously removed it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前删除了`View.OnClickListener`，请在类声明的末尾替换它。
- en: 'Now, scroll down to the `onClick` function that Android Studio added for us
    after we implemented the `OnClickListener` interface. Add the `Float size` variable
    declaration and an empty `when` block inside it so it looks like this next code.
    The new code to add is highlighted next. There is one more thing to notice and
    implement in the next code. When the `onClick` function was autogenerated by Android
    Studio, a question mark was added after the `v: View?` parameter. Remove the question
    mark, as shown in the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，滚动到Android Studio在我们实现`OnClickListener`接口后添加的`onClick`函数。添加`Float size`变量声明和一个空的`when`块，使其看起来像下面的代码。要添加的新代码已经突出显示。在下一个代码中还有一件事需要注意和实现。当`onClick`函数由Android
    Studio自动生成时，在`v: View?`参数后添加了一个问号。删除问号，如下面的代码所示：'
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Remember that `when` will check for a matching value to an expression. The `when`
    condition is `v.id`. The `v` variable is passed to the `onClick` function, and
    `v.id` identifies the `id` property of whichever button was clicked. It will match
    the `id` of one of our buttons in the layout.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`when`将检查匹配表达式的值。`when`条件是`v.id`。`v`变量被传递给`onClick`函数，`v.id`标识了被点击的按钮的`id`属性。它将匹配布局中我们按钮的`id`。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are wondering about that curious question mark that we deleted, it will
    be explained in the next section: *Nullability – val and var revisited.*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对我们删除的那个奇怪的问号感到好奇，它将在下一节中解释：*可空性——val和var重新讨论*。
- en: 'What we need to do next is handle what happens for each button. Add this next
    block of code inside the opening and closing curly brackets of the `when` expression,
    and then we will go through and discuss it. Try and work out the code for yourself
    first, as you will be pleasantly surprised how much we already understand:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要处理每个按钮的操作。将下面的代码块添加到`when`表达式的大括号内，然后我们将讨论它。首先尝试自己解决代码，你会惊讶地发现我们已经理解了多少。
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is that first line of code again:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码的第一行：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`View` is the parent class for `Button`, `TextView`, and more. So, perhaps
    as we might expect, using `v.id` will return the `id` attribute of the UI widget
    that has been clicked, and which triggered the call to `onClick` in the first
    place.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`View`是`Button`、`TextView`等的父类。因此，也许正如我们所期望的那样，使用`v.id`将返回被点击的UI小部件的`id`属性，并触发首次调用`onClick`。'
- en: 'All we need to do then is provide a `when` statement (and an appropriate action)
    for each of the `Button` id values we want to respond to. Here is that part of
    the code again for your convenience:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们想要响应的每个`Button` id值提供一个`when`语句（和一个适当的操作）。以下是代码的一部分，以供您参考：
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Have another look at the next part of the code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 再看一下代码的下一部分：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code is the first three `when` branches. They handle `R.id.btnAdd`,
    `R.id.btnTake`, and `R.id.btnReset`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是前三个`when`分支。它们处理`R.id.btnAdd`、`R.id.btnTake`和`R.id.btnReset`。
- en: The code in the `R.id.btnAdd` branch simply increments the `value` variable,
    and then it does something new.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`R.id.btnAdd`分支中的代码简单地增加了`value`变量，然后做了一些新的事情。'
- en: It sets the `text` property of the the `txtValue` object. This has the effect
    of causing this `TextView` to display whatever value is stored in `value`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 它设置了`txtValue`对象的`text`属性。这样做的效果是使这个`TextView`显示存储在`value`中的任何值。
- en: The **TAKE** button (`R.id.btnTake`) does exactly the same, only it subtracts
    one from `value` instead of adding one.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**TAKE**按钮（`R.id.btnTake`）做的事情完全相同，只是从`value`中减去1，而不是加1。'
- en: The third branch of the `when` statement handles the **RESET** button, sets
    `value` to zero, and again updates the `text` property of `txtValue`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`语句的第三个分支处理**RESET**按钮，将`value`设置为零，并再次更新`txtValue`的`text`属性。'
- en: At the end of whichever `when` branch is executed, the entire `when` block is
    exited, the `onClick` function returns, and life goes back to normal – until the
    user's next click.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何`when`分支的末尾，整个`when`块都会退出，`onClick`函数返回，生活恢复正常——直到用户的下一次点击。
- en: 'Let''s move on to examine the next two branches of the `when` block. Here they
    are again for your convenience:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续检查`when`块的下两个分支。以下是为了方便您再次查看：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The next two branches handle the **SHRINK** and **GROW** buttons from our UI.
    We can confirm this from the id's `R.id.btnGrow` value and `R.id.btnShrink` value.
    What is new, and more interesting, are the getter and setter of the `TextView`
    class that are used on the buttons.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个分支处理我们UI中的**SHRINK**和**GROW**按钮。我们可以从id的`R.id.btnGrow`值和`R.id.btnShrink`值确认这一点。新的更有趣的是`TextView`类的getter和setter在按钮上使用。
- en: The getter of the `textScaleX` property returns the horizontal scale of the
    text within the object it is used on. We can see that the object it is used on
    is our `TextView txtValue` instance. The `size =` code at the start of the line
    of code assigns that returned value to our `Float` variable `size`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`textScaleX`属性的getter返回所使用对象中文本的水平比例。我们可以看到它所使用的对象是我们的`TextView txtValue`实例。代码`size
    =`在代码行的开头将返回的值分配给我们的`Float`变量`size`。'
- en: The next line of code in each `when` branch changes the horizontal scale of
    the text using the setter of the `textScaleX` property. When the **GROW** button
    is pressed, the scale is set to `size + 1`, and when the **SHRINK** button is
    pressed, the scale is set to `size - 1`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`when`分支中的下一行代码使用`textScaleX`属性的setter来改变文本的水平比例。当按下**GROW**按钮时，比例设置为`size
    + 1`，当按下**SHRINK**按钮时，比例设置为`size - 1`。
- en: The overall effect is to allow these two buttons to grow and shrink the text
    in `txtValue` by a scale of `1` on each click.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 总体效果是允许这两个按钮通过每次点击来放大和缩小`txtValue`中的文本，比例为`1`。
- en: 'Let''s look at the final branch of the `when` code. Here it is again for your
    convenience:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`when`代码的最后一个分支。以下是为了方便您再次查看：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding code takes a little bit of explaining, so let''s take it a step
    at a time. First, there is an `if` – `else` expression nested inside the `when`
    branch. Here is the `if` part again:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码需要一点解释，所以让我们一步一步来。首先，在`when`分支内嵌套了一个`if`-`else`表达式。以下是`if`部分：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The condition to be evaluated is `txtValue.visibility == View.VISIBLE`. The
    first part of that, before the `==` operator, uses the `visibility` property's
    getter to return the value describing whether or not the `TextView` is currently
    visible. The return value will be one of three possible constant values as defined
    in the `View` class. They are `View.VISIBLE`, `View.INVISIBLE,` and `View.GONE`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要评估的条件是`txtValue.visibility == View.VISIBLE`。在`==`运算符之前的部分使用`visibility`属性的getter返回描述`TextView`当前是否可见的值。返回值将是`View`类中定义的三个可能的常量值之一。它们是`View.VISIBLE`，`View.INVISIBLE`和`View.GONE`。
- en: If `TextView` is visible to the user on the UI, the getter returns `View.VISIBLE`,
    the condition is evaluated as `true,` and the `if` block is executed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`TextView`在UI上对用户可见，则getter返回`View.VISIBLE`，条件被评估为`true`，并且执行`if`块。
- en: Inside the `if` block, we use the `visibility` property's setter and make it
    invisible to the user with the `View.INVISIBLE` value.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块内，我们使用`visibility`属性的setter将其对用户不可见，使用`View.INVISIBLE`值。
- en: In addition to this, we change the text on the `btnHide` object to **SHOW**
    using the `text` property's setter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们使用`text`属性的setter将`btnHide`对象上的文本更改为**SHOW**。
- en: After the `if` block has executed, `txtValue` will be invisible, and we have
    a button on our UI that says **SHOW**. When the user clicks on it in this state,
    the `if` statement will be false and the `else` block will execute. In the `else`
    block, we reverse the situation. We set the `txtValue` object's `visibility` property
    back to `View.VISIBLE`, and the `text` property on `btnHide` back to **HIDE**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块执行后，`txtValue`将不可见，并且我们的UI上有一个按钮显示**SHOW**。当用户在这种状态下点击它时，`if`语句将为false，`else`块将执行。在`else`块中，我们将情况反转。我们将`txtValue`对象的`visibility`属性设置回`View.VISIBLE`，并将`btnHide`上的`text`属性设置回**HIDE**。
- en: If this is in any way unclear, just enter the code, run the app, and revisit
    this last code and explanation once you have seen it in action.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何不清楚的地方，只需输入代码，运行应用程序，然后在看到它实际运行后再回顾一下最后的代码和解释。
- en: 'We have the UI and the code in place, so it is now time to run the app and
    try out all the buttons. Notice that the **ADD** and **TAKE** buttons change the
    value of `value` by one in either direction, and then display the result in the
    `TextView`. In this next image, I have clicked the **ADD** button three times:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好UI和代码，现在是时候运行应用程序并尝试所有按钮了。请注意，**ADD**和**TAKE**按钮会分别将`value`的值增加或减少一，并在`TextView`中显示结果。在下一张图片中，我点击了**ADD**按钮三次：
- en: '![Using buttons and TextView widgets from our layout with a little help from
    interfaces](img/B12806_12_07.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![使用按钮和TextView小部件从我们的布局中获得帮助](img/B12806_12_07.jpg)'
- en: 'Notice that the **SHRINK** and **GROW** buttons increase the width of the text,
    and **RESET** sets the `value` variable to zero and displays it on the `TextView`.
    In the following screenshot, I have clicked the **GROW** button eight times:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**SHRINK**和**GROW**按钮增加了文本的宽度，**RESET**将`value`变量设置为零，并在`TextView`上显示它。在下面的截图中，我点击了**GROW**按钮八次：
- en: '![Using buttons and TextView widgets from our layout with a little help from
    interfaces](img/B12806_12_08.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![使用按钮和TextView小部件从我们的布局中获得帮助](img/B12806_12_08.jpg)'
- en: Finally, the **HIDE** button not only hides the `TextView,` but changes its
    own text to **SHOW**, and will, indeed, re-show the `TextView` if tapped again.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**HIDE**按钮不仅隐藏`TextView`，还将其自身文本更改为**SHOW**，如果再次点击，则确实会重新显示`TextView`。
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I will not bother you by showing you an image of something that is hidden. Be
    sure to try the app in an emulator as well as following along with the book. If
    you are wondering about the difference between `View.INVISIBLE` and `View.GONE`,
    `INVISIBLE` simply hides the object, but when `GONE` is used the layout behaves
    as if the object was never there, so can affect the layout of the remaining UI.
    Change the line of code from `INVISIBLE` to `GONE` and run the app to observe
    the difference.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会打扰你，向你展示一个隐藏的东西的图片。一定要在模拟器中尝试该应用，并跟着书本一起学习。如果你想知道`View.INVISIBLE`和`View.GONE`之间的区别，`INVISIBLE`只是隐藏了对象，但当使用`GONE`时，布局的行为就好像对象从未存在过一样，因此可能会影响剩余UI的布局。将代码行从`INVISIBLE`更改为`GONE`，并运行应用程序以观察差异。
- en: Notice that there was no need for `Log` or `Toast` in this app, as we are finally
    manipulating the UI using our Kotlin code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个应用程序中不需要`Log`或`Toast`，因为我们最终是使用我们的Kotlin代码来操作UI。
- en: Nullability – val and var revisited
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可空性 - val和var重温
- en: When we declare an instance of a class with `val` it does not mean we cannot
    change the value held in the properties. What determines whether we can reassign
    the values held by the properties is whether the properties themselves are `val`
    or `var`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用`val`声明一个类的实例时，并不意味着我们不能改变属性中保存的值。决定我们是否可以重新分配属性中保存的值的是属性本身是`val`还是`var`。
- en: 'When we declare an instance of a class with `val`, it just means we cannot
    reassign another instance to it. When we want to reassign to an instance, we must
    declare it with `var`. Here are some examples:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用`val`声明一个类的实例时，这只意味着我们不能重新分配另一个实例给它。当我们想要重新分配一个实例时，我们必须用`var`声明它。以下是一些例子：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding hypothetical code, an instance called `someInstance` is declared,
    and it is of the `SomeClass` type. It is declared as `val`. The three lines of
    code that follow suggest that, if its properties were declared with `var` we can
    change those properties, but, as we have already learned, when the property is
    declared with `val` we cannot change it. So, what exactly does declaring an instance
    with `val` or `var` mean? Look at this next hypothetical code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的假设代码中，声明了一个名为`someInstance`的实例，它是`SomeClass`类型。它被声明为`val`。接下来的三行代码表明，如果它的属性被声明为`var`，我们可以更改这些属性，但是，正如我们已经学到的，当属性被声明为`val`时，我们不能更改它。那么，用`val`或`var`声明一个实例到底意味着什么？看看下面的假设代码：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code makes clear that when an instance is a `val`, it cannot be
    reassigned to refer to a different object on the heap, but when it is `var` it
    can. Whether an instance is `val` or `var` does not affect whether its properties
    are `val` or `var`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码清楚地表明，当一个实例是`val`时，它不能被重新分配到堆上的另一个对象，但当它是`var`时可以。实例是`val`还是`var`并不影响其属性是`val`还是`var`。
- en: We have already learned when discussing properties that, if we don't need to
    change a value, it is good practice to declare as `val`. The same is true for
    objects/instances. If we don't need to reassign an instance, we should declare
    it as `val`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学到，当讨论属性时，如果我们不需要改变一个值，最好的做法是声明为`val`。对于对象/实例也是如此。如果我们不需要重新分配一个实例，我们应该将其声明为`val`。
- en: Null objects
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空对象
- en: 'When we declare an object or property as `var`, we have the option not to initialize
    it immediately, and sometimes this is what we need. When we don''t initialize
    an object, it is called a **null reference**, because it doesn''t refer to anything.
    We often need to declare an object but not initialize it until our app is running,
    but this can cause a problem. Look at some more hypothetical code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将对象或属性声明为`var`时，我们有选择不立即初始化它，有时这正是我们需要的。当我们不初始化一个对象时，它被称为**空引用**，因为它不指向任何东西。我们经常需要声明一个对象，但直到我们的应用程序运行时才初始化它，但这可能会引起问题。看看更多的假设代码：
- en: '[PRE19]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we have declared a new instance of `SomeClass` called
    `someInstance5`, but we have not initialized it. Now, look at this screenshot
    to see what happens when we try to use this instance before we have initialized
    it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个名为`someInstance5`的`SomeClass`的新实例，但我们没有初始化它。现在，看看这个截图，看看当我们在初始化之前尝试使用这个实例时会发生什么：
- en: '![Null objects](img/B12806_12_09.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![空对象](img/B12806_12_09.jpg)'
- en: 'The compiler will not allow us to do this. When we need to initialize an instance
    during program execution, we must specifically initialize it as `null` so that
    the compiler knows it is intentional. Furthermore, when we initialize an instance
    as `null`, we must use the **nullable operator**. Look at the next hypothetical
    code that fixes the problem we have just seen:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器不允许我们这样做。当我们需要在程序执行期间初始化一个实例时，我们必须明确地将其初始化为`null`，以便编译器知道这是有意的。此外，当我们将实例初始化为`null`时，我们必须使用**可空运算符**。看看下一个修复刚才问题的假设代码：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, the nullable operator is used on the end of the `SomeClass?`
    type, and the instance is initialized to `null`. When we use the nullable operator
    we can think of the instance as being a different type – *SomeClass nullable*
    as opposed to just *SomeClass*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，可空运算符用在`SomeClass?`类型的末尾，并且实例被初始化为`null`。当我们使用可空运算符时，我们可以将实例视为不同的类型
    - *SomeClass可空*，而不仅仅是*SomeClass*。
- en: 'Then, we could initialize the instance whenever we need to in our code. We
    will see some real examples of this starting in [Chapter 14](ch14.html "Chapter 14. Android
    Dialog Windows"), *Android Dialog Windows*, and throughout the rest of the book,
    but for now, here is a hypothetical way we might conditionally initialize this
    null object:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在代码中需要的时候初始化实例。我们将在[第14章](ch14.html "第14章。Android对话框窗口")中看到一些真实的例子，*Android对话框窗口*，以及本书的其余部分，但现在，这是我们可能有条件地初始化这个空对象的一种假设方式：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We could then proceed to use `someInstance5` as normal.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像平常一样使用`someInstance5`。
- en: Safe call operator
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全调用运算符
- en: 'Sometimes we need more flexibility. Suppose that we need the value of one of
    the properties in `someInstance5`, but it is not possible to guarantee that it
    has been initialized? In this situation we can use the **safe call** `?` operator:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要更灵活性。假设我们需要`someInstance5`中一个属性的值，但无法保证它已经初始化？在这种情况下，我们可以使用**安全调用**`?`运算符：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, if `someInstance5` has been initialized, the value stored
    in the `someImmutable` property will be used to initialize `someInt`. If it hasn't
    been initialized, then `someInt` will be initialized with null. Note, therefore,
    that `someInt` is inferred to be of the `Int` nullable type, not plain `Int`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，如果`someInstance5`已经初始化，则将使用`someImmutable`属性中存储的值来初始化`someInt`。如果尚未初始化，则`someInt`将被初始化为null。因此，请注意，`someInt`被推断为可空类型`Int`，而不是普通的`Int`。
- en: Non null assertion
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非空断言
- en: 'There will arise situations where we cannot guarantee, at compile time, that
    the instance is initialized, and it is not possible to satisfy the compiler that
    it will be. When this is the case, we must assert that the object is not null
    with the **non-null assertion** `!!` operator. Consider the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 会出现一些情况，我们无法在编译时保证实例已初始化，并且无法让编译器相信它会被初始化。在这种情况下，我们必须使用**非空断言**`!!`运算符来断言对象不为空。考虑以下代码：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding code, it is possible that `someInstance5` might not have been
    initialized, and we used the non-null assertion operator, or the code would not
    have compiled.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`someInstance5`可能尚未初始化，我们使用了非空断言运算符，否则代码将无法编译。
- en: Also note that, if we write some faulty logic and the instance is still null
    when we use it, then the app will crash. In fact, the `!!` operator should be
    used as infrequently as possible, as the safe call operator is preferred.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果我们编写了一些错误的逻辑，并且在使用时实例仍然为空，那么应用程序将崩溃。实际上，应尽量少地使用`!!`运算符，而应优先使用安全调用运算符。
- en: Nullability in review
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾空值性
- en: There is more to nullability than we have covered so far. It is possible to
    write many pages discussing the different usages of the different operators, and
    there are more of these as well. The point is that Kotlin is designed to help
    us avoid crashes due to null objects whenever possible. It is much more instructive,
    however, to see nullable types, the safe call operator, and the non-null assertion
    operator in action than it is to theorize about them. We will bump into all three
    of them regularly throughout the book, when hopefully their context will be more
    instructive than their theory.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 空值性还有更多内容，我们还没有涵盖到。讨论不同运算符的不同用法可能需要写很多页，而且还有更多的运算符。关键是，Kotlin旨在帮助我们尽可能避免由于空对象而导致的崩溃。然而，看到可空类型、安全调用运算符和非空断言运算符的实际应用要比理论更有教育意义。在本书的其余部分中，我们将经常遇到这三种情况，希望它们的上下文会比它们的理论更有教育意义。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we finally had some real interaction between our code and our
    UI. It turns out that every time we add a widget to our UI, we are adding a Kotlin
    instance of a class that we can access with a reference in our code. All these
    objects are stored in a separate area of memory called the Heap – along with any
    instances of classes of our own.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们最终在代码和UI之间有了一些真正的交互。原来，每当我们向UI添加一个小部件时，我们都在添加一个我们可以在代码中引用的类的Kotlin实例。所有这些对象都存储在一个称为堆的内存区域中，与我们自己的类的任何实例一起。
- en: We are now in a position where we can learn about and do cool things with some
    of the more interesting widgets. We will look at loads of them in the next chapter,
    [Chapter 13](ch13.html "Chapter 13. Bringing Android Widgets to Life"), *Bringing
    Android Widgets to Life*, and we will also keep introducing new widgets throughout
    the rest of the book.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以学习并使用一些更有趣的小部件。我们将在下一章[第13章](ch13.html "第13章。给Android小部件赋予生命")中看到很多这样的小部件，*给Android小部件赋予生命*，并且在本书的其余部分中我们还将继续介绍新的小部件。
