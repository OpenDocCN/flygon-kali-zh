- en: Tools for High Performance on the Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络高性能工具
- en: JavaScript has become the mainstay language of the web. There is no extra runtime
    needed, and there is no compilation process required to run an application in
    JavaScript. Any user can open up a web browser and start typing in the console
    to learn the language. In addition to this, there have been many advancements
    in the language along with the **Document Object Model** (**DOM**). All of this
    has led to a rich environment for developers to take and create.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript已经成为网络的主要语言。它不需要额外的运行时，也不需要编译过程来运行JavaScript应用程序。任何用户都可以打开一个网络浏览器并开始在控制台中输入来学习这种语言。除此之外，语言和**文档对象模型**（**DOM**）也有许多进步。所有这些都为开发人员提供了一个丰富的环境来创造。
- en: On top of this, we can see the web as a *build once, deploy anywhere* environment.
    The code that works on one operating system will work on another. There is some
    variation that will need to happen if we want to target all browsers, but it can
    be seen as a *develop once, deploy anywhere* platform. However, all of this has
    led to applications that have become bloated, with expensive frameworks and unnecessary
    polyfills. The necessity for these frameworks can be seen in most job postings,
    but sometimes we don't need them to create rich applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们可以将网络视为*一次构建，随处部署*的环境。在一个操作系统上运行的代码也将在另一个操作系统上运行。如果我们想要针对所有浏览器，可能需要进行一些调整，但它可以被视为*一次开发，随处部署*的平台。然而，所有这些都导致了应用程序变得臃肿，使用了昂贵的框架和不必要的polyfill。大多数工作职位都需要这些框架，但有时我们不需要它们来创建丰富的应用程序。
- en: 'This chapter focuses on the tools that we will use to help us build and profile
    high-performance web applications. We will take a look at the different modern
    browsers and their unique contributions. We will then take a deep dive into the
    Chrome developer tools. Overall, we will learn the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍我们将用来帮助构建和分析高性能网络应用程序的工具。我们将研究不同的现代浏览器及其独特的贡献。然后我们将深入研究Chrome开发者工具。总的来说，我们将学到以下内容：
- en: The different development tools embedded in each browser
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个浏览器中嵌入的不同开发工具
- en: 'An in depth look at the following Chrome tools:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解以下Chrome工具：
- en: The Performance tab
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能选项卡
- en: The Memory tab
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存选项卡
- en: The Renderer tab
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染器选项卡
- en: jsPerf and benchmarking code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jsPerf和代码基准测试
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are prerequisites for this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的先决条件如下：
- en: A web browser, preferably Chrome.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网络浏览器，最好是Chrome。
- en: An editor; VS Code is preferred.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑器；最好使用VS Code。
- en: Knowledge of JavaScript and some of the DOM APIs.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的知识和一些DOM API。
- en: The relevant code can be found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter01).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关代码可以在[https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter01](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter01)找到。
- en: DevTools for different environments
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同环境的开发工具
- en: There are four browsers that are considered modern browsers. These are Edge,
    Chrome, Firefox, and Safari. These browsers uphold the latest in standards and
    are being actively developed. We will take a look at how each is developing and
    some of their unique features.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种被认为是现代浏览器的浏览器。它们是Edge、Chrome、Firefox和Safari。这些浏览器遵守最新的标准，并且正在积极开发。我们将看看它们各自的发展情况以及一些独特的功能。
- en: Internet Explorer is getting close to the end of its life cycle. The only development
    that will be happening with the browser is critical security fixes. New applications
    should try to deprecate this browser, but if there is a client base still utilizing
    it, then we may need to develop for it. We will not be focusing on polyfills for
    it in this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Internet Explorer接近于终止其生命周期。浏览器只会进行关键的安全修复。新应用程序应该尽量淘汰这个浏览器，但如果仍有客户群在使用它，我们可能需要为其开发。在本书中，我们不会专注于为其提供polyfill。
- en: Edge
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Edge
- en: Microsoft's Edge browser was their take on the modern web. With the EdgeHTML
    renderer and the Chakra JavaScript engine, it performs well in many benchmarks.
    While the Chakra engine does have different optimizations for it than Chrome or
    Firefox, it is an interesting browser to look at from a pure JavaScript perspective.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的Edge浏览器是他们对现代网络的看法。借助EdgeHTML渲染器和Chakra JavaScript引擎，在许多基准测试中表现良好。虽然Chakra引擎与Chrome或Firefox有不同的优化，但从纯JavaScript的角度来看，这是一个有趣的浏览器。
- en: As of the time of writing of this book, Microsoft was changing the rendering
    engine of Edge to the Chromium system. This has many implications for web developers.
    First, this means that more browsers will be running the Chromium system. This
    means less to worry about in terms of cross-browser development. While support
    for the current form of Edge is required, it may disappear in the coming year.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，微软正在将Edge的渲染引擎更改为Chromium系统。这对Web开发人员有许多影响。首先，这意味着更多的浏览器将运行Chromium系统。这意味着在跨浏览器开发方面要担心的事情会减少。虽然需要支持当前形式的Edge，但它可能会在未来一年内消失。
- en: 'In terms of features, Edge is light compared to the other browsers. If we need
    to perform any type of performance testing for it, the best bet is to profile
    code with jsPerf or others instead of the built-in tools. On top of this, the
    Chakra engine utilizes different optimization techniques, so what may work with
    Chrome or Safari may be less optimized for Edge. To get to the developer tools
    on Windows, we can press *F12*. This will pull up the usual console dialog, shown
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能方面，Edge相对于其他浏览器来说比较轻。如果我们需要对其进行任何类型的性能测试，最好的选择是使用jsPerf或其他工具来分析代码，而不是使用内置工具。此外，Chakra引擎利用不同的优化技术，因此在Chrome或Safari上有效的代码可能对Edge来说不够优化。在Windows上打开开发者工具，我们可以按下*F12*。这将弹出通常的控制台对话框，如下所示：
- en: '![](assets/03e0519d-a88e-4fd9-8d77-7084d4d20dac.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/03e0519d-a88e-4fd9-8d77-7084d4d20dac.png)'
- en: We will not be going through any interesting features specific to Edge since
    most, if not all, of the features in their developer tools are the same as those
    found in other browsers.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会介绍Edge的任何有趣功能，因为他们的开发工具中的大多数，如果不是全部，功能与其他浏览器中的功能相同。
- en: With the latest Edge browser based on Chromium, OS X users will be happy to
    note that the browser is supposed to be supported. This means cross-browser development
    will get easier for those on OS X versus Windows or Linux.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Chromium的最新Edge浏览器将支持OS X用户，这意味着与Windows或Linux相比，OS X用户进行跨浏览器开发将变得更加容易。
- en: Safari
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Safari
- en: Apple's Safari browser is based on the WebKit rendering engine and the JavaScriptCore
    engine. The WebKit engine is what Chrome's Blink engine is based on, and the JavaScriptCore
    engine is used in a few places for the OS X operating system. An interesting point
    regarding Safari is the fact that if we are running Windows or Linux, we will
    not be able to access it directly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的Safari浏览器基于WebKit渲染引擎和JavaScriptCore引擎。WebKit引擎是Chrome的Blink引擎的基础，JavaScriptCore引擎在OS
    X操作系统的一些地方使用。关于Safari的一个有趣的点是，如果我们运行Windows或Linux，我们将无法直接访问它。
- en: To get access to Safari, we will need to utilize an online service. BrowserStack
    or LambdaTest, along with a host of others, can do this job for us. With any of
    these, we now have access to browsers that we may not otherwise have had. Thanks
    to LambdaTest, we will utilize their free service to take a brief look at Safari.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问Safari，我们需要利用在线服务。BrowserStack或LambdaTest以及其他一些服务都可以为我们完成这项工作。有了这些服务中的任何一个，我们现在可以访问我们可能没有的浏览器。感谢LambdaTest，我们将利用他们的免费服务简要查看Safari。
- en: Again, we will notice that there is not too much to the Safari browser development
    tools. All of the same tools are also available in the other browsers and they
    are usually more powerful in these other browsers. Getting familiar with each
    of the interfaces can help when debugging in that specific browser, but not a
    lot of time needs to be dedicated to looking at the browsers that do not have
    any specific features unique to them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们会注意到Safari浏览器开发工具并不是太多。所有这些工具在其他浏览器中也都可用，并且通常在这些其他浏览器中更加强大。熟悉每个界面可以帮助在特定浏览器中进行调试，但不需要花费太多时间查看那些没有任何特定功能的浏览器。
- en: Firefox
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Firefox
- en: Mozilla's Firefox utilizes the SpiderMonkey JavaScript engine and the enhanced Gecko
    engine. The Gecko engine got some nice improvements when they added parts of their
    project Servo code base to it to give a nice multithreaded renderer. Mozilla has
    been at the forefront of the latest web technologies. They were one of the first
    to implement WebGL and they have been one of the first to implement WebAssembly
    and the **WebAssembly System Interface** (**WASI**) standard.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Mozilla的Firefox使用了SpiderMonkey JavaScript引擎和增强的Gecko引擎。当他们将他们的项目Servo代码的部分添加到Gecko引擎中时，Gecko引擎得到了一些很好的改进，从而提供了一个不错的多线程渲染器。Mozilla一直处于最新Web技术的前沿。他们是最早实现WebGL的之一，他们也是最早实现WebAssembly和**WebAssembly
    System Interface**（**WASI**）标准的之一。
- en: What follows is a fairly technical discussion about shaders and the shader language,
    **OpenGL Shading Language** (**GLSL**). It is recommended that you read on to
    find out more about this, but for those of you who are lost, it may be helpful
    to visit the documentation to learn more about this technology, at [https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders](https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是关于着色器和着色器语言**OpenGL Shading Language**（**GLSL**）的一些技术讨论。建议您继续阅读以了解更多信息，但对于那些迷失方向的人来说，访问文档以了解更多关于这项技术的信息可能会有所帮助，网址为[https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders](https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders)。
- en: 'If we open the DevTools, *F12* in Windows, we may see the **Shader Editor**
    tab already. If not, go to the triple-dot menu on the right and open up Settings.
    On the left-hand side, there should be a list of checkboxes with a heading of
    Default Developer Tools. Go ahead and select the **Shader Editor** option. Now,
    if we head into this tab, we should get something that looks like the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Windows中打开DevTools，按*F12*，我们可能会看到**Shader Editor**选项卡。如果没有，可以转到右侧的三个点菜单，打开设置。在左侧，应该有一个带有默认开发者工具标题的复选框列表。继续选择**Shader
    Editor**选项。现在，如果我们进入此选项卡，应该会看到以下内容：
- en: '![](assets/0912e619-dc8b-4878-8f6c-b4f2902ad4c4.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0912e619-dc8b-4878-8f6c-b4f2902ad4c4.png)'
- en: 'The tab is asking for a canvas context. Essentially, the tool is looking for
    a few items:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该选项卡正在请求画布上下文。基本上，该工具正在寻找一些项目：
- en: A canvas element
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个画布元素
- en: A 3D-enabled context
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个启用了3D的上下文
- en: Vertex and fragment shaders
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点和片段着色器
- en: A file in our repository called `shader_editor.html` has the necessary code
    to get the canvas set up and also has the shaders set up so we can utilize them
    with the shader editor. These shaders are the way to programmatically use the
    GPU on the web. They utilize a version of the OpenGL specification called OpenGL
    ES 3.0\. This allows us to use almost everything in that specification, specifically,
    the vertex and fragment shaders.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仓库中的一个名为`shader_editor.html`的文件包含了设置画布和着色器的必要代码，这样我们就可以利用着色器编辑器。这些着色器是在Web上以编程方式使用GPU的方法。它们利用了一个名为OpenGL
    ES 3.0的OpenGL规范的版本。这使我们能够使用该规范中的几乎所有内容，特别是顶点和片段着色器。
- en: 'To program with these shaders, we use a language called **GL Shading Language**
    (**GLSL**). This is a C-like language that has a bunch of features that are specific
    to it, such as swizzling. Swizzling is the ability to utilize the vector components
    (up to four) and combine them in any shape or form that we choose. An example
    of this looks like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些着色器进行编程，我们使用一种称为**GL Shading Language**（**GLSL**）的语言。这是一种类似于C的语言，具有许多特定于它的功能，例如swizzling。Swizzling是利用矢量组件（最多四个）并以我们选择的任何形状或形式组合它们的能力。这看起来像下面这样的例子：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This creates a four-element vector and sets the *x*, *y*, *z*, and *w* components
    to the `x`, `y`, `x`, and `x` items, respectively, from the two-element vector.
    The nomenclature can take a while to get used to, but it makes certain things
    a lot easier. An example is shown above, where we need to create a four-element
    vector from a two-element vector. In basic JavaScript, we would have to do the
    following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个四元素向量，并将*x*、*y*、*z*和*w*分量分别设置为两元素向量中的`x`、`y`、`x`和`x`项。命名可能需要一段时间才能习惯，但它确实使某些事情变得更容易。如上所示的一个例子，我们需要从两元素向量中创建一个四元素向量。在基本的JavaScript中，我们需要执行以下操作：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Instead of writing the preceding, we are able to utilize the shorthand syntax
    of swizzling. There are other features in the GLSL system that we will look at
    in later chapters, but this should give a taste of how different the languages
    are.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用swizzling的简写语法，而不是编写前面的内容。GLSL系统中还有其他功能，我们将在后面的章节中进行介绍，但这应该让我们对这些语言有所了解。
- en: Now, if we open up the `shader_editor.html` file and reload the page, we should
    be greeted with what looks like a white page. If we look at the Shader Editor,
    we can see on the right-hand side that we are setting a variable called `gl_FragColor`
    to a four-element vector, all of which are set to `1.0`. What happens if we set
    it to `vec4(0.0, 0.0, 0.0, 1.0)`? We should now see a black box in the top-left
    corner. This showcases the fact that the four components of the vector are the
    red, green, blue, and alpha components of color, ranging from `0.0` to `1.0`,
    just like the `rgba` system for CSS.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们打开`shader_editor.html`文件并重新加载页面，我们应该会看到一个白色的页面。如果我们查看着色器编辑器，我们可以看到右侧我们正在将一个名为`gl_FragColor`的变量设置为一个四元素向量，其中所有元素都设置为`1.0`。如果我们将它设置为`vec4(0.0,
    0.0, 0.0, 1.0)`会发生什么？我们现在应该在左上角看到一个黑色的框。这展示了向量的四个分量是颜色的红色、绿色、蓝色和alpha分量，范围从`0.0`到`1.0`，就像CSS的`rgba`系统一样。
- en: Are there other color combinations besides a single flat color? Well, each shader
    comes with a few global variables that are defined ahead of time. One of these,
    in the fragment shader, is called `gl_FragCoord`. This is the lower left-hand
    coordinate in the window space ranging from `0.0` to `1.0` (there should be a
    theme developing here for what values are considered good in GLSL). If we set
    the four-vector *x* element to the *x* element of `gl_FragCoord`, and the *y*
    element to the *y* element of `gl_FragCoord`, we should get a simple white box,
    but with a single-pixel border on the left, and one on the bottom.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单一的纯色之外，还有其他颜色组合吗？每个着色器都带有一些预先定义的全局变量。其中之一，在片段着色器中，称为`gl_FragCoord`。这是窗口空间中左下角的坐标，范围从`0.0`到`1.0`（这里应该有一个主题，说明在GLSL中哪些值被认为是好的）。如果我们将四元素向量的*x*元素设置为`gl_FragCoord`的*x*元素，将*y*元素设置为`gl_FragCoord`的*y*元素，我们应该会得到一个简单的白色框，但左侧和底部各有一个单像素的边框。
- en: Besides swizzling and global variables, we also get other mathematical functions
    that we can use in these shaders. Let's wrap these *x* and *y* elements in a `sin`
    function. If we do this, we should get a nice plaid pattern on the screen. This
    should give a hint as to what the fragment shader is actually doing. It is trying
    to paint that location in the 3D space, based on various inputs, one being the
    location from the vertex shader.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了swizzling和全局变量，我们还可以在这些着色器中使用其他数学函数。让我们将这些*x*和*y*元素包装在`sin`函数中。如果我们这样做，我们应该在屏幕上得到一个漂亮的格子图案。这应该给出片段着色器实际在做什么的提示。它试图根据各种输入在3D空间中绘制该位置，其中一个输入是来自顶点着色器的位置。
- en: It is then trying to draw every single pixel that makes up the inside of the
    mesh that we declared with the vertex shader. Also, these fragments are calculated
    all at the same time (or as much as the graphics card is capable of), so this
    is a highly parallelized operation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它试图绘制构成我们用顶点着色器声明的网格内部的每个像素。此外，这些片段是同时计算的（或者尽可能多地由显卡来计算），因此这是一个高度并行化的操作。
- en: This should give a nice sneak peek into the world of GLSL programming, and the
    possibilities besides 3D work that the GLSL language can provide for us. For now,
    we can play a bit more with these concepts and move onto the last browser, Chrome.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们一个很好的窥视GLSL编程世界的机会，以及GLSL语言除了3D工作之外可以为我们提供的可能性。现在，我们可以更多地尝试这些概念，并转向最后一个浏览器Chrome。
- en: Chrome
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chrome
- en: Google's Chrome browser utilizes the Blink engine and uses the famous V8 JavaScript
    runtime. This is the same runtime that is used inside Node.js, so getting familiar
    with the development tools will help us in a lot of ways.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌的Chrome浏览器使用Blink引擎，并使用著名的V8 JavaScript运行时。这是Node.js内部使用的相同运行时，因此熟悉开发工具将在很多方面帮助我们。
- en: Chrome has been at the forefront of web technologies, just like Firefox. They
    have been the first to implement various ideas, such as the QUIC protocol, which
    the HTTP/3 standard is loosely based on. They created the **Native Plugin Interface**
    (**NaCL**) that helped, alongside `asm.js`, to create the standard for WebAssembly.
    They have even been pioneers in making web applications start to become more native-like
    by giving us APIs such as the Bluetooth, Gamepad, and Notifications APIs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome一直处于网络技术的前沿，就像Firefox一样。他们是第一个实现各种想法的人，比如QUIC协议，HTTP/3标准就是基于它。他们创建了原生插件接口（NaCL），帮助创建了WebAssembly的标准。他们甚至是使Web应用程序开始变得更像本地应用程序的先驱，通过提供蓝牙、游戏手柄和通知等API。
- en: 'We will be specifically looking at the Lighthouse feature that comes with Chrome.
    The Lighthouse feature can be accessed from the **Audits** tab in the Chrome browser.
    Once we are here, we can set up our audit with a myriad of settings:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将特别关注Chrome附带的Lighthouse功能。Lighthouse功能可以从Chrome浏览器的**审计**选项卡中访问。一旦我们在这里，我们可以使用各种设置来设置我们的审计：
- en: First, we can audit our page based on it running from a mobile device or desktop.
    We can then audit various features of our site.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们可以根据页面是在移动设备上运行还是在桌面上运行来审计我们的页面。然后我们可以审计我们网站的各种功能。
- en: If we are developing a progressive web application, we may decide that SEO is
    not needed. On the other hand, if we are developing a marketing site, we could
    decide that the progressive web app check is not needed. We can simulate a throttled
    connection.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们正在开发渐进式Web应用程序，我们可能会决定不需要SEO。另一方面，如果我们正在开发营销网站，我们可能会决定不需要渐进式Web应用程序检查。我们可以模拟受限连接。
- en: Finally, we can start off with clean storage. This is especially helpful if
    our application utilizes caching systems that are built into browsers, such as
    session storage or local storage.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以从干净的存储开始。如果我们的应用程序利用了内置浏览器缓存系统，比如会话存储或本地存储，这将特别有帮助。
- en: 'As an example, let''s look at an external site and see how well it stacks up
    in the audit application. The site we will be looking at is Amazon, located at
    [https://www.amazon.com](https://www.amazon.com). The site should be a good example
    for us to follow. We are going to look at it as a desktop application, without
    any throttling. If we run the audit, we should get something that looks like the
    following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，让我们看看外部网站，并查看它在审核应用程序中的表现如何。我们将查看的网站是亚马逊，位于[https://www.amazon.com](https://www.amazon.com)。这个网站应该是我们要遵循的一个很好的例子。我们将把它作为桌面应用程序来查看，不进行任何限制。如果我们运行审核，我们应该得到类似以下的结果：
- en: '![](assets/e41e6600-bb25-4f3d-a38c-8cf5ab197fe0.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e41e6600-bb25-4f3d-a38c-8cf5ab197fe0.png)'
- en: As we can see, the main page does well in performance and best practices, but
    Chrome is warning us about accessibility and SEO performance. In terms of accessibility,
    it seems that images do not have `alt` attributes, which means screen readers
    are not going to work well. Also, it seems that the developers have `tabindexes`
    higher than 0, possibly causing the tab order to not follow the normal page flow.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，主页在性能和最佳实践方面表现良好，但Chrome警告我们有关可访问性和SEO性能。在可访问性方面，似乎图片没有`alt`属性，这意味着屏幕阅读器将无法正常工作。此外，似乎开发人员的`tabindexes`高于0，可能导致选项卡顺序不遵循正常页面流程。
- en: If we wanted to set up our own system to test, we would need to host our pages
    locally. There are many great static site hosting solutions (we will be building
    one later in the book), but if we needed to host content, one of the easiest methods
    would be to download Node.js and install the `static-server` module. We will go
    into depth later on how to get Node.js up and running and how to create our own
    servers, but for now, this is the best bet.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要设置自己的系统进行测试，我们需要在本地托管我们的页面。有许多出色的静态站点托管解决方案（我们将在本书后面构建一个），但如果我们需要托管内容，最简单的方法之一是下载Node.js并安装`static-server`模块。我们将在后面深入介绍如何启动和运行Node.js，并如何创建我们自己的服务器，但目前这是最好的选择。
- en: We have looked at the main modern web browsers that are out there and that we
    should target. Each of them has its own capabilities and limitations, which means
    we should be testing our applications on all of them. However, the focus of this
    book will be the Chrome browser and the developer tools that come with it. Since
    Node.js is built with the V8 engine, and with many other new browsers being based
    on the Chromium engine, such as Brave, it would make sense to utilize this. We
    are going to go into detail regarding three specific features that the Chrome
    developer tools give us.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了主要的现代Web浏览器，我们应该瞄准它们。它们每个都有自己的能力和限制，这意味着我们应该在所有这些浏览器上测试我们的应用程序。然而，本书的重点将是Chrome浏览器及其附带的开发工具。由于Node.js是使用V8引擎构建的，并且许多其他新浏览器都是基于Chromium引擎构建的，比如Brave，因此利用这一点是有意义的。我们将详细介绍Chrome开发工具给我们的三个特定功能。
- en: Chrome – an in-depth look at the Performance tab
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chrome - 深入了解性能选项卡
- en: As stated before, except for a select few tools inside Firefox, Chrome has become
    widely ubiquitous as the browser of choice for users and developers. For developers,
    this can be in large part thanks to its wonderful developer tools. The following
    sections are going to take a look at three critical tools that are important to
    any developer when designing web applications. We will start with the performance
    tool.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Firefox内部的一些工具外，Chrome已经成为用户和开发人员首选的广泛使用的浏览器。对于开发人员来说，这在很大程度上要归功于其出色的开发工具。接下来的部分将着眼于设计Web应用程序时对任何开发人员都重要的三个关键工具。我们将从性能工具开始。
- en: This tool allows us to run performance tests while our application is running.
    This is great if we want to see how our application behaves when certain things
    are done. For example, we can profile our application's launch state and see where
    possible bottlenecks are located. Or, when user interaction happens, such as a
    submit on a form, we can see the call hierarchy that we go through to post the
    information and return it back to the user. On top of this, it can even help profile
    code when we use a web worker and how the data transfer works between our application
    contexts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具允许我们在应用程序运行时运行性能测试。如果我们想要查看我们的应用程序在执行某些操作时的行为，这将非常有用。例如，我们可以分析我们的应用程序的启动状态，并查看可能的瓶颈位置。或者，当用户交互发生时，比如在表单上提交时，我们可以看到我们经过的调用层次结构来发布信息并将其返回给用户。除此之外，它甚至可以帮助我们分析在使用Web
    Worker时代码的性能以及我们的应用程序上下文之间的数据传输方式。
- en: 'Following is a screenshot of the **Performance** tab from the latest version
    of Chrome at the time of writing:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是撰写时最新版本Chrome的**性能**选项卡的屏幕截图：
- en: '![](assets/55c88e55-444a-4c81-99fe-a4fd32b2b6ad.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/55c88e55-444a-4c81-99fe-a4fd32b2b6ad.png)'
- en: There are a couple of sections that are of interest. First, the bar below our
    developer tool tabs is our main toolbar. The left two buttons are probably the
    most important, the record and the record on reload tools. These will allow us
    to profile our application and see what happens at critical junctures in our code.
    After these come selection tools to grab profiles that you may have run before.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个部分是我们感兴趣的。首先，我们开发工具标签下面的工具栏是我们的主要工具栏。左边的两个按钮可能是最重要的，记录和重新加载记录工具。这些将允许我们对我们的应用程序进行分析，并查看在我们的代码的关键时刻发生了什么。在这些之后是选择工具，用于获取之前可能运行过的配置文件。
- en: 'Next up are two options that I usually have turned on at all times:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是两个选项，我通常都会随时打开：
- en: First, the screenshot capability will grab screenshots for us when it sees something
    critical happening with the application, such as memory growth or a new document
    being added.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，当应用程序发生关键事件时，屏幕截图功能会为我们抓取屏幕截图，比如内存增长或添加新文档。
- en: The next option is the memory profiler. It will tell us how much memory is being
    consumed at that time.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个选项是内存分析器。它将告诉我们当前消耗了多少内存。
- en: Finally, there is the delete action. As many would surmise, this deletes the
    profile that you are currently on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有删除操作。正如许多人所推测的那样，这将删除您当前正在使用的配置文件。
- en: Let's do a test run on a simple test application. Grab the `chrome_performance.html`
    file from the repository. This file showcases a standard Todo application, but
    it is written with a very basic templating system and no libraries. No libraries
    will become a standard throughout this book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个简单的测试应用程序上进行测试运行。从存储库中获取`chrome_performance.html`文件。这个文件展示了一个标准的待办事项应用程序，但它是用一个非常基本的模板系统和没有库来编写的。在本书中，不使用库将成为标准。
- en: 'If we run this application and run a performance test from reload, we should
    get something that looks like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个应用程序并从重新加载运行性能测试，我们应该得到以下结果：
- en: '![](assets/7ca12819-18a5-4053-8a1e-9e9a4cdf5813.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7ca12819-18a5-4053-8a1e-9e9a4cdf5813.png)'
- en: 'The page should be almost instant to load, but we still get some useful information
    here. Going from top to bottom, we get the following information:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载几乎是瞬间完成的，但我们仍然可以在这里得到一些有用的信息。从上到下，我们得到以下信息：
- en: A timeline of pictures, along with graphing for FPS, CPU usage, network usage,
    and heap usage.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列图片的时间轴，以及FPS、CPU使用率、网络使用率和堆使用率的图表。
- en: A line graph of different statistics, such as JavaScript heap usage, the number
    of documents, the number of document nodes, the number of listeners, and the GPU
    memory that we are utilizing.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同统计数据的折线图，比如JavaScript堆使用、文档数量、文档节点数量、监听器数量以及我们正在使用的GPU内存。
- en: Finally, we get a tabbed section that gives us all of the information about
    timings and a breakdown of where the time is allocated.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们得到一个分栏部分，其中包含有关时间和时间分配的所有信息。
- en: Make sure you let the profiler run its course. It should automatically shut
    down after all operations are done on the page. This should ensure that you are
    getting as close to the correct information as possible on how your application
    is doing. The profiler may have to be run a couple of times to get an accurate
    picture also. The internal garbage collector is trying to hold onto some objects
    so that it can reuse them later, so getting an accurate picture means seeing what
    the low point is since that is most likely where the application baseline is following
    **Garbage Collection** (**GC**). A good indicator of this is seeing a major GC
    and/or a DOM GC. This means we are starting afresh again.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 确保让分析器自行运行。在页面上的所有操作完成后，它应该会自动关闭。这应该确保您尽可能接近正确的应用程序运行信息。分析器可能需要运行几次才能得到准确的图片。内部垃圾收集器正在努力保留一些对象，以便稍后重用它们，因此获得准确的图片意味着看到低点是最有可能的应用程序基线，随后是**垃圾收集**（**GC**）。一个很好的指标是看到主要的GC和/或DOM
    GC。这意味着我们又重新开始了。
- en: In this basic example, we can see that most of the time was spent in the HTML.
    If we open this up, we will then see that evaluating our script took the majority
    of that time. Since most of our time was spent in evaluating the script and inserting
    our templated Todo application into the DOM, let's see what the statistics would
    look like if we did not have this behavior.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基本示例中，我们可以看到大部分时间都花在了HTML上。如果我们打开它，我们会看到评估我们的脚本占用了大部分时间。由于大部分时间都花在了评估脚本和将我们的模板化待办事项应用程序插入DOM中，让我们看看如果没有这种行为，统计数据会是什么样子。
- en: Comment out everything except for our basic tags, such as the `html`, `head`,
    and `body` tags. There are a few interesting elements regarding this run. First,
    the number of documents should have stayed the same or decreased. This will be
    touched upon later. Second, the number of nodes decreased dramatically and likely
    went down to around 12\. Our JavaScript heap went down a little bit, and the number
    of listeners went down significantly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注释掉除了我们的基本标签之外的所有内容，比如`html`、`head`和`body`标签。这次运行有一些有趣的元素。首先，文档的数量应该保持不变或减少。这将在后面提到。其次，节点的数量急剧减少，可能降到了大约12个。我们的JavaScript堆略微减少，监听器的数量显著减少。
- en: Let's bring a single `div` tag back in. The number of documents, heap space,
    and listeners stayed the same, but the number of nodes increased again. Let's
    add in another `div` element and see how that affects the number of nodes. It
    should increase by four. One last time, let's add in another `div` element. Again,
    we should notice an increase of four DOM nodes being added. This gives us a bit
    of a clue into how the DOM is running and how we can make sure our profiling is
    correct.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再加入一个`div`标签。文档、堆空间和监听器的数量保持不变，但节点的数量再次增加。让我们再添加另一个`div`元素，看看它对节点数量的影响。它应该增加四个。最后一次，让我们再添加另一个`div`元素。同样，我们应该注意到增加了四个DOM节点。这给了我们一些线索，了解DOM的运行方式以及如何确保我们的分析是正确的。
- en: First, the number of nodes is not directly equal to the number of DOM elements
    that are on the screen. DOM nodes are made up of several underlying basic nodes.
    As an example, if we add an element such as an `input` element, we may notice
    that the number of nodes increases by more than four. Second, the number of documents
    that are available is almost always going to be higher than a single document.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，节点的数量并不直接等于屏幕上的DOM元素数量。DOM节点由几个基本节点组成。例如，如果我们添加一个`input`元素，我们可能会注意到节点的数量增加了超过四个。其次，可用的文档数量几乎总是高于单个文档。
- en: While some of this behavior can be attributed to bugs in the profiler, it also
    showcases the fact that there are things happening behind the scenes that are
    not available to the developer. When we touch on the Memory tab and look at call
    hierarchies, we will see how internal systems are creating and destroying nodes
    that a developer does not have full control of, along with documents that are
    invisible to the developer but are optimizations for the browser.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些行为可以归因于性能分析器中的错误，但它也展示了幕后发生的事情，这些事情对开发人员是不可见的。当我们触及内存选项卡并查看调用层次时，我们会看到内部系统正在创建和销毁开发人员无法完全控制的节点，以及开发人员看不到但是浏览器优化的文档。
- en: 'Let''s add in our code block again and get back to what the original document
    was. If need be, go ahead and revert the Git branch (if this was pulled down from
    the repository) and run the profiler again. We specifically want to look at the
    Call Tree tab and the Parse HTML dropdown. There should be a hierarchy that looks
    something like the following: `Parse HTML > Evaluate Script > (anonymous) > runTemplate
    > runTemplate`.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次添加我们的代码块，回到原始文档。如果需要的话，继续回滚Git分支（如果这是从存储库中拉取的），然后再次运行性能分析器。我们特别想查看调用树选项卡和解析HTML下拉菜单。应该有一个类似以下的层次结构：`解析HTML
    > 评估脚本 > (匿名) > runTemplate > runTemplate`。
- en: 'Let''s change the code and turn our inner `for` loop into an array `map` function
    like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变代码，将我们的内部`for`循环转换为一个数组`map`函数，就像这样：
- en: '[PRE2]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Comment out both the `loopEls` array initialization and also the `for` loop.
    Run the profiler again and let's take a look at what this call stack looks like.
    We will notice that it is still profiling the `runTemplate` function as itself
    even though we bound it to a new function called `tempFun`. This is another piece
    that we have to keep in mind when we are looking at the call hierarchy. We may
    bind, call, or apply functions, but the development tools will still try to maintain
    the original definition of the function.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注释掉`loopEls`数组初始化和`for`循环。再次运行性能分析器，让我们看看这个调用堆栈是什么样子。我们会注意到，即使我们将其绑定到一个名为`tempFun`的新函数，它仍然会将`runTemplate`函数本身作为自己进行性能分析。这是我们在查看调用层次时必须牢记的另一个要点。我们可能会绑定、调用或应用函数，但开发工具仍会尝试维护函数的原始定义。
- en: 'Finally, let''s add a lot of items to our data list and see how this affects
    our profiling. Put the following code below the data section:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们向我们的数据列表添加很多项目，看看这对我们的分析有什么影响。将以下代码放在数据部分下面：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We should now get a bit of a different picture than what we had before:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该得到一个与之前不同的画面：
- en: First, where our time was close to being evenly split between layout by the
    GPU and the evaluation of our script, it now looks like we are spending most of
    our time running the layout engine. This makes sense since we are forcing the
    DOM to figure out the layout for each item when it gets added at the end of our
    script.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们的时间几乎平均分配在GPU的布局和脚本的评估之间，现在看起来我们大部分时间都在运行布局引擎。这是有道理的，因为我们在脚本的末尾添加每个项目时，我们强制DOM来计算布局。
- en: Second, the Evaluate Script section should now contain quite a few more pieces
    than the simple call hierarchy that we saw before.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，评估脚本部分现在应该包含比之前简单的调用层次更多的部分。
- en: We will also start to see different parts of the function being registered in
    the profiler. What this shows is that if something is below a certain threshold
    (it really depends on the machine and even the build of Chrome), it will not show
    that the function was considered important enough to be profiled.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将开始看到函数的不同部分在性能分析器中注册。这表明，如果某些东西低于某个阈值（这实际上取决于机器甚至Chrome的版本），它将不会显示函数被认为足够重要以进行性能分析。
- en: Garbage collection is the process of our environment cleaning up unused items
    that we are no longer using. Since JavaScript is a memory-managed environment,
    meaning developers are not allocating/deallocating memory themselves like in languages
    such as C++ and Rust, we have a program that does this for us. V8, in particular,
    has two GCs, a minor GC called **Scavenger**, and a major one called **Mark-Compact**.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收是环境清理我们不再使用的未使用项目的过程。由于JavaScript是一个内存管理环境，这意味着开发人员不像在C++和Rust等语言中那样自己分配/释放内存，我们有一个程序来为我们做这些。特别是V8有两个GC，一个叫做**Scavenger**的次要GC，一个叫做**Mark-Compact**的主要GC。
- en: 'The scavenger goes through newly allocated objects and sees whether there are
    any objects that are ready to be cleaned up. Most of the time, our code is going
    to be written to use a lot of temporary variables for a short time span. This
    means that they are not going to be needed within a couple of statements of the
    variables being initialized. Take the following piece of code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 清道夫会检查新分配的对象，看看是否有任何准备清理的对象。大多数时候，我们的代码将被编写为在短时间内使用大量临时变量。这意味着它们在初始化变量的几个语句之后将不再需要。看下面的代码片段：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this hypothetical example, we want to get objects and clone them if they
    are marked for some procedure. We gather the ones that we want and the rest are
    now unused. The scavenger would notice a couple of things. First, it would seem
    that we are no longer using the old list, so it would automatically collect this
    memory. Second, it would notice that we have a bunch of unused object pointers
    (except for primitive types in JavaScript, everything is passed by reference)
    and it can clean these up.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个假设的例子中，我们想获取对象并在它们标记为某个过程时对它们进行克隆。我们收集我们想要的对象，其余的现在没有用了。清道夫会注意到几件事情。首先，它似乎我们不再使用旧列表，所以它会自动收集这些内存。其次，它会注意到我们有一堆未使用的对象指针（除了JavaScript中的原始类型，其他都是按引用传递的），它可以清理这些。
- en: This is a quick process and it gets either intertwined in our runtime, known
    as stop-and-go garbage collection, or it will run in parallel to our code, meaning
    that it will run at the exact same time in another thread of execution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个快速的过程，它要么交织在我们的运行时中，称为停止-继续垃圾回收，要么会在与我们的代码并行运行，这意味着它将在另一个执行线程中的确切时间运行。
- en: The Mark-Compact garbage collection runs for much longer but collects a lot
    more memory. It will go through the list of items that are currently still in
    the heap and see whether there are zero references to these items. If there are
    no more references, it will remove these objects from the heap. It will then try
    to compact all of the holes that are in the heap so that way, we do not have highly
    fragmented memory. This is especially useful for things such as arrays.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 标记-压缩垃圾收集运行时间更长，但收集的内存更多。它将遍历当前仍在堆中的物品列表，并查看这些物品是否有零引用。如果没有更多的引用，它将从堆中删除这些对象。然后它将尝试压缩堆中的所有空隙，这样我们就不会有高度碎片化的内存。这对于诸如数组之类的东西特别有用。
- en: Arrays are contiguous in memory, so if the V8 engine can find a hole big enough
    for the array, then it will stick it there. Otherwise, it may have to grow the
    heap and allocate more memory for our runtime. This is what the Mark-Compact GC
    is trying to prevent from happening.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在内存中是连续的，所以如果V8引擎能找到足够大的空间来放置数组，它就会放在那里。否则，它可能需要扩展堆并为我们的运行时分配更多内存。这就是标记-压缩GC试图防止发生的事情。
- en: While a full understanding of how the garbage collector works is not needed
    in order to write highly performant JavaScript, a good understanding will go a
    long way into writing code that is not only easy to read but also performs well
    in the environment that you are using.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不需要完全了解垃圾收集器的工作方式才能编写高性能的JavaScript，但对它有一个良好的理解将有助于编写不仅易于阅读而且在你使用的环境中表现良好的代码。
- en: If you want to understand more about the V8 garbage collector, I would recommend
    going to the site at [https://v8.dev/blog](https://v8.dev/blog). It is always
    interesting to see how the V8 engine is working and how new optimizations lead
    to certain coding styles being more performant than they may have been in the
    past, such as the map function for arrays.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于V8垃圾收集器的信息，我建议你去这个网站[https://v8.dev/blog](https://v8.dev/blog)。看到V8引擎是如何工作的，以及新的优化如何导致某些编码风格比过去更高效，比如数组的map函数，总是很有趣。
- en: We did not go into full detail regarding the Performance tab, but this should
    give a good overview of how to utilize it when testing code. It should also showcase
    some of the internal workings of Chrome and the garbage collector.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有详细介绍性能选项卡，但这应该给出了如何在测试代码时利用它的一个很好的概述。它还应该展示了Chrome的一些内部工作和垃圾收集器。
- en: There will be more discussion in the next section on memory, but it is highly
    recommended to run some tests against a current code base and notice what the
    performance is like when running these applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节关于内存的讨论中将会有更多内容，但强烈建议对当前的代码库运行一些测试，并注意在运行这些应用程序时性能如何。
- en: Chrome – an in-depth look at the Memory tab
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chrome-深入了解内存选项卡
- en: As we move from the performance section to the memory section, we will revisit
    a good number of concepts from the performance tool. The V8 engine provides a
    great amount of support for developing applications that are both efficient in
    terms of CPU usage and also memory usage. A great way to test your memory usage
    and where it is being allocated is the memory profiling tool.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从性能部分转移到内存部分时，我们将重新审视性能工具中的许多概念。V8引擎为开发既在CPU使用效率方面又在内存使用效率方面高效的应用程序提供了大量支持。测试内存使用情况以及内存分配位置的一个很好的方法是内存分析工具。
- en: 'With the latest version of Chrome at the time of writing, the memory profiler
    appears as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时的最新版本的Chrome中，内存分析器显示如下：
- en: '![](assets/7e5b2bb5-9bfe-447f-aa66-0109c9e6bcc9.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7e5b2bb5-9bfe-447f-aa66-0109c9e6bcc9.png)'
- en: We will mainly be focusing on the first option that is selected, the Heap snapshot
    tool. The Allocation instrumentation on timeline tool is a great way to visualize
    and playback how the heap was being allocated and which objects were causing the
    allocations to occur. Finally, the Allocation sampling tool takes periodic snapshots
    instead of providing a continuous look, making it much lighter and able to perform
    memory tests while cumbersome operations are conducted.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要将关注被选中的第一个选项，即堆快照工具。时间轴上的分配仪表盘是可视化和回放堆是如何被分配的以及哪些对象导致分配发生的一个很好的方法。最后，分配抽样工具会定期进行快照，而不是提供连续的查看，使其更轻便，并能够在进行繁重操作时执行内存测试。
- en: The heap snapshot tool will allow us to see where memory is being allocated
    on the heap. From our previous example, let's run the heap snapshot tool (if you
    have not commented out the `for` loop that allocated 10,000 more DOM nodes, comment
    it out now). After the snapshot has run, you should get a table with a tree view
    on the left-hand side. Let's go looking for one of the *global* items that we
    are able to get to in the console.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 堆快照工具将允许我们看到堆上内存的分配位置。从我们之前的例子中，让我们运行堆快照工具（如果你还没有注释掉分配了10,000个DOM节点的`for`循环，现在注释掉它）。快照运行后，你应该会得到一个左侧有树形视图的表格。让我们去寻找在控制台中能够访问到的*global*物品之一。
- en: We currently have items grouped by what they are or who they belong to. If we
    open up the (closure) list, we can find the `runTemplate()` function being held
    there. If we go into the (string) list, we can find the strings that were used
    to create our list. A question that may be raised is why some of these items are
    still being held on the heap even though we no longer need them. Well, this goes
    back to how the garbage collector works and who is currently referencing these
    items.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前按它们是什么或者它们属于谁来分组物品。如果我们打开（闭包）列表，我们可以找到`runTemplate()`函数被保存在那里。如果我们进入（字符串）列表，我们可以找到用来创建我们列表的字符串。一个可能提出的问题是为什么一些这些物品仍然被保存在堆上，即使我们不再需要它们。嗯，这涉及到垃圾收集器的工作方式以及谁当前正在引用这些物品。
- en: 'Take a look at the list items that are currently being held in memory. If you
    click on each of them, it shows us they are being referenced by `loopEls`. If
    we head back into our code, it can be noted that the only line of code that we
    use, `loopEls`, is in the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 查看当前存储在内存中的列表项。如果您点击每个列表项，它会显示它们被`loopEls`引用。如果我们回到我们的代码，可以注意到我们使用的唯一一行代码`loopEls`在以下位置：
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Take this out and put the basic `for` loop back in. Run the heap snapshot and
    go back into the (strings) section. These strings are no longer there! Let''s
    change the code one more time using the `map` function, but this time let''s not
    use the bind function to create a new function. The code should look like the
    following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将其移除并将基本的`for`循环放回。运行堆快照并返回(strings)部分。这些字符串不再存在！让我们再次更改代码，使用`map`函数，但这次不使用bind函数创建新函数。代码应该如下所示：
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, run a heap snapshot after changing out the code and we will notice that
    those strings are no longer there. An astute reader will notice that there is
    an error in the code from the first run; the `loopEls` variable does not have
    any variable type prefix added to it. This has caused the `loopEls` variable to
    go onto the global scope, which means that the garbage collector cannot collect
    it, since the garbage collector thinks that the variable is still in use.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 再次更改代码后运行堆快照，我们会注意到这些字符串不再存在。敏锐的读者会注意到第一次运行中代码存在错误；`loopEls`变量没有添加任何变量类型前缀。这导致`loopEls`变量进入全局范围，这意味着垃圾收集器无法收集它，因为垃圾收集器认为该变量仍在使用中。
- en: Now, if we turn our attention to the first item in this list, we should observe
    that the entire template string is still being held. If we click on that element,
    we will notice that it is being held by the `template` variable. However, we may
    state that since the variable is a constant, it should automatically be collected.
    Again, the V8 compiler does not know this and has put it on the global scope for
    us.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们把注意力转向列表中的第一项，我们应该观察到整个模板字符串仍然被保留。如果我们点击该元素，我们会注意到它被`template`变量所持有。然而，我们可以说，由于该变量是一个常量，它应该自动被收集。再次说明，V8编译器不知道这一点，已经将它放在全局范围内。
- en: 'There are two ways that we can fix this issue. First, we can use the old-school
    technique and wrap it in an **Immediately Invoked Function Expression** (**IIFE**),
    which would look like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式解决这个问题。首先，我们可以使用老式技术，并将其包装在**立即调用的函数表达式**（**IIFE**）中，如下所示：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Or, if we wanted to and were writing our application only for browsers that
    support it, we could change the script type to a type of `module`. Both of these
    solutions make sure that our code is not now globally scoped. Let's put our entire
    code base in an IIFE since that is supported across all browsers. If we run a
    heap dump, we will see that that string is no longer there.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们愿意并且正在为支持它的浏览器编写我们的应用程序，我们可以将脚本类型更改为`module`类型。这两种解决方案都确保我们的代码现在不再是全局范围的。让我们将整个代码库放在IIFE中，因为这在所有浏览器中都受支持。如果我们运行堆转储，我们会看到那个字符串不再存在。
- en: 'Finally, the last area that should be touched on is the working set of heap
    space and the amount it actually has allocated. Add the following line to the
    top of the HTML file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应该触及的最后一个领域是堆空间的工作集和实际分配的数量。在HTML文件的顶部添加以下行：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is a simple file that adds itself to the window to act as a library. Then,
    we are going to test two scenarios. First, run the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的文件，它将自身添加到窗口以充当库。然后，我们将测试两种情况。首先，运行以下代码：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, go to the performance section and check out the two numbers that are being
    displayed. If need be, go ahead and hit the garbage can. This causes the major
    garbage collector to run. It should be noted that the left-hand number is what
    is currently being used, and the right-hand number is what has been allocated.
    This means that the V8 engine has allocated around 6-6.5 MB of space for the heap.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到性能部分，查看显示的两个数字。如果需要，可以点击垃圾桶。这会导致主要的垃圾收集器运行。应该注意左边的数字是当前使用的，右边的数字是已分配的。这意味着V8引擎为堆分配了大约6-6.5
    MB的空间。
- en: 'Now, let''s run the code in a similar fashion, but let''s break each of these
    runs into their own loops, like the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以类似的方式运行代码，但让我们将每个运行分解成它们自己的循环，如下所示：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Check the Performance tab again. The memory should be around 7 MB. Go ahead
    and click the trash can and it should drop back down to 5.8 MB, or around where
    the baseline heap should be at. What did this show us? Well, since it had to allocate
    items for each of those variables in the first `for` loop, it had to increase
    its heap space. Even though it only ran it once and the minor garbage collector
    should have collected it, it is going to keep that heap space due to heuristics
    built into the garbage collector. Since we decided to do that, the garbage collector
    will keep more memory in the heap because we are more than likely going to keep
    repeating that behavior in the short term.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 再次检查性能选项卡。内存应该在7 MB左右。点击垃圾桶，它应该降到5.8 MB左右，或者接近基线堆应该在的位置。这给我们展示了什么？由于它必须为第一个`for`循环中的每个变量分配项目，它必须增加其堆空间。即使它只运行了一次，次要垃圾收集器应该已经收集了它，但由于垃圾收集器内置的启发式，它将保留该堆空间。由于我们决定这样做，垃圾收集器将保留更多的堆内存，因为我们很可能会在短期内重复这种行为。
- en: Now, with the second set of code, we decided to use a bunch of `for` loops and
    only allocate a single variable at a time. While this may be slower, V8 saw that
    we were only allocating small chunks of space and that it could decrease the size
    of the main heap because we are more than likely to keep up the same behavior
    in the near future. The V8 system has a bunch of heuristics built into the system
    and it will try and guess what we are going to do based on what we have done in
    the past. The heap allocator can help show us what the V8 compiler is going to
    do and what our coding pattern is most like in terms of memory usage.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于第二组代码，我们决定使用一堆`for`循环，每次只分配一个变量。虽然这可能会慢一些，V8看到我们只分配了小块空间，因此可以减少主堆的大小，因为我们很可能会在不久的将来保持相同的行为。V8系统内置了许多启发式规则，并且它会尝试根据我们过去的行为来猜测我们将要做什么。堆分配器可以帮助我们了解V8编译器将要做什么，以及我们的编码模式在内存使用方面最像什么。
- en: Go ahead and keep playing with the memory tab and add code in. Take a look at
    popular libraries (try to keep them small so you can track the memory allocations)
    and notice how they decided to write their code and how that causes the heap allocator
    to retain objects in memory and even keep a larger heap size around.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 继续玩内存标签，并添加代码。看看流行的库（尝试保持它们小，以便跟踪内存分配），注意它们决定如何编写代码以及它如何导致堆分配器在内存中保留对象，甚至保持更大的堆大小。
- en: It is generally good practice for a multitude of reasons, but writing small
    functions that do one thing very well is also great for the garbage collector.
    It will base its heuristics on the fact that a coder is writing these tiny functions
    and will decrease the overall heap space it will keep around. This, in turn, will
    cause the memory footprint of the application to also go down. Remember, it is
    not the working set size (the left-hand number) but the total heap space (the
    right-hand number) that is our memory usage.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，编写小函数有很多好处，但编写做一件事情非常出色的小函数对于垃圾收集器也非常有益。它将根据编码人员编写这些小函数的事实来制定启发式规则，并减少总体堆空间。这反过来会导致应用程序的内存占用也减少。请记住，我们的内存使用情况不是工作集大小（左侧数字），而是总堆空间（右侧数字）。
- en: Chrome – an in-depth look at the Rendering tab
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chrome-深入了解渲染标签
- en: The last section that we will look at in the developer tools is going to be
    the rendering section. This is usually not a default tab that is available. In
    the toolbar, you will notice a three-dot button next to the Close button. Click
    that, go to More tools, and click the Rendering option.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在开发者工具中查看的最后一个部分将是渲染部分。这通常不是一个默认可用的标签。在工具栏中，您会注意到关闭按钮旁边有一个三点按钮。点击它，转到更多工具，然后点击渲染选项。
- en: 'There should now be a tabbed item next to the Console tab that looks like the
    following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该有一个标签项，靠近控制台标签，看起来像下面这样：
- en: '![](assets/070e6696-33c3-4f22-95e2-bdc511c9e190.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/070e6696-33c3-4f22-95e2-bdc511c9e190.png)'
- en: 'This tab can showcase a few items that we will be interested in when we are
    developing applications:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标签可以展示一些我们在开发应用程序时感兴趣的项目：
- en: First, when developing an application that is going to have a lot of data or
    a lot of eventing, it is suggested having the FPS meter turned on. This will not
    only let us know if our GPU is being utilized, but it will also show us if we
    are dropping frames due to constant repainting.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在开发一个将有大量数据或大量事件的应用程序时，建议打开FPS计量器。这不仅可以让我们知道我们的GPU是否被利用，还可以告诉我们是否由于不断重绘而丢失帧数。
- en: Second, if we are developing an application that has a lot of scrolling (think
    of the infinite scrolling applications), then we will want to turn on the Scrolling
    performance issues section. This can notify us if there is an item or items in
    our application that can make the scrolling experience unresponsive.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，如果我们正在开发一个有大量滚动的应用程序（考虑无限滚动的应用程序），那么我们将希望打开滚动性能问题部分。这可以通知我们，如果我们的应用程序中有一个或多个项目可能会导致滚动体验不流畅。
- en: Finally, the Paint flashing option is great to see when there is a lot of dynamic
    content in our application. It will flash when a paint event has occurred and
    it will highlight the section that had to be repainted.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，绘制闪烁选项非常适合在我们的应用程序中有大量动态内容时使用。当发生绘制事件时，它会闪烁，并突出显示必须重新绘制的部分。
- en: 'We are going to go through an application that is going to cause problems for
    most of these settings and see how we can improve the performance to make the
    user experience better. Open up the following file: `chrome_rendering.html`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个应用程序，这个应用程序将会对大多数这些设置造成问题，并看看我们如何提高性能以改善用户体验。打开以下文件：`chrome_rendering.html`。
- en: We should see a box in the top-left corner switching colors. If we turn on the
    **Paint flashing** option, we should now see a green box appearing whenever the
    box color changes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到左上角有一个方框在变换颜色。如果我们打开**绘制闪烁**选项，现在每当方框颜色改变时，我们应该看到一个绿色方框出现。
- en: 'This makes sense. Every time we recolor something, this means that the renderer
    has to repaint that location. Now, uncomment the following lines:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有道理的。每次重新着色时，这意味着渲染器必须重新绘制该位置。现在取消以下行的注释：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We should see elements being added at an interval of around 1 second. A couple
    of things are interesting. First, we still see that we are getting repainting
    done on the box that colors itself every second or so. But, on top of this, we
    will notice that the scrollbar is repainting itself. This means that the scrollbar
    is part of the rendering surface (some of you may know this since you can target
    scrollbars with CSS). But, what is also interesting is that when each element
    is added, it is not having to repaint the entire parent element; it is only painting
    where the child is being added.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到大约每隔1秒添加一个元素。有几件事情很有趣。首先，我们仍然看到每秒或更长时间自行着色的框被重新绘制。但是，除此之外，我们会注意到滚动条也在重新绘制自己。这意味着滚动条是渲染表面的一部分（有些人可能知道这一点，因为你可以用CSS来定位滚动条）。但同样有趣的是，当每个元素被添加时，它不必重新绘制整个父元素；它只在添加子元素的地方进行绘制。
- en: 'So, a good question now would be: What happens if we prepend an element to
    our document? Comment out the lines of code that are changing the DOM and uncomment
    the following lines of code to see this in action:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，一个很好的问题是：如果我们在文档中添加一个元素会发生什么？注释掉正在改变DOM的代码行，并取消注释以下代码行以查看其效果：
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We can see that around five seconds into the lifetime of the document, both
    the element that we added and the red box that is sitting there have been repainted.
    Again, this makes sense. Chrome has to repaint anything that has changed when
    an update occurred. In terms of what our window looks like, this means it had
    to change the location of the box, and add in the text we added at the top, causing
    a repaint of both items.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，在文档的生命周期中大约五秒钟后，我们添加的元素和那个红色框都被重新绘制了。这是有道理的。Chrome必须重新绘制任何发生变化的东西。就我们的窗口外观而言，这意味着它必须改变框的位置，并添加我们在顶部添加的文本，导致两个项目都被重新绘制。
- en: Now, an interesting thing that we can look at is what happens if we make the
    element absolutely positioned with CSS. This would mean, in terms of what we see,
    that only the top portion of the rectangle and our text element should need a
    repaint. But, if we do this by making the position absolute, we will still see
    that Chrome had to repaint both elements.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到一个有趣的事情，那就是如果我们用CSS将元素绝对定位会发生什么。这意味着，就我们所看到的而言，只有矩形的顶部部分和我们的文本元素需要重新绘制。但是，如果我们通过将位置设置为绝对来做到这一点，我们仍然会看到Chrome不得不重新绘制两个元素。
- en: Even if we change the line `document.body.prepend` to `document.body.append`,
    it will still paint both objects. Chrome has to do this because the box is one
    DOM object. It cannot repaint only parts of objects; it has to repaint the entire
    object.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们将`document.body.prepend`改为`document.body.append`，它仍然会同时绘制两个对象。Chrome必须这样做，因为框是一个DOM对象。它无法只重绘对象的部分；它必须重绘整个对象。
- en: A good thing to always remember is that when changing something in the document,
    what is it causing to reflow or repaint? Is adding a list item also causing other
    elements to move, change color, and so on? If it does, we may have to rethink
    our content hierarchy so we can ensure that we are causing the minimum amount
    of repainting in our document.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个要记住的好事是，当改变文档中的某些内容时，它会导致重新布局或重绘吗？添加一个列表项是否也会导致其他元素移动、改变颜色等？如果是，我们可能需要重新考虑我们的内容层次结构，以确保我们在文档中引起最少的重绘。
- en: A final note on painting. We should see how painting works with the canvas element.
    The canvas element allows us to create 2D and 3D imagery through the 2D rendering
    context, or through the WebGL context. We will specifically focus on the 2D rendering
    context, but it should be noted that these rules also apply with the WebGL context.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 关于绘画的最后一点。我们应该看看画布元素是如何工作的。画布元素允许我们通过2D渲染上下文或WebGL上下文创建2D和3D图像。我们将专门关注2D渲染上下文，但应该注意这些规则也适用于WebGL上下文。
- en: 'Go ahead and comment out all of the code we have added so far and uncomment
    the following lines:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 继续注释掉我们迄今为止添加的所有代码，并取消注释以下代码行：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After about two seconds, we should see the addition of a green box to our little
    diagonal group of squares. What is interesting about this paint is that it only
    showed us a repaint for that little green square. Let''s comment out that piece
    of code and add in the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大约两秒后，我们应该看到一个绿色框被添加到我们小的对角线方块组中。这种绘画方式有趣的地方在于它只显示了对那个小绿色方块的重新绘制。让我们注释掉那段代码，并添加以下代码：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At intervals of about 1 second, we will see that it is truly only repainting
    where we say to paint. This can have huge implications for applications that need
    to be constantly changing the information that is on the page. If we find that
    we need to have something constantly update, it can actually be better to have
    it done in a canvas than to have it in the DOM. While the canvas API may not lend
    itself to being a rich environment, there are libraries out there that help with
    this.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 大约每隔1秒，我们会看到它真正只在我们指定的位置进行重新绘制。这对于需要不断改变页面上的信息的应用程序可能会产生重大影响。如果我们发现需要不断更新某些内容，实际上在画布中完成可能比在DOM中更好。虽然画布API可能不适合成为一个丰富的环境，但有一些库可以帮助解决这个问题。
- en: It is not suggested that every application out there is going to need the repainting
    capabilities of the canvas; it should be noted that most will not. However, every
    piece of technology that we talk through in this book is not going to solve 100%
    of the issues found in applications. One such issue is repainting problems and
    this can be solved with canvas-based solutions. Areas that the canvas is especially
    useful for are graphing and grid-based applications.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是每个应用都需要画布的重绘能力，大多数应用都不需要。然而，我们在本书中讨论的每一种技术都不会解决应用程序中发现的100%的问题。其中一个问题是重绘问题，这可以通过基于画布的解决方案来解决。画布特别适用于绘图和基于网格的应用程序。
- en: We will now look at the scroll option. This can help us when we have a long
    list of items. This may be in a tree-view, in an infinite scrolling application,
    or even in a grid-based application. At some point, we are going to run into serious
    slowdowns due to trying to render thousands of elements at a single time.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看一下滚动选项。当我们有一个很长的项目列表时，这可以帮助我们。这可能是在树视图中，在无限滚动应用程序中，甚至在基于网格的应用程序中。在某些时候，由于尝试一次渲染数千个元素，我们将遇到严重的减速问题。
- en: 'First, let''s render 1,000,000 paragraph elements into our application with
    the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下代码将1,000,000个段落元素渲染到我们的应用程序中：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While this may not seem like a real-world scenario, it does showcase how unfeasible
    infinitely loaded applications would be to run if we had to add everything to
    the DOM right away. So how would we handle this scenario? We would use something
    called deferred rendering. Essentially, we will have all of our objects in memory
    (in this case; for other use cases, we would continually make rest requests for
    more data) and we will add them as they should appear on the screen. We will need
    some code to do this.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来不像一个真实的场景，但它展示了如果我们必须立即将所有内容添加到DOM中，无限加载的应用程序将会变得不可行。那么我们该如何处理这种情况呢？我们将使用一种称为延迟渲染的东西。基本上，我们将把所有对象保存在内存中（在这种情况下；对于其他用例，我们将不断地为更多数据进行REST请求），并且我们将按照它们应该出现在屏幕上的顺序添加它们。我们需要一些代码来实现这一点。
- en: The following example is by no means a foolproof way of implementing deferred
    rendering. As with most of the code in this book, it takes a simple view to try
    to showcase a point. It can easily be built upon to create a real-world system
    for deferred rendering, but it is not something that should be copied and pasted.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例绝不是实现延迟渲染的一种可靠方式。与本书中的大多数代码一样，它采用了一个简单的视图来展示一个观点。它可以很容易地进行扩展，以创建一个延迟渲染的真实系统，但这不是应该被复制和粘贴的东西。
- en: A good way to start deferred rendering is to know how many elements we are going
    to have, or at least want to showcase in our list. For this, we are going to use
    a height of 460 pixels. On top of this, we are going to set our list elements
    to have a padding of 5 pixels and to be a height of 12 pixels with a 1-pixel border
    on the bottom. This means that each element will have a total height of 23 pixels.
    This would also mean that the number of elements that can be seen at one time
    is 20 (460 / 23).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 开始延迟渲染的一个好方法是知道我们将拥有多少元素，或者至少想要在我们的列表中展示多少元素。为此，我们将使用460像素的高度。除此之外，我们将设置我们的列表元素具有5像素的填充，并且高度为12像素，底部有1像素的边框。这意味着每个元素的总高度为23像素。这也意味着一次可以看到20个元素（460
    / 23）。
- en: 'Next, we set the height of our list by multiplying the number of items we have
    by the height of each item. This can be seen in the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过将我们拥有的项目数量乘以每个项目的高度来设置列表的高度。这可以在以下代码中看到：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we need to hold our index that we are currently at (the current 20 items
    on the screen) and measure when we get a scroll event. If we notice that we are
    above the threshold, we move to a new index and reset our list to hold that group
    of 20 elements. Finally, we set the top padding of our unordered list to the total
    height of the list minus what we have already scrolled by.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要保存我们当前所在的索引（屏幕上当前的20个项目），并在发生滚动事件时进行测量。如果我们注意到我们在阈值以上，我们就会移动到一个新的索引，并重置我们的列表以保存那组20个元素。最后，我们将无序列表的顶部填充设置为列表的总高度减去我们已经滚动的部分。
- en: 'All of this can be seen in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以在以下代码中看到：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So now that we have all of this, what do we put this function inside of? Well,
    since we are scrolling, logically, it would make sense to put it in the scroll
    handler of the list. Let''s do that with the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们拥有了所有这些，我们把这个函数放在什么地方呢？嗯，既然我们在滚动，逻辑上来说，把它放在列表的滚动处理程序中是有意义的。让我们用以下代码来做到这一点：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let's turn on the **Scrolling performance issues** option. If we reload
    the page, we will notice that it is highlighting our list and stating that the
    `mousewheel` event could be a potential bottleneck. This makes sense. Chrome notices
    that we are attaching a non-trivial piece of code to run on each wheel event so
    it shows us that we are going to potentially have issues.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开**滚动性能问题**选项。如果我们重新加载页面，我们会注意到它正在突出显示我们的列表，并声明`mousewheel`事件可能成为潜在的瓶颈。这是有道理的。Chrome注意到我们在每次滚动事件上附加了一个非平凡的代码片段，因此它向我们显示我们可能会有问题。
- en: 'Now, if we are on a regular desktop, we will most likely not have any issues,
    but if we add the following code, we can easily see what Chrome is trying to tell
    us:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在常规桌面上，很可能不会有任何问题，但是如果我们添加以下代码，我们可以很容易地看到Chrome试图告诉我们的内容：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With that piece of code inside the wheel event, we can see the stuttering happen.
    Since we can now see stuttering and it being a potential bottleneck for scrolling,
    what's the next best option? Putting it in a `setInterval`, using `requestAnimationFrame`,
    or even using `requestIdleCallback`, with the last being the least optimal solution.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们可以看到滚动时出现了卡顿。既然我们现在能看到卡顿，并且它可能成为滚动的潜在瓶颈，下一个最佳选择是什么？将其放入`setInterval`中，使用`requestAnimationFrame`，甚至使用`requestIdleCallback`，最后一个是最不理想的解决方案。
- en: The Rendering tab can help flesh out quite a few issues that can crop up inside
    our applications and should become a regular tool for developers to figure out
    what is causing stuttering or performance problems in their applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染选项卡可以帮助解决应用程序中可能出现的许多问题，并且应该成为开发人员经常使用的工具，以找出是什么导致了应用程序的卡顿或性能问题。
- en: These three tabs can help diagnose most problems and should be used quite frequently
    when developing an application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个选项卡可以帮助诊断大多数问题，并且在开发应用程序时应该经常使用。
- en: jsPerf and benchmarking
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jsPerf和基准测试
- en: We have come to the last section regarding high performance for the web and
    how we can easily assess whether our application is performing at peak efficiency.
    However, there are times when we are going to want to actually do true benchmarking,
    even if this may not give the best picture. jsPerf is one of these tools.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经来到了关于网络高性能的最后一节，以及我们如何轻松评估我们的应用程序是否以最佳效率运行。然而，有时我们会想要真正进行基准测试，即使这可能不会给出最好的结果。jsPerf就是这样的工具之一。
- en: Now, great care has to be taken when creating a jsPerf test. First, we can run
    into optimizations that the browser does and that may skew results in favor of
    one implementation versus another. Next, we have to make sure that we run these
    tests in multiple browsers. As explained in a previous section, every browser
    runs a different JavaScript engine and this means that the creators have implemented
    them all differently. Finally, we need to make sure that we do not have any extraneous
    code in our tests, otherwise, the results can be skewed.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建jsPerf测试时必须非常小心。首先，我们可能会遇到浏览器进行的优化，这可能会使结果偏向于某种实现而不是另一种。接下来，我们必须确保在多个浏览器中运行这些测试。如前一节所述，每个浏览器都运行不同的JavaScript引擎，这意味着创建者们对它们进行了不同的实现。最后，我们需要确保在我们的测试中没有任何多余的代码，否则结果可能会被扭曲。
- en: 'Let''s look at a couple of scripts and see how they turn out based on running
    them inside jsPerf. So, let''s begin:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些脚本，并根据在jsPerf中运行它们的结果来看看它们的效果。所以，让我们开始：
- en: Head on over to [https://jsperf.com](https://jsperf.com). If we want to create
    our own tests, we will have to sign in with our GitHub account, so go ahead and
    do this now.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://jsperf.com](https://jsperf.com)。如果我们想创建自己的测试，我们将需要使用GitHub账户登录，所以现在就去做吧。
- en: 'Next, let''s create our first performance test. The system is self-explanatory,
    but we will go over a couple of areas:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的第一个性能测试。系统是不言自明的，但我们将讨论一些方面：
- en: First, if we needed to add in some HTML code so that we could perform DOM manipulation,
    we would put this in the *preparation code HTML* section.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，如果我们需要添加一些HTML代码，以便进行DOM操作，我们会将其放在*准备代码HTML*部分。
- en: Next, we will put in any variables that we will need in all of our tests.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将输入我们所有测试中需要的任何变量。
- en: Finally, we can incorporate our test cases. Let's run a test.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以整合我们的测试用例。让我们运行一个测试。
- en: The first test we will look at is utilizing a loop versus utilizing the `filter`
    function. We will not require any HTML for this, so we can leave this section
    blank.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先查看的测试是利用循环与利用“filter”函数。对于这个测试，我们不需要任何HTML，所以我们可以将这一部分留空。
- en: 'Next, we will input the following code that will be needed by all of our test
    cases:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将输入所有测试用例都需要的以下代码：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we will add in two different test cases, the `for` loop and the `filter`
    function. They should look like the following:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加两个不同的测试用例，“for”循环和“filter”函数。它们应该如下所示：
- en: 'In the case of the loop:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于循环的情况：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the case of the filter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于filter的情况：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we can save the test case and run the performance tester. Go ahead and
    hit the Run button and watch as the test runner goes over each piece of code multiple
    times. We should see something like the following:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以保存测试用例并运行性能测试器。点击运行按钮，观察测试运行器多次检查每段代码。我们应该看到如下内容：
- en: '![](assets/d23c88f7-5965-4ad3-b737-2f64b53dbe34.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d23c88f7-5965-4ad3-b737-2f64b53dbe34.png)'
- en: 'Well, as expected, the `for` loop performed better than the `filter` function.
    The breakdown of those three numbers on the right is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，正如预期的那样，“for”循环的性能优于“filter”函数。右侧的这三个数字的分解如下：
- en: The number of operations per second, or how many basic instructions the system
    could run in a single second.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒操作次数，或者系统在一秒内可以运行多少基本指令。
- en: The variance in each test run for that specific test case. In the case of the
    `for` loop, it was plus or minus 2 percent.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个特定测试用例的每次测试运行的差异。对于“for”循环，加减2%。
- en: Finally, it will say whether it was the fastest, or how much slower than that
    it was. In the case of the filter, it was 86 percent slower.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它会告诉我们它是否是最快的，或者比最快的慢了多少。对于filter，它慢了86%。
- en: Wow, that is quite significantly slower! In this case, we might think of a way
    for the filter to run more optimally. One way is that we might create the function
    ahead of time instead of creating an anonymous function. Near the bottom of our
    results, we will see a link for us to be able to add more tests. Let's head back
    into the test cases and add one for our new test.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这明显慢了很多！在这种情况下，我们可能会想出一种让filter运行更加高效的方法。一种方法是我们可以提前创建函数，而不是创建一个匿名函数。在我们的结果底部附近，我们将看到一个链接，可以让我们添加更多的测试。让我们回到测试用例中，为我们的新测试添加一个测试。
- en: 'Head near the bottom and there should be an **Add code snippet** button. Let''s
    press this and fill in the details. We will call this new code snippet `filterFunctionDefined`
    and it should look something like the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部附近应该有一个**添加代码片段**按钮。让我们点击这个按钮并填写细节。我们将称这个新的代码片段为`filterFunctionDefined`，它应该看起来像下面这样：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can save this test case and rerun our results. The results seem to be almost
    exactly like the regular `filter` function. Some of this is due to our browsers
    optimizing our code for us. We can test these results in all of the browsers so
    we can get a better picture of how our code would function in each. But, even
    if we did run this elsewhere, we will see that the results are the same; the `filter`
    function is slower than a regular `for` loop.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以保存这个测试用例并重新运行结果。结果似乎几乎与常规的“filter”函数完全相同。其中一些原因是我们的浏览器为我们优化了我们的代码。我们可以在所有浏览器中测试这些结果，以便更好地了解我们的代码在每个浏览器中的运行情况。但是，即使我们在其他地方运行这个测试，我们也会看到结果是一样的；“filter”函数比普通的“for”循环慢。
- en: This is true for pretty much every array-based function. Helper functions are
    great, but they are also slower than regular loops. We will go into greater detail
    in the next chapter, but just realize ahead of time that most of the convenience
    that the browser gives us is going to be slower than just writing the function
    in a more straightforward manner**.**
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于几乎每个基于数组的函数都是正确的。辅助函数很棒，但它们也比常规循环慢。我们将在下一章中详细介绍，但请提前意识到，浏览器提供给我们的大多数便利都会比直接以更简单的方式编写函数要慢。
- en: Let's set up another test just to make sure we understand jsPerf.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置另一个测试，只是为了确保我们理解jsPerf。
- en: First, create a new test. Let's perform a test on objects and see the difference
    between using a `for-in` loop versus a loop utilizing the `Object.keys()` method.
    Again, we will not need to utilize the DOM so we don't need to fill anything out
    for the HTML portion.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的测试。让我们对对象执行一个测试，并查看使用`for-in`循环与使用`Object.keys()`方法的差异。同样，我们不需要使用DOM，因此在HTML部分不需要填写任何内容。
- en: 'For our test setup, let''s create a blank object and then fill it with a bunch
    of useless data utilizing the following code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的测试设置，让我们创建一个空对象，然后使用以下代码填充它，其中包含一堆无用的数据：
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, let''s create two test cases, the first being call `for in`, which should
    appear as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建两个测试用例，第一个是调用`for in`，应该如下所示：
- en: '[PRE25]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second test case is the `Object.keys()` version, which appears as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试用例是`Object.keys()`版本，如下所示：
- en: '[PRE26]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, if we run our test, we will notice that the `keys` version is able to do
    around 600 operations per second, while the `fo..in` version is able to do around
    550\. This one is fairly close so browser difference may actually come into play.
    When we start to get into minor differences, it is best to choose whichever was
    implemented later or is most likely to get optimizations.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的测试，我们会注意到`keys`版本能够每秒执行大约600次操作，而`fo..in`版本能够每秒执行大约550次。这两者相差不大，因此浏览器的差异实际上可能会起作用。当我们开始出现轻微差异时，最好选择后来实现的或最有可能进行优化的选项。
- en: Most of the time, if something is just being implemented and the browser vendors
    agree to something being added, then it is probably in the early stages of development.
    If the performance results are within a tolerance that is allowed (usually around
    5-10% difference), then it is best to go with the newer option. It is more likely
    to be optimized in the future.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，如果某些东西只是被实现，并且浏览器供应商同意添加某些东西，那么它可能处于早期开发阶段。如果性能结果在允许的公差范围内（通常在5-10%的差异左右），那么最好选择更新的选项。它更有可能在未来进行优化。
- en: All of this testing is amazing, and if we find something that we truly want
    to share with people, this is a great solution. But, what if we wanted to run
    these tests ourselves and not have to worry about an external site? Well, we can
    utilize the underlying library that jsPerf is using. It is called *Benchmark.js*
    and it is a great utility when we need to set up our own system for debugging
    code. We can find it at [https://benchmarkjs.com/](https://benchmarkjs.com/).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些测试都很棒，如果我们找到了真正想与人们分享的东西，这是一个很好的解决方案。但是，如果我们想自己运行这些测试而不必担心外部网站怎么办呢？嗯，我们可以利用jsPerf正在使用的基础库。它被称为Benchmark.js，当我们需要为调试代码设置自己的系统时，它是一个很好的工具。我们可以在[https://benchmarkjs.com/](https://benchmarkjs.com/)找到它。
- en: Let's grab the source code and set it as an external script in our HTML file.
    We will also need to add *Lodash* as a dependency. Next, let's write the same
    tests that we wrote before, but we are going to write them in our internal script
    and have it display the results on our screen. We will also only have it display
    the title of our script along with these results.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取源代码，并将其设置为HTML文件中的外部脚本。我们还需要将*Lodash*添加为依赖项。接下来，让我们编写与之前相同的测试，但是我们将在内部脚本中编写它们，并在屏幕上显示结果。我们还将只显示我们脚本的标题以及这些结果。
- en: We can obviously make this a little fancier, but the focus will be on getting
    the library to properly benchmark for us.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然可以使这个更加花哨，但重点将是让库为我们正确地进行基准测试。
- en: 'We will have some setup code that will have an array of objects. These objects
    will have only two properties, the name of the test and the function that we want
    to run. In the case of our `for` loop versus our `filter` test, it would look
    like the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一些设置代码，其中将有一个对象数组。这些对象只有两个属性，测试的名称和我们想要运行的函数。在我们的`for`循环与`filter`测试的情况下，它看起来会像这样：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'From here, we set up a benchmark suite and loop through our tests, adding them
    to the suite. We then add two listeners, one for a complete cycle so we can display
    it in our list, and the other on completion, so we can highlight the fastest running
    entry. It should look like the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，我们设置了一个基准套件，并循环执行我们的测试，将它们添加到套件中。然后我们添加了两个监听器，一个用于完成循环，以便我们可以在列表中显示它，另一个用于完成，以便我们可以突出显示运行最快的条目。它应该如下所示：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If we set all of this up, or if we run `benchmark.html`, we will see the output.
    There are many other cool statistics that we can get from the benchmark library.
    One of these is the standard deviation for each test. In the case of the `for`
    loop test that was run in Edge, it came out to around 0.004\. Another interesting
    note is that we can look at each run and see the amount of time it took. Again,
    taking the `for` loop example, the Edge browser is slowly optimizing our code
    and also likely putting it into cache since the time keeps decreasing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们设置了所有这些，或者运行了`benchmark.html`，我们将看到输出。我们可以从基准库中获得许多其他有趣的统计数据。其中之一是每个测试的标准偏差。在Edge中运行的`for`循环测试的情况下，大约为0.004。另一个有趣的注释是我们可以查看每次运行所花费的时间。同样，以`for`循环为例，Edge浏览器正在慢慢优化我们的代码，并且很可能将其放入缓存，因为时间不断减少。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced many concepts for profiling and debugging our code.
    It took into account the various modern browsers that are out there and even the
    special features that each of them may or may not have. We specifically looked
    at the Chrome browser, since a good many developers use it as their main development
    browser. In addition to this, the V8 engine is used in Node.js, which means all
    of our Node.js code will use the V8 debugger. Finally, we took a look at utilizing
    jsPerf to find out what may be the best implementation of some piece of code.
    We even looked at the possibilities of running it in our own system and how we
    can implement this.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了许多用于分析和调试代码的概念。它考虑了各种现代浏览器，甚至考虑了它们可能具有或不具有的特殊功能。我们特别关注了Chrome浏览器，因为许多开发人员将其用作主要的开发浏览器。除此之外，V8引擎用于Node.js，这意味着我们所有的Node.js代码将使用V8调试器。最后，我们看了一下如何利用jsPerf来找出某段代码的最佳实现方式。我们甚至研究了在我们自己的系统中运行它的可能性以及如何实现这一点。
- en: Looking forward, the remainder of the book will not specifically talk about
    any of these topics in such detail again, but these tools should be used when
    developing the code for the rest of the book. On top of this, we will be running
    almost all of the code in the Chrome browser, except for when we write GLSL, since
    Firefox has one of the best components for actually testing this code out. In
    the next chapter, we will be looking at immutability and when we should utilize
    it in development.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 展望未来，本书的剩余部分将不再具体讨论这些主题，但在本书的其余部分开发代码时应该使用这些工具。除此之外，我们将几乎在Chrome浏览器中运行所有的代码，除了当我们编写GLSL时，因为Firefox拥有最好的组件来实际测试这些代码。在下一章中，我们将探讨不可变性以及在开发中何时应该利用它。
