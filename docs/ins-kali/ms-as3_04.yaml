- en: Device Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备开发
- en: Android Studio provides some very powerful layout tools, enabling us to quickly
    and easily experiment with and develop user interfaces. However, perhaps the biggest
    challenge any Android developer faces is the bewildering number of form factors
    their applications could run on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio提供了一些非常强大的布局工具，使我们能够快速轻松地尝试和开发用户界面。然而，任何Android开发人员面临的最大挑战可能是他们的应用程序可能在多种形态因素上运行的令人困惑的数量。
- en: We saw in previous chapters how classes, for example the constraint layout and
    libraries such as the percent library, help us design uniform and consistent layouts.
    However, these techniques only provide general solutions, and we will all have
    stumbled across apps that do not really seem to have been designed with our device
    in mind. With a little knowledge and effort, these design faults can easily be
    avoided.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中看到了一些类，例如约束布局和百分比库等，可以帮助我们设计统一和一致的布局。然而，这些技术只提供了一般解决方案，我们都会遇到一些似乎并没有真正考虑我们设备的应用程序。通过一点知识和努力，这些设计缺陷可以很容易地避免。
- en: 'In this chapter, you will learn to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: Create alternative layout files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建替代布局文件
- en: Extract string resources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取字符串资源
- en: Manage screen rotation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理屏幕旋转
- en: Configure resources
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置资源
- en: Create wearable UIs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可穿戴UI
- en: Build shape-aware layouts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建形状感知布局
- en: Read sensor data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取传感器数据
- en: Use virtual sensors
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟传感器
- en: Apply Studio's templates
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用Studio的模板
- en: Create a debug filter
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建调试过滤器
- en: Monitor devices
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视设备
- en: 'Before looking into how to develop our UIs so that they look great on all our
    users'' devices, we need to explore the most significant layout situation we will
    encounter: the rotation of a screen between portrait and landscape mode.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究如何开发我们的UI，使其在所有用户设备上都能看起来很棒之前，我们需要探索我们将遇到的最重要的布局情况：在纵向和横向模式之间旋转屏幕。
- en: Screen orientation
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕方向
- en: A large percentage of Android apps designed for phones and tablets are designed
    to work in both landscape and portrait mode and generally switch between these
    automatically. Many activities, such as videos, are best viewed in landscape mode,
    while lists are usually easier to scan in portrait; however, and there are some
    activities, and even entire apps, where the orientation is fixed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大量为手机和平板设计的Android应用程序都设计为在横向和纵向模式下都能工作，并且通常会自动在这两种模式之间切换。许多活动，比如视频，在横向模式下观看效果最佳，而列表通常在纵向模式下更容易扫描；然而，有一些活动，甚至整个应用程序，其方向是固定的。
- en: There are some layouts that look equally good, whichever way they are viewed,
    but this is not often the case; most of the time, we will want to design one for
    each orientation. Android Studio simplifies and speeds up this process by saving
    us the task of developing an alternative layout from scratch.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些布局无论以哪种方式查看都很好，但这并不经常发生；大多数情况下，我们都希望为每种方向设计一个布局。Android Studio通过为我们节省从头开始开发替代布局的任务，简化并加快了这个过程。
- en: 'Take a simple layout like the one here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以这里的简单布局为例：
- en: '![](img/b68e6b36-0318-4852-8875-94af4d3edc75.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b68e6b36-0318-4852-8875-94af4d3edc75.png)'
- en: A portrait layout
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 纵向布局
- en: 'A landscape variant can be created with a single click from the Layout Variant
    tool at the top of the design editor, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在设计编辑器顶部的布局变体工具中单击一次来创建横向变体，如下所示：
- en: '![](img/19fba689-187b-4295-83ce-8e0026bb9d00.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19fba689-187b-4295-83ce-8e0026bb9d00.png)'
- en: The Layout Variant tool.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 布局变体工具。
- en: If you recreate this exercise or create an equivalent of your own, you will
    soon see that a layout like this does not look good when just rotated, and you
    will have to reposition the views to best suit this aspect ratio. If you try this
    with a constraint layout, you will of discovered one of its few weaknesses, and
    the resultant layout can be quite a mess.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重新创建此练习或创建自己的等效练习，您很快会发现，这样的布局在旋转时看起来并不好，您将不得不重新调整视图以最适合这个纵横比。如果您尝试使用约束布局，您将发现它的一些弱点，而且最终的布局可能会非常混乱。
- en: Just how you recreate these layouts is down to your own artistic and design
    skills, but what is worth noting is the manner in which Android Studio stores
    and presents these files as this can be a little confusing, particularly if you
    are migrating from Eclipse, which manages this differently.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何重新创建这些布局取决于您自己的艺术和设计技能，但值得注意的是Android Studio存储和呈现这些文件的方式，这可能有点令人困惑，特别是如果您正在从管理方式不同的Eclipse迁移。
- en: 'If you open the project you just created in the Project Explorer, under Android
    you will find the landscape variant as `activity_main.xml (land)`, apparently
    inside the `activity_main.xml` directory. Studio presents it like this because
    it is convenient to have all our layouts in one place, but this is not how they
    are stored. Switching the Project Explorer to the Project view will display the
    actual file structure, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在项目资源管理器中打开刚刚创建的项目，在Android下，您将在`activity_main.xml (land)`中找到横向变体，显然在`activity_main.xml`目录中。Studio以这种方式呈现它，因为将所有布局放在一个地方很方便，但这并不是它们的存储方式。将项目资源管理器切换到项目视图将显示实际的文件结构，如下所示：
- en: '![](img/e32b1477-579f-4676-921e-8ac8adb9b3ce.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e32b1477-579f-4676-921e-8ac8adb9b3ce.png)'
- en: Project structure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 项目结构。
- en: This structure can also be determined from the navigation bar at the top of
    the IDE.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构也可以从IDE顶部的导航栏中确定。
- en: If you create layout variants like this, moving views into a more pleasing configuration,
    and give both versions the same ID, these will automatically animate between their
    two states when a user rotates their device. We will later see how to construct
    our own custom animations, but more often than not, the default animations are
    the best choice as they help promote a uniform user experience.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建类似这样的布局变体，将视图移动到更令人愉悦的配置，并为两个版本赋予相同的ID，当用户旋转其设备时，这些将自动在它们的两个状态之间进行动画。我们将在后面看到如何构建我们自己的自定义动画，但往往默认动画是最好的选择，因为它们有助于促进统一的用户体验。
- en: If you recreated the example above, you may have noticed a rather neat trick
    that the IDE performs to speed up the process of providing text resources.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新创建了上面的示例，你可能已经注意到IDE执行的一个非常巧妙的技巧，以加快提供文本资源的过程。
- en: You will already know that the use of hard-coded strings is strongly deprecated.
    Like many programming paradigms, Android development is designed so that data
    and code are created and worked on separately. Hard-coded strings also make translations
    nearly impossible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经知道，使用硬编码字符串是强烈不推荐的。像许多编程范式一样，Android开发旨在使数据和代码分开创建和处理。硬编码字符串也几乎不可能进行翻译。
- en: We saw previously how the quick-fix function allows us to automatically implement
    methods. Here, we can use it to create string resources without ever even having
    to open the `strings.xml` file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到快速修复功能如何让我们自动实现方法。在这里，我们可以使用它来创建字符串资源，甚至无需打开`strings.xml`文件。
- en: Simply enter a hard-coded string in your layout file and follow the quick-fix
    prompt to extract it as a string resource.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在布局文件中输入硬编码的字符串，然后按照快速修复提示将其提取为字符串资源。
- en: '![](img/b830abda-83eb-49a7-a67e-f1bcad19159f.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b830abda-83eb-49a7-a67e-f1bcad19159f.png)'
- en: String resource extraction.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串资源提取。
- en: The Layout Editor provides two ready made variants, landscape and extra large,
    but we can create variants of our own to suit any form factor we choose.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 布局编辑器提供了两个现成的变体，横向和超大，但我们可以创建适合任何形态因素的自定义变体。
- en: Now that we have started to add some dynamic elements such as screen rotation,
    the Layout Editor is not enough and we need to run our apps on a device or emulator.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经开始添加一些动态元素，比如屏幕旋转，布局编辑器已经不够用了，我们需要在设备或仿真器上运行我们的应用程序。
- en: Virtual devices
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟设备
- en: For a long time, **Android Virtual Devices** (**AVDs**) had the reputation of
    being buggy and horrendously slow. The introduction of hardware acceleration has
    made a big difference, but a powerful computer is still advised, especially if
    you want to run more than one at a time, which is very often the case.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间以来，Android虚拟设备（AVD）一直以有bug和运行极慢而闻名。硬件加速的引入带来了很大的改变，但仍建议使用一台性能强大的计算机，特别是如果你想同时运行多个AVD，这种情况经常发生。
- en: The biggest change to Android emulation is not hardware acceleration, but rather
    the appearance of alternative emulators. As we shall see shortly, some of these
    offer distinct advantages over the native emulator, but AVDs should not be written
    off. Despite the drawbacks, Android emulators are the only emulators that run
    on all Android versions, including the most recent, developer-only, versions.
    Not only this, but Android emulators are the most customizable and any possible
    hardware or software configuration can be recreated with a little effort.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Android仿真的最大变化不是硬件加速，而是替代仿真器的出现。正如我们将很快看到的，其中一些提供了与本机仿真器不同的优势，但AVD不应被忽视。尽管存在缺点，Android仿真器是唯一可以在所有Android版本上运行的仿真器，包括最新的仅供开发者使用的版本。不仅如此，Android仿真器是最可定制的，任何可能的硬件或软件配置都可以通过一点努力重新创建。
- en: Early on in the development process, it is important to be able to test out
    our ideas quickly and using one or two real-world devices is probably the best
    choice for this level of testing; however, sooner or later we are going to need
    to make sure that our layouts look great on all possible devices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程的早期阶段，能够快速测试我们的想法非常重要，使用一两个真实设备可能是最好的选择；然而，迟早我们需要确保我们的布局在所有可能的设备上看起来很棒。
- en: Layout and image qualification
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局和图像资格
- en: 'There are two issues that we need to consider here: screen density and aspect
    ratio. If you have done any Android development before, you will be aware of DPI
    and screen size groupings. These designated folders provide handy shortcuts to
    suit the enormous variety of available form factors, but we will all have experienced
    apps with layouts that don''t quite work on our devices. This is something that
    is entirely avoidable, and although countering it will take some effort on our
    part, it will result in avoiding those poor ratings that can so damage a revenue
    stream.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个问题需要考虑：屏幕密度和纵横比。如果你之前做过任何Android开发，你会了解DPI和屏幕大小分组。这些指定的文件夹提供了方便的快捷方式，以适应各种可用的形态因素，但我们都会遇到布局在我们设备上不太适用的应用。这是完全可以避免的，尽管我们需要付出一些努力来对抗它，但这将避免那些可能损害收入流的差评。
- en: It is very tempting to create an app that will work on as many form factors
    as possible, and Android Studio will occasionally encourage you to think that
    way. In reality we have to think about when and where devices are used. If we
    are waiting for a bus, then we probably want a game that is easily switched on
    and off and where tasks can be completed quickly. And although there are exceptions,
    these are not the same games that people choose to play on large screens for long
    periods. Picking the right platform is essential, and although it may sound counter-intuitive,
    it is often wiser to exclude a platform than just assume it may earn a little
    more revenue.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易产生一个能在尽可能多的形态因素上运行的应用程序的诱惑，而Android Studio偶尔会鼓励你这样思考。实际上，我们必须考虑设备的使用时间和地点。如果我们在等公交车，那么我们可能想要一个可以轻松开关并且可以快速完成任务的游戏。尽管也有例外，但这些不是人们选择在大屏幕上长时间玩耍的游戏。选择正确的平台是至关重要的，尽管这可能听起来违反直觉，但通常排除一个平台比仅仅假设它可能赚取更多收入更明智。
- en: Bearing this in mind, we will consider an app designed only for phones and tablets;
    however as well as looking at familiar features such as screen size and density,
    we will see how we can provide customized resources for many other configuration
    issues.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们将考虑一个仅设计用于手机和平板电脑的应用程序；然而，除了查看屏幕大小和密度等熟悉的功能之外，我们还将看到如何为许多其他配置问题提供定制资源。
- en: The two most commonly used resource designations are screen size and density.
    Android provides the following four size designations.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的资源指定是屏幕大小和密度。Android提供了以下四种大小指定。
- en: '`layout-small`: from two to four inches, 320 x 420dp or larger'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-small`：从两到四英寸，320 x 420dp或更大'
- en: '`layout-normal`: from three to five inches, 320 x 480dp or larger'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-normal`：从三到五英寸，320 x 480dp或更大'
- en: '`layout-large`: from four to seven inches, 480 x 640dp or larger'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-large`：从四到七英寸，480 x 640dp或更大'
- en: '`layout-xlarge`: from seven to 10 inches, 720 x 960dp or larger'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout-xlarge`：从七到十英寸，720 x 960dp或更大'
- en: If you are developing for Android 3.0 (API level 11) or below, devices at the
    lower end of this scale will often be categorized incorrectly. The only solution
    to this is to configure for individual devices or avoid developing for such devices
    at all.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在为Android 3.0（API级别11）或更低版本开发，这个范围较低的设备通常会被错误地分类。唯一的解决方案是为单独的设备进行配置，或者根本不开发这些设备。
- en: Generally speaking, we will need to produce a layout for each of the above sizes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我们需要为上述每种尺寸制作一个布局。
- en: The use of **density-independent pixels** (**dp** or **dip**) means that we
    do not need to design a new layout for each density setting, but we do have to
    provide a separate drawable for each density class, which are as follows.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**密度无关像素**（**dp**或**dip**）意味着我们不需要为每个密度设置设计新的布局，但我们必须为每个密度类提供单独的可绘制资源，如下所示。
- en: '`drawable-ldpi` ~ 120dpi'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawable-ldpi` 〜120dpi'
- en: '`drawable-mdpi` ~160dpi'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawable-mdpi` 〜160dpi'
- en: '`drawable-hdpi` ~240dpi'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawable-hdpi` 〜240dpi'
- en: '`drawable-xhdpi` ~320dpi'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawable-xhdpi` 〜320dpi'
- en: '`drawable-xxhdpi` ~480dpi'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawable-xxhdpi` 〜480dpi'
- en: '`drawable-xxxhdpi` ~640dpi'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawable-xxxhdpi` 〜640dpi'
- en: The dpi values in the preceding list inform us of the relative size in pixels
    that our resources need to be. For example bitmaps in the `drawable-xhdpi` directory
    need to be twice the size of their equivalent in the `drawable-mdpi` folder.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表中的dpi值告诉我们我们的资源需要的像素相对大小。例如，`drawable-xhdpi`目录中的位图需要是`drawable-mdpi`文件夹中相应位图大小的两倍。
- en: It is not really possible to create exactly the same output on every device,
    and this is not even desirable. People buy high-end devices because they want
    stunning imagery and fine detail, and we should endeavor to provide this level
    of quality. On the other hand many people buy small and less expensive devices
    for reasons of convenience and budget and we should reflect these choices in our
    designs. Rather than try to reproduce exactly the same experience on all devices,
    we should think about the reasons why people choose their devices and what it
    is they want from them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上不可能在每台设备上创建完全相同的输出，这甚至不可取。人们购买高端设备是因为他们想要令人惊叹的图像和精细的细节，我们应该努力提供这种质量水平。另一方面，许多人购买小型和价格较低的设备是出于便利和预算的原因，我们应该在设计中反映这些选择。与其试图在所有设备上完全复制相同的体验，我们应该考虑人们选择设备的原因以及他们想要从中获得什么。
- en: The following short exercise demonstrates how these differences manifest themselves
    across different screen configurations. This will give readers the opportunity
    to see how to best exploit the user's choice of device, using their own artistic
    and design acumen.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简短的练习演示了这些差异如何在不同的屏幕配置中表现出来。这将让读者有机会看到如何最好地利用用户选择的设备，利用他们自己的艺术和设计才能。
- en: Select any high-resolution image, ideally a photograph.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何高分辨率图像，最好是一张照片。
- en: Using whatever tools you choose, create a copy that has half the width and height
    of the original.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的任何工具，创建一个宽度和高度为原始尺寸一半的副本。
- en: Open a new Android Studio project.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的Android Studio项目。
- en: From the Project Explorer, create two new folders inside the res directory,
    called `drawable-mdpi` and `drawable-hdpi`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目资源管理器中，在res目录内创建两个名为`drawable-mdpi`和`drawable-hdpi`的新文件夹。
- en: Place the prepared images in these folders.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将准备好的图像放入这些文件夹中。
- en: Build a simple layout with an image view and some text.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建一个带有图像视图和一些文本的简单布局。
- en: Create two virtual devices, one with `mdpi` density and one `hdpi`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个虚拟设备，一个密度为`mdpi`，一个为`hdpi`。
- en: Finally, run the app on each device to observe the differences.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在每个设备上运行应用程序以观察差异。
- en: '![](img/c32e343f-ac39-4a5b-a430-c4cbe157edba.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c32e343f-ac39-4a5b-a430-c4cbe157edba.png)'
- en: Devices with mdpi and hdpi densities.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 密度为mdpi和hdpi的设备。
- en: These are not actually the only density qualifiers we can use. Apps designed
    for televisions often use the `tvdpi` qualifier. This has a value between `mdpi`
    and `hdpi`. There are also the `nodpi` qualifier, which is used when we want exact
    pixel mapping, and `anydpi`, which is used when all artwork is vector drawables.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上并不是我们可以使用的唯一密度限定符。为电视设计的应用程序通常使用`tvdpi`限定符。这个值介于`mdpi`和`hdpi`之间。还有`nodpi`限定符，当我们需要精确的像素映射时使用，以及`anydpi`，当所有艺术作品都是矢量可绘制时使用。
- en: 'There are a lot of other qualifiers and a full list can be found at:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多其他限定符，完整列表可以在以下网址找到：
- en: '[developer.android.com/guide/topics/resources/providing-resources.html](http://developer.android.com/guide/topics/resources/providing-resources.html)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[developer.android.com/guide/topics/resources/providing-resources.html](http://developer.android.com/guide/topics/resources/providing-resources.html)'
- en: It is worth taking a look at some of the more useful ones now.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在值得看一下一些更有用的限定符。
- en: Scale and platform
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比例和平台
- en: Generalized qualifiers such as those discussed earlier are very useful, suit
    most purposes, and save us a lot of time. However, there are times when we want
    more exact information about the device our app is running on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 像之前讨论过的那样的概括限定符非常有用，适用于大多数情况，并且节省了我们大量的时间。然而，有时我们需要更精确的关于我们的应用程序运行设备的信息。
- en: One of the most important features we want to have information about is screen
    size. We have already encountered qualifiers such as small, normal, and large,
    but we can also configure for more precise dimensions. The simplest of these is
    the available width and available height. For example, layouts in `res/layout/w720dp`
    will only inflate when there is a minimum of 720dp available and height and `res/layout/h1024dp`
    will inflate when the screen height is equal to or greater than 1024dp.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要了解的最重要的功能之一是屏幕尺寸。我们已经遇到了诸如小型、普通和大型之类的限定符，但我们也可以配置更精确的尺寸。其中最简单的是可用宽度和可用高度。例如，`res/layout/w720dp`中的布局只有在可用宽度至少为720dp时才会被填充，而`res/layout/h1024dp`中的布局则在屏幕高度等于或大于1024dp时被填充。
- en: Another very handy feature to configure resources for is the platform version
    number. This operates on the API level. So one would use a qualifier of `v16` for
    resources to be used when running on Android Jelly Bean devices.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常方便的功能是配置平台版本号的资源。这是基于API级别的。因此，当在Android Jelly Bean设备上运行时，可以使用`v16`的限定符来使用资源。
- en: Being able to select and prepare resources for such a wide range of hardware
    means we can provide lavish resources for those devices that are capable of displaying
    them and simpler resources for devices that have reduced capacity. Whether we
    are developing for budget phones or high-end tablets we still need some way to
    test our apps. We have already seen how flexible AVDs can be, but it is well worth
    taking a quick look at some of the alternatives.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 能够为如此广泛的硬件选择和准备资源意味着我们可以为那些能够显示它们的设备提供丰富的资源，对于容量较小的设备则提供更简单的资源。无论我们是为预算手机还是高端平板开发，我们仍然需要一种测试应用程序的方法。我们已经看到了AVDs的灵活性，但很值得快速看一下其他一些选择。
- en: Alternative emulators
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代模拟器
- en: 'One of the very best alternative emulators is probably Genymotion. This unfortunately
    is not free and is not as up-to-date as the native AVDs but it is fast and supports
    drag-and-drop file installation and mobile network functionality. It can be found
    at:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的替代模拟器之一可能是Genymotion。不幸的是，这个模拟器不是免费的，也不像原生AVDs那样及时更新，但它速度快，支持拖放文件安装和移动网络功能。它可以在以下网址找到：
- en: '[www.genymotion.com](http://www.genymotion.com)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.genymotion.com](http://www.genymotion.com)'
- en: 'Another fast and easy to use emulator is Manymo. This is is a browser-based
    emulator and its primary purpose is to test web apps, but it works perfectly well
    for mobile apps. It too is not free but it does have a wide selection of ready-made
    form factors. It can be found at:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个快速且易于使用的模拟器是Manymo。这是一个基于浏览器的模拟器，其主要目的是测试Web应用程序，但对于移动应用程序也非常有效。它也不是免费的，但它有各种各样的预制形态因子。它可以在以下网址找到：
- en: '[www.manymo.com](http://www.manymo.com)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[www.manymo.com](http://www.manymo.com)'
- en: 'In a very similar vein there is Appetize, which is located at:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面还有一个类似的工具是Appetize，它位于：
- en: '[appetize.io](http://appetize.io)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[appetize.io](http://appetize.io)'
- en: 'There are a growing number of such emulators but those mentioned above are
    probably the most functional from a development perspective. The following list
    directs the reader to some of the others:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的模拟器越来越多，但上面提到的那些可能是从开发的角度来看最功能齐全的。以下列表将读者引向其他一些模拟器：
- en: '[www.andyroid.net](http://www.andyroid.net)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[www.andyroid.net](http://www.andyroid.net)'
- en: '[www.bluestacks.com/app-player.html](http://www.bluestacks.com/app-player.html)'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[www.bluestacks.com/app-player.html](http://www.bluestacks.com/app-player.html)'
- en: '[www.droid4x.com](http://www.droid4x.com)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[www.droid4x.com](http://www.droid4x.com)'
- en: '[drive.google.com/file/d/0B728YkPxkCL8Wlh5dGdiVXdIS0k/edit](http://drive.google.com/file/d/0B728YkPxkCL8Wlh5dGdiVXdIS0k/edit)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[drive.google.com/file/d/0B728YkPxkCL8Wlh5dGdiVXdIS0k/edit](http://drive.google.com/file/d/0B728YkPxkCL8Wlh5dGdiVXdIS0k/edit)'
- en: There is one scenario where none of these alternatives are suitable and we are
    forced to use the AVD manager and that is when we want to develop for wearables,
    such as smart watches, which is what we will look at next.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种情况下，这些替代方案都不合适，我们被迫使用AVD管理器，那就是当我们想要为可穿戴设备（如智能手表）开发时，这是我们接下来要看的内容。
- en: Android Wear
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Wear
- en: Wearable devices have become very popular of late and Android Wear is fully
    incorporated into the Android SDK. The setting up of a Wear project is slightly
    more involved than other projects as wearable devices really act as a companion
    device with the apps themselves running from a mobile device.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可穿戴设备最近变得非常流行，Android Wear已完全整合到Android SDK中。设置Wear项目比其他项目稍微复杂一些，因为可穿戴设备实际上是作为应用程序的伴侣设备，应用程序本身是从移动设备上运行的。
- en: Despite this minor level of complication, developing for wearables can be a
    lot of fun, not least because they often offer us access to some cool sensors,
    such as the heart rate monitor.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有这种轻微的复杂性，为可穿戴设备开发可能会非常有趣，至少因为它们经常为我们提供访问一些很酷的传感器，比如心率监测器。
- en: Connecting to a wearable AVD
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到可穿戴AVD
- en: 'It may well be that you have access to a wearable device, but here we will
    be using emulators in the following exercise. This is because these devices come
    in two flavors: square and round.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您有可穿戴设备，但在以下练习中我们将使用模拟器。这是因为这些设备有两种类型：方形和圆形。
- en: When it comes to pairing one of these emulators with a phone or tablet, this
    can be done with either a real device or with another emulator, with a real device
    being preferable as this puts less strain on the computer. These two approaches
    are slightly different. The following exercise assumes you are pairing a wearable
    emulator with a real device, with an explanation of how to pair with an emulated
    mobile device at the end.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当要将这些模拟器之一与手机或平板配对时，可以使用真实设备或另一个模拟器，但最好使用真实设备，因为这会对计算机造成较小的压力。这两种方法略有不同。以下练习假设您正在将可穿戴模拟器与真实设备配对，并解释了如何在最后与模拟移动设备配对。
- en: 'Before doing anything else, open the SDK Manager and check that you have downloaded
    Android Wear System Images:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在做任何其他事情之前，打开SDK管理器并检查是否已下载了Android Wear系统镜像：
- en: '![](img/b4f5a271-696e-46cb-91f8-93235d4ccf00.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b4f5a271-696e-46cb-91f8-93235d4ccf00.png)'
- en: Open the AVD Manager and create two AVDs, one round and one square.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开AVD管理器并创建两个AVD，一个是圆形的，一个是方形的。
- en: Install the Android Wear app from the Play store on your handset and connect
    it to the computer.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在手机上从Play商店安装Android Wear应用程序，并将其连接到计算机。
- en: Locate and open the directory containing the `adb.exe` file. This can be found
    in `\AppData\Local\Android\Sdk\platform-tools\`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到并打开包含`adb.exe`文件的目录。这可以在`\AppData\Local\Android\Sdk\platform-tools\`中找到。
- en: 'Issue the following command:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出以下命令：
- en: '[PRE0]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Launch the companion app on your handset and follow the on-screen instructions
    to pair the devices.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在手机上启动伴侣应用程序，并按照屏幕上的说明配对设备。
- en: You will need to execute the port forwarding command each time you reconnect
    the handset.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每次重新连接手机时，您都需要执行端口转发命令。
- en: 'If you are going to pair the wearable with a virtual handset, the process is
    very similar, the only difference being the manner in which the companion app
    is installed. Follow the steps to achieve this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将可穿戴设备与虚拟手机配对，该过程非常类似，唯一的区别是伴侣应用程序的安装方式。按照以下步骤来实现这一点：
- en: Start or create an AVD that targets Google APIs.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动或创建一个目标为Google APIs的AVD。
- en: Download `com.google.android.wearable.app-2.apk`. There are many places online
    where the file can be found, such as www.file-upload.net/download.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载`com.google.android.wearable.app-2.apk`。有很多在线地方可以找到这个文件，比如www.file-upload.net/download。
- en: 'Put the file in your platform-tools folder and install it with:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件放入platform-tools文件夹中，并使用以下命令进行安装：
- en: '[PRE1]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Start the wearable AVD and enter `adb devices` at the command prompt (or Terminal
    if you are on a Mac) to check that both devices are visible.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动可穿戴AVD并在命令提示符（或者如果您在Mac上，则在终端）中输入`adb devices`来检查两个设备是否可见。
- en: Enter `adb telnet localhost 5554`, where `5554` is the phone emulator.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`adb telnet localhost 5554`，其中`5554`是手机模拟器。
- en: Finally enter `adb redir add tcp:5601:5601`. You can now use the wear app on
    the emulated phone in the same way as the previous exercise to pair the devices.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后输入`adb redir add tcp:5601:5601`。您现在可以像之前的练习一样在模拟手机上使用穿戴应用程序配对设备。
- en: Although it is added for us automatically, it is still important to understand
    that Android Wear apps require a support library. This can be seen by examining
    the module level in the `build.gradle` file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它是自动为我们添加的，但重要的是要理解Android Wear应用程序需要一个支持库。这可以通过检查`build.gradle`文件中的模块级别来看到。
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With our devices now paired, we can begin to actually develop and design our
    wearable app.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的设备已经配对，我们可以开始实际开发和设计我们的可穿戴应用程序了。
- en: Wearable layouts
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可穿戴布局
- en: One of the most interesting challenge when it comes to Android Wear UI development,
     is the two different shapes these smart watches come in. There are two ways we
    can approach this.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Wear UI开发中最有趣的挑战之一是这些智能手表的两种不同形状。我们可以以两种方式来解决这个问题。
- en: One is similar to the way we have managed things previously and involves designing
    a layout for each form factor whilst the other technique uses a method that produces
    a layout that will work for either shape.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种类似于我们之前管理事物的方式，并涉及为每种形态因素设计布局，而另一种技术使用一种产生适用于任何形状的布局的方法。
- en: On top of these techniques the wearable support library comes equipped with
    some very handy widgets suited to curved and round layouts and lists.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些技术之外，可穿戴支持库还配备了一些非常方便的小部件，适用于曲面和圆形布局以及列表。
- en: One of the most useful and instructive features of Android Studio is the project
    templates that are offered when a project is first set up. There is a good selection
    of these and they provide good starting points to most projects, in particular
    Wear apps.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio最有用和有教育意义的功能之一是在项目首次设置时提供的项目模板。这些模板有很好的选择，它们为大多数项目提供了良好的起点，特别是穿戴应用程序。
- en: '![](img/a15c089f-644e-4bfa-bdd4-5cc873a653a6.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a15c089f-644e-4bfa-bdd4-5cc873a653a6.png)'
- en: Wear templates
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 穿戴模板
- en: Starting a project this way can be helpful and revealing and even the blank
    activity template sets up both XML and Java files, creating a very creditable
    starting point.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从这种方式开始一个项目可能是有帮助和启发性的，甚至空白的活动模板设置了XML和Java文件，创建了一个非常可信的起点。
- en: If you start a project from Blank Wear Activity, the first thing you will notice
    is that, where we previously had only one module (called app by default), we now
    have two modules, one called mobile that replaces app and another named wear.
    Both these modules have the same structures as those we have encountered before,
    containing a manifest, resource directory and Java activities.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从空白的穿戴活动开始一个项目，您会注意到，我们之前只有一个模块（默认称为app），现在有两个模块，一个称为mobile，取代了app，另一个名为wear。这两个模块的结构与我们之前遇到的相同，包含清单、资源目录和Java活动。
- en: The WatchViewStub class
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WatchViewStub类
- en: The blank Wear activity template applies the first technique we discussed earlier
    for managing different device shapes. This takes the form of the `WatchViewStub`
    class, which can be found in the `wear/src/main/res/layout` folder.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 空白的穿戴活动模板应用了我们之前讨论的管理不同设备形状的第一种技术。这采用了`WatchViewStub`类的形式，可以在`wear/src/main/res/layout`文件夹中找到。
- en: '[PRE3]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As can be seen in the preceding example, the main activity directs the system
    to one or other of the two shaped layouts, which the template also provides.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，主要活动将系统引导到两种形状的布局之一，模板也提供了这两种布局。
- en: 'As you can see, this is not the way we have selected the correct layout previously
    and that is because `WatchViewStub` operates differently and requires a specialized
    listener that inflates our layouts once `WatchViewStub` has detected the watch
    face type. This code too is provided by the template in the main activity Java
    file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这不是我们之前选择正确布局的方式，这是因为`WatchViewStub`的操作方式不同，并且需要一个专门的监听器，一旦`WatchViewStub`检测到手表的类型，它就会填充我们的布局。这段代码也是模板在主活动Java文件中提供的：
- en: '[PRE4]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is tempting to think that `WatchViewStub` is all we need to design our wearable
    layouts. It allows us to design for both faces independently, which is precisely
    what we want to do. However, Wear layouts are generally very simple and indeed
    complex designs are strongly discouraged. Thus with a simple design of little
    more than an image and a button, it is simply a matter of convenience to have
    a `shape-aware` class that distributes its contents according to the shape of
    the device it finds itself being inflated on. This is how the `BoxInsetLayout`
    class works.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 诱人的是认为`WatchViewStub`是我们设计可穿戴布局所需的全部。它允许我们独立设计两个表盘，这正是我们想要做的。然而，可穿戴布局通常非常简单，复杂的设计被强烈不鼓励。因此，对于一个简单的设计，几乎只有一张图片和一个按钮，拥有一个`shape-aware`类，根据设备的形状分发其内容，只是一种方便。这就是`BoxInsetLayout`类的工作原理。
- en: Shape - aware layouts
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 形状感知布局
- en: The `BoxInsetLayout` class is part of the Wear UI library and allows us to design
    just one layout that will optimize itself for both square and round watch faces.
    It does this by inflating the largest possible square within any round frame.
    This is a simple solution but what the BoxInsetLayout also does very nicely is
    ensure that any background image we choose always fills all available space. As
    we shall see in a moment, if you position components horizontally across the screen,
    the `BoxInsetLayout` class automatically distributes them to cause a best fit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoxInsetLayout`类是Wear UI库的一部分，允许我们设计一个布局，可以优化自身适应方形和圆形表盘。它通过在任何圆形框架内充气最大可能的正方形来实现这一点。这是一个简单的解决方案，但`BoxInsetLayout`还非常好地确保我们选择的任何背景图像始终填充所有可用空间。正如我们将在一会儿看到的，如果您将组件水平放置在屏幕上，`BoxInsetLayout`类会自动分发它们以实现最佳适配。'
- en: One of the very first things you will want to do, when developing for these
    unusual form factors when working in Android Studio, is take advantage of the
    powerful preview system provided by the Layout Editor. This provides previews
    of each type of wearable device as well as any AVDs you may have created. This
    saves a great deal of time when testing a layout as we can view this directly
    from the IDE without having to launch an AVD.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Android Studio开发时，您将想要做的第一件事情之一是利用布局编辑器提供的强大预览系统。这提供了每种可穿戴设备的预览，以及您可能创建的任何AVD。这在测试布局时节省了大量时间，因为我们可以直接从IDE中查看，而无需启动AVD。
- en: The preview tool can be accessed from the `View | Tool Windows` menu; or, if
    the layout Text editor is open; it can be found, by default, in the right hand
    margin.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 预览工具可以从`View | Tool Windows`菜单中访问；或者，如果布局文本编辑器打开，可以在右侧边距中找到，默认情况下。
- en: Unlike `WatchViewStubs`, the `BoxInsetLayout` class is not provided by any of
    the templates and must be coded manually. Follow the short steps below to construct
    a dynamic Wear UI using the `BoxInsetLayout` class .
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与`WatchViewStubs`不同，`BoxInsetLayout`类不是由任何模板提供的，必须手动编码。按照以下简短步骤，使用`BoxInsetLayout`类构建动态的Wear
    UI。
- en: 'Create the following `BoxInsetLayout` as the root container of the main XML
    activity in the wear module:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`BoxInsetLayout`创建为wear模块中主XML活动的根容器：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Place this `FrameLayout` inside the `BoxInsetLayout` class:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个`FrameLayout`放在`BoxInsetLayout`类中：
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside `FrameLayout` include these widgets (or those of your own choosing):'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FrameLayout`中包括这些小部件（或您自己选择的小部件）：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, run the demonstration on both a round and a square emulator:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在圆形和方形模拟器上运行演示：
- en: '![](img/b138abb9-7ed0-4478-8ea6-7473de6a2740.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b138abb9-7ed0-4478-8ea6-7473de6a2740.png)'
- en: The BoxInsetLayout
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: BoxInsetLayout
- en: The `BoxInsetLayout` class is wonderfully easy to use. Not only does it save
    us time, it also keeps the memory footprint of our app down, as even the simplest
    layout has some cost. It may seem that it is somewhat wasteful of space in the
    round view, but Wear UIs should be bare and stripped down and empty space is not
    something to be avoided; a well designed wearable UI should  be quickly grasped
    by the user.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoxInsetLayout`类非常易于使用。它不仅节省我们的时间，还可以保持应用的内存占用量，因为即使是最简单的布局也有一定的成本。在圆形视图中，它可能看起来有些浪费空间，但是Wear
    UI应该是简洁和简化的，空白空间不是应该避免的东西；一个设计良好的可穿戴UI应该能够被用户快速理解。'
- en: One of the most frequently used features of Android Wear is the heart rate monitor
    and, as we are working with wearables, now would be a good time to look at how
    we access sensor data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Android Wear最常用的功能之一是心率监测器，因为我们正在处理可穿戴设备，现在是时候看看如何访问传感器数据了。
- en: Accessing sensors
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问传感器
- en: Devices worn on the wrist are ideal for fitness apps and the inclusion of a
    heart rate monitor in many models makes them perfect for such tasks. The way that
    the SDK manages all sensors is almost identical, so seeing how one works applies
    to the others.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 佩戴在手腕上的设备非常适合健身应用，许多型号中都包含心率监测器，使它们非常适合这样的任务。SDK管理所有传感器的方式几乎相同，因此了解一个传感器的工作方式也适用于其他传感器。
- en: 'The following exercise demonstrates how to read the heart rate sensor on a
    wearable device:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习演示了如何在可穿戴设备上读取心率传感器的数据：
- en: Open an Android Wear project with both mobile and wear modules.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个带有移动和可穿戴模块的Android Wear项目。
- en: Create a layout of your choosing, ensuring you include a `TextView` to display
    the output.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建您选择的布局，确保包括一个`TextView`来显示输出。
- en: 'Open the `Manifest` file in the wear module and add the following permission:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可穿戴模块的`Manifest`文件中添加以下权限：
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open the `MainActivity.java` file in the wear module and add the following
    fields:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可穿戴模块的`MainActivity.java`文件中添加以下字段：
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Have the `Activity` implement a sensor event listener, like so:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让`Activity`实现传感器事件监听器，如下所示：
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Implement the methods required by this.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现所需的方法。
- en: 'Edit the `onCreate()` method as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`onCreate()`方法如下：
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the `onResume()` method to register the listener when the activity starts
    or restarts:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onResume()`方法中注册监听器，当活动启动或重新启动时：
- en: '[PRE12]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then add the `onPause()` method to ensure the listener is switched off when
    not required:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加`onPause()`方法，以确保在不需要时关闭监听器：
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, edit the `onSensorChanged()` callback, as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编辑`onSensorChanged()`回调，如下所示：
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](img/60de7bbe-5ab2-4429-b973-f89155262741.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60de7bbe-5ab2-4429-b973-f89155262741.png)'
- en: 'As mentioned earlier, all sensors can be accessed in the same fashion, although
    of course the values they output differ according to their purpose. Full documentation
    of this can be found at:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，所有传感器都可以以相同的方式访问，尽管它们输出的值根据其目的而异。关于这一点的完整文档可以在以下网址找到：
- en: '[developer.android.com/reference/android/hardware/Sensor.html](http://developer.android.com/reference/android/hardware/Sensor.html)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[developer.android.com/reference/android/hardware/Sensor.html](http://developer.android.com/reference/android/hardware/Sensor.html)'
- en: Now, of course, the reader will be thinking this exercise is pointless without
    an actual device with an actual sensor. Fortunately, there is more than one way
    to make up for this lack of hardware in an emulator.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当然，读者会认为这个练习没有实际传感器的实际设备是没有意义的。幸运的是，在模拟器中弥补这种硬件缺乏的方法不止一种。
- en: Sensor emulation
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传感器仿真
- en: If you have not used the Android emulators for some time or are new to them,
    you may well have missed the extended controls that each AVD has. These can be
    accessed from the bottom of the emulator's toolbar.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一段时间没有使用Android模拟器，或者是第一次使用它们，您可能会错过每个AVD的扩展控件。这些可以从模拟器工具栏的底部访问。
- en: 'These extended controls offer a host of useful functions such as the ability
    to easily set mock locations and alternative input methods. Of interest to us
    here are virtual sensors. These allow us to simulate a variety of sensors and
    input values directly:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这些扩展控件提供了许多有用的功能，比如轻松设置模拟位置和替代输入方法的能力。我们感兴趣的是虚拟传感器。这些允许我们直接模拟各种传感器和输入值：
- en: '![](img/e797a1c2-3b12-4f31-91ad-515b15a08f87.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e797a1c2-3b12-4f31-91ad-515b15a08f87.png)'
- en: Virtual sensors
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟传感器
- en: 'There are several other routes to running sensors on emulated devices. Most
    of these depend on connecting real devices and using their hardware. These SDK
    controller sensors can be download from the Play store. There are also some great
    sensor simulators on GitHub, my personal favorite being:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟设备上运行传感器还有其他几种方法。其中大多数依赖于连接真实设备并使用它们的硬件。这些SDK控制器传感器可以从Play商店下载。GitHub上也有一些很棒的传感器模拟器，我个人最喜欢的是：
- en: '[github.com/openintents/sensorsimulator](http://github.com/openintents/sensorsimulator)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[github.com/openintents/sensorsimulator](http://github.com/openintents/sensorsimulator)'
- en: Now that we are beginning to develop more than just static layouts, we can start
    to take advantage of some of Studio's more powerful monitoring tools.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们开始开发不仅仅是静态布局，我们可以开始利用一些Studio更强大的监控工具。
- en: Device monitoring
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备监控
- en: Very often, simply running an app on a device or emulator is enough to tell
    us if what we have designed works and what, if anything, we need to change. However
    it is always great to see what is going on under the hood, and Android Studio
    has some fantastic tools when it comes to the live monitoring of an app's behavior.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，只需在设备或模拟器上运行应用程序就足以告诉我们我们设计的东西是否有效，以及我们是否需要更改任何内容。但是，了解应用程序行为的实时监控情况总是很好的，而在这方面，Android
    Studio有一些很棒的工具。
- en: We will cover debugging in detail in the next module, but it is never too soon
    to play with the **Android Debug Bridge** (**ADB**) and Android Studio's Device
    Monitor tool is one of the most significant benefits of choosing the IDE over
    the alternatives.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个模块中详细介绍调试，但现在玩一下**Android Debug Bridge**（**ADB**）和Android Studio的设备监视器工具是选择IDE而不是其他替代品的最重要的好处之一。
- en: This section also offers a good opportunity to take a closer look at project
    templates, another fantastic feature of Android Studio.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分还提供了一个很好的机会来更仔细地查看项目模板，这是Android Studio的另一个很棒的功能。
- en: Project templates
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目模板
- en: Android Studio comes packed with many useful project templates. These are designed
    for a series of typical project types, such as full screen apps or Google Maps
    projects. Templates are partially completed projects with code, layouts, and resources
    that can be used as a starting point for our own creations. The growing presence
    of material design has made the `Navigation Drawer Activity` template one of the
    most used templates and the one we will use to examine the Device Monitor tool.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio提供了许多有用的项目模板。这些模板设计用于一系列典型的项目类型，例如全屏应用程序或Google地图项目。模板是部分完成的项目，包括代码、布局和资源，可以作为我们自己创作的起点。材料设计的不断出现使得`导航抽屉活动`模板成为最常用的模板之一，也是我们将用来检查设备监视器工具的模板。
- en: 'The `Navigation Drawer Activity` template is interesting and useful in several
    ways. Firstly, note that there are four layout files including the `activity_main.xml`
    file that we are familiar with. Examining this code, you will note the following
    node:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`导航抽屉活动`模板在几个方面都很有趣和有用。首先，请注意，有四个布局文件，包括我们熟悉的`activity_main.xml`文件。检查这段代码，您会注意到以下节点：'
- en: '[PRE15]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The purpose of this node is simple to understand and the `app_bar_main.xml`
    file that it refers to contains the coordinator layout and other views that we
    covered earlier in the book. The use of the `<include>` tag is by no means necessary
    but it is very useful if we ever want to reuse that code in another activity,
    and of course it produces far cleaner looking code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个节点的目的很简单，`app_bar_main.xml`文件包含了我们在本书前面介绍过的协调布局和其他视图。使用`<include>`标签并不是必需的，但如果我们想在另一个活动中重用该代码，它是非常有用的，当然，它会产生更清晰的代码。
- en: Another point of interest in this template is the use of vector graphics in
    the drawable directory. We will be looking at these in detail in the next chapter
    but for now it is enough to know that they provide a fantastic way to manage the
    problem of having to provide separate imagery for each screen density grouping
    as they will scale to any screen.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板中另一个值得关注的地方是在drawable目录中使用矢量图形。我们将在下一章中详细讨论这些，但现在知道它们提供了一个很好的方法来解决为每个屏幕密度组提供单独图像的问题，因为它们可以缩放到任何屏幕。
- en: Before we take a look at how we can monitor an app's behavior, take a quick
    look at the main activity Java code. This shows very nicely how the various features
    are, and should be, coded. It is unlikely the example features will match those
    we want, but they can be replaced and edited very easily to suit our purposes,
    and an entire application can be built from this starting point.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看一下如何监视应用程序行为之前，快速查看一下主活动Java代码。这很好地展示了各种功能的编码方式。这些示例功能可能不符合我们的要求，但可以很容易地替换和编辑以适应我们的目的，并且可以从这个起点构建整个应用程序。
- en: Monitoring and profiling
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控和分析
- en: One tool that all developers want is the ability to monitor an application during
    runtime. Watching the live impact user actions have on hardware components such
    as memory and processors is a fantastic way to identify possible bottlenecks and
    other problems. Android Studio has a sophisticated set of profiling tools, which
    will be examined thoroughly in the next module. However, the Android Profiler
    is useful for UI develeopment as well as coding and certainly worth looking at
    briefly here.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 所有开发人员都希望能够在运行时监视应用程序的能力。观察用户操作对硬件组件（如内存和处理器）的实时影响是识别可能的瓶颈和其他问题的绝佳方式。Android
    Studio拥有一套复杂的分析工具，将在下一个模块中进行全面讨论。然而，Android Profiler对UI开发以及编码都很有用，因此在这里简要地看一下是值得的。
- en: 'The Android Profiler can be opened from the View | Tool Windows menu, the tools
    gutter, or by pressing *Alt* + *6*. It appears at the bottom of the IDE by default,
    but this can be customized using the Settings icon to suit individual preferences:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Android Profiler可以从“查看|工具窗口”菜单、工具栏或按*Alt* + *6*打开。它默认出现在IDE底部，但可以使用设置图标进行自定义以适应个人偏好：
- en: '![](img/0a8ad435-927c-4150-b9e8-fb2d72c87053.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0a8ad435-927c-4150-b9e8-fb2d72c87053.png)'
- en: The Android Profiler
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Android Profiler
- en: An advanced profiling option is available via the Run configuration dialog;
    this will be covered in the next module. For now there is another simple debugging/monitoring
    tool that can be very handy for UI design and development.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行配置对话框可以使用高级分析选项；这将在下一个模块中介绍。目前还有另一个简单的调试/监控工具，对UI设计和开发非常有用。
- en: The visual feedback provided by the profiler provides a lot of useful information,
    but this information is fleeting and, although advanced profiling allows us to
    record very detailed examination, often all we need is to confirm that a particular
    event took place, or the order in which certain events took place.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器提供的视觉反馈提供了大量有用的信息，但这些信息是瞬息万变的，尽管高级分析允许我们记录非常详细的检查，但通常我们只需要确认特定事件发生了，或者某些事件发生的顺序。
- en: For this, we can use another tool window, the logcat, and when all we need is
    to get some basic textual feedback on how and what our app is doing we can create
    a logcat filter for this purpose.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一点，我们可以使用另一个工具窗口logcat，当我们只需要获取关于我们的应用程序如何以及在做什么的基本文本反馈时，我们可以为此创建一个logcat筛选器。
- en: 'Perform the following steps to do this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这个过程：
- en: Open the logcat tool window via the View | Tool Windows menu or from the margin.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过“查看|工具窗口”菜单或边距打开logcat工具窗口。
- en: Select Edit Filter Configuration from the filter drop-down, on the right.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右侧的筛选下拉菜单中选择“编辑筛选配置”。
- en: 'Complete the dialog, as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式完成对话框：
- en: '![](img/f67419bf-c7de-48fa-a070-2a55df527520.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f67419bf-c7de-48fa-a070-2a55df527520.png)'
- en: Creating a logcat filter
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 创建logcat筛选器
- en: 'Add the following field to your `main` activity:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下字段添加到您的`main`活动中：
- en: '[PRE16]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Include the following import:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包括以下导入：
- en: '[PRE17]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, add the highlighted line in the following code:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在以下代码中添加突出显示的行：
- en: '[PRE18]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running the app with logcat open and tapping the FAB, will produce the following
    output.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开logcat并点击FAB运行应用程序时，将产生以下输出。
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although this example is simple, the power of this technique is obvious and
    this form of debugging is the fastest and simplest way to check simple UI behavior,
    program flow, and the activity life cycle state.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子很简单，但这种技术的强大是显而易见的，这种调试形式是检查简单UI行为、程序流程和活动生命周期状态的最快、最简单的方式。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has covered a lot of ground; we have taken the work done on Android
    layouts in an earlier chapter and begun to explore how these can be taken from
    static graphics to more dynamic structures. We have seen how Android provides
    classes and libraries that make developing for different screens easier than with
    other IDEs and how the emulator can be used to produce all possible form factors,
    including the most recent platforms.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了很多内容；我们已经在之前的章节中介绍了Android布局的工作，并开始探索如何将这些布局从静态图形转变为更动态的结构。我们已经看到Android提供了使开发适应不同屏幕比其他IDE更容易的类和库，以及模拟器可以用来生成所有可能的形态，包括最新的平台。
- en: There is only one more chapter in this module on layout and design before we
    move onto coding; in it we will cover how the numerous resources available to
    us are managed and how Android Studio assists us in this.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向编码之前，这个模块中只剩下一个关于布局和设计的章节；在其中，我们将介绍如何管理我们可用的众多资源以及Android Studio如何协助我们进行管理。
