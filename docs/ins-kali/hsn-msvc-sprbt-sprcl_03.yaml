- en: Introduction to Spring Boot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot简介
- en: In this chapter, we will be introduced to how to build a set of cooperating
    microservices using Spring Boot, focusing on how to develop functionality that
    delivers business value. The challenges that we pointed out in the previous chapter
    will be considered only to some degree, but they will be addressed to their full
    extent in later chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何使用Spring Boot构建一组协作的微服务，重点是如何开发能够提供业务价值的功能。我们在上一章中指出的挑战只会在一定程度上考虑，但它们将在后面的章节中得到充分解决。
- en: We will develop microservices that contain business logic based on plain Spring
    Beans and REST APIs using Spring WebFlux, the Swagger/OpenAPI-based documentation
    of the REST APIs, and SpringFox and data persistence, while using Spring Data
    to store data in both SQL and NoSQL databases
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发基于普通Spring Beans的业务逻辑的微服务，使用Spring WebFlux开发REST API，基于Swagger/OpenAPI的REST
    API文档和SpringFox和数据持久性，同时使用Spring Data在SQL和NoSQL数据库中存储数据。
- en: Since Spring Boot v2.0 was released in March 2018, it has become much easier
    to develop reactive microservices (refer to [Chapter 1](282e7b49-42b8-4649-af81-b4b6830d391d.xhtml), *Introduction
    to Microservices*, the *Reactive mi**croservices* section for more information).
    Therefore, we will also cover how to create reactive microservices in this chapter,
    including both non-blocking synchronous REST APIs and message-based asynchronous
    services. We will use Spring WebFlux to develop non-blocking synchronous REST
    APIs and Spring Cloud Stream to develop message-based asynchronous services.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 自2018年3月发布Spring Boot v2.0以来，开发反应式微服务变得更加容易（更多信息请参阅[第1章]（282e7b49-42b8-4649-af81-b4b6830d391d.xhtml），*微服务简介*，*反应式微服务*部分）。因此，我们还将在本章中介绍如何创建反应式微服务，包括非阻塞同步REST
    API和基于消息的异步服务。我们将使用Spring WebFlux开发非阻塞同步REST API和Spring Cloud Stream开发基于消息的异步服务。
- en: Finally, we will use Docker to run our microservices as containers. This will
    allow us to start and stop our microservice landscape, including database servers
    and a message broker, with a single command.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用Docker将我们的微服务作为容器运行。这将使我们能够通过一个命令启动和停止我们的微服务景观，包括数据库服务器和消息代理。
- en: That's a lot of technologies and frameworks, so let's go through each of them
    briefly to see what they are about!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多技术和框架，所以让我们简要介绍一下每一个！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Learning about Spring Boot
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Spring Boot
- en: Beginning with Spring WebFlux
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Spring WebFlux开始
- en: Exploring SpringFox
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索SpringFox
- en: Understanding Spring Data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Spring Data
- en: Understanding Spring Cloud Stream
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Spring Cloud Stream
- en: Learning about Docker
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习Docker
- en: More details about each product will be provided in upcoming chapters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个产品的更多细节将在即将到来的章节中提供。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not contain any source code that can be downloaded, nor does
    it require any tools to be installed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不包含可下载的源代码，也不需要安装任何工具。
- en: Learning about Spring Boot
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Spring Boot
- en: Spring Boot, and the Spring Framework that Spring Boot is based on, is a great
    framework for developing microservices in Java.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot和Spring Boot基于的Spring Framework是在Java中开发微服务的一个很好的框架。
- en: When the Spring Framework was released in v1.0 back in 2004, it was released
    in order to fix the overly complex **J2EE** standard (short for **Java 2 Platforms,
    Enterprise Edition**) with its infamous and heavyweight deployment descriptors.
    Spring Framework provided a much more lightweight development model based on the
    concept of **dependency injection** (**DI**). Spring Framework also used far more
    lightweight XML configuration files compared to the deployment descriptors in
    J2EE.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当Spring Framework在2004年发布v1.0时，它是为了修复过于复杂的**J2EE**标准（即**Java 2平台企业版**）以及其臭名昭著和沉重的部署描述符。Spring
    Framework提供了一个基于**依赖注入**（**DI**）概念的轻量级开发模型。与J2EE中的部署描述符相比，Spring Framework还使用了更轻量级的XML配置文件。
- en: 'To make things even worse with the J2EE standard, the heavyweight deployment
    descriptors actually came in two types:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于J2EE标准来说，情况变得更糟糕了，这些沉重的部署描述符实际上有两种类型：
- en: Standard deployment descriptors, describing the configuration in a standardized
    way
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准部署描述符，以标准化的方式描述配置
- en: Vendor-specific deployment descriptors, mapping the configuration to vendor-specific
    features in the vendor's application server
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商特定的部署描述符，将配置映射到供应商应用服务器中的特定功能
- en: J2EE was renamed in 2006 to **Java EE**, short for **Java Platform, Enterprise
    Edition**, and recently, Oracle submitted Jave EE to the Eclipse foundation. In
    February 2018, Java EE was renamed Jakarta EE.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: J2EE在2006年更名为**Java EE**，即**Java平台企业版**，最近，Oracle将Jave EE提交给了Eclipse基金会。2018年2月，Java
    EE更名为Jakarta EE。
- en: Over the years, while the Spring Framework gained increasing popularity, the
    functionality in the Spring Framework grew significantly. Slowly, the burden of
    setting up a Spring application using the no-longer-so-lightweight XML configuration
    file became a problem.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，随着Spring Framework的日益流行，Spring Framework中的功能显著增长。慢慢地，使用不再那么轻量级的XML配置文件设置Spring应用程序的负担成为了一个问题。
- en: In 2014, Spring Boot v1.0 was released, addressing these problems!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 2014年，Spring Boot v1.0发布，解决了这些问题！
- en: Convention over configuration and fat JAR files
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 约定优于配置和fat JAR文件
- en: Spring Boot targets the fast development of production-ready Spring applications
    by being strongly opinionated about how to set up both core modules from the Spring
    Framework and third-party products, such as libraries that are used for logging
    or connecting to a database. Spring Boot does that by applying a number of conventions
    by default, minimizing the need for configuration. Whenever required, each convention
    can be overridden by writing some configuration, case by case. This design pattern
    is known as **convention over configuration** and minimizes the need for initial
    configuration.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot通过强烈的意见表达，针对如何设置Spring框架的核心模块和用于日志记录或连接到数据库的第三方产品，如库，来快速开发可投入生产的Spring应用程序。Spring
    Boot通过默认应用一些约定来实现这一点，最大程度地减少了配置的需求。每当需要时，可以通过逐案编写一些配置来覆盖每个约定。这种设计模式被称为**约定优于配置**，并最大程度地减少了初始配置的需求。
- en: Configuration, when required, is in my opinion written best using Java and annotations.
    The good old XML-based configuration files can still be used, although they are
    significantly smaller than before Spring Boot was introduced.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，当需要时，使用Java和注解编写配置是最好的。虽然旧的基于XML的配置文件仍然可以使用，但它们比Spring Boot引入之前要小得多。
- en: Added to the usage of *c**onvention over configuration*, Spring Boot also favors
    a runtime model based on a standalone JAR file, also known as a fat JAR file.
    Before Spring Boot, the most common way to run a Spring application was to deploy
    it as a WAR file on a Java EE web server, such as Apache Tomcat. WAR file deployment
    is still supported by Spring Boot.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用**约定优于配置**，Spring Boot还支持基于独立JAR文件的运行时模型，也称为fat JAR文件。在Spring Boot之前，运行Spring应用程序的最常见方式是将其部署为WAR文件在Java
    EE Web服务器上，比如Apache Tomcat。Spring Boot仍然支持WAR文件部署。
- en: A fat JAR file contains not only the classes and resource files of the application
    itself, but also all the `.jar` files the application depends on. This means that
    the fat JAR file is the only JAR file required to run the application; that is,
    we only need to transfer one JAR file to an environment where we want to run the
    application instead of transferring the application's JAR file along with all
    the JAR files the application depends on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个fat JAR文件不仅包含应用程序本身的类和资源文件，还包含应用程序依赖的所有`.jar`文件。这意味着fat JAR文件是运行应用程序所需的唯一JAR文件；也就是说，我们只需要将一个JAR文件传输到我们想要运行应用程序的环境中，而不是传输应用程序的JAR文件以及应用程序依赖的所有JAR文件。
- en: Starting a fat JAR requires no separately installed Java EE web server, such
    as Apache Tomcat. Instead, it can be started with a simple command such as `java
    -jar app.jar`, making it a perfect choice for running in a Docker container! If
    the Spring Boot application uses HTTP, for example, to expose a REST API, it will
    contain an embedded web server.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个fat JAR不需要单独安装Java EE Web服务器，比如Apache Tomcat。相反，它可以通过简单的命令启动，比如`java -jar
    app.jar`，这使得它成为在Docker容器中运行的完美选择！如果Spring Boot应用程序使用HTTP，例如用于暴露REST API，它将包含一个嵌入式Web服务器。
- en: Code examples for setting up a Spring Boot application
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Spring Boot应用程序的代码示例
- en: To better understand what this means, let's look at some source code examples.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这意味着什么，让我们看一些源代码示例。
- en: We will only look at some small fragments of code here to point out the main
    features. For a fully working example, you'll have to wait until the next chapter!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会在这里看一些小片段的代码来指出主要特点。要获得完全可用的示例，您必须等到下一章！
- en: The magic @SpringBootApplication annotation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 神奇的@SpringBootApplication注解
- en: 'The convention-based autoconfiguration mechanism can be initiated by annotating
    the application class, that is, the class that contains the static `main` method, 
    with the `@SpringBootApplication` annotation. The following code shows this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 基于约定的自动配置机制可以通过在应用程序类上注释来启动，即包含静态`main`方法的类，使用`@SpringBootApplication`注解。以下代码显示了这一点：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following functionality will be provided by this annotation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个注解将提供以下功能：
- en: It enables component scanning, that is, looking for Spring components and configuration
    classes in the package of the application class and all its sub-packages.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它启用了组件扫描，即在应用程序类的包及其所有子包中查找Spring组件和配置类。
- en: The application class itself becomes a configuration class.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序类本身成为配置类。
- en: It enables autoconfiguration, where Spring Boot looks for JAR files in the classpath
    that it can configure automatically. If you, for example, have Tomcat in the classpath,
    Spring Boot will automatically configure Tomcat as an embedded web server.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它启用了自动配置，其中Spring Boot会在类路径中查找可以自动配置的JAR文件。例如，如果类路径中有Tomcat，Spring Boot将自动将Tomcat配置为嵌入式Web服务器。
- en: Component scanning
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件扫描
- en: 'Let''s assume we have the following Spring component in the package of the
    application class (or in one of its sub-packages):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在应用程序类的包（或其子包）中有以下Spring组件：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another component in the application can get the component automatically injected,
    also known as **auto-wiring**, using the `@Autowired` annotation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的另一个组件可以自动注入该组件，也称为**自动装配**，使用`@Autowired`注解：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I prefer using constructor injection (over field and setter injection) to keep
    the state in my components immutable. The immutable state is important if you
    want to be able to run the component in a multithreaded runtime environment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用构造函数注入（而不是字段和setter注入）来保持组件中的状态不可变。如果您希望能够在多线程运行时环境中运行组件，不可变状态是很重要的。
- en: 'If we want to use components that are declared in a package outside the applications
    package, for example, a utility component shared by multiple Spring Boot applications,
    we can complement the `@SpringBootApplication` annotation in the application class
    with a `@ComponentScan` annotation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用在应用程序包之外声明的组件，例如多个Spring Boot应用程序共享的实用组件，我们可以在应用程序类中的`@SpringBootApplication`注解中补充一个`@ComponentScan`注解：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now auto-wire components from the `se.magnus.util` package in the application
    code, for example, a utility component, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在应用程序代码中自动装配`se.magnus.util`包中的组件，例如一个实用组件，如下所示：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This utility component can be auto-wired in an application component like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实用组件可以像这样自动装配到应用程序组件中：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Java-based configuration
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Java的配置
- en: If we want to override Spring Boot's default configuration or if we want to
    add our own configuration, we can simply annotate a class with `@Configuration` and
    it will be picked up by the component scanning mechanism we described previously.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要覆盖Spring Boot的默认配置，或者想要添加自己的配置，我们可以简单地用`@Configuration`注解一个类，它将被我们之前描述的组件扫描机制所捕获。
- en: 'If we, for example, want to set up a filter in the processing of HTTP requests
    (handled by Spring WebFlux, which is described as follows) that writes a log message
    at the beginning and at the end of the processing of the request, we can configure
    a log-filter, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们，例如，想要在处理HTTP请求时设置一个过滤器（由Spring WebFlux处理），在请求处理的开始和结束时写入日志消息，我们可以配置一个log-filter，如下所示：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can also place the configuration directly in the application class since
    the `@SpringBootApplication` annotation implies the `@Configuration` annotation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以直接将配置放在应用程序类中，因为`@SpringBootApplication`注解意味着`@Configuration`注解。
- en: Now that we have learned about Spring Boot, let's talk about Spring WebFlux.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Spring Boot，让我们谈谈Spring WebFlux。
- en: Beginning with Spring WebFlux
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Spring WebFlux开始
- en: Spring Boot 2.0 is based on Spring Framework 5.0, which came with built-in support
    for developing reactive applications. Spring Framework uses **Project Reactor **as
    the base implementation of its reactive support, and also comes with a new web
    framework, Spring WebFlux, which supports the development of reactive, that is,
    non-blocking, HTTP clients and services.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot 2.0基于Spring Framework 5.0，它内置了对开发响应式应用程序的支持。Spring Framework使用Project
    Reactor作为其响应式支持的基本实现，并且还配备了一个新的Web框架Spring WebFlux，支持开发响应式的，即非阻塞的HTTP客户端和服务。
- en: 'Spring WebFlux supports two different programming models:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux支持两种不同的编程模型：
- en: An annotation-based imperative style, similar to the already existing web framework,
    Spring Web MVC, but with support for reactive services
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于注解的命令式风格，类似于已经存在的Web框架Spring Web MVC，但支持响应式服务
- en: A new function-oriented model based on routers and handlers
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于路由器和处理程序的新的面向函数的模型
- en: In this book, we will use the annotation-based imperative style to demonstrate
    how easy it is to move REST services from Spring Web MVC to Spring WebFlux and
    then start to refactor the services so that they become fully reactive.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用基于注解的命令式风格来演示将REST服务从Spring Web MVC迁移到Spring WebFlux并开始重构服务，使其变得完全响应式。
- en: Spring WebFlux also provides a fully reactive HTTP client, `WebClient`, as a
    complement to the existing `RestTemplate` client.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux还提供了一个完全响应式的HTTP客户端`WebClient`，作为现有`RestTemplate`客户端的补充。
- en: Spring WebFlux supports running on a servlet container (it requires Servlet
    v3.1 or higher), but also supports reactive non-servlet-based embedded web servers
    such as Netty ([https://netty.io/](https://netty.io/)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux支持在Servlet容器上运行（需要Servlet v3.1或更高版本），但也支持反应式的非Servlet嵌入式Web服务器，如Netty（[https://netty.io/](https://netty.io/)）。
- en: Code examples of setting up a REST service using Spring WebFlux
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring WebFlux设置REST服务的代码示例
- en: Before we can create a REST service based on Spring WebFlux, we need to add Spring
    WebFlux (and the dependencies that Spring WebFlux requires) to the classpath for
    Spring Boot to be detected and configured during startup. Spring Boot provides
    a large number of convenient *starter dependencies* that bring in a specific feature,
    together with the dependencies each feature normally requires. So, let's use the
    starter dependency for Spring WebFlux and then see what a simple REST service
    looks like!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以基于Spring WebFlux创建REST服务之前，我们需要将Spring WebFlux（以及Spring WebFlux所需的依赖项）添加到Spring
    Boot的类路径中，以便在启动期间被检测和配置。Spring Boot提供了大量方便的*启动依赖项*，每个功能通常需要的依赖项。因此，让我们使用Spring
    WebFlux的启动依赖项，然后看看一个简单的REST服务是什么样子的！
- en: Starter dependencies
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动依赖项
- en: 'In this book, we will use Gradle as our build tool, so the Spring WebFlux starter
    dependency will be added to the `build.gradle` file. It looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用Gradle作为我们的构建工具，因此Spring WebFlux的启动依赖项将被添加到`build.gradle`文件中。它看起来像这样：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You might be wondering why we don't specify a version number.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我们不指定版本号。
- en: We will talk about that when we look at a complete example in  [Chapter 3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml),
    *Creating a Set of Cooperating Microservices*!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第3章](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml)中讨论一个完整的示例时再谈论这个问题，*创建一组协作微服务*！
- en: 'When the microservice is started up, Spring Boot will detect Spring WebFlux
    on the classpath and configure it, as well as other things that are used to start
    up an embedded web server. Netty is used by default, which we can see from the
    log output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当微服务启动时，Spring Boot将检测到类路径上的Spring WebFlux并对其进行配置，以及用于启动嵌入式Web服务器的其他内容。默认情况下使用Netty，我们可以从日志输出中看到：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we want to switch from Netty to Tomcat as our embedded web server, we can
    override the default configuration by excluding Netty from the starter dependency
    and add the starter dependency for Tomcat:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要从Netty切换到Tomcat作为我们的嵌入式Web服务器，我们可以通过排除Netty从启动依赖项中并添加Tomcat的启动依赖项来覆盖默认配置：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After restarting the microservice, we can see that Spring Boot picked Tomcat
    instead:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动微服务后，我们可以看到Spring Boot选择了Tomcat：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Property files
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性文件
- en: As you can see from the preceding examples, the web server is started up using
    port `8080`. If you want to change the port, you can override the default value
    using a property file. Spring Boot application property files can either be a
    `.properties` file or a YAML file. By default, they are named `application.properties` and `application.yml`,
    respectively.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的例子中可以看出，Web服务器是使用端口`8080`启动的。如果要更改端口，可以使用属性文件覆盖默认值。Spring Boot应用程序属性文件可以是`.properties`文件或YAML文件。默认情况下，它们分别命名为`application.properties`和`application.yml`。
- en: 'In this book, we will use YAML files so that the HTTP port used by the embedded
    web server can be changed to `7001`. By doing this, we can avoid port collisions
    with other microservices running on the same server. To do this, add the following
    line to the `application.yml` file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用YAML文件，以便将嵌入式Web服务器使用的HTTP端口更改为`7001`。通过这样做，我们可以避免与同一服务器上运行的其他微服务发生端口冲突。要做到这一点，请将以下行添加到`application.yml`文件中：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Sample RestController
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例RestController
- en: 'Now, with Spring WebFlux and an embedded web server of our choice in place,
    we can write a REST service in the same way as when using Spring MVC, that is,
    as `RestController`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了Spring WebFlux和我们选择的嵌入式Web服务器，我们可以以与使用Spring MVC相同的方式编写REST服务，即作为`RestController`：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `@GetMapping` annotation on the `listResources()` method will map the Java
    method to an HTTP `GET` API on the `host:8080/myResource` URL. The return value
    of the `List<Resource>` type will be converted into JSON.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`listResources()`方法上的`@GetMapping`注解将Java方法映射到`host:8080/myResource`URL上的HTTP
    `GET` API。`List<Resource>`类型的返回值将被转换为JSON。'
- en: Now that we've talked about Spring WebFlux, let's see what SpringFox is about.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了Spring WebFlux，让我们看看SpringFox是什么。
- en: Exploring SpringFox
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索SpringFox
- en: One very important aspect of developing APIs, for example, RESTful services,
    is how to document them so that they are easy to use. When it comes to RESTful
    services, Swagger is one of the most widely used ways of documenting RESTful services.
    Many leading API gateways have native support for exposing the documentation of RESTful
    services using Swagger.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 开发API的一个非常重要的方面，例如RESTful服务，是如何对其进行文档化，以便于使用。在RESTful服务方面，Swagger是最广泛使用的文档化RESTful服务的方式之一。许多领先的API网关都原生支持使用Swagger公开RESTful服务的文档。
- en: In 2015, SmartBear Software donated the Swagger specification to the Linux Foundation
    under the OpenAPI Initiative and created the OpenAPI Specification. The name Swagger
    is still used for the tooling provided by SmartBear Software.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年，SmartBear Software将Swagger规范捐赠给了Linux Foundation，成立了OpenAPI Initiative，并创建了OpenAPI规范。Swagger这个名字仍然被SmartBear
    Software提供的工具所使用。
- en: SpringFox is an open-source project, separate from the Spring Framework, that
    can create Swagger-based API documentation at runtime. It does so by examining
    the application at startup, for example, inspecting `WebFlux` and Swagger-based annotations.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: SpringFox是一个独立于Spring框架的开源项目，可以在运行时创建基于Swagger的API文档。它通过在启动时检查应用程序，例如检查`WebFlux`和基于Swagger的注解来实现这一点。
- en: 'We will look at full source code examples in upcoming chapters, but for now
    the following screenshot of this sample API documentation will do:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中查看完整的源代码示例，但现在这个示例API文档的截图就足够了：
- en: '![](img/9c5f6fb1-6de7-4c81-996c-8c69ede17c43.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c5f6fb1-6de7-4c81-996c-8c69ede17c43.png)'
- en: Note the big Execute button, which can be used to actually try out the API,
    not just read its documentation!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意大的执行按钮，它可以用来实际尝试API，而不仅仅是阅读它的文档！
- en: SpringFox helped us understand how microservices delved into Spring Framework.
    Now, let's move on to Spring Data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: SpringFox帮助我们了解了微服务如何深入Spring框架。现在，让我们继续学习Spring Data。
- en: Understanding Spring Data
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Spring Data
- en: Spring Data comes with a common programming model for persisting data in various
    types of database engine, ranging from traditional relational databases (SQL databases)
    to various types of NoSQL database engine, such as document databases (for example,
    MongoDB), key-value databases (for example, Redis), and graph databases (for example, Neo4J).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data提供了一种通用的编程模型，用于在各种类型的数据库引擎中持久化数据，从传统的关系数据库（SQL数据库）到各种类型的NoSQL数据库引擎，例如文档数据库（例如MongoDB）、键值数据库（例如Redis）和图数据库（例如Neo4J）。
- en: The Spring Data project is divided into several subprojects and in this book
    we will use Spring Data subprojects for MongoDB and JPA that have been mapped
    to a MySQL database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data项目分为几个子项目，在本书中，我们将使用已映射到MySQL数据库的Spring Data子项目，用于MongoDB和JPA。
- en: '**JPA** stands for **Java Persistence API** and is a Java specification about
    how to handle relational data. Please go to [https://jcp.org/aboutJava/communityprocess/mrel/jsr338/index.html](https://jcp.org/aboutJava/communityprocess/mrel/jsr338/index.html)
    for the latest specification, which is JPA 2.2 at the time of writing.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**JPA**代表**Java持久化API**，是关于如何处理关系数据的Java规范。请访问[https://jcp.org/aboutJava/communityprocess/mrel/jsr338/index.html](https://jcp.org/aboutJava/communityprocess/mrel/jsr338/index.html)获取最新的规范，目前是JPA
    2.2。'
- en: The two core concepts of the programming model in Spring Data are entities and
    repositories. Entities and repositories generalize how data is stored and accessed
    from the various types of database. They provide a common abstraction but still
    support adding database-specific behavior to the entities and repositories. These
    two core concepts are briefly explained together with some illustrative code examples
    as we proceed through this chapter. Remember that more details will be provided
    in the upcoming chapters!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data编程模型的两个核心概念是实体和存储库。实体和存储库概括了数据如何存储和从各种类型的数据库中访问。它们提供了一个共同的抽象，但仍然支持向实体和存储库添加特定于数据库的行为。这两个核心概念将随着本章的进行而简要解释，同时提供一些说明性的代码示例。请记住，更多的细节将在接下来的章节中提供！
- en: Even though Spring Data provides a common programming model for different types
    of database, this doesn't mean that you will be able to write portable source
    code, for example, switching the database technology from a SQL database to a
    NoSQL database, without changes needing to be made to the source code!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Spring Data为不同类型的数据库提供了一个通用的编程模型，但这并不意味着您将能够编写可移植的源代码，例如，将数据库技术从SQL数据库切换到NoSQL数据库，而无需对源代码进行更改！
- en: Entity
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体
- en: An entity describes the data that will be stored by Spring Data. Entity classes
    are, in general, annotated with a mix of generic Spring Data annotations and annotations
    that are specific to each database technology.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实体描述了Spring Data将存储的数据。实体类通常使用一些通用的Spring Data注解和特定于每种数据库技术的注解进行注释。
- en: 'For example, an entity that will be stored in a relational database can be
    annotated with JPA annotations such as the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将存储在关系数据库中的实体可以使用JPA注解进行注释，如下所示：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If an entity is to be stored in a MongoDB database, annotations from the Spring
    Data MongoDB subproject can be used together with generic Spring Data annotations.
    For example, consider the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将实体存储在MongoDB数据库中，可以使用Spring Data MongoDB子项目的注解与通用Spring Data注解一起使用。例如，考虑以下代码：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `@Id` and `@Version` annotations are generic annotations, while the `@Document`
    annotation is specific to the Spring Data MongoDB subproject.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Id`和`@Version`注解是通用注解，而`@Document`注解是Spring Data MongoDB子项目特有的。'
- en: This can be revealed by studying the import statements; that is, the import
    statements that contain `mongodb` come from the Spring Data MongoDB subproject.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过研究导入语句来揭示；也就是说，包含`mongodb`的导入语句来自Spring Data MongoDB子项目。
- en: Repositories
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储库
- en: Repositories are used to store and access data from different types of database.
    In its most basic form, a repository can be declared as a Java interface, and
    Spring Data will generate its implementation on the fly using opinionated conventions.
    These conventions can be overridden and/or complemented by additional configuration
    and, if required, some Java code. Spring Data also comes with some base Java interfaces,
    for example, `CrudRepository`, to make the definition of a repository even simpler.
    The base interface, `CrudRepository`, provides us with standard methods for create,
    read, update, and delete operations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库用于存储和访问不同类型数据库中的数据。在其最基本的形式中，存储库可以声明为Java接口，Spring Data将使用默认约定动态生成其实现。这些约定可以通过额外的配置来覆盖和/或补充，并且如果需要的话，还可以使用一些Java代码。Spring
    Data还提供了一些基本的Java接口，例如`CrudRepository`，以使存储库的定义更加简单。基础接口`CrudRepository`为我们提供了用于创建、读取、更新和删除操作的标准方法。
- en: 'To specify a repository for handling the JPA entity, `ReviewEntity`, we only
    need to declare the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定一个处理JPA实体`ReviewEntity`的存储库，我们只需要声明以下内容：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example we use a class, `ReviewEntityPK`, to describe a composite primary
    key. It looks as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用一个类`ReviewEntityPK`来描述一个复合主键。它看起来像这样：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We have also added an extra method, `findByProductId`, which allows us to look
    up `Review` entities based on `productId` – a field that is part of the primary
    key. The naming of the method follows a naming convention defined by Spring Data
    that allows Spring Data to generate the implementation of this method on the fly
    as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个额外的方法`findByProductId`，它允许我们根据`productId`查找`Review`实体 - 这是主键的一部分。该方法的命名遵循Spring
    Data定义的命名约定，允许Spring Data动态生成此方法的实现。
- en: 'If we want to use the repository, we can simply inject it and then start to
    use it, for example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用存储库，我们可以简单地注入它，然后开始使用它，例如：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Also added to the `CrudRepository` interface, Spring Data also provides a reactive
    base interface, `ReactiveCrudRepository`, which enables reactive repositories.
    The methods in this interface do not return objects or collections of objects;
    instead, they return `Mono` and `Flux` objects.  `Mono` and `Flux` objects are,
    as we will see in later chapters, reactive streams that are capable of returning
    either `0`..`1` or `0`..`m` entities as they become available on the stream. The
    reactive-based interface can only be used by Spring Data subprojects that support
    reactive database drivers; that is, they are based on non-blocking I/O. The Spring
    Data MongoDB subproject supports reactive repositories, while Spring Data JPA
    does not.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`CrudRepository`接口，Spring Data还提供了一个响应式基础接口`ReactiveCrudRepository`，它支持响应式存储库。该接口中的方法不返回对象或对象集合；而是返回`Mono`和`Flux`对象。`Mono`和`Flux`对象是，正如我们将在后面的章节中看到的，能够根据流上可用的`0`..`1`或`0`..`m`实体返回的响应式流。基于响应式的接口只能被支持响应式数据库驱动程序的Spring
    Data子项目使用；也就是说，它们是基于非阻塞I/O的。Spring Data MongoDB子项目支持响应式存储库，而Spring Data JPA不支持。
- en: 'Specifying a reactive repository for handling the MongoDB entity, `RecommendationEntity`,
    as described previously, might look something like the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为处理MongoDB实体`RecommendationEntity`指定一个响应式存储库可能看起来像下面这样：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This concludes the section on Spring Data. Now let's see what the Spring Cloud
    Stream is about.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了Spring Data。现在让我们看看Spring Cloud Stream是什么。
- en: Understanding Spring Cloud Stream
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Spring Cloud Stream
- en: 'We will not focus on Spring Cloud in this chapter; we will do that from [Chapter
    9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding Service Discovery Using
    Netflix Eureka and Ribbon* to [Chapter 14](42f456c5-d911-494a-a1ba-4631863068b6.xhtml),
    *Understanding Distributed Tracing*. However, we will bring in one of the modules
    that''s part of Spring Cloud: Spring Cloud Stream. Spring Cloud Stream provides
    a streaming abstraction over messaging, based on the publish-and-subscribe integration
    pattern. Spring Cloud Stream currently comes with support for Apache Kafka and
    RabbitMQ out of the box. A number of separate projects exist that provide integration
    with other popular messaging systems. See [https://github.com/spring-cloud?q=binder](https://github.com/spring-cloud?q=binder)
    for more details.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会专注于Spring Cloud；我们将从[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)开始，*使用Netflix
    Eureka和Ribbon添加服务发现*，直到[第14章](42f456c5-d911-494a-a1ba-4631863068b6.xhtml)，*理解分布式跟踪*。但是，我们将引入Spring
    Cloud的一个模块：Spring Cloud Stream。Spring Cloud Stream提供了基于发布-订阅集成模式的消息流抽象。Spring
    Cloud Stream目前默认支持Apache Kafka和RabbitMQ。还存在许多单独的项目，提供与其他流行的消息系统的集成。有关更多详细信息，请参见[https://github.com/spring-cloud?q=binder](https://github.com/spring-cloud?q=binder)。
- en: 'The core concepts in Spring Cloud Stream are as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream中的核心概念如下：
- en: '**Message:** A data structure that''s used to describe data sent to and received
    from a messaging system.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**：用于描述发送到消息系统和从消息系统接收的数据的数据结构。'
- en: '**Publisher:** Sends messages to the messaging system.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布者**：将消息发送到消息系统。'
- en: '**Subscriber**: Receives messages from the messaging system.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**订阅者**：从消息系统接收消息。'
- en: '**Channel:** Used to communicate with the messaging system. Publishers use
    output channels and subscribers use input channels.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通道**：用于与消息系统通信。发布者使用输出通道，订阅者使用输入通道。'
- en: '**Binder:** A binder provides the actual integration with a specific messaging
    system, similar to what a JDBC driver does for a specific type of database.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Binder**：提供与特定消息系统的实际集成，类似于JDBC驱动程序为特定类型的数据库所做的工作。'
- en: The actual messaging system to be used is determined at runtime, depending on
    what is found on the classpath. Spring Cloud Stream comes with opinionated conventions
    on how to handle messaging. These conventions can be overridden by specifying
    a configuration for messaging features such as consumer groups, partitioning,
    persistence, durability, and error handling, such as retries and dead letter queue
    handling.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用的实际消息系统是在运行时确定的，取决于类路径上找到了什么。Spring Cloud Stream带有关于如何处理消息的默认约定。这些约定可以通过指定消息特性的配置来覆盖，例如消费者组、分区、持久性、耐久性和错误处理，例如重试和死信队列处理。
- en: Code examples for sending and receiving messages with Spring Cloud Stream
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Stream发送和接收消息的代码示例
- en: To better understand how all this fits together, let's look at some source code
    examples.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解所有这些是如何组合在一起的，让我们看一些源代码示例。
- en: 'Let''s assume that we have a simple message class such as the following (constructors,
    getters, and setters have been left out for improved readability):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的消息类，如下所示（为了提高可读性，构造函数、getter和setter已被省略）：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Spring Cloud Stream comes with default input and output channels, `Sink` and `Source`,
    so we don''t need to create our own to get started. To publish a message, we can
    use the following source code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream带有默认的输入和输出通道，`Sink`和`Source`，因此我们无需创建自己的通道即可开始。要发布消息，我们可以使用以下源代码：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To receive messages, we can use the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要接收消息，我们可以使用以下代码：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To bind to RabbitMQ, we will use a dedicated starter dependency in the build
    file, `build.gradle`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要绑定到RabbitMQ，我们将在构建文件`build.gradle`中使用专用的starter依赖项：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the subscriber to receive messages from the publisher, we need to configure
    the input and output channel to use the same destination. If we use YAML to describe
    our configuration, it might look like the following for the publisher:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让订阅者从发布者那里接收消息，我们需要配置输入和输出通道以使用相同的目的地。如果我们使用YAML来描述我们的配置，发布者的配置可能如下所示：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The configuration for the subscriber is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者的配置如下：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We use `default.contentType` to specify that we prefer messages to be serialized
    in JSON format.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`default.contentType`来指定我们希望消息以JSON格式进行序列化。
- en: Now that we understand the various Spring APIs, let's understand a concept relatively
    newer, Docker, in the next section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了各种Spring API，让我们在下一节中了解一个相对较新的概念，Docker。
- en: Learning about Docker
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Docker
- en: I assume that Docker and the concept of containers need no in-depth presentation.
    Docker the concept of containers as a lightweight alternative to virtual machines
    very popular in 2013\. Containers are actually processed in a Linux host that
    uses Linux **namespaces** to provide between containers of global system resources,
    such as users, processes, filesystems, and networking. Linux control groups (also
    known as **cgroups**) are used to limit the amount of CPU and memory that a container
    is allowed to consume. Compared to a virtual machine that uses a hypervisor to
    run a complete copy of an operating system in each virtual machine, the overhead
    in a container is a fraction of the overhead in a virtual machine. This leads
    to much faster startup times and significantly lower overhead in terms of CPU
    and memory usage. The isolation that's provided for a container is, however, not
    considered to be as secure as the isolation that's provided for a virtual machine.
    With the release of Windows Server 2016, Microsoft supports the use of Docker
    in Windows servers.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设 Docker 和容器的概念不需要深入介绍。Docker 是一个轻量级替代虚拟机的概念，在 2013 年非常流行。容器实际上是在使用 Linux
    的 Linux 命名空间在 Linux 主机上处理的，以提供全局系统资源之间的容器，例如用户、进程、文件系统和网络。Linux 控制组（也称为 cgroups）用于限制容器被允许消耗的
    CPU 和内存量。与在每个虚拟机中使用 hypervisor 运行操作系统的完整副本的虚拟机相比，容器中的开销是虚拟机中开销的一小部分。这导致启动时间更快，CPU
    和内存使用方面的开销显著降低。然而，容器提供的隔离并不被认为与虚拟机提供的隔离一样安全。随着 Windows Server 2016 的发布，微软支持在 Windows
    服务器上使用 Docker。
- en: Containers are very useful both during development and testing. Being able to
    start up a complete system landscape of cooperating microservices and resource
    managers (for example, database servers, messaging brokers, and so on) with a
    single command for testing is simply amazing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在开发和测试期间都非常有用。能够通过一个命令启动一整套协作微服务和资源管理器（例如，数据库服务器、消息代理等）进行测试，简直太神奇了。
- en: For example, we can write scripts in order to automate end-to-end tests of our microservice
    landscape. A test script can start up the microservice landscape, run tests using
    the exposed services, and tear down the landscape. This type of automated test
    script is very useful, both for running locally on a developer PC before pushing
    code to a source code repository, and to be executed as a step in a delivery pipeline.
    A build server can run these types of test in its continuous integration and deployment
    process whenever a developer pushes code to the source repository.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以编写脚本来自动化端到端测试我们的微服务景观。测试脚本可以启动微服务景观，使用暴露的服务运行测试，然后拆除景观。这种类型的自动化测试脚本非常有用，既可以在开发人员将代码推送到源代码存储库之前在开发人员的个人计算机上运行，也可以作为交付流程中的一步执行。构建服务器可以在持续集成和部署过程中运行这些类型的测试，每当开发人员将代码推送到源代码存储库时。
- en: For production usage, we need a container orchestrator such as Kubernetes. We
    will get back to container orchestrators and Kubernetes later in this book.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产使用，我们需要像 Kubernetes 这样的容器编排器。我们将在本书的后面再回到容器编排器和 Kubernetes。
- en: 'For most of the microservices we will look at in this book, a Dockerfile such
    as the following is all that is required to run the microservice as a Docker container:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中将要介绍的大多数微服务，只需要一个类似下面的 Dockerfile 就可以将微服务作为 Docker 容器运行：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we want to start and stop many containers with one command, Docker Compose
    is the perfect tool. Docker Compose uses a YAML file to describe the containers
    to be managed. For our microservices, it might look something like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要用一个命令启动和停止多个容器，Docker Compose 是一个完美的工具。Docker Compose 使用一个 YAML 文件来描述要管理的容器。对于我们的微服务，它可能看起来像下面这样：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let me explain the preceding source code a little:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我稍微解释一下前面的源代码：
- en: The `build` directive is used to specify which Dockerfile to use for each microservice.
    Docker Compose will use it to build a Docker image and then launch a Docker container
    based on that Docker image.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build` 指令用于指定每个微服务使用哪个 Dockerfile。Docker Compose 将使用它来构建一个 Docker 镜像，然后基于该
    Docker 镜像启动一个 Docker 容器。'
- en: The `ports` directive for the composite service is used to expose port `8080`
    on the server where Docker runs. On a developer's machine, this means that the
    port of the composite service can be reached simply by using `localhost:8080`!
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports` 指令用于在运行 Docker 的服务器上暴露端口 `8080`。在开发人员的机器上，这意味着可以通过简单地使用 `localhost:8080`
    来访问复合服务的端口！'
- en: 'All the containers in the YAML files can be managed with simple commands such
    as the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 文件中的所有容器都可以通过以下简单的命令进行管理：
- en: '`docker-compose up -d`: Starts all containers. `-d` means that the containers
    run in the background, not locking the Terminal from where the command was executed.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose up -d`：启动所有容器。`-d` 表示容器在后台运行，不会锁定执行命令的终端。'
- en: '`docker-compose down`: Stops and removes all containers.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose down`：停止并移除所有容器。'
- en: '`docker-compose logs -f --tail=0`: Prints out log messages from all containers. `-f`
    means that the command will not complete, and instead waits for new log messages. `--tail=0`
    means that we don''t want to see any previous log messages, only new ones.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose logs -f --tail=0`：打印出所有容器的日志消息。`-f` 表示命令不会完成，而是等待新的日志消息。`--tail=0`
    表示我们不想看到任何先前的日志消息，只想看到新的日志消息。'
- en: This was a brief introduction to Docker. We will go into more detail about Docker
    in the last few chapters of this book.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 Docker 的简要介绍。我们将在本书的最后几章中更详细地介绍 Docker。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have been introduced to Spring Boot and complementary open
    source tools that can be used to build cooperating microservices.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Spring Boot 和可以用来构建协作微服务的补充开源工具。
- en: Spring Boot is used to simplify the development of Spring-based, production-ready
    applications. It is strongly opinionated in terms of how to set up both core modules
    from the Spring Framework and third-party products.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot用于简化基于Spring的、适用于生产的应用程序的开发。它在如何设置Spring框架的核心模块和第三方产品方面有着强烈的意见。
- en: Spring WebFlux is a new module in the Spring family and is used to develop reactive,
    that is, non-blocking, REST services. It runs on both lightweight web servers
    such as Netty and on any Servlet 3.1+ compatible web server. It also supports
    the programming model from the older Spring MVC module; it is easy to move REST
    services written for Spring MVC to Spring WebFlux without fully rewriting the
    code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Spring WebFlux是Spring家族中的一个新模块，用于开发响应式、即非阻塞的REST服务。它可以在轻量级的Web服务器（如Netty）上运行，也可以在任何兼容Servlet
    3.1+的Web服务器上运行。它还支持旧的Spring MVC模块的编程模型；可以很容易地将为Spring MVC编写的REST服务移植到Spring WebFlux，而无需完全重写代码。
- en: SpringFox can be used to create Swagger and OpenAPI-based documentation regarding
    REST services. It creates the documentation on the fly at runtime by inspecting
    the annotations for the REST services – both the Spring annotations and some Swagger
    specific annotations – if used.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: SpringFox可以用于创建关于REST服务的Swagger和OpenAPI文档。它通过检查REST服务的注解（包括Spring注解和一些特定的Swagger注解）在运行时动态创建文档。
- en: Spring Data provides an elegant abstraction for accessing and manipulating persistent
    data using entities and repositories. The programming model is similar, but isn't
    portable between different types of database, for example, relational, document,
    key-value, and graph databases.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data提供了一种优雅的抽象，用于访问和操作持久数据，使用实体和存储库。编程模型类似，但不能在不同类型的数据库之间进行移植，例如关系型、文档型、键值型和图形数据库。
- en: Spring Cloud Stream provides a streaming abstraction over messaging, based on
    the publish and subscribe integration pattern. Spring Cloud Stream comes with
    out of the box support for Apache Kafka and RabbitMQ but can be extended to support
    other messaging brokers using custom binders.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud Stream提供了基于发布和订阅集成模式的消息流抽象。Spring Cloud Stream内置支持Apache Kafka和RabbitMQ，但可以通过自定义绑定器扩展以支持其他消息代理。
- en: Docker makes the concept of containers as a lightweight alternative to virtual
    machines easy to use. Based on Linux Namespaces and Control Groups, containers
    provide isolation similar to what traditional virtual machines provide, but with
    a significantly lower overhead in terms of CPU and memory usage. Docker is a very
    good tool for development and testing but in most cases requires a container orchestrator
    such as Kubernetes to be used in a production environment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使得容器的概念作为虚拟机的轻量级替代方案变得容易使用。基于Linux命名空间和控制组，容器提供了类似于传统虚拟机的隔离，但在CPU和内存使用方面具有显著更低的开销。Docker是开发和测试的非常好的工具，但在大多数情况下需要像Kubernetes这样的容器编排器在生产环境中使用。
- en: Questions
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the purpose of the `@SpringBootApplication` annotation?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@SpringBootApplication`注解的作用是什么？'
- en: What are the main differences between the older Spring component for developing
    REST services, Spring Web MVC, and the new Spring WebFlux?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧的用于开发REST服务的Spring组件Spring Web MVC和新的Spring WebFlux之间的主要区别是什么？
- en: How does SpringFox help a developer document REST APIs?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SpringFox如何帮助开发人员记录REST API？
- en: What is the function of a repository in Spring Data and what is the simplest
    possible implementation of a repository?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Data中存储库的作用是什么，存储库的最简单可能的实现是什么？
- en: What is the purpose of a binder in Spring Cloud Stream?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Spring Cloud Stream中绑定器的作用是什么？
- en: What is the purpose of Docker Compose?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose的目的是什么？
