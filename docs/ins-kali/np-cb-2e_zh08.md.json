["```py\n    $ sudo pip install pyflakes\n\n    ```", "```py\n    $ sudo easy_install pyflakes\n\n    ```", "```py\n    $ sudo yum install pyflakes\n\n    ```", "```py\n    $ sudo apt-get install pyflakes\n\n    ```", "```py\n    $ git clone git://github.com/numpy/numpy.git numpy\n\n    ```", "```py\n    $ pyflakes *.py\n    pavement.py:71: redefinition of unused 'md5' from line 69\n    pavement.py:88: redefinition of unused 'GIT_REVISION' from line 86\n    pavement.py:314: 'virtualenv' imported but unused\n    pavement.py:315: local variable 'e' is assigned to but never used\n    pavement.py:380: local variable 'sdir' is assigned to but never used\n    pavement.py:381: local variable 'bdir' is assigned to but never used\n    pavement.py:536: local variable 'st' is assigned to but never used\n    setup.py:21: 're' imported but unused\n    setup.py:27: redefinition of unused 'builtins' from line 25\n    setup.py:124: redefinition of unused 'GIT_REVISION' from line 118\n    setupegg.py:17: 'setup' imported but unused\n    setupscons.py:61: 'numpy' imported but unused\n    setupscons.py:64: 'numscons' imported but unused\n    setupsconsegg.py:6: 'setup' imported but unused\n\n    ```", "```py\n$ easy_install pylint\n$ sudo pip install pylint\n\n```", "```py\n$ pylint *.py\nNo config file found, using default configuration\n************* Module pavement\nC: 60: Line too long (81/80)\nC:139: Line too long (81/80)\n...\nW: 50: TODO\nW:168: XXX: find out which env variable is necessary to avoid the pb with python\nW: 71: Reimport 'md5' (imported line 143)\nF: 73: Unable to import 'paver'\nF: 74: Unable to import 'paver.easy'\nC: 79: Invalid name \"setup_py\" (should match (([A-Z_][A-Z0-9_]*)|(__.*__))$)\nF: 86: Unable to import 'numpy.version'\nE: 86: No name 'version' in module 'numpy'\nC:149: Operator not followed by a space\nif sys.platform ==\"darwin\":\n ^^\nC:202:prepare_nsis_script: Missing docstring\nW:228:bdist_superpack: Redefining name 'options' from outer scope (line 74)\nC:231:bdist_superpack.copy_bdist: Missing docstring\nW:275:bdist_wininst_nosse: Redefining name 'options' from outer scope (line 74)\n\n```", "```py\nMESSAGE_TYPE: LINE_NUM:[OBJECT:] MESSAGE\n\n```", "```py\n    $ python setup.py install\n\n    ```", "```py\n    $ sudo pip install http://sourceforge.net/projects/pychecker/files/pychecker/0.8.19/pychecker-0.8.19.tar.gz/download\n\n    ```", "```py\n    $ pychecker *.py\n    ...\n    Warnings...\n\n    ...\n\n    setup.py:21: Imported module (re) not used\n    setup.py:27: Module (builtins) re-imported\n\n    ...\n    ```", "```py\n    \"\"\"\n    Test for the factorial of 3 that should pass.\n    >>> factorial(3)\n    6\n\n    Test for the factorial of 0 that should fail.\n    >>> factorial(0)\n    1\n    \"\"\"\n\n    ```", "```py\n    return np.arange(1, n+1).cumprod()[-1]\n    ```", "```py\n    doctest.testmod()\n    ```", "```py\n    import numpy as np\n    import doctest\n\n    def factorial(n):\n       \"\"\"\n       Test for the factorial of 3 that should pass.\n       >>> factorial(3)\n       6\n\n       Test for the factorial of 0 that should fail.\n       >>> factorial(0)\n       1\n       \"\"\"\n       return np.arange(1, n+1).cumprod()[-1]\n\n    doctest.testmod()\n    ```", "```py\n    $ python docstringtest.py -v\n    Trying:\n     factorial(3)\n    Expecting:\n     6\n    ok\n    Trying:\n     factorial(0)\n    Expecting:\n     1\n    **********************************************************************\n    File \"docstringtest.py\", line 11, in __main__.factorial\n    Failed example:\n     factorial(0)\n    Exception raised:\n     Traceback (most recent call last):\n     File \".../doctest.py\", line 1253, in __run\n     compileflags, 1) in test.globs\n     File \"<doctest __main__.factorial[1]>\", line 1, in <module>\n     factorial(0)\n     File \"docstringtest.py\", line 14, in factorial\n     return numpy.arange(1, n+1).cumprod()[-1]\n     IndexError: index out of bounds\n    1 items had no tests:\n     __main__\n    **********************************************************************\n    1 items had failures:\n     1 of   2 in __main__.factorial\n    2 tests in 2 items.\n    1 passed and 1 failed.\n    ***Test Failed*** 1 failures.\n\n    ```", "```py\n    def factorial(n):\n      if n == 0:\n        return 1\n\n      if n < 0:\n        raise ValueError, \"Don't be so negative\"\n\n      return np.arange(1, n+1).cumprod()\n    ```", "```py\n        class FactorialTest(unittest.TestCase):\n            def test_factorial(self):\n              #Test for the factorial of 3 that should pass.\n              self.assertEqual(6, factorial(3)[-1])\n              np.testing.assert_equal(np.array([1, 2, 6]), factorial(3))\n\n            def test_zero(self):\n              #Test for the factorial of 0 that should pass.\n              self.assertEqual(1, factorial(0))\n\n            def test_negative(self):\n              #Test for the factorial of negative numbers that should fail.\n              # It should throw a ValueError, but we expect IndexError\n              self.assertRaises(IndexError, factorial(-10))\n        ```", "```py\n        import numpy as np\n        import unittest\n\n        def factorial(n):\n           if n == 0:\n              return 1\n\n           if n < 0:\n              raise ValueError, \"Don't be so negative\"\n\n           return np.arange(1, n+1).cumprod()\n\n        class FactorialTest(unittest.TestCase):\n           def test_factorial(self):\n              #Test for the factorial of 3 that should pass.\n              self.assertEqual(6, factorial(3)[-1])\n              np.testing.assert_equal(np.array([1, 2, 6]), factorial(3))\n\n           def test_zero(self):\n              #Test for the factorial of 0 that should pass.\n              self.assertEqual(1, factorial(0))\n\n           def test_negative(self):\n              #Test for the factorial of negative numbers that should fail.\n              # It should throw a ValueError, but we expect IndexError\n              self.assertRaises(IndexError, factorial(-10))\n\n        if __name__ == '__main__':\n            unittest.main()\n        ```", "```py\n        .E.\n        ======================================================================\n        ERROR: test_negative (__main__.FactorialTest)\n        ----------------------------------------------------------------------\n        Traceback (most recent call last):\n         File \"unit_test.py\", line 26, in test_negative\n         self.assertRaises(IndexError, factorial(-10))\n         File \"unit_test.py\", line 9, in factorial\n         raise ValueError, \"Don't be so negative\"\n        ValueError: Don't be so negative\n\n        ----------------------------------------------------------------------\n        Ran 3 tests in 0.001s\n\n        FAILED (errors=1)\n\n        ```", "```py\n    $ sudo easy_install mock\n\n    ```", "```py\n    reactor.factorial = MagicMock(return_value=6)\n    ```", "```py\n    reactor.factorial.assert_called_with(3, \"mocked\")\n    ```", "```py\n    from __future__ import print_function\n    from mock import MagicMock\n    import numpy as np\n    import unittest\n\n    class NuclearReactor():\n       def __init__(self, n):\n          self.n = n\n\n       def do_work(self, msg):\n          print(\"Working\")\n\n          return self.factorial(self.n, msg)\n\n       def factorial(self, n, msg):\n          print(msg)\n\n          if n == 0:\n             return 1\n\n          if n < 0:\n             raise ValueError, \"Core meltdown\"\n\n          return np.arange(1, n+1).cumprod()\n\n    class NuclearReactorTest(unittest.TestCase):\n       def test_called(self):\n          reactor = NuclearReactor(3)\n          reactor.factorial = MagicMock(return_value=6)\n          result = reactor.do_work(\"mocked\")\n          self.assertEqual(6, result)\n          reactor.factorial.assert_called_with(3, \"mocked\")\n\n       def test_unmocked(self):\n          reactor = NuclearReactor(3)\n          reactor.factorial(3, \"unmocked\")\n          np.testing.assert_raises(ValueError)\n\n    if __name__ == '__main__':\n        unittest.main()\n    ```", "```py\nWorking\n.unmocked\n.\n----------------------------------------------------------------------\nRan 2 tests in 0.000s\n\nOK\n\n```", "```py\n    $ pip install lettuce\n    $ sudo easy_install lettuce\n\n    ```", "```py\n    ./tests:\n    features\n\n    ./tests/features:\n    factorial.feature\tsteps.py\n\n    ```", "```py\n    Feature: Compute factorial\n\n        Scenario: Factorial of 0\n          Given I have the number 0 \n          When I compute its factorial \n          Then I see the number 1\n\n        Scenario: Factorial of 1\n          Given I have the number 1 \n          When I compute its factorial \n          Then I see the number 1\n\n        Scenario: Factorial of 3\n          Given I have the number 3 \n          When I compute its factorial \n          Then I see the number 1, 2, 6\n    ```", "```py\n    from lettuce import *\n    import numpy as np\n\n    @step('I have the number (\\d+)')\n    def have_the_number(step, number):\n        world.number = int(number)\n\n    @step('I compute its factorial')\n    def compute_its_factorial(step):\n        world.number = factorial(world.number)\n\n    @step('I see the number (.*)')\n    def check_number(step, expected):\n        expected = np.fromstring(expected, dtype=int, sep=',')\n        np.testing.assert_equal(world.number, expected, \\\n            \"Got %s\" % world.number)\n\n    def factorial(n):\n       if n == 0:\n          return 1\n\n       if n < 0:\n          raise ValueError, \"Core meltdown\"\n\n       return np.arange(1, n+1).cumprod()\n    ```", "```py\n    $ lettuce\n\n    Feature: Compute factorial        # features/factorial.feature:1\n\n     Scenario: Factorial of 0        # features/factorial.feature:3\n     Given I have the number 0     # features/steps.py:5\n     When I compute its factorial  # features/steps.py:9\n     Then I see the number 1       # features/steps.py:13\n\n     Scenario: Factorial of 1        # features/factorial.feature:8\n     Given I have the number 1     # features/steps.py:5\n     When I compute its factorial  # features/steps.py:9\n     Then I see the number 1       # features/steps.py:13\n\n     Scenario: Factorial of 3        # features/factorial.feature:13\n     Given I have the number 3     # features/steps.py:5\n     When I compute its factorial  # features/steps.py:9\n     Then I see the number 1, 2, 6 # features/steps.py:13\n\n    1 feature (1 passed)\n    3 scenarios (3 passed)\n    9 steps (9 passed)\n\n    ```"]