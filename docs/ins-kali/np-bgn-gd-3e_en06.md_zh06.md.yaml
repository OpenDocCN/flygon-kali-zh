- en: Chapter 6. Moving Further with NumPy Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章：深入探索 NumPy 模块
- en: '*NumPy has a number of modules inherited from its predecessor, Numeric. Some
    of these packages have a SciPy counterpart, which may have fuller functionality.
    We will discuss SciPy in a later chapter.*'
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 具有许多从其前身 Numeric 继承的模块。 其中一些包具有 SciPy 对应版本，可能具有更完整的功能。 我们将在下一章中讨论 SciPy。
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: The `linalg` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linalg`包'
- en: The `fft` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fft`包'
- en: Random numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数
- en: Continuous and discrete distributions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续和离散分布
- en: Linear algebra
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线性代数
- en: Linear algebra is an important branch of mathematics. The `numpy.linalg` package
    contains linear algebra functions. With this module, you can invert matrices,
    calculate eigenvalues, solve linear equations, and determine determinants, among
    other things (see [http://docs.scipy.org/doc/numpy/reference/routines.linalg.html](http://docs.scipy.org/doc/numpy/reference/routines.linalg.html)).
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数是数学的重要分支。 `numpy.linalg`包包含线性代数函数。 使用此模块，您可以求矩阵求逆，计算特征值，求解线性方程式和确定行列式等（见[`docs.scipy.org/doc/numpy/reference/routines.linalg.html`](http://docs.scipy.org/doc/numpy/reference/routines.linalg.html)）。
- en: Time for action – inverting matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：转换矩阵
- en: 'The inverse of a matrix `A` in linear algebra is the matrix `A^(-1)`, which,
    when multiplied with the original matrix, is equal to the identity matrix `I`.
    This can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数中矩阵`A`的逆是矩阵`A^(-1)`，当与原始矩阵相乘时，它等于单位矩阵`I`。 可以这样写：
- en: '`A A^(-1) = I`'
  prefs: []
  type: TYPE_NORMAL
  zh: '`A A^(-1) = I`'
- en: 'The `inv()` function in the `numpy.linalg` package can invert an example matrix
    with the following steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.linalg`包中的`inv()`函数可以通过以下步骤反转示例矩阵：'
- en: 'Create the example matrix with the `mat()` function we used in the previous
    chapters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面章节中使用的`mat()`函数创建示例矩阵：
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `A` matrix appears as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`A`矩阵如下所示：'
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Invert the matrix with the `inv()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`inv()`函数将矩阵求逆：
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The inverse matrix appears as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 逆矩阵如下所示：
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If the matrix is singular, or not square, a `LinAlgError` is raised. If you
    want, you can check the result manually with a pen and paper. This is left as
    an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
  zh: 如果矩阵是奇异的，或者不是正方形，则引发`LinAlgError`。 如果需要，可以用笔和纸手动检查结果。 这留给读者练习。
- en: 'Check the result by multiplying the original matrix with the result of the
    `inv()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将原始矩阵乘以`inv()`函数的结果来检查结果：
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result is the identity matrix, as expected:'
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是单位矩阵，如预期的那样：
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We calculated the inverse of a matrix with the `inv()` function of the `numpy.linalg`
    package. We checked, with matrix multiplication, whether this is indeed the inverse
    matrix (see `inversion.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`numpy.linalg`包的`inv()`函数计算了矩阵的逆。 我们使用矩阵乘法检查了这是否确实是逆矩阵（请参见`inversion.py`）：
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Pop quiz – creating a matrix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小测验 - 创建矩阵
- en: Q1\. Which function can create matrices?
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 哪个函数可以创建矩阵？
- en: '`array`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`array`'
- en: create_matrix
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`create_matrix`'
- en: mat
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`mat`'
- en: vector
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`vector`'
- en: Have a go hero – inverting your own matrix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 勇往直前：反转自己的矩阵
- en: Create your own matrix and invert it. The inverse is only defined for square
    matrices. The matrix must be square and invertible; otherwise, a `LinAlgError`
    exception is raised.
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的矩阵并将其求逆。 逆仅针对方阵定义。 矩阵必须是正方形且可逆； 否则，将引发`LinAlgError`异常。
- en: Solving linear systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 求解线性系统
- en: A matrix transforms a vector into another vector in a linear way. This transformation
    mathematically corresponds to a system of linear equations. The `numpy.linalg`
    function `solve()` solves systems of linear equations of the form `Ax = b`, where
    `A` is a matrix, `b` can be a one-dimensional or two-dimensional array, and `x`
    is an unknown variable. We will see the `dot()` function in action. This function
    returns the dot product of two floating-point arrays.
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵以线性方式将向量转换为另一个向量。 该变换在数学上对应于线性方程组。 `numpy.linalg`函数`solve()`求解形式为`Ax = b`的线性方程组，其中`A`是矩阵，`b`可以是一维或二维数组，而`x`是未知数变量。
    我们将看到`dot()`函数的使用。 此函数返回两个浮点数组的点积。
- en: 'The `dot()` function calculates the dot product (see [https://www.khanacademy.org/math/linear-algebra/vectors_and_spaces/dot_cross_products/v/vector-dot-product-and-vector-length](https://www.khanacademy.org/math/linear-algebra/vectors_and_spaces/dot_cross_products/v/vector-dot-product-and-vector-length)).
    For a matrix `A` and vector `b`, the dot product is equal to the following sum:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`dot()`函数计算点积（见[`www.khanacademy.org/math/linear-algebra/vectors_and_spaces/dot_cross_products/v/vector-dot-product-and-vector-length`](https://www.khanacademy.org/math/linear-algebra/vectors_and_spaces/dot_cross_products/v/vector-dot-product-and-vector-length)）。
    对于矩阵`A`和向量`b`，点积等于以下总和：'
- en: '![Solving linear systems](img/4154_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![求解线性系统](img/4154_06_08.jpg)'
- en: Time for action – solving a linear system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '实战时间：解决线性系统'
- en: 'Solve an example of a linear system with the following steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: '通过以下步骤解决线性系统的示例：'
- en: 'Create `A` and `b`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`A`和`b`：
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`A` and `b` appear as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`A`和`b`出现如下：'
- en: '![Time for action – solving a linear system](img/4154_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：解决线性系统](img/4154_06_07.jpg)'
- en: 'Solve this linear system with the `solve()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`solve()`函数求解线性系统：
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The solution of the linear system is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 线性系统的解如下：
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Check whether the solution is correct with the `dot()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dot()`函数检查解决方案是否正确：
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The result is as expected:'
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是预期的：
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We solved a linear system using the `solve()` function from the NumPy linalg
    module and checked the solution with the `dot()` function. Please refer to the
    `solution.py` file in this book''s code bundle:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 NumPy `linalg`模块的`solve()`函数求解了线性系统，并使用`dot()`函数检查了解。 请参考本书代码捆绑中的`solution.py`文件：
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Finding eigenvalues and eigenvectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找特征值和特征向量
- en: '**Eigenvalues** are scalar solutions to the equation `Ax = ax`, where `A` is
    a two-dimensional matrix and `x` is a one-dimensional vector. **Eigenvectors**
    are vectors corresponding to eigenvalues (see [https://www.khanacademy.org/math/linear-algebra/alternate_bases/eigen_everything/v/linear-algebra-introduction-to-eigenvalues-and-eigenvectors](https://www.khanacademy.org/math/linear-algebra/alternate_bases/eigen_everything/v/linear-algebra-introduction-to-eigenvalues-and-eigenvectors)).
    The `eigvals()` function in the `numpy.linalg` package calculates eigenvalues.
    The `eig()` function returns a tuple containing eigenvalues and eigenvectors.'
  prefs: []
  type: TYPE_NORMAL
  zh: '**特征值**是方程`Ax = ax`的标量解，其中`A`是二维矩阵，`x`是一维向量。**特征向量**是对应于特征值的向量（见[`www.khanacademy.org/math/linear-algebra/alternate_bases/eigen_everything/v/linear-algebra-introduction-to-eigenvalues-and-eigenvectors`](https://www.khanacademy.org/math/linear-algebra/alternate_bases/eigen_everything/v/linear-algebra-introduction-to-eigenvalues-and-eigenvectors)）。
    `numpy.linalg`包中的`eigvals()`函数计算特征值。 `eig()`函数返回包含特征值和特征向量的元组。'
- en: Time for action – determining eigenvalues and eigenvectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：确定特征值和特征向量
- en: 'Let''s calculate the eigenvalues of a matrix:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算矩阵的特征值：
- en: 'Create a matrix as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个矩阵，如下所示：
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The matrix we created looks like the following:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的矩阵如下所示：
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Call the `eigvals()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`eigvals()`函数：
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The eigenvalues of the matrix are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的特征值如下：
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Determine eigenvalues and eigenvectors with the `eig()` function. This function
    returns a tuple, where the first element contains eigenvalues and the second element
    contains corresponding eigenvectors, arranged column-wise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`eig（）`函数确定特征值和特征向量。 此函数返回一个元组，其中第一个元素包含特征值，第二个元素包含相应的特征向量，按列排列：
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The eigenvalues and eigenvectors appear as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 特征值和特征向量如下所示：
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Check the result with the `dot()` function by calculating the right and left
    side of the eigenvalues equation `Ax = ax`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过计算特征值方程`Ax = ax`的右侧和左侧，使用`dot()`函数检查结果：
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We found the eigenvalues and eigenvectors of a matrix with the `eigvals()`
    and `eig()` functions of the `numpy.linalg` module. We checked the result using
    the `dot()` function (see `eigenvalues.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现了具有`numpy.linalg`模块的`eigvals()`和`eig()`函数的矩阵的特征值和特征向量。 我们使用`dot()`函数检查了结果（请参见`eigenvalues.py`）：
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Singular value decomposition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 奇异值分解
- en: '**Singular** **value** **decomposition** (**SVD**) is a type of factorization
    that decomposes a matrix into a product of three matrices. The SVD is a generalization
    of the previously discussed eigenvalue decomposition. SVD is very useful for algorithms
    such as the pseudo inverse, which we will discuss in the next section. The `svd()`
    function in the `numpy.linalg` package can perform this decomposition. This function
    returns three matrices `U`, `∑`, and `V` such that `U` and `V` are unitary and
    `∑` contains the singular values of the input matrix:'
  prefs: []
  type: TYPE_NORMAL
  zh: '**奇异值分解**（**SVD**）是一种分解因子，可以将矩阵分解为三个矩阵的乘积。 SVD 是先前讨论的特征值分解的概括。 SVD 对于像这样的伪逆算法非常有用，我们将在下一部分中进行讨论。
    `numpy.linalg`包中的  `svd()`函数可以执行此分解。 此函数返回三个矩阵`U`，`∑`和`V`，使得`U`和`V`为一元且`∑`包含输入矩阵的奇异值：'
- en: '![Singular value decomposition](img/4154_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![奇异值分解](img/4154_06_09.jpg)'
- en: The asterisk denotes the **Hermitian** **conjugate** or the **conjugate** **transpose**.
    The **complex** **conjugate** changes the sign of the imaginary part of a complex
    number and is therefore not relevant for real numbers.
  prefs: []
  type: TYPE_NORMAL
  zh: 星号表示**厄密特共轭**或**共轭转置**。**复数的共轭**改变复数虚部的符号，因此与实数无关。
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: A complex square matrix A is unitary if `A^*A = AA^* = I` (the identity matrix).
    We can interpret SVD as a sequence of three operations—rotation, scaling, and
    another rotation.
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`A*A = AA* = I`（单位矩阵），则复方矩阵 A 是单位的。 我们可以将 SVD 解释为三个操作的序列-旋转，缩放和另一个旋转。
- en: We already transposed matrices in this book. The transpose flips matrices, turning
    rows into columns, and columns into rows.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在本书中转置了矩阵。 转置翻转矩阵，将行变成列，然后将列变成行。
- en: Time for action – decomposing a matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：分解矩阵
- en: 'It''s time to decompose a matrix with the SVD using the following steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: 现在该使用以下步骤用 SVD 分解矩阵：
- en: 'First, create a matrix as shown in the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建如下所示的矩阵：
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The matrix we created looks like the following:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的矩阵如下所示：
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Decompose the matrix with the `svd()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`svd()`函数分解矩阵：
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Because of the `full_matrices=False` specification, NumPy performs a reduced
    SVD decomposition, which is faster to compute. The result is a tuple containing
    the two unitary matrices `U` and `V` on the left and right, respectively, and
    the singular values of the middle matrix:'
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`full_matrices=False`规范，NumPy 执行了简化的 SVD 分解，计算速度更快。 结果是一个元组，在左侧和右侧分别包含两个单位矩阵`U`和`V`，以及中间矩阵的奇异值：
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We do not actually have the middle matrix—we only have the diagonal values.
    The other values are all 0\. Form the middle matrix with the `diag()` function.
    Multiply the three matrices as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，我们没有中间矩阵，只有对角线值。 其他值均为 0。 用`diag()`函数形成中间矩阵。 将三个矩阵相乘如下：
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The product of the three matrices is equal to the matrix we created in the
    first step:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个矩阵的乘积等于我们在第一步中创建的矩阵：
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We decomposed a matrix and checked the result by matrix multiplication. We
    used the `svd()` function from the NumPy `linalg` module (see `decomposition.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分解矩阵，并通过矩阵乘法检查结果。 我们使用了 NumPy `linalg`模块中的`svd()`函数（请参见`decomposition.py`）：
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Pseudo inverse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 伪逆
- en: The **Moore-Penrose** **pseudo inverse** of a matrix can be computed with the
    `pinv()` function of the `numpy.linalg` module (see [http://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_pseudoinverse](http://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_pseudoinverse)).
    The pseudo inverse is calculated using the SVD (see previous example). The `inv()`
    function only accepts square matrices; the `pinv()` function does not have this
    restriction and is therefore considered a generalization of the inverse.
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的**穆尔-彭罗斯伪逆**的计算公式为`numpy.linalg`模块的[`pinv()`函数](http://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_pseudoinverse)。
    使用 SVD 计算伪逆（请参见前面的示例）。 `inv()`函数仅接受方阵； `pinv()`函数确实没有的限制，因此被认为是反函数的推广。
- en: Time for action – computing the pseudo inverse of a matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：计算矩阵的伪逆
- en: 'Let''s compute the pseudo inverse of a matrix:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们计算矩阵的伪逆：
- en: 'First, create a matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个矩阵：
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The matrix we created looks like the following:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的矩阵如下所示：
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Calculate the pseudo inverse matrix with the `pinv()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`pinv()`函数计算伪逆矩阵：
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The pseudo inverse result is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 伪逆结果如下：
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Multiply the original and pseudo inverse matrices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原始和伪逆矩阵相乘：
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'What we get is not an identity matrix, but it comes close to it:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的不是一个恒等矩阵，但是很接近它：
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We computed the pseudo inverse of a matrix with the `pinv()` function of the
    `numpy.linalg` module. The check by matrix multiplication resulted in a matrix
    that is approximately an identity matrix (see `pseudoinversion.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`numpy.linalg`模块的`pinv()`函数计算了矩阵的伪逆。 通过矩阵乘法检查得出的矩阵大约是单位矩阵（请参见`pseudoinversion.py`）：
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Determinants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行列式
- en: The **determinant** is a value associated with a square matrix. It is used throughout
    mathematics; for more details, please refer to [http://en.wikipedia.org/wiki/Determinant](http://en.wikipedia.org/wiki/Determinant).
    For a `n x n` real value matrix, the determinant corresponds to the scaling a
    n-dimensional volume undergoes when transformed by the matrix. The positive sign
    of the determinant means the volume preserves its orientation (clockwise or anticlockwise),
    while a negative sign means reversed orientation. The `numpy.linalg` module has
    a `det()` function that returns the determinant of a matrix.
  prefs: []
  type: TYPE_NORMAL
  zh: '**行列式**是与方阵相关的值。 在整个数学中都使用它； 有关更多详细信息，请参见[`en.wikipedia.org/wiki/Determinant`](http://en.wikipedia.org/wiki/Determinant)。
    对于`n x n`实值矩阵，行列式对应于矩阵变换后 n 维体积所经历的缩放。 行列式的正号表示体积保留它的方向（顺时针或逆时针），而负号表示方向相反。 `numpy.linalg`模块具有`det()`函数，该函数返回矩阵的行列式。'
- en: Time for action – calculating the determinant of a matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：计算矩阵的行列式
- en: 'To calculate the determinant of a matrix, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算矩阵的行列式  ，请按照下列步骤操作：
- en: 'Create the matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建矩阵：
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The matrix we created appears as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的矩阵如下所示：
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Compute the determinant with the `det()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`det()`函数计算行列式：
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The determinant appears as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 行列式如下所示：
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We calculated the determinant of a matrix with the `det()` function from the
    `numpy.linalg` module (see `determinant.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`numpy.linalg`模块（请参见`determinant.py`）使用`det()`函数计算了矩阵的行列式：
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Fast Fourier transform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速傅立叶变换
- en: The **Fast** **Fourier** **transform** (**FFT**) is an efficient algorithm to
    calculate the **discrete** **Fourier** **transform** (**DFT**).
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速傅里叶变换**（**FFT**）是一种用于计算**离散傅立叶变换**（**DFT**）的有效算法。'
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The Fourier transform is related to the **Fourier** **series**, which was mentioned
    in the previous chapter—[Chapter 5](ch05.html "Chapter 5. Working with Matrices
    and ufuncs"), *Working with Matrices and ufuncs*. The Fourier series represents
    a signal as a sum of sine and cosine terms.
  prefs: []
  type: TYPE_NORMAL
  zh: 傅立叶变换与**傅立叶级数**相关，在上一章中提到了第五章，“处理矩阵和函数”。 傅里叶级数将信号表示为正弦和余弦项之和。
- en: FFT improves on more naïve algorithms and is of order `O(N log N)`. DFT has
    applications in signal processing, image processing, solving partial differential
    equations, and more. NumPy has a module called `fft` that offers FFT functionality.
    Many functions in this module are paired; for those functions, another function
    does the inverse operation. For instance, the `fft()` and `ifft()` function form
    such a pair.
  prefs: []
  type: TYPE_NORMAL
  zh: FFT 在更多朴素算法上进行了改进，其阶数为`O(N log N)`。 DFT 在信号处理，图像处理，求解偏微分方程等方面具有应用。 NumPy 有一个名为`fft`的模块，该模块提供
    FFT 函数。 该模块中的许多函数已配对。 对于那些函数，另一个函数执行逆运算。 例如，`fft()`和`ifft()`函数形成这样的一对。
- en: Time for action – calculating the Fourier transform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：计算傅立叶变换
- en: 'First, we will create a signal to transform. Calculate the Fourier transform
    with the following steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个要转换的信号。 通过以下步骤计算傅立叶变换：
- en: 'Create a cosine wave with `30` points as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有`30`点的余弦波，如下所示：
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Transform the cosine wave with the `fft()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`fft()`函数变换余弦波：
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Apply the inverse transform with the `ifft()` function. It should approximately
    return the original signal. Check with the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ifft()`函数应用逆变换。 它应该大致返回原始信号。 检查以下行：
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The result appears as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示如下：
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Plot the transformed signal with matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 绘制转换后的信号：
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following resulting diagram shows the FFT result:'
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了 FFT 结果：
- en: '![Time for action – calculating the Fourier transform](img/4154_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：计算傅立叶变换](img/4154_06_01.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We applied the `fft()` function to a cosine wave. After applying the `ifft()`
    function, we got our signal back (see `fourier.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`fft()`函数应用于余弦波。 应用`ifft()`函数后，我们得到了信号（请参阅`fourier.py`）：
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Shifting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移位
- en: The `fftshift()` function of the `numpy.linalg` module shifts zero-frequency
    components to the center of a spectrum. The zero-frequency component corresponds
    to the mean of the signal. The `ifftshift()` function reverses this operation.
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.linalg`模块的`fftshift()`函数将零频率分量移到频谱中心。 零频率分量对应于信号的平均值  。 `ifftshift()`函数可逆转此操作。'
- en: Time for action – shifting frequencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：变换频率
- en: 'We will create a signal, transform it, and then shift the signal. Shift the
    frequencies with the following steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个信号，对其进行转换，然后将其移位。 按以下步骤移动频率：
- en: 'Create a cosine wave with `30` points:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有`30`点的余弦波：
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Transform the cosine wave with the `fft()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fft()`函数变换余弦波：
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Shift the signal with the `fftshift()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fftshift()`函数移动信号：
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Reverse the shift with the `ifftshift()` function. This should undo the shift.
    Check with the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`ifftshift()`函数反转移位。 这应该撤消这种转变。 检查以下代码段：
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The result appears as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 'The result appears as follows:'
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Plot the signal and transform it with matplotlib:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制信号并使用 Matplotlib 对其进行转换：
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following diagram shows the effect of the shift and the FFT:'
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了移位和 FFT 的效果：
- en: '![Time for action – shifting frequencies](img/4154_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：变换频率](img/4154_06_02.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We applied the `fftshift()` function to a cosine wave. After applying the `ifftshift()`
    function, we got our signal back (see `fouriershift.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`fftshift()`函数应用于余弦波。 应用`ifftshift()`函数后，我们返回我们的信号（请参阅`fouriershift.py`）：
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Random numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机数
- en: Random numbers are used in Monte Carlo methods, stochastic calculus, and more.
    Real random numbers are hard to generate, so, in practice, we use **pseudo** **random**
    **numbers**, which are random enough for most intents and purposes, except for
    some very special cases. These numbers appear random, but if you analyze them
    more closely, you will realize that they follow a certain pattern. The random
    numbers-related functions are in the NumPy random module. The core random number
    generator is based on the **Mersenne** **Twister** **algorithm**—a standard and
    well-known algorithm (see [https://en.wikipedia.org/wiki/Mersenne_Twister](https://en.wikipedia.org/wiki/Mersenne_Twister)).
    We can generate random numbers from discrete or continuous distributions. The
    distribution functions have an optional size parameter, which tells NumPy how
    many numbers to generate. You can specify either an integer or a tuple as size.
    This will result in an array filled with random numbers of appropriate shape.
    Discrete distributions include the geometric, hypergeometric, and binomial distributions.
  prefs: []
  type: TYPE_NORMAL
  zh: '蒙特卡罗方法，随机演算等中使用了随机数。 真正的随机数很难生成，因此在实践中，我们使用**伪随机数字**，除了某些非常特殊的情况外，对于大多数意图和目的来说都是足够随机的。
    这些数字似乎是随机的，但是如果您更仔细地分析它们，则将意识到它们遵循一定的模式。 与随机数相关的函数位于 NumPy 随机模块中。 核心随机数字生成器基于
    **梅森旋转算法**——一种标准且众所周知的算法（见[`en.wikipedia.org/wiki/Mersenne_Twister`](https://en.wikipedia.org/wiki/Mersenne_Twister)）。
    我们可以从离散或连续分布中生成随机数。 分布函数具有一个可选的`size`参数，该参数告诉 NumPy 生成多少个数字。 您可以指定整数或元组作为大小。 这将导致数组中填充适当形状的随机数。
    离散分布包括几何分布，超几何分布和二项分布。'
- en: Time for action – gambling with the binomial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：使用二项来赌博
- en: The **binomial** **distribution** models the number of successes in an integer
    number of independent trials of an experiment, where the probability of success
    in each experiment is a fixed number (see [https://www.khanacademy.org/math/probability/random-variables-topic/binomial_distribution](https://www.khanacademy.org/math/probability/random-variables-topic/binomial_distribution)).
  prefs: []
  type: TYPE_NORMAL
  zh: '**二项分布**模型是整数个独立试验中的成功的次数，其中每个实验中成功的概率是固定的数字（见[`www.khanacademy.org/math/probability/random-variables-topic/binomial_distribution`](https://www.khanacademy.org/math/probability/random-variables-topic/binomial_distribution)）。'
- en: Imagine a 17th century gambling house where you can bet on flipping pieces of
    eight. Nine coins are flipped. If less than five are heads, then you lose one
    piece of eight, otherwise you win one. Let's simulate this, starting with 1,000
    coins in our possession. Use the `binomial()` function from the random module
    for that purpose.
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下一个 17 世纪的赌场，您可以在上面掷 8 个筹码。 九枚硬币被翻转。 如果少于五个，那么您将损失八分之一，否则将获胜。 让我们模拟一下，从拥有的
    1,000 个硬币开始。 为此，可以使用随机模块中的`binomial()`函数。
- en: 'To understand the `binomial()` function, look at the following section:'
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解  `binomial()`函数，请查看以下部分：
- en: 'Initialize an array, which represents the cash balance, to zeros. Call the
    `binomial()` function with a size of 10000\. This represents 10,000 coin flips
    in our casino:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代表现金余额的数组初始化为零。 调用大小为 10000 的`binomial()`函数。这表示在我们的赌场中有 10,000 次硬币翻转：
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Go through the outcomes of the coin flips and update the cash array. Print
    the minimum and maximum of the outcome, just to make sure we don''t have any strange
    outliers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看硬币翻转的结果并更新现金数组。 打印结果的最小值和最大值，只是为了确保我们没有任何奇怪的异常值：
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As expected, the values are between `0` and `9`. In the following diagram,
    you can see the cash balance performing a random walk:'
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，该值在`0`和`9`之间。 在下图中，您可以看到现金余额执行随机游走：
- en: '![Time for action – gambling with the binomial](img/4154_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：使用二项来赌博](img/4154_06_03.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We did a random walk experiment using the `binomial()` function from the NumPy
    random module (see `headortail.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 NumPy 随机模块中的`binomial()`函数进行了随机游走实验（请参见`headortail.py`）：
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Hypergeometric distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超几何分布
- en: The **hypergeometric** **distribution** models a jar with two types of objects
    in it. The model tells us how many objects of one type we can get if we take a
    specified number of items out of the jar without replacing them (see [https://en.wikipedia.org/wiki/Hypergeometric_distribution](https://en.wikipedia.org/wiki/Hypergeometric_distribution)).
    The NumPy random module has a `hypergeometric()` function that simulates this
    situation.
  prefs: []
  type: TYPE_NORMAL
  zh: '**超几何分布**对其中装有两种对象的罐进行建模。 该模型告诉我们，如果我们从罐子中取出指定数量的物品而不更换它们，可以得到一种类型的对象（见[`en.wikipedia.org/wiki/Hypergeometric_distribution`](https://en.wikipedia.org/wiki/Hypergeometric_distribution)）。
    NumPy 随机模块具有模拟这种情况的`hypergeometric()`函数。'
- en: Time for action – simulating a game show
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：模拟游戏节目
- en: 'Imagine a game show where every time the contestants answer a question correctly,
    they get to pull three balls from a jar and then put them back. Now, there is
    a catch, one ball in the jar is bad. Every time it is pulled out, the contestants
    lose six points. If, however, they manage to get out 3 of the 25 normal balls,
    they get one point. So, what is going to happen if we have 100 questions in total?
    Look at the following section for the solution:'
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，游戏会显示出参赛者每次正确回答问题时，都会从罐子中拉出三个球，然后放回去。 现在，有一个陷阱，罐子里的一个球不好。 每次拔出时，参赛者将失去
    6 分。 但是，如果他们设法摆脱 25 个普通球中的 3 个，则得到 1 分。 那么，如果我们总共有 100 个问题，将会发生什么？ 查看以下部分以了解解决方案：
- en: 'Initialize the outcome of the game with the `hypergeometric()` function. The
    first parameter of this function is the number of ways to make a good selection,
    the second parameter is the number of ways to make a bad selection, and the third
    parameter is the number of items sampled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`hypergeometric()`函数初始化游戏结果。 此函数的第一个参数是做出正确选择的方法数量，第二个参数是做出错误选择的方法数量，第三个参数是采样的项目数量：
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Set the scores based on the outcomes from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据上一步的结果设置评分：
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The following diagram shows how the scoring evolved:'
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了评分如何演变：
- en: '![Time for action – simulating a game show](img/4154_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：模拟游戏节目](img/4154_06_04.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We simulated a game show using the `hypergeometric()` function from the NumPy
    `random` module. The game scoring depends on how many good and how many bad balls
    the contestants pulled out of a jar in each session (see `urn.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 NumPy `random`模块中的  `hypergeometric()`函数模拟了游戏节目。 游戏得分取决于每次比赛参与者从罐子中抽出多少好球和坏球（请参阅`urn.py`）：
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Continuous distributions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连续分布
- en: We usually model continuous distributions with **probability density functions**
    (**PDF**). The probability that a value is in a certain interval is determined
    by integration of the PDF (see [https://www.khanacademy.org/math/probability/random-variables-topic/random_variables_prob_dist/v/probability-density-functions](https://www.khanacademy.org/math/probability/random-variables-topic/random_variables_prob_dist/v/probability-density-functions)).
    The NumPy `random` module has functions that represent continuous distributions—`beta()`,
    `chisquare()`, `exponential()`, `f()`, `gamma()`, `gumbel()`, `laplace()`, `lognormal()`,
    `logistic()`, `multivariate_normal()`, `noncentral_chisquare()`, `noncentral_f()`,
    `normal()`, and others.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用**概率密度函数**（**PDF**）对连续分布进行建模。 值处于特定间隔的可能性由 PDF 的积分确定（见[`www.khanacademy.org/math/probability/random-variables-topic/random_variables_prob_dist/v/probability-density-functions`](https://www.khanacademy.org/math/probability/random-variables-topic/random_variables_prob_dist/v/probability-density-functions)）。
    NumPy `random`模块具有表示连续分布的函数-`beta()`，`chisquare()`，`exponential()`，`f()`，`gamma()`，`gumbel()`，`laplace()`，`lognormal()`
    ，`logistic()`，`multivariate_normal()`，`noncentral_chisquare()`，`noncentral_f()`，`normal()`等。
- en: Time for action – drawing a normal distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：绘制正态分布
- en: 'We can generate random numbers from a normal distribution and visualize their
    distribution with a histogram (see [https://www.khanacademy.org/math/probability/statistics-inferential/normal_distribution/v/introduction-to-the-normal-distribution](https://www.khanacademy.org/math/probability/statistics-inferential/normal_distribution/v/introduction-to-the-normal-distribution)).
    Draw a normal distribution with the following steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从正态分布中生成随机数，并通过直方图可视化其分布（见[`www.khanacademy.org/math/probability/statistics-inferential/normal_distribution/v/introduction-to-the-normal-distribution`](https://www.khanacademy.org/math/probability/statistics-inferential/normal_distribution/v/introduction-to-the-normal-distribution)）。
    通过以下步骤绘制正态分布：
- en: 'Generate random numbers for a given sample size using the `normal()` function
    from the `random` NumPy module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`random` NumPy 模块中的`normal()`函数，为给定的样本量生成随机的数字：
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Draw the histogram and theoretical PDF with a center value of `0` and standard
    deviation of `1`. Use matplotlib for this purpose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制直方图和理论 PDF，其中心值为 0，标准偏差为 1。 为此，请使用 Matplotlib：
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'In the following diagram, we see the familiar bell curve:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图表中，我们看到了熟悉的钟形曲线：
- en: '![Time for action – drawing a normal distribution](img/4154_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：绘制正态分布](img/4154_06_05.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We visualized the normal distribution using the `normal()` function from the
    random NumPy module. We did this by drawing the bell curve and a histogram of
    randomly generated values (see `normaldist.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用来自随机 NumPy 模块的`normal()`函数可视化正态分布。 为此，我们绘制了钟形曲线和随机生成的值的直方图（请参见`normaldist.py`）：
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Lognormal distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对数正态分布
- en: A **lognormal** distribution is a distribution of a random variable whose natural
    logarithm is normally distributed. The `lognormal()` function of the random NumPy
    module models this distribution.
  prefs: []
  type: TYPE_NORMAL
  zh: '**对数正态**分布是自然对数呈正态分布的随机变量的分布。 随机 NumPy 模块的  `lognormal()`函数可对该分布进行建模。'
- en: Time for action – drawing the lognormal distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：绘制对数正态分布
- en: 'Let''s visualize the lognormal distribution and its PDF with a histogram:'
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用直方图可视化对数正态分布及其 PDF：
- en: 'Generate random numbers using the `normal()` function from the `random` NumPy
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`random` NumPy 模块中的`normal()`函数生成随机数：
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Draw the histogram and theoretical PDF with a center value of `0` and standard
    deviation of `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制直方图和理论 PDF，其中心值为 0，标准偏差为 1：
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The fit of the histogram and theoretical PDF is excellent, as you can see in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图和理论 PDF 的拟合非常好，如下图所示：
- en: '![Time for action – drawing the lognormal distribution](img/4154_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：绘制对数正态分布](img/4154_06_06.jpg)'
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: 'We visualized the lognormal distribution using the `lognormal()` function from
    the `random` NumPy module. We did this by drawing the curve of the theoretical
    PDF and a histogram of randomly generated values (see `lognormaldist.py`):'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`random` NumPy 模块中的`lognormal()`函数可视化了对数正态分布。 我们通过绘制理论 PDF 曲线和随机生成的值的直方图（请参见`lognormaldist.py`）来做到这一点：
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Bootstrapping in statistics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统计量自举
- en: '**Bootstrapping** is a method used to estimate variance, accuracy, and other
    metrics of sample estimates, such as the arithmetic mean. The simplest bootstrapping
    procedure consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
  zh: '**自举**是一种用于估计方差，准确性和其他样本估计量度的方法，例如算术平均值。 最简单的自举过程包括以下步骤：'
- en: Generate a large number of samples from the original data sample having the
    same size `N`. You can think of the original data as a jar containing numbers.
    We create the new samples by `N` times randomly picking a number from the jar.
    Each time we return the number into the jar, so a number can occur multiple times
    in a generated sample.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从具有相同大小`N`的原始数据样本中生成大量样本。 您可以将原始数据视为包含数字的罐子。 我们通过`N`次从瓶子中随机选择一个数字来创建新样本。 每次我们将数字返回到罐子中时，一个生成的样本中可能会多次出现一个数字。
- en: With the new samples, we calculate the statistical estimate under investigation
    for each sample (for example, the arithmetic mean). This gives us a sample of
    possible values for the estimator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于新样本，我们为每个样本计算要调查的统计估计值（例如，算术平均值）。 这为我们提供了估计器可能值的样本。
- en: Time for action – sampling with numpy.random.choice()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实战时间：使用`numpy.random.choice()`进行采样
- en: We will use the `numpy.random.choice()` function to perform bootstrapping.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`numpy.random.choice()`函数对执行自举。
- en: 'Start the IPython or Python shell and import NumPy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 IPython 或 Python Shell 并导入 NumPy：
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Generate a data sample following the normal distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照正态分布生成数据样本：
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Calculate the mean of the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算数据的平均值：
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Generate `100` samples from the original data and calculate their means (of
    course, more samples may lead to a more accurate result):'
  prefs: []
  type: TYPE_NORMAL
  zh: 从原始数据生成`100`样本并计算其平均值（当然，更多样本可能会导致更准确的结果）：
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Calculate the mean, variance, and standard deviation of the arithmetic means
    we obtained:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算得到的算术平均值的均值，方差和标准偏差：
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If we are assuming a normal distribution for the means, it may be relevant
    to know the **z-score**, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设均值的正态分布，则可能需要了解 **z 得分**，其定义如下：
- en: '![Time for action – sampling with numpy.random.choice()](img/4154_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![实战时间：使用`numpy.random.choice()`进行采样](img/4154_06_10.jpg)'
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: From the z-score value, we get an idea of how probable the actual mean is.
  prefs: []
  type: TYPE_NORMAL
  zh: 从 z 得分值，我们可以了解实际均值的可能性。
- en: '*What just happened?*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？
- en: We bootstrapped a data sample by generating samples and calculating the means
    of each sample. Then we computed the mean, standard deviation, variance, and z-score
    of the means. We used the `numpy.random.choice()` function for bootstrapping.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过生成样本并计算每个样本的平均值来自举数据样本。 然后，我们计算了均值，标准差，方差和均值的 z 得分。 我们使用`numpy.random.choice()`函数进行自举。
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: You learned a lot in this chapter about NumPy modules. We covered linear algebra,
    the Fast Fourier transform, continuous and discrete distributions, and random
    numbers.
  prefs: []
  type: TYPE_NORMAL
  zh: 您在本章中学到了很多有关 NumPy 模块的知识。 我们介绍了线性代数，快速傅立叶变换，连续和离散分布以及随机数。
- en: In the next chapter, we will cover specialized routines. These are functions
    that you probably will not use often, but are very useful when you do need them.
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍专门的例程。 这些函数可能不经常使用，但是在需要时非常有用。
