- en: Manipulating Streams and Their Values
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作流和它们的值
- en: Operators are functions we can call on our streams to perform manipulation in
    many different ways. Operators are immutable, which makes the stream easy to reason
    about and will also make it quite easy to test. As you will see throughout this
    chapter, we will seldom deal with just one stream, but many streams, and it is
    understanding how to forge and control these streams that allow you to go from
    thinking it's *dark magic* to actually being able to apply RxJS when and where
    you need it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符是我们可以在流上调用的函数，以许多不同的方式进行操作。操作符是不可变的，这使得流易于理解，也使得测试变得相当容易。正如你将在本章中看到的，我们很少只处理一个流，而是处理许多流，了解如何创建和控制这些流，才能让你从认为这是*黑魔法*到实际上能够在需要的时候应用RxJS。
- en: 'In this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖：
- en: How to use basic operators
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用基本操作符
- en: Debugging streams with operators as well as with existing tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用操作符以及现有工具调试流
- en: Digging deeper into different operator categories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入挖掘不同的操作符类别
- en: Developing the mindset to solve a problem the Rx way
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以Rx方式解决问题的思维方式
- en: Starting out
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: You almost always start out coding with RxJS by creating a stream of static
    values. Why static values? Well, there is no need to make it unnecessarily complex,
    and all you really need to start reasoning is an `Observable`. As you gradually
    progress in your problem solving, you might replace the static values with a more
    appropriate call to an AJAX call, or from another asynchronous source that your
    values originate from.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎总是从创建静态值的流开始编码RxJS。为什么是静态值？嗯，没有必要使它变得不必要复杂，你真正需要的只是一个`Observable`。随着你在解决问题上逐渐进展，你可能会用更合适的AJAX调用或来自其他异步来源的调用替换静态值，这些值来源于这些调用。
- en: You then start thinking about what you want to achieve. This leads you to consider
    which operators you might need and in which order you need to apply them. You
    might also think about how to divide your problem up; this usually means creating
    more than one stream, where each stream solves a specific problem that connects
    to the larger problem you are trying to solve.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你开始考虑你想要实现什么。这会让你考虑你可能需要哪些操作符，以及你需要以什么顺序应用它们。你可能还会考虑如何分解你的问题；这通常意味着创建多个流，其中每个流解决一个特定的问题，与你试图解决的更大的问题相关联。
- en: Let's start with stream creation and see how we can take our first steps working
    with streams.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从流的创建开始，看看我们如何迈出第一步来处理流。
- en: 'The following code creates a stream of static values:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个静态值的流：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That is a very basic example of how we can create a stream. We use the `of()` creation
    operator, which takes any number of arguments. All the arguments are emitted,
    one by one, as soon as there is a subscriber. In the preceding code, we also subscribe
    to `staticValuesStream$` by calling the `subscribe()` method and passing a function
    that takes the emitted value as a parameter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的例子，展示了我们如何创建一个流。我们使用`of()`创建操作符，它接受任意数量的参数。所有参数都会在有订阅者时依次发出。在前面的代码中，我们还通过调用`subscribe()`方法并传递一个以发出的值作为参数的函数来订阅`staticValuesStream$`。
- en: Let's introduce an operator, `map()`, which acts like a projection and allows
    you to change what is being emitted. The `map()` operator gets called on each
    value in the stream before it is emitted.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍一个操作符，`map()`，它的作用类似于投影，允许你改变被发出的内容。在发出之前，`map()`操作符会在流中的每个值上调用。
- en: 'You use the `map()` operator by supplying it with a function and carrying out
    a projection, like so:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供一个函数来使用`map()`操作符，并进行投影，就像这样：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, we have appended the `map()` operator to `staticValuesStream$` and
    we apply it to each value before emitting it and incrementing it by one. The resulting
    data is therefore changed. This is how you append operators to a stream: simply
    create the stream, or take an existing one, and append the operators one by one.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经将`map()`运算符附加到`staticValuesStream$`上，并在发出之前对每个值应用它并将其增加一。因此，结果数据发生了变化。这就是如何将运算符附加到流中的方法：简单地创建流，或者取一个现有的流，并逐个附加运算符。
- en: Let's add another operator, `filter()`, to ensure that we really understand
    how to work with operators. What does `filter()` do. Well, just like the `map()` operator,
    it is applied to each value, but instead of creating a projection, it decides
    which values will be emitted. `filter()` takes a Boolean. Any expression evaluated
    to `true` means the value will be emitted; if `false`, the expression will not
    be emitted.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个运算符`filter()`，以确保我们真正理解如何使用运算符。`filter()`是做什么的。嗯，就像`map()`运算符一样，它被应用于每个值，但是它不是创建一个投影，而是决定哪些值将被发出。`filter()`接受一个布尔值。任何计算结果为`true`的表达式意味着该值将被发出；如果是`false`，则该表达式将不被发出。
- en: 'You use the `filter()` operator in the following way:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样使用`filter()`运算符：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We add the `filter()` operator by chaining it to the existing `map()` operator.
    The condition we give our `filter()` operator says to only return `true` for values
    that are divisible by `2`, that's what the modulus operator does. We know from
    before that the `map()`   operator alone ensures that the values `2`, `3` , `4`,
    and `5` are emitted. These are the values that are now being evaluated by the
    `filter()` operator. Out of those four values, only `2` and `4` fulfill the condition
    set out by the `filter()` operator.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`filter()`运算符链接到现有的`map()`运算符来添加`filter()`运算符。我们给`filter()`运算符的条件是只返回能被`2`整除的值，这就是模运算符的作用。我们知道从前面的内容中，`map()`运算符单独确保了值`2`、`3`、`4`和`5`被发出。这些就是现在被`filter()`运算符评估的值。在这四个值中，只有`2`和`4`满足`filter()`运算符设定的条件。
- en: 'Of course, when working on a stream and applying operators, things might not
    always be as simple as the preceding code. It might not be possible to anticipate
    exactly what gets emitted. For those occasions, we have a few tricks we can use.
    One such trick is to use the `do()` operator, which will allow us to inspect each
    value without changing it. This gives us ample opportunity to use it for debugging
    purposes. Depending on where we are in the stream, the `do()` operator will output
    different values. Let''s look at different situations where it matters where the `do()` operator
    is applied:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当在流上工作并应用运算符时，事情可能并不总是像前面的代码那样简单。可能无法准确预测会发出什么。对于这些情况，我们有一些技巧可以使用。其中一种技巧是使用`do()`运算符，它将允许我们检查每个值而不改变它。这给了我们充分的机会将其用于调试目的。根据我们在流中的位置，`do()`运算符将输出不同的值。让我们看看在哪些情况下`do()`运算符的应用很重要：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, just by using the `do()` operator, we have a nice way to debug
    our streams, which becomes necessary as our streams grow in complexity.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，仅仅通过使用`do()`运算符，我们就有了一种很好的方式来调试我们的流，随着我们的流变得越来越复杂，这变得必要。
- en: Understanding operators
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解运算符
- en: So far, we have shown how to create a stream and use some very basic operators
    on it to change what values get emitted. We also introduced how to inspect your
    stream without changing it by using the `do()` operator. Not all operators are
    as easy to understand as the `map()`, `filter()`, and `do()` operators. There
    are different tactics you can use to try to understand what each operator does
    so you know when to use them. Using the `do()` operator is one way, but there
    is a graphical approach you can take. This approach is known as a marble diagram.
    It consists of an arrow that represents time passing from left to right. There
    are circles, or marbles, on this arrow that represent emitted values. The marbles
    have a value in them, but the distance between the marbles might also describe
    what is happening over time. A marble diagram usually consists of at least two
    arrows with marbles on them, as well as an operator. The idea is to represent
    what happens to a stream when an operator is applied. The second arrow usually
    represents the resulting stream.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了如何创建一个流，并在其上使用一些非常基本的操作符来改变发出的值。我们还介绍了如何使用`do()`操作符来检查流而不改变它。并不是所有的操作符都像`map()`、`filter()`和`do()`操作符那样容易理解。你可以尝试不同的策略来理解每个操作符的作用，以便知道何时使用它们。使用`do()`操作符是一种方法，但你也可以采用图形化的方法。这种方法被称为弹珠图。它由一个代表时间从左到右流逝的箭头组成。在这个箭头上有圆圈，或者弹珠，代表发出的值。弹珠里面有一个值，但弹珠之间的距离也可能描述随时间发生的事情。弹珠图通常由至少两个带有弹珠的箭头和一个操作符组成。其目的是表示应用操作符时流发生的变化。第二个箭头通常代表结果流。
- en: 'Here''s an example of a marble diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个弹珠图的示例：
- en: '![](Images/2dd33126-5938-4564-886a-9e438aff2bd5.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2dd33126-5938-4564-886a-9e438aff2bd5.png)'
- en: 'Most operators in RxJS are depicted by a marble diagram on the site RxMarbles: [http://rxmarbles.com/](http://rxmarbles.com/).
    This is a truly great resource to quickly gain an understanding of what operators
    do. However, to truly understand RxJS you need to code; there is no getting around
    it. There are different ways of doing that of course. You can easily set up your
    own project and install RxJS from NPM, refer to it through a CDN link, or you
    can use a page such as JS Bin ([www.jsbin.com](http://www.jsbin.com)), which gives
    you the ability to easily add RxJS as a library and allows you to start coding
    straight away. It looks something like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: RxJS中的大多数操作符都通过RxMarbles网站上的弹珠图来描述：[http://rxmarbles.com/](http://rxmarbles.com/)。这是一个非常好的资源，可以快速理解操作符的作用。然而，要真正理解RxJS，你需要编写代码；这是无法绕过的。当然，有不同的方法可以做到这一点。你可以轻松地设置自己的项目并从NPM安装RxJS，通过CDN链接引用它，或者你可以使用JS
    Bin（[www.jsbin.com](http://www.jsbin.com)），它可以让你轻松地将RxJS作为库添加，并立即开始编码。它看起来像这样：
- en: '![](Images/8e925f0d-1dd4-4302-8c65-5b5cda1a65ff.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8e925f0d-1dd4-4302-8c65-5b5cda1a65ff.png)'
- en: 'JS Bin makes it easy to start, but wouldn''t it be great if we could combine
    marble diagrams and JS Bin, and get a graphical representation of what you code,
    when you code? You can get just that with RxFiddle: [http://rxfiddle.net/](http://rxfiddle.net/).
    You can enter your code, click Run, and you are shown a marble diagram of what
    you just coded, which will look like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: JS Bin让开始变得容易，但如果我们能够结合弹珠图和JS Bin，并在编码时得到图形表示，那不是很棒吗？你可以通过RxFiddle实现这一点：[http://rxfiddle.net/](http://rxfiddle.net/)。你可以输入你的代码，点击运行，然后你会看到你刚刚编写的弹珠图，它会看起来像这样：
- en: '![](Images/66aadd7c-2b3c-4255-9a7a-13f5a6bc64d6.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/66aadd7c-2b3c-4255-9a7a-13f5a6bc64d6.png)'
- en: Stream in a stream
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在流中的流
- en: 'We have been looking at different operators that change the values being emitted.
    There is another different aspect to streams: what if you need to create a new
    stream from an existing stream? Another good question is: when does such a situation
    usually occur?  There are plenty of situations, such as:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在研究不同的操作符，这些操作符改变了被发出的值。流的另一个不同方面是：如果您需要从现有流中创建一个新流怎么办？另一个很好的问题是：这种情况通常发生在什么时候？有很多情况，比如：
- en: Based on a stream of keyUp events, do an AJAX call.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据一个keyUp事件流，执行一个AJAX调用。
- en: Count the number of clicks and determine whether the user single, double, or
    triple-clicked.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算点击次数，并确定用户是单击、双击还是三击。
- en: You get the idea; we are starting with one type of stream that needs to turn
    into another type of stream.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您明白了吧；我们从需要转换为另一种类型的流开始。
- en: 'Let''s first have a look at creating a stream and see what happens when we
    try to create a stream as the result of using an operator:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下创建一个流，并看看当我们尝试使用操作符创建一个流时会发生什么：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'At this point, every value that passes through the `map()` operator produces
    a new `Observable`. When you subscribe to `stream$`, each value that is emitted
    will be a stream. Your first instinct might be to attach a `subscribe()` to each
    of those values, like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，通过`map()`操作符传递的每个值都会产生一个新的`Observable`。当您订阅`stream$`时，发出的每个值都将是一个流。您可能的第一反应是对每个值附加一个`subscribe()`，就像这样：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Fight this urge. This will only create code that is hard to maintain. What you
    want to do is merge all these streams into one so, that you just need one `subscribe()`.
    There is an operator just for that, called `flatMap()`. What `flatMap()` does
    is to take your array of streams and turn them into one stream, a metastream.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 抵制这种冲动。这只会创建难以维护的代码。您想要做的是将所有这些流合并成一个，这样您只需要一个`subscribe()`。有一个专门的操作符可以做到这一点，叫做`flatMap()`。`flatMap()`的作用是将您的流数组转换为一个流，一个元流。
- en: 'It is used in the following way:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用方式如下：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'OK, we get it, we don''t want a stream of Observables, but rather a stream
    of values. This operator seems really great. We still aren''t quite certain when
    to use though. Let''s make this a bit more realistic. Imagine you have a UI that
    consists of an input field. The user enters characters into that input field.
    Imagine that you want to react to one or more characters being entered and, for
    example, perform an AJAX request as the result of characters being entered. We
    focus on two things here: how to collect characters being entered and how to perform
    an AJAX request.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们明白了，我们不想要一个Observable的流，而是想要一个值的流。这个操作符似乎真的很棒。不过我们仍然不太确定何时使用。让我们把这个问题变得更现实一点。想象一下，您有一个包含输入字段的UI。用户在该输入字段中输入字符。假设您希望对输入一个或多个字符做出反应，并且例如，作为输入字符结果执行一个AJAX请求。我们在这里关注两件事：如何收集输入的字符以及如何执行AJAX请求。
- en: 'Let'' start with the first thing, capturing characters entered into an input
    field. For this, we need an HTML page and a JavaScript page. Let''s start with
    the HTML page:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一件事开始，捕获输入字段中输入的字符。为此，我们需要一个HTML页面和一个JavaScript页面。让我们从HTML页面开始：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This depicts our input element and a script reference to RxJS, as well as a
    reference to the `app.js` file. Then we have `app.js` file, where we get a reference
    to the input element and start listening to keystrokes as soon as they are entered:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了我们的输入元素和对RxJS的脚本引用，以及对`app.js`文件的引用。然后我们有`app.js`文件，在那里我们获取输入元素的引用，并开始监听键盘输入：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Worth highlighting is the fact that we start listening to `keyup` events being
    emitted by calling the `fromEvent()` creation operator. Thereafter, we apply the `map()` operator
    to dig out the character value store on `ev.key`.  Lastly, we subscribe to the
    stream. As expected, running this code will lead to characters being typed in
    the console as soon as you input values in the HTML page.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，我们通过调用`fromEvent()`创建操作符开始监听`keyup`事件的发出。然后，我们应用`map()`操作符来提取存储在`ev.key`上的字符值。最后，我们订阅这个流。如预期的那样，运行这段代码将导致在HTML页面中输入值时立即在控制台中输入字符。
- en: Let's make this more tangible by doing an AJAX request based on what we type.
    For this, we will be using the `fetch()` API and an online API called swapi (swapi.com),
    which contains a collection of APIs containing information on the Star Wars movies.
    Let's first define our AJAX call and then see how it fits into our existing stream
    of keys.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过根据我们输入的内容进行AJAX请求来使其更具体化。为此，我们将使用`fetch()`API和一个名为swapi（swapi.com）的在线API，其中包含有关星球大战电影信息的一系列API。让我们首先定义我们的AJAX调用，然后看看它如何适应我们现有的按键流。
- en: 'We said we would use `fetch()`. It lets us formulate a GET request as simple
    as this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过我们将使用`fetch()`。它让我们可以轻松地制定一个GET请求，就像这样简单：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Of course, we want to turn this request into an `Observable` so that it can
    play well with our `keyStream$`. Fortunately for us, this is easily accomplished
    through the use of the `from()` operator. Let''s, however, first rewrite our `fetch()` call
    into a method that''s easy to work with. The result of the rewrite looks like
    this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们希望将此请求转换为`Observable`，以便它可以与我们的`keyStream$`很好地配合。幸运的是，我们可以通过使用`from()`操作符轻松实现这一点。然而，首先让我们将我们的`fetch()`调用重写为一个易于使用的方法。重写的结果如下：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code allows us to provide an argument used to construct a URL which we
    use to fetch some data with AJAX. At this point, we are ready to connect our function
    to our existing stream. We do that by typing the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码允许我们提供一个用于构造URL的参数，我们使用它来通过AJAX获取一些数据。此时，我们已经准备好将我们的函数连接到现有的流。我们通过输入以下内容来实现这一点：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We highlight the usage of the `flatmap()` operator in bold using our `from()`
    conversion operator. The operator mentioned last takes our `getStarwarsCharacterStream()` function as
    a parameter. The `from()` operator converts said function into a stream.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用粗体突出显示了使用我们的`from()`转换操作符的`flatmap()`操作符。最后提到的操作符将我们的`getStarwarsCharacterStream()`函数作为参数。`from()`操作符将该函数转换为一个流。
- en: 'Here, we have learned how to connect two different streams, but also how to
    convert a `Promise` into a stream. As good as this approach seems on paper, using `flatMap()` has
    its limitations and it is important to understand what they are. For that reason,
    let''s talk about the `switchMap()` operator next. The benefits of using a `switchMap()` operator
    will become clearer when we execute long-running tasks. For argument''s sake,
    let''s define such a task, like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们学习了如何连接两个不同的流，以及如何将`Promise`转换为流。尽管这种方法在理论上看起来很好，但使用`flatMap()`也有其局限性，重要的是要了解这些局限性。因此，让我们接下来讨论`switchMap()`操作符。使用`switchMap()`操作符的好处将在执行长时间运行的任务时变得更加清晰。举例来说，让我们定义这样一个任务：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this code, we have a function that takes 5 seconds to execute; enough time
    to show the point we are trying to make. Next, let''s show what the effect is
    if we keep using the `flatMap()` operator in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们有一个需要5秒才能执行的函数；足够的时间来展示我们试图说明的要点。接下来，让我们看看如果继续使用`flatMap()`操作符会有什么效果：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding code works in the following way: every time we hit a key, it
    generates an event. However, we have a `.filter()` operator in place that ensures
    an event is only generated when at least four keys are entered,   `filter(key
    => elem.value.length >3)`. Let''s talk about the user''s expectation at this point.
    If a user enters keys in an input control, they most likely expect a request to
    be made when they are done typing. A user defines being done as entering a few
    characters and also that they should be able to remove characters if they were
    mistyped. So, therefore, we can assume the following input sequence:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的代码工作方式如下：每次按键时都会生成一个事件。但是，我们放置了一个`.filter()`操作符，确保只有在输入至少四个键时才生成一个事件，`filter(key
    => elem.value.length >3)`。现在让我们谈谈用户此时的期望。如果用户在输入控件中输入键，他们很可能希望在输入完成时进行请求。用户定义完成输入为输入一些字符，并且还应该能够删除错误输入的字符。因此，我们可以假设以下输入序列： '
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'At this point, they have entered characters and, within a reasonable amount
    of time, edited their answer. The user expects to receive an answer based on `abcd`.
    Using the `flatMap()` operator, however, means the user will get two answers back
    because, in reality, they typed `abcde` and `abcd`. Imagine we get a results list
    based on these two inputs; it would most likely be two lists that looked somewhat
    different. The response based on our code would look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，他们已经输入了字符，并且在合理的时间内编辑了他们的答案。用户期望根据`abcd`收到一个答案。然而，使用`flatMap()`操作符意味着用户会得到两个答案，因为实际上他们输入了`abcde`和`abcd`。想象一下，我们基于这两个输入得到了一个结果列表；很可能会是两个看起来有些不同的列表。根据我们的代码，响应会是这样的：
- en: '![](Images/3938298b-e064-4bb3-8144-209f7a6a3ca8.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3938298b-e064-4bb3-8144-209f7a6a3ca8.png)'
- en: 'Our code most likely would be able to handle the situation  described by rerendering
    the results list as soon as a new response arrives. There are two problems with
    this though: firstly, we do an unnecessary network request for `abcde`, and secondly,
    if the backend is fast enough in responding, we will see a flickering in the UI
    as the result list is rendered once and then, shortly after, is rendered again,
    based on the second response. This is not good, and we want to have a situation
    where the first request will be abandoned if we keep on typing. This is where
    the `switchMap()` operator comes in. It does exactly that. Let''s therefore alter
    the preceding code to the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码很可能能够处理所描述的情况，即一旦新的响应到达，重新渲染结果列表。不过，这里有两个问题：首先，我们对`abcde`进行了不必要的网络请求；其次，如果后端响应足够快，我们会在UI中看到闪烁，因为结果列表会被渲染一次，然后很快又根据第二个响应被重新渲染。这不好，我们希望在继续输入时第一个请求会被放弃。这就是`switchMap()`操作符的作用。它正是这样做的。因此，让我们将前面的代码修改为以下内容：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this code, we simply switched our `flatMap()` to a `switchMap()`. When we
    now execute the code in the exact same way, that is, the user firstly typing `12345` and
    shortly altering that to `1234`, the end result is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们只是将我们的`flatMap()`改成了`switchMap()`。当我们以完全相同的方式执行代码时，也就是说，用户首先输入`12345`，然后很快将其改为`1234`，最终结果是：
- en: '![](Images/b72340e6-3015-478b-9f37-7b674949fcb8.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b72340e6-3015-478b-9f37-7b674949fcb8.png)'
- en: As we can see, we get one request only. The reason for this is that the previous
    event is aborted when a new event happens—`switchMap()` is doing its magic. The
    user is happy and we are happy.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们只收到了一个请求。这是因为在新事件发生时，之前的事件被中止了-`switchMap()`发挥了它的魔力。用户很高兴，我们也很高兴。
- en: AJAX
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AJAX
- en: 'We have already touched upon the topic of making AJAX requests. There are many
    ways to make AJAX requests; the two most common approaches are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了制作AJAX请求的话题。有许多方法可以进行AJAX请求；最常见的两种方法是：
- en: Using the fetch API; the fetch API is a web standard and is thus built into
    most browsers
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用fetch API；fetch API是一个Web标准，因此内置到大多数浏览器中
- en: Using the `ajax()` method, nowadays built into the RxJS library; it used to
    exist in a library called Rx.Dom
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ajax()`方法，现在内置到RxJS库中；它曾经存在于一个名为Rx.Dom的库中
- en: fetch()
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fetch()
- en: The `fetch()` API is a web standard. You can find the official documentation
    at the following link: [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
    The `fetch()` API is `Promise`-based, which means we need to convert it to an
    `Observable` before use. The API exposes a `fetch()` method, which takes a mandatory
    URL parameter as the first argument, with the second argument being an optional
    object that allows you to control which body to send, if any, which HTTP verb
    to use, and so on.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch()` API是一个Web标准。您可以在以下链接找到官方文档：[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)。`fetch()`
    API是基于`Promise`的，这意味着我们需要在使用之前将其转换为`Observable`。该API公开了一个`fetch()`方法，它以第一个参数作为必需的URL参数，第二个参数作为可选对象，允许您控制要发送的主体，如果有的话，要使用的HTTP动词等。'
- en: 'We have already mentioned how to best deal with it in the context of RxJS.
    It is worth repeating though. It is not as simple as just taking our fetch and
    sticking it into the `from()` operator though. Let''s write some code and see
    why:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了如何在RxJS的上下文中最好地处理它。虽然值得重申。但这并不像简单地将我们的fetch放入`from()`操作符中那样简单。让我们写一些代码，看看为什么：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We get our data right? Sorry, no, we get a `Response` object back. But that''s
    easy, just call a `json()` method in the `map()` operator and surely then we have
    our data? Again, sorry no, the `json()` method returns a `Promise` when you type
    the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了我们的数据吗？抱歉，不，我们得到了一个`Response`对象。但这很容易，只需在`map()`操作符中调用`json()`方法，那么我们就有我们的数据了吗？再次抱歉，不，当您键入以下内容时，`json()`方法返回一个`Promise`：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have already shown a possible solution to this in the previous section,
    and that is the following construct:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一节中展示了一个可能的解决方案，那就是以下结构：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What we did in this code was to simply take care of digging out our data before
    handing it over to the `from()` operator. It doesn''t feel quite RxJS to play
    around with Promises. There is a more stream-based approach you can take; we were
    almost there before, we just needed to make a minor adjustment:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们所做的只是在将数据交给`from()`操作符之前简单地处理数据。在RxJS中玩弄Promises并不是很合适。您可以采取更基于流的方法；我们几乎在那里了，我们只需要做出一些微小的调整：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And there it is: our `fetch()` call is now providing us data like a stream.
    So what did we do? Well, we changed our `map()` call to a `flatMap()` call. The
    reason for that was that when we called `r.json()`, we got a `Promise`. We fixed
    that by wrapping it in a `from()` call, `Rx.Observable.from(r.json())`. That would
    make the stream emit a `PromiseObservable` unless we changed from `map()` to `flatMap()`.
    As we learned in the previous section, if we risk creating a stream within a stream,
    we need `flatMap()` to come to our rescue, which it did.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是：我们的`fetch()`调用现在提供给我们数据，就像一个流一样。那我们做了什么呢？嗯，我们将我们的`map()`调用改为了`flatMap()`调用。这样做的原因是，当我们调用`r.json()`时，我们得到了一个`Promise`。我们通过将其包装在`from()`调用中来解决了这个问题，`Rx.Observable.from(r.json())`。这将使流发出一个`PromiseObservable`，除非我们从`map()`改为`flatMap()`。正如我们在上一节中学到的，如果我们冒着在流中创建另一个流的风险，我们需要`flatMap()`来拯救我们，它的确做到了。
- en: ajax() operator
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ajax()操作符
- en: 'Unlike the `fetch()` API, which is `Promise`-based, the `ajax()` method is
    actually `Observable`-based, which makes our job a little easier. Using it is
    quite straightforward, like so:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于`Promise`的`fetch()` API不同，`ajax()`方法实际上是基于`Observable`的，这使得我们的工作变得更容易。使用它非常简单，就像这样：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see, the preceding code calls the `ajax()` operator with a URL as
    an argument. The second thing worthy of mentioning is the call to the `map()` operator,
    which digs out our data from the `response` property. Because it is an `Observable`,
    we just have to subscribe to it as usual by calling the `subscribe()` method and
    providing it with a listener function as an argument.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，前面的代码调用了`ajax()`操作符，并将URL作为参数。值得一提的第二件事是调用`map()`操作符，它从`response`属性中挖出我们的数据。因为它是一个`Observable`，我们只需要像往常一样调用`subscribe()`方法并提供一个监听函数作为参数来订阅它。
- en: 'This covers a simple case when you want to fetch data using the HTTP verb `GET`.
    Fortunately for us, it is quite easy to create, update, or delete by using an
    overloaded version of the `ajax()` operator which takes an `AjaxRequest` object
    instance which has the following fields:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了当你想使用HTTP动词`GET`获取数据时的一个简单情况。对我们来说，幸运的是，通过使用`ajax()`操作符的重载版本，我们可以很容易地创建、更新或删除一个`AjaxRequest`对象实例，该实例具有以下字段：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see from this object specification, all the fields are optional and
    there are also quite a few things we can configure with our request, such as `headers`, `timeout`,
    `user`, `crossDomain`, and so on; pretty much what we would expect from a nice
    AJAX wrapping functionality. Except for the overload of the `ajax()` operator,
    a few shorthand options also exist:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个对象规范中我们可以看到，所有字段都是可选的，我们还可以用我们的请求配置很多东西，比如`headers`、`timeout`、`user`、`crossDomain`等等；基本上符合我们对一个很好的AJAX封装功能的期望。除了`ajax()`操作符的重载之外，还存在一些简写选项：
- en: '`get()`: Fetches data using the `GET` verb'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 使用`GET`动词获取数据'
- en: '`put()`: Updates data using the `PUT` verb'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put()`: 使用`PUT`动词更新数据'
- en: '`post()`: Creates data using the `POST` verb'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`post()`: 使用`POST`动词创建数据'
- en: '`patch()`: The idea with using the `PATCH` verb is to update a partial resource'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch()`: 使用`PATCH`动词更新部分资源的想法'
- en: '`delete()`: Removes data using the `DELETE` verb'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete()`: 使用`DELETE`动词删除数据'
- en: '`getJSON()`: Fetches data using the `GET` verb and sets the response type to
    `application/json`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getJSON()`: 使用`GET`动词获取数据并将响应类型设置为`application/json`'
- en: Cascading calls
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级联调用
- en: So far, we have covered the two main ways you will use AJAX to send or receive
    data. When it comes to receiving data, it's usually not as simple as fetching
    the data and rendering it. In fact, you will most likely have a dependency on
    when you can fetch which data. A typical example of this is needing to perform
    a login call before you can fetch the remaining data. In some cases, it might
    be that you need to first log in, then fetch the data of the logged in user, and
    once you have that you can fetch messages, orders, or whichever kind of data you
    need that might be specific to a certain user. This whole phenomenon of fetching
    data in this way is called cascading calls.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了你将使用AJAX发送或接收数据的两种主要方式。当涉及到接收数据时，通常不像获取数据和渲染数据那么简单。事实上，你很可能会对你何时可以获取哪些数据有依赖。一个典型的例子是需要在获取剩余数据之前执行登录调用。在某些情况下，可能需要先登录，然后获取已登录用户的数据，一旦你有了这些数据，就可以获取消息、订单或者你需要的特定用户的任何其他类型的数据。以这种方式获取数据的整个现象被称为级联调用。
- en: Let's have a look at how we use cascading calls with Promises and gradually
    learn how to do the same with RxJS. We are taking this little detour as we assume
    that most of you reading this book are familiar with Promises.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Promises进行级联调用，并逐渐学习如何使用RxJS进行相同的操作。我们做这个小的绕道是因为我们假设大多数阅读本书的人都熟悉Promises。
- en: 'Let''s look at the dependent case we first mentioned, where we need to perform
    the following steps in this order:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们首先提到的依赖情况，我们需要按照以下顺序执行以下步骤：
- en: The user first logs in to the system
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户首先登录到系统
- en: Then we fetch information about the user
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们获取有关用户的信息
- en: Then we fetch information about the user's orders
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们获取关于用户订单的信息
- en: 'Using promises, it would look something like this in code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 promises，在代码中会看起来像这样：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code describes how we first log in to the system, using the `login()` method,
    and obtain a token. We use this token in any future calls to ensure we make authenticated
    calls. We also see how we perform the `getUser()` call and obtain a user instance.
    We use that same user instance to perform our last call, `getOrders()`, whereby
    the user ID is used as a routing parameter: ``/orders/user/${user.id}``.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码描述了我们如何首先使用 `login()` 方法登录系统并获取令牌。我们在任何未来的调用中使用这个令牌来确保我们进行了身份验证的调用。我们还看到了如何执行 `getUser()` 调用并获取用户实例。我们使用相同的用户实例来执行我们的最后一个调用 `getOrders()`，其中用户
    ID 被用作路由参数：``/orders/user/${user.id}``。
- en: 'We have shown how to perform cascading calls using promises; we did this to
    establish a common ground for the problem we are trying to solve. The RxJS approach
    is very similar: we have shown that the `ajax()` operator exists and makes our
    lives easier when dealing with AJAX calls. To achieve the cascading calls effect
    with RxJS, we simply need to use the `switchMap()` operator. This will lead to our
    code looking like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何使用 promises 执行级联调用；我们这样做是为了建立我们试图解决的问题的共同基础。RxJS 方法非常相似：我们已经展示了 `ajax()` 操作符的存在，并且在处理
    AJAX 调用时使我们的生活更轻松。要使用 RxJS 实现级联调用效果，我们只需要使用 `switchMap()` 操作符。这将使我们的代码看起来像这样：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We have highlighted the parts that need changing in the preceding code. In
    short, the changes are:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经突出显示了上述代码中需要更改的部分。简而言之，更改如下：
- en: '`fetch()` is replaced by the `ajax()` operator'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fetch()` 被 `ajax()` 操作符替换'
- en: We call `.map(r => r.response)` instead of `.then(r => r.json())`
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们调用 `.map(r => r.response)` 而不是 `.then(r => r.json())`
- en: We do `.switchMap()` calls for each cascading call instead of `.then(getOrders)`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们对每个级联调用使用 `.switchMap()` 而不是 `.then(getOrders)`
- en: 'There is one more interesting aspect that we need to cover, namely that of
    parallel calls. When we fetched the user and the order, we waited for a previous
    call to fully complete before we initiated the next call. In a lot of cases, this
    might not be strictly necessary. Imagine that we have a similar case to the previous
    one, but there is a lot of interesting information surrounding the user that we
    want to fetch. Instead of just fetching orders, the user might have a friends
    collection or a collection of messages. The precondition for fetching that data
    is only that we fetched the user, so we know which collection of friends we should
    query for and which collection of messages we need. In the world of promises,
    we would use the `Promise.all()` construct to achieve parallelization. With that
    in mind, we update our `Promise` code to look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个有趣的方面需要我们涵盖，即并行调用。当我们获取用户和订单时，我们等待上一个调用完全完成后才启动下一个调用。在许多情况下，这可能并不是严格必要的。想象一下，我们有一个类似于之前的情况，但是围绕用户有很多有趣的信息，我们想要获取。我们不仅仅是获取订单，用户可能有一个朋友集合或一组消息。获取这些数据的前提只是我们获取了用户，所以我们知道应该查询哪个朋友集合和我们需要哪些消息集合。在
    promises 的世界中，我们会使用 `Promise.all()` 来实现并行化。考虑到这一点，我们更新我们的 `Promise` 代码如下：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we can see from the preceding code, we introduce the new `getUsersData()` method, which
    fetches orders, messages, and friends collections in parallel, making our app
    responsive sooner, as the data will arrive sooner than if we just fetched it one
    after another.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中可以看出，我们引入了新的 `getUsersData()` 方法，以并行方式获取订单、消息和朋友集合，使我们的应用程序更快响应，因为数据将比逐个获取更快到达。
- en: 'We can easily achieve the same thing with RxJS by introducing the `forkJoin()` operator.
    It takes a list of streams and fetches everything in parallel. We therefore update
    our RxJS code to look like the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过引入`forkJoin()`运算符轻松地使用RxJS实现相同的功能。它接受一个流列表并并行获取所有内容。因此，我们将更新我们的RxJS代码如下：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: A deeper look
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入研究
- en: 'So far, we have had a look at some operators that will let you create streams
    or change streams with the `map()` and `filter()` operators, we have learned how
    to manage different AJAX scenarios, and so on. The basics are there, but we haven''t
    really approached the topic of operators in a structured way. What do we mean
    by that? Well, operators can be thought of as belonging to different categories.
    The number of operators at our disposal is a staggering 60 plus. It''s going to
    take us time to learn all that, if we ever do. Here is the thing though: we just
    need to know which different types of operators exist so that we can apply them
    where appropriate. This reduces our cognitive load and our memory. Once we know
    which categories we have, we just have to drill down, and most likely we will
    end up knowing 10-15 operators in total and the rest we can just look up when
    we need them.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过一些运算符，让您可以创建流或使用`map()`和`filter()`运算符更改流，我们已经学会了如何处理不同的AJAX场景等。基础知识已经掌握，但我们还没有以结构化的方式接近运算符的主题。我们是什么意思呢？嗯，运算符可以被认为属于不同的类别。我们可以使用的运算符数量惊人地超过60个。如果我们有幸学会了所有这些，那将需要花费我们很多时间。但是这里的问题是：我们只需要知道存在哪些不同类型的运算符，以便我们可以在适当的地方应用它们。这减少了我们的认知负担和记忆负担。一旦我们知道我们有哪些类别，我们只需要深入研究，很可能我们最终会知道总共有10-15个运算符，其余的我们只需要在需要时查找。
- en: 'Currently, we have the following categories:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们有以下类别：
- en: '**Creation operators**: These operators help us create streams in the first
    place. Almost anything can be converted into a stream with the help of these operators.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建运算符：这些运算符帮助我们首先创建流。几乎任何东西都可以通过这些运算符转换为流。
- en: '**Combination operators**: These operators help us combine values as well as
    streams.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合运算符：这些运算符帮助我们组合值以及流。
- en: '**Mathematical operators**: These operators perform mathematical evaluations
    on the values being emitted.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学运算符：这些运算符对被发出的值进行数学评估。
- en: '**Time-based operators**: These operators change at which speed values are
    emitted.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于时间的运算符：这些运算符改变了值被发出的速度。
- en: '**Grouping operators**: The idea with these operators is to operate on a group
    of values rather than individual ones.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组运算符：这些运算符的想法是对一组值进行操作，而不是单个值。
- en: Creation operators
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建运算符
- en: 'We use creation operators to create the streams themselves, because let''s
    face it: what we need to turn into a stream isn''t always going to be a stream,
    but by making it into a stream, it will have to play nicely with other streams
    and, best of all, will get to leverage the full power of using operators.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用创建运算符来创建流本身，因为让我们面对现实吧：我们需要转换为流的东西并不总是流，但通过将其转换为流，它将不得不与其他流友好相处，并且最重要的是，将能够充分利用使用运算符的全部力量。
- en: So, what do these other non-streams consist of? Well, it could be anything asynchronous
    or synchronous. The important thing is that it is data that needs to be emitted
    at some point. Therefore, a range of creation operators exist. In the coming subsections,
    we will present a subset of all those that exist, enough for you to realize the
    power of turning anything into a stream.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些非流的其他内容包括什么？嗯，它可能是任何异步或同步的东西。重要的是，这是需要在某个时刻发出的数据。因此，存在一系列创建运算符。在接下来的小节中，我们将介绍其中的一部分，足以让您意识到将任何东西转换为流的强大力量。
- en: of() operator
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: of()运算符
- en: 'We have already had the chance to use this operator a few times. It takes an
    unknown number of comma-separated arguments, which can be integers, strings, or
    objects. This is an operator you want to use if you just want to emit a limited
    set of values. To use it, simply type:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有几次机会使用这个操作符了。它接受一个未知数量的逗号分隔的参数，可以是整数、字符串或对象。如果你只想发出一组有限的值，这是一个你想要使用的操作符。要使用它，只需输入：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As can be seen from the code, it really doesn't matter what we place in our `of()` operator,
    it is able to emit it anyway.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码中可以看出，我们放在`of()`操作符中的内容并不重要，它都能发出。
- en: from() operator
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: from() 操作符
- en: 'This operator can take arrays or a `Promise` as input and turn them into a
    stream. To use it, simply call it like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符可以接受数组或`Promise`作为输入，并将它们转换为流。要使用它，只需这样调用它：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This saves us a lot of headache by not having to deal with different types of
    asynchronous calls.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以避免我们处理不同类型的异步调用时的很多麻烦。
- en: range() operator
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: range() 操作符
- en: 'This operator lets you specify a range, a number to start from and a number
    to end on. This is a nice shorthand that quickly lets you create a stream with
    a range of numbers. To use it, simply type:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符允许你指定一个范围，一个起始数字和一个结束数字。这是一个很好的简写，可以快速地创建一个数字范围的流。要使用它，只需输入：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: fromEvent() operator
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fromEvent() 操作符
- en: Now it gets really interesting. The `fromEvent()` operator allows us to mix
    a UI event such as a `click` or a `scroll` event and turn it into a stream. So
    far, we have operated under the assumption that asynchronous calls is something
    that only has to do with AJAX calls. This is far from true. The fact that we can
    mix UI events with any type of asynchronous calls creates a really interesting
    situation that allows us to compose really powerful, expressive code. We will
    touch on this topic further in the coming section, *Thinking in streams*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变得非常有趣了。`fromEvent()` 操作符允许我们混合UI事件，比如`click`或`scroll`事件，并将其转换为流。到目前为止，我们一直假设异步调用只与AJAX调用有关。这远非事实。我们可以将UI事件与任何类型的异步调用混合在一起，这创造了一个非常有趣的情况，使我们能够组合非常强大、富有表现力的代码。我们将在接下来的部分*Thinking
    in streams*中进一步讨论这个话题。
- en: 'To use this operator, you need to provide it with two arguments: a DOM element
    and the name of an event, like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个操作符，你需要提供两个参数：一个DOM元素和一个事件的名称，就像这样：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Combination
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: Combination operators are about combining values from different streams. We
    have a few operators at our disposal that can help us out. This kind of operator
    makes sense when we, for some reason, don't have all the data in one place but
    need to acquire it from more than one place. Combining data structures from different
    sources could be tedious and error-prone work if it weren't for the powerful operators
    we are about to describe.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 组合操作符是关于合并来自不同流的值。我们有一些操作符可以帮助我们。当我们由于某种原因不是所有的数据都在一个地方，而是需要从多个地方获取数据时，这种操作符就是有意义的。如果不是因为我们即将描述的强大操作符，从不同来源组合数据结构可能是繁琐且容易出错的工作。
- en: merge() operator
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: merge() 操作符
- en: 'The `merge()` operator takes data from different streams and combines it. Here
    is the thing though: these streams can be of any kind as long as they are of type `Observable`.
    This means we can combine data from a timing operation, a promise, static data
    from an `of()` operator, and so on. What merging does is to interleave the emitted
    data. This means that it will emit from both streams at the same time in the following
    example. Using the operator comes in two flavors, as a static method but also
    as an instance method:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge()` 操作符从不同的流中获取数据并将其组合起来。不过需要注意的是：这些流可以是任何类型，只要它们是`Observable`类型。这意味着我们可以从定时操作、promise、`of()`操作符中获取的静态数据等不同类型的流中组合数据。合并的作用是交错发射数据。这意味着它将在以下示例中同时从两个流中发射。使用该操作符有两种方式，一种是作为静态方法，另一种是作为实例方法。'
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The takeaway here is that if you just need to combine one stream with another,
    then use the instance method version of this operator, but if you have several
    streams, then use the static version. Furthermore, the order in which the streams
    are specified matters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的要点是，如果你只需要将一个流与另一个流合并，那么使用该操作符的实例方法版本，但如果你有多个流，则使用静态版本。此外，指定流的顺序很重要。
- en: combineLatest()
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: combineLatest()
- en: 'Imagine you have a situation where you have set up connections with several
    endpoints that serve you with data. What you care about is the latest data that
    was emitted from each endpoint. You might be in a situation where one or several
    endpoints stop sending data after a while and you want to know what the last thing
    that happened was. In this situation, we want the ability to combine all the latest
    values from all of the involved endpoints. That''s where the `combineLatest()` operator comes
    in. You use it in the following way:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你设置了与多个端点建立连接，这些端点为你提供数据。你关心的是每个端点最后发射的数据。你可能会遇到这样的情况，一个或多个端点在一段时间后停止发送数据，而你想知道最后发生的事情是什么。在这种情况下，我们希望能够将所有涉及端点的最新值组合在一起。这就是`combineLatest()`操作符的用处。你可以这样使用它：
- en: '[PRE31]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What we can see here is that `firstStream$` stops emitting values after a while thanks
    to the `take()` operator, which limits the number of items. However, the `combineLatest()` operator
    ensures we are still given the very last value `firstStream$` emitted.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`firstStream$`在一段时间后停止发射值，这要归功于`take()`操作符，它限制了发射的项目数量。然而，`combineLatest()`操作符确保我们仍然会得到`firstStream$`发射的最后一个值。
- en: zip()
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: zip()
- en: 'The point of this operator is to stitch as many values together as possible.
    We may be dealing with continuous streams, but also with streams that have a limit
    to the number of values they emit. You use this operator in the following way:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作符的目的是尽可能多地将值拼接在一起。我们可能正在处理连续的流，但也可能处理有限数量值的流。你可以这样使用该操作符：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we can see, here, we stitch values together vertically, and by the least
    common denominator, `thirdStream$` is the shortest, calculating the number of
    emitted values. This means we will take values from left to right and zip them
    together. As `thirdStream$` only has two values, we end up with only two emits.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这里看到的，我们在垂直方向上将值拼接在一起，并且以最小公倍数`thirdStream$`为准，计算发射值的数量。这意味着我们将从左到右取值并将它们合并。由于`thirdStream$`只有两个值，我们最终只会得到两个发射。
- en: concat()
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: concat()
- en: 'At first look, the `concat()` operator looks like another `merge()` operator,
    but this is not entirely true. The difference is that a `concat()` waits for other
    streams to be completed first before emitting a stream from the next stream in
    order. How you arrange your stream in your call to `concat()` matters. The operator
    is used in the following way:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，`concat()` 操作符看起来像另一个 `merge()` 操作符，但这并不完全正确。不同之处在于 `concat()` 在发出下一个流之前会等待其他流完成。如何安排你的流在调用
    `concat()` 中很重要。操作符的使用方式如下：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Mathematical
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学
- en: Mathematical operators are simply operators that carry out mathematical operations
    on values, such as finding the largest or smallest value, summarizing all values,
    and so on.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 数学运算符只是在值上执行数学运算的操作符，比如找到最大或最小值，总结所有值等。
- en: max
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: max
- en: 'The `max()` operator finds the largest value. This comes in two flavors: we
    either just call the `max()` operator with no arguments, or we give it a `compare`
    function. The `compare` function then decides whether something is larger than,
    smaller than, or equal to an emitted value. Let''s have a look at the two different
    versions:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`max()` 操作符找到最大值。有两种形式：我们可以只调用 `max()` 操作符而不带参数，或者给它一个 `compare` 函数。`compare`
    函数然后决定某个值是否大于、小于或等于一个发出的值。让我们看看这两种不同的版本：'
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can see in the preceding code that we get one result back and it is the largest
    one.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的代码中看到我们得到了一个结果，它是最大的。
- en: min
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: min
- en: 'The `min()` operator is pretty much the opposite of the `max()` operator; it
    comes in two flavors: with parameter and without parameter. Its task is to find
    the smallest value. To use it, type:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`min()` 操作符基本上是 `max()` 操作符的相反；它有两种形式：带参数和不带参数。它的任务是找到最小值。要使用它，输入：'
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: sum
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sum
- en: 'There used to be an operator called `sum()`, but it hasn''t existed for several
    versions. What there is instead is `.reduce()`. With the `reduce()` operator,
    we can easily achieve the same thing. The following is how you would write a `sum()` operator
    using `reduce()`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一个叫做 `sum()` 的操作符，但它已经在几个版本中不存在了。现在有的是 `.reduce()`。使用 `reduce()` 操作符，我们可以很容易地实现相同的功能。以下是使用
    `reduce()` 编写 `sum()` 操作符的方法：
- en: '[PRE36]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'What this does is to loop through all the emitted values and sum up the results.
    So, in essence, it sums up everything. Of course, this kind of operator can not
    only be applied to numbers, but to objects as well. The difference lies in how
    you carry out the `reduce()` operation. The following example covers such a scenario:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的作用是循环遍历所有发出的值并将结果相加。因此，它本质上是将所有值相加。当然，这种类型的操作符不仅可以应用于数字，还可以应用于对象。不同之处在于如何执行
    `reduce()` 操作。以下示例涵盖了这种情况：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see from the preceding code, the `reduce()` operator ensures that
    all the object's properties get merged together into one object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看到，`reduce()` 操作符确保所有对象的属性都被合并成一个对象。
- en: Time
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间
- en: Time is a very important concept when talking about streams. Imagine you have
    multiple streams that have different bandwidths, or one stream is just faster
    than the other, or you have a scenario where you want to retry an AJAX call within
    a certain time interval. In all of these situations, we need to control how fast
    the data is being emitted, and time plays an important role in all these scenarios.
    At our disposal, we have a ton of operators that, like a magician, enable us to
    craft and control our values as we see fit.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 时间在谈论流时是一个非常重要的概念。想象一下，你有多个带宽不同的流，或者一个流比另一个流快，或者你有一个场景，你想在一定的时间间隔内重试一个 AJAX
    调用。在所有这些情况下，我们需要控制数据的发出速度，时间在所有这些情况下都起着重要的作用。我们可以使用大量的操作符，就像魔术师一样，让我们根据需要制作和控制我们的值。
- en: interval() operator
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: interval() 操作符
- en: 'In JavaScript, there is a `setInterval()` function that enables you to execute
    code at regular intervals, up until the point that you choose to stop it. RxJS
    has an operator that behaves just like that, the `interval()` operator. It takes
    one parameter: normally, the number of milliseconds between emitted values. You
    use it in the following way:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，有一个`setInterval()`函数，可以让您以固定的时间间隔执行代码，直到您选择停止为止。RxJS有一个行为类似的操作符，即`interval()`操作符。它接受一个参数：通常是发出值之间的毫秒数。您可以按照以下方式使用它：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A word of caution is that this operator will continue emitting until you stop
    it. The best way to stop it is to combine it with a `take()` operator. A `take()` operator
    takes a parameter that specifies how many emitted values it wants before stopping.
    The updated code looks like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这个操作符会继续发出值，直到您停止它。停止它的最佳方法是将它与`take()`操作符结合使用。`take()`操作符接受一个参数，指定在停止之前要发出多少个值。更新后的代码如下：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: timer() operator
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器（timer()）操作符
- en: 'The `timer()` operator has the job of emitting values after a certain amount
    of time. It comes in two flavors: you either emit just one value after a number
    of milliseconds, or you keep on emitting values with a certain amount of delay
    between them. Let''s look at the two different flavors available:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`timer()`操作符的作用是在一定时间后发出值。它有两种方式：要么在一定毫秒数后发出一个值，要么在它们之间有一定的延迟发出值。让我们看看这两种不同的方式：'
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: delay() operator
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟（delay()）操作符
- en: 'The `delay()` operator delays all the values being emitted and is used in the
    following way:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay()`操作符延迟发出所有的值，使用方式如下：'
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: sampleTime() operator
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采样时间（sampleTime()）操作符
- en: 'The `sampleTime()` operator is used to only emit values after the sample period
    has passed. A good use case for this is when you want to have a *cooldown* functionality.
    Imagine you have users that press a Save button way too often. It might be that
    saving takes a few seconds to complete. A way to approach this is to disable the
    Save button while saving. Another valid approach is to simply ignore any presses
    of the button until the operation has had the chance to complete. The following
    code does just that:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampleTime()`操作符用于在采样周期过后才发出值。一个很好的用例是当您想要实现*冷却*功能时。想象一下，您有一些用户经常按保存按钮。也许保存需要几秒钟才能完成。一种方法是在保存时禁用保存按钮。另一种有效的方法是简单地忽略按钮的任何按压，直到操作有机会完成。以下代码就是这样做的：'
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: debounceTime() operator
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防抖时间（debounceTime()）操作符
- en: 'The `sampleTime()` operator was able to ignore the user for a certain period
    of time, but the `debounceTime()` operator takes a different approach. Debounce
    as a concept means that we wait for things to calm down before emitting a value.
    Imagine an input element that the user types into. The user will stop typing eventually.
    We want to make sure the user has actually stopped, so we wait for a while before
    we actually do something. This is what the `debounceTime()` operator does for
    us. The following example shows how we can listen to the user typing into an input
    element, wait for the user to stop typing, and lastly, perform an AJAX call:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`sampleTime()`操作符能够在一定时间内忽略用户，但`debounceTime()`操作符采用了不同的方式。防抖作为一个概念意味着我们在发出值之前等待事情平静下来。想象一下用户输入的输入元素。用户最终会停止输入。我们希望确保用户实际上已经停止了，所以我们在实际执行操作之前等待一段时间。这就是`debounceTime()`操作符为我们做的。以下示例显示了我们如何监听用户在输入元素中输入，等待用户停止输入，最后执行一个AJAX调用：'
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When the user then types a number in the text box, the keyup event will be triggered
    after 2 seconds of inactivity. After that, an AJAX call will be carried out using
    our text box input.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当用户在文本框中输入数字时，如果有2秒的不活动时间，将触发keyup事件。之后，将使用我们的文本框输入执行一个AJAX调用。
- en: Grouping
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组
- en: Grouping operators allow us to operate on a group of collected events rather
    than one emitted event at a time.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 分组运算符允许我们对一组收集的事件进行操作，而不是一次发射一个事件。
- en: buffer() operator
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: buffer()运算符
- en: 'The idea with the `buffer()` operator is that we can collect a bunch of events
    without them being emitted straight away. The operator itself takes an argument,
    an `Observable` that defines when we should stop collecting events. At that point
    in time, we can choose what to do with those events. Here is how you can use this
    operator:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer()`运算符的想法是，我们可以收集一堆事件，而不会立即发射它们。运算符本身需要一个参数，即一个定义我们何时停止收集事件的`Observable`。在那时，我们可以选择如何处理这些事件。以下是您可以使用此运算符的方式：'
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What this does is to collect events until there has been 2 seconds of inactivity.
    At that point, we release all the key events we have buffered up. When we release
    all those events, we can, for example, send them somewhere via AJAX. This is a
    typical scenario in a chat application. Using the preceding code, we can always
    send the latest character that has been typed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 它的作用是收集事件，直到有2秒的不活动时间。在那时，我们释放所有已缓冲的关键事件。当我们释放所有这些事件时，我们可以，例如，通过AJAX将它们发送到某个地方。这是聊天应用程序中的典型情景。使用前面的代码，我们可以始终发送最新输入的字符。
- en: bufferTime() operator
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: bufferTime()运算符
- en: A very similar operator to `buffer()` is `bufferTime()`. This one lets us specify
    how long we would like to buffer events for. It is a bit less flexible than `buffer()`,
    but can still be quite useful.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与`buffer()`非常相似的运算符是`bufferTime()`。这个运算符允许我们指定要缓冲事件的时间长度。它比`buffer()`灵活性稍差，但仍然非常有用。
- en: Thinking in streams
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以流的方式思考
- en: 'So far, we have gone through a bunch of scenarios that have shown us which
    operators are at our disposal and how they can be chained. We have also seen how
    operators such as `flatMap()` and `switchMap()` can really change things as we
    move from one type of observable to another. So, which approach should you take
    when working with Observables? Obviously, we need to express an algorithm using
    operators, but where do we start? The first thing we need to do is to think of
    the start and the end. Which types of events do we want to capture and what should
    the end result look like? That already gives us a hint as to the number of transformations
    we need to carry out to get there. If we want to transform the data only, then
    we can probably make do with a `map()` operator and a `filter()` operator. If
    we want to transform from one `Observable` to the next, then we need a `flatMap()` or
    a `switchMap()`. Do we have a specific behavior, such as waiting for the user
    to stop typing? If so, then we need to look at `debounceTime()` or similar. It''s
    really the same as all problems: break it down, see which parts you have, divide,
    and conquer. Let''s try to break this down into a list of steps though:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经经历了一系列情景，向我们展示了哪些运算符可以使用以及它们如何链接。我们还看到了像`flatMap()`和`switchMap()`这样的运算符在我们从一个类型的可观察对象转换到另一个类型时可以真正改变事情。那么，在使用可观察对象时应该采取哪种方法呢？显然，我们需要使用运算符来表达算法，但我们应该从哪里开始呢？我们需要做的第一件事是考虑起点和终点。我们想要捕获哪些类型的事件，最终结果应该是什么样子？这已经给了我们一个提示，即我们需要执行多少次转换才能到达目标。如果我们只想转换数据，那么我们可能只需要使用`map()`运算符和`filter()`运算符。如果我们想从一个`Observable`转换到另一个`Observable`，那么我们需要使用`flatMap()`或`switchMap()`。我们是否有特定的行为，比如等待用户停止输入？如果是这样，那么我们需要看看`debounceTime()`或类似的运算符。这实际上与所有问题都是一样的：分解问题，看看你有哪些部分，分割并征服。尽管我们尝试将其分解为一系列步骤：
- en: What are the inputs? UI events or something else?
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入是什么？UI事件还是其他东西？
- en: What are the outputs? The end result?
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出是什么？最终结果是什么？
- en: Given the second bullet, which transformations do I need to get there?
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鉴于第二个要点，我需要哪些转换才能到达那里？
- en: Do I deal with more than one stream?
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我是否需要处理多个流？
- en: Do I need to handle errors, and if so, how?
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我需要处理错误吗？如果需要，应该如何处理？
- en: This has hopefully introduced you to how to think about streams. Remember, start
    small and work your way toward your goal.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这希望能让你了解如何思考流。记住，从小处开始，朝着目标努力。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We set out to learn more about basic operators. In doing so, we encountered
    the `map()` and `filter()` operators, which allowed us to control what was being
    emitted. Knowledge of the `do()` operator gave us a way to debug our streams.
    Furthermore, we learned about the existence of sandboxed environments, such as
    JS Bin and RxFiddle, and how they can help us to quickly get started with RxJS.
    AJAX was the next topic that we delved into, and we built an understanding of
    the different scenarios that might occur. Moving on deeper into RxJS, we looked
    at different operator categories. We barely scratched the surface on that one,
    but it offered us a way to approach how to learn which types of operators are
    in the library. Finally, we finished off this chapter by looking at how to change
    and develop our mindset to thinking about streams.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始学习更多关于基本操作符的知识。在这个过程中，我们遇到了 `map()` 和 `filter()` 操作符，它们让我们能够控制发出的内容。了解了
    `do()` 操作符让我们有了一种调试流的方式。此外，我们了解了沙盒环境的存在，比如 JS Bin 和 RxFiddle，以及它们如何帮助我们快速开始使用
    RxJS。AJAX 是我们接下来深入研究的话题，我们建立了对可能发生的不同情景的理解。深入了解 RxJS 后，我们看了不同的操作符类别。我们只是触及了表面，但它为我们提供了一种学习库中哪些类型的操作符的方法。最后，我们通过思考如何改变和发展我们的思维方式来处理流来结束了这一章。
- en: It is with all this acquired knowledge that we are now ready to venture into
    more advanced Rx topics in the next chapter. We know our basics, now the time
    has come to master them.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些获得的知识，我们现在准备在下一章中涉足更高级的 Rx 主题。我们已经掌握了基础知识，现在是时候来精通它们了。
