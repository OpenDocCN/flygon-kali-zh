- en: '*Chapter 8*: Using Helm with the Operator Framework'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：使用Helm与操作员框架'
- en: One of the advantages of using Helm is the ability to synchronize the local
    and the live states. With Helm, the local state is managed with values files that,
    when provided using the `install` or `upgrade` command, apply the values to synchronize
    the live state in a Kubernetes cluster. In previous chapters, this was performed
    by invoking these commands when a change to the application was desired.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Helm的一个优势是能够同步本地和实时状态。使用Helm，本地状态是通过值文件进行管理的，当使用`install`或`upgrade`命令提供这些值时，将这些值应用于Kubernetes集群中的实时状态以进行同步。在之前的章节中，当希望对应用程序进行更改时，通过调用这些命令来执行此操作。
- en: Another way these changes can be synchronized is to create an application inside
    the cluster that checks periodically that the desired state matches the current
    configurations within an environment. If the state does not match, the application
    can automatically modify the environment to match the desired state. This application
    is referred to as a Kubernetes operator. In this chapter, we will create a Helm-based
    operator that helps ensure the locally defined state always matches the live state
    of the cluster. If it does not, the operator will execute the appropriate Helm
    commands to update the environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种同步这些更改的方法是在集群内创建一个应用程序，定期检查期望状态是否与环境中的当前配置匹配。如果状态不匹配，应用程序可以自动修改环境以匹配期望的状态。这种应用程序被称为Kubernetes操作员。在本章中，我们将创建一个基于Helm的操作员，以确保本地定义的状态始终与集群的实时状态匹配。如果不匹配，操作员将执行适当的Helm命令来更新环境。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Kubernetes Operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Kubernetes操作员
- en: Creating a Helm Operator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Helm操作员
- en: Using Helm to manage Operators and **Custom Resources** (**CRs**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helm来管理操作员和自定义资源（CRs）
- en: Cleaning up your Kubernetes environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理您的Kubernetes环境
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to have the following technologies installed
    on your local machine:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要在本地机器上安装以下技术：
- en: '`minikube`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minikube`'
- en: '`helm`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helm`'
- en: '`kubectl`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl`'
- en: In addition to these tools, you should find the Packt repository containing
    resources associated with the examples on GitHub at [https://github.com/PacktPublishing/-Learn-Helm](https://github.com/PacktPublishing/-Learn-Helm).
    This repository will be referenced throughout this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些工具之外，您还应该在GitHub上找到Packt存储库，其中包含与示例相关的资源，网址为[https://github.com/PacktPublishing/-Learn-Helm](https://github.com/PacktPublishing/-Learn-Helm)。本存储库将在本章中被引用。
- en: Understanding Kubernetes Operators
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Kubernetes操作员
- en: Automation is at the core of the Kubernetes platform. As covered in [*Chapter
    1*](B15458_01_Final_JM_ePub.xhtml#_idTextAnchor017), *Understanding Kubernetes
    and Helm*, Kubernetes resources can be managed either implicitly by running `kubectl`
    commands or declaratively by applying **YAML**-formatted representations. Once
    the resources are applied using the Kubernetes **Command-Line Interface** (**CLI**),
    one of the fundamental principles of Kubernetes is to match the current state
    of resources within the cluster to the desired state, a process known as **the
    control loop**. This ongoing, non-terminating pattern of monitoring the state
    of the cluster is implemented through the use of controllers. Kubernetes includes
    numerous controllers that are native to the platform, with examples ranging from
    admission controllers that intercept requests to the Kubernetes **Application
    Programming Interface** (**API)** to replication controllers that manage the number
    of Pod replicas that are running.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化是Kubernetes平台的核心。正如在[*第1章*](B15458_01_Final_JM_ePub.xhtml#_idTextAnchor017)中所介绍的，*了解Kubernetes和Helm*，Kubernetes资源可以通过运行`kubectl`命令隐式管理，也可以通过应用YAML格式的表示来声明性地管理。一旦使用Kubernetes命令行界面（CLI）应用了资源，Kubernetes的基本原则之一是将集群中资源的当前状态与期望状态匹配，这个过程称为**控制循环**。这种持续的、非终止的监视集群状态的模式是通过控制器实现的。Kubernetes包括许多本地于平台的控制器，例如拦截对Kubernetes应用程序编程接口（API）的请求的准入控制器，以及管理运行的Pod副本数量的复制控制器。
- en: As interest in Kubernetes began to grow, the combination of providing users
    the ability to extend the capabilities of the base platform, as well as a way
    to provide more intelligence around managing the life cycle of applications, led
    to the creation of several important concepts that have defined the second wave
    of Kubernetes development. First, the introduction of the **Custom Resource Definitions**
    (**CRDs**) enabled users the ability to extend the default Kubernetes API, the
    mechanism for interacting with the Kubernetes platform, in order to create and
    register new types of resources. Registering a new CRD creates a new **Representational
    State Transfer** (**REST****ful**) resource path on the Kubernetes API server.
    So, similar to how you can use the Kubernetes CLI to execute `kubectl get pods`
    to retrieve all Pod objects, registering a new CRD for an object type called **Guestbook**,
    for example, allows for the capability of invoking `kubectl get guestbook` to
    view all Guestbook objects that have been previously created. With this new capability
    realized, developers could now create controllers of their own to monitor these
    types of CRs to manage the lifecycle of applications that can be described through
    the use of CRDs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着对Kubernetes的兴趣开始增长，提供用户扩展基础平台功能的能力，以及提供更多关于管理应用程序生命周期的智能的组合，导致了几个重要概念的产生，这些概念定义了Kubernetes开发的第二波。首先，引入了自定义资源定义（CRD），使用户能够扩展默认的Kubernetes
    API，这是与Kubernetes平台交互的机制，以创建和注册新类型的资源。注册新的CRD会在Kubernetes API服务器上创建一个新的RESTful资源路径。因此，类似于您可以使用Kubernetes
    CLI执行`kubectl get pods`来检索所有Pod对象，例如，为名为**Guestbook**的对象类型注册一个新的CRD，允许调用`kubectl
    get guestbook`来查看先前创建的所有Guestbook对象。有了这种新的能力，开发人员现在可以创建自己的控制器来监视这些类型的CR，以管理可以通过CRD描述的应用程序的生命周期。
- en: The second major trend was the advances in the types of applications that were
    being deployed onto Kubernetes. Instead of small and simple applications, more
    complex and stateful applications were being deployed more frequently. These types
    of advanced applications typically require a higher level of management and maintenance,
    such as handling the deployment of multiple components, as well as considerations
    around 'day 2' activities, such as backup and restorations. These tasks extend
    beyond the typical types of controllers found in Kubernetes, as deep knowledge
    related to the application they are managing must be embedded within. This pattern
    of using a CR to manage applications and their components is known as an **Operator**
    pattern. First coined by the software company CoreOS in 2016, Operators aim to
    capture the knowledge that a human operator would have for managing the lifecycle
    of an application. Operators are packaged as normal containerized applications—deployed
    within pods—that react on changes to the API against CRs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个主要趋势是Kubernetes部署的应用程序类型的进展。与小型简单的应用程序不同，更复杂和有状态的应用程序被部署得更频繁。这些高级应用程序通常需要更高级的管理和维护水平，例如处理多个组件的部署，以及围绕“第二天”活动的考虑，如备份和恢复。这些任务超出了Kubernetes中典型控制器的范围，因为必须嵌入与其管理的应用程序相关的深层知识。使用CR来管理应用程序及其组件的这种模式被称为**Operator**模式。由软件公司CoreOS在2016年首次提出，Operators旨在捕获人类操作员在管理应用程序生命周期方面的知识。Operators被打包为普通的容器化应用程序——部署在pod中——对CR的API更改做出反应。
- en: 'Operators are commonly written using a toolkit called the Operator Framework,
    and are based on one of the following three different technologies:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Operators通常使用称为Operator Framework的工具包编写，并基于以下三种不同的技术之一：
- en: Go
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: Ansible
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible
- en: Helm
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm
- en: Go-based Operators leverage the Go programming language to implement control
    loop logic. Ansible-based Operators leverage the Ansible CLI tool and Ansible
    playbooks. Ansible is an automation tool whose logic is written in YAML files
    called playbooks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Go的Operators利用Go编程语言实现控制循环逻辑。基于Ansible的Operators利用Ansible CLI工具和Ansible playbooks。Ansible是一种自动化工具，其逻辑是在称为playbooks的YAML文件中编写的。
- en: In this chapter, we will focus on Helm-based Operators. Helm Operators base
    their control loop logic on Helm charts and a subset of the features provided
    by the Helm CLI. As a result, they represent an easy way for Helm users to implement
    their Operators.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于基于Helm的Operators。Helm Operators将其控制循环逻辑基于Helm图表和Helm CLI提供的一部分功能。因此，它们代表了Helm用户实现其Operators的一种简单方式。
- en: With an understanding of Operators, let's create an operator of our own, using
    Helm.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了Operators，让我们使用Helm创建自己的operator。
- en: Creating a Helm operator
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Helm operator
- en: In this section, we will write a Helm-based operator that will be used to install
    the Guestbook Helm chart created in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*. This chart can be seen under the `guestbook/`
    folder of the Pack[t repository (https://github.com/PacktPublishing/-Learn-Helm/tree/master/helm-charts/ch](https://github.com/PacktPublishing/-Learn-Helm/tree/master/helm-charts/charts/guestbook)arts/guestbook).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个基于Helm的operator，用于安装[*第5章*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265)中创建的Guestbook
    Helm图表，*构建您的第一个Helm图表*。该图表可以在Pack[t存储库的`guestbook/`文件夹下找到（https://github.com/PacktPublishing/-Learn-Helm/tree/master/helm-charts/ch](https://github.com/PacktPublishing/-Learn-Helm/tree/master/helm-charts/charts/guestbook)arts/guestbook）。
- en: 'An operator is built as a container image that contains the control loop logic
    to maintain an application. The following diagram demonstrates how the Guestbook
    Operator will function once it is deployed:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员是作为一个包含控制循环逻辑以维护应用程序的容器镜像构建的。下图演示了访客留言簿操作员部署后的功能：
- en: '![Figure 8.1 – Guestbook Operator workflow'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 - 访客留言簿操作员工作流'
- en: '](image/Figure_8.1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.1.jpg)'
- en: Figure 8.1 – Guestbook Operator workflow
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 - 访客留言簿操作员工作流
- en: The Guestbook Operator will constantly watch for changes to Guestbook CRs. When
    a Guestbook CR is created, the Guestbook Operator will install the Guestbook chart
    you created in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*. Conversely, if the Guestbook CR is deleted,
    the Guestbook Operator will remove the Guestbook Helm chart.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 访客留言簿操作员将不断监视访客留言簿CR的更改。当创建访客留言簿CR时，访客留言簿操作员将安装您在[*第5章*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265)中创建的访客留言簿图表，*构建您的第一个Helm图表*。相反，如果删除了访客留言簿CR，访客留言簿操作员将删除访客留言簿Helm图表。
- en: With an understanding of how the Guestbook Operator will function, let's set
    up an environment in which the operator can be built and deployed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 了解访客留言簿操作员的功能后，让我们设置一个可以构建和部署操作员的环境。
- en: Setting up the environment
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'First, since the operator will be deployed to Kubernetes, you should start
    your Minikube environment by running the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于操作员将部署到Kubernetes，您应该通过运行以下命令来启动Minikube环境：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After starting Minikube, create a namespace called `chapter8`, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Minikube后，创建一个名为`chapter8`的命名空间，如下所示：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the Guestbook Operator is built as a container image, you will need to
    create an image repository that can store it so it can later be referenced. To
    store this image, we will create a new repository in Quay (quay.io), a public
    container registry (though if you have an account elsewhere, that will suffice
    as well). We will also prepare a local development environment with the necessary
    tooling required to build the operator image.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于访客留言簿操作员是作为一个容器镜像构建的，您需要创建一个可以存储它以便以后引用的镜像存储库。为了存储这个镜像，我们将在Quay（quay.io）中创建一个新的存储库，这是一个公共容器注册表（如果您在其他地方有帐户，那也可以）。我们还将准备一个本地开发环境，其中包含构建操作员镜像所需的必要工具。
- en: Let's begin by creating a new image repository in Quay.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在Quay中创建一个新的镜像存储库开始。
- en: Creating a Quay repository
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Quay存储库
- en: Creating a new repository in Quay requires you to have a Quay account. Follow
    these steps to create a Quay accou[nt:](https://quay.io/signin/)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Quay中创建一个新的存储库需要您拥有一个Quay帐户。按照以下步骤创建一个Quay帐户：[nt:](https://quay.io/signin/)
- en: '[Navigate to https:/](https://quay.io/signin/)/quay.io/signin/ in your browser.
    You will be prompted by a screen to enter your Quay credentials, as illustrated
    in the following screenshot:![Figure 8.2 – Red Hat Quay sign-in page'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[在浏览器中导航到https:/](https://quay.io/signin/)/quay.io/signin/。屏幕会提示您输入Quay凭据，如下截图所示：![图8.2
    - 红帽Quay登录页面'
- en: '](image/Figure_8.2.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.2.jpg)'
- en: Figure 8.2 – Red Hat Quay sign-in page
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 - 红帽Quay登录页面
- en: At the bottom of the page, click the **Create Account** link. You will be prompted
    with a set of dialog boxes to create a new Quay account, as illustrated in the
    following screenshot:![Figure 8.3 – Red Hat Quay Create new account page
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面底部，单击**创建帐户**链接。屏幕会提示您使用一组对话框来创建一个新的Quay帐户，如下截图所示：![图8.3 - 红帽Quay创建新帐户页面
- en: '](image/Figure_8.3.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.3.jpg)'
- en: Figure 8.3 – Red Hat Quay **Create new account** page
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 - 红帽Quay**创建新帐户**页面
- en: Enter your desired credentials, and then select **Create Free Account**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您想要的凭据，然后选择**创建免费帐户**。
- en: You will soon be sent an email confirmation. Click the link on the confirmation
    email to verify your account and continue using Quay with your new account.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您很快将收到一封电子邮件确认。单击确认电子邮件中的链接以验证您的帐户并继续使用新帐户的Quay。
- en: Once you have created a new Quay account, you can continue to create a new image
    repository for the operator image.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了新的Quay帐户后，您可以继续为operator图像创建新的图像存储库。
- en: 'To create a new image repository, select the **+** plus icon at the top-right
    corner of the Quay page and select **New Repository**, as illustrated in the following
    screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的图像存储库，请在Quay页面右上角选择**+**加号图标，然后选择**新存储库**，如下截图所示：
- en: '![Figure 8.4 – Selecting “New Repository” to create a new image repository'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 - 选择“新存储库”以创建新的图像存储库'
- en: '](image/Figure_8.4.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.4.jpg)'
- en: Figure 8.4 – Selecting 'New Repository' to create a new image repository
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 - 选择“新存储库”以创建新的图像存储库
- en: 'You will then be taken to the **Create New Repository** page, where you should
    enter the following details:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您将被带到**创建新存储库**页面，在那里您应该输入以下细节：
- en: For **Repository Name**, enter `guestbook-operator.`
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**存储库名称**，输入`guestbook-operator`。
- en: Select the **Public** radio button, indicating unauthenticated access to the
    repository. This change will simplify how Kubernetes will be able to access the
    image.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**Public**单选按钮，表示对存储库的无身份验证访问。此更改将简化Kubernetes访问图像的方式。
- en: 'The remainder of the options can be kept at the default values. Once complete,
    the **Create New Repository** page should appear, as illustrated in the following
    screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 其余选项可以保持默认值。完成后，**创建新存储库**页面应该会出现，如下截图所示：
- en: '![Figure 8.5 – The “Create New Repository” page in Quay'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 - Quay中的“创建新存储库”页面'
- en: '](image/Figure_8.5.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.5.jpg)'
- en: Figure 8.5 – The 'Create New Repository' page in Quay
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 - Quay中的“创建新存储库”页面
- en: Select the **Create Public Repository** button to create the Quay repository.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**创建公共存储库**按钮以创建Quay存储库。
- en: Now that a repository has been created to store the Guestbook Operator image,
    let's prepare an environment with the tooling required to build a Helm operator.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经创建了一个存储库来存储Guestbook Operator图像，让我们准备一个环境，其中包含构建Helm operator所需的工具。
- en: Preparing a local development environment
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备本地开发环境
- en: 'In order to create a Helm operator, you will need the following CLI tools at
    a minimum:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建Helm operator，您至少需要以下CLI工具：
- en: '`operator-sdk`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator-sdk`'
- en: '`docker`, `podman`, or `buildah`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker`，`podman`或`buildah`'
- en: The `operator-sdk` CLI is a toolkit used to help develop Kubernetes Operators.
    It contains inherent logic to simplify the operator development process. Under
    the hood, `operator-sdk` requires a container management tool that it can use
    to build the operator image. The `operator-sdk` CLI supports `docker`, `podman`,
    and `buildah` as the underlying container management tools.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator-sdk` CLI是用于帮助开发Kubernetes Operators的工具包。它包含简化operator开发过程的内在逻辑。在幕后，`operator-sdk`需要一个容器管理工具，它可以用来构建operator图像。`operator-sdk`
    CLI支持`docker`，`podman`和`buildah`作为底层容器管理工具。'
- en: To install the `operator-sdk` CLI, you can simply download a release from their
    [GitHub repository at https://github.com/operator-framework/](https://github.com/operator-framework/operator-sdk/releases)operator-sdk/releases.
    However, the process used to install `docker`, `podman`, or `buildah` may vary
    greatly, depending on your operating system; not to mention, that Windows users
    will not be able to use the `operator-sdk` toolkit natively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`operator-sdk` CLI，您可以从它们的[GitHub存储库https://github.com/operator-framework/](https://github.com/operator-framework/operator-sdk/releases)operator-sdk/releases下载一个版本。但是，安装`docker`，`podman`或`buildah`的过程可能会因操作系统而异；更不用说，Windows用户将无法原生地使用`operator-sdk`工具包。
- en: Fortunately, the Minikube **Virtual Machine** (**VM**) can be leveraged as a
    working environment for developers of many different operating systems since it
    is a Linux VM and also contains the Docker CLI. In this section, we will install
    `operator-sdk` to the Minikube VM and will use this environment to create the
    operator. Note that while the steps provided are designed to run in the VM, most
    of these steps will also apply to all Linux and Mac machines.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Minikube虚拟机（VM）可以作为开发人员的工作环境，因为它是一个Linux VM，并且还包含Docker CLI，适用于许多不同操作系统。在本节中，我们将在Minikube
    VM上安装`operator-sdk`，并将使用此环境来创建operator。请注意，虽然提供的步骤旨在在VM中运行，但大多数步骤也适用于所有Linux和Mac机器。
- en: 'Follow these steps to install `operator-sdk` on the Minikube VM:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤在Minikube VM上安装`operator-sdk`：
- en: 'Gain access to the VM by running the `minikube ssh` command, as follows:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`minikube ssh`命令来访问VM，如下所示：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once inside the VM, you need to download the `operator-sdk` CLI. This can be
    accomplished using the `curl` command. Note that the `operator-sdk` version used
    at the time of writing was version `0.15.2`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入VM，您需要下载`operator-sdk` CLI。这可以通过使用`curl`命令来完成。请注意，写作时使用的`operator-sdk`版本是`0.15.2`版本。
- en: 'To download this version of the `operator-sdk` CLI, run the following command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载此版本的`operator-sdk` CLI，请运行以下命令：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once downloaded, you will need to change the permission of the `operator-sdk`
    binary to be user-executable. Run the `chmod` command to make this modification,
    as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载后，您需要更改`operator-sdk`二进制文件的权限为用户可执行。运行`chmod`命令进行此修改，如下所示：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, move the `operator-sdk` binary to a location managed by the VM''s `PATH`
    variable, such as `/usr/bin`. Because this operation requires a root privilege,
    you will need to run the `mv` command using `sudo`, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`operator-sdk`二进制文件移动到VM的`PATH`变量管理的位置，例如`/usr/bin`。因为此操作需要root权限，您需要使用`sudo`运行`mv`命令，如下所示：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, verify your `operator-sdk` installation by running the `operator-sdk
    version` command, like this:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过运行`operator-sdk version`命令来验证您的`operator-sdk`安装，如下所示：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If this command executes without error, you have successfully installed the
    `operator-sdk` CLI.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此命令执行没有错误，那么您已成功安装了`operator-sdk` CLI。
- en: As an additional step, you should also clone the Packt repository in your Minikube
    VM since we will later leverage the `guestbook` Helm chart to build a Helm operator.
    Run the following command in your VM to clone the r[epository:](https://github.com/PacktPublishing/-Learn-Helm.git)
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为一个额外的步骤，您还应该在Minikube VM中克隆Packt存储库，因为我们将稍后利用`guestbook` Helm图表来构建Helm operator。在VM中运行以下命令来克隆存储库：](https://github.com/PacktPublishing/-Learn-Helm.git)
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that you have a Quay image repository and a local development environment
    created from the Minikube VM, let's begin writing the Guestbook Operator. Note
    that an example of the operator code is located in t[he Packt repository at https://github.com/PacktPublishing/-Learn-Helm/tree/ma](https://github.com/PacktPublishing/-Learn-Helm/tree/master/guestbook-operator)ster/guestbook-operator.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了Quay镜像存储库和从Minikube VM创建的本地开发环境，让我们开始编写Guestbook Operator。请注意，operator代码的示例位于Packt存储库的https://github.com/PacktPublishing/-Learn-Helm/tree/master/guestbook-operator位置。
- en: Scaffolding the operator file structure
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搭建operator文件结构
- en: 'Similar to Helm charts themselves, Helm Operators built by the `operator-sdk`
    CLI have a specific file structure that must be adhered to. The file structure
    is explained in the following table:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与Helm图表本身类似，由`operator-sdk` CLI构建的Helm Operators具有必须遵守的特定文件结构。文件结构在下表中进行了解释：
- en: '![Figure 8.6 – The file structures explained'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 - 文件结构解释'
- en: '](image/Figure_8.6.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.6.jpg)'
- en: Figure 8.6 – The file structures explained
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 - 文件结构解释
- en: 'The operator file structure can be easily created using the `operator-sdk new`
    command. In your Minikube VM, execute the following command to scaffold the Guestbook
    Operator:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`operator-sdk new`命令可以轻松创建操作员文件结构。在您的Minikube VM中，执行以下命令来创建Guestbook Operator的脚手架：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `operator-sdk new` command created a local directory called `guestbook-operator`,
    which contains the operator contents. It is specified that a Helm operator should
    be created using the `--type` flag, along with `Guestbook` as the name of the
    CR.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator-sdk new`命令创建了一个名为`guestbook-operator`的本地目录，其中包含操作员内容。指定应使用`--type`标志创建Helm操作员，以及`Guestbook`作为CR的名称。'
- en: Finally, the `--helm-chart` flag instructed the `operator-sdk` CLI to copy the
    source Guestbook chart to the operator directory.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`--helm-chart`标志指示`operator-sdk` CLI将源Guestbook图表复制到操作员目录。
- en: With the Guestbook operator successfully scaffolded, let's build the operator
    and push it to your Quay registry.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 成功创建了Guestbook操作员的脚手架，让我们构建操作员并将其推送到您的Quay注册表。
- en: Building the operator and pushing it to Quay
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建操作员并将其推送到Quay
- en: The `operator-sdk` CLI provides an `operator-sdk build` command that makes it
    straightforward to build an operator image. This command is designed to be run
    against the top-level directory of an operator, and will build the image by referencing
    the Dockerfile located under the operator's `build/` folder.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator-sdk` CLI提供了一个`operator-sdk build`命令，可以轻松构建操作员图像。此命令旨在针对操作员的顶级目录运行，并将通过引用位于操作员`build/`文件夹下的Dockerfile来构建图像。'
- en: 'In your Minikube VM, run the `operator-sdk build` command, substituting your
    Quay username where directed, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Minikube VM中，运行`operator-sdk build`命令，将您的Quay用户名替换为指定位置，如下所示：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the build is successful, you will receive the following message:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建成功，您将收到以下消息：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since the Minikube VM has Docker installed, the `operator-sdk` CLI used Docker
    in the background to build the image. You can run the `docker images` command
    to verify that the image has been built, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Minikube VM安装了Docker，`operator-sdk` CLI在后台使用Docker构建图像。您可以运行`docker images`命令来验证图像是否已构建，如下所示：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the operator image built locally, it must be pushed to an image registry
    so that it can be pulled from Kubernetes. In order to push an image to a registry
    using Docker, you must first authenticate with the target registry. Use the `docker
    login` command to log in to Quay, as shown in the following code snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员图像在本地构建后，必须将其推送到图像注册表，以便可以从Kubernetes中拉取。为了使用Docker将图像推送到注册表，您必须首先对目标注册表进行身份验证。使用`docker
    login`命令登录到Quay，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once logged in to Quay, use the `docker push` command to push your operator
    image to your Quay registry, like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到Quay后，使用`docker push`命令将操作员图像推送到Quay注册表，就像这样：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When the push is finished, return to the `guestbook-operator` repository that
    you created in the *Creating a Quay repository* section. You should be able to
    see a new tag published under the **Repository tags** section, as illustrated
    in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 推送完成后，返回到您在*创建Quay存储库*部分创建的`guestbook-operator`存储库。您应该能够在**存储库标签**部分看到一个新的标签发布，如下面的屏幕截图所示：
- en: '![Figure 8.7 – A new tag should be pushed to your Quay registry'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 – 应将新标签推送到您的Quay注册表'
- en: '](image/Figure_8.7.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.7.jpg)'
- en: Figure 8.7 – A new tag should be pushed to your Quay registry
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 应将新标签推送到您的Quay注册表
- en: Now that your operator has been pushed to a container registry, let's continue
    by deploying the operator to your Kubernetes environment.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的操作员已经推送到容器注册表，让我们继续通过将操作员部署到您的Kubernetes环境。
- en: Deploying the Guestbook Operator
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署Guestbook操作员
- en: When scaffolding the Guestbook Operator, the `operator-sdk` CLI also created
    a folder called `deploy` and generated the files required to deploy the operator
    within.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在搭建Guestbook Operator时，`operator-sdk` CLI还创建了一个名为`deploy`的文件夹，并生成了部署操作员所需的文件。
- en: 'The following file structure depicts the contents of the `deploy` folder:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`deploy`文件夹中的内容所示的文件结构：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `crds/` folder contains the YAML resource required to create the Guestbook
    CRD (`charts.helm.k8s.io_guestbooks_crd.yaml`). This file is required to register
    the new Guestbook API endpoint with Kubernetes. In addition, the `crds/` folder
    contains an example Guestbook CR application (`charts.helm.k8s.io_v1alpha1_guestbook_cr.yaml`).
    Creating this file will trigger the operator to install the Guestbook Helm chart.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`crds/`文件夹包含创建Guestbook CRD所需的YAML资源（`charts.helm.k8s.io_guestbooks_crd.yaml`）。此文件用于在Kubernetes中注册新的Guestbook
    API端点。此外，`crds/`文件夹包含一个示例Guestbook CR应用程序（`charts.helm.k8s.io_v1alpha1_guestbook_cr.yaml`）。创建此文件将触发操作员安装Guestbook
    Helm图表。'
- en: 'Review the contents of the CR in order to become familiar with the types of
    properties defined, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看CR的内容，以熟悉所定义属性的类型，如下所示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A snippet of the output is provided in the following code block:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块中提供了输出的片段：
- en: '![Figure 8.8 – Snippet of the Guestbook CR'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 - Guestbook CR的片段'
- en: '](image/Figure_8.8.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_8.8.jpg)'
- en: Figure 8.8 – Snippet of the Guestbook CR
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 - Guestbook CR的片段
- en: Each of the entries under the `spec` stanza refer to the Guestbook chart's `values.yaml`
    file. The `operator-sdk` tool automatically created this example CR with each
    of the default values that were included from this file. Additional entries can
    be added or modified before applying this CR, to override other values of the
    Guestbook chart. These values are consumed by the operator at runtime to deploy
    the Guestbook application accordingly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec`部分中的每个条目都指向Guestbook图表的`values.yaml`文件。`operator-sdk`工具自动使用此文件中包含的每个默认值创建了此示例CR。在应用此CR之前，可以添加或修改其他条目，以覆盖Guestbook图表的其他值。这些值在运行时由操作员使用，以相应地部署Guestbook应用程序。'
- en: The `deploy/operator.yaml` file defines the actual operator itself and contains
    a simple deployment resource. We will return soon to this file's contents.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`deploy/operator.yaml`文件定义了实际的操作员本身，并包含一个简单的部署资源。我们将很快返回到这个文件的内容。'
- en: The `role_binding.yaml`, `role.yaml` and `service_account.yaml` files were created
    in order to provide the operator with the permissions necessary to watch for Guestbook
    CRs and install the Guestbook Helm chart to Kubernetes. It performs these actions
    by authenticating with the Kubernetes API using the service account defined in
    the `service_account.yaml` file. Once authenticated, the operator will be provided
    authorization based on the `role.yaml` and `role_binding.yaml` resources. The
    `role.yaml` file lists the finely grained permissions that describe the exact
    resources and actions that the operator is allowed to perform. The `role_binding.yaml`
    file binds the role to the operator's service account.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`role_binding.yaml`、`role.yaml`和`service_account.yaml`文件是为了为操作员提供必要的权限，以便监视Guestbook
    CR并将Guestbook Helm图表安装到Kubernetes中。它通过在`service_account.yaml`文件中定义的服务帐户进行身份验证，然后执行这些操作。一旦经过身份验证，操作员将根据`role.yaml`和`role_binding.yaml`资源获得授权。`role.yaml`文件列出了描述操作员被允许执行的确切资源和操作的精细权限。`role_binding.yaml`文件将角色绑定到操作员的服务帐户。'
- en: 'With an understanding of each resource created under the operator''s `deploy/`
    folder, follow these steps to deploy your Guestbook operator:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 了解操作员`deploy/`文件夹下创建的每个资源后，请按照以下步骤部署您的Guestbook操作员：
- en: 'Unfortunately, the Minikube VM does not contain `Kubectl`, so you must first
    exit to your local system if you are still connected to the VM from the command
    line, by running the following command:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不幸的是，Minikube VM不包含`Kubectl`，所以如果您仍然通过命令行连接到VM，您必须首先退出到您的本地系统，通过运行以下命令：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The resources that were created with `operator-sdk` earlier are also located
    in the Packt repository under the `guestbook-operator/` folder. If you have not
    cloned this repository in previous chapters, clone it now using the following
    command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 早些时候使用`operator-sdk`创建的资源也位于Packt存储库的`guestbook-operator/`文件夹下。如果您之前没有克隆过这个存储库，请使用以下命令现在克隆它：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'As a quick aside, note that the only resource in the Packt repository that
    is modified from the resources you created in your Minikube VM is the `role.yaml`
    file. The `operator-sdk` CLI generated a simple `role.yaml` file based on the
    template files that were included in the guestbook Helm chart. However, if you
    can recall, the guestbook chart contained a couple of resources that would only
    be included based on a conditional value. These resources were the `Job` and `PersistentVolumeClaim`
    hook resources that were only included if persistent storage was enabled. One
    example of this is shown in the `PersistentVolumeClaim` template, in the following
    code snippet:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速的旁注，需要注意的是，Packt存储库中唯一修改自Minikube VM中创建的资源的资源是`role.yaml`文件。`operator-sdk`
    CLI基于包含在guestbook Helm图表中的模板文件生成了一个简单的`role.yaml`文件。但是，如果您能回忆起来，guestbook图表包含了一些资源，只有在条件值基础上才会包含这些资源。这些资源是`Job`和`PersistentVolumeClaim`挂钩资源，只有在启用持久存储时才会包含。其中一个示例显示在`PersistentVolumeClaim`模板中，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `operator-sdk` CLI did not automatically create the **Role-Based Access
    Control** (**RBAC**) rules for `Jobs` and `PersistentVolumeClaims` since it did
    not know whether this template would be included.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`operator-sdk` CLI没有自动为`Jobs`和`PersistentVolumeClaims`创建**基于角色的访问控制**（**RBAC**）规则，因为它不知道是否应该包含此模板。'
- en: As a result, the authors have added these rules to the `role.yaml` file, located
    at https://github.com/PacktPublishing/-Learn-Helm/blob/master/guestbook-operator/deploy/role.yaml#L81-L104.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作者已将这些规则添加到位于https://github.com/PacktPublishing/-Learn-Helm/blob/master/guestbook-operator/deploy/role.yaml#L81-L104的`role.yaml`文件中。
- en: 'The Guestbook operator will be dependent on a new API endpoint. Create this
    endpoint by applying the CRD under the `guestbook-operator/deploy/crds` folder,
    as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Guestbook操作员将依赖于一个新的API端点。通过在`guestbook-operator/deploy/crds`文件夹下应用CRD来创建此端点，如下所示：
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We will use the second file under that folder (the CR) later to deploy the Guestbook
    application.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后使用该文件夹下的第二个文件（CR）来部署Guestbook应用程序。
- en: 'Next, you will need to modify the `guestbook-operator/deploy/operator.yaml`
    file to specify the operator image that you built earlier. You will notice the
    following lines of code within this file:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要修改`guestbook-operator/deploy/operator.yaml`文件，以指定您之前构建的操作员图像。您会注意到在这个文件中有以下代码行：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Replace the `REPLACE_IMAGE` text with the location of your operator image. This
    value should be similar to `quay.io/$QUAY_USERNAME/guestbook-operator`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将`REPLACE_IMAGE`文本替换为您的操作员图像的位置。此值应类似于`quay.io/$QUAY_USERNAME/guestbook-operator`。
- en: 'Once you have applied the CRD and updated your `operator.yaml` file, you can
    proceed to apply each of the resources under the `guestbook-operator/deploy/`
    folder by running the following command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您应用了CRD并更新了您的`operator.yaml`文件，您可以通过运行以下命令来继续应用`guestbook-operator/deploy/`文件夹中的每个资源：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Wait for the operator to report the `1/1` ready state by running a watch against
    the Pods in the `chapter8` namespace, like this:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过对`chapter8`命名空间中的Pods运行观察，等待操作员报告`1/1`就绪状态，就像这样：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that the Guestbook operator has been deployed, let's use it to install the
    Guestbook Helm chart.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Guestbook operator已部署，让我们使用它来安装Guestbook Helm chart。
- en: Deploying the Guestbook application
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署Guestbook应用程序
- en: 'When using Helm normally as a standalone CLI tool, you would install a Helm
    chart by running the `helm install` command. With a Helm operator, you install
    a Helm chart by creating a CR. Install the Guestbook Helm chart by creating the
    provided CR located under the `guestbook-operator/deploy/crds/` folder, as shown
    in the following code snippet:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Helm作为独立的CLI工具时，您可以通过运行`helm install`命令来安装Helm chart。使用Helm operator，您可以通过创建CR来安装Helm
    chart。通过创建位于`guestbook-operator/deploy/crds/`文件夹下的提供的CR来安装Guestbook Helm chart，如下面的代码片段所示：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run another `watch` command against the Pods in the `chapter8` namespace, as
    shown in the following code snippet, and you should be able to see the Guestbook
    and Redis Pods spin up as a result of the Helm chart installation:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对`chapter8`命名空间中的Pod运行另一个`watch`命令，如下面的代码片段所示，您应该能够看到Guestbook和Redis Pods因Helm
    chart安装而启动：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code block depicts each Pod in its `READY` state:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块描述了每个Pod处于`READY`状态：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you created the Guestbook CR, a `helm install` command was executed by
    the operator to install the Guestbook chart. You can confirm the release that
    was created by running `helm list`, like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建Guestbook CR时，操作员会执行`helm install`命令来安装Guestbook chart。您可以通过运行`helm list`来确认已创建的发布，就像这样：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'An upgrade of the release can be performed by modifying the `example-guestbook`
    CR. Modify your `guestbook-operator/deploy/crds/charts.helm.k8s.io_v1alpha1_guestbook_cr.yaml`
    file to change the number of replicas from `1 to 2`, like this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改`example-guestbook` CR来执行发布的升级。修改您的`guestbook-operator/deploy/crds/charts.helm.k8s.io_v1alpha1_guestbook_cr.yaml`文件，将副本数从`1`更改为`2`，就像这样：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Apply the change once you have updated the `replicaCount` value, as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新了`replicaCount`值之后应用更改，如下所示：
- en: '[PRE28]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The modification to the Guestbook CR will trigger a `helm upgrade` command
    against the `example-guestbook` release. As you may recall from [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*, the upgrade hook for the Guestbook Helm chart
    will initiate a backup of the Redis database. If you run a watch against the Pods
    in the `chapter8` namespace after modifying the CR, you will notice a backup `Job`
    begin and will see one of the two Guestbook Pods terminate once the backup is
    finished. You will also notice from the `helm list` command in the following code
    snippet that the revision number of the `example-guestbook` release was increased
    to `2`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 修改Guestbook CR将触发针对`example-guestbook`发布的`helm upgrade`命令。正如您可能还记得[*第5章*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265)中所述，*构建您的第一个Helm
    Chart*，Guestbook Helm chart的升级钩子将启动对Redis数据库的备份。如果您在修改CR后对`chapter8`命名空间中的Pod运行`watch`，您将注意到一个备份`Job`开始，并且一旦备份完成，您将看到两个Guestbook
    Pods中的一个终止。您还将从以下代码片段中的`helm list`命令中注意到`example-guestbook`发布的修订号已增加到`2`：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Although the revision number was increased to `2`, one limitation of Helm-based
    Operators as of writing is that you cannot initiate a rollback to a previous revision
    as you can by using the CLI. If you attempt to run `helm history` against the
    `example-guestbook` release, you will also notice that only the second revision
    is in the release history, as illustrated in the following code snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管修订号已增加到`2`，但截至撰写本文时，基于Helm的Operators的一个限制是您无法像使用CLI那样发起回滚到先前的修订。如果您尝试对`example-guestbook`发布运行`helm
    history`，您还将注意到只有第二个修订在发布历史中，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is an important difference between using Helm regularly with the CLI and
    using Helm via a Helm-based operator. Because the release history is not retained,
    the Helm-based operator does not allow you to perform an explicit rollback. However,
    a `helm rollback` command will be run in cases where upgrades fail. In this case,
    the rollback hook will be executed in an attempt to roll back to the attempted
    upgrade.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用Helm CLI和使用基于Helm的operator之间的重要区别。由于不保留发布历史记录，基于Helm的operator不允许执行显式回滚。但是，如果升级失败，将运行`helm
    rollback`命令。在这种情况下，将执行回滚钩子，试图回滚到尝试的升级。
- en: Although the Helm-based operator does not retain release history, one area in
    which it excels is synchronizing the desired and live states of an application.
    This is because the operator constantly watches the state of the Kubernetes environment
    and ensures that the application is always configured to match the configuration
    specified on the CR. In other words, if one of the Guestbook application's resources
    is modified, the operator will immediately revert the change to make it match
    the specification as defined on the CR. You can see this in action by modifying
    a field on one of the Guestbook resources.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基于Helm的operator不保留发布历史记录，但它在同步应用程序的期望状态和实际状态方面表现出色。这是因为operator不断监视Kubernetes环境的状态，并确保应用程序始终配置为与CR上指定的配置匹配。换句话说，如果修改了Guestbook应用程序的资源之一，operator将立即恢复更改，使其与CR上定义的规范匹配。您可以通过修改Guestbook资源之一上的字段来看到这一点。
- en: As an example, we will change the Guestbook deployment's replica count directly
    from `2` to `3` and watch the operator revert this back to `2` replicas automatically
    to re-synchronize the desired state defined in the CR.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将直接将Guestbook部署的副本计数从`2`更改为`3`，并观察operator自动将其恢复为`2`个副本，以重新同步CR中定义的期望状态。
- en: 'Execute the following `kubectl patch` command to change the replica count of
    the Guestbook deployment from `2` to `3`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下`kubectl patch`命令，将Guestbook部署的副本计数从`2`更改为`3`：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Normally, this would simply add an additional replica of your Guestbook application.
    However, because the Guestbook CR currently defines only `2` replicas, the operator
    quickly changes the replica count back to `2` and terminates the additional Pod
    that was created. If you actually wanted to increase the replica count to `3`,
    you would have to update the `replicaCount` value on the Guestbook CR. This process
    provides the advantage of ensuring that the desired state matches the live state
    of the cluster.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这只会添加一个额外的Guestbook应用程序副本。但是，因为Guestbook CR当前仅定义了`2`个副本，所以operator会快速将副本计数更改回`2`，并终止创建的额外Pod。如果您实际上想将副本计数增加到`3`，则必须更新Guestbook
    CR上的`replicaCount`值。该过程的优势在于确保期望状态与集群的实际状态匹配。
- en: 'Uninstalling the Guestbook application with a Helm-based operator is as simple
    as removing the CR. Delete the `example-guestbook` CR to uninstall the release,
    like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于Helm的operator卸载Guestbook应用程序就像删除CR一样简单。删除`example-guestbook` CR以卸载发布，就像这样：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will remove the `example-guestbook` release and all of the dependent resources.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除`example-guestbook`发布以及所有相关资源。
- en: 'You can also remove the Guestbook Operator and its resources as well, since
    we will not need them in the next section. You can do this by running the following
    command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以删除Guestbook Operator及其资源，因为我们在下一节中将不再需要它们。您可以通过运行以下命令来执行此操作：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In general, you should always make sure that you delete the CR first before
    deleting the operator. The operator is programmed to perform a `helm uninstall`
    command on your release when you delete the CR. If you accidentally delete the
    operator first, you will have to manually run `helm uninstall` from the command
    line.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您应该始终确保在删除运算符之前先删除CR。当您删除CR时，运算符会执行`helm uninstall`命令来删除您的发布。如果您意外地先删除了运算符，您将不得不在命令行上手动运行`helm
    uninstall`。
- en: In this section, you created a Helm operator and learned how to deploy an application
    using an operator-based approach. In the next section, we will continue the discussion
    on Operators by investigating how they can be managed using Helm.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您创建了一个Helm运算符，并学习了如何使用基于运算符的方法部署应用程序。在下一节中，我们将继续讨论运算符，探讨如何使用Helm来管理它们。
- en: Using Helm to manage Operators and CRs
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Helm管理运算符和CRs
- en: In the previous section, you installed the Guestbook Operator by first creating
    the CRD that is found underneath the `guestbook-operator/deploy/crds/` folder.
    Next, you created the operator resources contained underneath the `guestbook-operator/deploy/`
    folder. Finally, you created the CR to deploy the Guestbook application. Each
    of these tasks was performed by using the Kubectl CLI, but this instead can also
    be accomplished using Helm charts to provide a more flexible and repeatable solution
    toward installing and managing an operator.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，您首先通过创建位于`guestbook-operator/deploy/crds/`文件夹下的CRD来安装了Guestbook运算符。接下来，您创建了位于`guestbook-operator/deploy/`文件夹下的运算符资源。最后，您创建了CR来部署Guestbook应用程序。这些任务都是使用Kubectl
    CLI执行的，但也可以使用Helm图表来提供更灵活和可重复的解决方案来安装和管理运算符。
- en: Helm allows you to provide a special directory called `crds/` inside your Helm
    chart, which is used to create CRDs whenever the chart is installed. Helm creates
    CRDs before any of the other resources defined under the `templates/` folder,
    making it simpler to install applications such as Operators that depend on the
    presence of CRDs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Helm允许您在Helm图表中提供一个名为`crds/`的特殊目录，用于在安装图表时创建CRDs。Helm会在`templates/`文件夹下定义的任何其他资源之前创建CRDs，使得安装依赖于CRDs存在的应用程序（如运算符）更加简单。
- en: 'The following file structure depicts a Helm chart that could be used to install
    the Guestbook Operator:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文件结构描述了一个Helm图表，可用于安装Guestbook运算符：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This Helm chart, upon installation, would first install the Guestbook CRD. If
    the CRD is already present in the cluster, it would skip CRD creation and would
    simply create the template resources instead. Note that while CRDs can be convenient
    to include in a Helm chart, there are several limitations. First, CRDs in a Helm
    chart cannot contain any Go templating, so CRDs cannot benefit from parameterization
    as in typical resources. CRDs can also never be upgraded, rolled back, or deleted.
    As a result, users must take care to modify or remove the CRDs manually if these
    actions are desired. Finally, installing such a chart as previously described
    would require a cluster-admin privilege, the highest privilege permitted in Kubernetes,
    because the chart contains at least one CRD resource.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 安装此Helm图表时，首先会安装Guestbook CRD。如果CRD已经存在于集群中，它将跳过CRD的创建，而只会创建模板资源。请注意，虽然CRDs可以方便地包含在Helm图表中，但存在一些限制。首先，Helm图表中的CRDs不能包含任何Go模板，因此CRDs无法像典型资源那样受益于参数化。CRDs也永远无法升级、回滚或删除。因此，如果需要执行这些操作，用户必须小心地手动修改或删除CRDs。最后，如前所述安装此类图表将需要集群管理员权限，这是Kubernetes中允许的最高权限，因为图表至少包含一个CRD资源。
- en: The Helm chart described previously can be used by cluster administrators to
    easily install the Guestbook operator. This, however, is only half of the equation,
    as end users must still create CRs to deploy the Guestbook application. Luckily,
    end users of the operator can also leverage Helm by creating a Helm chart that
    wraps the Guestbook CR.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 前面描述的Helm chart可以被集群管理员使用，以便轻松安装Guestbook operator。然而，这只是方程的一半，因为最终用户仍然必须创建CRs来部署Guestbook应用程序。幸运的是，operator的最终用户也可以利用Helm，创建一个包装Guestbook
    CR的Helm chart。
- en: 'An example layout for such a Helm chart is shown in the following file structure:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的Helm chart的示例布局显示在以下文件结构中：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding example includes a template called `guestbook.yaml`. This template
    could contain the Guestbook CR originally generated by the `operator-sdk` CLI,
    with the name `charts.helm.k8s.io_v1alpha1_guestbook_cr.yaml`. Unlike CRDs, CRs
    underneath the `templates/` folder benefit from Go templating and lifecycle management,
    as do all other resources. This methodology provides the most value when the CR
    contains complex fields that may be conditionally included based on the user-provided
    values or when multiple different CRs must be included in the same release. With
    this method, you would also be able to manage the lifecycle of your CRs and maintain
    a history of revisions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例包括一个名为`guestbook.yaml`的模板。这个模板可以包含最初由`operator-sdk` CLI生成的Guestbook CR，名称为`charts.helm.k8s.io_v1alpha1_guestbook_cr.yaml`。与CRDs不同，`templates/`文件夹下的CRs受益于Go模板和生命周期管理，就像所有其他资源一样。当CR包含基于用户提供的值有条件地包含的复杂字段，或者当同一个发布中必须包含多个不同的CRs时，这种方法提供了最大的价值。通过这种方法，您还可以管理CRs的生命周期并保持修订历史。
- en: Now that you have an understanding of how a Helm operator can be created and
    how Helm can be used to help manage Operators, feel free to clean up your Kubernetes
    environment in the next section.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何创建Helm operator以及如何使用Helm来帮助管理Operators，可以在下一节中自由地清理您的Kubernetes环境。
- en: Cleaning up your Kubernetes environment
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理您的Kubernetes环境
- en: 'First, run the following command to remove your Guestbook CRD:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，运行以下命令来删除您的Guestbook CRD：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Before you proceed with the next clean-up steps, note that one of the questions
    posed later under the *Questions* section will challenge you with writing your
    own Helm charts to implement the chart designs discussed under the *Using Helm
    to manage Operators and CRs* section. You may want to postpone these steps to
    test your implementation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一个清理步骤之前，请注意，在*问题*部分后面提出的一个问题将挑战您编写自己的Helm charts来实现*使用Helm管理Operators和CRs*部分讨论的图表设计。您可能希望推迟这些步骤来测试您的实现。
- en: 'To continue the clean-up, run the following command to delete your `chapter8`
    namespace:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续清理工作，请运行以下命令来删除您的`chapter8`命名空间：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, run the `minikube stop` command to stop your Minikube VM.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行`minikube stop`命令来停止您的Minikube虚拟机。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Operators are important to help ensure that the desired state always matches
    the live state. Such a feat allows users to more easily maintain a source of truth
    for resource configuration. Users can leverage the Helm-based operator to provide
    this type of resource reconciliation, and it is easy to get started because this
    uses Helm charts as its deployment mechanism. When a CR is created, the Helm operator
    will install the associated Helm chart to create a new release. Subsequent upgrades
    will be performed when the CR is modified, and the release will be uninstalled
    when the CR is deleted.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: operator对于确保期望状态始终与实际状态匹配非常重要。这样的功能允许用户更轻松地维护资源配置的真实来源。用户可以利用基于Helm的operator来提供这种类型的资源协调，并且很容易上手，因为它使用Helm图表作为部署机制。当创建CR时，Helm
    operator将安装相关的Helm图表以创建新的发布。当修改CR时，将执行后续升级，并且在删除CR时将卸载发布。
- en: To manage the operator, cluster administrators can create a separate Helm chart
    used for creating the operator's resources and CRDs. End users can also create
    a separate Helm chart that can be used for creating the operator's CRs, along
    with any other resources that may be relevant.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理operator，集群管理员可以创建一个单独的Helm图表，用于创建operator的资源和CRDs。最终用户也可以创建一个单独的Helm图表，用于创建operator的CRs，以及其他可能相关的任何资源。
- en: In the next chapter, we will discuss best practices and topics around security
    within the Helm ecosystem.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Helm生态系统中安全性的最佳实践和主题。
- en: Further reading
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information about the Kubernetes resources, you can check the following
    links:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Kubernetes资源的更多信息，您可以查看以下链接：
- en: 'To discover more Operators that have been developed b[y the community, consult
    this repository: https://githu](https://github.com/operator-framework/awesome-operators)b.com/operator-framework/awesome-Operators.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要发现更多由社区开发的Operators，请查阅此存储库：[https://github.com/operator-framework/awesome-operators](https://github.com/operator-framework/awesome-operators)。
- en: You can learn more about Operators along with their origins from the Kubernetes
    documentation at [https://kubernetes.io/docs/concepts/extend-kubernetes/operator/.](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/.
    )
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从Kubernetes文档中了解有关Operators及其起源的更多信息：[https://kubernetes.io/docs/concepts/extend-kubernetes/operator/.](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/.
    )
- en: Questions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does a Kubernetes operator work?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes operator是如何工作的？
- en: What are the differences between using the Helm CLI and using a Helm-based operator?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Helm CLI和使用基于Helm的operator之间有什么区别？
- en: Imagine you are tasked with creating a Helm operator out of an existing Helm
    chart. What steps would you take to complete this task?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设你被要求将现有的Helm图表创建为Helm operator。你会采取哪些步骤来完成这个任务？
- en: How do the install, upgrade, rollback, and uninstall lifecycle hooks function
    in a Helm operator?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Helm operator中，安装、升级、回滚和卸载的生命周期钩子函数是如何工作的？
- en: What is the purpose of the `crds/` folder in a Helm chart?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Helm图表中，“crds/”文件夹的目的是什么？
- en: In the *Using Helm to manage Operators and CRs* section, we introduced two different
    Helm charts that can be used to help manage Operators and CRs. Implement the Helm
    charts by using the chart layouts provided within that section. The charts should
    be used to install the Guestbook operator and to install the Guestbook CR. Refer
    to [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265), *Building Your
    First Helm Chart* for assistance on creating a Helm chart.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“使用Helm管理Operators和CRs”部分中，我们介绍了两种不同的Helm图表，可以用来帮助管理Operators和CRs。使用该部分提供的图表布局来实现Helm图表。这些图表应该用于安装Guestbook
    operator和安装Guestbook CR。有关创建Helm图表的帮助，请参考“第5章”，*构建您的第一个Helm图表*。
