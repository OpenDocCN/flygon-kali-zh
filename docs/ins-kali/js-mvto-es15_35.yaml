- en: Chapter 7. Functional Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 函数式响应式编程
- en: If you are a frontend or backend JavaScript developer who works on large and
    complex JavaScript applications and deals with a lot of code that responds to
    asynchronous data updates, user activities, and system activities, then it's perhaps
    the best time to explore **functional reactive programming** (**FRP**), as it's
    a time-saving, bug-preventing, easy-to-read, and modularized style of writing
    code. You don't need to know any functional programming language or be a hardcore
    functional language programmer; rather, you just need to know the basics of functional
    programming. In this chapter, we will learn how to use FRP using `Bacon.js`, which
    is an FRP library for both frontend and backend JavaScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是一个前端或后端JavaScript开发人员，负责处理大型复杂的JavaScript应用程序，并处理大量响应异步数据更新、用户活动和系统活动的代码，那么现在或许是探索**函数式响应式编程**（**FRP**）的最佳时机，因为它是一种节省时间、预防错误、易于阅读和模块化的代码编写风格。您不需要了解任何函数式编程语言，也不需要成为专业的函数式语言程序员；相反，您只需要了解函数式编程的基础知识。在本章中，我们将学习如何使用`Bacon.js`来使用FRP，这是一个适用于前端和后端JavaScript的FRP库。
- en: 'We''ll cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下内容：
- en: Reactive programming in a nutshell
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程简介
- en: Problems with writing reactive code in JavaScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JavaScript中编写响应式代码的问题
- en: Introduction to functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程介绍
- en: What FRP is
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FRP是什么
- en: The building blocks of FRP
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FRP的构建模块
- en: The advantages of FRP
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FRP的优势
- en: All the APIs provided by Bacon.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bacon.js提供的所有API
- en: Introduction to reactive programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程介绍
- en: Before we get into FRP, we need to understand what it is. I will be explaining
    reactive programming with respect to JavaScript. The concept of reactive programming
    is the same in every programming language.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解FRP之前，我们需要了解它是什么。我将以JavaScript为例来解释响应式编程。响应式编程的概念在每种编程语言中都是相同的。
- en: '**Reactive programming** is writing code to look for asynchronous data updates,
    user activities, and system activities and propagate changes onto the dependent
    parts of the application. Reactive programming is not something new; believe it
    or not, you have already been doing reactive programming without realizing it.
    For example, the code you write to handle a button''s click event is reactive
    code. There are various approaches to reactive programming, such as event-driven,
    callback, promise patterns and FRP.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式编程**是编写代码来查找异步数据更新、用户活动和系统活动，并将更改传播到应用程序的依赖部分。响应式编程并不是什么新鲜事；信不信由你，你已经在不知不觉中进行了响应式编程。例如，你编写的处理按钮点击事件的代码就是响应式代码。响应式编程有各种不同的方法，如事件驱动、回调、promise模式和FRP。'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Problems with writing reactive code
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写响应式代码的问题
- en: 'There are basically three patterns natively supported by JavaScript for writing
    reactive code: **event-driven**, **callback**,and **promise**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript本身基本上支持三种用于编写响应式代码的模式：**事件驱动**、**回调**和**promise**。
- en: Anyone who knows a bit of JavaScript is familiar with event-driven and callback
    patterns. Although these two patterns are the most popular way of writing reactive
    code, they make it difficult to catch exceptions and result in nested function
    calls, which makes the code harder to read and debug.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 任何了解一点JavaScript的人都熟悉事件驱动和回调模式。尽管这两种模式是编写响应式代码最流行的方式，但它们使捕获异常变得困难，并导致嵌套函数调用，使代码更难阅读和调试。
- en: Due to the problems caused by event-driven and callback patterns, ES6 ([https://www.packtpub.com/web-development/learning-ecmascript-6](https://www.packtpub.com/web-development/learning-ecmascript-6))
    introduced the promise pattern. The promise pattern makes the code look more like
    synchronous code, therefore making it easy to read and debug. The pattern also
    makes exception handling easier. A promise represents an asynchronous operation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件驱动和回调模式造成的问题，ES6 ([https://www.packtpub.com/web-development/learning-ecmascript-6](https://www.packtpub.com/web-development/learning-ecmascript-6))引入了promise模式。promise模式使代码看起来更像同步代码，因此更易于阅读和调试。该模式还使异常处理变得更容易。promise代表一个异步操作。
- en: But the promise pattern has a problem, that is, a promise can be resolved only
    once. The promise pattern can only respond to a single activity or data update
    of an asynchronous operation. For example, if we make an AJAX request using a
    promise pattern, then we can handle only *request success* and *failure* activities
    and not the states of the request and response cycle, such as weather server connections
    that have been established and response headers received. Similarly, if we handle
    a user click activity using a promise pattern, then we can handle only the first
    click, not the ones occurring after it, because the promise gets resolved in the
    first click.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但是promise模式存在一个问题，即promise只能被解决一次。promise模式只能响应异步操作的单个活动或数据更新。例如，如果我们使用promise模式进行AJAX请求，那么我们只能处理*请求成功*和*失败*活动，而不能处理请求和响应周期的状态，比如服务器连接是否已建立和接收到的响应头。同样，如果我们使用promise模式处理用户点击活动，那么我们只能处理第一次点击，而不能处理之后的点击，因为promise在第一次点击时被解决。
- en: 'You may or may not be familiar with the promise pattern, so let''s look at
    some sample code of what a promise pattern looks like:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能对promise模式不熟悉，因此让我们看一些promise模式的示例代码：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the `$http()` method makes an HTTP request asynchronously and returns
    a promise. The promise is resolved if the request is successful, and the callback
    passed to the first `then()` method is invoked, that is, the promise is resolved.
    If the request fails, then the callback is passed to the `catch()` method, which
    is invoked, and the promise is rejected. The `then()` method always returns a
    promise, making it possible to run multiple asynchronous operations one after
    another. In the code, you can see how asynchronous operations are chained. What's
    important here is that the `then()` methods are invoked only once, that is, the
    promise returned by the `$http()` method can be resolved only once, and multiple
    attempts to resolve a promise will be ignored. Therefore, we cannot use promise
    patterns to write reactive code when we have to deal with multiple activities
    or data updates of an asynchronous operation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$http()`方法会异步发出HTTP请求并返回一个承诺。如果请求成功，承诺会被解决，并且传递给第一个`then()`方法的回调会被调用，即承诺被解决。如果请求失败，那么回调会传递给`catch()`方法，被调用，并且承诺被拒绝。`then()`方法总是返回一个承诺，使得可以依次运行多个异步操作。在代码中，你可以看到异步操作是如何链接在一起的。这里重要的是`then()`方法只会被调用一次，也就是说，`$http()`方法返回的承诺只能被解决一次，多次尝试解决承诺将被忽略。因此，当我们需要处理多个异步操作的活动或数据更新时，我们不能使用承诺模式来编写响应式代码。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some developers create a new promise for every activity and data update. This
    technique may seem fine since you are able to write reactive code involving multiple
    activities and data updates using promise patterns, but it's an anti-pattern.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员为每个活动和数据更新创建一个新的承诺。这种技术可能看起来不错，因为你可以使用承诺模式编写涉及多个活动和数据更新的响应式代码，但这是一种反模式。
- en: Due to the problems with the event-driven, callback, and promise patterns, there
    was a need for another pattern, and functional reactive programming came to the
    rescue.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件驱动、回调和承诺模式存在问题，需要另一种模式，函数式响应式编程应运而生。
- en: FRP is simply reactive programming using functional programming style. We will
    learn more about functional programming in the next section. Actually, the drawbacks
    of the event-driven, callback, and promise patterns weren't the real reason for
    the invention of FRP; rather, FRP was actually invented because there were demands
    for a functional pattern for reactive programming, as functional code is easy
    to write, test, debug, reuse, update, and read. But as FRP solves the problems
    caused by the event-driven, callback, and promise patterns, we can say that FRP
    is an alternative to the other patterns.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: FRP只是使用函数式编程风格的响应式编程。我们将在下一节更多地了解函数式编程。实际上，事件驱动、回调和承诺模式的缺点并不是FRP发明的真正原因；相反，FRP实际上是因为需要一种用于响应式编程的函数式模式，因为函数式代码易于编写、测试、调试、重用、更新和阅读。但是由于FRP解决了事件驱动、回调和承诺模式造成的问题，我们可以说FRP是其他模式的替代品。
- en: In this chapter, we will learn about FRP, which is considered the modern way
    of writing reactive code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习FRP，这被认为是编写响应式代码的现代方式。
- en: Functional programming in a nutshell
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之，函数式编程
- en: Before we get into FRP, it's necessary to have basic knowledge about functional
    programming.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解FRP之前，有必要对函数式编程有基本的了解。
- en: In a nutshell, functional programming is a style of writing code in which we
    use only pure function calls (including recursion) instead of loops and conditionals,
    and data is immutable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，函数式编程是一种编写代码的风格，其中我们只使用纯函数调用（包括递归），而不使用循环和条件语句，并且数据是不可变的。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Functional programming falls under the criterion of declarative programming.
    Declarative programming is a style of writing code where we write code to tell
    the system what we would like to happen instead of how to do it. Some other examples
    of declarative programming are SQL and regular expressions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程属于声明式编程的标准。声明式编程是一种编写代码的风格，我们在其中编写代码告诉系统我们希望发生什么，而不是如何做。其他一些声明式编程的例子包括SQL和正则表达式。
- en: So what is a pure function? A **pure function** is a function that depends only
    on its input arguments and that always provides the same output for a particular
    input. If it reads anything else outside of its scope, including global variables,
    then it's not a pure function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那么什么是纯函数？**纯函数**是一个仅依赖于其输入参数的函数，并且对于特定的输入始终提供相同的输出。如果它在其作用域之外读取任何其他内容，包括全局变量，那么它就不是一个纯函数。
- en: Obviously, it's not always possible to make all the functions pure. For example,
    a function that fetches a web page or reads from the filesystem cannot guarantee
    the same return value. We should try to make as many as functions as pure as possible.
    So, we can say that 100% purity is impossible to achieve, but 85% purity is still
    very productive.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，并不总是可能使所有函数都是纯的。例如，一个获取网页或从文件系统读取的函数无法保证相同的返回值。我们应该尽量使尽可能多的函数是纯的。因此，我们可以说100%的纯度是不可能实现的，但85%的纯度仍然非常高效。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Functions without side effects, stateless functions, and pure functions are
    terms used interchangeably.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无副作用的函数、无状态函数和纯函数是可以互换使用的术语。
- en: As data is immutable in functional programming, you must be wondering how it
    is possible to write code without modifying data. Well, in practice, we simply
    create new data structures instead of modifying existing ones. For example, if
    we have an array with four values and we want to remove the last one, then we
    simply create a new array, which doesn't have the last value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数式编程中数据是不可变的，你一定会想知道如何可能在不修改数据的情况下编写代码。实际上，我们只是简单地创建新的数据结构，而不是修改现有的数据。例如，如果我们有一个包含四个值的数组，我们想要移除最后一个值，那么我们只需创建一个新的数组，不包含最后一个值。
- en: The advantages of immutable data
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变数据的优点
- en: 'There are several advantages of immutable data. Here are a few of them:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变数据有几个优点。以下是其中一些：
- en: They are thread-safe, that is, multiple threads operating on them cannot modify/corrupt
    their state. Learn more about thread safety at [https://en.wikipedia.org/wiki/Thread_safety](https://en.wikipedia.org/wiki/Thread_safety).
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是线程安全的，也就是说，多个操作它们的线程不能修改/破坏它们的状态。了解更多关于线程安全的信息，请访问[https://en.wikipedia.org/wiki/Thread_safety](https://en.wikipedia.org/wiki/Thread_safety)。
- en: They object copying can be shared easily. One doesn't have to employ a strategy
    such as defensive copying, like in mutable data structures. Learn more about object
    copying at [https://en.wikipedia.org/wiki/Object_copying](https://en.wikipedia.org/wiki/Object_copying).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的对象复制可以很容易地共享。一个人不必采用防御性复制等策略，就像在可变数据结构中一样。了解更多关于对象复制的信息，请访问[https://en.wikipedia.org/wiki/Object_copying](https://en.wikipedia.org/wiki/Object_copying)。
- en: They help avoid temporal coupling. More about temporal coupling can be found
    at [https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Object-oriented_programming](https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Object-oriented_programming).
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有助于避免时间耦合。有关时间耦合的更多信息，请访问[https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Object-oriented_programming](https://en.wikipedia.org/wiki/Coupling_(computer_programming)#Object-oriented_programming)。
- en: Functional data structures
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式数据结构
- en: 'As data is immutable, there are several problems you are likely to face. Here
    are a few:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据是不可变的，你可能会面临一些问题。以下是一些：
- en: If an immutable array has millions of values, then creating a new array and
    copying all the values from the previous array is CPU and memory intensive
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个不可变数组有数百万个值，那么创建一个新数组并从先前的数组中复制所有值是CPU和内存密集型的。
- en: If two threads need to write to the same variable, coordinating the final value
    of the variable will be difficult
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个线程需要写入同一个变量，协调变量的最终值将会很困难
- en: There are many other issues. These issues led to the idea of functional data
    structures. Functional data structures are a different type of data structure
    that aim to solve these kinds of issue. But you don't need to know about functional
    data structures to follow this chapter or write functional reactive code in JavaScript.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他问题。这些问题导致了函数式数据结构的想法。函数式数据结构是一种不同类型的数据结构，旨在解决这些问题。但是，你不需要了解函数式数据结构来遵循本章或在JavaScript中编写函数式响应式代码。
- en: The advantages of pure functions
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数的优点
- en: 'Here are a few advantages of pure functions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是纯函数的一些优点：
- en: They increase reusability and maintainability, as each function is independent
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们增加了可重用性和可维护性，因为每个函数都是独立的。
- en: Easier testing and debugging is possible, as each function can be tested and
    debugged separately
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以进行更容易的测试和调试，因为每个函数都可以单独测试和调试
- en: Functional programs are easy to understand as they are written in a declarative
    manner, that is, the code says what is to be done instead of how it's done.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式程序易于理解，因为它们以声明方式编写，也就是说，代码说明了要做什么，而不是如何做。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The style of writing code using loops, conditionals, and function calls is called
    imperative programming. Imperative programming and functional programming are
    considered opposites of each other. JavaScript, C++, Java, Python, Ruby, are examples
    of imperative programming languages.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环、条件和函数调用编写代码的风格称为命令式编程。命令式编程和函数式编程被认为是彼此的对立面。JavaScript、C++、Java、Python、Ruby是命令式编程语言的例子。
- en: Functional programming with JavaScript
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JavaScript进行函数式编程
- en: You don't have to use a functional programming language such as Erlang, Haskell,
    and so on to write functional code. Most imperative programming languages allow
    us to write functional code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必使用函数式编程语言，如Erlang、Haskell等来编写函数式代码。大多数命令式编程语言都允许我们编写函数式代码。
- en: Due to the fact that functions in JavaScript are first-class (we will learn
    more about first-class functions later), it is possible to write functional code
    in JavaScript.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript中的函数是第一类的（我们将在后面学习更多关于第一类函数的知识），因此可以在JavaScript中编写函数式代码。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '"First-class" and "high-order" are terms used interchangeably.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: “第一类”和“高阶”是可以互换使用的术语。
- en: A function is said to be first-class when it can be passed as an argument to
    another function, can return another function, and be assigned to a variable.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数可以作为另一个函数的参数传递，可以返回另一个函数，并且可以分配给一个变量时，该函数被称为第一类函数。
- en: In JavaScript, functions are first-class because they are objects. Because an
    object can be passed as an argument to another function, a function can return
    an object, and an object can be assigned to a variable, functions can be first-class.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数是第一类对象，因为它们是对象。因为对象可以作为参数传递给另一个函数，函数可以返回一个对象，并且对象可以分配给一个变量，所以函数可以是第一类的。
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**What is the difference between a closure and a first-class function?**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**闭包和第一类函数之间有什么区别？**'
- en: '**Closures** are the most misunderstood topic in JavaScript. In a nutshell,
    a closure is a function returned by another function, and when the function is
    invoked, it has access to the lexical scope in which it was defined. A function
    returned by a first-class function may or may not be a closure. Here is an example
    to demonstrate closures:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**闭包**是JavaScript中最被误解的主题。简而言之，闭包是由另一个函数返回的函数，当函数被调用时，它可以访问它被定义的词法作用域。由第一类函数返回的函数可能是闭包，也可能不是。以下是一个示例来演示闭包：'
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the function named `c` is a closure as it's returned by `a`, and when
    invoked, it has access to the variables declared inside `a`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，名为`c`的函数是一个闭包，因为它是由`a`返回的，并且在调用时，它可以访问在`a`内部声明的变量。
- en: Functional programming helper functions
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程辅助函数
- en: '**Functional programming languages** provide a lot of in-built functions called
    helper functions to make it easy to write functional code. For example, as we
    cannot use loops for iteration in functional code, we need some sort of function
    to take a collection and map each value of the collection to a function. Functional
    programming languages provide the `map` helper function for this purpose. Similarly,
    there are a lot of other helper functions for different purposes.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数式编程语言**提供了许多内置函数，称为辅助函数，以便轻松编写函数式代码。例如，由于我们不能在函数式代码中使用循环进行迭代，所以我们需要某种函数来获取集合并将集合的每个值映射到一个函数。函数式编程语言为此提供了`map`辅助函数。类似地，还有许多其他用途的辅助函数。'
- en: As JavaScript is not a functional programming language, it doesn't come with
    functional helper functions. However, ES6 introduced some helper functions, such
    as `Array.from()`, `Array.prototype.from()`, and `Array.prototype.find()`. Still,
    this list is not enough to write functional code. Therefore, developers use libraries
    such as `Underscore.js` to write functional code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript不是一种函数式编程语言，它不带有函数式辅助函数。然而，ES6引入了一些辅助函数，例如`Array.from()`、`Array.prototype.from()`和`Array.prototype.find()`。但是，这个列表还不足以编写函数式代码。因此，开发人员使用诸如`Underscore.js`之类的库来编写函数式代码。
- en: Getting started with FRP
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用FRP
- en: FRP is simply reactive programming using functional programming style.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: FRP简单地使用函数式编程风格进行响应式编程。
- en: EventStreams and properties (don't get these confused with object properties)
    are the building blocks of FRP. Let's look at an overview of what both these terms
    mean.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: EventStreams和properties（不要将其与对象属性混淆）是FRP的构建模块。让我们来看看这两个术语的概述。
- en: EventStreams
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EventStreams
- en: An EventStream represents a stream of events. Events in an EventStream may happen
    at any time and need not occur synchronously.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: EventStream表示事件流。EventStream中的事件可能在任何时间发生，不一定是同步发生的。
- en: Let's understand EventStreams by comparing them to events in an event-driven
    pattern. Just like we subscribe to events in an event-driven pattern, we subscribe
    to EventStreams in FRP. Unlike events in event-driven programming, the power of
    EventStreams is that they can be merged, concatenated, combined, zipped, filtered,
    or transformed in any number of ways before you handle and act on the events.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将它们与事件驱动模式中的事件进行比较来理解EventStreams。就像我们订阅事件驱动模式中的事件一样，在FRP中我们订阅EventStreams。与事件驱动编程中的事件不同，EventStreams的强大之处在于在处理和响应事件之前，它们可以以任意方式进行合并、连接、组合、压缩、过滤或转换。
- en: In functional programming, data is immutable, so merging, concatenating, combining,
    zipping, filtering, or transforming an EventStream creates a new EventStream instead
    of modifying the existing one.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，数据是不可变的，因此合并、连接、组合、压缩、过滤或转换EventStream会创建一个新的EventStream，而不是修改现有的EventStream。
- en: 'Here is a diagram that shows how an EventStream representing the click event
    of a UI element would look:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个图表，显示了表示UI元素点击事件的EventStream的外观：
- en: '![EventStreams](img/00116.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![EventStreams](img/00116.jpeg)'
- en: 'This EventStream can be merged with any other stream. Here is a diagram that
    shows how it looks when two EventStreams are merged:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个EventStream可以与任何其他流合并。以下是显示两个EventStreams合并时的外观的图表：
- en: '![EventStreams](img/00117.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![EventStreams](img/00117.jpeg)'
- en: Merging can be useful when we want to apply the same action when an event occurs
    to two different EventStreams. Instead of subscribing and attaching a callback
    to two different EventStreams, we can now subscribe to a single EventStream, eliminating
    duplicate code and making it easy to update code. Merging can be useful in various
    other cases as well.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望在事件发生时对两个不同的EventStreams应用相同的操作时，合并是有用的。我们现在可以订阅单个EventStream，而不是订阅和附加回调到两个不同的EventStreams，从而消除重复代码并使更新代码变得容易。合并在其他各种情况下也是有用的。
- en: Properties
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: A property represents a value that changes over time. Properties can be used
    as an alternative to JavaScript variables whose values change in response to asynchronous
    activities and data updates. For example, you can use properties to represent
    the total number of times a button was clicked, the total number of logged-in
    users, and so on.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 属性表示随时间变化的值。属性可以用作JavaScript变量的替代，其值会随异步活动和数据更新而变化。例如，您可以使用属性来表示按钮被点击的总次数，已登录用户的总数等。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Properties are also called signals or behaviors.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 属性也被称为信号或行为。
- en: The advantage of using properties instead of JavaScript variables is that you
    can subscribe to properties, that is, whenever the value of a property changes,
    a callback is fired to update the parts of the system that depend on it. This
    prevents code duplication and has many other benefits.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性而不是JavaScript变量的优势在于，您可以订阅属性，也就是说，每当属性的值发生变化时，都会触发回调来更新依赖于它的系统部分。这可以防止代码重复，并具有许多其他好处。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can create a property from another property as well as merge, combine, zip,
    sample, filter, or transform properties.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从另一个属性创建属性，以及合并、组合、压缩、采样、过滤或转换属性。
- en: We've just looked at the basics of FRP. Creating EventStreams and properties,
    their methods, and other things to work with them differ depending on the library
    we use to write functional reactive code. Now, let's explore how to write functional
    reactive code using the Bacon.js library.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚了解了FRP的基础知识。创建EventStreams和properties，它们的方法以及其他与它们一起工作的事物取决于我们用来编写函数式响应式代码的库。现在，让我们探索如何使用Bacon.js库编写函数式响应式代码。
- en: FRP using Bacon.js
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Bacon.js的FRP
- en: '**Bacon.js** is a JavaScript library that helps us write functional reactive
    code in JavaScript. It can be used for both frontend and backend JavaScript. The
    official website of Bacon.js library is [https://baconjs.github.io/](https://baconjs.github.io/).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bacon.js**是一个JavaScript库，可以帮助我们在JavaScript中编写函数式响应式代码。它可以用于前端和后端JavaScript。Bacon.js库的官方网站是[https://baconjs.github.io/](https://baconjs.github.io/)。'
- en: Let's create a basic website project to demonstrate FRP with Bacon.js.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的网站项目来演示使用Bacon.js的FRP。
- en: Setting up the project
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: Let's learn how to download and install Bacon.js for use with frontend and backend
    JavaScript. On the frontend, Bacon.js depends on jQuery.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何下载和安装Bacon.js以用于前端和后端JavaScript。在前端，Bacon.js依赖于jQuery。
- en: Create a directory named `baconjs-example`. Inside it, create files called `package.json`
    and `app.js` and a directory called `public`. Inside the `public` directory, create
    directories called `html` and `js`. Inside the `html` directory, create a file
    called `index.html`. Finally, inside the `js` directory, create a file called
    `index.js`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`baconjs-example`的目录。在其中，创建名为`package.json`和`app.js`的文件，以及一个名为`public`的目录。在`public`目录中，创建名为`html`和`js`的目录。在`html`目录中，创建一个名为`index.html`的文件。最后，在`js`目录中，创建一个名为`index.js`的文件。
- en: Download the frontend Bacon.js library from [http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.73/Bacon.js](http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.73/Bacon.js)
    and jQuery from [https://code.jquery.com/jquery-2.2.0.min.js](https://code.jquery.com/jquery-2.2.0.min.js),
    and place them in the `js` directory.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从[http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.73/Bacon.js](http://cdnjs.cloudflare.com/ajax/libs/bacon.js/0.7.73/Bacon.js)下载前端Bacon.js库，从[https://code.jquery.com/jquery-2.2.0.min.js](https://code.jquery.com/jquery-2.2.0.min.js)下载jQuery，并将它们放在`js`目录中。
- en: At the time of writing, 0.7.73 was the latest version of the frontend Bacon.js
    library, and 2.2.0 was the latest version of jQuery.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，0.7.73是前端Bacon.js库的最新版本，2.2.0是jQuery的最新版本。
- en: 'In the `index.html` file, place this code to enqueue jQuery and the frontend
    Bacon.js library:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`index.html`文件中，放置以下代码来排队jQuery和前端Bacon.js库：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `package.json` file, place this code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`文件中，放置以下代码：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, run `npm install` inside the `baconjs-example` directory to download the
    npm packages.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`baconjs-example`目录中运行`npm install`来下载npm包。
- en: At the time of writing, 0.7.83 was the latest version of backend Bacon.js library.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，0.7.83是后端Bacon.js库的最新版本。
- en: 'In the `app.js` file, place the following code to import the backend Bacon.js
    and Express modules. It also starts our webserver in order to serve the web page
    and static files:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`文件中，放置以下代码来导入后端Bacon.js和Express模块。它还启动我们的web服务器以便提供网页和静态文件：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have now set up a basic Bacon.js project. Run `node app.js` to start the
    web server. Now, let's explore Bacon.js APIs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置了一个基本的Bacon.js项目。运行`node app.js`来启动web服务器。现在，让我们探索Bacon.js的API。
- en: Bacon.js APIs
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bacon.js API
- en: Bacon.js provides APIs to do almost anything that's possible using EventStreams
    and properties. The method of importing and downloading Bacon.js for the backend
    and frontend is different, but the APIs are the same for both. Let's look at the
    most important APIs provided by Bacon.js.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js提供了几乎可以使用EventStreams和属性做任何事情的API。导入和下载Bacon.js用于后端和前端的方法不同，但API对于两者都是相同的。让我们看看Bacon.js提供的最重要的API。
- en: Creating EventStreams
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建EventStreams
- en: There are various ways of creating EventStreams, depending on how an asynchronous
    API is designed, that is, which pattern an asynchronous API follows. An asynchronous
    API follows the event-driven, promise, or callback pattern. We need to wrap these
    patterns with Bacon-provided APIs to connect their data updates or activity updates
    to event streams, that is, convert them to functional reactive patterns.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 根据异步API的设计方式，有各种创建EventStreams的方法，即异步API遵循的模式。异步API遵循事件驱动、promise或回调模式。我们需要使用Bacon提供的API来包装这些模式，将它们的数据更新或活动更新连接到事件流，即将它们转换为函数式响应式模式。
- en: 'If we want to create an EventStream for a UI element on a web page, we can
    use the `$.asEventStream()` method. Let''s look at an example of how it works.
    Place the following code in the `<body>` tag of the `index.html` file to create
    a button:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想为网页上的UI元素创建一个EventStream，我们可以使用`$.asEventStream()`方法。让我们看一个它的工作示例。将以下代码放在`index.html`文件的`<body>`标签中以创建一个按钮：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In an event-driven pattern, to print something whenever a button is clicked,
    we would write something like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件驱动模式中，每当按钮被点击时打印一些东西，我们会写成这样：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But in Bacon.js, we will write it this way. Place this code in the `index.js`
    file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但在Bacon.js中，我们会这样写。将这段代码放在`index.js`文件中：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we use a jQuery selector to point to the button, and we then use the `$.asEventStream`
    method to connect its click events to an EventStream. The `$.asEventStream` method
    takes the name of the event as its first parameter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用jQuery选择器指向按钮，然后使用`$.asEventStream`方法将其点击事件连接到一个EventStream。`$.asEventStream`方法将事件的名称作为其第一个参数。
- en: The `onValue` method is used to add subscribers to an EventStream. The `onValue`
    method of an EventStream takes a callback, which is executed every time a new
    event is added to the EventStream. The callback has a single parameter, which
    represents the current event that has been added to the EventStream. In this case,
    it's of the event interface. We can call the `onValue` method multiple times to
    add multiple callbacks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`onValue`方法用于向EventStream添加订阅者。EventStream的`onValue`方法接受一个回调，每当新事件被添加到EventStream时就会执行。回调有一个参数，表示已添加到EventStream的当前事件。在这种情况下，它是事件接口的一部分。我们可以多次调用`onValue`方法来添加多个回调。'
- en: A subscriber can be used to update the UI, perform logging, and so on. But the
    logic code for handling the event should be written using the helper functions
    and not be inside the subscriber. This is how functional reactive code is supposed
    to be written.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者可以用于更新UI、执行日志记录等。但是处理事件的逻辑代码应该使用辅助函数编写，而不应该在订阅者内部。这就是函数式响应式代码应该被编写的方式。
- en: The subscriber callback will not be invoked for events that occurred before
    the subscriber was registered.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅者回调不会对订阅之前发生的事件进行调用。
- en: 'Similarly, there are lots of other APIs provided by Bacon.js to create EventStreams.
    Here are a few of them:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，Bacon.js提供了许多其他API来创建EventStreams。以下是其中一些：
- en: '`Bacon.fromPromise`: This is used to create an EventStream from a promise object.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bacon.fromPromise`：这用于从一个promise对象创建一个EventStream。'
- en: '`Bacon.fromEvent`: This is used to create an EventStream from events of an
    EventTarget or Node.js EventEmitter object.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bacon.fromEvent`：用于从EventTarget或Node.js EventEmitter对象的事件创建EventStream。'
- en: '`Bacon.fromCallback`: This is used to create an EventStream from a function
    that accepts a callback.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bacon.fromCallback`：用于从接受回调的函数创建EventStream。'
- en: '`Bacon.fromNodeCallback`: This is the same as `Bacon.fromCallback`, but it
    requires the callback to be called in Node.js convention.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bacon.fromNodeCallback`：与`Bacon.fromCallback`相同，但它要求在Node.js约定中调用回调。'
- en: '`Bacon.fromBinder`: If none of the previous APIs are fitting well, then you
    can use this one.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bacon.fromBinder`：如果之前的API都不合适，那么可以使用这个。'
- en: Creating properties
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建属性
- en: A property is created from an EventStream, that is, a stream whose events the
    value of the property depends on. Whenever an event occurs in the EventStream,
    a callback is executed to update the property value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从EventStream创建属性，即属性的值取决于流的事件。每当EventStream中发生事件时，都会执行回调以更新属性值。
- en: You can create a property for an EventStream using either the `toProperty` or
    `scan` methods. The `scan` method is used instead of `toProperty` when we want
    to give an initial value as well as an accumulator function to the property. You
    may or may not provide an initial value when creating a property using `toProperty`().
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`toProperty`或`scan`方法为EventStream创建属性。当我们想要为属性提供初始值以及累加器函数时，使用`scan`方法而不是`toProperty`。在使用`toProperty`创建属性时，可以选择是否提供初始值。
- en: Calling `scan` or `toProperty` multiple times create multiple properties.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 多次调用`scan`或`toProperty`会创建多个属性。
- en: 'Let''s create a property to hold the total number of times a button is clicked.
    Here is the code to do this; place it in the `index.js` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个属性来保存按钮被点击的总次数。以下是完成此操作的代码；将其放在`index.js`文件中：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we created a property using the `scan` method and initialized it to `0`.
    The second argument is a callback, which is invoked to update the property value
    whenever an event happens in the EventStream to which the property is attached.
    This callback should return the new property value. The callback has two parameters,
    that is, the current value of the property and the event.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`scan`方法创建了一个属性，并将其初始化为`0`。第二个参数是一个回调函数，当事件发生在属性所附加的EventStream中时，会调用该回调来更新属性值。这个回调应该返回新的属性值。回调有两个参数，即属性的当前值和事件。
- en: The `onValue` method of a property takes a callback that is executed every time
    the property value changes. We can call the `onValue` method multiple times to
    register multiple callbacks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的`onValue`方法接受一个回调，每当属性值发生变化时都会执行。我们可以多次调用`onValue`方法来注册多个回调。
- en: When we register a subscriber for a property, the subscriber is executed with
    the current value as soon as it's registered, but not for the values that occurred
    before it had been registered. If the property has not yet been assigned to anything,
    then the callback is not executed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为属性注册订阅者时，订阅者会立即执行当前值，但不会执行之前发生的值。如果属性尚未分配给任何内容，则不会执行回调。
- en: Here, whenever the property value changes, we log a statement informing us about
    the total number of times the button was clicked.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每当属性值发生变化时，我们记录一条声明，告诉我们按钮被点击的总次数。
- en: 'A property can also be created from another property. This is useful when a
    property''s value depends on another property. Let''s create a property from the
    previous property, which holds the time at which the property was last clicked
    and the button click count at that time. Here is the code to do this; place it
    in the `index.js` file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 属性也可以从另一个属性创建。当属性的值取决于另一个属性时，这是有用的。让我们从先前的属性创建一个属性，该属性保存了属性上次被点击的时间和该时间的按钮点击计数。以下是完成此操作的代码；将其放在`index.js`文件中：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Everything here is self-explanatory. The only thing you need to know is that
    the second parameter of the second argument passed to the `scan` method represents
    the value of the property we used to create this property.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一切都是不言自明的。您唯一需要知道的是，传递给`scan`方法的第二个参数的第二个参数代表我们用来创建此属性的属性的值。
- en: A property holds a stream that has all of its previous and current values internally;
    therefore, we can also merge, combine, zip, sample, filter, and transform properties.
    Merging, combining, zipping, sampling, filtering, or transforming properties gives
    us new properties. This feature is useful for writing code for the more complex
    situation of a property's value depending on another property. For example, if
    we want to ignore some values of a property while calculating the value of another
    property based on it, then we can use filter feature.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 属性保存了其内部所有先前和当前值的流；因此，我们还可以合并、组合、压缩、采样、过滤和转换属性。合并、组合、压缩、采样、过滤或转换属性会给我们新的属性。这个特性对于编写代码来处理属性值取决于另一个属性的更复杂情况非常有用。例如，如果我们想要在计算基于另一个属性的值时忽略某些属性的值，那么我们可以使用过滤功能。
- en: Bacon.js also allows us to create EventStreams based on properties, that is,
    the events of an EventStream represent the values of a property. Events in these
    EventStreams occur when their respective property value is changed. This feature
    has many benefits, one of which is that it can prevent code duplication when we
    have to trigger the same action in response to several properties changing their
    values.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js还允许我们基于属性创建EventStreams，即EventStream的事件代表属性的值。这些EventStreams中的事件发生在它们各自的属性值发生变化时。这个特性有很多好处，其中之一是在多个属性改变值时，可以防止代码重复。
- en: To create EventStreams based on properties, we can use the `toEventStream` method
    of a property.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性创建EventStreams，我们可以使用属性的`toEventStream`方法。
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Retrieving the latest value of a property**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**检索属性的最新值**'
- en: There is no method to obtain the latest value of a property, and there will
    be. You obtain the value by subscribing to the property and handling the values
    in your callback. If you need the value of more than one source, use one of the
    `combine` methods. This is how functional reactive code using Bacon.js is supposed
    to be written.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 目前没有方法可以获取属性的最新值，但将会有。您可以通过订阅属性并在回调中处理值来获取值。如果需要多个来源的值，请使用`combine`方法之一。这就是使用Bacon.js编写函数响应式代码的方式。
- en: Merging, filtering, and transforming EventStreams and properties
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并、过滤和转换EventStreams和properties
- en: Bacon.js provides various helper functions to work with EventStreams and properties.
    Let's look at some of the most useful helper functions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js提供了各种辅助函数来处理EventStreams和properties。让我们看看一些最有用的辅助函数。
- en: Merging
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 合并
- en: '**Merging** streams or properties gives us a new stream or property that delivers
    all the events or values of all the streams or properties. To merge EventStreams
    or properties, we can use their `Bacon.mergeAll` method instances. Here is some
    example code to demonstrate this. Place it in the `index.js` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**合并**流或属性会给我们提供一个新的流或属性，其中包含所有流或属性的事件或值。要合并EventStreams或properties，我们可以使用它们的`Bacon.mergeAll`方法实例。以下是一些示例代码以演示这一点。将其放在`index.js`文件中：'
- en: '[PRE11]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we merge two properties. `Bacon.mergeAll` takes an array of either EventStreams
    or properties. Whenever the value of either of the two properties changes, the
    value is made the current value of the resultant property.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们合并了两个属性。`Bacon.mergeAll`接受一个EventStreams或properties的数组。每当两个属性中的任何一个值发生变化时，该值就成为结果属性的当前值。
- en: There are various other helper functions available for merging properties and
    EventStreams.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些可用于合并属性和EventStreams的辅助函数。
- en: Filtering
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过滤
- en: '**Filtering** is removing specific events or values from EventStreams or properties,
    respectively, that we don''t need.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**过滤**是从EventStreams或properties中删除我们不需要的特定事件或值。'
- en: Bacon.js provides a lot of helper functions to filter EventStreams and properties,
    depending on what you want to filter. Let's look at the `filter` method for EventStreams
    and properties that lets us filter based on a predicate function; that is, if
    the function returns `true`, then the value is accepted; otherwise, it is rejected.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js提供了许多辅助函数，用于根据您想要过滤的内容来过滤EventStreams和properties。让我们看看`filter`方法，它允许我们基于谓词函数进行过滤；也就是说，如果函数返回`true`，则接受该值；否则，将被拒绝。
- en: 'Let''s look at example code to demonstrate this. In the `index.js` file, find
    this code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例代码以演示这一点。在`index.js`文件中，找到这段代码：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Replace that with this code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 用这段代码替换它：
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we are filtering all those click events in which we didn't press the *Shift*
    key. So, for the click event to be accepted, we need to press the *Shift* key
    while clicking on the button.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在过滤所有那些在点击时没有按下*Shift*键的点击事件。因此，要接受点击事件，我们需要在点击按钮时按下*Shift*键。
- en: You can think of filtering as an alternative to using the `if…else` conditional.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将过滤视为使用`if…else`条件的替代方法。
- en: Transforming
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 转换
- en: '**Transforming** is creating an EventStream or property from another EventStream
    or property, respectively, whose events are transformed to something else. For
    example, a property whose value represents a URL can be transformed to another
    property, whose value represents the response of the URL. Transforming EventStreams
    and properties actually creates new EventStreams and properties, respectively.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**转换**是从另一个EventStream或property创建一个EventStream或property，其事件分别转换为其他内容。例如，表示URL的值的属性可以转换为另一个属性，其值表示URL的响应。实际上，转换EventStreams和properties会创建新的EventStreams和properties。'
- en: You can think of transforming as an alternative to loops, that is, to using
    `for` loops.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将转换视为循环的替代方法，即使用`for`循环。
- en: There are several helper functions provided by Bacon.js for transformation depending
    on how and what you want to transform.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js提供了几个辅助函数，用于根据您想要进行的转换方式和内容进行转换。
- en: 'One popular transformation function is `map()`, which maps events or values
    of EventStreams or properties to a function. Let''s look at a code sample to demonstrate
    this. Find this code in the `index.js` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常用的转换函数是`map()`，它将EventStreams或properties的事件或值映射到一个函数。让我们看一个代码示例以演示这一点。在`index.js`文件中找到这段代码：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Replace it with this code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 用这段代码替换它：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we are using `map()` to transform the Unix timestamp to the HH:MM format,
    which is easy to understand.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`map()`将Unix时间戳转换为易于理解的HH:MM格式。
- en: 'There is another, vital transformation helper function provided by Bacon.js
    called `flatMap`. There are basically two differences between `flatMap` and `map`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Bacon.js提供了另一个重要的转换辅助函数，称为`flatMap`。`flatMap`和`map`之间基本上有两个区别：
- en: The `flatMap` function always returns an EventStream regardless of whether it
    was called on a EventStream or property.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap`函数始终返回一个EventStream，无论它是在EventStream还是property上调用的。'
- en: If the callback passed to `flatMap` returns an EventStream or property, then
    the events of the EventStream returned by the `flatMap` function are events and
    values of the streams and properties returned by the callback passed to `flatMap`.
    Whenever an event or value is added to the streams and properties returned by
    the callback passed to `flatMap`, the event and value will automatically be added
    to the EventStream returned by the `flatMap` function.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传递给`flatMap`的回调返回一个EventStream或property，则`flatMap`函数返回的EventStream的事件和流和属性的值将是传递给`flatMap`的回调返回的流和属性的事件和值。每当传递给`flatMap`的回调返回的流和属性中添加事件或值时，该事件和值将自动添加到`flatMap`函数返回的EventStream中。
- en: You need to use `flatMap` instead of `map` when retrieving the return value
    of a callback passed to a network, disk drive, or somewhere else asynchronous.
    For example, in the previous example, where I talked about transforming a URL
    to a URL response, we need to use `flatMap` instead of `map` as instead of a callback,
    we need to make an AJAX request, and its response will be captured as a stream,
    and the stream will be returned. When the AJAX request completes, the event will
    be put inside the stream returned by the `flatMap` function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当检索传递给网络、磁盘驱动器或其他地方异步的回调的返回值时，您需要使用`flatMap`而不是`map`。例如，在前面的例子中，我谈到了将URL转换为URL响应，我们需要使用`flatMap`而不是`map`，因为我们需要进行AJAX请求，其响应将被捕获为流，并返回该流。当AJAX请求完成时，事件将被放入`flatMap`函数返回的流中。
- en: 'Let''s look at an implementation of this example. First, create an input text
    field and place it in the `index.html` file, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个例子的实现。首先，在`index.html`文件中创建一个输入文本字段并放置如下：
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s write code using Bacon.js to log the output of the URL entered
    in the field when a user hits the *Enter* key. Here is the code to do this. Place
    it in the `index.js` file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Bacon.js编写代码，以便在用户按下*Enter*键时记录输入字段中输入的URL的输出。以下是执行此操作的代码。将其放在`index.js`文件中：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is how the code works:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的工作原理如下：
- en: First, we create an EventStream for the `keyup` event.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们为`keyup`事件创建了一个EventStream。
- en: Then, we filter only *Enter*-key events because we will take action only if
    the *Enter* key is pressed.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们仅过滤*Enter*键事件，因为我们只会在按下*Enter*键时采取行动。
- en: Then, we create a variable to hold the value of the text field.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个变量来保存文本字段的值。
- en: Then, we use `flatMap` to fetch the response of the URL using jQuery AJAX. We
    are using `Bacon.fromPromise` to create an EventStream from a promise.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用`flatMap`使用jQuery AJAX获取URL的响应。我们使用`Bacon.fromPromise`从一个promise创建一个EventStream。
- en: When the AJAX request finishes, it adds the response to the EventStream returned
    by the callback passed to `flatMap`. Then, `flatMap` adds the same response to
    the EventStream returned by the `flatMap` function itself. As soon as it's added,
    we log the response using `onValue`.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当AJAX请求完成时，它将响应添加到传递给`flatMap`的回调返回的EventStream中。然后，`flatMap`将相同的响应添加到`flatMap`函数本身返回的EventStream中。一旦添加，我们就使用`onValue`记录响应。
- en: Here, if we had used `map` instead of `flatMap`, then we would have ended up
    logging EventStream objects instead of the events of the EventStream returned
    by the `map` function.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们使用`map`而不是`flatMap`，那么我们最终会记录EventStream对象，而不是`map`函数返回的EventStream的事件。
- en: Although we can have both `url` and `response` properties directly created from
    the `enter_key_click_stream`, it is likely to cause code repetition and make the
    code difficult to understand.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以直接从`enter_key_click_stream`创建`url`和`response`属性，但这可能会导致代码重复，并使代码难以理解。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you call a method to transform, filter, or do something else with EventStreams,
    then the events that occurred before the method call are not taken into account.
    However, in the case of a property, the current value is taken into account, but
    not the values that occurred before the method call. If the property has not yet
    been assigned to anything, nothing is taken into account.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用方法来转换、过滤或对EventStreams进行其他操作时，方法调用之前发生的事件不会被考虑在内。但是，在属性的情况下，当前值会被考虑在内，但不会考虑方法调用之前发生的值。如果属性尚未分配任何内容，则不会考虑任何内容。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We looked at reactive programming, functional programming, FRP, and finally
    an overview of Bacon.js. You should now be comfortable with writing basic functional
    reactive code and have a clear idea of its benefits.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了响应式编程、函数式编程、FRP，最后是Bacon.js的概述。现在，您应该可以轻松编写基本的函数式响应式代码，并清楚地了解其好处。
- en: We will learn about more of the APIs provided by Bacon.js and build a real-world
    project using Bacon.js in the next chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解Bacon.js提供的更多API，并使用Bacon.js构建一个真实的项目。
