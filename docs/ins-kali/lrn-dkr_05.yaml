- en: Mastering Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握容器
- en: 'In the previous chapter, you learned how to optimally prepare your working
    environment for the productive and frictionless use of Docker. In this chapter,
    we are going to get our hands dirty and learn everything that is important to
    know when working with containers. Here are the topics we''re going to cover in
    this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学会了如何为高效和无摩擦地使用Docker准备您的工作环境。在本章中，我们将亲自动手，学习在使用容器时需要了解的一切重要内容。以下是本章我们将要涵盖的主题：
- en: Running the first container
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行第一个容器
- en: Starting, stopping, and removing containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动、停止和删除容器
- en: Inspecting containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查容器
- en: Exec into a running container
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行的容器中执行
- en: Attaching to a running container
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加到运行的容器
- en: Retrieving container logs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索容器日志
- en: Anatomy of containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的结构
- en: 'After finishing this chapter, you will be able to do the following things:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够做到以下几点：
- en: Run, stop, and delete a container based on an existing image, such as Nginx,
    BusyBox, or Alpine.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于现有镜像（如Nginx、BusyBox或Alpine）运行、停止和删除容器。
- en: List all containers on the system.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出系统上的所有容器。
- en: Inspect the metadata of a running or stopped container.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查正在运行或已停止容器的元数据。
- en: Retrieve the logs produced by an application running inside a container.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索在容器内运行的应用程序产生的日志。
- en: Run a process such as `/bin/sh` in an already-running container.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在已运行的容器中运行`/bin/sh`等进程。
- en: Attach a Terminal to an already-running container.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将终端连接到已运行的容器。
- en: Explain in your own words to an interested lay person the underpinnings of a
    container.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用您自己的话向一个感兴趣的外行人解释容器的基础知识。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you should have installed Docker for Desktop on your macOS
    or Windows PC. If you are on an older version of Windows or are using Windows
    10 Home Edition, then you should have Docker Toolbox installed and ready to use.
    On macOS, use the Terminal application, and on Windows, a PowerShell or Bash console,
    to try out the commands you will be learning.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，您应该已经在您的macOS或Windows PC上安装了Docker for Desktop。如果您使用的是较旧版本的Windows或者使用的是Windows
    10家庭版，那么您应该已经安装并准备好使用Docker Toolbox。在macOS上，请使用终端应用程序，在Windows上，请使用PowerShell或Bash控制台来尝试您将要学习的命令。
- en: Running the first container
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行第一个容器
- en: 'Before we start, we want to make sure that Docker is installed correctly on
    your system and ready to accept your commands. Open a new Terminal window and
    type in the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们希望确保Docker已正确安装在您的系统上，并准备好接受您的命令。打开一个新的终端窗口，并输入以下命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you are using Docker Toolbox then use the Docker Quickstart Terminal that
    has been installed with the Toolbox, instead of the Terminal on macOS or Powershell
    on Windows.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Docker Toolbox，则请使用已与Toolbox一起安装的Docker Quickstart终端，而不是macOS上的终端或Windows上的PowerShell。
- en: 'If everything works correctly, you should see the version of Docker client
    and server installed on your laptop output in the Terminal. At the time of writing,
    it looks like this (shortened for readability):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，您应该在终端中看到安装在您的笔记本电脑上的Docker客户端和服务器的版本。在撰写本文时，它看起来是这样的（为了可读性而缩短）：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see that I have `beta3` of version `19.03.0` installed on my macOS.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我在我的macOS上安装了`19.03.0`版本的`beta3`。
- en: If this doesn't work for you, then something with your installation is not right.
    Please make sure that you have followed the instructions in the previous chapter
    on how to install Docker for Desktop or Docker Toolbox on your system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对您不起作用，那么您的安装可能有问题。请确保您已按照上一章中关于如何在您的系统上安装Docker for Desktop或Docker Toolbox的说明进行操作。
- en: 'So, you''re ready to see some action. Please type the following command into
    your Terminal window and hit *Return*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，您已经准备好看到一些操作了。请在您的终端窗口中输入以下命令并按*Return*键：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you run the preceding command the first time, you should see an output
    in your Terminal window similar to this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次运行上述命令时，您应该在终端窗口中看到类似于这样的输出：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that was easy! Let''s try to run the very same command again:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这很容易！让我们再次尝试运行完全相同的命令：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second, third, or *n*^(th) time you run the preceding command, you should
    see only this output in your Terminal:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次、第三次或第n次运行上述命令时，您应该在终端中只看到以下输出：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Try to reason about why the first time you run a command you see a different
    output than all of the subsequent times. But don't worry if you can't figure it
    out; we will explain the reasons in detail in the following sections of this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试推理第一次运行命令时为什么会看到不同的输出，而所有后续次数都不同。但是如果您无法弄清楚，不要担心；我们将在本章的后续部分详细解释原因。
- en: Starting, stopping, and removing containers
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动、停止和删除容器
- en: 'You have successfully run a container in the previous section. Now, we want
    to investigate in detail what exactly happened and why. Let''s look again at the
    command we used:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您已成功运行了一个容器。现在，我们想详细调查到底发生了什么以及为什么。让我们再次看看我们使用的命令：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command contains multiple parts. First and foremost, we have the word `docker`.
    This is the name of the Docker **Command-Line Interface** (**CLI**) tool, which
    we are using to interact with the Docker engine that is responsible to run containers.
    Next, we have the word `container`, which indicates the context we are working
    with. As we want to run a container, our context is the word `container`. Next
    is the actual command we want to execute in the given context, which is `run`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令包含多个部分。首先，我们有单词`docker`。这是Docker**命令行界面**（**CLI**）工具的名称，我们使用它与负责运行容器的Docker引擎进行交互。接下来是单词`container`，它表示我们正在处理的上下文。因为我们要运行一个容器，所以我们的上下文是`container`。接下来是我们要在给定上下文中执行的实际命令，即`run`。
- en: Let me recap—so far, we have `docker container run`, which means, *Hey Docker,
    we want to run a container.*
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我回顾一下——到目前为止，我们有`docker container run`，这意味着，“嘿，Docker，我们想要运行一个容器。”
- en: Now we also need to tell Docker which container to run. In this case, this is
    the so-called `alpine` container.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还需要告诉Docker要运行哪个容器。在这种情况下，这就是所谓的`alpine`容器。
- en: '`alpine` is a minimal Docker image based on Alpine Linux with a complete package
    index and is only 5 MB in size.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`alpine` 是一个基于Alpine Linux的最小Docker镜像，具有完整的软件包索引，大小仅为5MB。'
- en: Finally, we need to define what kind of process or task shall be executed inside
    the container when it is running. In our case, this is the last part of the command, `echo
    "Hello World"`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义在容器运行时应执行什么类型的进程或任务。在我们的情况下，这是命令的最后一部分，`echo "Hello World"`。
- en: 'Maybe the following screenshot can help you to get a better idea of the whole
    thing:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 也许以下截图可以帮助您更好地了解整个过程：
- en: '![](assets/aa2c9ba0-11fb-4b2a-ae10-2c3419981032.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aa2c9ba0-11fb-4b2a-ae10-2c3419981032.png)'
- en: Anatomy of the docker container run expression
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: docker container run表达式的解剖
- en: 'Now that we have understood the various parts of a command to run a container,
    let''s try to run another container with a different process running inside it.
    Type the following command into your Terminal:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了运行容器命令的各个部分，让我们尝试在容器中运行另一个不同的进程。在终端中键入以下命令：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see output in your Terminal window similar to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端窗口中看到类似以下的输出：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What changed is that this time, the container image we're using is `centos` and
    the process we're executing inside the `centos` container is `ping -c 5 127.0.0.1`,
    which pings the loopback address five times until it stops.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 改变的是，这次我们使用的容器镜像是`centos`，我们在`centos`容器内执行的进程是`ping -c 5 127.0.0.1`，它会对回环地址进行五次ping直到停止。
- en: '`centos` is the official Docker image for CentOS Linux, which is a community-supported
    distribution derived from sources freely provided to the public by **Red Hat**for
    **Red Hat Enterprise Linux** (**RHEL**).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`centos`是CentOS Linux的官方Docker镜像，这是一个社区支持的发行版，源自**Red Hat**为**Red Hat Enterprise
    Linux**（**RHEL**）免费提供给公众的源代码。'
- en: Let's analyze the output in detail.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析输出。
- en: 'The first line is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行如下：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This tells us that Docker didn''t find an image named `centos:latest` in the
    local cache of the system. So, Docker knows that it has to pull the image from
    some registry where container images are stored. By default, your Docker environment
    is configured so that images are pulled from Docker Hub at `docker.io`. This is
    expressed by the second line, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们Docker在系统的本地缓存中没有找到名为`centos:latest`的镜像。因此，Docker知道它必须从存储容器镜像的某个注册表中拉取镜像。默认情况下，您的Docker环境配置为从`docker.io`的Docker
    Hub拉取镜像。这由第二行表示，如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next three lines of output are as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三行输出如下：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This tells us that Docker has successfully pulled the `centos:latest` image from
    Docker Hub.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们Docker已成功从Docker Hub拉取了`centos:latest`镜像。
- en: All of the subsequent lines of the output are generated by the process we ran
    inside the container, which is the Ping tool in this case. If you have been attentive
    so far, then you might have noticed the `latest` keyword occurring a few times.
    Each image has a version (also called `tag`), and if we don't specify a version
    explicitly, then Docker automatically assumes it is `latest`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的所有后续行都是由我们在容器内运行的进程生成的，这种情况下是Ping工具。如果你到目前为止一直很注意，那么你可能已经注意到`latest`关键字出现了几次。每个镜像都有一个版本（也称为`tag`），如果我们不明确指定版本，那么Docker会自动假定它是`latest`。
- en: If we run the preceding container again on our system, the first five lines
    of the output will be missing since, this time, Docker will find the container
    image cached locally and hence won't have to download it first. Try it out and
    verify what I just told you.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在我们的系统上再次运行前面的容器，输出的前五行将会丢失，因为这一次Docker会在本地找到容器镜像的缓存，因此不需要先下载它。试一试，验证我刚才告诉你的。
- en: Running a random trivia question container
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行一个随机琐事问题容器
- en: For the subsequent sections of this chapter, we need a container that runs continuously
    in the background and produces some interesting output. That's why we have chosen
    an algorithm that produces random trivia questions. The API that produces that
    free random trivia can be found at [http://jservice.io/](http://jservice.io/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，我们需要一个在后台持续运行并产生一些有趣输出的容器。这就是为什么我们选择了一个产生随机琐事问题的算法。产生免费随机琐事的API可以在[http://jservice.io/](http://jservice.io/)找到。
- en: 'Now the goal is to have a process running inside a container that produces
    a new random trivia question every five seconds and outputs the question to `STDOUT`.
    The following script will do exactly that:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的目标是在容器内运行一个进程，每五秒产生一个新的随机琐事问题，并将问题输出到`STDOUT`。以下脚本将完全做到这一点：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Try it in a Terminal window. Stop the script by pressing *Ctrl *+ *C*. The
    output should look similar to this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中尝试一下。通过按*Ctrl*+*C*来停止脚本。输出应该类似于这样：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each response is a different trivia question.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个响应都是一个不同的琐事问题。
- en: You may need to install `jq` first on your macOS or Windows computer. `jq` is
    a handy tool often used to nicely filter and format JSON output, which increases
    the readability of it on the screen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要先在您的macOS或Windows计算机上安装`jq`。`jq`是一个方便的工具，通常用于过滤和格式化JSON输出，这样可以增加屏幕上的可读性。
- en: 'Now, let''s run this logic in an `alpine` container. Since this is not just
    a simple command, we want to wrap the preceding script in a script file and execute
    that one. To make things simpler, I have created a Docker image called `fundamentalsofdocker/trivia`
    that contains all of the necessary logic, so that we can just use it here. Later
    on, once we have introduced Docker images, we will analyze this container image
    further. For the moment, let''s just use it as is. Execute the following command
    to run the container as a background service. In Linux, a background service is
    also called a daemon:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在一个`alpine`容器中运行这个逻辑。由于这不仅仅是一个简单的命令，我们想把前面的脚本包装在一个脚本文件中并执行它。为了简化事情，我创建了一个名为`fundamentalsofdocker/trivia`的Docker镜像，其中包含了所有必要的逻辑，这样我们就可以直接在这里使用它。稍后，一旦我们介绍了Docker镜像，我们将进一步分析这个容器镜像。暂时，让我们就这样使用它。执行以下命令将容器作为后台服务运行。在Linux中，后台服务也被称为守护进程：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding expression, we have used two new command-line parameters, `-d` and `--name`.
    Now, `-d` tells Docker to run the process running in the container as a Linux
    daemon. The `--name` parameter, in turn, can be used to give the container an
    explicit name. In the preceding sample, the name we chose is `trivia`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表达式中，我们使用了两个新的命令行参数`-d`和`--name`。现在，`-d`告诉Docker将在容器中运行的进程作为Linux守护进程运行。而`--name`参数则可以用来给容器指定一个显式的名称。在前面的示例中，我们选择的名称是`trivia`。
- en: If we don't specify an explicit container name when we run a container, then
    Docker will automatically assign the container a random but unique name. This
    name will be composed of the name of a famous scientist and an adjective. Such
    names could be `boring_borg` or `angry_goldberg`. They're quite humorous, our
    Docker engineers, *aren't they?*
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在运行容器时没有指定显式的容器名称，那么Docker将自动为容器分配一个随机但唯一的名称。这个名称将由一个著名科学家的名字和一个形容词组成。这样的名称可能是`boring_borg`或`angry_goldberg`。我们的Docker工程师们相当幽默，*不是吗？*
- en: We are also using the tag `ed2` for the container. This tag just tells us that
    this image has been created for the second edition of this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在容器中使用标签`ed2`。这个标签只是告诉我们这个镜像是为本书的第二版创建的。
- en: 'One important takeaway is that the container name has to be unique on the system.
    Let''s make sure that the trivia container is up and running:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要点是，容器名称在系统上必须是唯一的。让我们确保`trivia`容器正在运行：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should give us something like this (shortened for readability):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们类似于这样的东西（为了可读性而缩短）：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The important part of the preceding output is the `STATUS` column, which in
    this case is `Up 9 seconds`. That is, the container has been up and running for
    9 seconds now.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面输出的重要部分是`STATUS`列，本例中是`Up 9 seconds`。也就是说，容器已经运行了9秒钟。
- en: Don't worry if the last Docker command is not yet familiar to you, we will come
    back to it in the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果最后一个Docker命令对您来说还不太熟悉，不要担心，我们将在下一节回到它。
- en: 'To complete this section, let''s stop and remove the `trivia` container with
    the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本节，让我们停下来，使用以下命令停止并移除`trivia`容器：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now it is time to learn how to list containers running or dangling on our system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习如何列出在我们的系统上运行或悬空的容器了。
- en: Listing containers
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出容器
- en: 'As we continue to run containers over time, we get a lot of them in our system.
    To find out what is currently running on our host, we can use the `container ls` command,
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们继续运行容器，我们的系统中会有很多容器。要找出当前在我们的主机上运行的是什么，我们可以使用`container ls`命令，如下所示：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will list all currently running containers. Such a list might look similar
    to this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出所有当前正在运行的容器。这样的列表可能看起来类似于这样：
- en: '![](assets/068c2859-04d5-43a4-9e16-e1326761f468.png)List of all containers
    running on the system'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/068c2859-04d5-43a4-9e16-e1326761f468.png)列出系统上所有正在运行的容器'
- en: 'By default, Docker outputs seven columns with the following meanings:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker输出七列，含义如下：
- en: '|  **Column**  |  **Description**  |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **列** | **描述** |'
- en: '| `Container ID` | This is the unique ID of the container. It is an SHA-256.
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `容器ID` | 这是容器的唯一ID。它是一个SHA-256。 |'
- en: '| `Image` | This is the name of the container image from which this container
    is instantiated. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `镜像` | 这是实例化该容器的容器镜像的名称。 |'
- en: '| `Command` | This is the command that is used to run the main process in the
    container. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `命令` | 这是用于在容器中运行主进程的命令。 |'
- en: '| `Created` | This is the date and time when the container was created. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `创建时间` | 这是容器创建的日期和时间。 |'
- en: '| `Status` | This is the status of the container (created, restarting, running,
    removing, paused, exited, or dead). |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `状态` | 这是容器的状态（已创建、重新启动、运行中、正在移除、暂停、已退出或已停止）。 |'
- en: '| `Ports` | This is the list of container ports that have been mapped to the
    host. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `端口` | 这是已映射到主机的容器端口列表。 |'
- en: '| `Names` | This is the name assigned to this container (multiple names are
    possible). |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `名称` | 这是分配给该容器的名称（可以有多个名称）。 |'
- en: 'If we want to list not only the currently running containers but all containers
    that are defined on our system, then we can use the command-line parameter `-a` or `--all`, as
    follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不仅想列出当前正在运行的容器，而是所有在系统上定义的容器，那么我们可以使用命令行参数`-a`或`--all`，如下所示：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will list containers in any state, such as `created`, `running`, or `exited`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出任何状态的容器，例如`已创建`、`运行中`或`已退出`。
- en: 'Sometimes, we want to just list the IDs of all containers. For this, we have
    the `-q` parameter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们只想列出所有容器的ID。为此，我们有`-q`参数：
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You might wonder where this is useful. I will show you a command where it is
    very helpful right here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道这有什么用。我将在这里向您展示一个非常有用的命令：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Lean back and take a deep breath. Then, try to find out what the preceding command
    does. Don't read any further until you find the answer or give up.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 往后倾斜，深呼吸。然后，尝试找出前面的命令是做什么的。在找到答案或放弃之前，请不要再往下读。
- en: The preceding command deletes all containers that are currently defined on the
    system, including the stopped ones. The `rm` command stands for remove, and it
    will be explained soon.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令会删除系统上当前定义的所有容器，包括已停止的容器。`rm`命令代表删除，很快就会解释。
- en: 'In the previous section, we used the `-l` parameter in the list command. Try
    to use Docker help to find out what the `-l` parameter stands for. You can invoke
    help for the list command as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，我们在列表命令中使用了`-l`参数。尝试使用Docker帮助找出`-l`参数代表什么。您可以按照以下方式调用列表命令的帮助：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, let's learn how to stop and restart containers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何停止和重新启动容器。
- en: Stopping and starting containers
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止和启动容器
- en: 'Sometimes, we want to (temporarily) stop a running container. Let''s try this
    out with the trivia container we used previously:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想（暂时）停止一个运行中的容器。让我们尝试一下之前使用的trivia容器：
- en: 'Run the container again with this command:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用这个命令再次运行容器：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, if we want to stop this container, then we can do so by issuing this command:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们想要停止这个容器，我们可以通过发出这个命令来做到：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you try to stop the trivia container, you will probably note that it takes
    a while until this command is executed. To be precise, it takes about 10 seconds. *Why
    is this the case?*
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试停止trivia容器时，您可能会注意到这个命令执行起来需要一段时间。确切地说，大约需要10秒。*为什么会这样？*
- en: Docker sends a Linux `SIGTERM` signal to the main process running inside the
    container. If the process doesn't react to this signal and terminate itself, Docker
    waits for 10 seconds and then sends `SIGKILL`, which will kill the process forcefully
    and terminate the container.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Docker向容器内部运行的主进程发送Linux `SIGTERM`信号。如果进程对此信号不做出反应并终止自身，Docker将等待10秒，然后发送`SIGKILL`，这将强制终止进程并终止容器。
- en: In the preceding command, we have used the name of the container to specify
    which container we want to stop. But we could have also used the container ID
    instead.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用容器的名称来指定我们要停止的容器。但我们也可以使用容器ID。
- en: '*How do we get the ID of a container?* There are several ways of doing so.
    The manual approach is to list all running containers and find the one that we''re
    looking for in the list. From there, we copy its ID. A more automated way is to
    use some shell scripting and environment variables. If, for example, we want to
    get the ID of the trivia container, we can use this expression:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们如何获取容器的ID？*有几种方法可以做到这一点。手动方法是列出所有运行中的容器，并在列表中找到我们要找的容器。然后，我们复制它的ID。更自动化的方法是使用一些shell脚本和环境变量。例如，如果我们想要获取trivia容器的ID，我们可以使用这个表达式：'
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are using the `-a` parameter with the Docker `container ls` command to list
    all containers, even the stopped ones. This is necessary in this case since we
    stopped the trivia container a moment ago.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Docker `container ls`命令中使用`-a`参数来列出所有容器，即使是已停止的。在这种情况下是必要的，因为我们刚刚停止了trivia容器。
- en: 'Now, instead of using the container name, we can use the `$CONTAINER_ID` variable in
    our expression:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在表达式中使用`$CONTAINER_ID`变量，而不是使用容器名称：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once we have stopped the container, its status changes to `Exited`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们停止了容器，它的状态就会变为`Exited`。
- en: 'If a container is stopped, it can be started again using the `docker container
    start` command. Let''s do this with our trivia container. It is good to have it
    running again, as we''ll need it in the subsequent sections of this chapter:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器已停止，可以使用`docker container start`命令重新启动。让我们用trivia容器来做这个操作。让它再次运行是很好的，因为我们将在本章的后续部分中需要它：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It is now time to discuss what to do with stopped containers that we don't need
    anymore.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候讨论我们不再需要的已停止容器该怎么办了。
- en: Removing containers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除容器
- en: 'When we run the `docker container ls -a` command, we can see quite a few containers
    that are in the `Exited` status. If we don''t need these containers anymore, then
    it is a good thing to remove them from memory; otherwise, they unnecessarily occupy
    precious resources. The command to remove a container is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`docker container ls -a`命令时，我们可以看到相当多的容器处于`Exited`状态。如果我们不再需要这些容器，那么将它们从内存中删除是一件好事；否则，它们会不必要地占用宝贵的资源。删除容器的命令如下：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Another command to remove a container is the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个删除容器的命令如下：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Try to remove one of your exited containers using its ID.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用其ID删除一个已退出的容器。
- en: Sometimes, removing a container will not work as it is still running. If we
    want to force a removal, no matter what the condition of the container currently
    is, we can use the command-line parameter `-f` or `--force`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，删除容器可能不起作用，因为它仍在运行。如果我们想要强制删除，无论容器当前的状态如何，我们可以使用命令行参数`-f`或`--force`。
- en: Inspecting containers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查容器
- en: 'Containers are runtime instances of an image and have a lot of associated data
    that characterizes their behavior. To get more information about a specific container,
    we can use the `inspect` command. As usual, we have to provide either the container
    ID or name to identify the container of which we want to obtain the data. So,
    let''s inspect our sample container:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是镜像的运行时实例，并且具有许多特征其行为的关联数据。要获取有关特定容器的更多信息，我们可以使用`inspect`命令。通常情况下，我们必须提供容器ID或名称来标识我们想要获取数据的容器。因此，让我们检查我们的示例容器：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The response is a big JSON object full of details. It looks similar to this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是一个充满细节的大型JSON对象。它看起来类似于这样：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The output has been shortened for readability.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出已经被缩短以便阅读。
- en: 'Please take a moment to analyze what you got. You should see information such
    as the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请花一点时间分析你得到的信息。您应该看到诸如以下信息：
- en: The ID of the container
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的ID
- en: The creation date and time of the container
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的创建日期和时间
- en: The image from which the container is built
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器的镜像
- en: Many sections of the output, such as `Mounts` or `NetworkSettings`, don't make
    much sense right now, but we will certainly discuss those in the upcoming chapters
    of this book. The data you're seeing here is also named the metadata of a container.
    We will be using the `inspect` command quite often in the remainder of this book
    as a source of information.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的许多部分，如`Mounts`或`NetworkSettings`，现在并没有太多意义，但我们肯定会在本书的后续章节中讨论这些内容。您在这里看到的数据也被称为容器的元数据。在本书的其余部分中，我们将经常使用`inspect`命令作为信息来源。
- en: 'Sometimes, we need just a tiny bit of the overall information, and to achieve
    this, we can either use the grep tool or a filter. The former method does not
    always result in the expected answer, so let''s look into the latter approach:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们只需要整体信息的一小部分，为了实现这一点，我们可以使用`grep`工具或过滤器。前一种方法并不总是得到预期的答案，所以让我们看看后一种方法：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `-f` or `--filter` parameter is used to define the filter. The filter expression itself
    uses the Go template syntax. In this example, we only want to see the state part
    of the whole output in the JSON format.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`或`--filter`参数用于定义过滤器。过滤器表达式本身使用Go模板语法。在这个例子中，我们只想以JSON格式看到整个输出中的状态部分。'
- en: 'To nicely format the output, we pipe the result into the `jq` tool:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使输出格式良好，我们将结果传输到`jq`工具中：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After we have learned how to retrieve loads of important and useful meta information
    about a container, we now want to investigate how we can execute it in a running
    container.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学会如何检索有关容器的大量重要和有用的元信息之后，我们现在想调查如何在运行的容器中执行它。
- en: Exec into a running container
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行的容器中执行
- en: 'Sometimes, we want to run another process inside an already-running container.
    A typical reason could be to try to debug a misbehaving container. *How can we
    do this?* First, we need to know either the ID or the name of the container, and
    then we can define which process we want to run and how we want it to run. Once
    again, we use our currently running trivia container and we run a shell interactively
    inside it with the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望在已经运行的容器内运行另一个进程。一个典型的原因可能是尝试调试行为异常的容器。*我们如何做到这一点？*首先，我们需要知道容器的ID或名称，然后我们可以定义我们想要运行的进程以及我们希望它如何运行。再次，我们使用当前正在运行的trivia容器，并使用以下命令在其中交互式运行一个shell：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `-i` flag signifies that we want to run the additional process interactively,
    and `-t` tells Docker that we want it to provide us with a TTY (a Terminal emulator)
    for the command. Finally, the process we run is `/bin/sh`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`标志表示我们要交互式地运行附加进程，`-t`告诉Docker我们希望它为命令提供TTY（终端仿真器）。最后，我们运行的进程是`/bin/sh`。'
- en: 'If we execute the preceding command in our Terminal, then we will be presented
    with a new prompt, `/app #`. We''re now in a shell inside the trivia container.
    We can easily prove that by, for example, executing the `ps` command, which will
    list all running processes in the context:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在终端中执行上述命令，那么我们将看到一个新的提示符`/app＃`。我们现在在trivia容器内的shell中。我们可以很容易地通过执行`ps`命令来证明这一点，该命令将列出上下文中所有正在运行的进程：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result should look somewhat similar to this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该看起来与这个有些相似：
- en: '![](assets/4f28c7e4-bd1d-42f6-9b52-ed75c1a3f98e.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4f28c7e4-bd1d-42f6-9b52-ed75c1a3f98e.png)'
- en: List of processes running inside the trivia container
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列出在trivia容器内运行的进程
- en: We can clearly see that the process with `PID 1` is the command that we have
    defined to run inside the trivia container. The process with `PID 1` is also named
    the main process.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，具有`PID 1`的进程是我们在trivia容器内定义的要运行的命令。具有`PID 1`的进程也被称为主进程。
- en: 'Leave the container by pressing *Ctrl *+ *D*. We cannot only execute additional
    processes interactive in a container. Please consider the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按下*Ctrl* + *D*来离开容器。我们不仅可以在容器中交互地执行额外的进程。请考虑以下命令：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output evidently looks very similar to the preceding output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显然与前面的输出非常相似。
- en: '![](assets/484111d6-69b2-44fc-9529-4d42a780eecc.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/484111d6-69b2-44fc-9529-4d42a780eecc.png)'
- en: List of processes running inside the trivia container
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 列出在trivia容器内运行的进程
- en: 'We can even run processes as a daemon using the `-d` flag and define environment
    variables using the `-e` flag variables, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用`-d`标志以守护进程的形式运行进程，并使用`-e`标志变量定义环境变量，如下所示：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Great, we have learned how to execute into a running container and run additional
    processes. But there is another important way to mingle with a running container.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们已经学会了如何进入一个正在运行的容器并运行额外的进程。但是还有另一种重要的方式可以与正在运行的容器交互。
- en: Attaching to a running container
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加到一个正在运行的容器
- en: 'We can use the `attach` command to attach our Terminal''s standard input, output,
    and error (or any combination of the three) to a running container using the ID
    or name of the container. Let''s do this for our trivia container:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`attach`命令将我们终端的标准输入、输出和错误（或三者的任意组合）附加到正在运行的容器，使用容器的ID或名称。让我们为我们的trivia容器这样做：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, we will see every five seconds or so a new quote appearing in
    the output.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将每隔五秒左右在输出中看到一个新的引用出现。
- en: To quit the container without stopping or killing it, we can press the key combination *Ctrl *+ *P*+
    *Ctrl *+ *Q*. This detaches us from the container while leaving it running in
    the background. On the other hand, if we want to detach and stop the container
    at the same time, we can just press *Ctrl* + *C.*
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出容器而不停止或杀死它，我们可以按下组合键*Ctrl* + *P* + *Ctrl* + *Q*。这样我们就可以从容器中分离出来，同时让它在后台运行。另一方面，如果我们想要分离并同时停止容器，我们只需按下*Ctrl*
    + *C*。
- en: 'Let''s run another container, this time an Nginx web server:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行另一个容器，这次是一个Nginx Web服务器：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we run the Alpine version of Nginx as a daemon in a container named `nginx`.
    The `-p 8080:80` command-line parameter opens port `8080` on the host for access
    to the Nginx web server running inside the container. Don''t worry about the syntax
    here as we will explain this feature in more detail in [Chapter 10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml), *S**ingle-Host
    Networking*:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在一个名为`nginx`的容器中以守护进程的形式运行Alpine版本的Nginx。`-p 8080:80`命令行参数在主机上打开端口`8080`，以便访问容器内运行的Nginx
    Web服务器。不用担心这里的语法，因为我们将在第10章“单主机网络”中更详细地解释这个特性：
- en: 'Let''s see whether we can access Nginx using the `curl` tool and running this
    command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看是否可以使用`curl`工具访问Nginx并运行这个命令：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If all works correctly, you should be greeted by the welcome page of Nginx
    (shortened for readability):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该会看到Nginx的欢迎页面（为了方便阅读而缩短）：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s attach our Terminal to the `nginx` container to observe what''s
    happening:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们附加我们的终端到`nginx`容器，观察发生了什么：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once you are attached to the container, you first will not see anything. But
    now open another Terminal, and in this new Terminal window, repeat the `curl` command
    a few times, for example, using the following script:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你附加到容器上，你首先看不到任何东西。但现在打开另一个终端，在这个新的终端窗口中，重复`curl`命令几次，例如，使用以下脚本：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should see the logging output of Nginx, which looks similar to this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到Nginx的日志输出，看起来类似于这样：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Quit the container by pressing *Ctrl *+ *C*. This will detach your Terminal
    and, at the same time, stop the `nginx` container.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl*+*C*来退出容器。这将分离你的终端，并同时停止`nginx`容器。
- en: 'To clean up, remove the `nginx` container with the following command:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理时，使用以下命令删除`nginx`容器：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the next section, we're going to learn how to work with container logs.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何处理容器日志。
- en: Retrieving container logs
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索容器日志
- en: It is a best practice for any good application to generate some logging information
    that developers and operators alike can use to find out what the application is
    doing at a given time, and whether there are any problems to help to pinpoint
    the root cause of the issue.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何良好的应用程序来说，生成一些日志信息是最佳实践，开发人员和运维人员都可以使用这些信息来找出应用程序在特定时间正在做什么，以及是否存在任何问题，以帮助找出问题的根本原因。
- en: 'When running inside a container, the application should preferably output the
    log items to `STDOUT` and `STDERR` and not into a file. If the logging output
    is directed to `STDOUT` and `STDERR`, then Docker can collect this information
    and keep it ready for consumption by a user or any other external system:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内运行时，应用程序最好将日志项输出到`STDOUT`和`STDERR`，而不是输出到文件中。如果日志输出被定向到`STDOUT`和`STDERR`，那么Docker可以收集这些信息，并准备好供用户或任何其他外部系统使用：
- en: 'To access the logs of a given container, we can use the `docker container logs` command.
    If, for example, we want to retrieve the logs of our `trivia` container, we can
    use the following expression:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问特定容器的日志，我们可以使用`docker container logs`命令。例如，如果我们想要检索我们的`trivia`容器的日志，我们可以使用以下表达式：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will retrieve the whole log produced by the application from the very beginning
    of its existence.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检索应用程序从其存在的最开始产生的整个日志。
- en: Stop, wait a second—this is not quite true, what I just said. By default, Docker
    uses the so-called `json-file` logging driver. This driver stores the logging
    information in a file. And if there is a file rolling policy defined, then `docker
    container logs` only retrieves what is in the current active log file and not
    what is in previous rolled files that might still be available on the host.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 停下，等一下——我刚才说的不太对。默认情况下，Docker使用所谓的`json-file`日志驱动程序。这个驱动程序将日志信息存储在一个文件中。如果定义了文件滚动策略，那么`docker
    container logs`只会检索当前活动日志文件中的内容，而不是之前滚动文件中可能仍然可用的内容。
- en: 'If we want to only get a few of the latest entries, we can use the `-t` or `--tail` parameter,
    as follows:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只想获取一些最新的条目，我们可以使用`-t`或`--tail`参数，如下所示：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will retrieve only the last five items the process running inside the container
    produced.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只检索容器内运行的进程产生的最后五个条目。
- en: 'Sometimes, we want to follow the log that is produced by a container. This
    is possible when using the `-f` or `--follow` parameter. The following expression
    will output the last five log items and then follow the log as it is produced
    by the containerized process:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望跟踪容器产生的日志。当使用`-f`或`--follow`参数时，这是可能的。以下表达式将输出最后五个日志项，然后跟踪容器化进程产生的日志：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Often using the default mechanism for container logging is not enough. We need
    a different way of logging. This is discussed in the following section.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用容器日志的默认机制是不够的。我们需要一种不同的日志记录方式。这将在下一节中讨论。
- en: Logging drivers
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录驱动程序
- en: 'Docker includes multiple logging mechanisms to help us to get information from
    running containers. These mechanisms are named** logging drivers**. Which logging
    driver is used can be configured at the Docker daemon level. The default logging
    driver is `json-file`. Some of the drivers that are currently supported natively
    are as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Docker包括多种日志记录机制，帮助我们从运行的容器中获取信息。这些机制被称为**日志记录驱动程序**。使用哪个日志记录驱动程序可以在Docker守护程序级别进行配置。默认的日志记录驱动程序是`json-file`。目前原生支持的一些驱动程序如下：
- en: '| **Driver**  | **Description**  |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **驱动程序** | **描述** |'
- en: '| `none` | No log output for the specific container is produced. |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `none` | 不会产生特定容器的日志输出。 |'
- en: '| `json-file` | This is the default driver. The logging information is stored
    in files, formatted as JSON. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `json-file` | 这是默认驱动程序。日志信息存储在以JSON格式的文件中。 |'
- en: '| `journald` | If the journals daemon is running on the host machine, we can
    use this driver. It forwards logging to the `journald` daemon. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `journald` | 如果主机上运行着日志守护程序，我们可以使用此驱动程序。它将日志转发到`journald`守护程序。 |'
- en: '| `syslog` | If the `syslog` daemon is running on the host machine, we can
    configure this driver, which will forward the log messages to the `syslog` daemon.
    |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `syslog` | 如果主机上运行着`syslog`守护程序，我们可以配置此驱动程序，它将日志消息转发到`syslog`守护程序。 |'
- en: '| `gelf` | When using this driver, log messages are written to a **Graylog
    Extended Log Format** (**GELF**) endpoint. Popular examples of such endpoints
    are Graylog and Logstash. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `gelf` | 使用此驱动程序时，日志消息将写入**Graylog扩展日志格式**（**GELF**）端点。此类端点的常见示例包括Graylog和Logstash。
    |'
- en: '| `fluentd` | Assuming that the `fluentd` daemon is installed on the host system,
    this driver writes log messages to it. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `fluentd` | 假设在主机系统上安装了`fluentd`守护程序，此驱动程序将日志消息写入其中。 |'
- en: If you change the logging driver, please be aware that the `docker container
    logs` command is only available for the `json-file` and `journald` drivers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改了日志记录驱动程序，请注意`docker container logs`命令仅适用于`json-file`和`journald`驱动程序。
- en: Using a container-specific logging driver
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用特定于容器的日志记录驱动程序
- en: 'We have seen that the logging driver can be set globally in the Docker daemon
    configuration file. But we can also define the logging driver on a container by
    container basis. In the following example, we are running a `busybox` container
    and use the `--log-driver` parameter to configure the `none` logging driver:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到日志记录驱动程序可以在Docker守护程序配置文件中全局设置。但我们也可以在容器与容器之间定义日志记录驱动程序。在以下示例中，我们运行了一个`busybox`容器，并使用`--log-driver`参数配置了`none`日志记录驱动程序：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We should see the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下内容：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, let''s try to get the logs of the preceding container:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试获取前一个容器的日志：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is to be expected since the `none` driver does not produce any logging
    output. Let''s clean up and remove the `test` container:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以预期的，因为`none`驱动程序不会产生任何日志输出。让我们清理并删除`test`容器：
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Advanced topic – changing the default logging driver
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级主题-更改默认日志记录驱动程序
- en: 'Let''s change the default logging driver of a Linux host:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改Linux主机的默认日志记录驱动程序：
- en: 'The easiest way to do this is on a real Linux host. For this purpose, we''re
    going to use Vagrant with an Ubuntu image:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在真实的Linux主机上进行这项操作是最简单的。为此，我们将使用Vagrant和Ubuntu镜像：
- en: '[PRE54]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Vagrant** is an open source tool developed by Hashicorp that is often used
    for building and maintaining portable virtual software development environments.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vagrant**是由Hashicorp开发的开源工具，通常用于构建和维护可移植的虚拟软件开发环境。'
- en: 'Once inside the Ubuntu VM, we want to edit the Docker daemon configuration
    file. Navigate to the `/etc/docker` folder and run `vi` as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入Ubuntu虚拟机后，我们要编辑Docker守护程序配置文件。转到`/etc/docker`文件夹并运行`vi`如下：
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Enter the following content:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下内容：
- en: '[PRE56]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Save and exit `vi` by first pressing *Esc*and then typing `:w:q` and finally
    hitting the *Enter* key.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过首先按*Esc*，然后输入`:w:q`，最后按*Enter*键保存并退出`vi`。
- en: The preceding definition tells the Docker daemon to use the `json-log` driver
    with a maximum log file size of 10 MB before it is rolled, and the maximum number
    of log files that can be present on the system is `3` before the oldest file gets
    purged.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的定义告诉Docker守护程序使用`json-log`驱动程序，最大日志文件大小为10MB，然后滚动，并且在系统上可以存在的最大日志文件数为`3`，在最老的文件被清除之前。
- en: 'Now we have to send a `SIGHUP` signal to the Docker daemon so that it picks
    up the changes in the configuration file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须向Docker守护程序发送`SIGHUP`信号，以便它接受配置文件中的更改：
- en: '[PRE57]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that the preceding command only reloads the config file and does not restart
    the daemon.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的命令只重新加载配置文件，而不重新启动守护程序。
- en: Anatomy of containers
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的解剖学
- en: Many people wrongly compare containers to VMs. However, this is a questionable
    comparison. Containers are not just lightweight VMs. OK then, *what is the correct
    description of a container?*
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人错误地将容器与虚拟机进行比较。然而，这是一个值得商榷的比较。容器不仅仅是轻量级的虚拟机。那么，*容器的正确描述是什么*？
- en: Containers are specially encapsulated and secured processes running on the host
    system. Containers leverage a lot of features and primitives available in the Linux
    OS. The most important ones are *namespaces *and *cgroups*. All processes running
    in containers only share the same Linux kernel of the underlying host operating
    system. This is fundamentally different compared with VMs, as each VM contains
    its own full-blown operating system.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是在主机系统上运行的特殊封装和安全进程。容器利用了Linux操作系统中许多可用的特性和原语。最重要的是*命名空间*和*cgroups*。在容器中运行的所有进程只共享底层主机操作系统的相同Linux内核。这与虚拟机有根本的不同，因为每个虚拟机都包含自己的完整操作系统。
- en: The startup times of a typical container can be measured in milliseconds, while
    a VM normally needs several seconds to minutes to start up. VMs are meant to be
    long-living. It is a primary goal of each operations engineer to maximize the
    uptime of their VMs. Contrary to that, containers are meant to be ephemeral. They
    come and go relatively quickly.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Typical container的启动时间可以用毫秒来衡量，而虚拟机通常需要几秒到几分钟才能启动。虚拟机的寿命较长。每个运维工程师的主要目标是最大化虚拟机的正常运行时间。相反，容器的寿命较短。它们相对快速地出现和消失。
- en: Let's first get a high-level overview of the architecture that enables us to
    run containers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先对使我们能够运行容器的架构进行高级概述。
- en: Architecture
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: 'Here, we have an architectural diagram on how this all fits together:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个关于所有这些如何组合在一起的架构图：
- en: '![](assets/350f0f91-f671-4ed5-9eae-0f0d6c5dae6e.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/350f0f91-f671-4ed5-9eae-0f0d6c5dae6e.png)'
- en: High-level architecture of Docker
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的高级架构
- en: In the lower part of the preceding diagram, we have the Linux operating system
    with its **cgroups**, **Namespaces**, and **Layer** **Capabilities** as well as
    **Other OS Functionality** that we do not need to explicitly mention here. Then,
    there is an intermediary layer composed of **containerd** and **runc**. On top
    of all that now sits the **Docker engine**. The **Docker engine** offers a RESTful
    interface to the outside world that can be accessed by any tool, such as the Docker
    CLI, Docker for macOS, and Docker for Windows or Kubernetes to name just a few.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图的下部，我们有Linux操作系统及其**cgroups**、**名称空间**和**层** **功能**，以及我们不需要在这里明确提到的**其他操作系统功能**。然后，有一个由**containerd**和**runc**组成的中间层。现在所有这些之上是**Docker引擎**。**Docker引擎**为外部世界提供了一个RESTful接口，可以被任何工具访问，比如Docker
    CLI、Docker for macOS和Docker for Windows或Kubernetes等。
- en: Let's now describe the main building blocks in a bit more detail.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地描述一下主要的构建模块。
- en: Namespaces
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 名称空间
- en: Linux namespaces had been around for years before they were leveraged by Docker
    for their containers. A namespace is an abstraction of global resources such as
    filesystems, network access, and process trees (also named PID namespaces) or
    the system group IDs and user IDs. A Linux system is initialized with a single
    instance of each namespace type. After initialization, additional namespaces can
    be created or joined.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Linux名称空间在被Docker用于其容器之前已经存在多年。名称空间是全局资源的抽象，如文件系统、网络访问和进程树（也称为PID名称空间）或系统组ID和用户ID。Linux系统初始化时具有每种名称空间类型的单个实例。初始化后，可以创建或加入其他名称空间。
- en: The Linux namespaces originated in 2002 in the 2.4.19 kernel. In kernel version
    3.8, user namespaces were introduced and with it, namespaces were ready to be
    used by containers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Linux名称空间起源于2002年的2.4.19内核。在内核版本3.8中，引入了用户名称空间，随之而来的是名称空间已经准备好被容器使用。
- en: 'If we wrap a running process, say, in a filesystem namespace, then this process
    has the illusion that it owns its own complete filesystem. This, of course, is
    not true; it is only a virtual filesystem. From the perspective of the host, the
    contained process gets a shielded subsection of the overall filesystem. It is
    like a filesystem in a filesystem:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个正在运行的进程，比如说，放在一个文件系统名称空间中，那么这个进程会产生一种错觉，认为它拥有自己完整的文件系统。当然，这是不真实的；这只是一个虚拟文件系统。从主机的角度来看，包含的进程获得了整体文件系统的受保护子部分。就像一个文件系统中的文件系统：
- en: '![](assets/9ce9575c-b97c-4da2-8cf9-13bf1b9bd15b.png)Filesystem namespaces on
    Linux'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/9ce9575c-b97c-4da2-8cf9-13bf1b9bd15b.png)Linux上的文件系统名称空间'
- en: The same applies to all of the other global resources for which namespaces exist.
    The user ID namespace is another example. Having a user namespace, we can now
    define a `jdoe `user many times on the system as long as it is living in its own
    namespace.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他全局资源，名称空间也适用。用户ID名称空间是另一个例子。有了用户名称空间，我们现在可以在系统上定义一个`jdoe`用户多次，只要它存在于自己的名称空间中。
- en: 'The PID namespace is what keeps processes in one container from seeing or interacting
    with processes in another container. A process might have the apparent PID **1** inside
    a container, but if we examine it from the host system, it would have an ordinary
    PID, say **334**:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: PID名称空间是防止一个容器中的进程看到或与另一个容器中的进程交互的机制。一个进程在容器内可能具有表面上的PID **1**，但如果我们从主机系统检查它，它将具有普通的PID，比如**334**：
- en: '![](assets/a4d80d0a-451d-40dd-9c62-90b7c451dce9.png)Process tree on a Docker
    host'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a4d80d0a-451d-40dd-9c62-90b7c451dce9.png)Docker主机上的进程树'
- en: In a given namespace, we can run one to many processes. That is important when
    we talk about containers, and we have experienced that already when we executed
    another process in an already-running container.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的名称空间中，我们可以运行一个到多个进程。当我们谈论容器时，这一点很重要，当我们在已经运行的容器中执行另一个进程时，我们已经有了这种经验。
- en: Control groups (cgroups)
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制组（cgroups）
- en: Linux cgroups are used to limit, manage, and isolate resource usage of collections
    of processes running on a system. Resources are CPU time, system memory, network
    bandwidth, or combinations of these resources, and so on.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Linux cgroups被用来限制、管理和隔离在系统上运行的进程集合的资源使用。资源包括CPU时间、系统内存、网络带宽，或者这些资源的组合等等。
- en: Engineers at Google originally implemented this feature in 2006\. The cgroups
    functionality was merged into the Linux kernel mainline in kernel version 2.6.24,
    which was released in January 2008.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Google的工程师最初在2006年实现了这个功能。cgroups功能被合并到Linux内核主线中，内核版本为2.6.24，发布于2008年1月。
- en: Using cgroups, administrators can limit the resources that containers can consume.
    With this, we can avoid, for example, the classical *noisy neighbor* problem,
    where a rogue process running in a container consumes all CPU time or reserves
    massive amounts of RAM and, as such, starves all of the other processes running
    on the host, whether they're containerized or not.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用cgroups，管理员可以限制容器可以消耗的资源。通过这种方式，我们可以避免例如经典的“吵闹的邻居”问题，其中在容器中运行的恶意进程消耗了所有的CPU时间或者保留了大量的内存，从而使得所有在主机上运行的其他进程，无论它们是否被容器化，都饿死了。
- en: Union filesystem (Unionfs)
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合文件系统（Unionfs）
- en: Unionfs forms the backbone of what is known as container images. We will discuss
    container images in detail in the next chapter. At this time, we want to just
    understand a bit better what Unionfs is, and how it works. Unionfs is mainly used
    on Linux and allows files and directories of distinct filesystems to be overlaid
    to form a single coherent filesystem. In this context, the individual filesystems
    are called branches. Contents of directories that have the same path within the
    merged branches will be seen together in a single merged directory, within the
    new virtual filesystem. When merging branches, the priority between the branches
    is specified. In that way, when two branches contain the same file, the one with
    the higher priority is seen in the final filesystem.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Unionfs构成了所谓的容器镜像的基础。我们将在下一章详细讨论容器镜像。此时，我们只想更好地理解Unionfs是什么，以及它是如何工作的。Unionfs主要用于Linux，允许不同文件系统的文件和目录叠加在一起，形成一个统一的文件系统。在这种情况下，各个文件系统被称为分支。在合并分支时，指定了分支之间的优先级。这样，当两个分支包含相同的文件时，具有更高优先级的文件将出现在最终的文件系统中。
- en: Container plumbing
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器管道
- en: The basement on top of which the Docker engine is built; is the **container
    plumbing** and is formed by two components, **runc** and **containerd**.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎构建的基础是**容器管道**，由两个组件**runc**和**containerd**组成。
- en: Originally, Docker was built in a monolithic way and contained all of the functionality
    necessary to run containers. Over time, this became too rigid and Docker started
    to break out parts of the functionality into their own components. Two important
    components are runc and containerd.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Docker是以单片方式构建的，并包含了运行容器所需的所有功能。随着时间的推移，这变得过于僵化，Docker开始将功能的部分拆分成它们自己的组件。两个重要的组件是runc和containerd。
- en: runC
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: runC
- en: runC is a lightweight, portable container runtime. It provides full support
    for Linux namespaces as well as native support for all security features available
    on Linux, such as SELinux, AppArmor, seccomp, and cgroups.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: runC是一个轻量级、便携的容器运行时。它完全支持Linux命名空间，以及Linux上所有可用的安全功能，如SELinux、AppArmor、seccomp和cgroups。
- en: runC is a tool for spawning and running containers according to the **Open Container
    Initiative** (**OCI**) specification. It is a formally specified configuration format,
    governed by the **Open Container Project** (**OCP**) under the auspices of the
    Linux Foundation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: runC是一个根据**Open Container Initiative**（OCI）规范生成和运行容器的工具。它是一个经过正式规范化的配置格式，由Linux
    Foundation的**Open Container Project**（OCP）监管。
- en: Containerd
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Containerd
- en: runC is a low-level implementation of a container runtime; containerd builds
    on top of it and adds higher-level features, such as image transfer and storage,
    container execution, and supervision as well as network and storage attachments.
    With this, it manages the complete life cycle of containers. Containerd is the
    reference implementation of the OCI specifications and is by far the most popular
    and widely used container runtime.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: runC是一个容器运行时的低级实现；containerd在其基础上构建，并添加了更高级的功能，如镜像传输和存储、容器执行和监督，以及网络和存储附件。通过这些功能，它管理容器的完整生命周期。Containerd是OCI规范的参考实现，是目前最受欢迎和广泛使用的容器运行时。
- en: Containerd was donated to and accepted by the CNCF in 2017\. There exist alternative
    implementations of the OCI specification. Some of them are rkt by CoreOS, CRI-O
    by RedHat, and LXD by Linux Containers. However, containerd at this time is by
    far the most popular container runtime and is the default runtime of Kubernetes
    1.8 or later and the Docker platform.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Containerd于2017年捐赠并被CNCF接受。OCI规范存在替代实现。其中一些是CoreOS的rkt，RedHat的CRI-O和Linux Containers的LXD。然而，containerd目前是最受欢迎的容器运行时，并且是Kubernetes
    1.8或更高版本和Docker平台的默认运行时。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to work with containers that are based on existing
    images. We showed how to run, stop, start, and remove a container. Then, we inspected
    the metadata of a container, extracted the logs of it, and learned how to run
    an arbitrary process in an already-running container. Last but not least, we dug
    a bit deeper and investigated how containers work and what features of the underlying
    Linux operating system they leverage.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何使用基于现有镜像的容器。我们展示了如何运行、停止、启动和删除容器。然后，我们检查了容器的元数据，提取了它的日志，并学习了如何在已运行的容器中运行任意进程。最后，我们深入挖掘了容器的工作原理以及它们利用的底层Linux操作系统的特性。
- en: In the next chapter, you're going to learn what container images are and how
    we can build and share our own custom images. We'll also be discussing the best
    practices commonly used when building custom images, such as minimizing their
    size and leveraging the image cache. Stay tuned!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习容器镜像是什么，以及我们如何构建和共享我们自己的自定义镜像。我们还将讨论构建自定义镜像时常用的最佳实践，例如最小化其大小和利用镜像缓存。敬请关注！
- en: Questions
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To assess your learning progress, please answer the following questions:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估您的学习进度，请回答以下问题：
- en: What are the states of a container?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器的状态是什么？
- en: Which command helps us to find out what is currently running on our Docker host?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令帮助我们找出当前在我们的Docker主机上运行的内容？
- en: Which command is used to list the IDs of all containers?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于列出所有容器的ID的命令是什么？
- en: Further reading
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following articles give you some more information related to the topics
    we discussed in this chapter:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文章为您提供了一些与本章讨论的主题相关的更多信息：
- en: Docker containers at [http://dockr.ly/2iLBV2I](http://dockr.ly/2iLBV2I)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker容器在[http://dockr.ly/2iLBV2I](http://dockr.ly/2iLBV2I)
- en: Getting started with containers at [http://dockr.ly/2gmxKWB](http://dockr.ly/2gmxKWB)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器入门在[http://dockr.ly/2gmxKWB](http://dockr.ly/2gmxKWB)
- en: Isolating containers with a user namespace at [http://dockr.ly/2gmyKdf](http://dockr.ly/2gmyKdf)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户命名空间隔离容器在[http://dockr.ly/2gmyKdf](http://dockr.ly/2gmyKdf)
- en: Limiting a container's resources at [http://dockr.ly/2wqN5Nn](http://dockr.ly/2wqN5Nn)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制容器的资源在[http://dockr.ly/2wqN5Nn](http://dockr.ly/2wqN5Nn)。
