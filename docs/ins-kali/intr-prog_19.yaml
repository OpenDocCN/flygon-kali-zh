- en: Streams and Pipelines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流和管道
- en: 'The lambda expressions described and demonstrated in the previous chapter, together
    with functional interfaces, added a powerful functional programming capability
    to Java. It allows for passing behaviors (functions) as parameters to the libraries
    optimized for the performance of the data processing. This way, an application
    programmer can concentrate on the business aspects of the developed system, leaving
    the performance aspects to the specialists: the authors of the library. One example
    of such a library is the `java.util.stream` package, which is going to be the
    focus of this chapter.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章描述和演示的lambda表达式以及功能接口中，为Java增加了强大的函数式编程能力。它允许将行为（函数）作为参数传递给针对数据处理性能进行优化的库。这样，应用程序员可以专注于开发系统的业务方面，将性能方面留给专家：库的作者。这样的一个库的例子是`java.util.stream`包，它将成为本章的重点。
- en: We will introduce the concept of data streams processing, and will explain what
    streams are, how to process them, and how to build processing pipelines. We will
    also show how easily one can organize stream processing in parallel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍数据流处理的概念，并解释流是什么，如何处理它们以及如何构建处理管道。我们还将展示如何轻松地组织并行流处理。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下主题：
- en: What is a stream?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是流？
- en: Creating a stream
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建流
- en: Intermediate operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间操作
- en: Terminal operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端操作
- en: Stream pipelines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流管道
- en: Parallel processing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行处理
- en: Exercise – Multiplying all of the stream elements
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习 - 将所有流元素相乘
- en: What is a stream?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是流？
- en: The best way to understand a stream is to compare it to a collection. The latter
    is a data structure stored in memory. Every collection element is computed *before*
    being added to the collection. In contrast, an element emitted by a stream exists
    somewhere else (in the source) and is computed *on demand*. So, a collection can
    be a source for a stream.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 理解流的最好方法是将其与集合进行比较。后者是存储在内存中的数据结构。在将元素添加到集合之前，会计算每个集合元素。相反，流发出的元素存在于其他地方（源）并且根据需要进行计算。因此，集合可以是流的源。
- en: In Java, a stream is an object of a `Stream`, `IntStream`, `LongStream`, or `DoubleStream` interface
    of the `java.util.stream` package. All methods present in the `Stream` interface
    are also available (with corresponding type changes) in the `IntStream`, `LongStream`,
    or `DoubleStream` specialized *numeric* stream interfaces. Some of the numeric
    stream interfaces have a few extra methods, such as `average()` and `sum()`, specific
    to the numeric values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，流是`java.util.stream`包的`Stream`、`IntStream`、`LongStream`或`DoubleStream`接口的对象。`Stream`接口中的所有方法也可以在`IntStream`、`LongStream`或`DoubleStream`专门的*数值*流接口中使用（相应类型更改）。一些数值流接口有一些额外的方法，例如`average()`和`sum()`，专门用于数值。
- en: In this chapter, we will mostly speak about the `Stream` interface and its methods.
    But everything introduced can be equally applied to the numeric stream interfaces,
    too. At the end of the chapter, we will also review a few methods that are available
    in the numeric stream interfaces, but not in the `Stream` interface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要讨论`Stream`接口及其方法。但是，所介绍的一切同样适用于数值流接口。在本章末尾，我们还将回顾一些在数值流接口中可用但在`Stream`接口中不可用的方法。
- en: A stream represents some source of data—a collection, an array, or a file, for
    example—and generates (produces, emits) some values (stream elements of the same
    type as the stream) sequentially, as soon as the previously emitted element has
    been processed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 流代表一些数据源 - 例如集合、数组或文件 - 并且按顺序生成（产生、发出）一些值（与流相同类型的流元素），一旦先前发出的元素被处理。
- en: The `java.util.stream` package allows for the declarative presentation of the
    procedures (functions) that can be applied to the emitted elements, also in parallel.
    Today, with the machine learning requirements of massive data processing and the
    fine-tuning of operations having become ubiquitous, this feature reinforces the
    position of Java among the few modern programming languages of choice.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.stream`包允许以声明方式呈现可以应用于发出元素的过程（函数），也可以并行进行。如今，随着机器学习对大规模数据处理的要求以及对操作的微调变得普遍，这一特性加强了Java在少数现代编程语言中的地位。'
- en: Stream operations
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流操作
- en: Many of the methods of the `Stream` interface (those that have a functional
    interface type as a parameter) are called operations, because they are not implemented
    as traditional methods. Their functionalities are passed into the methods as a
    functions. The methods themselves are just shells that call a method of the functional
    interface, assigned as the type of the method parameter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`接口的许多方法（具有函数接口类型作为参数的方法）被称为操作，因为它们不是作为传统方法实现的。它们的功能作为函数传递到方法中。方法本身只是调用分配为方法参数类型的函数接口的方法的外壳。'
- en: For example, let us look at the `Stream<T> filter (Predicate<T> predicate)` method.
    Its implementation is based on the call to the `boolean test(T)` method of the
    `Predicate<T>` function. So, instead of saying, "We use the `filter()` method
    of the `Stream` object to select some of the stream elements and skip others,"
    the programmers prefer to say, "We apply the `filter` operation that allows some
    of the stream elements to get through, and skips others." It sounds similar to
    the statement, "We apply an operation of addition." It describes the nature of
    the action (operation), not the particular algorithm, which is unknown until the
    method receives the particular function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看一下`Stream<T> filter (Predicate<T> predicate)`方法。它的实现基于对`Predicate<T>`函数的`boolean
    test(T)`方法的调用。因此，程序员更喜欢说，“我们应用`filter`操作，允许一些流元素通过，跳过其他元素”，而不是说“我们使用`Stream`对象的`filter()`方法来选择一些流元素并跳过其他元素”。这听起来类似于说“我们应用加法操作”。它描述了动作（操作）的性质，而不是特定的算法，直到方法接收到特定函数为止。
- en: 'So, there are three groups of methods in the `Stream` interface:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Stream`接口中有三组方法：
- en: Static factory methods that create `Stream` objects.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`Stream`对象的静态工厂方法。
- en: Intermediate operations, which are instance methods that return `Stream` objects.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间操作是返回`Stream`对象的实例方法。
- en: Terminal operations, which are instance methods that return some type other
    than `Stream`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端操作是返回`Stream`之外的某种类型的实例方法。
- en: Stream processing is organized typically as a pipe using a fluent (dot-connected)
    style (see the *Stream pipeline* section). A `Stream` factory method or another
    stream source starts such a pipe, and a Terminal operation produces the pipe result
    or a side effect, and ends the pipe (thus, the name). An intermediate operation
    can be placed between the originating `Stream` object and the Terminal operation.
    It processes the stream elements (or not, in some cases), and returns the modified
    (or not modified) `Stream` object, so the next intermediate or Terminal operation
    can be applied.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 流处理通常以流畅（点连接）的方式组织（参见*流管道*部分）。`Stream`工厂方法或另一个流源开始这样的管道，终端操作产生管道结果或副作用，并结束管道（因此得名）。中间操作可以放置在原始`Stream`对象和终端操作之间。它处理流元素（或在某些情况下不处理），并返回修改的（或未修改的）`Stream`对象，以便应用下一个中间或终端操作。
- en: 'Examples of intermediate operations are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 中间操作的示例如下：
- en: '`filter()`: This selects only elements matching a criterion.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter()`: 这将选择与条件匹配的元素。'
- en: '`map()`: This transforms elements according to a function.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map()`: 这将根据函数转换元素。'
- en: '`distinct()`: This removes duplicates.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distinct()`: 这将删除重复项。'
- en: '`limit()`: This limits a stream to the specified number of elements.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit()`: 这将限制流的元素数量。'
- en: '`sorted()`: This transforms unsorted stream into a sorted one.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sorted()`: 这将把未排序的流转换为排序的流。'
- en: There are some other methods that we will discuss in the *Intermediate operations*
    section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他方法，我们将在*中间操作*部分讨论。
- en: The processing of the stream elements actually begins only when a Terminal operation
    starts executing. Then, all of the intermediate operations (if present) start
    processing. The stream closes (and cannot be reopened) as soon as the Terminal
    operation finishes execution. Examples of Terminal operations are `forEach()`,
    `findFirst()`, `reduce()`, `collect()`, `sum()`, `max()`, and other methods of
    the `Stream` interface that do not return `Stream`. We will discuss them in the *Terminal
    operations* section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 流元素的处理实际上只有在开始执行终端操作时才开始。然后，所有中间操作（如果存在）开始处理。流在终端操作完成执行后关闭（并且无法重新打开）。终端操作的示例包括`forEach()`、`findFirst()`、`reduce()`、`collect()`、`sum()`、`max()`和`Stream`接口的其他不返回`Stream`的方法。我们将在*终端操作*部分讨论它们。
- en: All of the Stream methods support parallel processing, which is especially helpful
    in the case of a large amount of data processed on a multi-core computer. One
    must make sure that the processing pipeline does not use a context state that
    can vary across different processing environments. We will discuss this in the *Parallel
    processing* section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的Stream方法都支持并行处理，这在多核计算机上处理大量数据时特别有帮助。必须确保处理管道不使用可以在不同处理环境中变化的上下文状态。我们将在*并行处理*部分讨论这一点。
- en: Creating a stream
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建流
- en: There are many ways to create a stream—an object of the `Stream` type or any
    of the numeric interfaces. We have grouped them by classes and interfaces that
    have methods creating Stream objects. We did so for the reader's convenience,
    to provide a better overview, so that it will be easier for the reader to find
    them if needed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多创建流的方法——`Stream`类型的对象或任何数字接口。我们已经按照创建Stream对象的方法所属的类和接口对它们进行了分组。我们之所以这样做是为了方便读者，提供更好的概览，这样读者在需要时更容易找到它们。
- en: Stream interface
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流接口
- en: This group of `Stream` factories is composed of static methods that belong to
    the `Stream` interface.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这组`Stream`工厂由属于`Stream`接口的静态方法组成。
- en: empty(), of(T t), ofNullable(T t)
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: empty(), of(T t), ofNullable(T t)
- en: 'The following three methods create either empty or single-element `Stream`
    objects:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三种方法创建空的或单个元素的`Stream`对象：
- en: '`Stream<T> empty()`: Creates an empty sequential `Stream` object.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> empty()`: 创建一个空的顺序`Stream`对象。'
- en: '`Stream<T> of(T t)`: Creates a sequential single-element `Stream` object.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> of(T t)`: 创建一个顺序的单个元素`Stream`对象。'
- en: '`Stream<T> ofNullable(T t)`: Creates a sequential `Stream` object containing
    a single element if the `t` parameter is non-null; otherwise, creates an empty
    Stream.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> ofNullable(T t)`: 如果`t`参数非空，则创建一个包含单个元素的顺序`Stream`对象；否则，创建一个空的Stream。'
- en: 'The following code demonstrates the usage of the preceding methods:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了前面方法的用法：
- en: '```java'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream.empty().forEach(System.out::println);    //prints nothing
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.empty().forEach(System.out::println);    //不打印任何内容
- en: 'Stream.of(1).forEach(System.out::println);      //prints: 1'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.of(1).forEach(System.out::println);      //打印：1
- en: List<String> list = List.of("1 ", "2");
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("1 ", "2");
- en: //printList1(null);                             //NullPointerException
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: //printList1(null);                             //NullPointerException
- en: 'printList1(list);                               //prints: 1 2'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: printList1(list);                               //打印：1 2
- en: void printList1(List<String> list){
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: void printList1(List<String> list){
- en: list.stream().forEach(System.out::print);;
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().forEach(System.out::print);;
- en: '}'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Notice how the first call to the `printList1()` method generates `NullPointerException`
    and prints `1 2` when the list is not `null`. To avoid the exception, we could
    implement the `printList1()` method as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当列表不为空时，第一次调用`printList1()`方法会生成`NullPointerException`并打印`1 2`。为了避免异常，我们可以将`printList1()`方法实现如下：
- en: '```java'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void printList1(List<String> list){
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: void printList1(List<String> list){
- en: '(list == null ? Stream.empty() : list.stream())'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '(list == null ? Stream.empty() : list.stream())'
- en: .forEach(System.out::print);
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print);
- en: '}'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Instead, we have used the `ofNullable(T t) ` method, as you can see in the
    following implementation of the `printList2()` method:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们使用了`ofNullable(T t)`方法，如下面的`printList2()`方法的实现所示：
- en: '```java'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: printList2(null);                                //prints nothing
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: printList2(null);                                //prints nothing
- en: 'printList2(list);                                //prints: [1 , 2]'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 'printList2(list);                                //prints: [1 , 2]'
- en: void printList2(List<String> list){
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: void printList2(List<String> list){
- en: Stream.ofNullable(list).forEach(System.out::print);
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.ofNullable(list).forEach(System.out::print);
- en: '}'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: That is the use case that has motivated the creation of the `ofNullable(T t)` method. But
    you may have noticed that a stream created by `ofNullable()` emitting the list
    as one object: it is printed as `[1 , 2]`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是激发`ofNullable(T t)`方法创建的用例。但是您可能已经注意到，`ofNullable()`创建的流将列表作为一个对象发出：它被打印为`[1
    , 2]`。
- en: 'To process each element of the list in this case, we would need to add an intermediate
    `Stream` operation, `flatMap()`, that converts each element to a `Stream` object:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下处理列表的每个元素，我们需要添加一个中间的`Stream`操作`flatMap()`，将每个元素转换为`Stream`对象：
- en: '```java'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream.ofNullable(list).flatMap(e -> e.stream())
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.ofNullable(list).flatMap(e -> e.stream())
- en: '.forEach(System.out::print);      //prints: 1 2'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);      //prints: 1 2'
- en: '```'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We will discuss `flatMap()` method further in the *Intermediate operations*
    section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*Intermediate operations*部分进一步讨论`flatMap()`方法。
- en: 'The function passed into the `flatMap()` operation in the preceding code can
    be expressed as a method reference, too:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中传递给`flatMap()`操作的函数也可以表示为方法引用：
- en: '```java'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream.ofNullable(list).flatMap(Collection::stream)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.ofNullable(list).flatMap(Collection::stream)
- en: '.forEach(System.out::print);      //prints: 1 2'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);      //prints: 1 2'
- en: '```'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: iterate(Object, UnaryOperator)
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iterate(Object, UnaryOperator)
- en: 'Two static methods of the `Stream` interface allow us to generate a stream
    of values using an iterative process similar to the traditional `for` loop:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`接口的两个静态方法允许我们使用类似传统`for`循环的迭代过程生成值流：'
- en: '`Stream<T> iterate(T seed, UnaryOperator<T> func)`: Creates an **infinite**
    sequential `Stream` object, based on the iterative application of the second parameter
    (a `func` function) to the first `seed` parameter, producing a stream of `seed`,
    `f(seed)`, and `f(f(seed))` values.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> iterate(T seed, UnaryOperator<T> func)`: 根据第一个`seed`参数的迭代应用第二个参数（`func`函数）创建一个**无限**顺序`Stream`对象，生成`seed`、`f(seed)`和`f(f(seed))`值的流。'
- en: '`Stream<T> iterate(T seed, Predicate<T> hasNext, UnaryOperator<T> next)`: Creates
    a finite sequential `Stream` object based on the iterative application of the
    third parameter (the `next` function) to the first `seed` parameter, producing
    a stream of `seed`, `f(seed)`, and `f(f(seed))`, values, as long as the third
    parameter (the `hasNext` function) returns `true`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> iterate(T seed, Predicate<T> hasNext, UnaryOperator<T> next)`: 根据第三个参数（`next`函数）对第一个`seed`参数的迭代应用，生成`seed`、`f(seed)`和`f(f(seed))`值的有限顺序`Stream`对象，只要第三个参数（`hasNext`函数）返回`true`。'
- en: 'The following code demonstrates the usage of these methods:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了这些方法的用法：
- en: '```java'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream.iterate(1, i -> ++i).limit(9)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.iterate(1, i -> ++i).limit(9)
- en: '.forEach(System.out::print);        //prints: 123456789'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);        //prints: 123456789'
- en: Stream.iterate(1, i -> i < 10, i -> ++i)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.iterate(1, i -> i < 10, i -> ++i)
- en: '.forEach(System.out::print);        //prints: 123456789'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);        //prints: 123456789'
- en: '```'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that we were forced to add a `limit()` intermediate operator to the first
    pipeline to avoid generating an infinite number of values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们被迫在第一个管道中添加一个`limit()`中间操作，以避免生成无限数量的值。
- en: concat(Stream a, Stream b)
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: concat(Stream a, Stream b)
- en: 'The `Stream<T>` concatenate (`Stream<> a`, `Stream<T> b`) static method of
    the `Stream` interface creates a stream of values based on two Stream objects,
    `a` and `b`, passed in as the parameters. The newly created stream consists of all
    the elements of the first parameter, `a`, followed by all of the elements of the
    second parameter, `b`. The following code demonstrates this method of Stream object
    creation:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream<T>` concatenate (`Stream<> a`, `Stream<T> b`) `Stream` 接口的静态方法基于传递的两个`Stream`对象`a`和`b`创建一个值流。新创建的流由第一个参数`a`的所有元素组成，后跟第二个参数`b`的所有元素。以下代码演示了`Stream`对象创建的这种方法：'
- en: '```java'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream<Integer> stream1 = List.of(1, 2).stream();
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Stream<Integer> stream1 = List.of(1, 2).stream();
- en: Stream<Integer> stream2 = List.of(2, 3).stream();
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Stream<Integer> stream2 = List.of(2, 3).stream();
- en: Stream.concat(stream1, stream2)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.concat(stream1, stream2)
- en: '.forEach(System.out::print);        //prints: 1223'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);        //prints: 1223'
- en: '```'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that the `2` element is present in both original streams, and consequently,
    it is present twice in the resulting stream.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，原始流中存在`2`元素，并且因此在生成的流中出现两次。
- en: generate(Supplier)
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: generate(Supplier)
- en: 'The `Stream<T> generate(Supplier<T> supplier)` static method of the `Stream` interface creates
    an infinite stream, where each element is generated by the provided `Supplier<T>` function.
    Here are two examples:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream<T> generate(Supplier<T> supplier)` `Stream` 接口的静态方法创建一个无限流，其中每个元素由提供的`Supplier<T>`函数生成。以下是两个示例：'
- en: '```java'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream.generate(() -> 1).limit(5)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.generate(() -> 1).limit(5)
- en: '.forEach(System.out::print);       //prints: 11111'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);       //prints: 11111'
- en: Stream.generate(() -> new Random().nextDouble()).limit(5)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.generate(() -> new Random().nextDouble()).limit(5)
- en: '.forEach(System.out::println);     //prints: 0.38575117472619247'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::println);     //prints: 0.38575117472619247'
- en: //        0.5055765386778835
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: //        0.5055765386778835
- en: //        0.6528038976983277
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: //        0.6528038976983277
- en: //        0.4422354489467244
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: //        0.4422354489467244
- en: //        0.06770955839148762
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: //        0.06770955839148762
- en: '```'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Since the stream is infinite, we have added a `limit()` operation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于流是无限的，我们已经添加了`limit()`操作。
- en: of(T... values)
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: of(T... values)
- en: 'The `Stream<T> of(T... values)` method accepts varargs, or an array of values,
    and creates a Stream object with the provided values as the stream elements:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream<T> of(T... values)` 方法接受可变参数或值数组，并使用提供的值作为流元素创建`Stream`对象：'
- en: '```java'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'Stream.of("1 ", 2).forEach(System.out::print);      //prints: 1 2'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'Stream.of("1 ", 2).forEach(System.out::print);      //prints: 1 2'
- en: //Stream<String> stringStream = Stream.of("1 ", 2); //compile error
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: //Stream<String> stringStream = Stream.of("1 ", 2); //compile error
- en: String[] strings = {"1 ", "2"};
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: String[] strings = {"1 ", "2"};
- en: 'Stream.of(strings).forEach(System.out::print);      //prints: 1 2'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.of(strings).forEach(System.out::print);      //输出：1 2
- en: '```'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that in the first line of the preceding code, a `Stream` object accepts
    elements of different types if there is no type specified in the generics of the `Stream` reference
    declaration. In the next line, the generics define the type of the `Stream` object
    as `String`, and the same mix of element types generates a compile error. Generics
    definitely help programmers to avoid many mistakes, and should be used wherever
    possible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述代码的第一行中，如果在`Stream`引用声明的泛型中没有指定类型，则`Stream`对象将接受不同类型的元素。在下一行中，泛型将`Stream`对象的类型定义为`String`，相同的元素类型混合会生成编译错误。泛型绝对有助于程序员避免许多错误，并且应该在可能的地方使用。
- en: 'The `of(T... values)` method can also be used for the concatenation of multiple
    streams. Let''s assume, for example, that we have the following four streams,
    and we would like to concatenate into one:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`of(T... values)`方法也可用于连接多个流。例如，假设我们有以下四个流，并且我们想要将它们连接成一个：'
- en: '```java'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream<Integer> stream1 = Stream.of(1, 2);
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Stream<Integer> stream1 = Stream.of(1, 2);
- en: Stream<Integer> stream2 = Stream.of(2, 3);
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Stream<Integer> stream2 = Stream.of(2, 3);
- en: Stream<Integer> stream3 = Stream.of(3, 4);
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Stream<Integer> stream3 = Stream.of(3, 4);
- en: Stream<Integer> stream4 = Stream.of(4, 5);
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Stream<Integer> stream4 = Stream.of(4, 5);
- en: '```'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We expect the new stream to emit the values `1`, `2`, `2`, `3`, `3`, `4`, `4`,
    and `5`. First, we try the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望新流发出值`1`、`2`、`2`、`3`、`3`、`4`、`4`和`5`。首先，我们尝试以下代码：
- en: '```java'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream.of(stream1, stream2, stream3, stream4)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.of(stream1, stream2, stream3, stream4)
- en: .forEach(System.out::print);
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print);
- en: '//prints: java.util.stream.ReferencePipeline$Head@58ceff1j'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: //输出：java.util.stream.ReferencePipeline$Head@58ceff1j
- en: '```'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The preceding code did not do what we hoped. It treated each stream as an object
    of the `java.util.stream.ReferencePipeline` internal class, which is used in the
    `Stream` interface implementation. So, we have added a `flatMap()` operation that
    converts each stream element into a stream (we will describe it in the *Intermediate
    operations* section):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码并没有达到我们的期望。它将每个流都视为`java.util.stream.ReferencePipeline`内部类的对象，该内部类用于`Stream`接口实现。因此，我们添加了一个`flatMap()`操作，将每个流元素转换为流（我们将在*中间操作*部分中描述它）：
- en: '```java'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream.of(stream1, stream2, stream3, stream4)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.of(stream1, stream2, stream3, stream4)
- en: '.flatMap(e -> e).forEach(System.out::print);   //prints: 12233445'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: .flatMap(e -> e).forEach(System.out::print);   //输出：12233445
- en: '```'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: The function we passed into `flatMap()` as a parameter (`e -> e`) may look like
    it's doing nothing, but that is because each element of the stream is a stream
    already, so we did not need to transform it. By returning an element as the result
    of the `flatMap()` operation, we have told the pipeline to treat it as a `Stream`
    object. That was done, and the expected result was displayed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将作为参数传递给`flatMap()`的函数（`e -> e`）可能看起来好像什么都没做，但这是因为流的每个元素已经是一个流，所以我们不需要对其进行转换。通过将元素作为`flatMap()`操作的结果返回，我们已经告诉管道将其视为`Stream`对象。已经完成了这一点，并且显示了预期的结果。
- en: The Stream.Builder interface
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stream.Builder接口
- en: 'The `Stream.Builder<T> builder()` static method returns an internal (located
    inside the interface `Stream` interface) `Builder` interface that can be used
    to construct a `Stream` object. The `Builder` interface extends the `Consumer`
    interface, and has the following methods:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream.Builder<T> builder()`静态方法返回一个内部（位于`Stream`接口中的）`Builder`接口，可用于构造`Stream`对象。`Builder`接口扩展了`Consumer`接口，并具有以下方法：'
- en: '`void accept(T t)`: Adds an element to the stream (this method comes from the
    `Consumer` interface).'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void accept(T t)`: 将元素添加到流中（此方法来自`Consumer`接口）。'
- en: '`default Stream.Builder<T> add(T t)`: Calls the `accept(T)` method and returns
    `this`, thus allowing chaining `add(T)` methods in a fluent, dot-connected style.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default Stream.Builder<T> add(T t)`: 调用`accept(T)`方法并返回`this`，从而允许以流畅的点连接样式链接`add(T)`方法。'
- en: '`Stream<T> build()`: Transitions this builder from the constructing state to
    the built state. After this method is called, no new elements can be added to
    the stream.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> build()`: 将此构建器从构造状态转换为构建状态。调用此方法后，无法向流中添加新元素。'
- en: 'Using the `add()` method is straightforward:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`add()`方法很简单：
- en: '```java'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream.<String>builder().add("cat").add(" dog").add(" bear")
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.<String>builder().add("cat").add(" dog").add(" bear")
- en: '.build().forEach(System.out::print);  //prints: cat dog bear'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: .build().forEach(System.out::print);  //输出：cat dog bear
- en: '```'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Just notice the `<String>` generics that we have added in front of the `builder()`
    method. This way, we tell the builder that the stream we are creating will have
    `String` type elements. Otherwise, it will add them as `Object` types.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 只需注意我们在`builder()`方法前面添加的`<String>`泛型。这样，我们告诉构建器我们正在创建的流将具有`String`类型的元素。否则，它将将它们添加为`Object`类型。
- en: 'The `accept()` method is used when the builder is passed as a parameter of
    the `Consumer` type, or when you do not need to chain the methods that add the
    elements. For example, here is how the builder is passed in as a `Consumer` object:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建器作为`Consumer`对象传递时，或者不需要链接添加元素的方法时，使用`accept()`方法。例如，以下是构建器作为`Consumer`对象传递的方式：
- en: '```java'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream.Builder<String> builder = Stream.builder();
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.Builder<String> builder = Stream.builder();
- en: List.of("1", "2", "3").stream().forEach(builder);
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: List.of("1", "2", "3").stream().forEach(builder);
- en: 'builder.build().forEach(System.out::print);        //prints: 123'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: builder.build().forEach(System.out::print);        //输出：123
- en: '```'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'There are also cases where there is no need to chain the methods while adding
    the stream elements. The following method receives a list of `String` objects,
    and adds some of them (those that contain the character `a`) to a stream:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些情况不需要在添加流元素时链接方法。以下方法接收`String`对象的列表，并将其中一些对象（包含字符`a`的对象）添加到流中：
- en: '```java'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream<String> buildStream(List<String> values){
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Stream<String> buildStream(List<String> values){
- en: Stream.Builder<String> builder = Stream.builder();
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.Builder<String> builder = Stream.builder();
- en: 'for(String s: values){'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'for(String s: values){'
- en: if(s.contains("a")){
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果(s.contains("a")){
- en: builder.accept(s);
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: builder.accept(s);
- en: '}'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return builder.build();
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: return builder.build();
- en: '}'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that we have added the `<String>` generics the `Stream.Builder` interface
    for the same reason—to tell the builder that the elements we are adding should
    be treated as `String` types.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，出于同样的原因，我们为`Stream.Builder`接口添加了`<String>`泛型，告诉构建器我们添加的元素应该被视为`String`类型。
- en: 'When the preceding method is called, it produces the expected result:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用前面的方法时，它会产生预期的结果：
- en: '```java'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = List.of("cat", " dog", " bear");
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("cat", " dog", " bear");
- en: 'buildStream(list).forEach(System.out::print);        //prints: cat bear'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: buildStream(list).forEach(System.out::print);        //输出：cat bear
- en: '```'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Other classes and interfaces
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类和接口
- en: 'In Java 8, two default methods were added to the `java.util.Collection` interface:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，`java.util.Collection`接口添加了两个默认方法：
- en: '`Stream<E> stream()`: Returns a stream of the elements of this collection.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<E> stream()`: 返回此集合的元素流。'
- en: '`Stream<E> parallelStream()`: Returns (possibly) a parallel stream of the elements
    of this collection. We say possibly because the JVM attempts to split the stream
    into several chunks and process them in parallel (if there are several CPUs) or
    virtually parallel (using the time-sharing of the CPU). This is not always possible;
    it depends, in part, on the nature of the requested processing.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<E> parallelStream()`: 返回（可能）此集合元素的并行流。这里的可能是因为JVM会尝试将流分成几个块并并行处理它们（如果有几个CPU）或虚拟并行处理（使用CPU的时间共享）。这并非总是可能的；这在一定程度上取决于所请求处理的性质。'
- en: 'It means that all of the collection interfaces that extend this interface,
    including `Set` and `List`, have these methods. Here is an example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着扩展此接口的所有集合接口，包括`Set`和`List`，都有这些方法。这是一个例子：
- en: '```java'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Integer> list = List.of(1, 2, 3, 4, 5);
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: List<Integer> list = List.of(1, 2, 3, 4, 5);
- en: 'list.stream().forEach(System.out::print);    //prints: 12345'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().forEach(System.out::print);    //输出：12345
- en: '```'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We will discuss parallel streams further in the *Parallel processing* section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*并行处理*部分进一步讨论并行流。
- en: 'Eight static overloaded `stream()` methods were added to the `java.util.Arrays` class,
    too. They create streams of different types from a corresponding array, or its
    subset:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Arrays`类还添加了八个静态重载的`stream()`方法。它们从相应的数组或其子集创建不同类型的流：'
- en: '`Stream<T> stream(T[] array)`: Creates `Stream` from the provided array.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> stream(T[] array)`: 从提供的数组创建`Stream`。'
- en: '`IntStream stream(int[] array)`: Creates `IntStream` from the provided array.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream stream(int[] array)`: 从提供的数组创建`IntStream`。'
- en: '`LongStream stream(long[] array)`: Creates `LongStream` from the provided array.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LongStream stream(long[] array)`: 从提供的数组创建`LongStream`。'
- en: '`DoubleStream stream(double[] array)`: Creates `DoubleStream` from the provided
    array.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleStream stream(double[] array)`: 从提供的数组创建`DoubleStream`。'
- en: '`Stream<T> stream(T[] array, int startInclusive, int endExclusive)`: Creates
    `Stream` from the specified range of the provided array.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> stream(T[] array, int startInclusive, int endExclusive)`: 从提供的数组的指定范围创建`Stream`。'
- en: '`IntStream stream(int[] array, int startInclusive, int endExclusive)`: Creates
    `IntStream` from the specified range of the provided array.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream stream(int[] array, int startInclusive, int endExclusive)`: 从提供的数组的指定范围创建`IntStream`。'
- en: '`LongStream stream(long[] array, int startInclusive, int endExclusive)`: Creates
    `LongStream` from the specified range of the provided array.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LongStream stream(long[] array, int startInclusive, int endExclusive)`: 从提供的数组的指定范围创建`LongStream`。'
- en: '`DoubleStream stream(double[] array, int startInclusive, int endExclusive)`:
    Creates `DoubleStream` from the specified range of the provided array.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleStream stream(double[] array, int startInclusive, int endExclusive)`:
    从提供的数组的指定范围创建`DoubleStream`。'
- en: 'Here is an example of creating a stream from the subset of an array:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个从数组的子集创建流的示例：
- en: '```java'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int[] arr = {1, 2, 3, 4, 5};
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: int[] arr = {1, 2, 3, 4, 5};
- en: 'Arrays.stream(arr, 2, 4).forEach(System.out::print);    //prints: 34'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Arrays.stream(arr, 2, 4).forEach(System.out::print);    //输出：34
- en: '```'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that we have used the `Stream<T> stream(T[] array, int startInclusive,
    int endExclusive)` method, which means we have created `Stream` and not `IntStream`,
    although all of the elements in the created stream are integers, as in `IntStream`.
    The difference is that `IntStream` provides some numeric-specific operations not
    available in `Stream` (see the *Numeric stream interfaces* section).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了`Stream<T> stream(T[] array, int startInclusive, int endExclusive)`方法，这意味着我们创建了`Stream`而不是`IntStream`，尽管创建的流中的所有元素都是整数，就像`IntStream`一样。不同之处在于，`IntStream`提供了一些数字特定的操作，而`Stream`中没有（请参阅*数字流接口*部分）。
- en: 'The `java.util.Random` class allows us to create numeric streams of pseudorandom
    values:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Random`类允许我们创建伪随机值的数字流：'
- en: '`IntStream ints()` and `LongStream longs()`: Create an unlimited stream of
    pseudorandom values of the corresponding type.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream ints()` 和 `LongStream longs()`: 创建相应类型的无限伪随机值流。'
- en: '`DoubleStream doubles()`: Creates an unlimited stream of pseudorandom double
    values, each between zero (inclusive) and one (exclusive).'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleStream doubles()`: 创建一个无限流的伪随机双精度值，每个值都介于零（包括）和一（不包括）之间。'
- en: '`IntStream ints(long streamSize)` and `LongStream longs(long streamSize)`:
    Create a stream of the specified number of pseudorandom values of the corresponding
    type.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream ints(long streamSize)` 和 `LongStream longs(long streamSize)`: 创建指定数量的相应类型的伪随机值流。'
- en: '`DoubleStream doubles(long streamSize)`: Creates a stream of the specified
    number of pseudorandom double values, each between zero (inclusive) and one (exclusive).'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleStream doubles(long streamSize)`: 创建指定数量的伪随机双精度值流，每个值都介于零（包括）和一（不包括）之间。'
- en: '`IntStream ints(int randomNumberOrigin, int randomNumberBound)`, `LongStream
    longs(long randomNumberOrigin, long randomNumberBound)`, and `DoubleStream doubles(long
    streamSize, double randomNumberOrigin, double randomNumberBound)`: Create an infinite
    stream of pseudorandom values of the corresponding type, each value equal to or
    larger than the first parameter, and smaller than the second parameter.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream ints(int randomNumberOrigin, int randomNumberBound)`, `LongStream
    longs(long randomNumberOrigin, long randomNumberBound)`, 和 `DoubleStream doubles(long
    streamSize, double randomNumberOrigin, double randomNumberBound)`: 创建一个无限流，包含对应类型的伪随机值，每个值大于或等于第一个参数，小于第二个参数。'
- en: 'Here is an example of one of the preceding methods:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述方法的示例之一：
- en: '```java'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: new Random().ints(5, 8)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: new Random().ints(5, 8)
- en: .limit(5)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: .limit(5)
- en: '.forEach(System.out::print);    //prints: 56757'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print);    //打印：56757
- en: '```'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `java.nio.File` class has six static methods to create streams of lines
    and paths:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.File`类有六个静态方法，用于创建行和路径流：'
- en: '`Stream<String> lines(Path path)`: Creates a stream of lines from the file
    specified by the provided path.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<String> lines(Path path)`: 从提供的路径指定的文件创建一行流。'
- en: '`Stream<String> lines(Path path, Charset cs)`: Creates a stream of lines from
    the file specified by the provided path. Bytes from the file are decoded into
    characters using the provided charset.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<String> lines(Path path, Charset cs)`: 从提供的路径指定的文件创建一行流。使用提供的字符集将文件的字节解码为字符。'
- en: '`Stream<Path> list(Path dir)`: Creates a stream of the entries in the specified
    directory.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<Path> list(Path dir)`: 创建指定目录中的条目流。'
- en: '`Stream<Path> walk(Path start, FileVisitOption... options)`: Creates a stream of
    the entries of the file tree rooted at a given starting file.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<Path> walk(Path start, FileVisitOption... options)`: 创建以给定起始文件为根的文件树条目流。'
- en: '`Stream<Path> walk(Path start, int maxDepth, FileVisitOption... options)`:
    Creates a stream of the entries of the file tree rooted at a given starting file
    to the specified depth.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<Path> walk(Path start, int maxDepth, FileVisitOption... options)`:
    创建以给定起始文件为根的文件树条目流，到指定深度。'
- en: '`Stream<Path> find(Path start, int maxDepth, BiPredicate<Path, BasicFileAttributes>
    matcher, FileVisitOption... options)`: Creates a stream of the entries of the
    file tree rooted at a given starting file to the specified depth that match the
    provided predicate.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<Path> find(Path start, int maxDepth, BiPredicate<Path, BasicFileAttributes>
    matcher, FileVisitOption... options)`: 创建以给定起始文件为根的文件树条目流，到指定深度匹配提供的谓词。'
- en: 'Other classes and methods that create streams include:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 其他创建流的类和方法包括：
- en: '`IntStream stream()` of the `java.util.BitSet` class: Creates a stream of indices
    for which `BitSet` contains a bit in the set state.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream stream()` of the `java.util.BitSet` class: 创建一个索引流，其中`BitSet`包含设置状态的位。'
- en: '`Stream<String> lines()` of the `java.io.BufferedReader` class: Creates a stream
    of lines read from the `BufferedReader` object, typically from a file.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<String> lines()` of the `java.io.BufferedReader` class: 创建从`BufferedReader`对象读取的行流，通常来自文件。'
- en: '`Stream<JarEntry> stream()` of the `java.util.jar.JarFile` class: Creates a
    stream of the ZIP file entries.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<JarEntry> stream()` of the `java.util.jar.JarFile` class: 创建ZIP文件条目的流。'
- en: 'default `IntStream chars()` of the `java.lang.CharSequence` interface: Creates
    a stream of `int` zero-extending the `char` values from this sequence.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream chars()` of the `java.lang.CharSequence` interface: 从此序列创建`int`类型的流，零扩展`char`值。'
- en: 'default `IntStream codePoints()` of the `java.lang.CharSequence` interface:
    Creates a stream of code point values from this sequence.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream codePoints()` of the `java.lang.CharSequence` interface: 从此序列创建代码点值的流。'
- en: '`Stream<String> splitAsStream(CharSequence input)` of the `java.util.regex.Pattern` class:
    Creates a stream from the provided sequence around matches of this pattern.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<String> splitAsStream(CharSequence input)` of the `java.util.regex.Pattern`
    class: 创建一个围绕此模式匹配的提供序列的流。'
- en: There is also the `java.util.stream.StreamSupport` class, which contains static,
    low-level utility methods for library developers. That is outside the scope of
    this book.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`java.util.stream.StreamSupport`类，其中包含库开发人员的静态低级实用方法。这超出了本书的范围。
- en: Intermediate operations
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间操作
- en: 'We have already seen how a `Stream` object that represents a source and emits
    elements can be created. As we have mentioned already, the operations (methods)
    provided by the `Stream` interface can be divided into three groups:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建代表源并发出元素的`Stream`对象。正如我们已经提到的，`Stream`接口提供的操作（方法）可以分为三组：
- en: The methods that create a `Stream` object based on a source.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于源创建`Stream`对象的方法。
- en: Intermediate operations that accept a function and produce a `Stream` object
    that emits the same, or modified, values.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受函数并生成发出相同或修改的值的`Stream`对象的中间操作。
- en: Terminal operations that complete the stream processing, close it, and produce
    the result.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端操作完成流处理，关闭它并生成结果。
- en: In this section, we will review the intermediate operations that, in turn, can
    be grouped by their functionalities.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾中间操作，这些操作可以根据其功能进行分组。
- en: Filtering
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤
- en: 'This group includes operations that remove duplicates, skip some of the elements,
    and limit the number of processed elements, only selecting those that are needed:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此组包括删除重复项、跳过一些元素和限制处理元素数量的操作，仅选择所需的元素：
- en: '`Stream<T> distinct()`: Compares stream elements using the `Object.equals(Object)`
    method, and skips the duplicates.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> distinct()`: 使用`Object.equals(Object)`方法比较流元素，并跳过重复项。'
- en: '`Stream<T> skip(long n)`: Ignores the provided number of stream elements that
    are emitted first.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> skip(long n)`: 忽略前面提供的数量的流元素。'
- en: '`Stream<T> limit(long maxSize)`: Allows only the provided number of stream
    elements to be processed.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> limit(long maxSize)`: 仅允许处理提供的流元素数量。'
- en: '`Stream<T> filter(Predicate<T> predicate)`: Allows only those elements that
    result in `true` (when processed by the provided `Predicate` function).'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> filter(Predicate<T> predicate)`: 仅允许通过提供的`Predicate`函数处理的结果为`true`的元素。'
- en: 'Default `Stream<T> dropWhile(Predicate<T> predicate)`: Skips the first elements
    of the stream that result in `true` when processed by the provided `Predicate` function.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '默认`Stream<T> dropWhile(Predicate<T> predicate)`: 跳过流的第一个元素，该元素在通过提供的`Predicate`函数处理时结果为`true`。'
- en: 'Default `Stream<T> takeWhile(Predicate<T> predicate)`: Allows only the first
    elements of the stream that result in `true` (when processed by the provided `Predicate` function)
    to be processed.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '默认`Stream<T> takeWhile(Predicate<T> predicate)`: 仅允许流的第一个元素在通过提供的`Predicate`函数处理时结果为`true`。'
- en: 'The following code demonstrates how the preceding operations work:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了前面的操作是如何工作的：
- en: '```java'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Stream.of("3", "2", "3", "4", "2").distinct()
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Stream.of("3", "2", "3", "4", "2").distinct()
- en: '.forEach(System.out::print);  //prints: 324'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);  //prints: 324'
- en: List<String> list = List.of("1", "2", "3", "4", "5");
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("1", "2", "3", "4", "5");
- en: 'list.stream().skip(3).forEach(System.out::print);         //prints: 45'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 'list.stream().skip(3).forEach(System.out::print);         //prints: 45'
- en: 'list.stream().limit(3).forEach(System.out::print);        //prints: 123'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 'list.stream().limit(3).forEach(System.out::print);        //prints: 123'
- en: list.stream().filter(s -> Objects.equals(s, "2"))
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().filter(s -> Objects.equals(s, "2"))
- en: '.forEach(System.out::print);  //prints: 2'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);  //prints: 2'
- en: list.stream().dropWhile(s -> Integer.valueOf(s) < 3)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().dropWhile(s -> Integer.valueOf(s) < 3)
- en: '.forEach(System.out::print);  //prints: 345'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);  //prints: 345'
- en: list.stream().takeWhile(s -> Integer.valueOf(s) < 3)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().takeWhile(s -> Integer.valueOf(s) < 3)
- en: '.forEach(System.out::print);  //prints: 12'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);  //prints: 12'
- en: '```'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that we were able to reuse the `List<String>` source object, but could
    not reuse the `Stream` object. Once it has been closed, it cannot be reopened.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们能够重用`List<String>`源对象，但无法重用`Stream`对象。一旦关闭，就无法重新打开。
- en: Mapping
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mapping
- en: 'This group includes arguably the most important intermediate operations. They
    are the only intermediate operations that modify the elements of the stream. They
    *map* (transform) the original stream element value to a new one:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这组包括可能是最重要的中间操作。它们是唯一修改流元素的中间操作。它们*map*（转换）原始流元素值为新值：
- en: '`Stream<R> map(Function<T, R> mapper)`: Applies the provided function to each
    element of the `T` type of this stream, and produces a new element value of the `R` type.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<R> map(Function<T, R> mapper)`: 将提供的函数应用于此流的`T`类型的每个元素，并生成`R`类型的新元素值。'
- en: '`IntStream mapToInt(ToIntFunction<T> mapper)`: Converts this stream to an `IntStream`
    of the `Integer` values.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream mapToInt(ToIntFunction<T> mapper)`: 将此流转换为`Integer`值的`IntStream`。'
- en: '`LongStream mapToLong(ToLongFunction<T> mapper)`: Converts this stream to a `LongStream`
    of the `Long` values.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LongStream mapToLong(ToLongFunction<T> mapper)`: 将此流转换为`Long`值的`LongStream`。'
- en: '`DoubleStream mapToDouble(ToDoubleFunction<T> mapper)`: Converts this stream
    to a `DoubleStream` of the `Double` values.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleStream mapToDouble(ToDoubleFunction<T> mapper)`: 将此流转换为`Double`值的`DoubleStream`。'
- en: '`Stream<R> flatMap(Function<T, Stream<R>> mapper)`: Applies the provided function
    to each element of the `T` type of this stream and produces a `Stream<R>` object
    that emits elements of the `R` type.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<R> flatMap(Function<T, Stream<R>> mapper)`: 将提供的函数应用于此流的`T`类型的每个元素，并生成一个发出`R`类型元素的`Stream<R>`对象。'
- en: '`IntStream flatMapToInt(Function<T, IntStream> mapper)`: Converts each element
    of the `T` type to a stream of `Integer` values, using the provided function.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream flatMapToInt(Function<T, IntStream> mapper)`: 使用提供的函数将`T`类型的每个元素转换为`Integer`值流。'
- en: '`LongStream flatMapToLong(Function<T, LongStream> mapper)`: Converts each element
    of the `T` type to a stream of `Long` values, using the provided function.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LongStream flatMapToLong(Function<T, LongStream> mapper)`: 使用提供的函数将`T`类型的每个元素转换为`Long`值流。'
- en: '`DoubleStream flatMapToDouble(Function<T, DoubleStream> mapper)`: Converts
    each element of the `T` type to a stream of `Double` values, using the provided
    function.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DoubleStream flatMapToDouble(Function<T, DoubleStream> mapper)`: 使用提供的函数将`T`类型的每个元素转换为`Double`值流。'
- en: 'The following are examples of the usage of these operations:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些操作的用法示例：
- en: '```java'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = List.of("1", "2", "3", "4", "5");
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("1", "2", "3", "4", "5");
- en: list.stream().map(s -> s + s)
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().map(s -> s + s)
- en: '.forEach(System.out::print);        //prints: 1122334455'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);        //prints: 1122334455'
- en: list.stream().mapToInt(Integer::valueOf)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().mapToInt(Integer::valueOf)
- en: '.forEach(System.out::print);             //prints: 12345'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);             //prints: 12345'
- en: list.stream().mapToLong(Long::valueOf)
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().mapToLong(Long::valueOf)
- en: '.forEach(System.out::print);             //prints: 12345'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);             //prints: 12345'
- en: list.stream().mapToDouble(Double::valueOf)
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().mapToDouble(Double::valueOf)
- en: .mapToObj(Double::toString)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: .mapToObj(Double::toString)
- en: .map(s -> s + " ")
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: .map(s -> s + " ")
- en: '.forEach(System.out::print);//prints: 1.0 2.0 3.0 4.0 5.0'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);//prints: 1.0 2.0 3.0 4.0 5.0'
- en: list.stream().mapToInt(Integer::valueOf)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().mapToInt(Integer::valueOf)
- en: .flatMap(n -> IntStream.iterate(1, i -> i < n, i -> ++i))
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: .flatMap(n -> IntStream.iterate(1, i -> i < n, i -> ++i))
- en: '.forEach(System.out::print);        //prints: 1121231234'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);        //prints: 1121231234'
- en: list.stream().map(Integer::valueOf)
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().map(Integer::valueOf)
- en: .flatMapToInt(n ->
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: .flatMapToInt(n ->
- en: IntStream.iterate(1, i -> i < n, i -> ++i))
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: IntStream.iterate(1, i -> i < n, i -> ++i))
- en: '.forEach(System.out::print);        //prints: 1121231234'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);        //prints: 1121231234'
- en: list.stream().map(Integer::valueOf)
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().map(Integer::valueOf)
- en: .flatMapToLong(n ->
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: .flatMapToLong(n ->
- en: LongStream.iterate(1, i -> i < n, i -> ++i))
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: LongStream.iterate(1, i -> i < n, i -> ++i))
- en: '.forEach(System.out::print);        //prints: 1121231234;'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);        //prints: 1121231234;'
- en: list.stream().map(Integer::valueOf)
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().map(Integer::valueOf)
- en: .flatMapToDouble(n ->
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: .flatMapToDouble(n ->
- en: DoubleStream.iterate(1, i -> i < n, i -> ++i))
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: DoubleStream.iterate(1, i -> i < n, i -> ++i))
- en: .mapToObj(Double::toString)
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: .mapToObj(Double::toString)
- en: .map(s -> s + " ")
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: .map(s -> s + " ")
- en: .forEach(System.out::print);
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print);
- en: '//prints: 1.0 1.0 2.0 1.0 2.0 3.0 1.0 2.0 3.0 4.0'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '//prints: 1.0 1.0 2.0 1.0 2.0 3.0 1.0 2.0 3.0 4.0'
- en: '```'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the preceding examples, in the case of `Double` values, we converted a numeric
    value to a `String`, and added space, so the result will be printed with a space
    between the numbers. These examples are very simple—just conversion with minimal
    processing. But in real life, each `map` or `flatMap` operation can accept a (function
    of any level of complexity) that does something really useful.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，对于`Double`值，我们将数值转换为`String`，并添加空格，因此结果将以空格分隔的形式打印出来。这些示例非常简单——只是进行最小处理的转换。但是在现实生活中，每个`map`或`flatMap`操作都可以接受一个（任何复杂程度的函数）来执行真正有用的操作。
- en: Sorting
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: 'The following two intermediate operations sort the stream elements. Naturally,
    such an operation cannot be finished until all of the elements are emitted, so
    it creates a lot of overhead, slows down performance, and has to be used either
    for the small size streams:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个中间操作对流元素进行排序。自然地，这样的操作直到所有元素都被发射完毕才能完成，因此会产生大量的开销，降低性能，并且必须用于小型流：
- en: '`Stream<T> sorted()`: Sorts the stream elements in a natural order (according
    to their `Comparable` interface implementation).'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> sorted()`: 按照它们的`Comparable`接口实现的自然顺序对流元素进行排序。'
- en: '`Stream<T> sorted(Comparator<T> comparator)`: Sorts the stream elements in
    the order according to the provided `Comparator<T>` object.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream<T> sorted(Comparator<T> comparator)`: 按照提供的`Comparator<T>`对象的顺序对流元素进行排序。'
- en: 'Here is a demo code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是演示代码：
- en: '```java'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = List.of("2", "1", "5", "4", "3");
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("2", "1", "5", "4", "3");
- en: 'list.stream().sorted().forEach(System.out::print);  //prints: 12345'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 'list.stream().sorted().forEach(System.out::print);  //prints: 12345'
- en: list.stream().sorted(Comparator.reverseOrder())
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().sorted(Comparator.reverseOrder())
- en: '.forEach(System.out::print);           //prints: 54321'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);           //prints: 54321'
- en: '```'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Peeking
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Peeking
- en: A `Stream<T> peek(Consumer<T> action)` intermediate operation applies the provided `Consumer` function
    to each stream element and does not change this `Stream` (returns the same element
    value it has received) because the `Consumer` function returns `void` and cannot
    affect the value. This operation is used for debugging.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream<T> peek(Consumer<T> action)`中间操作将提供的`Consumer`函数应用于每个流元素，并且不更改此`Stream`（返回它接收到的相同元素值），因为`Consumer`函数返回`void`，并且不能影响值。此操作用于调试。'
- en: 'The following code shows how it works:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了它的工作原理：
- en: '```java'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = List.of("1", "2", "3", "4", "5");
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("1", "2", "3", "4", "5");
- en: list.stream().peek(s-> {
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().peek(s-> {
- en: if("3".equals(s)){
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: if("3".equals(s)){
- en: System.out.print(3);
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(3);
- en: '}'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}).forEach(System.out::print);  //prints: 123345'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '}).forEach(System.out::print);  //prints: 123345'
- en: '```'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Terminal operations
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终端操作
- en: 'The Terminal operations are the most important operations of a stream pipeline.
    It is easy to accomplish everything without a need for any other operations. We
    have used already the `forEach(Consumer<T>)` Terminal operation to print each
    element. It does not return a value; thus, it is used for its side effects. But
    the `Stream` interface has many more powerful Terminal operations that do return
    values. The central among them is a `collect()` operation, which has two forms, `R
    collect(Collector<T, A, R> collector)` and `R collect(Supplier<R> supplier, BiConsumer<R,
    T> accumulator, BiConsumer<R, R> combiner)`. These allow us to compose practically
    any process that can be applied to a stream. The classic example is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 终端操作是流管道中最重要的操作。不需要任何其他操作就可以轻松完成所有操作。我们已经使用了`forEach(Consumer<T>)`终端操作来打印每个元素。它不返回值；因此，它用于其副作用。但是`Stream`接口还有许多更强大的终端操作，它们会返回值。其中最重要的是`collect()`操作，它有两种形式，`R
    collect(Collector<T, A, R> collector)`和`R collect(Supplier<R> supplier, BiConsumer<R,
    T> accumulator, BiConsumer<R, R> combiner)`。这些允许我们组合几乎可以应用于流的任何过程。经典示例如下：
- en: '```java'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> asList = stringStream.collect(ArrayList::new,
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> asList = stringStream.collect(ArrayList::new,
- en: ArrayList::add,
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayList::add,
- en: ArrayList::addAll);
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: ArrayList::addAll);
- en: '```'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, it is implemented in a way suited for parallel processing. It
    uses the first function to produce a value based on the stream element, accumulates
    the result using the second function, and then combines the accumulated results
    from all of the threads that processed the stream.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它是为并行处理而实现的。它使用第一个函数基于流元素生成值，使用第二个函数累积结果，然后结合处理流的所有线程累积的结果。
- en: However, having only one such generic Terminal operation would force the programmers
    to write the same functions repeatedly. That is why the API authors added the `Collectors` class,
    which generates many specialized `Collector` objects without the need to create
    three functions for every `collect()` operation. In addition to that, the API
    authors added even more specialized Terminal operations, which are much simpler
    and easier to use to the `Stream` interface.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有一个这样的通用终端操作会迫使程序员重复编写相同的函数。这就是为什么API作者添加了`Collectors`类，它可以生成许多专门的`Collector`对象，而无需为每个`collect()`操作创建三个函数。除此之外，API作者还添加了更多专门的终端操作，这些操作更简单，更容易使用`Stream`接口。
- en: In this section, we will review all of the Terminal operation of the `Stream`
    interface, and, in the `Collecting` subsection, look at the vast population of
    `Collector` objects produced by the `Collectors` class.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾`Stream`接口的所有终端操作，并在`Collecting`子部分中查看`Collectors`类生成的大量`Collector`对象的种类。
- en: We will start with the most simple Terminal operation, which allows for processing
    each element of a stream one at a time.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的终端操作开始，它允许逐个处理流的每个元素。
- en: Processing each element
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理每个元素
- en: 'There are two Terminal operations in this group:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组中有两个终端操作：
- en: '`void forEach(Consumer<T> action)`: Applies the provided action (process) for
    each element of the stream.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void forEach(Consumer<T> action)`: 对流的每个元素应用提供的操作（处理）。'
- en: '`void forEachOrdered(Consumer<T> action)`: Applies the provided action (process)
    for each element of the stream in an order defined by the source, regardless of
    whether the stream is sequential or parallel.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void forEachOrdered(Consumer<T> action)`: 对流的每个元素应用提供的操作（处理），其顺序由源定义，无论流是顺序的还是并行的。'
- en: If the order in which you need the elements to be processed is important for
    your application, and it has to be in the order the values were arranged in the
    source, use the second method—especially if can foresee that your code is going
    to be executed on a computer with several CPUs. Otherwise, use the first one,
    as we have done in all our examples.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序对需要处理的元素的顺序很重要，并且必须按照源中值的排列顺序进行处理，那么使用第二种方法是很重要的，特别是如果您可以预见到您的代码将在具有多个CPU的计算机上执行。否则，使用第一种方法，就像我们在所有的例子中所做的那样。
- en: 'It is not unusual to see this operation being used for *any kind* of stream
    processing, especially when the code is written by an inexperienced programmer.
    For the following example, we have created the `Person` class:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作被用于*任何类型*的流处理是很常见的，特别是当代码是由经验不足的程序员编写时。对于下面的例子，我们创建了`Person`类：
- en: '```java'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class Person {
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: class Person {
- en: private int age;
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: private int age;
- en: private String name;
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: private String name;
- en: public Person(int age, String name) {
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: public Person(int age, String name) {
- en: this.name = name;
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: this.name = name;
- en: this.age = age;
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: this.age = age;
- en: '}'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public String getName() { return this.name; }
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: public String getName() { return this.name; }
- en: public int getAge() {return this.age; }
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: public int getAge() {return this.age; }
- en: '@Override'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString() {
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() {
- en: return "Person{" + "name='" + this.name + "'" +
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: return "Person{" + "name='" + this.name + "'" +
- en: '", age=" + age + "}";'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '", age=" + age + "}";'
- en: '}'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We are going to use this class throughout our discussion of Terminal operations.
    For this example, we are going to read comma-separated values (age and name) from
    a file and create `Person` objects. We have placed the following `persons.csv` file
    (**Comma-Separated Values (CSV)**) in the `resources` folder:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在终端操作的讨论中使用这个类。在这个例子中，我们将从文件中读取逗号分隔的值（年龄和姓名），并创建`Person`对象。我们已经将以下`persons.csv`文件（**逗号分隔值（CSV）**）放在`resources`文件夹中：
- en: '```java'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 23 , Ji m
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 23 , Ji m
- en: 2 5 , Bob
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 2 5 , Bob
- en: 15 , Jill
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 15 , Jill
- en: 17 , Bi ll
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 17 , Bi ll
- en: '```'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Notice the spaces that we have added outside and inside of the values. We have
    done it in order to take the opportunity to show you some simple, but very useful,
    tips for working with real-life data. Here is how an inexperienced programmer
    may write the code that reads this file and creates a list of `Person` objects:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们在值的外部和内部添加的空格。我们这样做是为了借此机会向您展示一些简单但非常有用的处理现实数据的技巧。以下是一个经验不足的程序员可能编写的代码，用于读取此文件并创建`Person`对象列表：
- en: '```java'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> persons = new ArrayList<>();
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> persons = new ArrayList<>();
- en: Path path = Paths.get("src/main/resources/persons.csv");
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Path path = Paths.get("src/main/resources/persons.csv");
- en: try (Stream<String> lines = Files.newBufferedReader(path).lines()) {
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: try (Stream<String> lines = Files.newBufferedReader(path).lines()) {
- en: lines.forEach(s -> {
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: lines.forEach(s -> {
- en: String[] arr = s.split(",");
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: String[] arr = s.split(",");
- en: int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));
- en: persons.add(new Person(age, StringUtils.remove(arr[1], ' ')));
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: persons.add(new Person(age, StringUtils.remove(arr[1], ' ')));
- en: '});'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '} catch (IOException ex) {'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (IOException ex) {'
- en: ex.printStackTrace();
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '}'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: persons.stream().forEach(System.out::println);
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: persons.stream().forEach(System.out::println);
- en: '//prints: Person{name=''Jim'', age=23}'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '//prints: Person{name=''Jim'', age=23}'
- en: //        Person{name='Bob', age=25}
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: //        Person{name='Bob', age=25}
- en: //        Person{name='Jill', age=15}
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: //        Person{name='Jill', age=15}
- en: //        Person{name='Bill', age=17}
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: //        Person{name='Bill', age=17}
- en: '```'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You can see that we used the `String` method, `split()`, to break each line
    by a comma that separates the values, and that we have used the `org.apache.commons.lang3.StringUtils` class
    to remove spaces from each value. The preceding code also provides a real-life
    example of the `try-with-resources` construct, which is used to close the `BufferedReader`
    object automatically.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们使用了`String`方法`split()`，通过逗号分隔每一行的值，并且我们使用了`org.apache.commons.lang3.StringUtils`类来移除每个值中的空格。前面的代码还提供了`try-with-resources`结构的真实示例，用于自动关闭`BufferedReader`对象。
- en: Although this code works fine in small examples and on a single-core computer,
    it might create unexpected results with a long stream and parallel processing.
    That is, the reason that lambda expressions require all variables to be final,
    or effectively final, because the same function can be executed in a different
    context.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码在小例子和单核计算机上运行良好，但在长流和并行处理中可能会产生意外的结果。也就是说，lambda表达式要求所有变量都是final的，或者有效地是final的，因为相同的函数可以在不同的上下文中执行。
- en: 'In contrast, here is the correct implementation of the preceding code:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，这是前面代码的正确实现：
- en: '```java'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> persons = new ArrayList<>();
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> persons = new ArrayList<>();
- en: Path path = Paths.get("src/main/resources/persons.csv");
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Path path = Paths.get("src/main/resources/persons.csv");
- en: try (Stream<String> lines = Files.newBufferedReader(path).lines()) {
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: try (Stream<String> lines = Files.newBufferedReader(path).lines()) {
- en: persons = lines.map(s -> s.split(","))
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: persons = lines.map(s -> s.split(","))
- en: .map(arr -> {
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: .map(arr -> {
- en: int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));
- en: return new Person(age, StringUtils.remove(arr[1], ' '));
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: return new Person(age, StringUtils.remove(arr[1], ' '));
- en: '}).collect(Collectors.toList());'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '}).collect(Collectors.toList());'
- en: '} catch (IOException ex) {'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (IOException ex) {'
- en: ex.printStackTrace();
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '}'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: persons.stream().forEach(System.out::println);
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: persons.stream().forEach(System.out::println);
- en: '```'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'To improve readability, one can create a method that does the job of mapping:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性，可以创建一个执行映射工作的方法：
- en: '```java'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public List<Person> createPersons() {
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: public List<Person> createPersons() {
- en: List<Person> persons = new ArrayList<>();
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> persons = new ArrayList<>();
- en: Path path = Paths.get("src/main/resources/persons.csv");
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: Path path = Paths.get("src/main/resources/persons.csv");
- en: try (Stream<String> lines = Files.newBufferedReader(path).lines()) {
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: try (Stream<String> lines = Files.newBufferedReader(path).lines()) {
- en: persons = lines.map(s -> s.split(","))
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: persons = lines.map(s -> s.split(","))
- en: .map(this::createPerson)
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: .map(this::createPerson)
- en: .collect(Collectors.toList());
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.toList());
- en: '} catch (IOException ex) {'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '} catch (IOException ex) {'
- en: ex.printStackTrace();
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ex.printStackTrace();
- en: '}'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return persons;
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: return persons;
- en: '}'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private Person createPerson(String[] arr){
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: private Person createPerson(String[] arr){
- en: int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: int age = Integer.valueOf(StringUtils.remove(arr[0], ' '));
- en: return new Person(age, StringUtils.remove(arr[1], ' '));
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: return new Person(age, StringUtils.remove(arr[1], ' '));
- en: '}'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, we used the `collect()` operation and the `Collector` function
    created by the `Collectors.toList()` method. We will see more of the `Collector`
    functions created by the `Collectors` class in the *Collect* subsection.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们使用了`collect()`操作和`Collectors.toList()`方法创建的`Collector`函数。我们将在*Collect*子部分中看到更多由`Collectors`类创建的`Collector`函数。
- en: Counting all elements
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算所有元素
- en: 'The `long count()` Terminal operation of the `Stream` interface looks straightforward
    and benign. It returns the number of elements in this stream. Those who are used
    to working with collections and arrays may use the `count()` operation without
    thinking twice. Here is an example that proves it works just fine:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`long count()`终端操作的`Stream`接口看起来很简单，也很温和。它返回这个流中的元素数量。习惯于使用集合和数组的人可能会毫不犹豫地使用`count()`操作。下面是一个例子，证明它可以正常工作：'
- en: '```java'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: long count = Stream.of("1", "2", "3", "4", "5")
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: long count = Stream.of("1", "2", "3", "4", "5")
- en: .peek(System.out::print)
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: .peek(System.out::print)
- en: .count();
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: .count();
- en: 'System.out.print(count);                 //prints: 5'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(count);                 //输出：5
- en: '```'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, the code that implements the method count was able to determine
    the stream size without executing all the pipe. The values of elements were not
    printed by the `peek()` operation, which proves that the elements were not emitted.
    But it is not always possible to determine the stream size at the source. Besides,
    the stream may be infinite. So, one has to use `count()` with care.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，实现计数方法的代码能够确定流的大小，而不需要执行整个管道。元素的值并没有被`peek()`操作打印出来，这证明元素并没有被发出。但是并不总是能够在源头确定流的大小。此外，流可能是无限的。因此，必须谨慎使用`count()`。
- en: 'Since we are on the topic of counting elements, we would like to show you another
    possible way to determine the stream size, using the `collect()` operation:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们正在讨论计算元素的话，我们想展示另一种可能的确定流大小的方法，使用`collect()`操作：
- en: '```java'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int count = Stream.of("1", "2", "3", "4", "5")
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: int count = Stream.of("1", "2", "3", "4", "5")
- en: '.peek(System.out::print)         //prints: 12345'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: .peek(System.out::print)         //输出：12345
- en: .collect(Collectors.counting());
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.counting());
- en: 'System.out.println(count);                //prints: 5'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(count);                //输出：5
- en: '```'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'You can see that the implementation of the `collect()` operation does not even
    attempt to calculate the stream size at the source (because, as you can see, the
    pipe was fully executed and each element was printed by the `peek()` operation).
    This is because the `collect()` operation is not as specialized as the `count()` operation.
    It just applies the passed-in collector to the stream, and the collector counts
    the elements provided to it by the `collect()` operation. You could consider this
    an example of bureaucratic myopia: every operator does its job as expected, but
    the overall performance is wanting.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到`collect()`操作的实现甚至没有尝试在源头计算流的大小（因为，正如你所看到的，管道已经完全执行，并且每个元素都被`peek()`操作打印出来）。这是因为`collect()`操作不像`count()`操作那样专门化。它只是将传入的收集器应用于流，而收集器则计算由`collect()`操作提供给它的元素。你可以将这看作是官僚近视的一个例子：每个操作符都按预期工作，但整体性能仍然有所欠缺。
- en: Matching all, any, or none
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匹配所有、任意或没有
- en: 'There are three (seemingly very similar) Terminal operations that allow us
    to asses whether all, any, or none of the stream elements have a certain value:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个（看起来非常相似的）终端操作，允许我们评估流中的所有、任意或没有元素是否具有特定值：
- en: '`boolean allMatch(Predicate<T> predicate)`: Returns `true` when each of this
    stream elements returns `true`, when used as a parameter of the provided `Predicate<T>`
    function'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean allMatch(Predicate<T> predicate)`: 当流中的每个元素返回`true`时，作为提供的`Predicate<T>`函数的参数时返回`true`。'
- en: '`boolean anyMatch(Predicate<T> predicate)`: Returns `true` when one of this
    stream elements returns `true`, when used as a parameter of the provided `Predicate<T>` function'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean anyMatch(Predicate<T> predicate)`: 当流中的一个元素返回`true`时，作为提供的`Predicate<T>`函数的参数时返回`true`。'
- en: '`boolean noneMatch(Predicate<T> predicate)`: Returns `true` when none of the
    stream elements return `true`, when used as a parameter of the provided `Predicate<T>` function.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean noneMatch(Predicate<T> predicate)`: 当流中没有元素返回`true`时，作为提供的`Predicate<T>`函数的参数时返回`true`。'
- en: 'The following are examples of their usage:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它们的使用示例：
- en: '```java'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = List.of("1", "2", "3", "4", "5");
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("1", "2", "3", "4", "5");
- en: boolean found = list.stream()
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: boolean found = list.stream()
- en: '.peek(System.out::print)          //prints: 123'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: .peek(System.out::print)          //输出：123
- en: .anyMatch(e -> "3".equals(e));
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: .anyMatch(e -> "3".equals(e));
- en: 'System.out.print(found);                  //prints: true   <= line 5'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(found);                  //输出：true   <= 第5行
- en: found = list.stream()
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: found = list.stream()
- en: '.peek(System.out::print)          //prints: 12345'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: .peek(System.out::print)          //输出：12345
- en: .anyMatch(e -> "0".equals(e));
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: .anyMatch(e -> "0".equals(e));
- en: 'System.out.print(found);                  //prints: false'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(found);                  //输出：false
- en: boolean noneMatches = list.stream()
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: boolean noneMatches = list.stream()
- en: '.peek(System.out::print)          //prints: 123'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: .peek(System.out::print)          //输出：123
- en: .noneMatch(e -> "3".equals(e));
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: .noneMatch(e -> "3".equals(e));
- en: 'System.out.print(noneMatches);            //prints: false'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(noneMatches);            //输出：false
- en: noneMatches = list.stream()
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: noneMatches = list.stream()
- en: '.peek(System.out::print)          //prints: 12345'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: .peek(System.out::print)          //输出：12345
- en: .noneMatch(e -> "0".equals(e));
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: .noneMatch(e -> "0".equals(e));
- en: 'System.out.print(noneMatches);            //prints: true  <= line 17'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.print(noneMatches);            //输出：true  <= 第17行
- en: boolean allMatch = list.stream()
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: boolean allMatch = list.stream()
- en: '.peek(System.out::print)          //prints: 1'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: .peek(System.out::print)          //输出：1
- en: .allMatch(e -> "3".equals(e));
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: .allMatch(e -> "3".equals(e));
- en: 'System.out.print(allMatch);               //prints: false'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.print(allMatch);               //prints: false'
- en: '```'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Let's look at the results of the preceding example more closely. Each of these
    operations triggers the stream pipe execution, and at least one element of the
    stream is processed every time. But look at the `anyMatch()` and `noneMatch()`
    operations. Line 5 states that there is at least one element equal to `3`. The
    result was returned *after only three first elements* had been processed. Line
    17 states that there was no element equal to `0` *after all of the elements* of
    the stream had been processed.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下前面示例的结果。这些操作中的每一个都触发了流管道的执行，每次至少处理流的一个元素。但是看看`anyMatch()`和`noneMatch()`操作。第5行说明至少有一个元素等于`3`。结果是在*处理了前三个元素之后*返回的。第17行说明在*处理了流的所有元素*之后，没有元素等于`0`。
- en: The question is, which of these two operations should you when you use would
    like to know whether the stream *does not contain* the `v` value? If `noneMatch()`
    is used, *all of the elements are going to be processed*. But if `anyMatch()`
    is used, all of the elements are going to be processed *only if there is no* `v`* value*
    in the stream. It seems that the `noneMatch()` operation is useless, because when
    `anyMatch()` returns `true`, it means the same as when `noneMatch()` returns `false`,
    while the `anyMatch()` operation achieves it with fewer elements processed. This
    difference grows in significance with the growth of the stream size and the chance
    that there is an element with the `v` value. It seems that the only reason for
    having the `noneMatch()` operation is for code readability, when processing time
    is not important, because the stream size is small.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，当您想要知道流*不包含*`v`值时，这两个操作中的哪一个应该使用？如果使用`noneMatch()`，*所有元素都将被处理*。但是如果使用`anyMatch()`，只有在流中没有`v`*值*时，所有元素才会被处理。似乎`noneMatch()`操作是无用的，因为当`anyMatch()`返回`true`时，它的含义与`noneMatch()`返回`false`相同，而`anyMatch()`操作只需处理更少的元素即可实现。随着流大小的增长和存在`v`值的机会增加，这种差异变得更加重要。似乎`noneMatch()`操作的唯一原因是代码可读性，当处理时间不重要时，因为流大小很小。
- en: The `allMatch()` operation does not have an alternative, and, similar to `anyMatch()`,
    either returns when the first non-matching element is encountered or requires
    processing all of the stream elements.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '`allMatch()`操作没有替代方案，与`anyMatch()`类似，当遇到第一个不匹配的元素时返回，或者需要处理所有流元素。'
- en: Finding any or first
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找任何或第一个
- en: 'The following Terminal operations allow us to find any, or the first, element
    of the stream:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 以下终端操作允许我们找到流的任何元素或第一个元素：
- en: '`Optional<T> findAny()`: Returns `Optional` with the value of any element of
    the stream, or an empty `Optional` if the stream is empty.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T> findAny()`: 返回流的任何元素的值的`Optional`，如果流为空，则返回一个空的`Optional`。'
- en: '`Optional<T> findFirst()`: Returns `Optional` with the value of the first element
    of the stream, or an empty `Optional` if the stream is empty.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T> findFirst()`: 返回流的第一个元素的值的`Optional`，如果流为空，则返回一个空的`Optional`。'
- en: 'The following example illustrates these operations:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了这些操作：
- en: '```java'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = List.of("1", "2", "3", "4", "5");
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("1", "2", "3", "4", "5");
- en: Optional<String> result = list.stream().findAny();
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: Optional<String> result = list.stream().findAny();
- en: 'System.out.println(result.isPresent());    //prints: true'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(result.isPresent());    //prints: true'
- en: 'System.out.println(result.get());          //prints: 1'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(result.get());          //prints: 1'
- en: result = list.stream().filter(e -> "42".equals(e)).findAny();
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: result = list.stream().filter(e -> "42".equals(e)).findAny();
- en: 'System.out.println(result.isPresent());    //prints: true'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(result.isPresent());    //prints: true'
- en: //System.out.println(result.get());        //NoSuchElementException
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: //System.out.println(result.get());        //NoSuchElementException
- en: result = list.stream().findFirst();
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: result = list.stream().findFirst();
- en: 'System.out.println(result.isPresent());    //prints: true'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(result.isPresent());    //prints: true'
- en: 'System.out.println(result.get());          //prints: 1'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(result.get());          //prints: 1'
- en: '```'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, they return the same results. That is because we are executing
    the pipe in a single thread. The differences between these two operations are
    more prominent in parallel processing. When the stream is broken into several
    parts for parallel processing, the `findFirst()` operation always returns the
    first element of the stream if the stream is not empty, while the `findAny()` operation
    returns the first element only in one of the processing threads.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它们返回相同的结果。这是因为我们在单个线程中执行管道。这两个操作之间的差异在并行处理中更加显著。当流被分成几个部分进行并行处理时，如果流不为空，`findFirst()`操作总是返回流的第一个元素，而`findAny()`操作只在一个处理线程中返回第一个元素。
- en: Let's discuss the `java.util.Optional` class in more detail.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地讨论`java.util.Optional`类。
- en: Class Optional
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Optional类
- en: 'The object of `java.util.Optional` is used to avoid returning `null`, as it
    may cause a `NullPointerException`. Instead, an `Optional` object provides methods
    that can be used to check the value presence and to substitute it if there is
    no value. For example:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Optional`对象用于避免返回`null`，因为它可能会导致`NullPointerException`。相反，`Optional`对象提供了可以用来检查值是否存在并在没有值的情况下替换它的方法。例如：'
- en: '```java'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = List.of("1", "2", "3", "4", "5");
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("1", "2", "3", "4", "5");
- en: String result = list.stream().filter(e -> "42".equals(e))
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: String result = list.stream().filter(e -> "42".equals(e))
- en: .findAny().or(() -> Optional.of("Not found")).get();
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: .findAny().or(() -> Optional.of("Not found")).get();
- en: 'System.out.println(result);                       //prints: Not found'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(result);                       //prints: Not found'
- en: result = list.stream().filter(e -> "42".equals(e))
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: result = list.stream().filter(e -> "42".equals(e))
- en: .findAny().orElse("Not found");
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: .findAny().orElse("Not found");
- en: 'System.out.println(result);                        //prints: Not found'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(result);                        //prints: Not found'
- en: Supplier<String> trySomethingElse = () -> {
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: Supplier<String> trySomethingElse = () -> {
- en: //Code that tries something else
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: //尝试其他操作的代码
- en: return "43";
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: return "43";
- en: '};'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: result = list.stream().filter(e -> "42".equals(e))
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: result = list.stream().filter(e -> "42".equals(e))
- en: .findAny().orElseGet(trySomethingElse);
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: .findAny().orElseGet(trySomethingElse);
- en: 'System.out.println(result);                          //prints: 43'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(result);                          //prints: 43'
- en: list.stream().filter(e -> "42".equals(e))
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().filter(e -> "42".equals(e))
- en: .findAny().ifPresentOrElse(System.out::println,
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: .findAny().ifPresentOrElse(System.out::println,
- en: '() -> System.out.println("Not found"));  //prints: Not found'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '() -> System.out.println("Not found"));  //prints: Not found'
- en: '```'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, if the `Optional` object is empty, then:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 'As you can see, if the `Optional` object is empty, then:'
- en: The `or()` method of the `Optional` class allows for returning an alternative
    `Optional` object (with a value).
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The `or()` method of the `Optional` class allows for returning an alternative
    `Optional` object (with a value).
- en: The `orElse()` method allows for returning an alternative value.
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The `orElse()` method allows for returning an alternative value.
- en: The `orElseGet()` method allows for providing the `Supplier` function, which
    returns an alternative value.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The `orElseGet()` method allows for providing the `Supplier` function, which
    returns an alternative value.
- en: 'The `ifPresentOrElse()` method allows for providing two functions: one that
    consumes the value from the `Optional` object, and another that does something
    if the `Optional` object is empty.'
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'The `ifPresentOrElse()` method allows for providing two functions: one that
    consumes the value from the `Optional` object, and another that does something
    if the `Optional` object is empty.'
- en: Min and max
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Min and max
- en: 'The following Terminal operations return the minimum or maximum value of the
    stream elements, if present:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 'The following Terminal operations return the minimum or maximum value of the
    stream elements, if present:'
- en: '`Optional<T> min`(Comparator<T> comparator): Returns the minimum element of
    this stream, using the provided Comparator object.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T> min`(Comparator<T> comparator): Returns the minimum element of
    this stream, using the provided Comparator object.'
- en: '`Optional<T> max`(Comparator<T> comparator): Returns the maximum element of
    this stream, using the provided Comparator object.'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T> max`(Comparator<T> comparator): Returns the maximum element of
    this stream, using the provided Comparator object.'
- en: 'Here is the demonstration code:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 'Here is the demonstration code:'
- en: '```java'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = List.of("a", "b", "c", "c", "a");
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("a", "b", "c", "c", "a");
- en: String min = list.stream().min(Comparator.naturalOrder()).orElse("0");
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: String min = list.stream().min(Comparator.naturalOrder()).orElse("0");
- en: 'System.out.println(min);     //prints: a'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(min);     //prints: a'
- en: String max = list.stream().max(Comparator.naturalOrder()).orElse("0");
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: String max = list.stream().max(Comparator.naturalOrder()).orElse("0");
- en: 'System.out.println(max);     //prints: c'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(max);     //prints: c'
- en: '```'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, in the case of non-numerical values, the minimum element is
    the one that is first (when ordered from the left to the right), according to
    the provided comparator; the maximum, accordingly, is the last element. In the
    case of numeric values, the minimum and maximum are just that—the biggest and
    the smallest number among the stream elements:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 'As you can see, in the case of non-numerical values, the minimum element is
    the one that is first (when ordered from the left to the right), according to
    the provided comparator; the maximum, accordingly, is the last element. In the
    case of numeric values, the minimum and maximum are just that—the biggest and
    the smallest number among the stream elements:'
- en: '```java'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int mn = Stream.of(42, 33, 77).min(Comparator.naturalOrder()).orElse(0);
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: int mn = Stream.of(42, 33, 77).min(Comparator.naturalOrder()).orElse(0);
- en: 'System.out.println(mn);    //prints: 33'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(mn);    //prints: 33'
- en: int mx = Stream.of(42, 33, 77).max(Comparator.naturalOrder()).orElse(0);
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: int mx = Stream.of(42, 33, 77).max(Comparator.naturalOrder()).orElse(0);
- en: 'System.out.println(mx);    //prints: 77'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(mx);    //prints: 77'
- en: '```'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Let''s look at another example, assuming that there is a `Person` class:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 'Let''s look at another example, assuming that there is a `Person` class:'
- en: '```java'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class Person {
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: class Person {
- en: private int age;
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: private int age;
- en: private String name;
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: private String name;
- en: public Person(int age, String name) {
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: public Person(int age, String name) {
- en: this.age = age;
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: this.age = age;
- en: this.name = name;
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: this.name = name;
- en: '}'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int getAge() { return this.age; }
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: public int getAge() { return this.age; }
- en: public String getName() { return this.name; }
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: public String getName() { return this.name; }
- en: '@Override'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString() {
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() {
- en: return "Person{name:" + this.name + ",age:" + this.age + "}";
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: return "Person{name:" + this.name + ",age:" + this.age + "}";
- en: '}'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The task is to find the oldest person in the following list:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 'The task is to find the oldest person in the following list:'
- en: '```java'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> persons = List.of(new Person(23, "Bob"),
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> persons = List.of(new Person(23, "Bob"),
- en: new Person(33, "Jim"),
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(33, "Jim"),
- en: new Person(28, "Jill"),
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(28, "Jill"),
- en: new Person(27, "Bill"));
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(27, "Bill"));
- en: '```'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'In order to do that, we can create the following `Compartor<Person>`:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 'In order to do that, we can create the following `Compartor<Person>`:'
- en: '```java'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Comparator<Person> perComp = (p1, p2) -> p1.getAge() - p2.getAge();
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: Comparator<Person> perComp = (p1, p2) -> p1.getAge() - p2.getAge();
- en: '```'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Then, using this comparator, we can find the oldest person:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 'Then, using this comparator, we can find the oldest person:'
- en: '```java'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person theOldest = persons.stream().max(perComp).orElse(null);
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: Person theOldest = persons.stream().max(perComp).orElse(null);
- en: 'System.out.println(theOldest);  //prints: Person{name:Jim,age:33}'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(theOldest);  //prints: Person{name:Jim,age:33}'
- en: '```'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The toArray() operation
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: The toArray() operation
- en: 'These two Terminal operations generate an array that contains the stream elements:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 'These two Terminal operations generate an array that contains the stream elements:'
- en: '`Object[] toArray()` : Creates an array of objects; each object is an element
    of this stream.'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object[] toArray()` : Creates an array of objects; each object is an element
    of this stream.'
- en: '`A[] toArray(IntFunction<A[]> generator)`: Creates an array of the stream elements
    using the provided function.'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`A[] toArray(IntFunction<A[]> generator)`: Creates an array of the stream elements
    using the provided function.'
- en: 'Let''s look at an example:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 'Let''s look at an example:'
- en: '```java'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = List.of("a", "b", "c");
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("a", "b", "c");
- en: Object[] obj = list.stream().toArray();
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: Object[] obj = list.stream().toArray();
- en: 'Arrays.stream(obj).forEach(System.out::print);    //prints: abc'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 'Arrays.stream(obj).forEach(System.out::print);    //prints: abc'
- en: String[] str = list.stream().toArray(String[]::new);
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: String[] str = list.stream().toArray(String[]::new);
- en: 'Arrays.stream(str).forEach(System.out::print);    //prints: abc'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 'Arrays.stream(str).forEach(System.out::print);    //prints: abc'
- en: '```'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The first example is straightforward. It converts elements to an array of the
    same type. As for the second example, the representation of `IntFunction` as `String[]::new`
    is probably not obvious, so let's walk through it.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: The first example is straightforward. It converts elements to an array of the
    same type. As for the second example, the representation of `IntFunction` as `String[]::new`
    is probably not obvious, so let's walk through it.
- en: '`String[]::new` is a method reference that represents the following lambda
    expression:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '`String[]::new` is a method reference that represents the following lambda
    expression:'
- en: '```java'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String[] str = list.stream().toArray(i -> new String[i]);
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串[] str = list.stream().toArray(i -> new String[i]);
- en: 'Arrays.stream(str).forEach(System.out::print);    //prints: abc'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: Arrays.stream(str).forEach(System.out::print);    //打印：abc
- en: '```'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And that is already `IntFunction<String[]>`, which, according to its documentation,
    accepts an `int` parameter and returns the result of the specified type. It can
    be defined by using an anonymous class, as follows:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是`IntFunction<String[]>`，根据其文档，它接受一个`int`参数并返回指定类型的结果。可以通过使用匿名类来定义，如下所示：
- en: '```java'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: IntFunction<String[]> intFunction = new IntFunction<String[]>() {
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: IntFunction<String[]> intFunction = new IntFunction<String[]>() {
- en: '@Override'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String[] apply(int i) {
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: public String[] apply(int i) {
- en: return new String[i];
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: return new String[i];
- en: '}'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '```'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'You may recall (from [Chapter 13](3d6ae5fa-f48e-44e2-ae03-62dae2f78401.xhtml),
    *Java Collections*) how we converted a collection to an array:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得（来自[第13章](3d6ae5fa-f48e-44e2-ae03-62dae2f78401.xhtml)，*Java集合*）我们如何将集合转换为数组：
- en: '```java'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: str = list.toArray(new String[list.size()]);
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: str = list.toArray(new String[list.size()]);
- en: 'Arrays.stream(str).forEach(System.out::print);    //prints: abc'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: Arrays.stream(str).forEach(System.out::print);    //打印：abc
- en: '```'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: You can see that the `toArray()` operation of the `Stream` interface has a very
    similar signature, except that it accepts a function, instead of just an array.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`Stream`接口的`toArray()`操作具有非常相似的签名，只是它接受一个函数，而不仅仅是一个数组。
- en: The reduce operation
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: reduce操作
- en: This Terminal operation is called *reduce* because it processes all of the stream
    elements and produces one value. It *reduces* all of the stream elements to one
    value. But this is not the only operation that does it. The *collect* operation
    reduces all of the values of the stream element into one result, too. And, in
    a way, all Terminal operations reduce. They produce one value after processing
    of all the elements.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这个终端操作被称为*reduce*，因为它处理所有流元素并产生一个值。它将所有流元素减少为一个值。但这不是唯一的操作。*collect*操作也将流元素的所有值减少为一个结果。而且，在某种程度上，所有终端操作都会减少。它们在处理所有元素后产生一个值。
- en: So, you may look at *reduce* and *collect* as synonyms that help to add structure
    and classification to many operations available in the `Stream` interface. Also,
    the operations in the *reduce* group can be viewed as specialized versions of
    the *collect* operation, because `collect()` can be tailored to provide the same
    functionality, too.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以将*reduce*和*collect*视为帮助为`Stream`接口中提供的许多操作添加结构和分类的同义词。此外，*reduce*组中的操作可以被视为*collect*操作的专门版本，因为`collect()`也可以被定制以提供相同的功能。
- en: 'With that, let''s look at the group of *reduce* operations:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，让我们看看*reduce*操作组：
- en: '`Optional<T> reduce(BinaryOperator<T> accumulator)`: Reduces the elements of
    this stream by using the provided associative function that defines the logic
    of the element aggregation. Returns `Optional` with the reduced value, if available.'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<T> reduce(BinaryOperator<T> accumulator)`: 使用提供的定义元素聚合逻辑的可关联函数来减少此流的元素。如果可用，返回带有减少值的`Optional`。'
- en: '`T reduce(T identity, BinaryOperator<T> accumulator)`: Provides the same functionality
    as the previous `reduce()` version, but with the `identity` parameter used as the initial
    value for an accumulator, or a default value, if a stream is empty.'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T reduce(T identity, BinaryOperator<T> accumulator)`: 提供与先前`reduce()`版本相同的功能，但使用`identity`参数作为累加器的初始值，或者如果流为空则使用默认值。'
- en: '`U reduce(U identity, BiFunction<U,T,U> accumulator, BinaryOperator<U> combiner)`:
    Provides the same functionality as the previous `reduce()` version, but, in addition,
    uses the `combiner` function to aggregate the results when this operation is applied
    to a parallel stream. If the stream is not parallel, the combiner function is
    not used.'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`U reduce(U identity, BiFunction<U,T,U> accumulator, BinaryOperator<U> combiner)`:
    提供与先前`reduce()`版本相同的功能，但另外使用`combiner`函数在应用于并行流时聚合结果。如果流不是并行的，则不使用组合器函数。'
- en: 'For a demonstration of the `reduce()` operation, we are going to use the same `Person` class
    that that we before:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`reduce()`操作，我们将使用之前的`Person`类：
- en: '```java'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class Person {
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 类Person {
- en: private int age;
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: private int age;
- en: private String name;
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: private String name;
- en: public Person(int age, String name) {
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: public Person(int age, String name) {
- en: this.age = age;
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: this.age = age;
- en: this.name = name;
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: this.name = name;
- en: '}'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public int getAge() { return this.age; }
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: public int getAge() { return this.age; }
- en: public String getName() { return this.name; }
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: public String getName() { return this.name; }
- en: '@Override'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString() {
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() {
- en: return "Person{name:" + this.name + ",age:" + this.age + "}";
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: return "Person{name:" + this.name + ",age:" + this.age + "}";
- en: '}'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We are also going to use the same list of `Person` objects as the source for
    our stream examples:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用相同的`Person`对象列表作为我们流示例的来源：
- en: '```java'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> list = List.of(new Person(23, "Bob"),
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list = List.of(new Person(23, "Bob"),
- en: new Person(33, "Jim"),
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(33, "Jim"),
- en: new Person(28, "Jill"),
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(28, "Jill"),
- en: new Person(27, "Bill"));
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(27, "Bill"));
- en: '```'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now, using the `reduce()` operation, let''s find the oldest person in this
    list:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`reduce()`操作，让我们找到此列表中年龄最大的人：
- en: '```java'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person theOldest = list.stream()
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: Person theOldest = list.stream()
- en: '.reduce((p1, p2) -> p1.getAge() > p2.getAge() ? p1 : p2).orElse(null);'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '.reduce((p1, p2) -> p1.getAge() > p2.getAge() ? p1 : p2).orElse(null);'
- en: 'System.out.println(theOldest);         //prints: Person{name:Jim,age:33}'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(theOldest);         //打印：Person{name:Jim,age:33}
- en: '```'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The implementation is somewhat surprising, isn't it? We were talking about the
    "accumulator," but we did not accumulate anything. We just compared all of the
    stream elements. Well, apparently, the accumulator saves the result of the comparison
    and provides it as the first parameter for the next comparison (with the next
    element). One could say that the accumulator, in this case, accumulates the results
    of all previous comparisons. In any case, it does the job we wanted it to do.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现有点令人惊讶，不是吗？我们在谈论“累加器”，但我们没有累加任何东西。我们只是比较了所有的流元素。显然，累加器保存了比较的结果，并将其作为下一个比较（与下一个元素）的第一个参数提供。可以说，在这种情况下，累加器累积了所有先前比较的结果。无论如何，它完成了我们希望它完成的工作。
- en: 'Let''s now accumulate something explicitly. Let''s assemble all of the names
    from the list of people in one comma-separated list:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们明确地累积一些东西。让我们将人员名单中的所有名称组合成一个逗号分隔的列表：
- en: '```java'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String allNames = list.stream().map(p->p.getName())
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: String allNames = list.stream().map(p->p.getName())
- en: .reduce((n1, n2) -> n1 + ", " + n2).orElse(null);
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: .reduce((n1, n2) -> n1 + "，" + n2).orElse(null);
- en: 'System.out.println(allNames);            //prints: Bob, Jim, Jill, Bill'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(allNames);            //打印：Bob, Jim, Jill, Bill
- en: '```'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The notion of accumulation, makes a bit more sense in this case, doesn't it?
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，积累的概念更有意义，不是吗？
- en: 'Now, let''s use the identity value to provide an initial value:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用身份值提供一个初始值：
- en: '```java'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String allNames = list.stream().map(p->p.getName())
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: String allNames = list.stream().map(p->p.getName())
- en: '.reduce("All names: ", (n1, n2) -> n1 + ", " + n2);'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: .reduce("所有名称：", (n1，n2) -> n1 + "，" + n2);
- en: 'System.out.println(allNames);       //All names: , Bob, Jim, Jill, Bill'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(allNames);       //所有名称：，Bob, Jim, Jill, Bill
- en: '```'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice that this version of the `reduce()` operation returns the value, not
    the `Optional` object. That is because, by providing the initial value, we guarantee
    that this value will be present in the result, even if the stream turns out to
    be empty.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个版本的`reduce()`操作返回值，而不是`Optional`对象。这是因为通过提供初始值，我们保证该值将出现在结果中，即使流为空。
- en: 'But the resulting string does not look as pretty as we had hoped. Apparently,
    the provided initial value is treated as any other stream element, and a comma
    is added after it by the accumulator we created. To make the result look pretty
    again, we could use the first version of the `reduce()` operation again, and add
    the initial value this way:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，结果字符串看起来并不像我们希望的那样漂亮。显然，提供的初始值被视为任何其他流元素，并且累加器创建的后面添加了逗号。为了使结果再次看起来漂亮，我们可以再次使用`reduce()`操作的第一个版本，并通过这种方式添加初始值：
- en: '```java'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'String allNames = "All names: " + list.stream().map(p->p.getName())'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: String allNames = "所有名称：" + list.stream().map(p->p.getName())
- en: .reduce((n1, n2) -> n1 + ", " + n2).orElse(null);
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: .reduce((n1, n2) -> n1 + "，" + n2).orElse(null);
- en: 'System.out.println(allNames);         //All names: Bob, Jim, Jill, Bill'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(allNames);         //所有名称：Bob, Jim, Jill, Bill
- en: '```'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We have decided to use a space as a separator, instead of a comma, for demonstration
    purposes:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定使用空格作为分隔符，而不是逗号，以进行演示：
- en: '```java'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String allNames = list.stream().map(p->p.getName())
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: String allNames = list.stream().map(p->p.getName())
- en: .reduce("All names:", (n1, n2) -> n1 + " " + n2);
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: .reduce("所有名称：", (n1, n2) -> n1 + " " + n2);
- en: 'System.out.println(allNames);        //All names: Bob, Jim, Jill, Bill'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(allNames);        //所有名称：Bob, Jim, Jill, Bill
- en: '```'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Now, the result looks better. While demonstrating the `collect()` operation
    in the next subsection, we will show you another way to create a comma-separated
    list of values with a prefix.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果看起来更好了。在下一小节中演示`collect()`操作时，我们将向您展示另一种使用前缀创建逗号分隔值列表的方法。
- en: 'Now, let''s look at how to use the third form of the `reduce()` operation—the
    one with three parameters, the last one is called a combiner. Adding the combiner
    to the preceding `reduce()` operation does not change the result:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`reduce()`操作的第三种形式——具有三个参数的形式，最后一个称为组合器。将组合器添加到前面的`reduce()`操作中不会改变结果：
- en: '```java'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String allNames = list.stream().map(p->p.getName())
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: String allNames = list.stream().map(p->p.getName())
- en: .reduce("All names:", (n1, n2) -> n1 + " " + n2,
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: .reduce("所有名称：", (n1, n2) -> n1 + " " + n2,
- en: (n1, n2) -> n1 + " " + n2 );
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: (n1, n2) -> n1 + " " + n2 );
- en: 'System.out.println(allNames);          //All names: Bob, Jim, Jill, Bill'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(allNames);          //所有名称：Bob, Jim, Jill, Bill
- en: '```'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: That is because the stream is not parallel, and the combiner is used only with
    a parallel stream.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为流不是并行的，并且组合器仅与并行流一起使用。
- en: 'If we make the stream parallel, the result changes:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使流并行，结果会改变：
- en: '```java'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String allNames = list.parallelStream().map(p->p.getName())
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: String allNames = list.parallelStream().map(p->p.getName())
- en: .reduce("All names:", (n1, n2) -> n1 + " " + n2,
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: .reduce("所有名称：", (n1, n2) -> n1 + " " + n2,
- en: (n1, n2) -> n1 + " " + n2 );
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: (n1, n2) -> n1 + " " + n2 );
- en: System.out.println(allNames);
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(allNames);
- en: '//All names: Bob All names: Jim All names: Jill All names: Bill'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: //所有名称：Bob 所有名称：Jim 所有名称：Jill 所有名称：Bill
- en: '```'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Apparently, for a parallel stream, the sequence of elements is broken into
    subsequences, each being processed independently; their results are aggregated
    by the combiner. When doing so, the combiner adds the initial value (identity)
    to each of the results. Even if we remove the combiner, the result of the parallel
    stream processing remains the same, because a default combiner behavior is provided:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，对于并行流，元素序列被分成子序列，每个子序列都是独立处理的；它们的结果由组合器聚合。这样做时，组合器将初始值（身份）添加到每个结果中。即使我们删除组合器，并行流处理的结果仍然是相同的，因为提供了默认的组合器行为：
- en: '```java'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: String allNames = list.parallelStream().map(p->p.getName())
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: String allNames = list.parallelStream().map(p->p.getName())
- en: .reduce("All names:", (n1, n2) -> n1 + " " + n2);
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: .reduce("所有名称：", (n1, n2) -> n1 + " " + n2);
- en: System.out.println(allNames);
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(allNames);
- en: '//All names: Bob All names: Jim All names: Jill All names: Bill'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: //所有名称：Bob 所有名称：Jim 所有名称：Jill 所有名称：Bill
- en: '```'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the previous two forms of `reduce()` operations, the identity value was used
    by the accumulator. In the third form, with the `U reduce(U identity, BiFunction<U,T,U>
    accumulator, BinaryOperator<U> combiner)` signature, the identity value is used
    by the combiner (notice that, the `U` type is the combiner type).
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两种`reduce()`操作中，标识值被累加器使用。在第三种形式中，使用了`U reduce(U identity, BiFunction<U,T,U>
    accumulator, BinaryOperator<U> combiner)`签名，标识值被组合器使用（注意，`U`类型是组合器类型）。
- en: 'To get rid of the repetitive identity value in the result, we have decided
    to remove it from the second parameter in the combiner:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除结果中重复的标识值，我们决定从combiner的第二个参数中删除它：
- en: '```java'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: allNames = list.parallelStream().map(p->p.getName())
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: allNames = list.parallelStream().map(p->p.getName())
- en: .reduce("All names:", (n1, n2) -> n1 + " " + n2,
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: .reduce("所有名称:", (n1, n2) -> n1 + " " + n2，
- en: (n1, n2) -> n1 + " " + StringUtils.remove(n2, "All names:"));
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: (n1, n2) -> n1 + " " + StringUtils.remove(n2, "所有名称:"));
- en: 'System.out.println(allNames);       //All names: Bob, Jim, Jill, Bill'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(allNames); //所有名称：Bob, Jim, Jill, Bill
- en: '```'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, the result now looks much better.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，结果现在看起来好多了。
- en: 'In our examples so far, the identity played not only the role of an initial
    value, but also of the identifier (a label) in the result. When the elements of
    the stream are numeric, the identity looks more like the initial value only. Let''s
    look at the following example:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的例子中，标识不仅起到了初始值的作用，还起到了结果中的标识（标签）的作用。当流的元素是数字时，标识看起来更像是初始值。让我们看下面的例子：
- en: '```java'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Integer> ints = List.of(1, 2, 3);
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 整数列表= List.of(1, 2, 3);
- en: int sum = ints.stream().reduce((i1, i2) -> i1 + i2).orElse(0);
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: int sum = ints.stream().reduce((i1, i2) -> i1 + i2).orElse(0);
- en: 'System.out.println(sum);                          //prints: 6'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(sum); //打印：6
- en: sum = ints.stream().reduce(Integer::sum).orElse(0);
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: sum = ints.stream().reduce(Integer::sum).orElse(0);
- en: 'System.out.println(sum);                          //prints: 6'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(sum); //打印：6
- en: sum = ints.stream().reduce(10, Integer::sum);
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: sum = ints.stream().reduce(10, Integer::sum);
- en: 'System.out.println(sum);                         //prints: 16'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(sum); //打印：16
- en: sum = ints.stream().reduce(10, Integer::sum, Integer::sum);
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: sum = ints.stream().reduce(10, Integer::sum, Integer::sum);
- en: 'System.out.println(sum);                         //prints: 16'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(sum); //打印：16
- en: '```'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The first two stream pipes are exactly the same, except that the second pipe
    uses a method reference instead of a lambda expression. The third and the fourth
    pipes have the same functionality too. They both use an initial value of 10\.
    Now the first parameter makes more sense as the initial value than the identity,
    isn't it? In the fourth pipe, we added a combiner but it is not used because the
    stream is not parallel.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个流管道完全相同，只是第二个管道使用了方法引用而不是lambda表达式。第三个和第四个管道也具有相同的功能。它们都使用初始值10。现在第一个参数作为初始值比标识更有意义，不是吗？在第四个管道中，我们添加了一个组合器，但它没有被使用，因为流不是并行的。
- en: 'Let''s make it parallel and see what happens:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们并行处理一下，看看会发生什么：
- en: '```java'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Integer> ints = List.of(1, 2, 3);
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 整数列表= List.of(1, 2, 3);
- en: int sum = ints.parallelStream().reduce(10, Integer::sum, Integer::sum);
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: int sum = ints.parallelStream().reduce(10, Integer::sum, Integer::sum);
- en: 'System.out.println(sum);                                   //prints: 36'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(sum); //打印：36
- en: '```'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The result is 36 because the initial value of 10 was added three times—with
    each partial result. Apparently, the stream was broken into three subsequences.
    But that is not always the case, it changes as the stream grows and the number
    of CPUs on the computer increases. So, one cannot rely on a certain fixed number
    of subsequences and it is better not to use it for such cases, and add to the
    result if needed:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 结果为36，因为初始值10被添加了三次-每次都有部分结果。显然，流被分成了三个子序列。但情况并非总是如此，随着流的增长和计算机上CPU数量的增加而发生变化。因此，不能依赖于一定数量的子序列，最好不要在这种情况下使用它，如果需要，可以添加到结果中：
- en: '```java'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Integer> ints = List.of(1, 2, 3);
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 整数列表= List.of(1, 2, 3);
- en: int sum = ints.parallelStream().reduce(0, Integer::sum, Integer::sum);
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: int sum = ints.parallelStream().reduce(0, Integer::sum, Integer::sum);
- en: 'System.out.println(sum);                                   //prints: 6'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(sum); //打印：6
- en: sum = 10 + ints.parallelStream().reduce(0, Integer::sum, Integer::sum);
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: sum = 10 + ints.parallelStream().reduce(0, Integer::sum, Integer::sum);
- en: 'System.out.println(sum);                                   //prints: 16'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(sum); //打印：16
- en: '```'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The collect operation
  id: totrans-724
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集操作
- en: Some of the usages of the `collect()` operation are very simple and recommended
    for any beginner, while other cases can be complex and inaccessible even for a
    seasoned programmer. Together with the operations discussed already, the most
    popular cases of `collect()` we present in this section are more than enough for
    all the needs a beginner may have. Add the operations of numeric streams we are
    going to present in the *Numeric stream interfaces* section, and the covered material
    may easily be all a mainstream programmer will need for the foreseeable future.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '`collect()`操作的一些用法非常简单，适合任何初学者，而其他情况可能复杂，即使对于经验丰富的程序员也难以理解。除了已经讨论过的操作之外，我们在本节中介绍的`collect()`的最受欢迎的用法已经足够满足初学者的所有需求。再加上我们将在*数字流接口*部分介绍的数字流操作，覆盖的内容可能很容易是未来主流程序员所需的一切。'
- en: 'As we have mentioned already, the collect operation is very flexible, and allows
    us to customize the stream processing. It has two forms:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，collect操作非常灵活，允许我们自定义流处理。它有两种形式：
- en: '`R collect(Collector<T, A, R> collector)`: Processes the elements of this stream
    of the `T` type using the provided `Collector` and producing the result of the `R` type
    via an intermediate accumulation of the `A` type'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R collect(Collector<T, A, R> collector)`:使用提供的`Collector`处理此`T`类型的流的元素，并通过`A`类型的中间累积产生`R`类型的结果'
- en: '`R collect(Supplier<R> supplier, BiConsumer<R, T> accumulator, BiConsumer<R,
    R> combiner)`: Processes the elements of this stream of the `T` type using the
    provided functions:'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`R collect(Supplier<R> supplier, BiConsumer<R, T> accumulator, BiConsumer<R,
    R> combiner)`: 使用提供的函数处理`T`类型的流的元素：'
- en: '`Supplier<R>`: Creates a new result container'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Supplier<R>`: 创建一个新的结果容器'
- en: '`BiConsumer<R, T> accumulator`: A stateless function that adds an element to
    the result container'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BiConsumer<R, T> accumulator`: 一个无状态的函数，将一个元素添加到结果容器中'
- en: '`BiConsumer<R, R> combiner`: A stateless function that merges two partial result
    containers, adds the elements from the second result container into the first
    result container.'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BiConsumer<R, R> combiner`：一个无状态的函数，将两个部分结果容器合并在一起，将第二个结果容器的元素添加到第一个结果容器中。'
- en: 'Let''s look at the second form of the `collect()` operation. It is very similar
    to the `reduce()` operation, with the three parameters we have just demonstrated.
    The biggest difference is that the first parameter in the `collect()` operation
    is not identity or initial value, but the container—an object—that is going to
    be passed between functions and that maintains the state of the processing. For
    the following example, we are going to use the `Person1` class as the container:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`collect()`操作的第二种形式。它与`reduce()`操作非常相似，具有我们刚刚演示的三个参数。最大的区别在于`collect()`操作中的第一个参数不是标识或初始值，而是容器——一个对象，将在函数之间传递，并维护处理的状态。对于以下示例，我们将使用`Person1`类作为容器：
- en: '```java'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class Person1 {
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: class Person1 {
- en: private String name;
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: private String name;
- en: private int age;
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: private int age;
- en: public Person1(){}
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: public Person1(){}
- en: public String getName() { return this.name; }
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: public String getName() { return this.name; }
- en: public void setName(String name) { this.name = name; }
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: public void setName(String name) { this.name = name; }
- en: public int getAge() {return this.age; }
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: public int getAge() {return this.age; }
- en: public void setAge(int age) { this.age = age;}
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: public void setAge(int age) { this.age = age;}
- en: '@Override'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '@Override'
- en: public String toString() {
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: public String toString() {
- en: return "Person{name:" + this.name + ",age:" + age + "}";
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: return "人{name:" + this.name + ",年龄:" + age + "}";
- en: '}'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, the container has to have a constructor without parameters
    and setters, because it should be able to receive and keep the partial results—the
    name and age of the person that is the oldest, so far. The `collect()` operation
    will use this container while processing each element and, after the last element
    is processed, will contain the name and the age of the oldest person. Here is
    the list of people, which should be familiar to you:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，容器必须有一个没有参数的构造函数和setter，因为它应该能够接收和保留部分结果——迄今为止年龄最大的人的姓名和年龄。`collect()`操作将在处理每个元素时使用这个容器，并且在处理完最后一个元素后，将包含年龄最大的人的姓名和年龄。这是人员名单，你应该很熟悉：
- en: '```java'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> list = List.of(new Person(23, "Bob"),
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list = List.of(new Person(23, "Bob"),
- en: new Person(33, "Jim"),
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(33, "吉姆"),
- en: new Person(28, "Jill"),
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 新的人(28, "吉尔"),
- en: new Person(27, "Bill"));
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(27, "Bill"));
- en: '```'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And here is the `collect()` operation that should find the oldest person in
    the list:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应该在列表中找到最年长的人的`collect()`操作：
- en: '```java'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Person1 theOldest = list.stream().collect(Person1::new,
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: Person1 theOldest = list.stream().collect(Person1::new,
- en: (p1, p2) -> {
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: (p1, p2) -> {
- en: if(p1.getAge() < p2.getAge()){
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: if(p1.getAge() < p2.getAge()){
- en: p1.setAge(p2.getAge());
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: p1.setAge(p2.getAge());
- en: p1.setName(p2.getName());
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: p1.setName(p2.getName());
- en: '}'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '},'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: (p1, p2) -> { System.out.println("Combiner is called!"); });
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: (p1, p2) -> { System.out.println("组合器被调用了!"); });
- en: '```'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We tried to inline the functions in the operation call, but it looks a bit
    difficult to read, so here is the better version of the same code:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试在操作调用中内联函数，但看起来有点难以阅读，所以这是相同代码的更好版本：
- en: '```java'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: BiConsumer<Person1, Person> accumulator = (p1, p2) -> {
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: BiConsumer<Person1, Person> accumulator = (p1, p2) -> {
- en: if(p1.getAge() < p2.getAge()){
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: if(p1.getAge() < p2.getAge()){
- en: p1.setAge(p2.getAge());
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: p1.setAge(p2.getAge());
- en: p1.setName(p2.getName());
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: p1.setName(p2.getName());
- en: '}'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: BiConsumer<Person1, Person1> combiner = (p1, p2) -> {
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: BiConsumer<Person1, Person1> combiner = (p1, p2) -> {
- en: System.out.println("Combiner is called!");        //prints nothing
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("组合器被调用了!");        //不打印任何内容
- en: '};'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: theOldest = list.stream().collect(Person1::new, accumulator, combiner);
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: theOldest = list.stream().collect(Person1::new, accumulator, combiner);
- en: 'System.out.println(theOldest);        //prints: Person{name:Jim,age:33}'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(theOldest);        //打印：人{name:吉姆,年龄:33}
- en: '```'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The `Person1` container object is created only once—for the first element processing
    (in this sense, it is similar to the initial value of the `reduce()` operation).
    Then it is passed to the accumulator that compared it with the first element.
    The `age` field in the container was initialized to the default value of zero
    and thus, the age and name of the first element were set in the container as the
    parameters of the oldest person, so far.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person1`容器对象只创建一次——用于第一个元素的处理（在这个意义上，它类似于`reduce()`操作的初始值）。然后将其传递给比较器，与第一个元素进行比较。容器中的`age`字段被初始化为零的默认值，因此，迄今为止，容器中设置了第一个元素的年龄和姓名作为年龄最大的人的参数。'
- en: When the second element (the `Person` object) of the stream was emitted, its `age` field
    was compared with the `age` value currently stored in the container (the `Person1` object),
    and so on, until all elements of the stream were processed. The result is shown
    in the preceding comments.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 当流的第二个元素（`Person`对象）被发出时，它的`age`字段与容器（`Person1`对象）中当前存储的`age`值进行比较，依此类推，直到处理完流的所有元素。结果如前面的注释所示。
- en: 'The combiner was never called because the stream is not parallel. But when
    we make it parallel, we need to implement the combiner as follows:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 组合器从未被调用，因为流不是并行的。但是当我们并行时，我们需要实现组合器如下：
- en: '```java'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: BiConsumer<Person1, Person1> combiner = (p1, p2) -> {
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: BiConsumer<Person1, Person1> combiner = (p1, p2) -> {
- en: System.out.println("Combiner is called!");   //prints 3 times
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("组合器被调用了!");   //打印3次
- en: if(p1.getAge() < p2.getAge()){
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: if(p1.getAge() < p2.getAge()){
- en: p1.setAge(p2.getAge());
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: p1.setAge(p2.getAge());
- en: p1.setName(p2.getName());
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: p1.setName(p2.getName());
- en: '}'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: theOldest = list.parallelStream()
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: theOldest = list.parallelStream()
- en: .collect(Person1::new, accumulator, combiner);
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Person1::new, accumulator, combiner);
- en: 'System.out.println(theOldest);  //prints: Person{name:Jim,age:33}'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(theOldest);  //prints: Person{name:Jim,age:33}'
- en: '```'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The combiner compares the partial results (of all the stream subsequences) and
    comes up with the final result. Now we see the `Combiner is called!` message printed
    three times. But, as in the case of the `reduce()` operation, the number of partial
    results (the stream subsequences) may vary.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 组合器比较了所有流子序列的部分结果，并得出最终结果。现在我们看到`Combiner is called!`消息打印了三次。但是，与`reduce()`操作一样，部分结果（流子序列）的数量可能会有所不同。
- en: 'Now let''s look at the first form of the `collect()` operation. It requires an
    object of the class that implements the `java.util.stream.Collector<T,A,R>` interface
    where `T` is the stream type, `A` is the container type, and `R` is the result
    type. One can use the `of()` method of the `Collector` interface to create a necessary
    `Collector` object:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`collect()`操作的第一种形式。它需要一个实现`java.util.stream.Collector<T,A,R>`接口的类的对象，其中`T`是流类型，`A`是容器类型，`R`是结果类型。可以使用`Collector`接口的`of()`方法来创建必要的`Collector`对象：
- en: '`static Collector<T,R,R> of(Supplier<R> supplier, BiConsumer<R,T> accumulator,
    BinaryOperator<R> combiner, Collector.Characteristics... characteristics)`'
  id: totrans-797
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static Collector<T,R,R> of(Supplier<R> supplier, BiConsumer<R,T> accumulator,
    BinaryOperator<R> combiner, Collector.Characteristics... characteristics)`'
- en: '`static Collector<T,A,R> of(Supplier<A> supplier, BiConsumer<A,T> accumulator,
    BinaryOperator<A> combiner, Function<A,R> finisher, Collector.Characteristics...
    characteristics)`.'
  id: totrans-798
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static Collector<T,A,R> of(Supplier<A> supplier, BiConsumer<A,T> accumulator,
    BinaryOperator<A> combiner, Function<A,R> finisher, Collector.Characteristics...
    characteristics)`.'
- en: The functions one has to pass to the preceding methods are similar to those
    we have demonstrated already. But we are not going to do it for two reasons. First,
    it is somewhat more involved and pushes beyond the scope of this introductory
    course, and, second, before doing that, one has to look in the `java.util.stream.Collectors` class
    that provides many ready-to-use collectors.  As we have mentioned already, together
    with the operations discussed in this book and the numeric streams operations
    we are going to present in the *Numeric stream interfaces* section, they cover
    the vast majority of the processing needs in mainstream programming, and there
    is a good chance you would never need to create a custom collector at all.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法中必须传递的函数与我们已经演示过的函数类似。但我们不打算这样做有两个原因。首先，这涉及的内容更多，超出了本入门课程的范围，其次，在这之前，必须查看提供了许多现成收集器的`java.util.stream.Collectors`类。正如我们已经提到的，加上本书讨论的操作和我们将在*数字流接口*部分介绍的数字流操作，它们涵盖了主流编程中绝大多数处理需求，很可能你根本不需要创建自定义收集器。
- en: Class collectors
  id: totrans-800
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类收集器
- en: 'The `java.util.stream.Collectors` class provides more than 40 methods that
    create `Collector` objects. We are going to demonstrate only the simplest and 
    most popular ones:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.stream.Collectors`类提供了40多种方法来创建`Collector`对象。我们将仅演示最简单和最流行的方法：'
- en: '`Collector<T,?,List<T>> toList()`: Creates a collector that collects the stream
    elements into a `List` object.'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,List<T>> toList()`：创建一个收集器，将流元素收集到一个`List`对象中。'
- en: '`Collector<T,?,Set<T>> toSet()`: Creates a collector that collects the stream
    elements into a `Set` object.'
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Set<T>> toSet()`：创建一个收集器，将流元素收集到一个`Set`对象中。'
- en: '`Collector<T,?,Map<K,U>> toMap (Function<T,K> keyMapper, Function<T,U> valueMapper)`:
    Creates a collector that collects the stream elements into a `Map` object.'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Map<K,U>> toMap (Function<T,K> keyMapper, Function<T,U> valueMapper)`：创建一个收集器，将流元素收集到一个`Map`对象中。'
- en: '`Collector<T,?,C> toCollection (Supplier<C> collectionFactory)`: Creates a
    collector that collects the stream elements into a `Collection` object of the
    type specified by the collection factory.'
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,C> toCollection (Supplier<C> collectionFactory)`：创建一个收集器，将流元素收集到由集合工厂指定类型的`Collection`对象中。'
- en: '`Collector<CharSequence,?,String> joining()`: Creates a collector that concatenates
    the elements into a `String` value.'
  id: totrans-806
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<CharSequence,?,String> joining()`：创建一个收集器，将元素连接成一个`String`值。'
- en: '`Collector<CharSequence,?,String> joining (CharSequence delimiter)`: Creates
    a collector that concatenates the elements into a delimiter-separated `String`
    value.'
  id: totrans-807
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<CharSequence,?,String> joining (CharSequence delimiter)`：创建一个收集器，将元素连接成一个以提供的分隔符分隔的`String`值。'
- en: '`Collector<CharSequence,?,String> joining (CharSequence delimiter, CharSequence
    prefix, CharSequence suffix)`: Creates a collector that concatenates the elements
    into a delimiter-separated `String` value with the provided prefix and suffix.'
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<CharSequence,?,String> joining (CharSequence delimiter, CharSequence
    prefix, CharSequence suffix)`：创建一个收集器，将元素连接成一个以提供的前缀和后缀分隔的`String`值。'
- en: '`Collector<T,?,Integer> summingInt(ToIntFunction<T>)`: Creates a collector
    that calculates the sum of the results generated by the provided function applied
    to each element. The same method exists for the `long` and `double` types.'
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Integer> summingInt(ToIntFunction<T>)`：创建一个计算由提供的函数应用于每个元素生成的结果的总和的收集器。相同的方法也适用于`long`和`double`类型。'
- en: '`Collector<T,?,IntSummaryStatistics> summarizingInt(ToIntFunction<T>)`: Creates
    a collector that calculates the sum, min, max, count, and average of the results
    generated by the provided function applied to each element. The same method exists
    for the `long` and `double` types.'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,IntSummaryStatistics> summarizingInt(ToIntFunction<T>)`：创建一个收集器，计算由提供的函数应用于每个元素生成的结果的总和、最小值、最大值、计数和平均值。相同的方法也适用于`long`和`double`类型。'
- en: '`Collector<T,?,Map<Boolean,List<T>>> partitioningBy (Predicate<? super T> predicate)`:
    Creates a collector that partitions the elements according to the provided `Predicate`
    function.'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Map<Boolean,List<T>>> partitioningBy (Predicate<? super T> predicate)`：创建一个收集器，根据提供的`Predicate`函数将元素分区。'
- en: '`Collector<T,?,Map<K,List<T>>> groupingBy(Function<T,U>)`: Creates a collector
    that groups elements into a `Map` with keys generated by the provided function.'
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collector<T,?,Map<K,List<T>>> groupingBy(Function<T,U>)`：创建一个收集器，将元素分组到由提供的函数生成的`Map`中。'
- en: 'The following demo code shows how to use the collectors created by these methods.
    First, we demonstrate usage of the  `toList()`, `toSet()`, `toMap()`, and `toCollection()` methods:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 'The following demo code shows how to use the collectors created by these methods.
    First, we demonstrate usage of the  `toList()`, `toSet()`, `toMap()`, and `toCollection()` methods:'
- en: '```java'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> ls = Stream.of("a", "b", "c").collect(Collectors.toList());
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> ls = Stream.of("a", "b", "c").collect(Collectors.toList());
- en: 'System.out.println(ls);                //prints: [a, b, c]'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(ls);                //prints: [a, b, c]'
- en: Set<String> set = Stream.of("a", "a", "c").collect(Collectors.toSet());
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: Set<String> set = Stream.of("a", "a", "c").collect(Collectors.toSet());
- en: 'System.out.println(set);                //prints: [a, c]'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(set);                //prints: [a, c]'
- en: List<Person> persons = List.of(new Person(23, "Bob"),
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> persons = List.of(new Person(23, "Bob"),
- en: new Person(33, "Jim"),
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(33, "Jim"),
- en: new Person(28, "Jill"),
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(28, "Jill"),
- en: new Person(27, "Bill"));
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(27, "Bill"));
- en: Map<String, Person> map = persons.stream()
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: Map<String, Person> map = persons.stream()
- en: .collect(Collectors.toMap(p->p.getName() + "-" + p.getAge(), p->p));
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.toMap(p->p.getName() + "-" + p.getAge(), p->p));
- en: 'System.out.println(map); //prints: {Bob-23=Person{name:Bob,age:23},'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(map); //prints: {Bob-23=Person{name:Bob,age:23},'
- en: Bill-27=Person{name:Bill,age:27},
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: Bill-27=Person{name:Bill,age:27},
- en: Jill-28=Person{name:Jill,age:28},
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: Jill-28=Person{name:Jill,age:28},
- en: Jim-33=Person{name:Jim,age:33}}
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: Jim-33=Person{name:Jim,age:33}}
- en: Set<Person> personSet = persons.stream()
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: Set<Person> personSet = persons.stream()
- en: .collect(Collectors.toCollection(HashSet::new));
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: .collect(Collectors.toCollection(HashSet::new));
- en: 'System.out.println(personSet);  //prints: [Person{name:Bill,age:27},'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(personSet);  //prints: [Person{name:Bill,age:27},'
- en: Person{name:Jim,age:33},
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: Person{name:Jim,age:33},
- en: Person{name:Bob,age:23},
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: Person{name:Bob,age:23},
- en: Person{name:Jill,age:28}]
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: Person{name:Jill,age:28}]
- en: '```'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `joining()` method allows concatenating the `Character` and `String` values
    in a delimited list with a prefix and suffix:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `joining()` method allows concatenating the `Character` and `String` values
    in a delimited list with a prefix and suffix:'
- en: '```java'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> list = List.of("a", "b", "c", "d");
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> list = List.of("a", "b", "c", "d");
- en: String result = list.stream().collect(Collectors.joining());
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: String result = list.stream().collect(Collectors.joining());
- en: System.out.println(result);           //abcd
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(result);           //abcd
- en: result = list.stream().collect(Collectors.joining(", "));
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: result = list.stream().collect(Collectors.joining(", "));
- en: System.out.println(result);           //a, b, c, d
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(result);           //a, b, c, d
- en: result = list.stream()
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: result = list.stream()
- en: '.collect(Collectors.joining(", ", "The result: ", ""));'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '.collect(Collectors.joining(", ", "The result: ", ""));'
- en: 'System.out.println(result);          //The result: a, b, c, d'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(result);          //The result: a, b, c, d'
- en: result = list.stream()
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: result = list.stream()
- en: '.collect(Collectors.joining(", ", "The result: ", ". The End."));'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '.collect(Collectors.joining(", ", "The result: ", ". The End."));'
- en: 'System.out.println(result);          //The result: a, b, c, d. The End.'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(result);          //The result: a, b, c, d. The End.'
- en: '```'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `summingInt()` and `summarizingInt()` methods create collectors that calculate
    the sum and other statistics of the `int` values produced by the provided function
    applied to each element:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `summingInt()` and `summarizingInt()` methods create collectors that calculate
    the sum and other statistics of the `int` values produced by the provided function
    applied to each element:'
- en: '```java'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> list = List.of(new Person(23, "Bob"),
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list = List.of(new Person(23, "Bob"),
- en: new Person(33, "Jim"),
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(33, "Jim"),
- en: new Person(28, "Jill"),
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(28, "Jill"),
- en: new Person(27, "Bill"));
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(27, "Bill"));
- en: int sum = list.stream().collect(Collectors.summingInt(Person::getAge));
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: int sum = list.stream().collect(Collectors.summingInt(Person::getAge));
- en: 'System.out.println(sum);  //prints: 111'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(sum);  //prints: 111'
- en: IntSummaryStatistics stats =
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: IntSummaryStatistics stats =
- en: list.stream().collect(Collectors.summarizingInt(Person::getAge));
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().collect(Collectors.summarizingInt(Person::getAge));
- en: System.out.println(stats);     //IntSummaryStatistics{count=4, sum=111,
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(stats);     //IntSummaryStatistics{count=4, sum=111,
- en: //    min=23, average=27.750000, max=33}
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: //    min=23, average=27.750000, max=33}
- en: System.out.println(stats.getCount());    //4
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(stats.getCount());    //4
- en: System.out.println(stats.getSum());      //111
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(stats.getSum());      //111
- en: System.out.println(stats.getMin());      //23
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(stats.getMin());      //23
- en: System.out.println(stats.getAverage());  //27.750000
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(stats.getAverage());  //27.750000
- en: System.out.println(stats.getMax());      //33
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(stats.getMax());      //33
- en: '```'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: There are also `summingLong()`, `summarizingLong()` , `summingDouble()`, and `summarizingDouble()` methods.
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: There are also `summingLong()`, `summarizingLong()` , `summingDouble()`, and `summarizingDouble()` methods.
- en: 'The `partitioningBy()` method creates a collector that groups the elements
    by the provided criteria and put the groups (lists) in a `Map` object with a `boolean`
    value as the key:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 'The `partitioningBy()` method creates a collector that groups the elements
    by the provided criteria and put the groups (lists) in a `Map` object with a `boolean`
    value as the key:'
- en: '```java'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> list = List.of(new Person(23, "Bob"),
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list = List.of(new Person(23, "Bob"),
- en: new Person(33, "Jim"),
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(33, "Jim"),
- en: new Person(28, "Jill"),
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(28, "Jill"),
- en: new Person(27, "Bill"));
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(27, "Bill"));
- en: Map<Boolean, List<Person>> map =
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Boolean, List<Person>> map =
- en: list.stream().collect(Collectors.partitioningBy(p->p.getAge() > 27));
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().collect(Collectors.partitioningBy(p->p.getAge() > 27));
- en: System.out.println(map);
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map);
- en: //{false=[Person{name:Bob,age:23}, Person{name:Bill,age:27}],
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: //{false=[Person{name:Bob,age:23}, Person{name:Bill,age:27}],
- en: //  true=[Person{name:Jim,age:33}, Person{name:Jill,age:28}]}
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: //  true=[Person{name:Jim,age:33}, Person{name:Jill,age:28}]}
- en: '```'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, using the `p.getAge() > 27` criteria, we were able to put all
    the people in two groups—one is below or equals 27 years of age (the key is `false`),
    and the other is above 27 (the key is `true`).
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: As you can see, using the `p.getAge() > 27` criteria, we were able to put all
    the people in two groups—one is below or equals 27 years of age (the key is `false`),
    and the other is above 27 (the key is `true`).
- en: 'And, finally, the `groupingBy()` method allows us to group elements by a value
    and put the groups (lists) in a `Map` object with this value as a key:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 'And, finally, the `groupingBy()` method allows us to group elements by a value
    and put the groups (lists) in a `Map` object with this value as a key:'
- en: '```java'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Person> list = List.of(new Person(23, "Bob"),
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: List<Person> list = List.of(new Person(23, "Bob"),
- en: new Person(33, "Jim"),
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(33, "Jim"),
- en: new Person(23, "Jill"),
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(23, "Jill"),
- en: new Person(33, "Bill"));
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: new Person(33, "Bill"));
- en: Map<Integer, List<Person>> map =
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: Map<Integer, List<Person>> map =
- en: list.stream().collect(Collectors.groupingBy(Person::getAge));
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().collect(Collectors.groupingBy(Person::getAge));
- en: System.out.println(map);
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(map);
- en: //{33=[Person{name:Jim,age:33}, Person{name:Bill,age:33}],
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: //{33=[Person{name:Jim,age:33}, Person{name:Bill,age:33}],
- en: // 23=[Person{name:Bob,age:23}, Person{name:Jill,age:23}]}
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: // 23=[Person{name:Bob,age:23}, Person{name:Jill,age:23}]}
- en: '```'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: To be able to demonstrate the preceding method, we changed our list of `Person`
    objects by setting the age on each of them either to 23 or to 33\. The result
    is two groups by their age.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示前面的方法，我们通过将每个人的年龄设置为23或33来改变了`Person`对象的列表。结果是按年龄分成两组。
- en: 'There are also overloaded `toMap()`, `groupingBy()`, and `partitioningBy()` methods as
    well as the following, often overloaded too, methods that create corresponding
    `Collector` objects:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 还有重载的`toMap()`、`groupingBy()`和`partitioningBy()`方法，以及以下通常也重载的方法，它们创建相应的`Collector`对象：
- en: '`counting()`'
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counting()`'
- en: '`reducing()`'
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reducing()`'
- en: '`filtering()`'
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filtering()`'
- en: '`toConcurrentMap()`'
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toConcurrentMap()`'
- en: '``collectingAndThen()``'
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '``collectingAndThen()``'
- en: '`maxBy()` and `minBy()`'
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxBy()` 和 `minBy()`'
- en: '`mapping()` and `flatMapping()`'
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapping()` 和 `flatMapping()`'
- en: '`averagingInt()`, `averagingLong()`, and `averagingDouble()`'
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`averagingInt()`, `averagingLong()`, 和 `averagingDouble()`'
- en: '`toUnmodifiableList()`, `toUnmodifiableMap()`, and `toUnmodifiableSet()`'
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toUnmodifiableList()`、`toUnmodifiableMap()`和 `toUnmodifiableSet()`'
- en: If you cannot find the operation you need among those discussed in this book,
    search the `Collectors` API first, before building your own `Collector` object.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在本书中找不到所需的操作，请先搜索`Collectors`API，然后再构建自己的`Collector`对象。
- en: Numeric stream interfaces
  id: totrans-906
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字流接口
- en: 'As we have mentioned already, all the three numeric interfaces, `IntStream`,
    `LongStream`, and `DoubleStream`,have methods similar to the methods in the `Stream` interface,
    including methods of the `Stream.Builder` interface. This means that everything
    we have talked so far in this chapter equally applies to any of the numeric stream
    interfaces. That is why, in this section, we will only talk about those methods
    that are not present in the `Stream` interface:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，所有三个数字接口，`IntStream`、`LongStream`和`DoubleStream`，都有类似于`Stream`接口的方法，包括`Stream.Builder`接口的方法。这意味着我们在本章中讨论的所有内容同样适用于任何数字流接口。因此，在本节中，我们只会讨论`Stream`接口中不存在的那些方法：
- en: The `range(lower,upper)` and `rangeClosed(lower,upper)` methods in the `IntStream`
    and `LongStream` interfaces. They allow us to create a stream from the values
    in the specified range.
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntStream`和`LongStream`接口中的`range(lower,upper)`和`rangeClosed(lower,upper)`方法。它们允许我们从指定范围内的值创建流。'
- en: The `boxed()` and `mapToObj()` intermediate operations, which convert a numeric
    stream to `Stream`.
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boxed()`和`mapToObj()`中间操作，将数字流转换为`Stream`。'
- en: The `mapToInt()`, `mapToLong()`, and `mapToDouble()` intermediate operations,
    which convert a numeric stream of one type to a numeric stream of another type.
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mapToInt()`、`mapToLong()`和`mapToDouble()`中间操作，将一个类型的数字流转换为另一个类型的数字流。'
- en: The `flatMapToInt()`, `flatMapToLong()`, and `flatMapToDouble()` intermediate
    operations, which convert a stream to a numeric stream.
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMapToInt()`、`flatMapToLong()`和`flatMapToDouble()`中间操作，将流转换为数字流。'
- en: The `sum()` and `average()` Terminal operations, which calculate sum and average
    of the numeric stream elements.
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum()`和`average()`终端操作，计算数字流元素的和和平均值。'
- en: Creating a stream
  id: totrans-913
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建流
- en: In addition to the methods of the `Stream` interface that create streams, the `IntStream` and `LongStream` interfaces
    allow us to create a stream from the values in the specified range.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建流的`Stream`接口方法外，`IntStream`和`LongStream`接口还允许我们从指定范围内的值创建流。
- en: range(), rangeClosed()
  id: totrans-915
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: range()，rangeClosed()
- en: 'The `range(lower, upper)` method generates all the values sequentially, starting
    from the `lower` value and ending with the value just before `upper`:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '`range(lower, upper)`方法按顺序生成所有值，从`lower`值开始，以`upper`值之前的值结束：'
- en: '```java'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'IntStream.range(1, 3).forEach(System.out::print);  //prints: 12'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 'IntStream.range(1, 3).forEach(System.out::print);  //prints: 12'
- en: 'LongStream.range(1, 3).forEach(System.out::print);  //prints: 12'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 'LongStream.range(1, 3).forEach(System.out::print);  //prints: 12'
- en: '```'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `rangeClosed(lower, upper)` method generates all the values sequentially,
    starting from the `lower` value and ending with the `upper` value:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: '`rangeClosed(lower, upper)` 方法按顺序生成所有值，从`lower`值开始，以`upper`值结束：'
- en: '```java'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'IntStream.rangeClosed(1, 3).forEach(System.out::print);  //prints: 123'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 'IntStream.rangeClosed(1, 3).forEach(System.out::print);  //prints: 123'
- en: 'LongStream.rangeClosed(1, 3).forEach(System.out::print);  //prints: 123'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 'LongStream.rangeClosed(1, 3).forEach(System.out::print);  //prints: 123'
- en: '```'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Intermediate operations
  id: totrans-926
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间操作
- en: 'In addition to the `Stream` intermediate operations, the `IntStream`, `LongStream`,
    and `DoubleStream` interfaces also have number-specific intermediate operations:
    `boxed()`, `mapToObj()`, `mapToInt()`, `mapToLong()`, `mapToDouble()`, `flatMapToInt()`,
    `flatMapToLong()`, and `flatMapToDouble()`.'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Stream`中间操作外，`IntStream`、`LongStream`和`DoubleStream`接口还具有特定于数字的中间操作：`boxed()`、`mapToObj()`、`mapToInt()`、`mapToLong()`、`mapToDouble()`、`flatMapToInt()`、`flatMapToLong()`和`flatMapToDouble()`。
- en: boxed() and mapToObj()
  id: totrans-928
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: boxed()和mapToObj()
- en: 'The `boxed()` intermediate operation converts (boxes) elements of the primitive
    numeric type to the corresponding wrapper type:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: '`boxed()` 中间操作将原始数值类型的元素转换（装箱）为相应的包装类型：'
- en: '```java'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: //IntStream.range(1, 3).map(Integer::shortValue)        //compile error
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: //IntStream.range(1, 3).map(Integer::shortValue)        //compile error
- en: //                     .forEach(System.out::print);
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: //                     .forEach(System.out::print);
- en: IntStream.range(1, 3).boxed().map(Integer::shortValue)
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: IntStream.range(1, 3).boxed().map(Integer::shortValue)
- en: '.forEach(System.out::print);  //prints: 12'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);  //prints: 12'
- en: //LongStream.range(1, 3).map(Long::shortValue)          //compile error
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: //LongStream.range(1, 3).map(Long::shortValue)          //compile error
- en: //                      .forEach(System.out::print);
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: //                      .forEach(System.out::print);
- en: LongStream.range(1, 3).boxed().map(Long::shortValue)
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: LongStream.range(1, 3).boxed().map(Long::shortValue)
- en: '.forEach(System.out::print);  //prints: 12'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '.forEach(System.out::print);  //prints: 12'
- en: //DoubleStream.of(1).map(Double::shortValue)            //compile error
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: //DoubleStream.of(1).map(Double::shortValue)            //compile error
- en: //                  .forEach(System.out::print);
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: //                  .forEach(System.out::print);
- en: DoubleStream.of(1).boxed().map(Double::shortValue)
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: DoubleStream.of(1).boxed().map(Double::shortValue)
- en: '.forEach(System.out::print);      //prints: 1'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print);      //打印：1
- en: '```'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the preceding code, we have commented out the lines that generate compilation
    errors because the elements generated by the `range()` method are of primitive
    types. By adding the `boxed()` operation, we convert the primitive values to the
    corresponding wrapping type and can then process them as a reference type.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们已经注释掉了生成编译错误的行，因为`range()`方法生成的元素是原始类型。通过添加`boxed()`操作，我们将原始值转换为相应的包装类型，然后可以将它们作为引用类型进行处理。
- en: 'The `mapToObj()` intermediate operation does a similar transformation, but 
    it is not as specialized as the `boxed()` operation and allows to use an element
    of the primitive type to produce an object of any type:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapToObj()`中间操作进行了类似的转换，但它不像`boxed()`操作那样专门化，并且允许使用原始类型的元素来生成任何类型的对象：'
- en: '```java'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: IntStream.range(1, 3).mapToObj(Integer::valueOf)
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: IntStream.range(1, 3).mapToObj(Integer::valueOf)
- en: .map(Integer::shortValue)
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: .map(Integer::shortValue)
- en: '.forEach(System.out::print);       //prints: 12'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print);       //打印：12
- en: IntStream.range(42, 43).mapToObj(i -> new Person(i, "John"))
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: IntStream.range(42, 43).mapToObj(i -> new Person(i, "John"))
- en: .forEach(System.out::print);
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print);
- en: '//prints: Person{name:John,age:42}'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: //打印：Person{name:John,age:42}
- en: LongStream.range(1, 3).mapToObj(Long::valueOf)
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: LongStream.range(1, 3).mapToObj(Long::valueOf)
- en: .map(Long::shortValue)
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: .map(Long::shortValue)
- en: '.forEach(System.out::print);      //prints: 12'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print);      //打印：12
- en: DoubleStream.of(1).mapToObj(Double::valueOf)
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: DoubleStream.of(1).mapToObj(Double::valueOf)
- en: .map(Double::shortValue)
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: .map(Double::shortValue)
- en: '.forEach(System.out::print);          //prints: 1'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print);          //打印：1
- en: '```'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the preceding code, we have added the `map()` operation just to prove that
    the `mapToObj()` operation does the job and creates a wrapping type object as
    expected. Also, by adding the stream pipe that produces the `Person` objects,
    we have demonstrated how the `mapToObj()` operation can be used to create an object
    of any type.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们添加了`map()`操作，只是为了证明`mapToObj()`操作可以按预期执行工作并创建包装类型对象。此外，通过添加生成`Person`对象的流管道，我们演示了如何使用`mapToObj()`操作来创建任何类型的对象。
- en: mapToInt(), mapToLong(), and mapToDouble()
  id: totrans-961
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mapToInt()、mapToLong()和mapToDouble()
- en: 'The `mapToInt()`, `mapToLong()`, `mapToDouble()` intermediate operations allow
    us to convert a numeric stream of one type to a numeric stream of another type.
    For the demonstration code, we convert the list of `String` values to a numeric
    stream of different types by mapping each `String` value to its length:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapToInt()`、`mapToLong()`、`mapToDouble()`中间操作允许我们将一个类型的数值流转换为另一种类型的数值流。在演示代码中，我们通过将每个`String`值映射到其长度，将`String`值列表转换为不同类型的数值流：'
- en: '```java'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: list.stream().mapToInt(String::length)
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().mapToInt(String::length)
- en: '.forEach(System.out::print); //prints: 335'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print); //打印：335
- en: list.stream().mapToLong(String::length)
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().mapToLong(String::length)
- en: '.forEach(System.out::print); //prints: 335'
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print); //打印：335
- en: list.stream().mapToDouble(String::length)
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().mapToDouble(String::length)
- en: '.forEach(d -> System.out.print(d + " "));   //prints: 3.0 3.0 5.0'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(d -> System.out.print(d + " "));   //打印：3.0 3.0 5.0
- en: '```'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The elements of the created numeric streams are of a primitive type:'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的数值流的元素是原始类型的：
- en: '```java'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: //list.stream().mapToInt(String::length)
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: //list.stream().mapToInt(String::length)
- en: //             .map(Integer::shortValue)   //compile error
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: //             .map(Integer::shortValue)   //编译错误
- en: //             .forEach(System.out::print);
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: //             .forEach(System.out::print);
- en: '```'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And since we are on this topic, if you would like to convert elements to a
    numeric wrapping type, the `map()` intermediate operation is the way to do it
    (instead of `mapToInt()`):'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在这个话题上，如果您想将元素转换为数值包装类型，`map()`中间操作就是这样做的方法（而不是`mapToInt()`）：
- en: '```java'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: list.stream().map(String::length)
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().map(String::length)
- en: .map(Integer::shortValue)
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: .map(Integer::shortValue)
- en: '.forEach(System.out::print);  //prints: 335'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print);  //打印：335
- en: '```'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: flatMapToInt(), flatMapToLong(), and flatMapToDouble()
  id: totrans-983
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: flatMapToInt()、flatMapToLong()和flatMapToDouble()
- en: 'The `flatMapToInt()`, `flatMapToLong()`, `flatMapToDouble()` intermediate operations
    produce a numeric stream of a corresponding type:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMapToInt()`、`flatMapToLong()`、`flatMapToDouble()`中间操作会生成相应类型的数值流：'
- en: '```java'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Integer> list = List.of(1, 2, 3);
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: List<Integer> list = List.of(1, 2, 3);
- en: list.stream().flatMapToInt(i -> IntStream.rangeClosed(1, i))
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().flatMapToInt(i -> IntStream.rangeClosed(1, i))
- en: '.forEach(System.out::print);    //prints: 112123'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print);    //打印：112123
- en: list.stream().flatMapToLong(i -> LongStream.rangeClosed(1, i))
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().flatMapToLong(i -> LongStream.rangeClosed(1, i))
- en: '.forEach(System.out::print);    //prints: 112123'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print);    //打印：112123
- en: list.stream().flatMapToDouble(DoubleStream::of)
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: list.stream().flatMapToDouble(DoubleStream::of)
- en: '.forEach(d -> System.out.print(d + " "));  //prints: 1.0 2.0 3.0'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(d -> System.out.print(d + " "));  //打印：1.0 2.0 3.0
- en: '```'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, in the preceding code, we have used `int` values in the original
    stream. But it can be a stream of any type:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在上述代码中，我们在原始流中使用了`int`值。但它可以是任何类型的流：
- en: '```java'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<String> str = List.of("one", "two", "three");
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: List<String> str = List.of("one", "two", "three");
- en: str.stream().flatMapToInt(s -> IntStream.rangeClosed(1, s.length()))
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: str.stream().flatMapToInt(s -> IntStream.rangeClosed(1, s.length()))
- en: '.forEach(System.out::print);  //prints: 12312312345'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: .forEach(System.out::print);  //打印：12312312345
- en: '```'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Terminal operations
  id: totrans-1000
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终端操作
- en: 'The additional Terminal operations of numeric streams are pretty straightforward.
    There are two of them:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 数值流的附加终端操作非常简单。它们中有两个：
- en: '`sum()`: Calculates the sum of the numeric stream elements'
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum()`: 计算数值流元素的总和'
- en: '`average()`: Calculates the average of the numeric stream elements'
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`average()`: 计算数值流元素的平均值'
- en: sum() and average()
  id: totrans-1004
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sum()和average()
- en: 'If you need to calculate a sum or an average of the values of numeric stream
    elements, the only requirement for the stream is that it should not be infinite.
    Otherwise, the calculation never finishes:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要计算数值流元素的总和或平均值，则流的唯一要求是它不应该是无限的。否则，计算永远不会完成：
- en: '```java'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int sum = IntStream.empty().sum();
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: int sum = IntStream.empty().sum();
- en: 'System.out.println(sum);          //prints: 0'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(sum);          //打印：0
- en: sum = IntStream.range(1, 3).sum();
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: sum = IntStream.range(1, 3).sum();
- en: 'System.out.println(sum);          //prints: 3'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(sum);          //打印：3
- en: double av = IntStream.empty().average().orElse(0);
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: double av = IntStream.empty().average().orElse(0);
- en: 'System.out.println(av);           //prints: 0.0'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(av);           //打印：0.0
- en: av = IntStream.range(1, 3).average().orElse(0);
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: av = IntStream.range(1, 3).average().orElse(0);
- en: 'System.out.println(av);           //prints: 1.5'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(av);           //打印：1.5
- en: long suml = LongStream.range(1, 3).sum();
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: long suml = LongStream.range(1, 3).sum();
- en: 'System.out.println(suml);         //prints: 3'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(suml);         //打印：3
- en: double avl = LongStream.range(1, 3).average().orElse(0);
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: double avl = LongStream.range(1, 3).average().orElse(0);
- en: 'System.out.println(avl);          //prints: 1.5'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(avl);          //打印：1.5
- en: double sumd = DoubleStream.of(1, 2).sum();
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: double sumd = DoubleStream.of(1, 2).sum();
- en: 'System.out.println(sumd);         //prints: 3.0'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(sumd);         //打印：3.0
- en: double avd = DoubleStream.of(1, 2).average().orElse(0);
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: double avd = DoubleStream.of(1, 2).average().orElse(0);
- en: 'System.out.println(avd);          //prints: 1.5'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(avd);          //打印：1.5
- en: '```'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, using these operations on an empty stream is not a problem.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，对空流使用这些操作不是问题。
- en: Parallel processing
  id: totrans-1025
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行处理
- en: We have seen that changing from a sequential stream to a parallel stream can
    lead to incorrect results if the code was not written and tested for processing
    a parallel stream. The following are a few more considerations related to the
    parallel stream.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，从顺序流切换到并行流可能会导致不正确的结果，如果代码没有为处理并行流而编写和测试。以下是与并行流相关的一些其他考虑。
- en: Stateless and stateful operations
  id: totrans-1027
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态和有状态的操作
- en: There are stateless operations, such as `filter()`, `map()`, and `flatMap()`,
    which do not keep data around (do not maintain state) while moving from processing
    from one stream element to the next. And there are stateful operations, such as
    `distinct()`, `limit()`, `sorted()`, `reduce()`, and `collect()`, which may pass
    the state from previously processed elements to the processing of the next element.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 有无状态的操作，比如`filter()`、`map()`和`flatMap()`，在从一个流元素的处理转移到下一个流元素的处理时不会保留数据（不维护状态）。还有有状态的操作，比如`distinct()`、`limit()`、`sorted()`、`reduce()`和`collect()`，可能会将先前处理的元素的状态传递给下一个元素的处理。
- en: Stateless operations usually do not pose a problem when switching from a sequential
    stream to a parallel one. Each element is processed independently and the stream
    can be broken into any number of sub-streams for independent processing.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态操作通常在从顺序流切换到并行流时不会造成问题。每个元素都是独立处理的，流可以被分成任意数量的子流进行独立处理。
- en: With stateful operations, the situation is different. To start with, using them
    for an infinite stream may never finish processing. Also, while discussing the `reduce()`
    and `collect()` stateful operations, we have demonstrated how switching to a parallel
    stream can produce a different result if the initial value (or identity) is set
    without parallel processing in mind.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有状态的操作，情况是不同的。首先，对无限流使用它们可能永远无法完成处理。此外，在讨论`reduce()`和`collect()`有状态操作时，我们已经演示了如果初始值（或标识）在没有考虑并行处理的情况下设置，切换到并行流可能会产生不同的结果。
- en: And there are performance considerations too. Stateful operations often require
    processing all the stream elements in several passes using buffering. For large
    streams, it may tax JVM resources and slow down, if not completely shut down,
    the application.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 而且还有性能方面的考虑。有状态的操作通常需要使用缓冲区多次处理所有流元素。对于大流，这可能会消耗JVM资源并减慢甚至完全关闭应用程序。
- en: That is why a programmer should not take switching from a sequential to a parallel
    stream lightly. If stateful operations are involved, the code has to be designed
    and tested to be able to perform the parallel stream processing without negative
    effects.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么程序员不应该轻易从顺序流切换到并行流。如果涉及有状态的操作，代码必须被设计和测试，以便能够在没有负面影响的情况下执行并行流处理。
- en: Sequential or parallel processing?
  id: totrans-1033
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序或并行处理？
- en: As we indicated in the previous section, parallel processing may or may not
    produce better performance. One has to test every use case before deciding to
    use it. Parallelism can yield better performance, but the code has to be designed
    and possibly optimized to do it. And each assumption has to be tested in the environment
    as close to the production as possible.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中所指出的，并行处理可能会产生更好的性能，也可能不会。在决定使用之前，必须测试每个用例。并行处理可能会产生更好的性能，但代码必须被设计和可能被优化。每个假设都必须在尽可能接近生产环境的环境中进行测试。
- en: 'However, there are a few considerations one can take into account while deciding
    between sequential and parallel processing:'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在决定顺序处理和并行处理之间可以考虑一些因素：
- en: Small streams typically are processed faster sequentially (well, what is "small"
    for your environment should be determined through testing and measuring the performance)
  id: totrans-1036
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，小流在顺序处理时处理速度更快（对于您的环境来说，“小”是通过测试和测量性能来确定的）
- en: If stateful operations cannot be replaced with stateless ones, design the code
    carefully for the parallel processing or just avoid it completely
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有状态的操作无法用无状态的操作替换，那么必须仔细设计代码以进行并行处理，或者完全避免它。
- en: Consider parallel processing for the procedures that require extensive calculations,
    but think about bringing the partial results together for the final result
  id: totrans-1038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑对需要大量计算的程序进行并行处理，但要考虑将部分结果合并为最终结果
- en: Exercise – Multiplying all the stream elements
  id: totrans-1039
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习 - 将所有流元素相乘
- en: 'Multiply all the values of the following list using a stream:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流来将以下列表的所有值相乘：
- en: '```java'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: List<Integer> list = List.of(2, 3, 4);
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: List<Integer> list = List.of(2, 3, 4);
- en: '```'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Answer
  id: totrans-1044
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: '```java'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int r = list.stream().reduce(1, (x, y) -> x * y);
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: int r = list.stream().reduce(1, (x, y) -> x * y);
- en: 'System.out.println(r);     //prints: 24'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(r);     //打印：24
- en: '```'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Summary
  id: totrans-1049
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced the powerful concept of data-streams processing and
    provided many examples of functional programming usage. It explained what streams
    are, how to process them, and how to build processing pipelines. It also demonstrated
    how one can organize stream processing in parallel and some of the possible pitfalls.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了数据流处理的强大概念，并提供了许多函数式编程使用示例。它解释了流是什么，如何处理它们以及如何构建处理管道。它还演示了如何可以并行组织流处理以及一些可能的陷阱。
- en: In the next chapter, we are going to discuss reactive systems, their advantages,
    and possible implementations. You will learn about asynchronous non-blocking processing,
    reactive programming, and microservices, all with code examples that demonstrate
    the main principles on which these reactive systems are based.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论反应式系统，它们的优势以及可能的实现。您将了解异步非阻塞处理、反应式编程和微服务，所有这些都有代码示例，演示了这些反应式系统所基于的主要原则。
