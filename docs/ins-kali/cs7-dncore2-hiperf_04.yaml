- en: Data Structures and Writing Optimized Code in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构和在C#中编写优化代码
- en: Data structures are a particular way of storing data in software engineering.
    They play a vital role in storing data in a computer so that it can be accessed
    and modified efficiently, and they provide different storing mechanisms for storing
    different types of data. There are many types of data structure, and each one
    is designed to store a definite type of data. In this chapter, we will cover data
    structures in detail and learn which data structures should be used for particular
    scenarios in order to improve the performance of the system as regards data storage
    and retrieval. We will also learn how we can write optimized code in C# and what
    primary factors can affect performance, which is sometimes overlooked by developers
    when coding programs. We will learn some best practices that can be used to optimize
    code that is performance effective.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是软件工程中存储数据的一种特定方式。它们在计算机中存储数据方面发挥着重要作用，以便可以有效地访问和修改数据，并为存储不同类型的数据提供不同的存储机制。有许多类型的数据结构，每种都设计用于存储一定类型的数据。在本章中，我们将详细介绍数据结构，并了解应该在特定场景中使用哪些数据结构以改善系统在数据存储和检索方面的性能。我们还将了解如何在C#中编写优化代码以及什么主要因素可能影响性能，这有时在编写程序时被开发人员忽视。我们将学习一些可以用于优化性能有效的最佳实践。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What data structures are and their characteristics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构是什么以及它们的特点
- en: Choosing the right data structure for performance optimizations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择正确的数据结构进行性能优化
- en: Understand the use of Big O notation to measure the performance and complexity
    of a program
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解使用大O符号来衡量程序的性能和复杂性
- en: Best practices when writing code in .NET Core
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在.NET Core中编写代码时的最佳实践
- en: What are data structures?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是数据结构？
- en: A data structure is a way of storing and unifying data in such a way that operations
    on that data can be performed in an efficient manner. The data can be stored in
    several ways. For example, we can have a `Person` object that contains a few properties,
    such as `PersonID` and `PersonName`, where `PersonID` is of the integer type and
    `PersonName` is of the *string *type. This `Person` object stores the data in
    memory, and can be further used to save that record in the database. Another example
    is an array called `Countries` of the `string` type that contains a list of countries.
    We can use the `Countries` array to retrieve a country name and use it in a program.
    Therefore, any type of object that stores data is called a data structure. All
    primitive types, such as integers, strings, chars, and Booleans, are different
    types of data structure, whereas other collection types, such as `LinkedList`,
    `ArrayList`, `SortedList`, and others, are also types of data structure that can
    store information in exclusive ways.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是一种以有效的方式存储和统一数据的方式。数据可以以多种方式存储。例如，我们可以有一个包含一些属性的`Person`对象，例如`PersonID`和`PersonName`，其中`PersonID`是整数类型，`PersonName`是*字符串*类型。这个`Person`对象将数据存储在内存中，并可以进一步用于将该记录保存在数据库中。另一个例子是名为`Countries`的*字符串*类型的*数组*，其中包含国家列表。我们可以使用`Countries`数组来检索国家名称并在程序中使用它。因此，存储数据的任何类型的对象都称为数据结构。所有原始类型，例如整数、字符串、字符和布尔值，都是不同类型的数据结构，而其他集合类型，例如`LinkedList`、`ArrayList`、`SortedList`等，也是可以以独特方式存储信息的数据结构类型。
- en: 'The following diagram illustrates the types of data structures and their relationship
    to each other:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了数据结构的类型及其相互关系：
- en: '![](img/00045.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00045.jpeg)'
- en: 'There are two types of data structure: *primitive* and *nonprimitive* types.
    Primitive types are value types that include s*igned integral*, *unsigned integral*,
    *unicode characters*, *IEEE floating point*, *high-precision decimal*, *Boolean*,
    *enum*, *struct* and *nullable* value types.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构有两种类型：*原始*和*非原始*类型。原始类型是包括*有符号整数*、*无符号整数*、*Unicode字符*、*IEEE浮点*、*高精度小数*、*布尔*、*枚举*、*结构*和*可空*值类型的值类型。
- en: 'Here is a list of the primitive data types available in C#:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是C#中可用的原始数据类型列表：
- en: '| **Primitive types** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '**原始类型**'
- en: '| Signed integral | `sbyte`, `short`, `int`, `long` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 有符号整数 | `sbyte`, `short`, `int`, `long` |'
- en: '| Unsigned integral | `byte`, `ushort`, `uint`, `ulong` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: 无符号整数 | `byte`, `ushort`, `uint`, `ulong` |
- en: '| Unicode characters | `Char` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| Unicode字符 | `Char` |'
- en: '| IEEE floating point | `float`, `double` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| IEEE浮点 | `float`, `double` |'
- en: '| High-precision decimal | `Decimal` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 高精度小数 | `Decimal` |'
- en: '| Boolean | `Bool` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 布尔 | `Bool` |'
- en: '| String | `String` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `String` |'
- en: '| Object | `System.Object` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | `System.Object` |'
- en: Nonprimitive types are user-defined types, and further categorized as linear
    or nonlinear types. In a linear data structure, the elements are organized in
    a sequence, such as in *Array*, *Linked List*, and other related types, whereas
    in a nonlinear data structure, the elements are stored without any sequence, such
    as in *trees* and *graphs.*
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 非原始类型是用户定义的类型，并进一步分类为线性或非线性类型。在线性数据结构中，元素按顺序组织，例如*数组*、*链表*和其他相关类型，而在非线性数据结构中，元素存储在没有任何顺序的情况下，例如*树*和*图*。
- en: 'The following table shows the types of linear and nonlinear classes available
    in .NET Core:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了.NET Core中可用的线性和非线性类的类型：
- en: '| **Nonprimitive types - linear data structures** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **非原始类型 - 线性数据结构** |'
- en: '| Array | `ArrayList`, `String[]`, `primitive typed arrays`, `List`, `Dictionary`,
    `Hashtable`, `BitArray` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | `ArrayList`, `String[]`, `原始类型数组`, `List`, `Dictionary`, `Hashtable`,
    `BitArray` |'
- en: '| Stack | `Stack<T>`, `SortedSet<T>`, `SynchronizedCollection<T>` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 栈 | `Stack<T>`, `SortedSet<T>`, `SynchronizedCollection<T>` |'
- en: '| Queue | `Queue<T>` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 队列 | `Queue<T>` |'
- en: '| Linked list | `LinkedList<T>` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 链表 | `LinkedList<T>` |'
- en: .NET Core does not provide any nonprimitive, nonlinear types to represent data
    in tree or graph formats. However, we can develop custom classes to support these
    kinds of types.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core不提供任何非原始、非线性类型来表示树形或图形格式的数据。但是，我们可以开发自定义类来支持这些类型。
- en: 'For example, here is the code to write a custom tree that stores data in the
    tree format:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是编写存储数据的自定义树的代码格式：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Finally, we can write a program to populate a tree view on the console window
    as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以编写一个程序，在控制台窗口上填充树视图如下：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you run the preceding program, it generates the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上述程序时，它会生成以下输出：
- en: '![](img/00046.gif)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00046.gif)'
- en: Understanding the use of Big O notation to measure the performance and complexity
    of an algorithm
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解使用大O符号来衡量算法的性能和复杂性
- en: Big O notation is used to define the complexity and performance of an algorithm
    with respect to time or space consumed during execution. It is an essential technique
    to express the performance of an algorithm and determine the worst-case complexity
    of the program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 大O符号用于定义算法的复杂性和性能，以及在执行期间所消耗的时间或空间。这是一种表达算法性能并确定程序最坏情况复杂性的重要技术。
- en: To understand it in detail, let's go through some code examples and use Big
    O notation to calculate their performance.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了详细了解它，让我们通过一些代码示例并使用大O符号来计算它们的性能。
- en: 'If we calculate the complexity of the following program, the Big O notation
    will be equal to *O(1)*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们计算以下程序的复杂度，大O符号将等于*O(1)*：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is because, however the parameter is specified, it is just adding and returning
    it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为无论参数如何指定，它只是添加并返回它。
- en: 'Let''s consider another program that loops through the list. The Big O notation
    will be determined as *O(N)*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个循环遍历列表的程序。大O符号将被确定为*O(N)*：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, the program is looping through the item list and comparing
    the value passed as a parameter with each item in the list. If the item is found,
    the program returns `true`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，程序正在循环遍历项目列表，并将传递的值与列表中的每个项目进行比较。如果找到项目，则程序返回`true`。
- en: The complexity is determined as *O(N)* because the worst-case scenario could
    be a loop towards *N* items where *N* could be either a first index or any index
    until it reaches the last index, which is *N*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂度被确定为*O(N)*，因为最坏情况可能是一个循环向*N*个项目，其中*N*可以是第一个索引或任何索引，直到达到最后一个索引，即*N*。
- en: 'Now, let''s look at an example of the *selection sort*, which is defined as
    *O(N2)*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个*选择排序*的例子，它被定义为*O(N2)*：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, we have two loops that are nested. The first loop
    traverses from `0` to the last index, whereas the second loop traverses from the
    next item to the penultimate item and swaps the values to sort the array in ascending
    order. The number of nested loops is directly proportional to the power of *N*,
    hence the Big O notation is defined as *O(N2)*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们有两个嵌套的循环。第一个循环从`0`遍历到最后一个索引，而第二个循环从下一个项目遍历到倒数第二个项目，并交换值以按升序排序数组。嵌套循环的数量与*N*的幂成正比，因此大O符号被定义为*O(N2)*。
- en: 'Next, let''s consider a recursive function where the Big O notation is defined
    as *O(2N),* where *2N* determines the time taken, which doubles with each additional
    element in the input dataset that runs for an exponential period of time. Here
    is an example of a `Fibonacci_Recursive` method that recursively calls the method
    until the counter becomes equal to the maximum number:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑一个递归函数，其中大O符号被定义为*O(2N)*，其中*2N*确定所需的时间，随着输入数据集中每个额外元素的加入而加倍。以下是一个递归调用方法的示例，该方法递归调用方法，直到计数器变为最大数字为止：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Logarithms
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对数
- en: A logarithm operation is the complete opposite of an exponential operation.
    The logarithm is a  quantity representing the power to which a base number must
    be raised to produce a given number.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对数运算是指数运算的完全相反。对数是表示必须将基数提高到产生给定数字的幂的数量。
- en: For example, *2x = 32*, where *x=5*, can be represented as *log2 32 =5*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*2x = 32*，其中*x=5*，可以表示为*log2 32 =5*。
- en: In this case, the logarithm of above expression is 5 that represents the power
    of a fixed number 2 which is raised to produce a given number 32.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，上述表达式的对数是5，表示固定数字2的幂，它被提高以产生给定数字32。
- en: 'Consider a binary search algorithm that works more effectively by splitting
    the list of an item into two datasets and uses a specific dataset based on the
    number. For example, say that I have a list of different numbers sorted in ascending
    order:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个二分搜索算法，通过将项目列表分成两个数据集并根据数字使用特定数据集来更有效地工作。例如，假设我有一个按升序排列的不同数字列表：
- en: '*{1, 5, 6, 10, 15, 17, 20, 42, 55, 60, 67, 80, 100}*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*{1, 5, 6, 10, 15, 17, 20, 42, 55, 60, 67, 80, 100}*'
- en: Say that we want to find number *55*. One way to do this is to loop through
    each index and check each item one by one. The more effective way is to split
    the list into two sets and check whether the number I am looking for is greater
    than the last item of the first dataset or to use the second dataset.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要找到数字*55*。这样做的一种方法是循环遍历每个索引并逐个检查每个项目。更有效的方法是将列表分成两组，并检查我要查找的数字是否大于第一个数据集的最后一个项目，或者使用第二个数据集。
- en: 'Here is an example of a binary search whose Big O notation will be determined
    as *O(LogN)*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个二分搜索的示例，其大O符号将被确定为*O(LogN)*：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Choosing the right data structure for performance optimization
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择正确的数据结构进行性能优化
- en: A data structure is a precise way of organizing data in a computer program.
    If data is not efficiently stored in the right data structure, it may lead to
    some performance issues that impact the overall experience of the application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是计算机程序中组织数据的一种精确方式。如果数据没有有效地存储在正确的数据结构中，可能会导致一些影响应用程序整体体验的性能问题。
- en: 'In this section, we will learn the advantages and disadvantages of the different
    collection types available in .NET Core and which ones are the better types for
    particular scenarios:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习.NET Core中可用的不同集合类型的优缺点，以及哪些类型适用于特定场景：
- en: Arrays and lists
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和列表
- en: Stacks and queues
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈和队列
- en: LinkedLists (single, double, and circular)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表（单链表，双链表和循环链表）
- en: Dictionaries, hashtables, and hashsets
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典，哈希表和哈希集
- en: Generic lists
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用列表
- en: Arrays
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array is a collection that holds similar types of elements. Arrays of both
    value types and reference types can be created.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是保存相似类型元素的集合。可以创建值类型和引用类型的数组。
- en: 'Here are few circumstances where arrays are useful:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是数组有用的一些情况：
- en: If the data is of a fixed, set length, using an array is a better option as
    it is faster than other collections, such as `arraylists` and generic lists
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据是固定的，长度固定，使用数组比其他集合更快，例如`arraylists`和通用列表
- en: Arrays are good to represent data in a multidimensional way
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组很适合以多维方式表示数据
- en: They take less memory compared to other collections
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们占用的内存比其他集合少
- en: With arrays, we can iterate through elements sequentially
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组，我们可以顺序遍历元素
- en: 'The following table shows the Big O notation for each operation that can be
    performed in an array:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了可以在数组中执行的每个操作的大O符号：
- en: '| **Operations** | **Big O notation** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **大O符号** |'
- en: '| Access by Index | *O(1)* |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 按索引访问 | *O(1)* |'
- en: '| Search | *O(n)* |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 搜索 | *O(n)* |'
- en: '| Insert at the end | *O(n)* |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 在末尾插入 | *O(n)* |'
- en: '| Remove at the end | *O(n)* |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 在末尾删除 | *O(n)* |'
- en: '| Insert at a position before the last element | *O(n)* |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 在最后一个元素之前的位置插入 | *O(n)* |'
- en: '| Remove an element at an index | *O(1)* |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 删除索引处的元素 | *O(1)* |'
- en: As shown in the preceding table, the search for and insertion of an item in
    a specific position degrades performance, whereas accessing any item in an index
    or removing it from any position has a lower impact on performance.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，在特定位置搜索和插入项目会降低性能，而访问索引中的任何项目或从任何位置删除它对性能的影响较小。
- en: Lists
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are extensively used by .NET developers. Although it is preferable to
    use it in many scenarios, there are some performance limitations, too.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: .NET开发人员广泛使用列表。虽然在许多情况下最好使用它，但也存在一些性能限制。
- en: Using lists is mostly advisable when you want to access the item using its index.
    Unlike a linked list, where you have to iterate over each node using an enumerator
    to search for the item, with a list, we can easily access it using an index.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想使用索引访问项目时，大多数情况下建议使用列表。与链表不同，链表需要使用枚举器迭代每个节点来搜索项目，而使用列表，我们可以轻松使用索引访问它。
- en: 'Here are few recommendations where lists are useful:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是列表有用的一些建议：
- en: It is recommended that you use list when the collection size is not known. Resizing
    arrays is an expensive operation, and with lists we can easily grow the size of
    the collection by just adding to it as needed.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议在集合大小未知时使用列表。调整数组大小是一项昂贵的操作，而使用列表，我们可以根据需要轻松增加集合的大小。
- en: Unlike arrays, lists do not reserve the total memory address space for the number
    of items when it is created. This is because, with lists, specifying the size
    of the collection is not needed. On the other hand, arrays depend on the type
    and the size at which it is initialized, and reserve the address space during
    initialization.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与数组不同，列表在创建时不会为项目数量保留总内存地址空间。这是因为使用列表时不需要指定集合的大小。另一方面，数组依赖于初始化时的类型和大小，并在初始化期间保留地址空间。
- en: With lists, we can use lambda expressions to filter out records, sort items
    in descending order, and execute other operations. Arrays do not provide sorting,
    filtering, or other such operations.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用列表，我们可以使用lambda表达式来过滤记录，按降序对项目进行排序，并执行其他操作。数组不提供排序、过滤或其他此类操作。
- en: Lists represent a single dimension collection.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表表示单维集合。
- en: 'The following table shows the Big O notation for each operation that can be
    performed on lists:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了可以在列表上执行的每个操作的大O符号：
- en: '| **Operations** | **Big O notation** |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **大O符号** |'
- en: '| Access by index | *O(1)* |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 按索引访问 | *O(1)* |'
- en: '| Search | *O(n)* |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 搜索 | *O(n)* |'
- en: '| Insert at the end | *O(1)* |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 在末尾插入 | *O(1)* |'
- en: '| Remove from the end | *O(1)* |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 从末尾删除 | *O(1)* |'
- en: '| Insert at a position before the last element | *O(n)* |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 在最后一个元素之前的位置插入 | *O(n)* |'
- en: '| Remove an element at an index | *O(n)* |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 删除索引处的元素 | *O(n)* |'
- en: Stacks
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆栈
- en: 'Stacks maintain a collection of items in **Last In First Out** (**LIFO**) order.
    The last item to be inserted is retrieved first. Only two operations are allowed
    on stacks, namely `push` and `pop`. The real application of a stack is an `undo`
    operation that inserts the changes into the stack and, on undoing, removes the
    last action that was performed:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈以**后进先出**（**LIFO**）顺序维护项目的集合。最后插入的项目首先被检索。堆栈只允许两种操作，即`push`和`pop`。堆栈的真正应用是`undo`操作，它将更改插入堆栈中，并在撤消时删除执行的最后一个操作：
- en: '![](img/00047.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00047.jpeg)'
- en: The preceding diagram illustrates how the items are added to the stack. The
    last inserted item pops out first, and to access the first item that was inserted,
    we have to pop out each element until it reaches the first one.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 上图说明了如何将项目添加到堆栈中。最后插入的项目首先弹出，要访问首先插入的项目，我们必须弹出每个元素，直到达到第一个元素。
- en: 'Here are a few of the circumstance where stacks are useful:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些堆栈有用的情况：
- en: Scenarios where the item should be removed when its value is accessed
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问其值时应删除项目的情况
- en: Where an `undo` operation needs to be implemented in a program
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在程序中实现`undo`操作
- en: To maintain navigation history on a web application
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Web应用程序上维护导航历史记录
- en: Recursive operations
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归操作
- en: 'The following table shows the Big O notation for each operation that can be
    performed on stacks:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了可以在堆栈上执行的每个操作的大O符号：
- en: '| **Operations** | **Big O notation** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **大O符号** |'
- en: '| Access to the first object | *O(1)* |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 访问第一个对象 | *O(1)* |'
- en: '| Search | *O(n)* |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 搜索 | *O(n)* |'
- en: '| Push item | *O(1)* |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 推送项目 | *O(1)* |'
- en: '| Pop item | *O(1)* |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 弹出项目 | *O(1)* |'
- en: Queue
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: Queues maintain a collection of items in a **First In First Out** (**FIFO**)
    order. The item inserted into the queue first is retrieved first from the queue.
    Only three operations are allowed in queues, namely `Enqueue`, `Dequeue`, and
    `Peek`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 队列以**先进先出**（**FIFO**）顺序维护项目的集合。首先插入队列的项目首先从队列中检索。队列中只允许三种操作，即`Enqueue`，`Dequeue`和`Peek`。
- en: '`Enqueue` adds an element to the end of the queue, whereas `Dequeue` removes
    the element from the start of the queue. `Peek` returns the oldest elements in
    the queue but does not remove them:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enqueue`将元素添加到队列的末尾，而`Dequeue`从队列的开头移除元素。`Peek`返回队列中最旧的元素，但不会将它们移除：'
- en: '![](img/00048.gif)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00048.gif)'
- en: The preceding diagram illustrates how items are added to the queue. The item
    inserted first will be removed first from the queue and the pointer moves to the
    next item in the queue. `Peek` always returns the first item that was inserted or
    the item to which the pointer is set, based on whether the first item is removed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上图说明了如何将项目添加到队列。首先插入的项目将首先从队列中移除，并且指针移动到队列中的下一个项目。`Peek`始终返回第一个插入的项目或指针所指向的项目，取决于是否移除了第一个项目。
- en: 'Here are some of the circumstances where queues are useful:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是队列有用的一些情况：
- en: To process items in a sequence
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按顺序处理项目
- en: To serve an order based on a first-come-first-served basis
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按先来先服务的顺序提供服务
- en: 'The following table shows the Big O notation for each operation that can be
    performed on queues:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了可以在队列上执行的每个操作的大O表示法：
- en: '| **Operations** | **Big O notation** |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **大O表示法** |'
- en: '| Access to the first object inserted | *O(1)* |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 访问第一个插入的对象 | *O(1)* |'
- en: '| Search | *O(n)* |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 搜索 | *O(n)* |'
- en: '| Queue item | *O(1)* |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 队列项目 | *O(1)* |'
- en: '| Enqueue item | *O(1)* |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 入队项目 | *O(1)* |'
- en: '| Peek item | *O(1)* |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| Peek项目 | *O(1)* |'
- en: Linked lists
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表
- en: The linked list is a linear data structure where each node in the list contains
    the reference pointer to the next node, and the last node has a reference to null.
    The first node is known as the head. There are three types of linked list, known
    as *singly*, *doubly*, and *circular* linked lists.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 链表是一种线性数据结构，其中列表中的每个节点都包含对下一个节点的引用指针，最后一个节点引用为null。第一个节点称为头节点。有三种类型的链表，称为*单向*，*双向*和*循环*链表。
- en: Singly linked lists
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单链表
- en: 'Singly linked lists contain only the reference to the next node. The following
    diagram represents the singly linked list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表只包含对下一个节点的引用。以下图表示单链表：
- en: '![](img/00049.gif)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00049.gif)'
- en: Doubly linked lists
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双向链表
- en: 'In doubly linked lists, the nodes contain the references of both the next node
    and the previous node. The user can iterate forward and backward using reference
    pointers. The following image is a representation of a doubly linked list:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向链表中，节点包含对下一个节点和上一个节点的引用。用户可以使用引用指针向前和向后迭代。以下图像是双向链表的表示：
- en: '![](img/00050.gif)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00050.gif)'
- en: Circular linked lists
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环链表
- en: 'In circular linked lists, the last node points back to the first node. Here
    is a representation of a circular linked list:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环链表中，最后一个节点指向第一个节点。以下是循环链表的表示：
- en: '![](img/00051.gif)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.gif)'
- en: 'Here are a few circumstances where a linked list is useful:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是链表有用的一些情况：
- en: To provide access to an item in a sequential manner
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以顺序方式提供对项目的访问
- en: Insert an item in any position of the list
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表的任何位置插入项目
- en: Remove any item at any point or node
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何位置或节点删除任何项目
- en: When you need to consume less memory, as there is no array copy in the linked
    list
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要消耗更少的内存时，因为链表中没有数组复制
- en: 'The following table shows the Big O notation value for each operation that
    can be performed on linked lists:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了可以在链表上执行的每个操作的大O表示法值：
- en: '| **Operations** | **Big O notation** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **大O表示法** |'
- en: '| Access the item | *O(1)* |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 访问项目 | *O(1)* |'
- en: '| Search for the item | *O(n)* |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 搜索项目 | *O(n)* |'
- en: '| Insert item | *O(1)* |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 插入项目 | *O(1)* |'
- en: '| Delete item | *O(1)* |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 删除项目 | *O(1)* |'
- en: Dictionaries, hashtables, and hashsets
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字典，哈希表和哈希集
- en: 'Dictionary, hashtable, and hashset objects store items in key—value format.
    However, hashsets and dictionaries are good for scenarios where performance is
    key. Here are a few circumstances where these types are useful:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 字典，哈希表和哈希集对象以键-值格式存储项目。但是，哈希集和字典适用于性能至关重要的场景。以下是这些类型有用的一些情况：
- en: To store an item in key–value format that can be retrieved based on a particular
    key
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以键-值格式存储可以根据特定键检索的项目
- en: To store unique values
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储唯一值
- en: 'The following table shows the Big O notation value for each operation that
    can be performed on these objects:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了可以在这些对象上执行的每个操作的大O表示法值：
- en: '| **Operations** | **Big O notation** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **大O表示法** |'
- en: '| Access | *O(n)* |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 访问 | *O(n)* |'
- en: '| Search for the value if the key is not known | *O(n)* |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 如果不知道键，则搜索值 | *O(n)* |'
- en: '| Insert item | *O(n)* |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 插入项目 | *O(n)* |'
- en: '| Delete item | *O(n)* |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 删除项目 | *O(n)* |'
- en: Generic lists
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用列表
- en: The generic list is a strongly typed list of elements that is accessed using
    an index. In contrast to arrays, generic lists are expandable, and the list can
    grow dynamically; for this reason, they are known as dynamics arrays or vectors.
    Unlike arrays, generic lists are one dimensional, and are one of the best options
    for manipulating an in-memory collection of elements.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通用列表是一种强类型的元素列表，可以使用索引访问。与数组不同，通用列表是可扩展的，列表可以动态增长；因此，它们被称为动态数组或向量。与数组不同，通用列表是一维的，是操作内存中元素集合的最佳选择之一。
- en: 'We can define a generic list as shown in the following code example. The code
    phrase `lstNumbers` allows only integer values to be stored, the phrase `lstNames`
    stores the `only` string, `personLst` stores `Person` objects, and so on:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个通用列表，如下面的代码示例所示。代码短语`lstNumbers`只允许存储整数值，短语`lstNames`存储`only`字符串，`personLst`存储`Person`对象，等等：
- en: '[PRE7]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following table shows the Big O notation value for each operation that
    can be performed on these objects:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了可以在这些对象上执行的每个操作的大O符号值：
- en: '| **Operations** | **Big O notation**                                     
        |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **操作** | **大O符号** |'
- en: '| Access by index | *O(1)* |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 通过索引访问 | *O(1)* |'
- en: '| Search | *O(n)* |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 搜索 | *O(n)* |'
- en: '| Insert at the end | *O(1)* |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 在末尾插入 | *O(1)* |'
- en: '| Remove from the end | *O(1)* |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 从末尾删除 | *O(1)* |'
- en: '| Insert at a position before the last element | *O(n)* |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 在最后一个元素之前的位置插入 | *O(n)* |'
- en: '| Remove an element at an index | *O(n)* |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 删除索引处的元素 | *O(n)* |'
- en: Best practices in writing optimized code in C#
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中编写优化代码的最佳实践
- en: There are many factors that negatively impact the performance of a .NET Core
    application. Sometimes these are minor things that were not considered earlier
    at the time of writing the code, and are not addressed by the accepted best practices.
    As a result, to solve these problems, programmers often resort to ad hoc solutions.
    However, when bad practices are combined together, they produce performance issues.
    It is always better to know the best practices that help developers write cleaner
    code and make the application performant.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多因素会对.NET Core应用程序的性能产生负面影响。有时这些是在编写代码时未考虑的小事情，并且不符合已接受的最佳实践。因此，为了解决这些问题，程序员经常求助于临时解决方案。然而，当不良实践结合在一起时，它们会产生性能问题。了解有助于开发人员编写更清洁的代码并使应用程序性能良好的最佳实践总是更好的。
- en: 'In this section, we will learn, the following topics:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习以下主题：
- en: Boxing and unboxing overhead
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装箱和拆箱开销
- en: String concatenation
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串连接
- en: Exceptions handling
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: '`for` versus `foreach`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`与`foreach`'
- en: Delegates
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托
- en: Boxing and unboxing overhead
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装箱和拆箱开销
- en: The boxing and unboxing methods are not always good to use and they negatively
    impact the performance of mission-critical applications. Boxing is a method of
    converting a value type to an object type, and is done implicitly, whereas unboxing
    is a method of converting an object type back to a value type and requires explicit
    casting.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 装箱和拆箱方法并不总是好用的，它们会对关键任务应用程序的性能产生负面影响。装箱是将值类型转换为对象类型的方法，它是隐式完成的，而拆箱是将对象类型转换回值类型的方法，需要显式转换。
- en: 'Let''s go through an example where we have two methods executing a loop of
    10 million records, and in each iteration, they are incrementing the counter by
    1\. The `AvoidBoxingUnboxing` method is using a primitive integer to initialize
    and increment it on each iteration, whereas the `BoxingUnboxing` method is boxing
    by assigning the numeric value to the object type first and then unboxing it on
    each iteration to convert it back to the integer type, as shown in the following
    code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看，我们有两种方法执行1000万条记录的循环，每次迭代时都会将计数器加1。`AvoidBoxingUnboxing`方法使用原始整数来初始化并在每次迭代时递增，而`BoxingUnboxing`方法是通过首先将数值赋给对象类型进行装箱，然后在每次迭代时进行拆箱以将其转换回整数类型，如下所示：
- en: '[PRE8]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we run both methods, we will clearly see the differences in performance.
    The `BoxingUnboxing` is executed seven times slower than the `AvoidBoxingUnboxing`
    method, as shown in the following screenshot:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这两种方法时，我们将清楚地看到性能上的差异。如下截图所示，`BoxingUnboxing`方法的执行速度比`AvoidBoxingUnboxing`方法慢了七倍：
- en: '![](img/00052.gif)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.gif)'
- en: For mission-critical applications, it's always better to avoid boxing and unboxing.
    However, in .NET Core, we have many other types that internally use objects and
    perform boxing and unboxing. Most of the types under `System.Collections` and
    `System.Collections.Specialized` use objects and object arrays for internal storage,
    and when we store primitive types in these collections, they perform boxing and
    convert each primitive value to an object type, adding extra overhead and negatively
    impacting the performance of the application. Other types of `System.Data`, namely
    `DateSet`, `DataTable`, and `DataRow`, also use object arrays under the hood.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关键任务应用程序，最好避免装箱和拆箱。然而，在.NET Core中，我们有许多其他类型，内部使用对象并执行装箱和拆箱。`System.Collections`和`System.Collections.Specialized`下的大多数类型在内部存储时使用对象和对象数组，当我们在这些集合中存储原始类型时，它们执行装箱并将每个原始值转换为对象类型，增加额外开销并对应用程序的性能产生负面影响。`System.Data`的其他类型，即`DateSet`，`DataTable`和`DataRow`，也在内部使用对象数组。
- en: Types under the `System.Collections.Generic` namespace or typed arrays are the
    best approaches to use when performance is the primary concern. For example, `HashSet<T>`,
    `LinkedList<T>`, and `List<T>` are all types of generic collections.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能是主要关注点时，`System.Collections.Generic`命名空间下的类型或类型化数组是最佳的方法。例如，`HashSet<T>`，`LinkedList<T>`和`List<T>`都是通用集合类型。
- en: 'For example, here is a program that stores the integer value in `ArrayList`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个将整数值存储在`ArrayList`中的程序：
- en: '[PRE9]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s write another program that uses a generic list of the integer type:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写另一个使用整数类型的通用列表的程序：
- en: '[PRE10]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When running both programs, the differences are pretty noticeable. The code
    with the generic list `List<int>` is over 10 times faster than the code with `ArrayList`.
    The result is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这两个程序时，差异是非常明显的。使用通用列表`List<int>`的代码比使用`ArrayList`的代码快了10倍以上。结果如下：
- en: '![](img/00053.gif)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.gif)'
- en: String concatenation
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串连接
- en: In .NET, strings are immutable objects. Two strings refer to the same memory
    on the heap until the string value is changed. If any of the string is changed,
    a new string is created on the heap and is allocated a new memory space. Immutable
    objects are generally thread safe and eliminate the race conditions between multiple
    threads. Any change in the string value creates and allocates a new object in
    memory and avoids producing conflicting scenarios with multiple threads.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，字符串是不可变对象。直到字符串值改变之前，两个字符串引用堆上的相同内存。如果任何一个字符串被改变，将在堆上创建一个新的字符串，并分配一个新的内存空间。不可变对象通常是线程安全的，并消除了多个线程之间的竞争条件。字符串值的任何更改都会在内存中创建并分配一个新对象，并避免与多个线程产生冲突的情况。
- en: 'For example, let''s initialize the string and assign the `Hello World` value to
    the  `a` string variable:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们初始化字符串并将`Hello World`的值分配给`a`字符串变量：
- en: '[PRE11]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s assign the  `a` string variable to another variable, `b`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将`a`字符串变量分配给另一个变量`b`：
- en: '[PRE12]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Both `a` and `b` point to the same value on the heap, as shown in the following
    diagram:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`和`b`都指向堆上的相同值，如下图所示：'
- en: '![](img/00054.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.jpeg)'
- en: 'Now, suppose we change the value of `b` to `Hope this helps`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们将`b`的值更改为`Hope this helps`：
- en: '[PRE13]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will create another object on the heap, where `a` points to the same and
    `b` refers to the new memory space that contains the new text:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在堆上创建另一个对象，其中`a`指向相同的对象，而`b`指向包含新文本的新内存空间：
- en: '![](img/00055.gif)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.gif)'
- en: With each change in the string, the object allocates a new memory space. In
    some cases, it may be an overkill scenario, where the frequency of string modification
    is higher and each modification is allocated a separate memory space, creates
    work for the garbage collector in collecting the unused objects and freeing up
    space. In such a scenario, it is highly recommended that you use the `StringBuilder`
    class.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 随着字符串的每次更改，对象都会分配一个新的内存空间。在某些情况下，这可能是一个过度的情况，其中字符串修改的频率较高，并且每次修改都会分配一个单独的内存空间，这会导致垃圾收集器在收集未使用的对象并释放空间时产生额外的工作。在这种情况下，强烈建议您使用`StringBuilder`类。
- en: Exception handling
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: 'Improper handling of exceptions also decreases the performance of an application.
    The following list contains some of the best practices in dealing with exceptions
    in .NET Core:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不正确处理异常也会降低应用程序的性能。以下列表包含了在.NET Core中处理异常的一些最佳实践：
- en: Always use a specific exception type or a type that can catch the exception
    for the code you have written in the method. Using the `Exception` type for all
    cases is not a good practice.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用特定的异常类型或可以捕获方法中的异常的类型。对所有情况使用`Exception`类型不是一个好的做法。
- en: It is always a good practice to use `try`, `catch`, and finally `block` where
    the code can throw exceptions. The final block is usually used to clean up the
    resources, and returns a proper response that the calling code is expecting.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能引发异常的代码中，始终使用`try`、`catch`和`finally`块。通常使用最终块来清理资源，并返回调用代码期望的适当响应。
- en: In deeply nested code, don't use `try catch` block and handle it to the calling
    method or main method. Catching exceptions on multiple stacks slows down performance
    and is not recommended.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在嵌套深的代码中，不要使用`try catch`块，而是将其处理给调用方法或主方法。在多个堆栈上捕获异常会减慢性能，不建议这样做。
- en: Always use exceptions for fatal conditions that terminate the program.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用异常处理程序来处理终止程序的致命条件。
- en: Using exceptions for noncritical conditions, such as converting the value to
    an integer or reading the value from an empty array, is not recommended and should
    be handled through custom logic. For example, converting a string value to the
    integer type can be done by using the `Int32.Parse` method rather than by using
    the `Convert.ToInt32` method and then failing at a point when the string is not
    represented as a digit.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不建议对非关键条件使用异常，例如将值转换为整数或从空数组中读取值，并且应通过自定义逻辑进行处理。例如，将字符串值转换为整数类型可以使用`Int32.Parse`方法，而不是使用`Convert.ToInt32`方法，然后在字符串表示为数字时失败。
- en: 'While throwing an exception, add a meaningful message so that the user knows
    where that exception has actually occurred rather than going through the stack
    trace. For example, the following code shows a way of throwing an exception and
    adding a custom message based on the method and class being called:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在抛出异常时，添加一个有意义的消息，以便用户知道异常实际发生的位置，而不是查看堆栈跟踪。例如，以下代码显示了抛出异常并根据所调用的方法和类添加自定义消息的方法：
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Throw exceptions rather than returning the custom messages or error codes and
    handle it in the main calling method.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常而不是返回自定义消息或错误代码，并在主调用方法中处理它。
- en: When logging exceptions, always check the inner exception and read the exception
    message or stack trace. It is helpful, and gives the actual point in the code
    where the error is thrown.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在记录异常时，始终检查内部异常并阅读异常消息或堆栈跟踪。这是有帮助的，并且可以给出代码中实际引发错误的位置。
- en: For and foreach
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`for`和`foreach`'
- en: For and foreach are two of the alternative ways of iterating over a list of
    items. Each of them operates in a different way. The for loop actually loads all
    the items of the list in memory first and then uses an indexer to iterate over
    each element, whereas foreach uses an enumerator and iterates until it reaches
    the end of the list.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`和`foreach`是在列表中进行迭代的两种替代方式。它们每个都以不同的方式运行。for循环实际上首先将列表的所有项加载到内存中，然后使用索引器迭代每个元素，而foreach使用枚举器并迭代直到达到列表的末尾。'
- en: 'The following table shows the types of collections that are good to use for
    `for` and `foreach`:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了适合在`for`和`foreach`中使用的集合类型：
- en: '| **Type** | **For/Foreach** |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **For/Foreach** |'
- en: '| Typed array | Good for both |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 类型化数组 | 适合使用for和foreach |'
- en: '| Array list | Better with for |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 数组列表 | 更适合使用for |'
- en: '| Generic collections | Better with for  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 通用集合 | 更适合使用for |'
- en: Delegates
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托
- en: Delegates are a type in .NET which hold the reference to the method. The type
    is equivalent to the function pointer in C or C++. When defining a delegate, we
    can specify both the parameters that the method can take and its return type.
    This way, the reference methods will have the same signature.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 委托是.NET中保存方法引用的一种类型。该类型相当于C或C++中的函数指针。在定义委托时，我们可以指定方法可以接受的参数和返回类型。这样，引用方法将具有相同的签名。
- en: 'Here is a simple delegate that takes a string and returns an integer:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的委托，它接受一个字符串并返回一个整数：
- en: '[PRE15]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, suppose we have a `LogToConsole` method that has the same signature as
    the one shown in the following code. This method takes the string and writes it
    to the console window:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个`LogToConsole`方法，它具有与以下代码中所示的相同签名。该方法接受字符串并将其写入控制台窗口：
- en: '[PRE16]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can initialize and use this delegate like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样初始化和使用这个委托：
- en: '[PRE17]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Suppose we have another method called `LogToDatabase` that writes the information
    in the database:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有另一个名为`LogToDatabase`的方法，它将信息写入数据库：
- en: '[PRE18]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the initialization of the new `logDelegate` instance that references
    the `LogToDatabase` method:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的`logDelegate`实例的初始化，它引用了`LogToDatabase`方法：
- en: '[PRE19]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding delegate is the representation of unicast delegates, as each
    instance refers to a single method. On the other hand, we can also create multicast
    delegates by assigning  `LogToDatabase` to the same `LogDelegate` instance, as
    follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的委托是单播委托的表示，因为每个实例都引用一个方法。另一方面，我们也可以通过将`LogToDatabase`分配给相同的`LogDelegate`实例来创建多播委托，如下所示：
- en: '[PRE20]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code seems pretty straightforward and optimized, but under the
    hood, it has a huge performance overhead. In .NET, delegates are implemented by
    a `MutlicastDelegate` class that is optimized to run unicast delegates. It stores
    the reference of the method to the target property and calls the method directly.
    For multicast delegates, it uses the invocation list, which is a generic list,
    and holds the references to each method that is added. With multicast delegates,
    each target property holds the reference to the generic list that contains the
    method and executes in sequence. However, this adds an overhead for multicast
    delegates and takes more time to execute.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码看起来非常直接和优化，但在底层，它有巨大的性能开销。在.NET中，委托是由一个`MutlicastDelegate`类实现的，它经过优化以运行单播委托。它将方法的引用存储到目标属性，并直接调用该方法。对于多播委托，它使用调用列表，这是一个通用列表，并保存添加的每个方法的引用。对于多播委托，每个目标属性都保存对包含方法的通用列表的引用，并按顺序执行。然而，这会为多播委托增加开销，并且需要更多时间来执行。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned the core concepts about data structures, the
    types of data structures, as well as their advantages and disadvantages, followed
    by the best possible scenarios in which each can be used. We also learned about
    the Big O notation, which is one of the core topics to consider when writing code
    and helps developers to identify code performance. Finally, we looked into some
    best practices and covered topics such as boxing and unboxing, string concatenation,
    exception handling, `for` and `foreach` loops, and delegates.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了关于数据结构的核心概念，数据结构的类型，以及它们的优缺点，接着是它们可以使用的最佳场景。我们还学习了大O符号，这是编写代码时需要考虑的核心主题之一，它帮助开发人员识别代码性能。最后，我们研究了一些最佳实践，并涵盖了诸如装箱和拆箱、字符串连接、异常处理、`for`和`foreach`循环以及委托等主题。
- en: In the next chapter, we will learn some guidelines and best practices that could
    be helpful when designing .NET Core applications.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一些在设计.NET Core应用程序时可能有帮助的准则和最佳实践。
