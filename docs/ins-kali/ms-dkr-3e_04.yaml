- en: Managing Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理容器
- en: So far, we have been concentrating on how to build, store, and distribute our
    Docker images. Now we are going to look at how we can launch containers, and also
    how we can use the Docker command-line client to manage and interact with them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在集中讨论如何构建、存储和分发我们的Docker镜像。现在我们将看看如何启动容器，以及如何使用Docker命令行客户端来管理和与它们交互。
- en: We will be revisiting the commands we used in the first chapter by going into
    a lot more detail, before delving deeper into the commands that are available.
    Once we are familiar with the container commands, we will look at Docker networks
    and Docker volumes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新访问我们在第一章中使用的命令，并更详细地了解，然后深入了解可用的命令。一旦我们熟悉了容器命令，我们将看看Docker网络和Docker卷。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: 'Docker container commands:'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker容器命令：
- en: The basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础知识
- en: Interacting with your containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与您的容器交互
- en: Logs and process information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志和进程信息
- en: Resource limits
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源限制
- en: Container states and miscellaneous commands
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器状态和其他命令
- en: Removing containers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除容器
- en: Docker networking and volumes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网络和卷
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will continue to use our local Docker installation. As before,
    the screenshots in this chapter will be from my preferred operating system, macOS, but the Docker
    commands we will be running will work on all three of the operating systems on
    which we have installed Docker so far; however, some of the supporting commands,
    which will be few and far between, may be applicable only to macOS and Linux-based
    operating systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续使用我们的本地Docker安装。与之前一样，本章中的截图将来自我首选的操作系统macOS，但我们将运行的Docker命令将在迄今为止安装了Docker的三种操作系统上都可以工作；但是，一些支持命令可能只适用于macOS和基于Linux的操作系统。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看代码的实际操作：
- en: '[http://bit.ly/2yupP3n](http://bit.ly/2yupP3n)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2yupP3n](http://bit.ly/2yupP3n)'
- en: Docker container commands
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker容器命令
- en: Before we dive into the more complex Docker commands, let's review and go into
    a little more detail on the commands we have used in previous chapters.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究更复杂的Docker命令之前，让我们回顾并更详细地了解我们在之前章节中使用的命令。
- en: The basics
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: 'In [Chapter 1](db23d482-1df4-41c2-af33-d38a98fc5a1c.xhtml), *Docker Overview*,
    we launched the most basic container of all, the `hello-world` container, using
    the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](db23d482-1df4-41c2-af33-d38a98fc5a1c.xhtml)中，*Docker概述*，我们使用以下命令启动了最基本的容器`hello-world`容器：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you may recall, this command pulls a 1.84 KB image from the Docker Hub.
    You can find the Docker Store page for the image at [https://store.docker.com/images/hello-world/](https://store.docker.com/images/hello-world/),
    and as per the following Dockerfile, it runs an executable called `hello`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能还记得，这个命令从Docker Hub拉取了一个1.84 KB的镜像。您可以在[https://store.docker.com/images/hello-world/](https://store.docker.com/images/hello-world/)找到该镜像的Docker
    Store页面，并且根据以下Dockerfile，它运行一个名为`hello`的可执行文件：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `hello` executable prints the `Hello from Docker!` text to the Terminal,
    and then the process exits. As you can see from the full message text in the following
    Terminal output, the `hello` binary also lets you know exactly what steps have
    just occurred:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello`可执行文件将`Hello from Docker!`文本打印到终端，然后进程退出。从以下终端输出的完整消息文本中可以看出，`hello`二进制文件还会告诉您刚刚发生了什么步骤：'
- en: '![](Images/60c57d8f-1e69-4387-ae4f-61328267a54a.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/60c57d8f-1e69-4387-ae4f-61328267a54a.png)'
- en: 'As the process exits, our container also stops; this can be seen by running
    the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随着进程退出，我们的容器也会停止；可以通过运行以下命令来查看：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the command is given here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下：
- en: '![](Images/00190aaa-8351-4217-a20a-9a5f46206da2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/00190aaa-8351-4217-a20a-9a5f46206da2.png)'
- en: You may notice in the Terminal output that I first ran `docker container ls`
    with and without the `-a` flag—this is shorthand for `--all`, as running it without
    the flag does not show any exited containers.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到在终端输出中，我首先运行了带有和不带有`-a`标志的`docker container ls`命令——这是`--all`的缩写，因为不带标志运行它不会显示任何已退出的容器。
- en: We didn't have to name our container as it wasn't around long enough for us
    to care what it was called. Docker automatically assigns names for containers,
    though, and in my case, you can see that it was called `pensive_hermann`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必给我们的容器命名，因为它存在的时间不够长，我们也不在乎它叫什么。Docker会自动为容器分配名称，而在我的情况下，你可以看到它被称为`pensive_hermann`。
- en: 'You will notice, throughout your use of Docker, that it comes up with some
    really interesting names for your containers if you choose to let it generate
    them for you. Although this is slightly off-topic, the code to generate the names
    can be found in `names-generator.go`. Right at the end of the source code, it
    has the following `if` statement:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，在您使用Docker的过程中，如果选择让它为您生成容器，它会为您的容器起一些非常有趣的名字。尽管这有点离题，但生成这些名称的代码可以在`names-generator.go`中找到。在源代码的最后，它有以下的`if`语句：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means there will never be a container called `boring_wozniak` (and quite
    rightly, too).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着永远不会有一个名为`boring_wozniak`的容器（这也是完全正确的）。
- en: Steve Wozniak is an inventor, electronics engineer, programmer, and entrepreneur
    who co-founded Apple Inc. with Steve Jobs. He is known as a pioneer of the personal
    computer revolution of the 70s and 80s, and is definitely not boring!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Steve Wozniak是一位发明家、电子工程师、程序员和企业家，他与史蒂夫·乔布斯共同创立了苹果公司。他被誉为70年代和80年代个人电脑革命的先驱，绝对不是无聊的！
- en: 'We can remove the container with a status of `exited` by running the following
    command, making sure that you replace the name of the container with your own
    container name:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令删除状态为`exited`的容器，确保您用您自己的容器名称替换掉命令中的容器名称：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, at the end of [Chapter 1](db23d482-1df4-41c2-af33-d38a98fc5a1c.xhtml),
    *Docker Overview*, we launched a container using the official nginx image, using
    the following command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，在[第1章](db23d482-1df4-41c2-af33-d38a98fc5a1c.xhtml) *Docker概述*的结尾，我们使用官方nginx镜像启动了一个容器，使用以下命令： '
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you may remember, this downloads the image and runs it, mapping port `8080`
    on our host machine to port `80` on the container, and calls it `nginx-test`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能记得的那样，这会下载镜像并运行它，将我们主机上的端口`8080`映射到容器上的端口`80`，并将其命名为`nginx-test`：
- en: '![](Images/796a8134-aa46-4c0a-b133-d47ebca3ad68.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/796a8134-aa46-4c0a-b133-d47ebca3ad68.png)'
- en: 'As you can see, running `docker image ls` shows us that we now have two images
    downloaded and also running. The following command shows us that we have a running
    container:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从我们的`docker image ls`命令中可以看到的，我们现在已经下载并运行了两个镜像。以下命令显示我们有一个正在运行的容器：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following Terminal output shows that mine had been up for 5 minutes when
    I ran the command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下终端输出显示，当我运行该命令时，我的容器已经运行了5分钟：
- en: '![](Images/f002c3b3-9feb-4993-8137-95b09982b12c.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f002c3b3-9feb-4993-8137-95b09982b12c.png)'
- en: As you can see from our `docker container run` command, we introduced three
    flags. One of them was `-d`, which is shorthand for `--detach`. If we hadn't added
    this flag, then our container would have executed in the foreground, which means
    that our Terminal would have been frozen until we passed the process an escape
    command by pressing *Ctrl* + *C*.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的`docker container run`命令中可以看到，我们引入了三个标志。其中一个是`-d`，它是`--detach`的缩写。如果我们没有添加这个标志，那么我们的容器将在前台执行，这意味着我们的终端会被冻结，直到我们通过按下*Ctrl*
    + *C*传递进程的退出命令。
- en: 'We can see this in action by running the following command to launch a second
    `nginx` container to run alongside the container we have already launched:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来看到这一点，以启动第二个`nginx`容器与我们已经启动的容器一起运行：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once launched, open a browser and go to `http://localhost:9090/`. As you load
    the page, you will notice that your page visit is printed to the screen; hitting
    refresh in your browser will display more hits, until you press *Ctrl* + *C* back
    in the Terminal.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，打开浏览器并转到`http://localhost:9090/`。当您加载页面时，您会注意到您的页面访问被打印到屏幕上；在浏览器中点击刷新将显示更多的访问量，直到您在终端中按下*Ctrl*
    + *C*。
- en: '![](Images/5f74deb2-6202-486b-b99e-542262ab4569.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5f74deb2-6202-486b-b99e-542262ab4569.png)'
- en: 'Running `docker container ls -a` shows that you have two containers, one of
    which has exited:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker container ls -a`显示您有两个容器，其中一个已退出：
- en: '![](Images/595d8d02-f115-4928-9bc6-689caa8046a2.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/595d8d02-f115-4928-9bc6-689caa8046a2.png)'
- en: So what happened? When we removed the detach flag, Docker connected us to the
    nginx process directly within the container, meaning that we had visibility of
    `stdin`, `stdout`, and `stderr` for that process. When we used *Ctrl* + *C*, we
    actually sent an instruction to the nginx process to terminate it. As that was
    the process that was keeping our container running, the container exited immediately
    once there was no longer a running process.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？当我们移除了分离标志时，Docker直接将我们连接到容器内的nginx进程，这意味着我们可以看到该进程的`stdin`、`stdout`和`stderr`。当我们使用*Ctrl*
    + *C*时，实际上是向nginx进程发送了一个终止指令。由于那是保持容器运行的进程，一旦没有运行的进程，容器立即退出。
- en: Standard input (`stdin`) is the handle that our process reads to get information
    from the end user. Standard output (`stdout`) is where the process writes normal
    information to. Standard error (`stderr`) is where the process writes error messages
    to.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输入（`stdin`）是我们的进程用来从最终用户那里获取信息的句柄。标准输出（`stdout`）是进程写入正常信息的地方。标准错误（`stderr`）是进程写入错误消息的地方。
- en: Another thing you may have noticed when we launched the `nginx-foreground` container
    is that we gave it a different name using the `--name` flag.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动`nginx-foreground`容器时，您可能还注意到我们使用`--name`标志为其指定了不同的名称。
- en: 'This is because you cannot have two containers with the same name, since Docker
    gives you the option of interacting with your containers using both the `CONTAINER
    ID` or `NAME` values. This is the reason the name generator function exists: to
    assign a random name to containers you do not wish to name yourself—and also to
    ensure that we never call Steve Wozniak boring.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为您不能使用相同的名称拥有两个容器，因为Docker允许您使用`CONTAINER ID`或`NAME`值与容器进行交互。这就是名称生成器函数存在的原因：为您不希望自己命名的容器分配一个随机名称，并确保我们永远不会称史蒂夫·沃兹尼亚克为无聊。
- en: 'The final thing to mention is that when we launched `nginx-foreground`, we
    asked Docker to map port `9090` to port `80` on the container. This was because
    we cannot assign more than one process to a port on a host machine, so if we attempted
    to launch our second container with the same port as the first, we would have
    received an error message:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要提到的是，当我们启动`nginx-foreground`时，我们要求Docker将端口`9090`映射到容器上的端口`80`。这是因为我们不能在主机上的一个端口上分配多个进程，因此如果我们尝试使用与第一个相同的端口启动第二个容器，我们将收到错误消息：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Also, since we are running the container in the foreground, you may receive
    an error from the nginx process, as it failed to start:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们在前台运行容器，您可能会收到来自nginx进程的错误，因为它未能启动：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, you may also notice that we are mapping to port 80 on the container—why
    no error there?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能还注意到我们将端口映射到容器上的端口80——为什么没有错误？
- en: Well, as explained in [Chapter 1](db23d482-1df4-41c2-af33-d38a98fc5a1c.xhtml),
    *Docker Overview*, the containers themselves are isolated resources, which means
    that we can launch as many containers as we like with port 80 remapped, and they
    will never clash with other containers; we only run into problems when we want
    to route to the exposed container port from our Docker host.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，正如在[第1章](db23d482-1df4-41c2-af33-d38a98fc5a1c.xhtml)中解释的那样，*Docker概述*，容器本身是隔离的资源，这意味着我们可以启动尽可能多的容器，并重新映射端口80，它们永远不会与其他容器冲突；当我们想要从Docker主机路由到暴露的容器端口时，我们只会遇到问题。
- en: Let's keep our nginx container running for the next section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保持我们的nginx容器在下一节中继续运行。
- en: Interacting with your containers
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与您的容器进行交互
- en: So far, our containers have been running a single process. Docker provides you
    with a few tools that enable you to both fork additional processes and interact
    with them.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的容器一直在运行单个进程。Docker为您提供了一些工具，使您能够fork额外的进程并与它们交互。
- en: attach
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: attach
- en: 'The first way of interacting with your running container is to `attach` to
    the running process. We still have our `nginx-test` container running, so let''s
    connect to that by running this command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与正在运行的容器进行交互的第一种方法是`attach`到正在运行的进程。我们仍然有我们的`nginx-test`容器在运行，所以让我们通过运行这个命令来连接到它：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Opening your browser and going to `http://localhost:8080/` will print the nginx
    access logs to screen, just as when we launched the `nginx-foreground` container.
    Pressing *Ctrl* + *C* will terminate the process and return your Terminal to normal;
    however, as before, we would have terminated the process that was keeping the
    container running:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并转到`http://localhost:8080/`将会将nginx访问日志打印到屏幕上，就像我们启动`nginx-foreground`容器时一样。按下*Ctrl*
    + *C*将终止进程并将您的终端返回正常；但是，与之前一样，我们将终止保持容器运行的进程：
- en: '![](Images/1bb4e06d-3b7a-4ff5-a240-277270cfc9f2.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1bb4e06d-3b7a-4ff5-a240-277270cfc9f2.png)'
- en: 'We can start our container back up by running the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令重新启动我们的容器：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will start the container back up in the detached state, meaning that it
    is running in the background again, as this was the state that the container was
    originally launched in. Going to `http://localhost:8080/` will show you the nginx
    welcome page again.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以分离状态重新启动容器，这意味着它再次在后台运行，因为这是容器最初启动时的状态。转到`http://localhost:8080/`将再次显示nginx欢迎页面。
- en: 'Let''s reattach to our process, but this time with an additional option:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新连接到我们的进程，但这次附加一个额外的选项：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Hitting the container''s URL a few times and then pressing *Ctrl* + *C* will
    detach us from the nginx process, but this time, rather than terminating the nginx
    process, it will just return us to our Terminal, leaving the container in a detached
    state that can be seen by running `docker container ls`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 多次访问容器的URL，然后按下*Ctrl* + *C*将使我们从nginx进程中分离出来，但这次，而不是终止nginx进程，它将只是将我们返回到我们的终端，使容器处于分离状态，可以通过运行`docker
    container ls`来查看：
- en: '![](Images/a4b9322c-7f40-4ca1-8a24-86b30d727a2b.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a4b9322c-7f40-4ca1-8a24-86b30d727a2b.png)'
- en: exec
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: exec
- en: The `attach` command is useful if you need to connect to the process your container
    is running, but what if you need something a little more interactive?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`attach`命令在您需要连接到容器正在运行的进程时很有用，但如果您需要更交互式的东西呢？'
- en: 'You can use the `exec` command; this spawns a second process within the container
    that you can interact with. For example, to see the contents of the `/etc/debian_version` file, we
    can run the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`exec`命令；这会在容器内生成第二个进程，您可以与之交互。例如，要查看`/etc/debian_version`文件的内容，我们可以运行以下命令：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will spawn a second process, the cat command in this case, which prints
    the contents of `/etc/debian_version` to `stdout`. The second process will then
    terminate, leaving our container as it was before the exec command was executed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生第二个进程，本例中是cat命令，它将打印`/etc/debian_version`的内容到`stdout`。第二个进程然后将终止，使我们的容器在执行exec命令之前的状态：
- en: '![](Images/26de55e0-7fde-47c8-8d5b-304a3fe6da7e.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/26de55e0-7fde-47c8-8d5b-304a3fe6da7e.png)'
- en: 'We can take this one step further by running the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令进一步进行：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This time, we are forking a bash process and using the `-i` and `-t` flags to
    keep open console access to our container. The `-i` flag is shorthand for `--interactive`,
    which instructs Docker to keep `stdin` open so that we can send commands to the
    process. The `-t` flag is short for `--tty` and allocates a pseudo-TTY to the
    session.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们正在派生一个bash进程，并使用`-i`和`-t`标志来保持对容器的控制台访问。`-i`标志是`--interactive`的简写，它指示Docker保持`stdin`打开，以便我们可以向进程发送命令。`-t`标志是`--tty`的简写，并为会话分配一个伪TTY。
- en: Early user terminals connected to computers were called teletypewriters. While
    these devices are no longer used today, the acronym TTY has continued to be used
    to described text-only consoles in modern computing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 早期用户终端连接到计算机被称为电传打字机。虽然这些设备今天不再使用，但是TTY的缩写在现代计算中继续用来描述纯文本控制台。
- en: 'What this means is that you will be able to interact with the container as
    if you had a remote Terminal session, like SSH:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您将能够像远程终端会话（如SSH）一样与容器进行交互：
- en: '![](Images/adc82b1e-ce80-447f-ba61-df6187947c28.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/adc82b1e-ce80-447f-ba61-df6187947c28.png)'
- en: While this is extremely useful, as you can interact with the container as if
    it were a virtual machine, I do not recommend making any changes to your containers
    as they are running using the pseudo-TTY. It is more than likely that those changes
    will not persist and will be lost when your container is removed. We will go into
    the thinking behind this in more detail in [Chapter 12](2a59899d-85fa-4a6f-960f-15f77654396d.xhtml),
    *Docker Workflows*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这非常有用，因为您可以像与虚拟机一样与容器进行交互，但我不建议在使用伪TTY运行时对容器进行任何更改。很可能这些更改不会持久保存，并且在删除容器时将丢失。我们将在[第12章](2a59899d-85fa-4a6f-960f-15f77654396d.xhtml)中更详细地讨论这背后的思考，*Docker工作流*。
- en: Logs and process information
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志和进程信息
- en: So far, we have been attaching to either the process in our container, or the
    container itself, to view information. Docker provides a few commands to allow
    you to view information about your containers without having to use either the
    `attach` or `exec` commands.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们要么附加到容器中的进程，要么附加到容器本身，以查看信息。Docker提供了一些命令，允许您查看有关容器的信息，而无需使用`attach`或`exec`命令。
- en: logs
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志
- en: 'The `logs` command is pretty self-explanatory; it allows you to interact with
    the `stdout` stream of your containers, which Docker is keeping track of in the
    background. For example, to view the last entries written to `stdout` for our
    `nginx-test` container, you just need to use the following command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`logs`命令相当不言自明；它允许您与Docker在后台跟踪的容器的`stdout`流进行交互。例如，要查看我们的`nginx-test`容器的`stdout`的最后条目，只需使用以下命令：'
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the command is shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下所示：
- en: '![](Images/f4d55587-638d-40a9-b254-6ea3b7dfd5ca.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f4d55587-638d-40a9-b254-6ea3b7dfd5ca.png)'
- en: 'To view the logs in real time, I simply need to run the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要实时查看日志，我只需要运行以下命令：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `-f` flag is shorthand for `--follow`. I can also, say, view everything
    that has been logged since a certain time by running the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`标志是`--follow`的简写。我也可以，比如，通过运行以下命令查看自从某个时间以来已经记录的所有内容：'
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of the command is shown here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下所示：
- en: '![](Images/81472a8d-7d42-47f3-8992-3ef68d28d1f2.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/81472a8d-7d42-47f3-8992-3ef68d28d1f2.png)'
- en: You might notice that, in the preceding output, the timestamp in the access
    log is 17:12, which is before 18:00\. Why is that?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在前面的输出中，访问日志中的时间戳是 17:12，早于 18:00。为什么会这样？
- en: 'The `logs` command shows the timestamps of `stdout` as recorded by Docker,
    and not the time within the container. You can see this when I run the following
    commands:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`logs` 命令显示了 Docker 记录的 `stdout` 的时间戳，而不是容器内部的时间。当我运行以下命令时，你可以看到这一点：'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is shown here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](Images/ad0e1a71-4115-41f3-9cf9-ce4611e9c86e.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ad0e1a71-4115-41f3-9cf9-ce4611e9c86e.png)'
- en: There is an hour's time difference between my host machine and the container
    due to **British Summer Time** (**BST**) being in effect on my host.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我的主机上正在使用**英国夏令时**（**BST**），所以我的主机和容器之间有一个小时的时间差。
- en: 'Luckily, to save confusion—or add to it, depending on how you look at it—you
    can add `-t` to your `logs` commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，为了避免混淆（或者增加混淆，这取决于你的观点），你可以在 `logs` 命令中添加 `-t`：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `-t` flag is short for `--timestamp`; this option prepends the time the
    output was captured by Docker:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t` 标志是 `--timestamp` 的缩写；这个选项会在输出之前添加 Docker 捕获的时间：'
- en: '![](Images/5adad768-d3f4-48cf-861f-2c2928badd3b.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5adad768-d3f4-48cf-861f-2c2928badd3b.png)'
- en: top
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: top
- en: 'The `top` command is quite a simple one; it lists the processes running within
    the container you specify, and is used as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`top` 命令非常简单；它列出了你指定的容器中正在运行的进程，使用方法如下：'
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of the command is shown here:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出如下：
- en: '![](Images/4a4ecf85-0897-4c4f-ae0a-0d837d554327.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4a4ecf85-0897-4c4f-ae0a-0d837d554327.png)'
- en: As you can see from the following Terminal output, we have two processes running,
    both of which are nginx, which is to be expected.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从下面的终端输出中可以看到，我们有两个正在运行的进程，都是 nginx，这是可以预料到的。
- en: stats
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: stats
- en: 'The `stats` command provides real-time information on either the specified
    container or, if you don''t pass a `NAME` or `ID` container, on all running containers:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`stats` 命令提供了关于指定容器的实时信息，或者如果你没有传递 `NAME` 或 `ID` 容器，则提供所有正在运行的容器的信息：'
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see from the following Terminal output, we are given information
    on the `CPU`, `RAM`, `NETWORK`, `DISK IO`, and `PIDS` for the specified container:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从下面的终端输出中可以看到，我们得到了指定容器的 `CPU`、`RAM`、`NETWORK`、`DISK IO` 和 `PIDS` 的信息：
- en: '![](Images/b65c9bb2-62b3-4d50-bfd7-6fc5586a4ad9.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b65c9bb2-62b3-4d50-bfd7-6fc5586a4ad9.png)'
- en: 'We can also pass the `-a` flag; this is short for `--all` and displays all
    containers, running or not. For example, try running the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以传递 `-a` 标志；这是 `--all` 的缩写，显示所有容器，无论是否正在运行。例如，尝试运行以下命令：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should receive something like the following output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会收到类似以下的输出：
- en: '![](Images/290518ab-d015-4073-99f4-96ba471a7fd3.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/290518ab-d015-4073-99f4-96ba471a7fd3.png)'
- en: However, as you can see from the preceding output, if the container isn't running,
    there aren't any resources being utilized, so it doesn't really add any value,
    other than giving you a visual representation of how many containers you have
    running and where the resources are being used.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如你从前面的输出中可以看到，如果容器没有运行，那么就没有任何资源被利用，所以它实际上并没有增加任何价值，除了让你直观地看到你有多少个容器正在运行以及资源的使用情况。
- en: It is also worth pointing out that the information displayed by the `stats`
    command is real time only; Docker does not record the resource utilization and
    make it available in the same way that the `logs` command does. We will be looking
    at more long-term storage for resource utilization in later chapters.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，`stats` 命令显示的信息只是实时的；Docker 不会记录资源利用情况并以与 `logs` 命令相同的方式提供。我们将在后面的章节中研究更长期的资源利用情况存储。
- en: Resource limits
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源限制
- en: The last command we ran showed us the resource utilization of our containers;
    by default, when launched, a container will be allowed to consume all the available
    resources on the host machine if it requires it. We can put caps on the resources
    our containers can consume; let's start by updating the resource allowances of
    our `nginx-test` container.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行的最后一个命令显示了我们容器的资源利用情况；默认情况下，启动时，容器将被允许消耗主机机器上所有可用的资源。我们可以对容器可以消耗的资源进行限制；让我们首先更新我们的`nginx-test`容器的资源允许量。
- en: 'Typically, we would have set the limits when we launched our container using
    the `run` command; for example, to halve the CPU priority and set a memory limit
    of `128M`, we would have used the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会在使用`run`命令启动容器时设置限制；例如，要将CPU优先级减半并设置内存限制为`128M`，我们将使用以下命令：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, we didn''t launch our `nginx-test` container with any resource limits,
    meaning that we need to update our already running container; to do this, we can
    use the `update` command. Now, you may have thought that this should just entail
    running the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们没有使用任何资源限制启动我们的`nginx-test`容器，这意味着我们需要更新我们已经运行的容器；为此，我们可以使用`update`命令。现在，您可能认为这应该只涉及运行以下命令：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But actually, running the preceding command will produce an error:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，运行上述命令会产生一个错误：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So what is the `memoryswap` limit currently set to? To find this out, we can
    use the `inspect` command to display all of the configuration data for our running
    container; just run the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当前设置的`memoryswap`限制是多少？要找出这个，我们可以使用`inspect`命令来显示我们正在运行的容器的所有配置数据；只需运行以下命令：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see by running the preceding command, there is a lot of configuration
    data. When I ran the command, a 199-line JSON array was returned. Let''s use the
    `grep` command to filter out just the lines that contain the word `memory`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行上述命令，您可以看到有很多配置数据。当我运行该命令时，返回了一个199行的JSON数组。让我们使用`grep`命令来过滤只包含单词`memory`的行：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This returns the following configuration data:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回以下配置数据：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Everything is set to `0`, so how can `128M` be smaller than `0`?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都设置为`0`，那么`128M`怎么会小于`0`呢？
- en: 'In the context of the configuration of the resources, `0` is actually the default
    value and means that there are no limits—notice the lack of `M` after each numerical
    value. This means that our update command should actually read the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源配置的上下文中，`0`实际上是默认值，表示没有限制—注意每个数字值后面缺少`M`。这意味着我们的更新命令实际上应该如下所示：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Paging is a memory management scheme in which the kernel stores and retrieves,
    or swaps, data from secondary storage for use in the main memory. This allows
    processes to exceed the size of physical memory available.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 分页是一种内存管理方案，其中内核将数据存储和检索，或者交换，从辅助存储器中用于主内存。这允许进程超出可用的物理内存大小。
- en: 'By default, when you set `--memory` as part of the run command, Docker will
    set the `-- memory-swap` size to be twice that of `--memory`. If you run `docker
    container stats nginx-test` now, you should see our limits in place:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当您在运行命令中设置`--memory`时，Docker将设置`--memory-swap`大小为`--memory`的两倍。如果现在运行`docker
    container stats nginx-test`，您应该看到我们设置的限制：
- en: '![](Images/77a31bee-f5aa-47fa-bc45-c87ce4e5d593.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/77a31bee-f5aa-47fa-bc45-c87ce4e5d593.png)'
- en: 'Also, re-running `docker container inspect nginx-test | grep -i memory` will
    show the changes as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重新运行`docker container inspect nginx-test | grep -i memory`将显示以下更改：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The values when running `docker container inspect` are all shown in bytes rather
    megabytes (MB).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker container inspect`时，值都以字节而不是兆字节（MB）显示。
- en: Container states and miscellaneous commands
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器状态和其他命令
- en: For the final part of this section, we are going to look at the various states
    your containers could be in, along with the few remaining commands we have yet
    to cover as part of the `docker container` command.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后部分，我们将看一下容器可能处于的各种状态，以及作为`docker container`命令的一部分尚未涵盖的几个剩余命令。
- en: 'Running `docker container ls -a` should show something similar to the following
    Terminal output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker container ls -a`应该显示类似以下终端输出：
- en: '![](Images/5772ae4a-e0c4-4b08-9eaa-6736196039a3.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5772ae4a-e0c4-4b08-9eaa-6736196039a3.png)'
- en: 'As you can see, we have two containers; one has the status of `Up` and the
    other has `Exited`. Before we continue, let''s launch five more containers. To
    do this quickly, run the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有两个容器；一个状态为`Up`，另一个为`Exited`。在继续之前，让我们启动五个更多的容器。要快速执行此操作，请运行以下命令：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When running `docker container ls -a`, you should see your five new containers,
    named `nginx1` through to `nginx5`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker container ls -a`时，您应该看到您的五个新容器，命名为`nginx1`到`nginx5`：
- en: '![](Images/93f06e05-03cc-4a87-afa7-405edc4fc671.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/93f06e05-03cc-4a87-afa7-405edc4fc671.png)'
- en: Pause and unpause
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停和取消暂停
- en: 'Let''s look at pausing `nginx1`. To do this, simply run the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看暂停`nginx1`。要做到这一点，只需运行以下命令：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Running `docker container ls` will show that the container has a status of
    `Up`, but it also says `Paused`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker container ls`将显示容器的状态为`Up`，但也显示为`Paused`：
- en: '![](Images/1d9542b7-02c5-4c7d-9c9d-2231f3be2885.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1d9542b7-02c5-4c7d-9c9d-2231f3be2885.png)'
- en: Note that we didn't have to use the `-a` flag to see information about the container
    as the process has not been terminated; instead, it has been suspended using the
    `cgroups` freezer. With the `cgroups` freezer, the process is unaware it has been
    suspended, meaning that it can be resumed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不必使用`-a`标志来查看有关容器的信息，因为进程尚未终止；相反，它已经被使用`cgroups`冻结器挂起。使用`cgroups`冻结器，进程不知道自己已经被挂起，这意味着它可以被恢复。
- en: 'As you will have probably already guessed, you can resume a paused container
    using the `unpause` command, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到了，可以使用`unpause`命令恢复暂停的容器，如下所示：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This command is useful if you need to freeze the state of a container; for example,
    maybe one of your containers is going haywire and you need to do some investigation
    later, but don't want it to have a negative impact on your other running containers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要冻结容器的状态，这个命令非常有用；例如，也许您的一个容器出现了问题，您需要稍后进行一些调查，但不希望它对其他正在运行的容器产生负面影响。
- en: Stop, start, restart, and kill
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止，启动，重启和杀死
- en: 'Next up, we have the `stop`, `start`, `restart`, and `kill` commands. We have
    already used the `start` command to resume a container with a status of `Exited`.
    The `stop` command works in exactly the same way as when we used *Ctrl* + *C*
    to detach from your container running in the foreground. Run the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`stop`，`start`，`restart`和`kill`命令。我们已经使用`start`命令恢复了状态为`Exited`的容器。`stop`命令的工作方式与我们在前台运行容器时使用*Ctrl*
    + *C*分离的方式完全相同。运行以下命令：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With this, a request is sent to the process for it to terminate, called a `SIGTERM`.
    If the process has not terminated itself within a grace period, then a kill signal,
    called a `SIGKILL`, is sent. This will immediately terminate the process, not
    giving it any time to finish whatever is causing the delay; for example, committing
    the results of a database query to disk.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，发送一个请求给进程终止，称为`SIGTERM`。如果进程在宽限期内没有自行终止，那么将发送一个终止信号，称为`SIGKILL`。这将立即终止进程，不给它完成导致延迟的任何时间；例如，将数据库查询的结果提交到磁盘。
- en: 'Because this could be bad, Docker gives you the option of overriding the default
    grace period, which is `10` seconds, by using the `-t` flag; this is short for
    `--time`. For example, running the following command will wait up to `60` seconds
    before sending a `SIGKILL`, in the event that it needs to be sent to kill the
    process:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这可能是不好的，Docker给了你覆盖默认的宽限期的选项，这个默认值是`10`秒，可以使用`-t`标志来覆盖；这是`--time`的缩写。例如，运行以下命令将在发送`SIGKILL`之前等待最多`60`秒，如果需要发送以杀死进程：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `start` command, as we have already seen, will start the process back up;
    however, unlike the `pause` and `unpause` commands, the process, in this case,
    starts from scratch using the flags that  originally launched it, rather than
    starting from where it left off:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`命令，正如我们已经看到的，将重新启动进程；然而，与`pause`和`unpause`命令不同，这种情况下，进程将使用最初启动它的标志从头开始，而不是从离开的地方开始：'
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `restart` command is a combination of the following two commands; it stops
    and then starts the `ID` or `NAME` container you pass it. Also, as with `stop`,
    you can pass the `-t` flag:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`restart`命令是以下两个命令的组合；它先停止，然后再启动你传递的`ID`或`NAME`容器。与`stop`一样，你也可以传递`-t`标志：'
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, you also have the option of sending a `SIGKILL` command immediately
    to the container by running the `kill` command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还可以通过运行`kill`命令立即向容器发送`SIGKILL`命令：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Removing containers
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除容器
- en: 'Let''s check the containers we have running using the `docker container ls
    -a` command. When I run the command, I can see that I have two containers with
    an `Exited` status and all of the others are running:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`docker container ls -a`命令来检查我们正在运行的容器。当我运行命令时，我可以看到我有两个处于`Exited`状态的容器，其他所有容器都在运行：
- en: '![](Images/4bcbe8c0-ef73-4ee3-892f-736df9b751ed.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4bcbe8c0-ef73-4ee3-892f-736df9b751ed.png)'
- en: 'To remove the two exited containers, I can simply run the `prune` command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除两个已退出的容器，我只需运行`prune`命令：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When doing so, a warning pops up asking you to confirm whether you are really
    sure, as seen in the following screenshot:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做时，会弹出一个警告，询问您是否真的确定，如下面的截图所示：
- en: '![](Images/6bf28535-d586-446d-90c9-652a5be114b0.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6bf28535-d586-446d-90c9-652a5be114b0.png)'
- en: 'You can choose which container you want to remove using the `rm` command, an
    example of which is shown here:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`rm`命令选择要删除的容器，下面是一个示例：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Another alternative would be to string the `stop` and `rm` commands together:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是将`stop`和`rm`命令串联在一起：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, given that you can use the `prune` command now, this is probably way
    too much effort, especially as you are trying to remove the containers and probably
    don't care too much how gracefully the process is terminated.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，鉴于您现在可以使用`prune`命令，这可能是太费力了，特别是在您试图删除容器并且可能不太关心进程如何优雅地终止的情况下。
- en: Feel free to remove the remainder of your containers using whichever method
    you like.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 随意使用您喜欢的任何方法删除剩余的容器。
- en: Miscellaneous commands
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杂项命令
- en: For the final part of this section, we are going to look at a few commands that
    you probably won't use too much during your day-to-day use of Docker. The first
    of these is `create`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后部分，我们将看一些在日常使用Docker时可能不会经常使用的命令。其中之一是`create`。
- en: 'The `create` command is pretty similar to the `run` command, except that it
    does not start the container, but instead prepares and configures one:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`create`命令与`run`命令非常相似，只是它不启动容器，而是准备和配置一个：'
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can check the status of your created container by running `docker container
    ls -a`, and then starting the container with `docker container start nginx-test`,
    before checking the status again:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`docker container ls -a`来检查已创建容器的状态，然后使用`docker container start nginx-test`启动容器，然后再次检查状态：
- en: '![](Images/0ce749fe-7c8c-4322-8f83-59b00098ab61.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0ce749fe-7c8c-4322-8f83-59b00098ab61.png)'
- en: 'The next command we are going to quickly look at is the `port` command; this
    displays the port along with any port mappings for the container:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要快速查看的下一个命令是`port`命令；这将显示容器的端口以及任何端口映射：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It should return the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该返回以下内容：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We already know this, as it is what we configured. Also, the ports are listed
    in the `docker container ls` output.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道这一点，因为这是我们配置的内容。此外，端口在`docker container ls`输出中列出。
- en: The final command we are going to look at quickly is the `diff` command. This
    command prints a list of all of the files that have been added (`A`) or changed
    (`C`) since the container was started—so basically, a list of the differences
    on the filesystem between the original image we used to launch the container and
    what files are present now.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要快速查看的最后一个命令是`diff`命令。该命令打印自容器启动以来已添加（`A`）或更改（`C`）的所有文件的列表——基本上是我们用于启动容器的原始映像和现在存在的文件之间文件系统的差异列表。
- en: 'Before we run the command, let''s create a blank file within the `nginx-test`
    container using the `exec` command:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行命令之前，让我们使用`exec`命令在`nginx-test`容器中创建一个空白文件：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that we have a file called `testing` in `/tmp`, we can view the differences
    between the original image and the running container using the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`/tmp`中有一个名为`testing`的文件，我们可以使用以下命令查看原始映像和运行容器之间的差异：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will return a list of files; as you can see from the following list, our
    testing file is there, along with the files that were created when nginx started:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个文件列表；从下面的列表中可以看到，我们的测试文件在那里，还有在nginx启动时创建的文件：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It is worth pointing out that once we stop and remove the container, these files
    will be lost. In the next section of this chapter, we will look at Docker volumes
    and learn how we can persist data.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，一旦停止并删除容器，这些文件将丢失。在本章的下一节中，我们将看看Docker卷，并学习如何持久保存数据。
- en: Again, if you are following along, you should remove any running containers
    launched during this section using the command of your choice.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果您在跟着做，应该使用您选择的命令删除在本节启动的任何正在运行的容器。
- en: Docker networking and volumes
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 网络和卷
- en: Before we finish off this chapter, we are going to take a look at the basics
    of Docker networking and Docker volumes using the default drivers. Let's take
    a look at networking first.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，我们将首先使用默认驱动程序来了解Docker网络和Docker卷的基础知识。让我们先看看网络。
- en: Docker networking
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 网络
- en: So far, we have been launching our containers on a single flat shared network.
    Although we have not talked about it yet, this means the containers we have been
    launching would have been able to communicate with each other without having to
    use any of the host
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在单个共享网络上启动我们的容器。尽管我们还没有讨论过，但这意味着我们一直在启动的容器可以在不使用主机的情况下相互通信
- en: networking.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 网络。
- en: Rather than going into detail now, let's work through an example. We are going
    to be running a two-container application; the first container will be running
    Redis, and the second, our application, which uses the Redis container to store
    a system state.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不详细讨论，让我们通过一个例子来工作。我们将运行一个双容器应用程序；第一个容器将运行Redis，第二个容器将运行我们的应用程序，该应用程序使用Redis容器来存储系统状态。
- en: '**Redis** is an in-memory data structure store that can be used as a database,
    cache, or message broker. It supports different levels of on-disk persistence.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redis**是一个内存数据结构存储，可以用作数据库、缓存或消息代理。它支持不同级别的磁盘持久性。'
- en: 'Before we launch our application, let''s download the container images we will
    be using, and also create the network:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动应用程序之前，让我们下载将要使用的容器映像，并创建网络：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You should see something similar to the following Terminal output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到类似以下终端输出：
- en: '![](Images/437d8315-2fb0-4b30-919e-de523c2a9d8f.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/437d8315-2fb0-4b30-919e-de523c2a9d8f.png)'
- en: 'Now that we have our images pulled and our network created, we can launch our
    containers, starting with the Redis one:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拉取了我们的镜像并创建了我们的网络，我们可以启动我们的容器，从Redis开始：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As you can see, we used the `--network` flag to define the network that our
    container was launched in. Now that the Redis container is launched, we can launch
    the application container by running the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们使用了`--network`标志来定义我们的容器启动的网络。现在Redis容器已经启动，我们可以通过运行以下命令来启动应用程序容器：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Again, we launched the container into the `moby-counter` network; this time,
    we mapped port `8080` to port `80` on the container. Note that we did not need
    to worry about exposing any ports of the Redis container. That is because the
    Redis image comes with some defaults that expose the default port, which is `6379`
    for us. This can be seen by running `docker container ls`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将容器启动到`moby-counter`网络中；这一次，我们将端口`8080`映射到容器上的端口`80`。请注意，我们不需要担心暴露Redis容器的任何端口。这是因为Redis镜像带有一些默认值，暴露默认端口，对我们来说默认端口是`6379`。这可以通过运行`docker
    container ls`来查看：
- en: '![](Images/1b81c8f6-2b54-40c8-bccd-b2ba1cd835e8.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1b81c8f6-2b54-40c8-bccd-b2ba1cd835e8.png)'
- en: 'All that remains now is to access the application; to do this, open your browser
    and go to `http://localhost:8080/`. You should be greeted by a mostly blank page,
    with the message **Click to add logos**:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是访问应用程序；要做到这一点，打开浏览器，转到`http://localhost:8080/`。您应该会看到一个几乎空白的页面，上面显示着**点击添加标志**的消息：
- en: '![](Images/d2e7aade-e54d-49a5-8867-cd7fec245ee5.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d2e7aade-e54d-49a5-8867-cd7fec245ee5.png)'
- en: 'Clicking anywhere on the page will add Docker logos, so click away:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 单击页面上的任何位置都会添加Docker标志，所以请点击：
- en: '![](Images/d32f4117-a87d-48e6-a1ac-06550232f498.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d32f4117-a87d-48e6-a1ac-06550232f498.png)'
- en: So what is happening? The application that is being served from the moby-counter
    container is making a connection to the `redis` container, and using the service
    to store the on-screen coordinates of each of the logos that you place on the
    screen by clicking.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？从moby-counter容器提供的应用程序正在连接到`redis`容器，并使用该服务来存储您通过点击放置在屏幕上的每个标志的屏幕坐标。
- en: 'How is the moby-counter application connecting to the `redis` container? Well,
    in the `server.js` file, the following default values are being set:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: moby-counter应用程序是如何连接到`redis`容器的？在`server.js`文件中，设置了以下默认值：
- en: '[PRE51]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This means that the `moby-counter` application is looking to connect to a host
    called `redis` on port `6379`. Let''s try using the exec command to ping the `redis`
    container from the `moby-counter` application and see what we get:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`moby-counter`应用程序正在尝试连接到名为`redis`的主机的端口`6379`。让我们尝试使用exec命令从`moby-counter`应用程序中ping`redis`容器，看看我们得到什么：
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You should see something similar to the following output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到类似以下输出：
- en: '![](Images/4b88fe00-2244-44b4-88fe-1bd7efe6ef10.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4b88fe00-2244-44b4-88fe-1bd7efe6ef10.png)'
- en: 'As you can see, the `moby-counter` container resolves `redis` to the IP address
    of the `redis` container, which is `172.18.0.2`. You may be thinking that the
    application''s host file contains an entry for the `redis` container; let''s take
    a look using the following command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`moby-counter`容器将`redis`解析为`redis`容器的IP地址，即`172.18.0.2`。您可能会认为应用程序的主机文件包含了`redis`容器的条目；让我们使用以下命令来查看一下：
- en: '[PRE53]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This returns the contents of `/etc/hosts`, which, in my case, looks like the
    following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了`/etc/hosts`的内容，在我的情况下，看起来像以下内容：
- en: '[PRE54]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Other than the entry at the end, which is actually the IP address resolving
    to the hostname of the local container, `4e7931312ed2` is the ID of the container;
    there is no sign of an entry for `redis`. Next, let''s check `/etc/resolv.conf`
    by running the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 除了最后的条目外，实际上是IP地址解析为本地容器的主机名，`4e7931312ed2`是容器的ID；没有`redis`的条目。接下来，让我们通过运行以下命令来检查`/etc/resolv.conf`：
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This returns what we are looking for; as you can see, we are using a local
    `nameserver`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了我们正在寻找的内容；如您所见，我们正在使用本地`nameserver`：
- en: '[PRE56]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Let''s perform a DNS lookup on `redis` against `127.0.0.11` using the following
    command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令对`redis`进行DNS查找，针对`127.0.0.11`：
- en: '[PRE57]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This returns the IP address of the `redis` container:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了`redis`容器的IP地址：
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s create a second network and launch another application container:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建第二个网络并启动另一个应用程序容器：
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now that we have the second application container up and running, let''s try
    pinging the `redis` container from it:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动并运行了第二个应用程序容器，让我们尝试从中ping`redis`容器：
- en: '[PRE60]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In my case, I get the following error:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我得到了以下错误：
- en: '![](Images/fe272858-2c80-4c3d-a694-619b4c7b0046.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fe272858-2c80-4c3d-a694-619b4c7b0046.png)'
- en: 'Let''s check the `resolv.conf` file to see if the same nameserver is being
    used already, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`resolv.conf`文件，看看是否已经在使用相同的域名服务器，如下所示：
- en: '[PRE61]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As you can see from the following output, the nameserver is indeed in use already:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下输出中可以看出，域名服务器确实已经在使用中：
- en: '[PRE62]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As we have launched the `moby-counter2` container in a different network to
    that where the container named `redis` is running, we cannot resolve the hostname
    of the container, so it returns a bad address error:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在与名为`redis`的容器运行的不同网络中启动了`moby-counter2`容器，我们无法解析容器的主机名，因此返回了错误的地址错误：
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Let's look at launching a second Redis server in our second network; as we have
    already discussed, we cannot have two containers with the same name, so let's
    creatively name it `redis2`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在我们的第二个网络中启动第二个Redis服务器；正如我们已经讨论过的，我们不能有两个同名的容器，所以让我们有创意地将其命名为`redis2`。
- en: As our application is configured to connect to a container that resolves to
    `redis`, does this mean we will have to make changes to our application container?
    No, but Docker has you covered.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序配置为连接到解析为`redis`的容器，这是否意味着我们将不得不对我们的应用程序容器进行更改？不，但Docker已经为您做好了准备。
- en: 'While you cannot have two containers with the same names, as we have already
    discovered, our second network is running completely isolated from our first network,
    meaning that we can still use the DNS name of `redis`. To do this, we need to
    add the `-- network-alias` flag as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不能有两个同名的容器，正如我们已经发现的那样，我们的第二个网络完全与第一个网络隔离运行，这意味着我们仍然可以使用`redis`的DNS名称。为此，我们需要添加`--network-alias`标志，如下所示：
- en: '[PRE64]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'As you can see, we have named the container `redis2`, but set the `--network-alias`
    to be `redis`; this means that when we perform the lookup, we see the correct
    IP address returned:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经将容器命名为`redis2`，但将`--network-alias`设置为`redis`；这意味着当我们执行查找时，我们会看到返回的正确IP地址：
- en: '[PRE65]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As you can see, `redis` is actually an alias for `redis2.moby-counter2`, which
    then resolves to `172.19.0.3`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`redis`实际上是`redis2.moby-counter2`的别名，然后解析为`172.19.0.3`。
- en: 'Now we should have two applications running side by side in their own isolated
    networks on your local Docker host, accessible at `http://localhost:8080/` and
    `http://localhost:9090/`. Running `docker network ls` will display all of the
    networks configured on your Docker host, including the default networks:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该有两个应用程序在本地Docker主机上以自己的隔离网络并行运行，可以通过`http://localhost:8080/`和`http://localhost:9090/`访问。运行`docker
    network ls`将显示在Docker主机上配置的所有网络，包括默认网络：
- en: '![](Images/028c4da4-f1c6-4714-9720-ac7eeed8307d.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/028c4da4-f1c6-4714-9720-ac7eeed8307d.png)'
- en: 'You can find out more information about the configuration of the networks by
    running the following `inspect` command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下`inspect`命令来了解有关网络配置的更多信息：
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Running the preceding command returns the following JSON array:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令将返回以下JSON数组：
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, it contains information on the network addressing being used
    in the IPAM section, along with details on each of the two containers running
    in the network.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它包含有关在IPAM部分中使用的网络寻址信息，以及网络中运行的两个容器的详细信息。
- en: '**IP address management (IPAM)** is a means of planning, tracking, and managing
    IP addresses within the network. IPAM has both DNS and DHCP services, so each
    service is notified of changes in the other. For example, DHCP assigns an address
    to `container2`. The DNS service is then updated to return the IP address assigned
    by DHCP whenever a lookup is made against `container2`.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**IP地址管理（IPAM）**是规划、跟踪和管理网络内的IP地址的一种方法。IPAM具有DNS和DHCP服务，因此每个服务都会在另一个服务发生变化时得到通知。例如，DHCP为`container2`分配一个地址。然后更新DNS服务，以便在针对`container2`进行查找时返回DHCP分配的IP地址。'
- en: 'Before we progress to the next section, we should remove one of the applications
    and associated networks. To do this, run the following commands:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一节之前，我们应该删除一个应用程序和相关网络。要做到这一点，请运行以下命令：
- en: '[PRE68]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'This will remove the containers and network, as shown in the following screenshot:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除容器和网络，如下截图所示：
- en: '![](Images/f90ab3a9-4e23-474b-bb23-6ca5f25a95e3.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f90ab3a9-4e23-474b-bb23-6ca5f25a95e3.png)'
- en: As mentioned at the start of this section, this is only the default network
    driver, meaning that we are restricted to our networks being available only on
    a single Docker host. In later chapters, we will look at how we can expand our
    Docker network across multiple hosts and even providers.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本节开头提到的，这只是默认的网络驱动程序，这意味着我们只能在单个Docker主机上使用我们的网络。在后面的章节中，我们将看看如何将我们的Docker网络扩展到多个主机甚至多个提供商。
- en: Docker volumes
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker卷
- en: 'If you have been following along with the network example from the previous
    section, you should have two containers running, as shown in the following screenshot:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在按照上一节的网络示例进行操作，您应该有两个正在运行的容器，如下截图所示：
- en: '![](Images/d8736f3a-5221-4505-8f87-be8f4880a91f.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/d8736f3a-5221-4505-8f87-be8f4880a91f.png)'
- en: 'When you go to the application in a browser (at `http://localhost:8080/`),
    you will probably see that there already are Docker logos on screen. Let''s stop
    and then remove the Redis container and see what happens. To do this, run the
    following commands:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器中访问应用程序（在`http://localhost:8080/`），您可能会看到屏幕上已经有Docker标志。让我们停下来，然后移除Redis容器，看看会发生什么。要做到这一点，请运行以下命令：
- en: '[PRE69]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you have your browser open, you may notice that the Docker icons have faded
    into the background and there is an animated loader in the center of the screen.
    This is basically to show that the application is waiting for the connection to
    the Redis container to be re-established:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的浏览器打开，您可能会注意到Docker图标已经淡出到背景中，屏幕中央有一个动画加载器。这基本上是为了显示应用程序正在等待与Redis容器重新建立连接：
- en: '![](Images/877b5f80-6b36-4d49-be89-2f09a51aea48.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/877b5f80-6b36-4d49-be89-2f09a51aea48.png)'
- en: 'Relaunch the Redis container using the following command:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令重新启动Redis容器：
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This restores connectivity; however, when you start to interact with the application,
    your previous icons disappear and you are left with a clean slate. Quickly add
    some more logos to the screen, this time placed in a different pattern, as I have
    done here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这恢复了连接；但是，当您开始与应用程序交互时，您之前的图标会消失，您将得到一个干净的界面。快速在屏幕上添加一些图标，这次以不同的模式放置，就像我在这里做的一样：
- en: '![](Images/ae34105f-21e6-4e8e-ad8d-98e7ebebdb46.png)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ae34105f-21e6-4e8e-ad8d-98e7ebebdb46.png)'
- en: 'Once you have a pattern, let''s remove the Redis container again, by running
    the following commands:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个模式，让我们再次通过以下命令移除Redis容器：
- en: '[PRE71]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As we discussed earlier in the chapter, losing the data in the container is
    to be expected. However, as we used the official Redis image, we haven't in fact
    lost any of our data.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面讨论过的，容器中的数据丢失是可以预料的。然而，由于我们使用了官方的Redis镜像，实际上我们并没有丢失任何数据。
- en: 'The Dockerfile for the official Redis image that we used looks like the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的官方Redis镜像的Dockerfile如下所示：
- en: '[PRE72]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: If you notice, toward the end of the file, there are the `VOLUME` and `WORKDIR`
    directives declared; this means that when our container was launched, Docker actually
    created a volume and then ran `redis-server` from within the volume.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到文件末尾有`VOLUME`和`WORKDIR`指令声明；这意味着当我们的容器启动时，Docker实际上创建了一个卷，然后在卷内部运行了`redis-server`。
- en: 'We can see this by running the following command:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令，我们可以看到这一点：
- en: '[PRE73]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This should show at least two volumes, as seen in the following screenshot:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示至少两个卷，如下截图所示：
- en: '![](Images/a53d746d-cbc9-4f6d-8a9c-89758fcc9bb8.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a53d746d-cbc9-4f6d-8a9c-89758fcc9bb8.png)'
- en: As you can see, the volume name is not very friendly at all; in fact, it is
    the unique ID of the volume. So how can we use the volume when we launch our Redis
    container?
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，卷的名称并不友好；实际上，它是卷的唯一ID。那么当我们启动Redis容器时，我们该如何使用这个卷呢？
- en: We know from the Dockerfile that the volume was mounted at `/data` within the
    container, so all we have to do is tell Docker which volume to use and where it
    should be mounted at runtime.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Dockerfile中知道，卷被挂载到容器中的`/data`，所以我们只需要告诉Docker在运行时使用哪个卷以及应该挂载到哪里。
- en: 'To do this, run the following command, making sure you replace the volume ID
    with that of your own:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请运行以下命令，确保你用自己的卷ID替换卷ID：
- en: '[PRE74]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If your application page looks like it is still trying to reconnect to the Redis
    container once you have launched your Redis container, then you may need to refresh
    your browser; failing that, restarting the application container by running `docker
    container restart moby-counter` and then refreshing your browser again should
    work.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启动了Redis容器后，你的应用页面看起来仍在尝试重新连接到Redis容器，那么你可能需要刷新你的浏览器；如果刷新不起作用，可以通过运行`docker
    container restart moby-counter`来重新启动应用容器，然后再次刷新你的浏览器。
- en: 'You can view the contents of the volume by running the following command to
    attach the container and list the files in `/data`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来查看卷的内容，以附加到容器并列出`/data`中的文件：
- en: '[PRE75]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This will return something that looks like the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回类似以下内容：
- en: '[PRE76]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: You can also remove your running container and relaunch it, but this time using
    the ID of the second volume. As you can see from the application in your browser,
    the two different patterns you originally created are intact.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以移除正在运行的容器并重新启动它，但这次使用第二个卷的ID。从你浏览器中的应用程序可以看出，你最初创建的两种不同模式是完好无损的。
- en: 'Finally, you can override the volume with your own. To create a volume, we
    need to use the `volume` command:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以用自己的卷来覆盖这个卷。要创建一个卷，我们需要使用`volume`命令：
- en: '[PRE77]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Once created, we will be able to use the `redis_data` volume to store our Redis
    by running the following command after removing the Redis container, which is
    probably already running:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建完成，我们就可以通过运行以下命令来使用`redis_data`卷来存储我们的Redis，这是在移除Redis容器后进行的操作，该容器可能已经在运行：
- en: '[PRE78]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can then reuse the volume as needed, the screen below shows the volume being
    created, attached to a container which is then removed and finally reattached
    to a new container:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以根据需要重复使用这个卷，下面的屏幕显示了卷的创建，附加到一个容器，然后移除，最后重新附加到一个新的容器：
- en: '![](Images/587c6e86-e8de-4dca-bf50-f3e35dfe9776.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/587c6e86-e8de-4dca-bf50-f3e35dfe9776.png)'
- en: 'Like the `network` command, we can view more information on the volume using
    the `inspect` command, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 与`network`命令一样，我们可以使用`inspect`命令查看有关卷的更多信息，如下所示：
- en: '[PRE79]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The preceding code will produce something like the following output:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将产生类似以下输出：
- en: '[PRE80]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: You can see that there is not much to a volume when using the local driver;
    one interesting thing to note is that the path to where the data is stored on
    the Docker host machine is `/var/lib/docker/volumes/redis_data/_data`. If you
    are using Docker for Mac or Docker for Windows, then this path will be your Docker
    host virtual machine, and not your local machine, meaning that you do not have
    direct access to the data inside the volume.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到使用本地驱动程序时卷并不多；值得注意的一件事是，数据存储在Docker主机机器上的路径是`/var/lib/docker/volumes/redis_data/_data`。如果您使用的是Docker
    for Mac或Docker for Windows，那么这个路径将是您的Docker主机虚拟机，而不是您的本地机器，这意味着您无法直接访问卷内的数据。
- en: 'Don''t worry though; we will be looking at Docker volumes and how you can interact
    with data in later chapters. For now, we should tidy up. First of all, remove
    the two containers and network:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 不过不用担心；我们将在后面的章节中讨论Docker卷以及您如何与数据交互。现在，我们应该整理一下。首先，删除这两个容器和网络：
- en: '[PRE81]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Then we can remove the volumes by running the following command:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过运行以下命令来删除卷：
- en: '[PRE82]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You should see something similar to the following Terminal output:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下终端输出：
- en: '![](Images/8a083f82-ac74-40d9-ad79-af59bc811b43.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8a083f82-ac74-40d9-ad79-af59bc811b43.png)'
- en: We are now back to having a clean slate, so we can progress to the next chapter.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们又回到了一个干净的状态，所以我们可以继续下一章了。
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we looked at how you can use the Docker command-line client
    to both manage individual containers and launch multi-container applications in
    their own isolated Docker networks. We also discussed how we can persist data
    on the filesystem using Docker volumes. So far, in this and previous chapters,
    we have covered in detail the majority of the available commands that we will
    use in the following sections:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何使用Docker命令行客户端来管理单个容器并在它们自己的隔离Docker网络中启动多容器应用程序。我们还讨论了如何使用Docker卷在文件系统上持久化数据。到目前为止，在本章和之前的章节中，我们已经详细介绍了我们将在接下来的章节中使用的大部分可用命令：
- en: '[PRE83]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now that we have covered the four main areas of using Docker locally, we can
    start to look at how to create more complex applications using Docker Compose.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了在本地使用Docker的四个主要领域，我们可以开始看如何使用Docker Compose创建更复杂的应用程序。
- en: In the next chapter, we will take a look at another core Docker tool, called
    Docker Compose.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下另一个核心Docker工具，称为Docker Compose。
- en: Questions
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which flag do you have to append to `docker container ls` to view all the containers,
    both running and stopped?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您必须附加哪个标志到`docker container ls`以查看所有容器，包括运行和停止的容器？
- en: 'True or false: the `-p 8080:80` flag will map port 80 on the container to port
    8080 on the host.'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：`-p 8080:80`标志将容器上的端口80映射到主机上的端口8080。
- en: Explain the difference between what happens when you use *Ctrl* + *C* to exit
    a container you have attached, compared to using the attach command with `--sig-proxy=false`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释使用*Ctrl* + *C*退出您已连接的容器时发生的情况与使用`--sig-proxy=false`命令的附加命令。
- en: 'True or false: The `exec` command attaches you to the running process.'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：`exec`命令将您连接到正在运行的进程。
- en: Which flag would you use to add an alias to a container so that it responds
    to DNS requests, when you already have a container running with the same DNS name
    in another network?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将使用哪个标志为容器添加别名，以便在另一个网络中已经具有相同DNS名称的容器运行时响应DNS请求？
- en: Which command would you use to find out details on a Docker volume?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将使用哪个命令来查找有关Docker卷的详细信息？
- en: Further reading
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find out more about some of the topics we have discussed in this chapter
    at the following links:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到更多关于本章讨论的一些主题的信息：
- en: The Names Generator Code: [https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go](https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go)
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称生成器代码：[https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go](https://github.com/moby/moby/blob/master/pkg/namesgenerator/names-generator.go)
- en: The cgroups freezer function: [https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.txt](https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.txt)
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cgroups冷冻功能：[https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.txt](https://www.kernel.org/doc/Documentation/cgroup-v1/freezer-subsystem.txt)
- en: Redis: [https://redis.io/](https://redis.io/)
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Redis: [https://redis.io/](https://redis.io/)'
