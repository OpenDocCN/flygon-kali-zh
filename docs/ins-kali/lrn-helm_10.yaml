- en: '*Chapter 7*: Automating Helm Processes Using CI/CD and GitOps'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：使用CI/CD和GitOps自动化Helm流程'
- en: In this book, we have so far discussed two high-level processes. First, we explored
    using Helm as an end user, leveraging Helm as a package manager to deploy applications
    of varying complexities to Kubernetes. Second, we explored developing and testing
    Helm charts as a chart developer, which involved encapsulating Kubernetes complexities
    in Helm charts and performing tests on charts to ensure that the required features
    were delivered to end users successfully.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们迄今为止讨论了两个高级流程。首先，我们探讨了使用Helm作为最终用户，利用Helm作为软件包管理器将各种复杂性的应用程序部署到Kubernetes。其次，我们探讨了作为图表开发人员开发和测试Helm图表，这涉及将Kubernetes的复杂性封装在Helm图表中，并对图表进行测试，以确保所需的功能成功交付给最终用户。
- en: Both of these processes involve invoking various different Helm CLI commands.
    These Helm CLI commands, while effective in carrying out their respective tasks,
    require manual invocation from the command line. Manual invocation can serve as
    a pain point when managing multiple different charts or applications and can make
    it difficult for larger enterprises to scale. As a result, we should explore alternative
    options that provide additional automation on top of what Helm already provides.
    In this chapter, we will investigate concepts relating to **Continuous Integration**
    and **Continuous Delivery** (**CI**/**CD**) and `GitOps`, which are methodologies
    that can automatically invoke the Helm CLI along with other commands in order
    to perform automated workflows against the contents of a Git repository. These
    workflows can be used to automatically deploy applications using Helm and to build,
    test, and package Helm charts during the chart development life cycle.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个流程都涉及调用各种不同的Helm CLI命令。这些Helm CLI命令在执行各自的任务时非常有效，但需要从命令行手动调用。手动调用在管理多个不同的图表或应用程序时可能会成为一个痛点，并且可能会使大型企业难以扩展。因此，我们应该探索提供额外自动化的替代选项，以在Helm已经提供的基础上提供额外的自动化。在本章中，我们将调查与**持续集成**和**持续交付**（**CI**/**CD**）以及`GitOps`相关的概念，这些方法可以自动调用Helm
    CLI以及其他命令，以执行针对Git存储库的自动化工作流。这些工作流可以用于使用Helm自动部署应用程序，并在图表开发生命周期中构建、测试和打包Helm图表。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding CI/CD and GitOps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解CI/CD和GitOps
- en: Setting up our environment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的环境
- en: Creating a CI pipeline to build Helm charts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于构建Helm图表的CI流水线
- en: Creating a CD pipeline to deploy applications with Helm
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helm创建CD流水线以部署应用程序
- en: Cleaning up
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires you to have the following technologies installed on your
    local machine:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要您在本地机器上安装以下技术：
- en: Minikube
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minikube
- en: Helm
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm
- en: kubectl
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl
- en: Git
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: In addition to these tools, you should find the Packt repository containing
    resources associated with the examples used in this chapter on GitHub at [https://github.com/PacktPublishing/-Learn-Helm](https://github.com/PacktPublishing/-Learn-Helm).
    This repository will be referenced throughout this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些工具，您还应该在GitHub的Packt存储库中找到与本章中使用的示例相关的资源，网址为[https://github.com/PacktPublishing/-Learn-Helm](https://github.com/PacktPublishing/-Learn-Helm)。本存储库将在本章中被引用。
- en: Understanding CI/CD and GitOps
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解CI/CD和GitOps
- en: 'So far, we have addressed many of the key concepts that are inherent to Helm
    development—building, testing, and deploying. However, our exploration has been
    limited to manual configurations and invocations of the Helm CLI. While this is
    okay when getting started with Helm, as you look to move a chart into a production-like
    environment, there are several questions that you need to consider, including
    the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了许多与Helm开发相关的关键概念——构建、测试和部署。然而，我们的探索仅限于手动配置和调用Helm CLI。当您希望将图表移入类似生产环境时，有几个问题需要考虑，包括以下内容：
- en: How can I be sure that the best practices for chart development and deployment
    are enforced?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何确保图表开发和部署的最佳实践得到执行？
- en: What are the implications of collaborators participating in the development
    and deployment processes?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合作者参与开发和部署过程的影响是什么？
- en: These points are applicable to any software project, not just to Helm chart
    development. While we have covered a lot of best practices so far, when taking
    on new collaborators, they may not have the same understanding of these topics
    or the discipline to perform these crucial steps. Through the use of automation
    and repeatable processes, concepts such as CI/CD have been established to address
    some of these challenges.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些观点适用于任何软件项目，不仅适用于Helm图表开发。虽然我们已经涵盖了许多最佳实践，但在接纳新的合作者时，他们可能对这些主题没有相同的理解，或者没有执行这些关键步骤的纪律。通过使用自动化和可重复的流程，诸如CI/CD之类的概念已经被建立起来，以解决其中的一些挑战。
- en: CI/CD
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD
- en: The need for an automated software development process that can be adhered to
    each time a software change occurs led to the creation of CI. CI not only ensures
    that best practices are adhered to, but it also helps eliminate the common challenges
    faced by many developers, as embodied in the phrase 'it works on my machine.'
    One factor that we discussed previously is the use of **version control systems**,
    such as `git`, to store source code. Often, each user would have their own independent
    copy of source code, which made maintaining the code base challenging to manage
    as additional contributors were brought on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个自动化的软件开发流程，每次软件发生变化时都能遵循，这导致了CI的产生。CI不仅确保了最佳实践的遵守，而且还有助于消除许多开发人员面临的常见挑战，正如“它在我的机器上可以运行”所体现的。我们之前讨论过的一个因素是使用版本控制系统，比如`git`，来存储源代码。通常，每个用户都会有自己独立的源代码副本，这使得在增加贡献者时难以管理代码库。
- en: CI is properly enabled through the use of an automation tool, where source code
    is retrieved and undergoes a predetermined set of steps whenever changes occur.
    The need for a proper automation tool led to the rise of software specifically
    designed for this purpose. Several examples of CI tools include Jenkins, TeamCity,
    and Bamboo, along with a variety of **Software-as-a-Service** (**SaaS**)-based
    solutions. By offloading the responsibility of tasks onto a third-party component,
    developers are more likely to commit code frequently and project managers can
    feel confident in the skill of their teams and the robustness of their products.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CI是通过使用自动化工具来正确启用的，其中源代码在发生更改时经历一组预定的步骤。对于正确的自动化工具的需求导致了专门为此目的设计的软件的兴起。一些CI工具的例子包括Jenkins、TeamCity和Bamboo，以及各种基于软件即服务（SaaS）的解决方案。通过将任务的责任转移到第三方组件，开发人员更有可能频繁提交代码，项目经理可以对团队的技能和产品的健壮性感到自信。
- en: One key feature that is found in most of these tools is the ability to provide
    timely notifications on the current state of a project. Instead of discovering
    a breaking change later in the software development cycle, through the use of
    CI, as soon as changes are incorporated, processes are executed and notifications
    to interested parties are transmitted. By making use of rapid notifications, it
    provides the user who introduced the change with the opportunity to resolve the
    issue while the area of interest is at the front of the mind, instead of later
    on in the delivery process when they may be occupied elsewhere.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些工具中都具有的一个关键特性是能够及时通知项目当前状态的能力。通过使用持续集成，不是在软件开发周期的后期才发现破坏性变化，而是在变化被整合后立即执行流程并向相关方发送通知。通过利用快速通知，它为引入变化的用户提供了解决问题的机会，而兴趣所在的领域正处于头脑前沿，而不是在交付过程的后期，当时他们可能已经在其他地方忙碌。
- en: The ability to apply many of CI's concepts throughout an entire software delivery
    life cycle as an application moves its way toward production led to the creation
    of CD. CD is a set of defined steps written to progress software through a release
    process (more commonly referred to as a pipeline). CI and CD are typically paired
    together as many of the same execution engines that perform CI can also implement
    CD. CD has gained acceptance and popularity among many organizations where proper
    change control is enforced and approvals are required in order for the software
    release process to progress to the next stage. As many of the concepts around
    CI/CD are automated in a repeatable fashion, teams can look to fully eliminate
    the need for the manual approval steps once they feel confident that they have
    a reliable framework in place.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将CI的许多概念应用于整个软件交付生命周期，随着应用程序向生产环境推进，导致了CD的产生。CD是一组定义的步骤，编写用于推进软件通过发布过程（更常被称为流水线）。CI和CD通常一起配对，因为执行CI的许多相同引擎也可以实现CD。CD在许多组织中得到了接受和流行，这些组织强制执行适当的变更控制，并要求批准，以便软件发布过程能够进展到下一个阶段。由于CI/CD周围的许多概念都是以可重复的方式自动化的，团队可以寻求完全消除手动批准步骤的需要，一旦他们确信已经建立了可靠的框架。
- en: The process of implementing a fully automated build, test, deployment, and release
    process without any human intervention is known as **continuous deployment**.
    While many software projects never fully achieve continuous deployment, by just
    implementing the concepts emphasized by CI/CD, teams are able to produce real
    business value faster. In the next section, we will introduce GitOps as a mechanism
    to improve the management of applications and their configuration.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有任何人为干预的情况下实施完全自动化的构建、测试、部署和发布过程的过程被称为**持续部署**。虽然许多软件项目从未完全实现持续部署，但通过实施CI/CD强调的概念，团队能够更快地产生真正的业务价值。在下一节中，我们将介绍GitOps作为改进应用程序及其配置管理的机制。
- en: Taking CI/CD to the next level using GitOps
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将CI/CD提升到下一个级别，使用GitOps
- en: Kubernetes is a platform that embraces the use of declarative configuration.
    In the same way that an application written in any programming language, such
    as Python, Golang, or Java traverses its way through a CI/CD pipeline, Kubernetes
    manifests can implement many of the same patterns. Manifests should also be stored
    in a source code repository, such as Git, and can undergo the same type of build,
    test, and deployment practices. The rise in popularity of managing the life cycle
    of Kubernetes cluster configuration within Git repositories and then applying
    these resources in an automated fashion led to the concept of GitOps. First introduced
    by the software company WeaveWorks in 2017, GitOps has increased in popularity
    ever since as a way to manage Kubernetes configurations. While GitOps is best
    known in the context of Kubernetes, its principles can be applied to any cloud-native
    environment.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是一个支持声明式配置的平台。与任何编程语言编写的应用程序（如Python、Golang或Java）通过CI/CD流水线的方式一样，Kubernetes清单也可以实现许多相同的模式。清单也应该存储在源代码仓库（如Git）中，并且可以经历相同类型的构建、测试和部署实践。在Git存储库中管理Kubernetes集群配置的生命周期的流行度上升，然后以自动化的方式应用这些资源，导致了GitOps的概念。GitOps最早由软件公司WeaveWorks在2017年首次引入，自那时以来，作为管理Kubernetes配置的一种方式，GitOps的流行度一直在增加。虽然GitOps在Kubernetes的背景下最为人所知，但其原则可以应用于任何云原生环境。
- en: Similar to CI/CD, tools have been developed to manage the GitOps process. These
    include **ArgoCD from Intuit** and **Flux by WeaveWorks**, the organization responsible
    for coining the term GitOps. You do not need to use a tool that is specifically
    designed for GitOps as any automation tool, particularly one designed for managing
    the CI/CD process, can be utilized. The key differentiator between a traditional
    CI/CD tool and a tool designed for GitOps is the ability for the GitOps tool to
    constantly observe the state of the Kubernetes cluster and apply the desired configurations
    whenever the current state does not match the desired state, as defined in the
    manifests stored in Git. These tools make use of the controller pattern that is
    fundamental to Kubernetes itself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与CI/CD类似，已经开发了工具来管理GitOps流程。这些包括Intuit的ArgoCD和WeaveWorks的Flux，这个组织负责创造GitOps这个术语。您不需要使用专门设计用于GitOps的工具，因为任何自动化工具，特别是设计用于管理CI/CD流程的工具，都可以被利用。传统CI/CD工具和专为GitOps设计的工具之间的关键区别在于GitOps工具能够不断观察Kubernetes集群的状态，并在当前状态与Git存储中定义的期望状态不匹配时应用所需的配置。这些工具利用了Kubernetes本身的控制器模式。
- en: Since Helm charts are ultimately rendered as Kubernetes resources, they, too,
    can be used to participate in the GitOps process and many of the aforementioned
    GitOps tools natively support Helm. We will see how to make use of Helm charts
    using CI/CD and GitOps throughout the remainder of this chapter, leveraging Jenkins
    as the tool of choice for both CI and CD.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Helm图表最终被渲染为Kubernetes资源，它们也可以用于参与GitOps流程，并且许多前述的GitOps工具本身原生支持Helm。我们将在本章的其余部分中看到如何利用CI/CD和GitOps来使用Helm图表，利用Jenkins作为CI和CD的首选工具。
- en: Setting up our environment
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的环境
- en: In this chapter, we will develop two different pipelines to demonstrate how
    different processes around Helm can be automated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发两种不同的流水线，以演示如何自动化Helm周围的不同流程。
- en: 'Take the following steps to begin setting up your local environment:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 开始设置本地环境的步骤如下：
- en: 'First, given the increased memory requirements of this chapter, you should
    delete your `minikube` cluster and recreate it with `4g` of memory if it was not
    inititalized with 4g of memory in [*Chapter 2*](B15458_02_Final_JM_ePub.xhtml#_idTextAnchor098)*,
    Preparing a Kubernetes and Helm Environment*. This can be done by running the
    following commands:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，鉴于本章的内存要求增加，如果在[*第2章*]（B15458_02_Final_JM_ePub.xhtml#_idTextAnchor098）中未使用4g内存初始化`minikube`集群，则应删除该集群并使用4g内存重新创建。可以通过运行以下命令来完成：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once Minikube starts, create a new namespace called `chapter7`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Minikube启动后，创建一个名为`chapter7`的新命名空间：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should, additionally, fork the Packt repository, which will allow you to
    make modifications against the repository based on the steps described in these
    exercises:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还应该fork Packt存储库，这将允许您根据这些练习中描述的步骤对存储库进行修改：
- en: Create a fork of the Packt repository by clicking the **Fork** button on the
    Git repo:![Figure 7.1 – Select the Fork button to fork the Packt repository
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击Git存储库上的**Fork**按钮来创建Packt存储库的分支：![图7.1 - 选择Fork按钮来创建Packt存储库的分支
- en: '](image/Figure_7.1.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.1.jpg)'
- en: Figure 7.1 – Select the Fork button to fork the Packt repository
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 - 选择Fork按钮来创建Packt存储库的分支
- en: You must have a GitHub account to fork a repository. The process of creating
    a new account is described in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须拥有GitHub帐户才能fork存储库。创建新帐户的过程在[*第5章*]（B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265）中有描述，*构建您的第一个Helm图表*。
- en: 'After you create a fork of the Packt repository, clone this fork to your local
    machine by running the following command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Packt存储库的分支后，通过运行以下命令将此分支克隆到本地计算机：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In addition to creating a fork of the Packt repository, you may want to remove
    the `guestbook` chart from your Helm repository, served from your GitHub Pages
    repository, which we created in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*. While it is not strictly necessary, the examples
    in this chapter will assume a clean slate.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建Packt存储库的分支外，您可能还希望从您的Helm存储库中删除`guestbook`图表，该图表是从您的GitHub Pages存储库中提供的，我们在[*第5章*]（B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265）中创建了*构建您的第一个Helm图表*。虽然这并不是绝对必要的，但本章中的示例将假定一个干净的状态。
- en: 'Use the following steps to remove this chart from your chart repository:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤从图表存储库中删除此图表：
- en: 'Navigate to the local clone of your Helm chart repository. As you will recall,
    the name we recommended for your chart repository was `Learn-Helm-Chart-Repository`,
    so we will use this name throughout this chapter to refer to your GitHub Pages-based
    chart repository:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到Helm图表存储库的本地克隆。您会记得，我们建议的图表存储库的名称是`Learn-Helm-Chart-Repository`，因此在本章中我们将使用这个名称来引用您的基于GitHub
    Pages的图表存储库：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Remove the `guestbook-1.0.0.tgz` and `index.yaml` files from your chart repository:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从图表存储库中删除`guestbook-1.0.0.tgz`和`index.yaml`文件：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Push these changes to your remote repository:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些更改推送到您的远程存储库：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should be able to confirm in GitHub that your chart and index files have
    been removed, leaving only the `README.md` file:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该能够在GitHub中确认您的图表和索引文件已被删除，只留下`README.md`文件：
- en: '![Figure 7.2 – The only file you should see in your chart repository is the
    README.md file'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - 您在图表存储库中应该看到的唯一文件是README.md文件
- en: '](image/Figure_7.2.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.2.jpg)'
- en: Figure 7.2 – The only file you should see in your chart repository is the README.md
    file
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 - 您在图表存储库中应该看到的唯一文件是README.md文件
- en: Now that you have started Minikube, created a fork of the Packt repository,
    and removed the Guestbook chart from `Learn-Helm-Chart-Repository`, let's begin
    learning how a CI pipeline can be created to release Helm charts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经启动了Minikube，创建了Packt存储库的一个分支，并从`Learn-Helm-Chart-Repository`中删除了Guestbook图表，让我们开始学习如何创建一个CI流水线来发布Helm图表。
- en: Creating a CI pipeline to build Helm charts
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个CI流水线来构建Helm图表
- en: The concept of CI can be applied to the perspective of a chart developer who
    builds, tests, packages, and releases Helm charts to a chart repository. In this
    section, we will describe what using an end-to-end CI pipeline to streamline this
    process may look like, as well as walk you through how to build an example pipeline.
    The first step is to design the components required for the example pipeline.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: CI的概念可以应用于构建、测试、打包和发布Helm图表到图表存储库的图表开发人员的视角。在本节中，我们将描述使用端到端CI流水线来简化这个过程可能是什么样子，以及如何通过构建一个示例流水线来引导您。第一步是设计示例流水线所需的组件。
- en: Designing the pipeline
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计流水线
- en: In the previous chapters, developing Helm charts was largely a manual process.
    While Helm provides automation for creating `test` hooks in a Kubernetes cluster,
    the invocation of the `helm lint`, `helm test`, or `ct lint-and-install` commands
    is manually executed after a change in code to ensure tests still pass. Once linting
    and testing continue to pass after a code change, the chart can be packaged by
    running the `helm package` command. If the chart is served using a GitHub Pages
    repository (such as the one created in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm chart*), the `index.yaml` file is created by running
    `helm repo index`, and the `index.yaml` file, along with the packaged chart, is
    pushed to the GitHub repository.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，开发Helm图表主要是一个手动过程。虽然Helm提供了在Kubernetes集群中创建`test`钩子的自动化，但在代码更改后手动执行`helm
    lint`、`helm test`或`ct lint-and-install`命令以确保测试仍然通过。一旦代码更改后继续通过linting和测试，图表就可以通过运行`helm
    package`命令进行打包。如果使用GitHub Pages存储库（比如在[*第5章*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265)中创建的那个，*构建您的第一个Helm图表*），则通过运行`helm
    repo index`创建`index.yaml`文件，并将`index.yaml`文件以及打包的图表推送到GitHub存储库。
- en: While invoking each command manually is certainly feasible, this workflow can
    become increasingly difficult to sustain as you develop additional Helm charts
    or add additional contributors. With a manual workflow, it is easy to allow untested
    changes to be made to your charts and it is difficult to ensure that contributors
    are adhering to testing and contributing guidelines. Luckily, these issues can
    be avoided by creating a CI pipeline that automates your release process.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然手动调用每个命令当然是可行的，但随着您开发更多的Helm图表或添加更多的贡献者，这种工作流程可能变得越来越难以维持。使用手动工作流程，很容易允许未经测试的更改被应用到您的图表中，并且很难确保贡献者遵守测试和贡献指南。幸运的是，通过创建一个自动化发布流程的CI流水线，可以避免这些问题。
- en: 'The following steps outline an example CI workflow using the commands and tooling
    discussed throughout this book so far. It will assume that the resulting charts
    are saved in a GitHub Pages repository:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了使用本书中讨论的命令和工具来进行示例CI工作流。它将假定生成的图表保存在GitHub Pages存储库中：
- en: A chart developer makes a code change to a chart or a set of charts in a `git`
    monorepo.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图表开发人员对`git` monorepo中的一个图表或一组图表进行代码更改。
- en: The developer pushes the change(s) to the remote repository.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员将更改推送到远程存储库。
- en: The charts that have been modified are automatically linted and tested in a
    Kubernetes namespace by running the `ct lint` and `ct install` commands.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已修改的图表会通过运行`ct lint`和`ct install`命令在Kubernetes命名空间中自动进行linting和测试。
- en: If linting and testing is successful, the charts are automatically packaged
    with the `helm package` command.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果linting和测试成功，图表将自动使用`helm package`命令打包。
- en: The `index.yaml` file is automatically generated with the `helm repo index`
    command.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`index.yaml`文件将使用`helm repo index`命令自动生成。'
- en: The packaged charts and the updated `index.yaml` file are automatically pushed
    to the repository. They are pushed to either `stable` or `staging`, depending
    on the branch that the job was run against.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打包的图表和更新的`index.yaml`文件将自动推送到存储库。它们将被推送到`stable`或`staging`，具体取决于作业运行的分支。
- en: In the next section, we will perform this process using **Jenkins**. Let's begin
    by understanding what Jenkins is and how it works.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用**Jenkins**执行这个过程。让我们首先了解一下Jenkins是什么以及它是如何工作的。
- en: Understanding Jenkins
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解Jenkins
- en: Jenkins is an open source server used to perform automated tasks and workflows.
    It is commonly used to create CI/CD pipelines via Jenkins's **pipeline as code**
    feature, written in a file called a `Jenkinsfile` that defines a Jenkins pipeline.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是一个用于执行自动化任务和工作流程的开源服务器。它通常用于通过Jenkins的**管道即代码**功能创建CI/CD流水线，该功能在一个名为`Jenkinsfile`的文件中编写，该文件定义了Jenkins流水线。
- en: A Jenkins pipeline is written using the Groovy **Domain-Specific Language**
    (**DSL**). Groovy is a language similar to Java but, unlike Java, it can be used
    as an object-oriented scripting language, lending itself to writing easy-to-read
    automation. Throughout this chapter, we will walk you through two existing `Jenkinsfile`
    files that have already been prepared for you. You do not need to have any prior
    experience with writing a `Jenkinsfile` file from scratch, as a deep dive into
    Jenkins is beyond the scope of this book. With that said, by the end of this chapter,
    you should be able to take the concepts learned and apply them to an automation
    tool of your choice. While Jenkins is featured in this chapter, its concepts can
    be applied to any other automation tool.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins流水线是使用Groovy**领域特定语言**（**DSL**）编写的。Groovy是一种类似于Java的语言，但与Java不同的是，它可以用作面向对象的脚本语言，适合编写易于阅读的自动化。在本章中，我们将带您了解两个已经为您准备好的`Jenkinsfile`文件。您不需要有任何关于从头开始编写`Jenkinsfile`文件的经验，因为深入研究Jenkins超出了本书的范围。话虽如此，到本章结束时，您应该能够将学到的概念应用到您选择的自动化工具中。虽然本章中介绍了Jenkins，但其概念也可以应用于任何其他自动化工具。
- en: When a `Jenkinsfile` file is created, the defined set of steps of the workflow
    is executed on the Jenkins server itself or in a separate agent delegated to run
    the job, instead. Additional capabilities can be integrated with Kubernetes by
    automatically scheduling Jenkins agents as separate Pods whenever a build is kicked
    off, simplifying the creation and management of agents. After an agent completes,
    it can be configured to automatically terminate so that the next build can run
    in a fresh, clean Pod. In this chapter, we will run the example pipelines using
    Jenkins agents.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个`Jenkinsfile`文件时，工作流程的一组定义的步骤将在Jenkins服务器本身上执行，或者委托给运行该作业的单独代理。还可以通过自动调度Jenkins代理作为单独的Pod集成额外的功能，每当启动构建时，简化代理的创建和管理。代理完成后，可以配置为自动终止，以便下一个构建可以在一个新的、干净的Pod中运行。在本章中，我们将使用Jenkins代理运行示例流水线。
- en: Jenkins also lends itself well to the concept of GitOps by providing the ability
    to scan a source control repository for the presence of a `Jenkinsfile` file.
    For each branch that contains a `Jenkinsfile` file, a new job is automatically
    configured that will begin by cloning the repository against the desired branch.
    This makes it simple to test new features and fixes as new jobs can be automatically
    created alongside their corresponding branches.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins还非常适合GitOps的概念，因为它提供了扫描源代码存储库以查找`Jenkinsfile`文件的能力。对于每个包含`Jenkinsfile`文件的分支，将自动配置一个新作业，该作业将从所需分支克隆存储库开始。这样可以很容易地测试新功能和修复，因为新作业可以自动创建并与其相应的分支一起使用。
- en: With a basic understanding of Jenkins, let's now install Jenkins on our Minikube
    environment.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在对Jenkins有基本了解之后，让我们在Minikube环境中安装Jenkins。
- en: Installing Jenkins
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Jenkins
- en: 'As with many applications that are commonly deployed on Kubernetes, Jenkins
    can be deployed with one of many different community Helm charts from Helm Hub.
    In this chapter, we will use the Jenkins Helm chart from the **Codecentric** software
    development company. Add the `codecentric` chart repository to begin installing
    the Codecentric Jenkins Helm chart:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多通常部署在Kubernetes上的应用程序一样，Jenkins可以使用来自Helm Hub的许多不同社区Helm图之一进行部署。在本章中，我们将使用来自**Codecentric**软件开发公司的Jenkins
    Helm图。添加`codecentric`图存储库以开始安装Codecentric Jenkins Helm图：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Among the expected Kubernetes-related values, such as configuring the resource
    limits and the service type, the `codecentric` Jenkins Helm chart contains other
    Jenkins-related values used to automatically configure different Jenkins components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在预期的与Kubernetes相关的值中，例如配置资源限制和服务类型，`codecentric` Jenkins Helm图包含其他用于自动配置不同Jenkins组件的Jenkins相关值。
- en: 'Since configuring these values requires a deeper understanding of Jenkins that
    is beyond the scope of this book, a `values` file is provided for you that will
    automatically prepare the following Jenkins configurations:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于配置这些值需要对超出本书范围的Jenkins有更深入的了解，因此为您提供了一个`values`文件，该文件将自动准备以下Jenkins配置：
- en: Add relevant Jenkins plugins that are not included in the base image.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加未包含在基本镜像中的相关Jenkins插件。
- en: Configure the credentials required to authenticate with GitHub.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置所需的凭据以与GitHub进行身份验证。
- en: Configure a Jenkins agent specifically designed for testing and installing Helm
    charts.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置专门设计用于测试和安装Helm图的Jenkins代理。
- en: Configure Jenkins to automatically create a new job based on the presence of
    the `Jenkinsfile` file.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Jenkins以根据`Jenkinsfile`文件的存在自动创建新作业。
- en: Skip manual prompts that normally occur on the startup of a new installation.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过通常在新安装启动时发生的手动提示。
- en: Disable authentication to simplify Jenkins access for this chapter.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用身份验证，以简化本章中对Jenkins的访问。
- en: 'The `values` file will also configure the following Kubernetes-related details:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`values`文件还将配置以下与Kubernetes相关的细节：'
- en: Set resource limits against the Jenkins server.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对Jenkins服务器设置资源限制。
- en: Set the Jenkins service type to `NodePort.`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Jenkins服务类型设置为`NodePort`。
- en: Create the ServiceAccounts and RBAC rules required for Jenkins and Jenkins agents
    to run jobs and deploy Helm charts in the Kubernetes environment.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Jenkins和Jenkins代理在Kubernetes环境中运行作业和部署Helm图所需的ServiceAccounts和RBAC规则。
- en: Set the Jenkins `PersistentVolumeClaim` size to `2Gi.`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Jenkins的`PersistentVolumeClaim`大小设置为`2Gi`。
- en: 'This values file is available at [https://github.com/PacktPublishing/-Learn-Helm/blob/master/jenkins/values.yaml](https://github.com/PacktPublishing/-Learn-Helm/blob/master/jenkins/values.yaml).
    When browsing the content of these values, you may notice that the configuration
    defined under `fileContent` contains Go templating. The beginning of this value
    can be seen here:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该values文件可在[https://github.com/PacktPublishing/-Learn-Helm/blob/master/jenkins/values.yaml](https://github.com/PacktPublishing/-Learn-Helm/blob/master/jenkins/values.yaml)找到。浏览这些值的内容时，您可能会注意到`fileContent`下定义的配置包含Go模板。该值的开头如下所示：
- en: '![Figure 7.3 – The values.yaml file for the Jenkins Helm chart contains Go
    templating](image/Figure_7.3.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 - Jenkins Helm图表的values.yaml文件包含Go模板](image/Figure_7.3.jpg)'
- en: Figure 7.3 – The `values.yaml` file for the Jenkins Helm chart contains Go templating
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 - Jenkins Helm图表的`values.yaml`文件包含Go模板
- en: 'While Go templating is not normally valid in a `values.yaml` file, the Codecentric
    Jenkins Helm chart supplies the `fileContent` configuration to a template function
    called `tpl`. A simplified view of what this looks like on the template side is
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Go模板通常在`values.yaml`文件中无效，但Codecentric Jenkins Helm图表向模板函数`tpl`提供了`fileContent`配置。在模板方面，这看起来如下所示：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `tpl` command will parse the `fileContent` value as a Go template, allowing
    it to contain Go templating even though it is defined in a `values.yaml` file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`tpl`命令将解析`fileContent`值作为Go模板，使其可以包含Go模板，即使它是在`values.yaml`文件中定义的。'
- en: 'For this chapter, the Go templating defined in the `fileContent` configuration
    helps ensure that Jenkins is installed in a way that corresponds with this chapter''s
    requirements. Namely, the templating will require the following additional values
    to be provided during installation:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，`fileContent`配置中定义的Go模板有助于确保Jenkins安装方式符合本章的要求。换句话说，模板将需要在安装过程中提供以下附加值：
- en: '`githubUsername`: The GitHub username'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`githubUsername`：GitHub用户名'
- en: '`githubPassword`: The GitHub password'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`githubPassword`：GitHub密码'
- en: '`githubForkUrl`: The URL of your Packt repository fork, which was taken in
    the *Technical requirements* section of this chapter'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`githubForkUrl`：您的Packt存储库分支的URL，该分支在本章的*技术要求*部分中提取'
- en: '`githubPagesRepoUrl`: The URL of your GitHub Pages Helm repository, which was
    created at the end of [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`githubPagesRepoUrl`：您的GitHub Pages Helm存储库的URL，该存储库是在[*第5章*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265)结束时创建的，*构建您的第一个Helm图表*'
- en: Note that this is not the URL to your static site, but the URL to the GitHub
    repository itself—for example, https://github.com/$GITHUB_USERNAME/Learn-Helm-Chart-Repository.git.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这不是您静态站点的URL，而是GitHub存储库本身的URL，例如，https://github.com/$GITHUB_USERNAME/Learn-Helm-Chart-Repository.git。
- en: The four values described in the preceding list can be provided using the `--set`
    flag, or they can be provided from an additional `values` file using the `--values`
    flag. If you choose to create a separate `values` file, ensure that you do not
    commit and push that file to source control as it contains sensitive information.
    The example in this chapter favors the `--set` flag for these four values. In
    addition to the values described, the `values.yaml` file included in the Packt
    repository should also be provided using the `--values` flag.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前述列表中描述的四个值可以使用`--set`标志提供，也可以使用`--values`标志从额外的`values`文件中提供。如果选择创建单独的`values`文件，请确保不要将该文件提交和推送到源代码控制，因为它包含敏感信息。本章的示例偏向于使用`--set`标志来提供这四个值。除了上述描述的值之外，还应该使用`--values`标志提供Packt存储库中包含的`values.yaml`文件。
- en: 'Install your `Jenkins` instance with the `helm install` command, using the
    following example as a reference:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下示例作为参考，使用`helm install`命令安装您的`Jenkins`实例：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can monitor the installation by running a watch against the Pods in the
    `chapter7` namespace:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过对“chapter7”命名空间中的Pod运行监视来监视安装。
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that in very rare cases, your Pod may become stuck at the `Init:0/1` stage.
    This can occur if availability issues to external dependencies, such as if the
    Jenkins plugin site and its mirrors were experiencing downtime. If this occurs,
    try deleting your release and reinstalling it after several minutes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在极少数情况下，您的Pod可能会在“Init:0/1”阶段卡住。如果外部依赖出现可用性问题，比如Jenkins插件站点及其镜像正在经历停机时间，就会发生这种情况。如果发生这种情况，请尝试在几分钟后删除您的发布并重新安装它。
- en: 'Once your Jenkins Pod reports `1/1` under the `READY` column, your `Jenkins`
    instance is ready to be accessed. Copy and paste the following contents of the
    displayed post-installation notes to reveal the Jenkins URL:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的Jenkins Pod在“READY”列下报告“1/1”，您的“Jenkins”实例就可以被访问了。复制并粘贴显示的安装后说明的以下内容以显示Jenkins
    URL：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you access Jenkins, your front page should look similar to the following
    screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问Jenkins时，您的首页应该看起来类似于以下屏幕截图：
- en: '![Figure 7.4 – The Jenkins home page after running the Helm installation'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4-运行Helm安装后的Jenkins主页'
- en: '](image/Figure_7.4.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.4.jpg)'
- en: Figure 7.4 – The Jenkins home page after running the Helm installation
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4-运行Helm安装后的Jenkins主页
- en: If the chart were installed properly, you'll notice that a new job called **Test
    and Release Helm Charts** is created. At the bottom left-hand corner of the page,
    you'll notice the **Build Executor Status** panel, which is used to provide an
    overview of the active jobs that are currently running. A job is automatically
    triggered for the first time when it is created, which is why you will see it
    running when you log in to your Jenkins instance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图表安装正确，您会注意到一个名为**测试和发布Helm图表**的新作业被创建。在页面的左下角，您会注意到**构建执行器状态**面板，用于提供当前正在运行的活动作业的概览。当作业被创建时，将自动触发该作业，这就是为什么当您登录到Jenkins实例时会看到它正在运行。
- en: Now that Jenkins is installed and its frontend has been validated, let's walk
    through the example `Jenkinsfile` file from the Packt repository to understand
    how the CI pipeline works. Note that we will not display the full contents of
    the `Jenkinsfile` file in this chapter as we want to simply highlight the key
    areas of interest. The full contents of the file can be viewed in the Packt repository
    at [https://github.com/PacktPublishing/-Learn-Helm/blob/master/helm-charts/Jenkinsfile](https://github.com/PacktPublishing/-Learn-Helm/blob/master/helm-charts/Jenkinsfile).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Jenkins已安装并且其前端已经验证，让我们浏览一下Packt存储库中的示例“Jenkinsfile”文件，以了解CI管道的工作原理。请注意，本章节中我们不会显示“Jenkinsfile”文件的全部内容，因为我们只想简单地突出感兴趣的关键领域。文件的全部内容可以在Packt存储库中查看[https://github.com/PacktPublishing/-Learn-Helm/blob/master/helm-charts/Jenkinsfile](https://github.com/PacktPublishing/-Learn-Helm/blob/master/helm-charts/Jenkinsfile)。
- en: Understanding the pipeline
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解管道
- en: 'The first thing that occurs when the `Test and Deploy Helm Charts` job is triggered
    is that a new Jenkins agent is created. By leveraging the values provided in `Learn-Helm/jenkins/values.yaml`,
    the Jenkins chart installation automatically configures a Jenkins agent called
    `chart-testing-agent`. The following line designates that agent as the agent for
    this `Jenkinsfile` file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 触发“测试和部署Helm图表”作业时发生的第一件事是创建一个新的Jenkins代理。通过利用“Learn-Helm/jenkins/values.yaml”中提供的值，Jenkins图表安装会自动配置一个名为“chart-testing-agent”的Jenkins代理。以下一行指定该代理为此“Jenkinsfile”文件的代理：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This agent is configured by the Jenkins chart values to run using the chart
    testing image provided by the Helm community. The chart testing image, located
    at `quay.io/helmpack/chart-testing`, contains many of the tools that were discussed
    in [*Chapter 6*](B15458_06_Final_JM_ePub.xhtml#_idTextAnchor292), *Testing Helm
    Charts*. Specifically, this image contains the following tools:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此代理由Jenkins图表值配置，使用Helm社区提供的图表测试图像运行。位于`quay.io/helmpack/chart-testing`的图表测试图像包含了[*第6章*](B15458_06_Final_JM_ePub.xhtml#_idTextAnchor292)中讨论的许多工具，*测试Helm图表*。具体来说，该图像包含以下工具：
- en: '`helm`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`helm`'
- en: '`ct`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ct`'
- en: '`yamllint`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yamllint`'
- en: '`yamale`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yamale`'
- en: '`git`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git`'
- en: '`Kubectl`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Kubectl`'
- en: Since this image contains all of the tools required to test the Helm charts,
    it can be used as the primary image to perform CI for our Helm charts.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此图像包含测试Helm图表所需的所有工具，因此可以将其用作执行Helm图表的CI的主要图像。
- en: When a Jenkins agent is run, it clones your GitHub fork, specified by the `githubForkUrl`
    value, using `githubUsername` and `githubPassword` for authentication. This is
    performed implicitly by Jenkins, so no code needs to be specified within the `Jenkinsfile`
    file to perform this action.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当Jenkins代理运行时，它会使用`githubUsername`和`githubPassword`进行身份验证，隐式地克隆您的GitHub分支，由`githubForkUrl`值指定。Jenkins会自动执行此操作，因此不需要在`Jenkinsfile`文件中指定任何代码来执行此操作。
- en: 'After the Jenkins agent clones your repository, it begins executing the stages
    defined in the `Jenkinsfile` file. Stages are logical groupings within a pipeline
    that can help visualize the high-level steps. The first stage that will be performed
    is the lint stage, which contains the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins代理克隆您的存储库后，将开始执行`Jenkinsfile`文件中定义的阶段。阶段是管道中的逻辑分组，可以帮助可视化高级步骤。将执行的第一个阶段是lint阶段，其中包含以下命令：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `sh` portion in the preceding command is a command used to run a bash shell
    or script and invokes the `lint` subcommand of the `ct` tool. As you will recall,
    this command lints the `Chart.yaml` and `values.yaml` files on all charts that
    have been modified against the master branch, which we covered in [*Chapter 6*](B15458_06_Final_JM_ePub.xhtml#_idTextAnchor292),
    *Testing Helm Charts*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令中的`sh`部分是用于运行bash shell或脚本并调用`ct`工具的`lint`子命令。您会记得，此命令会针对已修改的所有图表的`Chart.yaml`和`values.yaml`文件对主分支进行检查，我们在[*第6章*](B15458_06_Final_JM_ePub.xhtml#_idTextAnchor292)中已经讨论过这一点，*测试Helm图表*。
- en: 'If the linting is successful, the pipeline will continue on to the test stage
    and will run the following command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果linting成功，流水线将继续进行到测试阶段，并执行以下命令：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command should look familiar, also. It installs each modified chart from
    its version on the master branch and performs the defined test suites. It also
    ensures any upgrades from the previous version are successful, which aids in helping
    to prevent regressions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令也应该很熟悉。它会从主分支上的版本安装每个修改的图表，并执行定义的测试套件。它还确保从上一个版本的任何升级都成功，有助于防止回归。
- en: Note that the two previous stages could have been combined by running a single
    `ct lint-and-install --upgrade` command. This would still have resulted in a valid
    pipeline, but this example, which is broken up into separate stages, allows better
    visualization of the actions that are performed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前两个阶段可以通过运行单个`ct lint-and-install --upgrade`命令来合并。这仍然会导致有效的流水线，但这个示例将它们分成单独的阶段，可以更好地可视化执行的操作。
- en: 'If the test stage is successful, the pipeline proceeds to the package charts
    stage, which executes the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试阶段成功，流水线将继续进行到打包图表阶段，执行以下命令：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The command at this stage will simply package each chart contained under the
    `helm-charts/charts` folder. It will also update and download each dependency
    that is declared.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，命令将简单地打包`helm-charts/charts`文件夹下包含的每个图表。它还将更新和下载每个声明的依赖项。
- en: 'If the packaging is successful, the pipeline proceeds to the final stage, called
    `push charts to repo`. This is the most complex stage, so we will break it up
    into smaller steps. The first step can be seen here:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果打包成功，管道将继续进行到最后一个阶段，称为`推送图表到存储库`。这是最复杂的阶段，所以我们将把它分解成较小的步骤。第一步可以在这里看到：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Since the Helm chart repository that we are pushing to is a separate GitHub
    Pages repository, we must clone the repository so that we can add the new charts
    and push the changes. Once the GitHub Pages repository is cloned, a variable called
    `repoType` is set, depending on the branch that the CI/CD pipeline runs against.
    This variable is used to determine whether the charts packaged in the previous
    stage should be pushed to the `stable` or `staging` chart repository.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Helm图表存储库是一个单独的GitHub Pages存储库，我们必须克隆该存储库，以便我们可以添加新的图表并推送更改。一旦克隆了GitHub Pages存储库，就会设置一个名为`repoType`的变量，具体取决于CI/CD管道针对的分支。该变量用于确定前一阶段打包的图表应该推送到`stable`或`staging`图表存储库。
- en: For this pipeline, `stable` implies that the charts have been tested, validated,
    and merged into the master branch. `staging` implies that the chart is under development
    and has not yet been merged into the master branch nor been officially released.
    You can, alternatively, release charts under the stable repository when you cut
    to a release branch, but for this example, we will take the former approach of
    assuming every merge into master is a new release.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个管道，`stable`意味着图表已经经过测试、验证并合并到主分支中。`staging`意味着图表正在开发中，尚未合并到主分支，也尚未正式发布。或者，您可以在切换到发布分支时在稳定存储库中发布图表，但是在这个例子中，我们将采用假设每次合并到主分支都是一个新发布的前一种方法。
- en: '`stable` and `staging` are served as two separate chart repositories; this
    can be done by creating two separate directories at the top level of the GitHub
    Pages repository:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`stable`和`staging`作为两个单独的图表存储库提供；这可以通过在GitHub Pages存储库的顶层创建两个单独的目录来完成：'
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The stable and staging folders then contain their own `index.yaml` files to
    differentiate them as separate chart repositories.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，稳定和暂存文件夹包含它们自己的`index.yaml`文件，以区分它们作为单独的图表存储库。
- en: For convenience, the final snippet of the preceding pipeline excerpt creates
    the `stable` or `staging` folders automatically if the pipeline execution based
    on the branch relies on its existence.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，前述管道摘录的最后一部分会在管道执行依赖于其存在的分支时自动创建`stable`或`staging`文件夹。
- en: 'Now that the type of repository that the charts should be pushed to has been
    determined, we proceed to the next stage of the pipeline, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在确定了图表应该推送到的存储库类型，我们继续进行管道的下一个阶段，如下所示：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first command copies each of the packaged charts from the previous stage
    to the `stable` or `staging` folders. Next, the `stable` or `staging` `index.yaml`
    file is updated using the `helm repo index` command to reflect the changed or
    added charts.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条命令将从前一阶段复制每个打包的图表到`stable`或`staging`文件夹。接下来，使用`helm repo index`命令更新`stable`或`staging`的`index.yaml`文件，以反映已更改或添加的图表。
- en: One point to keep in mind is that if we use a different chart repository solution,
    such as **ChartMuseum** (a chart repository solution maintained by the Helm community),
    the `helm repo index` command is not needed since the `index.yaml` file is automatically
    updated when ChartMuseum receives a new packaged Helm chart. For implementations
    that do not automatically calculate the `index.yaml` file, such as GitHub Pages,
    the `helm repo index` command is necessary, as we can see in this pipeline.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一点是，如果我们使用不同的图表存储库解决方案，比如**ChartMuseum**（由Helm社区维护的图表存储库解决方案），则不需要使用`helm
    repo index`命令，因为当ChartMuseum接收到新的打包Helm图表时，`index.yaml`文件会自动更新。对于不会自动计算`index.yaml`文件的实现，比如GitHub
    Pages，`helm repo index`命令是必要的，正如我们在这个管道中所看到的。
- en: The final two commands from the preceding snippet set the `git` `username` and
    `email`, which are required to push contents to a `git` repository. For this example,
    we will set the username to `chartrepo-robot` to indicate that a CI/CD process
    facilitated the `git` interactions an[d we will set the email to](mailto:chartrepo-robot@example.com)
    as an example value. You probably want the email to represent the organization
    in charge of maintaining the chart repository.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面片段的最后两个命令设置了`git`的`username`和`email`，这些是推送内容到`git`存储库所必需的。在本例中，我们将用户名设置为`chartrepo-robot`，以表示CI/CD过程促进了`git`交互，我们将设置邮箱为`(mailto:chartrepo-robot@example.com)`作为示例值。您可能希望邮箱代表负责维护图表存储库的组织。
- en: 'The final step is to push the changes. This action is captured in the final
    pipeline snippet, shown here:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是推送更改。这个操作在最终的管道片段中被捕获，如下所示：
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The packaged charts are first added and committed using the `git add` and `git
    commit` commands. Next, a push to the repository is performed with the `git push`
    command, using a credential called `github-auth`. This credential was created
    during installation from the `githubUsername` and `githubPassword` values. The
    `github-auth` credential allows you to securely refer to these secrets without
    printing them in plaintext in your pipeline code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 打包的图表首先使用`git add`和`git commit`命令添加和提交。接下来，使用`git push`命令对存储库进行推送，使用名为`github-auth`的凭据。这个凭据是在安装过程中从`githubUsername`和`githubPassword`值创建的。`github-auth`凭据允许您安全地引用这些机密，而不会在管道代码中以明文形式打印出来。
- en: Note that the Helm community has published a tool called `Chart Releaser` ([https://github.com/helm/chart-releaser](https://github.com/helm/chart-releaser))
    that can be used as an alternative to generating the `index.yaml` file with the
    `helm repo index` command and uploading it to GitHub with `git push`. The `Chart
    Releaser` tool is designed to abstract some of this additional complexity by managing
    the Helm charts contained in GitHub Pages.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Helm社区发布了一个名为`Chart Releaser`的工具（[https://github.com/helm/chart-releaser](https://github.com/helm/chart-releaser)），可以作为使用`helm
    repo index`命令生成`index.yaml`文件并使用`git push`上传到GitHub的替代方案。`Chart Releaser`工具旨在通过管理包含在GitHub
    Pages中的Helm图表来抽象一些额外的复杂性。
- en: We have decided not to implement the pipeline using this tool in this chapter,
    however, because `Chart Releaser` does not support Helm 3 (at the time of writing).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定在本章中不使用这个工具来实现管道，因为在撰写本文时，“Chart Releaser”不支持Helm 3。
- en: Now that we have provided an overview of the CI pipeline, let's run through
    an example execution.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经概述了CI管道，让我们通过一个示例执行来运行一遍。
- en: Running the pipeline
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行管道
- en: 'As we discussed earlier, the first run of this pipeline was actually triggered
    automatically when we installed Jenkins. The job was run against the master branch
    and can be seen by clicking the **Test and Release Helm Charts** link on the Jenkins
    landing page. You will observe that one successful job ran against the master
    branch:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，当我们安装Jenkins时，这个流水线的第一次运行实际上是自动触发的。该作业针对主分支运行，并且可以通过单击Jenkins登陆页面上的**测试和发布Helm
    Charts**链接来查看。您会注意到有一个成功的作业针对主分支运行了：
- en: '![Figure 7.5 – The first runthrough of the pipeline'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 - 流水线的第一次运行'
- en: '](image/Figure_7.5.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.5.jpg)'
- en: Figure 7.5 – The first runthrough of the pipeline
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 - 流水线的第一次运行
- en: 'Every pipeline build in Jenkins has an associated log that contains the output
    of the execution. You can access the log for this build by selecting the **#1**
    link next to the blue circle on the left-hand side and then selecting **Console
    Output** on the next screen. The logs for this build reveal that the first stage,
    `Lint`, succeeded by displaying this message:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins中的每个流水线构建都有一个关联的日志，其中包含执行的输出。您可以通过在左侧选择蓝色圆圈旁边的**#1**链接，然后在下一个屏幕上选择**控制台输出**来访问此构建的日志。此构建的日志显示第一个阶段`Lint`成功，显示了这条消息：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is what we would expect because no charts were changed from the perspective
    of the master branch. A similar output can be seen under the install stage as
    well:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们所期望的，因为从主分支的角度来看，没有任何图表发生变化。在安装阶段也可以看到类似的输出：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Because both the Lint and Install stages completed without error, the pipeline
    continued to the Package Charts stage. Here, you can view the output::'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Lint和Install阶段都没有错误，所以流水线继续到了Package Charts阶段。在这里，您可以查看输出：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, the pipeline concludes by cloning your GitHub Pages repository, creating
    a `stable` folder within it, copying the packaged charts over to the `stable`
    folder, committing the changes to the GitHub Pages repository locally, and pushing
    the changes to GitHub. We can observe that each file that was added to our repository
    is outputted in the following lines:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，流水线通过克隆您的GitHub Pages存储库，在其中创建一个`stable`文件夹，将打包的图表复制到`stable`文件夹中，将更改提交到GitHub
    Pages存储库本地，并将更改推送到GitHub。我们可以观察到每个添加到我们存储库的文件都在以下行中输出：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You may be curious to know what your GitHub Pages repository looks like after
    the automatic push. Your repository should look as follows, with a new `stable`
    folder containing the Helm charts:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会好奇在自动推送后您的GitHub Pages存储库是什么样子。您的存储库应该如下所示，其中包含一个新的`stable`文件夹，其中包含Helm图表：
- en: '![Figure 7.6 – The state of the repository after the CI pipeline completes'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 - CI流水线完成后存储库的状态'
- en: '](image/Figure_7.6.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.6.jpg)'
- en: Figure 7.6 – The state of the repository after the CI pipeline completes
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 - CI流水线完成后存储库的状态
- en: 'In the `stable` folder, you should be able to see three different files, two
    separate charts, and one `index.yaml` file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`stable`文件夹中，您应该能够看到三个不同的文件，两个单独的图表和一个`index.yaml`文件：
- en: '![Figure 7.7 – The contents of the stable folder'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7 - `stable`文件夹的内容'
- en: '](image/Figure_7.7.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.7.jpg)'
- en: Figure 7.7 – The contents of the `stable` folder
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - `stable`文件夹的内容
- en: This first pipeline build successfully created the initial set of `stable` charts,
    but it did not demonstrate how new charts can be linted and tested before being
    deemed stable and ready for end users to consume. To demonstrate this, we need
    to cut a feature branch off the master branch to modify one or more charts, push
    the changes to the feature branch, and then start a new build in Jenkins.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个流水线构建成功地创建了一组初始的`stable`图表，但没有演示在被认为是稳定并且可以供最终用户使用之前，新图表如何进行linting和测试。为了演示这一点，我们需要从主分支切出一个功能分支来修改一个或多个图表，将更改推送到功能分支，然后在Jenkins中启动一个新的构建。
- en: 'To begin, create a new branch called `chapter7` off of the master branch:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从主分支创建一个名为 `chapter7` 的新分支：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: On this branch, we will simply modify the version of the `ngnix` chart to trigger
    the chart's linting and testing. NGINX is a web server and a reverse proxy. It
    is much more lightweight than the Guestbook application we have been working with
    in this book, so for that reason, we will use the `ngnix` chart from the Packt
    repository for this example to avoid any resource constraints that might occur
    with Jenkins also running in your Minikube environment.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个分支上，我们将简单地修改`ngnix`图表的版本以触发图表的linting和测试。NGINX是一个Web服务器和反向代理。它比我们在本书中一直使用的Guestbook应用程序要轻量得多，因此，为了避免Jenkins在您的Minikube环境中运行时可能出现的任何资源限制，我们将在本示例中使用Packt存储库中的`ngnix`图表。
- en: 'In the `helm-charts/charts/nginx/Chart.yaml` file, change the version of the
    chart from `1.0.0` to `1.0.1`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`helm-charts/charts/nginx/Chart.yaml`文件中，将图表的版本从`1.0.0`更改为`1.0.1`：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run `git status` to confirm that a change was detected:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `git status` 确认已检测到变化：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice that the `ngnix` `Chart.yaml` file has been modified. Add the file and
    then commit the changes. Finally, you can proceed with pushing the change to your
    fork:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`ngnix`的`Chart.yaml`文件已经被修改。添加文件，然后提交更改。最后，您可以继续将更改推送到您的分支：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Within Jenkins, we need to trigger a repository scan so that Jenkins can detect
    and start a new build against this branch. Navigate to the **Test and Release
    Helm Charts** page. You can easily do so by clicking on the **Test and Release
    Helm Charts** tab on the top bar:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins中，我们需要触发仓库扫描，以便Jenkins可以检测并针对此分支启动新的构建。转到**测试和发布Helm Charts**页面。您可以通过点击顶部标签栏上的**测试和发布Helm
    Charts**标签轻松实现：
- en: '![Figure 7.8 – The Test and Release Helm Charts page'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 – 测试和发布Helm Charts页面'
- en: '](image/Figure_7.8.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.8.jpg)'
- en: Figure 7.8 – The Test and Release Helm Charts page
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 测试和发布Helm Charts页面
- en: 'Once selected, click the **Scan Multibranch Pipeline Now** button in the left-hand
    side menu. This allows Jenkins to detect your new branch and to automatically
    start a new build. The scan should complete within approximately 10 seconds. Refresh
    the page and the new `chapter7` branch should appear on the page as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 选择后，点击左侧菜单中的**立即扫描多分支流水线**按钮。这允许Jenkins检测到您的新分支并自动启动新的构建。扫描应在大约10秒内完成。刷新页面，新的`chapter7`分支应如下出现在页面上：
- en: '![Figure 7.9 – The Test and Deploy Helm Charts page after scanning for the
    new chapter7 branch'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9 – 扫描新的chapter7分支后的测试和部署Helm Charts页面'
- en: '](image/Figure_7.9.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.9.jpg)'
- en: Figure 7.9 – The Test and Deploy Helm Charts page after scanning for the new
    `chapter7` branch
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 扫描新的`chapter7`分支后的测试和部署Helm Charts页面
- en: 'The `chapter7` job will run for a longer period of time than the master job
    since the `chapter7` job contains a modified Helm chart that is tested with the
    chart testing tool. You can observe this pipeline in action by navigating to the
    console output for `chapter7`. From the **Test and Release Helm Charts** overview
    page, select the [*Chapter 7*](B15458_07_Final_JM_ePub.xhtml#_idTextAnchor335)
    branch and then the **#1** link at the bottom left-hand side. Finally, select
    the **Console Output** link. If you navigate to this page while the pipeline is
    still running, you will receive the log updates as they occur in real time. Wait
    until the end of the pipeline, where the following message should be displayed:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`chapter7`作业包含经过修改的Helm图表，并使用图表测试工具进行测试，因此`chapter7`作业的运行时间将比主作业长。您可以通过导航到`chapter7`的控制台输出来观察此流水线的运行情况。从**测试和发布Helm图表**概述页面，选择[*第7章*](B15458_07_Final_JM_ePub.xhtml#_idTextAnchor335)分支，然后在左下角选择**#1**链接。最后，选择**控制台输出**链接。如果您在流水线仍在运行时导航到此页面，您将实时收到日志更新。等到流水线结束，在那里应该显示以下消息：
- en: '[PRE27]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Toward the beginning of the console output logs, notice how the `ct lint` and
    `ct install` commands were run against the `ngnix` chart as this was the only
    chart where a change occurred:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台输出日志的开始处，注意`ct lint`和`ct install`命令是针对`ngnix`图表运行的，因为这是唯一发生更改的图表：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The additional output for each command should already be familiar as it is the
    same as the output that was described in [*Chapter 6*](B15458_06_Final_JM_ePub.xhtml#_idTextAnchor292),
    *Testing Helm Charts*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令的附加输出应该已经很熟悉，因为它与[*第6章*](B15458_06_Final_JM_ePub.xhtml#_idTextAnchor292)中描述的输出相同，*测试Helm图表*。
- en: 'In your GitHub Pages repository, you should see the new version of the `ngnix`
    chart in the `staging` folder as it was not built against the master branch:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的GitHub Pages存储库中，您应该看到`staging`文件夹中的`ngnix`图表的新版本，因为它没有构建在主分支上：
- en: '![Figure 7.10 – The contents of the staging folder](image/Figure_7.10.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10 - “staging”文件夹的内容](image/Figure_7.10.jpg)'
- en: Figure 7.10 – The contents of the `staging` folder
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 - “staging”文件夹的内容
- en: 'To release the `nginx-1.0.1.tgz` chart, you need to merge the `chapter7` branch
    into the master branch, which will cause this chart to be pushed to the stable
    repository. On the command line, merge your `chapter7` branch into the master
    branch and push it to the `remote` repository:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布`nginx-1.0.1.tgz`图表，您需要将`chapter7`分支合并到主分支，这将导致该图表被推送到稳定存储库。在命令行上，将您的`chapter7`分支合并到主分支并将其推送到`remote`存储库：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Within Jenkins, navigate to the master pipeline job by returning to the **Test
    and Release Helm Charts** page and clicking on the **master** job. Your screen
    should appear as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins中，通过返回到**测试和发布Helm图表**页面并点击**master**作业来导航到主流水线作业。您的屏幕应该如下所示：
- en: '![Figure 7.11 – The master job for the Test and Release Helm charts project'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11 - 测试和发布Helm图表项目的主作业'
- en: '](image/Figure_7.11.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.11.jpg)'
- en: Figure 7.11 – The master job for the Test and Release Helm charts project
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 - 测试和发布Helm图表项目的主作业
- en: 'Once on this page, click on the **Build Now** link on the left-hand side. Once
    again, notice in the logs that chart tests were skipped because the chart testing
    tool compared the clone against the master branch. Since the content is the same,
    the tool determines that there is no testing to be done. When the build finishes,
    navigate to your GitHub Pages repository to confirm the new `nginx-1.0.1.tgz`
    chart is under the `stable` repository:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入此页面，点击左侧的**立即构建**链接。再次注意日志中的内容，图表测试被跳过，因为图表测试工具将克隆与主分支进行了比较。由于内容相同，工具确定没有需要测试的内容。构建完成后，导航到您的GitHub
    Pages存储库，确认新的`nginx-1.0.1.tgz`图表位于`stable`存储库下：
- en: '![Figure 7.12 – The state of the repository after the new nginx chart has been
    added'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.12 - 添加新的nginx图表后存储库的状态'
- en: '](image/Figure_7.12.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.12.jpg)'
- en: Figure 7.12 – The state of the repository after the new `nginx` chart has been
    added
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 - 添加新的`nginx`图表后存储库的状态
- en: 'You can verify that these charts are deployed properly to the GitHub Pages
    `stable` repository by adding the repository locally using `helm repo add`. In
    [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265), *Building Your
    First Helm Chart*, you added the root location of the GitHub Pages repository.
    However, we modified the file structure to contain the `stable` and `staging`
    folders. If it is still configured, you can remove this repository by running
    the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在本地添加`helm repo add`来验证这些图表是否已正确部署到GitHub Pages的`stable`存储库。在[*第5章*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265)中，*构建您的第一个Helm图表*，您添加了GitHub
    Pages存储库的根位置。但是，我们修改了文件结构以包含`stable`和`staging`文件夹。如果仍然配置，您可以通过运行以下命令来删除此存储库：
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The repository can be added again with the updated location of the `stable`
    repository:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`stable`存储库的更新位置再次添加存储库：
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that the value of `$GITHUB_PAGES_SITE_URL` references the static site that
    GitHub serves and not your actual `git` repository. Your GitHub Pages site URL
    should have a format similar to [https://$GITHUB_USERNAME.github.io/Learn-Helm-Repository/stable](https://$GITHUB_USERNAME.github.io/Learn-Helm-Repository/stable).
    The exact link can be found in the **Settings** tab of your GitHub Pages repository.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`$GITHUB_PAGES_SITE_URL`的值引用GitHub提供的静态站点，而不是您实际的`git`存储库。您的GitHub Pages站点URL应该类似于[https://$GITHUB_USERNAME.github.io/Learn-Helm-Repository/stable](https://$GITHUB_USERNAME.github.io/Learn-Helm-Repository/stable)。确切的链接可以在GitHub
    Pages存储库的**设置**选项卡中找到。
- en: 'After adding the `stable` repository, run the following command to view each
    of the charts that have been built and pushed over the course of the two master
    builds:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加`stable`存储库后，运行以下命令查看在两个主构建过程中构建和推送的每个图表：
- en: '[PRE32]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You should see three results, two of which contain both versions of the `nginx`
    chart that was built and pushed:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到三个结果，其中两个包含构建和推送的`nginx`图表的两个版本：
- en: '![Figure 7.13 – Results from the helm search repo command'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.13 - `helm search repo`命令的结果'
- en: '](image/Figure_7.13.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.13.jpg)'
- en: Figure 7.13 – Results from the `helm search repo` command
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 - `helm search repo`命令的结果
- en: In this section, we discussed how the life cycle of Helm charts can be managed
    through a CI pipeline. By following an automated workflow using the example provided,
    you can easily perform routine linting and testing before releasing charts to
    end users.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何通过CI管道管理Helm图表的生命周期。通过使用提供的示例遵循自动化工作流程，您可以在发布图表给最终用户之前轻松执行常规的linting和测试。
- en: While this section focused primarily on the CI of Helm charts, CD and GitOps
    can also be implemented to deploy Helm charts to different environments. We will
    explore how a CD pipeline can be built in the next section.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本节主要关注Helm图表的CI，但CD和GitOps也可以用于将Helm图表部署到不同的环境。我们将在下一节中探讨如何构建CD管道。
- en: Creating a CD pipeline to deploy applications with Helm
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个使用Helm部署应用程序的CD管道
- en: A CD pipeline is a set of repeatable steps that can deploy to one or more different
    environments in an automated fashion. In this section, we will create a CD pipeline
    to deploy the `nginx` chart that we tested and pushed to our GitHub Pages repository
    in the previous section. GitOps will also be leveraged by referencing the `values`
    files saved to a `git` repository.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: CD管道是一组可重复部署到一个或多个不同环境的步骤。在本节中，我们将创建一个CD管道，以部署我们在上一节中测试并推送到GitHub Pages存储库的`nginx`图表。还将通过引用保存到`git`存储库的`values`文件来利用GitOps。
- en: Let's design the high-level steps that need to be included in this pipeline.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设计需要包括在此管道中的高级步骤。
- en: Designing the pipeline
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计管道
- en: In previous chapters, deploying to a Kubernetes environment with Helm was a
    manual process. This CD pipeline, however, is designed to deploy to multiple different
    environments while abstracting the use of Helm.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的章节中，使用Helm部署到Kubernetes环境是一个手动过程。然而，这个CD管道旨在在抽象使用Helm的同时部署到多个不同的环境。
- en: 'The following steps describe the CD workflow that we will cover in this section:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤描述了我们将在本节中涵盖的CD工作流程。
- en: Add the stable GitHub Pages repository containing the `nginx` chart release.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加包含`nginx`图表发布的稳定GitHub Pages存储库。
- en: Deploy the `nginx` chart to the development environment.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`nginx`图表部署到开发环境。
- en: Deploy the `nginx` chart to the **Quality Assurance** (**QA**) environment.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`nginx`图表部署到**质量保证**（**QA**）环境。
- en: Wait for the user to approve the pipeline to proceed to the production deployment.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待用户批准管道以继续进行生产部署。
- en: Deploy the `nginx` chart to the production environment.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`nginx`图表部署到生产环境。
- en: The CD workflow is contained in a separate `Jenkinsfile` file to the file created
    previously for the CI pipeline. Before we create the `Jenkinsfile` file, let's
    update the Minikube and Jenkins environments so that we can perform the CD process.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: CD工作流包含在单独的`Jenkinsfile`文件中，与先前为CI管道创建的文件不同。在创建`Jenkinsfile`文件之前，让我们更新Minikube和Jenkins环境，以便执行CD流程。
- en: Updating the environments
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新环境
- en: The development, QA, and production environments will be modeled by different
    namespaces within your local Minikube cluster. While we would usually discourage
    you from allowing non-production (development and QA) and production environments
    to coexist within the same cluster, we will co-locate these three environments
    just to demonstrate our example CD process.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 开发、QA和生产环境将由本地Minikube集群中的不同命名空间建模。虽然我们通常不建议允许非生产（开发和QA）和生产环境共存于同一集群中，但为了演示我们的示例CD流程，我们将这三个环境放在一起。
- en: 'Create the `dev`, `qa`, and `prod` namespaces to represent each of these environments:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`dev`、`qa`和`prod`命名空间来表示每个环境：
- en: '[PRE33]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You should also delete the `chapter7` branch that you created in the previous
    section. This branch should be deleted because when the new CD pipeline is created,
    Jenkins will attempt to run it against each of your repository's branches. For
    simplicity and to avoid resource constraints, we recommend advancing with only
    the master branch.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该删除在上一节中创建的`chapter7`分支。应删除此分支，因为当创建新的CD管道时，Jenkins将尝试针对存储库的每个分支运行它。为简单起见，并避免资源限制，我们建议仅使用主分支进行推进。
- en: 'Remove the `chapter7` branch from your repository with the following commands:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令从存储库中删除`chapter7`分支：
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, you will need to upgrade your Jenkins instance to set an environment
    variable called `GITHUB_PAGES_SITE_URL`. This is the location of your chart repository
    in GitHub Pages that has a [https://$GITHUB_USERNAME.github.io/Learn-Helm-Chart-Repository/stable](https://$GITHUB_USERNAME.github.io/Learn-Helm-Chart-Repository/stable)
    format. The environment variable is referenced in the CD pipeline to add the `stable`
    GitHub Pages chart repository with `helm repo add`. To add this variable, you
    can reuse the values that were previously applied by using the `--reuse-values`
    flag, while also specifying an additional value called `githubPagesSiteUrl` by
    using `--set`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要升级您的Jenkins实例以设置一个名为`GITHUB_PAGES_SITE_URL`的环境变量。这是您在GitHub Pages中图表存储库的位置，格式为[https://$GITHUB_USERNAME.github.io/Learn-Helm-Chart-Repository/stable](https://$GITHUB_USERNAME.github.io/Learn-Helm-Chart-Repository/stable)。CD流水线中引用了该环境变量，以通过`helm
    repo add`添加`stable` GitHub Pages图表存储库。要添加此变量，您可以通过使用`--reuse-values`标志重新使用先前应用的值，同时使用`--set`指定一个名为`githubPagesSiteUrl`的附加值。
- en: 'Execute the following command to upgrade your Jenkins instance:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令来升级您的Jenkins实例：
- en: '[PRE35]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This upgrade will cause your Jenkins instance to restart. You can wait for
    the Jenkins Pod to be ready by running a watch against the `chapter7` namespace''s
    Pods:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此次升级将导致Jenkins实例重新启动。您可以通过针对`chapter7`命名空间的Pod运行watch来等待Jenkins Pod准备就绪：
- en: '[PRE36]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The Jenkins Pod is available when it indicates that `1/1` containers are ready.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当Jenkins Pod指示`1/1`个容器已准备就绪时，该Jenkins Pod可用。
- en: 'Once Jenkins is ready, access the Jenkins instance by using the same URL from
    the previous section. You should find another job, called `Deploy NGINX Chart`,
    which represents the CD pipeline:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Jenkins准备就绪，通过使用上一节中相同的URL访问Jenkins实例。您应该会找到另一个作业，名为`Deploy NGINX Chart`，它代表了CD流水线：
- en: '![Figure 7.14 – The Jenkins front page after upgrading the Jenkins release'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.14-升级Jenkins版本后的Jenkins首页'
- en: '](image/Figure_7.14.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.14.jpg)'
- en: Figure 7.14 – The Jenkins front page after upgrading the Jenkins release
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14-升级Jenkins版本后的Jenkins首页
- en: This job is configured in the `values.yaml` file to be created when GITHUB_PAGES_SITE_URL
    is set (to help improve the flow of this chapter).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置了GITHUB_PAGES_SITE_URL时，此作业将在`values.yaml`文件中配置为创建（以帮助改进本章流程）。
- en: Note that as with the CI pipeline, the CD pipeline also starts automatically
    since it is detected for the first time. Before we review this pipeline's logs,
    let's examine the process that makes up the CD pipeline.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与CI流水线一样，CD流水线也会自动启动，因为它是首次被检测到。在我们审查此流水线的日志之前，让我们先来看看构成CD流水线的过程。
- en: Understanding the pipeline
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解流水线
- en: In this section, we will just review the key areas of the pipeline, but the
    full CD pipeline has been written up and is located at [https://github.com/PacktPublishing/-Learn-Helm/blob/master/nginx-cd/Jenkinsfile](https://github.com/PacktPublishing/-Learn-Helm/blob/master/nginx-cd/Jenkinsfile).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将仅审查流水线的关键领域，但完整的CD流水线已经编写好，并位于[https://github.com/PacktPublishing/-Learn-Helm/blob/master/nginx-cd/Jenkinsfile](https://github.com/PacktPublishing/-Learn-Helm/blob/master/nginx-cd/Jenkinsfile)。
- en: 'As with the previous CI pipeline, to test and release Helm charts, the CD pipeline
    begins by dynamically creating a new Jenkins agent as a Kubernetes Pod running
    the chart testing image:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的CI流水线一样，为了测试和发布Helm图表，CD流水线首先通过动态创建一个新的Jenkins代理作为运行图表测试镜像的Kubernetes Pod来开始：
- en: '[PRE37]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Although we are not using the `ct` tool in this pipeline, the chart testing
    image contains the Helm CLI that is required to perform the `nginx` deployments,
    so the image suffices for this example CD pipeline. However, it would also be
    acceptable to create a smaller image that removes the tools that are not utilized.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这个流水线中没有使用`ct`工具，但是图表测试镜像包含了执行`nginx`部署所需的Helm CLI，因此该镜像足以用于这个示例CD流水线。然而，也可以创建一个更小的镜像，删除未使用的工具也是可以接受的。
- en: Once an agent is created, Jenkins implicitly clones your fork, as it did previously
    in the CI pipeline.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦代理被创建，Jenkins会隐式克隆您的分支，就像在CI流水线中一样。
- en: 'The first explicitly defined stage of the pipeline is called `Setup`, which
    adds your `stable` chart repository hosted in GitHub Pages to the local Helm client
    on the Jenkins agent:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线的第一个明确定义的阶段称为“设置”，它将托管在GitHub Pages上的您的`stable`图表存储库添加到Jenkins代理上的本地Helm客户端中。
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once the repository is added, the pipeline can begin deploying NGINX to the
    different environments. The next stage, called `Deploy to Dev`, deploys the NGINX
    chart to your `dev` namespace:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦存储库被添加，流水线就可以开始将NGINX部署到不同的环境中。下一个阶段称为“部署到开发环境”，将NGINX图表部署到您的“dev”命名空间：
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first detail you might notice about this stage is the `dir('nginx-cd')`
    closure. This is the `Jenkinsfile` syntax to set the working directory of the
    commands contained within it. We will explain the `nginx-cd` folder in greater
    detail soon.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到这个阶段的第一个细节是`dir('nginx-cd')`闭包。这是`Jenkinsfile`语法，用于设置其中包含的命令的工作目录。我们将很快更详细地解释`nginx-cd`文件夹。
- en: You can also see that this stage runs the `helm upgrade` command with the provided
    `--install` flag. `helm upgrade` is normally performed against an already-existing
    release and fails if attempted against a release that doesn't exist. The `--install`
    flag, however, installs the chart if a release does not already exist. If a release
    does already exist, the `helm upgrade` command upgrades the release. The `--install`
    flag is convenient for use for automated processes, such as the CD pipeline described
    in this section, because it prevents you from needing to perform a check to determine
    the existence of a release.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到，这个阶段使用提供的`--install`标志运行`helm upgrade`命令。`helm upgrade`通常针对已经存在的发布执行，并且如果尝试针对不存在的发布执行则会失败。然而，`--install`标志会在发布不存在时安装图表。如果发布已经存在，`helm
    upgrade`命令会升级发布。`--install`标志对于自动化流程非常方便，比如本节中描述的CD流水线，因为它可以避免您需要执行检查来确定发布的存在。
- en: 'Another interesting detail about this `helm upgrade` command is that it uses
    the `--values` flag twice—once against a file called `common-values.yaml` and
    once against a file called `dev/values.yaml`. Both of these files are located
    in the `nginx-cd` folder. The following contents are found in the `nginx-cd` folder:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个`helm upgrade`命令的另一个有趣细节是它两次使用了`--values`标志——一次针对名为`common-values.yaml`的文件，一次针对名为`dev/values.yaml`的文件。这两个文件都位于`nginx-cd`文件夹中。以下内容位于`nginx-cd`文件夹中：
- en: '[PRE40]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When deploying an application to different environments, you may need to slightly
    modify the application''s configuration to allow it to integrate with other services
    in the environment. Each of the `values` files under the `dev`, `qa`, and `prod`
    folders contain an environment variable that is set on the NGINX deployment, depending
    on the environment that it is deployed to. For example, the `dev/values.yaml`
    file contents are shown here:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在将应用程序部署到不同的环境时，您可能需要稍微修改应用程序的配置，以使其能够与环境中的其他服务集成。`dev`、`qa`和`prod`文件夹下的每个`values`文件都包含一个环境变量，该变量根据部署的环境设置在NGINX部署上。例如，这里显示了`dev/values.yaml`文件的内容：
- en: '[PRE41]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Similarly, the `qa/values.yaml` file contents are shown here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这里显示了“qa/values.yaml”文件的内容：
- en: '[PRE42]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `prod/values.yaml` file contents are as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`prod/values.yaml`文件的内容如下：'
- en: '[PRE43]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: While the NGINX chart that is deployed in this example is straightforward and
    does not strictly require these values to be specified, you will find it helpful
    to separate environment-specific configurations in separate `values` files using
    the method shown here for complex and real-world use cases. The corresponding
    values file can then be applied to the installation by passing it to the `helm
    upgrade --install` command with `--values ${env}/values.yaml`, where `${env}`
    represents either `dev`, `qa`, or `prod`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个示例中部署的NGINX图表是直接的，并且不严格要求指定这些值，但您会发现将环境特定的配置分开放在单独的`values`文件中，使用这里展示的方法对于复杂的真实用例非常有帮助。然后可以通过将相应的values文件传递给`helm
    upgrade --install`命令来应用安装，其中`${env}`表示`dev`、`qa`或`prod`。
- en: 'The `common-values.yaml` file, as its name implies, is used for values that
    are common across all the deployment environments. The `common-values.yaml` file
    for this example is written as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`common-values.yaml`文件用于所有部署环境中通用的值。这个示例的`common-values.yaml`文件写成如下形式：
- en: '[PRE44]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This file indicates that each NGINX service created during the installation
    of the chart should have a `NodePort` type. All the other default values set in
    the NGINX chart's `values.yaml` file are also applied to each environment since
    they have not been overridden in the `common-values.yaml` file or the individual
    `values.yaml` environment files.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件表示在安装图表期间创建的每个NGINX服务都应该具有`NodePort`类型。由于它们没有在`common-values.yaml`文件或单独的`values.yaml`环境文件中被覆盖，NGINX图表的`values.yaml`文件中设置的所有其他默认值也被应用到每个环境中。
- en: 'One important point to note is that your application should be deployed as
    identically as possible across each of your deployment environments. Any value
    that changes the physical properties of your running Pods or containers should
    be specified in the `common-values.yaml` file. These configurations include, but
    are not limited to, the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的一点是，您的应用程序应该在每个部署环境中尽可能相同地部署。任何改变运行中的Pod或容器的物理属性的值都应该在`common-values.yaml`文件中指定。这些配置包括但不限于以下内容：
- en: The replica count
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 副本计数
- en: The resource requests and limits
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源请求和限制
- en: The service type
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务类型
- en: The image name
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像名称
- en: The image tag
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像标签
- en: '`ImagePullPolicy`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImagePullPolicy`'
- en: The volume mounts
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷挂载
- en: 'Values that change the configuration to integrate with environment-specific
    services can be modified in the individual environment `values` files. These configurations
    may include the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 修改与特定环境服务集成的配置可以在单独的环境`values`文件中进行修改。这些配置可能包括以下内容：
- en: The location of metrics or monitoring services
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指标或监控服务的位置
- en: The location of a database or backend service
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库或后端服务的位置
- en: The application/ingress URL
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用/入口URL
- en: The notification services
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知服务
- en: Circling back to the Helm command used in the `Deploy to Dev` stage of the CD
    pipeline, a combination of the `--values common-values.yaml` and `--values dev/values.yaml`
    flags merges both of these `values` files to install the `nginx` chart in `dev`.
    This command also uses the `-n dev` flag to indicate that the deployment should
    be performed in the `dev` namespace. In addition, the `--wait` flag is used to
    pause the `nginx` Pod until it is reported as `ready`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 回到CD流水线的`Deploy to Dev`阶段中使用的Helm命令，`--values common-values.yaml`和`--values
    dev/values.yaml`标志的组合将这两个`values`文件合并到`dev`中安装`nginx`图表。该命令还使用`-n dev`标志表示部署应该在`dev`命名空间中执行。此外，`--wait`标志用于暂停`nginx`
    Pod，直到它被报告为`ready`。
- en: 'Continuing with the pipeline, the next stage after deploying to `dev` is a
    smoke test. This stage runs the following command:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行流水线，部署到`dev`后的下一个阶段是烟雾测试。该阶段运行以下命令：
- en: '[PRE45]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The NGINX chart contains a test hook that checks the connection of the NGINX
    Pod. If the `test` hook is able to verify that a connection to the Pod can be
    made, the test is returned as successful. While the `helm test` command is often
    reserved for chart testing, it can also be used as a good way of performing a
    basic smoke test during the CD process. A smoke test is a test performed to ensure
    that the critical functions of an application work as designed after a deployment.
    Since the NGINX chart test does not interfere in any way with the running application
    or the rest of the deployment environment, the `helm test` command is an appropriate
    method of making sure that the NGINX chart is deployed successfully.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX图表包含一个测试钩子，用于检查NGINX Pod的连接。如果`test`钩子能够验证可以与Pod建立连接，则测试将返回为成功。虽然`helm
    test`命令通常用于图表测试，但它也可以作为在CD过程中执行基本烟雾测试的良好方法。烟雾测试是部署后进行的测试，以确保应用的关键功能按设计工作。由于NGINX图表测试不会以任何方式干扰正在运行的应用程序或部署环境的其余部分，因此`helm
    test`命令是确保NGINX图表成功部署的适当方法。
- en: 'After the smoke test, the example CD pipeline runs the next stage, called `Deploy
    to QA`. This stage contains a conditional that assesses whether the current branch
    the pipeline is executing against is the master branch, as shown:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 烟雾测试后，示例CD流水线运行下一个阶段，称为`部署到QA`。该阶段包含一个条件，评估流水线正在执行的当前分支是否是主分支，如下所示：
- en: '[PRE46]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This conditional allows you to use feature branches to test the deployment code
    contained in the `values.yaml` files without promoting it to higher environments.
    It implies that only Helm values contained in the master branch should be production-ready,
    although this is not the only strategy you can take when you release an application
    in a CD pipeline. Another common strategy is to allow higher-level promotions
    to take place on release branches that begin with the `release/` prefix.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 该条件允许您使用功能分支来测试`values.yaml`文件中包含的部署代码，而无需将其提升到更高的环境。这意味着只有主分支中包含的Helm值应该是生产就绪的，尽管这不是您在CD流水线中发布应用时可以采取的唯一策略。另一种常见的策略是允许在以`release/`前缀开头的发布分支上进行更高级别的推广。
- en: 'The Helm command used in the `Deploy to QA` stage is displayed as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`部署到QA`阶段中使用的Helm命令显示如下：'
- en: '[PRE47]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Given your knowledge of the `Deploy to Dev` stage and the separation of common
    and environment-specific values, the code for `Deploy to QA` is predictable. It
    references the `qa/values.yaml` file for QA-specific values and passes the `-n
    qa` flag to deploy to the `qa` namespace.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于您对`部署到Dev`阶段和常见值与特定环境值的分离的了解，`部署到QA`的代码是可以预测的。它引用了`qa/values.yaml`文件中的QA特定值，并传递了`-n
    qa`标志以部署到`qa`命名空间。
- en: After deploying to `qa`, or a similar testing environment, you can run the smoke
    test described earlier again to ensure that the basic functions of the `qa` deployment
    work properly. You can also include any other automated tests, at this stage,
    that would be necessary to verify the function of your application before their
    deployment to `prod`. These details have been omitted from this example pipeline.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署到`qa`或类似的测试环境之后，您可以再次运行前面描述的烟雾测试，以确保`qa`部署的基本功能正常工作。您还可以在这个阶段包括任何其他自动化测试，以验证在部署到`prod`之前应用的功能是否正常。这些细节已从此示例流水线中省略。
- en: 'The next stage of the pipeline is called `Wait for Input`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线的下一个阶段称为`等待输入`：
- en: '[PRE48]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This input step pauses the Jenkins pipeline and prompts the user with a `Deploy
    to Prod?` question. The user is given two choices—`Proceed` and `Abort`—in the
    console log of the running job. While the production deployment can be executed
    automatically without this manual step, many developers and companies prefer to
    have a human gate between the `non-prod` and `prod` deployments. This `input`
    command provides an opportunity for the user to make a decision about whether
    to continue the deployment or to abort the pipeline after the `qa` stage.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输入步骤暂停了Jenkins流水线，并用“部署到生产环境？”的问题提示用户。在运行作业的控制台日志中，用户有两个选择 - “继续”和“中止”。虽然可以自动执行生产部署而无需此手动步骤，但许多开发人员和公司更喜欢在“非生产”和“生产”部署之间设置一个人为的门。这个“输入”命令为用户提供了一个机会，让用户决定是否继续部署或在“qa”阶段之后中止流水线。
- en: 'If the user decides to proceed, the final stage is executed, called `Deploy
    to Prod`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户决定继续，将执行最终阶段，称为“部署到生产环境”：
- en: '[PRE49]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This stage is almost identical to the `Deploy to Dev` and `Deploy to QA` stages,
    with the exception of the production-specific `values` file and the `prod` namespace
    defined as part of the `helm upgrade --install` command.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段几乎与“部署到Dev”和“部署到QA”阶段相同，唯一的区别是生产特定的“values”文件和作为“helm upgrade --install”命令的一部分定义的“prod”命名空间。
- en: Now that the example CD pipeline has been outlined, let's observe the pipeline
    run that started when you upgraded your Jenkins instance.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在示例CD流水线已经概述，让我们观察流水线运行，该流水线是在您升级Jenkins实例时启动的。
- en: Running the pipeline
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行流水线
- en: 'To see this CD pipeline in action, navigate to the master branch of the `Deploy
    NGINX Chart` job. On the Jenkins front page, click on **Deploy NGINX Chart** and
    **master**. Your screen should appear as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此CD流水线的运行情况，请导航到“部署NGINX图”作业的主分支。在Jenkins首页，点击**部署NGINX图**和**主分支**。您的屏幕应该如下所示：
- en: '![Figure 7.15 – The master branch of the Deploy NGINX Chart CD pipeline'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.15 - 部署NGINX图CD流水线的主分支'
- en: '](image/Figure_7.15.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.15.jpg)'
- en: Figure 7.15 – The master branch of the Deploy NGINX Chart CD pipeline
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 - 部署NGINX图CD流水线的主分支
- en: 'Once you have navigated to this page, click on the **#1** link and navigate
    to the console logs:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您导航到此页面，请点击**＃1**链接并导航到控制台日志：
- en: '![Figure 7.16 – The Console Output page for the Deploy NGINX Chart CD pipeline'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.16 - 部署NGINX图CD流水线的控制台输出页面'
- en: '](image/Figure_7.16.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.16.jpg)'
- en: Figure 7.16 – The Console Output page for the Deploy NGINX Chart CD pipeline
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 - 部署NGINX图CD流水线的控制台输出页面
- en: When you navigate to the logs, you should see a prompt that says `Deploy to
    Prod?.` We will address this soon. First, let's look back at the beginning of
    the log to review the pipeline's execution up to this point.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当您导航到日志时，您应该会看到一个提示，上面写着“部署到生产环境？”。我们很快会解决这个问题。首先，让我们回顾一下日志的开头，以便查看到目前为止流水线的执行情况。
- en: 'The first deployment you can see is the `dev` deployment:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到的第一个部署是“dev”部署：
- en: '[PRE50]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, you should see the smoke test, which was run by the `helm test` command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您应该会看到由“helm test”命令运行的冒烟测试：
- en: '[PRE51]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After the smoke test came the `qa` deployment:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 冒烟测试之后是“qa”部署：
- en: '[PRE52]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This brings us to the input stage, which we saw when we first opened the logs:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们到输入阶段，我们在首次打开日志时看到的：
- en: '![Figure 7.17 – The input step before deploying to prod'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.17 - 部署到生产环境之前的输入步骤'
- en: '](image/Figure_7.17.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_7.17.jpg)'
- en: Figure 7.17 – The input step before deploying to prod
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17 - 部署到生产环境之前的输入步骤
- en: 'Click the **Proceed** link to continue the pipeline execution, as clicking
    **Abort** will fail the pipeline and prevent the production deployment from occurring.
    You will then see the `prod` deployment occur:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**继续**链接以继续流水线执行，点击**中止**将导致流水线失败，并阻止生产部署的发生。然后您将看到“prod”部署发生：
- en: '[PRE53]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, if the production deployment is successful, you will see the following
    message at the end of the pipeline:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果生产部署成功，您将在流水线结束时看到以下消息：
- en: '[PRE54]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can manually verify that the deployments were successful from your command
    line. Run the `helm list` command to find the `nginx-master` releases:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以手动验证部署是否成功。运行 `helm list` 命令查找 `nginx-master` 发布版本：
- en: '[PRE55]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Each command should list the `nginx` release in each namespace:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命令都应该列出每个命名空间中的 `nginx` 发布版本：
- en: '[PRE56]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You can also use `kubectl` to list the Pods in each namespace and verify that
    NGINX was deployed:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `kubectl` 列出每个命名空间中的Pod，并验证NGINX是否已部署：
- en: '[PRE57]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The result for each namespace will be similar to the following (`dev` will
    also have a completed test Pod that was performed in the smoke test stage):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命名空间的结果将类似于以下内容（`dev` 还将有一个在冒烟测试阶段执行的已完成测试Pod）：
- en: '[PRE58]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this section, we discussed how Helm can be used in a CD pipeline to deploy
    an application across multiple environments in Kubernetes. The pipeline relied
    on the GitOps practice of storing configuration (the `values.yaml` files) in source
    control and referenced these files to properly configure NGINX. With an understanding
    of how Helm can be used in a CD environment, you can now clean up your Minikube
    cluster.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何在Kubernetes中的CD流水线中使用Helm来部署应用程序到多个环境中。该流水线依赖于GitOps实践，将配置（`values.yaml`文件）存储在源代码控制中，并引用这些文件来正确配置NGINX。了解了Helm如何在CD环境中使用后，您现在可以清理您的Minikube集群。
- en: Cleaning up
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理
- en: 'To clean up your Minikube cluster of this chapter''s exercises, delete the
    `chapter7`, `dev`, `qa`, and `prod` namespaces:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要清理本章练习中的Minikube集群，请删除 `chapter7`、`dev`、`qa` 和 `prod` 命名空间：
- en: '[PRE59]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You can also shut down your Minikube VM:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以关闭您的Minikube虚拟机：
- en: '[PRE60]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Invoking the Helm CLI in CI and CD pipelines is an efficient way of further
    abstracting the capabilities that Helm provides. Chart developers can automate
    the end-to-end chart development process by writing a CI pipeline that lints,
    tests, packages, and releases charts to a chart repository. End users can write
    a CD pipeline that uses Helm to deploy a chart across multiple different environments,
    leveraging GitOps to ensure applications can be deployed and configured as code.
    Writing pipelines helps developers and companies scale applications faster and
    more easily by abstracting and automating processes that could otherwise become
    tedious and introduce human error.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI和CD流水线中调用Helm CLI是进一步抽象Helm提供的功能的有效方式。图表开发人员可以通过编写CI流水线来自动化端到端的图表开发过程，包括代码检查、测试、打包和发布到图表存储库。最终用户可以编写CD流水线，使用Helm在多个不同的环境中部署图表，利用GitOps来确保应用程序可以作为代码部署和配置。编写流水线有助于开发人员和公司通过抽象和自动化过程更快、更轻松地扩展应用程序，避免了可能变得繁琐并引入人为错误的过程。
- en: In the next chapter, we will introduce another option for abstracting the Helm
    CLI—writing a Helm operator.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍另一种抽象Helm CLI 的选项——编写Helm operator。
- en: Further reading
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about the chart testing container image, go to [https://helm.sh/blog/chart-testing-intro/](https://helm.sh/blog/chart-testing-intro/).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关图表测试容器映像的更多信息，请访问[https://helm.sh/blog/chart-testing-intro/](https://helm.sh/blog/chart-testing-intro/)。
- en: To learn more about Jenkins and Jenkins pipelines, check out the Jenkins project
    documentation ([https://jenkins.io/doc/](https://jenkins.io/doc/)), the Jenkins
    pipeline documentation ([https://jenkins.io/doc/book/pipeline/](https://jenkins.io/doc/book/pipeline/))
    and the Multibranch Pipeline plugin documentation ([https://plugins.jenkins.io/workflow-multibranch/](https://plugins.jenkins.io/workflow-multibranch/)).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Jenkins和Jenkins流水线的信息，请查阅Jenkins项目文档（[https://jenkins.io/doc/](https://jenkins.io/doc/)）、Jenkins流水线文档（[https://jenkins.io/doc/book/pipeline/](https://jenkins.io/doc/book/pipeline/)）和多分支流水线插件文档（[https://plugins.jenkins.io/workflow-multibranch/](https://plugins.jenkins.io/workflow-multibranch/)）。
- en: Questions
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between CI and CD?
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI和CD之间有什么区别？
- en: What is the difference between CI/CD and GitOps?
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI/CD和GitOps之间有什么区别？
- en: What high-level steps are included in a CI/CD pipeline for creating and releasing
    Helm charts?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI/CD流水线创建和发布Helm图表包括哪些高级步骤？
- en: What advantages does CI bring to chart developers?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI给图表开发者带来了哪些优势？
- en: What high-level steps are included in a CD pipeline for deploying Helm charts?
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CD流水线部署Helm图表包括哪些高级步骤？
- en: What advantages does a CD pipeline bring to a chart's end users?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CD流水线给图表的最终用户带来了哪些优势？
- en: How can you maintain an application's configuration as code for multiple environments?
    What can you do to reduce boilerplate across the `values` files?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将应用程序的配置作为代码在多个环境中进行维护？如何减少`values`文件中的样板代码？
