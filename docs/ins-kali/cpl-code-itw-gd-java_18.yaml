- en: '*Chapter 15*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第15章*：'
- en: Mathematics and Puzzles
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数学和谜题
- en: 'This chapter covers a controversial topic that''s faced in interviews: mathematics
    and puzzle problems. A significant number of companies consider that these kinds
    of problems should not be part of a technical interview, while other companies
    still consider this topic relevant.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了一个在面试中经常遇到的有争议的话题：数学和谜题问题。许多公司认为这类问题不应该成为技术面试的一部分，而其他公司仍然认为这个话题是相关的。
- en: The problems included in this topic are brain-teasing and may require a decent
    level of knowledge in mathematics and logic. You should expect such problems if
    you plan to apply to a company that works in academic fields (mathematics, physics,
    chemistry, and so on). However, big companies such as Amazon and Google are also
    willing to rely on such problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题包括的问题是令人费解的，可能需要相当高的数学和逻辑知识。如果你计划申请在学术领域工作的公司（数学、物理、化学等），你应该期待这样的问题。然而，亚马逊和谷歌等大公司也愿意依赖这类问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Tips and suggestions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示和建议
- en: Coding challenges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码挑战
- en: By the end of this chapter, you should be familiar with these kinds of problems
    and be able to explore more such problems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该熟悉这类问题，并能够探索更多类似的问题。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code files present in this chapter are available on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter15](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter15).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中包含的所有代码文件都可以在GitHub上找到：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter15](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter15)。
- en: Tips and suggestions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和建议
- en: When you get a brain-teaser problem, the most important aspect is to not panic.
    Read the problem several times and write down your conclusions in a systematic
    approach. It is mandatory to clearly identify what input, output, and constraints
    it should obey.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到一个脑筋急转弯的问题时，最重要的是不要惊慌。多次阅读问题，并以系统化的方式写下你的结论是必不可少的。必须清楚地确定它应该遵守的输入、输出和约束条件。
- en: Try to take several examples (input data samples), make some sketches, and keep
    talking with the interviewer while analyzing the problem. The interviewer doesn't
    expect you to have the solution immediately, but they are expecting to hear you
    talking while trying to solve the problem. This way, the interviewer can track
    the logic of your ideas and understand how you approach the problem.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试举几个例子（输入数据样本），画一些草图，并在分析问题时与面试官保持交流。面试官并不希望你立即得出解决方案，但他们期望听到你在尝试解决问题时的思考过程。这样，面试官可以追踪你的想法逻辑，并了解你解决问题的方式。
- en: Also, it is very important to write down any rules or patterns that you noticed
    while developing the solution. With every statement you write down, you are closer
    to the solution. Commonly, if you look from the solution perspective (you know
    the solution), such problems are not extremely hard; they just require a high
    level of observation and increased attention.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，非常重要的是写下你在解决问题时注意到的任何规则或模式。每写下一个陈述，你离解决方案更近一步。通常，如果你从解决方案的角度来看（你知道解决方案），这些问题并不是非常困难；它们只是需要高度的观察和更高的注意力。
- en: Let's try a simple example. Two fathers and two sons sit down and eat eggs.
    They eat exactly three eggs; each person has an egg. How is this possible?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来试一个简单的例子。两个父亲和两个儿子坐下来吃鸡蛋。他们一共吃了三个鸡蛋；每个人都有一个鸡蛋。这怎么可能？
- en: If this is the first time you've seen such a problem, you may think that it
    is illogical or impossible to solve. It is normal to think that there is some
    mistake in the text (there was probably four eggs, not three) and read it again
    and again. These are the most common reactions to brain-teaser problems. Once
    you see the solution, it looks quite simple.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次遇到这样的问题，你可能会认为这是不合逻辑或不可能解决的。认为文本中有错误（可能是四个鸡蛋，而不是三个）并一遍又一遍地阅读是正常的。这些是对脑筋急转弯问题最常见的反应。一旦你看到解决方案，它看起来就很简单了。
- en: Now, let's act as a candidate in the presence of the interviewer. The following
    paragraphs follow a *thinking aloud approach*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设自己是面试官面前的候选人。以下段落采用了*大声思考*的方法。
- en: It may seem obvious that if each person has an egg and there are three eggs,
    then one of them doesn't have any egg. So, you may think that the answer is that
    three people eat an egg (each of them eats an egg) and that the fourth person
    doesn't eat anything. But the problem says that two fathers and two sons sit down
    and eat eggs, so all four of them eat eggs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个人都有一个鸡蛋，而有三个鸡蛋，那么显然有一个人没有鸡蛋。所以，你可能会认为答案是三个人吃了一个鸡蛋（每个人都吃了一个鸡蛋），而第四个人什么都没吃。但问题说两个父亲和两个儿子坐下来吃鸡蛋，所以他们四个人都吃了鸡蛋。
- en: 'How about thinking like this: each person has an egg and they (four people)
    eat exactly three eggs, so it doesn''t say that each person *eats* an egg; they
    only *have* an egg. Maybe one of them shares their egg with another person. Hmmm,
    this doesn''t seem too logical!'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 试想一下：每个人都有一个鸡蛋，他们（四个人）一共吃了三个鸡蛋，所以问题并没有说每个人*吃*了一个鸡蛋；他们只是*有*一个鸡蛋。也许其中一个人把自己的鸡蛋分享给了另一个人。嗯，这似乎不太合乎逻辑！
- en: Is it possible to have only three people? If one of the fathers is also a grandfather,
    this means that the other father is a son and a father at the same time. This
    way, we have two fathers and two sons via three people. They eat three eggs and
    each of them has an egg. Problem solved!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可能只有三个人吗？如果其中一个父亲也是一个祖父，这意味着另一个父亲同时也是一个儿子和父亲。这样，通过三个人，我们有两个父亲和两个儿子。他们吃了三个鸡蛋，每个人都有一个鸡蛋。问题解决了！
- en: As you can see, the solution is the result of a cascade of reasoning that eliminates
    the wrong solutions one by one. Trying to solve the problem by eliminating the
    wrong solutions via logical deduction is one of the approaches to solving these
    kinds of problems. Other problems are just about computing. Most of the time,
    there are no complicated computations or a lot of computations, but they require
    mathematical knowledge and/or deductions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，解决方案是通过一系列推理的结果，逐个排除错误的解决方案而得到的。试图通过逻辑推理排除错误的解决方案来解决问题是解决这类问题的方法之一。其他问题只是关于计算。大多数时候，没有复杂的计算或大量的计算，但它们需要数学知识和/或推理。
- en: It is quite hard to claim that there are some tricks and tips that will help
    you solve math and logical puzzle problems in seconds. The best approach is to
    practice as much as possible. With that, let's proceed with the *Coding challenges*
    section.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 很难断言有一些技巧和提示可以帮助你在几秒钟内解决数学和逻辑谜题问题。最好的方法是尽可能多地练习。有了这个，让我们继续进行*编码挑战*部分。
- en: Coding challenges
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码挑战
- en: In the following 15 coding challenges, we will focus on the most popular problems
    from the math and logical puzzles category. Let's get started!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的15个编码挑战中，我们将专注于数学和逻辑谜题类别中最受欢迎的问题。让我们开始吧！
- en: Coding challenge 1 – FizzBuzz
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战1 - FizzBuzz
- en: '**Adobe**, **Microsoft**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**Microsoft**'
- en: '**Problem**: Consider you''ve been given a positive integer, *n*. Write a problem
    that prints the numbers from 1 to *n*. For multiples of five, print *fizz*, for
    multiples of seven, print *buzz*, and for multiples of five and seven, print *fizzbuzz*.
    Print a new line after each string or number.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到了一个正整数*n*。编写一个问题，打印从1到*n*的数字。对于5的倍数，打印*fizz*，对于7的倍数，打印*buzz*，对于5和7的倍数，打印*fizzbuzz*。在每个字符串或数字后打印一个新行。'
- en: '**Solution**: This is a simple problem that relies on your knowledge of division
    and the Java modulus (%) operator. When we divide two numbers, the *dividend*
    and the *divisor*, we get a *quotient* and the *remainder*. In Java, we can obtain
    the remainder of a division via the modulus (%) operator. In other words, if *X*
    is the dividend and *Y* is the divisor, then *X* modulus *Y* (written in Java
    as *X* % *Y*) returns the remainder of dividing *X* by *Y*. For example, 11(dividend)
    / 2(divisor) = 5(quotient) 1(remainder), so 11 % 2 = 1.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：这是一个简单的问题，依赖于你对除法和Java取模(%)运算符的了解。当我们除两个数，被除数和除数，我们得到一个商和一个余数。在Java中，我们可以通过取模(%)运算符获得除法的余数。换句话说，如果*X*是被除数，*Y*是除数，那么*X*模*Y*（在Java中写作*X*
    % *Y*）返回*X*除以*Y*的余数。例如，11(被除数) / 2(除数) = 5(商) 1(余数)，所以11 % 2 = 1。'
- en: 'Put another way, if the remainder is 0, then the dividend is a multiple of
    the divisor; otherwise, it''s not. So, a multiple of five must respect that *X*
    % 5 = 0, while a multiple of seven must respect that *X* % 7 = 0\. Based on these
    relations, we can write the solution to this problem as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果余数为0，则被除数是除数的倍数；否则，它不是。因此，五的倍数必须满足*X* % 5 = 0，而七的倍数必须满足*X* % 7 = 0。基于这些关系，我们可以将这个问题的解决方案写成如下形式：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The complete application is called *FizzBuzz*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*FizzBuzz*。
- en: Coding challenge 2 – Roman numerals
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战2 - 罗马数字
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon**，**Google**，**Adobe**，**Microsoft**，**Flipkart**'
- en: '**Problem**: Consider you''ve been given a positive integer, *n*. Write a snippet
    of code that converts this number into its Roman number representation. For example,
    if *n*=34, then the Roman number is XXXIV. You''ve been given the following constants,
    which contain the Roman number symbols:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到了一个正整数*n*。编写一小段代码，将这个数字转换成它的罗马数字表示。例如，如果*n*=34，那么罗马数字就是XXXIV。你已经得到了以下包含罗马数字符号的常量：'
- en: '![Figure 15.1 – Roman numbers'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.1 - 罗马数字'
- en: '](img/Figure_15.1_B15403.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.1_B15403.jpg)'
- en: Figure 15.1 – Roman numbers
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 - 罗马数字
- en: '**Solution**: This problem relies on the fact that Roman numbers are common
    knowledge. If you''ve never heard about Roman numbers, then it is advisable to
    mention this to the interviewer. They will probably agree to give you another
    coding challenge in place of this one. But if you do know what the Roman numbers
    are, then great – let''s see how we can write an application that solves this
    problem.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：这个问题依赖于罗马数字是常识。如果你从来没有听说过罗马数字，那么最好向面试官提到这一点。他们可能会同意给你另一个编码挑战来代替这个。但如果你知道罗马数字是什么，那太好了
    - 让我们看看如何编写一个解决这个问题的应用程序。'
- en: 'The algorithm for this problem can be deduced from several examples. Let''s
    look at several use cases:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的算法可以从几个例子中推导出来。让我们看几个用例：
- en: '*n* = 73 = 50+10+10+1+1+1 = L+X+X+I+I+I = LXXIII'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* = 73 = 50+10+10+1+1+1 = L+X+X+I+I+I = LXXIII'
- en: '*n* = 558 = 500+50+5+1+1+1 = D+L+V+I+I+I = DLVIII'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* = 558 = 500+50+5+1+1+1 = D+L+V+I+I+I = DLVIII'
- en: '*n* = 145 = 100+(50-10)+5 = C+(L-X)+V = C+XL+V = CXLV'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* = 145 = 100+(50-10)+5 = C+(L-X)+V = C+XL+V = CXLV'
- en: '*n* = 34 = 10+10+10+(5-1) = X+X+X+(V-I) = X+X+X+IV = XXXIV'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* = 34 = 10+10+10+(5-1) = X+X+X+(V-I) = X+X+X+IV = XXXIV'
- en: '*n* = 49 = (50-10)+(10-1) = (L-X)+(X-I) = XL+IX = XLIX'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* = 49 = (50-10)+(10-1) = (L-X)+(X-I) = XL+IX = XLIX'
- en: 'Roughly, we take the given number and try to find the Roman symbols corresponding
    to ones, tens, hundreds, or thousands. This algorithm can be expressed as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 大致上，我们拿到给定的数字，然后尝试找到对应于个位、十位、百位或千位的罗马符号。这个算法可以表达如下：
- en: Start from the thousand's place and print the corresponding Roman number. For
    example, if the digit at thousand's place is 4, then print the Roman equivalent
    of 4,000, which is MMMM.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从千位开始并打印相应的罗马数字。例如，如果千位上的数字是4，则打印4000的罗马数字等价物，即MMMM。
- en: Continue by dividing the number using digits at hundred's place and print the
    corresponding Roman number.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续通过使用百位数字分割数字并打印相应的罗马数字。
- en: Continue by dividing the number using digits at ten's place and print the corresponding
    Roman number.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续通过使用十位数字分割数字并打印相应的罗马数字。
- en: Continue by dividing the number using digits at one's place and print the corresponding
    Roman number.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续通过使用个位数对数字进行除法，并打印相应的罗马数字。
- en: 'In terms of code, this algorithm works as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，这个算法的工作原理如下：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The complete application is called *RomanNumbers*. Another approach relies on
    successive subtractions instead of division. The *RomanNumbers* application contains
    this implementation as well.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*RomanNumbers*。另一种方法依赖于连续的减法而不是除法。*RomanNumbers*应用程序也包含了这种实现。
- en: Coding challenge 3 – Visiting and toggling 100 doors
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战3 - 访问和切换100扇门
- en: '**Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**Microsoft**，**Flipkart**'
- en: '**Problem**: Consider you''ve been given 100 doors in a row that are initially
    closed. You have to visit these doors 100 times and each time you do, you start
    from the first door. For each visited door, you toggle it (if it is closed, then
    you open it, and vice versa). At the first visit, you visit all 100 doors. At
    the second visit, you visit every second door (#2, #4, #6 ...). At the third visit,
    you visit every third door (#3, #6, #9, ...). You follow this pattern until you
    visit only the 100th door. Write a snippet of code that reveals the state of the
    doors (closed or opened) after 100 visits.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你有100扇门，它们最初都是关闭的。你必须访问这些门100次，每次都从第一扇门开始。对于每个访问的门，你都要切换它（如果它关闭，则打开它，反之亦然）。在第一次访问时，你访问所有100扇门。在第二次访问时，你访问每第二扇门（＃2、＃4、＃6……）。在第三次访问时，你访问每第三扇门（＃3、＃6、＃9……）。你按照这个模式一直到只访问第100扇门。编写一小段代码，揭示100次访问后门的状态（关闭或打开）。'
- en: '**Solution**: The solution to this problem can be intuited by traversing several
    steps. At the initial state, all 100 doors are closed (in the following image,
    each 0 is a closed door and each 1 is an opened door):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：通过遍历几步可以直观地解决这个问题。在初始状态下，所有100扇门都是关闭的（在下图中，每个0都是关闭的门，每个1都是打开的门）：'
- en: '![Figure 15.2 – All the doors are closed (initial state)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.2 - 所有门都关闭（初始状态）'
- en: '](img/Figure_15.2_B15403.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.2_B15403.jpg)'
- en: Figure 15.2 – All the doors are closed (initial state)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 - 所有门都关闭（初始状态）
- en: 'Now, let''s see what we can observe and conclude at each of the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在以下每个步骤中我们能观察和得出什么结论：
- en: 'At the first pass, we open every door (we visit each door, #1, #2, #3, #4,
    ..., #100):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次访问时，我们打开每扇门（我们访问每扇门，＃1、＃2、＃3、＃4、…，＃100）：
- en: '![Figure 15.3 – All the doors are opened (step 1)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.3 - 所有门都打开（步骤1）'
- en: '](img/Figure_15.3_B15403.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.3_B15403.jpg)'
- en: Figure 15.3 – All the doors are opened (step 1)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 - 所有门都打开（步骤1）
- en: 'At the second pass, we only visit the even doors (#2, #4, #6, #8, #10, #12
    …), so the even doors are closed and the odd ones are opened:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次访问时，我们只访问偶数门（＃2、＃4、＃6、＃8、＃10、＃12……），所以偶数门关闭，奇数门打开：
- en: '![Figure 15.4 – The even doors are closed and the odd ones are opened (step
    2)](img/Figure_15.4_B15403.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4 - 偶数门关闭，奇数门打开（步骤2）](img/Figure_15.4_B15403.jpg)'
- en: Figure 15.4 – The even doors are closed and the odd ones are opened (step 2)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 - 偶数门关闭，奇数门打开（步骤2）
- en: 'At the third pass, we only visit doors #3, #6, #9, #12, …. This time, we close
    door #3, which we opened on our first visit, open door #6, which was closed on
    our second visit, and so on and forth:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三次访问时，我们只访问门＃3、＃6、＃9、＃12……这次，我们关闭了第一次访问时打开的门＃3，打开了第二次访问时关闭的门＃6，依此类推：
- en: '![Figure 15.5 – The result of applying the third visit (step 3)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.5 - 应用第三次访问后的结果（步骤3）'
- en: '](img/Figure_15.5_B15403.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.5_B15403.jpg)'
- en: Figure 15.5 – The result of applying the third visit (step 3)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 - 应用第三次访问后的结果（步骤3）
- en: 'At the fourth visit, we only visit doors #4, #8, #12 …. If we continue like
    this, then at the 100th visit, we will get the following result:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四次访问时，我们只访问门＃4、＃8、＃12……如果我们继续这样做，那么在第100次访问时，我们将得到以下结果：
- en: '![Figure 15.6 – The opened doors are all perfect squares (last visit)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.6 - 所有打开的门都是完全平方数（最后一次访问）'
- en: '](img/Figure_15.6_B15403.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.6_B15403.jpg)'
- en: Figure 15.6 – The opened doors are all perfect squares (last visit)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 - 所有打开的门都是完全平方数（最后一次访问）
- en: 'So, at the last visit (the 100th visit), the opened doors are all perfect squares,
    while the rest of the doors are closed. Obviously, even if we observe this, we
    don''t have the necessary time in an interview to traverse 100 visits. But maybe
    we don''t even need to do all 100 visits to observe this result. Let''s assume
    that we do only 15 steps and we try to see what''s happening to a certain door.
    For example, the following image reveals the state of door #12 over 15 steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在最后一次访问（第100次访问）时，所有打开的门都是完全平方数，而其余的门都是关闭的。显然，即使我们观察到这一点，在面试中我们也没有足够的时间来遍历100次访问。但也许我们甚至不需要做所有100次访问来观察这个结果。让我们假设我们只做15步，然后我们试图看看某扇门发生了什么。例如，以下图像显示了门＃12在15步中的状态：
- en: '![Figure 15.7 – Door #12 after 15 steps'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.7 - 第15步后的门＃12'
- en: '](img/Figure_15.7_B15403.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.7_B15403.jpg)'
- en: 'Figure 15.7 – Door #12 after 15 steps'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 - 第15步后的门＃12
- en: 'Check out the steps highlighted in the preceding image. The state of door #12
    has changed at *steps 1, 2, 3, 4, 6*, and *12*. All these steps are divisors of
    12\. Moreover, *step 1* opens the door, *step 2* closes the door, *step 3* opens
    the door, *step 4* closes the door, *step 6* opens the door, and *step 12* closes
    the door. Starting from this observation, we can conclude that for every pair
    of divisors, the door will just end up back in its initial state, which is closed.
    In other words, each door that has an even number of divisors remains closed in
    the end.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 检查前面图像中突出显示的步骤。门＃12的状态在*步骤1、2、3、4、6*和*12*发生了变化。所有这些步骤都是12的约数。此外，*步骤1*打开门，*步骤2*关闭门，*步骤3*打开门，*步骤4*关闭门，*步骤6*打开门，*步骤12*关闭门。从这个观察开始，我们可以得出结论，对于每一对约数，门最终都会回到初始状态，即关闭状态。换句话说，每个具有偶数个约数的门最终都会关闭。
- en: 'Let''s see whether this is true for a perfect square, such as 9\. The reason
    for choosing a perfect square relies on the fact that a perfect square always
    has an odd number of positive divisors. For example, the divisors of 9 are 1,
    3, and 9\. This means that door #9 remains open.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是否对于一个完全平方数来说是正确的，比如9。选择完全平方数的原因在于完全平方数总是有奇数个正因子。例如，9的因子是1、3和9。这意味着门#9保持打开状态。
- en: 'Based on these two paragraphs, we can conclude that, after 100 visits, the
    doors that remain opened are those that are perfect squares (#1, #4, #9, #16,
    ..., #100), while the rest of the doors remain closed.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这两段文字，我们可以得出结论，经过100次访问后，保持打开状态的门是那些完全平方数（#1，#4，#9，#16，...，#100），而其余的门保持关闭状态。
- en: 'Once you understand the preceding process, it is quite straightforward to write
    an application that confirms the final result:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了前面的过程，编写一个确认最终结果的应用程序就非常简单了：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The complete application is called *VisitToggle100Doors*.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*VisitToggle100Doors*。
- en: Coding challenge 4 – 8 teams
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战4 - 8支队伍
- en: '**Amazon**, **Google**, **Adobe**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**'
- en: '**Problem**: Consider there''s a contest where there''s 8 teams. Each team
    plays twice with other teams. From all these teams, only 4 go to the semi-finals.
    How many matches should a team win to go through to the semi-finals?'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑有一个比赛，有8支队伍。每支队伍与其他队伍比赛两次。从所有这些队伍中，只有4支队伍进入半决赛。一支队伍要赢得多少场比赛才能进入半决赛？'
- en: '**Solution**: Let''s denote the teams as T1, T2, T3, T4, T5, T6, T7, and T8\.
    If T1 plays with T2...T8, they will play 7 matches. Since each team must play
    with the other teams twice, we have 8*7=56 matches. If, at each match, a team
    can win a point, then we have 56 points that are distributed between 8 teams.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们将队伍标记为T1、T2、T3、T4、T5、T6、T7和T8。如果T1与T2...T8比赛，他们将进行7场比赛。由于每个队伍必须与其他队伍比赛两次，所以我们有8*7=56场比赛。如果每场比赛中一支队伍可以赢得一分，那么我们有56分分配给8支队伍。'
- en: Let's consider the worst-case scenario. T0 loses all their games. This means
    that T0 gets 0 points. On the other hand, T1 wins 2 points against T0 and loses
    all their other matches, T2 wins 4 points against T0 and T1 and loses all their
    other matches, T3 wins 6 points against T0, T1, and T2 and loses all their other
    matches, and so on. T4 wins 8 points, T5 wins 10 points, T6 wins 12 points, and
    T7 wins 14 points. So, a team that wins all their matches wins 14 points. The
    last four teams (those that go through to the semi-finals) have won 8+10+12+14=44
    points. So, a team can be sure that they go through to the semi-finals if they
    obtain a minimum of 44/4=11 points.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑最坏的情况。T0输掉了所有比赛。这意味着T0得到0分。另一方面，T1对T0赢得了2分，并输掉了所有其他比赛，T2对T0和T1赢得了4分，并输掉了所有其他比赛，T3对T0、T1和T2赢得了6分，并输掉了所有其他比赛，依此类推。T4赢得了8分，T5赢得了10分，T6赢得了12分，T7赢得了14分。因此，一支赢得所有比赛的队伍赢得了14分。最后四支队伍（进入半决赛的队伍）赢得了8+10+12+14=44分。因此，一支队伍可以确保他们进入半决赛，如果他们获得至少44/4=11分。
- en: Coding challenge 5 – Finding the kth number with the prime factors 3, 5, and
    7
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战5 - 找到具有质因数3、5和7的第k个数字
- en: '**Adobe**, **Microsoft**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**微软**'
- en: '**Problem**: Design an algorithm to find the kth number where the only prime
    factors are 3, 5, and 7.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：设计一个算法，找到唯一的质因数是3、5和7的第k个数字。'
- en: '**Solution**: Having a list of numbers whose only prime factors are 3, 5, and
    7 means a list that looks as follows: 1, 3, 5, 7, 9, 15, 21, 25, and so on. Or,
    to be more suggestive, it can be written as follows: 1, 1*3, 1*5, 1*7, 3*3, 3*5,
    3*7, 5*5, 3*3*3, 5*7, 3*3*5, 7*7, and so on.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：拥有一组数字，其唯一的质因数是3、5和7，意味着一组看起来如下：1、3、5、7、9、15、21、25等等。或者，更具启发性地，可以写成：1、1*3、1*5、1*7、3*3、3*5、3*7、5*5、3*3*3、5*7、3*3*5、7*7等等。'
- en: 'With this suggestive representation, we can see that we can initially insert
    the value 1 into a list, while the rest of the elements must be computed. The
    simplest way to understand the algorithm for determining the rest of the elements
    is to look at the implementation itself, so let''s see it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种具有启发性的表示，我们可以看到我们可以最初将值1插入列表中，而其余的元素必须计算出来。理解确定其余元素的算法最简单的方法是看实现本身，所以让我们来看看：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can provide an implementation via three queues as well. The steps of this
    algorithm are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过三个队列来实现。该算法的步骤如下：
- en: Initialize an integer, *minElem*=1.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个整数*minElem*=1。
- en: Initialize three queues; that is, *queue3*, *queue5*, and *queue7*.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化三个队列；即*queue3*、*queue5*和*queue7*。
- en: 'Loop from 1 to the given *k*-1:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从1到给定的*k*-1进行循环：
- en: a. Insert *minElem**3, *minElem**5, and *minElem**7 into *queue3*, *queue5*,
    and *queue7*, respectively.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: a. 将*minElem**3、*minElem**5和*minElem**7分别插入*queue3*、*queue5*和*queue7*。
- en: b. Update *minElem* as min(*queue3*.peek, *queue5*.peek, *queue7*.peek).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: b. 更新*minElem*为min(*queue3*.peek, *queue5*.peek, *queue7*.peek)。
- en: c. If *minElem* is *queue3*.peek, then do *queue3*.poll.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: c. 如果*minElem*是*queue3*.peek，则执行*queue3*.poll。
- en: d. If *minElem* is *queue5*.peek, then do *queue5*.poll.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: d. 如果*minElem*是*queue5*.peek，则执行*queue5*.poll。
- en: e. If *minElem* is *queue7*.peek, then do *queue7*.poll.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: e. 如果*minElem*是*queue7*.peek，则执行*queue7*.poll。
- en: Return *minElem*.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回*minElem*。
- en: The complete application is called *KthNumber357*. It contains both solutions
    presented in this section.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*KthNumber357*。它包含了本节中提出的两种解决方案。
- en: Coding challenge 6 – Count decoding a digit's sequence
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战6 - 计算解码数字序列
- en: '**Amazon**, **Microsoft**, **Flipkart**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**微软**，**Flipkart**'
- en: '**Problem**: Consider that *A* is 1, *B* is 2, *C* is 3, ... *Z* is 26\. For
    any given sequence of digits, write a snippet of code that counts the number of
    possible decodings (for example, 1234 can be decoded as 1 2 3 4, 12 3 4, and 1
    23 4, which means as ABCD, LCD, and AWD). The given sequence of digits is valid
    if it contains digits from 0 to 9\. No leading 0s, no extra trailing 0s, and no
    two or more consecutive 0s are allowed.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设*A*是1，*B*是2，*C*是3，... *Z*是26。对于任何给定的数字序列，编写一小段代码来计算可能的解码数量（例如，1234可以解码为1
    2 3 4，12 3 4和1 23 4，也就是ABCD、LCD和AWD）。如果给定的数字序列包含从0到9的数字，则它是有效的。不允许前导0，不允许额外的尾随0，也不允许连续出现两个或更多个0。'
- en: '**Solution**: This problem can be solved via recursion or via dynamic programming.
    Both techniques were covered in [*Chapter 8*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161)*,
    Recursion and Dynamic Programming*. So, let''s look at the recursive algorithm
    for a sequence of *n* digits:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：这个问题可以通过递归或动态规划来解决。这两种技术都在[*第 8 章*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161)*，递归和动态规划*中讨论过。因此，让我们看看一个
    *n* 位数字序列的递归算法：'
- en: Initialize the total number of decodings with 0.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解码的总数初始化为 0。
- en: Start from the end of the given sequence of digits.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从给定数字序列的末尾开始。
- en: If the last digit is not 0, then apply recursion for the (*n*-1) digits and
    use the result to update the total number of decodings.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果最后一位不是 0，则对(*n*-1)位数字应用递归，并使用结果更新解码的总数。
- en: If the last two digits represent a number less than 27 (therefore, a valid character),
    then apply recursion to the (*n*-2) digits and use the result to update the total
    number of decodings.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果最后两位数字表示的数字小于 27（因此是有效字符），则对(*n*-2)位数字应用递归，并使用结果更新解码的总数。
- en: 'In terms of code, we have the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下内容：
- en: '[PRE4]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code runs in an exponential time. But we can apply dynamic programming
    to reduce the runtime to O(n) via a similar non-recursive algorithm, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行时间是指数级的。但是我们可以应用动态规划，通过类似的非递归算法将运行时间降低到 O(n)，具体如下：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code runs in O(n) time. The complete application is called *DecodingDigitSequence*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行时间是 O(n)。完整的应用程序称为 *DecodingDigitSequence*。
- en: Coding challenge 7 – ABCD
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战 7 – ABCD
- en: '**Problem**: Find a number of types, ABCD, such that when multiplied by 4,
    it gives us DCBA.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：找到一种类型的数字 ABCD，使得乘以 4 后得到 DCBA。'
- en: '**Solution**: These kinds of problems are usually quite hard. In this case,
    we have to use some math to solve it.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：这类问题通常相当难。在这种情况下，我们必须使用一些数学来解决它。'
- en: 'Let''s start with some simple inequalities:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些简单的不等式开始：
- en: 1 <= A <= 9 (A cannot be zero because ABCD is a four-digit number)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 <= A <= 9（A 不能为零，因为 ABCD 是一个四位数）
- en: 0 <= B <= 9
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 <= B <= 9
- en: 0 <= C <= 9
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0 <= C <= 9
- en: 4 <= D <= 9 (D must be at least 4*A, so it should be at least 4)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 <= D <= 9（D 必须至少为 4*A，所以至少应为 4）
- en: Next, we can assume that our number, ABCD, is written as 1000A + 100B + 10C
    + D. Following the problem statement, we can multiply ABCD by 4 to obtain DCBA,
    which can be written as 1000D + 100C + 10B + A.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以假设我们的数字 ABCD 被写成 1000A + 100B + 10C + D。根据问题描述，我们可以将 ABCD 乘以 4 得到 DCBA，可以写成
    1000D + 100C + 10B + A。
- en: Conforming to divisibility by 4, BA is a two-digit number divisible by 4\. Now,
    the larger ABCD is 2499, because a number greater than 2499 multiplied by 4 will
    result in a five-digit number.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 符合4的整除性，BA 是一个可以被 4 整除的两位数。现在，较大的 ABCD 是 2499，因为大于 2499 的数乘以 4 将得到一个五位数。
- en: Next, A can be 1 and 2\. However, if BA is a two-digit number divisible by 4,
    then A must be even, so it must be 2.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，A 可以是 1 和 2。然而，如果 BA 是一个可以被 4 整除的两位数，那么 A 必须是偶数，所以必须是 2。
- en: Continuing with this logic, this means that D is either 8 or 9\. However, since
    D times 4 would end in 2, D must be 8.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 继续这种逻辑，这意味着 D 要么是 8，要么是 9。然而，由于 D 乘以 4 会以 2 结尾，所以 D 必须是 8。
- en: Moreover, 4000A + 400B + 40C + 4D = 1000D + 100C + 10B + A. Since A=2 and D=8,
    this can be written as 2C-13B=1\. B and C can only be a single digit integer in
    [1, 7], but B must be odd since BA is a two-digit number divisible by 4\. Since
    the greatest possible number is 2499, this means that B can be 1 or 3.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，4000A + 400B + 40C + 4D = 1000D + 100C + 10B + A。由于 A=2 和 D=8，这可以写成 2C-13B=1。B
    和 C 只能是 [1, 7] 范围内的个位整数，但由于 BA 是一个可以被 4 整除的两位数，B 必须是奇数。由于最大可能的数字是 2499，这意味着 B
    可以是 1 或 3。
- en: So, the result is 2178 because 2178*4=8712, so ABCD*4=DCBA.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结果是 2178，因为 2178*4=8712，所以 ABCD*4=DCBA。
- en: 'We can use the brute-force approach to find this number as well. The following
    code speaks for itself:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用蛮力方法来找到这个数字。以下代码说明了这一点：
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The complete application is called *Abcd*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为 *Abcd*。
- en: Coding challenge 8 – Rectangles overlapping
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战 8 – 重叠的矩形
- en: '**Amazon**, **Google**, **Microsoft**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**微软**'
- en: '`true` if these rectangles overlap (also referred to as colliding or intersecting).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`true` 如果这些矩形重叠（也称为相交）。'
- en: '**Solution**: This problem sounds a little bit vague. It is important to discuss
    this with the interviewer and agree about two important aspects:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：这个问题听起来有点模糊。重要的是要与面试官讨论并就两个重要方面达成一致：'
- en: '*The two rectangles are parallel to each other and form an angle of 0 degrees
    with the horizontal plane (they are parallel to the coordinate axes) or can they
    be rotated under an angle?*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*这两个矩形是平行的，并且与水平面成0度角（它们与坐标轴平行），或者它们可以在一个角度下旋转吗？*'
- en: Most of the time, the given rectangles are parallel to each other and to the
    coordinate axes. If rotation is involved, then the solution requires some geometry
    knowledge that is not so obvious during an interview. Most probably, the interviewer
    wants to test your logic, not your knowledge of geometry, but challenge yourself
    and implement the problem for non-parallel rectangles as well.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，给定的矩形是平行的，并且与坐标轴平行。如果涉及旋转，那么解决方案需要一些几何知识，这在面试中并不那么明显。面试官很可能是想测试你的逻辑，而不是你的几何知识，但是挑战自己，为非平行矩形实现问题。
- en: '*Are the coordinates of the rectangles given in the Cartesian plane?* The answer
    should be affirmative since this is a common coordinates system used in mathematics.
    This means that a rectangle increases its size from left to right and from bottom
    to top.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*矩形的坐标是在笛卡尔平面上给出的吗？* 答案应该是肯定的，因为这是数学中常用的坐标系。这意味着一个矩形从左到右，从下到上增加大小。'
- en: 'So, let''s denote the rectangles as *r1* and *r2*. Each of them is given via
    the coordinates of the top-left corner and bottom-right corner. The top-left corner
    of *r1* has the coordinates *r1lt.x* and *r1lt.y*, while the bottom-right corner
    has the coordinates *r2rb.x* and *r2rb.y*, as shown in the following diagram:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将矩形表示为*r1*和*r2*。它们每个都是通过左上角和右下角的坐标给出的。*r1*的左上角的坐标为*r1lt.x*和*r1lt.y*，而右下角的坐标为*r2rb.x*和*r2rb.y*，如下图所示：
- en: '![Figure 15.8 – Rectangle coordinates'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.8-矩形坐标'
- en: '](img/Figure_15.8_B15403.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.8_B15403.jpg)'
- en: Figure 15.8 – Rectangle coordinates
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8-矩形坐标
- en: 'We might say that two rectangles are overlapping if they *touch* each other
    (they at least have a common point). In other words, the five pairs of rectangles
    shown in the following diagram overlap:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，如果两个矩形*接触*（至少有一个公共点），它们就是重叠的。换句话说，在下图中显示的五对矩形中，有重叠：
- en: '![Figure 15.9 – Overlapping rectangles'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.9-重叠的矩形'
- en: '](img/Figure_15.9_B15403.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.9_B15403.jpg)'
- en: Figure 15.9 – Overlapping rectangles
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9-重叠的矩形
- en: 'From the preceding diagram, we can conclude that two rectangles that don''t
    overlap can be in one of the following four cases:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，我们可以得出两个不重叠的矩形可能处于以下四种情况之一：
- en: '*r1* is totally to the right of *r2.*'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r1*完全在*r2*的右边。'
- en: '*r1* is totally to the left of *r2.*'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r1*完全在*r2*的左边。 '
- en: '*r1* is totally above *r2.*'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r1*完全在*r2*的上方。'
- en: '*r1* is totally below *r2.*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r1*完全在*r2*下方。'
- en: 'The following diagram reveals these four cases:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了这四种情况：
- en: '![Figure 15.10 – Non-overlapping rectangles'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.10-不重叠的矩形'
- en: '](img/Figure_15.10_B15403.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.10_B15403.jpg)'
- en: Figure 15.10 – Non-overlapping rectangles
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10-不重叠的矩形
- en: 'We can express the preceding four bullets in terms of coordinates, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用坐标表示前面的四个项目，如下所示：
- en: '*r1* is totally to the right of *r2* →*r1lt.x>r2rb.x*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r1*完全在*r2*的右边→*r1lt.x>r2rb.x*'
- en: '*r1* is totally to the left of *r2* →*r2lt.x>r1rb.x*'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r1*完全在*r2*的左边→*r2lt.x>r1rb.x*'
- en: '*r1* is totally above *r2* →*r1rb.y>r2lt.y*'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r1*完全在*r2*上方→*r1rb.y>r2lt.y*'
- en: '*r1* is totally below *r2* →*r2rb.y>r1lt.y*'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r1*完全在*r2*下方→*r2rb.y>r1lt.y*'
- en: 'So, if we group these conditions into code, we get the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们将这些条件分组到代码中，我们得到以下结果：
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code runs in O(1) time. Alternatively, we can condense these two conditions
    into a single one, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行时间为O(1)。或者，我们可以将这两个条件合并为一个条件，如下所示：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The complete applications is called *RectangleOverlap*. Note that the interviewer
    may define *overlapping* in different ways. Based on this problem, you should
    be able to adapt the code accordingly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*RectangleOverlap*。请注意，面试官可能以不同的方式定义*重叠*。根据这个问题，你应该能够相应地调整代码。
- en: Coding challenge 9 – Multiplying large numbers
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战9-乘以大数
- en: '**Amazon**, **Microsoft**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**微软**'
- en: '`int` or `long` domains. Write a snippet of code that computes *a*b*.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 整数或长整数域。编写一个计算*a*b*的代码片段。
- en: '**Solution**: Let''s consider that *a*=4145775 and *b*=771467\. Then, *a*b*=3198328601925\.
    Solving this problem relies on mathematics. The following image depicts the *a*b*
    solution that can be applied on paper and coded as well:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们假设*a*=4145775和*b*=771467。然后，*a*b*=3198328601925。解决这个问题依赖于数学。以下图像描述了可以在纸上应用并编码的*a*b*解决方案：'
- en: '![Figure 15.11 – Multiplying two large numbers'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.11-两个大数相乘'
- en: '](img/Figure_15.11_B15403.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.11_B15403.jpg)'
- en: Figure 15.11 – Multiplying two large numbers
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11-两个大数相乘
- en: Mainly, we rely on the fact that multiplication can be written as a suite of
    additions. So, we can write 771467 as 7+60+400+1000+70000+700000 and we multiply
    each of these numbers by 4145775\. Finally, we add the results to obtain the final
    result, 3198328601925\. Taking this logic one step further, we can take the last
    digit of the first number (5) and multiply it by all the digits of the second
    number (7, 6, 4, 1, 7, 7). Then, we take the second digit of the first number
    (7) and multiply it by all the digits of the second number (7, 6, 4, 1, 7, 7).
    Then, we take the third digit of the first number (7) and multiply it by all the
    digits of the second number (7, 6, 4, 1, 7, 7). We continue this process until
    we've multiplied all the digits of the first number by all the digits of the second
    number. While adding the results, we state that the *t*th multiplication shifted.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 主要是，我们依赖于乘法可以写成一系列加法的事实。因此，我们可以将771467写成7+60+400+1000+70000+700000，然后我们将这些数字中的每一个与4145775相乘。最后，我们将结果相加以获得最终结果3198328601925。进一步推理，我们可以取第一个数字的最后一位（5）并将其乘以第二个数字的所有数字（7,6,4,1,7,7）。然后，我们取第一个数字的第二位（7）并将其乘以第二个数字的所有数字（7,6,4,1,7,7）。然后，我们取第一个数字的第三位（7）并将其乘以第二个数字的所有数字（7,6,4,1,7,7）。我们继续这个过程，直到我们将第一个数字的所有数字乘以第二个数字的所有数字。在添加结果时，我们声明*t*th乘法移位。
- en: 'In terms of code, we have the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下内容：
- en: '[PRE9]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The complete application is called *MultiplyLargeNumbers*.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*MultiplyLargeNumbers*。
- en: Coding challenge 10 – Next greatest number with the same digits
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战10-具有相同数字的下一个最大数字
- en: '**Amazon**, **Google**, **Microsoft**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**微软**'
- en: '**Problem**: Consider you''ve been given a positive integer. Write a snippet
    of code that returns the next greatest number with the same digits.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到了一个正整数。编写一个返回具有相同数字的下一个最大数字的代码片段。'
- en: '**Solution**: The solution to this problem can be observed via several examples.
    Let''s consider the following examples:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：通过几个示例可以观察到这个问题的解决方案。让我们考虑以下示例：'
- en: 'Example 1: 6 → Not possible'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例1：6→不可能
- en: 'Example 2: 1234 → 1243'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例2：1234→1243
- en: 'Example 3: 1232 → 1322'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例3：1232→1322
- en: 'Example 4: 321 → Not possible'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例4：321→不可能
- en: 'Example 5: 621873 → 623178'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例5：621873→623178
- en: From the preceding examples we can intuit that the solution can be obtained
    by rearranging the digits of the given number. So, if we can find the set of rules
    for swapping the digits that leads us to the searched number, then we can attempt
    an implementation.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，我们可以直觉到解决方案可以通过重新排列给定数字的数字来获得。因此，如果我们可以找到交换数字的规则集，使我们得到要搜索的数字，那么我们可以尝试实现。
- en: 'Let''s try several observations:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试几个观察：
- en: From examples 1 and 4, we can see that if the digits of the given number are
    in descending order, then it is impossible to find a greater number. Every swap
    will lead to a smaller number.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从示例1和4可以看出，如果给定数字的数字是降序的，那么不可能找到更大的数字。每次交换都会导致更小的数字。
- en: From example 2, we can see that if the digits of the given number are in ascending
    order, then the next greater number that has the same digits can be obtained by
    swapping the last two digits.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从示例2可以看出，如果给定数字的数字是按升序排列的，那么具有相同数字的下一个更大数字可以通过交换最后两个数字来获得。
- en: From examples 3 and 5, we can see that we need to find the smallest of all the
    greater numbers. For this, we have to process the number from the right-most side.
    The following algorithm clarifies this statement.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从示例3和5可以看出，我们需要找到所有更大数字中的最小数字。为此，我们必须从最右边处理数字。以下算法阐明了这一说法。
- en: 'Based on these three observations, we can elaborate the following algorithm,
    which has been exemplified on the number 621873:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这三点观察，我们可以详细说明以下算法，该算法已在数字621873上进行了示例：
- en: We start by traversing the number digit by digit from the right-most side. We
    keep traversing until we find a digit that is smaller than the previously traversed
    digit. For example, if the given number is 621873, then we traverse the number
    until digit 1 in 621873\. Digit 1 is the first digit that's smaller than the previously
    traversed digit, 8.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从最右边的数字开始逐个遍历数字。我们一直遍历，直到找到一个比先前遍历的数字小的数字。例如，如果给定的数字是621873，那么我们遍历到621873中的数字1。数字1是第一个比先前遍历的数字8小的数字。
- en: Next, we focus on the digits from the right-hand side of the digit that we found
    at step 1\. We want to find the smallest digit among these digits (let's denote
    it as *t*). Since these digits are sorted in descending order, the smallest digit
    is at the last position. For example, 3 is the smallest digit among the digits
    from the right-hand side of 1, 62**1**87**3**.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们关注我们在步骤1中找到的数字右侧的数字。我们想在这些数字中找到最小的数字（我们将其表示为*t*）。由于这些数字按降序排列，最小的数字在最后位置。例如，3是1右侧数字中最小的数字，62**1**87**3**。
- en: We swap these two digits (1 with 3) and we obtain 62**3**87**1**.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们交换这两个数字（1和3），我们得到62**3**87**1**。
- en: Finally, we sort all the digits to the right-hand side of *t* in ascending order.
    But since we know that all the digits from the right-hand side of *t* are sorted
    in descending order, except for the last digit, we can apply a linear reverse.
    This means that the result is 623**178**. This is the searched number.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将所有数字按升序排列到*t*的右侧。但是由于我们知道*t*右侧的所有数字都是按降序排列的，除了最后一个数字，我们可以应用线性反转。这意味着结果是623**178**。这就是要搜索的数字。
- en: 'This algorithm can be easily implemented, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法可以很容易地实现，如下所示：
- en: '[PRE10]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code runs in O(n) time. The complete application is called *NextElementSameDigits*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行时间为O(n)。完整的应用程序称为*NextElementSameDigits*。
- en: Coding challenge 11 – A number divisible by its digits
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战11 - 数字可被其数字整除
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**'
- en: '`true` if the given number is divisible by its digits.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定数字可以被其数字整除，则返回`true`。
- en: '`true` since 412 is divisible by 2, 1, and 4\. On the other hand, if *n*=143,
    then the output should be `false` since 143 is not divisible by 3 and 4.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`，因为412可以被2、1和4整除。另一方面，如果*n*=143，那么输出应该是`false`，因为143不能被3和4整除。'
- en: If you think that this problem is simple, then you're absolutely right. These
    kinds of problems are used as *warm-up* problems and are useful to quickly filter
    a lot of candidates. Most of the time, you should solve it in a given time (for
    example, 2-3 minutes).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为这个问题很简单，那么你是完全正确的。这些问题被用作*热身*问题，并且有助于快速筛选出很多候选人。大多数情况下，你应该在规定的时间内解决它（例如，2-3分钟）。
- en: Important note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: It is advisable to treat these simple problems with the same degree of seriousness
    as any other problem. A little mistake can prematurely eliminate you from the
    race.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 建议对待这些简单的问题与对待任何其他问题一样认真。一个小错误可能会让你提前退出比赛。
- en: 'So, for this problem, the algorithm is comprised of the following steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这个问题，算法包括以下步骤：
- en: Fetch all the digits of the given number.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取给定数字的所有数字。
- en: For each digit, check whether the *given number* *% digit* is 0 (this means
    divisible).
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个数字，检查*给定数字* *%数字*是否为0（这意味着可被整除）。
- en: If any of them are non-zero, return `false`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果其中任何一个不为零，则返回`false`。
- en: If, for all the digits the *given number % digit* is 0, return `true`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对于所有数字，*给定数字%数字*都是0，则返回`true`。
- en: 'In terms of code, we have the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下内容：
- en: '[PRE11]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The complete application is called *NumberDivisibleDigits*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*NumberDivisibleDigits*。
- en: Coding challenge 12 – Breaking chocolate
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战12 - 打破巧克力
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you''ve been a given rectangular bar of chocolate of
    size *width* x *height* and a number of tiles. As usual, the chocolate consists
    of a number of little tiles, so the *width* and *height* give us the number of
    tiles (for example, the chocolate is 4 x 3 in size and contains 12 tiles). Write
    a snippet of code that computes the number of breaks (cuts) we need to apply to
    the given chocolate to obtain a piece that has exactly the required number of
    tiles. You can break (cut) the given chocolate into two rectangular pieces via
    a single vertical or horizontal break (cut) along the tile edges.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到了尺寸为*宽度* x *高度*的矩形巧克力条和一些瓷砖。通常情况下，巧克力由许多小瓷砖组成，因此*宽度*和*高度*给出了我们的瓷砖数量（例如，巧克力尺寸为4
    x 3，包含12块瓷砖）。编写一小段代码，计算我们需要对给定的巧克力施加多少次断裂（切割）才能获得具有完全所需数量的瓷砖的一块。您可以通过单个垂直或水平断裂（切割）将给定的巧克力切成两个矩形块。'
- en: '**Solution**: Let''s consider the chocolate shown in the following image (a
    3 x 6 bar of chocolate that has 18 tiles):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑以下图像中显示的巧克力（一个3 x 6的巧克力条，有18块瓷砖）：'
- en: '![Figure 15.12 – A 3 x 6 chocolate bar](img/Figure_15.12_B15403.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图15.12 – 一个3 x 6巧克力条](img/Figure_15.12_B15403.jpg)'
- en: Figure 15.12 – A 3 x 6 chocolate bar
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12 – 一个3 x 6巧克力条
- en: 'The preceding image reveals seven cases that can lead us to the solution, as
    follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图像显示了七种情况，可以带我们找到解决方案，如下：
- en: 'Cases 1, 2, and 3: If the number of given tiles is greater than 3 x 6 or we
    cannot arrange the tiles along with the chocolate''s *width* or *height*, then
    it is not possible to attain a solution. For no solution, we return -1.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 情况1、2和3：如果给定瓷砖的数量大于3 x 6或者我们无法将瓷砖与巧克力的*宽度*或*高度*排列在一起，则无法获得解决方案。对于无解，我们返回-1。
- en: 'Case 4: If the number of given tiles is equal to 3 x 6 = 18, then this is the
    solution, so we have 0 cuts. We''ll return 0.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 情况4：如果给定瓷砖的数量等于3 x 6 = 18，则这就是解决方案，所以我们不需要切割。我们将返回0。
- en: 'Case 5: If the number of given tiles can be arranged along with the chocolate
    bar''s *width*, then there is a single cut. We''ll return 1.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 情况5：如果给定瓷砖的数量可以与巧克力条的*宽度*排列在一起，则只需要一次切割。我们将返回1。
- en: 'Case 6: If the number of given tiles can be arranged along with the chocolate
    bar''s *height*, then there is a single cut. We''ll return 1.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 情况6：如果给定瓷砖的数量可以与巧克力条的*高度*排列在一起，则只需要一次切割。我们将返回1。
- en: 'Case 7: In all other cases, we need 2 cuts. We''ll return 2.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 情况7：在所有其他情况下，我们需要2次切割。我们将返回2。
- en: 'Let''s see the code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE12]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete application is called *BreakChocolate*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*BreakChocolate*。
- en: Coding challenge 13 – Clock angle
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战13 – 时钟角度
- en: '**Google**, **Microsoft**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**谷歌**，**微软**'
- en: '**Problem**: Consider you''ve been given the time in *h:m* format. Write a
    snippet of code that calculates the shorter angle between the hour and the minute
    hand on an analog clock.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经以*h:m*格式给出时间。编写一小段代码，计算模拟时钟上时针和分针之间的较短角度。'
- en: '**Solution**: Right from the start, we have to take into account several formulas
    that will help us come up with a solution.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：从一开始，我们必须考虑几个公式，这些公式将帮助我们得出解决方案。'
- en: 'First of all, a clock is divided into 12 equal hours (or 12 equals parts) and
    since it is a complete circle, it has 360o. So, 1 hour has 360o/12 = 30o. So,
    at 1:00, the hour hand forms an angle of 300 with the minute hand. At 2:00, the
    hour hand forms an angle of 60o with the minute hand, and so on and so forth.
    The following image clarifies this aspect:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，时钟被分成12个相等的小时（或12个相等的部分），因为它是一个完整的圆，所以有360o。因此，1小时有360o/12 = 30o。因此，在1:00时，时针与分针形成300的角度。在2:00时，时针与分针形成60o的角度，依此类推。以下图像阐明了这一方面：
- en: '![Figure 15.13 – 360 degree split at 12 hours'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.13 – 12小时的360度分割'
- en: '](img/Figure_15.13_B15403.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.13_B15403.jpg)'
- en: Figure 15.13 – 360 degree split at 12 hours
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13 – 12小时的360度分割
- en: Taking this logic further, an hour has 60 minutes and 30o, so a minute has 30/60
    = 0.5o. So, if we refer only to the hour hand, then at 1:10, we have an angle
    of 30o + 10*0.5o = 30o + 5o = 35o. Or, at 4:17, we have an angle of 4*30o + 17*0.5o
    = 120o + 8.5o = 128.5o.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步推理，1小时有60分钟和30o，因此1分钟有30/60 = 0.5o。因此，如果我们只参考时针，那么在1:10时，我们有30o + 10*0.5o
    = 30o + 5o = 35o。或者，在4:17时，我们有4*30o + 17*0.5o = 120o + 8.5o = 128.5o。
- en: So far, we know that we can compute the angle of the hour hand for a given *h:m*
    time as *h**300 + *m**0.5o. For computing the angle of the minute hand, we can
    think that, in 1 hour, the minute hand takes a complete 360o tour, so 360o/ 60
    minutes = 6o for each minute. So, at *h*:24, the minute hand forms an angle of
    24 * 6o = 144o. At *h*:35, the minute hand forms an angle of 35 * 6o = 210o, and
    so on and so forth.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道可以计算给定*h:m*时间的时针角度为*h**300 + *m**0.5o。对于计算分针的角度，我们可以认为，在1小时内，分针需要完成360o的旋转，因此360o/
    60分钟 = 每分钟6o。因此，在*h*:24时，分针形成144o的角度。在*h*:35时，分针形成210o的角度，依此类推。
- en: So, the angle between the hour and the minute hand is the abs((*h**30o + *m**0.5o)
    - *m**6o). If the returned *result* is greater than 180o, then we have to return
    (360o - *result*) since the problem requires us to calculate the shorter angle
    between the hour and the minute hand.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，时针和分针之间的角度是abs((*h**30o + *m**0.5o) - *m**6o)。如果返回的*result*大于180o，则我们必须返回(360o
    - *result*)，因为问题要求我们计算时针和分针之间的较短角度。
- en: 'Now, let''s try to calculate the required angle for the clocks shown in the
    following image:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试计算以下图像中显示的时钟所需的角度：
- en: '![Figure 15.14 – Three clocks'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.14 – 三个时钟'
- en: '](img/Figure_15.14_B15403.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.14_B15403.jpg)'
- en: Figure 15.14 – Three clocks
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14 – 三个时钟
- en: '**Clock 1, 10:10**:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**时钟1，10:10**：'
- en: 'Hour hand: 10*30o + 10*0.5o = 300o + 5o = 305o'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时针：10*30o + 10*0.5o = 300o + 5o = 305o
- en: 'Minute hand: 10 * 6o = 60o'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分针：10 * 6o = 60o
- en: 'Result: abs(305o - 60o) = abs(245o) = 245o > 180o, so return 360o - 245o =
    115o'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果：abs(305o - 60o) = abs(245o) = 245o > 180o，因此返回360o - 245o = 115o
- en: '**Clock 2, 9:40**:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**时钟2，9:40**：'
- en: 'Hour hand: 9*30o + 40*0.5o = 270o + 20o = 290o'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时针：9*30o + 40*0.5o = 270o + 20o = 290o
- en: 'Minute hand: 40 * 6o = 240o'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分针：40 * 6o = 240o
- en: 'Result: abs(290o - 240o) = abs(50o) = 50o'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果：abs(290o - 240o) = abs(50o) = 50o
- en: '**Clock 3, 4:40**:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**时钟3，4:40**：'
- en: 'Hour hand: 4*30o + 40*0.5o = 120o + 20o = 140o'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时针：4*30o + 40*0.5o = 120o + 20o = 140o
- en: 'Minute hand: 40 * 6o = 240o'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分钟：40 * 6o = 240o
- en: 'Result: abs(140o - 240o) = abs(-100o) = 100o'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果：abs(140o - 240o) = abs(-100o) = 100o
- en: 'Based on these statements, we can write the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些陈述，我们可以编写以下代码：
- en: '[PRE13]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The complete application is called *HourMinuteAngle*.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*HourMinuteAngle*。
- en: Coding challenge 14 – Pythagorean triplets
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战14-勾股定理三元组
- en: '**Google**, **Adobe**, **Microsoft**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**谷歌**，**Adobe**，**微软**'
- en: '**Problem**: A Pythagorean triplet is a set of three positive integers {*a,
    b, c*} such that *a*2 = *b*2 + *c*2\. Consider you''ve been given an array of
    positive integers, *arr*. Write a snippet of code that prints all the Pythagorean
    triplets of this array.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：勾股定理三元组是一组三个正整数{*a，b，c*}，使得*a*2 = *b*2 + *c*2。假设你得到了一个正整数数组*arr*。编写一小段代码，打印出这个数组的所有勾股定理三元组。'
- en: '**Solution**: The brute-force approach can be implemented via three loops that
    can try all the possible triples in the given array. But this will work in O(n3)
    complexity time. Obviously, the brute-force approach (commonly known as the *naive*
    approach) will not impress the interviewer, so we must do better than this.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：可以通过三个循环实现蛮力方法，尝试给定数组中的所有可能三元组。但这将在O(n3)的复杂度时间内工作。显然，蛮力方法（通常称为*naive*方法）不会给面试官留下深刻印象，所以我们必须做得比这更好。'
- en: 'We can, in fact, solve the problem in O(n2) time. Let''s see the algorithm''s
    steps:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以在O(n2)的时间内解决这个问题。让我们看看算法的步骤：
- en: Square every element in the input array (O(n)). This means that we can write
    *a*2 = *b*2 + *c*2 as *a* = *b* + *c*.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对输入数组中的每个元素进行平方（O(n)）。这意味着我们可以将*a*2 = *b*2 + *c*2写成*a* = *b* + *c*。
- en: Sort the given array in ascending order (O(n log n)).
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按升序对给定数组进行排序（O(n log n)）。
- en: If *a* = *b* + *c*, then *a* is always the largest value between *a*, *b*, and
    *c*. So, we fix *a* so that it becomes the last element of this sorted array.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*a* = *b* + *c*，那么*a*始终是*a*、*b*和*c*之间的最大值。因此，我们固定*a*，使其成为这个排序数组的最后一个元素。
- en: Fix *b* so that it becomes the first element of this sorted array.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固定*b*，使其成为这个排序数组的第一个元素。
- en: Fix *c* so that it becomes the element right before element *a*.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固定*c*，使其成为元素*a*之前的元素。
- en: 'So far, *b<a* and *c<a*. To find the Pythagorean triplets, execute a loop that
    increases *b* from 1 to *n* and decreases *c* from *n* to 1\. The loop stops when
    *b* and *c* meet:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，*b<a*且*c<a*。要找到勾股定理三元组，执行一个循环，从1增加*b*到*n*，从*n*减少*c*到1。当*b*和*c*相遇时，循环停止：
- en: a. Increase the index of *b* if *b + c < a*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果*b + c < a*，则增加*b*的索引。
- en: b. Decrease the index of *c* if *b + c > a*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果*b + c > a*，则减少*c*的索引。
- en: c. If *b + c* is equal to *a*, then print the found triplet. Increment the index
    of *b* and decrement the index of *c*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: c. 如果*b + c*等于*a*，则打印找到的三元组。增加*b*的索引并减少*c*的索引。
- en: Repeat from *step 3* for the next *a*.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从*步骤3*开始重复下一个*a*。
- en: 'Let''s consider that *arr*={3, 6, 8, 5, 10, 4, 12, 14}. After the first two
    steps, *arr*={9, 16, 25, 36, 64, 100, 144, 196}. After *steps 3*, *4*, and *5*,
    we have *a*=196, *b*=9, and *c*=144, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*arr*={3, 6, 8, 5, 10, 4, 12, 14}。经过前两步，*arr*={9, 16, 25, 36, 64, 100, 144,
    196}。经过*步骤3*、*4*和*5*，我们有*a*=196，*b*=9，*c*=144，如下所示：
- en: '![Figure 15.15 – Setting a, b, and c'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.15-设置a、b和c'
- en: '](img/Figure_15.15_B15403.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.15_B15403.jpg)'
- en: Figure 15.15 – Setting a, b, and c
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15-设置a、b和c
- en: Since 9+144 < 196, the index of *b* is increased by 1, conforming to *step 6a*.
    The same step applies for 16+144, 25+144, and 36+144\. Since 64+144 > 196, the
    index of *c* is decreased by 1, conforming to *step 6b*.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于9+144 < 196，*b*的索引增加1，符合*步骤6a*。对于16+144，25+144和36+144，同样的步骤适用。由于64+144 > 196，*c*的索引减少1，符合*步骤6b*。
- en: 'Since 64 +100 < 196, the index of *b* is increased by 1, conforming to *step
    6a*. The loop stops here since *b* and *c* have met, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于64 +100 < 196，*b*的索引增加1，符合*步骤6a*。循环在这里停止，因为*b*和*c*相遇，如下所示：
- en: '![Figure 15.16 – b and c at the end of the loop](img/Figure_15.16_B15403.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图15.16-循环结束时的b和c](img/Figure_15.16_B15403.jpg)'
- en: Figure 15.16 – b and c at the end of the loop
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.16-循环结束时的b和c
- en: 'Next, conforming to *step 7*, we set *a*=144, *b*=9, and *c*=100\. This process
    is repeated for each *a*. When *a* becomes 100, we find the first Pythagorean
    triplet; that is, *a*=100, *b*=36, and *c*=64, as shown here:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据*步骤7*，我们设置*a*=144，*b*=9，*c*=100。对每个*a*重复此过程。当*a*变为100时，我们找到了第一个勾股定理三元组；即*a*=100，*b*=36，*c*=64，如下所示：
- en: '![Figure 15.17 – A Pythagorean triplet'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.17-勾股定理三元组'
- en: '](img/Figure_15.17_B15403.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_15.17_B15403.jpg)'
- en: Figure 15.17 – A Pythagorean triplet
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.17-勾股定理三元组
- en: 'Let''s put this algorithm into code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个算法写成代码：
- en: '[PRE14]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The complete application is called *PythagoreanTriplets*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*PythagoreanTriplets*。
- en: Coding challenge 15 – Scheduling one elevator
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战15-调度一个电梯
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you''ve been given an array representing the destination
    floors of *n* people. The elevator has a capacity of the given *k*. Initially,
    the elevator and all the people are on floor 0 (ground floor). It takes 1 unit
    of time for the elevator to reach any consecutive floor (up or down) from the
    current floor. Write a snippet of code that will schedule the elevator in such
    a way that we obtain the minimum total time needed to get all the people to their
    destination floors and then return to the ground floor.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你得到了一个表示*n*个人目的地楼层的数组。电梯的容量为给定的*k*。最初，电梯和所有人都在0楼（底楼）。电梯从当前楼层到达任何连续楼层（向上或向下）需要1个时间单位。编写一小段代码，安排电梯，以便我们获得将所有人到达目的地楼层所需的最小总时间，然后返回到地面楼层。'
- en: '**Solution**: Let''s consider that the given array of destinations is *floors*
    = {4, 2, 1, 2, 4} and *k*=3\. So, we have five people: one person for the first
    floor, two people for the second floor, and two people for the fourth floor. The
    elevator can take three people at a time. So, how can we schedule the elevator
    to take these five people to their floors in the shortest amount of time?'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑给定的目的地数组为*floors* = {4, 2, 1, 2, 4}，*k*=3。所以，我们有五个人：一个人去一楼，两个人去二楼，两个人去四楼。电梯一次可以搭载三个人。那么，我们如何安排电梯以最短的时间将这五个人送到他们的楼层呢？'
- en: 'The solution consists of getting the people to their respective floors in descending
    order. Let''s tackle this scenario based on the following image:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案包括按降序将人们送到各自的楼层。让我们根据以下图片来处理这个场景：
- en: '![Figure 15.18 – Scheduling an elevator example](img/Figure_15.18_B15403.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图15.18 - 调度电梯示例](img/Figure_15.18_B15403.jpg)'
- en: Figure 15.18 – Scheduling an elevator example
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.18 - 调度电梯示例
- en: 'Let''s traverse the steps of this scenario:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遍历这个场景的步骤：
- en: This is the initial state. The elevator is on the ground floor and five people
    are ready to take it. Let's consider that the minimum time is 0 (so, 0 units of
    time).
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是初始状态。电梯在地面层，有五个人准备搭乘。让我们假设最小时间为0(所以，0个时间单位)。
- en: In the elevator, we take the people who are going to the 4th floor and the one
    person who is going to the 2nd floor. Remember that we can take a maximum of three
    people at a time. So far, the minimum time is 0.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在电梯中，我们带上了要去四楼的人和要去二楼的一个人。记住我们一次最多可以带三个人。到目前为止，最小时间为0。
- en: The elevator goes up and stops at the 2nd floor. One person gets off. Since
    each floor represents a unit of time, we have a minimum time of 2.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电梯上升并停在二楼。一个人下去。因为每层代表一个时间单位，我们有一个最小时间为2。
- en: The elevator goes up and stops at the 4th floor. The remaining two people get
    off. The minimum time becomes equal to 4.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电梯上升并停在四楼。剩下的两个人下去。最小时间变为4。
- en: At this step, the elevator is empty. It must go down to the ground floor to
    pick up more people. Since it goes down four floors, the minimum time becomes
    8.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步，电梯是空的。它必须下到地面层去接更多的人。因为它下降了四层，最小时间变为8。
- en: We pick up the remaining two people. The minimum time remains as 8.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接上剩下的两个人。最小时间保持为8。
- en: The elevator goes up and stops at the 1st floor. One person gets off. The minimum
    time becomes 9.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电梯上升并停在一楼。一个人下去。最小时间变为9。
- en: The elevator goes up and stops at the 2nd floor. One person gets off. The minimum
    time becomes 10.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电梯上升并停在二楼。一个人下去。最小时间变为10。
- en: At this step, the elevator is empty. It must go down to the ground floor. Since
    it goes down two floors, the minimum time becomes 12.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步，电梯是空的。它必须下到地面层。因为它下降了两层，最小时间变为12。
- en: 'So, the total minimum time is 12\. Based on this scenario, we can elaborate
    the following algorithm:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总最小时间为12。基于这个场景，我们可以详细说明以下算法：
- en: Sort the given array in descending order of destinations.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按目的地降序对给定的数组进行排序。
- en: Create groups of *k* persons. The time needed for each group will be 2 * *floors*[*group*].
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建*k*人的组。每组所需的时间为2 * *floors*[*group*]。
- en: So, sorting our testing data will result in *floors* = {4, 4, 2, 2, 1}. We have
    two groups. One group contains three people (4, 4, 2), while the other group contains
    two people (2, 1). The total minimum time is (2 * *floors*[0]) + (2 * *floors*[3])
    = (2 * 4) + (2 * 2) = 8 + 4 = 12.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对我们的测试数据进行排序将得到*floors* = {4, 4, 2, 2, 1}。我们有两组。一组包含三个人(4, 4, 2)，而另一组包含两个人(2,
    1)。总最小时间为(2 * *floors*[0]) + (2 * *floors*[3]) = (2 * 4) + (2 * 2) = 8 + 4 = 12。
- en: 'In terms of code, we have the following:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下内容：
- en: '[PRE15]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Of course, you may end up choosing a better sorting algorithm. The complete
    application is called *ScheduleOneElevator*. This was the last coding challenge
    of this chapter.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能最终选择了一个更好的排序算法。完整的应用程序称为*ScheduleOneElevator*。这是本章的最后一个编码挑战。
- en: Scheduling multiple elevators
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调度多部电梯
- en: But how do we schedule multiple elevators with an arbitrary number of floors?
    Well, most probably, in an interview, you won't need to implement a solution for
    more than one elevator, but you could be asked how you'd design a solution for
    more.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如何安排多部电梯和任意数量的楼层呢？嗯，在面试中，你可能不需要为多部电梯实现解决方案，但你可能会被问到如何设计一个解决方案。
- en: The problem of scheduling multiple elevators and the algorithm are famous and
    difficult. There is no best algorithm for this problem. In other words, creating
    an algorithm that can be applied to the real-world scheduling of elevators is
    really difficult, and apparently, it is patented.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 调度多部电梯和算法的问题是著名且困难的。对于这个问题并没有最佳算法。换句话说，创建一个可以应用于现实世界电梯调度的算法是非常困难的，而且显然已经被专利保护。
- en: 'The Elevator algorithm (https://en.wikipedia.org/wiki/Elevator_algorithm) is
    a good place to start. Before thinking about how to design a solution for multi-elevators,
    you must make a list of all the assumptions or constraints that you want to consider.
    Every available solution/algorithm has a list of assumptions or constraints referring
    to the number of floors, number of elevators, capacity of each elevator, number
    of average people, rush hour times, elevator speed, load and unload times, and
    so on. Mainly, there are three solutions, as follows:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 电梯算法(https://en.wikipedia.org/wiki/Elevator_algorithm)是一个很好的起点。在考虑如何为多部电梯设计解决方案之前，你必须列出你想要考虑的所有假设或约束条件的清单。每个可用的解决方案/算法都有一个关于楼层数、电梯数量、每部电梯的容量、平均人数、高峰时间、电梯速度、装载和卸载时间等的假设或约束条件的清单。主要有三种解决方案，如下：
- en: '**Sectors**: Each elevator is allocated to a sector (it services a subset of
    floors).'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域**：每部电梯分配到一个区域(它服务一部分楼层)。'
- en: '**Nearest elevator**: Each person is assigned to the nearest elevator (it does
    this based on the elevator''s position, the direction of call, and the current
    direction of the elevator).'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最近的电梯**：每个人被分配到最近的电梯（这是基于电梯的位置、呼叫的方向和电梯当前的方向）。'
- en: '**Nearest elevator with capacity considerations**: This is similar to the nearest
    elevator option, but it takes the load in each elevator into account.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑容量的最近电梯**：这类似于最近电梯选项，但它考虑了每部电梯的负载。'
- en: Sectors
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部门
- en: 'For example, a building that has eight floors and three elevators can be serviced
    like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个有八层楼和三部电梯的建筑可以这样服务：
- en: Elevator 1 serves floors 1, 2, and 3.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电梯1服务1楼、2楼和3楼。
- en: Elevator 2 serves floors 1, 4, and 5.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电梯2服务1楼、4楼和5楼。
- en: Elevator 3 serves floors 1, 6, 7, and 8.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电梯3服务1楼、6楼、7楼和8楼。
- en: Each elevator services the ground floor since the ground floor has the highest
    arrival rate.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 每部电梯都服务一楼，因为一楼的到达率最高。
- en: Nearest elevator
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最近的电梯
- en: 'Allocate a score to each elevator. This score represents the suitability score
    for an elevator when a new person arrives:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为每部电梯分配一个分数。这个分数代表了新人到来时电梯的适用性评分：
- en: '*Toward the call, same direction*: *FS* = (*N +* 2) - *d*'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*朝呼叫方向，相同方向*：*FS* = (*N +* 2) - *d*'
- en: '*Toward the call, opposite direction*: *FS* = (*N*+1) - *d*'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*朝呼叫方向，相反方向*：*FS* = (*N*+1) - *d*'
- en: '*Away from the call*: *FS* = 1'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*远离呼叫*：*FS* = 1'
- en: 'Where, *N* = #Floors – 1, and *d* = distance between elevator and call.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '其中，*N* = #楼层 - 1，*d* = 电梯和呼叫之间的距离。'
- en: Nearest elevator with capacity considerations
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑容量的最近电梯
- en: 'This is exactly the same as the nearest elevator situation, but it takes into
    account the excess capacity of the elevator:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这与最近电梯的情况完全相同，但它考虑了电梯的多余容量：
- en: '*Toward the call, same direction*: *FS* = (*N* + 2) - *d* + *C*'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*朝呼叫方向，相同方向*：*FS* = (*N* + 2) - *d* + *C*'
- en: '*Toward the call, opposite direction*: *FS* = (*N* + 1) - *d* + *C*'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*朝呼叫方向，相反方向*：*FS* = (*N* + 1) - *d* + *C*'
- en: '*Away from the call*: *FS* = 1 + *C*'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*远离呼叫*：*FS* = 1 + *C*'
- en: 'Here, *N* is #Floors – 1, *d* is the distance between the elevator and the
    call, and *C* is the excess capacity.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*N*是#楼层 - 1，*d*是电梯和呼叫之间的距离，*C*是多余容量。
- en: 'I strongly recommend that you search and study different implementations for
    this problem and try to learn the one that you find the most suitable for you.
    I suggest that you start from here:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你搜索和学习这个问题的不同实现，并尝试学习你认为最适合你的那个。我建议你从这里开始：
- en: '[https://github.com/topics/elevator-simulation](https://github.com/topics/elevator-simulation)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/topics/elevator-simulation](https://github.com/topics/elevator-simulation)'
- en: '[https://austingwalters.com/everyday-algorithms-elevator-allocation/](https://austingwalters.com/everyday-algorithms-elevator-allocation/).'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://austingwalters.com/everyday-algorithms-elevator-allocation/](https://austingwalters.com/everyday-algorithms-elevator-allocation/).'
- en: Now, let's summarize this chapter.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们总结一下这一章。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the most popular problems that fit into the mathematics
    and puzzles categories. While many companies avoid such problems, there are still
    major players such as Google and Amazon that rely on these kinds of problems in
    their interviews.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了最受欢迎的数学和谜题类问题。虽然许多公司避免这类问题，但仍然有像谷歌和亚马逊这样的主要参与者在面试中依赖这类问题。
- en: Practicing such problems represents a good exercise for our brains. Besides
    the math knowledge, these problems sustain analytical thinking based on deductions
    and intuition, which means they are great support for any programmer.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 练习这些问题对我们的大脑是一个很好的锻炼。除了数学知识，这些问题还能够支持基于推理和直觉的分析思维，这意味着它们对任何程序员都是很好的支持。
- en: 'In the next chapter, we''ll tackle a hot topic in interviews: concurrency (multithreading).'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论面试中的一个热门话题：并发（多线程）。
