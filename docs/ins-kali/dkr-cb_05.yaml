- en: Chapter 5. Docker Use Cases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。Docker使用案例
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Testing with Docker
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker进行测试
- en: Doing CI/CD with Shippable and Red Hat OpenShift
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Shippable和Red Hat OpenShift进行CI/CD
- en: Doing CI/CD with Drone
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Drone进行CI/CD
- en: Setting up PaaS with OpenShift Origin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenShift Origin设置PaaS
- en: Building and deploying an app on OpenShift v3 from the source code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在OpenShift v3上构建和部署应用程序的源代码
- en: Configuring Docker as a hypervisor driver for Openstack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Docker配置为Openstack的hypervisor驱动程序
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Now we know how to work with containers and images. In the last chapter, we
    also saw how to link containers and share data between the host and other containers.
    We also saw how containers from one host can communicate with other containers
    from other hosts.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用容器和镜像。在上一章中，我们还看到了如何链接容器并在主机和其他容器之间共享数据。我们还看到了来自一个主机的容器如何与其他主机的容器进行通信。
- en: 'Now let''s look at different use cases of Docker. Let''s list a few of them
    here:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看Docker的不同用例。这里列举了其中的一些：
- en: '**Quick prototyping of ideas**: This is one of my favorite use cases. Once
    we have an idea, it is very easy to prototype it with Docker. All we have to do
    is set up containers to provide all the backend services we need and connect them
    together. For example, to set up a LAMP application, get the web and DB servers
    and link them, as we saw in the previous chapter.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速原型设计**：这是我最喜欢的用例之一。一旦我们有了一个想法，使用Docker很容易进行原型设计。我们所需要做的就是设置容器来提供我们需要的所有后端服务，并将它们连接在一起。例如，要设置一个LAMP应用程序，获取Web和DB服务器并将它们链接在一起，就像我们在上一章中看到的那样。'
- en: '**Collaboration and distribution**: GitHub is one of the best examples of collaborating
    and distributing the code. Similarly, Docker provides features such as Dockerfile,
    registry, and import/export to share and collaborate with others. We have covered
    all this in earlier chapters.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作和分发**：GitHub是协作和分发代码的最佳示例之一。同样，Docker提供了Dockerfile、注册表和导入/导出等功能，以与他人共享和协作。我们在之前的章节中已经涵盖了所有这些内容。'
- en: '**Continuous Integration** (**CI**): The following definition on Martin Fowler''s
    website ([http://www.martinfowler.com/articles/continuousIntegration.html](http://www.martinfowler.com/articles/continuousIntegration.html))
    covers it all:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）：Martin Fowler网站上的以下定义（[http://www.martinfowler.com/articles/continuousIntegration.html](http://www.martinfowler.com/articles/continuousIntegration.html)）涵盖了所有内容：'
- en: '*"Continuous Integration is a software development practice where members of
    a team integrate their work frequently, usually each person integrates at least
    daily - leading to multiple integrations per day. Each integration is verified
    by an automated build (including test) to detect integration errors as quickly
    as possible. Many teams find that this approach leads to significantly reduced
    integration problems and allows a team to develop cohesive software more rapidly.
    This article is a quick overview of Continuous Integration summarizing the technique
    and its current usage."*'
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"持续集成是一个软件开发实践，团队成员经常集成他们的工作，通常每个人至少每天集成一次 - 导致每天多次集成。每次集成都由自动构建（包括测试）进行验证，以尽快检测集成错误。许多团队发现这种方法大大减少了集成问题，并允许团队更快地开发一致的软件。本文是持续集成的快速概述，总结了该技术及其当前用法。"*'
- en: 'Using recipes from other chapters, we can build an environment for CI using
    Docker. You can create your own CI environment or get services from companies
    such as Shippable and Drone. We''ll see how Shippable and Drone can be used for
    CI work later in this chapter. Shippable is not a hosted solution but Drone is,
    which can give you better control. I thought it would be helpful if I talk about
    both of them here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其他章节的示例，我们可以使用Docker构建一个CI环境。您可以创建自己的CI环境，也可以从Shippable和Drone等公司获取服务。我们将在本章后面看到如何使用Shippable和Drone进行CI工作。Shippable不是托管解决方案，但Drone是，它可以给您更好的控制。我认为在这里谈论它们两个会很有帮助：
- en: '**Continuous Delivery** (**CD**): The next step after CI is Continuous Delivery,
    through which we can deploy our code rapidly and reliably to our customers, the
    cloud and other environments without any manual work. In this chapter, we''ll
    see how we can automatically deploy an app on Red Hat OpenShift through Shippable
    CI.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续交付（CD）：CI之后的下一步是持续交付，通过这一步，我们可以将我们的代码快速可靠地部署到我们的客户、云和其他环境中，而无需任何手动工作。在本章中，我们将看到如何通过Shippable
    CI自动部署Red Hat OpenShift上的应用程序。
- en: '**Platform-as-a-Service** (**PaaS**): Docker can be used to build your own
    PaaS. It can be deployed using tools/platforms such as OpenShift, CoreOS, Atomic,
    Tsuru, and so on. Later in this chapter, we''ll see how to set up PaaS using OpenShift
    Origin ([https://www.openshift.com/products/origin](https://www.openshift.com/products/origin)).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台即服务（PaaS）：Docker可以用于构建您自己的PaaS。它可以使用OpenShift、CoreOS、Atomic、Tsuru等工具/平台进行部署。在本章后面，我们将看到如何使用OpenShift
    Origin（[https://www.openshift.com/products/origin](https://www.openshift.com/products/origin)）设置PaaS。
- en: Testing with Docker
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker进行测试
- en: While doing the development or QA, it will be helpful if we can check our code
    against different environments. For example, we may wish to check our Python code
    between different versions of Python or on different distributions such as Fedora,
    Ubuntu, CentOS, and so on. For this recipe, we will pick up sample code from Flask's
    GitHub repository, which is a microframework for Python ([http://flask.pocoo.org/](http://flask.pocoo.org/)).
    I chose this to keep things simple, and it is easier to use for other recipes
    as well.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发或QA期间，如果我们可以针对不同的环境检查我们的代码，将会很有帮助。例如，我们可能希望在不同版本的Python或不同发行版（如Fedora、Ubuntu、CentOS等）之间检查我们的Python代码。对于这个配方，我们将从Flask的GitHub存储库中挑选示例代码，这是一个用于Python的微框架（[http://flask.pocoo.org/](http://flask.pocoo.org/)）。我选择这个是为了保持简单，并且它也更容易用于其他配方。
- en: For this recipe, we will create images to have one container with Python 2.7
    and other with Python 3.3\. We'll then use a sample Python test code to run against
    each container.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将创建图像，其中一个容器带有Python 2.7，另一个带有Python 3.3。然后，我们将使用一个示例Python测试代码来针对每个容器运行。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'As we are going to use example code from Flask''s GitHub repository, let''s
    clone it:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们将使用Flask的GitHub存储库中的示例代码，让我们克隆它：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a `Dockerfile_2.7` file as follows and then build an image from it:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`Dockerfile_2.7`的文件，然后从中构建一个图像：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To build the `python2.7test` image, run the following command:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要构建`python2.7test`图像，请运行以下命令：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Similarly, create a Dockerfile with `python:3.3` as the base image and build
    the `python3.3test` image:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，创建一个以`python:3.3`为基础图像的Dockerfile，并构建`python3.3test`图像：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To build the image, run the following command:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要构建图像，请运行以下命令：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Make sure both the images are created.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 确保两个图像都已创建。
- en: '![Getting ready](../Images/image00347.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](../Images/image00347.jpeg)'
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Now, using Docker''s volume feature, we will mount the external directory that
    contains the source code and test cases. To test with Python 2.7, do the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用Docker的卷功能，我们将挂载包含源代码和测试用例的外部目录。要使用Python 2.7进行测试，请执行以下操作：
- en: 'Go to the directory that contains the Flask examples:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到包含Flask示例的目录：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Start a container with the `python2.7` test image and mount `blueprintexample`
    under `/test`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个带有`python2.7`测试镜像并在`/test`下挂载`blueprintexample`的容器：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![How to do it…](../Images/image00348.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法...](../Images/image00348.jpeg)'
- en: 'Similarly, to test with Python 3.3, run the following command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，要使用Python 3.3进行测试，请运行以下命令：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While running the preceding test on Fedora/RHEL/CentOS where SELinux is enabled,
    you will get a `Permission denied` error. To fix it, relabel the host directory
    while mounting it within the container as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启用SELinux的Fedora/RHEL/CentOS上运行上述测试时，您将收到“权限被拒绝”的错误。要解决此问题，请在容器内挂载主机目录时重新标记主机目录，如下所示：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more details on SELinux, please look at [Chapter 9](part0092.xhtml#aid-2NNJO2
    "Chapter 9. Docker Security"), *Docker Security*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有关SELinux的更多详细信息，请参阅[第9章](part0092.xhtml#aid-2NNJO2 "第9章。Docker安全性")，“Docker安全性”。
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: As you can see from the Dockerfile, before running CMD, which runs the `py.test`
    binary, we change our working directory to `/test`. And while starting the container,
    we mount our source code to `/test`. So, as soon as the container starts, it will
    run the `py.test` binary and run tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从Dockerfile中可以看出，在运行`py.test`二进制文件的CMD之前，我们将工作目录更改为`/test`。在启动容器时，我们将源代码挂载到`/test`。因此，一旦容器启动，它将运行`py.test`二进制文件并运行测试。
- en: There's more…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we have seen how to test our code with different versions of
    Python. Similarly, you can pick up different base images from Fedora, CentOS,
    Ubuntu and test them on different Linux distributions.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们已经看到了如何使用不同版本的Python来测试我们的代码。同样，您可以从Fedora、CentOS、Ubuntu中选择不同的基本镜像，并在不同的Linux发行版上进行测试。
- en: If you use Jenkins in your environment, then you can use its Docker plugin to
    dynamically provision a slave, run a build, and tear it down on the Docker host.
    More details about this can be found at [https://wiki.jenkins-ci.org/display/JENKINS/Docker+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Docker+Plugin).
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在环境中使用Jenkins，则可以使用其Docker插件动态提供从机器，运行构建并在Docker主机上关闭它。有关此的更多详细信息，请访问[https://wiki.jenkins-ci.org/display/JENKINS/Docker+Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Docker+Plugin)。
- en: Doing CI/CD with Shippable and Red Hat OpenShift
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Shippable和Red Hat OpenShift进行CI/CD
- en: In the preceding recipe, we saw an example of how Docker can be used for testing
    in a local Dev and QA environment. Let's look at an end-to-end example to see
    how Docker is now used in the CI/CD environment. In this recipe, we'll see how
    we can use Shippable ([http://www.shippable.com/](http://www.shippable.com/))
    to perform CI/CD and deploy it on Red Hat's OpenShift environment ([https://openshift.redhat.com](https://openshift.redhat.com)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们看到了Docker如何在本地开发和QA环境中用于测试的示例。让我们看一个端到端的示例，看看Docker现在如何在CI/CD环境中使用。在这个示例中，我们将看到如何使用Shippable
    ([http://www.shippable.com/](http://www.shippable.com/)) 进行CI/CD并将其部署在Red Hat的OpenShift环境
    ([https://openshift.redhat.com](https://openshift.redhat.com))。
- en: 'Shippable is a SaaS platform that lets you easily add Continuous Integration/Deployment
    to your GitHub and Bitbucket(Git) repositories, which is completely built on Docker.
    Shippable uses build minions, which are Docker-based containers, to run workloads.
    Shippable supports many languages such as Ruby, Python, Node.js, Java, Scala,
    PHP, Go, and Clojure. The default build minions are of Ubuntu 12.04 LTS and Ubuntu
    14.04\. They have also added support to use custom images from Docker Hub as minions.
    Shippable CI needs information about the project and build instructions in a `yml`
    file called `shippable.yml`, which you have to provide in your source code repo.
    The `yml` file contains the following instructions:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Shippable是一个SaaS平台，可以让您轻松地将持续集成/部署添加到您的GitHub和Bitbucket(Git)存储库中，它完全建立在Docker上。Shippable使用构建minions，这些是基于Docker的容器，用于运行工作负载。Shippable支持许多语言，如Ruby、Python、Node.js、Java、Scala、PHP、Go和Clojure。默认的构建minions是Ubuntu
    12.04 LTS和Ubuntu 14.04。他们还添加了支持使用来自Docker Hub的自定义镜像作为minions。Shippable CI需要关于项目和构建指令的信息，这些信息存储在名为`shippable.yml`的`yml`文件中，您必须在源代码存储库中提供。`yml`文件包含以下指令：
- en: '`build_image`: This is a Docker image to use to build'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build_image`：这是用于构建的Docker镜像'
- en: '`language`: This will show the programming language'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`language`：这将显示编程语言'
- en: '`versions`: You can specify different versions of the language to get tested
    in a single build instruction.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`versions`：您可以指定不同版本的语言以在单个构建指令中进行测试。'
- en: '`before_install`: These are the instructions before running the build'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before_install`：这些是在运行构建之前的指令'
- en: '`script`: This is a binary/script to run the test'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script`：这是一个用于运行测试的二进制/脚本'
- en: '`after_success`: These are instructions after the build succeeds; this is used
    to perform deployment on PaaS such as Heroku, Amazon Elastic Beanstalk, AWS OpsWorks,
    Google App Engine, Red Hat OpenShift, and others.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after_success`：这些是构建成功后的指令；这用于在PaaS上执行部署，如Heroku、Amazon Elastic Beanstalk、AWS
    OpsWorks、Google App Engine、Red Hat OpenShift等。'
- en: Red Hat's OpenShift is a PaaS platform to host your application. Currently,
    it uses non-Docker based container technology to host the application, but the
    next version of OpenShift ([https://github.com/openshift/origin](https://github.com/openshift/origin))
    is being built on Kubernetes and Docker. This tells us the pace at which Docker
    is being adopted in the enterprise world. We'll see how to set up OpenShift v3
    later in this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Red Hat的OpenShift是一个用于托管应用程序的PaaS平台。目前，它使用非基于Docker的容器技术来托管应用程序，但下一个版本的OpenShift([https://github.com/openshift/origin](https://github.com/openshift/origin))正在基于Kubernetes和Docker构建。这告诉我们Docker在企业世界中被采用的速度。我们将在本章后面看到如何设置OpenShift
    v3。
- en: For this recipe, we will use the same example code we used in the previous recipe,
    to first test on Shippable and then deploy it on OpenShift.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用在上一个食谱中使用的相同示例代码，首先在Shippable上进行测试，然后在OpenShift上部署它。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create an account on Shippable ([https://www.shippable.com/](https://www.shippable.com/)).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Shippable上创建一个帐户([https://www.shippable.com/](https://www.shippable.com/))。
- en: Fork the flask example from [https://github.com/openshift/flask-example](https://github.com/openshift/flask-example).
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://github.com/openshift/flask-example](https://github.com/openshift/flask-example)派生flask示例。
- en: 'Create an app on OpenShift for the forked repository with the following steps:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenShift上为派生存储库创建一个应用程序，具体步骤如下：
- en: Create an account ([https://www.openshift.com/app/account/new](https://www.openshift.com/app/account/new))
    on OpenShift and log in.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenShift上创建一个帐户([https://www.openshift.com/app/account/new](https://www.openshift.com/app/account/new))并登录。
- en: Select **Python 2.7 Cartridge** for the application.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为应用程序选择**Python 2.7 Cartridge**。
- en: Update the **Public URL** section you want. In the **Source Code** section,
    provide the URL of our forked repo. For this example, I have put down `blueprint`
    and `https://github.com/nkhare/flask-example` respectively:![Getting ready](../Images/image00349.jpeg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您想要的**Public URL**部分。在**Source Code**部分，提供我们分叉存储库的URL。对于本示例，我分别放下了`blueprint`和`https://github.com/nkhare/flask-example`：![准备就绪](../Images/image00349.jpeg)
- en: Click on **Create Application** to create the new app. Once created, you should
    be able to access the Public URL we mentioned in the previous step.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Create Application**创建新应用程序。创建后，您应该能够访问我们在上一步中提到的公共URL。
- en: Once the app is created, OpenShift provides a way to manage/update the source
    code for this app in the `Making code changes` section. As we want to deploy the
    app using Shippable, we don't have to follow those instructions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序后，OpenShift提供了一种在`进行代码更改`部分管理/更新此应用程序的源代码的方法。由于我们希望使用Shippable部署应用程序，因此无需遵循这些说明。
- en: 'Clone the forked repository on the local system:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地系统上克隆分叉存储库：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s use the same blueprint example that we used earlier. To do so, follow
    these instructions:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用之前使用过的相同蓝图示例。要这样做，请按照以下说明进行操作：
- en: 'Clone the flask repository:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆flask存储库：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Copy the blueprint example:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制蓝图示例：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Update the `flask-example/wsgi/application` file to import the `app` module
    from the `blueprintexample` module. So, the last line in the `flask-example/wsgi/application`
    file looks like the following:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`flask-example/wsgi/application`文件，从`blueprintexample`模块导入`app`模块。因此，`flask-example/wsgi/application`文件中的最后一行看起来像下面这样：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the `requirements.txt` file with the following contents at the top level
    of the flask-example repository:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在flask-example存储库的顶层添加带有以下内容的`requirements.txt`文件：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the `shippable.yml` file with following content:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加带有以下内容的`shippable.yml`文件：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Commit the code and push it in your forked repository.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交代码并将其推送到您的分叉存储库中。
- en: How to do it…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Log in to Shippable.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到Shippable。
- en: After logging in, click on **SYNC ACCOUNT** to get your forked repository listed,
    if it has not already been listed. Find and enable the repo that you want to build
    and run tests. For this example, I chose `flask-example` from my GitHub repos.
    After enabling it, you should see something like the following:![How to do it…](../Images/image00350.jpeg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，单击**SYNC ACCOUNT**以获取列出您的分叉存储库，如果尚未列出。查找并启用要构建和运行测试的存储库。在本例中，我选择了我的GitHub存储库中的`flask-example`。启用后，您应该看到类似以下内容：![如何操作...](../Images/image00350.jpeg)
- en: 'Click on the play button and select branch to build. For this recipe, I chose
    master:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击播放按钮并选择要构建的分支。对于本示例，我选择了master：
- en: If the build is successful, then you will see the success icon.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建成功，您将看到成功的图标。
- en: 'Next time you do a commit in your repository, a build on Shippable will be
    triggered and the code will be tested. Now, to perform Continuous Deployment on
    OpenShift, let''s follow the instructions provided on the Shippable website ([http://docs.shippable.com/deployment/openshift/](http://docs.shippable.com/deployment/openshift/)):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下次在存储库中提交代码时，Shippable将触发构建并测试代码。现在，要在OpenShift上执行持续部署，请按照Shippable网站提供的说明进行操作（[http://docs.shippable.com/deployment/openshift/](http://docs.shippable.com/deployment/openshift/)）：
- en: Get the deployment key from your Shippable dashboard (located on the right-hand
    side, below **Repos**):![How to do it…](../Images/image00351.jpeg)
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Shippable仪表板获取部署密钥（位于右侧，**Repos**下方）：![如何操作...](../Images/image00351.jpeg)
- en: Copy it under the ([https://openshift.redhat.com/app/console/settings](https://openshift.redhat.com/app/console/settings))
    **Settings** | **Public** **Keys** section on OpenShift as follows:![How to do
    it…](../Images/image00352.jpeg)
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其复制到OpenShift的([https://openshift.redhat.com/app/console/settings](https://openshift.redhat.com/app/console/settings))
    **Settings** | **Public** **Keys**部分如下所示：![如何操作...](../Images/image00352.jpeg)
- en: Get the **Source Code** repository link from the OpenShift application page,
    which will be used as `OPNESHIFT_REPO` in the next step:![How to do it…](../Images/image00353.jpeg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从OpenShift应用程序页面获取**源代码**存储库链接，它将在下一步中用作`OPNESHIFT_REPO`：![如何操作...](../Images/image00353.jpeg)
- en: 'After the deployment key is installed, update the `shippable.yml` file as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装部署密钥后，更新`shippable.yml`文件如下：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`OPENSHIFT_REPO` should reflect the app you have deployed using OpenShift.
    It will be different from what is shown in this example.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`OPENSHIFT_REPO`应该反映您使用OpenShift部署的应用程序。它将与此示例中显示的内容不同。'
- en: Now commit these changes and push it to GitHub. You will see a build on Shippable
    triggered and a new app deployed on OpenShift.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在提交这些更改并将其推送到GitHub。您将看到Shippable触发的构建以及在OpenShift上部署的新应用程序。
- en: Visit your app's homepage, and you should see its updated contents.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问您的应用主页，您应该看到其更新的内容。
- en: How it works…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'At every build instruction, Shippable spins off new containers depending on
    the image and language type specified in the `shippable.yml` file and runs the
    build to perform testing. In our case, Shippable will spin off two containers,
    one for Python 2.6 and the other for Python 2.7\. Shippable adds a webhook to
    your GitHub repository as follows when you register it with them:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个构建指令中，Shippable会根据`shippable.yml`文件中指定的镜像和语言类型，启动新的容器并运行构建以执行测试。在我们的情况下，Shippable将启动两个容器，一个用于Python
    2.6，另一个用于Python 2.7。当您在GitHub上注册时，Shippable会向您的存储库添加一个webhook，如下所示：
- en: '![How it works…](../Images/image00354.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](../Images/image00354.jpeg)'
- en: So every time a change is committed to GitHub, a build on Shippable gets triggered
    and after the success, it is deployed on OpenShift.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次对GitHub进行提交更改时，Shippable上的构建都会被触发，并在成功后部署到OpenShift上。
- en: See also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Detailed documentation is available on the Shippable website at [http://docs.shippable.com/](http://docs.shippable.com/)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shippable网站上提供了详细的文档，网址为[http://docs.shippable.com/](http://docs.shippable.com/)。
- en: Doing CI/CD with Drone
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Drone进行CI/CD
- en: As mentioned on the Drone website ([https://drone.io/](https://drone.io/)),
    Drone is a hosted Continuous Integration service. It enables you to conveniently
    set up projects to automatically build, test, and deploy as you make changes to
    your code. They provide an open source version of their platform, which you can
    host in your environment or on cloud. As of now, they support languages such as
    C/C++, Dart, Go, Haskell, Groovy, Java, Node.js, PHP, Python, Ruby, and Scala.
    Using Drone, you can deploy your application on platforms such as Heroku, Dotcloud,
    Google App Engine, and S3\. You can also SSH (rsync) your code to a remote server
    for deployment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如Drone网站（[https://drone.io/](https://drone.io/)）上所述，Drone是一个托管的持续集成服务。它使您能够方便地设置项目，以便在对代码进行更改时自动构建、测试和部署。他们提供了他们平台的开源版本，您可以在您的环境或云上进行托管。截至目前，他们支持诸如C/C++、Dart、Go、Haskell、Groovy、Java、Node.js、PHP、Python、Ruby和Scala等语言。使用Drone，您可以将应用程序部署到Heroku、Dotcloud、Google
    App Engine和S3等平台。您还可以通过SSH（rsync）将代码同步到远程服务器进行部署。
- en: For this recipe, let's use the same example that we used in the earlier recipes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，让我们使用之前示例中使用的相同示例。
- en: Getting ready
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Log in to Drone ([https://drone.io/](https://drone.io/)).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到Drone（[https://drone.io/](https://drone.io/)）。
- en: Click on **New Project** and set up repository. In our case, we'll pick the
    same repository from GitHub that we used in the previous recipe ([https://github.com/nkhare/flask-example](https://github.com/nkhare/flask-example)):![Getting
    ready](../Images/image00355.jpeg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**新项目**并设置存储库。在我们的情况下，我们将选择在之前的示例中使用的GitHub上的相同存储库（[https://github.com/nkhare/flask-example](https://github.com/nkhare/flask-example)）：![准备工作](../Images/image00355.jpeg)
- en: Once selected, it will ask you to select the programming language for the selected
    repository. I selected Python in this case.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择了，它会要求您为所选的存储库选择编程语言。在这种情况下，我选择了Python。
- en: 'It will then prompt you to set up the build script. For this recipe, we''ll
    put the following and save it:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后它会提示您设置构建脚本。对于这个教程，我们将输入以下内容并保存：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤如下…
- en: Trigger a manual build by clicking on **Build Now**, as shown in the following
    screenshot:![How to do it…](../Images/image00356.jpeg)
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**立即构建**来触发手动构建，如下面的屏幕截图所示：![操作步骤如下…](../Images/image00356.jpeg)
- en: How it works…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The build process starts a new container, clones the source code repository,
    and runs the commands that we specified in the **Commands** section (running the
    test cases) within it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程启动一个新的容器，克隆源代码存储库，并在其中运行我们在**命令**部分中指定的命令（运行测试用例）。
- en: There's more…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Once the build is complete, you can look at the console output.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建完成后，您可以查看控制台输出。
- en: Drone also adds a webhook in GitHub; so the next time you commit changes in
    the repository, a build will be triggered.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drone还在GitHub中添加了一个Webhook；因此，下次您提交存储库中的更改时，将触发构建。
- en: Drone also supports Continuous Deployment to different cloud environments, as
    we have seen in the earlier recipe. To set that up, go to the **Settings** tab,
    select **Deployment**, and then select **Add New Deployment**. Select your cloud
    provider and set it up:![There's more…](../Images/image00357.jpeg)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drone还支持将应用程序持续部署到不同的云环境，就像我们在之前的教程中看到的那样。要设置这个，转到**设置**选项卡，选择**部署**，然后选择**添加新的部署**。选择您的云提供商并设置它：![还有更多…](../Images/image00357.jpeg)
- en: See also
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The Drone documentation at [http://docs.drone.io/](http://docs.drone.io/)
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drone的文档网址为[http://docs.drone.io/](http://docs.drone.io/)
- en: The steps to configure a self-hosted Drone environment, which is in the alpha
    stage as of now, at [https://github.com/drone/drone](https://github.com/drone/drone)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置自托管的Drone环境的步骤，目前处于alpha阶段，网址为[https://github.com/drone/drone](https://github.com/drone/drone)
- en: Setting up PaaS with OpenShift Origin
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenShift Origin设置PaaS
- en: Platform-as-a-Service is a type of cloud service where the consumer controls
    the software deployments and configuration settings for applications (mostly web),
    and the provider provides servers, networks, and other services to manage those
    deployments. The provider can be external (a public provider) or internal (an
    IT department in an organization). There are many PaaS providers, such as Amazon
    ([http://aws.amazon.com/](http://aws.amazon.com/)), Heroku ([https://www.heroku.com/](https://www.heroku.com/)),
    OpenShift ([https://www.openshift.com/](https://www.openshift.com/)), and so on.
    In the recent past, containers seem to have become the natural choice for applications
    to get deployed to.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 平台即服务是一种云服务类型，其中消费者控制应用程序（主要是Web应用程序）的软件部署和配置设置，提供者提供服务器、网络和其他服务来管理这些部署。提供者可以是外部的（公共提供者）或内部的（组织中的IT部门）。有许多PaaS提供者，例如Amazon
    ([http://aws.amazon.com/](http://aws.amazon.com/))、Heroku ([https://www.heroku.com/](https://www.heroku.com/))、OpenShift
    ([https://www.openshift.com/](https://www.openshift.com/))等。最近，容器似乎已成为应用程序部署的自然选择。
- en: Earlier in this chapter, we looked at how we can build a CI/CD solution using
    Shippable and OpenShift, where we deployed our app to OpenShift PaaS. We deployed
    our app on Openshift Online, which is the Public Cloud Service. At the time of
    writing this book, the OpenShift Public Cloud Service uses non-Docker container
    technology to deploy apps to the Public Cloud Service. The OpenShift team has
    been working on OpenShift v3 ([https://github.com/openshift/origin](https://github.com/openshift/origin)),
    which is a PaaS that leverages technologies such as Docker and Kubernetes ([http://kubernetes.io](http://kubernetes.io))
    among others, providing a complete ecosystem to service your cloud-enabled apps.
    They plan to move this to the Public Cloud Service later this year. As we have
    talked about Kubernetes in [Chapter 8](part0081.xhtml#aid-2D7TI1 "Chapter 8. Docker
    Orchestration and Hosting Platforms"), *Docker Orchestration and Hosting Platforms*,
    it is highly recommended to read that chapter first before continuing with this
    recipe. I am going to borrow some of the concepts from that chapter.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们看了如何使用Shippable和OpenShift构建CI/CD解决方案，我们将我们的应用程序部署到OpenShift PaaS。我们在Openshift
    Online上部署了我们的应用程序，这是公共云服务。在撰写本书时，OpenShift公共云服务使用非Docker容器技术将应用程序部署到公共云服务。OpenShift团队一直在开发OpenShift
    v3 ([https://github.com/openshift/origin](https://github.com/openshift/origin))，这是一个利用Docker和Kubernetes
    ([http://kubernetes.io](http://kubernetes.io))等技术的PaaS，为您的云启用应用程序提供了一个完整的生态系统。他们计划在今年晚些时候将其移至公共云服务。正如我们在[第8章](part0081.xhtml#aid-2D7TI1
    "第8章。Docker编排和托管平台")，“Docker编排和托管平台”中所讨论的，强烈建议在继续本教程之前先阅读该章节。我将借用该章节中的一些概念。
- en: '![Setting up PaaS with OpenShift Origin](../Images/image00358.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![使用OpenShift Origin设置PaaS](../Images/image00358.jpeg)'
- en: '[https://blog.openshift.com/openshift-v3-deep-dive-docker-kubernetes/](https://blog.openshift.com/openshift-v3-deep-dive-docker-kubernetes/)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://blog.openshift.com/openshift-v3-deep-dive-docker-kubernetes/](https://blog.openshift.com/openshift-v3-deep-dive-docker-kubernetes/)'
- en: Kubernetes provides container cluster management with features such as scheduling
    pods and service discovery, but it does not have the concept of complete application,
    as well as the capabilities to build and deploy Docker images from the source
    code. OpenShift v3 extends the base Kubernetes model and fills those gaps. If
    we fast-forward and look at [Chapter 8](part0081.xhtml#aid-2D7TI1 "Chapter 8. Docker
    Orchestration and Hosting Platforms"), *Docker Orchestration and Hosting Platforms*,
    for the Kubernetes section, you will notice that to deploy an app, we need to
    define Pods, Services, and Replication-Controllers. OpenShift v3 tries to abstract
    all that information and let you define one configuration file that takes care
    of all the internal wiring. Furthermore, OpenShift v3 provides other features
    such as automated deployment through source code push, the centralized administration
    and management of an application, authentication, team and project isolation,
    and resource tracking and limiting, all of which are required for enterprise deployment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了容器集群管理的功能，如调度pod和服务发现，但它没有完整应用程序的概念，也没有从源代码构建和部署Docker镜像的能力。OpenShift
    v3扩展了基本的Kubernetes模型，并填补了这些空白。如果我们快进并查看[第8章](part0081.xhtml#aid-2D7TI1 "第8章。Docker编排和托管平台")，“Docker编排和托管平台”，对于Kubernetes部分，您会注意到要部署一个应用程序，我们需要定义Pods、Services和Replication-Controllers。OpenShift
    v3试图将所有这些信息抽象出来，并让您定义一个配置文件，该文件负责处理所有内部连接。此外，OpenShift v3还提供其他功能，如通过源代码推送进行自动部署，集中管理和管理应用程序，身份验证，团队和项目隔离，以及资源跟踪和限制，所有这些都是企业部署所需的。
- en: In this recipe, we will set up all-in-one OpenShift v3 Origin on a VM and start
    a pod. In the next recipe, we will see how to build and deploy an app through
    source code using the **Source-to-image** (**STI**) build feature. As there is
    active development happening on OpenShift v3 Origin, I have selected a tag from
    the source code and used that code-base in this recipe and the next one. In the
    newer version, the command-line options may change. With this information in hand,
    you should be able to adapt to the latest release. The latest example can be found
    at [https://github.com/openshift/origin/tree/master/examples/hello-openshift](https://github.com/openshift/origin/tree/master/examples/hello-openshift).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将在VM上设置全功能的OpenShift v3 Origin并启动一个pod。在下一个示例中，我们将看到如何使用**源到镜像**（**STI**）构建功能通过源代码构建和部署应用程序。由于OpenShift
    v3 Origin正在进行积极的开发，我从源代码中选择了一个标签，并在这个示例和下一个示例中使用了该代码库。在更新的版本中，命令行选项可能会发生变化。有了这些信息，您应该能够适应最新的发布版本。最新的示例可以在[https://github.com/openshift/origin/tree/master/examples/hello-openshift](https://github.com/openshift/origin/tree/master/examples/hello-openshift)找到。
- en: Getting ready
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Set up Vagrant ([https://www.vagrantup.com/](https://www.vagrantup.com/)) and
    install the VirtualBox provider ([https://www.virtualbox.org/](https://www.virtualbox.org/)).
    The instructions on how to set these up are outside the scope of this book.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Vagrant ([https://www.vagrantup.com/](https://www.vagrantup.com/))并安装VirtualBox提供程序([https://www.virtualbox.org/](https://www.virtualbox.org/))。如何设置这些内容的说明超出了本书的范围。
- en: 'Clone the OpenShift Origin repository:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆OpenShift Origin存储库：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check out the `v0.4.3` tag:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检出`v0.4.3`标签：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Start the VM:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动虚拟机：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Log in to the container:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到容器：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How to do it…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Build the OpenShift binary:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建OpenShift二进制文件：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Go to the `hello-openshift` examples:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`hello-openshift`示例：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Start all the OpenShift services in one daemon:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个守护进程中启动所有OpenShift服务：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: OpenShift services are secured by TLS. Our client will need to accept the server
    certificates and present its own client certificate. Those are generated as part
    of Openshift start in the current working directory.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenShift服务由TLS保护。我们的客户端需要接受服务器证书并呈现自己的客户端证书。这些证书是作为Openshift启动的一部分在当前工作目录中生成的。
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create the pod from the `hello-pod.json` definition:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据`hello-pod.json`定义创建pod：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![How to do it…](../Images/image00359.jpeg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](../Images/image00359.jpeg)'
- en: 'Connect to the pod:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到pod：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When OpenShift starts, all Kubernetes services start as well. Then, we connect
    to the OpenShift master through CLI and request it to start a pod. That request
    is then forwarded to Kubernetes, which starts the pod. In the pod configuration
    file, we mentioned to map port `6061` of the host machine with port `8080` of
    the pod. So, when we queried the host on port `6061`, we got a reply from the
    pod.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当OpenShift启动时，所有Kubernetes服务也会启动。然后，我们通过CLI连接到OpenShift主服务器，并请求它启动一个pod。该请求然后转发到Kubernetes，Kubernetes启动了pod。在pod配置文件中，我们提到将主机机器的端口`6061`映射到pod的端口`8080`。因此，当我们在端口`6061`上查询主机时，我们从pod得到了回复。
- en: There's more…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you run the `docker ps` command, you will see the corresponding containers
    running.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行`docker ps`命令，将看到相应的容器正在运行。
- en: See also
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Learn More* section on [https://github.com/openshift/origin](https://github.com/openshift/origin)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/openshift/origin](https://github.com/openshift/origin)上的*了解更多*部分
- en: The OpenShift 3 beta 3 Video tutorial at [https://blog.openshift.com/openshift-3-beta-3-training-commons-briefing-12/](https://blog.openshift.com/openshift-3-beta-3-training-commons-briefing-12/)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://blog.openshift.com/openshift-3-beta-3-training-commons-briefing-12/](https://blog.openshift.com/openshift-3-beta-3-training-commons-briefing-12/)上查看OpenShift
    3 beta 3视频教程
- en: The latest OpenShift training at [https://github.com/openshift/training](https://github.com/openshift/training)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最新的OpenShift培训在[https://github.com/openshift/training](https://github.com/openshift/training)
- en: The OpenShift v3 documentation at [http://docs.openshift.org/latest/welcome/index.html](http://docs.openshift.org/latest/welcome/index.html)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenShift v3文档位于[http://docs.openshift.org/latest/welcome/index.html](http://docs.openshift.org/latest/welcome/index.html)
- en: Building and deploying an app on OpenShift v3 from the source code
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从源代码构建和部署应用程序到OpenShift v3
- en: 'OpenShift v3 provides the build process to build an image from source code.
    The following are the build strategies that one can follow to build images:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift v3提供了从源代码构建镜像的构建过程。以下是可以遵循的构建策略：
- en: '**Docker build**: In this, users will supply to the Docker context (Dockerfiles
    and support files), which can be used to build images. OpenShift just triggers
    the `docker build` command to create the image.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker构建**：在这种情况下，用户将提供Docker上下文（Dockerfiles和支持文件），用于构建镜像。OpenShift只需触发`docker
    build`命令来创建镜像。'
- en: '**Source-to-image (STI) build**: In this, the developer defines the source
    code repository and the builder image, which defines the environment used to create
    the app. STI then uses the given source code and builder image to create a new
    image for the app. More details about STI can be found at [https://github.com/openshift/source-to-image](https://github.com/openshift/source-to-image).'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源到镜像（STI）构建**：在这种情况下，开发人员定义源代码仓库和构建器镜像，后者定义了用于创建应用程序的环境。然后STI使用给定的源代码和构建器镜像为应用程序创建一个新的镜像。有关STI的更多详细信息，请参见[https://github.com/openshift/source-to-image](https://github.com/openshift/source-to-image)。'
- en: '**Custom build**: This is similar to the Docker build strategy, but users might
    customize the builder image that will be used for build execution.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义构建**：这类似于Docker构建策略，但用户可以自定义将用于构建执行的构建器镜像。'
- en: In this recipe, we are going to look at the STI build process. We are going
    to look at sample-app from the OpenShift v3 Origin repo ([https://github.com/openshift/origin/tree/v0.4.3/examples/sample-app](https://github.com/openshift/origin/tree/v0.4.3/examples/sample-app)).
    The corresponding STI build file is located at [https://github.com/openshift/origin/blob/v0.4.3/examples/sample-app/application-template-stibuild.json](https://github.com/openshift/origin/blob/v0.4.3/examples/sample-app/application-template-stibuild.json).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将看一下STI构建过程。我们将查看OpenShift v3 Origin仓库中的sample-app（[https://github.com/openshift/origin/tree/v0.4.3/examples/sample-app](https://github.com/openshift/origin/tree/v0.4.3/examples/sample-app)）。相应的STI构建文件位于[https://github.com/openshift/origin/blob/v0.4.3/examples/sample-app/application-template-stibuild.json](https://github.com/openshift/origin/blob/v0.4.3/examples/sample-app/application-template-stibuild.json)。
- en: In the `BuildConfig` section, we can see that the source is pointing to a GitHub
    repo (`git://github.com/openshift/ruby-hello-world.git`) and the image under the
    `strategy` section is pointing to the `openshift/ruby-20-centos7` image. So, we
    will use the `openshift/ruby-20-centos7` image and build a new image using the
    source from the GitHub repo. The new image, after the build is pushed to the local
    or third-party Docker registry, depending on the settings. The `BuildConfig` section
    also defines triggers on when to trigger a new build, for instance, when the build
    image changes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BuildConfig`部分，我们可以看到源指向GitHub仓库（`git://github.com/openshift/ruby-hello-world.git`），而`strategy`部分下的镜像指向`openshift/ruby-20-centos7`镜像。因此，我们将使用`openshift/ruby-20-centos7`镜像，并使用来自GitHub仓库的源代码构建一个新的镜像。构建后的新镜像将根据设置被推送到本地或第三方Docker注册表。`BuildConfig`部分还定义了何时触发新构建的触发器，例如，当构建镜像发生变化时。
- en: In the same STI build file (`application-template-stibuild.json`), you will
    find multiple `DeploymentConfig` sections, one of each pod. A `DeploymentConfig`
    section has information such as exported ports, replicas, the environment variables
    for the pod, and other info. In simple terms, you can think of `DeploymentConfig`
    as an extended replication controller of Kubernetes. It also has triggers to trigger
    new deployment. Each time a new deployment is created, the `latestVersion` field
    of `DeploymentConfig` is incremented. A `deploymentCause` is also added to `DeploymentConfig`
    describing the change that led to the latest deployment.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个STI构建文件（`application-template-stibuild.json`）中，您会找到多个`DeploymentConfig`部分，每个pod一个。`DeploymentConfig`部分包含诸如导出端口、副本、pod的环境变量和其他信息等信息。简单来说，您可以将`DeploymentConfig`视为Kubernetes的扩展复制控制器。它还有触发器来触发新的部署。每次创建新的部署时，`DeploymentConfig`的`latestVersion`字段会递增。还会向`DeploymentConfig`添加`deploymentCause`，描述导致最新部署的更改。
- en: '`ImageRepository`, which was recently renamed as `ImageStream`, is a stream
    of related images. `BuildConfig` and `DeploymentConfig` watch `ImageStream` to
    look for image changes and react accordingly, based on their respective triggers.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageRepository`，最近更名为`ImageStream`，是一组相关图像。`BuildConfig`和`DeploymentConfig`监视`ImageStream`以查找图像更改并根据各自的触发器做出相应反应。'
- en: The other sections that you will find in the STI build file are services for
    pods (database and frontend), a route for the frontend service through which the
    app can be accessed, and a template. A template describes a set of resources intended
    to be used together that can be customized and processed to produce a configuration.
    Each template can define a list of parameters that can be modified for consumption
    by containers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在STI构建文件中，您还会找到用于pod的服务（数据库和前端）、用于前端服务的路由，通过该路由可以访问应用程序，以及一个模板。模板描述了一组预期一起使用的资源，可以进行自定义和处理以生成配置。每个模板可以定义一组参数，这些参数可以被容器修改后使用。
- en: Similar to STI build, there are examples of Docker and custom build in the same
    sample-app example folder. I am assuming you have the earlier recipe, so we will
    continue from there.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与STI构建类似，在同一个sample-app示例文件夹中有Docker和自定义构建的示例。我假设您已经有了之前的配方，所以我们将从那里继续。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should have completed the earlier recipe, *Setting up PaaS with OpenShift
    Origin*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经完成了之前的配方，*使用OpenShift Origin设置PaaS*。
- en: Your current working directory should be `/data/src/github.com/openshift/origin
    /examples/hello-openshift` inside the VM, started by Vagrant.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您当前的工作目录应该是Vagrant启动的VM内的`/data/src/github.com/openshift/origin /examples/hello-openshift`。
- en: How to do it…
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Deploy a private Docker registry to host images created by the STI build process:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署一个私有的Docker注册表来托管STI构建过程中创建的镜像：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Confirm the registry has started (this can take a few minutes):'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认注册表已启动（这可能需要几分钟）：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![How to do it…](../Images/image00360.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](../Images/image00360.jpeg)'
- en: 'Create a new project in OpenShift. This creates a namespace `test` to contain
    the builds and an app that we will generate later:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在OpenShift中创建一个新项目。这将创建一个命名空间`test`来包含构建和稍后我们将生成的应用程序：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Log in with the `test-admin` user and switch to the `test` project, which will
    be used by every command from now on:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`test-admin`用户登录并切换到`test`项目，从现在开始每个命令都将使用该项目：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Submit the application template for processing (generating shared parameters
    requested in the template) and then request the creation of the processed template:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交应用程序模板进行处理（生成模板中请求的共享参数），然后请求创建处理后的模板：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will not trigger the build. To start the build of your application, run
    the following command:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这不会触发构建。要启动应用程序的构建，请运行以下命令：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Monitor the build and wait for the status to go to `complete` (this can take
    a few minutes):'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监视构建并等待状态变为`complete`（这可能需要几分钟）：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Get the list of services:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取服务列表：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![How to do it…](../Images/image00361.jpeg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](../Images/image00361.jpeg)'
- en: How it works…
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `BuildConfig` (`ruby-sample-build`) section, we specified our source
    as the `ruby-hello-world` Git repo (`git://github.com/openshift/ruby-hello-world.git`)
    and our image as `openshift/ruby-20-centos7`. So the build process takes that
    image, and with STI builder, a new image called `origin-ruby-sample` is created
    after building our source on `openshift/ruby-20-centos7`. The new image is then
    pushed to the Docker registry we created earlier.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BuildConfig`（`ruby-sample-build`）部分，我们将源指定为`ruby-hello-world` Git存储库（`git://github.com/openshift/ruby-hello-world.git`），我们的镜像为`openshift/ruby-20-centos7`。因此，构建过程将使用该镜像，并使用STI构建器，在`openshift/ruby-20-centos7`上构建我们的源后创建一个名为`origin-ruby-sample`的新镜像。然后将新镜像推送到我们之前创建的Docker注册表中。
- en: With `DeploymentConfig`, frontend and backend pods are also deployed and linked
    to corresponding services.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DeploymentConfig`，前端和后端pod也被部署并链接到相应的服务。
- en: There's more…
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The preceding frontend service can be accessed through the service IP and corresponding
    port, but it will not be accessible from the outside world. To make it accessible,
    we give our app an FQDN; for instance, in the following example, it is defined
    as `www.example.com`:![There's more…](../Images/image00361.jpeg)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的前端服务可以通过服务IP和相应的端口访问，但无法从外部访问。为了使其可访问，我们给我们的应用程序一个FQDN；例如，在以下示例中，它被定义为`www.example.com`：![还有更多...](../Images/image00361.jpeg)
- en: OpenShift v3 provides an HAProxy router, which can map over FQDN to the corresponding
    pod. For more information, please visit [http://docs.openshift.org/latest/architecture/core_objects/routing.html](http://docs.openshift.org/latest/architecture/core_objects/routing.html).
    You will also require an entry in the external DNS to resolve the FQDN provided
    here.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift v3提供了一个HAProxy路由器，可以将FQDN映射到相应的pod。有关更多信息，请访问[http://docs.openshift.org/latest/architecture/core_objects/routing.html](http://docs.openshift.org/latest/architecture/core_objects/routing.html)。您还需要在外部DNS中添加一个条目来解析此处提供的FQDN。
- en: 'OpenShift v3 Origin is also a management GUI. To look at our deployed app on
    the GUI, bind the username `test-admin` to the view role in the default namespace
    so you can observe the progress in the web console:'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenShift v3 Origin也是一个管理GUI。要在GUI上查看我们部署的应用程序，请将用户名`test-admin`绑定到默认命名空间中的查看角色，以便您可以在Web控制台中观察进展：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, through the browser, connect to `https://<host>:8443/console` and log
    in through the `test-admin` user by giving any password. As Vagrant forwards the
    traffic of port `8443` on the host machine to the VM, you should be able to connect
    through the host on which VM is running. Then select **OpenShift 3 Sample** as
    the project and explore:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过浏览器，连接到`https://<host>:8443/console`，并通过`test-admin`用户登录，输入任何密码。由于Vagrant将主机机器上端口`8443`的流量转发到VM，您应该能够通过运行VM的主机连接。然后选择**OpenShift
    3 Sample**作为项目并进行探索。
- en: '![There''s more…](../Images/image00362.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](../Images/image00362.jpeg)'
- en: In the multiple node setup, your pods can be scheduled on different systems.
    OpenShift v3 connects pods though the overlay network pod running on one node
    can access another. It is called `openshift-sdn`. For more details, please visit
    [https://github.com/openshift/openshift-sdn](https://github.com/openshift/openshift-sdn).
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多节点设置中，您的pod可以安排在不同的系统上。OpenShift v3通过覆盖网络pod连接pod，运行在一个节点上的pod可以访问另一个节点上的pod。它被称为`openshift-sdn`。有关更多详细信息，请访问[https://github.com/openshift/openshift-sdn](https://github.com/openshift/openshift-sdn)。
- en: See also
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Learn More* section at [https://github.com/openshift/origin](https://github.com/openshift/origin)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/openshift/origin](https://github.com/openshift/origin)的*了解更多*部分
- en: The OpenShift 3 beta 3 video tutorial at [https://blog.openshift.com/openshift-3-beta-3-training-commons-briefing-12/](https://blog.openshift.com/openshift-3-beta-3-training-commons-briefing-12/)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://blog.openshift.com/openshift-3-beta-3-training-commons-briefing-12/](https://blog.openshift.com/openshift-3-beta-3-training-commons-briefing-12/)上有OpenShift
    3 beta 3视频教程
- en: The latest OpenShift training at [https://github.com/openshift/training](https://github.com/openshift/training)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最新的OpenShift培训在[https://github.com/openshift/training](https://github.com/openshift/training)
- en: The OpenShift v3 documentation at [http://docs.openshift.org/latest/welcome/index.html](http://docs.openshift.org/latest/welcome/index.html)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[http://docs.openshift.org/latest/welcome/index.html](http://docs.openshift.org/latest/welcome/index.html)上有OpenShift
    v3文档
- en: Configuring Docker as a hypervisor driver for OpenStack
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Docker配置为OpenStack的虚拟化程序驱动程序
- en: I am assuming that the reader has some exposure to OpenStack for this recipe,
    as covering it is outside the scope of this book. For more information on OpenStack
    and its components, please visit [http://www.openstack.org/software/](http://www.openstack.org/software/).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设读者对OpenStack有一定了解，因为本书不涵盖这方面的内容。有关OpenStack及其组件的更多信息，请访问[http://www.openstack.org/software/](http://www.openstack.org/software/)。
- en: 'In OpenStack, Nova supports different hypervisors for computation, such as
    KVM, XEN, VMware, HyperV, and others. We can provision VMs using these drivers.
    Using Ironic ([https://wiki.openstack.org/wiki/Ironic](https://wiki.openstack.org/wiki/Ironic)),
    you can provision bare metal as well. Nova added support for containers provisioning
    using Docker in the Havana ([https://www.openstack.org/software/havana/](https://www.openstack.org/software/havana/))
    release, but currently, it lives out of the mainline for faster dev cycle. There
    are plans to merge it in the mainline in the future. Under the hood, it looks
    like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenStack中，Nova支持不同的计算虚拟化程序，如KVM、XEN、VMware、HyperV等。我们可以使用这些驱动程序来创建虚拟机。使用Ironic（[https://wiki.openstack.org/wiki/Ironic](https://wiki.openstack.org/wiki/Ironic)），您也可以创建裸金属服务器。Nova在Havana（[https://www.openstack.org/software/havana/](https://www.openstack.org/software/havana/)）版本中添加了对Docker的容器创建支持，但目前它不在主线中，以加快开发周期。未来计划将其合并到主线中。在底层，它看起来像这样：
- en: '![Configuring Docker as a hypervisor driver for OpenStack](../Images/image00363.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![为OpenStack配置Docker作为虚拟化程序驱动程序](../Images/image00363.jpeg)'
- en: '[https://wiki.openstack.org/wiki/File:Docker-under-the-hood.png](https://wiki.openstack.org/wiki/File:Docker-under-the-hood.png)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.openstack.org/wiki/File:Docker-under-the-hood.png](https://wiki.openstack.org/wiki/File:Docker-under-the-hood.png)'
- en: DevStack ([http://docs.openstack.org/developer/devstack/overview.html](http://docs.openstack.org/developer/devstack/overview.html))
    is a collection of scripts to quickly create an OpenStack development environment.
    It is not a general-purpose installer, but it is a very easy way to get started
    with OpenStack. In this recipe, we'll configure DevStack's environment with Docker
    as Nova driver on Fedora21.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: DevStack（[http://docs.openstack.org/developer/devstack/overview.html](http://docs.openstack.org/developer/devstack/overview.html)）是一组脚本，用于快速创建OpenStack开发环境。它不是通用安装程序，但是非常容易开始使用OpenStack的方法。在本教程中，我们将在Fedora21上将DevStack的环境配置为使用Docker作为Nova驱动程序。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Install Docker on the system.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在系统上安装Docker。
- en: 'Clone `nova-docker` and `devstack`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆`nova-docker`和`devstack`：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following step is needed until we can make use of `configure_nova_hypervisor_rootwrap`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以使用`configure_nova_hypervisor_rootwrap`之前需要以下步骤：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Prepare Devstack for installation:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备安装Devstack：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create the stack user and add it to `sudo`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建stack用户并将其添加到`sudo`：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Install `docker-py` to communicate with docker through Python:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python安装`docker-py`以与docker进行通信：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How to do it…
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'After the prerequisite steps are completed, run the following commands to install
    Devstack:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成先决条件步骤后，运行以下命令安装Devstack：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: How it works...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `prepare_devstack.sh` driver makes the following entries in the `localrc`
    file set the right environment to set Docker for the Nova driver:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prepare_devstack.sh`驱动程序在`localrc`文件中进行以下条目的设置，以设置Nova驱动程序的正确环境：'
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'After running the `stackrc` file, we can see the following changes with respect
    to Nova and Glance:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`stackrc`文件后，我们可以看到关于Nova和Glance的以下更改：
- en: 'The `/etc/nova/nova.conf` file changes the compute driver:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/nova/nova.conf`文件更改了计算驱动程序：'
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `/etc/nova/rootwrap.d/docker.filters` file is updated with the following
    content:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/nova/rootwrap.d/docker.filters`文件更新为以下内容：'
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In `/etc/glance/glance-api.conf`, adds `docker` in the container/image format:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`/etc/glance/glance-api.conf`中，在容器/镜像格式中添加`docker`：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There's more…
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In `localrc`, we mentioned `cirros` as the default image, so once the setup
    is completed, we can see that the Docker image for `cirros` is downloaded:![There's
    more…](../Images/image00364.jpeg)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`localrc`中，我们将`cirros`作为默认镜像，因此一旦设置完成，我们可以看到已下载`cirros`的Docker镜像：![更多内容...](../Images/image00364.jpeg)
- en: 'This is being imported to Glance automatically:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动导入到Glance中。
- en: '![There''s more…](../Images/image00365.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](../Images/image00365.jpeg)'
- en: From the preceding screenshot, we can see that the container format is Docker.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们可以看到容器格式是Docker。
- en: Now you can create an instance using a `cirros` image using Horizon, or from
    the command line, and look at the container started using the Docker command line.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在您可以使用Horizon创建一个使用`cirros`镜像的实例，或者从命令行创建一个实例，并查看使用Docker命令行启动的容器。
- en: 'To import any image to Glance, you can do something like the following:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将任何镜像导入Glance，可以执行以下操作：
- en: 'Pull the required image from Docker Hub:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Docker Hub拉取所需的镜像：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Import the image (currently only admin can import the image):'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入镜像（目前只有管理员可以导入镜像）：
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![There''s more…](../Images/image00366.jpeg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![更多内容...](../Images/image00366.jpeg)'
- en: There is a lack of integration with Cinder and Neutron, but things are catching
    up quickly.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cinder和Neutron的集成不足，但情况正在迅速改善。
- en: 'While installing, if you get the `AttributeError: ''module'' object has no
    attribute ''PY2'' error`, then run the following commands to fix it:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在安装过程中，如果出现`AttributeError: ''module'' object has no attribute ''PY2''`错误，则运行以下命令进行修复：'
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: See also
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The documentation on OpenStack website at [https://wiki.openstack.org/wiki/Docker](https://wiki.openstack.org/wiki/Docker).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在OpenStack网站上的文档[https://wiki.openstack.org/wiki/Docker](https://wiki.openstack.org/wiki/Docker)。
- en: Docker is also one of the resource types for OpenStack Heat. Learn more about
    it at [http://docs.openstack.org/developer/heat/template_guide/contrib.html#dockerinc-resource](http://docs.openstack.org/developer/heat/template_guide/contrib.html#dockerinc-resource).
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker也是OpenStack Heat的资源类型之一。在[http://docs.openstack.org/developer/heat/template_guide/contrib.html#dockerinc-resource](http://docs.openstack.org/developer/heat/template_guide/contrib.html#dockerinc-resource)了解更多信息。
- en: There is an interesting project in OpenStack called Kolla, which focuses on
    deploying OpenStack services through Docker containers. Find more about it at
    [https://github.com/stackforge/kolla/](https://github.com/stackforge/kolla/).
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenStack中有一个有趣的项目叫做Kolla，它专注于通过Docker容器部署OpenStack服务。在[https://github.com/stackforge/kolla/](https://github.com/stackforge/kolla/)了解更多信息。
