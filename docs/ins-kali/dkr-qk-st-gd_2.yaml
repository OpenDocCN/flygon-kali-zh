- en: Learning Docker Commands
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Docker命令
- en: In this chapter, we will learn some essential Docker commands. While we focus
    on one of the most important commands, the `container run` command, we will also
    cover many other commands that you will be using every day. These commands include
    the list container command, the stop container command, and the remove container
    command. Along the way, we will also discover other container commands such as
    logs, inspect, stats, attach, exec, and commit. I think you will find this chapter
    to be an excellent foundation for Docker education.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一些基本的Docker命令。虽然我们将重点关注最重要的命令之一，即`container run`命令，但我们也将涵盖许多其他您每天都会使用的命令。这些命令包括列出容器命令、停止容器命令和删除容器命令。在学习过程中，我们还将了解其他容器命令，如日志、检查、统计、附加、执行和提交。我认为您会发现本章对Docker教育是一个很好的基础。
- en: 'BIC: The Bureau of International des Containers was founded in 1933 as a neutral,
    non-profit, international organization whose mission is to promote the safe, secure,
    and sustainable expansion of containerization and intermodal transportation.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: BIC：国际集装箱局成立于1933年，是一个中立的、非营利性的国际组织，其使命是促进集装箱化和联运交通的安全、安全和可持续发展。
- en: 'By the end of this chapter, you will know the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解以下内容：
- en: The current and previous command-line syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前和以前的命令行语法
- en: Both ways to use the version commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用版本命令的两种方式
- en: How to use the `container run` command and many of its optional parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`container run`命令及其许多可选参数
- en: How to start and stop your containers, view information about your containers,
    interact with running containers, and how to save and reuse changes made to your
    containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何启动和停止容器、查看容器信息、与运行中的容器交互，以及如何保存和重用对容器所做的更改
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will be pulling Docker images from Docker's public repo, and installing
    the jq software package, so basic internet access is required to execute the examples
    within this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您将从Docker的公共仓库中拉取Docker镜像，并安装jq软件包，因此需要基本的互联网访问权限来执行本章中的示例。
- en: 'The code files of this chapter can be found on GitHub:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：
- en: '[https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter02](https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter02)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter02](https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter02)'
- en: 'Check out the following video to see the code in action: [http://bit.ly/2P43WNT](http://bit.ly/2P43WNT)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[http://bit.ly/2P43WNT](http://bit.ly/2P43WNT)
- en: Information about command syntax
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令语法信息
- en: Before we dive into learning about Docker commands and their many options, I
    want to inform you of a change to the Docker CLI that happened in January 2017.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入学习Docker命令及其众多选项之前，我想通知您的是Docker CLI在2017年1月发生了变化。
- en: 'The number of commands and associated options have been increasing with each
    new release of Docker. Docker decided that the complexity this was creating needed
    to be addressed. So, with the release of Docker version 1.13 (Docker also changed
    the version numbing scheme in 2017), the CLI commands have been divided into management
    functional groups. For example, there is now a container management group of commands,
    and an image management group of commands. This changes how you run Docker commands.
    Here is an example of the use of the old and new `run` command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个新版本的发布，Docker命令和相关选项的数量都在增加。Docker决定需要解决这种复杂性。因此，随着Docker版本1.13的发布（Docker还在2017年更改了版本编号方案），CLI命令已被划分为管理功能组。例如，现在有一个容器管理组的命令，以及一个镜像管理组的命令。这改变了您运行Docker命令的方式。以下是旧和新`run`命令的使用示例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This change provides better command organization, but also adds some verbosity
    to the command line. It's a trade-off. For now, as far as I know, the old command
    syntax still works for all Docker commands, but for the rest of the examples in
    this book, I am planning to use the new syntax. At least I'll try, as old habits
    die hard.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化提供了更好的命令组织，但也增加了命令行的冗长。这是一个权衡。就我所知，目前为止，旧的命令语法仍然适用于所有Docker命令，但在本书的其余示例中，我打算使用新的语法。至少我会尝试，因为旧习惯难改。
- en: 'One other note I would like to make here is that most command options have
    a short and long format. I will try to share the long format as an option in my
    examples at least once so you will know what the short version stands for. If
    you installed the Docker command-line completion, it will be a helpful resource
    for remembering both the new Docker management-based commands and the parameters
    that can be used with them. Here is a look at the top-level command-completion
    help for the container commands:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我想在这里提一点，大多数命令选项都有短格式和长格式。我会尝试在我的示例中至少分享一次长格式，这样你就会知道短版本代表什么。如果你安装了Docker命令行完成，它将是一个有用的资源，可以记住新的基于Docker管理的命令和可以与之一起使用的参数。这是容器命令的顶级命令完成帮助的样子：
- en: '![](Images/f5fa4bbe-0891-4883-8c95-ddb910ca7e9a.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f5fa4bbe-0891-4883-8c95-ddb910ca7e9a.png)'
- en: 'That command list gives us a sneak peek at some of the commands we are going
    to review in this chapter, so let''s get started with learning Docker commands.
    In [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml), *Setting up a Docker
    Development Environment*, we used two very common Docker commands: the `version`
    command and the `run` command. While you think you know pretty much everything
    there is to know about the `version` command, you may be surprised to learn that
    it has another trick up its sleeve. There is another version of Docker''s version
    command.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令列表让我们提前了解了一些我们将在本章中审查的命令，所以让我们开始学习Docker命令。在[第1章](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml)中，*设置Docker开发环境*，我们使用了两个非常常见的Docker命令：`version`命令和`run`命令。虽然你认为你已经了解了`version`命令的所有内容，但你可能会惊讶地发现它还有另一个技巧。Docker的version命令还有另一个版本。
- en: The version command
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: version命令
- en: 'You have already used the `docker --version` command as a quick test to confirm
    that Docker was installed. Now try the command without the dashes:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用了`docker --version`命令作为一个快速测试来确认Docker是否已安装。现在尝试一下没有破折号的命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This version of the command gives you greater detail about the version of Docker
    installed on your system. It is worth noting that the docker-compose command,
    which we will talk about later, also has two versions of the version command—one
    with the dashes providing a single-line response, and one without the dashes that
    delivers more details.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的命令可以更详细地了解安装在系统上的Docker的版本。值得注意的是，docker-compose命令，我们稍后会谈到，也有两个版本的version命令——一个带有破折号提供单行响应，另一个没有破折号，提供更多细节。
- en: Remember that all the Docker commands have a rich help system built in. Try
    it by entering any part of a Docker command and using the `--help` parameter.
    For example, `docker container run --help`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，所有Docker命令都有一个丰富的帮助系统。尝试输入Docker命令的任何部分并使用`--help`参数来查看。例如，`docker container
    run --help`。
- en: The Docker run command
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker run命令
- en: 'Since we will be using the `run` command a lot, we should take a look at that
    now. You have already used the `run` command in its most basic form:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将经常使用`run`命令，我们现在应该看一下。你已经以其最基本的形式使用了`run`命令：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command tells Docker that you want to run a container based on the image
    described as hello-world. You may be asking yourself, did the hello-world container
    image get installed when I installed Docker? The answer is no. The `docker run`
    command will look at the local container image cache to see whether there is a
    container image that matches the description of the requested container. If there
    is, Docker will run the container from the cached image. If the desired container
    image is not found in the cache, Docker will reach out to a Docker registry to
    try to download the container image, storing it in the local cache in the process.
    Docker will then run the newly-downloaded container from the cache.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令告诉Docker，您想要基于描述为hello-world的镜像运行一个容器。您可能会问自己，当我安装Docker时，hello-world容器镜像是否已安装？答案是否定的。`docker
    run`命令将查看本地容器镜像缓存，以查看是否有与所请求容器描述匹配的容器镜像。如果有，Docker将从缓存的镜像中运行容器。如果在缓存中找不到所需的容器镜像，Docker将访问Docker注册表，尝试下载容器镜像，并在此过程中将其存储在本地缓存中。然后Docker将从缓存中运行新下载的容器。
- en: 'A Docker registry is just a centralized location to store and retrieve Docker
    images. We will talk more about registries and the Docker registry specifically
    later. For now, just understand that there is a local image cache and a remote
    image store. You saw the container not found locally process occur when we ran
    the hello-world container in [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml), *Setting
    up a Docker Development Environment. *Here is what it looks like when Docker does
    not find the container image in the local cache and has to download it from the
    registry:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker注册表只是一个集中存储和检索Docker镜像的地方。我们稍后会更多地讨论注册表和Docker注册表。现在，只需了解有本地镜像缓存和远程镜像存储这一点。当我们在[第1章](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml)中运行hello-world容器时，您看到了本地未找到容器的过程，*设置Docker开发环境。*当Docker在本地缓存中找不到容器镜像并且必须从注册表中下载时，情况是这样的：
- en: '![](Images/8d336a4c-94d9-4a62-832f-c6a370eb84de.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8d336a4c-94d9-4a62-832f-c6a370eb84de.png)'
- en: 'You can pre-seed the local docker cache with container images you plan to run
    by using the docker `pull` command; for example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用docker `pull`命令预先填充本地docker缓存，以便运行您计划运行的容器镜像；例如：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you prefetch the container image with a `pull` command, when you execute
    the docker `run` command, it will find the image in the local cache and not need
    to download it again.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`pull`命令预取容器镜像，当您执行docker `run`命令时，它将在本地缓存中找到镜像，而无需再次下载。
- en: 'You may have noticed in the preceding screenshot that you requested the hello-world container
    image and Docker unsuccessfully searched the local cache and then downloaded the `hello-world:latest` container
    image from the repository. Each container image description is made up of three
    parts:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到在前面的屏幕截图中，您请求了hello-world容器镜像，Docker未能在本地缓存中找到，然后从存储库中下载了`hello-world:latest`容器镜像。每个容器镜像描述由三个部分组成：
- en: Docker registry host name
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker注册表主机名
- en: Slash-separated name
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斜杠分隔的名称
- en: Tag name
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签名称
- en: The first part, the registry host name, we have not seen or used yet, but it
    was included via a default value of the public Docker registry. Whenever you do
    not specify a registry host name, Docker will invisibly use the public Docker
    registry. This registry host name is `docker.io`. The contents of the Docker registry
    can be browsed at [https://hub.docker.com/explore](https://hub.docker.com/explore).
    This is the main public store for Docker images. It is possible to set up and
    use other public or private image registries, and many corporations will do just
    that, setting up their own private Docker image registry. We will talk a little
    more about that in Chapter 8, *Docker and Jenkins*. For now, just understand that
    the first part of a Docker image description is the registry host name that hosts
    the container image. It is worth noting that the registry host name can include
    a port number. This can be used for registries that are configured to serve data
    on a non-default port value.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分，注册表主机名，我们还没有看到或使用过，但它是通过公共Docker注册表的默认值包含的。每当您不指定注册表主机名时，Docker将隐式使用公共Docker注册表。此注册表主机名是`docker.io`。Docker注册表的内容可以在[https://hub.docker.com/explore](https://hub.docker.com/explore)上浏览。这是Docker镜像的主要公共存储库。可以设置和使用其他公共或私有镜像注册表，并且许多公司将这样做，建立自己的私有Docker镜像注册表。我们将在第8章“Docker和Jenkins”中再谈一些相关内容。现在，只需了解Docker镜像描述的第一部分是托管容器镜像的注册表主机名。值得注意的是，注册表主机名可以包括端口号。这可以用于配置为在非默认端口值上提供数据的注册表。
- en: The second part of the container image description is the slash-separated name.
    This part is like a path to, and name of, the container image. There are certain
    official container images that do not need to specify the path. For those images,
    you can simply specify the name portion of the slash-separated name. In our example,
    that is the hello-world part of the description.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像描述的第二部分是斜杠分隔的名称。这部分就像是容器镜像的路径和名称。有一些官方容器镜像不需要指定路径。对于这些镜像，您可以简单地指定斜杠分隔名称的名称部分。在我们的示例中，这是描述的hello-world部分。
- en: 'The third part of the container image description is the tag name. This part
    is considered the version tag for the image, but it does not need to be made up
    of just numbers. The tag name can be any set of ASCII characters, including uppercase
    and lowercase letters, numbers, dashes, underscores, or periods. About the only
    restrictions on tag names are that they cannot start with a period or dash, and
    have to be 128 characters or fewer. The tag name is separated from the slash-separated
    name by a colon. This brings us back to the `hello-world:latest` image description
    we saw earlier. Like the registry host name, there is a default value for the
    tag name. That default value is `latest`. In our example, the tag name being used
    is the default, and it is shown in the search and download as `hello-world:latest`.
    You can see all of this in action in the following example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像描述的第三部分是标签名称。这部分被认为是镜像的版本标签，但它不需要仅由数字组成。标签名称可以是任何一组ASCII字符，包括大写和小写字母，数字，破折号，下划线或句点。关于标签名称的唯一限制是它们不能以句点或破折号开头，并且必须少于128个字符。标签名称与斜杠分隔的名称之间用冒号分隔。这让我们回到之前看到的`hello-world:latest`镜像描述。与注册表主机名一样，标签名称有一个默认值。默认值是`latest`。在我们的示例中，使用的标签名称是默认值，并且在搜索和下载中显示为`hello-world:latest`。您可以在以下示例中看到所有这些内容：
- en: '![](Images/8e50f5e2-4ba1-4a13-962d-84665c6b3369.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8e50f5e2-4ba1-4a13-962d-84665c6b3369.png)'
- en: We confirmed that our local image cache is empty, with the `docker images` command,
    and we then pulled the fully qualified hello-world image to prefetch it into our
    local cache. Then we used the same short description as we did in all of our previous
    hello-world examples, and Docker runs the container without downloading again,
    showing that the default values are used and that they match the fully-qualified
    values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确认了我们的本地镜像缓存是空的，使用`docker images`命令，然后拉取了完全限定的hello-world镜像以预取到我们的本地缓存中。然后我们使用了与之前所有的hello-world示例中相同的简短描述，Docker运行容器而不再次下载，显示使用了默认值并且它们与完全限定的值匹配。
- en: 'Okay, now that we have all of the basics of the Docker `run` command out of
    the way, let''s dig a little deeper and examine some of the optional parameters
    that you can use with the `run` command. If you look at the full `run` command
    syntax, you will see this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们已经了解了Docker `run`命令的所有基础知识，让我们深入一点，检查一些你可以与`run`命令一起使用的可选参数。如果你查看完整的`run`命令语法，你会看到这样的内容：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that the last parts of the command are `[COMMAND] [ARG...]`. This tells
    us that the `container run` command has an optional command parameter that can
    also include its own optional parameters. Docker container images are built with
    a default command that is executed when you run a container based on the image.
    For the hello-world container, the default command is `/hello`. For a full Ubuntu
    OS container, the default command is `bash`. Whenever you run an Ubuntu container
    and don''t specify a command to run in the container, the default command will
    be used. Don''t worry if this doesn''t make much sense yet—we will cover the default
    command and overriding it at runtime later in this chapter in the *Back to the
    Docker run command* section. For now, it is enough to know that when you run a
    container, it will execute a command that is either the default command or, if
    provided to the `container run` command, an override command to execute in the
    running container. One last note: when the command being executed by the running
    container (either default or override) terminates, the container will exit. In
    our examples using the hello-world container, as soon as the `/hello` command
    terminates inside the container, the hello-world container exits. In a moment,
    you will learn more about the difference between a running container and one that
    has exited.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意命令的最后部分是`[COMMAND] [ARG...]`。这告诉我们`container run`命令有一个可选的命令参数，也可以包括自己的可选参数。Docker容器镜像是使用默认命令构建的，当你基于该镜像运行容器时，会执行该默认命令。对于hello-world容器，默认命令是`/hello`。对于完整的Ubuntu
    OS容器，默认命令是`bash`。每当你运行一个Ubuntu容器并且没有指定在容器中运行的命令时，将使用默认命令。如果现在这些还不太清楚，不要担心——我们将在本章的*回到Docker运行命令*部分稍后讨论默认命令和在运行时覆盖它。现在，知道当你运行一个容器时，它将执行一个命令，要么是默认命令，要么是提供给`container
    run`命令的覆盖命令来在运行的容器中执行。最后一点注意：当运行容器的命令（默认或覆盖）终止时，容器将退出。在我们使用hello-world容器的示例中，一旦容器内的`/hello`命令终止，hello-world容器就会退出。一会儿，你将了解更多关于运行中容器和已退出容器之间的区别。
- en: For now, we will continue our `run` command discussion with one of my favorite
    optional parameters, the `--rm` parameter. A little background information is
    required here. As you may recall from [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml), *Setting
    up a Docker Development Environment*, a Docker image is made up of layers. Whenever
    you run a docker container, it is really just using the locally-cached docker
    image (which is a stack of layers), and creating a new layer on top that is a
    read/write layer. All of the execution and changes that occur during the running
    of a container are stored in its own read/write layer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将继续讨论`run`命令的一个我最喜欢的可选参数，即`--rm`参数。这里需要一些背景信息。您可能还记得来自[第1章](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml)的*设置Docker开发环境*，Docker镜像由多个层组成。每当您运行一个Docker容器时，实际上只是使用本地缓存的Docker镜像（这是一堆层），并在其顶部创建一个新的读/写层。在容器运行期间发生的所有执行和更改都存储在其自己的读/写层中。
- en: The list container command
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出容器的命令
- en: 'The indication of a running container can be shown using the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令显示运行中的容器：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is the list containers command, and without any additional parameters,
    it will list the currently-running containers. What do I mean by currently running?
    A container is a special process running on the system, and like other processes
    on the system, a container can stop or exit. However, unlike other types of processes
    on your system, the default behavior for a container is to leave behind its read/write
    layer when it stops. This is because you can restart the container if desired,
    keeping the state data it had when it exited. As an example, imagine you run a
    container that is an OS, such as Ubuntu, and in that container you install `wget`.
    After the container exits, you can restart it, and it will still have `wget` installed.
    Remember that each running container has its own read/write layer, so, if you
    run one Ubuntu container and install `wget`, then you run another Ubuntu container,
    it will not have `wget`. The read/write layers are not shared between containers.
    However, if you restart a container that had the `wget` installed, it will still
    be installed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是列出容器的命令，如果没有任何额外的参数，它将列出当前正在运行的容器。我所说的当前运行是什么意思？容器是在系统上运行的特殊进程，就像系统上的其他进程一样，容器可以停止或退出。然而，与系统上其他类型的进程不同，容器的默认行为是在停止时保留其读/写层。这是因为如果需要，您可以重新启动容器，保持其退出时的状态数据。举个例子，假设您运行一个作为操作系统的容器，比如Ubuntu，在该容器中安装了`wget`。容器退出后，您可以重新启动它，它仍然安装了`wget`。请记住，每个运行的容器都有自己的读/写层，因此，如果您运行一个Ubuntu容器并安装了`wget`，然后运行另一个Ubuntu容器，它将不会有`wget`。读/写层在容器之间不共享。但是，如果重新启动安装了`wget`的容器，它仍然会安装。
- en: 'So, the difference between a running container and a stopped one is that the
    process is either running or it has exited, leaving behind its own read/write
    layer. There is a parameter to the list containers command that allows you to
    list all of the containers, both those running and those that have exited. As
    you may have guessed, it is the `--all` parameter, and it looks like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，运行中的容器和停止的容器之间的区别在于进程是正在运行还是已退出，留下了自己的读/写层。有一个参数可以让您列出所有容器，包括正在运行和已退出的容器。您可能已经猜到了，它是`--all`参数，它看起来像这样：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s go back to one of my favorite optional run command parameters,
    the `--rm` parameter:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到我最喜欢的可选运行命令参数之一，即`--rm`参数：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This parameter instructs Docker to remove the container''s read/write layer
    automatically when the container exits. When you run a docker container without
    the `--rm` parameter, the container data is left behind when the container exits
    so that the container can be restarted again later. If, however, you include the
    `--rm` parameter when you run a container, all of the container''s read/write
    data is removed at the time the container exits. This parameter provides an easy
    clean up on `exit` function that you will often find very helpful. Let''s see
    this with a quick example using the run and `container ls` commands we just discussed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数指示Docker在容器退出时自动删除容器的读/写层。当您运行一个docker容器而没有`--rm`参数时，容器数据在容器退出时会被留下，以便稍后可以重新启动容器。然而，如果在运行容器时包括`--rm`参数，那么在容器退出时所有容器的读/写数据都会被删除。这个参数提供了一个在`exit`时进行简单清理的功能，这在很多情况下都会非常有用。让我们通过一个快速示例来看一下，使用我们刚刚讨论过的run和`container
    ls`命令：
- en: '![](Images/537bbccb-96a6-49ac-8ed4-f80ef15988f7.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/537bbccb-96a6-49ac-8ed4-f80ef15988f7.png)'
- en: First, we confirmed we had the hello-world image in our local cache. Next, we
    listed all of the containers on our system, both running and exited. Note the
    distinction between images and containers. If you are familiar with VMware, the
    analogy would be somewhat like a template and a VM. Next, we ran the hello-world
    container using the `--rm` parameter. The hello-world container prints its message
    and then immediately exits (we redirected the output to `/dev/null` to keep the
    example output short). Next, we listed the containers again, as we saw that the
    hello-world container's read/write data was automatically removed when the container
    exited. After that, we ran the hello-world container again, but this time did
    not use the `--rm` parameter. When we listed the containers this time, we saw
    the indication of the (exited) container. Often you will run a container, knowing
    that you will never need to restart it later, and using the `--rm` parameter to
    automatically clean it up is very handy. But what if you don't use the `--rm`
    parameter? Are you stuck with an ever-growing list of containers? Of course not.
    Docker has a command for that. It is the `container rm` command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们确认我们的本地缓存中有hello-world镜像。接下来，我们列出了系统上所有的容器，包括正在运行和已退出的。请注意镜像和容器之间的区别。如果您熟悉VMware，类似于模板和虚拟机的类比。接下来，我们使用`--rm`参数运行了hello-world容器。hello-world容器打印其消息，然后立即退出（我们将输出重定向到`/dev/null`，以使示例输出变短）。接下来，我们再次列出了容器，因为我们看到hello-world容器的读/写数据在容器退出时被自动删除了。之后，我们再次运行了hello-world容器，但这次没有使用`--rm`参数。当我们这次列出容器时，我们看到了（已退出）容器的指示。通常，您会运行一个容器，知道您以后永远不需要重新启动它，并使用`--rm`参数自动清理它非常方便。但如果您不使用`--rm`参数会怎么样呢？您会被困在一个不断增长的容器列表中吗？当然不会。Docker有一个命令来处理这个问题。那就是`container
    rm`命令。
- en: The remove container command
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除容器命令
- en: 'The remove container command looks something like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 删除容器命令看起来像这样：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The command requires a value that uniquely identifies a container; in this
    case, I used the full container ID for the hello-world container that we just
    ran. You can use the first few characters of a container''s ID, as long as it
    provides a unique identifier between all of the containers on your system. Another
    way to uniquely identify the container is by the `name` assigned to it. Docker
    will provide a unique randomly-generated name for your container when you run
    it. In the preceding example, the random name assigned was `competent_payne`.
    So we could have used the remove command like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '该命令需要一个唯一标识容器的值；在本例中，我使用了刚刚运行的hello-world容器的完整容器ID。您可以使用容器ID的前几个字符，只要它在系统上提供了唯一标识符。另一种唯一标识容器的方法是通过分配给它的`name`。当您运行容器时，Docker将为其提供一个唯一的随机生成的名称。在上面的示例中，分配的随机名称是`competent_payne`。因此，我们可以像这样使用删除命令： '
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While the randomly-generated names provided by docker are more human-readable
    than the container IDs it assigns, they still may not be as relevant as you would
    like. This is why docker has provided an optional parameter to the `run` command
    for naming your containers. Here is an example using the `--name` parameter:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker提供的随机生成的名称比其分配的容器ID更易读，但它们可能仍然不如您希望的那样相关。这就是为什么Docker为`run`命令提供了一个可选参数来为您的容器命名。以下是使用`--name`参数的示例：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now when we list all of the containers, we can see our container has the name
    `hi-earl`. Of course, you would probably want to use a better container name,
    perhaps one that describes the function performed by the container, such as `db-for-earls-app`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们列出所有容器时，我们可以看到我们的容器名称为`hi-earl`。当然，您可能希望使用更好的容器名称，也许是描述容器执行功能的名称，例如`db-for-earls-app`。
- en: 'Note: Like the container IDs, the container names must be unique on a host.
    You cannot have two containers (even if one has exited) that have the same name.
    If you will have more than one container running the same image, such as web server
    image, name them uniquely, for example, web01 and web02.![](Images/9d9bae7d-2569-4d62-b104-0f77cef7e52c.png)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：与容器ID一样，容器名称在主机上必须是唯一的。您不能有两个具有相同名称的容器（即使其中一个已退出）。如果将有多个运行相同镜像的容器，例如Web服务器镜像，请为它们分配唯一的名称，例如web01和web02。![](Images/9d9bae7d-2569-4d62-b104-0f77cef7e52c.png)
- en: 'You can delete multiple containers at the same time by providing the unique
    identifier for each on the command line:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在命令行上提供每个容器的唯一标识符来同时删除多个容器：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Usually, you will remove containers only after they have exited, such as the
    hello-world containers that we have been using. However, sometimes you will want
    to remove a container even if it is currently running. You can use the `--force`
    parameter to handle that situation. Here is an example of using the force parameter
    to remove a running container:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您只会在容器退出后删除容器，例如我们一直在使用的hello-world容器。但是，有时您可能希望删除当前正在运行的容器。您可以使用`--force`参数来处理这种情况。以下是使用force参数删除运行中容器的示例：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is what that would look like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它的样子：
- en: '![](Images/e6d64ba5-07f6-4495-a2d1-b8e9b6964384.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e6d64ba5-07f6-4495-a2d1-b8e9b6964384.png)'
- en: Notice that in the first `container ls` command, we didn't use the `--all` parameter.
    This reminds us that the web server container is running. When we tried to remove
    it, we were informed that the container is still running and would not be removed.
    This is a good safeguard to help prevent the removal of running containers. Next,
    we used the force command, and the running container was removed without any warning.
    Finally, we did another `container ls` command, including the `--all` parameter
    to show that the read/write data for our container was actually removed this time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第一个`container ls`命令中，我们没有使用`--all`参数。这提醒我们Web服务器容器正在运行。当我们尝试删除它时，我们被告知容器仍在运行，不会被删除。这是一个很好的保障，有助于防止删除运行中的容器。接下来，我们使用了强制命令，运行中的容器被删除而没有任何警告。最后，我们进行了另一个`container
    ls`命令，包括`--all`参数，以显示这次实际上删除了我们容器的读/写数据。
- en: If you have set up Docker command completion, you can type in the command up
    to where you need to enter the unique identifier for the container(s) and then
    use the *Tab *key to get a list of containers, tabbing to the one you want to
    delete. Once you've highlighted the container to delete, use the space or *Enter*
    key to select it. You can hit *Tab* again to select another container to delete
    more than one at a time. Once you have all the containers selected, press *Enter*
    to execute the command. Remember that you will only see stopped containers when
    you tab for the `rm` command unless you include the force parameter, `rm -f`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经设置了Docker命令完成，您可以输入命令，直到需要输入容器的唯一标识符，然后使用*Tab*键获取容器列表，切换到您想要删除的容器。一旦您突出显示要删除的容器，使用空格键或*Enter*键进行选择。您可以再次按*Tab*键选择另一个要一次删除多个容器。选择所有容器后，按*Enter*执行命令。请记住，除非包括强制参数`rm
    -f`，否则在为`rm`命令切换时，您只会看到已停止的容器。
- en: 'Sometimes, you may want to remove all of the containers on your system, running
    or not. There is a useful way to handle that situation. You can combine the `container
    ls` command and the container remove command to get the job done. You will be
    using a new parameter on the `container ls` command to accomplish this—the `--quiet`
    parameter. This command instructs Docker to only return the container IDs instead
    of the full list with a header. Here is the command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望删除系统上的所有容器，无论是否正在运行。有一种有用的方法来处理这种情况。您可以结合`container ls`命令和容器删除命令来完成任务。您将使用`container
    ls`命令的新参数来完成这个任务——`--quiet`参数。此命令指示Docker仅返回容器ID，而不是带有标题的完整列表。以下是命令：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we can *feed* the values returned by the `container ls` command as input
    parameters to the container remove command. It will look like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`container ls`命令返回的值作为输入参数提供给容器删除命令。它看起来像这样：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will remove *all* of the containers *both running and exited* from your
    system, so be careful!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从您的系统中删除*所有*容器*运行和退出*，所以要小心！
- en: You will probably use this shortcut often, so creating a system alias for it
    is pretty handy.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能经常使用这个快捷方式，所以为它创建一个系统别名非常方便。
- en: 'You can add something like the following to your `~/.bash_profile` or `~/zshrc`
    file: `alias RMAC=''docker container rm --force $(docker container ls --all --quiet)''`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将以下内容添加到您的`~/.bash_profile`或`~/zshrc`文件中：`alias RMAC='docker container rm
    --force $(docker container ls --all --quiet)'。
- en: 'Many containers are designed to run and exit immediately, such as the hello-world
    example we''ve used several times already. Other container''s images are created
    so that, when you run a container using it, the container will continue running,
    providing some ongoing useful function, such as serving web pages. When you run
    a container that persists, it will hold onto the foreground process until it exits,
    attaching to the processes: standard input, standard output, and standard error.
    This is okay for some testing and development use cases, but normally, this would
    not be desired for a production container. Instead, it would be better to have
    the `container run` as a background process, giving you back control of your terminal
    session once it launches. Of course, there is a parameter for that. It is the
    `--detach` parameter. Here is what using that parameter looks like:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 许多容器被设计为运行并立即退出，例如我们已经多次使用的hello-world示例。其他容器的镜像被创建为，当您使用它运行容器时，容器将继续运行，提供一些持续有用的功能，例如提供网页服务。当您运行一个持久的容器时，它将保持前台进程直到退出，并附加到进程：标准输入、标准输出和标准错误。这对于一些测试和开发用例来说是可以的，但通常情况下，这不适用于生产容器。相反，最好将`container
    run`作为后台进程运行，一旦启动就将控制权交还给您的终端会话。当然，有一个参数可以实现这一点。那就是`--detach`参数。使用该参数的效果如下：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using this parameter detaches the process from the foreground session and returns
    control to you as soon as the container has started. Your next question is probably,
    how do I stop a detached container? Well, I am glad you asked. You use the `container
    stop` command.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此参数将进程从前台会话中分离，并在容器启动后立即将控制权返回给您。您可能的下一个问题是，如何停止一个分离的容器？好吧，我很高兴您问了。您可以使用`container
    stop`命令。
- en: The stop container command
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止容器命令
- en: 'The stop command is easy to use. Here are the syntax and an example of the
    command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 停止命令很容易使用。以下是命令的语法和示例：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In our case, we used the `--rm` parameter when running the container, so as
    soon as the container is stopped, the read/write layer will be automatically deleted.
    Like many of the Docker commands, you can provide more than one unique container
    identifier as parameters to stop more than one container with a single command.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，运行容器时我们使用了`--rm`参数，因此一旦容器停止，读/写层将被自动删除。与许多Docker命令一样，您可以提供多个唯一的容器标识符作为参数，以一条命令停止多个容器。
- en: Now you might be wondering if I use the `--detach` parameter, how do I see what
    is happening with the container? There are several ways you can get information
    from, and about, the container. Let's take a look at some of them before we continue
    with our run parameter exploration.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可能会想知道，如果我使用`--detach`参数，我如何查看容器的运行情况？有几种方法可以从容器中获取信息。让我们在继续运行参数探索之前先看看其中一些。
- en: The container logs command
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器日志命令
- en: 'When you run a container in the foreground, all of the output the container
    sends to standard output and standard error is displayed in the console for the
    session that ran the container. However, when you use the `--detach` parameter,
    control of the session is returned as soon as the container starts so you don''t
    see the data sent to `stdout` and `stderr`. If you want to see that data, you
    use the `container logs` command. That command looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在前台运行容器时，容器发送到标准输出和标准错误的所有输出都会显示在运行容器的会话控制台中。然而，当您使用`--detach`参数时，容器一旦启动，会立即返回会话控制，因此您看不到发送到`stdout`和`stderr`的数据。如果您想查看这些数据，可以使用`container
    logs`命令。该命令如下：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `--details`, `--follow`, `--timestamps`, and `--tail` parameters are all
    optional, but I have included them here for reference. When you use the `container
    logs` command with no optional parameters, it will just dump all of the contents
    of the container's logs to the console. You can use the `--tail` parameter with
    a number to dump just the last number of lines. You can combine the parameters
    (except for `--tail` and `--follow`) to get the results you want. The `--follow`
    parameter is like using a `tail -f` command when viewing logs that are being continually
    written to, and will display each line as it is written to the log. You use *Ctrl *+ *C* to
    exit the log being followed. The `--timestamps` parameter is great for evaluating
    the frequency at which lines have been written to the container's logs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`--details`、`--follow`、`--timestamps`和`--tail`参数都是可选的，但我在这里包括了它们以供参考。当您使用`container
    logs`命令而没有可选参数时，它将只是将容器日志的所有内容转储到控制台。您可以使用`--tail`参数加上一个数字来仅转储最后几行。您可以组合这些参数（除了`--tail`和`--follow`）以获得您想要的结果。`--follow`参数就像在查看不断写入的日志时使用`tail
    -f`命令，并将每行写入日志时显示出来。您可以使用*Ctrl *+ *C* 退出正在跟踪的日志。`--timestamps`参数非常适合评估写入容器日志的频率。'
- en: The container top command
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器顶部命令
- en: 'You may not always want to simply view the logs of a container; sometimes you
    want to know what processes are running inside a container. That''s where the
    `container top` command comes in. Ideally, each container is running a single
    process, but the world is not always ideal, so you can use a command such as this
    to view all the processes running in the targeted container:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能并不总是只想查看容器的日志；有时您想知道容器内运行着哪些进程。这就是`container top`命令的用处。理想情况下，每个容器都运行一个进程，但世界并不总是理想的，因此您可以使用这样的命令来查看目标容器中运行的所有进程：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you might expect, the `container top` command is only used for viewing the
    processes of a single container at a time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能期望的那样，`container top`命令只用于一次查看单个容器的进程。
- en: The container inspect command
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器检查命令
- en: 'When you run a container, there is a lot of metadata that gets associated with
    the container. There are many times that you will want to review that metadata.
    The command for doing that is:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行容器时，会有大量与容器关联的元数据。有许多时候您会想要查看那些元数据。用于执行此操作的命令是：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As mentioned, this command returns a lot of data. You may only be interested
    in a subset of the metadata. You can use the `--format` parameter to narrow the
    data returned. Check out these examples:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，此命令返回大量数据。您可能只对元数据的子集感兴趣。您可以使用`--format`参数来缩小返回的数据。查看这些示例：
- en: 'Getting some State data:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一些状态数据：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Getting some `NetworkSettings` data:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一些`NetworkSettings`数据：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Getting data for more than one container with a single command:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单个命令获取多个容器的数据：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Most of these examples use the json processor, `jq`. If you haven''t already
    installed it on your system, now is a good time to do so. Here are the commands
    to install `jq` on each of the OSes we''ve used in this book:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例大多使用json处理器`jq`。如果您尚未在系统上安装它，现在是一个很好的时机。以下是在本书中使用的每个操作系统上安装`jq`的命令：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `--format` parameter of the inspect command uses go templates. You can find
    more information about them on the Docker document pages for formatting output: [https://docs.docker.com/config/formatting](https://docs.docker.com/config/formatting).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: inspect命令的`--format`参数使用go模板。您可以在Docker文档页面上找到有关它们的更多信息，用于格式化输出：[https://docs.docker.com/config/formatting](https://docs.docker.com/config/formatting)。
- en: The container stats command
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器统计命令
- en: 'Another very useful Docker command is the stats command. It provides live,
    continually-updated usage statistics for one or more running containers. It is
    a bit like using the Linux `top` command. You can run the command with no parameters
    to view the stats for all running containers, or you can provide one or more unique
    container identifiers to view the stats for one or more container''s specific
    containers. Here are some examples of using the command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常有用的Docker命令是stats命令。它为一个或多个正在运行的容器提供实时、持续更新的使用统计信息。这有点像使用Linux的`top`命令。您可以不带参数运行该命令，以查看所有正在运行的容器的统计信息，或者您可以提供一个或多个唯一的容器标识符，以查看一个或多个容器的特定容器的统计信息。以下是使用该命令的一些示例：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you have seen enough stats, you use C*trl* + *C* to exit the view.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看了足够的统计信息后，您可以使用C*trl* + *C*退出视图。
- en: 'Getting back to `run` command parameters, next, we''ll discuss two parameters
    for the `run` command that are usually used together. Sometimes you run a container,
    and you want to have an interactive session with it. For example, you may run
    a container that executes some application inside a more or less full OS, such
    as Ubuntu, and you want to have access inside that container to change the configuration
    or debug some issue, similar to using SSH to connect to a server. As with most
    things Docker, there is more than one way to accomplish this. One common method
    is to use two optional parameters for the run command: `--interactive` and `--tty`.
    Let''s take a look at how that works now. You have already seen how we can use
    the `--detach` parameter startup disconnected from the container we are running:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`run`命令参数，接下来，我们将讨论通常一起使用的`run`命令的两个参数。有时候你运行一个容器，你想与它进行交互式会话。例如，您可能运行一个在更多或更少完整的操作系统（如Ubuntu）内执行某些应用程序的容器，并且您希望在该容器内部进行访问以更改配置或调试一些问题，类似于使用SSH连接到服务器。与大多数Docker相关的事情一样，有多种方法可以实现这一点。一种常见的方法是使用`run`命令的两个可选参数：`--interactive`和`--tty`。现在让我们看看它是如何工作的。您已经看到我们如何使用`--detach`参数启动与我们正在运行的容器断开连接：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When we run this command to start up our nginx web server and browse to `http://localhost`,
    we find that it is not serving the welcome page we expect. So we decide to do
    some debugging, and, instead of detaching from our container, we decide to run
    it interactively using the two `--interactive` and `--tty` parameters. Now, since
    this is a nginx container, it has a default command that is executed when the
    container starts. That command is `nginx -g ''daemon off;''`. Since that is the
    default command, it won''t do us any good to interact with the container. So we
    are going to override the default command by providing one as a parameter to our
    run command. It will look something like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行此命令启动我们的nginx web服务器并浏览`http://localhost`时，我们发现它没有提供我们期望的欢迎页面。因此，我们决定进行一些调试，而不是从容器中分离出来，我们决定使用两个`--interactive`和`--tty`参数进行交互式运行。现在，由于这是一个nginx容器，它在容器启动时执行一个默认命令。该命令是`nginx
    -g 'daemon off;'`。由于这是默认命令，与容器进行交互对我们没有任何好处。因此，我们将通过在运行命令中提供一个参数来覆盖默认命令。它看起来会像这样：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This command will run the container as before, but instead of executing the
    default command, it will execute the `bash` command. It will also open a terminal
    session with the container that we can interact with. As needed, we can execute
    commands inside of the container as the `root` user. We can view folders and files,
    we can edit configuration settings, we can install packages, and so on. We can
    even run the image''s default command to see whether we have resolved any issues.
    Here is a somewhat contrived example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将像以前一样运行容器，但是不会执行默认命令，而是执行`bash`命令。它还会打开一个与容器交互的终端会话。根据需要，我们可以以`root`用户的身份在容器内执行命令。我们可以查看文件夹和文件，编辑配置设置，安装软件包等等。我们甚至可以运行镜像的默认命令，以查看是否解决了任何问题。这里有一个有点牵强的例子：
- en: '![](Images/5355ddb7-ef52-4406-9397-c7839cf8de8f.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5355ddb7-ef52-4406-9397-c7839cf8de8f.png)'
- en: 'You may have noticed the `-p 80:80` parameter. That is the short form of the
    publish parameter, which we will discuss shortly in the *Back to the Docker run
    command* section. Using the `container ls` command, you can see the differences
    between running the container using the default command versus running the container
    using an override command:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到了`-p 80:80`参数。这是发布参数的简写形式，我们将在*回到Docker运行命令*部分讨论。使用`container ls`命令，您可以看到使用默认命令运行容器与使用覆盖命令运行容器之间的区别：
- en: '![](Images/339ffd7a-c93b-466f-b9f1-e389a763598b.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/339ffd7a-c93b-466f-b9f1-e389a763598b.png)'
- en: 'Web-server run used the default CMD, and web-server2 used the override CMD
    `bash`. This is a contrived example to help you understand these concepts. A real-world
    example might be when you want to interactively connect with an OS-based container,
    such as Ubuntu. You may recall that at the beginning of [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml),
    *Setting up a Docker Development Environment*, it said that the default command
    run in an Ubuntu container is `bash`. Since that is the case, you don''t have
    to supply a command to override the default. You can use a run command like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器运行使用了默认的CMD，而web-server2使用了覆盖的CMD `bash`。这是一个牵强的例子，帮助您理解这些概念。一个真实的例子可能是当您想要与基于操作系统的容器进行交互连接时，比如Ubuntu。您可能还记得在[第1章](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml)的开头，*设置Docker开发环境*中提到，默认在Ubuntu容器中运行的命令是`bash`。既然如此，您就不必提供一个命令来覆盖默认值。您可以使用这样的运行命令：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this `container run` command, you are connected to an interactive terminal
    session of your running Ubuntu container. You can do pretty much anything you
    would normally do when ssh-ed into an Ubuntu server. You can install software
    with `apt-get`, you can view running processes, you can execute a `top` command,
    and so on. That might look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`container run`命令，您可以连接到正在运行的Ubuntu容器的交互式终端会话。您可以做几乎任何您通常在连接到Ubuntu服务器时会做的事情。您可以使用`apt-get`安装软件，查看运行中的进程，执行`top`命令等等。可能会像这样：
- en: '![](Images/9fafd0d2-f070-4432-bea9-b6d2a7a141ba.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9fafd0d2-f070-4432-bea9-b6d2a7a141ba.png)'
- en: There are a couple of other container commands that help you interact with a
    container that is already running and is detached. Let's take a quick look at
    these commands now.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他容器命令可以帮助您与已经运行并分离的容器进行交互。现在让我们快速看一下这些命令。
- en: The container attach command
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器附加命令
- en: 'Suppose you have a running container. It is currently detached from your terminal
    session. You can use the `container attach` command to bring that container''s
    executing process to be the foreground process of your terminal session. Let''s
    use the web-server example we used earlier:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个正在运行的容器。它当前与您的终端会话分离。您可以使用`container attach`命令将该容器的执行进程带到您的终端会话的前台进程。让我们使用之前使用过的web服务器示例：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When you attach to the running container, its executing command becomes the
    foreground process for your terminal session. To detach from the container, you
    need to issue a*Ctrl* + *PQ* keystroke. If you issue a *Ctrl* + *C* keystroke,
    the container's executing process will receive a sig-term signal and will terminate,
    which in turn will exit the container. This is usually not desired. So remember
    to detach by using a *Ctrl* + *PQ* keystroke.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你附加到运行的容器时，它的执行命令将成为你的终端会话的前台进程。要从容器中分离，你需要发出*Ctrl* + *PQ*按键。如果你发出*Ctrl* + *C*按键，容器的执行进程将接收到sig-term信号并终止，这将导致容器退出。这通常是不希望的。所以记住要使用*Ctrl* + *PQ*按键来分离。
- en: 'However, there is a known issue on macOS: for Docker on Mac, the *Ctrl* + *PQ* keystroke
    does not work, and unless you use another parameter, the `--sig-proxy=false` parameter,
    on the `attach` command, you will not be able to detach from the container without
    terminating it with a *Ctrl *+ *C* keystroke:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在macOS上存在一个已知问题：对于Mac上的Docker，*Ctrl* + *PQ*按键组合不起作用，除非你在`attach`命令上使用另一个参数，`--sig-proxy=false`参数，否则你将无法在不使用*Ctrl *+
    *C*按键的情况下从容器中分离出来：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When you provide the `--sig-proxy=false` parameter to the `attach` command,
    you can issue a *Ctrl *+ *C* keystroke to the attached container and it will detach
    without sending the sig-term signal to the container process, thus keeping the
    container running, once again detached from your terminal session:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向`attach`命令提供`--sig-proxy=false`参数时，你可以向附加的容器发出*Ctrl *+ *C*按键，它将分离而不向容器进程发送sig-term信号，从而使容器再次以分离状态运行，脱离你的终端会话：
- en: '![](Images/fcf8b70a-0e46-4ad1-a260-d783fadf9ca6.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fcf8b70a-0e46-4ad1-a260-d783fadf9ca6.png)'
- en: The container exec command
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器exec命令
- en: 'Sometimes, when you have a container running detached, you might want to get
    access to it, but don''t want to attach to the executing command. You can accomplish
    this by using the container exec command. This command allows you to execute another
    command in the running container, without attaching to or interfering with the
    already-running command. This command is often used to create an interactive session
    with an already-running container or to execute a single command within the container.
    The command looks like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你有一个以分离状态运行的容器时，你可能想要访问它，但不想附加到执行命令。你可以通过使用容器exec命令来实现这一点。这个命令允许你在运行的容器中执行另一个命令，而不附加或干扰已经运行的命令。这个命令经常用于创建与已经运行的容器的交互会话，或者在容器内执行单个命令。命令看起来像这样：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When the `exec` command completes, you exit the bash shell, or the file contents
    have been displaced, then it exits back to the terminal session leaving the container
    running detached:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当`exec`命令完成时，你退出bash shell，或者文件内容已经被替换，然后它会退出到终端会话，让容器以分离状态运行：
- en: '![](Images/fb344e4d-5ba7-440f-af71-9b42c8c4ccce.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fb344e4d-5ba7-440f-af71-9b42c8c4ccce.png)'
- en: Let's take a look at another Docker command before we continue our discussion
    of the many optional `container run` parameters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在继续讨论许多可选的`container run`参数之前，先看看另一个Docker命令。
- en: The container commit command
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器commit命令
- en: 'It is important to know that when you are attached to a running container and
    make changes to it, such as installing new packages, or changing configuration
    files, that those changes only apply to that running container. If, for example,
    you use an Ubuntu image to run a container and then install `curl` into that container,
    the change does not apply back to the image you ran the container from, in this
    example, Ubuntu. If you were to start another container from the same Ubuntu image,
    you would need to install `curl` again. However, if you want to have the changes
    you make inside a running container persist and be available when you run new
    containers, you can use the `container commit` command. The `container commit`
    command allows you to save the current read/write layer of a container along with
    the layers of the original image, creating a brand new image. When you run containers
    using the new image, it will include the changes you made and saved with the `container
    commit` command. Here is what the `container commit` command looks like:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，当您连接到正在运行的容器并对其进行更改，比如安装新的软件包或更改配置文件时，这些更改只适用于该正在运行的容器。例如，如果您使用Ubuntu镜像运行一个容器，然后在该容器中安装`curl`，那么这个更改不会应用到您从中运行容器的镜像，例如Ubuntu。如果您要从相同的Ubuntu镜像启动另一个容器，您需要再次安装`curl`。但是，如果您希望在运行新容器时保留并使用在运行容器内进行的更改，您可以使用`container
    commit`命令。`container commit`命令允许您保存容器的当前读/写层以及原始镜像的层，从而创建一个全新的镜像。当您使用新镜像运行容器时，它将包括您使用`container
    commit`命令保存的更改。`container commit`命令的样子如下：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And here is an example of using the `container commit` command to install `curl`
    to a running container, and then creating a new container that includes the installed
    `curl` command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用`container commit`命令将`curl`安装到正在运行的容器中，并创建一个包含安装的`curl`命令的新容器的示例：
- en: '![](Images/47f18f01-68e7-42e5-80de-4dacdf2aad16.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/47f18f01-68e7-42e5-80de-4dacdf2aad16.png)'
- en: With this example, I can now run new containers from the `ubuntu-curl` image,
    and all of them will have the `curl` command already installed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个例子，我现在可以从`ubuntu-curl`镜像运行新的容器，它们都将已经安装了`curl`命令。
- en: Back to the Docker run command
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到Docker运行命令
- en: 'Now, let''s return to our discussion of the `container run` command. Earlier,
    you saw an example of using the `run` command with the `--publish` parameter.
    Using the optional publish parameter allows you to specify what ports will be
    opened related to the run container. The `--publish` parameter includes pairs
    of port numbers separated by a colon. For example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到讨论`container run`命令。之前，您看到了使用`run`命令和`--publish`参数的示例。使用可选的发布参数允许您指定与运行容器相关的将要打开的端口。`--publish`参数包括用冒号分隔的端口号对。例如：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first port number is associated with the host running the container. In
    the nginx example, `8080` is exposed on the host; in our case that would be `http://localhost:8080`.
    The second port number is the port that is open on the running container. In this
    case, it would be `80`. Speaking out the description of the `--publish 8080:80`
    parameter, you would say something like, the traffic sent to port `8080` *o*n
    the host is redirected to port `80` on the running container:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个端口号与运行容器的主机相关联。在nginx示例中，`8080`在主机上暴露；在我们的情况下，那将是`http://localhost:8080`。第二个端口号是运行容器上打开的端口。在这种情况下，它将是`80`。描述`--publish
    8080:80`参数时，您可以说类似于，发送到主机上端口`8080`的流量被重定向到运行容器上的端口`80`：
- en: '![](Images/3309bf24-df9f-47bf-b97c-9bc3112928fb.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3309bf24-df9f-47bf-b97c-9bc3112928fb.png)'
- en: 'It is an important distinction to make between the host ports and the container
    ports. I can run several containers on the same system that all expose port `80`,
    but only one container can have traffic from each port on the host. Look at the
    following examples to better understand:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的区别在于主机端口和容器端口。我可以在同一系统上运行多个暴露端口`80`的容器，但是每个端口在主机上只能有一个容器的流量。看下面的例子更好地理解：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Know that this is a limitation of networking in general, not a limitation of
    Docker or containers. Here we can see these commands and their output. Notice
    the ports and names, and how the use of a port already used as an endpoint fails:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道这是网络的一般限制，而不是Docker或容器的限制。在这里我们可以看到这些命令及其输出。注意端口和名称，以及已经使用的端口作为端点的使用失败：
- en: '![](Images/60594bf1-705f-48cf-9ecd-60d4691320be.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/60594bf1-705f-48cf-9ecd-60d4691320be.png)'
- en: That was a lot of data on various options parameters for the `container run`
    command. It's not all the options parameters, but it should be enough to get you
    off to a great start. If you want to learn more about the optional parameters
    we explored, or find out about the ones we didn't cover here, be sure to visit
    the docker documents page for the `container run` command, which can be found
    at [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于`container run`命令的各种选项参数的大量数据。这并不是所有的选项参数，但应该足够让你有一个很好的开始。如果你想了解更多我们探讨的可选参数，或者找出我们没有涵盖的内容，一定要访问docker文档页面上的`container
    run`命令，网址是[https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about Docker image descriptions and a little about
    Docker registries. Then we saw that there is another form of the version command.
    After that, we explored a lot of Docker container commands, including `run`, `stop`,
    `ls`, `logs`, `top`, `stats`, `attach`, `exec`, and the `commit` command. Finally,
    we found out how to expose your containers by opening ports from your host and
    to your containers. You should feel pretty good about what you can do with Docker
    already, but hang on—in [Chapter 3](ab7747ed-23c9-462c-98cb-c70e330c5d87.xhtml),
    *Creating Docker Images*, we are going to show you how to create your own Docker
    images with a `Dockerfile` and the image build command. If you're ready, turn
    the page.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于Docker镜像描述和Docker注册表的知识。然后我们看到了版本命令的另一种形式。之后，我们探索了许多Docker容器命令，包括`run`、`stop`、`ls`、`logs`、`top`、`stats`、`attach`、`exec`和`commit`命令。最后，我们了解了如何通过从主机到容器打开端口来暴露您的容器。你应该对Docker已经能做的事情感到很满意，但是请稍等，在[第3章](ab7747ed-23c9-462c-98cb-c70e330c5d87.xhtml)
    *创建Docker镜像*中，我们将向您展示如何使用`Dockerfile`和镜像构建命令创建自己的Docker镜像。如果你准备好了，翻页吧。
- en: References
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考
- en: Docker registry: [https://hub.docker.com/explore/](https://hub.docker.com/explore/)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker注册表：[https://hub.docker.com/explore/](https://hub.docker.com/explore/)
- en: All of the parameters for the `container run` command: [https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有`container run`命令的参数：[https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)
- en: Using the `--format` parameter with the container inspect command: [https://docs.docker.com/config/formatting](https://docs.docker.com/config/formatting)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`--format`参数与容器检查命令：[https://docs.docker.com/config/formatting](https://docs.docker.com/config/formatting)
- en: The json jq parser: [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json jq解析器：[https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)
- en: The Chocolatey Windows package manager: [https://chocolatey.org/](https://chocolatey.org/)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chocolatey Windows软件包管理器：[https://chocolatey.org/](https://chocolatey.org/)
