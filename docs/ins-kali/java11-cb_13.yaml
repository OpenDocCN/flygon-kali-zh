- en: Working with New Date and Time APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的日期和时间API
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: How to construct time zone-independent date and time instances
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建不依赖于时区的日期和时间实例
- en: How to construct time zone-dependent time instances
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何构建依赖于时区的时间实例
- en: How to create a date-based period between date instances
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建日期间的基于日期的周期
- en: How to create a time-based period between time instances
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建基于时间的时间实例之间的周期
- en: How to represent epoch time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何表示纪元时间
- en: How to manipulate date and time instances
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何操作日期和时间实例
- en: How to compare date and time
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何比较日期和时间
- en: How to work with different calendar systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理不同的日历系统
- en: How to format dates using `DateTimeFormatter`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`DateTimeFormatter`格式化日期
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Working with `java.util.Date` and `java.util.Calendar` was a pain for Java
    developers until Stephen Colebourne ([http://www.joda.org/](http://www.joda.org/))
    introduced Joda-Time ([http://www.joda.org/joda-time/](http://www.joda.org/joda-time/)),
    a library for working with date and time in Java. Joda-Time provided the following
    advantages over the JDK API:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`java.util.Date`和`java.util.Calendar`对于Java开发人员来说是一种痛苦，直到Stephen Colebourne
    ([http://www.joda.org/](http://www.joda.org/))引入了Joda-Time ([http://www.joda.org/joda-time/](http://www.joda.org/joda-time/))，这是一个用于在Java中处理日期和时间的库。Joda-Time相对于JDK
    API提供了以下优势：
- en: Richer API for getting date components, such as the day of a month, the day
    of a week, the month, and the year, and time components, such as the hour, minutes,
    and seconds.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更丰富的API用于获取日期组件，如月份的日、星期的日、月份和年份，以及时间组件，如小时、分钟和秒。
- en: Ease of manipulation and comparison of dates and time.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松操作和比较日期和时间。
- en: Both time zone-independent and time zone-dependent APIs are available. Most
    of the time, we will be using time zone-independent APIs, which makes it easier
    to use the API.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的既不依赖于时区又依赖于时区的API。大多数情况下，我们将使用不依赖于时区的API，这样更容易使用API。
- en: Amazing APIs to compute duration between dates and times.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令人惊叹的API，可以计算日期和时间之间的持续时间。
- en: Date formatting and duration computation follow ISO standards by default.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期格式化和持续时间计算默认遵循ISO标准。
- en: Supports multiple calendars such as Gregorian, Buddhist, and Islamic.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个日历，如公历、佛历和伊斯兰历。
- en: Joda-Time inspired JSR-310 ([https://jcp.org/en/jsr/detail?id=310](https://jcp.org/en/jsr/detail?id=310)),
    which ported the API to JDK under the `java.time` package and was released as
    part of Java 8\. As the new Date/Time API is based on ISO standards, it makes
    it dead simple to integrate date/time libraries across different layers of your
    application. For example, at the JavaScript layer, we can use moment.js ([https://momentjs.com/docs/](https://momentjs.com/docs/))
    to work with date and time and use its default formatting style (which is ISO-compliant)
    to send data to the server. At the server layer, we can use the new Date/Time
    API to obtain date and time instances as required. So we are interacting between
    the client and server using standard date representations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Joda-Time启发了JSR-310 ([https://jcp.org/en/jsr/detail?id=310](https://jcp.org/en/jsr/detail?id=310))，将API移植到了`java.time`包下，并作为Java
    8的一部分发布。由于新的日期/时间API基于ISO标准，因此可以轻松地在应用程序的不同层之间集成日期/时间库。例如，在JavaScript层，我们可以使用moment.js
    ([https://momentjs.com/docs/](https://momentjs.com/docs/))处理日期和时间，并使用其默认格式化样式（符合ISO标准）将数据发送到服务器。在服务器层，我们可以使用新的日期/时间API根据需要获取日期和时间实例。因此，我们可以使用标准日期表示在客户端和服务器之间进行交互。
- en: In this chapter, we will look at different ways we can leverage the new Date/Time
    API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨利用新的日期/时间API的不同方法。
- en: How to work with time zone-independent date and time instances
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何处理不依赖于时区的日期和时间实例
- en: Prior to JSR-310, it was not straightforward to create date and time instances
    for any point in time or any day in a calendar. The only way was to use the `java.util.Calendar`
    object to set the required dates and time, and then invoke the `getTime()` method
    to get an instance of `java.util.Date`. And those date and time instances contained
    time zone information as well, which sometimes led to bugs in the application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSR-310之前，要为任何时间点或日历中的任何一天创建日期和时间实例并不直观。唯一的方法是使用`java.util.Calendar`对象设置所需的日期和时间，然后调用`getTime()`方法获取`java.util.Date`的实例。这些日期和时间实例也包含时区信息，有时会导致应用程序中的错误。
- en: In new APIs, it's far simpler to get date and time instances, and these date
    and time instances do not have any time zone information associated with them.
    In this recipe, we will show you how to work with date-only instances represented
    by `java.time.LocalDate`, time-only instances represented by `java.time.LocalTime`,
    and date/time instances represented by `java.time.LocalDateTime`. These date and
    time instances are time zone-independent and represent the information in the
    current time zone of the machine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的API中，获取日期和时间实例要简单得多，这些日期和时间实例不包含任何与时区相关的信息。在本示例中，我们将向您展示如何使用`java.time.LocalDate`表示仅日期的实例，使用`java.time.LocalTime`表示仅时间的实例，以及使用`java.time.LocalDateTime`表示日期/时间实例。这些日期和时间实例是不依赖于时区的，并表示机器的当前时区中的信息。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have at least JDK 8 installed to be able to use these newer libraries,
    and the samples in this chapter use the syntax that is supported on Java 10 and
    onward. If you want, you can run these code snippets directly in JShell. You can
    visit [Chapter 12](3eb4f1fb-a9ad-422c-b8fb-0fad844f29af.xhtml), *The Read-Evaluate-Print
    Loop (REPL) Using JShell,* to learn more about JShell.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装至少JDK 8才能使用这些更新的库，本章中的示例使用Java 10及更高版本支持的语法。如果您愿意，可以直接在JShell中运行这些代码片段。您可以访问[第12章](3eb4f1fb-a9ad-422c-b8fb-0fad844f29af.xhtml)，*使用JShell进行读取-求值-打印循环(REPL)*，了解更多关于JShell的信息。
- en: How to do it…
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The current date wrapped in `java.time.LocalDate` can be obtained using the
    `now()` method, as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`now()`方法可以获取包装在`java.time.LocalDate`中的当前日期，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can get individual fields of the `java.time.LocalDate` instance using the
    generic `get(fieldName)` method or specific methods such as `getDayOfMonth()`,
    `getDayOfYear()`, `getDayOfWeek()`, `getMonth()`, and `getYear()`, as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用通用的`get(fieldName)`方法或特定的方法，如`getDayOfMonth()`、`getDayOfYear()`、`getDayOfWeek()`、`getMonth()`和`getYear()`来获取`java.time.LocalDate`实例的各个字段，如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can get an instance of `java.time.LocalDate` for any date in the calendar
    using the `of()` method, as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`of()`方法获取日历中任何日期的`java.time.LocalDate`实例，如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There is the `java.time.LocalTime` class, which is used to represent any time
    instance irrespective of the date. The current time can be obtained using the
    following:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有`java.time.LocalTime`类，用于表示任何时间实例，而不考虑日期。可以使用以下方法获取当前时间：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `java.time.LocalTime` class also comes with the `of()` factory method, which
    can be used to create an instance representing any time. Similarly, there are
    methods to get different components of the time, as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java.time.LocalTime`类还带有`of()`工厂方法，可用于创建表示任何时间的实例。类似地，有方法来获取时间的不同组件，如下所示：'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`java.time.LocalDateTime` is used to represent an entity containing both time
    and date. It is made up of `java.time.LocalDate` and `java.time.LocalTime` to
    represent date and time respectively. Its instance can be created using `now()`
    and different flavors of the `of()`  factory method, as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java.time.LocalDateTime`用于表示包含时间和日期的实体。它由`java.time.LocalDate`和`java.time.LocalTime`组成，分别表示日期和时间。可以使用`now()`和不同版本的`of()`工厂方法创建其实例，如下所示：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The following three classes in the `java.time` package represent date and time
    values in the default time zone (the system''s time zone):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time`包中的以下三个类代表默认时区（系统的时区）中的日期和时间值：'
- en: '`java.time.LocalDate`: Contains only date information'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.time.LocalDate`: 只包含日期信息'
- en: '`java.time.LocalTime`: Contains only time information'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.time.LocalTime`: 只包含时间信息'
- en: '`java.time.LocalDateTime`: Contains both date and time information'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.time.LocalDateTime`: 包含日期和时间信息'
- en: 'Each of the classes is made up of fields, namely the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都由以下字段组成：
- en: Day
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日期
- en: Month
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月
- en: Year
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年
- en: Hour
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小时
- en: Minutes
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分钟
- en: Seconds
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秒
- en: Milliseconds
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 毫秒
- en: All classes contain the `now()` method, which returns the current date and time
    values. There are `of()` factory methods provided to build the date and time instances
    from their fields, such as day, month, year, hour, and minute. `java.time.LocalDateTime`
    is made up of `java.time.LocalDate` and `java.time.LocalTime`, so one can build
    `java.time.LocalDateTime` from `java.time.LocalDate` and `java.time.LocalTime`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类都包含`now()`方法，返回当前的日期和时间值。提供了`of()`工厂方法来根据它们的字段（如日、月、年、小时和分钟）构建日期和时间实例。`java.time.LocalDateTime`由`java.time.LocalDate`和`java.time.LocalTime`组成，因此可以从`java.time.LocalDate`和`java.time.LocalTime`构建`java.time.LocalDateTime`。
- en: 'The important APIs learned from this recipe are the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个示例中学到的重要API如下：
- en: '`now()`: This gives the current date and time'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`now()`: 这会给出当前日期和时间'
- en: '`of()`: This factory method is used to construct the required date, time and
    date/time instances'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`of()`: 这个工厂方法用于构造所需的日期、时间和日期/时间实例'
- en: There's more…
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In Java 9, there's a new API, `datesUntil`, which takes the end date and returns
    a stream of sequential dates (in other words, `java.time.LocalDate`) from the
    date of the current object until the end date (but excluding it). Using this API
    groups all the dates for the given month and year into their respective days of
    the week, namely, Monday, Tuesday, Wednesday, and so forth.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，有一个新的API，`datesUntil`，它接受结束日期并返回从当前对象的日期到结束日期（但不包括结束日期）的顺序日期流（换句话说，`java.time.LocalDate`）。使用此API将给定月份和年份的所有日期分组到它们各自的星期几，即星期一、星期二、星期三等。
- en: 'Let''s accept the month and year and store it in the `month` and `year` variables respectively.
    The start of the range will be the first day of the month and year, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们接受月份和年份，并将其分别存储在`month`和`year`变量中。范围的开始将是该月和年的第一天，如下所示：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The end date of the range will be the number of days in the month, as shown
    in the following snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 范围的结束日期将是该月的天数，如下所示：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are making use of the `lengthOfMonth` method to fetch the number of days
    in the month. We then use the `datesUntil` method to get a stream of `java.time.LocalDate`
    and then we perform some stream operations:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`lengthOfMonth`方法获取该月的天数。然后我们使用`datesUntil`方法获取`java.time.LocalDate`的流，然后执行一些流操作：
- en: Grouping `java.time.LocalDate` instances by day of the week.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按星期几对`java.time.LocalDate`实例进行分组。
- en: Collecting the grouped instances into `java.util.ArrayList`. But before that,
    we are applying a transformation to convert the `java.time.LocalDate` instances
    into a simple day of the month, which gives us a list of integers representing
    the day of the month.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将分组的实例收集到`java.util.ArrayList`中。但在此之前，我们正在应用转换将`java.time.LocalDate`实例转换为一个简单的月份，这给我们提供了一个表示月份的整数列表。
- en: 'The preceding two operations in the code are shown in the following snippet:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的前两个操作如下所示：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code for this can be found at `Chapter13/1_2_print_calendar` of the downloaded
    code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码可以在下载的代码的`Chapter13/1_2_print_calendar`中找到。
- en: How to construct time zone-dependent time instances
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何构造依赖于时区的时间实例
- en: In the previous recipe, *How to construct time zone-independent date and time
    instances,* we constructed date and time objects that didn't contain any time
    zone information. They implicitly represented the values in the system's time
    zone; these classes were `java.time.LocalDate`, `java.time.LocalTime`, and `java.time.LocalDateTime`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，*如何构造不依赖于时区的日期和时间实例*，我们构造了不包含任何时区信息的日期和时间对象。它们隐式地表示了系统时区中的值；这些类是`java.time.LocalDate`、`java.time.LocalTime`和`java.time.LocalDateTime`。
- en: Often we would need to represent the time with respect to some time zone; in
    such scenarios we will make use of `java.time.ZonedDateTime`, which contains time
    zone information along with `java.time.LocalDateTime`. The time zone information
    is embedded using `java.time.ZoneId` or `java.time.ZoneOffset` instances. There
    are two other  classes, `java.time.OffsetTime` and `java.time.OffsetDateTime`,
    which are also time zone-specific variants for `java.time.LocalTime` and `java.time.LocalDateTime`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们需要根据某个时区表示时间；在这种情况下，我们将使用`java.time.ZonedDateTime`，它包含了带有`java.time.LocalDateTime`的时区信息。时区信息是使用`java.time.ZoneId`或`java.time.ZoneOffset`实例嵌入的。还有两个类，`java.time.OffsetTime`和`java.time.OffsetDateTime`，它们也是`java.time.LocalTime`和`java.time.LocalDateTime`的特定于时区的变体。
- en: In this recipe, we will show you how to make use of `java.time.ZonedDateTime`,
    `java.time.ZoneId`, `java.time.ZoneOffset`, `java.time.OffsetTime`, and `java.time.OffsetDateTime`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将展示如何使用`java.time.ZonedDateTime`、`java.time.ZoneId`、`java.time.ZoneOffset`、`java.time.OffsetTime`和`java.time.OffsetDateTime`。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will make use of Java 10 syntax that uses `var` for local variable declarations
    and modules. Apart from Java 10 and higher, there is no other prerequisite.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Java 10的语法，使用`var`来声明局部变量和模块。除了Java 10及以上版本，没有其他先决条件。
- en: How to do it…
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'We will make use of the `now()` factory method to get the current date, time,
    and time zone information based on the system''s time zone, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`now()`工厂方法根据系统的时区获取当前的日期、时间和时区信息，如下所示：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will make use of `java.time.ZoneId` to get the current date and time information
    based on any given time zone:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`java.time.ZoneId`根据任何给定的时区获取当前的日期和时间信息：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`java.time.ZoneOffset` can also be used to provide time zone information for
    the date and time, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java.time.ZoneOffset`也可以用来提供日期和时间的时区信息，如下所示：'
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We make use of the `of()` factory method to build an instance of `java.time.ZonedDateTime`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`of()`工厂方法构建`java.time.ZonedDateTime`的一个实例：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can even extract `java.time.LocalDateTime` from`java.time.ZonedDateTime`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以从`java.time.ZonedDateTime`中提取`java.time.LocalDateTime`：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: First, let's look at how the time zone information is captured. It's captured
    based on the number of hours and minutes from **Greenwich Mean Time (GMT)**, also
    known as Coordinated Universal Time (UTC). For example, Indian Standard Time (IST),
    also known as Asia/Kolkata, is 5:30 hours ahead of GMT.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何捕获时区信息。它是根据**格林威治标准时间（GMT）**的小时和分钟数捕获的，也被称为协调世界时（UTC）。例如，印度标准时间（IST），也称为Asia/Kolkata，比GMT提前5小时30分钟。
- en: 'Java provides `java.time.ZoneId` and `java.time.ZoneOffset` to represent time
    zone information. `java.time.ZoneId` captures time zone information based on the
    time zone name, such as Asia/Kolkata, US/Pacific, and US/Mountain. There are around
    599 zone IDs. This has been computed using the following line of code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了`java.time.ZoneId`和`java.time.ZoneOffset`来表示时区信息。`java.time.ZoneId`根据时区名称捕获时区信息，例如Asia/Kolkata，US/Pacific和US/Mountain。大约有599个时区ID。这是使用以下代码行计算的：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will print 10 of the zone IDs:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打印10个时区ID：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Time zone names, such as Asia/Kolkata, Africa/Nairobi, and America/Cuiaba, are
    based on the time zone database released by International Assigned Numbers Authority
    (IANA). The time zone region names provided by IANA are the default for Java.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 时区名称，例如Asia/Kolkata，Africa/Nairobi和America/Cuiaba，基于国际分配的数字管理局（IANA）发布的时区数据库。IANA提供的时区区域名称是Java的默认值。
- en: Sometimes time zone region names are also represented as GMT+02:30 or simply
    +02:30, which indicates the offset (ahead or behind) of the current time zone
    from the GMT zone.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有时时区区域名称也表示为GMT+02:30或简单地+02:30，这表示当前时区与GMT时区的偏移（提前或落后）。
- en: 'This `java.time.ZoneId` captures `java.time.zone.ZoneRules`, which contains
    rules for obtaining the time zone offset transitions and other information, such
    as the daylight savings time. Let''s investigate the zone rules for US/Pacific:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`java.time.ZoneId`捕获了`java.time.zone.ZoneRules`，其中包含了获取时区偏移转换和其他信息的规则，比如夏令时。让我们调查一下US/Pacific的时区规则：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `getDaylightSavings()` method returns a `java.time.Duration` object, which
    represents some duration in terms of hours, minutes, and seconds. The default
    `toString()` implementation returns the duration represented using ISO 8601 seconds-based
    representation where a duration of 1 hour, 20 minutes, and 20 seconds is represented
    as `PT1H20M20S`. More about this will be covered in the *How to create a time-based
    period between time instances* recipe in this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDaylightSavings()`方法返回一个`java.time.Duration`对象，表示以小时、分钟和秒为单位的一些持续时间。默认的`toString()`实现返回使用ISO
    8601基于秒的表示，其中1小时20分钟20秒的持续时间表示为`PT1H20M20S`。关于这一点将在本章的*如何在时间实例之间创建基于时间的期间*中进行更多介绍。'
- en: We are not going into the details of how it's been calculated. For those interested
    to know more about `java.time.zone.ZoneRules` and `java.time.ZoneId`, visit the
    documentation at [https://docs.oracle.com/javase/10/docs/api/java/time/zone/ZoneRules.html ](https://docs.oracle.com/javase/10/docs/api/java/time/zone/ZoneRules.html)and
    [https://docs.oracle.com/javase/10/docs/api/java/time/ZoneId.html](https://docs.oracle.com/javase/10/docs/api/java/time/ZoneId.html) respectively.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍它是如何计算的。对于那些想了解更多关于`java.time.zone.ZoneRules`和`java.time.ZoneId`的人，请访问[https://docs.oracle.com/javase/10/docs/api/java/time/zone/ZoneRules.html](https://docs.oracle.com/javase/10/docs/api/java/time/zone/ZoneRules.html)和[https://docs.oracle.com/javase/10/docs/api/java/time/ZoneId.html](https://docs.oracle.com/javase/10/docs/api/java/time/ZoneId.html)的文档。
- en: 'The `java.time.ZoneOffset` class captures the time zone information in terms
    of the number of hours and minutes the time zone is ahead of or behind GMT. Let''s
    create an instance of the `java.time.ZoneOffset` class using the `of*()` factory
    method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time.ZoneOffset`类以时区领先或落后GMT的小时和分钟数来捕获时区信息。让我们使用`of*()`工厂方法创建`java.time.ZoneOffset`类的一个实例：'
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `java.time.ZoneOffset` class extends from `java.time.ZoneId` and adds a
    few new methods. The important thing to remember is to construct the right instance
    of `java.time.ZoneOffset` and `java.time.ZoneId` based on the required time zone
    to be used in your applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time.ZoneOffset`类继承自`java.time.ZoneId`并添加了一些新方法。重要的是要记住根据应用程序中要使用的所需时区构造`java.time.ZoneOffset`和`java.time.ZoneId`的正确实例。'
- en: Now that we have an understanding of time zone representation, `java.time.ZonedDateTime`
    is nothing but `java.time.LocalDateTime` along with `java.time.ZoneId` or `java.time.ZoneOffset`.
    There are two other classes, `java.time.OffsetTime` and `java.time.OffsetDateTime`,
    which wraps `java.time.LocalTime` and `java.time.LocalDateTime` respectively,
    along with `java.time.ZoneOffset`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对时区表示有了了解，`java.time.ZonedDateTime`实际上就是`java.time.LocalDateTime`加上`java.time.ZoneId`或`java.time.ZoneOffset`。还有两个其他类，`java.time.OffsetTime`和`java.time.OffsetDateTime`，分别包装了`java.time.LocalTime`和`java.time.LocalDateTime`，以及`java.time.ZoneOffset`。
- en: Let's see some ways to construct instances of `java.time.ZonedDateTime`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些构造`java.time.ZonedDateTime`实例的方法。
- en: 'The first way is using `now()`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用`now()`：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first usage of `now()` uses the system's clock, as well as the system time
    zone to print the current date and time. The second usage of `now()` uses the
    system's clock, but the time zone is provided by `java.time.ZoneId`, which in
    this case is Asia/Kolkata. The third usage of `now()` uses the fixed clock provided
    and the time zone provided by `java.time.ZoneId`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`now()`的第一种用法使用系统时钟以及系统时区来打印当前日期和时间。`now()`的第二种用法使用系统时钟，但时区由`java.time.ZoneId`提供，这种情况下是Asia/Kolkata。`now()`的第三种用法使用提供的固定时钟和`java.time.ZoneId`提供的时区。'
- en: 'The fixed clock is created using the `java.time.Clock` class and its static
    method, `fixed()`, which takes an instance of `java.time.Instant` and `java.time.ZoneId`.
    The instance of `java.time.Instant` has been built using some static number of
    seconds after epoch. `java.time.Clock` is used to represent a clock which can
    be used by the new Date/Time API to determine the current time. The clock can
    be fixed, as we have seen earlier, then we can create a clock which is one hour
    ahead of the current system time in the Asia/Kolkata time zone, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`java.time.Clock`类及其静态方法`fixed()`创建固定时钟，该方法接受`java.time.Instant`和`java.time.ZoneId`的实例。`java.time.Instant`的实例是在纪元后的一些静态秒数后构建的。`java.time.Clock`用于表示新的日期/时间API可以用来确定当前时间的时钟。时钟可以是固定的，就像我们之前看到的那样，然后我们可以创建一个比Asia/Kolkata时区的当前系统时间提前一小时的时钟，如下所示：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can use this new clock to build instances of `java.time.LocalDateTime` and
    `java.time.ZonedDateTime`, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个新的时钟来构建`java.time.LocalDateTime`和`java.time.ZonedDateTime`的实例，如下所示：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Both date and time values are based on the same time zone, that is, `Asia/Kolkata`,
    but as we have already learned, `java.time.LocalDateTime` doesn't have any time
    zone information and it bases the values on the time zone of the system or the
    `java.time.Clock` provided in this case. On the other hand, `java.time.ZonedDateTime`
    contains and displays the time zone information as `[Asia/Kolkata]`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间值都基于相同的时区，即Asia/Kolkata，但正如我们已经了解的那样，`java.time.LocalDateTime`没有任何时区信息，它基于系统的时区或在这种情况下提供的`java.time.Clock`的值。另一方面，`java.time.ZonedDateTime`包含并显示时区信息为[Asia/Kolkata]。
- en: 'The other approach for creating an instance of `java.time.ZonedDateTime` is
    using its `of() ` factory method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建`java.time.ZonedDateTime`实例的方法是使用其`of()`工厂方法：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There's more…
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We mentioned the `java.time.OffsetTime` and `java.time.OffsetDateTime` classes.
    Both contain time zone-specific time values. Let''s play around with those classes
    before we wrap up this recipe:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到了`java.time.OffsetTime`和`java.time.OffsetDateTime`类。两者都包含特定于时区的时间值。在我们结束这个教程之前，让我们玩一下这些类。
- en: 'Using the `of()` factory method:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`of()`工厂方法：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using the `now()` factory method:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`now()`工厂方法：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It's worth noting the way we built a `java.time.Clock` instance, which is 330
    minutes (5 hours and 30 minutes) ahead of the UTC clock. The other class, `java.time.OffsetDateTime`,
    is the same as `java.time.OffsetTime`, except that it uses `java.time.LocalDateTime`.
    So you will be passing the date information, namely, year, month, and day, along
    with the time information to its factory method, `of()`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是我们如何构建了一个`java.time.Clock`实例，它比UTC时钟提前了330分钟（5小时30分钟）。另一个类`java.time.OffsetDateTime`与`java.time.OffsetTime`相同，只是它使用`java.time.LocalDateTime`。因此，您将向其工厂方法`of()`传递日期信息，即年、月和日，以及时间信息。
- en: How to create a date-based period between date instances
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在日期实例之间创建基于日期的期间
- en: There are times in the past when we tried to measure the period between two
    date instances but, due to the lack of an API prior to Java 8 and also lack of
    proper support to capture this information, we resorted to different means. We
    remember using SQL-based approaches to process such information. But from Java
    8 and onward, we have a new class, `java.time.Period`, which can be used to capture
    a period between two date instances in terms of the number of years, months, and
    days.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们曾试图测量两个日期实例之间的期间，但由于Java 8之前缺乏API以及缺乏捕获此信息的适当支持，我们采用了不同的方法。我们记得使用基于SQL的方法来处理这样的信息。但从Java
    8开始，我们有了一个新的类`java.time.Period`，它可以用来捕获两个日期实例之间的期间，以年、月和日的数量来表示。
- en: Also, this class supports parsing ISO 8601 standard-based strings for representing
    the period. The standard states that any period can be represented in the form
    of `PnYnMnD`, where **P** is a fixed character to represent the period, **nY**
    stands for the number of years, **nM** for the number of months, and **nD** for
    the number of days. For example, a period of 2 years, 4 months, and 10 days is
    represented as `P2Y4M10D`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该类支持解析基于ISO 8601标准的字符串来表示期间。该标准规定任何期间都可以用`PnYnMnD`的形式表示，其中**P**是表示期间的固定字符，**nY**表示年数，**nM**表示月数，**nD**表示天数。例如，2年4个月10天的期间表示为`P2Y4M10D`。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need at least JDK8 to play around with `java.time.Period`, JDK 9 to be able
    to make use of JShell, and at least JDK 10 to make use of the examples used in
    this recipe.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您至少需要JDK8来使用`java.time.Period`，需要JDK 9才能使用JShell，并且至少需要JDK 10才能使用本示例中使用的示例。
- en: How to do it…
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s create an instance of `java.time.Period` using its `of()` factory method, which
    has the signature `Period.of(int years, int months, int days)` :'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用其`of()`工厂方法创建一个`java.time.Period`的实例，其签名为`Period.of(int years, int months,
    int days)`：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are specific variants of the `of*()` method, namely, `ofDays()`, `ofMonths()`,
    and `ofYears()`, which can be used as well:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有特定变体的`of*()`方法，即`ofDays()`，`ofMonths()`和`ofYears()`，也可以使用：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that the `ofWeeks()` method is a helper method to build `java.time.Period`
    based on days by accepting the number of weeks.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ofWeeks()`方法是一个辅助方法，用于根据接受的周数构建`java.time.Period`。
- en: 'The period can also be constructed using the period string, which is generally
    of the form `P<x>Y<y>M<z>D` where `x`, `y`, and `z` represent the number of years,
    months, and days respectively:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期间也可以使用期间字符串构造，该字符串通常采用`P<x>Y<y>M<z>D`的形式，其中`x`，`y`和`z`分别表示年、月和日的数量：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can also compute the period between two instances of `java.time.ChronoLocalDate`
    (one of its implementations is `java.time.LocalDate`):'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以计算`java.time.ChronoLocalDate`的两个实例之间的期间（其实现之一是`java.time.LocalDate`）：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These are the most useful ways to create an instance of `java.time.Period`.
    The start date is inclusive and the end date is exclusive.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是创建`java.time.Period`实例的最有用的方法。开始日期是包含的，结束日期是不包含的。
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We make use of the factory methods in `java.time.Period` to create its instance.
    The `java.time.Period` has three fields to hold the values for year, month, and
    day respectively, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用`java.time.Period`中的工厂方法来创建其实例。`java.time.Period`有三个字段分别用于保存年、月和日的值，如下所示：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There is an interesting set of methods, namely, `withDays()`, `withMonths()`,
    and `withYears()`. These methods return the same instance if the field that it''s
    trying to update has the same value; otherwise, it returns a new instance with
    updated values, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一组有趣的方法，即`withDays()`，`withMonths()`和`withYears()`。如果它正在尝试更新的字段具有相同的值，则这些方法返回相同的实例；否则，它返回一个具有更新值的新实例，如下所示：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There's more…
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'We can even compute `java.time.Period` between the two date instances using
    the `until()` method present in `java.time.ChronoLocalDate`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用`java.time.ChronoLocalDate`中的`until()`方法计算两个日期实例之间的`java.time.Period`：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Given an instance of `java.time.Period`, we can use it to manipulate a given
    date instance. There are two possible ways:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`java.time.Period`的一个实例，我们可以使用它来操作给定的日期实例。有两种可能的方法：
- en: Using the `addTo` or `subtractFrom` method of the period object
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用期间对象的`addTo`或`subtractFrom`方法
- en: Using the `plus` or `minus` method of the date object
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用日期对象的`plus`或`minus`方法
- en: 'Both of the approaches are shown in the following snippets:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都显示在以下代码片段中：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'On similar lines, you can try out the `subtractFrom` and `minus` methods. There
    is another set of methods used to manipulate the `java.time.Period` instance,
    namely, the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以尝试`subtractFrom`和`minus`方法。还有另一组用于操作`java.time.Period`实例的方法，即以下方法：
- en: '`minus`, `minusDays`, `minusMonths`, and `minusYears`: Subtract the given value
    from the period.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minus`，`minusDays`，`minusMonths`和`minusYears`：从期间中减去给定的值。'
- en: '`plus`, `plusDays`, `plusMonths`, and `plusYears`: Add the given value to the
    period.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plus`，`plusDays`，`plusMonths`和`plusYears`：将给定的值添加到期间。'
- en: '`negated`: Returns the new period with each of its values negated.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`negated`：返回每个值都取反的新期间。'
- en: '`normalized`: Returns a new period by normalizing its higher-order fields,
    such as months and days. For example, 15 months is normalized to 1 year and 3
    months.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`normalized`：通过规范化其更高阶字段（如月和日）返回一个新的期间。例如，15个月被规范化为1年和3个月。'
- en: 'We will show you these methods in action as follows, starting with the `minus`
    methods:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示这些方法的操作，首先是`minus`方法：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we will see the `plus` methods:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将看到`plus`方法：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, here are the `negated()` and `normalized()` methods:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是`negated()`和`normalized()`方法：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Observe that, in both of the earlier cases, it is not mutating the existing
    period, instead of returning a new instance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的两种情况下，它并没有改变现有的期间，而是返回一个新的实例。
- en: How to create a time-based period between time instances
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何创建基于时间的期间实例
- en: In our previous recipe, we created a date-based period, which is represented
    by `java.time.Period`. In this recipe, we will look at creating a time-based difference
    between time instances in terms of seconds and nanoseconds using the `java.time.Duration`
    class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们创建了一个基于日期的期间，由`java.time.Period`表示。在这个示例中，我们将看看如何使用`java.time.Duration`类来以秒和纳秒的方式创建时间实例之间的时间差异。
- en: 'We will look at different ways to create an instance of `java.time.Duration`,
    manipulate the duration instance, and obtain the duration in terms of different
    units, such as hours and minutes. The ISO 8601 standard specifies one of the possible
    patterns for representing duration to be `PnYnMnDTnHnMnS`, where the following
    applies:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看创建`java.time.Duration`实例的不同方法，操作持续时间实例，并以小时和分钟等不同单位获取持续时间。ISO 8601标准指定了表示持续时间的可能模式之一为`PnYnMnDTnHnMnS`，其中以下内容适用：
- en: '`Y`, `M`, and `D` represent the date component fields, namely, year, month,
    and day'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Y`，`M`和`D`代表日期组件字段，即年、月和日'
- en: '`T` separates the date with the time information'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T`用于将日期与时间信息分隔开'
- en: '`H`, `M`, and `S` represent the time component fields, namely, hour, minutes,
    and seconds'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`H`，`M`和`S`代表时间组件字段，即小时、分钟和秒'
- en: The string representation implementation of `java.time.Duration` is loosely
    based on the ISO 8601\. There is more on this in the *How it works* section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time.Duration`的字符串表示实现基于ISO 8601。在*它是如何工作*部分中有更多内容。'
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好了
- en: You need at least JDK 8 to play around with `java.time.Duration` and JDK 9 to
    be able to make use of JShell.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您至少需要JDK 8才能使用`java.time.Duration`，并且需要JDK 9才能使用JShell。
- en: How to do it…
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: '`java.time.Duration` instances can be created using the `of*()` factory methods.
    We will show using a few of them, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`of*()`工厂方法创建`java.time.Duration`实例。我们将展示如何使用其中的一些方法，如下所示：
- en: '[PRE35]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'They can also be created by parsing the duration string, as follows:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们也可以通过解析持续时间字符串来创建，如下所示：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'They can be constructed by finding the span between two `java.time.Temporal`
    instances, which support time information (that is, instances of `java.time.LocalDateTime`
    and the likes), as follows:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们可以通过查找两个支持时间信息的`java.time.Temporal`实例之间的时间跨度来构建，这些实例支持时间信息（即`java.time.LocalDateTime`等的实例），如下所示：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works…
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The data required for `java.time.Duration` is stored in two fields representing
    seconds and nanoseconds respectively. There are convenience methods provided to
    get the duration in terms of minutes, hours, and days, namely, `toMinutes()`,
    `toHours()`, and `toDays()`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time.Duration`所需的数据存储在两个字段中，分别表示秒和纳秒。提供了一些便利方法，以分钟、小时和天为单位获取持续时间，即`toMinutes()`、`toHours()`和`toDays()`。'
- en: Let's discuss the string representation implementation. `java.time.Duration`
    supports parsing the ISO string representation containing only the day component
    in the date part and hours, minutes, seconds, and nanoseconds in the time part.
    For example, `P2DT3M` is acceptable, whereas parsing `P3M2DT3M` results in `java.time.format.DateTimeParseException`
    because the string contains the month component in the date part.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论字符串表示实现。`java.time.Duration`支持解析ISO字符串表示，其中日期部分仅包含天组件，时间部分包含小时、分钟、秒和纳秒。例如，`P2DT3M`是可接受的，而解析`P3M2DT3M`将导致`java.time.format.DateTimeParseException`，因为字符串包含日期部分的月份组件。
- en: 'The `toString()` method of `java.time.Duration` always returns a string of
    the `PTxHyMz.nS` form, where `x` represents the number of hours, `y` represents
    the number of minutes, and `z.n` represents the number of seconds to nanosecond
    precision. Let''s see some examples:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time.Duration`的`toString()`方法始终返回`PTxHyMz.nS`形式的字符串，其中`x`表示小时数，`y`表示分钟数，`z.n`表示秒数到纳秒精度。让我们看一些例子：'
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There's more…
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let''s look at the manipulation methods provided, which allow adding/subtracting
    a value from the specific unit of time, such as days, hours, minutes, seconds,
    or nanoseconds. Each of these methods is immutable, so a new instance is returned
    each time, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下提供的操作方法，这些方法允许从特定的时间单位（如天、小时、分钟、秒或纳秒）中添加/减去一个值。每个方法都是不可变的，因此每次都会返回一个新实例，如下所示：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Similarly, you can try out the `minus*()` methods, which does the subtraction.
    Then there are methods that manipulate the instances of  `java.time.LocalDateTime`,
    `java.time.ZonedDateTime`, and their like. These methods add/subtract the duration
    to/from the date/time information. Let''s see some examples:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以尝试`minus*()`方法，进行减法。然后有一些方法可以操作`java.time.LocalDateTime`、`java.time.ZonedDateTime`等的实例。这些方法将持续时间添加/减去日期/时间信息。让我们看一些例子：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can observe in the preceding example that we got an exception when we tried
    to add the duration to the entity containing only date information.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到在前面的示例中，当我们尝试将持续时间添加到仅包含日期信息的实体时，我们得到了一个异常。
- en: How to represent epoch time
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何表示纪元时间
- en: In this recipe, we will look at using `java.time.Instant` to represent a point
    in time, as well as convert that point in time to epoch seconds/milliseconds.
    The Java epoch is used to refer to the time instant 1970-01-01 to 0:00:00Z and
    `java.time.Instant` stores the number of seconds from the Java epoch. A positive
    value indicates the time is ahead of the epoch and negative indicates the time
    is behind the epoch. It uses the system clock in UTC to compute the current time
    instant value.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将学习如何使用`java.time.Instant`来表示一个时间点，并将该时间点转换为纪元秒/毫秒。Java纪元用于指代时间瞬间1970-01-01
    00:00:00Z，`java.time.Instant`存储了从Java纪元开始的秒数。正值表示时间超过了纪元，负值表示时间落后于纪元。它使用UTC中的系统时钟来计算当前时间瞬间值。
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to have JDK supporting new Date/Time APIs and JShell installed to be
    able to try out the solution provided.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装支持新日期/时间API和JShell的JDK，才能尝试提供的解决方案。
- en: How to do it…
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will just create an instance of `java.time.Instant` and print out the epoch
    seconds, which will give the time in UTC after the Java epoch:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个`java.time.Instant`实例，并打印出纪元秒，这将给出Java纪元后的UTC时间：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also print out the epoch milliseconds, which shows the number of milliseconds
    after the epoch. This is a bit more precise than just seconds:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以打印出纪元毫秒，这显示了纪元后的毫秒数。这比仅仅秒更精确：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How it works…
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `java.time.Instant` class stores the time information in its two fields:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time.Instant`类将时间信息存储在其两个字段中：'
- en: Seconds, which is of the `long` type: This stores the number of seconds from
    the epoch of 1970-01-01T00:00:00Z.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秒，类型为`long`：这存储了从1970-01-01T00:00:00Z纪元开始的秒数。
- en: 'Nanos, which is of the `int `type: This stores the number of nanoseconds'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纳秒，类型为`int`：这存储了纳秒数
- en: When you invoke the `now()` method,  `java.time.Instant` uses the system clock
    in UTC to represent that time instant. And then we can use `atZone()` or `atOffset()`
    to convert it into the required time zone, as we will see in the next section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用`now()`方法时，`java.time.Instant`使用UTC中的系统时钟来表示该时间瞬间。然后我们可以使用`atZone()`或`atOffset()`将其转换为所需的时区，我们将在下一节中看到。
- en: Use this class if you want to just represent the timeline of actions in UTC;
    that way, the timestamp stored for different events will be based on UTC and you
    can then convert it into your required time zone as and when required.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想表示UTC中的操作时间线，那么存储不同事件的时间戳将基于UTC，并且您可以在需要时将其转换为所需的时区。
- en: There's more…
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can manipulate the `java.time.Instant` by adding/subtracting nanoseconds,
    milliseconds, and seconds, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加/减去纳秒、毫秒和秒来操纵`java.time.Instant`，如下所示：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Similarly, you can try out the `minus*()` methods. We can also obtain the time
    zone-dependent date time using the `java.time.Instant` methods, `atOffset()` and
    `atZone()`, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以尝试`minus*()`方法。我们还可以使用`java.time.Instant`方法获取依赖于时区的日期时间，如`atOffset()`和`atZone()`所示：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How to manipulate date and time instances
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操纵日期和时间实例
- en: The date and time classes, `java.time.LocalDate`, `java.time.LocalTime`, `java.time.LocalDateTime`,
    and `java.time.ZonedDateTime`, provide methods to add and subtract values from
    their components, namely, days, hours, minutes, seconds, weeks, months, years,
    and others.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 日期和时间类`java.time.LocalDate`、`java.time.LocalTime`、`java.time.LocalDateTime`和`java.time.ZonedDateTime`提供了从它们的组件中添加和减去值的方法，即天、小时、分钟、秒、周、月、年等。
- en: In this recipe, we will look at a few such methods, which can be used to manipulate
    date and time instances by adding and subtracting different values.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看一些可以用来通过添加和减去不同的值来操纵日期和时间实例的方法。
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You will need a JDK installation that supports the new Date/Time APIs and the
    JShell console.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要安装支持新的日期/时间API和JShell控制台的JDK。
- en: How to do it…
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s manipulate`java.time.LocalDate`:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们操纵`java.time.LocalDate`：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s manipulate the date and time instance, `java.time.LocalDateTime`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们操纵日期和时间实例，`java.time.LocalDateTime`：
- en: '[PRE46]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s manipulate the time zone-dependent date and time, `java.time.ZonedDateTime`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们操纵依赖于时区的日期和时间，`java.time.ZonedDateTime`：
- en: '[PRE47]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There's more…
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We just looked at a few of the add and subtract APIs represented by `plus*()`
    and `minus*()`. There are different methods provided to manipulate different components
    of date and time, such as years, days, months, hours, minutes, seconds, and nanoseconds.
    You can try those APIs as an exercise.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看了一些由`plus*()`和`minus*()`表示的添加和减去API。还提供了不同的方法来操纵日期和时间的不同组件，如年、日、月、小时、分钟、秒和纳秒。您可以尝试这些API作为练习。
- en: How to compare date and time
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何比较日期和时间
- en: Often, we would want to compare date and time instances with others to check
    if they are before, after, or the same as that of the other. To achieve this,
    JDK provides `isBefore()`, `isAfter()`, and `isEqual()` methods in the `java.time.LocalDate`,
    `java.time.LocalDateTime`, and `java.time.ZonedDateTime` classes. In this recipe,
    we will look at using these methods to compare date and time instances.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望将日期和时间实例与其他实例进行比较，以检查它们是在之前、之后还是与其他实例相同。为了实现这一点，JDK在`java.time.LocalDate`、`java.time.LocalDateTime`和`java.time.ZonedDateTime`类中提供了`isBefore()`、`isAfter()`和`isEqual()`方法。在这个示例中，我们将看看如何使用这些方法来比较日期和时间实例。
- en: Getting ready
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You will need a JDK installation that has the new Date/Time APIs and supports
    JShell.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要安装具有新的日期/时间API并支持JShell的JDK。
- en: How to do it…
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s try out comparing two `java.time.LocalDate` instances:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试比较两个`java.time.LocalDate`实例：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can also compare the time zone-dependent date and time instances:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以比较依赖于时区的日期和时间实例：
- en: '[PRE49]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There's more…
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The comparison can be performed on `java.time.LocalTime` and `java.time.LocalDateTime`.
    This is left to the reader to explore.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 比较可以在`java.time.LocalTime`和`java.time.LocalDateTime`上进行。这留给读者去探索。
- en: How to work with different calendar systems
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用不同的日历系统
- en: So far in our recipes, we worked with the ISO calendar system, which is the
    de facto calendar system followed in the world. There are other regional calendar
    systems followed in the world, such as Hijrah, Japanese, and Thai. JDK provides
    support for such calendar systems as well.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的示例中，我们使用了ISO日历系统，这是世界上遵循的事实标准日历系统。世界上还有其他地区遵循的日历系统，如伊斯兰历、日本历和泰国历。JDK也为这些日历系统提供了支持。
- en: 'In this recipe, we will look at working with two calendar systems: Japanese
    and the Hijri.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看看如何使用两个日历系统：日本和伊斯兰历。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You should have a JDK installed that supports the new Date/Time APIs and the
    JShell tool.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该安装支持新的日期/时间API和JShell工具的JDK。
- en: How to do it…
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s print the current date in the different calendar systems supported by
    JDK:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打印JDK支持的不同日历系统中的当前日期：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s play around with the date represented in the Japanese calendar system:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们玩弄一下用日本日历系统表示的日期：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Different eras supported in the Japanese calendar can be enumerated using `java.time.chrono.JapeneseEra`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日本日历中支持的不同纪元可以使用`java.time.chrono.JapeneseEra`进行枚举：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s create a date in the Hijrah calendar system:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在伊斯兰历中创建一个日期：
- en: '[PRE53]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can even convert the ISO date/time into date/time in the Hijrah calendar
    system as follows:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们甚至可以将ISO日期/时间转换为伊斯兰历的日期/时间，如下所示：
- en: '[PRE54]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How it works…
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The calendar system is represented by `java.time.chrono.Chronology` and its
    implementations, a few of which are `java.time.chrono.IsoChronology`, `java.time.chrono.HijrahChronology`,
    and `java.time.chrono.JapaneseChronology`. `java.time.chrono.IsoChronology` is
    the ISO-based de facto calendar system used in the world. The date in each of
    these calendar systems is represented by `java.time.chrono.ChronoLocalDate` and
    its implementations, some of which are `java.time.chrono.HijrahDate`, `java.time.chrono.JapaneseDate`,
    and the well-known `java.time.LocalDate`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 日历系统由`java.time.chrono.Chronology`及其实现表示，其中一些是`java.time.chrono.IsoChronology`、`java.time.chrono.HijrahChronology`和`java.time.chrono.JapaneseChronology`。`java.time.chrono.IsoChronology`是世界上使用的基于ISO的事实标准日历系统。每个日历系统中的日期由`java.time.chrono.ChronoLocalDate`及其实现表示，其中一些是`java.time.chrono.HijrahDate`、`java.time.chrono.JapaneseDate`和著名的`java.time.LocalDate`。
- en: 'To be able to use these APIs in JShell, you need to import the relevant packages,
    as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在JShell中使用这些API，您需要导入相关的包，如下所示：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is applicable to all the recipes that use JShell.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于所有使用JShell的示例。
- en: 'We can directly play with the implementations of `java.time.chrono.ChronoLocalDate`,
    such as `java.time.chrono.JapaneseDate`, or use the implementation of `java.time.chrono.Chronology`
    to obtain relevant date representations, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用`java.time.chrono.ChronoLocalDate`的实现，例如`java.time.chrono.JapaneseDate`，或者使用`java.time.chrono.Chronology`的实现来获取相关的日期表示，如下所示：
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: From the preceding code snippets, we can see that one can convert the ISO system
    date into dates in the required calendar system by using their calendar system's
    `date(TemporalAccessor temporal)` method.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们可以看到可以使用其日历系统的`date(TemporalAccessor temporal)`方法将ISO系统日期转换为所需日历系统中的日期。
- en: There's more…
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多…
- en: You can play around with the other calendar systems supported in JDK, namely,
    Thai, Buddhist, and Minguo (Chinese) calendar systems. It's also worth exploring
    to create our custom calendar systems by writing an implementation of `java.time.chrono.Chronology`,
    `java.time.chrono.ChronoLocalDate`, and `java.time.chrono.Era`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以尝试使用JDK支持的其他日历系统，即泰国、佛教和民国（中国）日历系统。还值得探索如何通过编写`java.time.chrono.Chronology`、`java.time.chrono.ChronoLocalDate`和`java.time.chrono.Era`的实现来创建我们自定义的日历系统。
- en: How to format dates using the DateTimeFormatter
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用DateTimeFormatter格式化日期
- en: 'While working with `java.util.Date`, we made use of `java.text.SimpleDateFormat`
    to format the date into different text representations and vice versa. Formatting
    a date means, given a date or a time object representing it in different formats,
    such as the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`java.util.Date`时，我们使用`java.text.SimpleDateFormat`将日期格式化为不同的文本表示形式，反之亦然。格式化日期意味着，以不同格式表示给定日期或时间对象，例如以下格式：
- en: 23 Jun 2018
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2018年6月23日
- en: 23-08-2018
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2018年8月23日
- en: '2018-08-23'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '2018-08-23'
- en: 23 Jun 2018 11:03:33 AM
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2018年6月23日上午11:03:33
- en: 'These formats are controlled by format strings, such as the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式由格式字符串控制，例如以下格式：
- en: '`dd MMM yyyy`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dd MMM yyyy`'
- en: '`dd-MM-yyyy`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dd-MM-yyyy`'
- en: '`yyyy-MM-DD`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`yyyy-MM-DD`'
- en: '`dd MMM yyyy hh:mm:ss`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dd MMM yyyy hh:mm:ss`'
- en: In this recipe, we will look at `java.time.format.DateTimeFormatter` to format
    the date and time instances in the new date and time API and also look at the
    most commonly used pattern letters.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用`java.time.format.DateTimeFormatter`来格式化新日期和时间API中的日期和时间实例，并查看最常用的模式字母。
- en: Getting ready
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need a JDK that has the new Date/Time APIs as well as the `jshell`
    tool.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要一个具有新的日期/时间API和`jshell`工具的JDK。
- en: How to do it…
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s use the built-in formats to format the date and time:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用内置格式来格式化日期和时间：
- en: '[PRE57]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s create a custom date/time format:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个自定义的日期/时间格式：
- en: '[PRE58]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s use the custom `java.time.format.DateTimeFormatter` for formatting the
    current date/time:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用自定义的`java.time.format.DateTimeFormatter`来格式化当前的日期/时间：
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: How it works…
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Let''s understand the most commonly used format letters:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解最常用的格式字母：
- en: '| **Symbol** | **Meaning** | **Example** |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | **意义** | **示例** |'
- en: '| `d` | day of the month | 1,2,3,5 |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 一个月中的日期 | 1,2,3,5 |'
- en: '| `M`, `MMM`, `MMMM` | month of the year | `M`: 1,2,3,`MMM`: Jun, Jul, Aug`MMMM`:
    July, August |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `M`, `MMM`, `MMMM` | 一年中的月份 | `M`: 1,2,3,`MMM`: 六月，七月，八月`MMMM`: 七月，八月 |'
- en: '| `y`, `yy` | year | `y`, `yyyy`: 2017, 2018`yy`: 18, 19 |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `y`, `yy` | 年 | `y`, `yyyy`: 2017, 2018`yy`: 18, 19 |'
- en: '| `h` | hour of the day (1-12) | 1, 2, 3 |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `h` | 一天中的小时（1-12） | 1, 2, 3 |'
- en: '| `k` | hour of the day (0-23) | 0, 1, 2, 3 |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `k` | 一天中的小时（0-23） | 0, 1, 2, 3 |'
- en: '| `m` | minutes | 1, 2, 3 |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `m` | 分钟 | 1, 2, 3 |'
- en: '| `s` | seconds | 1, 2, 3 |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 秒 | 1, 2, 3 |'
- en: '| `a` | AM/PM of the day | AM, PM |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 一天中的上午/下午 | 上午，下午 |'
- en: '| `VV` | Time zone ID | Asia/Kolkata |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `VV` | 时区ID | 亚洲/加尔各答 |'
- en: '| `ZZ` | Time zone name | IST, PST, AST |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `ZZ` | 时区名称 | IST, PST, AST |'
- en: '| `O` | Time zone offset | GMT+5:30, GMT+3 |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `O` | 时区偏移 | GMT+5:30, GMT+3 |'
- en: 'Based on the preceding format letters, let''s format `java.time.ZonedDateTime`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的格式字母，让我们格式化`java.time.ZonedDateTime`：
- en: '[PRE60]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`java.time.format.DateTimeFormatter` comes shipped with plenty of default formatting
    based on the ISO standards. These formats should be more than enough when you
    are dealing with the date manipulation without any user being involved, that is,
    when the date and time is being exchanged between different layers of the application.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time.format.DateTimeFormatter`附带了基于ISO标准的大量默认格式。当您处理日期操作而没有用户参与时，这些格式应该足够了，也就是说，当日期和时间在应用程序的不同层之间交换时。'
- en: 'But for presenting the date and time information to an end user, we would need
    to format it in a readable format and, for that, we would need a custom `DateTimeFormatter`.
    If you need a custom `java.time.format.DateTimeFormatter`, here are two ways of
    creating one:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为了向最终用户呈现日期和时间信息，我们需要以可读的格式对其进行格式化，为此，我们需要一个自定义的`DateTimeFormatter`。如果您需要自定义的`java.time.format.DateTimeFormatter`，有两种创建方式：
- en: Using a pattern, such as dd MMMM yyyy and the `ofPattern()` method in `java.time.format.DateTimeFormatter`
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模式，例如dd MMMM yyyy和`java.time.format.DateTimeFormatter`中的`ofPattern()`方法
- en: Using `java.time.DateTimeFormatterBuilder`
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`java.time.DateTimeFormatterBuilder`
- en: '**Using Pattern**:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用模式**：'
- en: 'We create an instance of `java.time.format.DateTimeFormatter`, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`java.time.format.DateTimeFormatter`的实例，如下所示：
- en: '[PRE61]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And then we apply the format to a date and time instance:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将格式应用到日期和时间实例：
- en: '[PRE62]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The pattern approach also uses `DateTimeFormatterBuilder` wherein the builder
    parses the given format string to build a `DateTimeFormatter` object.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 模式方法也使用`DateTimeFormatterBuilder`，其中构建器解析给定的格式字符串以构建`DateTimeFormatter`对象。
- en: '**Using `java.time.format.DateTimeFormatterBuilder`:**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用`java.time.format.DateTimeFormatterBuilder`：**'
- en: 'Let''s build `DateTimeFormatter` using `DateTimeFormatterBuilder`, as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`DateTimeFormatterBuilder`来构建`DateTimeFormatter`，如下所示：
- en: '[PRE63]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You can observe that a `DateTimeFormatter` object consists of a set of instructions
    on how to represent the date and time. These instructions are presented in form
    of `Value()`, `Text()`, and delimiters.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到`DateTimeFormatter`对象由一组指令组成，用于表示日期和时间。这些指令以`Value()`、`Text()`和分隔符的形式呈现。
