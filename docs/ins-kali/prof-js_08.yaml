- en: '*Chapter 8*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: Asynchronous Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够：
- en: Describe the workings of an asynchronous operation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述异步操作的工作原理
- en: Use callback to handle async operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用回调处理异步操作
- en: Demonstrate callbacks and event loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示回调和事件循环
- en: Implement promises to handle async operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现承诺来处理异步操作
- en: Rewrite async code with callbacks using promises
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用承诺重写带有回调的异步代码
- en: Refactor your legacy code using async and await functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构您的传统代码，使用async和await函数
- en: In this chapter, we will explore the asynchronous (later abbreviated as async)
    nature of JavaScript. The focus will be on how conventional languages handle operations
    that take time to complete, and how JavaScript handles these operations. Later,
    we will discuss various methods we can adopt to handle these situations in JavaScript.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨JavaScript的异步（后面简称为async）特性。重点将放在传统语言如何处理需要时间完成的操作以及JavaScript如何处理这些操作上。之后，我们将讨论在JavaScript中处理这些情况的各种方法。
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned how we can use arrays and objects and their
    helper functions. In this chapter, we will learn more about how JavaScript runs
    and how we can handle time-consuming operations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用数组和对象以及它们的辅助函数。在本章中，我们将更多地了解JavaScript的运行方式以及如何处理耗时操作。
- en: 'When working on large-scale projects with JavaScript, often, we must deal with
    network requests, disk IO, and data processing. Many of these operations take
    time to complete, and for beginners who have just started using JavaScript, it
    is very difficult to understand how to retrieve the results of these time-consuming
    operations. This is because, unlike other languages, JavaScript has a special
    way of handling these operations. When coding programs, we are used to linear
    thinking; that is, the program executes line by line and only breaks that flow
    when we have loops or branches. For example, if you wanted to make a simple network
    request in Java, you would have to do something similar to what''s shown in the
    following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理JavaScript的大型项目时，通常我们必须处理网络请求、磁盘IO和数据处理。许多这些操作需要时间完成，对于刚开始使用JavaScript的初学者来说，很难理解如何检索这些耗时操作的结果。这是因为，与其他语言不同，JavaScript有一种特殊的处理这些操作的方式。在编写程序时，我们习惯于线性思维；也就是说，程序逐行执行，只有在有循环或分支时才会打破这种流程。例如，如果你想在Java中进行简单的网络请求，你将不得不做类似于下面代码中所示的事情：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It''s simple to understand: you create an HTTP client and call a method within
    the client to request the contents of that URL. Once the request is made and a
    response is received, it will continue to run the next line of code that returns
    the body of the response. During this time, the whole function will halt and wait
    for the `fetch` and will only continue once the request is completed. This is
    the normal way these operations are handled in other languages. This way of handling
    time-consuming operations is called **synchronous handling** because it forces
    the program to pause and only resume once the operation is completed.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 理解起来很简单：你创建一个HTTP客户端，并在客户端内调用一个方法来请求该URL的内容。一旦请求被发出并收到响应，它将继续运行返回响应主体的下一行代码。在此期间，整个函数将暂停并等待`fetch`，只有在请求完成后才会继续。这是其他语言中处理这些操作的正常方式。处理耗时操作的这种方式称为**同步处理**，因为它强制程序暂停，只有在操作完成后才会恢复。
- en: 'Because of this linear thinking, many developers (including me) get very confused
    when they first start coding in JavaScript. Most people will start writing code
    like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种线性思维，许多开发人员（包括我）在开始使用JavaScript编码时会感到非常困惑。大多数人会开始编写这样的代码：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the look of the code, it should behave just like our preceding code. It
    will make the request, set the response variable to the response body once it
    is completed, and then it will output the response. Most developers that have
    tried this will know that this is not how JavaScript works; the code will run,
    produce 'undefined' output, and exit.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码的外观来看，它应该像我们之前的代码一样运行。它将发出请求，一旦完成，将响应变量设置为响应主体，然后输出响应。大多数尝试过这种方法的开发人员都会知道，这不是JavaScript的工作方式；代码将运行，产生'undefined'输出，然后退出。
- en: How JavaScript Handles Time-Consuming Operations
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript如何处理耗时操作
- en: 'In JavaScript, these operations are often handled using async programming.
    There are multiple ways to do that in JavaScript; the most widely used method,
    and the one you will see the most in legacy programs, is called a **callback**.
    A callback is just a fancy term for passing a function that includes the rest
    of your application logic to another function; they are actually very easy to
    understand. Consider the fact that traditional functions return their values once
    the logic is complete. In async programming, they often don''t return a value;
    instead, they pass their result to the callback function provided by the caller.
    Consider the following code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，这些操作通常使用异步编程来处理。在JavaScript中有多种方法可以做到这一点；最常用的方法，也是你在传统程序中最常见的方法，就是**回调**。回调只是一个传递包含应用程序其余逻辑的函数给另一个函数的花哨术语；它们实际上非常容易理解。考虑传统函数在逻辑完成后返回它们的值。在异步编程中，它们通常不返回值；相反，它们将它们的结果传递给调用者提供的回调函数。考虑以下代码：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s look at why this is not going to produce the result we want. The `request`
    library that we have used can be considered as a function that performs some operation
    logic that is time-consuming. The `request` function expects you to pass it a
    parameter as a callback that includes everything you are about to do next. In
    the callback function, we accept two parameters, `err` and `res`; inside the function,
    we assign the response variable we declared earlier to the `res` body (the response
    body). Outside the `request` function, we have `console.log` to log out the response.
    Because the callback function will get called sometime in the future, we will
    log the value of the response before we set any value to it. Most developers get
    very frustrated when dealing with JavaScript because the preceding code is not
    linear. The order of the execution follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看为什么这不会产生我们想要的结果。我们使用的`request`库可以被视为执行一些耗时操作逻辑的函数。`request`函数希望你传递一个回调函数作为参数，该回调函数包括你接下来要做的一切。在回调函数中，我们接受两个参数，`err`和`res`；在函数内部，我们将之前声明的响应变量赋值给`res`体（响应体）。在`request`函数外部，我们有`console.log`来记录响应。因为回调函数将在将来的某个时刻被调用，所以我们会在给它设置任何值之前记录响应的值。大多数开发人员在处理JavaScript时会感到非常沮丧，因为上面的代码不是线性的。执行的顺序如下：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see from the order of execution in the preceding code, the first
    three lines work just as we expected. We import the `request` library and declare
    a variable response, and then call the `request` library with a URL with a callback.
    Because the callback is only invoked when the network request finishes, the program
    will continue executing the rest of the code, which outputs the response.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码执行顺序可以看出，前三行的工作正如我们所期望的那样。我们导入了`request`库并声明了一个响应变量，然后调用了带有回调的`request`库。因为回调只有在网络请求完成时才会被调用，程序将继续执行其余的代码，输出响应。
- en: 'Lastly, when the network request is finished, it will invoke our callback function
    and run the line that assigns the body to our response. To make this code behave
    as we expected, we need to modify the code to the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当网络请求完成时，它将调用我们的回调函数并运行将体分配给我们的响应的行。为了使这段代码表现如我们所期望的那样，我们需要修改代码如下：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we pulled `console.log` inside the callback so that it
    can be executed only when the assignment is complete. Now, when we run this code,
    it will output the actual response body.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们将`console.log`放在回调函数内部，这样它只有在赋值完成后才会被执行。现在，当我们运行这段代码时，它将输出实际的响应体。
- en: Handling Async Operations Using Callbacks
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用回调处理异步操作
- en: In the introduction, we talked about how JavaScript treats async operations
    differently compared with other languages. In this chapter, we will explore how
    we can write complex JavaScript applications with many async operations using
    the callback method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍中，我们谈到了JavaScript如何与其他语言不同地处理异步操作。在本章中，我们将探讨如何使用回调方法编写包含许多异步操作的复杂JavaScript应用程序。
- en: 'Exercise 61: Writing Your First Callback'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习61：编写您的第一个回调
- en: In this exercise, we will first write a small function mimicking a function
    that takes a while to finish. Later, we will write another function that consumes
    our async function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将首先编写一个模拟需要一段时间才能完成的函数。之后，我们将编写另一个消耗我们异步函数的函数。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this exercise can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise61](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise61).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码文件可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise61](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise61)找到。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'Create a `slowAPI` object to create a mock API library; its purpose is to return
    the results in a reasonable amount of time. We write this first to introduce you
    to how we can mimic an async function without the need to perform async operations:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`slowAPI`对象来创建一个模拟API库；它的目的是在合理的时间内返回结果。我们首先编写这个来介绍如何模拟异步函数而无需执行异步操作。
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a `getUsers` function in the `slowAPI` object we just defined that returns
    nothing and expects a callback. Call the `setTimeout` function inside `getUsers`,
    which is used to add a 1-second delay to our code if needed:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们刚刚定义的`slowAPI`对象中创建一个`getUsers`函数，它不返回任何内容，需要一个回调函数。在`getUsers`内部调用`setTimeout`函数，用于在需要时给我们的代码添加1秒的延迟：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a `getCart` function in the `slowAPI` object and create an `if-else`
    loop inside the function to match the username and return an error if it doesn''t:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`slowAPI`对象中创建一个`getCart`函数，并在函数内部创建一个`if-else`循环，匹配用户名并在不匹配时返回错误：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a `runRequests` function that calls `getUsers` to grab a user list.
    Inside the callback function, we are going to print out the response or error:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`runRequests`函数，调用`getUsers`来获取用户列表。在回调函数内部，我们将打印出响应或错误：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Call the `run Request` function:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`run Request`函数：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output should be as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.1: Output of runRequest'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1：runRequest的输出'
- en: '](Images/C14587_08_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_01.jpg)'
- en: 'Figure 8.1: Output of runRequest'
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.1：runRequest的输出
- en: We can see that the `runRequest` function has finished running and our response
    is correctly printed out.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`runRequest`函数已经运行完毕，我们的响应被正确打印出来。
- en: 'Modify the `runRequest` function to call `getCart` as well:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`runRequest`函数以调用`getCart`：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we put a similar call to `slowAPI` inside our `runRequest` function;
    nothing else is changed. When we run this, we get a very interesting output, as
    follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`runRequest`函数内部放置了一个类似的对`slowAPI`的调用；其他都没有改变。当我们运行这个时，我们得到了一个非常有趣的输出，如下所示：
- en: '![Figure 8.2: Output after modifying the runRequest function'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2：修改runRequest函数后的输出'
- en: '](Images/C14587_08_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_02.jpg)'
- en: 'Figure 8.2: Output after modifying the runRequest function'
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.2：修改runRequest函数后的输出
- en: It's very interesting because it first outputs the result from `getCart`, and
    then the result for `getUsers`. The program is behaving like this because of the
    async and non-blocking nature of JavaScript. In our operations, because the `getCart`
    function only takes 500 milliseconds to complete, it will be the first output.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有趣，因为它首先输出了`getCart`的结果，然后是`getUsers`的结果。程序之所以表现如此，是因为JavaScript的异步和非阻塞特性。在我们的操作中，因为`getCart`函数只需要500毫秒就能完成，所以它将是第一个输出。
- en: 'Modify the preceding function to output the cart of the first user:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改前面的函数以输出第一个用户的购物车：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output should be as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.3: Output of the cart for the first user'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3：第一个用户的购物车输出'
- en: '](Images/C14587_08_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_03.jpg)'
- en: 'Figure 8.3: Output of the cart for the first user'
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.3：第一个用户的购物车输出
- en: Because we will be using the data from the first request, we must write the
    logic for our next request inside the callback of the first request.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将使用第一个请求的数据，所以我们必须在第一个请求的回调函数中编写我们下一个请求的逻辑。
- en: 'Trigger an error when accessing the cart of an unknown user:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在访问未知用户的购物车时触发错误：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'What we do know about the data we are returning from `getCart` is that the
    last user does not match any `if` statements. Therefore, it will throw an error
    when called. When we run the code, we will see the following error:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道从`getCart`返回的数据是，最后一个用户不匹配任何`if`语句。因此，在调用时会抛出错误。当我们运行代码时，将会看到以下错误：
- en: '![Figure 8.4: Printing the error'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4：打印错误'
- en: '](Images/C14587_08_04.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_04.jpg)'
- en: 'Figure 8.4: Printing the error'
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.4：打印错误
- en: The first error output we see in white is the error we are outputting through
    `console.error`. This can be customized to your preferred error message or output
    in a specific format using the logging framework. The second is from the process
    crashing because we are throwing a new error right after `console.log`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在白色中看到的第一个错误输出是通过`console.error`输出的错误。这可以根据您的喜好定制为特定格式的错误消息或输出，使用日志框架。第二个错误是由于我们在`console.log`后立即抛出新错误导致进程崩溃。
- en: In this exercise, we checked how we can mimic async functions with `setTimeout`.
    `setTimeout` is a very useful function. Although it's not really recommended for
    use in actual code, it is very useful if you need to mock a network request that
    takes time in tests or produces a race condition when debugging your software.
    Later, we went over ways to use async functions using callbacks and how error
    handling works in async functions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们检查了如何使用`setTimeout`模拟异步函数。`setTimeout`是一个非常有用的函数。虽然在实际代码中并不推荐使用，但在测试中需要模拟需要时间的网络请求或在调试软件时产生竞争条件时，它非常有用。之后，我们讨论了使用回调函数使用异步函数的方法以及异步函数中的错误处理方式。
- en: Next, we are going to briefly talk about why callbacks are slowly becoming outdated
    and what can happen if you don't use callbacks properly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将简要讨论为什么回调函数正在逐渐过时，以及如果不正确使用回调函数会发生什么。
- en: Event Loops
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件循环
- en: You might have heard this term before, referring to how JavaScript handles time-consuming
    operations. It is also very important to know how event loops work under the hood.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能以前听说过这个术语，指的是JavaScript如何处理耗时操作。了解事件循环在底层是如何工作也非常重要。
- en: 'When you consider what JavaScript is used most for, it is for making dynamic
    websites and it is used mostly in the browser. To the surprise of a lot of people,
    JavaScript code runs in a single thread, which simplifies a lot of things for
    developers, yet it opens challenges when dealing with multiple operations happening
    at the same time. In the JavaScript runtime, there is an infinite loop run in
    the background that manages messages for your code and handles events. The event
    loop is responsible for consuming callbacks in the callback queue, running functions
    in the stack, and calling web APIs. Most of the operations you can do in JavaScript
    are classified into two types: blocking and non-blocking. By blocking, we mean
    blocking the event loop (you can consider this as the normal UI thread for other
    languages). When the event loop is blocked, it cannot process any more events
    from other parts of the application, and the application will freeze until it
    is unblocked. Here is a list of sample operations and their classification:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑JavaScript最常用于什么时，它用于制作动态网站，主要在浏览器中使用。让很多人惊讶的是，JavaScript代码在单个线程中运行，这简化了开发人员的很多工作，但在处理同时发生的多个操作时会带来挑战。在JavaScript运行时，后台运行一个无限循环，用于管理代码的消息和处理事件。事件循环负责消耗回调队列中的回调、运行堆栈中的函数和调用Web
    API。JavaScript中大多数操作可分为两种类型：阻塞和非阻塞。阻塞意味着阻塞事件循环（您可以将其视为其他语言的正常UI线程）。当事件循环被阻塞时，它无法处理来自应用程序其他部分的更多事件，应用程序将冻结直到解除阻塞。以下是示例操作及其分类的列表：
- en: '![Figure 8.5: Table with sample operations and their classification'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5：带有示例操作及其分类的表'
- en: '](Images/C14587_08_05.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_05.jpg)'
- en: 'Figure 8.5: Table with sample operations and their classification'
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.5：带有示例操作及其分类的表
- en: 'What you can see from the preceding list is that almost all I/O in JavaScript
    is non-blocking, meaning that even if it takes more time to complete than expected,
    it will not block the event loop. Blocking the event loop, as in any language,
    is a terrible thing to do because it makes the application unstable and unresponsive.
    This brings us to a question: How can we know if a non-blocking operation was
    completed.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的列表中可以看到，几乎所有JavaScript中的I/O都是非阻塞的，这意味着即使完成时间比预期时间长，也不会阻塞事件循环。像任何语言一样，阻塞事件循环是一件糟糕的事情，因为它会使应用程序不稳定和无响应。这带来了一个问题：我们如何知道非阻塞操作是否已完成。
- en: How JavaScript Executes Code
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript如何执行代码
- en: When JavaScript is executing blocking code, it will block the loop and complete
    the operation before the program can continue with the rest of the code. If you
    run a loop that iterates 1 million times, the rest of your code must wait for
    that loop to finish before continuing. Therefore, it is not recommended to have
    a lot of blocking operations in your code because they affect performance, stability,
    and user experience. When JavaScript is executing non-blocking code, it initiates
    the process by handing it to web APIs to do the fetching, timeouts, and rests.
    Once the operation is complete, the callback is pushed to the callback queue so
    it can be consumed by the event loop later.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当JavaScript执行阻塞代码时，它会阻塞循环并在程序继续执行之前完成操作。如果你运行一个迭代100万次的循环，你的其余代码必须等待该循环完成才能继续。因此，在你的代码中不建议有大量阻塞操作，因为它们会影响性能、稳定性和用户体验。当JavaScript执行非阻塞代码时，它通过将进程交给Web
    API来进行获取、超时和休息。一旦操作完成，回调将被推送到回调队列中，以便稍后被事件循环消耗。
- en: 'In modern browsers, this is implemented as follows, where we have the heap
    that stores most of our object allocations, and the stack for the function calls.
    During each event loop cycle, the event loop favors the stack first and executes
    those events by calling appropriate web APIs. Once the operation is complete,
    the callback for that operation will then be pushed to the callback queue, which
    will be consumed later by the event loop:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代浏览器中，这是如何实现的，我们有一个堆来存储大部分对象分配，和一个用于函数调用的堆栈。在每个事件循环周期中，事件循环首先优先处理堆栈，并通过调用适当的Web
    API来执行这些事件。一旦操作完成，该操作的回调将被推送到回调队列中，稍后会被事件循环消耗：
- en: '![Figure 8.6: Event loop cycle'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6：事件循环周期'
- en: '](Images/C14587_08_06.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_06.jpg)'
- en: 'Figure 8.6: Event loop cycle'
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.6：事件循环周期
- en: 'To see how everything works under the hood, let''s consider the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解一切是如何在幕后运作的，让我们考虑以下代码：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'From the look of it, the code does two things: it creates a timeout that prints
    out ''`hi`'' after 2 seconds, and an infinite loop that does nothing at all. When
    you run the preceding code, it will behave a bit strangely – nothing gets printed
    out and the program just hangs. The reason it behaves like that is the event loop
    favors items on the stack more than items in the callback queue. Because we have
    an infinite `while` loop that keeps pushing to the call stack, the event loop
    is occupied with running the loop and ignores the completed `setTimeout` callback
    in the callback queue. Another interesting fact about the way `setTimeout` works
    is that we can use it to delay our function to the next cycle of the event loop.
    Consider the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从外观上看，这段代码做了两件事：创建一个在2秒后打印`hi`的超时，以及一个什么都不做的无限循环。当你运行上述代码时，它会表现得有点奇怪 - 什么都不会被打印出来，程序就会挂起。它表现得像这样的原因是事件循环更偏向于堆栈中的项目，而不是回调队列中的项目。因为我们有一个无限的`while`循环不断推入调用堆栈，事件循环忙于运行循环并忽略了回调队列中已完成的`setTimeout`回调。关于`setTimeout`工作方式的另一个有趣事实是，我们可以使用它来延迟我们的函数到事件循环的下一个周期。考虑以下代码：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, we have `setTimeout` followed by `console.log`, but here we are using
    `0` as the timeout, meaning we want this to be completed immediately. Once the
    timeout is complete and the callback is pushed to the callback queue, as our event
    loop favors call stacks, you can expect output like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有`setTimeout`后面跟着`console.log`，但这里我们使用`0`作为超时，意味着我们希望立即完成。一旦超时完成并且回调被推送到回调队列，由于我们的事件循环优先处理调用堆栈，你可以期待这样的输出：
- en: '![Figure 8.7: Output after the timeout is complete'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7：超时完成后的输出'
- en: '](Images/C14587_08_07.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_07.jpg)'
- en: 'Figure 8.7: Output after the timeout is complete'
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.7：超时完成后的输出
- en: We see that `hi` is printed out before `hi again` because even when we set the
    timeout to zero, it will still be executed last because the event loop will execute
    items on the call stack before items in the callback queue.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`hi`在`hi again`之前被打印出来，因为即使我们将超时设置为零，它仍然会最后执行，因为事件循环会在调用堆栈中的项目之前执行回调队列中的项目。
- en: 'Activity 11: Using Callbacks to Receive Results'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动11：使用回调接收结果
- en: 'In this activity, we will use callbacks to receive results. Suppose you are
    working as a software engineer for a local gas company and they want you to write
    a new feature for them:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将使用回调来接收结果。假设你正在为一家当地燃气公司担任软件工程师，并且他们希望你为他们编写一个新功能：
- en: You are given a client API library that you can use to request a list of local
    users.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个客户端API库，可以用来请求本地用户列表。
- en: 'You need to implement a feature that calculates the bill for those users and
    returns the result in the following format:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要实现一个功能，计算这些用户的账单，并以以下格式返回结果：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You need to implement a `calculateBill` function that takes `id` and calculates
    the gas bill for that user.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要实现一个`calculateBill`函数，它接受`id`并计算该用户的燃气费用。
- en: To accomplish this, you need to request the list of users and get the rates
    for those users and their usage. Lastly, calculate the final amount due and return
    the combined result.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你需要请求用户列表并获取这些用户的费率和使用情况。最后，计算最终应付金额并返回合并结果。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this activity can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Activity11](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Activity11).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的代码文件可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Activity11](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Activity11)找到。
- en: 'Perform the following steps to complete the activity:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个活动：
- en: Create a `calculate` function that takes `id` and a callback as an argument.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`calculate`函数，它接受`id`和回调函数作为参数。
- en: Call `getUsers` to get all of the users, which will give us the address we need.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`getUsers`来获取所有用户，这将给我们需要的地址。
- en: Call `getUsage` to get the usage of our user.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`getUsage`来获取我们用户的使用情况。
- en: Finally, call `getRate` to get the rate of the user we are doing the calculation
    for.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用`getRate`来获取我们正在为其计算的用户的费率。
- en: Invoke the `calculate` function using an existing ID.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用现有ID调用`calculate`函数。
- en: Invoke the `calculate` function using an ID that does not exist to check the
    resulting error.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不存在的ID调用`calculate`函数以检查返回的错误。
- en: 'You should see the following output with the error returned:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到返回的错误如下：
- en: '![Figure 8.8: Invoking a function using an ID that doesn’t exist'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8：使用不存在的ID调用函数'
- en: '](Images/C14587_08_08.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_08.jpg)'
- en: 'Figure 8.8: Invoking a function using an ID that doesn''t exist'
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.8：使用不存在的ID调用函数
- en: Note
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 613.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第613页找到。
- en: In this activity, the feature we implemented is very similar to what you might
    see in the real world. We worked with multiple async operations in one function.
    Next, we will talk about callback hell and how that can be a problem when we are
    dealing with multiple async operations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们实现的功能与实际世界中可能看到的非常相似。我们在一个函数中处理了多个异步操作。接下来，我们将讨论回调地狱以及在处理多个异步操作时可能出现的问题。
- en: Callback Hell
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调地狱
- en: 'Callback hell refers to the obstacles faced by JavaScript developers when working
    on large-scale projects. The cause of callback hell is not entirely the fault
    of the developer; it''s partially because of how JavaScript handles async operations.
    By using callbacks to handle multiple async operations, it''s very easy for things
    to get out of control. The following code illustrates an example of callback hell:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 回调地狱指的是JavaScript开发人员在处理大型项目时遇到的障碍。回调地狱的原因并不完全是开发人员的错，部分原因是JavaScript处理异步操作的方式。通过使用回调来处理多个异步操作，很容易让事情失控。以下代码举例说明了回调地狱的例子：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code example is a perfect example of callback hell. Although
    this code is shorter than actual callback hell code you will find in the real
    world, it is equally terrible. Callback hell is the condition where a block of
    code has so many callbacks nested inside it that it becomes hard for the developer
    to understand, maintain, and even debug the code. If the preceding code was being
    used to implement actual business logic, it would extend to more than 200 lines.
    With that many lines and that many levels of nesting, it would create the following
    issues:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码示例是回调地狱的典型例子。虽然这段代码比实际世界中找到的回调地狱代码要短，但同样糟糕。回调地狱是指一段代码中嵌套了太多回调，使得开发人员难以理解、维护甚至调试代码。如果前面的代码被用来实现实际的业务逻辑，它将会扩展到超过200行。有这么多行和这么多层嵌套，会产生以下问题：
- en: It would be difficult to figure out which callback you were currently in.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很难弄清楚你当前在哪个回调中。
- en: It could cause variable name collision and overwrite.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可能会导致变量名冲突和覆盖。
- en: It would be almost impossible to debug and breakpoint the code.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎不可能调试和断点代码。
- en: The code would be very hard to reuse.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码将非常难以重用。
- en: The code would not be testable.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码将无法进行测试。
- en: 'These issues are just some of a list of issues that can be caused by callback
    hell. They are the reason why many companies even include questions about callback
    hell in their interview questions. There are many proposed ways to make code much
    more readable than the preceding code. One way is to pull almost every callback
    out as a separate function. Using this technique, the preceding code can be modified
    as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题只是由回调地狱引起的问题清单中的一部分。这些问题是为什么许多公司甚至在面试问题中包括关于回调地狱的问题的原因。有许多提出的方法可以使代码比前面的代码更可读。一种方法是将几乎每个回调都作为单独的函数提取出来。使用这种技术，前面的代码可以修改如下：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When the code is rewritten like this, we can see that all our processing functions
    are separated out. Later, we can put them in a separate file and reference them
    using `require()` to import it. This does solve the problem of having all the
    code in one place and testability issues. It also makes the code base unnecessarily
    big and fragmented. In ES6, the promise was introduced. It opened up a brand new
    way to handle async operations. In the next section, we will go over how promises
    work and how we can use them to save us from callback hell.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码像这样重写时，我们可以看到所有的处理函数都被分开了。稍后，我们可以将它们放在一个单独的文件中，并使用`require()`来引用它们。这解决了将所有代码放在一个地方和可测试性问题。但它也使代码库变得不必要地庞大和分散。在ES6中，引入了承诺。它开辟了一种全新的处理异步操作的方式。在下一节中，我们将讨论承诺的工作原理以及如何使用它们来摆脱回调地狱。
- en: Promises
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 承诺
- en: 'In JavaScript, a promise is an object that represents some value in the future.
    Usually, it is a wrapper for an async operation. Promises can also be passed around
    in functions and used as returns for promises. Because a promise represents an
    async operation, it can have one of the following states:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，承诺是代表将来某个值的对象。通常，它是异步操作的包装器。承诺也可以在函数中传递并用作承诺的返回值。因为承诺代表一个异步操作，它可以有以下状态之一：
- en: Pending, meaning the promise is pending, which means there might be an async
    operation still running and there is no way to determine its result.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 待定，意味着承诺正在等待，这意味着可能仍有异步操作正在运行，没有办法确定其结果。
- en: Fulfilled, meaning the async operation has completed without errors and the
    value is ready to be received.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现，意味着异步操作已经完成，没有错误，值已准备好接收。
- en: Rejected, meaning the async operation has finished with errors.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝，意味着异步操作以错误完成。
- en: A promise can have only one of the preceding three states. When a promise is
    fulfilled, it will call the handler provided to the `.then` promise function,
    and when it is rejected, it will call the handler provided to the `.catch` promise
    function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺只能有前面三种状态之一。当承诺被实现时，它将调用提供给`.then`承诺函数的处理程序，当它被拒绝时，它将调用提供给`.catch`承诺函数的处理程序。
- en: 'To create a promise, we use the `new` keyword in the `Promise` constructor.
    The constructor takes a function that will include the code for the async operation.
    It also passes two functions as a parameter, `resolve` and `reject`. `resolve`
    is called with the resulting value when the async operation is completed and the
    value is ready to be passed. `reject` is called when the async operation has failed
    and you want to return the failure reason, which is typically an error object:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个promise，我们在`Promise`构造函数中使用`new`关键字。构造函数接受一个包含异步操作代码的函数。它还将两个函数作为参数传递，`resolve`和`reject`。当异步操作完成并且值准备好被传递时，将调用`resolve`。当异步操作失败并且你想要返回失败原因时，通常是一个错误对象，将调用`reject`：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code uses Promise.resolve to return a promise:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码使用Promise.resolve返回一个promise：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`Promise.resolve` returns a promise that is resolved to the value you passed
    down as the parameter. It is very useful when you want to keep your code base
    consistent, or are unsure whether a value is a promise or not. Once you wrap the
    value using `Promise.resolve`, you can start work on the value of the promise
    using the `then` handler.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.resolve`返回一个解析为你传递的值的promise。当你想要保持代码库一致，或者不确定一个值是否是promise时，它非常有用。一旦你使用`Promise.resolve`包装值，你可以使用`then`处理程序开始处理promise的值。'
- en: In the next exercise, we will look at how we can handle async operations with
    promises and how we can combine multiple async operations with promises without
    resulting in callback hell.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将看看如何使用promise处理异步操作，以及如何在不导致回调地狱的情况下将多个异步操作与promise结合起来。
- en: 'Exercise 62: Using Promises as Alternatives to Callbacks'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习62：使用Promise作为回调的替代方案
- en: In the last activity, we talked about how we can combine multiple async operations
    into one single result. It's very easy to understand, but it can also make the
    code very long and hard to manage. We went over callback hell and how to avoid
    it. One thing we can do is to utilize the `Promise` object introduced in ES6\.
    In this exercise, we will go over ways in which we can use promises in our applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个活动中，我们讨论了如何将多个异步操作组合成一个单一的结果。这很容易理解，但也会使代码变得很长并且难以管理。我们讨论了回调地狱以及如何避免它。我们可以做的一件事是利用ES6中引入的`Promise`对象。在这个练习中，我们将讨论如何在我们的应用程序中使用promise。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this exercise can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise62](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise62).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码文件可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise62](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise62)找到。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'Create a promise:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个promise：
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When creating a promise, we need to use the `new` keyword in the `Promise` constructor.
    The `Promise` constructor requires you to provide a resolver function to execute
    async operations. When a promise is created, it will automatically invoke the
    resolver function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 创建promise时，我们需要在`Promise`构造函数中使用`new`关键字。`Promise`构造函数要求你提供一个解析器函数来执行异步操作。当创建promise时，它将自动调用解析器函数。
- en: 'Add an operation to the resolver function:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向解析器函数添加一个操作：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output should be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.9: Adding an operation in the resolver function'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9：向解析器函数添加一个操作'
- en: '](Images/C14587_08_09.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_09.jpg)'
- en: 'Figure 8.9: Adding an operation to the resolver function'
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.9：向解析器函数添加一个操作
- en: Even though `console.log` is not an async operation, when we create a promise,
    it will automatically execute our resolver function and print out `hi`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`console.log`不是一个异步操作，当我们创建一个promise时，它将自动执行我们的解析器函数并打印出`hi`。
- en: 'Resolve the promise using `resolve`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`resolve`解决promise：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When the function is called, a `resolve` function is passed to our resolver
    function. When it is called, the promise will be resolved:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用函数时，会将一个`resolve`函数传递给我们的解析器函数。当它被调用时，promise将被解决：
- en: '![Figure 8.10: Resolved promise after the function is called'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10：调用函数后解决的promise'
- en: '](Images/C14587_08_10.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_10.jpg)'
- en: 'Figure 8.10: Resolved promise after the function is called'
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.10：调用函数后解决的promise
- en: 'Retrieve the value using the `then()` function. By attaching a `then` handler,
    you are expected to read the resolved promise value from the callback:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`then()`函数检索值。通过附加一个`then`处理程序，你期望从回调中读取解析的promise值：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output should be as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.11: Retrieving the value using the then function'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11：使用then函数检索值'
- en: '](Images/C14587_08_11.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_11.jpg)'
- en: 'Figure 8.11: Retrieving the value using the then function'
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.11：使用then函数检索值
- en: Whenever you create a promise, you expect the async function to complete and
    return a value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你创建一个promise时，你期望异步函数完成并返回一个值。
- en: 'Create an immediately resolved promise:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个立即解决的promise：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create an immediately rejected promise:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个立即被拒绝的promise：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output should be as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.12: Immediately rejected promise creation'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12：立即被拒绝的promise创建'
- en: '](Images/C14587_08_12.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_12.jpg)'
- en: 'Figure 8.12: Immediately rejected promise creation'
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.12：立即被拒绝的promise创建
- en: Just like `Promise.resolve`, creating a promise using `Promise.reject` will
    return a promise that is rejected with the reason you provided.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Promise.resolve`一样，使用`Promise.reject`创建promise将返回一个被提供的原因拒绝的promise。
- en: 'Handle `error` in the promise using `catch`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`catch`在promise中处理`error`：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can provide an error handler using `catch`. This adds a rejection callback
    to the promise. When you provide a catch handler, the error returned from the
    promise will be passed as the argument of the handler:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`catch`提供一个错误处理程序。这会向promise添加一个拒绝回调。当你提供一个catch处理程序时，从promise返回的错误将作为处理程序的参数传递：
- en: '![Figure 8.13: Handling an error in a promise using catch'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：使用catch处理promise中的错误
- en: '](Images/C14587_08_13.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_13.jpg)'
- en: 'Figure 8.13: Handling an error in a promise using catch'
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.13：使用catch处理promise中的错误
- en: 'Create a `wait` function that returns a promise:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个返回promise的`wait`函数：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Use an `async` function to delay our console log:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`async`函数延迟我们的控制台日志：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output should be as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.14: Delaying the console log using an async function'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14：使用异步函数延迟控制台日志'
- en: '](Images/C14587_08_14.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_14.jpg)'
- en: 'Figure 8.14: Delaying the console log using an async function'
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.14：使用异步函数延迟控制台日志
- en: As you can see, using it is very simple. Our `wait` function returns a new promise
    every time we invoke it. To run our code once the operation is complete, pass
    it into the `then` handler.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用它非常简单。我们的`wait`函数每次调用时都返回一个新的promise。在操作完成后运行我们的代码，将其传递给`then`处理程序。
- en: 'Chain the promises using the `then` function:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`then`函数链式调用promise：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output should be as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.15: Promises chained using the then function'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15：使用then函数链接的Promise'
- en: '](Images/C14587_08_15.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_15.jpg)'
- en: 'Figure 8.15: Promises chained using the then function'
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.15：使用then函数链式调用的Promise
- en: For example, when we want to chain two promises together, all we need to do
    is to pass them inside the `then` handler and make sure the result is also a promise.
    Here, we see that after we call `wait` for 2 seconds, we call another `wait` for
    2 seconds and make sure the timer starts after the first one finishes.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们想要将两个promise链在一起时，我们只需要将它们传递到`then`处理程序中，并确保结果也是一个promise。在这里，我们看到在调用`wait`等待2秒后，我们调用另一个`wait`等待2秒，并确保计时器在第一个完成后开始。
- en: In this exercise, we went over a couple of ways to create promises and how to
    create an async function that handles operations using promises instead of callbacks.
    Lastly, we chained promises using the `then` function. These are very simple ways
    to use promises. In the next chapter, we will talk about how to effectively chain
    them and how to handle errors from promises.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们讨论了几种创建promise的方法，以及如何创建一个使用promise而不是回调处理操作的异步函数。最后，我们使用`then`函数链式调用了promise。这些都是使用promise的非常简单的方法。在下一章中，我们将讨论如何有效地链式调用它们以及如何处理promise的错误。
- en: Chaining Promises
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链式调用Promise
- en: 'In the last exercise, we looked at a very simple way to chain promises. Promise
    chaining can be complex as well, and doing it properly can avoid a lot of potential
    issues in your code. When you are designing a complex application that requires
    you to do multiple async operations at once, it''s easy to get into callback hell
    when using callbacks. Using promises solves some of the problems related to callback
    hell, but it is not a silver bullet. Often, you will see code written like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们看了一种非常简单的方法来链式调用promise。Promise链式调用也可能很复杂，正确地使用它可以避免代码中的许多潜在问题。当你设计一个需要同时执行多个异步操作的复杂应用程序时，使用回调时很容易陷入回调地狱。使用promise解决了与回调地狱相关的一些问题，但它并不是万能的。通常，你会看到像这样编写的代码：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you see code written like this, it's hard to tell whether switching to
    promises solved anything. The preceding code has the same problem as our callback-hell
    code; all the logic is fragmented and nested. We also have other issues, such
    as the potential for the value on the upper scope to be accidentally overwritten.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到像这样编写的代码时，很难判断是否转换为promise解决了任何问题。前面的代码与我们的回调地狱代码有相同的问题；所有逻辑都是分散和嵌套的。我们还有其他问题，比如上层作用域的值可能会被意外覆盖。
- en: 'When we are writing code with promises, we should think about making the code
    as modular as possible and treat the collection of operations as a pipeline. For
    our preceding example, the pipeline would be like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写带有promise的代码时，我们应该考虑尽可能使代码模块化，并将操作集合视为管道。对于我们前面的示例，管道将如下所示：
- en: '![Figure 8.16: Example pipeline (a collection of operations)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16：示例管道（一系列操作）'
- en: '](Images/C14587_08_16.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_16.jpg)'
- en: 'Figure 8.16: Example pipeline (a collection of operations)'
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.16：示例管道（一系列操作）
- en: 'You will see that we want to pipe our values from one process to the next.
    This helps us to chain promises and can make our code very clean and very easy
    to maintain. We can rewrite the preceding code as the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现我们希望将值从一个过程传递到下一个过程。这有助于我们链式调用promise，并且可以使我们的代码非常清晰和易于维护。我们可以将前面的代码重写为以下内容：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, the rewritten code is much more readable, and anyone looking
    at this code will know exactly what is going to happen. When we chain promises
    in this way, we basically pass values from one process to another. By using this
    approach, we not only solve the problem of callback hell, but also make the code
    more testable as each of these helper functions is totally separate and they do
    not require anything more than the arguments passed to them. Not to mention that
    if there is any part of your application that wants to do a similar operation
    (for example, `optimizeImage`), you can reuse that part of the code easily. In
    the next exercise, we will go over how we can write complex functionality with
    multiple async operations using promise chaining.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，重写的代码更易读，任何查看这段代码的人都会准确知道将会发生什么。当我们以这种方式链式调用promise时，我们基本上是将值从一个过程传递到另一个过程。通过使用这种方法，我们不仅解决了回调地狱的问题，而且使代码更具可测试性，因为这些辅助函数中的每一个都是完全独立的，它们不需要任何比传递给它们的参数更多的东西。更不用说，如果你的应用程序中有任何部分想要执行类似的操作（例如，`optimizeImage`），你可以轻松地重用代码的这部分。在下一个练习中，我们将讨论如何使用promise链式调用编写具有多个异步操作的复杂功能。
- en: 'Exercise 63: Advanced JavaScript Promises'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习63：高级JavaScript Promise
- en: In this exercise, we will write a simple program to run multiple async operations
    and chain their results together using promise chaining. Later, we will also use
    useful static methods from the `Promise` class to help us manage multiple promises
    at once.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个简单的程序，运行多个异步操作，并使用promise链式调用它们的结果。之后，我们还将使用`Promise`类的有用静态方法来帮助我们同时管理多个promise。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this activity can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise63](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise63).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的代码文件可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise63](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise63)找到。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'Create `getProfile` and `getCart` functions that return a promise. `getProfile`
    should take the `id` string as input and resolve different results based on the
    input:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`getProfile`和`getCart`函数，它们返回一个promise。`getProfile`应该以`id`字符串作为输入，并根据输入解析不同的结果：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create another async function, `getSubscription`, which takes an ID and resolves
    `true` and `false` values for that ID:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个异步函数`getSubscription`，它接受一个ID并为该ID解析`true`和`false`值：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, the function only takes a string ID as input. If we want to chain this
    in our promise chain, we need to make sure the promise feeding this function resolves
    into a single string value.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，函数只接受一个字符串ID作为输入。如果我们想在我们的promise链中链接它，我们需要确保提供给该函数的promise解析为单个字符串值。
- en: 'Create `getFullRecord`, which returns a combined record for `id`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`getFullRecord`，它返回`id`的组合记录：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the `getFullRecord` function, we want to call all the preceding functions
    and combine the record into the return shown in the preceding code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getFullRecord`函数中，我们希望调用所有前面的函数并将记录组合成前面代码中显示的返回值。
- en: 'Call the function we declared before, in `getFullRecord`, and return the combined
    result from `getProfile`, `getCart`, and `getSubscription`:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用我们之前在`getFullRecord`中声明的函数，并返回`getProfile`，`getCart`和`getSubscription`的组合结果：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This function also returns a promise. We can invoke the function and print
    out its value:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数也返回一个promise。我们可以调用该函数并打印出它的值：
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This returns the following output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回以下输出：
- en: '![Figure 8.17: Calling the declared function in getFullRecord'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17：在getFullRecord中调用已声明的函数'
- en: '](Images/C14587_08_17.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_17.jpg)'
- en: 'Figure 8.17: Calling the declared function in `getFullRecord`'
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.17：在`getFullRecord`中调用已声明的函数
- en: But our code is very messy, and it didn't really utilize the promise chaining
    we mentioned earlier. To solve this, we need to make a modification to `getCart`
    and `getSubscription`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们的代码非常混乱，并且并没有真正利用我们之前提到的promise链式调用。为了解决这个问题，我们需要对`getCart`和`getSubscription`进行修改。
- en: 'Update the `getCart` function, which returns a new object, including every
    property of the `user` object and the `cart` items instead of just returning the
    `cart` items:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`getCart`函数，该函数返回一个新对象，包括`user`对象的每个属性和`cart`项，而不仅仅返回`cart`项：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Update the `getSubscription` function, which takes the `user` object as an
    input and returns an object instead of a single value:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`getSubscription`函数，该函数以`user`对象作为输入并返回一个对象，而不是单个值：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Update the `getFullRecord` function:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`getFullRecord`函数：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, this is much more readable than all the nesting we had before. We just
    reduced `getFullRecord` a lot with minimal changes to the two functions we had
    previously. When we call this function again, it should produce the exact same
    result:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这比以前的所有嵌套要可读得多。我们只是通过对之前的两个函数进行最小的更改，大大减少了`getFullRecord`。当我们再次调用此函数时，它应该产生完全相同的结果：
- en: '![Figure 8.18: Updated getFullRecord function'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18：更新的getFullRecord函数'
- en: '](Images/C14587_08_18.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_18.jpg)'
- en: 'Figure 8.18: Updated getFullRecord function'
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.18：更新的getFullRecord函数
- en: 'Create the `getFullRecords` function, which we will use to call multiple records
    and combine them into an array:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`getFullRecords`函数，我们将使用它来调用多个记录并将它们组合成一个数组：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Use `array.map` to generate a list of promises:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`array.map`生成promise列表：
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we utilized the `array.map` function to iterate through the array and
    return a new array. Because the array includes just the IDs, we can simply just
    pass the `getFullRecord` function in.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们利用了`array.map`函数来迭代数组并返回一个新数组。因为数组只包含ID，所以我们可以简单地传递`getFullRecord`函数。
- en: 'Use `Promise.all` to combine the results of a list of promises:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Promise.all`来合并一系列promise的结果：
- en: '[PRE42]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`Promise.all` simply takes an array of promises and returns a promise that
    waits for all the promises to resolve. Once all the promises in the array are
    resolved, it will resolve with an array of the results from those promises. Because
    our objective is to return a list of full records, this does exactly what we want.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all`只是接受一个promise数组并返回一个等待所有promise解析的promise。一旦数组中的所有promise都解析了，它将解析为这些promise的结果数组。因为我们的目标是返回完整记录列表，这正是我们想要的。'
- en: 'Test out `getFullRecords`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试`getFullRecords`：
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output should be as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.19: Testing the getFullRecords function'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19：测试getFullRecords函数'
- en: '](Images/C14587_08_19.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_19.jpg)'
- en: 'Figure 8.19: Testing the getFullRecords function'
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.19：测试getFullRecords函数
- en: In this exercise, we implemented complex logic using multiple async functions
    and their promise returns. We also tried to chain them and modified some of our
    functions to make chaining easy. Lastly, we used both `array.map` and `Promise.all`
    to create multiple promises using arrays and wait for all of them to resolve.
    This helps us to manage multiple promises and track their results. Next, we will
    talk about error handling in promises.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了多个异步函数和它们的promise返回来实现复杂的逻辑。我们还尝试链式调用它们，并修改了一些函数以便于链式调用。最后，我们使用了`array.map`和`Promise.all`来使用数组创建多个promise并等待它们全部解析。这有助于我们管理多个promise并跟踪它们的结果。接下来，我们将讨论promise中的错误处理。
- en: Error Handling in Promises
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Promise中的错误处理
- en: When we make requests to web servers or access files on disk, there is no guarantee
    that the operation we want to perform will be 100% successful. When it doesn't
    work the way we want, we will need to make sure that our application can handle
    these errors, so it doesn't quit unexpectedly or damage our data. When we were
    writing handlers for async functions before, we could simply get the error returned
    from the process in the error argument passed to our callback. When we are using
    promises, we can also get the error from the `catch` handler.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向 web 服务器发出请求或访问磁盘上的文件时，不能保证我们要执行的操作会100%成功。当它不按我们想要的方式工作时，我们需要确保我们的应用程序能够处理这些错误，以便它不会意外退出或损坏我们的数据。在以前编写异步函数的处理程序时，我们可以简单地从错误参数中获取返回的错误。当我们使用
    promises 时，我们也可以从`catch`处理程序中获取错误。
- en: 'But when we are handling errors, we are not only trying to prevent something
    bad from happening to us or our users; we also need to make sure that our errors
    are meaningful enough for us to use that information and prevent that error from
    reoccurring. Generally, if we want to handle errors in promises, we can just do
    the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们处理错误时，我们不仅仅是在尝试防止发生对我们或用户有害的事情；我们还需要确保我们的错误足够有意义，以便我们使用这些信息并防止该错误再次发生。通常，如果我们想要处理
    promises 中的错误，我们可以简单地这样做：
- en: '[PRE44]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When we want to handle a certain type of error, we can call the `catch` function
    and pass it an error handler. But what if we are dealing with multiple promises
    at once? What if we are using promise chaining? When dealing with multiple promises,
    you might think we need to do something like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要处理某种类型的错误时，我们可以调用`catch`函数并传递一个错误处理程序。但如果我们同时处理多个 promises 呢？如果我们使用 promise
    链呢？当处理多个 promises 时，你可能会认为我们需要做类似这样的事情：
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, we are handling any type of error from the promise returned by the `aFunctionReturnsPromise`
    function. Inside the `then` handler for that promise, we are calling `anotherFunctionReturnsPromise`,
    and inside the `then` handler for that, we are handling the error from that promise.
    This doesn''t look too terrible because we are only using two nested promises,
    so chaining them is not strictly necessary, and we are handling each error separately.
    But usually, when you see people writing code like this, you will also see something
    like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们处理了`aFunctionReturnsPromise`函数返回的 promise 的任何类型的错误。在该 promise 的`then`处理程序中，我们调用`anotherFunctionReturnsPromise`，在其`then`处理程序中，我们处理了该
    promise 的错误。这看起来并不太糟糕，因为我们只使用了两个嵌套的 promises，所以严格来说不需要链式调用，而且我们分别处理了每个错误。但通常，当你看到人们写这样的代码时，你也会看到类似这样的东西：
- en: '[PRE46]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'I have even seen production-grade code written like this. While this looks
    like a great idea to a lot of developers, it is not an ideal way to handle errors
    in promises. There are some use cases for this way of handling errors. One is
    if you are certain of the type of error you are going to get and you want to do
    custom handling for each of the different types. When you have code like this,
    it is very easy for you to have duplication in your log files because, as you
    can see from the preceding code, the error is logged twice: once in the catch
    handler in the nested promise, and once in the parent promise. To reduce the duplication
    of error handling, you can simply remove any handler in the nested promise, so
    the preceding code would look like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至看到过像这样写的生产级代码。虽然这看起来对很多开发者来说是个好主意，但这并不是处理 promises 中错误的理想方式。有一些使用情况适合这种错误处理方式。其中一种情况是，如果你确定了你将要得到的错误类型，并且想要为每种不同类型做自定义处理。当你的代码像这样时，很容易在日志文件中出现重复，因为你可以从前面的代码中看到，错误被记录了两次：一次在嵌套
    promise 的 catch 处理程序中，一次在父 promise 中。为了减少错误处理的重复，你可以简单地移除嵌套 promise 中的任何处理程序，这样前面的代码看起来会像这样：
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You don't have to worry that the error in the nested promise is not handled
    – because we are returning the promise in the `then` handler, and we are passing
    the status over, not the value. So, when the nested promise encounters an error,
    it will eventually be caught by the `catch` handler in the parent error handler.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必担心嵌套 promise 中的错误没有被处理 - 因为我们在`then`处理程序中返回了 promise，并且传递了状态而不是值。所以，当嵌套 promise
    遇到错误时，最终会被父错误处理程序中的`catch`处理程序捕获。
- en: 'One thing we must keep in mind is that when we are using promises, the `then`
    handler is not called when there is an error. Consider the following example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须记住的一件事是，当我们使用 promises 时，当出现错误时，`then`处理程序不会被调用。考虑以下例子：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Suppose you are creating a file processing function and after it is finished
    processing, you run your cleanup logic in the `then` handler. This creates an
    issue when we have errors because the cleanup process will never be called when
    this promise is rejected. This can cause a lot of issues. We can run out of disk
    space because temp files are not being removed. We can also risk memory leak if
    we don''t properly close connections. To solve this issue, some developers take
    the easy way and copy over the cleanup logic:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在创建一个文件处理函数，并且在处理完成后，在`then`处理程序中运行清理逻辑。当出现错误时，这会创建一个问题，因为当该 promise 被拒绝时，清理过程将永远不会被调用。这可能会引起很多问题。我们可能会因为临时文件没有被删除而耗尽磁盘空间。如果我们没有正确关闭连接，我们也可能会面临内存泄漏的风险。为了解决这个问题，一些开发者采取了简单的方法并复制了清理逻辑：
- en: '[PRE49]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'While this solves our issue, it also creates a duplicated block, so eventually,
    when we want to change some logic in the cleanup process, we need to remember
    to make the change in both places. Luckily for us, the `Promise` class gives us
    a very useful handler we can set to make sure that the handler is always called
    regardless of the status:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这解决了我们的问题，但也创建了一个重复的代码块，所以最终，当我们想要更改清理过程中的某些逻辑时，我们需要记住在两个地方都进行更改。幸运的是，`Promise`类给了我们一个非常有用的处理程序，我们可以设置它以确保无论状态如何，处理程序都会被调用：
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we are appending a new type of handler to our promise. The `.finally`
    handler will always be called when the promise is `settled`, regardless of whether
    it is resolved or rejected. This is a very useful handler we can set on our promises
    to make sure that we properly clean up connections or remove files.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在附加一种新类型的处理程序到我们的promise。`.finally`处理程序将在promise被`settled`时始终被调用，无论它是解决还是被拒绝。这是一个非常有用的处理程序，我们可以在我们的promises上设置它，以确保我们正确清理连接或删除文件。
- en: 'In the previous exercise, we managed to use `Promise.all` to grab a list of
    results from a list of promises. In our example, all the promises eventually resolved,
    and we got a very clean array returned to us. How would we handle cases where
    we are unsure about the result of the promises? Consider the `getFullRecords`
    function in the last exercise; when we run the function, it executes the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们设法使用`Promise.all`从一系列promises中获取结果列表。在我们的示例中，所有promises最终都解决了，并且我们得到了一个非常干净的数组返回给我们。我们如何处理我们不确定promises结果的情况？考虑上一个练习中的`getFullRecords`函数；当我们运行该函数时，它执行以下操作：
- en: '![Figure 8.20: Executing the getFullRecords function'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20：执行getFullRecords函数'
- en: '](Images/C14587_08_20.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_20.jpg)'
- en: 'Figure 8.20: Executing the getFullRecords function'
  id: totrans-281
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.20：执行getFullRecords函数
- en: 'The function executes all three operations at the same time and will resolve
    when they are resolved. Let''s modify the `getFullRecords` function to make it
    output an error:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数同时执行所有三个操作，并在它们解决时解决。让我们修改`getFullRecords`函数以使其输出错误：
- en: '[PRE51]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We know that the third ID we have provided doesn''t exist in our `getProfile`
    function, so it will be rejected. When we run this function, we will get an output
    like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们提供的第三个ID在我们的`getProfile`函数中不存在，因此它将被拒绝。当我们运行此函数时，我们将得到如下输出：
- en: '![Figure 8.21: Error when running the getProfile function'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21：运行getProfile函数时出错'
- en: '](Images/C14587_08_21.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_21.jpg)'
- en: 'Figure 8.21: Error when running the getProfile function'
  id: totrans-287
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.21：运行getProfile函数时出错
- en: '`Promise.all` waits for all the promises in the array to settle and will return
    a rejected promise if one of the requests is rejected. Keep this in mind when
    you are dealing with multiple promises using `Promise.all`; if a promise request
    is rejected, make sure you include as much info on the error message as you can
    so that you can tell which operation was rejected.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all`等待数组中的所有promises解决，并且如果其中一个请求被拒绝，它将返回一个拒绝的promise。在处理多个promises时，请记住这一点；如果一个promise请求被拒绝，请确保您在错误消息中包含尽可能多的信息，以便您可以知道哪个操作被拒绝。'
- en: 'Exercise 64: Refactor the Bill Calculator Using Promises'
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习64：使用Promises重构账单计算器
- en: 'In the last exercise, we wrote bill calculator logic using callbacks. Suppose
    the company you work for has now upgraded their Node.js runtime and they require
    you to rewrite that part of the logic with promises. Open the `promises.js` file
    and you will see the updated `clientApi` rewritten using promises:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们使用回调函数编写了账单计算逻辑。假设您工作的公司现在升级了他们的Node.js运行时，并且要求您使用promises重写该部分逻辑。打开`promises.js`文件，您将看到使用promises重写的更新后的`clientApi`：
- en: Note
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Promises.js is available at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise64](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise64).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Promises.js可在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise64](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise64)找到。
- en: You are given `clientApi`, which supports promises.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已经得到了支持promises的`clientApi`。
- en: 'You need to implement a feature that calculates the bill for a user and returns
    the result in this format:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要实现一个功能，该功能计算用户的账单并以此格式返回结果：
- en: '[PRE52]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You need to implement a `calculateBill` function that takes an ID and calculates
    the gas bill for that user.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要实现一个`calculateBill`函数，该函数接受一个ID并计算该用户的燃气账单。
- en: You need to implement a new `calculateAll` function to calculate the bill of
    all the users from `getUsers`.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要实现一个新的`calculateAll`函数来计算从`getUsers`获取的所有用户的账单。
- en: We will open the file that includes `clientApi` and do our work there.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将打开包含`clientApi`的文件并在那里进行工作。
- en: 'Perform the following steps to implement the exercise:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现练习：
- en: 'We will first create the `calculate` function. This time, we will only pass
    `id`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建`calculate`函数。这次，我们只会传递`id`：
- en: '[PRE53]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In `calculate`, we will call `getUsers` first:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`calculate`中，我们将首先调用`getUsers`：
- en: '[PRE54]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Because we want to calculate and return a promise, and `getUsers` returns a
    promise, we will simply return promise when we call `getUsers`. Here, we will
    run the same `find` method to find the user we are currently calculating. Then,
    if the user doesn't exist, we can just throw an error inside the `then` handler.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们想要计算并返回一个promise，并且`getUsers`返回一个promise，所以当我们调用`getUsers`时，我们将简单地返回promise。在这里，我们将运行相同的`find`方法来找到我们当前正在计算的用户。然后，如果用户不存在，我们可以在`then`处理程序中直接抛出错误。
- en: 'Call `getUsage` inside the `then` handler of `getUsers`:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getUsers`的`then`处理程序中调用`getUsage`：
- en: '[PRE55]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we are returning `clientApi` because we want to chain our promise and
    want the innermost promise to surface and be resolved.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们返回`clientApi`，因为我们想要链接我们的promise，并且希望最内层的promise出现并被解决。
- en: 'Call `getRate` inside the `then` handler of `getUsage`:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getUsage`的`then`处理程序中调用`getRate`：
- en: '[PRE56]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is the last function we need to call. We will also use `return` here. Inside
    our `then` handler, we will have all the information we need. Here, we can just
    run our calculation and return the value directly. That value will be the resolved
    value for the promise we are returning.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要调用的最后一个函数。我们也将在这里使用`return`。在我们的`then`处理程序中，我们将拥有所有我们需要的信息。在这里，我们可以直接运行我们的计算并直接返回值。该值将是我们返回的promise的解决值。
- en: 'Create a `calculateAll` function:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`calculateAll`函数：
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Call `getUsers` to get the list of our users:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`getUsers`以获取我们用户的列表：
- en: '[PRE58]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here, the result will be a list of the users in our system. Then, we will run
    `calculate` on each of them. Use `Promise.all` and a map array to call the `calculate`
    function on every user:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，结果将是我们系统中用户的列表。然后，我们将在每个用户上运行`calculate`。使用`Promise.all`和一个map数组来调用`calculate`函数对每个用户进行计算：
- en: '[PRE59]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We are using a map array to return a new array of promises. The array of promises
    will be the promise returned when we call our existing `calculate` function. When
    we feed that array to `Promise.all`, it will return a promise that will resolve
    into a list of results from the list of promises.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个map数组来返回一个新的promise数组。当我们调用现有的`calculate`函数时，返回的promise数组将是promise。当我们将该数组传递给`Promise.all`时，它将返回一个promise，该promise将解析为来自promise列表的结果列表。
- en: 'Call `calculate` on one of our users:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的一个用户上调用`calculate`：
- en: '[PRE60]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output should be as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.22: Calling calculate on one of our users'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22：调用我们的一个用户上的calculate'
- en: '](Images/C14587_08_22.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_22.jpg)'
- en: 'Figure 8.22: Calling calculate on one of our users'
  id: totrans-323
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.22：在我们的一个用户上调用calculate
- en: 'Call the `calculateAll` function:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`calculateAll`函数：
- en: '[PRE61]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The output should be as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.23: Calling the calculateAll function'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.23：调用calculateAll函数'
- en: '](Images/C14587_08_23.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_23.jpg)'
- en: 'Figure 8.23: Calling the calculateAll function'
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.23：调用calculateAll函数
- en: In the previous exercises and the activity, we created functions that calculate
    results from multiple async functions using callbacks and later rewrote those
    functions using promises. Now, you know how to refactor old callback-style code
    using promises. This is very useful when you are working on refactoring big projects
    that require you to start using promises while keeping the same functionality.
    In the next chapter, we will go over a new method we can adopt to handle async
    functions.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的练习和活动中，我们创建了函数，使用回调从多个异步函数计算结果，然后使用promise重写了这些函数。现在，您知道如何使用promise重构旧的回调风格代码。当您在重构需要您开始使用promise的大型项目时，这是非常有用的。在下一章中，我们将介绍一种新的方法，可以用来处理异步函数。
- en: Async and Await
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步和等待
- en: 'It has always been the dream of JavaScript developers to handle async functions
    without the need to write wrappers around them. Then, a new feature was introduced,
    and that changed everything we know about JavaScript async operations. Consider
    the code we used in the last exercise:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript开发人员一直梦想着处理异步函数而无需在其周围编写包装器。然后，引入了一个新功能，这改变了我们对JavaScript异步操作的认识。考虑我们在上一个练习中使用的代码：
- en: '[PRE62]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It is simple enough because we used promise chaining, but it doesn''t really
    tell us anything more than that, and it appears we are just calling a bunch of
    functions. What if we could have something like this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，因为我们使用了promise链式调用，但它并没有告诉我们更多的信息，看起来我们只是调用了一堆函数。如果我们可以有这样的东西会怎样：
- en: '[PRE63]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, when you look at the preceding code, it makes much more sense and it looks
    like we are just calling some non-async functions to grab the data and later returning
    combined data. This is what async and await can achieve. By using async and await,
    we can write our code like this while maintaining full control of our async operations.
    Consider a simple `async` function that returns a promise:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你看前面的代码时，它就更有意义了，看起来就像我们只是调用一些非异步函数来获取数据，然后返回组合数据。这就是async和await可以实现的。通过使用async和await，我们可以像这样编写我们的代码，同时保持对异步操作的完全控制。考虑一个简单的`async`函数，它返回一个promise：
- en: '[PRE64]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This is just a simple `async` function like the ones we used in the previous
    exercises and in the activity. Normally, if we wanted to call this function and
    get the value of the returned promise, we would need to execute the following
    command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的`async`函数，就像我们在以前的练习和活动中使用的那样。通常，如果我们想调用这个函数并获取返回的promise的值，我们需要执行以下命令：
- en: '[PRE65]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output should be as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.24: Getting the value of the returned promise'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.24：获取返回的promise的值'
- en: '](Images/C14587_08_24.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_24.jpg)'
- en: 'Figure 8.24: Getting the value of the returned promise'
  id: totrans-343
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.24：获取返回的promise的值
- en: 'There is nothing new about this method; we are still calling the function to
    return a promise and later getting the resolved value via the `then` handler.
    If we want to use the new async and await feature, we first create a function
    that will run the operation:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法并不新鲜；我们仍然调用函数返回一个promise，然后通过`then`处理程序获取解析后的值。如果我们想要使用新的async和await功能，我们首先创建一个将运行操作的函数：
- en: '[PRE66]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'All we did is add `async` before the `function` keyword. We do this to mark
    this function as an `async` function so that we can use `await` on the `sayHello`
    function inside the `printHello()` function without the need to use the `then`
    handler:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的就是在`function`关键字之前添加`async`。我们这样做是为了将这个函数标记为`async`函数，这样我们就可以在`printHello()`函数中使用`await`来调用`sayHello`函数，而不需要使用`then`处理程序：
- en: '[PRE67]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In this `async` function, we are calling our `sayHello` function, which returns
    a promise. Because we used the `await` keyword before, it will try to resolve
    that promise and feed the resolved value into the constant we declared as a message.
    By using this, we just made our `async` function look like a synchronous function.
    Later, we can call the function just like a normal function:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`async`函数中，我们调用了我们的`sayHello`函数，它返回一个promise。因为我们在之前使用了`await`关键字，它将尝试解析该promise并将解析后的值传递给我们声明为消息的常量。通过使用这个，我们让我们的`async`函数看起来像一个同步函数。稍后，我们可以像调用普通函数一样调用该函数：
- en: '[PRE68]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The output should be as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.25: Calling the printHello function'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25：调用printHello函数'
- en: '](Images/C14587_08_25.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_25.jpg)'
- en: 'Figure 8.25: Calling the printHello function'
  id: totrans-353
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.25：调用printHello函数
- en: 'Exercise 65: Async and Await Functions'
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习65：异步和等待函数
- en: In this exercise, we will go over creating async functions and calling them
    inside other async functions. Using async and await can really help us when dealing
    with a large amount of async operations within a single function. We will write
    our first `async` function together and explore some of the things you need keep
    in mind when dealing with async and await in your application.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将学习创建async函数并在其他async函数中调用它们。在单个函数中处理大量的async操作时，使用async和await可以帮助我们。我们将一起编写我们的第一个`async`函数，并探索在应用程序中处理async和await时需要牢记的一些事情。
- en: Note
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this activity can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise65](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise65).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的代码文件可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise65](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise65)找到。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'Create a `getConcertList` function:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`getConcertList`函数：
- en: '[PRE69]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Call the function and use `await`:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用函数并使用`await`：
- en: '[PRE70]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When we run the preceding code, we will get an error like this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述代码时，我们将会得到如下错误：
- en: '![Figure 8.26: Calling the function using await'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.26：使用await调用函数'
- en: '](Images/C14587_08_26.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_26.jpg)'
- en: 'Figure 8.26: Calling the function using await'
  id: totrans-366
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.26：使用await调用函数
- en: The reason we will get this error is that we can only use the `await` keyword
    inside an `async` function. If we want to use it, we must wrap the statement in
    an `async` function.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到这个错误的原因是我们只能在`async`函数内部使用`await`关键字。如果我们想使用它，我们必须将语句包装在`async`函数中。
- en: 'Modify the statement and wrap it in an `async` function:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改语句并将其包装在`async`函数中：
- en: '[PRE71]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The output should be as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.27: Modifying the statement and wrapping it in an async function'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.27：修改语句并将其包装在async函数中'
- en: '](Images/C14587_08_27.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_27.jpg)'
- en: 'Figure 8.27: Modifying the statement and wrapping it in an async function'
  id: totrans-373
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.27：修改语句并将其包装在async函数中
- en: When we run this function, we will see the list printed out and everything has
    worked out. We can also treat the `async` function as a function that returns
    a promise, so if we want to run code after the operation is over, we can use the
    `then` handler.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个函数时，我们将看到列表被打印出来，一切都运行正常。我们也可以将`async`函数视为返回promise的函数，因此如果我们想在操作结束后运行代码，我们可以使用`then`处理程序。
- en: 'Call the `then()` function with a handler of the `async` function:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`async`函数的`then()`函数调用处理程序：
- en: '[PRE72]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output should be as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.28: Calling the then function with a handler of the async function'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.28：使用async函数的then函数调用处理程序'
- en: '](Images/C14587_08_28.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_28.jpg)'
- en: 'Figure 8.28: Calling the then function with a handler of the async function'
  id: totrans-380
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.28：使用async函数的then函数调用处理程序
- en: Now, we know that the `async` function behaves just like a normal function that
    returns a promise.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道`async`函数的行为就像返回promise的普通函数一样。
- en: 'Create a `getPrice` function to retrieve the price of a concert:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`getPrice`函数来获取音乐会的价格：
- en: '[PRE73]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Modify `printList` to include the price from `getPrice`:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`printList`以包括从`getPrice`获取的价格：
- en: '[PRE74]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In this function, we are simply trying to get all the prices using the `getPrice`
    function. In the last section, we mentioned how to use `Promise.all` to wrap an
    array of promises in a promise that will only resolve once every promise in the
    array is resolved. Because the `await` keyword can be used on any function that
    returns a promise and will resolve its value, we can use this to get a price array.
    When we run the preceding code, we will see that this function resolves into the
    following:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们只是尝试使用`getPrice`函数获取所有的价格。在上一节中，我们提到了如何使用`Promise.all`将一个promise数组包装在一个promise中，该promise只有在数组中的每个promise都解析后才会解析。因为`await`关键字可以用于返回promise并解析其值的任何函数，我们可以使用它来获取一个价格数组。当我们运行上述代码时，我们将看到这个函数解析为以下内容：
- en: '![Figure 8.29: Modifying printList to include the price from getPrice'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.29：修改printList以包括从getPrice获取的价格'
- en: '](Images/C14587_08_29.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_29.jpg)'
- en: 'Figure 8.29: Modifying printList to include the price from getPrice'
  id: totrans-389
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.29：修改printList以包括从getPrice获取的价格
- en: This means that if we have a promise-returning function, we don't need to use
    the `then` handler anymore. In an `async` function, we can simply use the `await`
    keyword to get the resolved value. However, handling errors in `async` functions
    work a bit differently.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们有一个返回promise的函数，我们不再需要使用`then`处理程序。在`async`函数中，我们可以简单地使用`await`关键字来获取解析后的值。但是，在`async`函数中处理错误的方式有点不同。
- en: 'Create a `buggyCode` function that returns a rejected promise:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个返回rejected promise的`buggyCode`函数：
- en: '[PRE75]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Call `buggyCode` in `printList`:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`printList`中调用`buggyCode`：
- en: '[PRE76]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The output should be as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.30: Calling buggyCode in printList'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.30：在printList中调用buggyCode'
- en: '](Images/C14587_08_30.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_30.jpg)'
- en: 'Figure 8.30: Calling buggyCode in printList'
  id: totrans-398
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.30：在printList中调用buggyCode
- en: Because `buggyCode` throws an error, this stops the execution of our function
    and, in the future, it might even terminate our process. To handle this type of
    error, we will need to catch it.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`buggyCode`抛出了一个错误，这会停止我们的函数执行，并且将来甚至可能终止我们的进程。为了处理这种类型的错误，我们需要捕获它。
- en: 'Use a `catch` handler on `buggyCode`:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在buggyCode上使用`catch`处理程序：
- en: '[PRE77]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can handle the error of `buggyCode` just like a regular promise and pass
    it a `catch` handler. This way, the promise rejection will be marked as handled
    and will not return `UnhandledPromiseRejectionWarning`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像处理常规promise一样处理`buggyCode`的错误，并传递一个`catch`处理程序。这样，promise rejection将被标记为已处理，并且不会返回`UnhandledPromiseRejectionWarning`：
- en: '![Figure 8.31: Using the catch handler on buggyCode'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.31：在buggyCode上使用catch处理程序'
- en: '](Images/C14587_08_31.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_31.jpg)'
- en: 'Figure 8.31: Using the catch handler on buggyCode'
  id: totrans-405
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.31：在buggyCode上使用catch处理程序
- en: This is one way to handle promise rejection in `async` functions. There is also
    a more familiar way to do it.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理`async`函数中的promise rejection的一种方法。还有一种更常见的方法。
- en: 'Modify error handling using `try`…`catch`:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`try`…`catch`修改错误处理：
- en: '[PRE78]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output should be as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.32: Modifying error handling using try…catch'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.32：使用try…catch修改错误处理'
- en: '](Images/C14587_08_32.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_32.jpg)'
- en: 'Figure 8.32: Modifying error handling using try…catch'
  id: totrans-412
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.32：使用try…catch修改错误处理
- en: Using `try`…`catch` is what many developers are familiar with when dealing with
    functions that might throw errors. To handle the error from our `buggyCode`, using
    a `try`…`catch` block will make the code much more readable and achieve the goal
    of async, that is, eliminating passing promise handlers. Next, we will talk about
    how to properly handle multiple promises and concurrency.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`try`…`catch`是许多开发人员在处理可能抛出错误的函数时熟悉的。使用`try`…`catch`块来处理我们的`buggyCode`的错误将使代码更易读，并实现异步的目标，即消除传递promise处理程序。接下来，我们将讨论如何正确处理多个promise和并发性。
- en: Async Await Concurrency
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步等待并发性
- en: 'When dealing with multiple async operations in JavaScript, it''s crucial to
    know the order of the operations you want to run. The way you write this code
    can alter the behavior of your application a lot. Let''s look at this example:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理JavaScript中的多个异步操作时，了解你想要运行的操作的顺序至关重要。你编写代码的方式可以很大程度上改变应用程序的行为。让我们看一个例子：
- en: '[PRE79]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This is a very simple function that returns a promise that only resolves after
    `n` seconds has passed. To visualize concurrency, we declare the `runAsync` function:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的函数，它返回一个promise，只有在经过`n`秒后才会解析。为了可视化并发性，我们声明了`runAsync`函数：
- en: '[PRE80]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'When we run this function, we will see that our program will wait 1 second
    and print out the first statement, and another one after 2 seconds. The total
    wait time will be 3 seconds:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个函数时，我们会看到我们的程序会等待1秒并打印出第一条语句，然后在2秒后打印出另一条语句。总等待时间将是3秒：
- en: '![Figure 8.33: Function returning a promise that resolves after n seconds'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.33：返回在n秒后解析的promise的函数'
- en: '](Images/C14587_08_33.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_33.jpg)'
- en: 'Figure 8.33: Function returning a promise that resolves after n seconds'
  id: totrans-422
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.33：返回在n秒后解析的promise的函数
- en: 'What if we want to run both `wait` functions together? Here, we can use `Promise.all`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要同时运行两个`wait`函数呢？在这里，我们可以使用`Promise.all`：
- en: '[PRE81]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The output should be as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下所示：
- en: '![Figure 8.34: Running both wait functions using Promise.all'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.34：使用Promise.all运行两个等待函数'
- en: '](Images/C14587_08_34.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_34.jpg)'
- en: 'Figure 8.34: Running both wait functions using Promise.all'
  id: totrans-428
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.34：使用Promise.all运行两个等待函数
- en: 'What we did here is we removed `await` and put the two promises returned by
    the `wait` function in the array, and then fed it to `Promise.all`. When we remove
    the `await` keyword and use `Promise.all`, we can make sure that the code is not
    out of control and will continue to execute. What if you are dealing with promises
    in a loop, as in the following code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是移除了`await`，并将`wait`函数返回的两个promise放入数组中，然后将其传递给`Promise.all`。当我们移除`await`关键字并使用`Promise.all`时，我们可以确保代码不会失控并将继续执行。如果你在循环中处理promise，就像下面的代码一样：
- en: '[PRE82]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This offers no concurrency. Imagine that, instead of waiting, we are getting
    user information from a database:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这不提供并发性。想象一下，我们不是在等待，而是从数据库中获取用户信息：
- en: '[PRE83]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Here, our use case is fetching multiple user profiles from the database. While
    the preceding code will work, it is not the most performant implementation. Just
    as we have mentioned previously, this code will wait until the last request has
    finished before fetching the next one. To optimize this code, we can simply use
    `array.map` and `Promise.all` together:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的用例是从数据库中获取多个用户配置文件。虽然前面的代码可以工作，但它不是最高效的实现。正如我们之前提到的，这段代码会等到最后一个请求完成后才会获取下一个请求。为了优化这段代码，我们可以简单地使用`array.map`和`Promise.all`结合使用：
- en: '[PRE84]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This way, we aren't waiting for each operation to finish; we are only waiting
    for the wrapper promise to be resolved. In map array, we are only generating the
    promises and, once they are created, it will execute our operation. Compared to
    the `for` loop method, we don't need to wait for the previous promise to settle
    before executing the next promise. We will talk about their differences in the
    next chapter.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们不是等待每个操作完成；我们只是等待包装promise被解析。在map数组中，我们只是生成了promises，一旦它们被创建，它将执行我们的操作。与`for`循环方法相比，我们不需要等待前一个promise在执行下一个promise之前解决。我们将在下一章讨论它们的区别。
- en: When to Use await
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时使用await
- en: 'In the previous examples, we went over using the `await` keyword inside our
    `async` functions. But when should we use `await`, and when should we avoid it?
    In the last section, we discussed avoiding using `await` when we want to enable
    concurrency and make sure operations are not waiting for one another. Consider
    the following code example:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们讨论了在我们的`async`函数中使用`await`关键字。但是什么时候应该使用`await`，什么时候应该避免呢？在上一节中，我们讨论了当我们想要启用并发并确保操作不会互相等待时，应避免使用`await`。考虑以下代码示例：
- en: '[PRE85]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'In this example, the `operation2` function will only be executed once `operation1`
    is complete. This is useful when you have dependencies and `result2` depends on
    something from `result1`, as shown in the example. If they don''t have dependencies
    on one another, you could leverage `Promise.all` to ensure concurrency:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`operation2`函数只有在`operation1`完成后才会执行。当你有依赖关系并且`result2`依赖于`result1`中的某些内容时，这是很有用的，就像例子中所示的那样。如果它们之间没有相互依赖，你可以利用`Promise.all`来确保并发性：
- en: '[PRE86]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Without the `await` keyword, the code simply assigns the promise returned from
    both operations in the constant we declared. This ensures that `operations2` is
    fired right after `operation1` and that there is no `wait`. Another point that
    we need to be careful of is error handling. Consider the `buggyCode` we used in
    the last exercise:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`await`关键字，代码只是将从两个操作返回的promise分配给我们声明的常量。这确保了`operation2`在`operation1`之后立即触发，并且没有等待。我们还需要注意的另一点是错误处理。考虑我们在上一个练习中使用的`buggyCode`：
- en: '[PRE87]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This function simply returns a promise that is rejected. When using it, we
    should use `catch` to handle the error from the promise:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数只是返回一个被拒绝的promise。在使用它时，我们应该使用`catch`来处理promise的错误：
- en: '[PRE88]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'When we run this code, we will see that our error is handled beautifully, and
    the error message is logged. Here, we used `await` when we ran the `buggyCode`
    function, but when we remove the `await` keyword, here is what we will see:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，我们会看到我们的错误被很好地处理，并且错误消息被记录下来。在这里，我们在运行`buggyCode`函数时使用了`await`，但是当我们删除`await`关键字时，我们将看到以下内容：
- en: '![Figure 8.35: Running the buggyCode function after removing the await keyword'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.35：删除await关键字后运行buggyCode函数'
- en: '](Images/C14587_08_35.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下文本按行翻译成中文：
- en: 'Figure 8.35: Running the buggyCode function after removing the await keyword'
  id: totrans-448
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.35：删除await关键字后运行buggyCode函数
- en: You will see that we have an unhandled promise rejection; it just appeared as
    our `try`…`catch` didn't do anything. The reason for this is that without the
    `await` keyword, JavaScript will not try to wait for the promise to resolve; therefore,
    it has no idea that an error is going to be thrown in the future. What this `try`…`catch`
    block will catch is if there is an error thrown when executing the function. This
    is something we need to keep in mind when writing code using `async` and `await`.
    In the next exercise, we will write a complex function calling multiple `async`
    functions and that is able to recover from an error.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到我们有一个未处理的promise拒绝；它似乎没有出现，因为我们的`try`…`catch`什么也没做。这是因为没有`await`关键字，JavaScript不会尝试等待promise解析；因此，它不知道将来会抛出错误。这个`try`…`catch`块将捕获的是在执行函数时抛出的错误。这是我们在使用`async`和`await`编写代码时需要牢记的事情。在下一个练习中，我们将编写一个调用多个`async`函数并能够从错误中恢复的复杂函数。
- en: 'Exercise 66: Complex Async Implementation'
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习66：复杂的异步实现
- en: In this exercise, we will build a very complex `async` function and use everything
    we have learned previously to make sure the function is high-performance and resilient
    to errors.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将构建一个非常复杂的`async`函数，并使用我们之前学到的一切来确保函数具有高性能并对错误具有弹性。
- en: Note
  id: totrans-452
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this activity can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise66](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise66).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的代码文件可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise66](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson08/Exercise66)找到。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 完成练习的步骤如下：
- en: 'Create a `getPlaylists` function that returns an array of IDs given a playlist
    name:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`getPlaylists`函数，根据播放列表名称返回一个ID数组：
- en: '[PRE89]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This function will return an array of song IDs as a playlist. If not found,
    it will simply return `null`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将返回一个歌曲ID数组作为播放列表。如果未找到，它将简单地返回`null`。
- en: 'Create a `getSongUrl` function that returns a song URL given a number `id`:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`getSongUrl`函数，根据编号`id`返回一个歌曲URL：
- en: '[PRE90]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Create a `playSong` async function that takes the ID of a song and generates
    two outputs – one displaying the song that is being played, and another that informs
    the user that the song is finished:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`playSong`异步函数，该函数接受歌曲的ID并生成两个输出-一个显示正在播放的歌曲，另一个通知用户歌曲已经完成：
- en: '[PRE91]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create a `playPlaylist` function that takes a playlist ID and calls `playSong`
    on each song in the playlist:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`playPlaylist`函数，该函数接受一个播放列表ID，并在播放列表中的每首歌曲上调用`playSong`：
- en: '[PRE92]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: This is a simple implementation that doesn't perform error handling.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的实现，没有进行错误处理。
- en: 'Run the `playPlaylist` function:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`playPlaylist`函数：
- en: '[PRE93]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The output should be as follows:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.36: Running the playPlaylist function'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.36：运行playPlaylist函数'
- en: '](Images/C14587_08_36.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_36.jpg)'
- en: 'Figure 8.36: Running the playPlaylist function'
  id: totrans-470
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.36：运行playPlaylist函数
- en: We get a very interesting output; it is playing all the songs at the same time.
    Also, it doesn't handle errors gracefully.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一个非常有趣的输出；它同时播放所有歌曲。而且，它没有优雅地处理错误。
- en: 'Call `playPlaylist` with no argument:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带参数调用`playPlaylist`：
- en: '[PRE94]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The output should be as follows:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该如下：
- en: '![Figure 8.37: Calling playPlaylist with no argument'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.37：不带参数调用playPlaylist'
- en: '](Images/C14587_08_37.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_37.jpg)'
- en: 'Figure 8.37: Calling playPlaylist with no argument'
  id: totrans-477
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.37：不带参数调用playPlaylist
- en: The reason we are getting this error is that we are not handling errors when
    `getPlaylist` throws an error.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以出现这个错误是因为当`getPlaylist`抛出错误时，我们没有处理错误。
- en: 'Modify `playPlaylist` to handle errors:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`playPlaylist`以处理错误：
- en: '[PRE95]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We aren''t doing anything special here; we simply added a `try…catch` block
    around the `getPlaylist` so that when the promise does get rejected, it will be
    properly handled. After the update, when we run our code again, we will receive
    the following output:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有做任何特别的事情；我们只是在`getPlaylist`周围添加了一个`try…catch`块，这样当promise被拒绝时，它将被正确处理。更新后，当我们再次运行我们的代码时，我们将收到以下输出：
- en: '![Figure 8.38: Modifying playPlaylist for error handling'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.38：修改playPlaylist以处理错误'
- en: '](Images/C14587_08_38.jpg)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_38.jpg)'
- en: 'Figure 8.38: Modifying `playPlaylist` for error handling'
  id: totrans-484
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.38：修改`playPlaylist`以处理错误
- en: We see that the error is properly handled, but we still get the `finished` message
    at the end. This is something we do not want because when an error has occurred,
    we do not want the promise chain to continue.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到错误已经被正确处理，但是我们仍然在最后得到了`finished`消息。这是我们不想要的，因为当发生错误时，我们不希望promise链继续。
- en: 'Modify the `playPlaylist` function and the caller:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`playPlaylist`函数和调用者：
- en: '[PRE96]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: When writing `async` code, it is a good idea to keep the promise handling in
    the parent and let the error bubble up. This way, we can have only one error handler
    for this operation and be able to handle multiple errors at once.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写`async`代码时，最好将promise处理放在父级，并让错误冒泡。这样，我们可以为此操作只有一个错误处理程序，并能够一次处理多个错误。
- en: 'Try to call a corrupted playlist:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试调用一个损坏的播放列表：
- en: '[PRE97]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The output should be as follows:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_35.jpg)'
- en: '![Figure 8.39: Calling a corrupted playlist'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.39：调用一个损坏的播放列表'
- en: '](Images/C14587_08_39.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_39.jpg)'
- en: 'Figure 8.39: Calling a corrupted playlist'
  id: totrans-494
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.39：调用损坏的播放列表
- en: This code runs fine, and the error is handled, but it is still playing everything
    together. We wanted to show the `finished` message because the `song does not
    exist` error is a minor one and we want to suppress it.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行良好，并且错误已经处理，但仍然一起播放。我们想要显示`finished`消息，因为`歌曲不存在`错误是一个小错误，我们想要抑制它。
- en: 'Modify `playPlaylist` to play songs sequentially:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`playPlaylist`以按顺序播放歌曲：
- en: '[PRE98]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The output should be as follows:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.40: Modified playPlaylist to play songs sequentially'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.40：修改后的playPlaylist以按顺序播放歌曲'
- en: '](Images/C14587_08_40.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_40.jpg)'
- en: 'Figure 8.40: Modifying `playPlaylist` to play songs sequentially'
  id: totrans-501
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.40：修改`playPlaylist`以按顺序播放歌曲
- en: In the modification, we removed `Promise.all` and replaced it with a `for` loop
    with `await` for each song. This makes sure that we wait for each song to complete
    before we go on to the next song.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改中，我们删除了`Promise.all`，并用`for`循环替换了它，对每首歌曲使用`await`。这确保我们在继续下一首歌曲之前等待每首歌曲完成。
- en: 'Modify `playSong` to suppress the `not found` error:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`playSong`以抑制`未找到`错误：
- en: '[PRE99]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The output should be as follows:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.41: Modified playSong to suppress the not found error'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.41：修改后的playSong以抑制未找到的错误'
- en: '](Images/C14587_08_41.jpg)'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_41.jpg)'
- en: 'Figure 8.41: Modifying `playSong` to suppress the not found error'
  id: totrans-508
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.41：修改`playSong`以抑制未找到的错误
- en: What we did here is wrapped our logic with a `try`…`catch` block. This allows
    us to suppress any error generated by the code. When `getSongUrl` does throw an
    error, it will not be bubbled up to the parent; it will be caught by the `catch`
    block.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是用`try`...`catch`块包装我们的逻辑。这使我们能够抑制代码生成的任何错误。当`getSongUrl`抛出错误时，它不会上升到父级；它将被`catch`块捕获。
- en: In this exercise, we implemented a playlist player using `async` and `await`,
    and used our knowledge about `Promise.all` and `async` concurrency to optimize
    our playlist player to only play one song at a time. This enabled us to have a
    deeper understanding of async and await and implement our own `async` function
    in the future. In the next section, we will go over how we can migrate our existing
    promise- or callback-based code to async and await.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用`async`和`await`实现了一个播放列表播放器，并使用了我们对`Promise.all`和`async`并发的了解来优化我们的播放列表播放器，使其一次只播放一首歌曲。这使我们能够更深入地了解async和await，并在将来实现我们自己的`async`函数。在下一节中，我们将讨论如何将现有的基于promise或回调的代码迁移到async和await。
- en: 'Activity 12: Refactor the Bill Calculator Using Async and Await'
  id: totrans-511
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动12：使用Async和Await重构账单计算器
- en: 'Your company has updated its Node.js runtime again. In this activity, we will
    refactor the bill calculator we created previously using async and await:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 您的公司再次更新了其Node.js运行时。在此活动中，我们将使用async和await重构之前创建的账单计算器：
- en: You are given `clientApi`, implemented using promises.
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您获得了使用承诺实现的`clientApi`。
- en: You need to update `calculate()` to an `async` function.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要将`calculate()`更新为`async`函数。
- en: You need to update `calculateAll()` to an `async` function.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要将`calculateAll()`更新为`async`函数。
- en: '`calculateAll()` needs to get all the results at once using `Promise.all`.'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateAll()`需要使用`Promise.all`一次获取所有结果。'
- en: Open the `async.js` file to implement the `calculate` and `calculateAll` function
    using `async` and `await`.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`async.js`文件，使用`async`和`await`实现`calculate`和`calculateAll`函数。
- en: Note
  id: totrans-518
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The code files for this activity can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson08/Activity12/Activity12.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson08/Activity12/Activity12.js).
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的代码文件可以在[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson08/Activity12/Activity12.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson08/Activity12/Activity12.js)找到。
- en: 'Perform the following steps to complete the activity:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成活动：
- en: Create a `calculate` function that takes an ID as input.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建一个`calculate`函数，以ID作为输入。 '
- en: Inside `calculate`, use `await` to call `clientApi.getUsers()` to retrieve all
    of the users.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`calculate`中，使用`await`调用`clientApi.getUsers()`来检索所有用户。
- en: Use `array.find()` to find `currentUser` using the `id` argument.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`array.find()`使用`id`参数找到`currentUser`。
- en: Use `await` to call `getUsage()` to get the usage for that user.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`await`调用`getUsage()`来获取该用户的使用情况。
- en: Use `await` to call `getRate` to get the rate for at user.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`await`调用`getRate`以获取用户的费率。
- en: Return a new object with `id`, `address`, and the total due amount.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个新对象，其中包括`id`、`address`和总应付金额。
- en: Write the `calculateAll` function as an `async` function.
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`calculateAll`函数编写为`async`函数。
- en: Use `await` to call `getUsers` to retrieve all of the users.
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`await`调用`getUsers`以检索所有用户。
- en: Use an array map to create a list of promises and use `Promise.all` to wrap
    them. Then, use await on the promise returned by `Promise.all` and return its
    value.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数组映射创建一个承诺列表，并使用`Promise.all`将它们包装起来。然后，在由`Promise.all`返回的承诺上使用等待，并返回其值。
- en: Call `calculate` on one of the users.
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个用户上调用`calculate`。
- en: Call `calculateAll`.
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`calculateAll`。
- en: 'The output should be as follows:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '![Figure 8.42: Calling the calculateAll function'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.42：调用calculateAll函数'
- en: '](Images/C14587_08_42.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_08_42.jpg)'
- en: 'Figure 8.42: Calling the calculateAll function'
  id: totrans-535
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8.42：调用calculateAll函数
- en: Note
  id: totrans-536
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 615.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第615页找到。
- en: Migrating Callback- and Promise-Based Code to Async and Await
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将回调和Promise-Based代码迁移到Async和Await
- en: When working on large-sized projects, it's very common to have to refactor existing
    code using async and await. When we are doing these refactors, we need to keep
    in mind that we should keep the same functionality and type of error handling.
    In this section, we will learn how we can migrate existing callback and promise-based
    code to async and await.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大型项目时，经常需要使用async和await重构现有代码。在进行这些重构时，我们需要牢记应保持相同的功能和错误处理类型。在本节中，我们将学习如何将现有的回调和基于promise的代码迁移到async和await。
- en: Migrating Callback-Based Code to Async and Await
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将基于回调的代码迁移到Async和Await
- en: 'When we are migrating callback-based code, we need to rewrite the function
    and make sure it returns a promise instead of taking a callback. Consider the
    following code:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们迁移基于回调的代码时，我们需要重写函数，并确保它返回一个promise而不是使用回调。考虑以下代码：
- en: '[PRE100]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The preceding code takes a parameter and calls a `request` module, which we
    do not have access to modify, and returns a list of the user IDs. Once it is finished,
    if there is an error, it is simply returned through the callback. When we want
    to refactor this code using async and await, we can first make sure it returns
    a promise. When we do that, we also want to remove the `callback` parameter:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码接受一个参数并调用`request`模块，我们无法修改它，并返回用户ID的列表。一旦完成，如果出现错误，它将通过回调简单地返回。当我们想要使用async和await重构这段代码时，我们可以首先确保它返回一个promise。这样做的同时，我们也想删除`callback`参数：
- en: '[PRE101]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Then, we need to copy our logic in:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要把我们的逻辑复制到：
- en: '[PRE102]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Here, we need to make modifications. We need to remove all the references to
    `callback` and change them to use `reject` and `resolve`:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要进行修改。我们需要删除所有对`callback`的引用，并改用`reject`和`resolve`：
- en: '[PRE103]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'You can see here that we are still using the callback style when calling `request`.
    That is because we have no control over that external library. What we can do
    is make sure that each time we call it, we return a promise. Now, we have fully
    converted our legacy code to modern standards. You can now use it in the `async`
    function like this:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到，我们在调用`request`时仍在使用回调样式。那是因为我们无法控制外部库。我们能做的是确保每次调用它时，我们都返回一个promise。现在，我们已经完全将我们的传统代码转换为现代标准。您现在可以像这样在`async`函数中使用它：
- en: '[PRE104]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Usually, code is much more difficult to refactor. It is recommended to start
    from the most basic level and work your way up as you refactor. When you are dealing
    with nested callbacks, make sure you use `await` to ensure you preserve dependencies.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，代码重构要困难得多。建议从最基本的级别开始，随着重构的进行逐步提升。当处理嵌套回调时，确保使用`await`来确保保留依赖关系。
- en: Summary
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went over how we can use promises and async and await to
    better manage our async operations in our code. We also talked about the various
    ways in which we can refactor our existing callback code to async and await. Using
    async and await in our applications will not only help to make our code more readable,
    but will also help us to do future testing on our implementation. In the next
    chapter, we will go over how we can use event-based programming in our applications.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何使用promise和async和await更好地管理代码中的异步操作。我们还谈到了将现有的回调代码重构为async和await的各种方法。在我们的应用程序中使用async和await不仅有助于使我们的代码更易读，还将帮助我们对实现进行未来测试。在下一章中，我们将讨论如何在我们的应用程序中使用基于事件的编程。
