- en: Using Express
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Express
- en: As we've discussed, JavaScript in the backend is incredibly useful for creating
    web applications and harnessing the power of JavaScript on both the front- and
    back-end. One of the most fundamental tools for a server-side application that
    interacts with the frontend is a basic web server. In order to provide APIs, database
    access, and other functionality that is not designed to be handled by the browser,
    we first need to set up a piece of software to handle these interactions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们讨论过的，后端的JavaScript对于创建Web应用程序和利用JavaScript在前端和后端都非常有用。与前端交互的服务器端应用程序最基本的工具之一是基本的Web服务器。为了提供API、数据库访问和其他不适合由浏览器处理的功能，我们首先需要设置一个软件来处理这些交互。
- en: Express.js (or just Express) is a web application framework, considered the
    *de facto* web server of Node.js. It enjoys both high popularity and ease of use.
    Let's use it to build a full-blown web app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js（或者只是Express）是一个Web应用程序框架，被认为是Node.js的*事实标准*Web服务器。它享有很高的流行度和易用性。让我们使用它来构建一个完整的Web应用程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: 'The scaffold: Using `express-generator`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搭建脚手架：使用`express-generator`
- en: Routes and views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由和视图
- en: 'Controllers and data: Using APIs in Express'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Express中使用控制器和数据
- en: Creating an API with Express
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Express创建API
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Be prepared to work with the GitHub repository at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13).
    All you'll need is a code editor and a browser. In the *Routes and views *section*,*
    we'll discuss a few best practices for working with code editors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好在[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13)的GitHub存储库中使用代码编辑器和浏览器。在*路由和视图*部分，我们将讨论一些使用代码编辑器的最佳实践。
- en: The command-line examples are presented in macOS/Linux style. Windows users
    might need to consult the documentation to understand a few nuances of the Windows
    command line.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行示例以macOS/Linux风格呈现。Windows用户可能需要查阅文档以了解Windows命令行的一些细微差别。
- en: 'The scaffold: Using express-generator'
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搭建脚手架：使用express-generator
- en: To get started, we'll need to get on our **command-line interface** (**CLI**)
    again. If you remember [Chapter 2](94fc54d0-7655-4e18-ac2b-762a0752afaa.xhtml),
    *Can We Use JavaScript Server-Side? Sure!*, we took a look at Node and `npm` on
    the command line. Let's check our version again so we can make a few decisions
    about our application. On your command line, run `node -v`. If you have v8.2.0
    or greater, you have the option of using `npx` to install certain packages that
    are designed to be run only once in the lifespan of a project, such as express-generator.
    However, if you have a lower version, you can use `npm` to install one-time-use
    packages as well as packages that are used in your project.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要再次使用我们的**命令行界面**（**CLI**）。如果你还记得[第2章](94fc54d0-7655-4e18-ac2b-762a0752afaa.xhtml)中的内容，*我们可以在服务器端使用JavaScript吗？当然可以！*，我们曾经在命令行上查看了Node和`npm`。让我们再次检查我们的版本，以便我们可以对我们的应用程序做出一些决定。在你的命令行上运行`node
    -v`。如果你的版本是v8.2.0或更高，你可以选择使用`npx`来安装某些只在项目生命周期中运行一次的包，比如express-generator。然而，如果你的版本较低，你也可以使用`npm`来安装一次性使用的包以及在你的项目中使用的包。
- en: 'We''ll move forward with `npx` in this chapter, so if you need to take a quick
    look at the documentation for `npm` versus `npx,` be sure to give yourself some
    time to do that. In essence, to use `npm` for one-time packages that shouldn''t
    live inside your code base, for example, a scaffolding tool such as an Express
    generator or a React app creator, you can install the package globally on your
    system like this: `npm install -g express-generator`. Then, you''ll run the program
    with Express. However, this is considered a legacy usage of `npm` as `npx` is
    favored in today''s landscape.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续使用`npx`，所以如果你需要快速查看`npm`与`npx`的文档，请确保给自己一些时间来做。实质上，要使用`npm`安装一次性包，这些包不应该存在于你的代码库中，例如Express生成器或React应用程序创建器，你可以在系统上全局安装该包，如下所示：`npm
    install -g express-generator`。然后，你将使用Express运行该程序。然而，这被认为是`npm`的传统用法，因为在今天的环境中，`npx`更受青睐。
- en: 'Let''s create our Express app from scratch to build up muscle memory instead
    of continuing on from [Chapter 2](94fc54d0-7655-4e18-ac2b-762a0752afaa.xhtml), *Can
    We Use JavaScript Server-Side? Sure!*.Follow these steps to get started on an
    Express web server:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从头开始创建我们的Express应用程序，以建立肌肉记忆，而不是继续[第2章](94fc54d0-7655-4e18-ac2b-762a0752afaa.xhtml)中的内容，*我们可以在服务器端使用JavaScript吗？当然可以！*。按照以下步骤开始使用Express
    web服务器：
- en: In a convenient location, create a new directory with `mkdir my-webapp`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个方便的位置，使用`mkdir my-webapp`创建一个新目录。
- en: Navigate inside it with `cd my-webapp`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cd my-webapp`进入其中。
- en: 'The `npx express-generator --view=hbs` express generator will create several
    files and directories:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`npx express-generator --view=hbs` express生成器将创建多个文件和目录：'
- en: '![](assets/dc47dce1-47bb-4867-adb0-2ff2705a6af6.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dc47dce1-47bb-4867-adb0-2ff2705a6af6.png)'
- en: Figure 13.1 - Creating our Express scaffold
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 - 创建我们的Express脚手架
- en: We're going to set our application to use Handlebars for our templating instead
    of Jade, which is the default option. Express supports multiple templating languages
    out of the box (and can be extended to use any), but for ease of use, we'll stick
    with Handlebars, which is very similar to how we worked with frontend frameworks
    such as React and Vue in [Chapter 8](277a102d-e770-4152-a56d-40f35e2858e2.xhtml), *Working
    with Frameworks and Libraries,* with basic curly brace tokens.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置我们的应用程序使用Handlebars作为我们的模板，而不是默认选项Jade。Express支持多种模板语言（并且可以扩展使用任何模板语言），但为了方便起见，我们将使用类似于我们在[第8章](277a102d-e770-4152-a56d-40f35e2858e2.xhtml)中使用的React和Vue前端框架的Handlebars，它使用基本的花括号标记。
- en: Use `npm install` to install our dependencies. (Note that even if you used `npx`
    before, you're going to use `npm` here.) This is going to take a few seconds and
    will download a number of packages and other dependencies. Another thing to note
    is that you will need an internet connection, as `npm` retrieves packages from
    the internet.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm install`来安装我们的依赖项。（请注意，即使之前使用过`npx`，在这里你也要使用`npm`。）这将需要几秒钟的时间，并将下载许多包和其他依赖项。另一个需要注意的是，你需要互联网连接，因为`npm`会从互联网上检索包。
- en: 'Now, we''re ready to start our application using `npm start`:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备使用`npm start`来启动我们的应用程序：
- en: '![](assets/e7dee19b-5ea9-410f-9dde-ad6cdc7650b8.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e7dee19b-5ea9-410f-9dde-ad6cdc7650b8.png)'
- en: Figure 13.2 - Our application starting
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 - 我们的应用程序开始
- en: 'OK! Now, let''s access our Express site in a web browser:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好了！现在，让我们在Web浏览器中访问我们的Express网站：
- en: '![](assets/9c66eb77-2d5f-4557-86ad-a5ad5d2b021d.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9c66eb77-2d5f-4557-86ad-a5ad5d2b021d.png)'
- en: Figure 13.3 - Express welcome page
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 - Express欢迎页面
- en: Fantastic! Now that we're at this step, let's take this further than we did
    in [Chapter 2](94fc54d0-7655-4e18-ac2b-762a0752afaa.xhtml), *Can We Use JavaScript
    Server-Side? Sure!*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们到了这一步，让我们比在[第2章](94fc54d0-7655-4e18-ac2b-762a0752afaa.xhtml)中所做的更进一步，*我们可以在服务器端使用JavaScript吗？当然可以！*。
- en: RESTful architecture
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RESTful架构
- en: 'At the core of many web apps is a REST (or RESTful) application. **REST** is
    an abbreviation of **REpresentational State Transfer**, which is a design pattern
    that deals with the fact that most web technologies are inherently **stateless**.
    Think of a standard website that doesn''t require a login or much data—just static
    HTML and CSS, as we created in the previous chapters, but even simpler: without
    JavaScript. If we think of a site like this in terms of state, we can see that
    a bunch of HTML doesn''t know our user journey, doesn''t know who we are, and,
    quite frankly, it doesn''t care. Sites like these are like printed material: you
    interact with it by looking, reading, and turning pages. You don''t change anything
    about it. In general, the only way you''re really modifying the state of a book
    is with a bookmark to save your place. Honestly, that''s one step more interactive
    than a basic blob of HTML and CSS!'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Web应用程序的核心是一个REST（或RESTful）应用程序。**REST**是**REpresentational State Transfer**的缩写，它是一种处理大多数Web技术固有的**无状态**的设计模式。想象一下一个不需要登录或太多数据的标准网站——只是静态的HTML和CSS，就像我们在之前的章节中创建的那样，但更简单：没有JavaScript。如果我们从状态的角度来看待这样的网站，我们会发现一堆HTML并不知道我们的用户旅程，不知道我们是谁，而且，坦率地说，它也不关心。这样的网站就像印刷材料：你通过观看、阅读和翻页来与它交互。你不会改变它的任何内容。一般来说，你真正修改书的状态的唯一方式就是用书签保存你的位置。老实说，这比基本的HTML和CSS更具交互性。
- en: 'To work with users and data, REST is used as a functional paradigm. We already
    worked with two of the main HTTP verbs when working with APIs: GET and POST. These
    are the two main verbs that we''ll be using, but we''ll be looking at two more:
    PUT and DELETE.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理用户和数据，REST被用作一种功能范式。在处理API时，我们已经使用了两个主要的HTTP动词：GET和POST。这是我们将要使用的两个主要动词，但我们将再看看另外两个：PUT和DELETE。
- en: 'If you''re familiar with the concept of **Create, Read, Update, and Delete**
    (**CRUD**), this is how the standard HTTP REST verbs translate:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉**创建、读取、更新和删除**（**CRUD**）的概念，这就是标准的HTTP REST动词的翻译方式：
- en: '| **Concept** | **HTTP Verb** |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **概念** | **HTTP动词** |'
- en: '| Create | CREATE |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | 创建 |'
- en: '| Read | GET |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 读取 | 获取 |'
- en: '| Update | PUT or PATCH |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 更新 | PUT或PATCH |'
- en: '| Delete | DELETE |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | 删除 |'
- en: 'For more information, you can take a look at the Packt REST Tutorial: [https://hub.packtpub.com/what-are-rest-verbs-and-status-codes-tutorial/](https://hub.packtpub.com/what-are-rest-verbs-and-status-codes-tutorial/).'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息，你可以查看Packt REST教程：[https://hub.packtpub.com/what-are-rest-verbs-and-status-codes-tutorial/](https://hub.packtpub.com/what-are-rest-verbs-and-status-codes-tutorial/)。
- en: Now, it is possible to create a full application only using GET, or just GET
    and POST, but there are security and architectural reasons why you wouldn't want
    to do this. For now, let's agree to follow best practices and work within this
    established paradigm.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可能只使用GET，或者只使用GET和POST来创建一个完整的应用程序是可能的，但出于安全和架构的原因，你不会想这样做。现在，让我们同意遵循最佳实践，并在这个已建立的范式内工作。
- en: Now, we're going to create a RESTful application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个RESTful应用程序。
- en: Routes and views
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由和视图
- en: Routes and views are the foundation of how a RESTful application's URLs act
    as pathways to its logic and how content is presented back to the user. Routes
    will determine what parts of code correspond to the URLs of the application's
    interface. Views determine what is displayed, either to a browser, another API,
    or other programmatic access.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 路由和视图是RESTful应用程序的URL的基础，它们作为逻辑的路径，以及向用户呈现内容的方式。路由将决定代码的哪些部分对应于应用程序界面的URL。视图确定显示什么，无论是向浏览器、另一个API还是其他编程访问。
- en: 'To further understand the structure of an Express application, we can examine
    its routes and views:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步了解Express应用程序的结构，我们可以检查它的路由和视图：
- en: First of all, let's open our Express application in your favorite IDE. I'm going
    to be working with VS Code. If you use VS Code, Atom, Sublime, or another IDE
    that has command-line tools, I highly recommend installing them. For example,
    with Atom, you can launch a multi-panel Atom editing interface by typing `atom
    .` in the command prompt and opening that directory in Atom.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们在你喜欢的IDE中打开Express应用程序。我将使用VS Code进行工作。如果你使用VS Code、Atom、Sublime或其他具有命令行工具的IDE，我强烈建议安装它们。例如，使用Atom，你可以在命令提示符中输入`atom
    .`来启动多面板Atom编辑界面，并在Atom中打开该目录。
- en: 'Similarly, VS Code will do this with `code .`. Here''s what this looks like:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，VS Code会用`code .`来做到这一点。这是它的样子：
- en: '![](assets/82b8f281-8fb6-454f-bca4-85b3de493b4e.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/82b8f281-8fb6-454f-bca4-85b3de493b4e.png)'
- en: Figure 13.4 - VS Code
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 - VS Code
- en: I've expanded the directories on the left so that we can see the first level
    of the hierarchy.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经展开了左侧的目录，这样我们就可以看到层次结构的第一层。
- en: Open `app.js`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`app.js`。
- en: One of the first things you'll notice is that the syntax of this code that express-generator
    created for us is ***ES5***, not ES6\. For the moment, let's not concern ourselves
    with converting it to ES6; we'll do that a bit later. As we work on our first
    Node.js REST application, keep in mind that there are a couple of different ways
    of achieving our goal, and we'll take the more verbose path first in order to
    get our functionality working and then iterate on it to make it more flexible
    and more DRY.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这段代码的语法是express-generator为我们创建的***ES5***，而不是ES6。暂时，我们不要担心将其转换为ES6；我们稍后会做。当我们在第一个Node.js
    REST应用程序上工作时，请记住有几种不同的方法可以实现我们的目标，我们将首先采用更冗长的路径来使功能正常工作，然后对其进行迭代，使其更灵活和更DRY。
- en: 'Right now, you shouldn''t have to make any changes to `app.js`, but do take
    a second to familiarize yourself with its structure. One of the more unfamiliar
    aspects of it may be the `require()` statements at the beginning of the file.
    Similar to how you have used `import` in a frontend framework, `require()` is
    Node''s way of signaling to its component system to bring in these pieces from
    other files. In this case, the first few lines are bringing in modules installed
    via `npm,` like so:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你不需要对`app.js`做任何更改，但是花点时间熟悉它的结构。它可能比较陌生的一个方面是文件开头的`require()`语句。类似于前端框架中使用的`import`，`require()`是Node的一种方式，用于从其他文件中引入这些部分。在这种情况下，前几行是通过`npm`安装的模块，如下所示：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Note that there is no path in front of `(''express'')`. It''s simply stated.
    This is an indicator that the module referenced is not native to our code. If
    you look at the `require` statement for `indexRouter`, however, we see that it
    *does* have a path: `''./routes/index''`. It does *not* have the `.js` extension,
    but it''s pathed properly for our module usage.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`('express')`前面没有路径。它只是简单地陈述。这表明所引用的模块不是我们代码的本地模块。然而，如果你看一下`indexRouter`的`require`语句，我们会看到它*有*一个路径：`'./routes/index'`。它没有`.js`扩展名，但对于我们的模块使用来说，路径是正确的。
- en: Now, let's examine our `routes/index.js` file.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下我们的`routes/index.js`文件。
- en: Routes
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由
- en: 'If you open `routes/index.js`, you''ll see the following few lines of code
    that were generated for us:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开`routes/index.js`，你会看到为我们生成的以下几行代码：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There isn''t a whole lot surprising here: as we''re starting to gather, Express
    files begin with `require` statements, especially for `express` itself. In the
    next code block, we''re starting to see the beginnings of our REST service: `GET
    home page`. Look at the `router.get()` method right after the comment. It''s *explicitly*
    stating to the router that when a GET request is received for the URL of `/`,
    execute this code.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多令人惊讶的地方：正如我们开始了解的那样，Express文件以`require`语句开头，特别是对于`express`本身。在下一个代码块中，我们开始看到我们的REST服务的开端：`GET
    home page`。看一下注释后面的`router.get()`方法。它*明确*地告诉路由器，当收到URL为`/`的GET请求时，执行此代码。
- en: 'We can verify this fact by adding a few more GET paths here, just for fun.
    Let''s try modifying our code like so. After the `router.get()` block, but before
    `module.exports`, let''s register more routes on the router:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在这里添加一些GET路径来验证这一事实，只是为了好玩。让我们尝试修改我们的代码如下。在`router.get()`块之后，但在`module.exports`之前，让我们在路由器上注册更多的路由：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we must stop our Express server with *Ctrl + C*, restart it with `npm
    start`, and access our new page at `http://localhost:3000/hello`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须用*Ctrl + C*停止我们的Express服务器，用`npm start`重新启动它，并在`http://localhost:3000/hello`上访问我们的新页面：
- en: '![](assets/d2e9833f-53c9-4c6b-ac64-38bb966b920f.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d2e9833f-53c9-4c6b-ac64-38bb966b920f.png)'
- en: Figure 13.5 - A new route, with the Network tab open, showing we are making
    a GET request
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 - 一个新的路由，打开了网络选项卡，显示我们正在进行GET请求
- en: 'So far, this should seem pretty basic. Now, let''s do something a little different.
    Let''s work with this view and create a form for an Ajax POST request:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这应该看起来相当基本。现在，让我们做点不一样的事情。让我们使用这个视图并为Ajax POST请求创建一个表单：
- en: Create a new file called `public/javascripts/index.js`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`public/javascripts/index.js`的新文件。
- en: 'Write a basic `fetch` request to the endpoint `/hello` with POST JSON of `{
    message: "This is from Ajax" }` like so:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '编写一个基本的`fetch`请求到端点`/hello`，POST JSON为`{ message: "This is from Ajax" }`，如下所示：'
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Include this file in `views/index.hbs` like so:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像这样在`views/index.hbs`中包含这个文件：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that we don't need to include `public` in our path. This is because Express
    already understands that files within `public` are to be served statically without
    any intervention or parsing from Express, as opposed to Node files that must be
    run.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不需要在路径中包含`public`。这是因为Express已经理解到`public`中的文件应该静态提供，而不需要Express的干预或解析，与必须运行的Node文件相反。
- en: 'If you reload the page now, you really won''t see anything exciting happening
    because we haven''t yet written the route to handle the POST request. Write it
    like this:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在重新加载页面，你不会看到任何令人兴奋的事情发生，因为我们还没有编写处理POST请求的路由。编写如下：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Reload your page and you'll see… nothing. No POST in the Network tab, and certainly
    nothing rendered. What happened?
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新加载页面，你会看到... 什么也没有。在网络选项卡中没有POST，当然也没有渲染。发生了什么？
- en: 'Node has several tools that are used to reboot Express servers when code is
    changed so that the engine will refresh itself without us needing to kill and
    restart it, as we were doing before, but we did not do this time. These tools
    change over time, but the one I like is Supervisor: [https://www.npmjs.com/package/supervisor](https://www.npmjs.com/package/supervisor).
    Install it in your project simply by executing `npm install supervisor` in the
    directory of your project.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Node有几个工具用于在代码更改时重新启动Express服务器，以便引擎会自动刷新，而无需我们杀死并重新启动它，就像我们以前做的那样，但这次没有。这些工具随时间而变化，但我喜欢的是Supervisor：[https://www.npmjs.com/package/supervisor](https://www.npmjs.com/package/supervisor)。只需在项目目录中执行`npm
    install supervisor`即可在项目中安装它。
- en: 'Now, open the `package.json` file in the root of your project. You should see
    a file similar to this, but perhaps with some version differences:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开项目根目录中的`package.json`文件。你应该看到一个类似于这样的文件，但可能有一些版本差异：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the core of what is installed when running `npm install`. When you run
    it, you'll see a `node_modules` directory created and many files written there.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行`npm install`时安装的核心内容。运行时，您会看到一个`node_modules`目录被创建，并且有许多文件写入其中。
- en: If you're using version control such as Git, you will *not* want to commit the
    `node_modules` directory. With Git, you would include `node_modules` in a `.gitignore`
    file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用诸如Git之类的版本控制，您将*不*想提交`node_modules`目录。使用Git，您会在`.gitignore`文件中包含`node_modules`。
- en: 'The next thing we want to do is alter our start script to now use Supervisor:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来要做的事情是修改我们的启动脚本，现在使用Supervisor：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To use it, we still use `npm start` and to quit it, you just press *Ctrl + C*.
    It's worth noting that Supervisor is best for local development work, not production
    work; there are other tools such as Forever for that purpose.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，我们仍然使用`npm start`，要退出它，只需按下*Ctrl + C*。值得注意的是，Supervisor最适合本地开发工作，而不是生产工作；还有其他工具，比如Forever，可以用于这个目的。
- en: 'Now, let''s run `npm start` and see what happens. You should see some console
    messages that end with Press rs for restarting the process. Under most circumstances,
    issuing `rs` is not needed, but it is there if you need it:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行`npm start`，看看会发生什么。您应该看到一些以按下rs重新启动进程结束的控制台消息。在大多数情况下，不需要发出`rs`，但如果需要，可以使用它：
- en: '![](assets/d033f853-fde3-41dc-af2e-2bacba192699.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d033f853-fde3-41dc-af2e-2bacba192699.png)'
- en: Figure 13.6 - Response from Ajax!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6 - 来自Ajax的响应！
- en: 'Since we sent `This is from AJAX` from our frontend JavaScript, we''re seeing
    it reflected in our response HTML! Now, if we were to want it in our page, we
    would do this in our frontend JavaScript:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们从前端JavaScript发送了`这是来自AJAX`，我们在响应HTML中看到了它的反映！现在，如果我们想要在我们的页面中看到它，我们会在我们的前端JavaScript中这样做：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll see the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下内容：
- en: '![](assets/82301bb7-1533-4c39-9c64-6445093cb9ce.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/82301bb7-1533-4c39-9c64-6445093cb9ce.png)'
- en: Figure 13.7 - A message from Ajax!
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 - 来自Ajax的消息！
- en: Next, let's understand how to save data.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解如何保存数据。
- en: Saving data
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存数据
- en: 'For our next step, we''ll persist data in a local data store, which will be
    a simple local JSON file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一步，我们将在本地数据存储中持久化数据，这将是一个简单的本地JSON文件：
- en: 'Go ahead and quit Express with *Ctrl + C*. Let''s install an easy module that
    saves data in a local store: `npm install data-store`.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续并使用*Ctrl + C*退出Express。让我们安装一个简单的模块，它可以在本地存储中保存数据：`npm install data-store`。
- en: 'Let''s modify our routes to use it, like so:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改我们的路由以使用它，就像这样：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice the inclusion of `store` and its use in the `hello` and `/` routes.
    Let''s also modify our `index.hbs` file like this:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意`store`的包含以及在`hello`和`/`路由中的使用。让我们还修改我们的`index.hbs`文件，就像这样：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We''ll use the `Delete Data` button later, but for now, we''ll work with the
    `Add Data` button. Add some save logic to `public/javascripts/index.js` like so:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们稍后会使用`删除数据`按钮，但现在我们将使用`添加数据`按钮。在`public/javascripts/index.js`中添加一些保存逻辑，就像这样：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And now we''ll add our click handler:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将添加我们的点击处理程序：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you refresh the `/` page and click the Add Data button, you should see something
    like this:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您刷新`/`页面并点击添加数据按钮，您应该会看到类似这样的东西：
- en: '![](assets/ca234daf-da72-4cc8-855e-b339a0a3fc62.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ca234daf-da72-4cc8-855e-b339a0a3fc62.png)'
- en: Figure 13.8 - Adding data
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8 - 添加数据
- en: Now, refresh that page again. Notice that the message persists. In your filesystem,
    you should also notice a `data.json` file that contains the data.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次刷新该页面。注意消息是持久的。在您的文件系统中，您还应该注意到一个包含数据的`data.json`文件。
- en: We're now ready to work with this a bit more with a delete method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用删除方法更多地工作一下。
- en: Delete
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除
- en: 'We''ve explored GET and POST, and now it''s time to deal with another foundational
    REST verb: **DELETE**.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了GET和POST，现在是时候处理另一个基础REST动词了：**DELETE**。
- en: 'As its name implies, its goal is to remove data from a data store. We already
    have our button to do so, so let''s wire it up:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，它的目标是从数据存储中删除数据。我们已经有了我们的按钮来这样做，所以让我们把它连接起来：
- en: 'In our frontend JavaScript, we''ll add the following:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的前端JavaScript中，我们将添加以下内容：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, in the routes, add this route:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在路由中添加这个路由：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And that should be all we need. Refresh your index page and play around with
    the add and delete buttons. Pretty easy, right? In [Chapter 18](b36b27d1-f6cf-4382-ac73-f21a1aeabd3d.xhtml), *Node.js
    and MongoDB*, we'll discuss persisting and manipulating our data in a full-fledged
    database, but for now, we can work with the knowledge of GET, POST, and DELETE.
    We'll work with PUT with an actual database.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 那应该是我们需要的全部。刷新您的索引页面，并尝试使用添加和删除按钮。相当容易，对吧？在[第18章](b36b27d1-f6cf-4382-ac73-f21a1aeabd3d.xhtml)中，*Node.js和MongoDB*，我们将讨论在一个完整的数据库中持久化和操作我们的数据，但现在，我们可以使用GET、POST和DELETE的知识。我们将使用PUT来处理实际数据库。
- en: Views
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: We touched on the manipulation of views in the *Routers* section, so let's now
    dive in deeper. The **view layer** of an application is the presentation layer,
    which is why it houses our frontend JavaScript. While not all backend Node applications
    will serve a frontend, it's handy to know how to use it. Whenever I set up a simple
    webserver, I reach for Express and its functionality for both the frontend and
    backend.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*Routers*部分涉及了视图的操作，现在让我们深入了解一下。应用程序的**视图层**是表示层，这就是为什么它包含我们的前端JavaScript。虽然并非所有的后端Node应用程序都会提供前端，但了解如何使用它是很方便的。每当我设置一个简单的Web服务器时，我都会使用Express及其对前端和后端功能的功能。
- en: Since there are multiple frontend templating languages available to us, let's
    use Handlebars as an example of logic and structure.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有多种前端模板语言可供选择，让我们以Handlebars作为逻辑和结构的示例。
- en: If we want to, we can provide some conditional logic in our frontend code. Note
    that this logic is rendered by the backend, so it's a good example of when to
    render data on the backend (which is more performant for the frontend) and when
    to do it via JavaScript (which is, ostensibly, more flexible).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以在我们的前端代码中提供一些条件逻辑。请注意，这个逻辑是由后端渲染的，所以这是一个很好的例子，说明何时在后端渲染数据（对于前端来说更高效），何时通过JavaScript来做（这在表面上更灵活）。
- en: 'Let''s alter our `views/index.hbs` file like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的`views/index.hbs`文件，就像这样：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s also modify `routes/index.js`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还修改`routes/index.js`：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we''re using a ternary operator to simplify our display logic. Since our
    data from the store is JSON, we can''t simply test its length: we have to use
    the `Object.entries` method. If you''re thinking that we could have saved the
    `store.get()` to a variable instead of writing it twice, you''re right. However,
    in this case, we don''t really need to take up additional memory space since we''re
    immediately returning it versus manipulating it. The performance impact in this
    scenario is negligible, but it is something to keep in mind.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用三元运算符来简化我们的显示逻辑。由于我们从存储中获取的数据是JSON，我们不能简单地测试它的长度：我们必须使用`Object.entries`方法。如果你认为我们可以将`store.get()`保存到一个变量中而不是写两次，你是对的。然而，在这种情况下，我们不需要占用额外的内存空间，因为我们立即返回它而不是对它进行操作。在这种情况下，性能影响是可以忽略不计的，但这是需要记住的一点。
- en: 'Now, if we delete our data, we will see this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们删除我们的数据，我们会看到这个：
- en: '![](assets/6006a3be-14d2-467f-8bfe-98a2612ade90.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6006a3be-14d2-467f-8bfe-98a2612ade90.png)'
- en: Figure 13.9 - After deleting data
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9 - 删除数据后
- en: It's a little less confusing to see than to see an empty object's curly braces.
    Sure, we could have done the conditional work on the frontend by writing a more
    complex conditional, but why do that work when the backend can send us the appropriate
    data? There are certainly cases for both, but in this case, it's better to let
    each piece do its own work.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来比看到一个空对象的花括号要少混乱一些。当然，我们可以通过编写更复杂的条件在前端进行条件工作，但为什么在后端可以发送适当的数据时要做这项工作呢？当然，对于这两种情况都有情况，但在这种情况下，最好让每个部分都做自己的工作。
- en: 'You can find our completed work here: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/my-webapp](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/my-webapp).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到我们完成的工作：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/my-webapp](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/my-webapp)。
- en: Let's now turn our attention to how we actually get data into Express using
    **controllers**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转向如何使用**控制器**将数据实际传入Express。
- en: 'Controllers and data: Using APIs in Express'
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器和数据：在Express中使用API
- en: As you may have heard around the web, Express is great because it's not very
    opinionated on how you use it, and at the same time, people say that Express is
    hard to work with because it's not opinionated enough! While Express isn't typically
    set up as a traditional Model-View-Controller setup, it can be beneficial to split
    functionality out of your routes and into separate controllers, especially if
    you may end up having similar functionality between routes and want to keep your
    code DRY.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能在网络上听到的那样，Express很棒，因为它对你如何使用它没有太多的意见，同时，人们说Express很难使用，因为它的意见不够明确！虽然Express通常不设置为传统的模型-视图-控制器设置，但将功能拆分出路由并放入单独的控制器中可能是有益的，特别是如果你可能在路由之间有类似的功能，并且想要保持代码的DRY。
- en: 'If you''re not very familiar with the **Model-View-Controller** (**MVC**) paradigm,
    don''t worry—we won''t go into it in too much detail, as it''s a very weighty
    topic, complete with its own debates and conventions. For now, we''ll just define
    a few terms:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对**模型-视图-控制器**（**MVC**）范式不太熟悉，不用担心——我们不会详细讨论它，因为这是一个非常沉重的话题，有着自己的争论和惯例。现在，我们只是定义一些术语：
- en: A **Model** is a part of the application that deals with data manipulation,
    especially communication to and from a database.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**是应用程序的一部分，处理数据操作，特别是与数据库之间的通信。'
- en: A **Controller** deals with logic from routes (that is, the path of the HTTP
    request from the user).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**处理来自路由的逻辑（即用户的HTTP请求路径）。'
- en: The **Views** are the presentation layer to the end-client that provides markup
    to the client, routed by the controller.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**是向最终客户端提供标记的表示层，由控制器路由。'
- en: 'This is what the MVC paradigm looks like:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是MVC范式的样子：
- en: '![](assets/ef9b36c6-f8f5-4ac2-950c-1e771d5b572d.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ef9b36c6-f8f5-4ac2-950c-1e771d5b572d.png)'
- en: Figure 13.10 - The MVC paradigm
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10 - MVC范式
- en: Let's take a look at a sample application. At [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/controllers](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/controllers)
    is an application that uses Express.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例应用程序。在[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/controllers](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/controllers)是一个使用Express的应用程序。
- en: 'This is an API that uses controllers and models. As we''ll see, this structure
    will simplify our workflow. It''s still a fairly simple example, but this will
    give you a sense of why controllers and models can come in handy. Let''s investigate
    it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用控制器和模型的API。正如我们将看到的，这种结构将简化我们的工作流程。这仍然是一个相当简单的例子，但这会让你了解为什么控制器和模型会派上用场。让我们来调查一下：
- en: 'Go ahead and run `npm install`, and then run `npm start` to run the application.
    It should be accessible in your browser at `http://localhost:3000`, but if you
    have anything else running, Node will warn you and state a different port. Here''s
    what you''ll see:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续运行`npm install`，然后运行`npm start`来运行应用程序。它应该可以在你的浏览器中访问`http://localhost:3000`，但如果你有其他东西在运行，Node会警告你并指定一个不同的端口。你会看到以下内容：
- en: '![](assets/1deb7afc-912a-4f7c-b8bf-cd4c57f43d28.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1deb7afc-912a-4f7c-b8bf-cd4c57f43d28.png)'
- en: Figure 13.11 - Our sample Express application
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.11 - 我们的示例Express应用程序
- en: Pretty simple so far. Go ahead and click Add User a few times and play around
    with the functionality. This uses a random user API on the backend to create users
    and persist them to a filesystem data store.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止非常简单。继续点击添加用户几次，然后尝试一下功能。这使用后端的随机用户API来创建用户并将它们持久化到文件系统数据存储中。
- en: Examine the client-side JavaScript in the `public/javascripts` directory. This
    should all look familiar. If we remember the structure of the `fetch()` call,
    it returns a promise, so we can use the `.then()` paradigm to react to our events.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`public/javascripts`目录中的客户端JavaScript。这应该看起来很熟悉。如果我们记得`fetch()`调用的结构，它返回一个promise，所以我们可以使用`.then()`范式来对我们的事件做出反应。
- en: 'In `public/javascripts/index.js`, we can see the mechanism that creates our
    users when we click Add User:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`public/javascripts/index.js`中，我们可以看到当我们点击添加用户时创建用户的机制：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This shouldn''t be anything surprising: we''re using JavaScript''s `fetch`
    in an event handler to call the `/user` route with a POST. A **route** is basically
    an endpoint in an Express (or other) application: it contains some logic to react
    to an event. So, what is that logic?'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这不应该有什么意外：我们在事件处理程序中使用JavaScript的`fetch`来调用带有POST的`/user`路由。**路由**基本上是Express（或其他）应用程序中的一个端点：它包含一些逻辑来对事件做出反应。那么，这个逻辑是什么？
- en: 'Open `routes/user.js`:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`routes/user.js`：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's first compare the structure of this to the other examples. First, we'll
    see the `require()` statement for the controller for users. There's a `router.post()`
    method statement here, which is using `async`/`await` for asynchronous calls to
    our controller. Our controller will then call our model to do database work.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将其结构与其他示例进行比较。首先，我们将看到用户控制器的`require()`语句。这里有一个`router.post()`方法语句，它使用`async`/`await`进行对控制器的异步调用。然后，我们的控制器将调用我们的模型来进行数据库工作。
- en: 'So far, there are a good number of files and paths for execution. Before we
    get too lost in the code, let''s take a look at a diagram of how a frontend method,
    such as the Add User click handler, communicates with our Express backend:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，有许多文件和路径需要执行。在我们在代码中迷失之前，让我们看一下前端方法（例如添加用户点击处理程序）如何与我们的Express后端通信的图表：
- en: '![](assets/5942ab17-e961-4c9f-af8e-4b997e8c8eb0.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5942ab17-e961-4c9f-af8e-4b997e8c8eb0.png)'
- en: Figure 13.14 - End-to-end communication
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.14 - 端到端通信
- en: Reading from left-to-right and top-to-bottom, we can see how each step in the
    process plays its role. It may *look* a bit complicated for something as basic
    as retrieving information from an API, but part of the power of this architectural
    pattern is that each layer can be written and controlled by a different party.
    For example, the model layer will often be in the hands of database experts, as
    opposed to other types of backend developers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从左到右，从上到下阅读，我们可以看到每个步骤在过程中扮演的角色。对于从API检索信息这样基本的事情，它可能*看起来*有点复杂，但这种架构模式的一部分力量在于每个层可以由不同的一方编写和控制。例如，模型层通常由数据库专家掌握，而不是其他类型的后端开发人员。
- en: 'As you trace through the code for the controller and model, consider how the
    separation of concerns at each layer of the code makes for a more modular design.
    For example, we''re using a LocalStorage database to store our users. If we wanted
    to swap LocalStorage for a more robust system, such as MongoDB, we would really
    only have one file to edit: the model. In fact, even the model may be abstracted
    to have unified data handlers and then use an adapter for specific database methods.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当您跟踪控制器和模型的代码时，请考虑代码每一层的关注点分离如何使设计更加模块化。例如，我们使用一个LocalStorage数据库来存储我们的用户。如果我们想要将LocalStorage替换为更强大的系统，比如MongoDB，我们实际上只需要编辑一个文件：模型。事实上，甚至模型也可以被抽象化为具有统一数据处理程序，然后使用适配器进行特定数据库方法的调用。
- en: That might be a bit much for us right now, but let's next turn our sights on
    creating a starship game using the principles we just learned. We'll use this
    Node.js backend for our final project to make a frontend for the game in JavaScript.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说可能有点太多了，但接下来让我们把目光转向使用我们刚学到的原则来创建一个星际飞船游戏。我们将使用这个Node.js后端来制作JavaScript游戏的前端最终项目。
- en: In the next section, we'll get started with creating our game's API.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始创建我们游戏的API。
- en: Creating an API with Express
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Express创建API
- en: Who doesn't like a nice starship battle, like in Star Wars or Star Trek? I happen
    to be quite a fan of science fiction, so let's play along and construct a RESTful
    API using storage, routes, controllers, and models to keep track of our gameplay.
    While we'll be focusing on the backend of this application, we'll stand up a simple
    frontend for the population of data and testing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 谁不喜欢像《星球大战》或《星际迷航》中的美丽星舰战斗呢？我碰巧是科幻小说的忠实粉丝，所以让我们一起来构建一个使用存储、路由、控制器和模型来跟踪我们游戏过程的RESTful
    API。虽然我们将专注于应用程序的后端，但我们将建立一个简单的前端来填充数据和测试。
- en: 'You can find a work-in-progress example app at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/starship-app](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/starship-app).
    Let''s start there, and you can finish it using the following steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/starship-app](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/starship-app)找到一个正在进行中的示例应用程序。让我们从那里开始，您可以使用以下步骤完成它：
- en: Clone the repository if you haven't already.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有克隆存储库，请克隆它。
- en: Navigate into the directory with `cd starship-app` and run `npm install`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`cd starship-app`目录并运行`npm install`。
- en: Start the project with `npm start`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm start`启动项目。
- en: 'Open `http://localhost:3000` in a browser. If you already have any projects
    running on port 3000, the `start` command may prompt you to use a different port.
    Here''s our basic frontend:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://localhost:3000`。如果您已经在端口3000上运行任何项目，`start`命令可能会提示您使用其他端口。这是我们的基本前端：
- en: '![](assets/a585129a-7c90-4082-88c3-2d8e61e294f1.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a585129a-7c90-4082-88c3-2d8e61e294f1.png)'
- en: Figure 13.15 - Starship Fleet
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.15 - 星舰舰队
- en: Go ahead and play around with adding and scuttling ships both randomly and manually.
    This will be the setup for our gameplay.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随意添加和销毁飞船，无论是随机还是手动。这将是我们游戏的设置。
- en: 'Now, let''s unpack what the code is doing. Here''s our file structure:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们解开代码在做什么。这是我们的文件结构：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Open `public/javascripts/index.js`. Let''s first examine the event handler
    for random ship creation:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`public/javascripts/index.js`。让我们首先检查随机飞船创建的事件处理程序：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So far so good. This should all look familiar.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切都很顺利。这应该看起来很熟悉。
- en: 'Let''s examine this route: `/ships/random`. Open `routes/ships.js` (we can
    guess that the routing for `/ships/` will be in the `ships.js` file, but we can
    confirm this by reading the routing in the `app.js` file, as we''ve learned).
    Read through the `/random` route:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们来看看这条路线：`/ships/random`。打开`routes/ships.js`（我们可以猜测`/ships/`的路由将在`ships.js`文件中，但我们可以通过阅读`app.js`文件中的路由来确认这一点，因为我们已经学过了）。阅读`/random`路线：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first thing we'll notice is that this is an `async`/`await` construction,
    as we're going to be working with `fetch` on the frontend and (spoiler alert)
    a database on the backend.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先注意到的是这是一个`async`/`await`结构，因为我们将在前端使用`fetch`，（剧透）后端使用数据库。
- en: 'Let''s look at that controller method next:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们接下来看一下控制器方法：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Easy enough. Now for the model method:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 很容易。现在是模型方法：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: OK, it's a bit more complicated, so let's unpack this. The first couple of lines
    are simply selecting a random name from a seed file provided for you. Our `shipData`
    object is constructed from several key/value pairs, each corresponding to specific
    properties of our newly-created ship. After that, we check our database to see
    whether there's already a ship by that name or registry number. If so, we'll randomize
    again.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '好的，这有点复杂，所以让我们来解开这个。前几行只是从一个为你提供的种子文件中选择一个随机名称。我们的`shipData`对象由几个键/值对构成，每个对应于我们新创建的船只的特定属性。之后，我们检查我们的数据库，看看是否已经有一个同名或注册号的船只。如果有，我们将再次随机化。 '
- en: However, as with every application, there are areas for improvement. Here's
    a challenge for you.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与每个应用程序一样，都有改进的空间。这里有一个挑战给你。
- en: Challenge
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战
- en: 'Here''s your first task: can you think of how to improve the code so that in
    the re-randomization, it elegantly checks to see whether the *new* randomization
    also exists in our database? Hint: you may want to create a separate helper function
    or two.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个任务是：你能想出如何改进代码，使得在重新随机化时，优雅地检查*新*随机化是否也存在于我们的数据库中吗？提示：你可能想创建一个单独的辅助函数或两个。
- en: 'Maybe you arrived at something like this ([https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/starship-app-solution1](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/starship-app-solution1)):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你得到了类似于这样的东西（[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/starship-app-solution1](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-13/starship-app-solution1)）：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And to use it, execute the following command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用它，执行以下命令：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So, what are we doing here? First, let''s look at the usage of `Objects.map`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在这里做什么呢？首先，让我们看一下`Objects.map`的用法：
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we're using the `.map()` method of the `ships` object to create a new
    array of *only* the names of our existing ships. Essentially, what we're doing
    is just returning each name of the object into our array, so now we have an enumerable
    data type.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用`ships`对象的`.map()`方法来创建一个*只包含*现有船只名称的新数组。基本上，我们所做的就是将对象的每个名称返回到我们的数组中，所以现在我们有了一个可枚举的数据类型。
- en: 'Next, we want to *eliminate* used names from our possibilities, so we''ll use
    the `.filter()` function of arrays to only return the value if it''s not included
    in the array we created previously:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要*消除*已使用的名称，所以我们将使用数组的`.filter()`函数，只有在它不包含在我们之前创建的数组中时才返回该值：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We do the same with our registry numbers as with our names and return an object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与我们的名称一样处理我们的注册号，并返回一个对象。
- en: 'Now, here''s a new trick: destructuring an object. Take a look at this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有一个新技巧：解构一个对象。看看这个：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: What we're doing here is assigning two variables in one fell swoop! Since our
    `eliminateExistingShips()` method returns an object, we can use *destructuring*
    to break it into separate variables. This isn't completely necessary, but it simplifies
    our code by reducing the number of times we use dot notation.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是一举两得地分配两个变量！由于我们的`eliminateExistingShips()`方法返回一个对象，我们可以使用*解构*将其分解为单独的变量。这并不是完全必要的，但它通过减少我们使用点符号的次数来简化我们的代码。
- en: Onwards.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 继续。
- en: Ship properties
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 船只属性
- en: 'Here are the ship properties that we''ve defined for our game and their descriptions.
    This table of properties is the same for all ships we will construct, whether
    randomly or manually:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们为游戏定义的船只属性及其描述。这个属性表对我们将构建的所有船只都是相同的，无论是随机还是手动：
- en: '| **name** | A string value. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **name** | 一个字符串值。 |'
- en: '| **registry** | A string value. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **registry** | 一个字符串值。 |'
- en: '| **shields** | A number of shield strength, initialized at 100\. This will
    decrement as the ship sustains damage. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **shields** | 一个护盾强度的数字，初始化为100。随着船只受到损害，这个数字会减少。 |'
- en: '| **torpedos** | A number that indicates the number of torpedoes the ship has.
    This will decrement by 1 each time we fire a torpedo in our game. |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **torpedos** | 一个数字，表示船只拥有的鱼雷数量。在我们的游戏中，每次发射鱼雷时，这个数字会减少1。 |'
- en: '| **hull** | Starting from 0, a number that indicates how much hull damage
    the ship has sustained after the shields are depleted. When this reaches 100,
    the ship is destroyed. Hopefully, everyone got to the escape pods! |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| **hull** | 从0开始，一个数字，表示护盾耗尽后船只所承受的船体损伤。当这个数字达到100时，船只被摧毁。希望每个人都能到达逃生舱！ |'
- en: '| **speed** | From warp 1 to 9.99, our ship has a variable speed. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| **speed** | 从warp 1到9.99，我们的船只有一个可变速度。 |'
- en: '| **phasers** | No ship would be complete without phasers for battle! Define
    a random number from 1 to 100 to specify how much damage is done by the ship''s
    phasers. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **phasers** | 没有战斗相位器的船只是不完整的！定义一个从1到100的随机数字，以指定船只的相位器造成的伤害。 |'
- en: '| **x, y, and z** | The coordinates in three-dimensional space for our ship''s
    position, beginning at [0,0,0]. For our gameplay, we will upper-bound the coordinates
    at [100,100,100]. We don''t want our ships to get lost in space! |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| **x, y, and z** | 我们船只在三维空间中的坐标，从[0,0,0]开始。对于我们的游戏玩法，我们将坐标上限设定为[100,100,100]。我们不希望我们的船只在太空中迷失！
    |'
- en: For our database, we're not doing anything complicated; we're using a Node package
    called `node-persist`. This uses a directory on the filesystem to store values.
    It's basic, but it gets the job done. We'll get into real databases in [Chapter
    18](b36b27d1-f6cf-4382-ac73-f21a1aeabd3d.xhtml), *Node.js and MongoDB*. Note that
    these methods are also `async`/`await` functions, as we would expect a slight
    lag as the code interacts with the database (in this case, our filesystem).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的数据库，我们并没有做任何复杂的事情；我们使用了一个名为`node-persist`的Node包。它使用文件系统上的一个目录来存储值。它很基础，但能完成任务。我们将在[第18章](b36b27d1-f6cf-4382-ac73-f21a1aeabd3d.xhtml)
    *Node.js和MongoDB* 中介绍真正的数据库。请注意，这些方法也是`async`/`await`函数，因为我们期望代码与数据库交互时会有轻微的延迟（在这种情况下，是我们的文件系统）。
- en: OK! Since we're just returning nothing from our function, it will trigger the
    completion of our controller method, which then returns to our route and returns
    a `200 OK` message to the frontend. According to our frontend code, the page then
    reloads, displaying our new ship.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！由于我们的函数只返回空值，它将触发我们控制器方法的完成，然后返回一个`200 OK`消息到前端。根据我们的前端代码，页面将重新加载，显示我们的新飞船。
- en: 'Here''s area for improvement number two: can you use DOM manipulation to add
    your ship to the page without refreshing the page? You''ll have to modify all
    levels of the stack to accomplish your goal by returning the random values to
    the frontend.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有第二个改进的空间：你能否使用DOM操作在不刷新页面的情况下将你的飞船添加到页面上？你将需要修改整个堆栈的所有级别来实现你的目标，通过将随机值返回到前端。
- en: 'Before you get started on that, though, let''s ask ourselves an important question:
    *does it make sense to do this with our current structure*? If your thought process
    led to an overly complicated solution, as mine did, the answer is no. It stands
    to reason that the best way to handle DOM updates would be to leverage another
    tool we have: a framework. We''ll leave this be for now, but we''ll revisit it
    in our final project in [Chapter 19](8f5ef319-77fa-43ee-ad60-c4bef9a5f720.xhtml),
    *Putting It All Together,* when we create a full application.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始之前，让我们问自己一个重要的问题：*在我们当前的结构下这样做是否有意义*？如果你的思维过程导致了一个过于复杂的解决方案，就像我的一样，答案是否定的。很明显，处理DOM更新的最佳方式是利用我们拥有的另一个工具：一个框架。我们现在暂且不管它，但在我们的最终项目中[第19章](8f5ef319-77fa-43ee-ad60-c4bef9a5f720.xhtml)
    *将所有内容整合在一起* 中，我们将重新讨论它。
- en: 'Next, let''s look at how the starship battles will happen. If we go back to
    our ships router, we''ll see this route:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看星舰战斗将如何进行。如果我们回到我们的飞船路由，我们会看到这个路由：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you can guess from the construction of the route, the route will take the
    name of the first ship as parameter (`ship1`), then the `attack` string, and then
    the name of the second ship. This is an example of a RESTful route, and how Express
    handles path parameters. In our controller call, we are using these parameters
    and the `.fire()` method of the controller. In the controller, we see this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能从路由的构造中猜出来，路由将以第一艘飞船的名称作为参数（`ship1`），然后是`attack`字符串，然后是第二艘飞船的名称。这是一个RESTful路由的例子，以及Express如何处理路径参数。在我们的控制器调用中，我们使用这些参数和控制器的`.fire()`方法。在控制器中，我们看到这样的内容：
- en: '[PRE30]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now we're having fun. You can trace through the different model pieces, but
    I wanted to point out the use of the `calculateDamage` helper function. You'll
    find it toward the top of the file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们玩得很开心。你可以追踪不同的模型部分，但我想指出使用`calculateDamage`辅助函数。你会在文件的顶部找到它。
- en: 'For the damage calculation, we''ll use the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于伤害计算，我们将使用以下内容：
- en: '![](assets/3b45c762-3cf3-4878-8c52-a4aff4b5cd4e.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3b45c762-3cf3-4878-8c52-a4aff4b5cd4e.png)'
- en: Or, in English, "The chance of the target being hit by the source is calculated
    by subtracting the distance between the two ships in three-dimensional space from
    100, yielding a chance between 0% and 100%. To calculate this, round down 100
    minus the square root of the sum of the squares of the *x*, *y*, and *z* coordinate
    deltas." (Yes, I had to look up the calculation for distance in three-dimensional
    space. Don't worry if this is foreign to you.)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，用英语说，“计算目标被源命中的几率是通过从三维空间中两艘飞船之间的距离中减去100来计算的，得到0%到100%之间的几率。为了计算这个值，将100减去*x*、*y*和*z*坐标增量的平方和的平方根四舍五入。”（是的，我不得不查找三维空间距离的计算。如果这对你来说很陌生，不用担心。）
- en: 'Then, let *R[1]* be a pseudorandom value between 0 and 100, rounded up. In
    JavaScript, as in all programming languages, a random number is technically only a *pseudorandom*
    number:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让*R[1]*成为0到100之间的伪随机值，四舍五入。在JavaScript中，就像所有编程语言一样，随机数在技术上只是一个*伪随机*数：
- en: '![](assets/4119f22a-db9d-453c-940d-8f5ae712450b.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4119f22a-db9d-453c-940d-8f5ae712450b.png)'
- en: Or, "The possible damage caused by the source's phasers is calculated by rounding
    up the product of the source's phaser power by a `Math.random()` number."
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，“源头的相位炮可能造成的伤害是通过将源头的相位功率乘以一个`Math.random()`数四舍五入得到的。”
- en: If, however, the source fires a torpedo (and has torpedos left), then *possibledamage*
    *= 125*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果源头发射了鱼雷（并且还有鱼雷剩余），那么*possibledamage* *= 125*。
- en: 'Let *R[2]* be a pseudorandom number between 0 and 100, rounded up:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让*R[2]*成为0到100之间的伪随机数，四舍五入：
- en: '![](assets/ae1b1b17-36ed-4d42-a26d-4aa9b0f6a930.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae1b1b17-36ed-4d42-a26d-4aa9b0f6a930.png)'
- en: If *chance* minus the random number is greater than 0, *damage* will occur as
    *possibledamage*. Otherwise, no damage will occur.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*chance*减去随机数大于0，伤害将发生为*possibledamage*。否则，不会发生伤害。
- en: OK, now we have our calculation. Can you figure out the JavaScript code to do
    this?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们有了计算。你能想出用JavaScript代码来实现这个吗？
- en: 'Here it is:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样：
- en: '[PRE31]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To complete our game, we'll need to create the mechanism for actually firing
    and registering damage with our frontend.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的游戏，我们需要创建一个机制来实际发射并在前端注册伤害。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We covered a lot in this chapter, from routing to controllers to models. Keep
    in mind that not every application follows this paradigm, but it's a good baseline
    with which to start your approach of backend services as they relate to the frontend.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们涵盖了很多内容，从路由到控制器再到模型。请记住，并非每个应用都遵循这种范式，但这是一个很好的基准，可以帮助你开始处理后端服务与前端的关系。
- en: We should remember that using `express-generator` can help scaffold out applications,
    using `npm` or `npx`. Routes and views are our front line of the application,
    dictating where code is routed and what is viewed by the end client (whether it's
    JSON or HTML). We worked with APIs to explore the inherently asynchronous behavior
    of APIs, and also created our *own* API!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该记住，使用`express-generator`可以帮助搭建应用程序，使用`npm`或`npx`。路由和视图是我们应用程序的前线，决定代码的路由和最终客户端所看到的内容（无论是JSON还是HTML）。我们使用API来探索API的固有异步行为，并创建了*自己的*API！
- en: In the next chapter, we will discuss what makes Express a different type of
    framework than Django or Flask. We'll also examine how to join our frontend and
    backend frameworks.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Express与Django或Flask不同类型的框架。我们还将研究如何连接我们的前端和后端框架。
- en: Further reading
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Tutorial: REST Verbs and Status Codes: [https://hub.packtpub.com/what-are-rest-verbs-and-status-codes-tutorial/](https://hub.packtpub.com/what-are-rest-verbs-and-status-codes-tutorial/)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教程：REST动词和状态码：[https://hub.packtpub.com/what-are-rest-verbs-and-status-codes-tutorial/](https://hub.packtpub.com/what-are-rest-verbs-and-status-codes-tutorial/)
- en: 'How to enable ES6 (and beyond) syntax with Node and Express: [https://www.freecodecamp.org/news/how-to-enable-es6-and-beyond-syntax-with-node-and-express-68d3e11fe1ab/](https://www.freecodecamp.org/news/how-to-enable-es6-and-beyond-syntax-with-node-and-express-68d3e11fe1ab/)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Node和Express中启用ES6（及更高版本）语法：[https://www.freecodecamp.org/news/how-to-enable-es6-and-beyond-syntax-with-node-and-express-68d3e11fe1ab/](https://www.freecodecamp.org/news/how-to-enable-es6-and-beyond-syntax-with-node-and-express-68d3e11fe1ab/)
- en: 'Handling GET and POST Requests in Express 4: [https://codeforgeek.com/handle-get-post-request-express-4/](https://codeforgeek.com/handle-get-post-request-express-4/)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Express 4中处理GET和POST请求：[https://codeforgeek.com/handle-get-post-request-express-4/](https://codeforgeek.com/handle-get-post-request-express-4/)
- en: 'How to design a REST API: [https://restfulapi.net/rest-api-design-tutorial-with-example/](https://restfulapi.net/rest-api-design-tutorial-with-example/)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计REST API：[https://restfulapi.net/rest-api-design-tutorial-with-example/](https://restfulapi.net/rest-api-design-tutorial-with-example/)
