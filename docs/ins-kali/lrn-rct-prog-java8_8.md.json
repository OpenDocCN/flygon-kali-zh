["```java\nObservableHttp\n  .createGet(url, client)\n  .toObservable();\n```", "```java\npublic final static <T, Resource> Observable<T> using(\n  final Func0<Resource> resourceFactory,\n  final Func1<? super Resource, ? extends Observable<? extends T>> observableFactory,\n  final Action1<? super Resource> disposeAction\n)\n```", "```java\n// (1)\npublic Observable<ObservableHttpResponse> request(String url) {\n  Func0<CloseableHttpAsyncClient> resourceFactory = () -> {\n    CloseableHttpAsyncClient client = HttpAsyncClients.createDefault(); // (2)\n client.start();\n    System.out.println(\n      Thread.currentThread().getName() +\n      \" : Created and started the client.\"\n    );\n    return client;\n  };\n  Func1<HttpAsyncClient, Observable<ObservableHttpResponse>> observableFactory = (client) -> { // (3)\n    System.out.println(\n      Thread.currentThread().getName() + \" : About to create Observable.\"\n    );\n    return ObservableHttp.createGet(url, client).toObservable();\n  };\n  Action1<CloseableHttpAsyncClient> disposeAction = (client) -> {\n    try { // (4)\n      System.out.println(\n        Thread.currentThread().getName() + \" : Closing the client.\"\n      );\n      client.close();\n    }\n    catch (IOException e) {}\n  };\n  return Observable.using( // (5)\n resourceFactory,\n observableFactory,\n disposeAction\n );\n}\n```", "```java\nString url = \"https://api.github.com/orgs/ReactiveX/repos\";\n\nObservable<ObservableHttpResponse> response = request(url);\n\nSystem.out.println(\"Not yet subscribed.\");\n\nObservable<String> stringResponse = response\n.<String>flatMap(resp -> resp.getContent()\n.map(bytes -> new String(bytes, java.nio.charset.StandardCharsets.UTF_8))\n.retry(5)\n\n.map(String::trim);\n\nSystem.out.println(\"Subscribe 1:\");\nSystem.out.println(stringResponse.toBlocking().first());\n\nSystem.out.println(\"Subscribe 2:\");\nSystem.out.println(stringResponse.toBlocking().first());\n```", "```java\nNot yet subscribed.\nSubscribe 1:\nmain : Created and started the client.\nmain : About to create Observable.\n[{\"id\":7268616,\"name\":\"Rx.rb\",\"full_name\":\"ReactiveX/Rx.rb\",...\nSubscribe 2:\nI/O dispatcher 1 : Closing the client.\nmain : Created and started the client.\nmain : About to create Observable.\nI/O dispatcher 5 : Closing the client.\n[{\"id\":7268616,\"name\":\"Rx.rb\",\"full_name\":\"ReactiveX/Rx.rb\",...\n\n```", "```java\nString url = \"https://api.github.com/orgs/ReactiveX/repos\";\nObservable<ObservableHttpResponse> response = request(url);\n\nSystem.out.println(\"Not yet subscribed.\");\nObservable<String> stringResponse = response\n.flatMap(resp -> resp.getContent()\n.map(bytes -> new String(bytes)))\n.retry(5)\n.cast(String.class)\n.map(String::trim)\n.cache();\n\nSystem.out.println(\"Subscribe 1:\");\nSystem.out.println(stringResponse.toBlocking().first());\n\nSystem.out.println(\"Subscribe 2:\");\nSystem.out.println(stringResponse.toBlocking().first());\n```", "```java\nNot yet subscribed.\nSubscribe 1:\nmain : Created and started the client.\nmain : About to create Observable.\n[{\"id\":7268616,\"name\":\"Rx.rb\",...\nI/O dispatcher 1 : Closing the client.\nSubscribe 2:\n[{\"id\":7268616,\"name\":\"Rx.rb\",...\n\n```", "```java\npublic Observable<Map> requestJson(String url) {\nObservable<String> rawResponse = request(url)\n\n....\n\nreturn Observable.amb(fromCache(url), response);\n}\n```", "```java\npublic class Pair<L, R> {\n  final L left;\n  final R right;\n\npublic Pair(L left, R right) {\n    this.left = left;\n    this.right = right;\n  }\n\n  public L getLeft() {\n    return left;\n  }\n\npublic R getRight() {\n    return right;\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"%s : %s\", this.left, this.right);\n  }\n\n// hashCode and equals omitted\n\n}'\n```", "```java\npublic class Indexed<T> implements Operator<Pair<Long, T>, T> {\n  private final long initialIndex;\n  public Indexed() {\n    this(0L);\n  }\n  public Indexed(long initial) {\n    this. initialIndex = initial;\n  }\n  @Override\n  public Subscriber<? super T> call(Subscriber<? super Pair<Long, T>> s) {\n return new Subscriber<T>(s) {\n      private long index = initialIndex;\n @Override\n public void onCompleted() {\n s.onCompleted();\n }\n @Override\n public void onError(Throwable e) {\n s.onError(e);\n }\n @Override\n public void onNext(T t) {\n s.onNext(new Pair<Long, T>(index++, t));\n }\n };\n }\n}\n```", "```java\n@Test\npublic void testGeneratesSequentialIndexes() {\n  Observable<Pair<Long, String>> observable = Observable\n    .just(\"a\", \"b\", \"c\", \"d\", \"e\")\n    .lift(new Indexed<String>());\n  List<Pair<Long, String>> expected = Arrays.asList(\n    new Pair<Long, String>(0L, \"a\"),\n    new Pair<Long, String>(1L, \"b\"),\n    new Pair<Long, String>(2L, \"c\"),\n    new Pair<Long, String>(3L, \"d\"),\n    new Pair<Long, String>(4L, \"e\")\n  );\n  List<Pair<Long, String>> actual = observable\n    .toList()\n    .toBlocking().\n    single();\n  assertEquals(expected, actual);\n  // Assert that it is the same result for a second subscribtion.\n  TestSubscriber<Pair<Long, String>> testSubscriber = new TestSubscriber<Pair<Long, String>>();\n  observable.subscribe(testSubscriber);\n  testSubscriber.assertReceivedOnNext(expected);\n}\n```", "```java\nObservable<Pair<Long, String>> indexed = Observable.zip(\n  Observable.just(\"a\", \"b\", \"c\", \"d\", \"e\"),\n  Observable.range(0, 100),\n  (s, i) -> new Pair<Long, String>((long) i, s)\n);\nsubscribePrint(indexed, \"Indexed, no lift\");\n```", "```java\npublic class OddFilter<T> implements Transformer<T, T> {\n  @Override\n  public Observable<T> call(Observable<T> observable) {\n    return observable\n      .lift(new Indexed<T>(1L))\n      .filter(pair -> pair.getLeft() % 2 == 1)\n      .map(pair -> pair.getRight());\n  }\n}\n```", "```java\n@Test\npublic void testFiltersOddOfTheSequence() {\n  Observable<String> tested = Observable\n    .just(\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"June\", \"July\")\n    .compose(new OddFilter<String>());\n  List<String> expected =\n    Arrays.asList(\"One\", \"Three\", \"Five\", \"July\");\n  List<String> actual = tested\n    .toList()\n    .toBlocking()\n    .single();\n  assertEquals(expected, actual);\n}\n```"]