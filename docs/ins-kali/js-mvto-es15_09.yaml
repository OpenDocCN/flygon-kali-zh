- en: Chapter 8. DOM Manipulation and Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。DOM操作和事件
- en: The most important reason for JavaScript's existence is the web. JavaScript
    is the language for the web and the browser is the raison d'être for JavaScript.
    JavaScript gives dynamism to otherwise static web pages. In this chapter, we will
    dive deep into this relationship between the browser and language. We will understand
    the way in which JavaScript interacts with the components of the web page. We
    will look at the **Document Object Model** (**DOM**) and JavaScript event model.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript存在的最重要原因是网络。JavaScript是网络的语言，浏览器是JavaScript存在的理由。JavaScript使得原本静态的网页具有动态性。在本章中，我们将深入探讨浏览器和语言之间的关系。我们将了解JavaScript与网页组件交互的方式。我们将研究文档对象模型（DOM）和JavaScript事件模型。
- en: DOM
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM
- en: In this chapter, we will look at various aspects of JavaScript with regard to
    the browser and HTML. HTML, as I am sure you are aware, is the markup language
    used to define web pages. Various forms of markups exist for different uses. The
    popular marks are **Extensible Markup Language** (**XML**) and **Standard Generalized
    Markup Language** (**SGML**). Apart from these generic markup languages, there
    are very specific markup languages for specific purposes such as text processing
    and image meta information. **HyperText Markup Language** (**HTML**) is the standard
    markup language that defines the presentation semantics of a web page. A web page
    is essentially a document. The DOM provides you with a representation of this
    document. The DOM also provides you with a means of storing and manipulating this
    document. The DOM is the programming interface of HTML and allows structural manipulation
    using scripting languages such as JavaScript. The DOM provides a structural representation
    of the document. The structure consists of nodes and objects. Nodes have properties
    and methods on which you can operate in order to manipulate the nodes themselves.
    The DOM is just a representation and not a programming construct. DOM acts as
    a model for DOM processing languages such as JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从各个方面探讨JavaScript与浏览器和HTML的关系。HTML，我相信你已经知道，是用于定义网页的标记语言。不同用途存在各种形式的标记。流行的标记包括可扩展标记语言（XML）和标准通用标记语言（SGML）。除了这些通用的标记语言，还有非常特定的标记语言，用于特定目的，比如文本处理和图像元信息。超文本标记语言（HTML）是定义网页呈现语义的标准标记语言。网页本质上是一个文档。DOM为您提供了该文档的表示。DOM还为您提供了存储和操作该文档的手段。DOM是HTML的编程接口，允许使用JavaScript等脚本语言进行结构操作。DOM提供了文档的结构表示。结构由节点和对象组成。节点具有属性和方法，您可以操作这些属性和方法以操纵节点本身。DOM只是一种表示，而不是一种编程构造。DOM充当DOM处理语言（如JavaScript）的模型。
- en: Accessing DOM elements
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问DOM元素
- en: 'Most of the time, you will be interested in accessing DOM elements to inspect
    their values or processing these values for some business logic. We will take
    a detailed look at this particular use case. Let''s create a sample HTML file
    with the following content:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，您将有兴趣访问DOM元素以检查它们的值，或者为一些业务逻辑处理这些值。我们将详细研究这个特定用例。让我们创建一个包含以下内容的示例HTML文件：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can save this file as `sample_dom.html`; when you open this in the Google
    Chrome browser, you will see the web page displayed with the **Hello World** text
    displayed. Now, open Google Chrome Developer Tools by navigating to options |
    **More Tools** | **Developer Tools** (this route may differ on your operating
    system and browser version). In the **Developer Tools** window, you will see the
    DOM structure:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此文件保存为`sample_dom.html`；当您在Google Chrome浏览器中打开时，您将看到网页显示了**Hello World**文本。现在，通过导航到选项
    | **更多工具** | **开发者工具**（此路径可能因您的操作系统和浏览器版本而异），打开Google Chrome开发者工具。在**开发者工具**窗口中，您将看到DOM结构：
- en: '![Accessing DOM elements](img/00025.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![访问DOM元素](img/00025.jpeg)'
- en: 'Next, we will insert some JavaScript into this HTML page. We will invoke the
    JavaScript function when the web page is loaded. To do this, we will call a function
    on `window.onload`. You can place your script in the `<script>` tag located under
    the `<head>` tag. Your page should look as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在这个HTML页面中插入一些JavaScript。当网页加载时，我们将调用JavaScript函数。为此，我们将在`<head>`标签下的`<script>`标签中调用`window.onload`函数。您的页面应该如下所示：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The anonymous function is executed when the browser loads the page. In the function,
    we are getting the nodes of the DOM programmatically. The entire HTML document
    can be accessed using the `document.documentElement` function. We store the document
    in a variable. Once the document is accessed, we can traverse the nodes using
    several helper properties of the document. We are accessing the `<body>` element
    using `doc.body`. You can traverse through the children of an element using the
    `childNodes` array. The first and last children of a node can be accessed using
    additional properties—`firstChild` and `lastChild`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数在浏览器加载页面时执行。在该函数中，我们以编程方式获取DOM的节点。可以使用`document.documentElement`函数访问整个HTML文档。我们将文档存储在一个变量中。一旦访问了文档，我们可以使用文档的几个辅助属性遍历节点。我们使用`doc.body`访问`<body>`元素。您可以使用`childNodes`数组遍历元素的子元素。可以使用额外的属性—`firstChild`和`lastChild`访问节点的第一个和最后一个子节点。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is not recommended to use render-blocking JavaScript in the `<head>` tag.
    This slows down the page render dramatically. Modern browsers support the `async`
    and `defer` attributes to indicate to the browsers that the rendering can go on
    while the script is being downloaded. You can use these tags in the `<head>` tag
    without worrying about performance degradation. You can get more information at
    [http://stackoverflow.com/questions/436411/where-is-the-best-place-to-put-script-tags-in-html-markup](http://stackoverflow.com/questions/436411/where-is-the-best-place-to-put-script-tags-in-html-markup).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议在`<head>`标签中使用渲染阻塞的JavaScript。这会严重减慢页面的渲染速度。现代浏览器支持`async`和`defer`属性，可以指示浏览器在脚本下载时继续渲染。您可以在`<head>`标签中使用这些标签，而不必担心性能下降。您可以在[http://stackoverflow.com/questions/436411/where-is-the-best-place-to-put-script-tags-in-html-markup](http://stackoverflow.com/questions/436411/where-is-the-best-place-to-put-script-tags-in-html-markup)获取更多信息。
- en: Accessing specific nodes
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问特定节点
- en: 'The core DOM defines the `getElementsByTagName()` method to return `NodeList`
    of all the element objects whose `tagName` property is equal to a specific value.
    The following line of code returns a list of all the `<p/>` elements in a document:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 核心DOM定义了`getElementsByTagName()`方法，返回所有`tagName`属性等于特定值的元素对象的`NodeList`。以下代码返回文档中所有`<p/>`元素的列表：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The HTML DOM defines `getElementsByName()` to retrieve all the elements that
    have their name attribute set to a specific value. Consider the following snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: HTML DOM定义了`getElementsByName()`来检索所有其名称属性设置为特定值的元素。考虑以下代码片段：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we are creating a group of radio buttons with the `name` attribute
    defined as `feeling`. In the `showFeelings` function, we get all the elements
    with the `name` attribute set to `feeling` and we iterate through all these elements.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`feeling`的`name`属性定义的单选按钮组。在`showFeelings`函数中，我们获取所有`name`属性设置为`feeling`的元素，并遍历所有这些元素。
- en: 'The other method defined by the HTML DOM is `getElementById()`. This is a very
    useful method in accessing a specific element. This method does the lookup based
    on the `id` associated with an element. The `id` attribute is unique for every
    element and, hence, this kind of lookup is very fast and should be preferred over
    `getElementsByName()`. -However, you should be aware that the browser does not
    guarantee the uniqueness of the `id` attribute. In the following example, we are
    accessing a specific element using the ID. Element IDs are unique as opposed to
    tags or name attributes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: HTML DOM定义的另一种方法是`getElementById()`。这是访问特定元素的非常有用的方法。该方法根据与元素关联的`id`进行查找。`id`属性对于每个元素都是唯一的，因此这种查找非常快，应优先于`getElementsByName()`。-但是，您应该知道浏览器不能保证`id`属性的唯一性。在以下示例中，我们使用ID访问特定元素。与标签或名称属性不同，元素ID是唯一的：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: What we discussed so far was the basics of DOM traversal in JavaScript. When
    the DOM gets complex and you want sophisticated operations on the DOM, these traversal
    and access functions seem limiting. With this basic knowledge with us, it's time
    to get introduced to a fantastic library for DOM traversal (among other things)
    called jQuery.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的是JavaScript中DOM遍历的基础知识。当DOM变得复杂并且您希望对DOM进行复杂操作时，这些遍历和访问函数似乎有限。有了这些基本知识，现在是时候介绍一个名为jQuery的DOM遍历（以及其他功能）的绝妙库了。
- en: jQuery is a lightweight library designed to make common browser operations easier.
    Common operations such as DOM traversal and manipulation, event handling, animation,
    and Ajax can be tedious if done using pure JavaScript. jQuery provides you with
    easy-to-use and shorter helper mechanisms to help you develop these common operations
    very easily and quickly. jQuery is a feature-rich library, but as far as this
    chapter goes, we will focus primarily on DOM manipulation and events.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是一个轻量级库，旨在使常见的浏览器操作更容易。如果使用纯JavaScript进行常见操作，如DOM遍历和操作、事件处理、动画和Ajax，可能会很繁琐。jQuery为您提供了易于使用和更短的辅助机制，帮助您轻松快速地开发这些常见操作。jQuery是一个功能丰富的库，但就本章而言，我们将主要关注DOM操作和事件。
- en: 'You can add jQuery to your HTML by adding the script directly from a **content
    delivery network** (**CDN**) or manually downloading the file and adding it to
    the script tag. The following example shows you how to download jQuery from Google''s
    CDN:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从**内容传送网络**（**CDN**）直接添加脚本或手动下载文件并将其添加到脚本标记中来将jQuery添加到HTML中。以下示例显示了如何从Google的CDN下载jQuery：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The advantage of a CDN download is that Google''s CDN automatically finds the
    nearest download server for you and keeps an updated stable copy of the jQuery
    library. If you wish to download and manually host jQuery along with your website,
    you can add the script as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: CDN下载的优势在于Google的CDN会自动为您找到最近的下载服务器，并保持jQuery库的最新稳定副本。如果您希望下载并手动托管jQuery以及您的网站，可以按照以下方式添加脚本：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, the jQuery library is manually downloaded in the `lib` directory.
    With the jQuery setup in the HTML page, let''s explore the methods of manipulating
    the DOM elements. Consider the following example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，jQuery库是手动下载到`lib`目录中。在HTML页面中设置了jQuery后，让我们探索操作DOM元素的方法。考虑以下示例：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After adding jQuery to the HTML page, we write the custom JavaScript that selects
    the element with a `greeting` ID and changes its value. The strange-looking code
    within `$()` is the jQuery in action. If you read the jQuery source code (and
    you should, it''s brilliant) you will see the final line:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在将jQuery添加到HTML页面后，我们编写自定义JavaScript，选择具有`greeting` ID的元素并更改其值。`$()`中的奇怪代码是jQuery的实际操作。如果您阅读jQuery源代码（您应该这样做，它很棒），您将看到最后一行：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `$` is just a function. It is an alias for the function called jQuery. The
    `$` is a syntactic sugar that makes the code concise. In fact, you can use both
    `$` and `jQuery` interchangeably. For example, both `$('#greeting').html('Hello
    World Martian');` and `jQuery('#greeting').html('Hello World Martian');` are the
    same.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`只是一个函数。它是一个名为jQuery的函数的别名。`$`是一种使代码简洁的语法糖。事实上，你可以交替使用`$`和`jQuery`。例如，`$(''#greeting'').html(''Hello
    World Martian'');`和`jQuery(''#greeting'').html(''Hello World Martian'');`是一样的。'
- en: 'You can''t use jQuery before the page is completely loaded. As jQuery will
    need to know all the nodes of the DOM structure, the entire DOM has to be in-memory.
    To ensure that the page is completely loaded and in a state where it''s ready
    to be manipulated, we can use the `$(document).ready()` function. Here, the IIFE
    is executed only after the entire documented is *ready*:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面完全加载之前，你不能使用jQuery。因为jQuery需要知道DOM结构的所有节点，整个DOM必须在内存中。为了确保页面完全加载并处于可以操作的状态，我们可以使用`$(document).ready()`函数。在这里，IIFE只有在整个文档*准备就绪*之后才会执行：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is a very common thing to do when using jQuery—so much so that it has
    its own shortcut. You can replace the entire `ready()` call with a short `$()`
    call:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用jQuery时，这是一个非常常见的操作，以至于它有自己的快捷方式。你可以用一个简短的`$()`调用来替换整个`ready()`调用：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The most important function in jQuery is `$()`. This function typically accepts
    a CSS selector as its sole parameter and returns a new jQuery object pointing
    to the corresponding elements on the page. The three primary selectors are the
    tag name, ID, and class. They can be used either on their own or in combination
    with others. The following simple examples illustrate how these three selectors
    appear in code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery中最重要的函数是`$()`。这个函数通常接受一个CSS选择器作为它唯一的参数，并返回一个指向页面上相应元素的新的jQuery对象。三个主要的选择器是标签名、ID和类。它们可以单独使用，也可以与其他选择器结合使用。以下简单的例子说明了这三个选择器在代码中的使用方式：
- en: '| **Selector** | CSS Selector | jQuery Selector | Output from the selector
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **选择器** | CSS选择器 | jQuery选择器 | 选择器的输出 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| **Tag** | `p{}` | `$(''p'')` | This selects all the `p` tags from the document.
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| **标签** | `p{}` | `$(''p'')` | 这选择了文档中所有的`p`标签。'
- en: '| **Id** | `#div_1` | `$(''#div_1'')` | This selects single elements that have
    a `div_1` ID. The symbol used to identify the ID is `#`. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| **ID** | `#div_1` | `$(''#div_1'')` | 这选择了具有`div_1` ID的单个元素。用于标识ID的符号是`#`。'
- en: '| **Class** | `.bold_fonts` | `$(''.bold_fonts'')` | This selects all the elements
    in the document that have the CSS class `bold_fonts`. The symbol used to identify
    the class match is "`.`". |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| **类** | `.bold_fonts` | `$(''.bold_fonts'')` | 这选择了文档中所有具有CSS类`bold_fonts`的元素。用于标识类匹配的符号是“`.`”。'
- en: jQuery works on CSS selectors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery可以使用CSS选择器。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As CSS selectors are not in the scope of this module, I would suggest that you
    go to [http://www.w3.org/TR/CSS2/selector.html](http://www.w3.org/TR/CSS2/selector.html)
    to get a fair idea of the concept.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CSS选择器不在本模块的范围内，我建议你去[http://www.w3.org/TR/CSS2/selector.html](http://www.w3.org/TR/CSS2/selector.html)了解一下这个概念。
- en: 'We also assume that you are familiar with HTML tags and syntax. The following
    example covers the fundamental idea of how jQuery selectors work:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设你熟悉HTML标签和语法。以下例子涵盖了jQuery选择器工作的基本思想：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, we are selecting several DOM elements in the HTML page using
    selectors. We have an H1 header with the text, `Are we there yet ?`; when the
    page loads, our jQuery script accesses all H1 headers and appends the text `Finally?`
    to them:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用选择器选择了HTML页面中的几个DOM元素。我们有一个H1标题，文本是`Are we there yet ?`；当页面加载时，我们的jQuery脚本访问所有的H1标题，并在它们后面添加文本`Finally?`：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `$.html()` function sets the HTML for the target element—an H1 header in
    this case. Additionally, we select all H1 headers and apply a specific CSS style
    class, `highlight-blue`, to all of them. The `$('h1').addClass('highlight-blue')`
    statement selects all the H1 headers and uses the `$.addClass(<CSS class>)` method
    to apply a CSS class to all the elements selected using the selector.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`$.html()`函数设置了目标元素的HTML——在这种情况下是H1标题。此外，我们选择了所有的H1标题，并为它们应用了一个特定的CSS样式类`highlight-blue`。`$(''h1'').addClass(''highlight-blue'')`语句选择了所有的H1标题，并使用`$.addClass(<CSS类>)`方法为所有使用选择器选择的元素应用了一个CSS类。'
- en: 'We use the child combinator (`>`) to custom CSS styles using the `$.css()`
    function. In effect, the selector in the `$()` function is saying, "Find each
    header (`h1`) that is a child (`>`) of the element with an ID of header (`#header`)."
    For each such element, we apply a custom CSS. The next usage is interesting. Consider
    the following line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用子组合器(`>`)来使用`$.css()`函数自定义CSS样式。实际上，`$()`函数中的选择器是在说，“找到每个标题(`h1`)，它是元素ID为header(`#header`)的子元素(`>`)”。对于每个这样的元素，我们应用自定义的CSS。下一个用法很有趣。考虑下面这行：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are selecting "For all list elements (`li`) that do not have the class `highlight-blue`
    applied to them, apply CSS class `highlight-green`. The final line—`$(''tr:nth-child(odd)'').addClass(''zebra'')`—can
    be interpreted as: From all table rows (`tr`), for every odd row, apply CSS style
    `zebra`. The *n*th-child selector is a custom selector provided by jQuery. The
    final output looks something similar to the following (Though it shows several
    jQuery selector types, it is very clear that knowledge of jQuery is not a substitute
    for bad design taste.):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择“对于所有没有应用`highlight-blue`类的列表元素(`li`)，应用CSS类`highlight-green`”。最后一行——`$('tr:nth-child(odd)').addClass('zebra')`——可以解释为：从所有的表行(`tr`)中，对于每一行，应用CSS样式`zebra`。*n*th-child选择器是jQuery提供的自定义选择器。最终的输出看起来类似于以下内容（尽管它显示了几种jQuery选择器类型，但很明显，对jQuery的了解并不能替代糟糕的设计品味。）：
- en: '![Accessing specific nodes](img/00026.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![访问特定节点](img/00026.jpeg)'
- en: Once you have made a selection, there are two broad categories of methods that
    you can call on the selected element. These methods are **getters** and **setters**.
    Getters retrieve a piece of information from the selection, and setters alter
    the selection in some way.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进行了选择，就可以在所选元素上调用两类方法。这些方法是**获取器**和**设置器**。获取器从选择中检索信息片段，而设置器以某种方式修改选择。
- en: Getters usually operate only on the first element in a selection while setters
    operate on all the elements in a selection. Setters use implicit iteration to
    automatically iterate over all the elements in the selection.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器通常仅对选择中的第一个元素进行操作，而设置器对选择中的所有元素进行操作。设置器使用隐式迭代自动迭代选择中的所有元素。
- en: 'For example, we want to apply a CSS class to all list items on the page. When
    we call the `addClass` method on the selector, it is automatically applied to
    all elements of this particular selection. This is implicit iteration in action:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想要在页面上的所有列表项上应用CSS类。当我们在选择器上调用`addClass`方法时，它会自动应用于该特定选择的所有元素。这就是隐式迭代的作用：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'However, sometimes you just don''t want to go through all the elements via
    implicit iteration. You may want to selectively modify only a few of the elements.
    You can explicitly iterate over the elements using the `.each()` method. In the
    following code, we are processing elements selectively and using the `index` property
    of the element:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你只是不想通过隐式迭代遍历所有元素。您可能只想有选择地修改其中的一些元素。您可以使用`.each()`方法显式迭代元素。在下面的代码中，我们有选择地处理元素，并使用元素的`index`属性：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Chaining
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接
- en: 'Chaining jQuery methods allows you to call a series of methods on a selection
    without temporarily storing the intermediate values. This is possible because
    every setter method that we call returns the selection on which it was called.
    This is a very powerful feature and you will see it being used by many professional
    libraries. Consider the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 链接jQuery方法允许您在选择上调用一系列方法，而无需临时存储中间值。这是因为我们调用的每个设置器方法都会返回它被调用的选择。这是一个非常强大的功能，您将看到许多专业库使用它。考虑以下示例：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Traversal and manipulation
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历和操作
- en: We discussed various methods of element selection using jQuery. We will discuss
    several DOM traversal and manipulation methods using jQuery in this section. These
    tasks would be rather tedious to achieve using native DOM manipulation. jQuery
    makes them intuitive and elegant.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了使用jQuery进行元素选择的各种方法。在本节中，我们将讨论使用jQuery的几种DOM遍历和操作方法。使用原生DOM操作来实现这些任务将会相当繁琐。jQuery使它们直观而优雅。
- en: 'Before we delve into these methods, let''s familiarize ourselves with a bit
    of HTML terminology that we will be using from now on. Consider the following
    HTML:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究这些方法之前，让我们先熟悉一些HTML术语，从现在开始我们将使用它们。考虑以下HTML：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using jQuery traversal methods, we select the first element and traverse through
    the DOM in relation to this element. As we traverse the DOM, we alter the original
    selection and we are either replacing the original selection with the new one
    or we are modifying the original selection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用jQuery遍历方法，我们选择第一个元素并在与该元素相关的DOM中遍历。当我们遍历DOM时，我们会修改原始选择，要么用新选择替换原始选择，要么修改原始选择。
- en: 'For example, you can filter an existing selection to include only elements
    that match a certain criterion. Consider this example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以过滤现有选择，仅包括符合某种条件的元素。考虑以下示例：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'jQuery allows you to add and remove classes to elements. If you want to toggle
    class values for elements, you can use the `toggleClass()` method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery允许您向元素添加和删除类。如果要为元素切换类值，可以使用`toggleClass()`方法：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Most often, you may want to alter the value of elements. You can use the `val()`
    method to alter the form of element values. For example, the following line alters
    the value of all the `text` type inputs in the form:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可能想要更改元素的值。您可以使用`val()`方法来更改元素值的形式。例如，以下行更改了表单中所有`text`类型输入的值：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To modify element attributes, you can use the `attr()` method as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改元素属性，可以使用`attr()`方法如下：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: jQuery has an incredible depth of functionality when it comes to DOM manipulation—the
    scope of this module restricts a detailed discussion of all the possibilities.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及DOM操作时，jQuery具有令人难以置信的功能深度——本模块的范围限制了对所有可能性进行详细讨论。
- en: Working with browser events
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理浏览器事件
- en: When are you developing for browsers, you will have to deal with user interactions
    and events associated to them, for example, text typed in the textbox, scrolling
    of the page, mouse button press, and others. When the user does something on the
    page, an event takes place. Some events are not triggered by user interaction,
    for example, `load` event does not require a user input.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器中开发时，您将不得不处理与用户交互和与之相关的事件，例如在文本框中键入的文本，页面滚动，鼠标按钮按下等。当用户在页面上执行操作时，事件会发生。有些事件不是由用户交互触发的，例如`load`事件不需要用户输入。
- en: When you are dealing with mouse or keyboard events in the browser, you can't
    predict when and in which order these events will occur. You will have to constantly
    look for a key press or mouse move to happen. It's like running an endless background
    loop listening to some key or mouse event to happen. In traditional programming,
    this was known as polling. There were many variations of these where the waiting
    thread used to be optimized using queues; however, polling is still not a great
    idea in general.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在浏览器中处理鼠标或键盘事件时，无法预测这些事件将在何时以及以何种顺序发生。您将不断寻找按键或鼠标移动的发生。这就像运行一个无休止的后台循环，监听某个键或鼠标事件的发生。在传统编程中，这被称为轮询。有许多这样的变体，其中等待线程通常使用队列进行优化；然而，总的来说，轮询仍然不是一个好主意。
- en: 'Browsers provide a much better alternative to polling. Browsers provide you
    with programmatic means to react when an event occurs. These hooks are generally
    called listeners. You can register a listener that reacts to a particular event
    and executes an associated callback function when the event is triggered. Consider
    this example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器提供了比轮询更好的替代方法。浏览器为您提供了在事件发生时以编程方式做出反应的手段。这些挂钩通常称为监听器。您可以注册一个监听器，以对特定事件做出反应，并在事件触发时执行相关的回调函数。考虑这个例子：
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `addEventListener` function registers its second argument as a callback
    function. This callback is executed when the event specified in the first argument
    is triggered.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEventListener`函数将其第二个参数注册为回调函数。当触发第一个参数中指定的事件时，将执行此回调。'
- en: 'What we saw just now was a generic listener for the `click` event. Similarly,
    every DOM element has its own `addEventListener` method, which allows you to listen
    specifically on this element:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才我们看到的是`click`事件的通用监听器。同样，每个DOM元素都有自己的`addEventListener`方法，允许您专门在此元素上监听：
- en: '[PRE25]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we are using the reference to a specific element—a button with
    a `Bigbutton` ID—by calling `getElementById()`. On the reference of the button
    element, we are calling `addEventListener()` to assign a handler function for
    the click event. This is perfectly legitimate code that works fine in modern browsers
    such as Mozilla Firefox or Google Chrome. On Internet Explorer prior to IE9, however,
    this is not a valid code. This is because Microsoft implements its own custom
    `attachEvent()` method as opposed to the W3C standard `addEventListener()` prior
    to Internet Explorer 9\. This is very unfortunate because you will have to write
    very bad hacks to handle browser-specific quirks.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用特定元素的引用——具有`Bigbutton`ID的按钮——通过调用`getElementById()`。在按钮元素的引用上，我们调用`addEventListener()`为单击事件分配处理程序函数。这是完全合法的代码，在现代浏览器（如Mozilla
    Firefox或Google Chrome）中可以正常工作。然而，在IE9之前的Internet Explorer中，这不是有效的代码。这是因为Microsoft在Internet
    Explorer 9之前实现了自己的自定义`attachEvent()`方法，而不是W3C标准的`addEventListener()`。这非常不幸，因为您将不得不编写非常糟糕的代码来处理特定于浏览器的怪异行为。
- en: Propagation
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传播
- en: 'At this point, we should ask an important question—if an element and one of
    its ancestors have a handler on the same event, which handler will be fired first?
    Consider the following figure:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该问一个重要的问题——如果一个元素及其祖先在同一事件上有处理程序，哪个处理程序将首先触发？考虑以下图：
- en: '![Propagation](img/00027.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![传播](img/00027.jpeg)'
- en: For example, we have **Element2** as a child of **Element1** and both have the
    `onClick` handler. When a user clicks on Element2, `onClick` on both Element2
    and Element1 is triggered but the question is which one is triggered first. What
    should the event order be? Well, the answer, unfortunately, is that it depends
    entirely on the browser. When browsers first arrived, two opinions emerged, naturally,
    from Netscape and Microsoft.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有**Element2**作为**Element1**的子元素，两者都有`onClick`处理程序。当用户单击Element2时，Element2和Element1上的`onClick`都会触发，但问题是哪一个会首先触发。事件顺序应该是什么？很不幸，答案完全取决于浏览器。当浏览器首次出现时，自然地，来自Netscape和Microsoft的两种观点出现了。
- en: Netscape decided that the first event triggered should be Element1's `onClick`.
    This event ordering is known as event capturing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Netscape决定首先触发的事件应该是Element1的`onClick`。这种事件顺序被称为事件捕获。
- en: Microsoft decided that the first event triggered should be Element2's `onClick`.
    This event ordering is known as event bubbling.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft决定首先触发的事件应该是Element2的`onClick`。这种事件顺序被称为事件冒泡。
- en: These are two completely opposite views and implementations of how browsers
    handled events. To end this madness, **World Wide Web Consortium** (**W3C**) decided
    a wise middle path. In this model, an event is first captured until it reaches
    the target element and then bubbles up again. In this standard behavior, you can
    choose in which phase you want to register your event handler—either in the capturing
    or bubbling phase. If the last argument is true in `addEventListener()`, the event
    handler is set for the capturing phase, if it is false, the event handler is set
    for the bubbling phase.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种观点和实现方式完全相反，涉及浏览器如何处理事件。为了结束这种疯狂，**万维网联盟**（**W3C**）决定采取明智的中间道路。在这个模型中，事件首先被捕获，直到达到目标元素，然后再次冒泡。在这种标准行为中，您可以选择在哪个阶段注册事件处理程序——捕获阶段或冒泡阶段。如果`addEventListener()`中的最后一个参数为true，则事件处理程序设置为捕获阶段，如果为false，则事件处理程序设置为冒泡阶段。
- en: There are times when you don't want the event to be raised by the parents if
    it was already raised by the child. You can call the `stopPropagation()` method
    on the event object to prevent handlers further up from receiving the event. Several
    events have a default action associated with them. For example, if you click on
    a URL link, you will be taken to the link's target. The JavaScript event handlers
    are called before the default behavior is performed. You can call the `preventDefault()`
    method on the event object to stop the default behavior from being triggered.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，如果事件已经由子元素触发，您不希望父元素触发该事件。您可以在事件对象上调用`stopPropagation()`方法，以防止更上层的处理程序接收事件。几个事件与默认操作相关联。例如，如果单击URL链接，您将转到链接的目标。在执行默认行为之前，将调用JavaScript事件处理程序。您可以在事件对象上调用`preventDefault()`方法，以阻止触发默认行为。
- en: These are event basics when you are using plain JavaScript on a browser. There
    is a problem here. Browsers are notorious when it comes to defining event-handling
    behavior. We will look at jQuery's event handling. To make things easier to manage,
    jQuery always registers event handlers for the bubbling phase of the model. This
    means that the most specific elements will get the first opportunity to respond
    to any event.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在浏览器上使用纯JavaScript时的事件基础知识。这里有一个问题。当涉及定义事件处理行为时，浏览器是臭名昭著的。我们将看一下jQuery的事件处理。为了使事情更容易管理，jQuery总是为模型的冒泡阶段注册事件处理程序。这意味着最具体的元素将首先有机会对任何事件做出响应。
- en: jQuery event handling and propagation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: jQuery事件处理和传播
- en: 'jQuery event handling takes care of many of these browser quirks. You can focus
    on writing code that runs on most supported browsers. jQuery''s support for browser
    events is simple and intuitive. For example, this code listens for a user to click
    on any button element on the page:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery事件处理处理了许多这些浏览器怪癖。您可以专注于编写在大多数受支持的浏览器上运行的代码。jQuery对浏览器事件的支持简单直观。例如，此代码监听用户单击页面上的任何按钮元素：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Just like the `click()` method, there are several other helper methods to cover
    almost all kinds of browser event. The following helpers exist:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`click()`方法一样，还有其他几种辅助方法来覆盖几乎所有类型的浏览器事件。存在以下辅助方法：
- en: '`blur`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blur`'
- en: '`change`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`change`'
- en: '`click`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`click`'
- en: '`dblclick`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dblclick`'
- en: '`error`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`'
- en: '`focus`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`focus`'
- en: '`keydown`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keydown`'
- en: '`keypress`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keypress`'
- en: '`keyup`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyup`'
- en: '`load`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load`'
- en: '`mousedown`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mousedown`'
- en: '`mousemove`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mousemove`'
- en: '`mouseout`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseout`'
- en: '`mouseover`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseover`'
- en: '`mouseup`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseup`'
- en: '`resize`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resize`'
- en: '`scroll`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scroll`'
- en: '`select`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`select`'
- en: '`submit`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit`'
- en: '`unload`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unload`'
- en: Alternatively, you can use the `.on()` method. There are a few advantages of
    using the `on()` method as it gives you a lot more flexibility. The `on()` method
    allows you to bind a handler to multiple events. Using the `on()` method, you
    can work on custom events as well.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`.on()`方法。使用`on()`方法有一些优势，因为它给您更多的灵活性。`on()`方法允许您将处理程序绑定到多个事件上。使用`on()`方法，您还可以处理自定义事件。
- en: 'Event name is passed as the first parameter to the `on()` method just like
    the other methods that we saw:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 事件名称作为第一个参数传递给`on()`方法，就像我们看到的其他方法一样：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Once you''ve registered an event handler to an element, you can trigger this
    event as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注册了元素的事件处理程序后，可以按如下方式触发此事件：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This event can also be triggered as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此事件也可以按如下方式触发：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can unbind an event using jQuery''s `.off()` method. This will remove any
    event handlers that were bound to the specified event:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用jQuery的`.off()`方法解除绑定事件。这将删除绑定到指定事件的任何事件处理程序：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can add more than one handler to an element:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向元素添加多个处理程序：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When the event is fired, both the handlers will be invoked. If you want to
    remove only the first handler, you can use the `off()` method with the second
    parameter indicating the handler that you want to remove:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件触发时，两个处理程序都将被调用。如果您只想删除第一个处理程序，可以使用`off()`方法，并指示要删除的处理程序作为第二个参数：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is possible if you have the reference to the handler. If you are using
    anonymous functions as handlers, you can''t get reference to them. In this case,
    you can use namespaced events. Consider the following example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有对处理程序的引用，这是可能的。如果您将匿名函数用作处理程序，您无法引用它们。在这种情况下，您可以使用命名空间事件。考虑以下示例：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now that you have a namespaced event handler registered with the element, you
    can remove it as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经向元素注册了一个命名空间事件处理程序，可以按如下方式将其删除：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'A major advantage of using `.on()` is that you can bind to multiple events
    at once. The `.on()` method allows you to pass multiple events in a space-separated
    string. Consider the following example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`.on()`的一个主要优势是您可以一次绑定多个事件。`.on()`方法允许您在以空格分隔的字符串中传递多个事件。考虑以下示例：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can add multiple event handlers for multiple events as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按如下方式为多个事件添加多个事件处理程序：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As of jQuery 1.7, all events are bound via the `on()` method, even if you call
    helper methods such as `click()`. Internally, jQuery maps these calls to the `on()`
    method. Due to this, it's generally recommended to use the `on()` method for consistency
    and faster execution.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从jQuery 1.7开始，所有事件都是通过`on()`方法绑定的，即使您调用`click()`等辅助方法。在内部，jQuery将这些调用映射到`on()`方法。因此，通常建议使用`on()`方法以保持一致性和更快的执行。
- en: Event delegation
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件委托
- en: Event delegation allows us to attach a single event listener to a parent element.
    This event will fire for all the descendants matching a selector even if these
    descendants will be created in the future (after the listener was bound to the
    element).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 事件委托允许我们将单个事件侦听器附加到父元素。即使这些后代将来创建（在侦听器绑定到元素之后），此事件也将对匹配选择器的所有后代触发。
- en: 'We discussed *event bubbling* earlier. Event delegation in jQuery works primarily
    due to event bubbling. Whenever an event occurs on a page, the event bubbles up
    from the element that it originated from, up to its parent, then up to the parent''s
    parent, and so on, until it reaches the root element (`window`). Consider the
    following example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了*事件冒泡*。jQuery中的事件委托主要是由于事件冒泡而起作用。每当页面上发生事件时，事件都会从其起源元素冒泡到其父元素，然后冒泡到父元素的父元素，依此类推，直到达到根元素（`window`）。考虑以下示例：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now let''s say that we want to perform some common action on any of the URL
    clicks. We can add an event handler to all the `a` elements in the list as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想对任何URL单击执行一些常见操作。我们可以按如下方式向列表中的所有`a`元素添加事件处理程序：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This works perfectly fine, but this code has a minor bug. What will happen
    if there is an additional URL added to the list as a result of some dynamic action?
    Let''s say that we have an **Add** button that adds new URLs to this list. So,
    if the new list item is added with a new URL, the earlier event handler will not
    be attached to it. For example, if the following link is added to the list dynamically,
    clicking on it will not trigger the handler that we just added:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做完全没问题，但是这段代码有一个小错误。如果由于某些动态操作而向列表添加了其他URL，会发生什么？假设我们有一个**添加**按钮，可以向此列表添加新的URL。因此，如果新的列表项添加了新的URL，则早期的事件处理程序将不会附加到它。例如，如果动态添加了以下链接到列表中，单击它将不会触发我们刚刚添加的处理程序：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This is because such events are registered only when the `on()` method is called.
    In this case, as this new element did not exist when `.on()` was called, it does
    not get the event handler. With our understanding of event bubbling, we can visualize
    how the event will travel up the DOM tree. When any of the URLs are clicked on,
    the travel will be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为只有在调用`on()`方法时才注册此类事件。在这种情况下，由于在调用`.on()`时此新元素不存在，因此它不会获得事件处理程序。通过我们对事件冒泡的理解，我们可以想象事件将如何在DOM树中传播。当单击任何URL时，传播将如下进行：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can create a delegated event as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个委托事件，如下所示：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We moved `a` from the original selector to the second parameter in the `on()`
    method. This second parameter of the `on()` method tells the handler to listen
    to this specific event and check whether the triggering element was the second
    parameter (the `a` in our case). As the second parameter matches, the handler
    function is executed. With this delegate event, we are attaching a single handler
    to the entire `ul#list`. This handler will listen to the click event triggered
    by any descendent of the `ul` element.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `a` 从原始选择器移动到 `on()` 方法的第二个参数中。`on()` 方法的第二个参数告诉处理程序监听这个特定事件，并检查触发元素是否是第二个参数（在我们的例子中是
    `a`）。由于第二个参数匹配，处理程序函数被执行。通过这个委托事件，我们将一个单一的处理程序附加到整个 `ul#list`。这个处理程序将监听由 `ul`
    元素的任何后代触发的点击事件。
- en: The event object
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件对象
- en: 'So far, we attached anonymous functions as event handlers. To make our event
    handlers more generic and useful, we can create named functions and assign them
    to the events. Consider the following lines:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们附加了匿名函数作为事件处理程序。为了使我们的事件处理程序更通用和有用，我们可以创建命名函数并将它们分配给事件。考虑以下几行：
- en: '[PRE42]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, we are passing a named function instead of an anonymous function to the
    `on()` method. Let''s shift our focus now to the `event` parameter that we pass
    to the function. jQuery passes an event object with all the event callbacks. An
    event object contains very useful information about the event being triggered.
    In cases where we don''t want the default behavior of the element to kick in,
    we can use the `preventDefault()` method of the event object. For example, we
    want to fire an AJAX request instead of a complete form submission or we want
    to prevent the default location to be opened when a URL anchor is clicked on.
    In these cases, you may also want to prevent the event from bubbling up the DOM.
    You can stop the event propagation by calling the `stopPropagation()` method of
    the event object. Consider this example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一个命名函数传递给 `on()` 方法，而不是一个匿名函数。现在让我们把注意力转移到我们传递给函数的 `event` 参数上。jQuery
    传递一个带有所有事件回调的事件对象。事件对象包含有关触发的事件的非常有用的信息。在我们不希望元素的默认行为生效的情况下，我们可以使用事件对象的 `preventDefault()`
    方法。例如，我们希望触发一个 AJAX 请求而不是完整的表单提交，或者我们希望在单击 URL 锚点时阻止默认位置被打开。在这些情况下，您可能还希望阻止事件冒泡到
    DOM。您可以通过调用事件对象的 `stopPropagation()` 方法来停止事件传播。考虑这个例子：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Apart from the event object, you also get a reference to the DOM object on
    which the event was fired. This element can be referred by `$(this)`. Consider
    the following example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 除了事件对象，您还可以获得触发事件的 DOM 对象的引用。这个元素可以通过 `$(this)` 来引用。考虑以下例子：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was all about understanding JavaScript in its most important role—that
    of browser language. JavaScript plays the role of introducing dynamism on the
    web by facilitating DOM manipulation and event management on the browser. We discussed
    both of these concepts with and without jQuery. As the demands of the modern web
    are increasing, using libraries such as jQuery is essential. These libraries significantly
    improve the code quality and efficiency and, at the same time, give you the freedom
    to focus on important things.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要是关于理解 JavaScript 在其最重要的角色中——即浏览器语言的角色。JavaScript 通过在浏览器上进行 DOM 操作和事件管理，引入了网页的动态性。我们讨论了这两个概念，无论是使用还是不使用
    jQuery。随着现代网络的需求不断增加，使用 jQuery 等库是必不可少的。这些库显著提高了代码质量和效率，同时也让您有自由去关注重要的事情。
- en: We will focus on another incarnation of JavaScript—mainly on the server side.
    Node.js has become a popular JavaScript framework to write scalable server-side
    applications. We will take a detailed look at how we can best utilize Node.js
    for server applications.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于 JavaScript 的另一个版本——主要是在服务器端。Node.js 已经成为一个流行的 JavaScript 框架，用于编写可扩展的服务器端应用程序。我们将详细了解如何最好地利用
    Node.js 来开发服务器应用程序。
