- en: Chapter 5. Scripting with Blueprints
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用蓝图编写脚本
- en: 'We now come to one of the most important aspects of the game: interactivity.
    Without it, our game will just be an environment that the player can move around
    in. Those who have used UDK before may already be familiar with the concept of
    visual scripting. UDK had what is called Kismet, a powerful visual scripting tool.
    A really attractive feature of this tool is that anyone can use it without any
    prior programming knowledge. All you need to know is the logic behind the event
    you wish to implement. You can create a full game without even writing a single
    line of code.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到游戏中最重要的一个方面：互动性。没有它，我们的游戏只是玩家可以在其中移动的环境。以前使用过UDK的人可能已经熟悉视觉脚本的概念。UDK有一个称为Kismet的强大的视觉脚本工具。这个工具的一个非常吸引人的特点是任何人都可以在没有任何编程知识的情况下使用它。您只需要知道您希望实现的事件背后的逻辑。您甚至可以在不写一行代码的情况下创建一个完整的游戏。
- en: 'In Unreal 4, we have Blueprints, which is sort of an upgrade to Kismet. The
    basic setup is the same: you have various nodes and expressions, which you can
    use to script in-game events, actions, and so on. The interface is simple to understand,
    easy to use, and yet extremely powerful. Once you get the hang of it, you can
    create complex sequences and events.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻4中，我们有蓝图，这在某种程度上是对Kismet的升级。基本设置是相同的：您有各种节点和表达式，可以用来编写游戏事件、动作等。界面简单易懂，易于使用，但功能强大。一旦掌握了它，您就可以创建复杂的序列和事件。
- en: However, even though Blueprint is an easy-to-learn and a great tool, it is still
    limited in terms of what it can do. In that respect, C++ is much more versatile
    and flexible than Blueprint. C++ is great for implementing complex interactions
    and mechanics, which Blueprint may or may not offer. Another difference between
    Blueprint and C++ is that Blueprint is much slower to execute than C++ code, but
    this is only noticeable if you have a lot of Blueprint script in your game. There
    are several other differences between Blueprint and C++; but it all boils down
    to personal preference about the features, mechanics, and functionalities you
    want in your game. You can choose to use either one or both.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管蓝图是一种易学易用的工具，但在功能上仍然存在一定的局限性。在这方面，C++比蓝图更加灵活和多功能。C++非常适合实现复杂的交互和机制，而蓝图可能提供或可能不提供。蓝图和C++之间的另一个区别是，蓝图执行速度比C++代码慢得多，但只有在游戏中有大量蓝图脚本时才会注意到这一点。蓝图和C++之间还有其他几个区别；但最终都取决于您对游戏中所需功能、机制和功能的个人偏好。您可以选择使用其中一个或两者兼而有之。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What Blueprints are and how they work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图是什么以及它们的工作原理
- en: What Level Blueprints are and how to script using Level Blueprints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是级别蓝图以及如何使用级别蓝图进行脚本编写
- en: Level Blueprint user interface
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别蓝图用户界面
- en: What a Blueprint class is and how to use it in the game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图类是什么以及如何在游戏中使用它
- en: How to Script basic AI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写基本AI
- en: How Blueprint works
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图的工作原理
- en: 'Scripting in Blueprint is similar to creating a flowchart. At your disposal
    are various nodes, which you can connect to create an action sequence. In order
    to properly script in Blueprint, you should first know the logic behind the desired
    sequence. For example, say you want to implement a lamp that is switched on when
    you go near it and switched off when you move away from it. In such a case, you
    would first place a trigger around the lamp. Then, the logic behind this would
    be:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图中的脚本与创建流程图类似。您可以连接各种节点以创建动作序列。为了正确地在蓝图中编写脚本，您应该首先了解所需序列背后的逻辑。例如，假设您想要实现一个灯，当您靠近它时打开，当您远离它时关闭。在这种情况下，您首先会在灯周围放置一个触发器。然后，这背后的逻辑将是：
- en: If the player is overlapping the trigger, the light will be switched on.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家与触发器重叠，灯将被打开。
- en: If the player is not overlapping the trigger, the light will be switched off.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果玩家没有与触发器重叠，灯将被关闭。
- en: 'Now that we have figured out how to carry out this action, we can proceed to
    set up our nodes. Say your setup looks something like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经找到了如何执行此操作，我们可以继续设置我们的节点。假设您的设置看起来像这样：
- en: '![How Blueprint works](img/image00317.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图的工作原理](img/image00317.jpeg)'
- en: 'When the character walks into the box trigger, the ceiling light (the spotlight)
    is switched on. The Blueprint to toggle the light on/off will look something like
    this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当角色走进箱形触发器时，天花板灯（聚光灯）将被打开。切换灯的蓝图将看起来像这样：
- en: '![How Blueprint works](img/image00318.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图的工作原理](img/image00318.jpeg)'
- en: 'There are various types of nodes that you should know about:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种类型的节点，您应该了解：
- en: '**Event Nodes**: The nodes with the red bar are event notes. These are activated
    when the corresponding event takes place. They usually have a rightward facing
    arrow at the top left corner.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件节点**：红色条的节点是事件节点。这些在相应事件发生时被激活。它们通常在左上角有一个向右的箭头。'
- en: You also have Input Event Nodes, which fire off when the player gives the corresponding
    input (for example, firing a weapon when the player presses the left mouse button).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您还有输入事件节点，当玩家按下相应的输入时触发（例如，当玩家按下鼠标左键时开火）。
- en: '**Function Nodes**: The nodes with the blue top are function nodes. They usually
    have a function symbol **f** at the top left corner, as you can see in the preceding
    screenshot. These nodes perform a specific action on an actor or player.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能节点：蓝色顶部的节点是功能节点。通常在左上角有一个函数符号**f**，就像你在前面的截图中看到的那样。这些节点对演员或玩家执行特定操作。
- en: 'There are two types of function nodes: those that act upon an actor, and those
    that return a specific value. These types of nodes have green tops (not displayed
    in the screenshot). This includes things such as returning an actor''s location
    in the world, returning the actor''s velocity, and so on.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的功能节点：那些对演员产生影响的节点，以及返回特定值的节点。这些类型的节点具有绿色顶部（未在截图中显示）。这包括返回世界中演员的位置，返回演员的速度等。
- en: '**Reference or Variable Nodes**: The node in the center of the screenshot is
    a variable node (or reference). When you want a function node to act upon a specific
    actor in the scene, or if you want to "get" some of its property or properties,
    you need to create its reference in the Level Blueprint. The same goes with variable
    nodes. It should come as no surprise that variables play a very important role
    when scripting or coding. So naturally, you will have to create variables when
    you are using Blueprint.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用或变量节点**：屏幕截图中心的节点是一个变量节点（或引用）。当您希望函数节点作用于场景中的特定角色，或者如果您想要“获取”其某些属性，您需要在级别蓝图中创建其引用。变量节点也是如此。毫无疑问，变量在脚本或编码时起着非常重要的作用。因此，当您使用蓝图时，自然会创建变量。'
- en: When scripting using Blueprint, keep in mind that the fewer nodes you have,
    the better the performance. It also makes your workspace more organized and easier
    to read.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用蓝图进行脚本编写时，请记住节点越少，性能越好。这也使您的工作区更有组织且更易于阅读。
- en: When a particular event occurs, the corresponding event node fires off a pulse
    to whichever node it is attached. In our case, when the player overlaps the trigger,
    it will activate the Spotlight's **Toggle Visibility** function (since the light
    is off by default, it will toggle it on). And when the player stops overlapping
    the trigger (walks out of the trigger), it will fire the **Toggle Visibility**
    function once again (the light will be switched off).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当特定事件发生时，相应的事件节点会触发脉冲到其连接的任何节点。在我们的情况下，当玩家重叠触发器时，它将激活聚光灯的**切换可见性**功能（因为灯默认是关闭的，它将切换为开启）。当玩家停止重叠触发器（走出触发器）时，它将再次触发**切换可见性**功能（灯将关闭）。
- en: '![How Blueprint works](img/image00319.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![蓝图的工作原理](img/image00319.jpeg)'
- en: The preceding screenshot demonstrates how blueprints function when an event
    has taken place. When the player has overlapped the trigger (top left), the corresponding
    event fires off a pulse to the **Toggle Visibility** function, which toggles the
    light on. When the player moves out of the trigger, or stops overlapping, the
    corresponding event again fires a pulse to the **Toggle Visibility** function
    node, which toggles the light on.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图演示了事件发生时蓝图的功能。当玩家重叠触发器（左上角）时，相应的事件会触发脉冲到**切换可见性**功能，切换灯光开启。当玩家移出触发器或停止重叠时，相应的事件再次触发脉冲到**切换可见性**功能节点，切换灯光开启。
- en: You can actually see the pulse being fired whenever a node is activated. This
    makes debugging very easy, as you can see which node is causing the problem and
    fix it accordingly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您实际上可以看到每当节点被激活时脉冲被触发。这使得调试非常容易，因为您可以看到哪个节点导致了问题，并相应地进行修复。
- en: Apart from knowing the logic, you should also know which nodes are available
    and what they can be used to do. This comes with time and practice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了了解逻辑，您还应该知道哪些节点可用以及它们可以用来做什么。这需要时间和实践。
- en: 'There are two types of Blueprints in Unreal 4: Level Blueprint and Blueprint
    class.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻4中有两种蓝图：级别蓝图和蓝图类。
- en: Level Blueprints is to UE4 what Kismet was to UE3\. Each level or map that you
    create in your project file will have its own unique Level Blueprint. You can
    control everything level related using Level Blueprints, such as playing cutscenes,
    editing the properties of actors (visibility, location, and so on) in your level,
    and so on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 级别蓝图对于UE4来说就像Kismet对于UE3一样。您在项目文件中创建的每个级别或地图都将有其自己独特的级别蓝图。您可以使用级别蓝图控制与级别相关的一切，例如播放过场动画，在您的级别中编辑角色的属性（可见性、位置等）等等。
- en: Blueprint classes, on the other hand, are special actors that contain various
    components as well as scripts. These components include things such as static
    or skeletal meshes, camera, collision component, triggers, and audio components.
    By using scripts, you can set their properties and determine how they interact
    with the world. Blueprint classes are not unique to a particular level; therefore,
    you can use them in any map or level you have made in your project. You can export
    them to other projects as well.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，蓝图类是包含各种组件和脚本的特殊角色。这些组件包括静态或骨骼网格、摄像机、碰撞组件、触发器和音频组件等。通过脚本，您可以设置它们的属性并确定它们如何与世界交互。蓝图类不是特定于特定级别的；因此，您可以在您项目中制作的任何地图或级别中使用它们。您还可以将它们导出到其他项目中。
- en: Let us move on to the Level Blueprint's user interface.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讲解级别蓝图的用户界面。
- en: The Level Blueprint user interface
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级别蓝图用户界面
- en: The following screenshot features the Level Blueprint's user interface. Continuing
    with our style of dividing the UI into various parts, the interface is divided
    into sections, which we will go through individually.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了级别蓝图的用户界面。继续我们将界面分成各个部分的风格，界面被分成了几个部分，我们将逐个介绍。
- en: '![The Level Blueprint user interface](img/image00320.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![级别蓝图用户界面](img/image00320.jpeg)'
- en: The tab and menu bars
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选项卡和菜单栏
- en: The tab bar is the same as that seen in all the other windows. Just like in
    the case of web browsers, you can see which windows are open, swap between them,
    and close any window you want from there.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 选项卡栏与所有其他窗口中看到的相同。就像在Web浏览器中一样，您可以看到哪些窗口是打开的，在它们之间切换，并从那里关闭任何窗口。
- en: '![The tab and menu bars](img/image00321.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![选项卡和菜单栏](img/image00321.jpeg)'
- en: The menu bar is where you can access all the general commands and actions that
    you would need.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单栏是您可以访问所有通用命令和操作的地方。
- en: '**File**: In this menu, you can save your level, open any asset in your Content
    Browser, compile your blueprint, enable source control, and so on.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件**：在此菜单中，您可以保存您的级别，打开内容浏览器中的任何资产，编译蓝图，启用源代码控制等等。'
- en: '**Edit**: From this menu, you can perform actions such as undoing the last
    action, redoing it, searching for a specific node or expression, and so on.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编辑**：从此菜单中，您可以执行撤消上一个操作、重做操作、搜索特定节点或表达式等操作。'
- en: '**View**: Here, you can hide/unhide unused pins and unconnected pins (through
    which you connect nodes), zoom in, and zoom out in the event graph.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：在这里，您可以隐藏/显示未使用的引脚和未连接的引脚（通过它们连接节点），在事件图中放大和缩小。'
- en: '**Debug**: If there is a problem in your Blueprint sequence that you cannot
    figure out, you can use the options available in the Debug menu to find and resolve
    them. These include adding breaking points, watching the value of a particular
    variable at a particular point, and so on.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**：如果您的蓝图序列中有问题，您无法解决，您可以使用调试菜单中提供的选项来查找和解决问题。这包括添加断点、观察特定变量在特定点的值等。'
- en: '**Window**: Here, you can set what windows you want to be visible and what
    windows you do not want to be visible. You can customize the layout and save it
    from the Window menu.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**窗口**：在这里，您可以设置要显示的窗口和不想显示的窗口。您可以从窗口菜单中自定义布局并保存它。'
- en: '**Help**: From here, you can access Epic''s official documentation regarding
    Blueprints. You can also go to the Wiki page, the forums, and the Answer Hub from
    here.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帮助**：从这里，您可以访问Epic官方关于蓝图的文档。您还可以从这里访问Wiki页面、论坛和答案中心。'
- en: The toolbar
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具栏
- en: '**Toolbar** has the most commonly used actions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**工具栏**包含最常用的操作：'
- en: '![The toolbar](img/image00322.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![工具栏](img/image00322.jpeg)'
- en: 'The most commonly used actions are explained as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的操作解释如下：
- en: '**Compile**: Whenever you add, remove, or edit any node in the event graph,
    be sure to click on the **Compile** button. It compiles all the nodes and sequences,
    and if there is any error or warning, it will notify you in the **Compiler Results**
    panel, which you can then fix. Also, if you have a variable node, in order to
    set its default value, you first need to compile.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译**：每当您在事件图中添加、删除或编辑任何节点时，请务必点击**编译**按钮。它会编译所有节点和序列，如果有任何错误或警告，它会在**编译器结果**面板中通知您，然后您可以进行修复。此外，如果您有一个变量节点，为了设置其默认值，您首先需要编译。'
- en: '**Search**: When you have large and complex sequences with several connected
    nodes, trying to find a specific node or variable can be a tedious and time-consuming
    task. In order to avoid that, you can click on the **Search** button, and type
    in the name of whatever it is you wish to find. The results will, by default,
    be displayed at the bottom of the screen, where the **Compiler Results** panel
    is (it will open a new tab called **Find Results**).'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**搜索**：当您有大型和复杂的序列，有几个连接的节点时，尝试找到特定节点或变量可能是一项繁琐和耗时的任务。为了避免这种情况，您可以点击**搜索**按钮，然后输入您想要查找的内容的名称。结果将默认显示在屏幕底部，**编译器结果**面板所在的位置（它将打开一个名为**查找结果**的新选项卡）。'
- en: '**Class Settings**: Clicking on this will open up the Blueprint settings in
    the **Details panel**, where you can set certain options such as adding a description,
    category, and so on.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类设置**：点击这个按钮将在**详细信息面板**中打开蓝图设置，您可以在那里设置某些选项，比如添加描述、类别等。'
- en: '**Class Defaults**: Here, you can set the default or initial values of your
    Blueprint class.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类默认**：在这里，您可以设置蓝图类的默认或初始值。'
- en: '**Play**: Similar to the **Play** button in the **Viewport** toolbar, this
    opens a new window where you can test your game. While the game is running, clicking
    the *Esc* button will close the game and return to the Editor. You may notice
    a small downward-facing arrow next to the button. This opens a menu where you
    can set options such as how you want to preview your game, where the player should
    start, and so on.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**播放**：类似于**视口**工具栏中的**播放**按钮，这将打开一个新窗口，您可以在其中测试您的游戏。游戏运行时，点击*Esc*按钮将关闭游戏并返回到编辑器。您可能会注意到按钮旁边有一个小向下的箭头。这将打开一个菜单，您可以在其中设置选项，比如您想要预览游戏的方式，玩家应该从哪里开始等等。'
- en: The Details panel
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细信息面板
- en: In the **Details** panel, you can set the properties of various nodes and variables.
    It offers settings such as the type of variable you want (Boolean, float, integer,
    and so on), the name of the variable, and more.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在**详细信息**面板中，您可以设置各种节点和变量的属性。它提供设置，比如您想要的变量类型（布尔值、浮点数、整数等）、变量名称等。
- en: '![The Details panel](img/image00323.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![详细信息面板](img/image00323.jpeg)'
- en: The Compiler Results panel
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译器结果面板
- en: Anyone who has any programming knowledge will know what compilation is. It occurs
    when the code that you have written is converted from the language you wrote the
    code in into machine language that the computer understands, so that it can be
    executed. This is usually handled by a compiler. (If you do not see the **Compiler
    Results** panel, in Level Blueprint, go to Window, and click on **Compiler Results**.)
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有编程知识的人都会知道什么是编译。当您编写的代码从您编写代码的语言转换为计算机理解的机器语言时，就会发生编译，以便可以执行。这通常由编译器处理。（如果您在级别蓝图中看不到**编译器结果**面板，请转到窗口，然后点击**编译器结果**。）
- en: '![The Compiler Results panel](img/image00324.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![编译器结果面板](img/image00324.jpeg)'
- en: In the **Compiler Results** panel, you can see the output log of the compiler.
    How long it took to compile, any errors found during compilations, any warnings,
    and so on, all are displayed here.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在**编译器结果**面板中，您可以看到编译器的输出日志。编译花费了多长时间，编译期间发现的任何错误，任何警告等都会显示在这里。
- en: My Blueprint panel
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我的蓝图面板
- en: In this panel, you can see a list of all of the events, variables, and event
    dispatchers that you have created. Whenever you create an event node, it is displayed
    here, under **EventGraph**. Apart from that, you can also create various functions,
    macros, variables, and so on. To do so, you can click on the **Add New** button
    and select whatever it is you want to create, or by clicking on the **+** button
    in front of the names.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个面板中，您可以看到您创建的所有事件、变量和事件分发器的列表。每当您创建一个事件节点，它都会显示在**事件图**下面。除此之外，您还可以创建各种函数、宏、变量等。要这样做，您可以点击**添加新**按钮，然后选择您想要创建的内容，或者点击名称前面的**+**按钮。
- en: '![My Blueprint panel](img/image00325.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![我的蓝图面板](img/image00325.jpeg)'
- en: The Event Graph
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件图
- en: Located at the center of the screen, the **Event Graph** (also referred to as
    **Graph Editor**) is where you set up your nodes and sequences. By default, there
    are two event nodes already set up, namely **Event Begin Play**, which is activated
    when the game begins, and **Event Tick**, which is activated at every frame. These
    two events do not require any trigger to be activated.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 位于屏幕中央的**事件图**（也称为**图编辑器**）是您设置节点和序列的地方。默认情况下，已经设置了两个事件节点，即**事件开始播放**，在游戏开始时激活，以及**事件Tick**，在每一帧激活。这两个事件不需要任何触发器来激活。
- en: '![The Event Graph](img/image00326.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![事件图](img/image00326.jpeg)'
- en: At the top, you can see the tab. Below the tab, at the top-left corner, are
    two arrows. You can use them to switch between graphs. At the center, you can
    see the hierarchy and the blueprint structure. At the extreme right, you can see
    the zoom ratio—in other words, how much you have zoomed in our zoomed out.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，您可以看到选项卡。在选项卡下方，左上角有两个箭头。您可以使用它们在图表之间切换。在中心，您可以看到层次结构和蓝图结构。在极右边，您可以看到缩放比例—换句话说，您已经缩放了多少。
- en: 'The following table lists the controls of **Event Graph** that you should know
    and memorize:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下表列出了您应该了解和记忆的**事件图**的控件：
- en: '| Control | Action |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 动作 |'
- en: '| --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Left-click on mouse | Selects nodes |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 鼠标左键单击 | 选择节点 |'
- en: '| Left-click + drag | Creates selection box |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 左键单击+拖动 | 创建选择框 |'
- en: '| Right-click | Opens the Action Menu |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 右键单击 | 打开操作菜单 |'
- en: '| Right-click + drag | Pans the Graph Editor |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 右键单击+拖动 | 平移图编辑器 |'
- en: '| Scroll wheel up | Zooms in |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 滚轮向上 | 放大 |'
- en: '| Scroll wheel down | Zooms out |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 滚轮向下 | 缩小 |'
- en: '| C | Creates a comment box around selected node(s) |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| C | 在选定的节点周围创建注释框 |'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even though it is visual scripting, it can still get pretty messy when you script
    using Blueprints. So, to avoid confusion and keep everything organized, it is
    advisable to create comment boxes around your nodes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它是可视化脚本，但使用蓝图进行编写时仍然可能会变得非常混乱。因此，为了避免混淆并保持一切有序，建议在节点周围创建注释框。
- en: Using Level Blueprint in the game
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在游戏中使用关卡蓝图
- en: With all the basics out of the way, we can begin scripting our game. One thing
    you should know is that we might add more triggers and actors as we go along.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了所有基础知识，可以开始编写游戏了。您应该知道的一件事是，随着游戏的进行，我们可能会添加更多的触发器和角色。
- en: Key cube pickup and placement
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钥匙立方体拾取和放置
- en: The first thing that we are going to script is the player picking up the key
    cube. Now, when the player is close enough to the key cube and taps on it on their
    screen, they will be able to pick up the cube. In our case, to give the illusion
    that the player has picked up the key, we are going to destroy the actor when
    the player taps on it on the screen. Also, we will place a replica of the key
    cube on top of the pedestal at the very beginning and keep it hidden at the start
    of the game. When the player has picked up the cube and is close enough to the
    pedestal, tapping on the screen will unhide the cube from the game, giving the
    impression that the character has placed the key on the pedestal. So, let's set
    that up. Firstly, with the key cube selected, hold down the *Alt* button, and
    with the help of the Transform tool, drag out a duplicate. Place this duplicate
    on top of the pedestal.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要编写的第一件事是玩家拾取钥匙立方体。现在，当玩家靠近钥匙立方体并在屏幕上点击它时，他们将能够拾取立方体。在我们的情况下，为了让玩家产生拾取钥匙的错觉，当玩家在屏幕上点击时，我们将销毁该角色。此外，我们将在底座顶部放置一个钥匙立方体的复制品，并在游戏开始时将其隐藏起来。当玩家拾取了立方体并且靠近底座时，在屏幕上点击将使立方体从游戏中显示出来，给人一种角色已经将钥匙放在底座上的印象。所以，让我们设置一下。首先，选择钥匙立方体，按住*Alt*按钮，并借助变换工具，拖出一个副本。将这个副本放在底座顶部。
- en: '![Key cube pickup and placement](img/image00327.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![钥匙立方体拾取和放置](img/image00327.jpeg)'
- en: In its **Details** panel, under the **Rendering** section, tick the **Actor
    Hidden in Game** option. Doing so will hide the game from view during runtime.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在其**详细信息**面板中，在**渲染**部分下，选中**游戏中隐藏的角色**选项。这样做将在运行时隐藏游戏。
- en: '![Key cube pickup and placement](img/image00328.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![钥匙立方体拾取和放置](img/image00328.jpeg)'
- en: Now, let's open the Level Blueprint. To do this, click on **Blueprints** in
    the **Viewport** toolbar and select **Open Level Blueprint**.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开关卡蓝图。要做到这一点，点击**视口**工具栏中的**蓝图**，然后选择**打开关卡蓝图**。
- en: Now, the event in this case would be the player tapping on the screen, or in
    technical terms, providing a touch input. So in the **Event Graph** window, right-click
    to open the **Actions** menu and type in `Touch`. This should find and display
    the **Touch** event node. Click on it to add it to the **Event Graph**. You may
    find various types of **Touch** nodes—the one you need is the node that simply
    says **Touch**.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这种情况下，事件是玩家在屏幕上轻触，或者在技术术语中，提供触摸输入。因此，在**事件图**窗口中，右键单击打开**操作**菜单，然后键入`Touch`。这样应该可以找到并显示**Touch**事件节点。单击它以将其添加到**事件图**中。您可能会找到各种类型的**Touch**节点—您需要的是简单地说**Touch**的节点。
- en: '![Key cube pickup and placement](img/image00329.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![钥匙立方体拾取和放置](img/image00329.jpeg)'
- en: the **InputTouch** event node, we are only concerned with the **Pressed** output
    pin. The **Pressed** pin will be activated when the player presses anywhere on
    the screen.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在**InputTouch**事件节点中，我们只关注**Pressed**输出引脚。当玩家在屏幕上按下时，**Pressed**引脚将被激活。
- en: To remove the box from the scene, we are going to use the **Destroy Actor**
    function node. So, right-click anywhere in the **Graph Editor**, type in `Destroy
    Actor`, and click on the result (you can also find it manually find under the
    **Utility** section). With both nodes present, connect the **Pressed** output
    pin to the **Destroy Actor** input pin. Now, the function does not know itself
    which actor it has to destroy. We have to specify to it which actor we want to
    get rid of. In Blueprint terms, we have to create a reference to the actor we
    wish to apply the function to. So, in the **Viewport**, select the key cube. Then,
    in the **Graph Editor**, right-click and select **Create a Reference to TemplateCube_Rounded**.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从场景中移除盒子，我们将使用**销毁演员**功能节点。因此，在**图形编辑器**中的任何位置右键单击，键入`销毁演员`，然后点击结果（你也可以在**实用工具**部分手动找到它）。有了这两个节点后，将**按下**输出引脚连接到**销毁演员**输入引脚。现在，函数不知道它自己要销毁哪个演员。我们必须告诉它我们想要摆脱哪个演员。在蓝图术语中，我们必须创建一个对我们希望应用该函数的演员的引用。因此，在**视口**中，选择关键立方体。然后，在**图形编辑器**中，右键单击并选择**创建对TemplateCube_Rounded的引用**。
- en: If your object has a different name, instead of **TemplateCube_Rounded**, you
    will see the name of the actor.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的对象有不同的名称，而不是**TemplateCube_Rounded**，你会看到演员的名称。
- en: '![Key cube pickup and placement](img/image00330.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![关键立方体的拾取和放置](img/image00330.jpeg)'
- en: Doing so will create a reference node with the name of the actor written on
    it. Connect this to the **Destroy Actor** target pin.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将创建一个带有演员名称的参考节点。将其连接到**销毁演员**目标引脚。
- en: 'Another way of doing this is to drag the reference node''s output pin and release
    it anywhere in the **Event Graph**. Doing so will open a menu, from where you
    can select the **Destroy Actor** node. Once created, the reference node will automatically
    be connected to it. The setup so far should look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是拖动参考节点的输出引脚，并将其释放到**事件图**中的任何位置。这样将打开一个菜单，你可以从中选择**销毁演员**节点。一旦创建，参考节点将自动连接到它。到目前为止，设置应该是这样的：
- en: '![Key cube pickup and placement](img/image00331.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![关键立方体的拾取和放置](img/image00331.jpeg)'
- en: However, there is a problem here. If you were to test your game, you would notice
    that the cube is destroyed when you tap on the screen, no matter where you are.
    We only want the cube to be destroyed when the player is close enough to it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一个问题。如果你测试你的游戏，你会注意到无论你在屏幕上点击哪里，立方体都会被销毁。我们只希望当玩家足够靠近时才销毁立方体。
- en: To resolve this issue, the first thing we are going to do is render the input
    disabled at the start of the game. As you may remember, the event node that is
    activated when the game begins, **Event Begin Play**, is already present in the
    **Graph Editor**. To this, we are going to attach a **Disable Input** node. Right-click
    and find the node, and connect it to the **Event Begin Play**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们要做的第一件事是在游戏开始时禁用输入。你可能还记得，当游戏开始时激活的事件节点**事件开始播放**已经存在于**图形编辑器**中。我们要在这个事件上附加一个**禁用输入**节点。右键单击并找到该节点，并将其连接到**事件开始播放**。
- en: '![Key cube pickup and placement](img/image00332.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![关键立方体的拾取和放置](img/image00332.jpeg)'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although not required right now, if your game has several players or controllers,
    you will have to specify which player's controller you wish to disable. This can
    be done by first creating a **Get Player Controller** node and attaching it to
    **Player Controller** in the **Disable Input** node. By default, **Player Index**
    of the character you play as is 0.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现在不是必需的，但如果你的游戏有多个玩家或控制器，你将不得不指定要禁用哪个玩家的控制器。首先创建一个**获取玩家控制器**节点，并将其附加到**禁用输入**节点中的**玩家控制器**。默认情况下，你所扮演的角色的**玩家索引**为0。
- en: If you test your game now, when you tap on the screen, the key cube is not destroyed
    (although the character will start shooting projectiles again). Now, going back
    to our sequence, since we want the player to be only able to pick up the cube
    when they are at a certain distance, we are going to enable their input when they
    are overlapping with the trigger we had placed around the key cube.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在测试你的游戏，当你点击屏幕时，关键立方体不会被销毁（尽管角色会再次开始发射抛射物）。现在，回到我们的顺序，因为我们希望玩家只能在与我们放置在关键立方体周围的触发器重叠时才能拾取立方体，所以我们将在他们与触发器重叠时启用他们的输入。
- en: With the trigger selected, create an **EventBeginOverlap** node. After creating
    it, create an **Enable Input** node and attach it to the **EventBeginOverlap**
    node's output pin.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 选择触发器后，创建一个**事件开始重叠**节点。创建后，创建一个**启用输入**节点，并将其连接到**事件开始重叠**节点的输出引脚。
- en: '![Key cube pickup and placement](img/image00333.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![关键立方体的拾取和放置](img/image00333.jpeg)'
- en: We are now almost done with our setup. If you were to test it now, you would
    find that it functions the way we intended it to. However, this is still not complete.
    For one, if you have more than one key cube in your room, both of them will disappear
    when you click on one. We do not want that; we want only the key cube the player
    picks up to disappear. To do this, we are going to use a **Gate** node. A **Gate**
    node is used to control pulses going through the node based on certain conditions
    that you can set. For example, you can set it to **Open** when a certain event
    has taken place, and so on. For instance, when the player has overlapped with
    the trigger, it will open the gate, allowing pulses to go through it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎完成了设置。如果你现在测试它，你会发现它的功能方式与我们打算的一样。然而，这还不完整。首先，如果你的房间里有多个关键立方体，当你点击其中一个时，它们都会消失。我们不希望这样；我们只希望玩家拾取的关键立方体消失。为此，我们将使用一个**Gate**节点。**Gate**节点用于根据你可以设置的某些条件来控制通过节点的脉冲。例如，你可以设置它在发生某个事件时**打开**，等等。例如，当玩家与触发器重叠时，它将打开门，允许脉冲通过它。
- en: Right-click anywhere in the **Event Graph** and type `Gate`. Then, click on
    it to place it. You can also find it under **Utilities** | **Flow Control** |
    **Gate**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在**事件图**中的任何位置右键单击，然后键入`Gate`。然后，点击放置它。你也可以在**实用工具** | **流程控制** | **Gate**下找到它。
- en: '![Key cube pickup and placement](img/image00334.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![关键立方体的拾取和放置](img/image00334.jpeg)'
- en: The event you wish to control is connected to the **Gate** node's **Enter**
    input. The rest of the events are used to control the flow. Connecting the **Close**
    input to an event will stop anything from passing through the **Gate** when the
    event has occurred. Similarly, connecting the **Open** input to an event or function
    will allow pulses to pass through the node. The **Toggle** node will either open
    the **Gate** node if it was initially closed or vice versa. Finally, you have
    a **Start Closed** pin, which sets the initial state of the **Gate** node. If
    checked, it will be closed initially, and when unchecked, it will be open initially.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望控制的事件与**Gate**节点的**Enter**输入相连。其余的事件用于控制流程。将**Close**输入连接到事件将会阻止任何东西通过**Gate**当事件发生时。同样，将**Open**输入连接到事件或功能将允许脉冲通过节点。**Toggle**节点将打开**Gate**节点（如果最初关闭）或反之亦然。最后，您有一个**Start
    Closed**引脚，它设置了**Gate**节点的初始状态。如果选中，它最初将关闭，取消选中则最初将打开。
- en: 'First, disconnect the **Pressed** pin from the **InputTouch** node and connect
    it, instead, to the Gate node''s **Enter** pin. Then, connect the **Exit** pin
    to the **Destroy Actor** function''s Input pin. Once that is done, we need an
    event that will open the Gate node. This event would be when the player overlaps
    with the trigger. So, take the output pin of the **Enable Input** node and connect
    it to the **Open** input pin of the Gate node (make sure that **Start Closed**
    is checked). Your setup should look like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，断开**Pressed**引脚与**InputTouch**节点的连接，而是将其连接到Gate节点的**Enter**引脚。然后，将**Exit**引脚连接到**Destroy
    Actor**函数的输入引脚。完成后，我们需要一个事件来打开Gate节点。这个事件是玩家与触发器重叠时。因此，将**Enable Input**节点的输出引脚连接到Gate节点的**Open**输入引脚（确保**Start
    Closed**已选中）。您的设置应该如下所示：
- en: '![Key cube pickup and placement](img/image00335.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![关键方块拾取和放置](img/image00335.jpeg)'
- en: 'Now, when the player steps out of the trigger, that is, stops overlapping with
    the trigger, we again want to disable the input. So, with the trigger box selected,
    create an **OnActorEndOverlap** node. You can type it in the search bar or find
    it under **Add Event** for <name of the actor> | **Collision** | **Add On Actor
    End Overlap**. Also, create a **Disable Input** node. Again, you can type it in
    or find under **Input** | **Disable Input**. With everything set up, here is what
    we should end up with:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当玩家走出触发器，也就是停止与触发器重叠时，我们再次希望禁用输入。因此，选择触发框，创建一个**OnActorEndOverlap**节点。您可以在搜索栏中输入或在<actor名称>
    | **Collision** | **Add On Actor End Overlap**下找到它。还要创建一个**Disable Input**节点。同样，您可以输入或在**Input**
    | **Disable Input**下找到它。设置好一切后，我们应该得到以下结果：
- en: '![Key cube pickup and placement](img/image00336.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![关键方块拾取和放置](img/image00336.jpeg)'
- en: We now have a simple pickup action. But we have more to do before we are finished.
    We have only just scripted the picking up of the cube. We still have to script
    in for when the player places the key cube. This is straightforward.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个简单的拾取动作。但在完成之前，我们还有更多工作要做。我们只是编写了拾取方块的脚本。我们还需要为玩家放置关键方块编写脚本。这很简单。
- en: The first thing we need to do is add an overlap event that would enable the
    player's input. Hook them up the same way as you did with the previous trigger.
    Next, we are going to add another Touch event node. To this, we are going to connect
    a **Set Actor Hidden in Game** node. First, select the other key cube (the one
    that is hidden in the game), then right-click anywhere in the **Graph Editor**,
    and find it by typing in its name in the search bar. You can also find it in **Call
    Function** on <name of the selected actor> | **Rendering** | **Set Actor Hidden
    in Game**. You will notice that when you create this node, a reference node for
    the key cube will automatically be created with it, and connect to the **Target**
    input. Next, connect the **Pressed** output pin to the **Set Actor Hidden in Game**
    node's input pin. After having done that, add a **Gate** node with its **Toggle**
    input connected to the output of the **Enable Output** node.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是添加一个重叠事件，以启用玩家的输入。将它们与之前的触发器连接方式相同。接下来，我们将添加另一个触摸事件节点。我们将连接一个**Set
    Actor Hidden in Game**节点。首先，选择另一个关键方块（在游戏中隐藏的那个），然后在**Graph Editor**中的任意位置右键单击，并通过搜索栏找到它。您还可以在<所选角色名称>
    | **Rendering** | **Set Actor Hidden in Game**中找到它。当您创建此节点时，将自动创建一个关键方块的引用节点，并连接到**Target**输入。接下来，将**Pressed**输出引脚连接到**Set
    Actor Hidden in Game**节点的输入引脚。完成后，添加一个**Gate**节点，将其**Toggle**输入连接到**Enable Output**节点的输出。
- en: Finally, create an **OnActorEndOverlap** node and connect a **Disable Input**
    node to it, just like with the previous trigger.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建一个**OnActorEndOverlap**节点，并像之前的触发器一样连接一个**Disable Input**节点。
- en: '![Key cube pickup and placement](img/image00337.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![关键方块拾取和放置](img/image00337.jpeg)'
- en: 'If you were to test it out, you would find it working perfectly. However, there
    is a problem here: we have not set a condition as to when the player can place
    or unhide the key cube on the pedestal. In other words, if the player simply walks
    up to the pedestal, without picking up the first key cube, they would still be
    able to unhide the other key cube, since that would mean that the player can progress
    through the room without picking up the key cube.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进行测试，您会发现它完美地运行。但是，这里有一个问题：我们没有设置玩家何时可以放置或显示底座上的关键方块的条件。换句话说，如果玩家只是走到底座旁，而没有拾取第一个关键方块，他们仍然可以显示其他关键方块，因为这意味着玩家可以在不拾取关键方块的情况下通过房间。
- en: To fix that, we are first going to change a few properties of the trigger on
    the pedestal. We need to first turn off the trigger's collision. We will have
    to set it up so that initially, the trigger on the pedestal ignores all types
    of overlap events—in other words, toggle it off. To do so, select the trigger
    on the pedestal, and in the Details panel, go to the **Collision** section. Under
    this section, you will see an option called **Collision Presets**. By default,
    it will be set to **Trigger**. Click on the bar to open the preset menu. From
    here, select **Custom**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们首先要改变基座上触发器的一些属性。我们需要首先关闭触发器的碰撞。我们将设置它，使得最初，基座上的触发器忽略所有类型的重叠事件，换句话说，将其关闭。要这样做，选择基座上的触发器，在详细面板中，转到**碰撞**部分。在这个部分下，你会看到一个名为**碰撞预设**的选项。默认情况下，它将被设置为**触发器**。点击条以打开预设菜单。从这里，选择**自定义**。
- en: '![Key cube pickup and placement](img/image00338.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![关键立方体拾取和放置](img/image00338.jpeg)'
- en: 'Next, click on the small triangle next to **Collision Presets** in order to
    open a list of the trigger''s collision responses against different types of actors.
    There are three general responses:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击**碰撞预设**旁边的小三角，以打开触发器对不同类型角色的碰撞响应列表。有三种一般的响应：
- en: '**Ignore**: The trigger will not register any response to the collision. The
    actor(s) the trigger is set to ignore will neither be blocked, nor be registered
    by it.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**忽略**：触发器不会对碰撞做出任何响应。触发器设置为忽略的角色既不会被阻挡，也不会被它注册。'
- en: '**Overlap**: The actor(s) the trigger is set to overlap will not be blocked
    by it, but the collision will be registered by it. This collision registration
    is how we are able to script things such as switching on the light when the player
    overlaps the trigger.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重叠**：触发器设置为重叠的角色不会被它阻挡，但碰撞会被它注册。这种碰撞注册是我们能够编写脚本的方式，比如当玩家重叠触发器时开灯。'
- en: '**Block**: The actor(s) the trigger is set to block will not be able to pass
    through it. It will act like a wall.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻挡**：触发器设置为阻挡的角色将无法通过它。它会像一堵墙一样。'
- en: You can either set what response you want from each actor individually, or choose
    the general response you want from all actors. We will be doing the later. At
    the very top, there is an option called **Collision Response**. In front of that,
    you have three boxes, one for each type of response. Simply check the **Ignore**
    box, and everything below it will be set to ignore. This is what we want. We want
    the trigger to ignore collision for all actors initially. We will change its collision
    response when the player has picked up the key cube.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为每个角色单独设置所需的响应，也可以选择所有角色所需的一般响应。我们将选择后者。在最顶部，有一个名为**碰撞响应**的选项。在它前面，有三个框，分别对应每种响应类型。简单地勾选**忽略**框，下面的所有内容都将被设置为忽略。这就是我们想要的。我们希望触发器最初忽略所有角色的碰撞。当玩家拾取了关键立方体后，我们将改变它的碰撞响应。
- en: Coming back to the pickup setup we had made, we will need to add a few more
    nodes to it. Right-click anywhere in the **Event Graph**, and in the **Flow Control**
    section, you will find something called **Sequence**. Select and create it. A
    **Sequence** node takes one input and has multiple outputs. If you want a particular
    node to activate or set off various different events or functions, you should
    use a **Sequence** node.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前设置的拾取，我们需要向其中添加一些节点。在**事件图**中的任意位置右键单击，在**流程控制**部分，你会找到一个叫做**序列**的东西。选择并创建它。**序列**节点有一个输入和多个输出。如果你想要一个特定的节点来触发或设置各种不同的事件或功能，你应该使用**序列**节点。
- en: '![Key cube pickup and placement](img/image00339.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![关键立方体拾取和放置](img/image00339.jpeg)'
- en: By default, a **Sequence** node has one input pin and two output pins. The first
    node is fired first, then the next, and so on. If you want more output pins, simply
    click on **Add Pins**, and it will create another output pin. Now, connect the
    **Gate** node's output pin to the **Sequence** node's input pin. Then, connect
    **Then 0** to the **Destroy Actor** node.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，**序列**节点有一个输入引脚和两个输出引脚。第一个节点首先触发，然后是下一个，依此类推。如果你想要更多的输出引脚，只需点击**添加引脚**，它将创建另一个输出引脚。现在，将**门**节点的输出引脚连接到**序列**节点的输入引脚。然后，将**然后
    0**连接到**销毁角色**节点。
- en: '![Key cube pickup and placement](img/image00340.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![关键立方体拾取和放置](img/image00340.jpeg)'
- en: We will now change the **Collision Response** of the trigger to **Overlap**
    when the player has picked up the cube. With the trigger selected, right-click
    on it and first uncheck the **Context Sensitive** box, which is located at the
    top-right corner of the menu. When you have an actor selected in the **Viewport**
    and when you right-click in the **Graph Editor**, the event nodes and the function
    nodes you can see are usually correlated to the selected actor. They only display
    the functions and expressions that can applied directly to the actor. Otherwise,
    Blueprint offers quite a few nodes, but some of them cannot be used either directly
    or at all on the selected actor.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家拾取了立方体后，我们将现在将触发器的**碰撞响应**改为**重叠**。选择触发器，右键单击它，首先取消选中**上下文敏感**框，它位于菜单右上角。当你在**视口**中选择一个角色并在**图形编辑器**中右键单击时，你可以看到的事件节点和函数节点通常与所选角色相关。它们只显示可以直接应用于角色的函数和表达式。否则，蓝图提供了相当多的节点，但其中一些不能直接或根本不能用于所选角色。
- en: The node that we need here is one that can be applied to the trigger, but not
    directly. What we need is a **Set Collision Response to All Channels** node. This
    node can be used to change the collision response of actors during runtime. Right-click
    in the **Event Graph** and type in the name of the node and create it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的节点是一个可以应用于触发器的节点，但不是直接的。我们需要的是一个**设置所有通道的碰撞响应**节点。这个节点可以用于在运行时改变角色的碰撞响应。在**事件图**中右键单击，输入节点的名称并创建它。
- en: '![Key cube pickup and placement](img/image00341.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![关键立方体拾取和放置](img/image00341.jpeg)'
- en: 'Here, you can set a target actor whose **Collision Response** you wish to change.
    If you click on the dropdown menu, you will see three settings: **Ignore**, **Overlap**,
    and **Block**. If you recall, these were the three types of responses in the trigger''s
    **Collision** section. We had set it to **Ignore**, but we want to change it to
    **Overlap** once the player has picked up the key cube. So, select **Overlap**
    in the dropdown menu. Next, connect the **Then 1** pin to this node''s input.
    Finally, with the trigger selected in the **Viewport**, right-click in the **Graph
    Editor**, check the **Context Sensitive** box, and select **Create Reference**
    for <actor name>. Connect this to the **Target** inputof the **Set Collision Response
    to All Channels** node. When you do this, you will find that it does not directly
    connect to the **Target** input. Instead, a new node is created, which takes the
    trigger''s reference as its input and has **Collision Component** as its output.
    What this does is take the trigger box and convert it into something called a
    **Primitive Component Reference**. It is the only way you can connect it to this
    node.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以设置希望更改其**碰撞响应**的目标角色。如果单击下拉菜单，您将看到三种设置：**忽略**、**重叠**和**阻挡**。如果您回忆一下，这些是触发器**碰撞**部分中的三种响应类型。我们将其设置为**忽略**，但是我们希望在玩家拾起钥匙立方体后将其更改为**重叠**。因此，在下拉菜单中选择**重叠**。接下来，将**然后1**引脚连接到此节点的输入。最后，选择**视口**中的触发器，在**图形编辑器**中右键单击，勾选**上下文敏感**框，并为<actor
    name>选择**创建引用**。将其连接到**设置所有通道的碰撞响应**节点的**目标**输入。当您这样做时，您会发现它并不直接连接到**目标**输入。相反，会创建一个新节点，该节点以触发器的引用作为其输入，并将**碰撞组件**作为其输出。这样做的作用是将触发器框转换为称为**基本组件引用**的东西。这是您可以将其连接到此节点的唯一方法。
- en: '![Key cube pickup and placement](img/image00342.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![钥匙立方体拾取和放置](img/image00342.jpeg)'
- en: If we were to test the game now, we would find things working the way we want.
    We would not be able to place the key cube without first picking it up.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在测试游戏，我们会发现事情正在按照我们想要的方式运行。我们将无法在没有先拾起它的情况下放置钥匙立方体。
- en: We are almost done with our setup here. Remember we had placed a **PostProcessVolume**
    around out key cube, which would act as a visual indicator that the player has
    picked up the key cube? We need to script that in as well. We had initially set
    it to be disabled. We will enable it via **Blueprint**, and then destroy it after
    a very brief moment. First, add a new pin to the **Sequence** node. Next, with
    the **PostProcessVolume** selected, right-click in the **Graph Editor** and create
    a reference for it. Then, click on its output pin, drag it out, and release the
    left mouse button to open the menu. Here, you can type in **Set Enabled**, which
    would create a **Bool** node (Bool nodes are red in color). Once created, you
    will see a tick box, which says **Enabled**. Tick that box, and connect it to
    the **Then 2** output pin of the **Sequence** node.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里的设置几乎完成了。记得我们在钥匙立方体周围放置了一个**后期处理体**，它将作为玩家拾起钥匙立方体的视觉指示器？我们也需要对其进行脚本编写。我们最初将其设置为禁用状态。我们将通过**蓝图**启用它，然后在非常短的时间后销毁它。首先，向**序列**节点添加一个新的引脚。接下来，选择**后期处理体**，在**图形编辑器**中右键单击并为其创建一个引用。然后，单击其输出引脚，拖动它并释放左鼠标按钮以打开菜单。在这里，您可以输入**设置启用**，这将创建一个**布尔**节点（布尔节点为红色）。创建后，您将看到一个复选框，上面写着**启用**。选中该框，并将其连接到**序列**节点的**然后2**输出引脚。
- en: Next, we need to destroy the actor after a brief moment. For that, we will need
    to create a **Delay** node. A **Delay** node takes in an input and fires off a
    pulse after a certain time (which you can set). Right-click in the **Graph Editor**
    and type in **Delay** and create it. You can also find it under **Utilities**
    | **Flow Control** | **Delay**. You can see an option called **Duration** in the
    node. Here, you can set how long before you want the pulse to be fired. For now,
    leave it at the default value (which is `0.2` seconds), and connect it to the
    **Set Enabled** node. Finally, create a **Destroy Actor** node, connect it to
    the **Delay** node, and set the **PostProcessVolume** as its target. You can simply
    select the post process reference you had created for the **Set Enabled** node
    by clicking *Ctrl* + *C*, and then *Ctrl* + *V*) to create a copy and connect
    this duplicate to the **Target** inputof the **Destroy Actor** node.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在短暂的时间后销毁角色。为此，我们需要创建一个**延迟**节点。**延迟**节点接收输入，并在一定时间后触发脉冲（您可以设置）。在**图形编辑器**中右键单击，输入**延迟**并创建它。您还可以在**实用工具**
    | **流程控制** | **延迟**下找到它。节点中有一个名为**持续时间**的选项。在这里，您可以设置在触发脉冲之前要等待多长时间。现在，将其保留在默认值（即`0.2`秒），并将其连接到**设置启用**节点。最后，创建一个**销毁角色**节点，将其连接到**延迟**节点，并将**后期处理体**设置为其目标。您可以通过单击*Ctrl*
    + *C*选择**设置启用**节点的后期处理引用，然后*Ctrl* + *V*）创建一个副本并将此副本连接到**销毁角色**节点的**目标**输入。
- en: '![Key cube pickup and placement](img/image00343.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![钥匙立方体拾取和放置](img/image00343.jpeg)'
- en: 'And there you have it! We have a pickup and placement system for our key cube.
    We also have a visual indicator that we have picked up the cube (we will cover
    how to script the door opening and closing in the next chapter). Now, though this
    was a fairly simple and small setup, doing this for every key cube would be a
    tedious job. Imagine if your game had 10…20…50…100 rooms! You would have to script
    for each key cube in the game and waste loads of time. Thankfully, UE4 offers
    something to get around such a scenario: a **Blueprint** class.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们为我们的钥匙立方体设置了拾取和放置系统。我们还有一个视觉指示器，表明我们已经拾起了立方体（我们将在下一章中介绍如何编写门的开关）。尽管这是一个相当简单和小的设置，但为每个钥匙立方体都这样做将是一项繁琐的工作。想象一下，如果您的游戏有10…20…50…100个房间！您将不得不为游戏中的每个钥匙立方体编写脚本，并浪费大量时间。幸运的是，UE4提供了一些方法来解决这种情况：**蓝图**类。
- en: The Blueprint class
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝图类
- en: As already mentioned, scripting for each key cube would just be a tedious and
    time-consuming task. With a Blueprint class, you would need to do all the scripting
    and everything else only once. A Blueprint class is an entity that contains actors
    (static meshes, volumes, camera classes, trigger box, and so on) and functionalities
    scripted in it. Looking at our example once again of the lamp turning on/off,
    say you want to place 10 such lamps. With a Blueprint class, you would just have
    to create and script once, save it, and duplicate it. This is really an amazing
    feature offered by UE4.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为每个关键立方体编写脚本将是一项乏味且耗时的任务。使用蓝图类，您只需要进行一次所有脚本编写和其他操作。蓝图类是一个包含在其中进行脚本编写的演员（静态网格、体积、摄像机类、触发盒等）的实体。再次看看我们的例子，比如灯的开关，假设您想放置10盏这样的灯。使用蓝图类，您只需创建并编写一次，保存并复制。这真是UE4提供的一个令人惊叹的功能。
- en: Creating a Blueprint class
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建蓝图类
- en: To create a Blueprint class, click on the **Blueprints** button in the **Viewport**
    toolbar, and in the dropdown menu, select **New Empty Blueprint Class.** A window
    will then open, asking you to pick your parent class, indicating the kind of Blueprint
    class you wish to create.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建蓝图类，请单击**视口**工具栏中的**蓝图**按钮，在下拉菜单中选择**新建空蓝图类**。然后会打开一个窗口，询问您选择父类，指示您希望创建的蓝图类的类型。
- en: '![Creating a Blueprint class](img/image00344.jpeg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![创建蓝图类](img/image00344.jpeg)'
- en: 'At the top, you will see the most common classes. These are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，您将看到最常见的类。它们如下：
- en: '**Actor**: An **Actor**, as already discussed, is an object that can be placed
    in the world (static meshes, triggers, cameras, volumes, and so on, all count
    as actors)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员：如前所述，**演员**是可以放置在世界中的对象（静态网格、触发器、摄像机、体积等都算作演员）
- en: '**Pawn**: A **Pawn** is an actor that can be controlled by the player or the
    computer'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棋子：**棋子**是可以由玩家或计算机控制的演员
- en: '**Character**: This is similar to a **Pawn**, but has the ability to walk around'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角色**：这类似于**棋子**，但具有四处走动的能力'
- en: '**Player Controller**: This is responsible for giving the **Pawn** or **Character**
    inputs in the game, or controlling it'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**玩家控制器**：负责在游戏中为**棋子**或**角色**提供输入或控制'
- en: '**Game Mode**: This is responsible for all of the rules of gameplay'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏模式**：负责游戏规则的所有内容'
- en: '**Actor Component**: You can create a component using this and add it to any
    actor'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员组件：您可以使用这个创建一个组件并将其添加到任何演员
- en: '**Scene Component**: You can create components that you can attach to other
    scene components'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景组件：您可以创建可以附加到其他场景组件的组件
- en: Apart from these, there are other classes that you can choose from. To see them,
    click on **All Classes**, which will open a menu listing all the classes you can
    create a Blueprint with. For our key cube, we will need to create an **Actor Blueprint
    Class**. Select **Actor**, which will then open another window, asking you where
    you wish to save it and what to name it. Name it **Key_Cube**, and save it in
    the `Blueprint` folder. After you are satisfied, click on **OK** and the **Actor
    Blueprint Class** window will open.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有其他类可供选择。要查看它们，请单击**所有类**，这将打开一个菜单，列出您可以创建蓝图的所有类。对于我们的关键立方体，我们需要创建一个**演员蓝图类**。选择**演员**，然后会打开另一个窗口，询问您希望将其保存在何处以及如何命名。将其命名为**Key_Cube**，并将其保存在`蓝图`文件夹中。满意后，单击**确定**，**演员蓝图类**窗口将打开。
- en: '![Creating a Blueprint class](img/image00345.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![创建蓝图类](img/image00345.jpeg)'
- en: 'The Blueprint class user interface is similar to that of Level Blueprint, but
    with a few differences. It has some extra windows and panels, which have been
    described as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图类用户界面与关卡蓝图类似，但有一些区别。它有一些额外的窗口和面板，如下所述：
- en: '**Components panel**: The **Components panel** is where you can view, and add
    components to the Blueprint class. The default component in an empty Blueprint
    class is **DefaultSceneRoot**. It cannot be renamed, copied, or removed. However,
    as soon as you add a component, it will replace it. Similarly, if you were to
    delete all of the components, it will come back. To add a component, click on
    the **Add Component** button, which will open a menu, from where you can choose
    which component to add. Alternatively, you can drag an asset from the Content
    Browser and drop it in either the **Graph Editor** or the **Components panel**,
    and it will be added to the Blueprint class as a component. Components include
    actors such as static or skeletal meshes, light actors, camera, audio actors,
    trigger boxes, volumes, particle systems, to name a few. When you place a component,
    it can be seen in the **Graph Editor**, where you can set its properties, such
    as size, position, mobility, material (if it is a static mesh or a skeletal mesh),
    and so on, in the **Details** panel.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件面板**：**组件面板**是您可以查看并向蓝图类添加组件的地方。空蓝图类中的默认组件是**DefaultSceneRoot**。它无法重命名、复制或删除。但是，一旦您添加了组件，它就会被替换。同样，如果您删除了所有组件，它也会回来。要添加组件，请单击**添加组件**按钮，这将打开一个菜单，您可以从中选择要添加的组件。或者，您可以从内容浏览器中拖动资产并将其放入**图形编辑器**或**组件面板**中，它将作为组件添加到蓝图类中。组件包括静态或骨骼网格、光源演员、摄像机、音频演员、触发盒、体积、粒子系统等。当您放置一个组件时，它可以在**图形编辑器**中看到，您可以在**详细信息**面板中设置其属性，如大小、位置、移动性、材质（如果是静态网格或骨骼网格）等。'
- en: '**Graph Editor**: The **Graph Editor** is also slightly different from that
    of Level Blueprint, in that there are additional windows and editors in a Blueprint
    class. The first window is the **Viewport**, which is the same as that in the
    Editor. It is mainly used to place actors and set their positions, properties,
    and so on. Most of the tools you will find in the main **Viewport** (the editor''s
    **Viewport**) toolbar are present here as well.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形编辑器**：**图形编辑器**与关卡蓝图类似，但在蓝图类中有一些额外的窗口和编辑器。第一个窗口是**视口**，与编辑器中的相同。它主要用于放置演员并设置它们的位置、属性等。大多数工具您将在主**视口**（编辑器的**视口**）工具栏中找到，这里也都有。'
- en: '**Event Graph**: The next window is the **Event Graph** window, which is the
    same as a Level Blueprint window. Here, you can script the components that you
    added in the **Viewport** and their functionalities (for example, scripting the
    toggling of the lamp on/off when the player is in proximity and moves away respectively).
    Keep in mind that you can script the functionalities of the components only present
    within the Blueprint class. You cannot use it directly to script the functionalities
    of any actor that is not a component of the Class.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件图**：下一个窗口是**事件图**窗口，它与级别蓝图窗口相同。在这里，你可以编写在**视口**中添加的组件及其功能（例如，在玩家靠近时脚灯的开关/关闭）。请记住，你只能编写蓝图类中存在的组件的功能。你不能直接使用它来编写不是类组件的任何演员的功能。'
- en: '**Construction Script**: Lastly, there is the **Construction Script** window.
    This is also similar to the **Event Graph**, as in you can set up and connect
    nodes, just like in the **Event Graph**. The difference here is that these nodes
    are activated when you are constructing the Blueprint class. They do not work
    during runtime, since that is when the **Event Graph** scripts work. You can use
    the **Construction Script** to set properties, create and add your own property
    of any of the components you wish to alter during the construction, and so on.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建脚本**：最后，还有**构建脚本**窗口。这也类似于**事件图**，你可以设置和连接节点，就像在**事件图**中一样。不同之处在于这些节点在构建蓝图类时激活。它们在运行时不起作用，因为那时**事件图**脚本起作用。你可以使用**构建脚本**来设置属性，创建和添加你希望在构建过程中改变的任何组件的属性，等等。'
- en: Let's begin creating the Blueprint class for our key cubes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为关键立方体创建蓝图类。
- en: Viewport
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视口
- en: 'The first thing we need are the components. We require three components: a
    cube, a trigger box, and a **PostProcessVolume**. In the **Viewport**, click on
    the **Add Components** button, and under **Rendering**, select **Static Mesh**.
    It will add a **Static Mesh** component to the class. You now need to specify
    which **Static Mesh** you want to add to the class. With the **Static Mesh** actor
    selected in the **Components panel**, in the actor''s **Details** panel, under
    the **Static Mesh** section, click on the **None** button and select **TemplateCube_Rounded**.
    As soon as you set the mesh, it will appear in the **Viewport**. With the cube
    selected, decrease its scale (located in the **Details** panel) from `1` to `0.2`
    along all three axes.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的第一件事是组件。我们需要三个组件：一个立方体，一个触发盒，和一个**后期处理体积**。在**视口**中，点击**添加组件**按钮，在**渲染**下选择**静态网格**。它会向类中添加一个**静态网格**组件。现在你需要指定要添加到类中的**静态网格**。选择**组件面板**中选中的**静态网格**演员，在演员的**详细信息**面板中，在**静态网格**部分，点击**无**按钮，选择**TemplateCube_Rounded**。一旦设置了网格，它将出现在**视口**中。选择立方体，将其比例（位于**详细信息**面板中）从`1`减少到`0.2`沿着所有三个轴。
- en: The next thing we need is a trigger box. Click on the **Add Component** button
    and select **Box Collision** in the **Collision** section. Once added, increase
    its scale from `1` to `9` along all three axes, and place it in such a way that
    its bottom is in line with the bottom of the cube.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的下一件事是一个触发盒。点击**添加组件**按钮，在**碰撞**部分选择**盒碰撞**。添加后，将其比例从`1`增加到`9`沿着所有三个轴，并将其放置在这样的方式，使其底部与立方体的底部齐平。
- en: '![Viewport](img/image00346.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![视口](img/image00346.jpeg)'
- en: The Construction Script
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建脚本
- en: You could set its material in the **Details** panel itself by clicking on the
    **Override Materials** button in the **Rendering** section, and selecting the
    key cube material. However, we are going to assign its material using **Construction
    Script**. Switch to the **Construction Script** tab. You will see a node called
    **Construction Script**, which is present by default. You cannot delete this node;
    this is where the script starts. However, before we can script it in, we will
    need to create a variable of the type `Material`. In the **My Blueprint** section,
    click on **Add New** and select **Variable** in the dropdown menu. Name this variable
    `Key Cube Material`, and change its type from **Bool** (which is the default variable
    type) to **Material** in the **Details** panel. Also, be sure to check the **Editable**
    box so that we can edit it from outside the Blueprint class.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在**详细信息**面板中点击**覆盖材质**按钮，并选择关键立方体材质来设置其材质。然而，我们将使用**构建脚本**来分配其材质。切换到**构建脚本**选项卡。你会看到一个名为**构建脚本**的节点，默认情况下存在。你无法删除此节点；这是脚本开始的地方。然而，在我们可以编写它之前，我们需要创建一个类型为`材质`的变量。在**我的蓝图**部分，点击**添加新**，在下拉菜单中选择**变量**。将此变量命名为`关键立方体材质`，并在**详细信息**面板中将其类型从**布尔**（默认变量类型）更改为**材质**。还要确保勾选**可编辑**框，以便我们可以从蓝图类外部进行编辑。
- en: '![The Construction Script](img/image00347.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![构建脚本](img/image00347.jpeg)'
- en: Next, drag the **Key** **Cube Material** variable from the **My Blueprint**
    panel, drop it in the **Graph Editor**, and select **Set** when the window opens
    up. Connect this to the output pin of the **Construction Script** node. Repeat
    this process, only this time, select **Get** and connect it to the input pin of
    **Key Cube Material**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从**我的蓝图**面板中拖动**关键立方体材质**变量，放入**图形编辑器**中，并在窗口打开时选择**设置**。将其连接到**构建脚本**节点的输出引脚。重复此过程，只是这次选择**获取**并将其连接到**关键立方体材质**的输入引脚。
- en: Right-click in the **Graph Editor** window and type in **Set Material** in the
    search bar. You should see **Set Material (Static Mesh)**. Click on it and add
    it to the scene. This node already has a reference of the Static Mesh actor (**TemplateCube_Rounded**),
    so we will not have to create a reference node. Connect this to the **Set** node.
    Finally, drag **Key Cube Material** from **My Blueprint**, drop it in the **Graph
    Editor**, select **Get**, and connect it to the **Material** input pin. After
    you are done, hit **Compile**. We will now be able to set the cube's material
    outside of the Blueprint class.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图形编辑器**窗口中右键单击，然后在搜索栏中键入**设置材料**。您应该看到**设置材料（静态网格）**。单击它并将其添加到场景中。此节点已经引用了静态网格角色（**TemplateCube_Rounded**），因此我们不必创建引用节点。将其连接到**设置**节点。最后，从**我的蓝图**中拖动**关键立方体材料**，将其放入**图形编辑器**中，选择**获取**，并将其连接到**材料**输入引脚。完成后，点击**编译**。现在我们将能够在蓝图类之外设置立方体的材料。
- en: '![The Construction Script](img/image00348.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![构造脚本](img/image00348.jpeg)'
- en: Let's test it out. Add the Blueprint class to the level. You will see a **TemplateCube_Rounded**
    actor added to the scene. In its **Details** panel, you will see a **Key Cube
    Material** option under the **Default** section. This is the variable we created
    inside our **Construction Script**. Any material we add here will be added to
    the cube. So, click on **None** and select **KeyCube_Material**. As soon as you
    select it, you will see the material on the cube. This is one of the many things
    you can do using **Construction Script**. For now, only this will do.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下。将蓝图类添加到关卡中。您将看到一个**TemplateCube_Rounded**角色添加到场景中。在其**详细信息**面板中，您将在**默认**部分下看到一个**关键立方体材料**选项。这是我们在**构造脚本**中创建的变量。我们在这里添加的任何材料都将添加到立方体上。因此，点击**无**，然后选择**KeyCube_Material**。一旦您选择它，您将看到立方体上的材料。这是使用**构造脚本**可以做的许多事情之一。目前，只有这样做。
- en: The Event Graph
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件图
- en: We now need to script the key cube's functionalities. This is more or less the
    same as what we did in the Level Blueprint with our first key cube, with some
    small differences. In the **Event Graph** panel, the first thing we are going
    to script is enabling and disabling input when the player overlaps and stops overlapping
    the trigger box respectively. In the **Components** section, right-click on **Box**.
    This will open a menu. Mouse over **Add Event** and select **Add OnComponentBeginOverlap**.
    This will add a **Begin Overlap** node to the **Graph Editor**. Next, we are going
    to need a **Cast** node. A **Cast** node is used to specify which actor you want
    to use. Right-click in the **Graph Editor** and add a **Cast to Character** node.
    Connect this to the **OnComponentBeginOverlap** node and connect the other actor
    pin to the **Object** pin of the **Cast to Character** node. Finally, add an **Enable
    Input** node and a **Get Player Controller** node and connect them as we did in
    the Level Blueprint.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要脚本化关键立方体的功能。这与我们在级别蓝图中使用第一个关键立方体所做的基本相同，只是有一些小的不同。在**事件图**面板中，我们要脚本化的第一件事是当玩家重叠和停止重叠触发框时启用和禁用输入。在**组件**部分，右键单击**框**。这将打开一个菜单。将鼠标悬停在**添加事件**上，然后选择**添加OnComponentBeginOverlap**。这将在**图形编辑器**中添加一个**开始重叠**节点。接下来，我们需要一个**投射**节点。**投射**节点用于指定要使用的角色。在**图形编辑器**中右键单击，添加一个**投射到角色**节点。将其连接到**OnComponentBeginOverlap**节点，并将另一个角色引脚连接到**投射到角色**节点的**对象**引脚。最后，添加一个**启用输入**节点和一个**获取玩家控制器**节点，并像在级别蓝图中一样连接它们。
- en: 'Next, we are going to add an event for when the player stops overlapping the
    box. Again, right-click on **Box** and add an **OnComponentEndOverlap** node.
    Do the exact same thing you did with the **OnComponentBeginOverlap** node; only
    here, instead of adding an **Enable Input** node, add a **Disable Input** node.
    The setup should look something like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为玩家停止重叠框时添加一个事件。同样，在**框**上右键单击，然后添加一个**OnComponentEndOverlap**节点。与**OnComponentBeginOverlap**节点做完全相同的事情；只是在这里，不是添加**启用输入**节点，而是添加一个**禁用输入**节点。设置应该看起来像这样：
- en: '![The Event Graph](img/image00349.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![事件图](img/image00349.jpeg)'
- en: You can move the key cube we had placed earlier on top of the pedestal, set
    it to hidden, and put the key cube Blueprint class in its place. Also, make sure
    that you set the collision response of the trigger actor to **Ignore**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以移动我们之前放置在基座上的关键立方体，将其设置为隐藏，并将关键立方体蓝图类放在其位置。还要确保将触发器角色的碰撞响应设置为**忽略**。
- en: '![The Event Graph](img/image00350.jpeg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![事件图](img/image00350.jpeg)'
- en: The next step is scripting the destruction of the key cube when the player touches
    the screen. This, too, is similar to what we had done in Level Blueprint, with
    a few differences. Firstly, add a **Touch** node and a **Sequence** node, and
    connect them to each other. Next, we need a **Destroy Component** node, which
    you can find under **Components** | **Destroy Component** (Static Mesh). This
    node already has a reference to the key cube (Static Mesh) inside it, so you do
    not have to create an external reference and connect it to the node. Connect this
    to the **Then 0** node.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是脚本化当玩家触摸屏幕时销毁关键立方体。这也与我们在级别蓝图中所做的类似，有一些不同之处。首先，添加一个**触摸**节点和一个**序列**节点，并将它们连接在一起。接下来，我们需要一个**销毁组件**节点，您可以在**组件**
    | **销毁组件**（静态网格）下找到它。此节点已经在其中引用了关键立方体（静态网格），因此您不必创建外部引用并将其连接到节点。将其连接到**然后0**节点。
- en: We also need to activate the trigger after the player has picked up the key
    cube. Now, since we cannot call functions on actors outside the Blueprint class
    directly (like we could in Level Blueprint), we need to create a variable. This
    variable will be of the type Trigger Box. The way this works is, when you have
    created a **Trigger Box** variable, you can assign it to any trigger in the level,
    and it will call that function to that particular trigger. With that in mind,
    in the **My Blueprint** panel, click on **Add New** and create a variable. Name
    this variable **Activated Trigger Box**, and set its type to **Trigger Box**.
    Finally, make sure you tick on the **Editable** box; otherwise, you will not be
    able to assign any trigger to it. After doing that, create a **Set Collision Response
    to All Channels** node (uncheck the Context Sensitive box), and set the **New
    Response** option to **Overlap**. For the target, drag the **Activated Trigger
    Box** variable, drop it in the **Graph Editor**, select **Get**, and connect it
    to the **Target** input.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩家拾取关键立方体后，我们还需要激活触发器。现在，由于我们无法直接在蓝图类外部的演员上调用函数（就像我们在关卡蓝图中可以），我们需要创建一个变量。这个变量将是**Trigger
    Box**类型。它的工作方式是，当您创建了一个**Trigger Box**变量后，您可以将其分配给关卡中的任何触发器，并且它将调用该特定触发器的函数。考虑到这一点，在**我的蓝图**面板中，单击**添加新内容**并创建一个变量。将此变量命名为**Activated
    Trigger Box**，并将其类型设置为**Trigger Box**。最后，确保您选中了**可编辑**框；否则，您将无法将任何触发器分配给它。在这样做之后，创建一个**设置所有通道的碰撞响应**节点（取消选中上下文敏感框），并将**新响应**选项设置为**重叠**。对于目标，拖动**Activated
    Trigger Box**变量，将其放入**图形编辑器**中，选择**获取**，并将其连接到**目标**输入。
- en: 'Finally, for the Post Process Volume, we will need to create another variable
    of the type **PostProcessVolume**. You can name this variable **Visual Indicator**,
    again, while ensuring that the **Editable** box is checked. Add this variable
    to the **Graph Editor** as well. Next, click on its pin, drag it out, and release
    it, which will open the actions menu. Here, type in **Enabled**, select **Set
    Enabled**, and check **Enabled**. Finally, add a **Delay** node and a **Destroy
    Actor** and connect them to the **Set Enabled** node, in that order. Your setup
    should look something like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于后期处理体积，我们需要创建另一个类型为**PostProcessVolume**的变量。您可以将此变量命名为**Visual Indicator**，同时确保**可编辑**框已被选中。将此变量添加到**图形编辑器**中。接下来，单击它的引脚，将其拖出并释放，这将打开操作菜单。在这里，键入**Enabled**，选择**Set
    Enabled**，并选中**Enabled**。最后，添加一个**延迟**节点和一个**销毁演员**，并按顺序将它们连接到**Set Enabled**节点。您的设置应该看起来像这样：
- en: '![The Event Graph](img/image00351.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![事件图](img/image00351.jpeg)'
- en: 'Back in the **Viewport**, you will find that under the **Default** section
    of the Blueprint class actor, two more options have appeared: **Activated Trigger
    Box** and **Visual Indicator** (the variables we had created). Using this, you
    can assign which particular trigger box''s collision response you want to change,
    and which exact post process volume you want to activate and destroy. In front
    of both variables, you will see a small icon in the shape of an eye dropper. You
    can use this to choose which external actor you wish to assign the corresponding
    variable. Anything you scripted using those variables will take effect on the
    actor you assigned in the scene. This is one of the many amazing features offered
    by the Blueprint class. All we need to do now for the remaining key cubes is:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在**视口**中，您会发现在蓝图类演员的**默认**部分下，出现了两个新选项：**激活触发框**和**视觉指示器**（我们创建的变量）。使用这个，您可以指定要更改哪个特定触发框的碰撞响应，以及要激活和销毁哪个后期处理体积。在这两个变量的前面，您会看到一个眼睛滴管形状的小图标。您可以使用这个来选择您希望分配相应变量的外部演员。使用这些变量编写的任何内容都将对您在场景中分配的演员产生影响。这是蓝图类提供的众多令人惊叹的功能之一。现在我们只需要为剩下的关键立方体做以下几件事：
- en: Place them in the level
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们放置在关卡中
- en: Using the eye dropper icon that is located next to the name of the variables,
    pick the trigger to activate once the player has picked up the key cube, and which
    post process volume to activate and destroy.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位于变量名称旁边的眼滴图标，选择在玩家拾取关键立方体后要激活的触发器，以及要激活和销毁的后期处理体积。
- en: 'In the second room, we have two key cubes: one to activate the large door and
    the other to activate the door leading to the third room. The first key cube will
    be placed on the pedestal near the big door. So, with the first key cube selected,
    using the eye dropper, select the trigger box on the pedestal near the big door
    for the **Activated Trigger Box** variable. Then, pick the post process volume
    inside which the key cube is placed for the **Visual Indicator** variable.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个房间中，我们有两个关键立方体：一个用于激活大门，另一个用于激活通往第三个房间的门。第一个关键立方体将放置在靠近大门的基座上。因此，选择第一个关键立方体，使用眼滴图标，为**Activated
    Trigger Box**变量选择靠近大门基座上的触发框。然后，为**Visual Indicator**变量选择放置关键立方体的后期处理体积。
- en: The next thing we need to do is to open **Level Blueprint** and script in what
    happens when the player places the key cube on the pedestal near the big door.
    Doing what we did in the previous room, we set up nodes that will unhide the hidden
    key cube on the pedestal, and change the collision response of the trigger box
    around the big door to **Overlap**, ensuring that it was set to **Ignore** initially.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的下一件事是打开**关卡蓝图**，并编写当玩家将关键立方体放置在靠近大门的基座上时发生的事情。与前一个房间所做的一样，我们设置节点，将隐藏的基座上的关键立方体显示出来，并将大门周围的触发框的碰撞响应更改为**重叠**，确保最初设置为**忽略**。
- en: '![The Event Graph](img/image00352.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![事件图](img/image00352.jpeg)'
- en: Test it out! You will find that everything is working as expected. Now, do the
    same with the remaining key cubes. Pick which trigger box and which post process
    volume to activate when you touch on the screen. Then, in the Level Blueprint,
    script in which key cube to unhide, and so on (place the key cubes we had placed
    earlier on the pedestals and set it to **Hidden**), and place the Blueprint class
    key cube in its place.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一下！你会发现一切都按预期工作。现在，对剩下的关键立方体做同样的操作。选择触发盒和后期处理体积在触摸屏幕时激活。然后，在关卡蓝图中，编写哪个关键立方体要显示，等等（将之前放置在基座上的关键立方体设置为**隐藏**），并将蓝图类关键立方体放在其位置上。
- en: This is one of the many ways you can use Blueprint class. You can see it takes
    a lot of work and hassle. Let us now move on to Artificial intelligence.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用蓝图类的众多方法之一。你可以看到这需要很多工作和麻烦。现在让我们继续进行人工智能的工作。
- en: Scripting basic AI
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本化基本AI
- en: Coming back to the third room, we are now going to implement AI in our game.
    We have an AI character in the third room which, when activated, moves. The main
    objective is to make a path for it with the help of switches and prevent it from
    falling. When the AI character reaches its destination, it will unlock the key
    cube, which the player can then pick up and place on the pedestal. We first need
    to create another Blueprint class of the type **Character**, and name it `AI_Character`.
    When created, double-click on it to open it. You will see a few components already
    set up in the **Viewport**. These are the **CapsuleComponent** (which is mainly
    used for collision), **ArrowComponent** (to specify which side is the front of
    the character, and which side is the back), **Mesh** (used for character animation),
    and **CharacterMovement**. All four are there by default, and cannot be removed.
    The only thing we need to do here is add a **StaticMesh** for our character, which
    will be **TemplateCube_Rounded**.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第三个房间，我们现在要在游戏中实现AI。我们在第三个房间中有一个AI角色，当激活时会移动。主要目标是通过开关为其制作一条路径，并防止其掉落。当AI角色到达目的地时，它将解锁关键立方体，玩家随后可以拾取并放置在基座上。我们首先需要创建另一个**Character**类型的蓝图类，并命名为`AI_Character`。创建后，双击打开它。你会看到**视口**中已经设置了一些组件。这些是**CapsuleComponent**（主要用于碰撞），**ArrowComponent**（用于指定角色的前面和后面），**Mesh**（用于角色动画）和**CharacterMovement**。所有这四个都是默认设置的，不能被移除。我们唯一需要做的是为我们的角色添加一个**静态网格**，它将是**TemplateCube_Rounded**。
- en: Click on **Add Components**, add a **StaticMesh**, and assign it **TemplateCube_Rounded**
    (in its **Details** panel). Next, scale this cube to `0.2` along all three axes
    and move it towards the bottom of the **CapsuleComponent**, so that it does not
    float in midair.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“添加组件”，添加一个“静态网格”，并在其“详细信息”面板中分配“TemplateCube_Rounded”。接下来，将这个立方体沿着三个轴缩放为`0.2`，并将其移动到**CapsuleComponent**的底部，这样它就不会漂浮在空中了。
- en: '![Scripting basic AI](img/image00353.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![脚本化基本AI](img/image00353.jpeg)'
- en: This is all we require for our AI character. The rest we will handle in Level
    Blueprints. Next, place **AI_Character** into the scene on the Player side of
    the pit, with all of the switches. Place it directly over the Target Point actor.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对AI角色的要求。其余的工作我们将在关卡蓝图中处理。接下来，将**AI_Character**放置在坑洞的玩家一侧，并放置所有开关。直接将其放置在目标点演员的正上方。
- en: '![Scripting basic AI](img/image00354.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![脚本化基本AI](img/image00354.jpeg)'
- en: Next, open up Level Blueprint, and let's begin scripting it. The left-most switch
    will be used to activate the AI character, and the remaining three will be used
    to draw the parts of a path on which it will walk to reach the other side.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开关卡蓝图，让我们开始编写脚本。最左边的开关将用于激活AI角色，其余三个将用于绘制路径的部分，以便它可以走到另一侧。
- en: To move the AI character, we will need an **AI Move To** node. The first thing
    we need is an overlapping event for the trigger over the first switch, which will
    enable the input, otherwise the AI character will start moving whenever the player
    touches the screen, which we do not want. Set up an **Overlap** event, an **Enable
    Input** node, and a **Gate** event. Connect the **Overlap** event to the **Enable
    Input** event, and then to the **Gate** node's **Open** input.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了移动AI角色，我们将需要一个**AI Move To**节点。我们首先需要一个触发第一个开关的重叠事件，这将启用输入，否则AI角色将在玩家触摸屏幕时开始移动，这是我们不想要的。设置一个**重叠**事件，一个**启用输入**节点和一个**门**事件。将**重叠**事件连接到**启用输入**事件，然后连接到**门**节点的**打开**输入。
- en: The next thing is to create a **Touch** node. To this, we will attach an **AI
    Move To** node. You can either type it in or find it under the AI section. Once
    created, attach it to the **Gate** node's **Exit** pin.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是创建一个**触摸**节点。我们将附加一个**AI Move To**节点。你可以输入它，也可以在AI部分下找到它。创建后，将其连接到**门**节点的**退出**引脚。
- en: '![Scripting basic AI](img/image00355.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![脚本化基本AI](img/image00355.jpeg)'
- en: We now need to specify to the node which character we want to move, and where
    it should move to. To specify which character we want to move, select the AI character
    in the **Viewport**, and in the Level Blueprint's **Graph Editor**, right-click
    and create a reference for it. Connect it to the **Pawn** input pin. Next, for
    the location, we want the AI character to move towards the second **Target Point**
    actor, located on the other side of the pit. But first, we need to get its location
    in the world. With it selected, right-click in the **Graph Editor**, and type
    in `Get Actor Location`. This node returns an actor's location (coordinates) in
    the world (the one connected to it). This will create a **Get Actor Location**,
    with the **Target Point** actor connect to its input pin.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要告诉节点我们要移动哪个角色，以及它应该移动到哪里。要指定我们要移动哪个角色，选择**视口**中的AI角色，在关卡蓝图的**图形编辑器**中，右键单击并为其创建一个引用。将其连接到**Pawn**输入引脚。接下来，对于位置，我们希望AI角色朝着坑洞另一侧的第二个**目标点**演员移动。但首先，我们需要获取它在世界中的位置。选择它，右键单击**图形编辑器**，输入`获取演员位置`。这个节点返回世界中一个演员的位置（坐标）（连接到它的那个）。这将创建一个**获取演员位置**，将**目标点**演员连接到其输入引脚。
- en: Finally, connect its **Return Value** to the **Destination** input of the **AI
    Move To** node.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将其**返回值**连接到**AI移动到**节点的**目的地**输入。
- en: '![Scripting basic AI](img/image00356.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![脚本基本人工智能](img/image00356.jpeg)'
- en: 'If you were to test it out, you would find that it works fine, except for one
    thing: the AI character stops when it reaches the edge of the pit. We want it
    to fall off the pit if there is no path. For that, we will need a **Nav Proxy
    Link** actor. As discussed in the previous chapter, a **Nav Proxy Link** actor
    is used when an AI character has to step outside the Nav Mesh temporarily (for
    example, jump between ledges). We will need this if we want our AI character to
    fall off the ledge. You can find it in the **All Classes** section in the **Modes**
    panel. Place it in the level.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进行测试，你会发现它运行良好，除了一件事：当AI角色到达坑的边缘时会停止。我们希望它在没有路径时掉入坑。为此，我们需要一个**Nav代理链接**角色。如前一章所述，当AI角色需要暂时离开Nav
    Mesh（例如，在台阶之间跳跃）时，会使用**Nav代理链接**角色。如果我们希望AI角色从悬崖上掉下来，我们将需要它。您可以在**模式**面板的**所有类**部分中找到它。将其放置在关卡中。
- en: '![Scripting basic AI](img/image00357.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![脚本基本人工智能](img/image00357.jpeg)'
- en: The actor is depicted by two cylinders with a curved arrow connecting them.
    We want the first cylinder to be on one side of the pit and the other cylinder
    on the other side. Using the **Scale** tool, increase the size of the **Nav Proxy
    Link** actor.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该角色由两个带有弯曲箭头连接的圆柱表示。我们希望第一个圆柱位于坑的一侧，另一个圆柱位于另一侧。使用**缩放**工具，增加**Nav代理链接**角色的大小。
- en: '![Scripting basic AI](img/image00358.jpeg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![脚本基本人工智能](img/image00358.jpeg)'
- en: 'When placing the **Nav Proxy Link** actor, keep two things in mind:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 放置**Nav代理链接**角色时，请记住两件事：
- en: Make sure that both cylinders intersect in the green area; otherwise, the actor
    will not work
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保两个圆柱相交在绿色区域；否则，该角色将无法工作
- en: Ensure that both cylinders are in line with the AI character; otherwise, it
    will not move in a straight line but instead to where the cylinder is located
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保两个圆柱与AI角色对齐；否则，它将不会沿直线移动，而是移动到圆柱所在的位置
- en: 'Once placed, you will see that the AI character falls off when it reaches the
    edge of the pit. We are not done yet. We need to bring the AI character back to
    its starting position so that the player can start over (or else the player will
    not be able to progress). For that, we need to first place a trigger at the bottom
    of the pit, making sure that if the AI character does fall into it, it overlaps
    the trigger. This trigger will perform two actions: first, it will teleport the
    AI character to its initial location (with the help of the first Target Point);
    second, it will stop the **AI Move To** node, or it will keep moving even after
    it has been teleported.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 放置后，您会发现当AI角色到达坑的边缘时会掉下来。我们还没有完成。我们需要将AI角色带回其起始位置，以便玩家可以重新开始（否则玩家将无法继续）。为此，我们首先需要在坑底放置一个触发器，确保如果AI角色掉入其中，它会重叠触发器。此触发器将执行两个操作：首先，它将将AI角色传送到其初始位置（借助第一个目标点）；其次，它将停止**AI移动到**节点，否则即使已被传送，它也会继续移动。
- en: '![Scripting basic AI](img/image00359.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![脚本基本人工智能](img/image00359.jpeg)'
- en: After placing the trigger, open Level Blueprint and create an Overlap event
    for the trigger box. To this, we will add a **Sequence** node, since we are calling
    two separate functions for when the player overlaps the trigger. The first node
    we are going to create is a **Teleport** node. Here, we can specify which actor
    to teleport, and where. The actor we want to teleport is the AI character, so
    create a reference for it and connect it to the **Target** input pin. As for the
    destination, first use the **Get Actor Location** function to get the location
    of the first Target Point actor (upon which the AI character is initially placed),
    and connect it to the **Dest Location** input.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 放置触发器后，打开关卡蓝图并为触发框创建一个重叠事件。为此，我们将添加一个**Sequence**节点，因为当玩家重叠触发器时，我们要调用两个单独的函数。我们要创建的第一个节点是**Teleport**节点。在这里，我们可以指定要传送的角色和位置。我们要传送的角色是AI角色，所以为其创建一个引用并将其连接到**目标**输入引脚。至于目的地，首先使用**获取角色位置**函数获取第一个目标点角色的位置（AI角色最初放置在其上），并将其连接到**目标位置**输入。
- en: '![Scripting basic AI](img/image00360.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![脚本基本人工智能](img/image00360.jpeg)'
- en: To stop the AI character's movement, right-click anywhere in the **Graph Editor**,
    and first uncheck the **Context Sensitive** box, since we cannot use this function
    directly on our AI character. What we need is a **Stop Active Movement** node.
    Type it into the search bar and create it. Connect this to the **Then 1** output
    node, and attach a reference of the AI character to it. It will automatically
    convert from a **Character Reference** into **Character Movement** component reference.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止AI角色的移动，在**图形编辑器**中右键单击任意位置，首先取消选中**上下文敏感**框，因为我们不能直接在AI角色上使用此功能。我们需要的是**停止活动移动**节点。在搜索栏中键入它并创建它。将其连接到**然后1**输出节点，并将AI角色的引用连接到它。它将自动从**角色引用**转换为**角色移动**组件引用。
- en: '![Scripting basic AI](img/image00361.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![脚本基本人工智能](img/image00361.jpeg)'
- en: 'This is all that we need to script for our AI in the third room. There is one
    more thing left: how to unlock the key cube. But we will cover this in the next
    chapter since it involves Matinee.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要为第三个房间的AI编写的所有内容。还有一件事：如何解锁关键立方体。但我们将在下一章中介绍这一点，因为它涉及Matinee。
- en: In the fourth room, we are going to use the same principle. Here, we are going
    to make a chain of **AI Move To** nodes, each connected to the previous one's
    **On Success** output pin. This means that when the AI character has successfully
    reached the destination (Target Point actor), it should move to the next, and
    so on. Using this, and what we have just discussed about AI, script the path that
    the AI will follow (recall the previous chapter, where we lined out the path the
    AI character would take in the fourth room).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个房间，我们将使用相同的原理。在这里，我们将制作一系列**AI移动到**节点，每个节点都连接到前一个节点的**成功时**输出引脚。这意味着当AI角色成功到达目的地（目标点演员）时，它应该移动到下一个目标，依此类推。利用这一点，以及我们刚刚讨论的关于AI的内容，编写AI将遵循的路径（回想一下上一章，在那里我们勾画了AI角色在第四个房间中将走的路径）。
- en: '![Scripting basic AI](img/image00362.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![编写基本AI脚本](img/image00362.jpeg)'
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered with Blueprints and discussed how they work. We
    also discussed Level Blueprints and the Blueprint class, and covered how to script
    AI. We still have a few more things to script, but first we will have to cover
    the topic of Unreal Matinee. In the next chapter, we will be doing just that.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了蓝图并讨论了它们的工作原理。我们还讨论了关卡蓝图和蓝图类，并介绍了如何编写AI脚本。我们还有一些脚本要做，但首先我们需要讨论虚幻Matinee的主题。在下一章中，我们将做到这一点。
