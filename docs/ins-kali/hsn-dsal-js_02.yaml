- en: Creating Queues for In-Order Executions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为顺序执行创建队列
- en: A queue is a programming construct that bears a heavy resemblance to real-world
    queues, for example, a queue at the movie theater, ATMs, or the bank. Queues,
    as opposed to stacks, are **first-in first-out **(**FIFO**), so whatever goes
    in first comes out first as well. This is especially helpful when you would like
    to maintain data in the same sequence in which it flows in.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是一个编程构造，与现实世界的队列（例如电影院、ATM或银行的队列）有很大的相似之处。与堆栈相反，队列是**先进先出**（**FIFO**），因此无论什么先进去，也会先出来。当您希望保持数据以流入的相同顺序时，这是特别有帮助的。
- en: 'A more computer/scientific definition of a queue would be as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 队列的更多计算机/科学定义如下：
- en: <q>An abstract data collection in which the elements can be added to the back
    called enqueue and removed from the front called dequeue which makes it a FIFO
    data structure.</q>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <q>一个抽象数据集合，其中元素可以被添加到后端称为enqueue，并从前端称为dequeue中移除，这使其成为FIFO数据结构。</q>
- en: Of course, having only *enqueue* and *dequeue* operations may be enough for
    the majority of cases to cover a wider spectrum of issues that we may encounter;
    however, we can expand the API and make our queue future-proof.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，只有*enqueue*和*dequeue*操作可能足够覆盖大多数情况，以涵盖我们可能遇到的更广泛的问题；然而，我们可以扩展API并使我们的队列具有未来的可扩展性。
- en: 'In this chapter, we will discuss the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Types of queue
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列的类型
- en: Implementation of different types of queue
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的队列实现
- en: Use cases showing the usefulness of queues
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示队列的有用性的用例
- en: Performance of queues as compared to other native data structures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他本地数据结构相比的队列性能
- en: Types of queue
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列的类型
- en: 'Before we begin understanding queues, let''s quickly take a look at the types
    of queues that we may want to use in our applications:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始理解队列之前，让我们快速看一下我们可能想在应用程序中使用的队列类型：
- en: '**Simple queue**: In a simple FIFO queue, the order is retained and data leaves
    in the same order in which it comes in'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单队列**：在简单的FIFO队列中，顺序被保留，数据以进入的顺序离开'
- en: '**Priority queue**: A queue in which the elements are given a predefined priority'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先队列**：队列中的元素被赋予预定义的优先级'
- en: '**Circular queue**: Similar to a simple queue, except that the back of the
    queue is followed by the front of the queue'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**循环队列**：类似于简单队列，只是队列的后端跟随队列的前端'
- en: '**Double ended queue** (**Dequeue**): Similar to the simple queue but can add
    or remove elements from either the front or the back of the queue'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双端队列**（**Dequeue**）：类似于简单队列，但可以从队列的前端或后端添加或移除元素'
- en: Implementing APIs
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现API
- en: 'Implementing an API is never as easy as it seems, as discussed earlier. When
    making generic classes, we can never predict what kinds of a situation our queue
    is going to be used in. With that in mind, let''s create a very generic API for
    our queue and expand it in future as we see fit. Some of the most common operations
    that we can add to the queue are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实现API从来不像看起来那么容易，正如之前讨论的那样。在创建通用类时，我们无法预测我们的队列将在何种情况下使用。考虑到这一点，让我们为我们的队列创建一个非常通用的API，并根据需要在将来扩展它。我们可以添加到队列的一些最常见的操作如下：
- en: '`add()`: Pushes an item to the back of the queue'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add()`: 将项目推送到队列的后端'
- en: '`remove()`: Removes an item from the start of the queue'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`: 从队列的开头移除一个项目'
- en: '`peek()`: Shows the last item added to the queue'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`: 显示添加到队列的最后一个项目'
- en: '`front()`: Returns the item at the front of the queue'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`front()`: 返回队列前端的项目'
- en: '`clear()`: Empties the queue'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()`: 清空队列'
- en: '`size()`: Gets the current size of the queue'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size()`: 获取队列的当前大小'
- en: Creating a queue
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建队列
- en: Of the four types of the queue that we have discussed earlier, first, we will
    implement a simple queueand then move on to modify it for each type of the subsequent
    queue*.*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前讨论过的四种类型的队列中，首先，我们将实现一个简单的队列，然后继续修改每种类型的后续队列。
- en: A simple queue
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的队列
- en: 'Similar to a stack, we will create a queue using the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与堆栈类似，我们将使用以下步骤创建一个队列：
- en: 'Define a `constructor()`:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`constructor()`：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will be using `WeakMap()` for in-memory data storage just like we did for
    stacks:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`WeakMap()`来进行内存数据存储，就像我们为堆栈所做的那样：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement the methods described previously in the API:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现先前在API中描述的方法：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have again wrapped the entire class inside an IIFE because we don''t want
    to make ;`Queue` items accessible from the outside:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次将整个类包装在IIFE中，因为我们不希望从外部访问`Queue`项：
- en: '![](assets/602f7738-6cd0-40f4-8fe3-b9ba8a960396.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/602f7738-6cd0-40f4-8fe3-b9ba8a960396.png)'
- en: Testing the queue
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试队列
- en: 'To test this queue, you can simply instantiate it and add/remove some items
    to/from the queue:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个队列，您可以简单地实例化它并向队列中添加/移除一些项目：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can note from the preceding code, all elements are treated the same.
    Irrespective of the data that they contain, elements are always treated in a FIFO
    fashion. Although that is a good approach, sometimes we may need something more:
    the ability to prioritize elements that are coming in and leaving the queue*,*
    as we can note in the next section.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以从前面的代码中注意到的那样，所有元素都被同等对待。无论它们包含的数据是什么，元素始终以FIFO的方式对待。尽管这是一个很好的方法，但有时我们可能需要更多：即优先处理进入和离开队列的元素，正如我们可以在接下来的部分中注意到的那样。
- en: Priority Queue
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列
- en: A priority queue is operationally similar the simple queues, that is, they support
    the same API, but there is a small addition to the data that they hold. Along
    with the element (your data), they can also persist a priority, which is just
    a numerical value indicating the priority of your element in the queue.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列在操作上类似于简单队列，即它们支持相同的API，但它们所持有的数据还有一个小小的附加项。除了元素（您的数据）之外，它们还可以保持一个优先级，这只是一个表示队列中元素优先级的数值。
- en: 'Addition or removal of these elements from the queue is based on priority.
    You can either have a minimum priority queue or a maximum priority queue, to help
    establish whether you are adding elements based on increasing priority or decreasing
    priority. We will take a look at how the `add()` method can substitute the `add()`
    method of the simple queue that we defined earlier:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从队列中添加或移除这些元素是基于优先级的。您可以拥有最小优先级队列或最大优先级队列，以帮助确定您是基于增加优先级还是减少优先级来添加元素。我们将看一下`add()`方法如何替代我们之前定义的简单队列的`add()`方法：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since we are accounting for the priority of the elements while they are being
    inserted into the stack, we do not have to concern ourselves with priority while
    we removeelements from the queue, so the `remove()`method is the same for both
    simple and priority queues. Other utility methods, such as `front()`, `clear()`,
    `peek()`, and `size()`, have no correlation with the type of data that is being
    saved in the queue, so they remain unchanged as well.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在插入堆栈时考虑了元素的优先级，所以我们在从队列中移除元素时不必关注优先级，因此`remove()`方法对于简单队列和优先队列是相同的。其他实用方法，如`front()`、`clear()`、`peek()`和`size()`，与保存在队列中的数据类型无关，因此它们也保持不变。
- en: A smart move while creating a priority queue would be to optimize your code
    and decide whether you would like to determine the priority at the time of addition or
    removal. That way, you are not overcalculating or analyzing your dataset at each
    step.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 创建优先队列时的一个聪明举措是优化您的代码，并决定您是否想要在添加或移除时确定优先级。这样，您就不会在每一步都过度计算或分析数据集。
- en: Testing a priority queue
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试优先队列
- en: 'Let''s first set up the data for testing the queue:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先设置用于测试队列的数据：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Visually, the preceding steps would generate a queue that looks like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，前面的步骤将生成一个如下所示的队列：
- en: '![](assets/8c841da0-1359-4cb8-bf55-731f3ac619a0.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8c841da0-1359-4cb8-bf55-731f3ac619a0.png)'
- en: 'From the preceding figure, we can note how when we add an element with a priority
    **2** it gets placed ahead of all the elements with priority **1**:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，我们可以注意到当我们添加一个优先级为2的元素时，它会排在所有优先级为1的元素之前：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And when we add an element with priority 1 (lowest) it gets added to the end
    of the queue:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加一个优先级为1（最低）的元素时，它会被添加到队列的末尾：
- en: '![](assets/ff347fa9-6abe-441c-94d7-26e1e3f7571b.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ff347fa9-6abe-441c-94d7-26e1e3f7571b.png)'
- en: The last element that we add here happens to be the one with the lowest priority
    as well, which makes it the last element of the queue, thus keeping all the elements
    ordered based on priority.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加的最后一个元素恰好也是优先级最低的元素，这使它成为队列的最后一个元素，从而根据优先级保持所有元素的顺序。
- en: 'Now, let''s remove elements from the queue:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从队列中移除元素：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There we have it: the creation of simple and priority queues in JavaScript
    using `WeakMap()`. Let''s now take a look at some of the practical applications
    of these queues.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是：使用`WeakMap()`在JavaScript中创建简单和优先队列。现在让我们来看一下这些队列的一些实际应用。
- en: Use cases for queues
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列的用例
- en: 'Before we start off with use cases, we will need a base starting point in the
    form of a Node.js application. To create one, ensure that you have the latest
    Node.js installed:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用案例之前，我们需要一个基本的起点，即一个Node.js应用程序。要创建一个，请确保您已安装了最新的Node.js：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This should show you your currently installed Node.js version; if it does not,
    then download and install the latest version of Node.js from [https://nodejs.org/en](https://nodejs.org/en/).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示您当前安装的Node.js版本；如果没有，那么请从[https://nodejs.org/en](https://nodejs.org/en/)下载并安装最新版本的Node.js。
- en: Creating a Node.js application
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Node.js应用程序
- en: 'To start off a sample Node.js project, simply create a project folder first
    and then run the following command from that folder:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始一个示例Node.js项目，首先创建一个项目文件夹，然后从该文件夹运行以下命令：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On running this command, Node will prompt you with a series of questions, which
    you can either fill or leave blank:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令时，Node将提示您一系列问题，您可以选择填写或留空：
- en: '![](assets/aa9bf36c-0a1d-443a-9483-d94608efff14.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aa9bf36c-0a1d-443a-9483-d94608efff14.png)'
- en: 'Once the blank application is created, all you see is a file called `package.json`*. *You
    can now add the dependencies that are needed to create the Node.js application:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 创建空应用程序后，您将看到一个名为`package.json`的文件。现在，您可以添加创建Node.js应用程序所需的依赖项：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `body-parser` modulehelps with parsing of the POST request body, whereas
    the `express`module helps with the creation of the Node.js server.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`body-parser`模块有助于解析POST请求体，而`express`模块有助于创建Node.js服务器。'
- en: Starting the Node.js server
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动Node.js服务器
- en: Once we have the application shell created, create a file called `index.js`,
    which will be the main file of your application; you can call it anything you
    like, but make sure that you update the `main` property accordingly in your `package.json`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了应用程序外壳，创建一个名为`index.js`的文件，这将是您的应用程序的主文件；您可以随意命名，但请确保您相应地更新`package.json`中的`main`属性。
- en: 'Now, let''s add some code to the `index.js` file to start an express server:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`index.js`文件中添加一些代码来启动一个express服务器：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'That''s it! The server is now up-and-running on the `3000` port. To test it,
    just add an empty route to tell you whether your application is up or not:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！服务器现在在`3000`端口上运行。要测试它，只需添加一个空路由来告诉您应用程序是否正常运行：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can go to your browser and navigate to `localhost:3000`*, *and that should
    show you the server status as `OK!` or give you an error if your server is down.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以打开浏览器并导航到`localhost:3000`，这应该会显示服务器状态为`OK！`，或者如果服务器宕机，则会给出错误。
- en: Creating a chat endpoint
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个聊天端点
- en: Now that we have the server up and running, we can create an in-memory chat
    endpoint, which would accept a message from two users and forward it to its intended
    recipient using a queue while retaining the order.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的服务器已经运行起来了，我们可以创建一个内存中的聊天端点，它将接受来自两个用户的消息，并使用队列将其转发给其预期的接收者，同时保留顺序。
- en: 'Before we add the logic, we will need to do some groundwork to set up the application
    in a modular way. First, let''s include the `body-parser`and use it in an express
    middlewareso that we can access the `body` of requests easily. So, the updated
    `index.js` file looks as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加逻辑之前，我们需要进行一些基础工作，以模块化地设置应用程序。首先，让我们包含`body-parser`并在express中间件中使用它，以便我们可以轻松访问请求的`body`。因此，更新后的`index.js`文件如下所示：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, to add the endpoint for the message, we can create a new file called `messages.js`
    under the `routes` folder to which we can add the basic `post`request:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要为消息添加端点，我们可以在`routes`文件夹下创建一个名为`messages.js`的新文件，然后在其中添加基本的`post`请求：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, we can inject it in our `index.js` and make it a part of our application:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将其注入到我们的`index.js`中，并使其成为我们应用程序的一部分：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, to test this, we can start our server and post a message to `localhost:3000/message`
    using Postman; then we can see the response posted, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试这个，我们可以启动服务器并使用Postman向`localhost:3000/message`发送一条消息；然后我们可以看到以下响应：
- en: '![](assets/10ca44ce-3541-493d-a17d-6233240f53c8.png)Figure: Sample post message'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/10ca44ce-3541-493d-a17d-6233240f53c8.png)图：示例发布消息'
- en: Now, we can go ahead and start adding the logic to send messages between two
    users. We are going to abstract, mock, and simplify the chat part of the application
    and focus more on queue applicationsin such complex applications.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续开始添加逻辑，以便在两个用户之间发送消息。我们将抽象、模拟和简化应用程序的聊天部分，并更专注于在这种复杂应用程序中使用队列应用。
- en: 'The workflow itself is relatively straightforward: user A sends a message to
    user B,which our server tries to forward to user B. If it goes through without
    any issue, then everything is good, and the message is delivered to user B;but
    if it fails, then we invoke our `FailureProtocol()`,which retries to send the
    last failed message per-conversation. For simplicity, we will assume that there
    is only one channel right now, that is, between user A and user B*. *'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流本身相对简单：用户A向用户B发送消息，我们的服务器尝试将其转发给用户B。如果没有任何问题，一切顺利，消息将被传递给用户B；但如果失败，我们将调用我们的`FailureProtocol()`，它会重试发送上一次失败的对话消息。为简单起见，我们现在假设只有一个通道，即用户A和用户B之间的通道*。
- en: The production counterpart of this would be capable of handling multiple channels
    simultaneously by creating a new `FailureProtocol()` handler for a particular
    channel when a message fails on a channel and would have the flexibility of deferring
    the job over to multiple threads.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境中的对应部分将能够同时处理多个通道，当通道上的消息发送失败时，会为特定通道创建一个新的`FailureProtocol()`处理程序，并具有将作业推迟到多个线程的灵活性。
- en: 'Let''s now mock out the `sendMessage()` and `getUniqueFailureQueue()` methods
    in a file called `messaging-utils.js` which will be our wrapper so that we can
    move them into their own module, as their internal workings are not really important
    to understand queuesin this scenario:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在一个名为`messaging-utils.js`的文件中模拟`sendMessage()`和`getUniqueFailureQueue()`方法，这将是我们的包装器，以便我们可以将它们移动到自己的模块中，因为它们在这种情况下对于理解队列并不重要：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, when we receive a new message, we try to send it to the intended end user:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们收到新消息时，我们会尝试将其发送给预期的最终用户：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If the message is sent successfully, we will need to immediately acknowledge
    that and send a success message—otherwise, we will get a unique `failedMessageQueue`
    between the two users—and then add the message to it, which is then followed by
    triggering the failure protocol.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果消息发送成功，我们需要立即确认并发送成功消息；否则，我们将在两个用户之间得到一个唯一的`failedMessageQueue`，然后将消息添加到其中，随后触发失败协议。
- en: 'A failure protocol can mean anything to different applications. While some applications
    choose to just show a failed message, applications such as ours will retry to
    send the message until it is sent successfully:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 失败协议对不同的应用程序可能意味着不同的事情。虽然一些应用程序选择只显示失败消息，像我们这样的应用程序会重试发送消息，直到成功发送为止：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can use the methods available in our `Queue` to pick the top message and
    then try to send it. If successful in doing so, then remove it; otherwise, retry.
    As you can see, using queues greatly simplifies and abstracts the logic of the
    actual queuing of failed messages and what is even better is that you can upgrade
    and enhance the queue at any time without having to think twice about what other
    components would get affected by that change.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的`Queue`中可用的方法来选择顶部消息，然后尝试发送它。如果成功，然后删除它；否则，重试。正如你所看到的，使用队列极大地简化和抽象了实际失败消息排队的逻辑，更好的是，你可以随时升级和增强队列，而不必考虑其他组件会受到这种变化的影响。
- en: 'Now that we have the API call ready to parse the incoming request, send it
    to the intended recipient and trigger our custom failure protocol. When we combine
    all of this logic together, we have the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好解析传入请求、发送给预期接收者并触发我们自定义的失败协议的API调用。当我们将所有这些逻辑结合在一起时，我们有以下内容：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Implementing logging using priority queues
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用优先队列实现日志记录
- en: Endpoints fail, it's inevitable. Although we can try to resend failed messages,
    we need to realize at some point that there is an issue on our end and stop bombarding
    the server with requests to forward the messages. This is where priority queues
    can come in handy.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 端点失败是不可避免的。虽然我们可以尝试重新发送失败的消息，但我们需要意识到在某个时候我们的端出现了问题，并停止向服务器发送请求以转发消息。这就是优先队列可以派上用场的地方。
- en: We will replace the existing logic to use a priority queue so that we detect
    when to stop trying to resend the message and notify the support team instead.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将替换现有逻辑，使用优先队列来检测何时停止尝试重新发送消息，并通知支持团队。
- en: The biggest change is in the `triggerFailureProtocol()` method where we check
    whether the message has failed more times than the preset `retryThreshold`; if
    it has, then we add the message to the queue with critical priority, which we
    later use to prevent subsequent bombardment of the server until the support team
    resolves the issue. This solution although rather naive is very efficient when
    it comes to preserving server resources.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的变化在`triggerFailureProtocol()`方法中，我们检查消息是否失败的次数超过了预设的`retryThreshold`；如果是，那么我们将消息添加到具有关键优先级的队列中，稍后我们将使用它来防止服务器的后续轰炸，直到支持团队解决问题。这个解决方案虽然相当天真，但在保留服务器资源方面非常有效。
- en: 'So, the updated code with the priority queue is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，带有优先队列的更新代码如下：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code, we wrapped the same login in an `if-else`block to be
    able to retry sending the message or create a critical error and stop our retry
    efforts.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们将相同的登录包装在`if-else`块中，以便能够重试发送消息或创建关键错误并停止我们的重试努力。
- en: So, the next time a new message for that channel comes in, you can verify that
    there already exists a critical error and reject the request directly rather than
    going through the hassle of trying to send the messages and failing, which keeps
    bloating the failure queue.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下次该频道收到新消息时，您可以验证是否已经存在关键错误，并直接拒绝请求，而不必经历尝试发送消息并失败的麻烦，这会不断膨胀失败队列。
- en: This is certainly one approach to solving this problem, but a more suitable
    approach, which is outside the scope of this example, is to notify the user of
    any critical errors when the user tries to access the channel rather than doing
    it when the users posts a message to it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是解决这个问题的一种方法，但更合适的方法是在用户尝试访问频道时通知用户任何关键错误，而不是在用户向其发布消息时这样做，这超出了本示例的范围。
- en: 'The following is the complete code including the priority queue:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包括优先队列的完整代码：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Comparing performance
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能比较
- en: 'Earlier, we saw how we can simply swap out a simple queue for a priority queue
    and not worry about the functional change that it might cause; similarly, we can
    swap out priority queues for a higher-performant variant of them: circular dequeues*.*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了如何简单地将简单队列替换为优先队列，而不必担心它可能引起的功能性变化；同样，我们可以将优先队列替换为性能更高的变体：循环双端队列。
- en: Before we start working on a comparison, we will need to discuss circular queues
    and why we need them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始进行比较之前，我们需要讨论循环队列以及为什么我们需要它们。
- en: The difference between a circular queue and a simple queue is that the back
    of the queue is followed by the front of the queue. That being said, they are
    not functionally different. They still perform the same operations, and produce
    the same results; you might be wondering where exactly they differ and what's
    the point if the end result is the same.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 循环队列和简单队列之间的区别在于队列的尾部紧随队列的前部。也就是说，它们在功能上没有区别。它们仍然执行相同的操作，并产生相同的结果；您可能想知道它们究竟在哪里不同，如果最终结果是相同的，那有什么意义。
- en: In JavaScript arrays, memory locations are contiguous. So, when creating a queue
    and performing operations such as `remove()`, we will need to worry about moving
    the remaining elements to point to the updated *front* instead of *null*, thus
    increasing the number of operations; it is a memory hit too, unless your queue
    has an unlimited/dynamic number of slots.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript数组中，内存位置是连续的。因此，当创建队列并执行`remove()`等操作时，我们需要担心将剩余元素移动到更新的*front*而不是*null*，从而增加操作的数量；这也是一个内存开销，除非您的队列有无限/动态数量的插槽。
- en: Now, imagine a circular queue—because of its circular nature, this queue has
    a fixed number of memory locations, and when an element is removed or added, you
    get to reuse memory locations and reduce the number of operations that are performed,
    which makes it faster than a regular queue.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一个循环队列——由于它的循环性质，这个队列有固定数量的内存位置，当元素被移除或添加时，您可以重用内存位置并减少执行的操作数量，这使得它比常规队列更快。
- en: 'Before we can make a similar judgment over the performance of this queue against
    native arrays in JavaScript, let''s take a look under the hood of Chrome''s JavaScript
    engine V8 and check whether it really matters in our case. The reason why we are
    considering this is because of the frequently overlooked concept of sparse and
    dense arrays in JavaScript, although this is an under-the-hood implementation
    and could keep changing every now and then. Most of the time, JavaScript arrays
    are dense and can easily become sparse if not handled properly. A simple way to
    test this is to create an array, as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对比这个队列与JavaScript中的原生数组的性能之前，让我们来看看Chrome的JavaScript引擎V8的内部工作，并检查它是否真的在我们的情况下很重要。我们考虑这个的原因是因为JavaScript中经常被忽视的稀疏数组和密集数组的概念，尽管这是一个底层实现，可能会不断变化。大多数情况下，JavaScript数组是密集的，如果处理不当很容易变得稀疏。测试这一点的一个简单方法是创建一个数组，如下所示：
- en: 'Consider example 1:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑示例1：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you log it, you see the same:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你记录它时，你会看到相同的结果：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, create an array like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个这样的数组：
- en: 'Consider example 2:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑示例2：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When you log it, you get the same result:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你记录它时，你会得到相同的结果：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is interesting, as it shows the difference between the dense (example 1)
    and sparse (example 2) behavior of JavaScript arrays. When you create these dense
    arrays, the elements of the array are known to be of specific values, and these
    values are known at the time of initialization, which gives JavaScript the option
    of keeping these values in contiguous memory.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣，因为它展示了JavaScript数组的密集（示例1）和稀疏（示例2）行为之间的差异。当您创建这些密集数组时，数组的元素被认为是特定值，并且这些值在初始化时是已知的，这使得JavaScript有可能将这些值保存在连续的内存中。
- en: The V8 code for the JavaScript array implementation has the following comment,
    which makes for another interesting observation that is in line with what we have
    discussed so far
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript数组实现的V8代码有以下注释，这使得我们可以观察到另一个有趣的现象，与我们之前讨论的内容一致。
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So, arrays internally are treated differently based on the type and size of
    data that is being saved in the array. As a rule of thumb, always create an empty
    array using an array literal and incrementally assign values to elements starting
    from the 0 index while leaving no gaps or holes in the array. This keeps the array
    fast, and it does not go into the dictionary mode unless the sheer size of the
    data demands it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数组在内部根据正在保存在数组中的数据的类型和大小而有所不同。作为一个经验法则，总是使用数组文字创建一个空数组，并从0索引开始逐步为元素分配值，同时不在数组中留下空隙或空洞。这样可以使数组保持快速，并且除非数据的规模要求，否则不会进入字典模式。
- en: A double-ended circular queue, also known as circular dequeue, is also similar
    to a simple queue, except that the `add()` and `remove()` can be done from either
    the front or the back of the queue.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 双端循环队列，也称为循环双端队列，与简单队列类似，只是`add()`和`remove()`可以从队列的前面或后面进行。
- en: 'This is basically the same API as your array, and we can build an example of
    the class that would provide this functionality, but let''s go one better and
    take a look at how we can implement everything we discussed previously using a
    circular queue and make it as performant as possible:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是与您的数组相同的API，我们可以构建一个提供此功能的类的示例，但让我们更进一步，看看如何使用循环队列实现我们之前讨论的一切，并使其尽可能高效：
- en: '![](assets/96b70c36-8796-4a30-9ebb-b82c590024e5.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/96b70c36-8796-4a30-9ebb-b82c590024e5.png)'
- en: 'First, we will make an assumption that this queue has a limited size; it can
    be extended later to be of a dynamic nature, but that''s not a concern right now.
    Until now, `WeakMap()` has been used as the in-memory data store in which we persisted
    the data necessary for the queue, but when it comes to performance it just adds
    another layer of retrieval to our data structure, so we will move over to a standard
    array in this case, as that is what we will be comparing against in our benchmark
    tests anyway. Translating this into some code, we can get our `CircularDequeue`,
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们假设这个队列有一个有限的大小；它可以随后扩展为动态的性质，但现在不是一个问题。到目前为止，`WeakMap()`已被用作内存中的数据存储，我们在其中保存了队列所需的数据，但是在性能方面，它只是为我们的数据结构添加了另一层检索，因此在这种情况下，我们将转移到标准数组，因为这是我们将在基准测试中进行比较的。将这些转化为一些代码，我们可以得到我们的`CircularDequeue`，如下所示：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Of course, this is only one way of implementing a circular dequeue; you can
    get better performance by adding the properties to the class's constructor itself
    instead of wrapping them inside an IIFE (that is, avoid scope chain lookups )
    and also further simplify the code if you are using TypeScript, which allows private
    class members as discussed with stacks.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这只是实现循环双端队列的一种方式；您可以通过将属性添加到类的构造函数本身而不是将它们包装在IIFE中（即避免作用域链查找），并且如果您使用TypeScript，还可以进一步简化代码，这允许私有类成员，就像我们在讨论堆栈时所讨论的那样。
- en: Running benchmark tests
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行基准测试
- en: Before we run the benchmark, it is important to understand our intention of
    comparing our queue with native arrays. We are not trying to prove that the queue
    is faster than arrays and that's why we should be using them. At the same time,
    we do not want to use something, that is ridiculously slow. The goal of these
    tests is to help us understand where queues lie with respect to native data structures
    and whether we can rely on them to provide a performant custom data structure
    if needed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行基准测试之前，重要的是要理解我们比较队列与本机数组的意图。我们并不试图证明队列比数组更快，这就是为什么我们应该使用它们。同时，我们也不想使用一些非常慢的东西。这些测试的目标是帮助我们了解队列在本机数据结构方面的位置，以及我们是否可以依赖它们提供高性能的自定义数据结构（如果需要）。
- en: Now, let's run some benchmark tests to compare a circular dequeue and an array*. *We
    will use `benchmark.js` to set up and run our benchmark tests. The setup is pretty
    straightforward; we will be comparing the circular dequeue API with a regular
    array's native operations.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行一些基准测试来比较循环双端队列和数组。我们将使用`benchmark.js`来设置和运行我们的基准测试。
- en: 'To start with the testing, let''s first include the benchmark node module in
    our project. To install it, run the following command on your Terminal in the
    project root:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始测试，让我们首先在项目中包含基准测试节点模块。要安装它，请在项目根目录的终端上运行以下命令：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once it is installed, we are ready to create our test suite. Create a `tests` folder and
    add a file called `benchmark.js` under it. To create a test suite, we will first
    set up the data. As discussed earlier, we will compare our `CircularDequeue` against
    an array:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们准备创建我们的测试套件。创建一个`tests`文件夹，并在其中添加一个名为`benchmark.js`的文件。为了创建一个测试套件，我们首先设置数据。如前所述，我们将比较我们的`CircularDequeue`和一个数组：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we start off with a small dataset in both the circular dequeue and array.
    This will allow the arrays to be dense and thus allow V8 engine will run in fast
    mode and apply internal optimizations.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用循环双端队列和数组中的小数据集。这将使数组变得密集，从而使V8引擎以快速模式运行并应用内部优化。
- en: 'Now, we can go ahead and add tests to our testing suite:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续并向我们的测试套件添加测试：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'One thing to note in the previous tests is that we always couple two operations
    together, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的测试中需要注意的一点是，我们总是将两个操作耦合在一起，如下所示：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we do not do a `shift()` method before doing the `push()` method and push
    a number instead, for example, `1` or `2`, then we will quickly run into an `out
    of memory` error, as the number of iterations of the tests internally is too large
    for the arrays to handle; circular queues, on the other hand, will be fine because
    of their circular nature: they would just overwrite the previous values.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在执行`push()`方法之前不执行`shift()`方法并推送一个数字，例如`1`或`2`，那么我们将很快遇到`内存不足`错误，因为测试的迭代次数对于数组来说太大了；另一方面，循环队列将没有问题，因为它们的循环性质：它们只会覆盖先前的值。
- en: 'Now, add the test to your `package.json` scripts for an easier access:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将测试添加到您的`package.json`脚本中以便更轻松地访问：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To run the benchmark test suite, run the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行基准测试套件，请运行以下命令：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The result will be as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下：
- en: '![](assets/4ff62d71-59e1-4930-b5f4-a9cbf6bcebd6.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4ff62d71-59e1-4930-b5f4-a9cbf6bcebd6.png)'
- en: As you can note from the preceding screenshot, the push and the unshift for
    the circular queues are much faster than the native push and unshift operations,
    whereas the pop and shift operations are almost 30% slower.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以从前面的截图中看到的，循环队列的push和unshift比本机的push和unshift操作快得多，而pop和shift操作几乎慢了30%。
- en: 'Now, let''s make the arrays sparse so that we force V8 to run the array methods
    in dictionary mode (this can be a real use case for some and also a possibility
    sometimes when dealing with arrays of mixed data types):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使数组稀疏，以便强制V8以字典模式运行数组方法（这对某些情况可能是真实用例，有时在处理混合数据类型的数组时也可能是可能的）：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we run similar tests but with sparse arrays, the results are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用稀疏数组运行类似的测试时，结果如下：
- en: '![](assets/8c009c93-8f99-491a-9b10-9c4123d53985.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8c009c93-8f99-491a-9b10-9c4123d53985.png)'
- en: You can see that the performance greatly varies from that of the fast mode for
    the `push()` operation, whereas the other pretty much remains the same. This is
    a great way to understand the consequences of adopting a particular coding practice.
    You will need to understand the requirements of your application and pick the
    right tool for the right job accordingly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，性能与`push()`操作的快速模式大不相同，而其他操作基本保持不变。这是了解采用特定编码实践后果的好方法。您需要了解应用程序的要求，并相应地选择合适的工具来完成工作。
- en: 'For example, when memory is a priority, we will use the simple queue instead,
    which works with `WeakMap()`, instead of regular array. We can create two new
    tests, which we can run separately to track their individual memory usage:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当内存是优先考虑因素时，我们将使用简单队列，它可以与`WeakMap()`一起使用，而不是常规数组。我们可以创建两个新的测试，可以分开运行以跟踪它们各自的内存使用情况：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It produces the following result:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它产生了以下结果：
- en: '![](assets/6ac6574f-7e19-48e9-b6f6-3c4319db9981.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6ac6574f-7e19-48e9-b6f6-3c4319db9981.png)'
- en: We can note from the preceding screenshot that it logs the result of our test
    run, which is the ops/sec, and also logs the total memory usage of that cycle.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的截图中看到，它记录了我们测试运行的结果，即ops/sec，并记录了该周期的总内存使用情况。
- en: 'Similarly, we can run the benchmark for a `remove` operation on the simple
    queue, which is very similar to what we did with the shift operation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以对简单队列进行`remove`操作的基准测试，这与我们对shift操作所做的非常相似：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This produces the following result:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下结果：
- en: '![](assets/6dc01644-a555-4d2a-92ea-3cdb3c8776c0.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6dc01644-a555-4d2a-92ea-3cdb3c8776c0.png)'
- en: You can see that the simple queue is obviously slower than the array by a factor
    of `4`, but what is important here is to note that the `heapUsed` for both scenarios.
    This is another factor that lets you decide when and how to pick a particular
    type of data structure.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，简单队列显然比数组慢了4倍，但这里重要的是要注意两种情况下的`heapUsed`。这是另一个让您决定何时以及如何选择特定类型数据结构的因素。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: With that, we conclude this chapter on queues. We learned about simple, priority,
    and circular queues and it's double-ended variant. We also learned when to apply
    them based on use cases and we saw with example, how we can leverage the power
    of benchmarking any algorithm or data structure as needed. In the next chapter,
    we will be putting sets, maps, and hashes under the microscope to understand their
    internal workings and see what situations they can be useful in.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们结束了关于队列的章节。我们学习了简单队列、优先级队列、循环队列以及双端队列的变体。我们还学习了何时根据使用情况应用它们，并且通过示例看到了如何利用基准测试任何算法或数据结构的能力。在下一章中，我们将对集合、映射和哈希进行深入研究，以了解它们的内部工作原理，并看看它们在哪些情况下可以发挥作用。
