- en: '*Chapter 10*: Lambdas, LINQ, and Functional Programming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：Lambda、LINQ和函数式编程'
- en: Although C# is an object-oriented programming language at its core, it is actually
    a *multi-paradigm language*. So far in this book, we have discussed imperative
    programming, object-oriented programming, and generic programming. However, C#
    also supports functional programming features. Throughout [*Chapter 7*](B12346_07_Final_JC_ePub.xhtml#_idTextAnchor134),
    *Collections*, and [*Chapter 8*](B12346_08_Final_JC_ePub.xhtml#_idTextAnchor154),
    *Advanced Topics*, we have already used some of these, such as lambdas and **Language-Integrated
    Query (LINQ)**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管C#在其核心是一种面向对象的编程语言，但它实际上是一种*多范式语言*。到目前为止，在本书中，我们已经讨论了命令式编程、面向对象编程和泛型编程。然而，C#也支持函数式编程特性。在[*第7章*](B12346_07_Final_JC_ePub.xhtml#_idTextAnchor134)、*集合*和[*第8章*](B12346_08_Final_JC_ePub.xhtml#_idTextAnchor154)、*高级主题*中，我们已经使用了其中一些，比如lambda和**语言集成查询（LINQ）**。
- en: In this chapter, we'll look at these in detail from the perspective of functional
    programming. Learning functional programming techniques will help you to write
    code in a declarative manner that is often simpler and easier to understand than
    the equivalent imperative code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从功能编程的角度详细讨论这些内容。学习函数式编程技术将帮助您以声明性的方式编写代码，通常比等效的命令式代码更简单、更容易理解。
- en: 'The topics that will be covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Functional programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Functions as first-class citizens
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为一等公民
- en: Lambda expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: LINQ
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ
- en: More functional programming concepts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多函数式编程概念
- en: By the end of this chapter, you will be able to understand lambda expressions
    in detail and will be able to use them together with LINQ to query data from a
    variety of sources. Moreover, you will be familiarized with functional programming
    concepts and techniques, such as higher-order functions, closures, monads, and
    monoids.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将能够详细了解lambda表达式，并能够与LINQ一起查询各种来源的数据。此外，您将熟悉函数式编程的概念和技术，如高阶函数、闭包、单子和幺半群。
- en: Let's start this chapter with an overview of functional programming and its
    core principles.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从功能编程及其核心原则的概述开始这一章。
- en: Functional programming
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: C# is a general-purpose and multi-paradigm programming language. Yet, so far
    in this book, we have only covered the imperative programming paradigm, which
    uses statements to change the program state and is focused on describing how a
    program operates. In imperative programming, functions may have side effects,
    thus changing the program state when they execute. Alternatively, the execution
    of a function may depend on the program state.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C#是一种通用的多范式编程语言。然而，到目前为止，在本书中，我们只涵盖了命令式编程范式，它使用语句来改变程序状态，并且专注于描述程序的操作方式。在命令式编程中，函数可能具有副作用，因此在执行时改变程序状态。或者，函数的执行可能取决于程序状态。
- en: The opposite paradigm is functional programming, which is concerned with describing
    *what* a program does and not *how* it does it. Functional programming treats
    computation as the evaluation of functions; it uses immutable data and avoids
    changing states. Functional programming is a declarative programming paradigm
    where expressions are used instead of statements. Functions no longer have side
    effects but are idempotent. This means that calling a function with the same arguments
    produces the same results every time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的范式是函数式编程，它关注描述程序做什么而不是如何做。函数式编程将计算视为函数的评估；它使用不可变数据并避免改变状态。函数式编程是一种声明性的编程范式，其中使用表达式而不是语句。函数不再具有副作用，而是幂等的。这意味着使用相同参数调用函数每次都会产生相同的结果。
- en: 'Functional programming provides several advantages, including the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程提供了几个优势，包括以下内容：
- en: The code is easier to understand and maintain because functions don't change
    states and only depend on the arguments they receive.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于函数不改变状态，只依赖于它们接收的参数，代码更容易理解和维护。
- en: The code is easier to test for the same reason.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数据是不可变的，函数没有副作用，因此更容易测试代码。
- en: It is simpler and more efficient to implement concurrency because data is immutable
    and functions don't have side effects, which avoids data races.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于数据是不可变的，函数没有副作用，实现并发更简单高效，这避免了数据竞争。
- en: '`Rectangle` (this could also be a class) that represents a rectangle:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle`（这也可以是一个类）代表一个矩形：'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can instantiate this type and alter its properties. For instance, if we
    want to inflate the width of the rectangle with 10 units, equally in each direction,
    we can do the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实例化这种类型并改变它的属性。例如，如果我们想要将矩形的宽度增加10个单位，每个方向都相等，我们可以这样做：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can also write a function that we could invoke. This could be a *member
    function*, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以编写一个我们可以调用的函数。这可以是一个*成员函数*，如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This can also be a *non-member function*, as shown in the following code. The
    difference between the two is only a matter of design. Writing it as an extension
    method is the only choice if we cannot modify the source code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以是一个*非成员函数*，如下面的代码所示。两者之间的区别只是设计上的问题。如果我们无法修改源代码，将其编写为扩展方法是唯一的选择：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `Rectangle` data type is mutable because its state can be changed. The
    `Inflate()` method has side effects because it changes the state of a rectangle.
    In functional programming, `Rectangle` should be immutable. A possible implementation
    is shown here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle`数据类型是可变的，因为它的状态可以改变。`Inflate()`方法具有副作用，因为它改变了矩形的状态。在函数式编程中，`Rectangle`应该是不可变的。可能的实现如下所示：'
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The pure function version of the `Inflate()` method would not have side effects.
    Its behavior would depend solely on the arguments and the result would be the
    same, no matter how many times it is called with the same arguments. An example
    of such an implementation is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Inflate()`方法的纯函数版本不会产生副作用。它的行为仅取决于参数，结果将是相同的，无论调用多少次具有相同参数。这样的实现示例如下：'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These can now be used as in the following example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以像下面的例子一样使用它们：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Functional programming stems from lambda calculus (developed by Alonzo Church),
    which is a framework, or mathematical system, for expressing computations based
    on function abstractions and applications using variable binding and substitution.
    Some programming languages, such as Haskell, are purely functional. Others, such
    as C#, support multiple paradigms and are not purely functional.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程源自λ演算（由阿隆佐·邱奇开发），它是一个基于函数抽象和应用的计算表达的框架或数学系统，使用变量绑定和替换。一些编程语言，比如Haskell，是纯函数式的。其他的，比如C#，支持多种范式，不是纯函数式的。
- en: The preceding example showed a variable, `r`, that was initialized to a value
    and then changed. In pure functional programming, this is not possible. A variable,
    once initialized, cannot change value; instead, a new variable must be assigned.
    This enables expressions to be replaced with their values, a property known as
    **referential transparency**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子展示了一个变量`r`，它被初始化为一个值，然后被改变。在纯函数式编程中，这是不可能的。一旦初始化，变量就不能改变值；而是必须分配一个新的变量。这使得表达式可以被它们的值替换，这是**引用透明性**的一个特性。
- en: C# enables us to write code using functional programming concepts and idioms.
    At the core of all these are lambda expressions, which we will look at in depth
    shortly. Before that, we need to explore another functional programming pillar,
    and that is treating functions as *first-class citizens*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: C#使我们能够使用函数式编程的概念和习语来编写代码。所有这些的核心都是lambda表达式，我们将很快深入研究。在那之前，我们需要探索另一个函数式编程的支柱，那就是将函数视为*一等公民*。
- en: Functions as first-class citizens
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为一等公民
- en: 'In [*Chapter 8*](B12346_08_Final_JC_ePub.xhtml#_idTextAnchor154), *Advanced
    Topics*, we learned about delegates and events. A delegate looks like a function
    but is a type that holds references to functions whose signatures match the definition
    of the delegate. Delegate instances can be passed as objects for function arguments.
    Let''s look at an example where we have a delegate that takes two `int` parameters
    and returns an `int` value:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第8章*《高级主题》中，我们学习了关于委托和事件。委托看起来像一个函数，但它是一种保存与委托定义匹配的函数引用的类型。委托实例可以作为函数参数传递。让我们看一个例子，其中有一个委托接受两个`int`参数并返回一个`int`值：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then have different functions, such as `Add()`, which adds two integers
    and returns the sum, `Sub()`, which subtracts two integers and returns their difference,
    or `Mul()`, which multiplies two integers and returns their product. Their signature
    matches the delegate, so an instance of the `Combine` delegate can hold references
    to all these functions. These functions are shown as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有不同的函数，比如`Add()`，它可以将两个整数相加并返回和，`Sub()`，它可以将两个整数相减并返回差，或者`Mul()`，它可以将两个整数相乘并返回积。它们的签名与委托匹配，因此`Combine`委托的实例可以保存对所有这些函数的引用。这些函数如下所示：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can write a general function that can apply one of these functions to two
    arguments. Such a function may look like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个通用函数，可以将其中一个函数应用于两个参数。这样的函数可能如下所示：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Invoking it is simple—we pass the arguments and a reference to the actual function
    that we want to invoke:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 调用它很简单——我们传递参数和我们想要调用的实际函数的引用：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For convenience, .NET defines a set of generic delegates called `Func` to avoid
    defining your own delegates all the time. These are defined in the `System` namespace
    and look like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，.NET定义了一组名为`Func`的通用委托，以避免一直定义自己的委托。这些定义在`System`命名空间中，如下所示：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a set of 17 overloads that take either 0, 1, or up to 16 arguments
    (of potentially different types) and return a value. Using these system delegates,
    we can rewrite the `Apply` function as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一组有17个重载的函数，可以接受0、1或多达16个参数（可能是不同类型的），并返回一个值。使用这些系统委托，我们可以将`Apply`函数重写如下：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This version of the function is generic so that it can be invoked with other
    types of arguments, not just integers. The way the function is invoked in the
    preceding examples does not change.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的函数是通用的，因此它可以用其他类型的参数来调用，而不仅仅是整数。在前面的例子中调用函数的方式并没有改变。
- en: 'These delegates return a value, so they cannot be used for functions that don''t
    have a return value. There is a similar set of overloads in the `System` namespace
    called `Action` that is defined as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些委托返回一个值，因此不能用于没有返回值的函数。在`System`命名空间中有一组类似的重载，称为`Action`，定义如下：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These delegates are very similar to the `Func` delegates we saw earlier. The
    only difference is that they do not return a value. There are still 17 overloads
    that take 0, 1, or up to 16 input arguments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些委托与我们之前看到的`Func`委托认非常相似。唯一的区别是它们不返回值。仍然有17个重载，可以接受0、1或多达16个输入参数。
- en: 'In the following example, the `Apply` function is overloaded so that it also
    takes a parameter of the `Action<string>` type, which is a function that has a
    single parameter of the `string` type and returns nothing. After applying the
    function, but before returning the result, this action is invoked with a string
    that describes the actual operation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，`Apply`函数被重载，以便它还接受`Action<string>`类型的参数，这是一个具有`string`类型的单个参数并且不返回任何值的函数。在应用函数之后，但在返回结果之前，将调用此操作，并传递描述实际操作的字符串：
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can invoke this new overload by passing `Console.WriteLine` for the last
    argument, which results in the operations being logged to the console:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`Console.WriteLine`作为最后一个参数传递来调用这个新的重载，这样操作就会被记录到控制台上：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Apply` function is called a *higher-order function*. A higher-order function
    is a function that takes one or more functions as arguments, returns a function,
    or both. All the other functions are called *first-order functions*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Apply`函数被称为*高阶函数*。高阶函数是一个接受一个或多个函数作为参数、返回一个函数或两者都有的函数。其他所有的函数都被称为*一阶函数*。'
- en: There are many higher-order functions that you might be using without any realization.
    For instance, `List<T>.Sort (Comparison<T> comparison)` is such a function. Most
    query predicates from LINQ (which we will explore later in this chapter in the
    *LINQ* section) are higher-order functions.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多高阶函数可能会在没有意识到的情况下使用。例如，`List<T>.Sort (Comparison<T> comparison)`就是这样一个函数。LINQ中的大多数查询谓词（我们将在本章的*LINQ*部分中探讨）都是高阶函数。
- en: 'An example of a higher-order function is a function that returns another function,
    as shown in the following snippet. `ApplyReverse()` takes a function as argument
    and returns another function that invokes the argument function with two arguments,
    but in reverse order:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数的一个例子是返回另一个函数的函数，如下面的代码片段所示。`ApplyReverse()`接受一个函数作为参数，并返回另一个函数，该函数以两个参数调用参数函数，但顺序相反：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This function is invoked as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数被调用如下：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What we have seen so far is the possibility in C# to pass functions as arguments,
    return functions from functions, assign functions to variables, store them in
    data structures, or define anonymous functions (that is, functions without a name).
    It's also possible to nest functions and test references to functions for equality.
    A programming language that does these things is said to treat functions as first-class
    citizens and its functions are first-class. C# is, therefore, such a language.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的是在C#中将函数作为参数传递，从函数中返回函数，将函数分配给变量，将它们存储在数据结构中，或者定义匿名函数（即没有名称的函数）的可能性。还可以嵌套函数并测试函数的引用是否相等。一个能做到这些的编程语言被称为将函数视为一等公民，并且它的函数是一等公民。因此，C#就是这样一种语言。
- en: 'Getting back to the previous examples, an alternative and simpler way of invoking
    the `Apply()` method is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回到之前的例子，调用`Apply()`方法的另一种更简单的方法如下：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, the methods from the `Math` class have been replaced with lambda expressions
    such as `(a, b) => a + b`. We can even define the `Apply()` function as a lambda
    expression and invoke it accordingly:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Math`类的方法已被替换为诸如`(a, b) => a + b`这样的lambda表达式。我们甚至可以将`Apply()`函数定义为lambda表达式并相应地调用它：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We'll look at lambda expressions in depth in the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节深入研究lambda表达式。
- en: Lambda expressions
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: Lambda expressions are a convenient way to write anonymous functions. They are
    a block of code, either an expression or one or more statements, that behaves
    like a function and can be assigned to a delegate. As a result, a lambda expression
    can be passed as an argument to a function or returned from a function. They are
    a convenient way to write LINQ queries, pass functions to higher-order functions
    (including code that should be executed asynchronously by `Task.Run()`), and create
    expression trees.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是一种方便的写匿名函数的方式。它们是一段代码，可以是一个表达式或一个或多个语句，表现得像一个函数，并且可以被分配给一个委托。因此，lambda表达式可以作为参数传递给函数或从函数中返回。它们是编写LINQ查询、将函数传递给高阶函数（包括应该由`Task.Run()`异步执行的代码）以及创建表达式树的一种方便方式。
- en: An expression tree is a way to represent code in a tree-like data structure,
    with nodes as expressions (such as method calls or binary operations). These expression
    trees can be compiled and executed, which enables dynamic changes to be performed
    on executable code. Expression trees are used to implement LINQ providers for
    various data sources and in the DLR to provide interoperability between .NET Framework
    and a dynamic language.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式树是一种以树状数据结构表示代码的方式，其中节点是表达式（如方法调用或二进制操作）。这些表达式树可以被编译和执行，从而使可执行代码能够进行动态更改。表达式树用于实现各种数据源的LINQ提供程序以及DLR中的.NET
    Framework和动态语言之间的互操作性。
- en: 'Let''s start with a simple example where we have a list of integers and we
    want to remove all the odd numbers from it. It can be written as follows (notice
    that the `IsOdd()` function can be either a class method or a local function):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始，我们有一个整数列表，我们想要从中删除所有的奇数。可以写成如下形式（注意`IsOdd()`函数可以是类方法，也可以是本地函数）：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code can actually be simplified with anonymous methods that allow us to
    pass code to a delegate without defining the separate `IsOdd()` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码实际上可以用匿名方法来简化，允许我们将代码传递给委托，而无需定义单独的`IsOdd()`函数：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Lambda expressions allow us to simplify the code even further with a simpler
    syntax that the compiler transforms into something similar to the preceding code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式允许我们使用更简单的语法进一步简化代码，编译器将其转换为类似于前面代码的内容：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The lambda expression that we can see here (`n => n % 2 == 1`) has two parts
    separated by `=>`, which is the **lambda declaration operator**:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的lambda表达式（`n => n % 2 == 1`）有两部分，由`=>`分隔，这是**lambda声明运算符**：
- en: The left part of the expression is the *list of parameters* (separated by a
    comma and enclosed in parentheses if there is more than one).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式的左部是*参数列表*（如果有多个参数，则用逗号分隔并括在括号中）。
- en: The right part of the expression is either an *expression or a statement*. If
    the right part is an expression (such as in the preceding example), the lambda
    is called an **expression lambda**. If the right part is a statement, the lambda
    is called a **statement lambda**.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式的右部要么是*表达式，要么是语句*。如果右部是表达式（就像前面的例子中），lambda被称为**表达式lambda**。如果右部是一个语句，lambda被称为**语句lambda**。
- en: 'Statements are always enclosed in curly braces `{}`. Any expression lambda
    can actually be written as a statement lambda. Expression lambdas are a simplified
    version of statement lambdas. The previous example with an expression lambda can
    be written as follows using a statement lambda:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 语句总是用大括号`{}`括起来。任何表达式lambda实际上都可以写成一个语句lambda。表达式lambda是语句lambda的简化版本。前面的例子使用表达式lambda可以写成以下形式的语句lambda：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are several examples of lambda expressions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个lambda表达式的例子：
- en: '![](img/Chapter_10_Table_1_01.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_10_Table_1_01.jpg)'
- en: A lambda does not have a type of its own. Instead, its type is either the type
    of delegate that it is assigned to or the `System.Expression` type when lambdas
    are used to build expression trees. A lambda that does not return a value corresponds
    to a `System.Action` delegate (and can be assigned to one). A lambda that does
    return a value corresponds to a `System.Func` delegate.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: lambda没有自己的类型。相反，它的类型要么是分配给它的委托的类型，要么是当lambda用于构建表达式树时的`System.Expression`类型。不返回值的lambda对应于`System.Action`委托（并且可以分配给一个）。返回值的lambda对应于`System.Func`委托。
- en: 'When you write a lambda expression, you do not need to write the type of the
    parameters as these are inferred by the compiler. The rules for type inference
    are as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你写一个lambda表达式时，你不需要写参数的类型，因为这些类型是由编译器推断的。类型推断的规则如下：
- en: The lambda must have the same number of parameters as the delegate it is assigned
    to.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda必须具有与其分配的委托相同数量的参数。
- en: Each parameter of a lambda must be implicitly converted to the corresponding
    parameter of the delegate it is assigned to.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda的每个参数必须隐式转换为它所分配的委托的对应参数。
- en: If the lambda has a return value, its type must be implicitly converted to the
    return type of the delegate it is assigned to.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果lambda有返回值，它的类型必须隐式转换为它所分配的委托的返回类型。
- en: 'Lambda expressions can be asynchronous. Such a lambda is preceded by the `async`
    keyword and must contain at least an `await` expression. The following example
    shows an asynchronous handler for the `Click` event for a button on a Windows
    Forms form:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式可以是异步的。这样的lambda前面要加上`async`关键字，并且必须包含至少一个`await`表达式。下面的例子展示了一个Windows
    Forms表单上按钮的`Click`事件的异步处理程序：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, `MyForm` is a form class and, in its constructor, we register
    a handler for the `Click` event. This is done using a lambda expression, but the
    lambda is asynchronous (it calls an asynchronous function) and therefore needs
    to be preceded with `async`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`MyForm`是一个表单类，在它的构造函数中，我们注册了一个`Click`事件的处理程序。这是使用lambda表达式完成的，但lambda是异步的（它调用一个异步函数），因此需要在前面加上`async`。
- en: 'Lambdas may use variables that are in the scope of the method or the type that
    contains the lambda expression. When a variable is used in a lambda, it is captured
    so that it can be used even if it goes out of scope. These variables must be definitely
    assigned before they are used in the lambda. In the following example, the lambda
    expression is capturing two variables—the `value` function parameter and the `Data`
    class member:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: lambda可以使用在方法或包含lambda表达式的类型范围内的变量。当变量在lambda中使用时，它被捕获，以便即使超出范围也可以使用。这些变量在lambda中使用之前必须被明确赋值。在下面的例子中，lambda表达式捕获了两个变量——`value`函数参数和`Data`类成员：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here are the rules that apply to the scope of variables in lambda expressions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是lambda表达式中变量作用域的规则：
- en: The variables that are introduced in a lambda expression are not visible outside
    the lambda (for instance, in the enclosing method).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda表达式中引入的变量在lambda之外是不可见的（例如，在封闭方法中）。
- en: A lambda cannot capture `in`, `ref`, or `out` parameters from the enclosing
    method.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda不能捕获封闭方法的`in`、`ref`或`out`参数。
- en: Variables that are captured by a lambda expression are not garbage collected,
    even if they would otherwise go out of scope until the delegate that the lambda
    is assigned to is garbage collected.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被lambda表达式捕获的变量不会被垃圾回收，即使它们本来会超出范围，直到lambda分配的委托被垃圾回收。
- en: A return statement of a lambda expression refers solely to the anonymous method
    that the lambda represents and does not cause the enclosing method to return.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda表达式的返回语句仅指代lambda所代表的匿名方法，并不会导致封闭方法返回。
- en: The most common use case for lambda expressions is writing LINQ query expressions.
    We will look at this in the following section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式最常见的用例是编写LINQ查询表达式。我们将在下一节中看到这一点。
- en: LINQ
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LINQ
- en: LINQ is a set of technologies that enable developers to query a multitude of
    data sources in a consistent manner. Typically, you would use different languages
    and technologies to query different types of data, such as SQL for relational
    databases, and XPath for XML. SQL queries are written as strings, which makes
    them impossible to verify at compile time and increase the chances of having runtime
    errors.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ是一组技术，使开发人员能够以一致的方式查询多种数据源。通常，您会使用不同的语言和技术来查询不同类型的数据，比如关系数据库使用SQL，XML使用XPath。SQL查询是以字符串形式编写的，这使得它们无法在编译时进行验证，并增加了运行时错误的可能性。
- en: LINQ defines a set of operators and a built-in language syntax for querying
    data. LINQ queries are strongly typed and therefore verified at compile time.
    LINQ also provides a framework for building your own LINQ providers, which are
    components that transform a query into APIs that are specific to a particular
    data source. The framework provides built-in support for querying objects (anything
    that is a collection in .NET), relational databases, and XML. Third parties have
    written LINQ providers for many data sources, such as web services.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ定义了一组操作符和用于查询数据的内置语言语法。LINQ查询是强类型的，因此在编译时进行验证。LINQ还提供了一个框架，用于构建自己的LINQ提供程序，这些提供程序是将查询转换为特定于特定数据源的API的组件。该框架提供了对查询对象（.NET中的任何集合）、关系数据库和XML的内置支持。第三方已经为许多数据源编写了LINQ提供程序，比如Web服务。
- en: 'LINQ enables developers to focus on what to do and be less concerned with how
    to do things. To better understand how this works, let''s look at an example where
    we have an array of integers and we want to find the sum of all the odd numbers.
    Typically, you''d write something like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ使开发人员能够专注于要做什么，而不太关心如何做。为了更好地理解这是如何工作的，让我们看一个例子，我们有一个整数数组，我们想找到所有奇数的和。通常，您会写类似以下的内容：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With LINQ, it is possible to reduce all this verbose code to the following
    line:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用LINQ，可以将所有这些冗长的代码简化为以下一行：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we are using the LINQ standard query operators, which are extension methods
    that operate on sequences and provide query capabilities, including filtering,
    projection, aggregation, sorting, and more. Many of these query operators, however,
    have direct support in the LINQ query syntax, which is a query language very similar
    to SQL. Using the query language, the solution to the problem can be written as
    follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了LINQ标准查询操作符，它们是作用于序列的扩展方法，提供了包括过滤、投影、聚合、排序等在内的查询功能。然而，许多这些查询操作符在LINQ查询语法中都有直接的支持，这是一种非常类似于SQL的查询语言。使用查询语言，解决问题的方案可以写成如下形式：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see in this example, not every query operator has an equivalent in
    query syntax. `Sum()` and all the other aggregation operators do not have an equivalent.
    In the following sections, we will look at these two flavors of LINQ in more detail.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这个例子中所看到的，不是每个查询操作符都有查询语法中的等价物。`Sum()`和所有其他聚合操作符都没有等价物。在接下来的章节中，我们将更详细地研究这两种LINQ的用法。
- en: Standard query operators
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准查询操作符
- en: The LINQ standard query operators are a set of extension methods that operate
    on sequences that implement either `IEnumerable<T>` or `IQueryable<T>`. The former
    exports an enumerator that enables iteration over a sequence. The latter is a
    LINQ-specific interface that inherits from `IEnumerable<T>` and provides us with
    the functionality to evaluate queries against a specific data source. The standard
    query operators are defined as extension methods to either the `Enumerable` or
    the `Queryable` class, depending on the type of sequence they operate on. Being
    extension methods, they can be called either using static method syntax or instance
    method syntax.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ标准查询操作符是一组作用于实现`IEnumerable<T>`或`IQueryable<T>`的序列的扩展方法。前者导出一个允许对序列进行迭代的枚举器。后者是一个特定于LINQ的接口，它继承自`IEnumerable<T>`并为我们提供了对特定数据源进行查询的功能。标准查询操作符被定义为作用于`Enumerable`或`Queryable`类的扩展方法，具体取决于它们操作的序列的类型。作为扩展方法，它们可以使用静态方法语法或实例方法语法进行调用。
- en: Most of the query operators may return more than one value. These methods return
    `IEnumerable<T>` or `IQueryable<T>`, which makes it possible to chain them together.
    The actual query on the data source is deferred until the enumerable object they
    return is iterated on. On the other hand, standard query operators that return
    a single value (such as `Sum()` or `Count()`) do not defer execution and execute
    immediately.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数查询操作符可能返回多个值。这些方法返回`IEnumerable<T>`或`IQueryable<T>`，这使得它们可以链接在一起。它们返回的可枚举对象上的实际查询在迭代时被推迟到数据源上。另一方面，返回单个值的标准查询操作符（如`Sum()`或`Count()`）不推迟执行并立即执行。
- en: 'The following table contains the names of all the LINQ standard query operators:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格包含了所有LINQ标准查询操作符的名称：
- en: '![](img/Chapter_10_Table_2_01.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_10_Table_2_01.jpg)'
- en: There is a large number of standard query operators. Discussing every one of
    them is beyond the scope of this book. You should read the official documentation
    or additional resources to get familiar with all of them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 标准查询操作符的数量很大。讨论它们中的每一个超出了本书的范围。你应该阅读官方文档或其他资源，以熟悉它们所有。
- en: 'To familiarize ourselves more with LINQ, we will look at several examples.
    In the first example, we want to count the number of words in a sentence. We consider
    dot (`.`), comma (`,`), and space as delimiters. We split the string into parts,
    and then filter all those that are not empty and count them. With LINQ, this is
    as simple as doing the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更加熟悉LINQ，我们将看几个例子。在第一个例子中，我们想要计算句子中的单词数量。我们将句子以句号（`.`）、逗号（`,`）和空格作为分隔符。我们将字符串分割成部分，然后过滤掉所有非空的部分并计数它们。使用LINQ，这就像下面这样简单：
- en: '[PRE29]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, if we want to group all the words based on their length and print
    them to the console, the problem becomes a little bit more complicated. We need
    to create groups with the word length as the key and the word itself as the element,
    filter out the groups that have the length zero, and order the remaining in ascending
    order based on the word length:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要根据它们的长度对所有单词进行分组并将它们打印到控制台上，问题就变得有点复杂了。我们需要以单词长度为键创建分组，以单词本身为元素，过滤掉长度为零的分组，并根据单词长度按升序排序剩下的部分：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: While the previous query was executed when `Count()` was called, the execution
    of this query is deferred until we actually iterate over it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个查询在调用`Count()`时执行，而这个查询的执行被推迟到我们实际迭代它时。
- en: 'The examples we''ve looked at so far haven''t been too complicated. Using LINQ,
    however, you can build queries of higher complexity. To illustrate this, let''s
    consider a system that deals with orders for customers. The system works with
    entities such as `Customer`, `Article`, `OrderLine`, and `Order`, which, in a
    very simplistic form, are shown here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的例子并不是太复杂。然而，使用LINQ，你可以构建更复杂的查询。为了说明这一点，让我们考虑一个处理客户订单的系统。该系统使用`Customer`、`Article`、`OrderLine`和`Order`等实体，这里以非常简化的形式显示：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s also consider that we have sequences of these types, as follows (for
    simplicity, only a couple of records are shown for each type, but you can find
    the full example in the source code that accompanies this book):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也考虑一下我们有这些类型的序列，如下所示（为简单起见，每种类型只显示了一些记录，但你可以在本书附带的源代码中找到完整的例子）：
- en: '[PRE32]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The question we want to find the answer to is, *what are the names of all the
    articles that a particular customer has bought since a given day?* It can be cumbersome
    to write this using an imperative approach, but using LINQ, this can be expressed
    as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要找到答案的问题是，*一个特定客户自从某一天以来购买的所有文章的名称是什么？*使用命令式方法编写这个问题可能会很麻烦，但是使用LINQ，可以表达如下：
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, we joined the orders with order lines and customers and the
    order lines with articles and kept only the orders made after April 1, 2020 for
    the customer whose first name was John. Then, we ordered them lexicographically
    by the article name and selected only the article name to project.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将订单与订单行和客户进行了连接，并将订单行与文章进行了连接，并且只保留了2020年4月1日后由名为John的客户下的订单。然后，我们按文章名称的字典顺序对它们进行了排序，并只选择了文章名称进行投影。
- en: 'There are several `Join()` operations and the syntax may look harder to understand.
    Let''s explain it using the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个`Join()`操作，语法可能看起来更难理解。让我们使用以下例子来解释一下：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, `orders` is called the *outer sequence*, and `orderlines` is called the
    *inner sequence*. The second argument of `Join()`, which is `o => o.Id`, is called
    the *key selector for the outer sequence*. We use this to select the orders. The
    third argument of `Join()`, which is `ol => ol.OrderId`, is called the *key selector
    of the inner sequence*. We use this to select order lines.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`orders`被称为*外部序列*，`orderlines`被称为*内部序列*。`Join()`的第二个参数，即`o => o.Id`，被称为*外部序列的键选择器*。我们用它来选择订单。`Join()`的第三个参数，即`ol
    => ol.OrderId`，被称为*内部序列的键选择器*。我们用它来选择订单行。
- en: Basically, these two lambda expressions help matching order lines that have
    `OrderId` equal to an order ID. The last argument, `(o, ol) => new { Order = o,
    Line = ol }`, is the projection of the join operation. We are creating a new object
    with two properties called `Order` and `Line`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这两个lambda表达式帮助匹配具有`OrderId`等于订单ID的订单行。最后一个参数`(o, ol) => new { Order = o,
    Line = ol }`是连接操作的投影。我们正在创建一个具有名为`Order`和`Line`的两个属性的新对象。
- en: Some standard query operators are simpler to use, while others are more complicated
    and may require a bit of practice to comprehend well. However, for many of them,
    a simpler alternative exists—the LINQ query syntax, which we will explore in the
    next section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一些标准查询操作更容易使用，而其他一些可能更复杂，可能需要一些练习才能理解得很好。然而，对于其中许多操作，存在一个更简单的替代方案——LINQ查询语法，我们将在下一节中探讨。
- en: Query syntax
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询语法
- en: LINQ query syntax is basically syntactic sugar (that is, a simplified syntax
    designed to make things easier to write and understand) for the standard query
    operators. The compiler transforms queries written in query syntax into queries
    using the standard query operators. Query syntax is simpler and easier to read
    than the standard query operators, but they are semantically equivalent. However,
    as mentioned previously, not all the standard query operators have an equivalent
    in query syntax.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ查询语法基本上是标准查询操作的语法糖（即，设计成更容易编写和理解的简化语法）。编译器将使用查询语法编写的查询转换为使用标准查询操作的查询。查询语法比标准查询操作更简单、更易读，但它们在语义上是等价的。然而，正如前面提到的，不是所有的标准查询操作在查询语法中都有等价物。
- en: To see how the method syntax of the standard query operators and the query syntax
    compare, let's rewrite the examples from the previous section using query syntax.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到标准查询操作的方法语法和查询语法的比较，让我们使用查询语法重写上一节中的例子。
- en: 'First, let''s look at the problem where we counted the words in a piece of
    text. With query syntax, the query changes to the following. Notice that `Count()`
    does not have an equivalent in query syntax:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下在一段文本中计算单词数的问题。使用查询语法，查询变成了以下形式。请注意，`Count()`在查询语法中没有等价物：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The second problem, on the other hand, can be entirely written using query
    syntax, as shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，第二个问题可以完全使用查询语法来编写，如下所示：
- en: '[PRE36]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Printing the text is a little bit different. Words are displayed on a single
    line, separated by a comma. To compose the text of comma-separated words, we used
    the `string.Join()` static method, which takes a separator and a sequence of values
    and joins them into a single string. The output of this program is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 打印文本有点不同。单词以逗号分隔的形式显示在一行上。为了组成逗号分隔的单词文本，我们使用了`string.Join()`静态方法，它接受一个分隔符和一系列值，并将它们连接成一个字符串。这个程序的输出如下：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last problem that we will rewrite is the example with the customer orders.
    This query can be expressed very succinctly, as shown in the following code. This
    code resembles SQL and the `join` operations are definitely simpler to write,
    read, and understand:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重写的最后一个问题是与客户订单相关的例子。这个查询可以非常简洁地表达，如下面的代码所示。这段代码类似于SQL，`join`操作的写法确实更简单，更易读，更易理解：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see from these examples, LINQ helps build queries in a much simpler
    way than using traditional imperative programming. Data sources of different natures
    can be queried in a consistent way with a language that looks like SQL. Queries
    are strongly typed and are verified at compile time, which helps to solve many
    potential bugs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些例子中可以看出，LINQ帮助以比传统的命令式编程更简单的方式构建查询。不同性质的数据源可以以类似SQL的语言一致地进行查询。查询是强类型的，并且在编译时进行验证，这有助于解决许多潜在的错误。
- en: 'Now, let''s take a look at some more functional programming concepts: partial
    function application, currying, closures, monoids, and monads.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一些更多的函数式编程概念：部分函数应用、柯里化、闭包、幺半群和单子。
- en: More functional programming concepts
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多的函数式编程概念
- en: At the beginning of this chapter, we looked at general functional programming
    concepts, mainly higher-order functions and immutability. In this section, we
    will explore several more functional programming concepts and techniques—partial
    function application, currying, closures, monoids, and monads.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们看了一般的函数式编程概念，主要是高阶函数和不可变性。在本节中，我们将探讨几个更多的函数式编程概念和技术——部分函数应用、柯里化、闭包、幺半群和单子。
- en: Partial function application
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分函数应用
- en: Partial function application is the process of taking a function with *N parameters*
    and *one argument* and returning another function with *N-1 parameters* after
    fixing the argument into one of the function's parameters. It is, of course, possible
    that the invocation is done with more than just one argument, say, *M*, in which
    case the returned function will have *N-M* parameters.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数应用是将具有*N个参数*和*一个参数*的函数进行处理，并在将参数固定为函数的一个参数后返回具有*N-1个参数*的另一个函数的过程。当然，也可能会使用多个参数进行调用，比如*M*，在这种情况下返回的函数将具有*N-M*个参数。
- en: 'To understand how this works, let''s start with a function that has several
    parameters and is returning a string (containing the value of the arguments):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这是如何工作的，让我们从一个具有多个参数并返回一个字符串（包含参数值）的函数开始：
- en: '[PRE39]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we invoke this function as `AsString(42, 43.5, "44")`, the result is the
    string `"a=42, b=43.5, c=44"`. However, if we had a function (let''s call it `Apply()`)
    that would bind an argument to the first parameter of this function, then we could
    invoke it as follows with the same result:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个函数作为`AsString(42, 43.5, "44")`调用，结果将是字符串`"a=42, b=43.5, c=44"`。然而，如果我们有一个函数（让我们称之为`Apply()`）可以将一个参数绑定到这个函数的第一个参数，那么我们可以用相同的结果来调用它：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The implementation of such an `Apply()` function is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这样一个`Apply()`函数的方法如下：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This higher-order function takes another function and a value as parameters
    and returns another higher function with one parameter less. This function resolves
    to invoke the `f` argument function with the `arg` argument value and additional
    parameters.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个高阶函数接受另一个函数和一个值作为参数，并返回另一个参数少一个的高阶函数。这个函数解析为使用`f`参数函数和`arg`参数值以及其他参数。
- en: 'It is also possible that we continue this process of reducing functions to
    another function with one less parameter until we have a function with no parameters,
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能继续将函数减少到另一个参数少一个的函数，直到我们有一个没有参数的函数，如下所示：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'However, to make this possible, we need additional overloads of the `Apply()`
    function, with the appropriate number of arguments. For the case shown here, we
    need the following (in practice, if you have functions with more than three arguments,
    you need more overloads to account for all possible numbers of arguments):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要实现这一点，我们需要`Apply()`函数的额外重载，以及相应数量的参数。对于这里显示的情况，我们需要以下内容（实际上，如果你有超过三个参数的函数，你需要更多的重载来考虑所有可能的参数数量）：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, it is important to note that the actual invocation of the `AsString()`
    function only happens when all the arguments are supplied; that is, the moment
    we invoke `f3()`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，重要的是要注意，只有当所有参数都提供时，才会实际调用`AsString()`函数；也就是说，当我们调用`f3()`时。
- en: 'You may be wondering when partial function application is useful. The typical
    case is when you invoke a function several (or many) times and some arguments
    are the same. In this case, there are several alternatives, including the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道部分函数应用何时有用。典型情况是当你多次（或多次）调用一个函数，而一些参数是相同的。在这种情况下，有几种替代方案，包括以下几种：
- en: Provide defaults for the function parameters, when you define it. However, this
    might not be possible for different reasons. Perhaps the defaults only make sense
    in some context, or maybe you do not actually own the code, so you cannot provide
    them.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义函数时为函数参数提供默认值。然而，由于不同的原因，这可能是不可能的。也许默认值只在某些情况下有意义，或者你实际上并不拥有这段代码，所以无法提供默认值。
- en: In the class where you invoke the function multiple times, you can write a `helper`
    function with fewer arguments that invoke the function with the right defaults.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多次调用函数的类中，可以编写一个带有较少参数的`helper`函数，以使用正确的默认值调用函数。
- en: Partial function application may be (in many of these cases) the simpler solution
    to use.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数应用可能是（在许多情况下）更简单的解决方案。
- en: Currying
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化
- en: '**Currying** is the process of taking a function with *N* arguments and decomposing
    it into *N* functions that take *one* argument. This technique takes its name
    from the mathematician and logician Haskell Curry, after whom the functional programming
    language **Haskell** is also named.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**柯里化**是将具有*N*个参数的函数分解为*接受一个*参数的*N*个函数的过程。这种技术得名于数学家和逻辑学家Haskell Curry，函数式编程语言**Haskell**也是以他的名字命名的。'
- en: Currying enables working with functions that have multiple arguments in contexts
    where only functions with one argument could be used. An example of this is analytical
    techniques in mathematics that can only be applied to functions with a single
    argument.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化使得能够在只能使用一个参数的情况下使用具有多个参数的函数。数学中的分析技术就是一个例子，它只能应用于具有单个参数的函数。
- en: 'Considering the `AsString()` function from the previous section, currying this
    function would do the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上一节中的`AsString()`函数，对这个函数进行柯里化将会做如下操作：
- en: Return a function, `f1`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个函数`f1`。
- en: When invoked with an argument, `a`, it would return a function, `f2`.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用参数`a`调用时，它将返回一个函数`f2`。
- en: When invoked with an argument, `b`, it would return a function, `f3`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用参数`b`调用时，它将返回一个函数`f3`。
- en: When invoked with an argument, `c`, it would invoke `AsString(a, b, c)`.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用参数`c`调用时，它将调用`AsString(a, b, c)`。
- en: 'These, when put in code, would look as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些放入代码中，看起来如下：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The generic `Curry()` function seen here is similar to the `Apply()` function
    from the previous section. However, instead of returning a function with *N-1*
    arguments, it returns a function with a single argument:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里看到的通用`Curry()`函数类似于上一节中的`Apply()`函数。但是，它返回的不是具有*N-1*个参数的函数，而是具有一个参数的函数：
- en: '[PRE45]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This function can be used to curry functions with exactly three parameters.
    Should you need to do that with functions that have another number of parameters,
    then you need appropriate overloads for it (just as in the case of `Apply()`).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数可以用于柯里化具有三个参数的函数。如果你需要对具有其他参数数量的函数进行柯里化，那么你需要适当的重载（就像在`Apply()`的情况下一样）。
- en: 'You should note that you do not necessarily need to decompose the `AsString()`
    function three different times, as seen earlier with `f1`, `f2`, and `f3`. You
    can skip intermediate functions and achieve the same result by invoking the function
    appropriately, as shown in the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意，您不一定需要将`AsString()`函数分解为三个不同的函数，就像之前的`f1`，`f2`和`f3`一样。您可以跳过中间函数，并通过适当调用函数来实现相同的结果，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Another important concept in function programming is closures. We'll learn about
    closures in the next section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 函数编程中的另一个重要概念是闭包。我们将在下一节学习有关闭包的知识。
- en: Closures
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: '**Closures** are defined as a technique to implement lexically scoped name-binding
    in a language with first-class functions. Lexical or static scoping is the setting
    of the scope of a variable to the block in which it was defined, so it may only
    be referred to by its name from within that scope.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**闭包**被定义为在具有头等函数的语言中实现词法范围名称绑定的技术。词法或静态作用域是将变量的作用域设置为定义它的块，因此只能在该作用域内通过其名称引用它。'
- en: Information box
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 信息框
- en: Scopes in C# are called **static** or **lexical** and can be viewed at compile
    time. The opposite is *dynamic scopes*, which are only resolved at runtime, but
    these are not supported in C#.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的作用域称为**静态**或**词法**，可以在编译时查看。相反的是*动态作用域*，它只在运行时解析，但在C#中不支持这种作用域。
- en: As we saw earlier in this chapter, C# is a language that has first-class functions
    because you can assign functions to variables, pass them around, and invoke them.
    However, this definition of a closure is probably harder to comprehend, so we
    will explain it step by step using an example.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面看到的，C#是一种具有头等函数的语言，因为您可以将函数分配给变量，传递它们并调用它们。然而，这种对闭包的定义可能更难理解，因此我们将使用一个示例逐步解释它。
- en: 'Let''s consider the following example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we have a function called `Increment()` that is returning another function
    that increments its argument with a value. However, that value is neither passed
    as an argument to the lambda nor defined as a local variable in the lambda. Instead,
    it is captured from the outer scope. For this reason, the step variable is called
    a `step` variable in the scope of the lambda; if it's not found, it looks to the
    enclosing scope, which, in this case, is the `Increment()` function. If it wasn't
    there either, it would have looked further in the class scope, and so on.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为`Increment()`的函数，它返回另一个函数，该函数使用一个值递增其参数。然而，该值既不作为参数传递给lambda，也不在lambda中定义为局部变量。相反，它是从外部范围捕获的。因此，在lambda的范围内，step变量被称为`step`变量；如果在那里找不到它，它会查找封闭范围，这种情况下是`Increment()`函数。如果那里也找不到它，它将进一步查找类范围，依此类推。
- en: What happens next is that we assign the value returned from the `Increment()`
    function, which is another function, to the `inc` variable and then invoke it
    with the value `42`. The result is that the value `43` is printed to the console.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来发生的是，我们将从`Increment()`函数返回的值（另一个函数）分配给`inc`变量，然后使用值`42`调用它。结果是将值`43`打印到控制台。
- en: The question is, *how does this work?* The `step` variable is actually a local
    function variable and should go out of scope as soon as `Increment()` is called.
    Yet, its value is known at the time of invoking the function returned from `Increment()`.
    This is because the lambda expression, `x => x + step`, is said to *close* over
    the free variable, `step`, thus defining a closure. Both the lambda expression
    and `step` are passed together (as part of the closure) so that the variable that
    would normally go out of scope still lives at the time the closure is invoked.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，*这是如何工作的？* `step`变量实际上是一个局部函数变量，应该在调用`Increment()`后立即超出范围。然而，在调用从`Increment()`返回的函数时，它的值是已知的。这是因为lambda表达式`x
    => x + step`被认为是*闭合*在自由变量`step`上，从而定义了一个闭包。lambda表达式和`step`一起传递（作为闭包的一部分），以便变量通常会超出范围，但在调用闭包时仍然存在。
- en: 'Closures are used all the time without us even realizing it. Consider the following
    example, where we have a list of engines and we want to search for an engine with
    minimum power and capacity. You would typically write something as follows using
    a lambda expression:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包经常被使用，而我们甚至没有意识到。考虑以下示例，我们有一个引擎列表，我们想要搜索具有最小功率和容量的引擎。您通常会使用lambda表达式编写如下内容：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'But this is actually creating a closure because the lambda closes over the
    `minp` and `minc` free variables. Without support for closure in the language,
    it would be cumbersome to write code that does the same. You would basically have
    to write a class that is capturing the value of these variables and has a method
    that takes an `Engine` object and compares its properties to these values. In
    this case, the code could look as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但这实际上创建了一个闭包，因为lambda闭合了`minp`和`minc`自由变量。如果语言不支持闭包，编写相同功能的代码将会很麻烦。你基本上需要编写一个捕获这些变量值的类，并且有一个方法，该方法接受一个`Engine`对象并将其属性与这些值进行比较。在这种情况下，代码可能如下所示：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This is quite similar to what the compiler does when encountering a closure,
    but it's the kind of detail you do not have to concern yourself with.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这与编译器在遇到闭包时所做的事情非常相似，但这是你不必担心的细节。
- en: 'You should also notice that the free variables that are captured by a lambda
    in a closure can change value. We exemplify this with the following sample where
    the `GetNextId()` function defines a closure that increments the value of the
    captured free variable, `id`, with each call:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该注意，lambda中捕获的自由变量的值可以改变。我们通过以下示例来说明这一点，其中`GetNextId()`函数定义了一个闭包，该闭包在每次调用时递增捕获的自由变量`id`的值：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We'll learn about monoids in the next section.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节学习有关单子的知识。
- en: Monoids
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单子
- en: A **monoid** is an algebraic structure with a single associative binary operation
    and an identity element. Any C# type that has those two elements is a monoid.
    Monoids are useful for defining concepts and reusing code. They help us build
    complex behavior out of simple components without the need to introduce new concepts
    in our code. Let's look at how we can create and use monoids in C#.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**单子**是一种具有单一可结合二元操作和单位元的代数结构。任何具有这两个元素的C#类型都是单子。单子对于定义概念和重用代码非常有用。它们帮助我们从简单的组件构建复杂的行为，而无需在我们的代码中引入新的概念。让我们看看如何在C#中创建和使用单子。'
- en: 'We could define a generic interface in C# to represent a monoid as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在C#中定义一个通用接口来表示单子，如下所示：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The monoid ensures associativity and left and right identity so that for any
    values, `a`, `b`, and `c`, we have the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 单子确保结合性和左右单位性，以便对于任何值`a`、`b`和`c`，我们有以下内容：
- en: '`Combine((Combine(a, b), c) == Combine(a, Combine(b, c))`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Combine((Combine(a, b), c) == Combine(a, Combine(b, c))`'
- en: '`Combine(Identify, a) == a`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Combine(Identify, a) == a`'
- en: '`Combine(a, Identity) == a`'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Combine(a, Identity) == a`'
- en: 'Concatenating strings or a list is an example of an associative binary operation.
    A type that provides that function, together with an identity element (an empty
    string or an empty list in these cases), is a monoid. So, we can actually implement
    these in C# as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串或列表是一个可结合的二元操作的例子。提供该函数的类型，以及一个单位元（在这些情况下是一个空字符串或一个空列表），就是一个单子。因此，我们实际上可以在C#中实现这些功能，如下所示：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Both `ConcatList` and `ConcatString` are examples of monoids. The latter could
    be used as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcatList`和`ConcatString`都是单子的例子。后者可以如下使用：'
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This would print `Learning C# 8` to the console. However, this code is a little
    bit cumbersome to use. We can simplify it by creating a helper class with a static
    method called `Concat()` that takes a monoid and a sequence of elements and combines
    them together using the monoids binary operation and its identity for the initial
    value:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台上打印`Learning C# 8`。然而，这段代码有点繁琐。我们可以通过创建一个带有静态方法`Concat()`的辅助类来简化它，该方法接受一个单子和一系列元素，并使用单子的二元操作和其初始值的单位元将它们组合在一起：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Having this helper class available, we can write the following simplified code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个辅助类，我们可以编写以下简化的代码：
- en: '[PRE55]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the first part of this example, we concatenated a list of strings into a
    single string and printed it to the console. In the second part, we concatenated
    a list of lists of integers into a single list of integers, which are later also
    printed to the console.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子的第一部分中，我们将一系列字符串连接成一个单一的字符串并打印到控制台。在第二部分中，我们将一系列整数的列表连接成一个单一的整数列表，然后也打印到控制台。
- en: In the next section, we'll take a look at monads.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将看看单子。
- en: Monads
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单子
- en: This is a concept that is usually harder to explain and, perhaps, also harder
    to understand, although a lot of literature has been written about it. In this
    book, we will try to explain it in simple terms, but we recommend that you read
    additional resources.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是一个更难解释，也许更难理解的概念，尽管已经有很多文献写过它。在这本书中，我们将尝试用简单的术语来解释它，但我们建议您阅读其他资源。
- en: In a few words, a monad is a container that encapsulates some functionality
    on top of the value that it wraps. We often work with monads in C# without realizing
    it. `Nullable<T>` is a monad that defines a special functionality that is *nullability*,
    which means a value may be present or not. `Task<T>` with `await` is a monad that
    defines a special functionality that is *asynchronicity*, which means a value
    can be used before it's actually computed. `IEnumerable<T>` with the LINQ query
    `SelectMany()` operator is also a monad.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，单子是一个封装了一些功能的容器，它包裹在它的值之上。我们经常在C#中使用单子而没有意识到。`Nullable<T>`是一个定义了特殊功能的单子，即*可空性*，这意味着一个值可能存在，也可能不存在。带有`await`的`Task<T>`是一个定义了特殊功能的单子，即*异步性*，这意味着一个值可以在实际计算之前被使用。带有LINQ查询`SelectMany()`操作符的`IEnumerable<T>`也是一个单子。
- en: 'A monad has two operations:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 单子有两个操作：
- en: One that *transforms* a value, `v`, into a container that wraps it (`v -> C(v)`).
    In functional programming, this function is called **return**.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将值`v`转换为包装它的容器（`v -> C(v)`）的函数。在函数式编程中，这个函数被称为**return**。
- en: One that *flattens* two containers into a single container (`C(C(v)) -> C(v)`).
    In functional programming, this is called **bind**.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将两个容器扁平化为一个单一容器的函数（`C(C(v)) -> C(v)`）。在函数式编程中，这被称为**bind**。
- en: 'Let''s look at the following example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, `numbers` is an array of arrays of integers. `SelectMany()` is used to
    select subsequences of odd numbers. However, this flattens the result into `IEnumerable<int>`
    instead of `IEnumerable<IEnumerable<int>>`. As we mentioned earlier, `IEnumerable<T>`
    with `SelectMany()` is a monad.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`numbers`是一个整数数组的数组。`SelectMany()`用于选择奇数的子序列。然而，这将结果扁平化为`IEnumerable<int>`而不是`IEnumerable<IEnumerable<int>>`。正如我们之前提到的，带有`SelectMany()`的`IEnumerable<T>`是一个单子。
- en: 'But how can you implement a monad in C#? The simplest form is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你如何在C#中实现一个单子呢？最简单的形式如下：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is actually called the `x => x`, you will get the initial monad back:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上被称为`x => x`，你将得到初始单子：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Another example of how this monad can be used is shown in the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单子如何使用的另一个例子在下面的代码中展示：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this example, `m` is a monad that wraps the integer value `21`. We bind with
    a function that returns a new monad that has a value that is double the initial
    one. We can again bind on this monad with a function that transforms the integer
    into a string.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`m`是一个包装整数值`21`的单子。我们使用一个返回新单子的函数进行绑定，该单子的值是初始值的两倍。我们可以再次使用一个将整数转换为字符串的函数对这个单子进行绑定。
- en: From this example, you can see that those binding operations can be chained
    together. This is what fluent interfaces provide—a mechanism to write code that
    looks like written prose by chaining methods. This can be further exemplified
    using the following example—given a system where a business has customers, customers
    place orders, and an order can contain one or more articles, you are required
    to find all the distinct articles bought by all the customers of a particular
    business.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，你可以看到这些绑定操作可以链接在一起。这就是流畅接口提供的功能——通过链接方法来编写类似书面散文的代码。这可以通过以下示例进一步说明——假设一个企业有客户，客户下订单，订单可以包含一个或多个商品，你需要找出一个特定企业所有客户购买的所有不同商品。
- en: 'For simplicity, let''s consider the following classes:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，让我们考虑以下类：
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In a typical imperative style, you could implement the solution as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的命令式风格中，你可以按照以下方式实现解决方案：
- en: '[PRE61]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'However, this can be simplified more by using LINQ and the `IEnumerable<T>`
    and `SelectMany()` monad. The functional programming style implementation could
    look as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过使用LINQ和“IEnumerable<T>”和“SelectMany（）”单子，这可以更简化。函数式编程风格的实现可能如下所示：
- en: '[PRE62]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This uses the fluent interface pattern and the result is more concise code that
    is also simpler to understand.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了流畅接口模式，结果是更简洁的代码，也更容易理解。
- en: Summary
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter was a departure from the imperative programming traits of C# since
    we explored functional programming concepts and techniques built into the language.
    We looked at higher-order functions, lambda expressions, partial function applications,
    currying, closures, monoids, and monads. We also had an introduction to LINQ with
    its two flavors: the method syntax and the query syntax. Most of these topics
    are complex and more advanced than the proposed scope of this book. Therefore,
    we recommend that you use other resources in order to master them.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是对C#命令式编程特性的一次离开，因为我们探讨了内置到语言中的函数式编程概念和技术。我们研究了高阶函数、lambda表达式、部分函数应用、柯里化、闭包、幺半群和单子。我们还介绍了LINQ及其两种风格：方法语法和查询语法。这些大多数主题都比本书的建议范围复杂和更高级。因此，我们建议您使用其他资源来掌握它们。
- en: In the next chapter, we will look at the reflection services that are available
    with .NET and the dynamic programming capabilities of C#.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究.NET中可用的反射服务以及C#的动态编程能力。
- en: Test what you learned
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你学到了什么
- en: What are the main characteristics of functional programming? What advantages
    does it provide?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程的主要特征是什么？它提供了什么优势？
- en: What is a higher-order function?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是高阶函数？
- en: What makes functions first-class citizens in the C# language?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是什么让函数在C#语言中成为一等公民？
- en: What is a lambda expression? What is the syntax for writing lambda expressions?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是lambda表达式？写lambda表达式的语法是什么？
- en: What are the rules that apply to variables' scope in lambda expressions?
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: lambda表达式中变量作用域适用的规则是什么？
- en: What is LINQ? What are the standard query operators and what is the query syntax?
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是LINQ？标准查询操作符是什么？查询语法是什么？
- en: What is the difference between `Select()` and `SelectMany()`?
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Select（）”和“SelectMany（）”之间有什么区别？
- en: What is a partial function application and how does it differ from currying?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是部分函数应用，它与柯里化有什么不同？
- en: What is a monoid?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是幺半群？
- en: What is a monad?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是单子？
