- en: Ensuring Purity - Immutability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保纯度-不可变性
- en: 'In [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml), *Behaving Properly
    - Pure Functions*, when we considered pure functions and their advantages, we
    saw that side-effects such as modifying a received argument or a global variable
    were frequent causes for impurity. Now, after several chapters dealing with many
    aspects and tools of FP, let''s get to the concept of *immutability*: how to work
    with objects in such a way that accidentally modifying them will become harder
    or, even better, impossible.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml)的*行为良好-纯函数*中，当我们考虑纯函数及其优点时，我们看到修改接收到的参数或全局变量等副作用经常导致不纯。现在，在处理FP的许多方面和工具的几章之后，让我们来看看*不可变性*的概念：如何以这样一种方式处理对象，使得意外修改它们变得更加困难，甚至更好的是不可能。
- en: 'We cannot force developers to work in a safe, guarded way, but if we find some
    way to make data structures immutable (meaning that they cannot be directly changed,
    except through some interface that never allows modifying the original data, but
    produces new objects instead) then we''ll have an enforceable solution. In this
    chapter, we will see two distinct approaches to working with such immutable objects
    and data structures:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法强迫开发人员以安全、受保护的方式工作，但如果我们找到某种方法使数据结构不可变（意味着除了通过一些永远不允许修改原始数据但产生新对象的接口之外，它们不能直接更改），那么我们将有一个可执行的解决方案。在本章中，我们将看到两种处理这种不可变对象和数据结构的不同方法：
- en: Basic JS ways, such as freezing objects, plus cloning to create new ones instead
    of modifying existing objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的JS方法，如冻结对象，以及克隆来创建新对象，而不是修改现有对象
- en: Persistent data structures, with methods that allow updating them without changing
    the original and without the need to clone everything either, for higher performance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久数据结构，具有允许更新它们而不更改原始数据且无需克隆所有内容的方法，以获得更高的性能
- en: 'A warning: the code in this chapter isn''t production-ready; I wanted to focus
    on the main points and not on all the myriad details having to do with properties,
    getters, setters, prototypes, and more, that you should take into account for
    a full, bulletproof, solution. For actual development, I''d very much recommend
    going with a third-party library, but only after checking that it really applies
    to your situation. We''ll be recommending several such libraries, but of course
    there are many more that you could use.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：本章中的代码不适合生产；我想专注于主要观点，而不是所有与属性、getter、setter、原型等有关的无数细节，这些细节应该考虑到一个完整、牢固的解决方案。对于实际开发，我非常建议使用第三方库，但在确认它确实适用于您的情况之后。我们将推荐几个这样的库，但当然还有许多其他库可供使用。
- en: The straightforward JS way
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接的JS方式
- en: One of the biggest causes of side-effects was the possibility of a function
    modifying either global objects or its arguments themselves. All non-primitive
    objects are passed as references, so when/if you modify them, the original objects
    will be changed. If we want to stop this (without just depending on the goodwill
    and clean coding of our developers) we may want to consider some straightforward
    JS techniques to disallow those side-effects.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用的最大原因之一是函数可能修改全局对象或其参数本身。所有非原始对象都作为引用传递，因此当/如果您修改它们时，原始对象将被更改。如果我们想要阻止这种情况（而不仅仅依赖开发人员的善意和清洁编码），我们可能需要考虑一些直接的JS技术来禁止这些副作用。
- en: Mutator functions
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改器函数
- en: A common source of unexpected problems comes from the fact that several JS methods
    actually modify the underlying object. In this case, by merely using them, you
    will be causing a side-effect, which you may even not recognize. Arrays are the
    basic source of problems and the list of troublesome methods is not short. (See
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods)
    for more on each method.)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 意外问题的一个常见来源是几个JS方法实际上修改了底层对象。在这种情况下，仅仅使用它们就会导致副作用，甚至您可能都意识不到。数组是问题的基本来源，令人头痛的方法列表并不短。（有关每种方法的更多信息，请参见[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods)。）
- en: '`.copyWithin()` lets you copy elements within the array'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.copyWithin()` 允许您在数组内复制元素'
- en: '`.fill()` fills an array with a given value'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.fill()` 用给定值填充数组'
- en: '`.push()` and `.pop()` let you add or delete elements at the end of an array'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.push()` 和 `.pop()` 允许您在数组末尾添加或删除元素'
- en: '`.shift()` and `.unshift()` work the same way, but at the beginning of the
    array'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.shift()` 和 `.unshift()` 以相同的方式工作，但在数组的开头'
- en: '`.splice()` lets you add or delete elements anywhere within the array'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.splice()` 允许您在数组中的任何位置添加或删除元素'
- en: '`.reverse()` and `.sort()` modify the array in place, reversing its elements
    or ordering them'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.reverse()` 和 `.sort()` 在原地修改数组，颠倒其元素或对其进行排序'
- en: 'For some of these operations, you might generate a copy of the array and then
    work with that. In the *Argument mutation* section of [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml),
    *Behaving Properly - Pure Functions*, we did just that with the spread operator;
    we could have used `.slice()` as well:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其中一些操作，您可能会生成数组的副本，然后使用它。在[第4章](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml)的*参数突变*部分，*行为良好-纯函数*，我们就是用了展开运算符；我们也可以使用`.slice()`：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Setter methods are also mutators and will logically produce side-effects because
    they can do just about anything. If this is the case, you'll have to go for some
    of the other solutions described later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Setter方法也是修改器，逻辑上会产生副作用，因为它们可以做任何事情。如果是这种情况，您将不得不选择稍后描述的其他解决方案之一。
- en: Constants
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: If the mutations do not happen because of using some JS methods, then we might
    want to attempt using `const` definitions, but that just won't work. In JS, a
    const definition means only that the *reference* to the object or array cannot
    change (so you cannot assign a different object to it) but you can still modify
    the properties of the object itself.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果突变不是因为使用某些JS方法而发生的，那么我们可能希望尝试使用`const`定义，但那只是行不通的。在JS中，const定义只意味着对象或数组的*引用*不能更改（因此您不能将不同的对象分配给它），但您仍然可以修改对象本身的属性。
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, if you decide to use `const` everywhere, you will be safe only against direct
    assignments to objects and arrays. More modest side-effects, such as changing
    an attribute or an array element, will still be possible, so this is not a solution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您决定在任何地方都使用`const`，那么您只能安全地防止对对象和数组的直接赋值。更为温和的副作用，例如更改属性或数组元素，仍然是可能的，因此这不是一个解决方案。
- en: What can work is using *freezing* to provide un-modifiable structures and *cloning*
    to produce modified new ones. These are probably not the best way to go about
    forbidding objects to be changed but can be used as a makeshift solution. Let's
    go with both of them in some detail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可以工作的是使用*冻结*来提供不可修改的结构和*克隆*来生成修改后的新结构。这可能不是禁止对象被更改的最佳方法，但可以用作权宜之计。让我们详细讨论一下这两种方法。
- en: Freezing
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冻结
- en: If we want to avoid the possibility of a programmer accidentally or willingly
    modifying an object, freezing it is a valid solution. After an object has been
    frozen, any attempts at modifying it will silently fail.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要避免程序员意外或故意修改对象的可能性，冻结它是一个有效的解决方案。在对象被冻结之后，任何修改它的尝试都将悄无声息地失败。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Don''t confuse freezing with sealing: `Object.seal()`, applied to an object,
    prohibits adding or deleting properties to it, so the structure of the object
    is immutable, but the attributes themselves can be changed. `Object.freeze()`
    includes not only sealing properties but also making them unchangeable. See [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/seal](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)
    and [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)
    for more on this.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将冻结与密封混淆：`Object.seal()`应用于对象，禁止向其添加或删除属性，因此对象的结构是不可变的，但属性本身可以更改。`Object.freeze()`不仅包括密封属性，还使它们不可更改。有关更多信息，请参阅[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/seal](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)和[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)。
- en: 'There is only one problem with this solution: freezing an object is a *shallow*
    operation, that freezes the attributes themselves similarly to what a `const`
    declaration does. If any of the attributes are objects or arrays themselves, with
    further objects or arrays as properties, and so on, they can still be modified.
    We will only be considering data here; you may also want to freeze, say, functions,
    but for most use cases it''s data you want to protect.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案只有一个问题：冻结对象是一个*浅*操作，它类似于`const`声明，冻结属性本身。如果任何属性本身是对象或数组，并且具有进一步的对象或数组作为属性，依此类推，它们仍然可以被修改。在这里我们只考虑数据；您可能还想要冻结函数，但对于大多数用例，您想要保护的是数据。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is only partially successful, as we can see:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是部分成功，如我们所见：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we want to achieve real immutability for our object, we need to write a
    routine that will freeze all the levels of an object. Fortunately, it''s easy
    to achieve that by applying recursion. Mainly, the idea is to first freeze the
    object itself and then recursively freeze each of its properties. We must take
    care we only freeze the object''s own properties; we shouldn''t mess with the
    prototype of the object, for example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要实现对象的真正不可变性，我们需要编写一个冻结对象所有级别的例程。幸运的是，通过递归很容易实现这一点。主要的想法是首先冻结对象本身，然后递归地冻结其每个属性。我们必须确保只冻结对象自己的属性；例如，我们不应该干扰对象的原型：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that, in the same way as `Object.freeze()` works, `deepFreeze()` also freezes
    the object *in place*. I wanted to keep the original semantics of the operation,
    so the returned object will always be the original one. If we wanted to work in
    a purer fashion, we should first make a copy of the original object (we'll be
    seeing how to do this in the next section) and then freeze that.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与`Object.freeze()`的工作方式相同，`deepFreeze()`也会*原地*冻结对象。我希望保持操作的原始语义，因此返回的对象将始终是原始对象。如果我们想以更纯粹的方式工作，我们应该首先复制原始对象（我们将在下一节中看到如何做到这一点），然后再冻结它。
- en: 'There remains a small possible problem, but with a very bad result: what would
    happen if an object included, somewhere down there, a reference to itself? We
    can avoid that if we skip freezing already frozen objects: backward circular references
    would then be ignored since objects they refer to would be already frozen. So,
    the logic we wrote took care of that problem and there''s nothing more to be done!'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然存在一个小的可能问题，但结果非常糟糕：如果对象包含对自身的引用，那么会发生什么？如果我们跳过已经冻结的对象进行冻结，我们可以避免这种情况：因为对象所引用的对象已经被冻结，所以会忽略向后的循环引用。因此，我们编写的逻辑已经解决了这个问题，没有更多需要做的了！
- en: 'If we apply `deepFreeze()` to an object, we can safely pass it to any function,
    knowing that there simply is no way in which it can be modified. You can also
    use this property to test whether a function modifies its arguments: deep freeze
    them, call the function, and if the function depends on modifying its arguments,
    it will not work, because the changes will be silently ignored. But, then, how
    can we return a result from a function, if it involves a received object? This
    can be solved in many ways, and a simple one uses cloning, as we''ll see.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对一个对象应用`deepFreeze()`，我们可以安全地将其传递给任何函数，知道它根本不可能被修改。您还可以使用此属性来测试函数是否修改其参数：深度冻结它们，调用函数，如果函数依赖于修改其参数，它将无法工作，因为更改将被悄悄忽略。但是，那么，我们如何从函数中返回结果，如果它涉及到一个接收到的对象？这可以通过许多方式解决，一个简单的方法使用克隆，我们将看到。
- en: Check the *Questions* section at the end of this chapter, for another way of
    freezing an object by means of proxies.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章末尾的*问题*部分中，查看另一种通过代理冻结对象的方式。
- en: Cloning and mutating
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆和变异。
- en: If mutating an object isn't allowed, then you must create a new object. For
    example, if you use Redux, a reducer is a function that receives the current state
    and an action (essentially, an object with new data) and produces the new state.
    Modifying the current state is totally forbidden and we could avoid this error
    by always working with frozen objects, as we saw in the previous section. Then,
    in order to fulfill the reducer requirements, we will have to be able to clone
    the original state, plus mutate it accordingly to the received action, and that
    resulting object will then become the new state.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不允许改变对象，则必须创建一个新对象。例如，如果你使用Redux，reducer是一个函数，它接收当前状态和一个动作（本质上是一个带有新数据的对象），并产生新状态。修改当前状态是完全禁止的，我们可以通过始终使用冻结对象来避免这种错误，就像我们在前一节中看到的那样。因此，为了满足reducer的要求，我们将需要能够克隆原始状态，然后根据接收到的动作进行相应的改变，然后得到的对象将成为新状态。
- en: You may want to revisit the *More general looping* section of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),
    *Programming Declaratively - A Better Style*, where we wrote a basic `objCopy()`
    function that provides a different approach from the one shown here.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望重新查看[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)的*更一般的循环*部分，即*声明式编程
    - 更好的风格*，在那里我们编写了一个基本的`objCopy()`函数，提供了与此处所示的不同方法。
- en: 'To round things off, we should also freeze the returned object, as we did with
    the original state. But let''s start at the beginning: how do we clone an object?
    Of course, you can always do it by hand, but that''s not something you''d really
    want to consider when working with large, complex objects.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还应该冻结返回的对象，就像我们对原始状态做的那样。但让我们从头开始：我们如何克隆一个对象？当然，你总是可以手工做，但当处理大型复杂对象时，这不是你真正想考虑的事情。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, going for more automatic solutions, there are a couple of straightforward
    ways of copying arrays or objects in JS, but they have the same *shallowness*
    problem.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，寻找更自动化的解决方案，有几种简单的JS数组或对象复制方式，但它们都有相同的*浅显性*问题。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If an object or array includes objects (which may themselves include objects,
    and so on) we get the same problem as with freezing: objects are copied by reference,
    which means that a change in the new object will also imply changing the old object.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个对象或数组包含对象（它们自己可能包含对象，依此类推），我们会遇到与冻结相同的问题：对象是通过引用复制的，这意味着新对象的更改也将意味着更改旧对象。
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There is a simple solution, based on JSON. If we `stringify()` the original
    object and then `parse()` the result, we'll get a new object but its totally separate
    from the old one.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单的解决方案，基于JSON。如果我们`stringify()`原始对象，然后`parse()`结果，我们将得到一个新对象，但它与旧对象完全分离。
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This works with both arrays and objects, but there''s a problem, anyway. If
    any of the properties of the object have a constructor, it won''t get invoked:
    the result will always be composed of plain JS objects. We can see this very simply
    with a `Date()`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于数组和对象，但无论如何都存在一个问题。如果对象的任何属性具有构造函数，它将不会被调用：结果将始终由普通JS对象组成。我们可以通过`Date()`非常简单地看到这一点。
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We could do a recursive solution, as with deep freezing, and the logic is quite
    similar. Whenever we find a property that is really an object, we invoke the appropriate
    constructor.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用递归解决方案，就像深度冻结一样，逻辑是相当相似的。每当我们发现一个真正是对象的属性时，我们调用适当的构造函数。
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This solves the problem we found with dates or, in fact, with any object! If
    we run the code above, but using `deepCopy()` instead of `jsonCopy()`, we'll get
    `object object` as output, as it should be. If we check types and constructors,
    everything will match. Furthermore, the data changing experiment will also work
    fine now.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了我们在日期或者实际上任何对象中发现的问题！如果我们运行上面的代码，但使用`deepCopy()`而不是`jsonCopy()`，我们将得到`object
    object`作为输出，这正是应该的。如果我们检查类型和构造函数，一切都将匹配。此外，数据更改实验现在也将正常工作。
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that we know how to copy an object, we can work in this way:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何复制一个对象，我们可以这样工作：
- en: Receive a (frozen) object as an argument.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收一个（冻结的）对象作为参数。
- en: Make a copy of it, which won't be frozen.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作一个不会被冻结的副本。
- en: Take values from that copy, to use in your code.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从该副本中获取值，以在您的代码中使用。
- en: Modify the copy at will.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随意修改副本。
- en: Freeze it.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冻结它。
- en: Return it as the result of the function.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其作为函数的结果返回。
- en: All of this is viable, though a bit cumbersome. So, let's add a couple of functions
    that will help bring everything together.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有些麻烦，但所有这些都是可行的。因此，让我们添加一些函数，帮助将所有内容整合在一起。
- en: Getters and setters
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: Doing all the work we listed at the end of the previous section, every time
    you want to update a field, would probably become troublesome, and prone to errors.
    Let's add a pair of functions to be able to get values from a frozen object, but
    unfreezing them so they become usable by you, and to allow modifying any property
    of the object, creating a new copy of it, so the original won't be actually modified.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节末尾列出的所有工作中，每次你想要更新一个字段，都会变得麻烦，并容易出错。让我们添加一对函数，以便能够从冻结的对象中获取值，但解冻它们以便你可以使用，并允许修改对象的任何属性，创建它的新副本，这样原始对象就不会被实际修改。
- en: Getting a property
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取属性
- en: Back in the *Getting a property from an object* section in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*, we wrote a simple `getField()`
    function that could handle getting a single attribute out of an object.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中的*从对象中获取属性*部分，*生成函数 - 高阶函数*，我们编写了一个简单的`getField()`函数，可以处理从对象中获取单个属性。
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We could get a deep attribute out of an object by composing a series of applications
    of `getField()`calls, but that would be rather cumbersome. Rather, let's have
    a function that will receive a *path* -an array of field names- and will return
    the corresponding part of the object, or will be undefined if the path doesn't
    exist. Using recursion is quite appropriate and simplifies coding!
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过组合一系列`getField()`调用来从对象中获取深层属性，但这样做会相当麻烦。相反，让我们编写一个函数，它将接收一个*路径* - 一个字段名称的数组
    - 并返回对象的相应部分，如果路径不存在则返回undefined。使用递归非常合适，简化了编码！
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once an object has been frozen, you cannot *defrost* it, so we must resort
    to making a new copy of it; `deepCopy()` is quite appropriate for that. Let''s
    try out our new function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对象被冻结，就无法*解冻*它，所以我们必须求助于制作它的新副本；`deepCopy()`非常适合这个任务。让我们尝试一下我们的新函数：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can also check that returned objects are not frozen.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检查返回的对象是否被冻结。
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Setting a property by path
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按路径设置属性
- en: Now that we wrote this, we can code a similar `setByPath()` function that will
    take a path, a value, and an object, and update an object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们写了这个，我们可以编写一个类似的`setByPath()`函数，它将接受一个路径、一个值和一个对象，并更新一个对象。
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are using recursion here to get into the object, creating new attributes
    if needed, until we have traveled the full length of the path. One important detail,
    when creating attributes, is whether we need an array or an object. We can determine
    that by checking the next element in the path: if it''s a number, then we need
    an array; otherwise, an object will do. When we get to the end of the path, we
    simply assign the new given value.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用递归来进入对象，如果需要的话创建新属性，直到我们遍历完路径的全部长度。一个重要的细节是，在创建属性时，我们是否需要一个数组还是一个对象。我们可以通过检查路径中的下一个元素来确定：如果它是一个数字，那么我们需要一个数组；否则，一个对象就可以了。当我们到达路径的末尾时，我们简单地赋予新给定的值。
- en: If you like this way of doing things, you should check out the *seamless-immutable*
    library, which works exactly in this fashion. The *seamless* part of the name
    alludes to the fact that you still work with normal objects, albeit frozen!, so
    you can use `.map()`, `.reduce()`, and so on. Read more about it at [https://github.com/rtfeldman/seamless-immutable](https://github.com/rtfeldman/seamless-immutable).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢这种做事情的方式，你应该看看*seamless-immutable*库，它正是以这种方式工作。名称中的*seamless*部分指的是你仍然可以使用正常的对象，尽管是冻结的！所以你可以使用`.map()`、`.reduce()`等方法。在[https://github.com/rtfeldman/seamless-immutable](https://github.com/rtfeldman/seamless-immutable)了解更多。
- en: We can then write a function that will be able to take a frozen object and update
    an attribute within it, returning a new, also frozen, object.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以编写一个函数，它将能够接受一个冻结的对象，并更新其中的属性，返回一个新的，同样被冻结的对象。
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can check out how it works: let''s run several updates on the `myObj3` object
    we have been using.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看看它是如何工作的：让我们对我们一直在使用的`myObj3`对象运行几次更新。
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Given this pair of functions, we have finally gotten ourselves a way to keep
    immutability:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一对函数，我们终于找到了保持不可变性的方法：
- en: Objects must be frozen from the beginning
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象必须从一开始就被冻结
- en: Getting data from objects is done with `getByPath()`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从对象中获取数据是通过`getByPath()`完成的
- en: Setting data is done with `updateObject()`, which internally uses ``setByPath()``
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`updateObject()`来设置数据，它在内部使用`setByPath()`
- en: 'If you want to see another way of using setters and getters to accomplish functional
    access and updates to objects, check out lenses, provided by libraries such as
    Ramda. Lenses can be seen as a functional way of not only getting and setting
    variables, but also running functions over them, in a composable way: a *something*
    that lets you focus on a specific part of a data structure, access it, and possibly
    also change it or apply functions to it. Check out more starting at [http://ramdajs.com/docs/#lens.](http://ramdajs.com/docs/#lens.)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想看另一种使用setter和getter来实现对对象的功能访问和更新的方法，请查看lenses，它由Ramda等库提供。Lenses可以被看作是一种功能性的方式，不仅可以获取和设置变量，还可以以可组合的方式对其运行函数：一种*某物*，让你专注于数据结构的特定部分，访问它，并可能也改变它或对其应用函数。从[http://ramdajs.com/docs/#lens.](http://ramdajs.com/docs/#lens.)开始了解更多。
- en: Persistent data structures
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久数据结构
- en: If every time you want to change something in a data structure, you just go
    and change it, your code will be full of side-effects. On the other hand, copying
    complete structures every time is a waste of time and space. There's a middle
    way, with persistent data structures, which, if handled correctly, let you apply
    changes while creating new structures, in an efficient way.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每次你想要改变数据结构中的某些东西，你都去改变它，你的代码将充满副作用。另一方面，每次复制完整的结构都是浪费时间和空间。有一种中间方法，使用持久数据结构，如果处理正确，可以让你在创建新结构的同时应用更改，以一种高效的方式。
- en: Working with lists
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列表
- en: 'Let''s consider a simple procedure: suppose you have a list, and you want to
    add a new element to it. How would you do it? We can assume each node is a `NodeList`
    object.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的过程：假设你有一个列表，你想要向其中添加一个新元素。你会怎么做？我们可以假设每个节点都是一个`NodeList`对象。
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A possible list would be as follows, where a `list` variable would point to
    the first element. See figure 10.1:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的列表如下，其中`list`变量将指向第一个元素。见图10.1：
- en: '![](assets/6de96866-8506-4eae-9ad7-54d464e40287.jpg)Figure 10.1\. The initial
    list. (Can you tell what is missing in this list, and where?)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6de96866-8506-4eae-9ad7-54d464e40287.jpg)图10.1。初始列表。（你能告诉这个列表缺少什么，以及缺少的部分在哪里吗？）'
- en: 'If you wanted to add D between B and F (this is something musicians will understand:
    we have here the *Circle of Thirds*, but D is missing) the simplest solution would
    be to just add a new node and change an existing one, to get the following result.
    See figure 10.2:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在B和F之间添加D（这是音乐家会理解的：我们这里有“三度圈”，但缺少了D），最简单的解决方案就是添加一个新节点并更改一个现有节点，得到以下结果。见图10.2：
- en: '![](assets/ba086145-a541-4238-9230-c876d1014ef7.jpg)Figure 10.2\. The list
    has now a new element: we had to modify an existing one to do the addition.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ba086145-a541-4238-9230-c876d1014ef7.jpg)图10.2。列表现在有一个新元素：我们不得不修改一个现有的元素来进行添加。'
- en: 'However, working in this way is obviously non-functional and it''s clear we
    are modifying data. There is a different way of working, by creating a persistent
    data structure, in which all alterations (insertions, deletions, and modifications)
    are done separately, being careful not to modify existing data. On the other hand,
    if some parts of the structure can be reused, this is done to gain in performance.
    Doing a persistent update would return a new list, with some nodes that are duplicates
    of some previous ones, but with no changes whatsoever to the original list. See
    figure 10.3:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以这种方式工作显然是非功能性的，很明显我们正在修改数据。有一种不同的工作方式，即创建一个持久的数据结构，在这种结构中，所有的改动（插入、删除和修改）都是分开进行的，小心不要修改现有的数据。另一方面，如果结构的某些部分可以被重复使用，那么就会为了性能而这样做。进行持久更新将返回一个新的列表，其中一些节点是之前的一些节点的副本，但原始列表完全没有任何改变。见图10.3：
- en: '![](assets/aeff7170-298f-418b-8481-93d246c2778d.jpg)Figure 10.3\. The dotted
    elements show the newly returned list: some elements had to be duplicated to avoid
    modifying the original structure. Old list refers to the original structure and
    new list to the result of the insertion.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/aeff7170-298f-418b-8481-93d246c2778d.jpg)图10.3。虚线元素显示了新返回的列表：一些元素必须被复制以避免修改原始结构。旧列表指的是原始结构，新列表指的是插入的结果。'
- en: Of course, we will also deal with updates or deletions. Starting again with
    the list as in Figure 10.4, if we wanted to update its fourth element, the solution
    would imply creating a new subset of the list, up to and including the fourth
    element, while keeping the rest unchanged.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还将处理更新或删除。再次从图10.4中的列表开始，如果我们想要更新它的第四个元素，解决方案将涉及创建列表的一个新子集，直到并包括第四个元素，同时保持其余部分不变。
- en: '![](assets/ecbdcf64-6a9b-4bd1-9b30-169c7d25f790.jpg)Figure 10.4\. Our list,
    with a changed element.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ecbdcf64-6a9b-4bd1-9b30-169c7d25f790.jpg)图10.4。我们的列表，有一个改变的元素。'
- en: 'Removing an element would also be similar. Let''s do away with the third element,
    F, in the original list. See figure 10.5:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个元素也是类似的。让我们在原始列表中去掉第三个元素F。见图10.5：
- en: '![](assets/1a66ce0d-d5f3-435f-b687-4ee1e7a8c798.jpg)Figure 10.5\. The original
    list, after removing the 3^(rd) element in a persistent way.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/1a66ce0d-d5f3-435f-b687-4ee1e7a8c798.jpg)图10.5。在持久的方式下删除第3个元素后的原始列表。'
- en: 'Working with lists or other structures can always be solved to provide data
    persistence. But, let''s now focus on what will probably be the most important
    kind of work for us: dealing with simple JS objects. After all, all data structures
    are JS objects, so if we can work with any objects, we can work with other structures.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表或其他结构始终可以解决数据持久性的问题。但是，现在让我们专注于对我们来说可能是最重要的工作：处理简单的JS对象。毕竟，所有的数据结构都是JS对象，所以如果我们可以处理任何对象，我们就可以处理其他结构。
- en: Updating objects
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新对象
- en: 'This kind of method can also be applied to more common requirements, such as
    modifying an object. This is a very good idea for, say, Redux users: a reducer
    can be programmed that will receive the old state as a parameter and produce an
    updated version with the minimum needed changes, without altering the original
    state in any way.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也可以应用于更常见的需求，比如修改一个对象。这对于Redux用户来说是一个非常好的主意：可以编写一个reducer，它将接收旧状态作为参数，并生成一个带有最小必要更改的更新版本，而不会以任何方式改变原始状态。
- en: 'Imagine you had an object as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你有一个如下的对象：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you wanted to modify `myObj.d.f`, and wanted to do it in a persistent way,
    you would create a new object, which would have several attributes in common with
    the previous object, but would define new ones for the modified ones. See figure
    10.6:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想修改`myObj.d.f`，并且想以持久的方式进行，你将创建一个新对象，它将与之前的对象有几个共同的属性，但将为修改的属性定义新的属性。见图10.6：
- en: '![](assets/c62a4319-a79b-45fa-9e71-35bdcf5666ac.jpg)Figure 10.6\. A persistent
    way of editing an object, by creating a new one with some shared attributes, and
    some new ones.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c62a4319-a79b-45fa-9e71-35bdcf5666ac.jpg)图10.6。通过创建一个具有一些共享属性和一些新属性的新对象，以持久的方式编辑对象。'
- en: 'If you had wanted to do this by hand, you would have had to write, in a very
    cumbersome way, something like the following. Most attributes are taken from the
    original object, but `d` and `d.f` are new:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想手动完成这个操作，你将不得不以非常繁琐的方式编写类似下面的内容。大多数属性都来自原始对象，但`d`和`d.f`是新的：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We already saw similar code earlier in this chapter, when we decided to work
    on a cloning function, but let's now go for a different type of solution. In fact,
    this kind of update can be automated.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的早些时候已经看到了类似的代码，当时我们决定要编写一个克隆函数，但现在让我们选择一种不同类型的解决方案。事实上，这种更新可以自动完成。
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The logic is recursive, but not too complex. First, we figure out, at the current
    level, what kind of object we need: either an array or an object. Then, we copy
    all attributes from the original object to the new one, except the property we
    are changing. Finally, we set that property to the given value (if we have finished
    with the path of property names), or we use recursion to go deeper with the copy.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑是递归的，但并不太复杂。首先，我们在当前级别确定我们需要什么样的对象：数组还是对象。然后，我们将所有属性从原始对象复制到新对象，除了我们正在更改的属性。最后，我们将该属性设置为给定值（如果我们已经完成了属性名称的路径），或者我们使用递归来深入复制。
- en: 'Note the order of the arguments: first the path, then the value, and finally
    the object. We are applying the concept of putting the most *stable* parameters
    first and the most variable last. If you curry this function, you can apply the
    same path to several different values and objects, and if you fix the path and
    the value, you can still use the function with different objects.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意参数的顺序：首先是路径，然后是值，最后是对象。我们应用了将最*稳定*的参数放在前面，最可变的参数放在最后的概念。如果你对这个函数进行柯里化，你可以将相同的路径应用到几个不同的值和对象上，如果你固定路径和值，你仍然可以使用不同的对象来使用该函数。
- en: We can give this logic a try. Let's start with a nonsensical object, but with
    several levels and even an array of objects, for variety.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试这种逻辑。让我们从一个毫无意义的对象开始，但是有几个级别，甚至有一个对象数组，以增加变化。
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can test changing `myObj.d.f` to a new value:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试将`myObj.d.f`更改为一个新值：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The logs at the bottom verify that the algorithm is working correctly: `myObj2.d`
    is a new object, but `myObj2.d.g` is re-using the value from `myObj`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的日志验证了算法是否正确运行：`myObj2.d`是一个新对象，但`myObj2.d.g`重用了`myObj`中的值。
- en: Further updating the array in the second object lets us test also how the logic
    works in those cases.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个对象中进一步更新数组让我们也能测试逻辑在这些情况下是如何工作的。
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We can compare the elements in the `myObj.d.j` array with the ones in the newly
    created object, and you can see that the array is a new one, but two of the elements
    (the ones that weren't updated) are still the same objects as in `myObj`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`myObj.d.j`数组中的元素与新创建的对象中的元素进行比较，你会发现数组是一个新数组，但两个元素（没有更新的元素）仍然是与`myObj`中相同的对象。
- en: This obviously isn't enough to get by. Our logic can update an existing field,
    or even add it if it wasn't there, but you'd also require the possibility of eliminating
    some attribute. Libraries usually provide many more functions, but let's at least
    work on the deletion of an attribute, to see other important structures change
    in an object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然还不够。我们的逻辑可以更新现有字段，甚至在没有的情况下添加它，但你还需要可能消除一些属性的可能性。通常库提供了更多的功能，但至少让我们来看看如何删除一个属性，以查看对象中的其他重要结构变化。
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The logic is similar to that of `setIn()`. The difference is that we do not
    always copy all attributes from the original object to the new one: we only do
    that while we haven''t yet arrived at the end of the array of path properties.
    Continuing the series of tests after the updates, we get the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑类似于`setIn()`的逻辑。不同之处在于我们并不总是将所有属性从原始对象复制到新对象：只有在我们还没有到达路径属性数组的末尾时才这样做。在更新后继续测试系列之后，我们得到了以下结果：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this pair of functions, we can manage to work with persistent objects,
    doing changes, additions, and deletions, in an efficient way that won't create
    new objects needlessly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一对函数，我们可以管理持久对象的工作，以一种高效的方式进行更改、添加和删除，而不会不必要地创建新对象。
- en: 'Probably the best-known library for working with immutable objects is the appropriately
    named *immutable.js*, at [https://facebook.github.io/immutable-js/](https://facebook.github.io/immutable-js/).
    The only weak point about it is its notoriously obscure documentation. However,
    there''s an easy solution for that: check out *The Missing Immutable.js Manual
    With All The Examples You’ll Ever Need* at [http://untangled.io/the-missing-immutable-js-manual/](http://untangled.io/the-missing-immutable-js-manual/)
    and you won''t have any trouble!'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最著名的用于处理不可变对象的库是名为*immutable.js*的库，网址为[https://facebook.github.io/immutable-js/](https://facebook.github.io/immutable-js/)。唯一的弱点是其臭名昭著的晦涩文档。然而，对此有一个简单的解决方案：查看[http://untangled.io/the-missing-immutable-js-manual/](http://untangled.io/the-missing-immutable-js-manual/)上的*The
    Missing Immutable.js Manual With All The Examples You’ll Ever Need*，你就不会有任何麻烦了！
- en: A final caveat
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的警告
- en: Working with persistent data structures requires some cloning, but how would
    you implement a persistent array? If you think about this, you'll realize that,
    in that case, there would be no way out apart from cloning the whole array after
    each operation. This would mean that an operation such as updating an element
    in an array, which took a basically constant time, would now take a length of
    time proportional to the size of the array.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用持久数据结构需要一些克隆，但你如何实现一个持久数组？如果你考虑一下，你会意识到，在这种情况下，除了在每次操作后克隆整个数组之外，没有其他办法。这意味着像更新数组中的元素这样的操作，它本来只需要基本恒定的时间，现在将需要与数组大小成比例的时间。
- en: In algorithm complexity terms, we would say that updates went from being an
    O(1) operation to an O(n) one. Similarly, access to an element may become an O(log
    n) operation, and similar slow-downs might be observed for other operations, such
    as mapping, reducing, and so on.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法复杂度方面，我们会说更新从O(1)操作变为O(n)操作。同样，访问一个元素可能会变成O(log n)操作，其他操作也可能出现类似的减速，比如映射、减少等。
- en: How do we avoid this? There's no easy solution. For example, you may find that
    an array is internally represented as a binary search tree (or even more complex
    data structures) and the persistence library provides the needed interface so
    you'll be still able to use it as an array, not noticing the internal difference.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何避免这种情况？没有简单的解决方案。例如，你可能会发现数组在内部被表示为二叉搜索树（甚至更复杂的数据结构），并且持久库提供了所需的接口，这样你仍然可以将其用作数组，而不会注意到内部的差异。
- en: When using this kind of libraries, the advantages of having immutable updates
    without cloning may be offset in part by some operations that may become slower.
    If this becomes a bottleneck in your application, you might even have to go so
    far as changing the way you implement immutability or even work out some way of
    changing your basic data structures to avoid the time loss, or at least minimize
    it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这种类型的库时，具有不可变更新而无需克隆的优势可能部分地被一些操作所抵消，这些操作可能变得更慢。如果这成为应用程序的瓶颈，甚至可能需要改变实现不可变性的方式，甚至想出一些改变基本数据结构的方法来避免时间损失，或者至少将其最小化。
- en: Questions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 10.1\. **Freezing by proxying**. In the *Chaining and Fluent Interfaces*section
    of [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions
    - Pipelining and Composition*, we used a proxy for getting operations in order
    to provide for automatic chaining. By using a proxy for *setting* and *deleting*
    operations, you may do your own *freezing* (if, instead of setting an object's
    property, you'd rather throw an exception). Implement a `freezeByProxy(obj)` function
    that will apply this idea to forbid all kinds of updates (adding, modifying, or
    deleting properties) for an object. Remember to work recursively, in case an object
    has other objects as properties!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 10.1\. **通过代理进行冻结**。在[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)的*链接函数
    - 管道和组合*部分，我们使用代理来获取操作，以便提供自动链接。通过使用代理进行*设置*和*删除*操作，您可以自行进行*冻结*（如果您不想设置对象的属性，而是宁愿抛出异常）。实现一个`freezeByProxy(obj)`函数，将这个想法应用到禁止所有类型的更新（添加、修改或删除属性）的对象上。记得要递归地工作，以防一个对象具有其他对象作为属性！
- en: '10.2\. **Inserting into a list, persistently**. In the *Working with lists*
    section, we described how an algorithm could add a new node to a list, but in
    a persistent way, by creating a new list as we earlier described. Implement an
    `insertAfter(list, newKey, oldKey)` function that will create a new list, but
    adding a new node with key `newKey` just after the node with key `oldKey`. You
    may assume the nodes of the list were created by the following logic:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 10.2\. **持久地插入到列表中**。在*使用列表*部分，我们描述了一种算法如何以持久的方式向列表中添加一个新节点，通过创建一个新的列表，就像我们之前描述的那样。实现一个`insertAfter(list,
    newKey, oldKey)`函数，它将创建一个新的列表，但在具有键`oldKey`的节点之后添加一个具有键`newKey`的新节点。您可以假设列表的节点是通过以下逻辑创建的：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have seen two different approaches (actually used by commonly
    available immutability libraries) to avoiding side-effects by working with immutable
    objects and data structures: one was based on using JavaScript''s *object freezing*
    plus some special logic for cloning and the other applied the concept of persistent
    data structures, with methods that allowed all kinds of updates without either
    changing the original or requiring full cloning.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了两种不同的方法（实际上是常见的不可变性库使用的方法），通过使用不可变对象和数据结构来避免副作用：一种是基于使用JavaScript的*对象冻结*加上一些特殊逻辑来克隆，另一种是应用持久数据结构的概念，其中的方法允许进行各种更新，而不会改变原始对象或需要完全克隆。
- en: 'In Chapter 11, *Implementing Design Patterns - The Functional Way*, we will
    focus on a question often asked by object-oriented programmers: how are design
    patterns used in FP? Are they required, available, or usable? Are they still practiced
    but with a new focus on functions rather than on objects? We''ll answer these
    questions with several examples showing where and how they are equivalent or they
    differ from the usual OOP practices.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章*实现设计模式 - 函数式方法*中，我们将专注于面向对象程序员经常问的一个问题：设计模式在FP中如何使用？它们是否必需、可用或可用？它们是否仍然被实践，但关注点转移到了函数而不是对象？我们将通过几个示例来回答这些问题，展示它们在哪里以及如何它们与通常的OOP实践相等或不同。
