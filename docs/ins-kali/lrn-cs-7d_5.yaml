- en: Day 05 - Overview of Reflection and Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第05天 - 反射和集合概述
- en: Today is day five of our seven-day learning series. Up till now, we have gone
    through various insights into the C# language and have got the idea about how
    to work with statements, loops, methods, and so on. Today, we will learn the best
    way to work dynamically when we're writing code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 今天是我们七天学习系列的第五天。到目前为止，我们已经深入了解了C#语言，并了解了如何处理语句、循环、方法等。今天，我们将学习在编写代码时动态工作的最佳方法。
- en: 'There are lots of ways we can dynamically implement code changes and generate
    an entire programming class. Today, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多方法可以动态实现代码更改并生成整个编程类。今天，我们将涵盖以下主题：
- en: What is reflection?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是反射？
- en: Overview of delegates and events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托和事件概述
- en: Collections and non-generics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合和非泛型
- en: What is reflection?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是反射？
- en: 'In simple terms, reflection is a way to get inside of a program, gathering
    the object information of a program/code and/or invoking these at runtime. So,
    with the help of reflection, we can analyze and assess our code by writing code
    in C#. To understand reflection in detail, let''s take the example of the `class`
    `OddEven`. Here is the partial code of this class:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，反射是一种进入程序内部的方法，收集程序/代码的对象信息和/或在运行时调用这些信息。因此，借助反射，我们可以通过在C#中编写代码来分析和评估我们的代码。要详细了解反射，让我们以`class`
    `OddEven`的例子来说明。这是这个类的部分代码：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After going through the code, we can say this code has a few public methods
    and private methods. Public methods utilize private methods for various functional
    demands and perform tasks to solve a real-world problems where we need to identify
    the odd or even numbers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看代码，我们可以说这段代码有一些公共方法和私有方法。公共方法利用私有方法来满足各种功能需求，并执行任务以解决我们需要识别奇数或偶数的实际问题。
- en: 'When we need to utilize the preceding class, we have to instantiate this class
    and then call their methods to get the results. Here is how we can utilize this
    simple class to get the results:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要利用前面的类时，我们必须实例化这个类，然后调用它们的方法来获取结果。以下是我们如何利用这个简单类来获取结果：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](img/00073.gif)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.gif)'
- en: The previous code shows one of the ways in which we can implement the code.
    In the same way, we can implement this using the same solution but by analyzing
    the code. We have already stated that reflection is a way to analyse our code.
    In the upcoming section, we will implement and discuss the code of a similar implementation,
    but with the use of reflection.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了我们可以实现代码的一种方式。同样，我们可以使用相同的解决方案来分析代码。我们已经说过反射是分析我们的代码的一种方法。在接下来的部分，我们将实现和讨论类似实现的代码，但使用反射。
- en: 'You need to add the following NuGet package to work with reflection, using
    the Package Manager Console: install-`Package System.Reflection`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要添加以下NuGet包来使用反射，使用包管理器控制台：install-`Package System.Reflection`。
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, instead of `Activator.CreateInstance(typeof(OddEven))`,
    we can also use `Assembly.CreateInstance("OddEven")`. `Assembly.CreateInstance`
    looks into the type of the assembly and creates the instance using `Activator.CreateInstance`.
    For more information on `Assembly`,`CreateInstance`, refer to: [https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.createinstance?view=netstandard-2.0#System_Reflection_Assembly_CreateInstance_System_String_](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.createinstance?view=netstandard-2.0#System_Reflection_Assembly_CreateInstance_System_String_).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以使用`Assembly.CreateInstance("OddEven")`来代替`Activator.CreateInstance(typeof(OddEven))`。`Assembly.CreateInstance`查看程序集的类型，并使用`Activator.CreateInstance`创建实例。有关`Assembly`，`CreateInstance`的更多信息，请参阅：[https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.createinstance?view=netstandard-2.0#System_Reflection_Assembly_CreateInstance_System_String_](https://docs.microsoft.com/en-us/dotnet/api/system.reflection.assembly.createinstance?view=netstandard-2.0#System_Reflection_Assembly_CreateInstance_System_String_)。
- en: 'Here is the output from the preceding code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/00074.gif)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.gif)'
- en: Reflection in use
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射的应用
- en: In the previous section, we get an idea about reflection and how we can utilize
    the power of `Reflection` to analyse the code. In this section, we will see more
    complex scenarios where we can use `Reflection` and discuss `System.Type` and
    `System.Reflection` in more detail.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们了解了反射以及如何利用`Reflection`的能力来分析代码。在本节中，我们将看到更复杂的场景，我们可以在其中使用`Reflection`并更详细地讨论`System.Type`和`System.Reflection`。
- en: Getting type info
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取类型信息
- en: 'There is a `System.Type` class available which provides us with the complete
    information about our object type: we can use `typeof` to get all the information
    about our class. Let''s see the following code snippet:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`System.Type`类可用，它为我们提供了关于我们对象类型的完整信息：我们可以使用`typeof`来获取关于我们类的所有信息。让我们看下面的代码片段：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![](img/00075.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00075.jpeg)'
- en: 'On the same node, we can we have method `GetType()` of the `System.Type` class,
    which gets the type and provides the information. Let us analyse and discuss the
    following code snippet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个节点上，我们可以使用`System.Type`类的`GetType()`方法，该方法获取类型并提供信息。让我们分析和讨论以下代码片段：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/00076.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00076.jpeg)'
- en: 'The code snippets discussed in the previous sections had a type which represented
    a class `System.Type`, and then we gathered the information using properties.
    These properties are explained in the following table:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分讨论的代码片段中，有一个代表`System.Type`类的类型，然后我们使用属性收集信息。这些属性在下表中解释：
- en: '| **Property name** | **Description** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **属性名称** | **描述** |'
- en: '| **Name** | Returns the name of the type, for example, `Program` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | 返回类型的名称，例如，`Program` |'
- en: '| **Full Name** | Returns the fully qualified name of the type without the
    assembly name, for example, `Day05.Program` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **完整名称** | 返回类型的完全限定名称，不包括程序集名称，例如，`Day05.Program` |'
- en: '| **Namespace** | Returns the namespace of the type, for example, `Day05`.
    This property returns null if there is no namespace |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| **命名空间** | 返回类型的命名空间，例如，`Day05`。如果没有命名空间，则此属性返回null |'
- en: These properties are read-only (of class `System.Type` which is an abstract
    class); that means we can only read or get the results, but they do not allow
    us to set the values.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性是只读的（属于抽象类`System.Type`）；这意味着我们只能读取或获取结果，但不能设置值。
- en: The `System.Reflection.TypeExtensions` class has everything we need to analyse
    and write code dynamically. The complete source code is available at [https://github.com/dotnet/corefx/blob/master/src/System.Reflection.TypeExtensions/src/System/Reflection/TypeExtensions.cs](https://github.com/dotnet/corefx/blob/master/src/System.Reflection.TypeExtensions/src/System/Reflection/TypeExtensions.cs).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Reflection.TypeExtensions`类具有我们分析和动态编写代码所需的一切。完整的源代码可在[https://github.com/dotnet/corefx/blob/master/src/System.Reflection.TypeExtensions/src/System/Reflection/TypeExtensions.cs](https://github.com/dotnet/corefx/blob/master/src/System.Reflection.TypeExtensions/src/System/Reflection/TypeExtensions.cs)上找到。'
- en: 'Implementation of all extension methods is beyond the scope of this book, so
    we added the following table which represents all details on important extension
    methods:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涵盖所有扩展方法的实现，因此我们添加了以下表格，其中包含所有重要扩展方法的详细信息：
- en: '| **Method name** | **Description** | **Source (** [https://github.com/dotnet/corefx/blob/master/src](https://github.com/dotnet/corefx/blob/master/src)
    ) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **方法名** | **描述** | **来源 (** [https://github.com/dotnet/corefx/blob/master/src](https://github.com/dotnet/corefx/blob/master/src)
    ) |'
- en: '| `GetConstructor(Type type, Type[] types)` | Performs over the provided type
    and returns output of type `System.Reflection. ConstructorInfo` | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs`
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `GetConstructor(Type type, Type[] types)` | 在提供的类型上执行，并返回`System.Reflection.ConstructorInfo`类型的输出
    | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
- en: '| `ConstructorInfo[] GetConstructors(Type type)` | Returns all constructor
    information for provided type and array outputs of `System.Reflection. ConstructorInfo`
    | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `ConstructorInfo[] GetConstructors(Type type)` | 返回提供的类型的所有构造函数信息和`System.Reflection.ConstructorInfo`数组输出
    | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
- en: '| `ConstructorInfo[] GetConstructors(Type type, BindingFlags bindingAttr)`
    | Returns all constructor information for provided type and attributes | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs`
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `ConstructorInfo[] GetConstructors(Type type, BindingFlags bindingAttr)`
    | 返回提供的类型和属性的所有构造函数信息 | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs`
    |'
- en: '| `MemberInfo[] GetDefaultMembers(Type type)` | Gets the access for provided
    attribute, for member, for given type, and for outputs of array `System.Reflection.
    MemberInfo` | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `MemberInfo[] GetDefaultMembers(Type type)` | 获取提供的属性的访问权限，对于成员，对于给定类型，并输出`System.Reflection.MemberInfo`数组
    | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
- en: '| `EventInfo` `GetEvent(Type type, string name)` | Provides the access to EventMetadata
    outputs of `System.Reflection. MemberInfo` | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs`
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `EventInfo` `GetEvent(Type type, string name)` | 提供对`System.Reflection.MemberInfo`的`EventMetadata`输出的访问
    | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
- en: '| `FieldInfo GetField(Type type, string name)` | Gets the field info of the
    specified type, and for the field name provided, and returns, output of `System.Reflection.
    FieldInfo` | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `FieldInfo GetField(Type type, string name)` | 获取指定类型的字段信息，并返回提供的字段名称的`System.Reflection.FieldInfo`输出
    | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
- en: '| `MemberInfo[] GetMember(Type type, string name)` | Gets the member info of
    the specified type by using member name, and this method outputs an array of `System.Reflection.
    MemberInfo` | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `MemberInfo[] GetMember(Type type, string name)` | 通过成员名称获取指定类型的成员信息，此方法输出`System.Reflection.MemberInfo`数组
    | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
- en: '| `PropertyInfo[] GetProperties(Type type)` | Provides all properties for the
    specified type and outputs as an array of `System.Reflection. PropertyInfo` |
    `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `PropertyInfo[] GetProperties(Type type)` | 为指定类型提供所有属性，并输出为`System.Reflection.PropertyInfo`数组
    | `/System.Reflection.Emit/ref/System.Reflection.Emit.cs` |'
- en: Try implementing all extension methods using a simple program.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用一个简单的程序来实现所有扩展方法。
- en: 'In previous sections, we learned how to analyze our compiled code/application
    using `Reflection`. `Reflection` works fine when we have existing code. Think
    of a scenario where we require some dynamic code generation logic. Let''s say
    we need to generate a simple class as mentioned in following code snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了如何使用`Reflection`来分析我们的已编译代码/应用程序。当我们有现有的代码时，`Reflection`可以很好地工作。想象一种情况，我们需要一些动态代码生成逻辑。假设我们需要生成一个简单的类，如下面的代码片段中所述：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Creating or writing purely dynamic code or code on the fly is not possible with
    the sole use of `Reflection`. With the help of `Reflection`, we can analyze our
    `MathClass`, but we can create this class on the fly with the use of `Reflection.Emit`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用`Reflection`无法创建或编写纯动态代码或即时代码。借助`Reflection`，我们可以分析我们的`MathClass`，但是我们可以使用`Reflection.Emit`来即时创建这个类。
- en: 'Dynamic code generation is beyond the scope of this book. You can refer to
    the following thread for more information: [https://stackoverflow.com/questions/41784393/how-to-emit-a-type-in-net-core](https://stackoverflow.com/questions/41784393/how-to-emit-a-type-in-net-core)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 动态代码生成超出了本书的范围。您可以参考以下主题获取更多信息：[https://stackoverflow.com/questions/41784393/how-to-emit-a-type-in-net-core](https://stackoverflow.com/questions/41784393/how-to-emit-a-type-in-net-core)
- en: Overview of delegates and events
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托和事件概述
- en: In this section, we will discuss the basics of delegates and events. Both delegates
    and events are the most advanced features of the C# language. We will understand
    these in coming sections in detail.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论委托和事件的基础知识。委托和事件都是C#语言最先进的特性。我们将在接下来的章节中详细了解这些内容。
- en: Delegates
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托
- en: In C#, delegates are a similar concept to pointers to functions, as in C and
    C++. A delegate is nothing but a variable of a reference type, which holds a reference
    of a method, and this method is triggered.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，委托是类似于C和C++中的函数指针的概念。委托只是一个引用类型的变量，它保存了一个方法的引用，并触发该方法。
- en: We can achieve late binding using delegates. In [Chapter 7](part0238.html#72V5S0-cd07d0bec7404d1cb3fdb41e48e5618f),
    *Understanding Object Oriented Programing with C#*, we will discuss late binding
    in detail.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用委托实现后期绑定。在[第7章](part0238.html#72V5S0-cd07d0bec7404d1cb3fdb41e48e5618f)，*使用C#理解面向对象编程*中，我们将详细讨论后期绑定。
- en: '`System.Delegate` is a class from which all delegates are derived. We use delegates
    to implement events.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Delegate`是所有委托派生的类。我们使用委托来实现事件。'
- en: Declaring a delegate type
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明委托类型
- en: 'Declaring a delegate type is similar to the method signature class. We just
    need to declare a type public delegate string: `PrintFizzBuzz(int number);`. In
    the preceding code, we declared a delegate type. This declaration is similar to
    an abstract method with the difference that delegate declaration has a type delegate.
    We just declared a delegate type `PrintFizzBuzz`, and it accepts one argument
    of int type and returns the result of the string. We can only declare public or
    internal accessible delegates.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '声明委托类型类似于方法签名类。我们只需要声明一个类型public delegate string: `PrintFizzBuzz(int number);`。在前面的代码中，我们声明了一个委托类型。这个声明类似于一个抽象方法，不同之处在于委托声明有一个委托类型。我们只声明了一个委托类型`PrintFizzBuzz`，它接受一个int类型的参数并返回字符串的结果。我们只能声明public或internal可访问的委托。'
- en: Accessibility of delegates is internal by default.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，委托的可访问性是internal。
- en: '![](img/00077.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00077.jpeg)'
- en: 'In the previous figure, we can analyse the syntax of the delegate declaration.
    If we saw this figure, we would notice that it started with public, then the keyword
    delegate, which tells us that this is a delegate type, the string, which is a
    return type, and our syntax is concluded with name and passing arguments. The
    following table defines that declaration has major parts:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们可以分析委托声明的语法。如果我们看到这个图，我们会注意到它以public开头，然后是关键字delegate，这告诉我们这是一个委托类型，字符串，它是一个返回类型，我们的语法以名称和传递参数结束。以下表定义了声明的主要部分：
- en: '| **Syntax part** | **Description** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **语法部分** | **描述** |'
- en: '| Modifier | Modifier is the defined accessibility of a delegate type. These
    modifiers can be only public or internal, and by default a delegate type modifier
    is internal. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 修饰符 | 修饰符是委托类型的定义可访问性。这些修饰符只能是public或internal，默认情况下委托类型的修饰符是internal。 |'
- en: '| Return type | Delegate can or cannot return a result; it can be of any type
    or void. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 返回类型 | 委托可以返回或不返回结果；可以是任何类型或void。 |'
- en: '| Name | The name of the declared delegate. The name of the delegate type follows
    the same rules as a typical class, as discussed on day two. |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 声明的委托的名称。委托类型的名称遵循与典型类相同的规则，如第二天所讨论的。 |'
- en: '| Parameter list | A typical parameter list; parameters can be any type. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 参数列表 | 典型的参数列表；参数可以是任何类型。 |'
- en: Instances of delegate
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托的实例
- en: 'In the previous section, we created a delegate type named `PrintFizzBuzz`.
    Now we need to declare an instance of this type so we can use the same in our
    code. This is similar to the way we declared variables—please refer to day two
    to know more about the declaration of variables. The following code snippet tells
    us how we can declare an instance of our delegate type:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们创建了一个名为`PrintFizzBuzz`的委托类型。现在我们需要声明这种类型的一个实例，这样我们就可以在我们的代码中使用它。这类似于我们声明变量的方式-请参考第二天了解更多关于变量声明的内容。以下代码片段告诉我们如何声明我们委托类型的一个实例：
- en: '`PrintFizzBuzz printFizzBuzz;`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintFizzBuzz printFizzBuzz;`'
- en: Delegates in use
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托的使用
- en: 'We can directly use delegate types by calling matching methods, which means
    the delegate type invokes a related method. In the following code snippet, we
    are simply invoking a method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接通过调用匹配方法来使用委托类型，这意味着委托类型调用相关方法。在下面的代码片段中，我们只是调用一个方法：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the code snippet written in the previous section, we are taking an input
    from the user and then, with the help of the delegate, we are getting the expected
    results. The following screenshot shows the complete output of the preceding code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中编写的代码片段中，我们从用户那里获取输入，然后借助委托获得预期的结果。以下屏幕截图显示了前面代码的完整输出：
- en: '![](img/00078.gif)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.gif)'
- en: More advanced delegates, namely multicast, and strongly typed delegates will
    be discussed on day six.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的委托，即多播和强类型的委托将在第六天讨论。
- en: Events
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: In general, whenever events come into the picture, we can think about an action
    for the user or user action. There are a couple of examples from our daily life;
    namely we check our emails, send emails, and so on. Actions such as clicking a
    send button or receive button from our email clients are nothing but events.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，每当事件出现时，我们可以考虑用户的行为或用户行为。我们日常生活中有一些例子；比如我们检查邮件，发送邮件等。像点击邮件客户端中的发送按钮或接收按钮这样的操作只是事件。
- en: Events are members of a type, and this type is of delegate type. These members
    notify to other types when raised.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是类型的成员，而这个类型是委托类型。这些成员在触发时通知其他类型。
- en: Events use the publisher-subscriber model. A publisher is nothing but an object
    which has a definition of the event and the delegate. On the other hand, a subscriber
    is an object which accepts the events and provides the event handler (event handlers
    are nothing but a method which is invoked by delegates in the publisher class).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 事件使用发布者-订阅者模型。发布者只是一个具有事件和委托定义的对象。另一方面，订阅者是接受事件并提供事件处理程序的对象（事件处理程序只是由发布者类中的委托调用的方法）。
- en: Declaring an event
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明事件
- en: 'Before we declare an event, we should have a delegate type, so we should first
    declare a delegate. The following code snippet shows delegate type:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明事件之前，我们应该有一个委托类型，所以我们应该首先声明一个委托。以下代码片段显示了委托类型：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](img/00079.gif)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.gif)'
- en: Collections and non-generics
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合和非泛型
- en: On day two, we learned about arrays, which are of fixed size, and you can use
    these for strongly typed list objects. But what about if we want to use or organize
    these objects into other data structures such as queues, lists, stacks, and so
    on? All these we can achieve with the use of collections (`System.Collections`).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二天，我们学习了数组，它们是固定大小的，并且您可以使用它们来进行强类型列表对象。但是，如果我们想要将这些对象使用或组织到其他数据结构中，例如队列、列表、堆栈等，怎么办？所有这些都可以通过使用集合（`System.Collections`）来实现。
- en: There are various ways to play with data (storage and retrieval) with the use
    of collections. The following are the main collection classes we can use.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以使用集合来玩耍数据（存储和检索）。以下是我们可以使用的主要集合类。
- en: '`System.Collections.NonGeneric` ([https://www.nuget.org/packages/System.Collections.NonGeneric/](https://www.nuget.org/packages/System.Collections.NonGeneric/)
    ) is a NuGet package which provides all non-generic types, namely `ArrayList`,
    `HashTable`, `Stack`, `SortedList`, `Queue`, and so on.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.NonGeneric` ([https://www.nuget.org/packages/System.Collections.NonGeneric/](https://www.nuget.org/packages/System.Collections.NonGeneric/)
    )是一个NuGet包，它提供了所有非泛型类型，如`ArrayList`、`HashTable`、`Stack`、`SortedList`、`Queue`等。'
- en: ArrayList
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ArrayList
- en: As it is an array, it contains an ordered collection of an object and can be
    indexed individually. As this is a non-generic class, it is available under a
    separate NuGet package from `System.Collections.NonGeneric`. To work with the
    example code, you should first install this NuGet package.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是一个数组，它包含一个有序的对象集合，并且可以单独进行索引。由于这是一个非泛型类，因此它在`System.Collections.NonGeneric`的单独NuGet包中可用。要使用示例代码，您首先应安装此NuGet包。
- en: Declaration of ArrayList
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明ArrayList
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `ArrayList` properties and methods are important to add, store, or remove
    our data items from our collections. There are many properties and methods available
    for the `ArrayList` class. In the upcoming sections, we will discuss commonly
    used methods and properties.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`的属性和方法对于向集合中添加、存储或移除数据项非常重要。`ArrayList`类有许多属性和方法可用。在接下来的部分中，我们将讨论常用的方法和属性。'
- en: Properties
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'The properties of `ArrayList` play a vital role while analysing an existing
    `ArrayList`; the following are the commonly used properties:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`的属性在分析现有的`ArrayList`时起着至关重要的作用；以下是常用的属性：'
- en: '| **Property** | **Description** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `Capacity` | A getter setter property; with the use of this, we can set or
    get the number of elements of `ArrayList`.For example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Capacity` | 一个getter setter属性；通过使用它，我们可以设置或获取`ArrayList`的元素数量。例如：'
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '|'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Count` | Total actual number of elements `ArrayList` contains. Please note
    that this count may differ from capacity.For example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Count` | `ArrayList`包含的实际元素总数。请注意，此计数可能与容量不同。例如：'
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '|'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `IsFixedSize` | A getter property returns true/false on the basis of whether
    `ArrayList` is of fixed size or not.For example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '| `IsFixedSize` | 一个getter属性，根据`ArrayList`是否为固定大小返回true/false。例如：'
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Methods
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'As we discussed in the previous section, properties play important roles while
    we''re working with `ArrayList`. In the same node, methods provide us a way to
    add, remove, or perform other operations while working with non-generic collections:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中讨论的，属性在我们使用`ArrayList`时起着重要作用。在同一节点上，方法为我们提供了一种在使用非泛型集合时添加、删除或执行其他操作的方式：
- en: '| **Method** | **Description** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Add (object value)` | Adds an object to the end of `ArrayList`.For example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Add (object value)` | 将对象添加到`ArrayList`的末尾。例如：'
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '|'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Void Clear()` | Removes all elements from `ArrayList`.For example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Void Clear()` | 从`ArrayList`中移除所有元素。例如：'
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '|'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Void Remove(object obj)` | Removes first occurred element in the collection.For
    example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Void Remove(object obj)` | 从集合中移除第一次出现的元素。例如：'
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Void Sort()` | Sorts all the elements in `ArrayList` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Void Sort()` | 对`ArrayList`中的所有元素进行排序。|'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the output of the preceding program:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面程序的输出：
- en: '![](img/00080.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.jpeg)'
- en: You will learn all advanced concepts of collections and generics on day six.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在第六天学习所有集合和泛型的高级概念。
- en: HashTable
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HashTable
- en: A non-generic type, the `hashTable` class is nothing but a representation of
    collections of key/value pairs and is organized on the basis of a key, which is
    nothing but a hash code. The use of `hashTable` is advisable when we need to access
    data on the basis of a key.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashTable`是一种非泛型类型，它只是键/值对集合的表示，并且是根据键（即哈希码）组织的。当我们需要根据键访问数据时，建议使用`hashTable`。'
- en: Declaration of HashTable
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明HashTable
- en: '`Hashtable` can be declared by initializing the `Hashtable` class; the following
    code snippet shows the same:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hashtable`可以通过初始化`Hashtable`类来声明；以下代码片段显示了相同的内容：'
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We will discuss commonly used methods and properties of `HashTable` next.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将讨论`HashTable`的常用方法和属性。
- en: Properties
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'The properties of `hashTable` play a vital role while analyzing an existing
    `HashTable`; the following are the commonly used properties:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashTable`的属性在分析现有的`HashTable`时起着至关重要的作用；以下是常用的属性：'
- en: '| **Property** | **Description** |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `Count` | A getter property; returns number of key/value pairs in the `HashTable`.For
    example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Count` | 一个getter属性；返回`HashTable`中键/值对的数量。例如：'
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `IsFixedSize` | A getter property; returns true/false on the basis of whether
    the `HashTable` is of fixed size or not.For example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '| `IsFixedSize` | 一个getter属性；根据`HashTable`是否为固定大小返回true/false。例如：'
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '|'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `IsReadOnly` | A getter property; tells us whether `Hashtable` is read-only
    or not.For example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '| `IsReadOnly` | 一个getter属性；告诉我们`HashTable`是否是只读的。例如：'
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Methods
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'The methods of `HashTable` provide a way to add, remove, and analyze the collection
    by providing more operations, as discussed in the following table:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashTable`的方法通过提供更多操作的方式来添加、删除和分析集合，如下表所述：'
- en: '| **Method** | **Description** |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Add (object key, object value)` | Adds an element of a specific key and
    value to `HashTable`.For example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Add (object key, object value)` | 向`HashTable`添加特定键和值的元素。例如：'
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Void Clear()` | Removes all elements from `HashTable`.For example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Void Clear()` | 从`HashTable`中移除所有元素。例如：'
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Void Remove (object key)` | Removes element of a specified key from HashTable.For
    example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Void Remove (object key)` | 从HashTable中移除指定键的元素。例如：'
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following is the output of the preceding code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/00081.gif)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.gif)'
- en: SortedList
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SortedList
- en: A non-generic type, the `SortedList` class is nothing but a representation of
    collections of key/value pairs, organized on the basis of a key, and is sorted
    by key. `SortedList` is a combination of `ArrayList` and `HashTable`. So, we can
    access the elements by key or index.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedList`类是一个非泛型类型，它只是一个基于键的键/值对集合的表示，按键排序。`SortedList`是`ArrayList`和`HashTable`的组合。因此，我们可以通过键或索引访问元素。'
- en: Declaration of SortedList
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SortedList的声明
- en: '`SortedList` can be declared by initializing the `SortedList` class; the following
    code snippet shows the same:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedList`可以通过初始化`SortedList`类来声明；以下代码片段显示了相同的方式：'
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will discuss commonly used methods and properties of `SortedList` next.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将讨论`SortedList`的常用方法和属性。
- en: Properties
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'The properties of `SortedList` play a vital role while analyzing an existing
    `SortedList`; the following are the commonly used properties:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`SortedList`的属性在分析现有的`SortedList`时起着至关重要的作用；以下是常用的属性：'
- en: '| **Property** | **Description** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `Capacity` | A getter setter property; with the use of this, we can set or
    get the capacity of `SortedList`.For example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Capacity` | 一个getter setter属性；通过使用这个属性，我们可以设置或获取`SortedList`的容量。例如：'
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '|'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Count` | A getter property; returns number of key/value pairs in the `HashTable`.For
    example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Count` | 一个getter属性；返回`HashTable`中键/值对的数量。例如：'
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '|'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `IsFixedSize` | A getter property; returns true/false on the basis of whether
    `SortedList` is of fixed size or not.For example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '| `IsFixedSize` | 一个getter属性；根据`SortedList`是否是固定大小返回true/false。例如：'
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '|'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `IsReadOnly` | A getter property; tells us whether `SortedList` is read-only
    or not.For example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '| `IsReadOnly` | 一个getter属性；告诉我们`SortedList`是否是只读的。例如：'
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Methods
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'The following are the commonly used methods:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是常用的方法：
- en: '| **Method** | **Description** |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Add (object key, object value)` | Adds an element of a specific key and
    value to `SortedList`.For example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Add (object key, object value)` | 向`SortedList`添加特定键和值的元素。例如：'
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Void Clear()` | Removes all elements from `SortedList`.For example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Void Clear()` | 从`SortedList`中移除所有元素。例如：'
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '|'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Void Remove (object key)` | Removes an element of specified key from `SortedList`.For
    example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Void Remove (object key)` | 从`SortedList`中移除指定键的元素。例如：'
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'In the upcoming section, we will implement code with the use of the properties
    and methods mentioned in previous sections. Let''s collect a list of all stakeholders
    of the book *Learn C# in 7 days* with the use of `SortedList`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将使用前面部分提到的属性和方法来实现代码。让我们使用`SortedList`收集《7天学会C#》一书的所有利益相关者列表：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following is the output of the preceding code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/00082.gif)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.gif)'
- en: Stack
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈
- en: 'A non-generic type, it represents a collection as **last in, first out (LIFO)**
    of objects. It contains two main things: `Push` and `Pop`. Whenever we''re inserting
    an item into the list, it is called pushing, and when we extract/remove an item
    from the list, it''s called popping. When we get an object without removing the
    item from the list, it is called peeking.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非泛型类型，表示对象的**后进先出（LIFO）**集合。它包含两个主要的操作：`Push`和`Pop`。当我们向列表中插入一个项目时，称为推入，当我们从列表中提取/移除一个项目时，称为弹出。当我们在不移除列表中的项目的情况下获取一个对象时，称为查看。
- en: Declaration of Stack
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈的声明
- en: 'The declaration of `Stack` is very similar to the way we declared other non-generic
    types. The following code snippet shows the same:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack`的声明与我们声明其他非泛型类型的方式非常相似。以下代码片段显示了相同的方式：'
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We will discuss commonly used methods and properties of `Stack`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论`Stack`的常用方法和属性。
- en: Properties
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'The `Stack` class has only one property, which tells the count:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stack`类只有一个属性，用于告诉计数：'
- en: '| **Property** | **Description** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `Count` | A getter property; returns number of elements a stack contains.For
    example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Count` | 一个getter属性；返回栈包含的元素数量。例如：'
- en: '[PRE38]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '|'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Methods
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'The following are the commonly used methods:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是常用的方法：
- en: '| **Method** | **Description** |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Object Peek()` | Returns the object at the top of the stack but does not
    remove it.For example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Object Peek()` | 返回栈顶的对象，但不移除它。例如：'
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Object Pop()` | Removes and returns the object at the top of the stack.For
    example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Object Pop()` | 移除并返回栈顶的对象。例如：'
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '|'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Void Push(object obj)` | Inserts an object at the top of the stack.For example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Void Push(object obj)` | 在栈顶插入一个对象。例如：'
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '|'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Void Clear()` | Removes all elements from the stack.For example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Void Clear()` | 从栈中移除所有元素。例如：'
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '|'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The following is the complete example of stack:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是栈的完整示例：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The previous code captures a list of stakeholders for the book *Learning C#
    in 7 days* using `Stack`, and showing the usage of properties and methods discussed
    in previous sections. This code resulted in the output shown in the following
    screenshot:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用`Stack`捕获了《7天学会C#》一书的利益相关者列表，并展示了前几节讨论的属性和方法的用法。这段代码产生了以下截图中显示的输出：
- en: '![](img/00083.gif)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00083.gif)'
- en: Queue
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Queue
- en: 'Queue is just a non-generic type that represents a FIFO collection of an object.
    There are two main actions of `queue`: when adding an item, it is called enqueuer,
    and when removing an item, it is called `dequeue`.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 队列只是一个表示对象的FIFO集合的非泛型类型。`queue`有两个主要操作：添加项目时称为enqueuer，移除项目时称为`dequeue`。
- en: Declaration of Queue
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列的声明
- en: 'The declaration of `Queue` is very similar to the way we declared other non-generic
    types. The following code snippet shows the same:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue`的声明与我们声明其他非泛型类型的方式非常相似。以下代码片段显示了相同的方式：'
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will discuss commonly used methods and properties of `Queue` next.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论`Queue`的常用方法和属性。
- en: Properties
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'The `Queue` class has only one property, which tells the count:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue`类只有一个属性，用于告诉计数：'
- en: '| **Property** | **Description** |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| `Count` | A getter property; returns the number of elements `queue` contained.For
    example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Count` | 一个getter属性；返回`queue`包含的元素数量。例如：'
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '|'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Methods
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'The following are the commonly used methods:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是常用的方法：
- en: '| **Method** | **Description** |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Object Peek()` | Returns the object at the top of the `queue` but does not
    remove it.For example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Object Peek()` | 返回`queue`顶部的对象，但不移除它。例如：'
- en: '[PRE46]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Object Dequeue()` | Removes and returns the object at the beginning of the
    `queue`.For example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Object Dequeue()` | 移除并返回`queue`开头的对象。例如：'
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Void Enqueue (object obj)` | Inserts an object at the end of the `queue`.For
    example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Void Enqueue (object obj)` | 在`queue`的末尾插入一个对象。例如：'
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Void Clear()` | Removes all elements from `Queue`.For example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Void Clear()` | 从`Queue`中移除所有元素。例如：'
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '|'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The following is the output of the preceding code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的输出：
- en: '![](img/00084.gif)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00084.gif)'
- en: BitArray
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BitArray
- en: BitArray is nothing but an array which manages an array of bit values. These
    values are represented as Boolean. True means bit is *ON* (1) and false means
    bit is *OFF*(0). This non-generic collection class is important when we need to
    store the bits.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: BitArray实际上是一个管理位值数组的数组。这些值被表示为布尔值。True表示位是*ON*（1），false表示位是*OFF*（0）。当我们需要存储位时，这个非泛型集合类是很重要的。
- en: The implementation of BitArray is not covered. Please refer to the exercises
    at the end of the chapter to implement BitArray.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: BitArray的实现没有涵盖。请参考本章末尾的练习来实现BitArray。
- en: We have discussed non-generic collections in this chapter. Generic collections
    are beyond the scope of this chapter; we will cover them on day six. To compare
    different collections, refer to [https://www.codeproject.com/Articles/832189/List-vs-IEnumerable-vs-IQueryable-vs-ICollection-v](https://www.codeproject.com/Articles/832189/List-vs-IEnumerable-vs-IQueryable-vs-ICollection-v).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章讨论了非泛型集合。泛型集合超出了本章的范围；我们将在第六天讨论它们。要比较不同的集合，请参考[https://www.codeproject.com/Articles/832189/List-vs-IEnumerable-vs-IQueryable-vs-ICollection-v](https://www.codeproject.com/Articles/832189/List-vs-IEnumerable-vs-IQueryable-vs-ICollection-v)。
- en: Hands - on exercise
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手练习
- en: 'Solve the following questions, which cover the concepts from today''s learning:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 解决以下问题，涵盖了今天学习的概念：
- en: What is reflection? Write a short program to use `System.Type`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是反射？编写一个使用`System.Type`的简短程序。
- en: Create a class that contains at least three properties, two constructors, two
    public methods, and three private methods, and implements at least one interface.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含至少三个属性、两个构造函数、两个公共方法和三个私有方法的类，并实现至少一个接口。
- en: Write a program with the use of `System.Reflection.Extensins` to assess the
    class created in question two.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，使用`System.Reflection.Extensins`来评估问题二中创建的类。
- en: Study the NuGet package `System.Reflection.TypeExtensions` and write a program
    by implementing all of its features.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习NuGet包`System.Reflection.TypeExtensions`，并编写一个程序来实现它的所有功能。
- en: Study the NuGet package `System.Reflection. Primitives` and write a program
    by implementing all of its features.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 学习NuGet包`System.Reflection. Primitives`，并编写一个程序来实现它的所有功能。
- en: What are delegate types and how can you define multicast delegates?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 委托类型是什么，如何定义多播委托？
- en: What are events? How are events are based on the publisher-subscriber model?
    Show this with the use of a real-world example.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是事件？事件是基于发布者-订阅者模型的吗？用一个现实世界的例子来展示这一点。
- en: Write a program using delegates and events to get an output similar to [https://github.com/garora/TDD-Katas#string-sum-kata](https://github.com/garora/TDD-Katas#string-sum-kata).
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个使用委托和事件的程序，以获得类似于[https://github.com/garora/TDD-Katas#string-sum-kata](https://github.com/garora/TDD-Katas#string-sum-kata)的输出。
- en: Define collections and implement non-generic types.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义集合并实现非泛型类型。
- en: Refer to our problem from day one, the vowel count problem, and implement this
    using all non-generic collection types.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 参考我们从第一天开始的问题，元音计数问题，并使用所有非泛型集合类型来实现它。
- en: Revisiting Day 05
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重温第05天
- en: Today, we have discussed very important concepts of C#, covering reflection,
    collections, delegates, and events.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们讨论了C#的非常重要的概念，涵盖了反射、集合、委托和事件。
- en: We discussed the importance of reflection in our code analysis approach. During
    the discussion, we implemented code showing the power of reflection, where we
    analyzed the complete code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代码分析方法中讨论了反射的重要性。在讨论过程中，我们实现了展示反射的强大之处的代码，分析了完整的代码。
- en: Then we discussed delegates and events and how delegates and events work in
    C#. We also implemented delegates and events.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了委托和事件，以及委托和事件在C#中的工作原理。我们还实现了委托和事件。
- en: One of the important and key features of the C# language that we discussed in
    detail was non-generic types, namely `ArrayList`, `HashTable`, `SortedList`, `Queue`,
    `Stack`, and so on. We implemented all these using C# 7.0 code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们详细讨论了C#语言的一个重要特性，即非泛型类型，即`ArrayList`、`HashTable`、`SortedList`、`Queue`、`Stack`等。我们使用C#
    7.0代码实现了所有这些。
