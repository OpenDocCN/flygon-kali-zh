- en: Chapter 4. Devising Microservices and N-Tier Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。设计微服务和N层应用程序
- en: 'Let''s expand on what we saw and learned in the last chapter about the more
    advanced development and deployment of microservices and N-tier applications.
    This chapter will address the underlying architectures for these design approaches
    as well as resolve typical issues faced while building these types of applications.
    We will cover the following topics in the chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展上一章中所看到和学到的关于微服务和N层应用程序更高级的开发和部署。本章将讨论这些设计方法的基础架构，以及在构建这些类型的应用程序时遇到的典型问题。本章将涵盖以下主题：
- en: Monolithic architectural pattern
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单片架构模式
- en: N-tier application architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: N层应用程序架构
- en: Building, testing, and automating N-tier applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建、测试和自动化N层应用程序
- en: Microservices architectural pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构模式
- en: Building, testing, and automating microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建、测试和自动化微服务
- en: Decoupling multi-tier applications into multiple images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多层应用程序解耦为多个图像
- en: Making different tiers of applications work
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使不同层的应用程序运行
- en: Nowadays, modern software built as services are giving rise to a shift in how
    applications are designed. Instead of using web frameworks to invoke services
    and produce web pages, applications today are built by consuming and producing
    APIs. Much has changed in the development and deployment of business applications,
    some of it dramatically and some of it either by revision or extension from the
    past design approaches, depending upon your viewpoint. Several architectural design
    approaches exist, and they are distinguishable by applications built for enterprise
    versus web versus Cloud.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，作为服务构建的现代软件正在引发应用程序设计方式的转变。如今，应用程序不再使用Web框架来调用服务和生成网页，而是通过消费和生成API来构建。在业务应用程序的开发和部署方面发生了许多变化，其中一些变化是戏剧性的，另一些变化是根据过去的设计方法进行修订或扩展的，这取决于您的观点。存在几种架构设计方法，它们可以通过为企业构建的应用程序与为Web构建的应用程序与云构建的应用程序进行区分。
- en: Development trends, over the last few years in particular, are awash with terms
    such as **microservices architecture** (**MSA**), applicable to a particular way
    of application design and development as suites of independently deployable services.
    The meteoric rise of the microservices architectural style is clearly an irrefutable
    force in today's development for deployment; there has been a considerable shift
    away from monolithic architecture and toward N-tier applications and microservices,
    but just how much of this is hype and how much of this can be honed?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年的发展趋势中，充斥着诸如**微服务架构**（MSA）之类的术语，这些术语适用于一种特定的应用程序设计和开发方式，即独立部署的服务套件。微服务架构风格的迅猛崛起显然是当今开发部署中不可否认的力量；从单片架构到N层应用程序和微服务的转变是相当大的，但这究竟有多少是炒作，有多少可以被磨练？
- en: Hype or hubris
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 炒作还是自负
- en: Before we begin diving deeply into troubleshooting, we ought to provide a basic contextual
    overview of modern applications and both the N-tier and microservices architectural
    styles. Knowing both the advantages and limitations of these architectural styles
    will help us plan for potential troubleshooting areas, and how we can avoid them.
    Containers are ideally suited for both of these architectural approaches, and
    we will discuss each one separately to give their proper due.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始深入研究故障排除之前，我们应该对现代应用程序以及N层和微服务架构风格进行基本的上下文概述。了解这些架构风格的优势和局限将有助于我们规划潜在的故障排除领域，以及我们如何避免它们。容器非常适合这两种架构方法，我们将分别讨论每种方法，以便给予它们适当的重视。
- en: Within all the noise, we sometimes forget that to deploy systems across these
    domains, one still has to create services and compose multiple services in working
    distributed applications. Here, it is important to understand the modern meaning
    of the term application. Applications are now primarily constructed as asynchronous
    message flows or synchronous request calls (if not both) that serve in forming
    collections of components or services allied by these connections. Participating
    services are highly distributive across variant machines and diverse Clouds (private,
    public, and hybrid).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有的噪音中，我们有时会忘记，要在这些领域部署系统，仍然需要创建服务，并在工作的分布式应用程序中组合多个服务。在这里，重要的是要理解术语“应用程序”的现代含义。应用程序现在主要是构建为异步消息流或同步请求调用（如果不是两者兼而有之），这些消息流或请求调用用于形成由这些连接联合的组件或服务的集合。参与的服务高度分布在不同的机器和不同的云（私有、公共和混合）之间。
- en: As for architectural styles, we shan't bother ourselves with too much comparison
    or engage in overly detailed discussions on what microservices actually are and
    whether they are any different from **Service-Oriented Architecture** (**SOA**)-there
    is certainly plenty of forum and related debate elsewhere for your choosing. With
    design principles rooted at least as far back as Unix, we will proffer no authoritative
    viewpoints in this book that the current microservices trend is either conceptually
    singular or entirely ingenious. Instead, we will put forward the major considerations
    for implementing this architectural approach and the benefits to be gained for
    modern applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于建筑风格，我们不会过多比较或进行过于详细的讨论，关于微服务到底是什么，以及它们是否与面向服务的架构（SOA）有任何不同-在其他地方肯定有很多论坛和相关的辩论可供选择。以Unix至少根植的设计原则为基础，我们在本书中不会提出任何权威观点，即当前的微服务趋势是概念上独特的或完全巧妙的。相反，我们将提出实施这种架构方法的主要考虑因素以及现代应用程序可以获得的好处。
- en: 'Use case still drives and dictates architectural approaches (or, in my opinion,
    should), and as such there is value in making some degree of comparative analysis
    among all predominant architectural styles: **monolithic**, **N-tier**, and **microservices**.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用例仍然驱动和决定架构方法（或者，在我看来，应该如此），因此在所有主要的架构风格之间进行一定程度的比较分析是有价值的：单体、N层和微服务。
- en: Monolithic architecture
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体架构
- en: Monoliths are essentially one deployment unit housing all services and dependencies,
    making them easy to develop, easy to test, relatively easy to deploy and, initially,
    easy to scale. However, this style does not meet the requisite needs for most
    modern enterprise applications (N-tier) and web development at scale, and certainly
    not (microservices) applications being deployed to the Cloud. Change cycles are
    tightly coupled-any changes made, even to the smallest parts of an application,
    require wholesale rebuilds and redeployments for the entire monolith. As the monolith
    matures, any attempts at scaling require scaling of the entire application rather
    than the individual parts, which specifically require greater resources, becoming
    altogether nightmarish, if not improbable. At this point, a monolithic application
    has become overly complex, weighted with vast lines of code that is ever-increasingly
    difficult to decipher, such that business-critical items like bug fixes or implementing
    new features become too much of a time drain to ever attempt. As the code base
    becomes unintelligible, it is only reasonable to expect any changes made likely
    to be done incorrectly. The burgeoning size of the application not only slows
    development, it impedes continuous development altogether; to update any part
    of a monolith, the entire app must be redeployed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用本质上是一个部署单元，包含所有服务和依赖关系，使其易于开发、易于测试、相对容易部署，并且最初易于扩展。然而，这种风格不符合大多数现代企业应用程序（N层）和大规模Web开发的必要需求，当然也不适用于部署到云端的微服务应用程序。变更周期紧密耦合-对应用程序的任何更改，甚至是最小的部分，都需要对整个单体进行全面重建和重新部署。随着单体的成熟，任何尝试扩展都需要扩展整个应用程序而不是单个部分，这特别需要更多的资源，变得非常困难，甚至不可能。在这一点上，单体应用程序变得过于复杂，充斥着越来越难以解读的大量代码，以至于像错误修复或实施新功能这样的业务关键项目变得太耗时，根本无法尝试。随着代码库变得难以理解，可以合理地预期任何更改可能会出现错误。应用程序的不断增长不仅减缓了开发速度，而且完全阻碍了持续开发；要更新单体的任何部分，必须重新部署整个应用程序。
- en: '![Monolithic architecture](graphics/Untitled.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![单体架构](graphics/Untitled.jpg)'
- en: Monolithic architectural pattern
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 单体架构模式
- en: Other problems with monoliths abound, resources cannot be catered to better
    meet needs, for example, CPU or memory requirements. Since all modules are running
    the same processes, any bug can potentially bring the entire process to a halt.
    Lastly, it becomes much more difficult to adopt newer frameworks or languages,
    creating a huge barrier to adopt new technologies-you are likely stuck with whatever
    technology choices you made at the beginning of the project. Needless to say,
    your needs may have changed rather dramatically since the beginning. Using obsolete,
    unproductive technology makes keeping and bringing in new talent more difficult.
    The application has now become very difficult to scale and is unreliable, making
    agile development and delivery of applications impossible. The initial ease and
    simplicity of a monolith quickly become its own Achilles heel.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序的其他问题也很多，资源无法更好地满足需求，例如CPU或内存需求。由于所有模块都在运行相同的进程，任何错误都有可能导致整个进程停止。最后，更难以采用新的框架或语言，这给采用新技术带来了巨大障碍-您可能会被困在项目开始时所做的技术选择中。不用说，自项目开始以来，您的需求可能已经发生了相当大的变化。使用过时的、低效的技术使得留住和引进新人才变得更加困难。应用程序现在变得非常难以扩展和不可靠，使得敏捷开发和交付应用程序变得不可能。单体应用程序最初的简单和便利很快变成了它自己的致命弱点。
- en: As these monolithic architectures are basically one deployment unit that does
    everything–N-tier and microservices architectures have arisen to address the specialized
    service needs of modernized applications, primarily Cloud and mobile-based.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些单片架构基本上是一个执行单元，可以完成所有任务，N层和微服务架构已经出现，以解决现代化应用程序，主要是云和移动应用程序的专门服务需求。
- en: N-tier application architecture
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: N层应用架构
- en: In order to understand N-tier applications and their potential for decoupling
    into microservices, we will hold its comparison against the monolithic style since
    both the development of N-tier applications and proliferation of microservices
    exist to address many of the problems found in the outdated conditions we've found
    resulting from the approach of monolithic architectures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解N层应用程序及其分解为微服务的潜力，我们将其与单片样式进行比较，因为N层应用程序的开发和微服务的普及都是为了解决单片架构所带来的过时条件中发现的许多问题。
- en: The N-tier application architecture, also referred to as **distributed applications**
    or **multi-tier**, proffers a model in which developers can create flexible and
    reusable applications. As the application is segregated into tiers, developers
    are empowered by the option of modifying or adding a specific tier or layer instead
    of requiring a rework of the entire application as would be necessary under monolithic.
    A multi-tier application is any application developed and distributed among more
    than one layer. It logically separates the different application-specific and
    operational layers. The number of layers varies by business and application requirements,
    but three-tier is the most commonly used architecture. Multi-tier applications
    are used to divide enterprise applications into two or more components that may
    be separately developed, tested, and deployed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: N层应用架构，也称为**分布式应用**或**多层**，提供了一个模型，开发人员可以创建灵活和可重用的应用程序。由于应用程序被分为多个层，开发人员可以选择修改或添加特定的层或层，而不需要对整个应用程序进行重新设计，这在单片应用程序下是必要的。多层应用程序是指分布在多个层之间的任何应用程序。它在逻辑上分离了不同的应用程序特定和操作层。层的数量根据业务和应用程序要求而变化，但三层是最常用的架构。多层应用程序用于将企业应用程序划分为两个或多个可以分别开发、测试和部署的组件。
- en: N-tier applications are essentially SOA that attempt to address some of the
    issues with antiquated monolothic design architecture. As we have seen in the previous chapters,
    Docker containers are a perfect match for N-tier application development.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: N层应用程序本质上是SOA，试图解决过时的单片设计架构的一些问题。正如我们在之前的章节中所看到的，Docker容器非常适合N层应用程序开发。
- en: '![N-tier application architecture](graphics/Untitled-1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![N层应用架构](graphics/Untitled-1.jpg)'
- en: N-tier application architecture
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: N层应用架构
- en: 'A common N-tier application consists of three layers: a **PRESENTATION TIER**
    (providing basic user interface and application services access), a **DOMAIN LOGIC
    TIER** (providing the mechanism used to access and process data), and a **DATA
    STORAGE TIER** (which holds and manages data that is at rest).'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的N层应用程序由三层组成：**表示层**（提供基本用户界面和应用程序服务访问）、**领域逻辑层**（提供用于访问和处理数据的机制）和**数据存储层**（保存和管理静态数据）。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While the concepts of layer and tier are often used interchangeably, a fairly
    common point of view is that there is actually a difference. This view holds that
    a *layer* is a logical structuring mechanism for the elements that make up the
    software solution, while a *tier* is a physical structuring mechanism for the
    system infrastructure. Unless otherwise specifically noted in our book, we will
    use tier and layer interchangeably.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然层和层经常可以互换使用，但一个相当普遍的观点是实际上存在差异。这个观点认为*层*是构成软件解决方案的元素的逻辑结构机制，而*层*是系统基础设施的物理结构机制。除非在我们的书中另有特别说明，否则我们将互换使用层和层。
- en: The easiest way to separate the various tiers in an N-tier application is to
    create discrete projects for each tier that you want to include in your application.
    For example, the presentation tier might be a Windows forms application, whereas
    the data access logic might be a class library located in the middle tier. Additionally,
    the presentation layer might communicate with the data access logic in the middle
    tier through a service. Separating application components into separate tiers
    increases the maintainability and scalability of the application. It does this
    by enabling easier adoption of new technologies that can be applied to a single
    tier without the requirement to redesign the whole solution. In addition, N-tier
    applications typically store sensitive information in the middle tier, which maintains
    isolation from the presentation tier.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将各种层在N层应用程序中分开的最简单方法是为您的应用程序中要包含的每个层创建单独的项目。例如，表示层可能是一个Windows表单应用程序，而数据访问逻辑可能是位于中间层的类库。此外，表示层可能通过服务与中间层的数据访问逻辑进行通信。将应用程序组件分离到单独的层中可以增加应用程序的可维护性和可扩展性。它可以通过使新技术更容易地应用于单个层而无需重新设计整个解决方案来实现这一点。此外，N层应用程序通常将敏感信息存储在中间层中，以保持与表示层的隔离。
- en: Probably the most common example of N-tier app development is websites; an example
    of this can be seen in the `cloudconsulted/joomla` image we used in the last chapter,
    where Joomla, Apache, MySQL, and PHP were all *layered* as tiers into a single
    container.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: N层应用程序开发的最常见示例可能是网站；在我们上一章中使用的`cloudconsulted/joomla`镜像中可以看到这样的示例，其中Joomla、Apache、MySQL和PHP都被*分层*为单个容器。
- en: It will be easy enough for us to simply recursively use our `cloudconsulted/joomla`
    image (from earlier) here, but let's build a classic three-tiered web application
    to expose ourselves to some other application potential as well as introduce another
    unit test tool for our development teams.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，很容易简单地递归使用我们之前的`cloudconsulted/joomla`镜像，但让我们构建一个经典的三层Web应用程序，以暴露自己于一些其他应用潜力，并为我们的开发团队引入另一个单元测试工具。
- en: Building a three-tier web application
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个三层Web应用程序
- en: 'Let''s develop and deploy a real-world three-tier web application with the
    help of the following containers:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助以下容器开发和部署一个真实的三层Web应用程序：
- en: 'NGINX > Ruby on Rails > PostgreSQL:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX > Ruby on Rails > PostgreSQL：
- en: 'The NGINX Docker container (Dockerfile), as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX Docker容器（Dockerfile）如下：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Ruby on Rails Docker container (Dockerfile), as shown:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示的Ruby on Rails Docker容器（Dockerfile）：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The PostgreSQL Docker container, as illustrated:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示的PostgreSQL Docker容器：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding Dockerfiles can be used to deploy a three-tier web application
    and help us get started with microservices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述Dockerfile可用于部署三层Web应用程序，并帮助我们开始使用微服务。
- en: Microservices architecture
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构
- en: 'To begin explaining the microservice architectural style, it will prove beneficial
    to again compare to the monolithic, as we did with N-tier. As you may recall,
    a monolithic application is constructed as a single unit. Also, recall that monolithic
    enterprise applications are often built around three primary tiers: a client-side
    user interface (comprising of HTML pages and JavaScript running in a browser on
    the user''s machine), a database (comprising of many tables inserted into a common,
    and usually relational, database management system), and a server-side application
    (which handles HTTP requests, executes domain logic, retrieves and updates data
    from the database, and selects and populates HTML views to be sent to the browser).
    This classic version of a monolithic enterprise application is a single, logical
    executable. Any changes to the system involve building and deploying a new version
    of the server-side application, and changes in the underlying technology are likely
    not prudent.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始解释微服务架构风格，将有利于再次与单片进行比较，就像我们在N层中所做的那样。您可能还记得，单片应用是作为一个单一单位构建的。还要记住，单片企业应用通常围绕三个主要层构建：客户端用户界面（包括在用户机器上的浏览器中运行的HTML页面和JavaScript）、数据库（包括插入到一个常见且通常是关系型数据库管理系统中的许多表）和服务器端应用程序（处理HTTP请求，执行领域逻辑，从数据库中检索和更新数据，并选择和填充要发送到浏览器的HTML视图）。这种经典版本的单片企业应用是一个单一的逻辑可执行文件。对系统的任何更改都涉及构建和部署服务器端应用程序的新版本，并且更改底层技术可能是不明智的。
- en: The path to modernity
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通往现代化的道路
- en: 'Microservices represent the convergence of the modern Cloud and modern application
    development, structured around the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务代表了现代云和现代应用开发的融合，围绕以下结构：
- en: Componentized services
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件化服务
- en: Organization around business capabilities
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕业务能力的组织
- en: Products, not projects
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品，而不是项目
- en: Smart endpoints and dumb pipes
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能端点和愚蠢的管道
- en: Decentralized governance and data management
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分散式治理和数据管理
- en: Infrastructure automation
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施自动化
- en: 'Here, monolithic typically focuses on **enterprise service bus** (**ESB**) used
    to integrate monolithic applications, modern application design is API driven.
    These modern applications embrace APIs on all sides: on the frontend for connecting
    to rich clients, the backend for integrating with internal systems, and on the
    sides to allow other applications access to their internal data and processes.
    Rather than leveraging the more complicated traditional enterprise mechanisms,
    many developers are finding that the same lightweight API services that have proven
    to be resilient, scalable, and agile for frontend, backend, and application-to-application
    scenarios can also be leveraged for application assembly. What is also compelling
    is that containers, and especially so within a microservices architectural approach,
    alleviate the perennial issue of developers being blocked out of architectural
    decisions while still realizing the benefits of repeatability. The use of preapproved
    container configurations.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，单片通常侧重于用于集成单片应用的企业服务总线（ESB），现代应用设计是API驱动的。这些现代应用在各个方面都采用API：在前端用于连接富客户端，在后端用于与内部系统集成，并在侧面允许其他应用访问其内部数据和流程。许多开发人员发现，与更复杂的传统企业机制相比，那些已被证明对前端、后端和应用程序之间的场景具有弹性、可扩展性和敏捷性的轻量级API服务也可以用于应用程序组装。同样引人注目的是，容器，尤其是在微服务架构方法中，缓解了开发人员被阻止参与架构决策的永恒问题，同时仍然实现了可重复性的好处。使用经过预先批准的容器配置。
- en: Microservices architectural pattern
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务架构模式
- en: 'Here, we illustrate that instead of a single, monstrous monolithic application,
    we have split the application into smaller, interconnected services (that is,
    microservices) that implement each functional area of the application. This allows
    us to deploy directly to address the needs of specialized use cases or specific
    devices or users /or/ the microservices approach, in a nutshell, dictates that
    instead of having one giant code base that all developers touch, which often becomes
    perilous to manage, there are numerous smaller code bases managed by small and
    agile teams. The only dependency these code bases have on one another is their
    APIs:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们说明了，我们没有一个单一的庞大的单片应用程序，而是将应用程序分割成更小、相互连接的服务（即微服务），每个功能区域实现一个。这使我们能够直接部署以满足专用用例或特定设备或用户的需求，或者微服务方法，简而言之，规定了我们不是拥有所有开发人员都接触的一个巨大的代码库，这通常变得难以管理，而是由小而敏捷的团队管理的许多较小的代码库。这些代码库之间唯一的依赖是它们的API：
- en: '![Microservices architectural pattern](graphics/Untitled-2.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: 微服务架构模式
- en: Microservices architectural pattern
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构模式
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A common discussion around microservices is debate over whether this is just
    SOA. Some validity exists on this point as the microservice style does share some
    of the advocacies of SOA. In reality, SOA means a host of many different things.
    As such, we submit and will attempt to show that while shared similarities do
    exist, SOA remains significantly different from the microservices architectural
    style as presented herein.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 围绕微服务的一个常见讨论是关于这是否只是SOA。在这一点上存在一些有效性，因为微服务风格确实分享了SOA的一些主张。实际上，SOA意味着许多不同的事情。因此，我们提出并将尝试表明，虽然存在共同的相似之处，但SOA与此处所呈现的微服务架构风格仍然存在显着差异。
- en: Common characteristics of microservices
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务的共同特征
- en: While we will not attempt a formal definition of the microservices architectural
    style, there are some common characteristics we can certainly use to identify
    it. Microservices are generally designed around business capabilities and priorities
    and include multiple component services that can be automated for deployment independently
    without compromising the application, intelligence endpoints, and decentralized
    control of languages and data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会尝试对微服务架构风格进行正式定义，但有一些共同的特征我们当然可以用来识别它。微服务通常围绕业务能力和优先级进行设计，并包括多个组件服务，可以独立自动化部署，而不会影响应用程序、智能端点和语言和数据的分散控制。
- en: 'To provide some basis then, if not common ground, to follow is an outline that
    can be seen as the common characteristics for architectures that fit the *microservices*
    label. It should be understood that not all microservice architectures will exhibit
    all characteristics at all times. Since we do, however, have expectations that
    most microservice architectures will exhibit most of these characteristics, let''s
    list them:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一些基础，如果不是共同的基础，以下是一个可以被视为符合*微服务*标签的架构的共同特征的概述。应该理解的是，并非所有的微服务架构都会始终展现所有的特征。然而，我们期望大多数微服务架构将展现大部分这些特征，让我们列举一下：
- en: Independent
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立
- en: Stateless
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态
- en: Asynchronous
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步
- en: Single responsibility
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责
- en: Loosely coupled
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散耦合
- en: Interchangeable
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可互换
- en: Advantages of microservices
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务的优势
- en: 'The common characteristics of microservices we just listed also serve to itemize
    their advantages. Without meaning to belabor the issue over too much redundancy,
    let''s at least canvass the main advantage points:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚列出的微服务的共同特征也用于列举它们的优势。而不是要过多地重复，让我们至少审视一下主要的优势点：
- en: '**Microservices enforce a level of modularity**: This is extremely difficult
    to accomplish in practice with a monolithic architecture. The microservices advantage
    is that individual services are much faster to develop, much easier to understand,
    and much easier to maintain.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务强制实施一定程度的模块化：这在单片架构中实际上非常难以实现。微服务的优势在于单个服务开发速度更快，更容易理解，更容易维护。
- en: '**Microservices enable each service to be developed independently**: This is
    done by teams specifically focused on that service. The microservices advantage
    is empowering developers with the freedom to choose whatever technology is best
    suited or makes better sense, so long as that service honors the API contract.
    By default, this also means that developers are no longer trapped with potentially
    obsolete technologies from a project''s beginning, or when starting a new project.
    Not only does an option exist to employ the current technology, but with a relatively
    small service size it is also now feasible to rewrite older services using a more
    relevant and reliable technology.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务使每个服务能够独立开发：这是由专门专注于该服务的团队完成的。微服务的优势在于赋予开发人员选择最适合或更合理的技术的自由，只要该服务遵守API合同。这也意味着开发人员不再被困在项目开始时或开始新项目时可能过时的技术中。不仅存在使用当前技术的选项，而且由于服务规模相对较小，现在还可以使用更相关和可靠的技术重写旧服务。
- en: '**Microservices enable each service to be deployed continuously**: Developers
    needn''t coordinate the deployment of changes that are localized to their service.
    The microservices advantage is in continuous deployment-deployment takes place
    as soon as changes are successfully tested.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务使每个服务能够持续部署：开发人员无需协调局部更改的部署。微服务的优势在于持续部署-只要更改成功测试，部署就会立即进行。
- en: '**Microservices enable each service to be scaled independently**: You need
    to deploy only the instances of each service necessary to satisfy the capacity
    and availability constraints. Additionally, we can also succinctly match the hardware
    to fulfill a service''s resource requirements (for example, compute or memory
    optimized hardware for CPU and memory-intensive services). The microservices advantage
    is in not only matching capacity and availability, but leveraging user-specific
    hardware optimized for a service.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务使每个服务能够独立扩展：您只需部署每个服务实例以满足容量和可用性约束。此外，我们还可以简洁地匹配硬件以满足服务的资源需求（例如，为CPU和内存密集型服务优化的计算或内存优化硬件）。微服务的优势在于不仅匹配容量和可用性，而且利用为服务优化的用户特定硬件。
- en: All of these advantages are extremely advantageous, but for the next bit let's
    elaborate on the point of scalability. As we've seen with monolithic architectures,
    while easy to initialize scaling, it is certainly deficient in executing it over
    time; bottlenecks abound and, eventually, it's approach to scaling is vastly untenable.
    Fortunately, microservices as an architectural style supremely excels at scaling.
    A quintessential book, *THE ART OF SCALABILITY* ([http://theartofscalability.com/](http://theartofscalability.com/)) illustrates
    a highly useful, three-dimensional model of scalability in a *scale cube* ([http://microservices.io/articles/scalecube.html](http://theartofscalability.com/)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些优势都非常有利，但接下来让我们详细阐述可伸缩性的观点。正如我们在单片架构中所看到的，虽然易于初始化扩展，但在随着时间的推移执行扩展时显然存在不足；瓶颈随处可见，最终，其扩展方法是极不可行的。幸运的是，作为一种架构风格，微服务在扩展方面表现出色。一本典型的书，《可伸缩性的艺术》（[http://theartofscalability.com/](http://theartofscalability.com/)）展示了一个非常有用的三维可伸缩性模型，即*可伸缩性立方体*（[http://microservices.io/articles/scalecube.html](http://theartofscalability.com/)）。
- en: Microservices at scalability
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可伸缩的微服务
- en: In the provided model, along the X-axis scaling (that is, Monolothic) we can
    see the common horizontal duplication approach, scaling an application by running
    multiple, cloned copies of that application behind a load balancer. This results
    in improved application capacity and availability.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的模型中，沿着X轴进行扩展（即，单体应用程序），我们可以看到常见的水平复制方法，通过在负载平衡器后运行应用程序的多个克隆副本来扩展应用程序。这将提高应用程序的容量和可用性。
- en: '![Microservices at scalability](graphics/image_04_004.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![可扩展的微服务](graphics/image_04_004.jpg)'
- en: Microservices at scalability
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展的微服务
- en: Moving along the Z-axis for scaling (that is N-tier/SOA), each server runs identical
    copies of code (similar to X-axis). The difference here comes in that each server
    is responsible solely for a strict subset of the data (that is, data partitioning
    or scaling by splitting into similar things). A given component of the system
    therefore has responsibility for routing a given request to an appropriate server.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在Z轴上进行扩展（即N层/SOA），每个服务器运行代码的相同副本（类似于X轴）。这里的区别在于每个服务器仅负责严格的数据子集（即数据分区或通过将数据拆分为相似的内容进行扩展）。因此，系统的某个组件负责将特定请求路由到适当的服务器。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Sharding** is a commonly used routing criteria where an attribute of the
    request is used to route the request to a particular server (for example, the
    primary key of a row or identity of a customer).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**分片**是一种常用的路由标准，其中使用请求的属性将请求路由到特定服务器（例如，行的主键或客户的身份）。'
- en: Just as with X-axis scaling, Z-axis scaling serves to improve application capacity
    and availability. However, as we learned in this chapter, neither the monolithic
    or N-tier approach (X- and Y-axis scaling) will resolve the inherent problems
    of our ever-increasing development and application complexities. To effectively
    deal with these issues, we need to apply Y-axis scaling (that is, microservices).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与X轴扩展一样，Z轴扩展旨在提高应用程序的容量和可用性。然而，正如我们在本章中所了解的，单体或N层方法（X和Y轴扩展）都无法解决我们不断增加的开发和应用程序复杂性的固有问题。要有效地解决这些问题，我们需要应用Y轴扩展（即，微服务）。
- en: This third dimension to scaling (Y-axis) involves functional decomposition,
    or scaling by splitting into different things. Occurring at the application tier,
    Y-axis scaling will split a monolithic application into separate sets of services
    wherein each service implements a set of allied functionalities (for example,
    customer management, order management, and so on). Later in this chapter, we will
    look directly into the decomposition of services.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的第三个维度（Y轴）涉及功能分解，或通过将不同的内容拆分来进行扩展。在应用程序层发生的Y轴扩展将把单体应用程序分解为不同的服务集，其中每个服务实现一组相关功能（例如，客户管理，订单管理等）。在本章后面，我们将直接探讨服务的分解。
- en: What we can typically see are applications that utilize all the three axes of
    the scaling cube together. Y-axis scaling decomposes the application into microservices;
    at runtime, X-axis scaling executes multiple instances of each service behind
    a load balancer for enhanced output and availability, and some applications may
    additionally use Z-axis scaling for partition of services.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常可以看到的是利用了扩展立方体的三个轴的应用程序。Y轴扩展将应用程序分解为微服务；在运行时，X轴扩展在负载平衡器后执行每个服务的多个实例，以增强输出和可用性，一些应用程序可能还会使用Z轴扩展来分区服务。
- en: Disadvantages of microservices
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 微服务的缺点
- en: 'Let''s do our full due diligence here by also understanding some of the disadvantages
    of microservices:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过了解一些微服务的缺点来全面尽职调查：
- en: '**Deploying a microservices-based application is much more complex**: In contrast
    to monolithic applications, a microservice application typically consists of a
    large number of services. Defacto, we have greater complexity in deploying them.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于微服务的应用部署要复杂得多**：与单片应用相比，微服务应用通常由大量服务组成。事实上，我们在部署它们时会面临更大的复杂性。'
- en: '**Management and orchestration of microservices is much more complex**: Each
    service, within a large number of services, will have multiple runtime instances.
    An exponential increase occurs across many more moving parts that require configuration,
    deployment, scaling, and monitoring. Any successful microservices deployment,
    therefore, requires more granular control of deployment methods by developers
    combined with a high level of automation.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理和编排微服务要复杂得多**：在大量服务中，每个服务都将有多个运行时实例。随着更多需要配置、部署、扩展和监控的移动部件的指数级增加。因此，任何成功的微服务部署都需要开发人员对部署方法进行更细粒度的控制，同时结合高水平的自动化。'
- en: '**Testing a microservices application is much more complex**: Writing test
    classes for a microservices application does not only require that service to
    be started, but also its dependency services.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试微服务应用要复杂得多**：为微服务应用编写测试类不仅需要启动该服务，还需要启动其依赖服务。'
- en: Once understood, we can strategize and design to mitigate these drawbacks and
    better plan for troubleshooting areas.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦理解，我们就可以制定策略和设计来减轻这些缺点，并更好地规划故障排除领域。
- en: Considerations for devising microservices
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制定微服务的考虑
- en: We have reviewed the transgression from single delivery to multi-tier to containerized
    microservices, and understand that each has its own functional place for application.
    Each architecture carries its own degree of validity; appropriate design strategy
    and application of these architectures is necessary for your deployment successes.
    Having learned the basic tenets for monolithic, N-tier, and microservices, we
    are better equipped toward strategically implementing the best-suited architectures
    on a per use case basis.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经审查了从单一交付到多层到容器化微服务的违规行为，并了解到每种应用都有其自己的功能位置。每种架构都有其自己的有效程度；适当的设计策略和这些架构的应用对于您的部署成功是必要的。通过学习了解了单片、N层和微服务的基本原则，我们更有能力根据每种情况来战略性地实施最合适的架构。
- en: '![Considerations for devising microservices](graphics/Untitled-3.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![制定微服务的考虑](graphics/Untitled-3.jpg)'
- en: From mono to micro
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从单一到微服务
- en: The microservice architectural pattern is a better choice for complex, evolving
    applications despite the drawbacks and implementation challenges. To utilize microservices
    for modern Cloud and web application design and deployment, how best do we leverage
    the advantages of microservices while mitigating the potential drawbacks?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在缺点和实施挑战，微服务架构模式是复杂、不断发展的应用的更好选择。为了利用微服务进行现代云和Web应用程序的设计和部署，我们如何最好地利用微服务的优势，同时减轻潜在的缺点？
- en: 'Whether developing a new application or reinvigorating an old one, these considerations
    must be taken into account for microservices:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是开发新应用还是重振旧应用，这些考虑因素都必须考虑到微服务：
- en: Building and maintaining highly available distributed systems is complex
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和维护高可用的分布式系统是复杂的
- en: More moving parts means more components to keep track of
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的移动部件意味着需要跟踪更多的组件
- en: Loosely coupled services means that steps need to be taken to keep data consistent
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散耦合的服务意味着需要采取步骤来保持数据一致
- en: Distributed asynchronous processes create network latency and more API traffic
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式异步进程会产生网络延迟和更多的API流量
- en: Testing and monitoring individual services is challenging
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和监控单个服务是具有挑战性的
- en: Mitigating the disadvantages
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 减轻缺点
- en: This is likely the most simplistic instruction provided in the entire book;
    however, time and again we witness the obvious either completely ignored, overlooked,
    or underpursued. Our submission here is that, in spite of the relatively few but
    known disadvantages, there exist both current and evolving mechanisms to resolve
    almost all of these issues; expectation is strong that the container market will
    evolve a plethora of working solutions to the current issues.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是整本书中提供的最简单的指导；然而，我们一次又一次地看到明显的事情要么完全被忽视，要么被忽视，要么被忽视。我们在这里提交的观点是，尽管已知的缺点相对较少，但存在着当前和不断发展的机制来解决几乎所有这些问题；人们强烈期望容器市场将发展出大量解决当前问题的解决方案。
- en: 'Once again, let''s just start with the most basic elements here as the foundation
    of successful microservices applications that require less troubleshooting:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们从这里开始，作为需要更少故障排除的成功微服务应用程序的基础：
- en: '**Take total ownership**: Without taking full ownership and knowing that ultimate
    success is directly up to you and your team, your projects and their resulting
    applications will suffer. Commitment, dedication, and persistence pay handsome
    results.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全面负责**：如果不全面负责并知道最终的成功直接取决于你和你的团队，你的项目及其产生的应用程序将受到影响。承诺、奉献和坚持会带来丰厚的成果。'
- en: '**Develop a complete understanding**: Fully comprehend what the business goals
    are and what technologies can be best applied to address them, not to mention
    the *how* and *why* for which you are using them. Always be learning!'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全面理解**：充分理解业务目标以及最适合解决这些目标的技术，更不用说你使用它们的“如何”和“为什么”。始终在学习！'
- en: '**Pursue exhaustive, coordinated planning**: Plan strategically, plan along with
    other application stakeholders, plan for failure, and then plan some more; Measure
    your results and revise the plan, re-evaluating the plan on a continuum. Always
    be measuring, and always be planning!'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进行详尽协调的规划**：战略性地规划，与其他应用程序利益相关者一起规划，为失败做规划，然后再做更多规划；衡量你的结果并修订计划，不断重新评估计划。始终在衡量，始终在规划！'
- en: '**Utilize the current technology**: It is imperative in today''s technology
    climate to make good use of the most stable and functional tools and applications;
    so, seek them out.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用当前技术**：在当今的技术环境中，充分利用最稳定和功能齐全的工具和应用程序至关重要；因此，寻找它们。'
- en: '**Evolve with the application**: You must be as agile and adaptable as the
    container technologies you are using; change must be an accepted part of your
    exhaustive, coordinated planning!'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随着应用程序的发展**：你必须像你正在使用的容器技术一样灵活和适应；变化必须成为你详尽协调规划的一部分！'
- en: Great! We know that we must not only acknowledge, but actively participate in
    the most basic elements of our application project process. We also know and understand
    the advantages and disadvantages of a microservices architectural approach, and
    that those advantages have the potential to far outweigh any negatives. Outside
    of the preceding five powerful items, how do we mitigate these drawbacks to use
    the positives afforded to us with microservices to our benefit?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们知道我们不仅必须承认，而且要积极参与我们应用项目过程的最基本要素。我们也知道并理解微服务架构方法的优缺点，以及这些优点可能远远超过任何负面影响。除了前面提到的五个强大的要素之外，我们如何减轻这些缺点，以利用微服务为我们带来的积极影响呢？
- en: Managing microservices
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理微服务
- en: At this point, you may be asking yourself "so, where does Docker fit into this
    conversation?" Our first tongue in cheek answer is that it fits in perfectly,
    indeed!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你可能会问自己“那么，Docker在这场对话中的位置在哪里？”我们的第一个半开玩笑的答案是，它完全合适！
- en: 'Docker is excellent for microservices as it isolates containers to one process
    or service. This intentional containerization of single services or processes
    makes it very simple to manage and update these services. Therefore, it''s not
    surprising that the next wave on top of Docker has led to the emergence of frameworks
    for the sole purpose of managing more complex scenarios, including as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Docker非常适合微服务，因为它将容器隔离到一个进程或服务中。这种有意的单个服务或进程的容器化使得管理和更新这些服务变得非常简单。因此，毫不奇怪，在Docker之上的下一个浪潮导致了专门用于管理更复杂场景的框架的出现，包括以下内容：
- en: How to manage single services in a cluster?
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在集群中管理单个服务？
- en: How to manage multiple instances in a service across hosts?
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在主机上跨多个实例中管理一个服务？
- en: How to coordinate between multiple services on a deployment and management level?
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在部署和管理层面协调多个服务？
- en: As expected within a maturing container market, we are seeing additional complementary
    tools emerge to go along with open source projects, such as Kubernetes, MaestroNG,
    and Mesos to only name but a few-all arising to address the management, orchestration,
    and automation needs for containerized applications with Docker. Kubernetes, as
    an example, is a project built especially for microservices and works extremely
    well with Docker. The key features of Kubernetes cater directly to the exact traits
    so imperative within the microservices architecture-easy deployment of new services
    via Docker, independent scaling of services, end-client transparency to failures,
    and simple, ad-hoc name-based discovery of service endpoints. Further, Docker's
    own native projects-Machine, Swarm, Compose, and Orca, while currently still in
    beta at the time of this writing, look highly promising-will likely soon be added
    to the Docker core kernel.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在不断成熟的容器市场中所预期的那样，我们看到了更多的辅助工具出现，以配合开源项目，例如Kubernetes、MaestroNG和Mesos等等，所有这些都是为了解决Docker容器化应用程序的管理、编排和自动化需求。例如，Kubernetes是专门为微服务构建的项目，并且与Docker非常配合。Kubernetes的关键特性直接迎合了微服务架构中至关重要的特征-通过Docker轻松部署新服务、独立扩展服务、终端客户端对故障的透明性以及简单的、临时的基于名称的服务端点发现。此外，Docker自己的原生项目-Machine、Swarm、Compose和Orca，虽然在撰写本文时仍处于测试阶段，但看起来非常有前途-很可能很快就会被添加到Docker核心内核中。
- en: Since we will later dedicate examples and discussion to Kubernetes, other third-party
    applications and an entire chapter to Docker Machine, Swarm, and Compose, let's
    look at an example here utilizing services we used earlier (NGINX, Node.js) along
    with Redis and Docker Compose.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们稍后将专门讨论Kubernetes、其他第三方应用程序以及整个章节的Docker Machine、Swarm和Compose，让我们在这里看一个例子，利用我们之前使用过的服务（NGINX、Node.js）以及Redis和Docker
    Compose。
- en: Real-world example
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真实世界的例子
- en: NGINX > Node.js > Redis > Docker Compose
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX > Node.js > Redis > Docker Compose
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will delve more thoroughly into Docker Compose in [Chapter 10](ch10.html
    "Chapter 10. Docker Deployment in a Public Cloud - AWS and Azure"), *Docker Machine,
    Compose and Swarm*. Additionally, we will also need to implement a service discovery
    mechanism (discussed in a later chapter) that enables a service to discover the
    locations (hosts and ports) of any other services it needs to communicate with.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第10章](ch10.html "第10章。AWS和Azure公共云中的Docker部署")中更深入地探讨Docker Compose，*Docker
    Machine、Compose和Swarm*。此外，我们还需要实现一个服务发现机制（在后面的章节中讨论），使服务能够发现其需要与之通信的任何其他服务的位置（主机和端口）。
- en: Automated tests and deployments
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化测试和部署
- en: We want as much confidence as possible that our applications are working; that
    starts with automated testing to facilitate our automated deployments. Needless
    to say, our automated tests are mission-critical. Promotion of working software
    *up* the pipeline means we automate deployment to each new environment.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望尽可能多地确信我们的应用程序正在运行；这始于自动化测试，以促进我们的自动化部署。不用说，我们的自动化测试是至关重要的。推动工作软件*上*管道意味着我们自动化部署到每个新环境。
- en: The testing of microservices right now is still relatively complex; as we've
    discussed, test classes for a service will require a launch of that service in
    addition to any services it depends upon. We at least need to configure stubs
    for those services. All this can be done, but let's look into mitigating its complexity.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，微服务的测试仍然相对复杂；正如我们讨论过的，对于一个服务的测试类将需要启动该服务，以及它所依赖的任何服务。我们至少需要为这些服务配置存根。所有这些都可以做到，但让我们来研究如何减少其复杂性。
- en: Automated testing
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化测试
- en: 'Strategically, we need to map out our design flow to include testing to validate
    our applications for deployment into production. Here''s an example workflow of
    what we want to accomplish with our automated testing:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从战略上讲，我们需要规划我们的设计流程，包括测试，以验证我们的应用程序是否可以部署到生产环境。以下是我们希望通过自动化测试实现的示例工作流程：
- en: '![Automated testing](graphics/image_04_006.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![自动化测试](graphics/image_04_006.jpg)'
- en: The preceding diagram represents a DevOps pipeline starting with code compilation
    and moving to integration test, performance test and, finally, the app getting
    deployed in a production environment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表代表了一个DevOps管道，从代码编译开始，经过集成测试、性能测试，最终在生产环境中部署应用程序。
- en: Designing for failure
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设计以应对故障
- en: In order to succeed, we must accept failures as a very real possibility. In
    fact, we really ought to be purposefully inserting failures into our application
    design flow to test how we can successfully deal with them when they occur. This
    kind of automated testing in production initially requires nerves of steel; however,
    we can derive automation that is self-healing through repetition and familiarity.
    Failures are a certainty; therefore, we must plan and test our automation for
    mitigating the damages of such a certainty.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功，我们必须接受故障是非常真实的可能性。事实上，我们确实应该有目的地将故障插入到我们的应用程序设计流程中，以测试当它们发生时我们如何成功地处理它们。这种在生产中的自动化测试最初需要钢铁般的神经；然而，通过重复和熟悉，我们可以得到自我修复的自动化。故障是必然的；因此，我们必须计划和测试我们的自动化，以减轻这种必然带来的损害。
- en: Successful application design involves built-in fault tolerances; this is particularly
    true of microservices as a consequence of using services as components. Since
    services can fail at any time, it's important to be able to detect the failures
    quickly and, if possible, automatically restore service. Real-time monitoring
    of our application is of critical emphasis across microservice applications, providing
    an early warning system of either issues actually occurring or those showing potential
    for error or problems. This affords an earlier response among development teams
    to follow up and investigate; because there is such choreography and event collaboration
    in a microservices architecture, our ability to track emergent behaviors becomes
    rather vital.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的应用程序设计涉及内置的容错能力；这对于微服务尤为重要，因为使用服务作为组件的结果。由于服务随时可能失败，能够快速检测到故障并且在可能的情况下自动恢复服务是非常重要的。对我们的应用程序进行实时监控在微服务应用程序中至关重要，提供了一个早期警报系统，可以提前发现问题或潜在的错误或问题。这为开发团队提供了更早的响应和调查；由于微服务架构中存在这样的协作和事件协同，我们追踪新出现的行为变得非常重要。
- en: 'Microservice teams should, therefore, design to include some minimums for monitoring
    and logging setups for each individual service: dashboards with up/down status,
    metadata on circuit breaker status, current throughput, and latency and a variety
    of operational and business relevant metrics.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，微服务团队应该设计包括一些最低限度的监控和日志设置，用于每个单独的服务：具有上/下状态的仪表板，断路器状态的元数据，当前吞吐量和延迟以及各种操作和业务相关的指标。
- en: At the end of our application builds, should our components not compose cleanly,
    we have accomplished little more than shifting complexity from inside a component
    to the connections between them. This puts things into areas harder to define
    and more difficult to control. Ultimately, we should design for the inevitability
    of failures to be successful.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序构建结束时，如果我们的组件不能清晰地组合在一起，我们所做的不过是将复杂性从组件内部转移到它们之间的连接。这使得事情变得更难定义和更难控制。最终，我们应该设计以应对失败的必然性才能取得成功。
- en: Dockunit for unit tests
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Dockunit用于单元测试
- en: To enhance our unit testing capabilities, we will also install and use **Dockunit**
    to deliver our unit testing. There are plenty of options available to us for our
    unit tests. In mixing and matching different tools to accomplish unit testing
    in the past, I have found that by deploying Dockunit as a *stock and standard*
    application in my development toolkit, I can meet almost any unit test needs with
    this utility. So as not to be too repetitive, let's go ahead and set up for automated
    testing using Dockunit.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增强我们的单元测试能力，我们还将安装和使用Dockunit来进行单元测试。对于我们的单元测试，有很多选项可供选择。在过去的单元测试中，我发现通过将Dockunit部署为我的开发工具包中的一个标准应用程序，我几乎可以满足任何单元测试需求。为了不显得太重复，让我们继续设置使用Dockunit进行自动化测试。
- en: Dockunit requirements are Node.js, npm, and Docker.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Dockunit的要求是Node.js、npm和Docker。
- en: 'If not already installed, install npm(we will assume installation of both Docker
    and Node.js):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未安装，安装npm（我们将假设已安装Docker和Node.js）：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can use Dockunit to easily test our Node.js applications. This is done
    simply via a `Dockunit.json` file; to follow is a sample that tests an application
    in Node.js 0.10.x and 0.12.0 using `mocha`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用Dockunit轻松测试我们的Node.js应用程序。这可以通过一个`Dockunit.json`文件来完成；以下是一个示例，测试了一个使用`mocha`的Node.js
    0.10.x和0.12.0应用程序：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code snippet shows how easily an application can be unit tested
    inside the docker container.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码片段显示了一个应用程序如何在docker容器内进行单元测试。
- en: Automated deployments
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化部署
- en: One approach to automation is to use an off-the-shelf PaaS (for example, Cloud
    Foundry or Tutum, and so on). A PaaS provides developers with an easy way to deploy
    and manage their microservices. It insulates them from concerns such as procuring
    and configuring IT resources. At the same time, the systems and network professionals
    who configure the PaaS can ensure compliance with best practices and company policies.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化的一种方法是使用现成的PaaS（例如Cloud Foundry或Tutum等）。PaaS为开发人员提供了一种简单的方式来部署和管理他们的微服务。它使他们免受采购和配置IT资源等问题的困扰。与此同时，配置PaaS的系统和网络专业人员可以确保符合最佳实践和公司政策。
- en: Another way to automate the deployment of microservices is to develop what is
    essentially your own PaaS. One typical starting point is to use a clustering solution,
    such as Mesos or Kubernetes, in conjunction with a technology, such as Docker.
    Later in this book, we will review how software-based application delivery approaches
    like NGINX, which easily handles caching, access control, API metering, and monitoring
    at the microservice level can help solve this problem.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化部署微服务的另一种方法是开发基本上是自己的PaaS。一个典型的起点是使用集群解决方案，如Mesos或Kubernetes，结合使用Docker等技术。本书的后面部分将介绍像NGINX这样的软件应用交付方法，它可以轻松处理缓存、访问控制、API计量和微服务级别的监控，从而帮助解决这个问题。
- en: Decoupling N-tier applications into multiple images
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将N层应用程序解耦为多个镜像
- en: Decomposing applications improves deployability and scalability and simplifies
    the adoption of new technologies. To achieve this level of abstraction, the application
    must be fully decoupled from the infrastructure. Application containers, such
    as Docker, provide a way to decouple application components from the infrastructure.
    At this level, each application service must be elastic (that is, it can scale
    up and down independently of other services) and resilient (that is, it has multiple
    instances and can survive instance failures). The application should also be designed
    so that failures in one service do not cascade to other services.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 分解应用程序可以提高部署能力和可伸缩性，并简化对新技术的采用。要实现这种抽象级别，应用程序必须与基础设施完全解耦。应用程序容器，如Docker，提供了一种将应用程序组件与基础设施解耦的方法。在这个级别上，每个应用服务必须是弹性的（即，它可以独立于其他服务进行扩展和缩减）和具有弹性（即，它具有多个实例并且可以在实例故障时继续运行）。应用程序还应该设计成一个服务的故障不会级联到其他服务。
- en: 'We''ve done entirely too much talking, and not enough doing. Let''s get at
    what we really need to know-how to build it! We can easily use our `cloudconsulted/wordpress`
    image here to show an example of our decoupling into separate containers: one
    for WordPress, PHP, and MySQL. Instead, let''s explore other applications to continue
    to show the range of capabilities and potential for application deployments that
    we can make with Docker; for this example, a simple LEMP stack'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说了太多，做得太少。让我们来看看我们真正需要知道的东西——如何构建它！我们可以在这里轻松使用我们的`cloudconsulted/wordpress`镜像来展示我们将其解耦为独立容器的示例：一个用于WordPress，PHP和MySQL。相反，让我们探索其他应用程序，继续展示我们可以使用Docker进行应用程序部署的能力和潜力；例如，一个简单的LEMP堆栈
- en: Building an N-tier web application
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建N层Web应用程序
- en: LEMP stack (NGINX > MySQL > PHP)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: LEMP堆栈（NGINX > MySQL > PHP）
- en: 'For simplification, we will split this LEMP stack across two containers: one
    for MySQL and the other for NGINX and PHP, each utilizing an Ubuntu base:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们将把这个LEMP堆栈分成两个容器：一个用于MySQL，另一个用于NGINX和PHP，每个都使用Ubuntu基础：
- en: '[PRE6]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A second container will install and house NGINX and PHP:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个容器将安装和存储NGINX和PHP：
- en: '[PRE7]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Making different tiers of applications work
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将不同层次的应用程序工作起来
- en: From our real-world production examples, we have already seen several different
    ways in which we can make different application tiers work together. Since discussion
    on making interoperable tiers workable within the application all depend upon
    the application tiers being deployed, we can continue on *ad-infinitum* as to
    how to do this; one example leading to another, and so on. Instead, we will delve
    into this area more thoroughly in [Chapter 06](ch06.html "Chapter 6. Making Containers
    Work"), *Making Containers Work*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的实际生产示例中，我们已经看到了几种不同的方法，可以使不同的应用程序层一起工作。由于讨论使应用程序层在应用程序内部可互操作的方式都取决于应用程序层的部署，我们可以继续*无限*地讨论如何做到这一点；一个例子引出另一个例子，依此类推。相反，我们将在[第06章](ch06.html
    "第6章。使容器工作")中更深入地探讨这个领域，*使容器工作*。
- en: Summary
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Containers are the vehicle for modern microservices architectures; the use of
    containers provides not some wild and imaginative advantages when coupled with
    microservices and N-tier architectural styles, but workable production-ready solutions.
    In many ways, the use of containers to implement a microservices architecture
    is an evolution not unlike those observed over the past 20 years in web development.
    Much of this evolution has been driven by the need to make better use of compute
    resources and the need to maintain increasingly complex web-based applications.
    For modern application development, Docker is a veritable and forceful weapon.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是现代微服务架构的载体；与微服务和N层架构风格结合使用容器不仅提供了一些狂野和富有想象力的优势，而且还提供了可行的生产就绪解决方案。在许多方面，使用容器来实现微服务架构与过去20年在Web开发中观察到的演变非常相似。这种演变的很大一部分是由于需要更好地利用计算资源和维护日益复杂的基于Web的应用程序的需求驱动的。对于现代应用程序开发来说，Docker是一种确凿而有力的武器。
- en: As we saw, the use of a microservices architecture with Docker containers addresses
    both these needs. We explored example environments designed seamlessly from development
    to test, eliminating the need for manual and error-prone resource provisioning
    and configuration. In doing so, we touched briefly on how a microservice application
    can be tested, automated, deployed, and managed, but the use of containers in
    distributed systems goes far beyond microservices. Increasingly, containers are
    becoming "first class citizens" in all distributed systems and, in the upcoming
    chapters, we'll discuss how tools such as Docker Compose and Kubernetes are essential
    for managing container-based computing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用Docker容器的微服务架构解决了这两个需求。我们探讨了从开发到测试无缝设计的示例环境，消除了手动和容易出错的资源配置和配置的需求。在这样做的过程中，我们简要介绍了微服务应用程序如何进行测试、自动化部署和管理，但在分布式系统中使用容器远不止微服务。越来越多地，容器正在成为所有分布式系统中的“一等公民”，在接下来的章节中，我们将讨论诸如Docker
    Compose和Kubernetes这样的工具对于管理基于容器的计算是至关重要的。
