- en: Chapter 1. An Introduction to Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。响应式编程简介
- en: Nowadays, the term **reactive programming** is trending. Libraries and frameworks
    in various programming languages are emerging. Blog posts, articles and presentations
    about reactive programming are being created. Big companies, such as Facebook,
    SoundCloud, Microsoft, and Netflix, are supporting and using this concept. So
    we, as programmers, are starting to wonder about it. Why are people so excited
    about reactive programming? What does it mean to be reactive? Would it be helpful
    in our projects? Should we learn how to use it?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，“响应式编程”这个术语正处于流行之中。各种编程语言中都出现了库和框架。有关响应式编程的博客文章、文章和演示正在被创建。Facebook、SoundCloud、Microsoft和Netflix等大公司正在支持和使用这个概念。因此，我们作为程序员开始思考。为什么人们对响应式编程如此兴奋？成为响应式意味着什么？它对我们的项目有帮助吗？我们应该学习如何使用它吗？
- en: Meanwhile, Java is popular with its multi-threading, speed, reliability, and
    good portability. It is used for building a wide variety of applications, from
    search engines, through databases to complex web applications running on server
    clusters. But Java has bad reputation too—it is very hard to write both concurrent
    and simple applications using only the built-in tools, and programming in Java
    requires writing a lot of boilerplate code. Also, if you need to be asynchronous
    (using futures, for example), you can easily get into "callback hell", which actually
    holds true for all programming languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，Java以其多线程、速度、可靠性和良好的可移植性而备受欢迎。它用于构建各种应用程序，从搜索引擎、数据库到在服务器集群上运行的复杂Web应用程序。但Java也有不好的声誉——仅使用内置工具编写并发和简单应用程序非常困难，而且在Java中编程需要编写大量样板代码。此外，如果需要是异步的（例如使用futures），你很容易陷入“回调地狱”，这实际上对所有编程语言都成立。
- en: In other words, Java is powerful and you can create great applications with
    it, but it won't be easy. The good news is that there is a way to change that,
    using the reactive style of programming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，Java很强大，你可以用它创建出色的应用程序，但这并不容易。好消息是，有一种方法可以改变这种情况，那就是使用响应式编程风格。
- en: This book will present **RxJava** ([https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)),
    an open source Java implementation of the reactive programming paradigm. Writing
    code using RxJava requires a different kind of thinking, but it will give you
    the power to create complex logic using simple pieces of well-structured code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将介绍**RxJava**（[https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)），这是响应式编程范式的开源Java实现。使用RxJava编写代码需要一种不同的思维方式，但它将使您能够使用简单的结构化代码片段创建复杂的逻辑。
- en: 'In this chapter, we will cover:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: What reactive programming is
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式编程是什么
- en: Reasons to learn and use this style of programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习和使用这种编程风格的原因
- en: Setting up RxJava and comparing it with familiar patterns and structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置RxJava并将其与熟悉的模式和结构进行比较
- en: A simple example with RxJava
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJava的一个简单例子
- en: What is reactive programming?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是响应式编程？
- en: Reactive programming is a paradigm that revolves around the propagation of change.
    In other words, if a program propagates all the changes that modify its data to
    all the interested parties (users, other programs, components, and subparts),
    then this program can be called **reactive**.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程是围绕变化的传播而展开的一种范式。换句话说，如果一个程序将修改其数据的所有变化传播给所有感兴趣的方，那么这个程序就可以被称为**响应式**。
- en: A simple example of this is Microsoft Excel. If you set a number in cell A1
    and another number in cell 'B1', and set cell 'C1' to `SUM(A1, B1)`; whenever
    'A1' or 'B1' changes, 'C1' will be updated to be their sum.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 微软Excel就是一个简单的例子。如果在单元格A1中设置一个数字，在单元格'B1'中设置另一个数字，并将单元格'C1'设置为`SUM(A1, B1)`；每当'A1'或'B1'发生变化时，'C1'将被更新为它们的和。
- en: Let's call this **the** **reactive sum**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称之为**响应式求和**。
- en: What is the difference between assigning a simple variable *c* to be equal to
    the sum of the *a* and *b* variables and the reactive sum approach?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将简单变量*c*分配为*a*和*b*变量的和与响应式求和方法之间有什么区别？
- en: 'In a normal Java program, when we change ''a'' or ''b'', we will have to update
    ''c'' ourselves. In other words, the change in the flow of the data represented
    by ''a'' and ''b'', is not propagated to ''c''. Here is this illustrated through
    source code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通的Java程序中，当我们改变'a'或'b'时，我们必须自己更新'c'。换句话说，由'a'和'b'表示的数据流的变化不会传播到'c'。下面通过源代码进行了说明：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接将文件发送到您的电子邮件。
- en: This is a very simple explanation of what "being reactive" means. Of course,
    there are various implementations of this idea and there are various problems
    that these implementations must solve.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对“响应式”意味着什么的非常简单的解释。当然，这个想法有各种实现，也有各种问题需要这些实现来解决。
- en: Why should we be reactive?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们应该是响应式的？
- en: The easiest way for us to answer this question is to think about the requirements
    we have while building applications these days.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回答这个问题最简单的方法是考虑我们在构建应用程序时的需求。
- en: While 10-15 years ago it was normal for websites to go through maintenance or
    to have a slow response time, today everything should be online 24/7 and should
    respond with lightning speed; if it's slow or down, users would prefer an alternative
    service. Today slow means unusable or broken. We are working with greater volumes
    of data that we need to serve and process fast.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 10-15年前，网站经过维护或响应时间缓慢是正常的，但今天一切都应该24/7在线，并且应该以闪电般的速度响应；如果慢或宕机，用户会选择另一个服务。今天慢意味着无法使用或损坏。我们正在处理更大量的数据，需要快速提供和处理。
- en: HTTP failures weren't something rare in the recent past, but now, we have to
    be fault-tolerant and give our users readable and reasonable message updates.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP故障在最近过去并不罕见，但现在，我们必须具有容错能力，并为用户提供可读和合理的消息更新。
- en: In the past, we wrote simple desktop applications, but today we write web applications,
    which should be fast and responsive. In most cases, these applications communicate
    with a large number of remote services.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，我们编写简单的桌面应用程序，但今天我们编写应该快速响应的Web应用程序。在大多数情况下，这些应用程序与大量远程服务进行通信。
- en: 'These are the new requirements we have to fulfill if we want our software to
    be competitive. So in other words we have to be:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们必须满足的新要求，如果我们希望我们的软件具有竞争力。换句话说，我们必须是：
- en: 'Modular/dynamic: This way, we will be able to have 24/7 systems, because modules
    can go offline and come online without breaking or halting the entire system.
    Additionally, this helps us better structure our applications as they grow larger
    and manage their code base.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化/动态：这样，我们将能够拥有24/7系统，因为模块可以下线并上线，而不会破坏或停止整个系统。此外，这有助于我们更好地构建随着规模扩大而管理其代码库的应用程序。
- en: 'Scalable: This way, we are going to be able to handle a huge amount of data
    or large numbers of user requests.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性：这样，我们将能够处理大量数据或大量用户请求。
- en: 'Fault-tolerant: This way, the system will appear stable to its users.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容错：这样，系统将对其用户显示稳定。
- en: 'Responsive: This means fast and available.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应性：这意味着快速和可用。
- en: 'Let''s think about how to accomplish this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑如何实现这一点：
- en: We can become modular if our system is *event-driven*. We can divide the system
    into multiple micro-services/components/modules that are going to communicate
    with each other using notifications. This way, we are going to react to the data
    flow of the system, represented by notifications.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们的系统是*事件驱动*，我们可以变得模块化。我们可以将系统分解为多个微服务/组件/模块，它们将使用通知相互通信。这样，我们将对系统的数据流做出反应，这些数据流由通知表示。
- en: To be scalable means to react to the ever-growing data, to react to load without
    falling apart.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展意味着对不断增长的数据做出反应，对负载做出反应而不会崩溃。
- en: Reacting to failures/errors will make the system more fault-tolerant.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对故障/错误的反应将使系统更具容错能力。
- en: To be responsive means reacting to user activity in a timely manner.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应性意味着及时对用户活动做出反应。
- en: If the application is event-driven, it can be decoupled into multiple self-contained
    components. This helps us become more scalable, because we can always add new
    components or remove old ones without stopping or breaking the system. If errors
    and failures are passed to the right component, which can handle them as notifications,
    the application can become more fault-tolerant or resilient. So if we build our
    system to be event-driven, we can more easily achieve scalability and failure
    tolerance, and a scalable, decoupled, and error-proof application is fast and
    responsive to users.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序是事件驱动的，它可以分解为多个自包含组件。这有助于我们变得更具可扩展性，因为我们可以随时添加新组件或删除旧组件，而不会停止或破坏系统。如果错误和故障传递到正确的组件，它可以将它们处理为通知，应用程序可以变得更具容错能力或弹性。因此，如果我们构建我们的系统为事件驱动，我们可以更容易地实现可扩展性和故障容忍性，而且可扩展、解耦和防错的应用程序对用户快速响应。
- en: '![Why should we be reactive?](img/4305_01_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![为什么我们应该是反应式的？](img/4305_01_01.jpg)'
- en: The **Reactive Manifesto** ([http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/))
    is a document defining the four reactive principles that we mentioned previously.
    Each reactive system should be message-driven (event-driven). That way, it can
    become loosely coupled and therefore scalable and resilient (fault-tolerant),
    which means it is reliable and responsive (see the preceding diagram).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**Reactive Manifesto**（[http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/)）是一份文件，定义了我们之前提到的四个反应原则。每个反应系统都应该是消息驱动的（事件驱动）。这样，它可以变得松散耦合，因此可扩展和具有弹性（容错），这意味着它是可靠和响应的（请参见上图）。'
- en: Note that the Reactive Manifesto describes a reactive system and is not the
    same as our definition of reactive programming. You can build a message-driven,
    resilient, scalable, and responsive application without using a reactive library
    or language.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Reactive Manifesto描述了一个反应式系统，并不同于我们对反应式编程的定义。您可以构建一个消息驱动、具有弹性、可扩展和响应的应用程序，而无需使用反应式库或语言。
- en: Changes in the application data can be modeled with notifications, which can
    be propagated to the right handlers. So, writing applications using reactive programming
    is the easiest way to comply with the Manifesto.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序数据的更改可以使用通知进行建模，并且可以传播到正确的处理程序。因此，使用反应式编程编写应用程序是遵守宣言的最简单方法。
- en: Introducing RxJava
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍RxJava
- en: To write reactive programs, we need a library or a specific programming language,
    because building something like that ourselves is quite a difficult task. Java
    is not really a reactive programming language (it provides some tools like the
    `java.util.Observable` class, but they are quite limited). It is a statically
    typed, object-oriented language, and we write a lot of boilerplate code to accomplish
    simple things (POJOs, for example). But there are reactive libraries in Java that
    we can use. In this book, we will be using RxJava (developed by people in the
    Java open source community, guided by Netflix).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写响应式程序，我们需要一个库或特定的编程语言，因为自己构建这样的东西是相当困难的任务。Java并不是一个真正的响应式编程语言（它提供了一些工具，比如“java.util.Observable”类，但它们相当有限）。它是一种静态类型的面向对象的语言，我们需要编写大量样板代码来完成简单的事情（例如POJOs）。但是在Java中有一些我们可以使用的响应式库。在这本书中，我们将使用RxJava（由Java开源社区的人员开发，由Netflix指导）。
- en: Downloading and setting up RxJava
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载和设置RxJava
- en: 'You can download and build RxJava from Github ([https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)).
    It requires zero dependencies and supports Java 8 lambdas. The documentation provided
    by its Javadoc and the GitHub wiki pages is well structured and some of the best
    out there. Here is how to check out the project and run the build:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从Github（[https://github.com/ReactiveX/RxJava](https://github.com/ReactiveX/RxJava)）下载并构建RxJava。它不需要任何依赖，并支持Java
    8的lambda。它的Javadoc和GitHub维基页面提供的文档结构良好，是最好的之一。以下是如何查看项目并运行构建：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, you can also download the prebuilt JAR. For this book, we'll be using
    version 1.0.8.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以下载预构建的JAR。在这本书中，我们将使用1.0.8版本。
- en: 'If you use Maven, you can add RxJava as a dependency to your `pom.xml` file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Maven，你可以将RxJava作为依赖项添加到你的“pom.xml”文件中：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, for Apache Ivy, put this snippet in your Ivy file''s dependencies:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于Apache Ivy，将这个片段放入你的Ivy文件的依赖项中：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you use Gradle instead, update your `build.gradle` file''s dependencies
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Gradle，你可以更新你的“build.gradle”文件的依赖项如下：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code examples and programs accompanying this book can be built and tested
    with Gradle. It can be downloaded from this Github repository: [https://github.com/meddle0x53/learning-rxjava](https://github.com/meddle0x53/learning-rxjava).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本书附带的代码示例和程序可以使用Gradle构建和测试。它可以从这个Github仓库下载：[https://github.com/meddle0x53/learning-rxjava](https://github.com/meddle0x53/learning-rxjava)。
- en: Now, let's take a peek at what RxJava is all about. We are going to begin with
    something well known, and gradually get into the library's secrets.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看RxJava到底是什么。我们将从一些众所周知的东西开始，逐渐深入到这个库的秘密中。
- en: Comparing the iterator pattern and the RxJava Observable
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较迭代器模式和RxJava Observable
- en: 'As a Java programmer, it is highly possible that you''ve heard or used the
    `Iterator` pattern. The idea is simple: an `Iterator` instance is used to traverse
    through a container (collection/data source/generator), pulling the container''s
    elements one by one when they are required, until it reaches the container''s
    end. Here is a little example of how it is used in Java:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Java程序员，你很可能听说过或使用过“迭代器”模式。这个想法很简单：一个“迭代器”实例用于遍历容器（集合/数据源/生成器），在需要时逐个拉取容器的元素，直到达到容器的末尾。以下是在Java中如何使用它的一个小例子：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Every `java.util.Collection` object is an `Iterable` instance which means that
    it has the method `iterator()`. This method creates an `Iterator` instance, which
    has as its source the collection. Let''s look at what the preceding code does:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每个“java.util.Collection”对象都是一个“Iterable”实例，这意味着它有“iterator()”方法。这个方法创建一个“Iterator”实例，它的源是集合。让我们看看前面的代码做了什么：
- en: We create a new `List` instance containing five strings.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个包含五个字符串的新“List”实例。
- en: We create an `Iterator` instance from this `List` instance, using the `iterator()`
    method.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用“iterator()”方法从这个“List”实例创建一个“Iterator”实例。
- en: 'The `Iterator` interface has two important methods: `hasNext()` and `next()`.
    The `hasNext()` method is used to check whether the `Iterator` instance has more
    elements for traversing. Here, we haven''t begun going through the elements, so
    it will return `True`. When we go through the five strings, it will return `False`
    and the program will proceed after the `while` loop.'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Iterator”接口有两个重要的方法：“hasNext()”和“next()”。“hasNext()”方法用于检查“Iterator”实例是否有更多元素可遍历。在这里，我们还没有开始遍历元素，所以它将返回“True”。当我们遍历这五个字符串时，它将返回“False”，程序将在“while”循环之后继续进行。
- en: The first five times, when we call the `next()` method on the `Iterator` instance,
    it will return the elements in the order they were inserted in the collection.
    So the strings will be printed.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前五次调用“Iterator”实例的“next()”方法时，它将按照它们在集合中插入的顺序返回元素。所以字符串将被打印出来。
- en: In this example, our program consumes the items from the `List` instance using
    the `Iterator` instance. It pulls the data (here, represented by strings) and
    the current thread blocks until the requested data is ready and received. So,
    for example, if the `Iterator` instance was firing a request to a web server on
    every `next()` method call, the main thread of our program would be blocked while
    waiting for each of the responses to arrive.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的程序使用“Iterator”实例从“List”实例中消耗项目。它拉取数据（这里用字符串表示），当前线程会阻塞，直到请求的数据准备好并接收到。所以，例如，如果“Iterator”实例在每次“next()”方法调用时向web服务器发送请求，我们程序的主线程将在等待每个响应到达时被阻塞。
- en: RxJava's building blocks are the observables. The `Observable` class (note that
    this is not the `java.util.Observable` class that comes with the JDK) is the mathematical
    dual of the `Iterator` class, which basically means that they are like the two
    sides of the same coin. It has an underlying collection or computation that produces
    values that can be consumed by a consumer. But the difference is that the consumer
    doesn't "pull" these values from the producer like in the `Iterator` pattern.
    It is exactly the opposite; the producer 'pushes**'** the values as notifications
    to the consumer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava的构建块是可观察对象。`Observable`类（请注意，这不是JDK中附带的`java.util.Observable`类）是`Iterator`类的数学对偶，这基本上意味着它们就像同一枚硬币的两面。它具有产生值的基础集合或计算，可以被消费者消耗。但不同之处在于，消费者不像`Iterator`模式中那样从生产者“拉”这些值。恰恰相反；生产者通过通知将值“推送”给消费者。
- en: 'Here is an example of the same program but written using an `Observable` instance:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相同程序的示例，但使用`Observable`实例编写：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is what is happening in the code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码中发生的情况：
- en: We create the list of strings in the same way as in the previous example.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们以与上一个示例相同的方式创建字符串列表。
- en: Then, we create an `Observable` instance from the list, using the `from(Iterable<?
    extends T> iterable)` method. This method is used to create instances of `Observable`
    that send all the values synchronously from an `Iterable` instance (the list in
    our case) one by one to their subscribers (consumers). We'll look at how the values
    are sent to the subscribers one by one in [Chapter 3](ch03.html "Chapter 3. Creating
    and Connecting Observables, Observers, and Subjects"), *Creating and Connecting
    Observables, Observers, and Subjects*.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从列表中创建一个`Observable`实例，使用`from(Iterable<? extends T> iterable)`方法。此方法用于创建`Observable`的实例，它们将所有值同步地从`Iterable`实例（在我们的例子中是列表）逐个发送给它们的订阅者（消费者）。我们将在[第3章](ch03.html
    "第3章。创建和连接Observable、Observer和Subject")中看看如何逐个将值发送给订阅者，*创建和连接Observable、Observer和Subject*。
- en: Here, we can subscribe to the `Observable` instance. By subscribing, we tell
    RxJava that we are interested in this `Observable` instance and want to receive
    notifications from it. We subscribe using an anonymous class implementing the
    `Action1` interface, by defining a single method—`call(T)`. This method will be
    called by the `Observable` instance every time it has a value, ready to be pushed.
    Always creating new `Action1` instances may seem too verbose, but Java 8 solves
    this verbosity. We'll learn more about that in [Chapter 2](ch02.html "Chapter 2. Using
    the Functional Constructions of Java 8"), *Using the Functional Constructions
    of Java 8*.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们可以订阅`Observable`实例。通过订阅，我们告诉RxJava我们对这个`Observable`实例感兴趣，并希望从中接收通知。我们使用实现`Action1`接口的匿名类进行订阅，通过定义一个单一方法`call(T)`。这个方法将由`Observable`实例每次有值准备推送时调用。始终创建新的`Action1`实例可能会显得太啰嗦，但Java
    8解决了这种冗长。我们将在[第2章](ch02.html "第2章。使用Java 8的函数构造")中了解更多信息，*使用Java 8的函数构造*。
- en: So, every string from the source list will be pushed through to the `call()`
    method, and it will be printed.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，源列表中的每个字符串都将通过`call()`方法推送，并将被打印出来。
- en: 'Instances of the RxJava `Observable` class behave somewhat like asynchronous
    iterators, which notify that there is a next value their subscribers/consumers
    by themselves. In fact, the `Observable` class adds to the classic `Observer`
    pattern (implemented in Java—see `java.util.Observable`, see `Design Patterns:
    Elements of Reusable Object-Oriented Software` by the Gang Of Four) two things
    available in the `Iterable` type.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava的`Observable`类的实例行为有点像异步迭代器，它们自己通知其订阅者/消费者有下一个值。事实上，`Observable`类在经典的`Observer`模式（在Java中实现——参见`java.util.Observable`，参见《设计模式：可复用面向对象软件的元素》）中添加了`Iterable`类型中的两个可用的东西。
- en: The ability to signal the consumer that there is no more data available. Instead
    of calling the `hasNext()` method, we can attach a subscriber to listen for a
    '`OnCompleted`' notification.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向消费者发出没有更多数据可用的信号的能力。我们可以附加一个订阅者来监听“`OnCompleted`”通知，而不是调用`hasNext()`方法。
- en: The ability to signal the subscriber that an error has occurred. Instead of
    try-catching an error, we can attach an error listener to the `Observable` instance.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号订阅者发生错误的能力。我们可以将错误侦听器附加到`Observable`实例，而不是尝试捕获错误。
- en: 'These listeners can be attached using the `subscribe(Action1<? super T>, Action1
    <Throwable>, Action0)` method. Let''s expand the `Observable` instance example
    by adding error and completed listeners:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些侦听器可以使用`subscribe(Action1<? super T>, Action1 <Throwable>, Action0)`方法附加。让我们通过添加错误和完成侦听器来扩展`Observable`实例示例：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The new things here are:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 新的东西在这里是：
- en: If there is an error while processing the elements, the `Observable` instance
    will send this error through the `call(Throwable)` method of this listener. This
    is analogous to the try-catch block in the `Iterator` instance example.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在处理元素时出现错误，`Observable`实例将通过此侦听器的`call(Throwable)`方法发送此错误。这类似于`Iterator`实例示例中的try-catch块。
- en: When everything finishes, this `call()` method will be invoked by the `Observable`
    instance. This is analogous to using the `hasNext()` method in order to see if
    the traversal over the `Iterable` instance has finished and printing "We've finished!".
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一切都完成时，`Observable`实例将调用此`call()`方法。这类似于使用`hasNext()`方法来查看`Iterable`实例的遍历是否已经完成并打印“We've
    finished!”。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example is available at GitHub and can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter01/ObservableVSIterator.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter01/ObservableVSIterator.java).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可在GitHub上查看，并可在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter01/ObservableVSIterator.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter01/ObservableVSIterator.java)上查看/下载。
- en: We saw how we can use the `Observable` instances and that they are not so different
    from something familiar to us—the `Iterator` instance. These `Observable` instances
    can be used for building asynchronous streams and pushing data updates to their
    subscribers (they can have multiple subscribers).This is an implementation of
    the reactive programming paradigm. The data is being propagated to all the interested
    parties—the subscribers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用`Observable`实例，它们与我们熟悉的`Iterator`实例并没有太大的不同。这些`Observable`实例可以用于构建异步流，并将数据更新推送给它们的订阅者（它们可以有多个订阅者）。这是反应式编程范式的一种实现。数据被传播给所有感兴趣的方，即订阅者。
- en: Coding using such streams is a more functional-like implementation of Reactive
    Programming. Of course, there are formal definitions and complex terms for it,
    but this is the simplest explanation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的流进行编码是反应式编程的更类似函数式的实现。当然，对此有正式的定义和复杂的术语，但这是最简单的解释。
- en: Subscribing to events should be familiar; for example, clicking on a button
    in a GUI application fires an event which is propagated to the subscribers—handlers.
    But, using RxJava, we can create data streams from anything—file input, sockets,
    responses, variables, caches, user inputs, and so on. On top of that, consumers
    can be notified that the stream is closed, or that there has been an error. So,
    by using these streams, our applications can react to failure.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅事件应该是熟悉的；例如，在GUI应用程序中点击按钮会触发一个事件，该事件会传播给订阅者—处理程序。但是，使用RxJava，我们可以从任何地方创建数据流—文件输入、套接字、响应、变量、缓存、用户输入等等。此外，消费者可以被通知流已关闭，或者发生了错误。因此，通过使用这些流，我们的应用程序可以对失败做出反应。
- en: To summarize, a stream is a sequence of ongoing messages/events, ordered as
    they are processed in real time. It can be looked at as a value that is changing
    through time, and these changes can be observed by subscribers (consumers), dependent
    on it. So, going back to the example from Excel, we have effectively replaced
    the traditional variables with "reactive variables" or RxJava's `Observable` instances.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，流是一系列持续的消息/事件，按照它们在实时处理中的顺序排序。它可以被看作是随着时间变化的值，这些变化可以被依赖它的订阅者（消费者）观察到。因此，回到Excel的例子，我们实际上用"反应式变量"或RxJava的`Observable`实例有效地替换了传统变量。
- en: Implementing the reactive sum
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现反应式求和
- en: Now that we are familiar with the `Observable` class and the idea of how to
    use it to code in a reactive way, we are ready to implement the reactive sum,
    mentioned at the beginning of this chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们熟悉了`Observable`类和如何以反应式方式使用它编码的想法，我们准备实现在本章开头提到的反应式求和。
- en: 'Let''s look at the requirements our program must fulfill:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的程序必须满足的要求：
- en: It will be an application that runs in the terminal.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将是一个在终端中运行的应用程序。
- en: Once started, it will run until the user enters `exit`.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦启动，它将一直运行，直到用户输入`exit`。
- en: If the user enters `a:<number>`, the *a* collector will be updated to the *<number>*.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入`a:<number>`，*a*收集器将更新为*<number>*。
- en: If the user enters `b:<number>`, the *b* collector will be updated to the *<number>*.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入`b:<number>`，*b*收集器将更新为*<number>*。
- en: If the user enters anything else, it will be skipped.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户输入其他内容，将被跳过。
- en: When both the *a* and *b* collectors have initial values, their sum will automatically
    be computed and printed on the standard output in the format *a + b = <sum>*.
    On every change in *a* or *b*, the sum will be updated and printed.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当*a*和*b*收集器都有初始值时，它们的和将自动计算并以*a + b = <sum>*的格式打印在标准输出上。在*a*或*b*的每次更改时，和将被更新并打印。
- en: The source code contains features that we will discuss in detail in the next
    four chapters.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含了我们将在接下来的四章中详细讨论的功能。
- en: 'The first piece of code represents the main body of the program:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段代码代表程序的主体：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'There are a lot of new things happening here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多新的事情：
- en: The first thing we must do is to create an `Observable` instance, representing
    the standard input stream (`System.in`). So, we use the `from(InputStream)` method
    (implementation will be presented in the next code snippet) to create a `ConnectableObservable`
    variable from the `System.in`. The `ConnectableObservable` variable is an `Observable`
    instance and starts emitting events coming from its source only after its `connect()`
    method is called. Read more on it in [Chapter 3](ch03.html "Chapter 3. Creating
    and Connecting Observables, Observers, and Subjects"), *Creating and Connecting
    Observables, Observers, and Subjects*.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是创建一个代表标准输入流（`System.in`）的`Observable`实例。因此，我们使用`from(InputStream)`方法（实现将在下一个代码片段中呈现）从`System.in`创建一个`ConnectableObservable`变量。`ConnectableObservable`变量是一个`Observable`实例，只有在调用其`connect()`方法后才开始发出来自其源的事件。在[第3章](ch03.html
    "第3章。创建和连接Observables、Observers和Subjects")中详细了解它，*创建和连接Observables、Observers和Subjects*。
- en: We create two `Observable` instances representing the `a` and `b` values, using
    the `varStream(String, Observable)` method, which we are going to examine later.
    The source stream for these values is the input stream.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`varStream(String, Observable)`方法创建代表`a`和`b`值的两个`Observable`实例，我们将在后面进行详细讨论。这些值的源流是输入流。
- en: We create a `ReactiveSum` instance, dependent on the `a` and `b` values.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`ReactiveSum`实例，依赖于`a`和`b`的值。
- en: And now, we can start listening to the input stream.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始监听输入流了。
- en: This code is responsible for building dependencies in the program and starting
    it off. The `a` and `b` values are dependent on the user input and their sum is
    dependent on them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码负责在程序中建立依赖关系并启动它。*a*和*b*的值依赖于用户输入，它们的和也依赖于它们。
- en: 'Now let''s look at the implementation of the `from(InputStream)` method, which
    creates an `Observable` instance with the `java.io.InputStream` source:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`from(InputStream)`方法的实现，它创建了一个带有`java.io.InputStream`源的`Observable`实例：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is one complex piece of code, so let''s look at it step-by-step:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段复杂的代码，让我们一步一步来看：
- en: This method implementation converts its `InputStream` parameter to the `BufferedReader`
    object and to calls the `from(BufferedReader)` method. We are doing that because
    we are going to use strings as data, and working with the `Reader` instance is
    easier.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个方法的实现将它的`InputStream`参数转换为`BufferedReader`对象，并调用`from(BufferedReader)`方法。我们这样做是因为我们将使用字符串作为数据，并且使用`Reader`实例更容易。
- en: So the actual implementation is in the second method. It returns an `Observable`
    instance, created using the `Observable.create(OnSubscribe)` method. This method
    is the one we are going to use the most in this book. It is used to create `Observable`
    instances with custom behavior. The `rx.Observable.OnSubscribe` interface passed
    to it has one method, `call(Subscriber)`. This method is used to implement the
    behavior of the `Observable` instance because the `Subscriber` instance passed
    to it can be used to emit messages to the `Observable` instance's subscriber.
    A subscriber is the client of an `Observable` instance, which consumes its notifications.
    Read more about that in [Chapter 3](ch03.html "Chapter 3. Creating and Connecting
    Observables, Observers, and Subjects"), *Creating and Connecting Observables,
    Observers, and Subjects*.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，实际的实现在第二个方法中。它返回一个`Observable`实例，使用`Observable.create(OnSubscribe)`方法创建。这个方法是我们在本书中将要经常使用的方法。它用于创建具有自定义行为的`Observable`实例。传递给它的`rx.Observable.OnSubscribe`接口有一个方法，`call(Subscriber)`。这个方法用于实现`Observable`实例的行为，因为传递给它的`Subscriber`实例可以用于向`Observable`实例的订阅者发出消息。订阅者是`Observable`实例的客户端，它消耗它的通知。在[第3章](ch03.html
    "第3章。创建和连接Observables、Observers和Subjects")中了解更多信息，*创建和连接Observables、Observers和Subjects*。
- en: If the subscriber has already unsubscribed from this `Observable` instance,
    nothing should be done.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果订阅者已经取消订阅了这个`Observable`实例，就不应该做任何事情。
- en: The main logic is to listen for user input, while the subscriber is subscribed.
    Every line the user enters in the terminal is treated as a message. This is the
    main loop of the program.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主要逻辑是监听用户输入，同时订阅者已经订阅。用户在终端输入的每一行都被视为一条消息。这是程序的主循环。
- en: If the user enters the word `exit` and hits *Enter*, the main loop stops.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户输入单词`exit`并按下*Enter*，主循环将停止。
- en: Otherwise, the message the user entered is passed as a notification to the subscriber
    of the `Observable` instance, using the `onNext(T)` method. This way, we pass
    everything to the interested parties. It's their job to filter out and transform
    the raw messages.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，用户输入的消息将通过`onNext(T)`方法作为通知传递给`Observable`实例的订阅者。这样，我们将一切都传递给感兴趣的各方。他们的工作是过滤和转换原始消息。
- en: If there is an IO error, the subscribers are notified with an `OnError` notification
    through the `onError(Throwable)` method.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生IO错误，订阅者将通过`onError(Throwable)`方法收到一个`OnError`通知。
- en: If the program reaches here (through breaking out of the main loop) and the
    subscriber is still subscribed to the `Observable` instance, an `OnCompleted`
    notification is sent to the subscribers using the `onCompleted()` method.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果程序到达这里（通过跳出主循环），并且订阅者仍然订阅了`Observable`实例，将使用`onCompleted()`方法向订阅者发送一个`OnCompleted`通知。
- en: With the `publish()` method, we turn the new `Observable` instance into `ConnectableObservable`
    instance. We have to do this because, otherwise, for every subscription to this
    `Observable` instance, our logic will be executed from the beginning. In our case,
    we want to execute it only once and all the subscribers to receive the same notifications;
    this is achievable with the use of a `ConnectableObservable` instance. Read more
    about that in [Chapter 3](ch03.html "Chapter 3. Creating and Connecting Observables,
    Observers, and Subjects"), *Creating and Connecting Observables, Observers, and
    Subjects*.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`publish()`方法，我们将新的`Observable`实例转换为`ConnectableObservable`实例。我们必须这样做，否则，对于对这个`Observable`实例的每次订阅，我们的逻辑将从头开始执行。在我们的情况下，我们希望只执行一次，并且所有订阅者都收到相同的通知；这可以通过使用`ConnectableObservable`实例来实现。在[第3章](ch03.html
    "第3章。创建和连接Observables、Observers和Subjects")中了解更多信息，*创建和连接Observables、Observers和Subjects*。
- en: This illustrates a simplified way to turn Java's IO streams into `Observable`
    instances. Of course, with this main loop, the main thread of the program will
    block waiting for user input. This can be prevented using the right `Scheduler`
    instances to move the logic to another thread. We'll revisit this topic in [Chapter
    6](ch06.html "Chapter 6. Using Concurrency and Parallelism with Schedulers"),
    *Using Concurrency and Parallelism with Schedulers*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了将Java的IO流简化为`Observable`实例的方法。当然，使用这个主循环，程序的主线程将阻塞等待用户输入。可以使用正确的`Scheduler`实例将逻辑移动到另一个线程来防止这种情况发生。我们将在[第6章](ch06.html
    "第6章。使用调度程序进行并发和并行处理")中重新讨论这个话题，*使用调度程序进行并发和并行处理*。
- en: 'Now, every line the user types into the terminal is propagated as a notification
    by the `ConnectableObservable` instance created by this method. The time has come
    to look at how we connect our value `Observable` instances, representing the collectors
    of the sum, to this input `Observable` instance. Here is the implementation of
    the `varStream(String, Observable)` method, which takes a name of a value and
    source `Observable` instance and returns an `Observable` instance representing
    this value:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户在终端输入的每一行都会被这个方法创建的`ConnectableObservable`实例传播为一个通知。现在是时候看看我们如何将代表总和收集器的值`Observable`实例连接到这个输入`Observable`实例了。这是`varStream(String,
    Observable)`方法的实现，它接受一个值的名称和源`Observable`实例，并返回代表这个值的`Observable`实例：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `map()` and `filter()` methods called on the `Observable` instance here
    are part of the fluent API provided by RxJava. They can be called on an `Observable`
    instance, creating a new `Observable` instance that depends on these methods and
    that transforms or filters the incoming data. Using these methods the right way,
    you can express complex logic in a series of steps leading to your objective.
    Read more about this in [Chapter 4](ch04.html "Chapter 4. Transforming, Filtering,
    and Accumulating Your Data"), *Transforming, Filtering, and Accumulating Your
    Data*. Let''s analyze the code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里调用的`map()`和`filter()`方法是RxJava提供的流畅API的一部分。它们可以在`Observable`实例上调用，创建一个依赖于这些方法的新的`Observable`实例，用于转换或过滤传入的数据。通过正确使用这些方法，您可以通过一系列步骤表达复杂的逻辑，以达到您的目标。在[第4章](ch04.html
    "第4章。转换、过滤和累积您的数据")中了解更多信息，*转换、过滤和累积您的数据*。让我们分析一下代码：
- en: 'Our variables are interested only in messages in the format `<var_name>: <value>`
    or `<var_name> = <value>`, so we are going to use this regular expression to filter
    and process only these kinds of messages. Remember that our input `Observable`
    instance sends each line the user writes; it is our job to handle it the right
    way.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '我们的变量只对格式为`<var_name>: <value>`或`<var_name> = <value>`的消息感兴趣，因此我们将使用这个正则表达式来过滤和处理这些类型的消息。请记住，我们的输入`Observable`实例会发送用户写的每一行；我们的工作是以正确的方式处理它。'
- en: Using the messages we receive from the input, we create a `Matcher` instance
    using the preceding regular expression as a pattern.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们从输入接收的消息，我们使用前面的正则表达式作为模式创建了一个`Matcher`实例。
- en: We pass through only data that matches the regular expression. Everything else
    is discarded.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只通过与正则表达式匹配的数据。其他一切都被丢弃。
- en: Here, the value to set is extracted as a `Double` number value.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里要设置的值被提取为`Double`数值。
- en: 'This is how the values `a` and `b` are represented by streams of double values,
    changing in time. Now we can implement their sum. We implemented it as a class
    that implements the `Observer` interface, because I wanted to show you another
    way of subscribing to `Observable` instances—using the `Observer` interface. Here
    is the code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是值`a`和`b`如何通过双值流表示，随时间变化。现在我们可以实现它们的总和。我们将其实现为一个实现了`Observer`接口的类，因为我想向您展示订阅`Observable`实例的另一种方式——使用`Observer`接口。以下是代码：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is the implementation of the actual sum, dependent on the two `Observable`
    instances representing its collectors:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实际总和的实现，依赖于表示其收集器的两个`Observable`实例：
- en: 'It is an `Observer` interface. The `Observer` instance can be passed to the
    `Observable` instance''s `subscribe(Observer)` method and defines three methods
    that are named after the three types of notification: `onNext(T)`, `onError(Throwable)`,
    and `onCompleted`. Read more about this interface in [Chapter 3](ch03.html "Chapter 3. Creating
    and Connecting Observables, Observers, and Subjects"), *Creating and Connecting
    Observables, Observers, and Subjects*.'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个`Observer`接口。`Observer`实例可以传递给`Observable`实例的`subscribe(Observer)`方法，并定义了三个方法，这些方法以三种类型的通知命名：`onNext(T)`、`onError(Throwable)`和`onCompleted`。在[第3章](ch03.html
    "第3章。创建和连接Observables、Observers和Subjects")中了解更多关于这个接口的信息，*创建和连接Observables、Observers和Subjects*。
- en: In our `onNext(Double)` method implementation, we set the sum to the incoming
    value and print an update to the standard output.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`onNext(Double)`方法实现中，我们将总和设置为传入的值，并在标准输出中打印更新。
- en: If we get an error, we just print it.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们遇到错误，我们只是打印它。
- en: When everything is done, we greet the user with the final sum.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一切都完成时，我们用最终的总和向用户致以问候。
- en: We implement the sum with the `combineLatest(Observable, Observable, Func2)`
    method. This method creates a new `Observable` instance. The new `Observable`
    instance is updated when any of the two `Observable` instances, passed to combineLatest
    receives an update. The value emitted through the new `Observable` instance is
    computed by the third parameter—a function that has access to the latest values
    of the two source sequences. In our case, we sum up the values. There will be
    no notification until both of the `Observable` instances passed to the method
    emit at least one value. So, we will have the sum only when both `a` and `b` have
    notifications. Read more about this method and other combiners in [Chapter 5](ch05.html
    "Chapter 5. Combinators, Conditionals, and Error Handling"), *Combinators, Conditionals,
    and Error Handling*.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`combineLatest(Observable, Observable, Func2)`方法实现总和。这个方法创建一个新的`Observable`实例。当传递给combineLatest的两个`Observable`实例中的任何一个接收到更新时，新的`Observable`实例将被更新。通过新的`Observable`实例发出的值是由第三个参数计算的——这个函数可以访问两个源序列的最新值。在我们的情况下，我们将这些值相加。只有当传递给该方法的两个`Observable`实例都至少发出一个值时，才会收到通知。因此，只有当`a`和`b`都有通知时，我们才会得到总和。在[第5章](ch05.html
    "第5章。组合器、条件和错误处理")中了解更多关于这个方法和其他组合器的信息，*组合器、条件和错误处理*。
- en: We subscribe our `Observer` instance to the combined `Observable` instance.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们的`Observer`实例订阅到组合的`Observable`实例上。
- en: 'Here is sample of what the output of this example would look like:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个示例的输出可能看起来像的样本：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So this is it! We have implemented our reactive sum using streams of data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们使用数据流实现了我们的响应式总和。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The source code of this example can be downloaded and tried out from here:
    [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter01/ReactiveSumV1.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter01/ReactiveSumV1.java).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的源代码可以从这里下载并尝试：[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter01/ReactiveSumV1.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter01/ReactiveSumV1.java)。
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went through the reactive principles and the reasons we
    should learn and use them. It is not so hard to build a reactive application;
    it just requires structuring the program in little declarative steps. With RxJava,
    this can be accomplished by building multiple asynchronous streams connected the
    right way, transforming the data all the way through its consumer.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了响应式原则以及学习和使用它们的原因。构建一个响应式应用并不难；它只需要将程序结构化为一系列小的声明式步骤。通过RxJava，可以通过构建多个正确连接的异步流来实现这一点，从而在整个数据传输过程中转换数据。
- en: The two examples presented in this chapter may look a bit complex and confusing
    at first glance, but in reality, they are pretty simple. There are a lot of new
    things in them, but everything will be explained in detail in the following chapters.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍的两个例子乍一看可能有点复杂和令人困惑，但实际上它们非常简单。它们中有很多新东西，但在接下来的章节中将会详细解释一切。
- en: 'If you want to read more about reactive programming, take a look at *Reactive
    Programming in the Netflix API with RxJava*, a fine article on the topic, available
    at [http://techblog.netflix.com/2013/02/rxjava-netflix-api.html](http://techblog.netflix.com/2013/02/rxjava-netflix-api.html).
    Another fine post introducing the concept can be found here: [https://gist.github.com/staltz/868e7e9bc2a7b8c1f754](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想阅读更多关于响应式编程的内容，请查看《在Netflix API中使用RxJava进行响应式编程》这篇精彩的文章，可在[http://techblog.netflix.com/2013/02/rxjava-netflix-api.html](http://techblog.netflix.com/2013/02/rxjava-netflix-api.html)上找到。另一篇介绍这一概念的精彩文章可以在这里找到：[https://gist.github.com/staltz/868e7e9bc2a7b8c1f754](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)。
- en: 'And these are slides about reactive programming and RX by Ben Christensen,
    one of the creators of RxJava: [https://speakerdeck.com/benjchristensen/reactive-programming-with-rx-at-qconsf-2014](https://speakerdeck.com/benjchristensen/reactive-programming-with-rx-at-qconsf-2014).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是由RxJava的创造者之一Ben Christensen制作的有关响应式编程和RX的幻灯片：[https://speakerdeck.com/benjchristensen/reactive-programming-with-rx-at-qconsf-2014](https://speakerdeck.com/benjchristensen/reactive-programming-with-rx-at-qconsf-2014)。
- en: In the next chapter, we are going to talk about some of the concepts of *functional
    programming* and their implementation in Java 8\. This will give us the basic
    ideas needed in the rest of the chapters and will help us get rid of Java verbosity
    when writing reactive programs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一些关于*函数式编程*的概念及其在Java 8中的实现。这将为我们提供在接下来的章节中所需的基本思想，并帮助我们摆脱在编写响应式程序时的Java冗长性。
