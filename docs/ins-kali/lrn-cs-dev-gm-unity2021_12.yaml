- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Saving, Loading, and Serializing Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存、加载和序列化数据
- en: Every game you've ever played works with data, whether it's your player stats,
    game progress, or online multiplayer scoreboards. Your favorite game also manages
    internal data, meaning the programmers used hardcoded information to build levels,
    keep track of enemy stats, and write helpful utilities. In other words, data is
    everywhere.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您玩过的每个游戏都使用数据，无论是您的玩家统计数据、游戏进度还是在线多人游戏积分榜。您最喜欢的游戏还管理内部数据，这意味着程序员使用硬编码信息来构建级别、跟踪敌人统计数据并编写有用的实用程序。换句话说，数据无处不在。
- en: 'In this chapter, we''re going to start with how both C# and Unity handle the
    filesystem on your computer, and move on to reading, writing, and serializing
    our game data. Our focus is on working with the three most common data formats
    you''ll likely come across: text files, XML, and JSON.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从C#和Unity如何处理计算机上的文件系统开始，并继续阅读、写入和序列化我们的游戏数据。我们的重点是处理您可能会遇到的三种最常见的数据格式：文本文件、XML和JSON。
- en: By the end of this chapter, you'll have a foundational understanding of your
    computer's filesystem, data formats, and basic read-write functionality. This
    will be the foundation you build your game data on, creating a more enriching
    and engaging experience for your players. You'll also be in a good position to
    start thinking about what game data is important enough to save, and how your
    C# classes and objects will look in different data formats.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对计算机的文件系统、数据格式和基本的读写功能有一个基础的理解。这将是您构建游戏数据的基础，为玩家创造更丰富和引人入胜的体验。您还将有一个很好的起点，开始思考哪些游戏数据是重要的，以及您的C#类和对象在不同的数据格式中会是什么样子。
- en: 'Along the way, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将涵盖以下主题：
- en: Introducing text, XML, and JSON formats
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍文本、XML和JSON格式
- en: Understanding the filesystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解文件系统
- en: Working with different stream types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的流类型
- en: Reading and writing game data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阅读和写入游戏数据
- en: Serializing objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化对象
- en: Introducing data formats
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍数据格式
- en: 'Data can take different forms in programming, but the three formats you should
    be familiar with at the beginning of your data journey are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在编程中可以采用不同的形式，但您在数据旅程开始时应熟悉的三种格式是：
- en: '**Text**, which is what you''re reading right now'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**，这就是您现在正在阅读的内容'
- en: '**XML** (**Extensible Markup Language**), which is a way of encoding document
    information so it''s readable for you and a computer'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**XML**（**可扩展标记语言**），这是一种编码文档信息的方式，使其对您和计算机可读'
- en: '**JSON** (**JavaScript Object Notation**), which is a human-readable text format
    made up of attribute-value pairs and arrays'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON**（**JavaScript对象表示**），这是一种由属性-值对和数组组成的可读文本格式'
- en: Each of these data formats has its own strengths and drawbacks, as well as applications
    in programming. For instance, text is generally used to store simpler, non-hierarchical,
    or nested information. XML is better at storing information in a document format,
    while JSON has a more diverse range of capabilities, specifically with database
    information and server communication with applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每种数据格式都有其自身的优势和劣势，以及在编程中的应用。例如，文本通常用于存储更简单、非分层或嵌套的信息。XML更擅长以文档格式存储信息，而JSON在数据库信息和应用程序的服务器通信方面具有更广泛的能力。
- en: You can find more information about XML at [https://www.xml.com](https://www.xml.com)
    and JSON at [https://www.json.org](https://www.json.org).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.xml.com](https://www.xml.com)找到有关XML的更多信息，以及在[https://www.json.org](https://www.json.org)找到有关JSON的信息。
- en: Data is a big topic in any programming language, so let's start off by breaking
    down what XML and JSON formats actually look like in the next two sections.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在任何编程语言中都是一个重要的主题，因此让我们从下两节中实际了解XML和JSON格式是什么样子开始。
- en: Breaking down XML
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解XML
- en: 'A typical XML file has a standardized format. Each element of the XML document
    has an opening (`<element_name>`), a closing tag (`</element_name>`), and supports
    tag attributes (`<element_name attribute= "attribute_name"></element_name>`).
    A basic file will start with the version and encoding being used, then the starting
    or root element, followed by a list of element items, and finally the closing
    element. As a blueprint, it would look like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的XML文件具有标准化格式。XML文档的每个元素都有一个开放标签(`<element_name>`)，一个关闭标签(`</element_name>`)，并支持标签属性(`<element_name
    attribute= "attribute_name"></element_name>`)。一个基本文件将以正在使用的版本和编码开始，然后是起始或根元素，然后是元素项列表，最后是关闭元素。作为蓝图，它将如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'XML data can also store more complex objects by using child elements. For example,
    we''ll be turning a list of weapons into XML using the `Weapon` class we wrote
    earlier in the book. Since each weapon has properties for its name and damage
    value, that will look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: XML数据还可以通过使用子元素存储更复杂的对象。例如，我们将使用我们在本书中早些时候编写的`Weapon`类，将武器列表转换为XML。由于每个武器都有其名称和伤害值的属性，它将如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s break down the example above to make sure we''ve got it right:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解上面的示例，确保我们理解正确：
- en: The XML document starts with the version being used
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XML文档以正在使用的版本开头
- en: The root element is declared with an opening tag named `ArrayOfWeapon`, which
    will hold all our element items
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根元素使用名为`ArrayOfWeapon`的开放标签声明，它将保存所有我们的元素项
- en: A weapon item is created with an opening tag named `Weapon`
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用开放标签`Weapon`创建了一个武器项目
- en: Its child properties are added with opening and closing tags on a single line
    for `name` and `damage`
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其子属性是通过单行上的开放和关闭标签添加的，用于`name`和`damage`
- en: The weapon item is closed, and two more weapon items are added
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 武器项目已关闭，并添加了两个武器项目
- en: The array is closed, marking the end of the document
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组关闭，标志着文档的结束
- en: The good news is our application doesn't have to manually write our data in
    this format. C# has an entire library of classes and methods to help us translate
    simple text and class objects directly into XML.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是我们的应用程序不必手动以这种格式编写我们的数据。C#有一个完整的类和方法库，可以帮助我们直接将简单文本和类对象转换为XML。
- en: We'll dive into practical code examples a little later on, but first we need
    to understand how JSON works.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后我们将深入实际的代码示例，但首先我们需要了解JSON的工作原理。
- en: Breaking down JSON
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析JSON
- en: 'The JSON data format is similar to XML, but without the tags. Instead, everything
    is based on attribute-value pairs, like the **Dictionary** collection type we
    worked with back in *Chapter 4*, *Control Flow and Collection Types*. Each JSON
    document starts with a parent dictionary that holds as many attribute-value pairs
    as you need. Dictionaries use open and closed curly braces ( `{ }` ), a colon
    separates each attribute and value, and each attribute-value pair is separated
    by a comma:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JSON数据格式类似于XML，但没有标签。相反，一切都基于属性-值对，就像我们在*第4章*“控制流和集合类型”中使用的**Dictionary**集合类型一样。每个JSON文档都以一个父字典开始，其中包含您需要的许多属性-值对。字典使用开放和关闭的大括号（`{}`），冒号分隔每个属性和值，每个属性-值对之间用逗号分隔：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'JSON can also have child or nested structures by setting the value of an attribute-value
    pair to an array of attribute-value pairs. For instance, if we want to store a
    weapon, it would look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JSON也可以通过将属性-值对的值设置为属性-值对数组来具有子结构。例如，如果我们想要存储一把武器，它会是这样的：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, JSON data is often made up of lists, or arrays, or objects. Continuing
    our example, if we wanted to store a list of all the weapons our player could
    choose, we would use a pair of square brackets to denote an array:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，JSON数据通常由列表、数组或对象组成。继续我们的例子，如果我们想要存储玩家可以选择的所有武器的列表，我们将使用一对方括号来表示一个数组：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can mix and match any of these techniques to store any kind of complex data
    you need, which is one of JSON's main strengths. But just like with XML, don't
    be overtaken by the new syntax – C# and Unity both have helper classes and methods
    to translate text and class objects into JSON without us having to do any heavy
    lifting. Reading XML and JSON is sort of like learning a new language—the more
    you use it the more familiar it becomes. Soon it'll be second nature!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以混合和匹配这些技术来存储您需要的任何类型的复杂数据，这是JSON的主要优势之一。但就像XML一样，不要被新的语法所吓倒——C#和Unity都有辅助类和方法，可以将文本和类对象转换为JSON，而无需我们做任何繁重的工作。阅读XML和JSON有点像学习一门新语言——您使用得越多，它就会变得越熟悉。很快它就会成为第二天性！
- en: Now that we've dipped our toes into data formatting basics, we can start talking
    about how the filesystem on your computer works and what properties we can access
    from our C# code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初步了解了数据格式化的基础知识，我们可以开始讨论计算机上的文件系统是如何工作的，以及我们可以从C#代码中访问哪些属性。
- en: Understanding the filesystem
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解文件系统
- en: When we say filesystem, we're talking about something you're already familiar
    with – how files and folders are created, organized, and stored on your computer.
    When you create a new folder on your computer, you can name it and put files or
    other folders inside it. It's also represented by an icon, which is both a visual
    cue and a way to drag, drop, and move it anywhere you like.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说文件系统时，我们指的是您已经熟悉的东西——文件和文件夹如何在计算机上创建、组织和存储。当您在计算机上创建一个新文件夹时，您可以为其命名并将文件或其他文件夹放入其中。它也由图标表示，这既是一种视觉提示，也是一种拖放和移动到任何您喜欢的位置的方式。
- en: Everything you can do on your desktop you can do in code. All you need is the
    name of the folder, or directory as it's called, and a location to store it. Anytime
    you want to add a file or subfolder, you reference the parent directory and add
    your new content.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在桌面上做的任何事情都可以在代码中完成。您只需要文件夹的名称，或者称为目录，以及存储它的位置。每当您想要添加文件或子文件夹时，您都需要引用父目录并添加新内容。
- en: 'To drive the filesystem home, let''s start building out the `DataManager` class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解文件系统，让我们开始构建`DataManager`类：
- en: Right-click in the **Hierarchy** and choose **Create Empty**, then name it **Data_Manager**:![](img/B17573_12_01.png)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**中右键单击并选择**Create Empty**，然后命名为**Data_Manager**：![](img/B17573_12_01.png)
- en: 'Figure 12.1: Data_Manager in the Hierarchy'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：Hierarchy中的Data_Manager
- en: Select the **Data_Manager** object in the **Hierarchy** and drag the `DataManager`
    script we created in *Chapter 10*, *Revisiting Types, Methods, and Classes*, from
    the **Scripts** folder into the **Inspector**:![](img/B17573_12_02.png)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**中选择**Data_Manager**对象，并将我们在*第10章*“重新审视类型、方法和类”中创建的`DataManager`脚本从**Scripts**文件夹拖放到**Inspector**中：![](img/B17573_12_02.png)
- en: 'Figure 12.2: Data_Manager in the Inspector'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：Inspector中的Data_Manager
- en: 'Open the `DataManager` script and update it with the following code to print
    out a few filesystem properties:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`DataManager`脚本，并使用以下代码更新它以打印出一些文件系统属性：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s break down the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码：
- en: First, we add the `System.IO` namespace, which has all the classes and methods
    we need to work with the filesystem.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加`System.IO`命名空间，其中包含了我们需要处理文件系统的所有类和方法。
- en: We call the `FilesystemInfo` method we create in the next step.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用我们在下一步创建的`FilesystemInfo`方法。
- en: 'We create the `FilesystemInfo` method to print out a few filesystem properties.
    Every operating system handles its filesystem paths differently—a path is the
    location of a directory or file written in a string. On Macs:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建`FilesystemInfo`方法来打印出一些文件系统属性。每个操作系统都以不同的方式处理其文件系统路径——路径是以字符串形式写入的目录或文件的位置。在Mac上：
- en: Paths are separated by a colon (`:`)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径由冒号(`:`)分隔
- en: Directories are separated by a forward slash (`/`)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录由斜杠(`/`)分隔
- en: The current directory path is where the *Hero Born* project is stored
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前目录路径是*Hero Born*项目存储的位置
- en: The temporary path is the location of your filesystem's temporary folder
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时路径是您文件系统的临时文件夹的位置
- en: If you're on other platforms and operating systems, make sure to check the `Path`
    and `Directory` methods for yourself before working with the filesystem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用其他平台和操作系统，请在使用文件系统之前自行检查`Path`和`Directory`方法。
- en: 'Run the game and take a look at the output:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并查看输出：
- en: '![](img/B17573_12_03.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_03.png)'
- en: 'Figure 12.3: Console messages from Data Manager'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：来自数据管理器的控制台消息
- en: The `Path` and `Directory` classes are the foundation we're going to be building
    on to store our data in the following sections. However, they're both large classes,
    so I encourage you to look into their documentation as you continue your data
    journey.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`和`Directory`类是我们将在接下来的部分中用来存储数据的基础。然而，它们都是庞大的类，所以我鼓励您在继续数据之旅时查阅它们的文档。'
- en: You can find more documentation for the Path class at [https://docs.microsoft.com/en-us/dotnet/api/system.io.path](https://docs.microsoft.com/en-us/dotnet/api/system.io.path)
    and the Directory class at [https://docs.microsoft.com/en-us/dotnet/api/system.io.directory](https://docs.microsoft.com/en-us/dotnet/api/system.io.directory).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/api/system.io.path](https://docs.microsoft.com/en-us/dotnet/api/system.io.path)找到`Path`类的更多文档，以及在[https://docs.microsoft.com/en-us/dotnet/api/system.io.directory](https://docs.microsoft.com/en-us/dotnet/api/system.io.directory)找到`Directory`类的更多文档。
- en: Now that we have a simple example of filesystem properties printed out in our
    `DataManager` script, we can create a filesystem path to the location where we
    want to save our data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`DataManager`脚本中打印出了文件系统属性的简单示例，我们可以创建一个文件系统路径，将数据保存到我们想要保存数据的位置。
- en: Working with asset paths
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理资源路径
- en: In a purely C# application, you would have to choose what folder to save your
    files in and write out the folder path in a string. However, Unity provides a
    handy pre-configured path as part of the `Application` class where you can store
    persistent game data. Persistent data means the information is saved and kept
    each time the program runs, which makes it ideal for this kind of player information.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯C#应用程序中，您需要选择要保存文件的文件夹，并将文件夹路径写入字符串中。然而，Unity提供了一个方便的预配置路径作为`Application`类的一部分，您可以在其中存储持久游戏数据。持久数据意味着信息在每次程序运行时都会被保存和保留，这使得它非常适合这种玩家信息。
- en: It's important to know that the path to Unity's persistent data directory is
    cross-platform, meaning that it's different whether you're building a game for
    iOS, Android, Windows, and more. You can find out more information in the Unity
    documentation at [https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，Unity持久数据目录的路径是跨平台的，这意味着为iOS、Android、Windows等构建游戏时会有所不同。您可以在Unity文档中找到更多信息[https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html)。
- en: The only update we need to make to `DataManager` is creating a private variable
    to hold our path string. We're making this private because we don't want any other
    script to be able to access or change the value. That way, `DataManager` is responsible
    for all data-related logic and nothing else.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对`DataManager`进行的唯一更新是创建一个私有变量来保存我们的路径字符串。我们将其设置为私有，因为我们不希望任何其他脚本能够访问或更改该值。这样，`DataManager`负责所有与数据相关的逻辑，而不会有其他东西。
- en: 'Add the following variable to `DataManager.cs`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DataManager.cs`中添加以下变量：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s break down our code update:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们的代码更新：
- en: We created a private variable to hold the data path string
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个私有变量来保存数据路径字符串
- en: 'We set the data path string to the application''s `persistentDataPath` value,
    added a new folder name called **Player_Data** using open and closed forward slashes,
    and printed out the complete path:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将数据路径字符串设置为应用程序的`persistentDataPath`值，使用开放和关闭的斜杠添加了一个名为**Player_Data**的新文件夹，并打印出完整路径：
- en: It's important to note that `Application.persistentDataPath` can only be used
    in a `MonoBehaviour` method like `Awake()`, `Start()`, `Update()`, and so on and
    the game needs to be running for Unity to return a valid path.![](img/B17573_12_04.png)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要的是要注意，`Application.persistentDataPath`只能在`MonoBehaviour`方法中使用，如`Awake()`、`Start()`、`Update()`等，游戏需要运行才能让Unity返回有效的路径。
- en: 'Figure 12.4: File path for Unity persistent data files'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：Unity持久数据文件的文件路径
- en: Since I'm using a Mac, my persistent data folder is nested inside my `/Users`
    folder. Remember to check out [https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html)
    to find out where your data is stored if you're using a different device.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我使用的是Mac，我的持久数据文件夹嵌套在我的`/Users`文件夹中。如果您使用不同的设备，请记得查看[https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html](https://docs.unity3d.com/ScriptReference/Application-persistentDataPath.html)以找出您的数据存储在何处。
- en: 'When you''re not working with a predefined asset path like Unity''s persistent
    data directory, C# has a handy method called `Combine` in the `Path` class for
    automatically configuring path variables. The `Combine()` method can take up to
    four strings as input parameters or an array of strings representing the path
    components. For example, a path to your `User` directory might look like:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不使用类似Unity持久数据目录这样的预定义资源路径时，C#中有一个名为`Combine`的便利方法，位于`Path`类中，用于自动配置路径变量。`Combine()`方法最多可以接受四个字符串作为输入参数，或者表示路径组件的字符串数组。例如，指向您的`User`目录的路径可能如下所示：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This takes care of any potential cross-platform issues with separating characters
    and back or forward slashes in paths and directories.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了路径和目录中的分隔字符和反斜杠或正斜杠的任何潜在跨平台问题。
- en: Now that we have a path to store our data, let's create a new directory, or
    folder, in the filesystem. This will let us store our data securely and between
    game runs, as opposed to temporary storage where it would be deleted or overwritten.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个存储数据的路径，让我们在文件系统中创建一个新目录，或文件夹。这将使我们能够安全地存储我们的数据，并在游戏运行之间进行存储，而不是在临时存储中被删除或覆盖。
- en: Creating and deleting directories
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和删除目录
- en: Creating a new directory folder is straightforward—we check to see if one already
    exists with the same name at the same path, and if not, we tell C# to create it
    for us. Everyone has their own ways of dealing with duplicates in their files
    and folders, so we'll be repeating a fair bit of duplicate checking code in the
    rest of the chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新目录文件夹很简单-我们检查是否已经存在具有相同名称和相同路径的目录，如果没有，我们告诉C#为我们创建它。每个人都有自己处理文件和文件夹中重复内容的方法，因此在本章的其余部分中我们将重复相当多的重复检查代码。
- en: 'I''d still recommend following the **DRY** (**Don''t Repeat Yourself**) principle
    in real-world applications; the duplicate checking code is only repeated here
    to make the examples complete and easy to understand:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我仍然建议在现实世界的应用程序中遵循**DRY**（**不要重复自己**）原则；重复检查代码只是为了使示例完整且易于理解而在这里重复。
- en: 'Add the following method to `DataManager`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`中添加以下方法：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Call the new method inside `Initialize()`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize()`中调用新方法：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s break down what we did:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们所做的事情：
- en: First, we check if the directory folder already exists using the path we created
    in the last step
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用上一步创建的路径检查目录文件夹是否已经存在
- en: If it's already been created, we send ourselves a message in the console and
    use the `return` keyword to exit the method without going any further
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已经创建，我们会在控制台中发送消息，并使用`return`关键字退出方法，不再继续执行
- en: If the directory folder doesn't exist, we pass the `CreateDirectory()` method
    our data path and log that it's been created
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果目录文件夹不存在，我们将向`CreateDirectory()`方法传递我们的数据路径，并记录它已被创建
- en: Run the game and make sure that you see the right debug logs in the console,
    as well as the new directory folder in your persistent data folder.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，并确保您在控制台中看到正确的调试日志，以及您的持久数据文件夹中的新目录文件夹。
- en: If you can't find it, use the `_dataPath` value we printed out in the previous
    step.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到它，请使用我们在上一步中打印出的`_dataPath`值。
- en: '![](img/B17573_12_05.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_05.png)'
- en: 'Figure 12.5: Console message for new directory creation'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：新目录创建的控制台消息
- en: '![](img/B17573_12_06.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_06.png)'
- en: 'Figure 12.6: New directory created on the desktop'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：在桌面上创建的新目录
- en: If you run the game a second time, no duplicate directory folder will be created,
    which is exactly the kind of safe code we want.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您第二次运行游戏，将不会创建重复的目录文件夹，这正是我们想要的安全代码。
- en: '![](img/B17573_12_07.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_07.png)'
- en: 'Figure 12.7: Console message for duplicate directory folders'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：重复目录文件夹的控制台消息
- en: Deleting a directory is very similar to how we created it – we check if it exists,
    then we use the `Directory` class to delete whatever folder is at the path we
    pass in.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 删除目录与创建方式非常相似-我们检查它是否存在，然后使用`Directory`类删除我们传入路径的文件夹。
- en: 'Add the following method to `DataManager`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DataManager`中添加以下方法：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since we want to keep the directory we just created, you don't have to call
    this function right now. However, if you want to try it out all you need to do
    is replace `NewDirectory()` with `DeleteDirectory()` in the `Initialize()` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想保留我们刚刚创建的目录，您现在不必调用此函数。但是，如果您想尝试它，您只需要在`Initialize()`函数中用`DeleteDirectory()`替换`NewDirectory()`。
- en: An empty directory folder isn't super useful, so let's create our first text
    file and save it in our new location.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 空目录文件夹并不是很有用，所以让我们创建我们的第一个文本文件并将其保存在新位置。
- en: Creating, updating, and deleting files
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建、更新和删除文件
- en: Working with files is similar to creating and deleting a directory, so we already
    have the basic building blocks we need. To make sure we don't duplicate data,
    we'll check if the file already exists, and if not, we'll create a new one in
    our new directory folder.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建和删除目录类似，处理文件也是如此，因此我们已经拥有了我们需要的基本构件。为了确保我们不重复数据，我们将检查文件是否已经存在，如果不存在，我们将在新目录文件夹中创建一个新文件。
- en: We'll be working with the `File` class for this section, which has a ton of
    helpful methods to help us implement our features. You can find the entire list
    at [https://docs.microsoft.com/en-us/dotnet/api/system.io.file](https://docs.microsoft.com/en-us/dotnet/api/system.io.file).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`File`类来处理文件，该类具有大量有用的方法来帮助我们实现我们的功能。您可以在[https://docs.microsoft.com/en-us/dotnet/api/system.io.file](https://docs.microsoft.com/en-us/dotnet/api/system.io.file)找到整个列表。
- en: An important point to drive home about files before we start is that they need
    to be opened before you can add text, and they need to be closed after you're
    finished. If you don't close the file you're programmatically working with, it
    will stay open in the program's memory. This both uses computation power for something
    you're not actively editing and can create potential memory leaks. More on them
    later in the chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，关于文件的一个重要观点是，在添加文本之前需要打开文件，并且在完成后需要关闭文件。如果不关闭正在程序化处理的文件，它将保持在程序的内存中。这既使用了计算能力，又可能导致内存泄漏。稍后在本章中会详细介绍。
- en: We're going to be writing individual methods for each action we want to perform
    (create, update, and delete). We're also going to check if the files we're working
    with exist or not in each case, which is repetitive. I've structured this part
    of the book so you can get a solid grasp of each of the procedures. However, you
    can absolutely combine them into more economical methods after you've learned
    the basics.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们想要执行的每个操作（创建、更新和删除）编写单独的方法。我们还将在每种情况下检查我们正在处理的文件是否存在，这是重复的。我构建了本书的这一部分，以便您可以牢固掌握每个过程。但是，在学会基础知识后，您绝对可以将它们合并为更经济的方法。
- en: 'Take the following steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 采取以下步骤：
- en: 'Add a new private string path for the new text file and set its value in `Awake`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新文本文件添加一个新的私有字符串路径，并在`Awake`中设置其值：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a new method to `DataManager`:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`中添加一个新方法：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Call the new method in `Initialize()`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize()`中调用新方法：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s break down our new code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们的新代码：
- en: 'We check if the file already exists, and if it does we `return` out of the
    method to avoid duplicates:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查文件是否已经存在，如果存在，我们将使用`return`退出方法以避免重复：
- en: It's worth noting that this approach works well for new files that aren't going
    to be changed. We'll cover updating and overwriting data to files in the next
    exercise.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得注意的是，这种方法适用于不会被更改的新文件。我们将在下一个练习中讨论更新和覆盖文件数据。
- en: 'We use the `WriteAllText()` method because it does everything we need all in
    one:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`WriteAllText()`方法，因为它可以一次完成所有需要的操作：
- en: A new file is created using our `_textFile` path
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的`_textFile`路径创建一个新文件
- en: We add a title string that says `<SAVE DATA>` and add two new lines with the
    `\n` characters
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加一个标题字符串，写着`<SAVE DATA>`，并添加两个新行，使用`\n`字符
- en: Then the file is closed for us automatically
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后文件会自动关闭
- en: We print out a log message to let us know everything went smoothly
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打印一个日志消息，让我们知道一切顺利进行
- en: 'When you play the game now, you''ll see the debug log in the console and the
    new text file in your persistent data folder location:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩游戏，你会在控制台看到调试日志和持久数据文件夹位置中的新文本文件：
- en: '![](img/B17573_12_08.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_08.png)'
- en: 'Figure 12.8: Console messages for new file creation'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：新文件创建的控制台消息
- en: '![](img/B17573_12_09.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_09.png)'
- en: 'Figure 12.9: New file created on desktop'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：在桌面上创建的新文件
- en: 'To update our new text file, we''ll do a similar set of operations. It''s always
    nice to know when a new game is started, so your next task is to add a method
    to write that information to our save data file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新我们的新文本文件，我们将进行类似的操作。知道新游戏何时开始总是很好，所以你的下一个任务是添加一个方法将这些信息写入我们的保存数据文件：
- en: 'Add a new `using` directive to the top of `DataManager`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`的顶部添加一个新的`using`指令：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a new method to `DataManager`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`中添加一个新方法：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Call the new method in `Initialize()`:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize()`中调用新方法：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s break down the above code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解上面的代码：
- en: If the file exists, we don't want to duplicate it so we just exit out of the
    method without any further action
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件存在，我们不想重复创建，所以我们只是退出方法而不采取进一步的行动
- en: 'If the file does exist, we use another all-in-one method called `AppendAllText()`
    to add the game''s start time:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件存在，我们使用另一个名为`AppendAllText()`的一体化方法来添加游戏的开始时间：
- en: This method opens the file
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个方法打开文件
- en: It adds a new line of text that's passed in as a method parameter
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它添加一个作为方法参数传入的新文本行
- en: It closes the file
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它关闭文件
- en: Print out a log message to let us know everything went smoothly
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印一个日志消息，让我们知道一切顺利进行
- en: 'Play the game again and you''ll see our console message and a new line in our
    text file with the new game''s date and time:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 再次玩游戏，你会看到我们的控制台消息和文本文件中的新行，显示了新游戏的日期和时间：
- en: '![](img/B17573_12_10.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_10.png)'
- en: 'Figure 12.10: Console messages for updating the text file'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：更新文本文件的控制台消息
- en: '![](img/B17573_12_11.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_11.png)'
- en: 'Figure 12.11: Text file data updated'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：更新的文本文件数据
- en: 'In order to read our new file data, we need a method to grab all the file''s
    text and hand it back to us in a string. Luckily, the `File` class has methods
    to do just that:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取我们的新文件数据，我们需要一个方法来获取文件的所有文本并以字符串形式返回给我们。幸运的是，`File`类有相应的方法：
- en: 'Add a new method to `DataManager`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`中添加一个新方法：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Call the new method in `Initialize()` and pass in the `_textFile` as a parameter:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize()`中调用新方法，并将`_textFile`作为参数传入：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s break down the new method''s code below:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解下面的新方法代码：
- en: We create a new method that takes in a string parameter for the file we want
    to read
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个接受文件名参数的新方法
- en: If the file doesn't exist, there's no action needed so we exit out of the method
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在，就不需要采取任何行动，所以我们退出方法
- en: We use the `ReadAllText()` method to get all the file's text data as a string
    and print it out to the console
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`ReadAllText()`方法将文件的所有文本数据作为字符串获取并打印到控制台
- en: Play the game and you'll see a console message with our previous save and a
    new one!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 玩游戏，你会看到一个控制台消息，显示我们之前的保存和一个新的保存！
- en: '![](img/B17573_12_12.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_12.png)'
- en: 'Figure 12.12: Console message with saved text data read from file'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：从文件中读取的保存文本数据的控制台消息
- en: 'Lastly, let''s add a method to delete our text file if we wanted. We''re not
    actually going to use this method, as we want to keep our text file as is, but
    you can always try it out for yourself:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们添加一个方法来删除我们的文本文件。实际上，我们不会使用这个方法，因为我们想保持我们的文本文件不变，但你可以自己尝试一下：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we've dipped our toes a little deeper into the filesystem waters, it's
    time to talk about a slightly upgraded way of working with information — data
    streams!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经深入了一点文件系统的水域，是时候谈谈一个稍微升级的处理信息方式了——数据流！
- en: Working with streams
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用流进行操作
- en: So far, we've been letting the `File` class do all of the heavy lifting with
    our data. What we haven't talked about is how the `File` class, or any other class
    that deals with reading and writing data, does that work under the hood.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直让`File`类来处理我们的数据。我们还没有讨论的是`File`类，或者任何其他处理读写数据的类是如何在底层工作的。
- en: For computers, data is made up of bytes. Think of bytes as the computer's atoms,
    they make up everything—there's even a C# `byte` type. When we read, write, or
    update a file, our data is converted into an array of bytes, which are then streamed
    to or from the file using a `Stream`. The data stream is responsible for carrying
    the data as a sequence of bytes to or from a file, acting as a translator or intermediary
    for us between our game application and the data files themselves.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于计算机来说，数据由字节组成。把字节想象成计算机的原子，它们构成了一切——甚至有一个C#的`byte`类型。当我们读取、写入或更新文件时，我们的数据被转换为字节数组，然后使用`Stream`将这些字节流到文件中或从文件中流出。数据流负责将数据作为字节序列传输到文件中或从文件中传输，充当我们的游戏应用程序和数据文件之间的翻译器或中介。
- en: '![](img/B17573_12_13.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_13.png)'
- en: 'Figure 12.13: Diagram of streaming data to a file'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：将数据流到文件的图示
- en: 'The `File` class uses `Stream` objects for us automatically, and there are
    different `Stream` subclasses for different functionality:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`类自动为我们使用`Stream`对象，不同的`Stream`子类有不同的功能：'
- en: Use a `FileStream` to read and write data to your files
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FileStream`来读取和写入文件数据
- en: Use a `MemoryStream` to read and write data to memory
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`MemoryStream`来读取和写入数据到内存
- en: Use a `NetworkStream` to read and write data to other networked computers
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`NetworkStream`来读取和写入数据到其他网络计算机
- en: Use a `GZipStream` to compress data for easier storage and downloading
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`GZipStream`来压缩数据以便更容易存储和下载
- en: In the coming sections, we'll get into managing stream resources, using helper
    classes called `StreamReader`and `StreamWriter` to create, read, update, and delete
    files. You'll also learn how to format XML more easily using the `XmlWriter` class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入了解管理流资源，使用名为`StreamReader`和`StreamWriter`的辅助类来创建、读取、更新和删除文件。您还将学习如何使用`XmlWriter`类更轻松地格式化XML。
- en: Managing your Stream resources
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理您的流资源
- en: One important topic we haven't talked about yet is resource allocation. What
    that means is some processes in your code will put computing power and memory
    on a sort of layaway plan where you can't touch it. These processes will wait
    until you explicitly tell your program or game to close and return the layaway
    resources to you so you're back to full power. Streams are one such process, and
    they need to be closed after you're done using them. If you don't properly close
    your streams, your program will keep using those resources even though you're
    not.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有谈论的一个重要主题是资源分配。这意味着您的代码中的一些进程将把计算能力和内存放在一种类似分期付款的计划中，您无法触及它。这些进程将等待，直到您明确告诉您的程序或游戏关闭并将分期付款资源归还给您，以便您恢复到全功率。流就是这样一个进程，它们在使用完毕后需要关闭。如果您不正确地关闭流，您的程序将继续使用这些资源，即使您不再使用它们。
- en: Luckily, C# has a handy interface called `IDisposable` that all `Stream` classes
    implement. This interface only has one method, `Dispose()`, which tells the stream
    when to give you back the resources it's been using.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C#有一个方便的接口叫做`IDisposable`，所有的`Stream`类都实现了这个接口。这个接口只有一个方法，`Dispose()`，它告诉流何时将使用的资源归还给您。
- en: You don't have to worry too much about this, as we'll cover an automatic way
    to make sure your streams are always closed correctly. Resource management is
    just a good programming concept to understand.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必太担心这个问题，因为我们将介绍一种自动方式来确保您的流始终正确关闭。资源管理只是一个很好的编程概念需要理解。
- en: We'll be using a `FileStream` for the rest of the chapter, but we'll be doing
    so with convenience classes called `StreamWriter` and `StreamReader`. These classes
    leave out the manual conversion of data to bytes, but still use `FileStream` objects
    themselves.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将使用`FileStream`，但我们将使用称为`StreamWriter`和`StreamReader`的便利类。这些类省去了将数据手动转换为字节的步骤，但仍然使用`FileStream`对象本身。
- en: Using a StreamWriter and StreamReader
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用StreamWriter和StreamReader
- en: Both the `StreamWriter` and `StreamReader` classes serve as helpers for using
    objects belonging to `FileStream` to write and read text data to a specific file.
    These classes are a big help because they create, open, and return a stream you
    can use with minimal boilerplate code. The example code we've covered so far is
    fine for small data files, but streams are the way to go if you're dealing with
    large and complex data objects.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamWriter`和`StreamReader`类都是`FileStream`的辅助类，用于将文本数据写入和读取到特定文件。这些类非常有帮助，因为它们创建、打开并返回一个流，您可以使用最少的样板代码。到目前为止，我们已经涵盖的示例代码对于小型数据文件来说是可以的，但是如果您处理大型和复杂的数据对象，流是最好的选择。'
- en: 'All we need is the name of the file we want to write to or read from and we''re
    all set. Your next task is to use a stream to write text to a new file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要文件的名称，我们就可以开始了。您的下一个任务是使用流将文本写入新文件：
- en: 'Add a new private string path for the new streaming text file and set its value
    in `Awake()`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新的流文本文件添加一个新的私有字符串路径，并在`Awake()`中设置其值：
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a new method to `DataManager`:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`DataManager`添加一个新的方法：
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Delete or comment out the methods in `Initialize()` that we used in the previous
    section and add in our new code:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除或注释掉我们在上一节中使用的`Initialize()`中的方法，并添加我们的新代码：
- en: '[PRE22]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s break down the new method in the above code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解上述代码中的新方法：
- en: First, we check if the file doesn't exist
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查文件是否不存在
- en: If the file hasn't been created yet, we add a new `StreamWriter` instance called
    `newStream`, which uses the `CreateText()` method to create and open the new file
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件尚未创建，我们添加一个名为`newStream`的新`StreamWriter`实例，该实例使用`CreateText()`方法创建和打开新文件
- en: Once the file is open, we use the `WriteLine()` method to add a header, close
    the stream, and print out a debug message
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件打开后，我们使用`WriteLine()`方法添加标题，关闭流，并打印出调试消息
- en: If the file already exists and we just want to update it, we grab our file through
    a new `StreamWriter` instance using the `AppendText()` method so our existing
    data doesn't get overwritten
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件已经存在，我们只想要更新它，我们通过使用`AppendText()`方法的新`StreamWriter`实例来获取我们的文件，以便我们的现有数据不被覆盖
- en: Finally, we write a new line with our game data, close the stream, and print
    out a debug message:![](img/B17573_12_14.png)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们写入游戏数据的新行，关闭流，并打印出调试消息！[](img/B17573_12_14.png)
- en: 'Figure 12.14: Console messages for writing and updating text with a stream'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：使用流写入和更新文本的控制台消息
- en: '![](img/B17573_12_15.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_15.png)'
- en: 'Figure 12.15: New file created and updated with a stream'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15：使用流创建和更新的新文件
- en: 'Reading from a stream is almost exactly like the `ReadFromFile()` method we
    created in the last section. The only difference is that we''ll use a `StreamReader`
    instance to open and read the information. Again, you want to use streams when
    you''re dealing with big data files or complex objects instead of manually creating
    and writing to files with the `File` class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从流中读取几乎与我们在上一节中创建的`ReadFromFile()`方法几乎完全相同。唯一的区别是我们将使用`StreamReader`实例来打开和读取信息。同样，当处理大数据文件或复杂对象时，您希望使用流，而不是使用`File`类手动创建和写入文件：
- en: 'Add a new method to `DataManager`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`DataManager`添加一个新的方法：
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Call the new method in `Initialize()` and pass in the `_streamingTextFile`
    as a parameter:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize()`中调用新方法，并将`_streamingTextFile`作为参数传入：
- en: '[PRE24]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s break down our new code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们的新代码：
- en: First, we check if the file doesn't exist, and if it doesn't then we print out
    a console message and exit the method
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查文件是否不存在，如果不存在，我们打印出一个控制台消息并退出方法
- en: If the file does exist, we create a new `StreamReader` instance with the name
    of the file we want to access and print out the entire contents using the `ReadToEnd`
    method:![](img/B17573_12_16.png)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件存在，我们使用要访问的文件的名称创建一个新的`StreamReader`实例，并使用`ReadToEnd`方法打印出整个内容！[](img/B17573_12_16.png)
- en: 'Figure 12.16: Console printing out saved data read from a stream'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16：控制台打印出从流中读取的保存数据
- en: As you'll start to notice, a lot of our code is starting to look the same. The
    only difference is our use of stream classes to do the actual reading-writing
    work. However, it's important to keep in mind how different use cases will determine
    which route you take. Refer back to the beginning of this section to review how
    each stream type is different.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将开始注意到的，我们的很多代码开始看起来一样。唯一的区别是我们使用流类来进行实际的读写工作。然而，重要的是要记住不同的用例将决定你采取哪种路线。回顾本节开头，了解每种流类型的不同之处。
- en: So far, we've covered the basic features of a **CRUD** (**Creating**, **Reading**,
    **Updating**, **and** **Deleting**) application using text files. But text files
    aren't the only data format you'll be using in C# games and applications. You're
    likely to see lots of XML and JSON in the wild once you start working with databases
    and your own complex data structures, which text can't compare to in efficiency
    or storage.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了使用文本文件的**CRUD**（**创建**，**读取**，**更新**和**删除**）应用程序的基本功能。但文本文件并不是你在C#游戏和应用程序中使用的唯一数据格式。一旦你开始使用数据库和自己的复杂数据结构，你可能会看到大量的XML和JSON，这些文本无法比拟的效率和存储。
- en: In the next section, we'll work with some basic XML data, then talk about an
    easier way to manage streams.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用一些基本的XML数据，然后讨论一种更容易管理流的方法。
- en: Creating an XMLWriter
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建XMLWriter
- en: Sometimes you won't just have plain old text to write and read from a file.
    Your project might require XML-formatted documents, in which case you'll need
    to know how to use a regular `FileStream` to save and load XML data.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你不只是需要简单的文本来写入和读取文件。你的项目可能需要XML格式的文档，这种情况下你需要知道如何使用常规的`FileStream`来保存和加载XML数据。
- en: Writing XML data to a file isn't all that different from what we've been doing
    with text and streams. The only difference is we'll explicitly create a `FileStream`
    and use it to create an instance of an `XmlWriter`. Think of the `XmlWriter` class
    as a wrapper that takes our data stream, applies XML formatting, and spits out
    our information as an XML file. Once we have that, we can structure the document
    in the proper XML format using methods from the `XmlWriter` class and close the
    file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将XML数据写入文件并没有太大的不同，与我们之前使用文本和流的方式相似。唯一的区别是我们将显式创建一个`FileStream`并使用它来创建一个`XmlWriter`的实例。将`XmlWriter`类视为一个包装器，它接受我们的数据流，应用XML格式，并将我们的信息输出为XML文件。一旦我们有了这个，我们可以使用`XmlWriter`类的方法在适当的XML格式中构造文档并关闭文件。
- en: 'Your next task is to create a file path for a new XML document and add the
    ability to write XML data to that file using the `DataManager` class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一个任务是为新的XML文档创建一个文件路径，并使用`DataManager`类的能力来将XML数据写入该文件：
- en: 'Add the highlighted `using` directive to the top of the `DataManager` class:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`类的顶部添加突出显示的`using`指令：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add a new private string path for the new XML file and set its value in `Awake()`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新的XML文件添加一个新的私有字符串路径，并在`Awake()`中设置其值：
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a new method at the bottom of the `DataManager` class:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`类的底部添加一个新的方法：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Call the new method in `Initialize()` and pass in `_xmlLevelProgress` as a
    parameter:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize()`中调用新方法，并传入`_xmlLevelProgress`作为参数：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s break down our XML writing method:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们的XML写入方法：
- en: First, we check if the file already exists
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查文件是否已经存在
- en: If the file doesn't exist, we create a new `FileStream` using the new path variable
    we created
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在，我们使用我们创建的新路径变量创建一个新的`FileStream`
- en: We then create a new `XmlWriter` instance and pass it our new `FileStream`
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个新的`XmlWriter`实例，并将其传递给我们的新的`FileStream`。
- en: Next, we use the `WriteStartDocument` method to specify XML version 1.0
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`WriteStartDocument`方法指定XML版本1.0
- en: Then we call the `WriteStartElement` method to add the opening root element
    tag named `level_progress`
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用`WriteStartElement`方法添加名为`level_progress`的根元素标签
- en: Now we can add individual elements to our document using the `WriteElementString`
    method, passing in `level` as the element tag and the level number using a `for`
    loop and its index value of `i`
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`WriteElementString`方法向我们的文档添加单独的元素，通过使用`for`循环和其索引值`i`传入`level`作为元素标签和级别数字
- en: To close the document, we use the `WriteEndElement` method to add a closing
    `level` tag
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了关闭文档，我们使用`WriteEndElement`方法添加一个闭合的`level`标签
- en: Finally, we close the writer and stream to release the stream resources we've
    been using
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们关闭写入器和流，释放我们一直在使用的流资源
- en: 'If you run the game now, you''ll see a new `.xml` file in our **Player_Data**
    folder with the level progress information:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行游戏，你会在我们的**Player_Data**文件夹中看到一个新的`.xml`文件，其中包含了级别进度信息：
- en: '![](img/B17573_12_17.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_17.png)'
- en: 'Figure 12.17: New XML file created with document data'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：使用文档数据创建的新XML文件
- en: You'll notice that there is no indenting or formatting, which is expected because
    we didn't specify any output formatting. We're not going to use any of them in
    this example because we'll be talking about a more efficient way of writing XML
    data in the next section, on serialization.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到没有缩进或格式化，这是预期的，因为我们没有指定任何输出格式。在这个例子中，我们不会使用任何输出格式，因为我们将在下一节中讨论一种更有效的写入XML数据的方法，即序列化。
- en: You can find the list of output formatting properties at [https://docs.microsoft.com/dotnet/api/system.xml.xmlwriter#specifying-the-output-format](https://docs.microsoft.com/dotnet/api/system.xml.xmlwriter#specifying-the-output-format).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.microsoft.com/dotnet/api/system.xml.xmlwriter#specifying-the-output-format](https://docs.microsoft.com/dotnet/api/system.xml.xmlwriter#specifying-the-output-format)找到输出格式属性的列表。
- en: 'The good news is that reading an XML file is no different than reading any
    other file. You can call either the `readfromfile()` or `readfromstream()` methods
    inside `initialize()` and get the same console output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，读取XML文件与读取任何其他文件没有任何区别。您可以在`initialize()`内部调用`readfromfile()`或`readfromstream()`方法，并获得相同的控制台输出：
- en: '[PRE29]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![](img/B17573_12_18.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_18.png)'
- en: 'Figure 12.18: Console output from reading the XML file data'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18：从读取XML文件数据的控制台输出
- en: Now that we've written a few methods using streams, let's take a look at how
    to efficiently, and more importantly automatically, close any stream.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了一些使用流的方法，让我们看看如何高效地，更重要的是自动地关闭任何流。
- en: Automatically closing streams
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动关闭流
- en: When you're working with streams, wrapping them in a `using` statement automatically
    closes the stream for you by calling the `Dispose()` method from the `IDisposable`
    interface we mentioned earlier.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用流时，将它们包装在`using`语句中会通过从我们之前提到的`IDisposable`接口调用`Dispose()`方法来自动关闭流。
- en: This way, you never have to worry about unused allocated resources your program
    might be keeping open for no reason.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，您就永远不必担心程序可能会保持打开但未使用的分配资源。
- en: 'The syntax is almost exactly the same as what we''ve already done, except we
    use the `using` keyword at the beginning of the line, then reference a new stream
    inside a pair of parentheses, followed by a set of curly braces. Anything we want
    the stream to do, like read or write data, is done inside the curly braces block
    of code. For example, creating a new text file as we did in the `WriteToStream()`
    method would look like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 语法几乎与我们已经完成的内容完全相同，只是在行的开头使用`using`关键字，然后在一对括号内引用一个新的流，然后是一组花括号。我们想要流执行的任何操作，比如读取或写入数据，都是在花括号的代码块内完成的。例如，创建一个新的文本文件，就像我们在`WriteToStream()`方法中所做的那样：
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As soon as the stream logic is inside the code block, the outer `using` statement
    automatically closes the stream and returns the allocated resources to your program.
    From here on out, I'd recommend always using this syntax to write your streaming
    code. It's more efficient, much safer, and will demonstrate your understanding
    of basic resource management!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦流逻辑在代码块内部，外部的`using`语句将自动关闭流并将分配的资源返回给您的程序。从现在开始，我建议您始终使用这种语法来编写您的流代码。这样更有效率，更安全，并且将展示您对基本资源管理的理解！
- en: With our text and XML stream code working, it's time to move on. If you're wondering
    why we didn't stream any JSON data, it's because we need to add one more tool
    to our data toolbox—serialization!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的文本和XML流代码的运行，是时候继续前进了。如果你想知道为什么我们没有流传输任何JSON数据，那是因为我们需要向我们的数据工具箱中添加一个工具——序列化！
- en: Serializing data
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化数据
- en: When we talk about serializing and deserializing data, what we're really talking
    about is translation. While we've been translating our text and XML piecemeal
    in previous sections, being able to take an entire object and translate it in
    one shot is a great tool to have.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论序列化和反序列化数据时，我们实际上在谈论翻译。虽然在之前的章节中我们一直在逐步翻译我们的文本和XML，但能够一次性地将整个对象翻译成另一种格式是一个很好的工具。
- en: 'By definition:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义：
- en: The act of **serializing** an object translates the object's entire state into
    another format
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**序列化**对象的行为是将对象的整个状态转换为另一种格式'
- en: The act of **deserializing** is the reverse, taking the data from a file and
    restoring it to its former object state
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反序列化**的行为是相反的，它将数据从文件中恢复到其以前的对象状态'
- en: '![](img/B17573_12_19.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_19.png)'
- en: 'Figure 12.19: Example of serializing an object into XML and JSON'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19：将对象序列化为XML和JSON的示例
- en: Let's take a practical example from the above image — an instance of our `Weapon`
    class. Each weapon has its own name and damage properties and associated values,
    which is called its state. The state of an object is unique, which allows the
    program to tell them apart.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从上面的图像中拿一个实际的例子——我们的`Weapon`类的一个实例。每个武器都有自己的名称和伤害属性以及相关的值，这被称为它的状态。对象的状态是独一无二的，这使得程序可以区分它们。
- en: An object's state also includes properties or fields that are reference types.
    For instance, if we had a `Character` class that had a `Weapon` property, C# would
    still recognize the weapon's `name` and `damage` properties when serializing and
    deserializing. You might hear objects with reference properties referred to as
    object graphs out in the programming world.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的状态还包括引用类型的属性或字段。例如，如果我们有一个`Character`类，它有一个`Weapon`属性，那么当序列化和反序列化时，C#仍然会识别武器的`name`和`damage`属性。您可能会在编程世界中听到具有引用属性的对象被称为对象图。
- en: Before we jump in, it's worth noting that serializing objects can be tricky
    if you're not keeping a close eye on making sure the object properties match the
    data from a file, and vice versa. For example, if there's a mismatch between your
    class object properties and the data being deserialized, the serializer will return
    an empty object. We'll cover this in more detail when we try to serialize a C#
    list into JSON later in the chapter.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，值得注意的是，如果您没有密切关注确保对象属性与文件中的数据匹配，反之亦然，那么序列化对象可能会很棘手。例如，如果您的类对象属性与正在反序列化的数据不匹配，序列化程序将返回一个空对象。当我们尝试在本章后面将C#列表序列化为JSON时，我们将更详细地介绍这一点。
- en: To really get the hang of this, let's take our `Weapon` example and turn it
    into working code.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正掌握这一点，让我们以我们的`Weapon`示例并将其转换为可工作的代码。
- en: Serializing and deserializing XML
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化和反序列化XML
- en: Your task for the rest of this chapter is to serialize and deserialize a list
    of weapons into XML and JSON, with XML going first!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩下的任务是将武器列表序列化和反序列化为XML和JSON，首先是XML！
- en: 'Add a new `using` directive to the top of the `DataManager` class:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`类的顶部添加一个新的`using`指令：
- en: '[PRE31]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add a serializable attribute to the `Weapon` class so Unity and C# know the
    object can be serialized:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Weapon`类添加一个可序列化的属性，以便Unity和C#知道该对象可以被序列化：
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add two new variables, one for the XML file path and one for the list of weapons:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个新变量，一个用于XML文件路径，一个用于武器列表：
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Set the XML file path value in `Awake`:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`中设置XML文件路径值：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add a new method at the bottom of the `DataManager` class:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`类的底部添加一个新方法：
- en: '[PRE35]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Call the new method in `Initialize`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize`中调用新方法：
- en: '[PRE36]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s break down our new method:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解我们的新方法：
- en: 'First, we create an `XmlSerializer` instance and pass in the type of data we''re
    going to be translating. In this case, the _`weaponInventory` is of type `List<Weapon>`,
    which is what we use in the `typeof` operator:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`XmlSerializer`实例，并传入我们要翻译的数据类型。在这种情况下，`weaponInventory`的类型是`List<Weapon>`，这是我们在`typeof`运算符中使用的类型：
- en: The `XmlSerializer` class is another helpful formatting wrapper, just like the
    `XmlWriter` class we used earlier
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XmlSerializer`类是另一个有用的格式包装器，就像我们之前使用的`XmlWriter`类一样'
- en: Then, we create a `FileStream` using the `_xmlWeapons` file path and wrapped
    in a `using` code block to make sure it's closed properly.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`FileStream`创建一个`_xmlWeapons`文件路径，并包装在`using`代码块中以确保它被正确关闭。
- en: Finally, we call the `Serialize()` method and pass in the stream and the data
    we want to translate.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们调用`Serialize()`方法，并传入流和我们想要翻译的数据。
- en: Run the game again and take a look at the new XML document we created without
    having to specify any additional formatting!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，并查看我们创建的新XML文档，而无需指定任何额外的格式！
- en: '![](img/B17573_12_20.png)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_20.png)'
- en: 'Figure 12.20: XML output in the weapon inventory file'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：武器清单文件中的XML输出
- en: 'To read back our XML into a list of weapons, we set up everything almost exactly
    same except we use the `Deserialize()` method from the `XmlSerializer` class instead:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的XML读回武器列表，我们几乎设置了完全相同的一切，只是我们使用了`XmlSerializer`类的`Deserialize()`方法：
- en: 'Add the following method to the bottom of the `DataManager` class:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`类的底部添加以下方法：
- en: '[PRE37]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Call the new method in `Initialize` and pass in the `_xmlWeapons` as a parameter:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize`中调用新方法，并将`_xmlWeapons`作为参数传入：
- en: '[PRE38]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s break down the `deserialize()` method:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解`deserialize()`方法：
- en: First, we check if the file exists
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查文件是否存在
- en: If the file exists, we create an `XmlSerializer` object and specify that we're
    going to put the XML data back into a `List<Weapon>` object
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件存在，我们创建一个`XmlSerializer`对象，并指定我们将把XML数据放回`List<Weapon>`对象中
- en: 'Then, we open up a `FileStream` with the `_xmlWeapons` file name:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们用`FileStream`打开`_xmlWeapons`文件名：
- en: We're using `File.OpenRead()` to specify that we want to open the file for reading,
    not writing
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`File.OpenRead()`来指定我们要打开文件进行读取，而不是写入
- en: 'Next, we create a variable to hold our deserialized list of weapons:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个变量来保存我们反序列化的武器列表：
- en: We put the explicit `List<Weapon>` cast in front of the call to `Deserialize()`
    so that we get the correct type back from the serializer
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`Deserialize()`调用前放置了显式的`List<Weapon>`转换，以便我们从序列化程序中获得正确的类型
- en: Finally, we use a `foreach` loop to print out each weapon's name and damage
    values in the console
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`foreach`循环在控制台中打印出每个武器的名称和伤害值
- en: When you run the game once again, you'll see that we get a console message for
    each weapon we deserialized from the XML list.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当您再次运行游戏时，您会看到我们从XML列表中反序列化的每个武器都会得到一个控制台消息。
- en: '![](img/B17573_12_21.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_21.png)'
- en: 'Figure 12.21: Console output from deserializing XML'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21：从反序列化XML中的控制台输出
- en: That's all we need to do for XML data, but before we finish out the chapter
    we still need to learn how to work with JSON!
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对XML数据所需做的一切，但在我们完成本章之前，我们仍然需要学习如何处理JSON！
- en: Serializing and deserializing JSON
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化和反序列化JSON
- en: When it comes to serializing and deserializing JSON, Unity and C# aren't completely
    in sync. Essentially, C# has its own `JsonSerializer` class that works the exact
    same way as the `XmlSerializer` class we used in the previous examples.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在序列化和反序列化JSON方面，Unity和C#并不完全同步。基本上，C#有自己的`JsonSerializer`类，它的工作方式与我们在先前示例中使用的`XmlSerializer`类完全相同。
- en: In order to access the JSON serializer, you need the `System.Text.Json` `using`
    directive. Here's the rub—Unity doesn't support that namespace. Instead, Unity
    uses the `System.Text` namespace and implements its own JSON serializer class
    called `JsonUtility`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问JSON序列化程序，您需要`System.Text.Json`的`using`指令。这就是问题所在——Unity不支持该命名空间。相反，Unity使用`System.Text`命名空间，并实现了自己的JSON序列化程序类`JsonUtility`。
- en: Because our project is in Unity, we're going to work with Unity's supported
    serialization class. However, if you're working with a non-Unity C# project, the
    concepts are the same as the XML code we just wrote.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的项目在Unity中，我们将使用Unity支持的序列化类。但是，如果您正在使用非Unity的C#项目，概念与我们刚刚编写的XML代码相同。
- en: You can find a complete how-to that includes code from Microsoft at [https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to#how-to-write-net-objects-as-json-serialize](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to#how-to-write-net-objects-as-json-serialize).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to#how-to-write-net-objects-as-json-serialize](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-how-to#how-to-write-net-objects-as-json-serialize)找到包含来自Microsoft的完整操作指南和代码。
- en: 'Your next task is to serialize a single weapon to get the hang of the `JsonUtility`
    class:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 您的下一个任务是序列化单个武器，以熟悉`JsonUtility`类：
- en: 'Add a new `using` directive to the top of the `DataManager` class:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`类的顶部添加一个新的`using`指令：
- en: '[PRE39]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add a new private string path for the new XML file and set its value in `Awake()`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新的XML文件添加一个私有字符串路径，并在`Awake()`中设置其值：
- en: '[PRE40]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Add a new method at the bottom of the `DataManager` class:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`类的底部添加一个新方法：
- en: '[PRE41]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Call the new method in `Initialize()` and pass in the `_jsonWeapons` as a parameter:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize()`中调用新方法，并将`_jsonWeapons`作为参数传入：
- en: '[PRE42]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here''s the breakdown of the serialize method:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这是序列化方法的分解：
- en: First, we need a weapon to work with, so we create one with our class initializer
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个要处理的武器，因此我们使用我们的类初始化器创建一个
- en: 'Then we declare a variable to hold the translated JSON data when it''s formatted
    as a string and call the `ToJson()` method:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们声明一个变量来保存格式化为字符串的翻译JSON数据，并调用`ToJson()`方法：
- en: The `ToJson()` method we're using takes in the `sword` object we want to serialize
    and a Boolean value of `true` so the string is pretty printed with proper indenting.
    If we didn't specify a `true` value, the JSON would still print out, it would
    just be a regular string, which isn't easily readable.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用的`ToJson()`方法接受我们要序列化的`sword`对象和一个布尔值`true`，以便字符串以正确的缩进方式漂亮打印。如果我们没有指定`true`值，JSON仍然会打印出来，只是一个常规字符串，不容易阅读。
- en: Now that we have a text string to write to a file, we create a `StreamWriter`
    stream and pass in the `_jsonWeapons` file name
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个要写入文件的文本字符串，我们创建一个`StreamWriter`流，并传入`_jsonWeapons`文件名
- en: Finally, we use the `WriteLine()` method and pass it the `jsonString` value
    to write to the file
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`WriteLine()`方法，并将`jsonString`值传递给它以写入文件。
- en: Run the program and look at the new JSON file we created and wrote data into!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序并查看我们创建并写入数据的新JSON文件！
- en: '![](img/B17573_12_22.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_22.png)'
- en: 'Figure 12.22: JSON file with weapon properties serialized'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22：序列化武器属性的JSON文件
- en: Now let's try and serialize our list of weapons we used in the XML examples
    and see what happens.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试序列化我们在XML示例中使用的武器列表，看看会发生什么。
- en: 'Update the `SerializeJSON()` method to use the existing list of weapons instead
    of the single `sword` instance:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`SerializeJSON()`方法，使用现有的武器列表而不是单个`sword`实例：
- en: '[PRE43]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When you run the game again, you''ll see the JSON file data was overwritten
    and all we ended up with is an empty array:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次运行游戏时，你会看到JSON文件数据被覆盖，我们最终得到的只是一个空数组：
- en: '![](img/B17573_12_23.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_23.png)'
- en: 'Figure 12.23: JSON file with an empty object after serialization'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23：序列化后为空对象的JSON文件
- en: Again, this is because the way Unity handles JSON serialization doesn't support
    lists or arrays by themselves. Any list or array needs to be part of a class object
    for Unity's `JsonUtility` class to recognize and handle it correctly.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Unity处理JSON序列化的方式不支持单独的列表或数组。任何列表或数组都需要作为类对象的一部分，以便Unity的`JsonUtility`类能够正确识别和处理它。
- en: Don't panic, if we think about this, it's a fairly intuitive fix—we just need
    to create a class that has a weapons list property and use that when we serialize
    our data into JSON!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 不要惊慌，如果我们考虑一下，这是一个相当直观的修复方法——我们只需要创建一个具有武器列表属性的类，并在将数据序列化为JSON时使用它！
- en: 'Open `Weapon.cs` and add the following serializable `WeaponShop` class to the
    bottom of the file. Be super careful to put the new class outside the `Weapon`
    class curly braces:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Weapon.cs`并在文件底部添加以下可序列化的`WeaponShop`类。一定要小心将新类放在`Weapon`类花括号之外：
- en: '[PRE44]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Back in the `DataManager` class, update the `SerializeJSON()` method with the
    following code:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`类中，使用以下代码更新`SerializeJSON()`方法：
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s break down the changes we just made:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解刚刚做的更改：
- en: First, we create a new variable called `shop`, which is an instance of the `WeaponShop`
    class
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`shop`的新变量，它是`WeaponShop`类的一个实例
- en: Then we set the `inventory` property to the `weaponInventory` list of weapons
    we already declared
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将“库存”属性设置为我们已经声明的武器列表`weaponInventory`
- en: Finally, we pass the `shop` object to the `ToJson()` method and write the new
    string data to the JSON file
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`shop`对象传递给`ToJson()`方法，并将新的字符串数据写入JSON文件
- en: 'Run the game again and look at the pretty printed list of weapons we''ve created:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，并查看我们创建的漂亮打印的武器列表：
- en: '![](img/B17573_12_24.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_24.png)'
- en: 'Figure 12.24: List object properly serialized into JSON'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24：列表对象正确序列化为JSON
- en: 'Deserializing JSON text back into an object is the reverse process of what
    we just did:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 将JSON文本反序列化为对象是刚才所做的过程的逆过程：
- en: 'Add a new method at the bottom of the `DataManager` class:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DataManager`类的底部添加一个新方法：
- en: '[PRE46]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Call the new method in `Initialize()` and pass `_jsonWeapons` in as a parameter:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Initialize()`中调用新方法，并将`_jsonWeapons`作为参数传递：
- en: '[PRE47]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s break down the `DeserializeJSON()` method below:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解下面的`DeserializeJSON()`方法：
- en: First, we check if the file exists
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们检查文件是否存在
- en: If it does exist, we create a stream with the `_jsonWeapons` file path wrapped
    in a `using` code block
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在，我们创建一个包装在`using`代码块中的`_jsonWeapons`文件路径的流
- en: Then, we use the stream's `ReadToEnd()` method to grab the entire JSON text
    from the file
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用流的`ReadToEnd()`方法从文件中获取整个JSON文本
- en: 'Next, we create a variable to hold our deserialized list of weapons and call
    the `FromJson()` method:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个变量来保存我们反序列化的武器列表，并调用`FromJson()`方法：
- en: Notice that we specify that we want to turn our JSON into a `WeaponShop` object
    with the `<WeaponShop>` syntax before passing in the JSON string variable
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，在传入JSON字符串变量之前，我们指定要将我们的JSON转换为“WeaponShop”对象的`<WeaponShop>`语法
- en: Finally, we loop through the weapon shop's `inventory` list property and print
    out each weapon's name and damage values in the console
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们循环遍历武器商店的“库存”列表属性，并在控制台中打印出每个武器的名称和伤害值
- en: 'Run the game one last time and you''ll see a console message printed out for
    each weapon in our JSON data:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行游戏，你会看到我们的JSON数据中为每个武器打印出一个控制台消息：
- en: '![](img/B17573_12_25.png)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_12_25.png)'
- en: 'Figure 12.25: Console output from deserializing a list of JSON objects'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25：反序列化JSON对象列表的控制台输出
- en: Data roundup
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据汇总
- en: Every individual module and topic we've covered in this chapter can be used
    by itself or combined to suit your project's needs. For example, you could use
    text files to store character dialogue and only load it when you need to. This
    would be more efficient than having the game keep track of it every time it runs,
    even when the information isn't being used.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中涵盖的每个单独的模块和主题都可以单独使用，也可以组合使用以满足项目的需求。例如，您可以使用文本文件存储角色对话，并且只在需要时加载它。这比游戏每次运行时都跟踪它更有效，即使信息没有被使用。
- en: You could also put character data or enemy statistics into either an XML or
    JSON file and read from the file anytime you need to level up a character or spawn
    a new monster. Finally, you could fetch data from a third-party database and serialize
    it into your own custom classes. This is a super common scenario with storing
    player accounts and external game data.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将角色数据或敌人统计数据放入XML或JSON文件中，并在需要升级角色或生成新怪物时从文件中读取。最后，你可以从第三方数据库中获取数据并将其序列化为你自己的自定义类。这在存储玩家账户和外部游戏数据时非常常见。
- en: You can find a list of data types that can be serialized in C# at [https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer](https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer).
    Unity handles serialization a little differently, so make sure you check the available
    types at [https://docs.unity3d.com/ScriptReference/SerializeField.html](https://docs.unity3d.com/ScriptReference/SerializeField.html).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer](https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/types-supported-by-the-data-contract-serializer)找到C#中可以序列化的数据类型列表。Unity处理序列化的方式略有不同，所以确保你在[https://docs.unity3d.com/ScriptReference/SerializeField.html](https://docs.unity3d.com/ScriptReference/SerializeField.html)上检查可用的类型。
- en: The point I'm trying to make is that data is everywhere, and it's your job to
    create a system that handles it the way your game needs, brick by brick.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要表达的是，数据无处不在，你的工作就是创建一个能够按照你的游戏需求处理数据的系统，一步一步地构建。
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: And that's a wrap on the basics of working with data! Congratulations on making
    it through this monster chapter intact. Data in any programming context is a big
    topic, so take everything you've learned in this chapter as a jumping-off point.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 关于处理数据的基础知识就介绍到这里了！恭喜你成功地完成了这一庞大的章节。在任何编程环境中，数据都是一个重要的话题，所以把这一章学到的东西当作一个起点。
- en: You already know how to navigate the filesystem, and create, read, update, and
    delete files. You also learned how to effectively work with text, XML, and JSON
    data formats, as well as data streams. And you know how to take an entire object's
    state and serialize or deserialize it into both XML and JSON. All in all, learning
    these skills was no small feat. Don't forget to review and revisit this chapter
    more than once; there's a lot here that might not become second nature on the
    first run-through.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何浏览文件系统，创建、读取、更新和删除文件。你还学会了如何有效地处理文本、XML和JSON数据格式，以及数据流。你知道如何将整个对象的状态序列化或反序列化为XML和JSON。总的来说，学习这些技能并不是一件小事。不要忘记多次复习和重温这一章；这里有很多东西可能不会在第一次阅读时变得很熟悉。
- en: In the next chapter, we'll discuss the basics of generic programming, get a
    little hands-on experience with delegates and events, and wrap up with an overview
    of exception handling.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论泛型编程的基础知识，获得一些关于委托和事件的实践经验，并最后概述异常处理。
- en: Pop quiz – data management
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速测验-数据管理
- en: Which namespace gives you access to the `Path` and `Directory` classes?
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命名空间让你可以访问`Path`和`Directory`类？
- en: In Unity, what folder path do you use to save data between runs of your game?
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，你使用什么文件夹路径来在游戏运行之间保存数据？
- en: What data type do `Stream` objects use to read and write information to files?
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stream`对象使用什么数据类型来读写文件中的信息？'
- en: What happens when you serialize an object into JSON?
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你将一个对象序列化为JSON时会发生什么？
- en: JOIN us on Discord!
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C#专家和Harrison Ferrone一起阅读本书。提出问题，为其他读者提供解决方案，通过*问我任何事*会话与作者交流，以及更多。
- en: Join Now!
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
