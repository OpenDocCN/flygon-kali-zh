- en: Chapter 8. Performance and Memory Optimization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。性能和内存优化
- en: Optimization is one of the most important tasks of any development cycle. It
    is inevitable, especially for games. Game optimization enhances performance significantly.
    Through optimization, more hardware platforms can be targeted.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是任何开发周期中最重要的任务之一。尤其是对于游戏来说是不可避免的。游戏优化显著提高了性能。通过优化，可以针对更多的硬件平台。
- en: You have already learned that Android supports a range of hardware platforms.
    Each platform has a separate configuration. By optimizing the use of hardware
    resources, a game can be run on more hardware platforms. This technique can be
    applied to visual quality as well. Not all devices have the same quality display,
    so optimizing the assets for low resolution saves a lot of storage space as well
    as heap memory during runtime.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解到安卓支持一系列硬件平台。每个平台都有单独的配置。通过优化硬件资源的使用，游戏可以在更多的硬件平台上运行。这种技术也可以应用于视觉质量。并非所有设备都具有相同的显示质量，因此为低分辨率优化资源可以节省大量的存储空间以及运行时的堆内存。
- en: In programming, the developer often writes intermediate code and forgets to
    optimize it later. This may cause a significant amount of performance loss or
    even cause the game to crash.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，开发人员经常编写中间代码，然后忘记对其进行优化。这可能导致大量的性能损失，甚至导致游戏崩溃。
- en: 'We will discuss the scope of various optimizations in Android game development
    through the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下主题讨论安卓游戏开发中各种优化的范围：
- en: Fields of optimization in Android games
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓游戏中的优化领域
- en: Relationship between performance and memory management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能和内存管理之间的关系
- en: Memory management in Android
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓中的内存管理
- en: Processing segments in Android
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓中的处理段
- en: Different memory segments
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的内存段
- en: Importance of memory optimization
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存优化的重要性
- en: Optimizing performance
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能优化
- en: Increasing the frame rate
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加帧率
- en: Importance of performance optimization
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能优化的重要性
- en: Common optimization mistakes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的优化错误
- en: Best optimization practices
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳优化实践
- en: Fields of optimization in Android games
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓游戏中的优化领域
- en: 'We all know the requirement of optimization in any development project. In
    the case of game development, this fact remains the same. In a game development
    project, the process starts with limited resources and design. After development,
    the game is expected to be run on maximum possible devices with maximum quality.
    To achieve that, memory and performance optimization becomes mandatory. So, let''s
    discuss the following four segments of optimization:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道在任何开发项目中都需要优化。在游戏开发的情况下，这一事实仍然如此。在游戏开发项目中，流程始于有限的资源和设计。开发后，预期游戏能在尽可能多的设备上以最高质量运行。为了实现这一点，内存和性能优化变得必不可少。因此，让我们讨论以下四个优化领域：
- en: Resource optimization
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源优化
- en: Design optimization
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计优化
- en: Memory optimization
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存优化
- en: Performance optimization
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能优化
- en: Resource optimization
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源优化
- en: Resource optimization is basically optimizing the art, sound, and data files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 资源优化基本上是优化艺术、声音和数据文件。
- en: Art optimization
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 艺术优化
- en: We have already discussed many optimization techniques and tools. Here, we will
    discuss the necessity of art optimization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了许多优化技术和工具。在这里，我们将讨论艺术优化的必要性。
- en: Art is visually the most important part in games. Improving the art with bigger
    and better display quality increases processing and storage costs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术在游戏中在视觉上是最重要的部分。提高艺术品的显示质量会增加处理和存储成本。
- en: Large textures occupy a large amount of memory. However, scaling up art to fit
    a bigger resolution screen affects visual quality. So, a balance must be met.
    Also, various Android devices support various limitations on texture size. Moreover,
    it takes more time for a shader to work on a larger texture.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 大纹理占用大量内存。然而，将艺术放大以适应更大分辨率的屏幕会影响视觉质量。因此，必须取得平衡。此外，各种安卓设备对纹理大小有各种限制。此外，着色器在较大纹理上的工作需要更多时间。
- en: One common mistake that developers make is using alpha information for a completely
    opaque texture. This data increases the texture size significantly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员常犯的一个错误是对完全不透明的纹理使用alpha信息。这会显著增加纹理大小。
- en: Art assets can be optimized on the art style. Many developers use flat-colored
    texture over gradient. Flat color information can be accommodated within 8-bit
    pixel data. This again saves disk space and processing time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术资源可以根据艺术风格进行优化。许多开发人员使用单色纹理而不是渐变色。单色信息可以容纳在8位像素数据中。这再次节省了磁盘空间和处理时间。
- en: In spite of these optimization scopes, the developer might not use all of them
    to increase flexibility in order to create quality visual art without spending
    much time on optimization.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些优化范围，开发人员可能不会全部使用，以增加灵活性，从而在不花费太多时间进行优化的情况下创建高质量的视觉艺术。
- en: Sound optimization
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声音优化
- en: Sound is another vital resource for games. Audio may be compressed to save space
    and effort. A common practice in the Android game industry is to use a compressed
    format for long audio files.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 声音是游戏中另一个重要的资源。音频可以被压缩以节省空间和精力。在安卓游戏行业中，一种常见做法是对长音频文件使用压缩格式。
- en: It takes time to compress and decompress files during runtime. So, using SFX
    dynamically can be a problem if it is compressed. It can trigger a significant
    and visible stutter. Developers like to use an uncompressed format for SFX and
    a compressed format for long and continuous playing sounds such as background
    music.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时压缩和解压文件需要时间。因此，如果SFX被压缩，动态使用可能会成为问题。它可能会触发显著且可见的卡顿。开发人员喜欢对SFX使用未压缩格式，并对长时间连续播放的声音（如背景音乐）使用压缩格式。
- en: Data file optimization
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据文件优化
- en: Sometimes, game developers use separate data files to create a flexible project
    structure to interact with external tools or for better data interface. Such files
    are commonly in text, XML, JSON, or binary formats. Developers may create their
    own data format in a binary model.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，游戏开发人员使用单独的数据文件来创建灵活的项目结构，以便与外部工具交互或获得更好的数据接口。这些文件通常以文本、XML、JSON或二进制格式存在。开发人员可能会创建自己的二进制模型数据格式。
- en: Binary data can be processed quickly if the correct algorithm is used. There
    is not much technicality in data optimization. However, developers always need
    to keep a check on the amount of data and the total file size.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用正确的算法，二进制数据可以快速处理。数据优化并没有太多技术性。然而，开发人员始终需要检查数据量和总文件大小。
- en: Design optimization
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计优化
- en: Design optimization is used to increase the scalability, quality experience,
    flexibility, and durability of the game. The main method is to restructure or
    modify the game parameters around the core game concept.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 设计优化用于增加游戏的可扩展性、质量体验、灵活性和耐久性。主要方法是围绕核心游戏概念重组或修改游戏参数。
- en: 'Let''s divide this section into two parts from the point of view of functionality:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从功能的角度将这一部分分为两部分：
- en: Game design optimization
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏设计优化
- en: Technical design optimization
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术设计优化
- en: Game design optimization
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏设计优化
- en: A game can be completely different from the initial idea during the game design
    optimization phase. Design optimization is done based on certain tasks. The developer
    needs to find different ways to communicate the basic game idea. Then, they can
    choose the best one, following some analysis.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏在游戏设计优化阶段可能与最初的想法完全不同。设计优化是基于某些任务进行的。开发人员需要找到不同的方式来传达基本的游戏理念。然后，他们可以选择最佳的方式，进行一些分析。
- en: Game design should be flexible enough to accommodate runtime changes to improve
    the overall experience and increase user count. A highly optimized game design
    can be efficient enough to predict user behavior, game performance on various
    devices, and even monetization.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计应该足够灵活，以适应运行时变化，以改善整体体验并增加用户数量。高度优化的游戏设计足够高效，可以预测用户行为、各种设备上的游戏性能，甚至货币化。
- en: The game control system design has to be optimized enough to carry out all the
    tasks easily. Game controls should be easy to spot and understand. For Android
    touch devices, the placement of controls is also very important.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏控制系统设计必须足够优化，以便轻松完成所有任务。游戏控制应该易于发现和理解。对于Android触摸设备，控件的放置也非常重要。
- en: Technical design optimization
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 技术设计优化
- en: Technical design optimization is limited to the development cycle. It sets the
    project structure, program structure, development platform dependency, and so
    on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 技术设计优化仅限于开发周期。它设置了项目结构、程序结构、开发平台依赖等。
- en: The technical design document also specifies the scope and scale of the game.
    Such specifications help run the game smoothly on a device, because the hardware
    platform is already covered within the technical design document.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 技术设计文档还规定了游戏的范围和规模。这些规范有助于在设备上顺利运行游戏，因为硬件平台已经在技术设计文档中涵盖。
- en: This is a pre-development process. A few assumptions need to be taken care of
    in this document. These assumptions should be optimized enough to evolve when
    a real-time situation occurs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个预开发过程。这份文件需要处理一些假设。这些假设应该足够优化，以便在实时情况发生时进行演变。
- en: 'Technical design can also take care of the following tasks during development.
    By optimizing these tasks, it is much easier to implement and execute:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 技术设计还可以在开发过程中处理以下任务。通过优化这些任务，实施和执行将更加容易：
- en: Program architecture
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序架构
- en: System architecture
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统架构
- en: System characteristics
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统特性
- en: Defined dependencies
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义的依赖关系
- en: Impacts
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响
- en: Risk analysis
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 风险分析
- en: Assumptions
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设
- en: All these tasks can be optimized for a better development cycle with less effort,
    and the game will be more polished and will have a higher performance rate.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些任务都可以优化，以便更轻松地进行更好的开发周期，游戏将更加精致，并且性能更高。
- en: Memory optimization
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存优化
- en: Memory optimization is mandatory for any software development procedure. Memory
    has its physical limitation based on the hardware configuration, but games and
    applications cannot be made separately for each device.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 内存优化对于任何软件开发过程都是必需的。内存根据硬件配置有其物理限制，但游戏和应用程序不能为每个设备单独制作。
- en: In a technical design, the range of memory use for the game across all targeted
    hardware platforms should be mentioned. Now, it is a very common scenario that
    games take more memory than predicted, which eventually results in the game crashing.
    The developer is awarded with a memory overflow exception.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术设计中，应该提到游戏在所有目标硬件平台上的内存使用范围。现在，游戏占用的内存超出预期是非常常见的情况，最终导致游戏崩溃。开发人员会收到内存溢出异常。
- en: 'To avoid this scenario, there are two main things to be taken care of:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，有两个主要的事情需要注意：
- en: Keep memory peak within the defined range
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持内存峰值在定义范围内
- en: Don't keep data loaded in memory unnecessarily
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要在内存中保留不必要的数据加载
- en: Android uses paging and mapping to manage memory usage. Unfortunately, it does
    not offer memory swapping. Android knows where to find the paged data and loads
    accordingly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Android使用分页和映射来管理内存使用。不幸的是，它不提供内存交换。Android知道在哪里找到分页数据并相应地加载。
- en: Here are some tricks to optimize memory in Android gaming.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些优化Android游戏内存的技巧。
- en: Don't create unnecessary objects during runtime
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要在运行时创建不必要的对象
- en: 'Often, the developer creates an intermediate data object inside a loop. It
    leaves memory footprints for the garbage collector to collect. Here is an example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员经常在循环内创建中间数据对象。这会留下内存印记，供垃圾收集器收集。以下是一个例子：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Use primitive data types as far as possible
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尽可能使用基本数据类型
- en: User-defined data types take more memory space than primitive data types. Declaring
    an integer takes less space than embedding an integer in a class. In Android,
    if the developer uses the `Integer` class instead of `int`, the data size increases
    four times.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的数据类型比原始数据类型占用更多的内存空间。声明一个整数所占用的空间比将整数嵌入类中要少。在Android中，如果开发人员使用`Integer`类而不是`int`，数据大小会增加四倍。
- en: For Android compilers (32 bit), `int` consumes 4 bytes (32 bit), and `Integer`
    consumes 16 bytes (128 bit).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android编译器（32位），`int`消耗4字节（32位），而`Integer`消耗16字节（128位）。
- en: With full respect to modern age Android devices, limited use of this data type
    may cause no significant harm to memory. However, extensive use of non-primitive
    data types may cause a significant amount of memory block until the developer
    or garbage collector frees the memory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现代Android设备，有限使用这种数据类型可能对内存没有显著的影响。然而，大量使用非原始数据类型可能会导致大量的内存块，直到开发人员或垃圾收集器释放内存。
- en: So, the developer should avoid `enum` and use static final `int` or `byte` instead.
    `enum`, being a user-defined data type, takes more memory than a primitive data
    type.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开发人员应避免使用`enum`，而是使用静态最终的`int`或`byte`。`enum`作为用户定义的数据类型，比原始数据类型占用更多的内存。
- en: Don't use unmanaged static objects
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要使用未管理的静态对象
- en: In older Android versions, it is a common issue that a static object does not
    get destroyed automatically. Developers used to manage static objects manually.
    This issue is no longer there in newer versions of Android. However, creating
    many static objects in games is not a good idea as the life span of static objects
    is equal to the game life. They directly block memory for a longer period.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版Android中，静态对象不会自动销毁是一个常见问题。开发人员过去需要手动管理静态对象。在新版Android中，这个问题已经不存在。然而，在游戏中创建许多静态对象并不是一个好主意，因为静态对象的寿命等于游戏的寿命。它们会长时间地直接阻塞内存。
- en: Using too many static objects may lead to memory exceptions, eventually crashing
    the game.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用太多静态对象可能导致内存异常，最终导致游戏崩溃。
- en: Don't create unnecessary classes or interfaces
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要创建不必要的类或接口
- en: Each class or interface has some extra binding space in its instance. The modular
    programming approach demands maximum possible breakage in the coding structure.
    This is directly proportional to the number of classes or interfaces. This is
    considered to be a good programming practice.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类或接口在其实例中都有一些额外的绑定空间。模块化编程方法要求在编码结构中尽可能多地进行分解。这与类或接口的数量成正比。这被认为是一种良好的编程实践。
- en: However, this has a consequence on memory usage. More classes consume more memory
    space for the same amount of data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这对内存使用有影响。更多的类消耗更多的内存空间来存储相同数量的数据。
- en: Use the minimum possible abstraction
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用最小可能的抽象
- en: Many developers use abstraction in multiple layers for a better programming
    structure. It is very useful to restrict a certain part of a custom library and
    provide only selective APIs. When it comes to game development, if the developer
    works on games only, then use of abstraction is not very necessary.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员在多个层次上使用抽象以获得更好的编程结构。限制自定义库的某一部分并仅提供选择性的API非常有用。在游戏开发方面，如果开发人员只开发游戏，那么抽象的使用并不是非常必要的。
- en: Abstraction results in more instructions, which directly leads to more processing
    time and more memory use. So, even if abstraction may be convenient sometimes,
    the developer should always think twice before using abstraction while developing
    games.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象导致更多的指令，直接导致更多的处理时间和更多的内存使用。因此，即使抽象有时可能很方便，开发人员在开发游戏时使用抽象之前应该三思而后行。
- en: For example, a game may have a set of various enemies. In such a case, creating
    a single enemy interface and implementing it for different enemy objects helps
    create a simple and convenient program hierarchy. However, there may be completely
    different attributes for different enemies. So, the use of abstraction will depend
    on the game design. Whatever the case is, if developers use abstraction, then
    it will always increase the set of instructions to be processed at runtime.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个游戏可能有一组不同的敌人。在这种情况下，创建一个单一的敌人接口，并为不同的敌人对象实现它，有助于创建一个简单和方便的程序层次结构。然而，不同的敌人可能有完全不同的属性。因此，抽象的使用将取决于游戏设计。无论情况如何，如果开发人员使用抽象，那么它将始终增加要在运行时处理的指令集。
- en: Keep a check on services
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对服务进行检查
- en: Services are useful for the completion of one task in the background, but they
    are very costly in terms of both process and memory. A developer should never
    keep a service running unless required. The best way to automatically manage the
    service life cycle is to use `IntentService`, which will finish once its work
    is done. For other services, it is the developer's responsibility to make sure
    that `stopService` or `stopSelf` are being called after the task is done.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 服务对于在后台完成一个任务非常有用，但在处理和内存方面非常昂贵。除非必要，开发人员不应该保持服务运行。自动管理服务生命周期的最佳方法是使用`IntentService`，它在工作完成后将结束。对于其他服务，开发人员有责任确保在任务完成后调用`stopService`或`stopSelf`。
- en: This process proves to be very efficient for game development, as it actively
    supports dynamic communication between the user and developer.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程对游戏开发非常有效，因为它积极支持用户和开发人员之间的动态交流。
- en: Optimize bitmaps
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化位图
- en: Bitmaps are the heaviest assets for a game. In game development, most of the
    heap memory is used by bitmaps. So, optimizing bitmaps can significantly optimize
    the use of heap memory during runtime.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 位图是游戏中最重的资源。在游戏开发中，大部分堆内存都被位图使用。因此，优化位图可以显著优化运行时堆内存的使用。
- en: 'Usually, the memory required for a bitmap to be loaded in memory is given by
    this formula:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将位图加载到内存所需的内存由以下公式给出：
- en: '*BitmapSize = BitmapWidth * BitmapHeight * bytePerPixel*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*BitmapSize = BitmapWidth * BitmapHeight * bytePerPixel*'
- en: 'For example, if a 480 x 800 size bitmap is being loaded in the `ARGB_8888`
    format (4 bytes), the memory will be as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果以`ARGB_8888`格式（4字节）加载一个480 x 800大小的位图，内存将如下：
- en: '*BitmapSize = 480 x 800 x 4 = 1536000 bytes ~ 1.5mb*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*位图大小 = 480 x 800 x 4 = 1536000字节〜1.5mb*'
- en: 'The format can be of the following types in Android:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，格式可以是以下类型之一：
- en: '`ARGB_8888` (4 bytes)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARGB_8888`（4字节）'
- en: '`RGB_565` (2 bytes)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RGB_565`（2字节）'
- en: '`ARGB_4444` (2 bytes) (deprecated in API level 13)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARGB_4444`（2字节）（在API级别13中已弃用）'
- en: '`ALPHA_8` (1 byte)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALPHA_8`（1字节）'
- en: Each bitmap will occupy memory according to the preceding formula. So, it is
    recommended that you load a bitmap in memory as per requirement to avoid unnecessary
    heap usage.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 每个位图将根据前述公式占用内存。因此，建议根据需要将位图加载到内存中，以避免不必要的堆使用。
- en: Release unnecessary memory blocks
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 释放不必要的内存块
- en: As we have discussed earlier for freeing memory, the same can be applied on
    any object. After the task is finished, the instance should be set to null so
    that the garbage collector can identify and free the allocated memory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前讨论释放内存一样，同样的方法也可以应用于任何对象。任务完成后，实例应设置为null，以便垃圾收集器可以识别并释放分配的内存。
- en: In a game state machine, the class structure should provide an interface to
    free the memory of instantiated objects. There may be a scenario where a few of
    the member objects are done with their tasks and a few are still in use, so it
    would be a bad idea to wait for the entire class instance to be freed. The developer
    should selectively free the memory of unused objects without deleting the class
    instance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏状态机中，类结构应提供一个接口来释放实例化对象的内存。可能会出现这样的情况，其中一些成员对象已完成其任务，而另一些仍在使用中，因此等待整个类实例被释放是一个坏主意。开发人员应选择性地释放未使用对象的内存，而不删除类实例。
- en: Use external tools such as zipalign and ProGuard
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用zipalign和ProGuard等外部工具
- en: The ProGuard tool is efficient at shrinking, optimizing, and obfuscating the
    code by removing unused code and renaming classes, fields, and methods with a
    secured and encoded naming structure. ProGuard can make the code more compact,
    which directly impacts RAM usage.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ProGuard工具通过删除未使用的代码和使用安全和编码的命名结构重命名类、字段和方法，有效地缩小、优化和混淆代码。ProGuard可以使代码更加紧凑，这直接影响RAM的使用。
- en: In game development, developers often use many multiple third-party libraries,
    which may be pre-compiled with ProGuard. In those cases, the developer must configure
    ProGuard to exclude those libraries. It is also a good idea to protect the codebase
    from getting stolen.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，开发人员经常使用许多第三方库，这些库可能已经使用ProGuard预编译。在这些情况下，开发人员必须配置ProGuard以排除这些库。还可以保护代码库免受盗窃。
- en: zipalign can be used to realign the released APK. This optimizes the APK further
    to use less space and have a more compact size. Normally, most of the APK building
    frameworks provide zipalign automatically. However, the developer might need to
    use it manually for few cases.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: zipalign可用于重新对齐发布的APK。这进一步优化APK，以使用更少的空间并具有更紧凑的大小。通常，大多数APK构建框架会自动提供zipalign。但是，开发人员可能需要在少数情况下手动使用它。
- en: Performance optimization
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能优化
- en: Performance means how smoothly the game will run on the target platform and
    maintain a decent FPS throughout the gameplay session. In the case of Android
    gaming, we already know about the wide range of hardware configurations. Maintaining
    the same performance across all devices is practically impossible. This is the
    reason developers choose target hardware and minimum hardware configuration to
    ensure that the game is performing well enough to be published. However, the expectation
    also varies from device to device.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 性能意味着游戏在目标平台上运行的流畅程度，并在整个游戏过程中保持良好的FPS。在Android游戏的情况下，我们已经了解到各种硬件配置的广泛范围。在所有设备上保持相同的性能实际上是不可能的。这就是开发人员选择目标硬件和最低硬件配置的原因，以确保游戏的性能足够好以发布。但是，期望也因设备而异。
- en: In real development constraints, performance optimization is limited to the
    targeting set of hardware. Thus, memory has its own optimizing space in the development
    process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际开发约束中，性能优化受限于目标硬件集。因此，内存在开发过程中有自己的优化空间。
- en: 'Technically, from the programming point of view, performance optimization can
    be done by paying more attention to writing and structuring code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程角度来看，性能优化可以通过更加关注编写和构造代码来实现：
- en: Using minimum objects possible per task
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量每个任务使用最少的对象
- en: Using minimum floating points
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量减少浮点数的使用
- en: Using fewer abstraction layers
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量减少抽象层
- en: Using enhanced loops wherever possible
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用增强循环
- en: Avoiding getters/setters of variables for internal use
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免为内部使用的变量使用getter/setter
- en: Using static final for constants
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对常量使用static final
- en: Using minimum possible inner classes
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量减少内部类的使用
- en: Using minimum objects possible per task
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尽量每个任务使用最少的对象
- en: 'Creating unnecessary objects increases processing overhead as they have to
    be initialized in a new memory segment. Using the same object for the same task
    multiple times is much faster. Here is an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建不必要的对象会增加处理开销，因为它们必须在新的内存段中初始化。多次使用相同对象执行相同任务要快得多。以下是一个例子：
- en: '[PRE1]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using minimum floating points
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尽量减少浮点数的使用
- en: In machine-level language, there is nothing like an integer or float. It is
    always a bit indicating true or false (0 and 1 in technical language). So, an
    integer can be directly represented by a set of bits, but floating points requires
    extra processing overhead.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器级语言中，不存在整数或浮点数。它总是表示真或假的位（在技术语言中为0和1）。因此，整数可以直接由一组位表示，但浮点数需要额外的处理开销。
- en: Until a point of time, there was no use of floating points in programming languages.
    Later, the conversion came, and floating point was introduced with extra processing
    requirements.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 直到某个时间点，编程语言中没有使用浮点数。后来，转换出现了，并且引入了额外的处理要求。
- en: Using fewer abstraction layers
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尽量减少抽象层
- en: It is very obvious that abstraction demands extra processing per layer. So,
    as we increase the abstraction layers, the process becomes slower.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，抽象需要每个层面额外的处理。因此，随着抽象层的增加，处理变得更慢。
- en: Using enhanced loops wherever possible
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尽可能使用增强循环
- en: In the case of array and list parsing, an enhanced `for` loop works way faster
    than the usual conventional `for` loop as it has no iterating variable system,
    and each array or list element can be accessed directly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组和列表解析的情况下，增强的`for`循环比通常的传统`for`循环要快得多，因为它没有迭代变量系统，可以直接访问每个数组或列表元素。
- en: 'Here is an example of a non-enhanced loop:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非增强循环的例子：
- en: '[PRE2]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is an example of an enhanced loop:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个增强循环的例子：
- en: '[PRE3]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Avoid getter/setters of variables for internal use
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免内部使用变量的getter/setter
- en: Getters and setters are used to access or change the state of any internal element
    of an object from outside the object. In high-level reasoning, it does not follow
    the basic concept of data encapsulation. However, getters and setters are used
    widely in Android game development.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用getter和setter来访问或更改对象的任何内部元素的状态。在高级推理中，它不遵循数据封装的基本概念。然而，在Android游戏开发中广泛使用getter和setter。
- en: In many cases, developers use getters and setters from inside the class object.
    This unnecessarily increases processing time, resulting in degraded performance.
    So, developers should use getters and setters as little as possible and make sure
    they are not being used internally.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，开发人员从类对象内部使用getter和setter。这不必要地增加了处理时间，导致性能下降。因此，开发人员应尽量少使用getter和setter，并确保它们不被内部使用。
- en: Use static final for constants
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用静态final来定义常量
- en: Constants are not meant to be changed during runtime. In the case of global
    constants, the data is directly associated with the class object. Hence, we're
    required to parse the class object in order to access it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 常量在运行时不应更改。对于全局常量，数据直接与类对象相关联。因此，我们需要解析类对象才能访问它。
- en: Using static is an excellent idea to get rid of this extra process. Element
    accessibility increases significantly when using static for constants. However,
    the developer needs to keep a check on memory usage as well.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态是一个很好的主意，可以摆脱这个额外的进程。使用静态常量可以显著增加元素的可访问性。然而，开发人员也需要检查内存使用情况。
- en: Using minimum possible inner classes
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尽量少使用内部类
- en: Each inner class adds an extra layer to processing. Sometimes, it is good to
    have inner classes in order to structure the codebase in an efficient and readable
    way. However, it comes with the cost of processing overhead. So, the developer
    should use the fewest possible inner classes in order to optimize performance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 每个内部类都会增加一层处理。有时，为了以高效和可读的方式构建代码库，使用内部类是很好的。然而，这会增加处理开销。因此，开发人员应尽量少使用内部类以优化性能。
- en: Relationship between performance and memory management
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能和内存管理之间的关系
- en: In Android game development, performance and memory optimization often conflict
    with each other. To maintain the visual quality of the game, better art assets
    are mandatory, which eventually increases memory overhead and performance lag.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android游戏开发中，性能和内存优化经常相互冲突。为了保持游戏的视觉质量，必须使用更好的艺术资源，这最终会增加内存开销和性能滞后。
- en: Optimizing memory needs to do frequent memory operations, resulting in performance
    drop. To increase performance, objects have to be readily available for smooth
    processing. Clearly, both cannot be applied at their extreme levels.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 优化内存需频繁进行内存操作，导致性能下降。为了提高性能，对象必须能够顺利处理。显然，两者都不能达到极端水平。
- en: Balancing between them is the only way out to optimize the full game to run
    smoothly without exhausting memory.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在它们之间取得平衡是优化整个游戏以顺利运行而不耗尽内存的唯一方法。
- en: Memory management in Android
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android中的内存管理
- en: 'Let''s discuss the memory management system in Android. It has a direct effect
    on the game development process. Games are treated like applications in Android.
    Very often, developers face memory issues in both the runtime and minimized states
    of the game. There are three main topics to discuss to understand the working
    principles:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下Android中的内存管理系统。它直接影响游戏开发过程。在Android中，游戏被视为应用程序。开发人员经常在游戏的运行时和最小化状态下遇到内存问题。有三个主要主题需要讨论以了解工作原理：
- en: Shared application memory
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序共享内存
- en: Memory allocation and deallocation
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存分配和释放
- en: Application memory distribution
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序内存分配
- en: Shared application memory
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序共享内存
- en: Android uses the Linux kernel, and Linux uses "shared" pages to share the same
    memory segment within running processes or services. For example, Android often
    shares the "code" memory within processes. Very often, external libraries and
    JVM's executable code memory can be safely shared across processes without creating
    a deadlock. Data pages could be shared temporarily between processes, until a
    process modifies the shared memory.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Android使用Linux内核，Linux使用“共享”页面在运行进程或服务之间共享相同的内存段。例如，Android经常在进程之间共享“代码”内存。很多时候，外部库和JVM的可执行代码内存可以安全地在进程之间共享，而不会创建死锁。数据页面可以在进程之间暂时共享，直到一个进程修改了共享内存。
- en: 'Android allocates dedicated memory for each application or process. This is
    called private memory. The same process may also use shared memory. Android automatically
    sets a cap, depending on the total of both, to determine when the process or application
    will be killed, especially if it is in the background. This cap is called **Proportionate
    Set Size** (**PSS**):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Android为每个应用程序或进程分配专用内存。这称为私有内存。同一进程也可能使用共享内存。Android会自动设置一个上限，取决于两者的总和，以确定进程或应用程序何时会被终止，特别是在后台运行时。这个上限称为**比例设置大小**（**PSS**）：
- en: '![Shared application memory](img/B05069_08_01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序共享内存](img/B05069_08_01.jpg)'
- en: If an application's PSS is high, then there is a very high chance that the process
    might be killed by Android. This scenario can be handled programmatically to keep
    memory usage in check, especially if the application is relying on some background
    activities or services to carry out some task. The developer has to make sure
    that the game uses minimum possible memory at any point in time, especially when
    the application goes into the background. It may be a good idea to free memory
    and objects that you no longer need in the background, and disconnect from any
    shared memory that you no longer need when you go into the background. This will
    reduce the chances of your application getting unexpectedly killed by the Android
    system.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用的PSS很高，那么这个进程可能被Android杀死的可能性很高。特别是如果应用程序依赖一些后台活动或服务来执行某些任务，这种情况可以通过编程方式处理以保持内存使用情况，开发人员必须确保游戏在任何时候使用的内存尽可能少，特别是当应用程序进入后台时。在后台释放不再需要的内存和对象，并在进入后台时断开不再需要的任何共享内存可能是一个不错的主意。这将减少您的应用程序被Android系统意外杀死的机会。
- en: Memory allocation and deallocation
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存分配和释放
- en: The Android memory management system defines a virtual cap for each application,
    which is the logical heap size. It can be increased if necessary, but only if
    there is free memory available. However, this logical heap size is not the actual
    allocated memory for the application. Calculated PSS is the actual physical cap
    that may vary during runtime and shared memory dependency.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Android内存管理系统为每个应用程序定义了一个虚拟上限，即逻辑堆大小。如果有必要，可以增加这个逻辑堆大小，但前提是有空闲内存可用。然而，这个逻辑堆大小并不是应用程序的实际分配内存。计算得到的PSS是在运行时可能变化的实际物理上限，并且存在共享内存依赖。
- en: 'Application memory cannot use more physical memory than PSS. So, after reaching
    this limit, if the application tries to allocate more memory, then it will receive
    `OutOfMemoryError` thrown by the system. Android might kill other empty or background
    processes to accommodate memory for the running application in a critical situation.
    Application memory will be deallocated in these scenarios:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序内存不能使用比PSS更多的物理内存。因此，在达到此限制后，如果应用程序尝试分配更多内存，那么它将收到系统抛出的`OutOfMemoryError`。在紧急情况下，Android可能会杀死其他空闲或后台进程以为运行中的应用程序腾出内存。在这些情况下，应用程序内存将被释放：
- en: If the application quits
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序退出
- en: If the process becomes inactive and some other process requires the memory
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进程变得不活动，而其他进程需要内存
- en: If the application crashes for any reason
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序因任何原因崩溃
- en: Application memory distribution
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序内存分配
- en: Android sets a hard limit on the heap size for each app to maintain a multitasking
    environment. The exact heap size limit varies between hardware configurations
    based on the capacity of RAM of the device. If the application reaches the heap
    capacity and tries to allocate more memory, it will receive `OutOfMemoryError`,
    and the application will be killed by Android.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Android为每个应用程序设置了堆大小的硬限制，以维持多任务环境。根据设备的RAM容量，确切的堆大小限制因硬件配置而异。如果应用程序达到堆容量并尝试分配更多内存，它将收到`OutOfMemoryError`，并且应用程序将被Android杀死。
- en: The developer needs to check the amount of memory available on the device and
    then determine an average target memory use. The developer can query the operating
    system for this amount of memory by calling `getMemoryClass()`. This returns an
    integer indicating the number of MBs available for the application's heap.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员需要检查设备上可用内存的数量，然后确定平均目标内存使用量。开发人员可以通过调用`getMemoryClass()`来查询操作系统的内存量。这将返回一个整数，表示应用程序堆可用的MB数。
- en: Processing segments in Android
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android中的处理段
- en: A game is basically an application in terms of functionality. Multiple applications
    or games can run on an Android platform. However, for games, only one game is
    active at one point of time, but rest of the applications run in the background.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏基本上是功能上的一个应用程序。多个应用程序或游戏可以在Android平台上运行。但是，对于游戏来说，一次只有一个游戏是活动的，而其他应用程序在后台运行。
- en: Let's have a look at how Android processes its applications.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Android如何处理其应用程序。
- en: Application priority
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序优先级
- en: Android sets the priority of the running applications, and it can kill a running
    application of low priority depending on the requirement.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Android设置了运行应用程序的优先级，并且根据需求可以杀死低优先级的运行应用程序。
- en: Each application uses some memory and processing bandwidth. There may be a situation
    where multiple applications are running together. If a new application wants to
    run, then Android allocates memory and process bandwidth for the new application.
    If there is not enough bandwidth or process available, then Android kills one
    or more than one running application with low priority.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都使用一些内存和处理带宽。可能出现多个应用程序同时运行的情况。如果一个新应用程序想要运行，那么Android会为新应用程序分配内存和处理带宽。如果没有足够的带宽或可用的处理，那么Android会杀死一个或多个优先级较低的运行中的应用程序。
- en: 'Android sets priority by the following status:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Android通过以下状态设置优先级：
- en: Active process
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动进程
- en: Visible process
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可见进程
- en: Active services
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动服务
- en: Background process
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后台进程
- en: Void process![Application priority](img/B05069_08_02.jpg)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空进程![应用程序优先级](img/B05069_08_02.jpg)
- en: Active process
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动进程
- en: An active process is basically a process that communicates with the platform
    very frequently and runs in the foreground. This process is the last one to be
    killed by Android, when necessary.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 活动进程基本上是指与平台频繁通信并在前台运行的进程。当必要时，这个进程是Android中最后一个被杀死的。
- en: 'An active process fulfils the following criteria:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 活动进程满足以下标准：
- en: It runs in the foreground
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在前台运行
- en: It is visible
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是可见的
- en: At least one Android activity is running
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少有一个Android活动正在运行
- en: It interacts actively with the user interface
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与用户界面积极交互
- en: All event handlers are in the active state
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有事件处理程序处于活动状态
- en: Visible process
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可见进程
- en: This process is basically an active process that is not in the foreground and
    does not interact with the user interface. It is the second highest priority for
    the Android platform.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程基本上是一个活动的进程，不在前台，也不与用户界面交互。这是Android平台的第二高优先级。
- en: 'The criteria for this process are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的标准如下：
- en: It runs in the background
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在后台运行
- en: It has visible activity
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有可见的活动
- en: It does not interact with the user interface
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不与用户界面交互
- en: UI event handlers are not active
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI事件处理程序不活动
- en: Process event handlers are active
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程事件处理程序是活动的
- en: Active services
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动服务
- en: Active services are services that support an ongoing process without a visible
    interface. Android will kill such services first and then the actual active process.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 活动服务是支持进行中的进程而没有可见界面的服务。Android将首先终止这些服务，然后才是实际的活动进程。
- en: 'This service follows the following criteria:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务遵循以下标准：
- en: It has no visible interface
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有可见的界面
- en: It supports or works for respective active processes
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持或为相应的活动进程工作
- en: It runs in the background
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在后台运行
- en: Background process
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 后台进程
- en: Background processes are basically minimized or inactive processes. These processes
    are not visible on the screen. The process thread does not run for these processes,
    but the application state is saved in the memory. These are vulnerable to being
    killed by the processor. These processes can be resumed after interruption.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 后台进程基本上是最小化或不活动的进程。这些进程在屏幕上不可见。这些进程的线程不运行，但应用程序状态保存在内存中。这些进程容易被处理器终止。这些进程在中断后可以恢复。
- en: These are inactive/minimized processes. They remain in memory. The application
    stays in the paused state.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是不活动/最小化的进程。它们保留在内存中。应用程序保持暂停状态。
- en: Void process
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空进程
- en: Void processes are also called empty processes. A void process is literally
    empty. It holds no application data or state in memory. This process has the highest
    priority in order to get killed by the operating system.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 空进程也称为空进程。空进程实际上是空的。它在内存中不保存任何应用程序数据或状态。这个进程有最高的优先级，以便被操作系统终止。
- en: Application services
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序服务
- en: Android application services are parts of the actual application process. These
    services may run within and outside the parent process.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用服务是实际应用程序过程的一部分。这些服务可以在父进程内部和外部运行。
- en: 'Let''s clear two very common misconceptions about services:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们澄清关于服务的两个常见误解：
- en: A service is not a separate process
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务不是一个独立的进程
- en: A service is not a thread
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务不是线程
- en: The fact is, services are part of an application process and not separate processes.
    Services are not threads. They are part of the process that runs in the background,
    and they keep running even if the main application is in a suspended state.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，服务是应用程序过程的一部分，而不是独立的进程。服务不是线程。它们是在后台运行的进程的一部分，即使主应用程序处于暂停状态，它们也会继续运行。
- en: Services are meant to carry out a single task and do not call back the parent
    application. This is why they can run even after the application is closed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 服务旨在执行单个任务，不会回调父应用程序。这就是为什么它们可以在应用程序关闭后继续运行。
- en: Service life cycle
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务生命周期
- en: 'Services are started by the parent application process, as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 服务由父应用程序进程启动，如下所示：
- en: '[PRE4]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After being started, the service starts carrying out a single task in the background.
    The service can stop itself after the task is done. For example, a simple file
    download service will stop after a successful downloading task. Many game developers
    use such features in their games to improve the user experience.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，服务开始在后台执行单个任务。任务完成后，服务可以停止自己。例如，简单的文件下载服务在成功下载任务后会停止。许多游戏开发者在他们的游戏中使用这些功能来提高用户体验。
- en: These services can be bound with one or more processes for interactivity. The
    application can send request and get response from a bound service, which creates
    a server-client architecture. But these bound services have a limited lifetime
    until the last application component is bound with the service.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务可以与一个或多个进程绑定以实现交互。应用程序可以向绑定的服务发送请求并获得响应，从而创建服务器-客户端架构。但这些绑定的服务在最后一个应用程序组件绑定到服务之前有限的生命周期。
- en: Resource processing
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源处理
- en: 'Android has its own resource process structure. It has some predefined resource
    types:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Android有自己的资源处理结构。它有一些预定义的资源类型：
- en: Drawable resources
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可绘制资源
- en: Layout resources
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局资源
- en: Color resources
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色资源
- en: Menu resources
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 菜单资源
- en: Tween animation resources
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tween动画资源
- en: Other resources
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他资源
- en: Drawable resources
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可绘制资源
- en: All drawable resources fall in this category, including frame animation. Android
    provides the `res/drawable/` project path dedicated to all drawable resources.
    All bitmaps, various XML, and predetermined frame animations can be placed here.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可绘制资源都属于这个类别，包括帧动画。Android提供了专门用于所有可绘制资源的`res/drawable/`项目路径。所有位图、各种XML和预定帧动画都可以放在这里。
- en: These can be accessed through the `R.drawable` class.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以通过`R.drawable`类访问。
- en: Layout resources
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布局资源
- en: All defined layouts fall in this category. Android provides the `res/layout/`
    project path dedicated to all layout files. Layout is useful to define the application
    UI.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 所有定义的布局都属于这个类别。Android提供了专门用于所有布局文件的`res/layout/`项目路径。布局对于定义应用程序UI非常有用。
- en: These can be accessed through the `R.layout` class.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以通过`R.layout`类访问。
- en: Color resources
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 颜色资源
- en: Color resources are basically a list of colors that are due to change upon changing
    the view of the applicable object. Android stores this in the `res/color/` folder
    in the hierarchy.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色资源基本上是一个颜色列表，随着适用对象视图的改变而改变。Android将其存储在层次结构中的`res/color/`文件夹中。
- en: These can be accessed through the `R.color` class.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以通过`R.color`类访问。
- en: Menu resources
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 菜单资源
- en: All menu contents can be defined here. Android provides the `res/menu/` project
    path dedicated to all **drawable** resources.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 所有菜单内容都可以在这里定义。Android提供了专门用于所有**drawable**资源的`res/menu/`项目路径。
- en: These can be accessed through the `R.menu` class.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以通过`R.menu`类访问。
- en: Tween animation resources
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tween动画资源
- en: All tween animation resources fall in this category. Android provides the `res/anim/`
    project path dedicated to all tween animation resources.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Tween动画资源都属于这个类别。Android提供了专门用于所有Tween动画资源的`res/anim/`项目路径。
- en: These can be accessed through the `R.anim` class.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以通过`R.anim`类访问。
- en: Other resources
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他资源
- en: All other resources are places in the `res/values/` folder. Many developers
    define the string under this category with styles.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他资源都放在`res/values/`文件夹中。许多开发人员在这个类别下定义了样式的字符串。
- en: These can be accessed through the `R.values` class.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以通过`R.values`类访问。
- en: Different memory segments
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的内存段
- en: 'During the runtime of an application, three main kinds of memory segments are
    used depending on the behavior:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序运行时，根据行为使用了三种主要的内存段：
- en: Stack memory
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆栈内存
- en: Heap memory
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆内存
- en: Register memory
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器内存
- en: Stack memory
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈内存
- en: All auto variables and runtime allocation during processing will be stored in
    the stack memory segment. The garbage collector deallocates the memory after use.
    So, there is no manual memory management process associated with the stack memory.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 所有自动变量和处理过程中的运行时分配将存储在堆栈内存段中。垃圾收集器在使用后释放内存。因此，与堆栈内存相关联的没有手动内存管理过程。
- en: However, extensive use of auto variables also may cause memory errors. This
    is the reason we have already discussed why minimizing unnecessary auto variable
    declarations is necessary.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大量使用自动变量也可能导致内存错误。这就是为什么我们已经讨论过为什么最小化不必要的自动变量声明是必要的原因。
- en: Stack memory is also used to execute program instructions. Each instruction
    is broken down into a single operation and put into a stack by the interpreter.
    Then, a recursive procedure is used to execute all the instruction stacks and
    return the result.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈内存也用于执行程序指令。每个指令都被解析为一个单独的操作，并由解释器放入堆栈中。然后，使用递归过程来执行所有指令堆栈并返回结果。
- en: 'Let''s have a look at how stack memory works for objects and primitives:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看堆栈内存如何处理对象和基本类型：
- en: '[PRE5]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, `bitMapCount` is an `int` local variable and gets stored in
    the stack directly. The memory used for this variable will be freed just after
    the scope.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`bitMapCount`是一个`int`局部变量，直接存储在堆栈中。这个变量使用的内存将在作用域结束后立即被释放。
- en: However, `testBmp` is a bitmap object, which will be allocated in the heap,
    but the reference will be stored in the stack. When the program pointer comes
    out of the scope, the reference will be automatically deleted, and the garbage
    collector can identify the heap memory allocated for `testBmp` as having zero
    reference and will free this memory segment.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`testBmp`是一个位图对象，将被分配在堆中，但引用将存储在堆栈中。当程序指针离开作用域时，引用将被自动删除，垃圾收集器可以识别为`testBmp`分配的堆内存具有零引用，并释放这个内存段。
- en: Heap memory
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆内存
- en: Heap memory is the segment where all the instances of classes and arrays are
    stored. JVM allocates this memory while instantiating any object.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 堆内存是存储所有类实例和数组实例的段。JVM在实例化任何对象时分配这个内存。
- en: The garbage collector does not operate automatically on this memory segment
    during application runtime. It is the developer's responsibility to free the memory
    after use. In the case of Android, the garbage collector will only free the memory
    when there is no reference for the memory segment in the running application.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器在应用程序运行时不会自动操作这个内存段。开发人员有责任在使用后释放内存。在Android的情况下，只有在运行应用程序中没有对内存段的引用时，垃圾收集器才会释放内存。
- en: Game assets are the major elements that are stored in this memory segment. Art
    is the most significant asset among them. So, optimizing bitmaps has a direct
    impact on heap memory uses. Very often, the developer allocates memory for assets
    and does not break the reference. This causes the memory block to be occupied
    during the entire runtime.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏资源是存储在这个内存段中的主要元素。艺术是其中最重要的资产。因此，优化位图对堆内存的使用有直接影响。开发人员经常为资产分配内存并且不会打破引用。这导致内存块在整个运行时期被占用。
- en: 'Here is an example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：
- en: '[PRE6]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the memory for the bitmap will be occupied even after the use,
    until the `ExampleClass` instance is there in memory. The interpreter has no standing
    instruction to free the memory segment, because `testBmp` still has the reference
    to the memory allocated to the bitmap.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，位图的内存将在使用后仍然被占用，直到`ExampleClass`实例在内存中。解释器没有立即释放内存段的指令，因为`testBmp`仍然引用了分配给位图的内存。
- en: 'We can optimize this in the following way with a bit of modification:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一些修改以以下方式优化这个问题：
- en: '[PRE7]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, by calling `unloadBitmap()` after the use of the bitmap will remove
    the reference of the loaded bitmap from `testBmp`. So, the garbage collector will
    find this memory location as zero-referenced memory and free it to be used for
    other allocations.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在使用位图后调用`unloadBitmap()`将从`testBmp`中删除加载的位图的引用。因此，垃圾收集器将找到这个内存位置为零引用内存，并释放它以供其他分配使用。
- en: Register memory
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寄存器内存
- en: In the case of Android development, the developer must not worry about register
    memory. Registers are directly associated with the processor, and the processor
    stores the most significant and frequently used data in this memory segment.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android开发中，开发人员不必担心寄存器内存。寄存器直接与处理器相关联，处理器将最重要和经常使用的数据存储在这个内存段中。
- en: Register memory is the fastest memory segment used for any application runtime.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器内存是任何应用程序运行时使用的最快的内存段。
- en: Importance of memory optimization
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存优化的重要性
- en: No matter how the game is, how good it looks, or how well it is designed, if
    the game does not run on the target platform, then it cannot be successful. We
    already know that Android has various sets of hardware configurations.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 无论游戏如何，外观如何，设计得多好，如果游戏在目标平台上无法运行，那么它就不会成功。我们已经知道Android有各种硬件配置。
- en: The main variations of hardware are specific to the processor and memory. In
    the case of processors, it depends on their speed and quality. In case of memory
    or RAM, it is only the volume.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件的主要变化是特定于处理器和内存。在处理器方面，这取决于其速度和质量。在内存或RAM方面，只取决于容量。
- en: Even today, RAM can vary from 512 MB to 4 GB in Android devices. Memory optimization
    should always have a minimum target of RAM as per design. So, memory optimization
    is immensely important in order to run a game on the minimum available RAM.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在今天，Android设备的RAM也可以从512MB到4GB不等。内存优化应该始终以设计为目标的最低RAM为目标。因此，内存优化对于在最小可用RAM上运行游戏非常重要。
- en: Sometimes, the developer fits the peak usage within the target limit of memory.
    However, they perform on a testing device, which does not project a real-time
    scenario most of the time. There is always an error margin. So, it is not always
    true that if the game runs on a certain limit of RAM, it will always be provided
    with the same memory. This is the place when memory optimization plays a major
    role. It helps a lot in creating the buffer range for the game to run in a real-time
    scenario.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开发人员将峰值使用量限制在目标内存限制内。然而，他们在测试设备上执行，这大部分时间并不反映实时情况。总是存在误差范围。因此，并不总是真实情况下游戏在一定的RAM限制下运行时，总是能提供相同的内存。这就是内存优化发挥重要作用的地方。它在创建游戏在实时情况下运行的缓冲范围方面起到了很大作用。
- en: There could be a scenario where the application runs out of memory, even when
    it does not require the amount of RAM it demands. This clearly indicates that
    the application is suffering from memory leakage. Memory leakage is one of the
    most common problems in game development. Optimizing memory properly helps get
    rid of this problem.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在这样的情况，即使应用程序不需要所需的RAM量，也会耗尽内存。这清楚地表明应用程序存在内存泄漏问题。内存泄漏是游戏开发中最常见的问题之一。正确优化内存有助于解决这个问题。
- en: Another aspect of memory optimization is to increase the probability of the
    game to stay in the background. When an application goes into the background,
    Android might kill the application if it needs to free memory space for other
    foreground applications. Memory optimization makes sure that the application occupies
    the minimum possible memory while running. So, it is possible to save the data
    of the state in the cache for a longer period of time for applications that use
    less memory.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 内存优化的另一个方面是增加游戏保持在后台的概率。当应用程序进入后台时，如果Android需要为其他前台应用程序释放内存空间，可能会杀死应用程序。内存优化确保应用程序在运行时占用尽可能少的内存。因此，对于使用较少内存的应用程序，可以将状态数据保存在缓存中更长时间。
- en: Many games use game services at the backend. If the application is not active,
    then there is a good chance that the service may also get killed by the operating
    system.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏在后台使用游戏服务。如果应用程序不活动，那么服务也有可能被操作系统杀死。
- en: Optimizing overall performance
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化整体性能
- en: Earlier, we discussed performance optimization from only the programming point
    of view. Let's discuss other scopes of optimizing the performance of Android games.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们仅从编程角度讨论了性能优化。让我们讨论Android游戏性能优化的其他方面。
- en: 'The developer can optimize performance from the time of design to development
    through the following points:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可以通过以下几点从设计到开发优化性能：
- en: Choosing the base resolution
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择基本分辨率
- en: Defining the portability range
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义可移植范围
- en: Program structure
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序结构
- en: Managing the database
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理数据库
- en: Managing the network connection
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理网络连接
- en: Choosing the base resolution
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择基本分辨率
- en: From the point of view of game development on Android, choosing the base resolution
    is probably the most significant design decision. Base resolution defines the
    scale of the graphical or visual element. The larger the resolution that the developer
    chooses to work upon, the more storage and process time it takes. Base resolution
    is also responsible for the quality and color information to be stored with bitmaps.
    Comparatively lower resolution does not demand many details in the visible asset,
    which can optimize bitmap data. However, as the resolution increases, it requires
    more data to preserve detailing. Eventually, this has a significant influence
    on processing.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android游戏开发的角度来看，选择基本分辨率可能是最重要的设计决策。基本分辨率定义了图形或视觉元素的比例。开发人员选择的分辨率越大，存储和处理时间就越多。基本分辨率还负责存储位图的质量和颜色信息。相对较低的分辨率不需要在可见资产中包含许多细节，这可以优化位图数据。然而，随着分辨率的增加，需要更多的数据来保留细节。最终，这对处理有重要影响。
- en: With the advancement of technology, Android device resolutions are getting bigger
    and better. So developers now choose a bigger resolution to support higher range
    devices.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术的进步，Android设备的分辨率越来越大。因此，开发人员现在选择更大的分辨率来支持更高范围的设备。
- en: Defining the portability range
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义可移植范围
- en: This is also a design phase optimization. In this stage, the developer needs
    to decide the range of hardware platform to support. This includes various configurations.
    We already know that the Android device range includes a large set of variations
    in terms of memory, processing speed, graphics quality, and so on.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是设计阶段的优化。在这个阶段，开发人员需要决定支持的硬件平台范围。这包括各种配置。我们已经知道，Android设备范围包括在内存、处理速度、图形质量等方面存在大量变化。
- en: 'If the range supports the range of portability of a similar device, then optimization
    becomes easier. However, this is not the case for most cases of game development.
    Usually, the developer should divide the optimization into three segments:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果范围支持类似设备的可移植范围，那么优化变得更容易。然而，这并不适用于大多数游戏开发情况。通常，开发人员应将优化分为三个部分：
- en: Low-performing devices
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低性能设备
- en: Average-performing devices
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均性能设备
- en: High-performing devices
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高性能设备
- en: So, ideally, there should be three layers of optimization to properly define
    the portability range.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，理想情况下，应该有三层优化来正确定义可移植范围。
- en: Program structure
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 程序结构
- en: The program structure is another very important technical design decision for
    both performance and memory optimization. This includes all the parameters for
    programming optimization, which we have already discussed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 程序结构是另一个非常重要的技术设计决策，对于性能和内存优化都很重要。这包括我们已经讨论过的所有编程优化参数。
- en: Additionally, program hierarchy also matters for performance. Often, the developer
    creates unnecessary intermediate calls to parse through several layers. A few
    singleton classes help here to optimize performance significantly. Proper game
    state machine design also helps optimize performance.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，程序层次结构对性能也很重要。通常，开发人员会创建不必要的中间调用来解析多个层。一些单例类在这里有助于显著优化性能。正确的游戏状态机设计也有助于优化性能。
- en: Managing the database
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理数据库
- en: There are many games that are mainly data driven. In such cases, a database
    needs to be managed properly.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多游戏主要是数据驱动的。在这种情况下，需要正确管理数据库。
- en: For example, a quiz game must have a question bank maintained in the database
    at some server to avoid frequent update of the game build. Database queries take
    time to execute as there is also a network layer in between. So, the game layer
    sends a query to the database. Then, the database fetches the data, binds it accordingly,
    and sends it back to the game. Then, the game has to unbind the received data
    in order to use it. Using the minimum query calls is the only way to minimize
    the performance overhead. Using a faster database also helps the game to perform
    well.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个问答游戏必须在数据库中维护一个问题库，以避免频繁更新游戏构建。数据库查询需要时间来执行，因为中间还有一个网络层。因此，游戏层发送查询到数据库。然后，数据库获取数据，相应地绑定并发送回游戏。然后，游戏必须解绑接收到的数据以使用它。使用最少的查询调用是最小化性能开销的唯一方法。使用更快的数据库也有助于游戏表现良好。
- en: Managing the network connection
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理网络连接
- en: 'Modern day gaming has enhanced to multiplayer and server-controlled mechanisms,
    which reduces the job of frequent updates of the game build. In both cases, network
    connection needs to be implemented in a proper way. There are mainly two types
    of multiplayer architecture currently being followed:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现代游戏已经发展到多人游戏和服务器控制机制，这减少了频繁更新游戏构建的工作。在这两种情况下，网络连接需要以适当的方式实现。目前主要有两种类型的多人游戏架构：
- en: Turn-based multiplayer
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回合制多人游戏
- en: Real-time multiplayer
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时多人游戏
- en: It's comparatively easy to manage a turn-based multiplayer system than real-time
    multiplayer. There is another model of multiplayer called asynchronous multiplayer.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 相对来说，管理回合制多人游戏系统比实时多人游戏系统要容易。还有另一种名为异步多人游戏的多人游戏模式。
- en: 'Each network call results in a lag in performance, as the game is dependent
    on the data from the server. So, the client-server architecture needs to be optimized
    in order to achieve the following goals:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网络调用都会导致性能延迟，因为游戏依赖于来自服务器的数据。因此，客户端-服务器架构需要优化，以实现以下目标：
- en: Less lag time
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较少的延迟时间
- en: Less layer processing
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较少的层处理
- en: Less number of pings to the server
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较少的对服务器的ping次数
- en: Increasing the frame rate
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加帧率
- en: The ultimate target for performance optimization is to increase the frame rate.
    A high frame rate automatically delivers smooth gameplay. However, the developer
    has to make sure that the frame rate effect is visible in the game in terms of
    smoothness and effect.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 性能优化的最终目标是提高帧率。高帧率自动提供流畅的游戏体验。然而，开发人员必须确保帧率效果在游戏中以流畅和效果的形式可见。
- en: For the current mobile gaming industry, an average FPS of 60 for a 2D game or
    mid-scaled 3D game is considered high performance. On the other hand, massive
    3D games might consider an average FPS of 30-35 as good performance.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 对于当前的移动游戏行业来说，2D游戏或中等规模的3D游戏的平均FPS为60被认为是高性能。另一方面，大型3D游戏可能认为平均FPS为30-35是良好的性能。
- en: High-performing games with higher FPS open a door for further visual effects
    to improve the user experience. This has a direct impact on monetization.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 具有更高FPS的高性能游戏为改善用户体验提供了进一步的视觉效果。这直接影响货币化。
- en: Importance of performance optimization
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能优化的重要性
- en: 'As we have just discussed, performance optimization directly influences the
    frame rate, which again directly impacts the gameplay experience. However, performance
    optimization has other importance too:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚讨论的，性能优化直接影响帧率，而帧率又直接影响游戏体验。然而，性能优化还有其他重要性：
- en: Games might crash or go in a not-responding state due to a non-optimized program
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于非优化的程序，游戏可能会崩溃或进入无响应状态
- en: Performance optimization has a direct impact on memory as well
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能优化也直接影响内存
- en: Performance optimization can enlarge the range of supported hardware platforms
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能优化可以扩大支持的硬件平台范围
- en: Common optimization mistakes
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的优化错误
- en: 'The gaming industry is now one of the fastest growing industries. To keep up
    with the speed and to stand in the market, many companies plan a shorter development
    period with limited optimization. In this scenario, the developer often commits
    the following mistakes knowingly or unknowingly:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏行业现在是增长最快的行业之一。为了跟上速度并在市场上站稳脚跟，许多公司计划缩短开发周期并限制优化。在这种情况下，开发人员通常会有意或无意地犯以下错误：
- en: Programming mistakes
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程错误
- en: Design mistakes
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计错误
- en: Wrong data structure
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的数据结构
- en: Using game services incorrectly
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误使用游戏服务
- en: Programming mistakes
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程错误
- en: Programming is a manual process, and to err is human. So, it is obvious that
    there is no bug-free and completely optimized programming for games. However,
    there are few ways in which a programmer can minimize mistakes to have an optimized
    game code base. Let's discuss the major mistakes a programmer commits while developing
    a game in Android.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 编程是一个手动的过程，犯错是人之常情。因此，显而易见，没有错误和完全优化的游戏编码。然而，程序员可以通过几种方式最小化错误，以获得优化的游戏代码库。让我们讨论在Android开发游戏时程序员犯的主要错误。
- en: Programmers often create many temporary variables and forget to keep track of
    them. Often, these variables occupy unnecessary memory and increase processing
    calls.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常创建许多临时变量并忘记跟踪它们。通常，这些变量会占用不必要的内存并增加处理调用。
- en: Sorting is widely used in game development for many purposes. There are several
    sorting algorithms. Most of the time, the developer chooses convenient techniques
    rather than efficient ones. For large arrays or lists, this may cause a serious
    lag in process flow.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 排序在游戏开发中被广泛使用。有几种排序算法。大多数情况下，开发者选择方便的技术而不是高效的技术。对于大型数组或列表，这可能会导致严重的流程延迟。
- en: Using too many static instances for accessibility ease is another bad practice.
    Using static may help in faster processing, but is not a good idea to make many
    static instances, as it blocks a lot of memory space during its lifetime. Many
    programmers even forget to manually free this memory.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便访问，使用太多静态实例也是一个不良的实践。使用静态可能会加快处理速度，但制作太多静态实例并不是一个好主意，因为它会在其生命周期内占用大量内存空间。许多程序员甚至忘记手动释放这些内存。
- en: Creating abstract layers and using them extensively makes the process slower.
    However, it is a good programming practice generally, but for game programming,
    it only helps in limited cases.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 创建抽象层并广泛使用它们会使流程变慢。然而，这通常是一个良好的编程实践，但对于游戏编程来说，只在有限的情况下有所帮助。
- en: Convenient loop use is another bad programming practice for games. There are
    several ways to work with loops. A programmer should first determine what goes
    best with the algorithm.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的循环使用是游戏中另一个不良的编程实践。有几种处理循环的方法。程序员应该首先确定哪种方法最适合算法。
- en: Game programming is mostly about logical development than technical. It may
    take time to build up the perfect logic for certain tasks. Many game programmers
    do not consider multiple ways of doing one task. Most of the time, it leaves a
    great scope of optimization unexplored.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏编程大多是关于逻辑开发而不是技术。为某些任务建立完美的逻辑可能需要时间。许多游戏程序员并不考虑执行一个任务的多种方式。大多数情况下，这会留下很大的优化空间未被发掘。
- en: Design mistakes
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计错误
- en: Designers often make mistakes when defining the hardware range and the game
    scope. Both are very important factors to create an optimized game design.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 设计师在定义硬件范围和游戏范围时经常犯错误。这两个因素都是创建优化游戏设计的非常重要的因素。
- en: Another mistake is to target the wrong target resolution. The target resolution
    has a direct effect on the art asset size. Targeting the wrong resolution leads
    to unnecessary scaling, causing extra processing overhead.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个错误是将目标分辨率定错。目标分辨率直接影响艺术资源的大小。定错目标分辨率会导致不必要的缩放，增加额外的处理开销。
- en: Wrong game data structure
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误的游戏数据结构
- en: Data structure is an inevitable part of game programming. Android supports dynamic
    array initialization. Yet, many developers prefer lists to store data. Lists are
    much slower than arrays. Lists should only be used when it is absolutely necessary.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是游戏编程中不可避免的一部分。Android支持动态数组初始化。然而，许多开发人员更喜欢使用列表来存储数据。列表比数组慢得多。只有在绝对必要时才应该使用列表。
- en: It is the developer's responsibility to figure out the perfect data structure
    for data-driven games. Proper technical design should include a data structure
    model and its use.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 为数据驱动的游戏找到完美的数据结构是开发者的责任。适当的技术设计应该包括数据结构模型及其使用。
- en: Using game services incorrectly
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误使用游戏服务
- en: Services are very useful at times. In the modern day gaming industry, services
    are used for download/upload of data, for push notifications, for deep linking
    in games, or for server connectivity. However, services come at a huge cost of
    processing and memory consumption. Running services causes significant amount
    of power consumption as well.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 服务在某些时候非常有用。在现代游戏行业中，服务用于数据的下载/上传，推送通知，游戏中的深度链接，或者服务器连接。然而，服务会带来巨大的处理和内存消耗成本。运行服务也会导致大量的能耗。
- en: So, using services should be mandatory only when there is no other way around.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只有在没有其他办法时才应该强制使用服务。
- en: Best optimization practices
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳优化实践
- en: 'Some defined and logical optimization techniques are available. We will discuss
    the major scopes and fields that are related to Android game development:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些定义明确且合乎逻辑的优化技术可供选择。我们将讨论与Android游戏开发相关的主要范围和领域：
- en: Game design constraints
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏设计约束
- en: Game development optimization
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏开发优化
- en: Game data structure model
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏数据结构模型
- en: Using game assets
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用游戏资源
- en: Handling cache data
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理缓存数据
- en: Design constraints
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计约束
- en: It is always a best practice to define the target hardware platforms and acknowledge
    the limitation. Technical design can structure the development constraints according
    to it.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 定义目标硬件平台并承认其限制总是最佳实践。技术设计可以根据它来构建开发约束。
- en: The scalability and portability should also be decided at the time of designing
    the game. This should give the developer a tentative platform limitation along
    with other constraints. We have already discussed design optimization. All those
    segments should be evaluated before going into development.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性和可移植性也应该在设计游戏时确定。这应该给开发者一个初步的平台限制以及其他约束。我们已经讨论了设计优化。在进入开发之前，所有这些部分都应该进行评估。
- en: Targeting screen size and resolution has to be fixed when designing the game
    along with creating layouts, which will fit in multiple resolutions. This is because
    Android has many screen sizes as discussed earlier.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计游戏时，需要固定目标屏幕大小和分辨率，并创建适合多种分辨率的布局。这是因为Android有许多不同的屏幕大小，正如前面所讨论的。
- en: Selecting the minimum Android version and the target Android version gives the
    developer an advantage when structuring the development project, as supported
    API levels and platform features are already defined.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最低的Android版本和目标Android版本在构建开发项目时给开发者带来了优势，因为支持的API级别和平台功能已经定义好了。
- en: Development optimization
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发优化
- en: 'This is one of the most important segments of optimization. Here are some tips
    to carry out the development process successfully with optimization:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这是优化中最重要的部分之一。以下是一些成功进行优化开发过程的提示：
- en: Using as many as possible folder structures provided by Android for project
    scalability.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用尽可能多的安卓提供的文件夹结构，以便项目可扩展性。
- en: Using resource formats according to the dpi list provided by Android.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据安卓提供的dpi列表使用资源格式。
- en: The developer should avoid scaling images. This effectively reduces memory and
    processing overhead.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员应避免缩放图像。这有效地减少了内存和处理开销。
- en: Using sprites for multiple purposes is also a good practice to create animations.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于多种用途使用精灵也是创建动画的良好实践。
- en: The tiling technique is very useful in terms of reducing memory consumption.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平铺技术在减少内存消耗方面非常有用。
- en: Overriding the `onDraw()` method is always a good practice to flush the old
    rendering pipeline and to use a systematic draw order with absolute requirement.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖`onDraw()`方法始终是刷新旧渲染管道并使用系统化绘制顺序的良好实践。
- en: Use XML-based layout wherever possible; however, games have very limited scope
    for this Android feature.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用基于XML的布局；然而，游戏对于这个安卓功能的使用范围非常有限。
- en: Data structure model
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据结构模型
- en: Data structures are one of the inevitable parts of game program design since
    the beginning, irrespective of the scale of the game. Each game always processes
    data for various purposes such as sorting, searching, storing, and so on.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构是游戏程序设计中不可避免的部分，无论游戏的规模如何。每个游戏都会处理各种目的的数据，如排序、搜索、存储等。
- en: There are many data structure models available for various operations. Each
    operation has its own advantages and disadvantages. The developer must choose
    the most efficient one depending on the requirement.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多数据结构模型可用于各种操作。每种操作都有其优点和缺点。开发人员必须根据需求选择最有效的方法。
- en: Let's take an example of data storing comparison between an array and a linked
    list. Effectively, linked lists are more flexible and dynamic in nature than arrays.
    However, this feature comes at a cost of slow processing and higher memory consumption.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以数组和链表之间的数据存储比较为例。实际上，链表比数组更灵活和动态。然而，这种特性会导致处理速度较慢和内存消耗较高的代价。
- en: The developer might not always require to store dynamic data. For example, if
    cricket team data needs to be stored, then an array is sufficient, because there
    will always be 11 players on each side, and that cannot be modified during gameplay.
    It will make the process much faster and more efficient than using a linked list
    in this particular case.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可能并不总是需要存储动态数据。例如，如果需要存储板球队数据，那么数组就足够了，因为每边总是有11名球员，并且在游戏过程中不能修改。在这种特定情况下，这将使过程比使用链表更快更高效。
- en: In another case, for a shooting game, the developer cannot predict the number
    of bullets the user may fire during gameplay. So, a queue data structure will
    be most efficient in order to process all the fired bullets.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一种情况下，对于射击游戏，开发人员无法预测用户在游戏过程中可能发射的子弹数量。因此，队列数据结构将是最有效的，以处理所有发射的子弹。
- en: Similarly, stacks and tree structures can be chosen whenever they fit the purpose.
    The same approach may be taken for sort and search algorithms.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，堆栈和树结构可以在适当的情况下选择。对于排序和搜索算法也可以采用相同的方法。
- en: Asset-using techniques
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产使用技术
- en: We have already categorized assets for games. Let's discuss them from the perspective
    of optimization techniques and best practices.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对游戏资产进行了分类。现在让我们从优化技术和最佳实践的角度来讨论它们。
- en: Art assets
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 艺术资产
- en: A separate optimization technique can be applied to a set of art assets. Art
    assets are the face of games. So, it is necessary that the visuals are attractive
    enough to start gameplay.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一组艺术资产可以应用单独的优化技术。艺术资产是游戏的面孔。因此，必须确保视觉足够吸引人，以开始游戏。
- en: As we have discussed already, better art assets cost memory and performance.
    However, this can be minimized to a certain level. There are several tools for
    art asset optimization. However, using inappropriate tools can cause data loss,
    which eventually results in poor visual quality.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，更好的艺术资产会消耗内存和性能。然而，这可以最小化到一定程度。有几种艺术资产优化工具。然而，使用不合适的工具可能会导致数据丢失，最终导致视觉质量不佳。
- en: Art should never compromise from the perspective of visual quality. Often, artists
    develop assets that do not reflect perfectly in games because of inappropriate
    optimization.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 艺术在视觉质量方面不应妥协。通常，艺术家开发的资产在游戏中不能完美反映，因为优化不当。
- en: We have already discussed how art assets should be made. Now, let's assume that
    some art is using only 8-bit data space as raw format, but the same is exported
    in a 24-bit format. Then, the developer can use tools to optimize the asset to
    a typical 8-bit format without affecting the visual quality.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了艺术资产应该如何制作。现在，让我们假设一些艺术只使用8位数据空间作为原始格式，但是导出时是24位格式。那么，开发人员可以使用工具将资产优化为典型的8位格式，而不影响视觉质量。
- en: This rule also applies for complete opaque assets. The developer can get rid
    of the transparency information in order to have optimized art assets.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则也适用于完全不透明的资产。开发人员可以摆脱透明信息，以获得优化的艺术资产。
- en: Audio assets
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音频资产
- en: Audio assets are standalone assets too. Audio has become a very important asset
    for extended user experience. Audio configuration can vary with a wide range of
    frequency, bit depth, and compression techniques. Each variation in configuration
    has a different level of processing and memory consumption.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 音频资产也是独立的资产。音频已经成为扩展用户体验的非常重要的资产。音频配置可以根据频率、位深度和压缩技术的广泛范围而变化。每种配置变化都有不同的处理和内存消耗水平。
- en: So, audio optimization is also a very important part of the optimization process.
    Regular practice in the Android game development industry is to choose two different
    formats of audio for SFX and music files.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，声音优化也是优化过程中非常重要的一部分。在安卓游戏开发行业中的常见做法是为SFX和音乐文件选择两种不同的音频格式。
- en: One thing that developers generally ignore is audio information data. Few Android
    devices have a certain frequency cap, but sounds are usually good when more frequencies
    are used. So, it is a technical design level step to determine the cap for Android
    game sounds. So, every sound should be made within the proximity.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常忽视的一件事是音频信息数据。一些安卓设备有特定的频率上限，但当使用更多频率时，声音通常会更好。因此，确定安卓游戏声音的上限是一个技术设计层面的步骤。因此，每个声音都应该在接近范围内制作。
- en: Sound designers need to keep up the quality within the limit. In this way, audio
    assets can be optimized at the time of development.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 声音设计师需要在限制内保持质量。通过这种方式，音频资产可以在开发时进行优化。
- en: Other assets
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他资产
- en: Besides art and audio, there may be other data assets used in games. The data
    format can be anything, such as binary, text, XML, JSON, or custom. Custom formats
    are basically the same as binary format, with some encryption.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 除了艺术和音频，游戏中可能还会使用其他数据资产。数据格式可以是任何形式，如二进制、文本、XML、JSON或自定义。自定义格式基本上与二进制格式相同，只是加了一些加密。
- en: It is a common practice in game development to use data sets separately. A separate
    data set helps structure the project and give flexibility to use the same code
    for a different output. Often, the developer updates data source to update the
    complete game experience without creating a new APK. This reduces development
    time in the longer run in order to maintain the game and do easy updates.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，将数据集分开使用是一种常见做法。单独的数据集有助于构建项目结构，并灵活地使用相同的代码来产生不同的输出。通常，开发人员更新数据源以更新完整的游戏体验，而无需创建新的APK。这在长期内减少了开发时间，以便维护游戏并进行简单的更新。
- en: From the optimization point of view, these data sources should be optimized
    enough to get processed quickly and not consume too much memory. However, reading
    and writing an external file takes time. Normally, binary files are the fastest
    to be processed and smallest in size. However, after reading the binary data,
    it has to be parsed to be used in games, which eventually increases processing.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 从优化的角度来看，这些数据源应该被优化到足够快速地处理并且不消耗太多内存。然而，读写外部文件需要时间。通常，二进制文件是处理速度最快且大小最小的。然而，在读取二进制数据后，必须对其进行解析以在游戏中使用，这最终会增加处理时间。
- en: The most commonly used data formats are XML and JSON. The Android library has
    support for both of them, which includes a generic parser. The developer can have
    readily available data without making extra processing effort. However, the data
    can be manipulated during gameplay, depending on the game's requirements.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的数据格式是XML和JSON。安卓库支持它们两者，包括通用解析器。开发人员可以在不进行额外处理的情况下获得可用的数据。然而，数据可以根据游戏的要求在游戏过程中进行操作。
- en: Handling cache data
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理缓存数据
- en: A cache is a memory segment that is similar to RAM from a functionality point
    of view, but acts faster than conventional RAM. The processor can access this
    segment much faster. So, logically, a cache should only store data that is being
    used frequently.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一个类似于RAM的内存段，但比传统RAM更快的功能。处理器可以更快地访问这个段。因此，从逻辑上讲，缓存应该只存储经常使用的数据。
- en: The best possible way to handle cache data is to keep a check on the application
    memory usage. Generally, there should be at least 10 % of free memory available
    for the operating system. It is tested that an application can use an average
    of 2% of the total free memory.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 处理缓存数据的最佳方式是监控应用程序内存的使用情况。通常，操作系统应至少有10%的空闲内存可用。经测试，一个应用程序可以使用平均2%的总空闲内存。
- en: However, the developer cannot control the cache technically. They can only make
    sure that the most commonly used elements are optimized in a perfect way so that
    the executer automatically uses cache memory for them.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，开发人员无法在技术上控制缓存。他们只能确保最常用的元素被优化得足够完美，以便执行器自动为它们使用缓存内存。
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Optimization is one of the most important tasks in any software development,
    especially in games, where logical programming dominates technical programming.
    There are plenty of optimization tools and techniques available for technical
    programming as it has the most common algorithms to implement. However, in the
    case of game programming, each gameplay indicates a different set of algorithms.
    In many cases, an artificial intelligence algorithm is also made separately. So,
    there is a very high probability that the programmer has to find out an efficient
    way to optimize freshly written algorithms.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是任何软件开发中最重要的任务之一，尤其是在游戏开发中，逻辑编程占据了技术编程的主导地位。对于技术编程来说，有大量的优化工具和技术可供使用，因为它有最常见的算法来实现。然而，在游戏编程的情况下，每个游戏玩法都需要不同的算法集。在许多情况下，还需要单独制作人工智能算法。因此，程序员很有可能需要找到一种有效的方法来优化新编写的算法。
- en: We have discussed all the possible scopes of optimization in Android game development.
    Technical optimization is mandatory as it has fixed guidelines to follow. However,
    logical development will depend on the game algorithm and its requirements. So,
    it is an extra effort for the game developer to optimize Android games.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了在安卓游戏开发中所有可能的优化范围。技术优化是强制性的，因为它有固定的指导方针要遵循。然而，逻辑开发将取决于游戏算法及其要求。因此，对于游戏开发人员来说，优化安卓游戏是额外的努力。
- en: Sometimes, developers over-optimize games. This is not recommended. Over-optimization
    usually downgrades the quality of the game. So, at the time of technical design,
    optimization cases should be declared.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，开发人员会过度优化游戏。这是不推荐的。过度优化通常会降低游戏的质量。因此，在技术设计时，应声明优化情况。
- en: Most large-scale development processes have a separately defined task set for
    optimization. Some developers choose to develop a dynamic optimization process.
    This means that the developer optimizes the game in different stages on different
    scales. Both the processes are effective, but the first one is logically more
    sensible, because defining a separate task will always give an idea about the
    tentative time duration for overall optimization. This helps manage the entire
    game development process in a better way.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数大规模开发过程都有一个单独定义的优化任务集。一些开发者选择开发动态优化过程。这意味着开发者在不同阶段、不同规模上优化游戏。这两种过程都是有效的，但第一种在逻辑上更合理，因为定义一个单独的任务总是会给出整体优化的暂定时间。这有助于更好地管理整个游戏开发过程。
- en: All optimization processes are validated through a testing phase. All design,
    engineering, and art work is tested in this segment of game development. We will
    have a deeper look at testing in the next chapter of this book.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 所有优化过程都经过测试阶段的验证。所有设计、工程和艺术工作都在游戏开发的这一阶段进行测试。我们将在本书的下一章更深入地讨论测试。
