- en: Transforming Functions - Currying and Partial Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数转换-柯里化和部分应用
- en: In [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing Functions
    - Higher-Order Functions*, we saw several ways of manipulating functions, to get
    new versions with some change in their functionality. In this chapter, we will
    go into a particular kind of transformation, a sort of *factory* method, that
    lets you produce new versions of any given function, with some fixed arguments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中，*生成函数-高阶函数*，我们看到了几种操纵函数的方法，以获得具有某些功能变化的新版本。在本章中，我们将深入研究一种特定类型的转换，一种*工厂*方法，它让您可以使用一些固定参数来生成任何给定函数的新版本。
- en: 'We will be considering the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑以下内容：
- en: '*Currying*, a classic FP theoretical function that transforms a function with
    many parameters into a sequence of unary functions'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*柯里化*，一个经典的FP理论函数，将具有许多参数的函数转换为一系列一元函数'
- en: '*Partial application*, another time-honored FP transformation, which produces
    new versions of functions by fixing some of their arguments'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部分应用*，另一个历史悠久的FP转换，通过固定一些参数来产生函数的新版本'
- en: Something I'll call *partial currying*, that can be seen as a mixture of the
    two previous transformations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将称之为*部分柯里化*的东西，可以看作是两种先前转换的混合体
- en: To be fair, we'll also see that some of these techniques can be emulated, with
    possibly greater clarity, by simple arrow functions. However, since you are quite
    liable to find currying and partial application in all sorts of texts and web
    pages on FP, it is quite important that you are aware of their meaning and usage,
    even if you opt for a simpler way out.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，我们还将看到，一些这些技术可以通过简单的箭头函数来模拟，可能会更清晰。然而，由于您很可能会在各种FP文本和网页上找到柯里化和部分应用，因此了解它们的含义和用法非常重要，即使您选择更简单的方法。
- en: A bit of theory
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点理论
- en: 'The concepts that we are going to use in this chapter are in some ways very
    similar and in other ways quite different. It''s common to find some confusion
    as to their real meanings and there are plenty of web pages which misuse terms.
    You could even say that all the transformations in this chapter are roughly equivalent
    since they let you transform a function into another one that fixes some parameters,
    leaving others free and eventually leading to the same result. OK, I agree, this
    isn''t very clear! So, let''s start by clearing the air, and providing some short
    definitions, which we will expand later. (If you feel that your eyes are glazing
    over, please just skip this section and come to it later!) Yes, you may find the
    following descriptions a bit perplexing, but bear with us: we''ll be getting into
    more detail just in a bit!'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将使用的概念在某些方面非常相似，在其他方面则有很大不同。人们常常会对它们的真正含义感到困惑，并且有很多网页滥用术语。您甚至可以说，本章中的所有转换大致等效，因为它们让您将一个函数转换为另一个函数，固定一些参数，留下其他参数自由，并最终导致相同的结果。好吧，我同意，这并不是很清楚！因此，让我们从澄清一些概念开始，并提供一些简短的定义，稍后我们将进行扩展。（如果您觉得自己的眼睛开始发直，请跳过这一部分，稍后再来看！）是的，您可能会觉得以下描述有点令人困惑，但请耐心等待：我们马上就会详细介绍！
- en: '*Currying* is the process of transforming an *m*-ary function (that is, a function
    of arity *m*) into a sequence of *m* unary functions, each of which receives one
    argument of the original function, from left to right. (The first function receives
    the first argument of the original function, the second function receives the
    second argument, and so on.) Upon being called with an argument, each function
    produces the next one in the sequence, and the last one does the actual calculations.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*柯里化*是将*m*元函数（即，具有*m*个参数的函数）转换为一系列*m*个一元函数的过程，每个函数接收原始函数的一个参数，从左到右。（第一个函数接收原始函数的第一个参数，第二个函数接收第二个参数，依此类推。）每次调用带有参数的函数时，都会产生序列中的下一个函数，最后一个函数执行实际的计算。'
- en: '*Partial application* is the idea of providing *n* arguments to a *m*-ary function,
    being *n* less than or equal to *m*, to transform it into a function with (*m-n*)
    parameters. Each time you provide some arguments, a new function is produced,
    with smaller arity. When you provide the last arguments, the actual calculations
    are performed.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部分应用*是提供*n*个参数给*m*元函数的想法，其中*n*小于或等于*m*，以将其转换为具有(*m-n*)个参数的函数。每次提供一些参数时，都会产生一个具有更小元数的新函数。当提供最后的参数时，将执行实际的计算。'
- en: '*Partial currying* is a mixture of both preceding ideas: you provide *n* arguments
    (from left to right) to a *m*-ary function and you produce a new function of arity
    (*m-n*). When this new function receives some other arguments, also from left
    to right, it will produce yet another function. When the last parameters are provided,
    the function produces the correct calculations.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*部分柯里化*是两种先前想法的混合体：您向*m*元函数提供*n*个参数（从左到右），并产生一个新的元函数（*m-n*）。当这个新函数接收到其他参数，同样是从左到右，它将产生另一个函数。当提供最后的参数时，函数将产生正确的计算结果。'
- en: In this chapter, we are going to see the three transformations, what they require,
    and ways of implementing them. With respect to this, we will go into more than
    one way of coding each higher-order function and that will give us several insights
    about interesting ways of JS coding, that you might find interesting for other
    applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到这三种转换，它们需要什么，以及实现它们的方法。关于这一点，我们将探讨每个高阶函数的编码方式，这将为我们提供有关JS编码的一些有趣见解，您可能会发现对其他应用程序很有趣。
- en: Currying
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化
- en: We already mentioned currying back in the *Arrow functions* section of [Chapter
    1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional - Several
    Questions*, and in the *One argument or many?* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*, but let's be more thorough here.
    Currying is a device that enables you to only work with single variable functions,
    even if you need a multiple variable one.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第1章](395f5897-0ecc-4841-86ed-21521e148beb.xhtml)的*箭头函数*部分和[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*一个参数还是多个参数？*部分中提到了柯里化，但让我们在这里更加彻底。柯里化是一种设备，它使您只能使用单变量函数，即使您需要多变量函数。
- en: The idea of converting a multi-variable function into a series of single-variable
    functions (or, more rigorously, reducing operators with several operands, to a
    sequence of applications of a single operand operator) had been worked on by Moses
    Schönfinkel, and there have been some authors who suggest, not necessarily tongue
    in cheek, that currying would be more correctly named *Schönfinkeling*!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将多变量函数转换为一系列单变量函数的想法（或者更严格地说，将具有多个操作数的运算符减少为单操作数运算符的一系列应用）是由Moses Schönfinkel研究过的，有一些作者建议，不一定是开玩笑，柯里化更正确地被称为*Schönfinkeling*！
- en: Dealing with many parameters
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理许多参数
- en: 'The idea of currying, by itself, is simple. If you need a function with, say,
    three parameters, instead of writing (with arrow functions) something like the
    following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化的想法本身很简单。如果您需要一个带有三个参数的函数，而不是（使用箭头函数）像下面这样写：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can have a sequence of functions, each with a single parameter:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以有一系列具有单个参数的函数：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you might want to consider them to be nested functions:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可能希望将它们视为嵌套函数：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In terms of usage, there''s an important difference in how you''d use each
    function. While you would call the first in usual fashion, such as `make3(1,2,4)`,
    that wouldn''t work with the second definition. Let''s work out why: `make3curried()`
    is an *unary* (single parameter), so we should write `make3curried(1)`... but
    what does this return? According to the definition above, this also returns an
    unary function -- and *that* function also returns a unary function! So, the correct
    call to get the same result as with the ternary function would be `make3curried(1)(2)(4)`!
    See Figure 7.1:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用上，每个函数的使用方式有一个重要的区别。虽然您可以像这样调用第一个函数，比如`make3(1,2,4)`，但是对于第二个定义，这样是行不通的。让我们来看看为什么：`make3curried()`是一个*一元*（单参数）函数，所以我们应该写`make3curried(1)`...但是这会返回什么？根据上面的定义，这也会返回一个一元函数--*那*个函数也会返回一个一元函数！因此，要获得与三元函数相同的结果，正确的调用应该是`make3curried(1)(2)(4)`！参见图7.1：
- en: '![](assets/47ca4163-c4a1-44eb-90ff-76d77804c6d7.jpg)Figure 7.1\. The difference
    between a common function, and a curried equivalent.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/47ca4163-c4a1-44eb-90ff-76d77804c6d7.jpg)图7.1。普通函数和柯里化等价函数之间的区别。'
- en: Study this carefully --we have the first function, and when we apply an argument
    to it, we get a second function. Applying an argument to it produces a third function
    and a final application produces the desired result. This can be seen as a needless
    exercise in theoretical computing, but it actually brings some advantages, because
    you can then always work with unary functions, even if you need functions with
    more parameters.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究这一点--我们有第一个函数，当我们对其应用一个参数时，我们得到第二个函数。对它应用一个参数会产生第三个函数和最终的应用会产生期望的结果。这可以被视为在理论计算中不必要的练习，但实际上它带来了一些优势，因为您可以始终使用一元函数，即使您需要具有更多参数的函数。
- en: Since there is a currying transformation, there also exists an uncurrying one!
    In our case, we would write `make3uncurried = (a,b,c) => make3curried(a)(b)(c)`
    to revert the currying process and make usable, once again, to provide all parameters
    at a sitting.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在柯里化转换，也存在反柯里化转换！在我们的例子中，我们会写`make3uncurried = (a,b,c) => make3curried(a)(b)(c)`来恢复柯里化过程，并再次使用，一次性提供所有参数。
- en: In some languages, such as Haskell, functions are only allowed to take a single
    parameter -- but then again, the syntax of the language allows you to invoke functions
    as if multiple parameters were permitted. For our example, in Haskell, writing
    `make3curried 1 2 4` would have produced the result 124, without anybody even
    needing to be aware that it involved *three* function calls, each with one of
    our arguments. Since you don't write parentheses around parameters, and you don't
    separate them with commas, you cannot tell that you are not providing a triplet
    of values instead of three singular ones.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，比如Haskell，函数只允许接受一个参数--但是语言的语法允许您调用函数，就好像允许多个参数一样。对于我们的例子，在Haskell中，写`make3curried
    1 2 4`会产生结果124，甚至不需要有人意识到它涉及*三*个函数调用，每个函数都有一个参数。由于您不在参数周围写括号，并且不用逗号分隔它们，您无法知道您没有提供三个单一值而是三个值的三元组。
- en: Currying is basic in Scala or Haskell, which are fully functional languages,
    but JavaScript has enough features to allow us to define and use currying in our
    work. It won't be as easy--since, after all, it's not built-in -- but we'll be
    able to manage.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化在Scala或Haskell中是基本的，这些都是完全功能的语言，但JavaScript有足够的功能来允许我们在工作中定义和使用柯里化。这不会那么容易--毕竟，它不是内置的--但我们将能够应对。
- en: 'So, to review the basic concepts, the key differences between our original
    `make3()` and `make3curried()` are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回顾基本概念，我们原始的`make3()`和`make3curried()`之间的关键区别如下：
- en: '`make3()` is a ternary function, but `make3curried()` is unary'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make3()`是一个三元函数，但`make3curried()`是一元的'
- en: '`make3()` returns a string; `make3curried()` returns another function -- which,
    itself, returns a *second* function, which returns yet a *third* function, which
    finally does return a string!'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`make3()`返回一个字符串；`make3curried()`返回另一个函数--它本身返回*第二*个函数，然后返回*第三*个函数，最终返回一个字符串！'
- en: You can produce a string by writing something like `make3(1,2,4)`, which returns
    124, but you'll have to write `make3curried(1)(2)(4)` to get the same result
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过编写类似`make3(1,2,4)`的东西来生成一个字符串，它返回124，但是您将不得不编写`make3curried(1)(2)(4)`来获得相同的结果
- en: 'Why would you go to all this bother? Let''s just see a simple example, and
    down below we will be seeing more examples. Suppose you had a function that calculated
    the VAT (*Value Added Tax*) for an amount:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要费这么大的劲呢？让我们看一个简单的例子，然后我们将看到更多的例子。假设您有一个计算增值税（VAT）的函数：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you had to apply a single, constant rate, you could then curry the `addVAT()`
    function, to produce a more specialized version, that always applied your given
    rate. For example, if your national rate was 6%, you could then have something
    like the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须应用单一的恒定费率，那么您可以对`addVAT()`函数进行柯里化，以生成一个更专业的版本，它总是应用您给定的费率。例如，如果您的国家税率是6%，那么您可以有以下内容：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first line defines a curried version of our VAT-calculating function. Given
    a tax rate, `addVATcurried()` returns a new function, that when given an amount
    of money, finally adds the original tax rate to it. So, if the national tax rate
    were 6%, then `addNationalVAT()` would be a function that added 6% to any amount
    given to it. For example, if we were to calculate `addNationalVAT(1500)`, as in
    the preceding code, the result would be 1590: $1500, plus a 6% tax.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了我们的增值税计算函数的柯里化版本。给定一个税率，`addVATcurried()`返回一个新函数，当给定一定金额的钱时，最终将原始税率加到其中。因此，如果国家税率为6%，那么`addNationalVAT()`将是一个函数，它会给任何给定的金额增加6%。例如，如果我们要计算`addNationalVAT(1500)`，就像前面的代码一样，结果将是1590：1500美元，再加上6%的税。
- en: 'Of course, you would be probably justified to say that this currying thing
    is a bit too much just to add a 6% tax, but the simplification is what counts.
    Let''s see one more example. In your application, you may want to include some
    logging, with a function such as the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能会认为这种柯里化对于只增加6%的税来说有点过分，但简化才是最重要的。让我们看一个例子。在您的应用程序中，您可能希望包含一些日志记录，例如以下函数：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, with this approach, every time you wanted to display a normal log
    message, you would write `myLog`(`"NORMAL"`, "some normal text"), and for warnings,
    you''d write `myLog`(`"WARNING"`, "some warning") -- but you could simplify this
    a bit with currying, by fixing the first parameter of `myLog()` as follows, with
    a `curry()` function that we''ll see later:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，采用这种方法，每次您想要显示一个正常的日志消息时，您将写`myLog`(`"NORMAL"`, "一些正常文本")，而对于警告，您将写`myLog`(`"WARNING"`,
    "一些警告")--但您可以通过柯里化简化一下，通过固定`myLog()`的第一个参数，如下所示，使用我们稍后将看到的`curry()`函数：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What do you gain? Now you can just write `myNormalLog("some normal text")` or
    `myWarningLog("some warning")`, because you have curried `myLog()` and then fixed
    its argument -- this makes for simpler, easier to read code!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到了什么？现在你可以只写`myNormalLog("一些正常文本")`或`myWarningLog("一些警告")`，因为你已经对`myLog()`进行了柯里化，然后固定了它的参数--这使得代码更简单，更易读！
- en: 'By the way, if you prefer, you could have also achieved the same result in
    a single step, with the original uncurried `myLog()` function, by currying it
    case by case:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果您愿意，您也可以通过逐个案例地对原始的非柯里化`myLog()`函数进行柯里化来以单个步骤实现相同的结果：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Currying by hand
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动柯里化
- en: 'If we want to implement currying just for a special case, there''s no need
    to do anything complex, because we can manage with simple arrow functions: we
    saw that for both `make3curried()` and `addVATcurried()`, so there''s no need
    to revisit that idea.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想为特殊情况实现柯里化，就没有必要做任何复杂的事情，因为我们可以使用简单的箭头函数来处理：我们看到了`make3curried()`和`addVATcurried()`都是如此，所以没有必要重新审视这个想法。
- en: 'Instead, let''s look into some ways of doing that automatically, so we will
    be able to produce an equivalent curried version of any function, even without
    knowing its arity beforehand. Going further, we might want to code a more intelligent
    version of a function, that could work differently depending on the number of
    received arguments. For example, we could have a `sum(x,y)` function that behaved
    like in the following examples:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们看一些自动执行这些操作的方法，这样我们将能够生成任何函数的等效柯里化版本，即使事先不知道它的arity。更进一步，我们可能希望编写一个函数的更智能版本，它可以根据接收到的参数数量而有所不同。例如，我们可以有一个`sum(x,y)`函数，它的行为如下例所示：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can achieve that behavior by hand. Our function would be something like
    the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动实现这种行为。我们的函数将是以下内容：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s recap what we did here. Our curried-by-hand function has this behavior:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在这里做了什么。我们手动柯里化的函数有以下行为：
- en: If we call it with two arguments, it adds them, and returns the sum; this provides
    our first use case, as in `sum(3,5)==8`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们用两个参数调用它，它会将它们相加，并返回总和；这提供了我们的第一个用例，就像`sum(3,5)==8`一样。
- en: 'If only one argument is provided, it returns a new function. This new function
    expects a single argument, and will return the sum of that argument and the original
    one: this behavior is what we expected in the other two use cases, such as `add2(3)==5`
    or `sum(2)(7)==9`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只提供一个参数，它将返回一个新函数。这个新函数期望一个参数，并将返回该参数和原始参数的总和：这种行为是我们在其他两种用例中所期望的，比如`add2(3)==5`或`sum(2)(7)==9`。
- en: Finally, if no arguments are provided, it returns itself. This means that we
    would be able to write `sum()(1)(2)` if we desire. (No, I cannot think of a reason
    for wanting to write that...)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果没有提供参数，它将返回自身。这意味着我们可以写`sum()(1)(2)`如果我们愿意。（不，我想不出想要写那个的原因...）
- en: So, if we want, we can incorporate currying in the definition itself of a function.
    However, you'll have to agree that having to deal with all the special cases in
    each function, can easily become troublesome, as well as error-prone. So, let's
    try to work out some more generic ways of accomplishing the same result, without
    any kind of particular coding.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们愿意，我们可以在函数的定义中直接包含柯里化。然而，您必须同意，必须在每个函数中处理所有特殊情况，这很容易变得麻烦，也容易出错。因此，让我们尝试找出一些更通用的方法来实现相同的结果，而不需要任何特定的编码。
- en: Currying with bind()
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用bind()进行柯里化
- en: We can find a solution to currying by using the `.bind()` method. This allows
    us to fixate one argument (or more, if need be; we won't be needing that here,
    but later on, we will use it) and provide a function with that fixed argument.
    Of course, many libraries (such as Lodash, Underscore, Ramda, and more) provide
    this functionality, but we want to see how to implement that by ourselves.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`.bind()`方法找到柯里化的解决方案。这使我们能够固定一个参数（或更多，如果需要；我们现在不需要，但以后会用到），并提供具有固定参数的函数。当然，许多库（如Lodash、Underscore、Ramda等）提供了这种功能，但我们想看看如何自己实现。
- en: Read more on `.bind()` at [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind)
    -- it will be useful since we'll take advantage of this method more times in this
    chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind)上阅读更多关于`.bind()`的内容--这将很有用，因为我们将在本章中多次利用这个方法。
- en: 'Our implementation is quite short but will require some explanation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现非常简短，但需要一些解释：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Start by noticing that `curry()` always returns a new function, which depends
    on the function `fn` given as its parameter. If the function has no (more) parameters
    left (when `fn.length===0`) because all parameters have already been fixed, we
    can simply evaluate it by doing `fn()`. Otherwise, the result of currying the
    function will be a new function, that receives a single argument, and produces
    itself a newly curried function, with another fixed argument. Let''s see this
    in action, with a detailed example, using the `make3()` function we saw at the
    beginning of this chapter once again:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先注意到`curry()`总是返回一个新函数，该函数取决于作为其参数给定的函数`fn`。如果函数没有（更多）剩余参数（当`fn.length===0`时），因为所有参数已经被固定，我们可以通过执行`fn()`来简单评估它。否则，柯里化函数的结果将是一个新函数，它接收一个参数，并产生一个新的柯里化函数，其中另一个参数被固定。让我们通过一个详细的例子来看看这个过程，再次使用我们在本章开头看到的`make3()`函数：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The explanation of this code is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的解释如下：
- en: The first function, `f1()`, has not received any arguments yet. Its result is
    a function of a single parameter, that will itself produce a curried version of
    `make3()`, with its first argument fixed to whatever it's given.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个函数`f1()`还没有接收任何参数。它的结果是一个单参数函数，它本身将产生`make3()`的柯里化版本，其第一个参数固定为给定的值。
- en: Calling `f1(6)` produces a new unary function, `f2()`, that will by itself produce
    a curried version of `make3()` -- but with its first argument set to `6`, so actually
    the new function will end fixing the second parameter of `make3()`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`f1(6)`会产生一个新的一元函数`f2()`，它本身将产生`make3()`的柯里化版本--但其第一个参数设置为`6`，因此实际上新函数将结束固定`make3()`的第二个参数。
- en: Similarly, calling `f2(5)` produces yet a third unary function, `f3()`, that
    will produce a version of `make3()`, but fixing its third argument, since the
    first two had already been fixed.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，调用`f2(5)`会产生第三个一元函数`f3()`，它将产生`make3()`的一个版本，但固定其第三个参数，因为前两个参数已经被固定。
- en: Finally, when we calculate `f3(8)`, this fixes the last parameter of `make3()`
    to `8`, and since there are no more arguments left, the thrice-bound `make3()`
    function is called and the result `"658"` is produced.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当我们计算`f3(8)`时，这将把`make3()`的最后一个参数固定为`8`，并且由于没有更多的参数了，三次绑定的`make3()`函数被调用，产生结果`"658"`。
- en: 'If you wanted to curry the function by hand, you could use JavaScript''s `.bind()`
    method. The sequence would be as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想手动进行函数柯里化，可以使用JavaScript的`.bind()`方法。顺序如下：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In each step, we provide a further parameter. (The `null` value is required,
    to provide context. If it were a method attached to an object, we would provide
    that object as the first parameter to `.bind()`. Since that's not the case, `null`
    is expected.) This is equivalent to what our code does, with the exception that
    the last time, `curryByBind()` does the actual calculation, instead of making
    you do it, as in `step3()`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步中，我们提供一个进一步的参数。（需要`null`值来提供上下文。如果它是附加到对象的方法，我们将该对象作为`.bind()`的第一个参数提供。由于这不是这种情况，所以期望是`null`。）这相当于我们的代码所做的事情，唯一的例外是最后一次，`curryByBind()`执行实际计算，而不是让您自己来做，就像`step3()`中一样。
- en: Testing this transformation is rather simple -- because there are not many possible
    ways of currying!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这个转换相当简单--因为柯里化的可能方式并不多！
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What else could you test? Maybe functions with just one parameter could be added,
    but there's no more to try.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还有什么可以测试的吗？也许可以添加只有一个参数的函数，但没有更多可以尝试的了。
- en: 'If we wanted to curry a function with a variable number of parameters, then
    using `fn.length` wouldn''t work; it only has a value for functions with a fixed
    number of parameters. We can solve this simply, by providing the desired number
    of arguments:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对具有可变参数数量的函数进行柯里化，那么使用`fn.length`是行不通的；它只对具有固定参数数量的函数有值。我们可以通过提供所需的参数数量来简单解决这个问题：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The new `curryByBind2()` function works as before, but instead of depending
    on `fn.length`, it works with the `len` parameter, which defaults to `fn.length`,
    for standard functions with a constant number of parameters. Notice that when
    `len` isn't 0, the returned function calls `curry2()` with `len-1` as its last
    argument -- this makes sense, because if one argument has just been fixed, then
    there is one fewer parameter left to fix.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`curryByBind2()`函数与以前的工作方式相同，但是不再依赖于`fn.length`，而是使用`len`参数，该参数默认为`fn.length`，用于具有恒定参数数量的标准函数。请注意，当`len`不为0时，返回的函数调用`curry2()`，并将`len-1`作为其最后一个参数--这是有道理的，因为如果一个参数刚刚被固定，那么剩下要固定的参数就会少一个。
- en: In our example, the `sum()` function can work with any number of parameters,
    and JavaScript informs us that `sum.length` is zero. However, when currying the
    function, if we set `len` to `5`, currying will be done as if `sum()` was a five-parameter
    function -- and the last line in the code listed above, shows that this is really
    the case.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`sum()`函数可以处理任意数量的参数，JavaScript告诉我们`sum.length`为零。然而，当对函数进行柯里化时，如果我们将`len`设置为`5`，柯里化将被视为`sum()`是一个五参数函数--代码中列出的最后一行显示这确实是这种情况。
- en: 'As before, testing is rather simple, given that we have no variants to try:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，测试是相当简单的，因为我们没有要尝试的变体：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We tested setting the arity of the curried function to 1, as a border case,
    but there are no more possibilities.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试了将柯里化函数的arity设置为1，作为边界情况，但没有更多的可能性。
- en: Currying with eval()
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用eval()进行柯里化
- en: 'There''s another interesting way of currying a function, by creating a new
    one by means of `eval()`... yes, that unsafe, dangerous, `eval()`! (Remember what
    we said earlier: this is for learning purposes, but you''ll be better off by avoiding
    the potential security headaches that `eval()` can bring!) We will also be using
    the `range()` function that we wrote in the *Working with ranges* section of [Chapter
    5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming Declaratively - A
    Better Style*.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种有趣的柯里化函数的方法，通过使用`eval()`创建一个新的函数... 是的，那个不安全的、危险的`eval()`！（记住我们之前说过的：这是为了学习目的，但最好避免`eval()`可能带来的潜在安全问题！）我们还将使用我们在[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)的*使用范围*部分编写的`range()`函数，*声明式编程-更好的风格*。
- en: Languages such as LISP have always had the possibility of generating and executing
    LISP code. JavaScript shares that functionality, but it's not often used -- mainly
    because of the dangers it may entail! However, in our case, since we want to generate
    new functions, it seems logical to take advantage of this neglected capability
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 像LISP这样的语言一直都有生成和执行LISP代码的可能性。JavaScript也共享了这一功能，但并不经常使用--主要是因为可能带来的危险！然而，在我们的情况下，由于我们想要生成新的函数，利用这种被忽视的能力似乎是合乎逻辑的。
- en: 'The idea is simple: in the *A bit of theory* section, earlier in this chapter,
    we saw that we could easily curry a function by using arrow functions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法很简单：在本章的*一点理论*部分中，我们看到我们可以通过使用箭头函数轻松地柯里化一个函数：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s apply a couple of changes to the second version, to rewrite it in a
    way that will help us, as you''ll see:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对第二个版本进行一些更改，以便以后能更好地帮助我们：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The needed code to generate this equivalent version is the following. We will
    be using the `range()` function we wrote back in the *Working with ranges* section
    of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming Declaratively
    - A Better Style*, to avoid needing to write an explicit loop:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 生成等效版本所需的代码如下。我们将使用我们在[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)的*使用范围*部分编写的`range()`函数，以避免需要编写显式循环：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is quite a chunk of code to digest and, in fact, it should rather be coded
    in several separate lines to make it more understandable. Let''s follow it, with
    the `make3()` function as input:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当多的代码需要消化，实际上，它应该被编码成几行分开来更容易理解。让我们以`make3()`函数作为输入来跟随它：
- en: The `range()` function produces an array with values `[0,1,2]`. If we don't
    provide a `len` argument, `make3.length` (that is, 3) will be used.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`range()`函数生成一个值为`[0,1,2]`的数组。如果我们不提供`len`参数，将使用`make3.length`（即3）。'
- en: We use `.map()` to generate a new array with values `["x0","x1","x2"]`.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`.map()`生成一个包含值`["x0","x1","x2"]`的新数组。
- en: We `join()` the values in that array to produce `x0=>x1=>x2`, which will be
    the beginning of the code that we will `eval()`.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`join()`将该数组中的值连接起来，生成`x0=>x1=>x2`，这将是我们将要`eval()`的代码的开头。
- en: 'We then add an arrow, the name of the function, and an opening parenthesis,
    to make the middle part of our newly generated code: `=> make3(`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们添加一个箭头，函数的名称和一个开括号，以使我们新生成的代码的中间部分：`=> make3(`。
- en: 'We use `range()`, `map()`, and `join()` again, but this time to generate a
    list of arguments: `x0,x1,x2`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们再次使用`range()`、`map()`和`join()`，但这次是为了生成参数列表：`x0,x1,x2`。
- en: 'We finally add a closing parenthesis, and after applying `eval()`, we get the
    curried version of `make3()`:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后我们添加一个闭括号，并在应用`eval()`之后，我们得到了`make3()`的柯里化版本：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There''s only one problem: if the original function didn''t have a name, the
    transformation wouldn''t work. (For more about that, check the *About Lambdas
    and functions* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*.) We could work around the function
    name problem by including the actual code of the function to be curried:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个问题：如果原始函数没有名称，转换就无法进行。（有关更多信息，请查看[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*关于Lambda和函数*部分，*从函数开始-核心概念*。）我们可以通过包含要柯里化的函数的实际代码来解决函数名称问题：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The only change is that instead of including the original function name, we
    substitute its actual code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的变化是，我们用实际的代码替换原始函数名：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The produced function is surprising, having a full function followed by its
    parameters -- but that''s actually valid JavaScript! All the following produce
    the same result:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的函数令人惊讶，有一个完整的函数后跟其参数--但这实际上是有效的JavaScript！所有以下都会产生相同的结果：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When you want to call a function, you write it, and follow with its arguments
    within parentheses -- so that's all we are doing, even if it looks weird!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想调用一个函数时，你写下它，并在括号内跟上它的参数--这就是我们正在做的，即使看起来有点奇怪！
- en: Partial application
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分应用
- en: The second transformation that we will be considering lets you fix some of the
    parameters of the function, creating a new function that will receive the rest
    of them. Let's make this clear with a nonsense example. Imagine you have a function
    with five parameters. You might want to fix the second and fifth parameters, and
    partial application would then produce a new version of the function that fixed
    those two parameters but left open the other three for new calls. If you called
    the resulting function with the three required arguments, it would produce the
    correct answer, by using the original two fixed parameters plus the newly provided
    three.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考虑的第二个转换允许你固定函数的一些参数，创建一个接收其余参数的新函数。让我们通过一个无意义的例子来澄清这一点。想象一下，你有一个有五个参数的函数。你可能想要固定第二个和第五个参数，部分应用将产生一个新版本的函数，固定这两个参数，但为新的调用留下其他三个。如果你用这三个必需的参数调用结果函数，它将使用原始的两个固定参数加上新提供的三个参数产生正确的答案。
- en: 'The idea of specifying only some of the parameters in function application,
    producing a function of the remaining parameters is called *projection*: you are
    said to be *projecting* the function onto the remaining arguments. We will not
    use this term, but we wanted to cite it, just in case you happen to find it somewhere
    else.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数应用中只指定一些参数，生成剩余参数的函数的想法被称为*投影*：你被认为是*投影*函数到剩余的参数上。我们不会使用这个术语，但我们想引用一下，以防你在其他地方找到它。
- en: Let's consider an example, using the `fetch()` API, which is widely considered
    to be the modern way to go for Ajax calls. You might want to fetch several resources,
    always specifying the same parameters for the call (for example, request headers)
    and only changing the URL to search. So, by using partial application, you could
    create a new `myFetch()` function that would always provide fixed parameters.
    Let's assume we have a `partial()` function that implements this kind of application
    and see how we'd use that.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，使用被广泛认为是现代Ajax调用的`fetch()` API。你可能想要获取多个资源，总是指定调用的相同参数（例如请求头），只改变搜索的URL。因此，通过部分应用，你可以创建一个新的`myFetch()`函数，它总是提供固定的参数。假设我们有一个实现这种应用的`partial()`函数，看看我们如何使用它。
- en: 'You can read more on `fetch()` at [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch),
    According to [http://caniuse.com/#search=fetch](http://caniuse.com/#search=fetch)
    you can use it in most browsers, except for (oh, surprise!) Internet Explorer...
    but you can go around this limitation with a polyfill, such as the one found at
    [https://github.com/github/fetch](https://github.com/github/fetch):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)上了解更多关于`fetch()`的信息。根据[http://caniuse.com/#search=fetch](http://caniuse.com/#search=fetch)的信息，你可以在大多数浏览器中使用它，除了（哦，惊讶！）Internet
    Explorer...但你可以通过polyfill绕过这个限制，比如在[https://github.com/github/fetch](https://github.com/github/fetch)找到的polyfill：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the request parameters had been the first argument for `fetch()`, currying
    would have worked. (We'll have more to say about the order of parameters later.)
    With partial application, you can replace any arguments, no matter which, so in
    this case `myFetch()` ends up as a unary function. This new function will get
    data from any URL you wish, always passing the same set of parameters for the
    `GET` operation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求参数是`fetch()`的第一个参数，柯里化就会起作用。（我们稍后会详细讨论参数的顺序。）通过部分应用，你可以替换任何参数，所以在这种情况下，`myFetch()`最终成为一个一元函数。这个新函数将从任何你希望的URL获取数据，始终传递相同的参数集合进行`GET`操作。
- en: Partial application with arrow functions
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数的部分应用
- en: 'Trying to do partial application by hand, as we did with currying, is too complicated,
    because, for a function with five parameters, you would have to write code that
    would allow the user to provide any of the 32 possible combinations of fixed and
    unfixed parameters (32 being equal to 2 raised to the fifth power) and even if
    you can simplify the problem, it will still remain hard to write and maintain.
    See Figure 7.2:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 手动进行部分应用，就像我们用柯里化一样，太复杂了，因为对于一个有五个参数的函数，你需要编写代码，允许用户提供32种可能的固定和未固定参数的组合（32等于5的2次方），即使你可以简化问题，编写和维护仍然很困难。见图7.2：
- en: '![](assets/1ef644da-2b9b-4a02-97d5-b1f111675bec.jpg)Figure 7.2\. Partial application
    may let you first provide some parameters, and then provide the rest, to finally
    get the result.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2。部分应用可能让你首先提供一些参数，然后提供其余的参数，最终得到结果。
- en: 'Doing partial application with arrow functions, however, is much simpler. With
    the example we were mentioning above, we would have something like the following
    code. In this case, we will assume we want to fix the second parameter to 22,
    and the fifth parameter to 1960:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用箭头函数进行部分应用要简单得多。对于上面提到的例子，我们会有以下代码。在这种情况下，我们假设我们想要将第二个参数固定为22，第五个参数固定为1960：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Doing partial application in this way is quite simple, though we may want to
    find a more general solution. You can fix any number of parameters, and all you
    do is create a new function out the previous one but fixing some more parameters.
    For instance, you might now want to also fix the last parameter of the new `fix2and5()`
    function to 9; nothing easier!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式进行部分应用是相当简单的，尽管我们可能想找到一个更一般的解决方案。你可以固定任意数量的参数，你所做的就是从之前的函数中创建一个新函数，但固定了更多的参数。例如，你现在可能还想将新的`fix2and5()`函数的最后一个参数固定为9；没有比这更容易的了！
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You might also have written `nonsense(a, 22, c, 9, 1960)`, if you wished to,
    but the fact remains that fixing parameters by using arrow functions is simple.
    Let's now consider, as we said, a more general solution.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你也可以写成`nonsense(a, 22, c, 9, 1960)`，但事实仍然是，使用箭头函数固定参数是简单的。现在让我们考虑一个更一般的解决方案。
- en: Partial application with eval()
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用eval()进行部分应用
- en: 'If we want to be able to do partial application fixing any combination of parameters,
    we must have a way to specify which arguments are to be left free and which will
    be fixed from that point on. Some libraries, such as Underscore or LoDash, use
    a special object, `_`, to signify an omitted parameter. In this fashion, still
    using the same `nonsense()` function, we would write the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要能够部分应用固定任意组合的参数，我们必须有一种方法来指定哪些参数将被保留，哪些将从那一点开始被固定。一些库，比如 Underscore 或
    LoDash，使用一个特殊对象 `_` 来表示省略的参数。以这种方式，仍然使用相同的 `nonsense()` 函数，我们将编写以下内容：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We could do the same sort of thing, by having a global variable that would represent
    a pending, not yet fixed argument, but let's make it simpler, and just write `undefined`
    to represent a missing parameter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用一个全局变量来表示一个待处理的、尚未固定的参数来做同样的事情，但让我们简化一下，只需写 `undefined` 来表示缺少的参数。
- en: When checking for undefined, remember to always use the `===` operator; with
    `==`, it happens that `null==undefined`, and you don't want that. See [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined)
    for more on this.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查未定义时，记得始终使用 `===` 运算符；使用 `==` 会导致 `null==undefined`，你不希望出现这种情况。请参阅 [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined)
    了解更多信息。
- en: 'We want to write a function that will partially apply some arguments and leave
    the rest open for the future. We want to write code similar to the following and
    produce a new function in the same fashion as we earlier did with arrow functions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要编写一个函数，部分应用一些参数，并将其余部分留给未来。我们想要编写类似以下的代码，并以与我们之前使用箭头函数相同的方式生成一个新函数：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can go back to using `eval()` and work out something like the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以回到使用 `eval()`，并想出类似以下的东西：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s break down this function step by step. Once again, we are using our
    `range()` function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地分解这个函数。我们再次使用我们的 `range()` 函数：
- en: '`rangeArgs` is an array with numbers from zero up to (but not including) the
    number of parameters in the input function.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rangeArgs` 是一个包含从零到输入函数的参数数量（不包括）的数字的数组。'
- en: '`leftList` is a string, representing the list of not applied variables. In
    our example, it would be `"X0,X2,X3"`, since we did provide values for the second
    and fifth arguments. This string will be used to generate the left part of the
    arrow function.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`leftList` 是一个字符串，表示未应用变量的列表。在我们的例子中，它将是 `"X0,X2,X3"`，因为我们为第二个和第五个参数提供了值。这个字符串将用于生成箭头函数的左部分。'
- en: '`rightList` is a string, representing the list of the parameters for the call
    to the provided function. In our case, it would be `"X0,''Z'',X2,X3,1960"`. We
    will use this string to generate the right part of the arrow function.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rightList` 是一个字符串，表示调用提供的函数的参数列表。在我们的例子中，它将是 `"X0,''Z'',X2,X3,1960"`。我们将使用这个字符串来生成箭头函数的右部分。'
- en: After having generated both lists, the remaining part of the code consists of
    just producing the appropriate string and giving it to `eval()` to get back a
    function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成了两个列表之后，代码的剩余部分只是生成适当的字符串，并将其传递给 `eval()` 以获得一个函数。
- en: If we were doing partial application on a function with a variable number of
    arguments, we could have substituted `args.length` for `fn.length`, or provided
    an extra (optional) parameter with the number to use, as we did in the currying
    section of this chapter.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对具有可变数量参数的函数进行部分应用，我们可以用 `args.length` 替换 `fn.length`，或者提供一个额外的（可选的）参数来指定要使用的数量，就像我们在本章的柯里化部分所做的那样。
- en: By the way, I deliberately expressed this function in this long way, to make
    it more clear. (We already saw somewhat similar, though shorter, code, when we
    did currying using `eval()`.) However, be aware that you might also find a shorter,
    more intense and obscure version... and that's the kind of code that gives FP
    a bad name!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我故意用这种冗长的方式来表达这个函数，以使其更清晰。（我们之前已经看到了类似的，虽然更短的代码，当我们使用 `eval()` 进行柯里化时。）然而，请注意，你可能会找到一个更短、更紧凑和更难理解的版本……这就是给函数式编程带来不好名声的代码！
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's finish this section by writing some tests. What are some things we should
    consider?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过编写一些测试来结束这一部分。我们应该考虑一些什么事情？
- en: When we do partial application, the arity of the produced function should decrease
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们进行部分应用时，生成的函数的参数个数应该减少。
- en: The original function should be called when arguments in correct order
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当参数按正确顺序传入时，应该调用原始函数。
- en: 'We could write something like the following, allowing for fixing arguments
    in different places. Instead of using a spy or mock, we can directly work with
    the `nonsense()` function we had because it''s quite efficient:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写类似以下的代码，允许在不同位置固定参数。我们可以直接使用 `nonsense()` 函数，而不是使用间谍或模拟，因为它非常高效：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We wrote a partial application higher-order function, but it's not as flexible
    as we would like. For instance, we can fix a few arguments in the first instance,
    but then we have to provide all the rest of the arguments in the next call. It
    would be better if, after calling `partialByEval()`, we got a new function, and
    if we didn't provide all needed arguments, we would get yet another function,
    and another, and so on, until all parameters had been provided -- somewhat along
    the lines of what happens with currying. So, let's change the way of doing partial
    application, and consider another solution.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个部分应用的高阶函数，但它并不像我们希望的那样灵活。例如，我们可以在第一次调用中固定一些参数，但然后我们必须在下一次调用中提供所有其余的参数。如果在调用
    `partialByEval()` 后，我们得到一个新函数，并且如果我们没有提供所有需要的参数，我们将得到另一个函数，以此类推，直到所有参数都被提供——这与柯里化的情况有些类似。因此，让我们改变部分应用的方式，并考虑另一个解决方案。
- en: Partial application with closures
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用闭包进行部分应用
- en: 'Let''s examine yet another way of doing partial application, which will behave
    in a fashion somewhat reminiscent of the `curry()` functions we wrote earlier
    in this chapter, and solve the deficiency we mentioned at the end of the previous
    section:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一种进行部分应用的方式，它的行为方式有点像我们在本章前面写的`curry()`函数，并解决了我们在上一节末尾提到的不足：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Wow, a longish bit of code! The key is the inner function `partialize()`. Given
    a list of parameters (`args1`), it produces a function that receives a second
    list of parameters (`args2`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，一大段代码！关键在于内部函数`partialize()`。给定一个参数列表（`args1`），它生成一个接收第二个参数列表（`args2`）的函数：
- en: First, it replaces all possible undefined values in `args1` with values from
    `args2`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它用`args2`中的值替换`args1`中所有可能的未定义值。
- en: Then, if any parameters are left in `args2`, it also appends them to those of
    `args1`, producing `allParams`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，如果`args2`中还有任何参数，它也会将它们附加到`args1`的参数中，生成`allParams`。
- en: Finally, if that list of arguments does not include any more undefined values,
    and it is sufficiently long, it calls the original function
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果参数列表中不再包含任何未定义值，并且足够长，它就会调用原始函数。
- en: Otherwise, it partializes itself, to wait for more parameters
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它会部分化自身，等待更多的参数。
- en: 'An example will make it more clear. Let''s go back to our trusty `make3()`
    function and we construct a partial version of it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子会更清楚。让我们回到我们可靠的`make3()`函数，并构建它的一个部分版本：
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we write a second function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们写一个第二个函数：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'What happens? The original list of parameters (`[undefined, 4]`) gets merged
    with the new list (a single element, in this case, `[7]`), producing a function
    that now receives `7` and `4` as its first two arguments. However, this isn''t
    yet ready, because the original function requires three arguments. If we now were
    to write:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？原始参数列表（`[undefined, 4]`）与新列表（在这种情况下是一个单一元素，`[7]`）合并，生成一个现在接收`7`和`4`作为它的前两个参数的函数。然而，这还不够，因为原始函数需要三个参数。如果我们现在写：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then the current list of arguments would be merged with the new argument, producing
    `[7,4,9]`. Since the list is now complete, the original function will be evaluated,
    producing `749` as the final result.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当前的参数列表将与新参数合并，生成`[7,4,9]`。由于列表现在是完整的，原始函数将被评估，产生`749`作为最终结果。
- en: 'There are important similarities between the structure of this code, and the
    other higher-order function we earlier wrote in the *Currying with* `bind()` section:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的结构与我们之前在*使用`bind()`进行柯里化*部分写的另一个高阶函数有重要的相似之处。
- en: If all the arguments have been provided, the original function is called
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有参数都已经提供，原始函数就会被调用。
- en: If some arguments are still required (when currying, it's just a matter of counting
    arguments; when doing partial application, you must also consider the possibility
    of having some undefined parameters) the higher-order function calls itself to
    produce a new version of the function, that will *wait* for the missing arguments
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果还需要一些参数（在柯里化时，只是简单地计算参数的数量；在进行部分应用时，你还必须考虑可能存在一些未定义的参数），那么高阶函数会调用自身来生成函数的新版本，这个新版本将*等待*缺失的参数。
- en: 'Let''s finish by writing some tests that will show the enhancements in our
    new way of doing partial application. Basically, all the tests we did earlier
    would work, but we must also try out applying arguments in sequence, so we should
    get the final result after two or more steps of applications. However, since we
    can now call our intermediate functions with any number of parameters, we cannot
    test arities: for all functions, `function.length===0`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最后写一些测试，展示我们新的部分应用方式的增强。基本上，我们之前做的所有测试都会生效，但我们还必须尝试按顺序应用参数，这样我们应该在两个或更多步骤的应用之后得到最终结果。然而，由于我们现在可以用任意数量的参数调用我们的中间函数，我们无法测试参数个数：对于所有函数，`function.length===0`：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The code is longer than before, but the tests themselves are easy to understand.
    The next-to-last test should remind you of currying, by the way!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 代码比以前长了，但测试本身很容易理解。倒数第二个测试应该会让你想起柯里化！
- en: Partial currying
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分柯里化
- en: The last transformation we will see is a sort of mixture of currying and partial
    application. If you google around, in some places you find it called *currying*,
    and in others, *partial application*, but as it happens, it fits neither... so
    I'm sitting on the fence and calling it *partial currying*!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个我们将看到的转换是柯里化和部分应用的混合。如果你在网上搜索一下，在一些地方你会发现它被称为*柯里化*，在其他地方被称为*部分应用*，但事实上，它都不太符合……所以我还在犹豫不决，称它为*部分柯里化*！
- en: 'The idea of this is, given a function, to fix its first few arguments, and
    produce a new function that will receive the rest of them. However, if that new
    function is given fewer arguments, it will fix whatever it was given and produce
    a newer function, to receive the rest of them, until all the arguments are given
    and the final result can be calculated. See Figure 7.3:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，给定一个函数，固定它的前几个参数，并生成一个新的函数来接收其余的参数。然而，如果给这个新函数传递的参数较少，它将固定它所接收到的参数，并生成一个新的函数来接收其余的参数，直到所有参数都被给出并且最终结果可以被计算出来。参见图7.3：
- en: '![](assets/ecea9d60-7d5b-473c-ad50-6312384c1036.jpg)Figure 7.3\. "Partial currying"
    is a mixture of currying and partial application. You may provide arguments from
    the left, in any quantity, until all have been provided, and then the result is
    calculated.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3。"部分柯里化"是柯里化和部分应用的混合。你可以提供任意数量的参数，直到所有参数都被提供，然后计算结果。
- en: 'To see an example, let''s go back to the `nonsense()` function we have been
    using in previous sections. Assume we already have a `partialCurry()` function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明，让我们回到我们在之前部分中一直在使用的`nonsense()`函数。假设我们已经有了一个`partialCurry()`函数：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The original function had an arity 5\. When we *partial curry* that function,
    and give it arguments 9 and 22, it becomes a ternary function, because out of
    the original five parameters, two have become fixed. If we take that ternary function
    and give it a single argument (60), the result is yet another function: in this
    case, a binary one, because now we have fixed the first three of the original
    five parameters. The final call, providing the last two arguments, then does the
    job of actually calculating the desired result.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 原始函数的参数个数为5。当我们*部分柯里化*该函数，并给它参数9和22时，它变成了一个三元函数，因为在原始的五个参数中，有两个已经固定。如果我们拿到这个三元函数并给它一个参数（60），结果就是另一个函数：在这种情况下，是一个二元函数，因为现在我们已经固定了原始五个参数中的前三个。最后一次调用，提供最后两个参数，然后执行实际计算所需的结果。
- en: 'There are some points in common with currying and partial application, but
    also some differences:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化和部分应用有一些共同点，但也有一些不同之处：
- en: The original function is transformed into a series of functions, each of which
    produces the next one, until the last in the series actually carries out its calculations.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始函数被转换为一系列函数，每个函数产生下一个函数，直到系列中的最后一个实际执行其计算。
- en: You always provide parameters starting from the first one (the leftmost one),
    as in currying, but you can provide more than one, as in partial application.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您始终从第一个参数（最左边的参数）开始提供参数，就像柯里化一样，但您可以像部分应用一样提供多个参数。
- en: When currying a function, all the intermediate functions are unary, but with
    partial currying that needs not be so. However, if on each instance we were to
    provide a single argument, then the result would require as many steps as plain
    currying.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在柯里化函数时，所有中间函数都是一元的，但部分柯里化则不需要如此。然而，如果在每个实例中我们提供一个参数，那么结果将需要与普通柯里化一样多的步骤。
- en: So, we have our definition -- let's now see how we can implement our new higher-order
    function; we'll probably be reusing a few concepts from the previous sections
    in this chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有了我们的定义--现在让我们看看如何实现我们的新高阶函数；我们可能会在本章的这一部分中重复使用前几节中的一些概念。
- en: Partial currying with bind()
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用bind()进行部分柯里化
- en: 'Similar to what we did with currying, there''s a simple way to do partial currying.
    We will take advantage of the fact that `.bind()` can actually fix many arguments
    at once:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们对柯里化所做的类似，有一种简单的方法可以进行部分柯里化。我们将利用`.bind()`实际上可以一次固定多个参数的事实：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Compare the code to the previous `curryByBind()` function and you''ll see the
    very small differences:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码与之前的`curryByBind()`函数进行比较，您会看到非常小的差异：
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The mechanism is exactly the same. The only difference is that in our new function,
    we can bind many arguments at the same time, while in `curryByBind()` we always
    bind just one. We can revisit our earlier example -- and the only difference is
    that we can get the final result in fewer steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 机制完全相同。唯一的区别是在我们的新函数中，我们可以同时绑定多个参数，而在`curryByBind()`中我们总是只绑定一个。我们可以重新访问我们之前的例子--唯一的区别是我们可以在更少的步骤中得到最终结果：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'By the way, and just to be aware of the existing possibilities, you can fix
    some parameters when currying:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，只要意识到现有的可能性，您可以在柯里化时固定一些参数：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Testing this function is easy and the examples we provided are a very good
    starting point. Note, however, that since we allow fixing any number of arguments,
    we cannot test the arity of the intermediate functions:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 测试这个函数很容易，我们提供的例子是一个很好的起点。但是，请注意，由于我们允许固定任意数量的参数，我们无法测试中间函数的参数个数：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s consider functions with a variable number of parameters. As before,
    we''ll have to provide an extra value:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑具有可变参数数量的函数。与以前一样，我们将不得不提供额外的值：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can try this out in a simple way, revisiting our currying example from some
    pages earlier:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以一种简单的方式尝试这一点，重新访问一些页面前的柯里化示例：
- en: '[PRE43]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The new `pcSum5()` function first collected two arguments (1,5) and produced
    a new function that expected three more. One single parameter was given (3) and
    a third function was created, to wait for the last two. When those two (7,4) were
    provided, the original function was called, to calculate the result (20).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`pcSum5()`函数首先收集了两个参数（1,5），并产生了一个期望另外三个参数的新函数。给定了一个单一参数（3），并创建了第三个函数，等待最后两个参数。当提供了这两个参数（7,4）时，原始函数被调用，计算结果为（20）。
- en: 'We can also add some tests for this alternate way of doing partial currying:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为这种替代的部分柯里化添加一些测试：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Trying out different arities is better than sticking to just one, so we did
    that for variety.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试不同的参数个数比坚持只使用一个更好，所以我们为了多样性而这样做了。
- en: Partial currying with closures
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用闭包进行部分柯里化
- en: 'As with partial application, there''s a solution that works with closures:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与部分应用一样，有一种使用闭包的解决方案：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If you compare `partialCurryByClosure()` and `partialByClosure()`, the main
    difference is that with partial currying, since we are always providing arguments
    from the left, and there is no way to skip some, you concatenate whatever arguments
    you had with the new ones, and check whether you got enough. If the new list of
    arguments has reached the expected arity of the original function, you can call
    it, and get the final result. In other cases, you just use `curryize()` to get
    a new intermediate function, that will wait for more arguments.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您比较`partialCurryByClosure()`和`partialByClosure()`，主要区别在于部分柯里化，因为我们总是从左边提供参数，没有办法跳过一些参数，您将之前的任何参数与新参数连接起来，并检查是否已经足够。如果新的参数列表达到了原始函数的预期参数个数，您可以调用它，并得到最终结果。在其他情况下，您只需使用`curryize()`来获得一个新的中间函数，等待更多的参数。
- en: 'As earlier, if you have to deal with functions with a varying number of parameters,
    you can provide an extra argument to the partial currying function:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前一样，如果您必须处理具有不同数量参数的函数，您可以为部分柯里化函数提供额外的参数：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The results are exactly the same as in the previous section, *Partial currying
    by bind*, so it's not worth repeating them. You could also easily change the tests
    we wrote to use `partialCurryByClosure()` instead of `partialCurryByBind()` and
    they would work.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与上一节的*通过bind进行部分柯里化*完全相同，因此不值得重复。您还可以轻松地更改我们编写的测试，使用`partialCurryByClosure()`而不是`partialCurryByBind()`，它们也可以正常工作。
- en: Final thoughts
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的想法
- en: 'Let''s finish this chapter with two more philosophical considerations regarding
    currying and partial application, which may cause a bit of a discussion:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以两个更多的关于柯里化和部分应用的哲学考虑来结束这一章，这可能会引起一些讨论：
- en: First, that many libraries are just wrong as to the order of their parameters,
    making them harder to use
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，许多库在参数顺序上都是错误的，使它们更难使用
- en: Second, that I don't usually even use the higher-order functions in this chapter,
    going for simpler JS code!
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我通常甚至不使用本章中的高阶函数，而是使用更简单的JS代码！
- en: That's not probably what you were expecting by this time, so let's go over those
    two points in more detail, so you'll see it's not a matter of *do as I say, not
    as I do* or *as the libraries do*!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不是您此时所期望的，所以让我们更详细地讨论这两点，这样您就会看到这不是*我说什么，我做什么*或*库所做的*的问题！
- en: Parameter order
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数顺序
- en: 'There''s a problem that''s common to not only functions such as Underscore''s
    or LoDash''s `_.map(list, mappingFunction)` or `_.reduce(list, reducingFunction,
    initialValue)`, but also to some that we have produced in this book, as the result
    of `demethodize()`, for example. (See the *Demethodizing: turning methods into
    functions* section of [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*, to review that higher-order function.)
    The problem is that the *order* of their parameters doesn''t really help with
    currying.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '不仅如此，这个问题不仅存在于Underscore或LoDash的`_.map(list, mappingFunction)`或`_.reduce(list,
    reducingFunction, initialValue)`等函数中，还存在于我们在本书中生成的一些函数中，比如`demethodize()`的结果。
    （请参阅[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)的*Demethodizing: turning
    methods into functions*部分，以回顾高阶函数。）问题在于它们的参数*顺序*并不能真正帮助柯里化。'
- en: 'When currying a function, you will probably want to store intermediate results.
    When we do something like in the code below, we assume that you are going to reuse
    the curried function with the fixed argument and that means that the first argument
    to the original function is the least likely to change. Let''s now consider a
    specific case. Answer this question: what''s more likely -- that you''ll use `map()`
    to apply the same function to several different arrays, or that you''ll apply
    several different functions to the same array? With validations or transformations,
    the former is more likely... but that''s not what we get!'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在柯里化函数时，您可能希望存储中间结果。当我们像下面的代码一样做某事时，我们假设您将重用带有固定参数的柯里化函数，这意味着原始函数的第一个参数最不可能改变。现在让我们考虑一个具体的情况。回答这个问题：更可能的是——您将使用`map()`将相同的函数应用于几个不同的数组，还是将几个不同的函数应用于相同的数组？对于验证或转换，前者更有可能……但这并不是我们得到的结果！
- en: 'We can write a simple function to flip the parameters for a binary function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个简单的函数来翻转二元函数的参数：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that even if the original `fn()` function could receive more or fewer arguments,
    after applying `flipTwo()` to it, the arity of the resulting function will be
    fixed to 2\. We will be taking advantage of this fact in the following section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使原始的`fn()`函数可以接收更多或更少的参数，但在将`flipTwo()`应用于它之后，结果函数的arity将固定为2。我们将在接下来的部分中利用这一事实。
- en: 'With this, you could then write code as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，您可以按照以下方式编写代码：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The most common case of use is that you'll want to apply the function to several
    different lists, and neither the library functions nor our own *demethodized*
    ones provide for that. However, by using `flipTwo()`, we can work in the fashion
    we would prefer.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的使用情况是您希望将函数应用于几个不同的列表，无论是库函数还是我们自己的*demethodized*函数都无法提供这种功能。然而，通过使用`flipTwo()`，我们可以按照我们希望的方式工作。
- en: In this particular case, we might have solved our problem by using partial application
    instead of currying, because with that we could fix the second argument to `map()`
    without any further bother. However, flipping arguments to produce new functions
    that have a different order of parameters is also an often-used technique, and
    I thought it important that you should be aware of it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种特殊情况下，我们可能已经通过使用部分应用来解决了我们的问题，而不是柯里化，因为这样我们就可以固定`map()`的第二个参数而不需要进一步的麻烦。然而，翻转参数以产生具有不同参数顺序的新函数也是一种经常使用的技术，我认为你应该意识到这一点很重要。
- en: 'For situations such as with `.reduce()`, which usually receives three arguments
    (the list, the function, and the initial value), we may opt for this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`.reduce()`这样通常接收三个参数（列表、函数和初始值）的情况，我们可以选择这样做：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: I used partial currying, to simplify the expression for `sumAll()`. The alternative
    would have been using common currying, and then I would have defined `sumAll =
    myReduce(sum)(0)`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了部分柯里化，简化了`sumAll()`的表达式。另一种选择是使用常规柯里化，然后我会定义`sumAll = myReduce(sum)(0)`。
- en: If you want, you can also go for more esoteric parameter rearranging functions,
    but you usually won't need more than these two. For really complex situations,
    you may rather opt for using arrow functions (as we did when defining `flipTwo()`
    and `flip3()`) and make it clear what kind of reordering you need.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您也可以选择更神秘的参数重新排列函数，但通常您不需要更多的这两种。对于真正复杂的情况，您可能更愿意使用箭头函数（就像我们在定义`flipTwo()`和`flip3()`时所做的那样），并明确说明您需要哪种重新排序。
- en: Being functional
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能性
- en: 'Now that we are nearing the end of this chapter, a confession is in order:
    I do not always use currying and partial application as shown above! Don''t misunderstand
    me, I *do* apply those techniques -- but sometimes it makes for longer, less clear,
    not necessarily better code. Let me show you what I''m talking about.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们接近本章的结束，有一个坦白的话要说：我并不总是像上面所示的那样使用柯里化和部分应用！不要误会我，我确实应用这些技术 -- 但有时它会导致更长、不太清晰、不一定更好的代码。让我向您展示我在说什么。
- en: 'If I''m writing my own function, and then I want to curry it in order to fix
    the first parameter, currying (or partial application, or partial currying) doesn''t
    really make a difference, in comparison to arrow functions. I''d have to write
    the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我正在编写自己的函数，然后想要对其进行柯里化以固定第一个参数，与箭头函数相比，柯里化（或部分应用，或部分柯里化）并不真的有什么区别。我将不得不编写以下内容：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Currying the function, and giving it a first parameter, all in the same line,
    may be considered not so clear; the alternative calls for an added variable and
    one more line of code. Later, the future call isn''t so good, either; however,
    partial currying makes it simpler: `myPartiallyCurriedFunction(second_argument,
    third_argument)`. In any case, when I compare the final code with the usage of
    arrow functions, I think the other solutions aren''t really better:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化函数，并在同一行给它一个第一个参数，可能被认为不太清晰；另一种调用需要一个额外的变量和一行代码。稍后，未来的调用也不太好；然而，部分柯里化使它更简单：`myPartiallyCurriedFunction(second_argument,
    third_argument)`。无论如何，当我将最终代码与箭头函数的使用进行比较时，我认为其他解决方案并不真的更好：
- en: '[PRE51]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Where I do think that currying and partial application is quite good is in
    my small library of demethodized, pre-curried, basic higher-order functions. I
    have my own set of functions such as the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为柯里化和部分应用非常好的地方在于我的小型库中的去方法化、预柯里化的基本高阶函数。我有自己的一组函数，如下所示：
- en: '[PRE52]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here are some points to note about the code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是有关代码的一些要点：
- en: I have these functions in a separate module, and I only export the `myXXX()`
    named ones.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将这些函数放在一个单独的模块中，并且只导出`myXXX()`命名的函数。
- en: The other functions are private, and I use the leading underscore to remind
    me of that.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他函数是私有的，我使用前导下划线来提醒我这一点。
- en: I use the `my...` prefix to remember that these are *my* functions and not the
    normal JavaScript ones. Some people would rather keep the standard names such
    as `map()` or `filter()`, but I prefer distinct names.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我使用`my...`前缀来记住这些是*我的*函数，而不是正常的JavaScript函数。有些人可能更愿意保留标准名称，如`map()`或`filter()`，但我更喜欢不同的名称。
- en: Since most of the JavaScript methods have a variable arity, I had to specify
    it when currying.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于大多数JavaScript方法具有可变的arity，我在进行柯里化时必须指定它。
- en: I always provide the third argument (initial value for reducing) to `.reduce()`,
    so the arity I chose for that function is three.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我总是为`.reduce()`提供第三个参数（用于减少的初始值），因此我为该函数选择的arity是三。
- en: When currying the flipped functions, you don't need to specify the number of
    parameters, because flipping already does that for you.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对翻转函数进行柯里化时，您不需要指定参数的数量，因为翻转已经为您做到了。
- en: In the end, it all comes down to a personal decision; experiment with the techniques
    that we saw in this chapter and see which ones you prefer!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这完全取决于个人决定；尝试本章中所见的技术，并看看您更喜欢哪些！
- en: Questions
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '7.1\. **Sum as you will**. The following exercise will help you understand
    some of the concepts we dealt with above, even if you solve it without using any
    of the functions we saw in the chapter. Write a `sumMany()` function that lets
    you sum an indeterminate quantity of numbers, in the following fashion. Note that
    when the function is called with no arguments, the sum is returned:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 7.1\. **随心所欲地求和**。以下练习将帮助您理解我们上面讨论的一些概念，即使您在不使用我们在本章中看到的任何函数的情况下解决它。编写一个`sumMany()`函数，让您以以下方式对不定数量的数字求和。请注意，当不带参数调用该函数时，将返回总和：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '7.2\. **Working stylishly**. Write an `applyStyle()` function that will let
    you apply basic styling to strings, in the following way. Use either currying
    or partial application:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 7.2\. **时尚工作**。编写一个`applyStyle()`函数，让您以以下方式对字符串应用基本样式。使用柯里化或部分应用：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '7.3\. **Currying by prototype**. Modify `Function.prototype` to provide a `.curry()`
    method, that will work like the `curry()` function we saw in the text. Completing
    the code below should produce the following results:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 7.3\. **原型柯里化**。修改`Function.prototype`以提供一个`.curry()`方法，该方法将像我们在文本中看到的`curry()`函数一样工作。完成下面的代码应该产生以下结果：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 7.4\. **Uncurrying the curried**. Write a function `unCurry(fn,arity)` that
    receives as arguments a (curried) function and its expected arity, and returns
    an uncurried version of `fn()`; that is, a function that will receive *n* arguments
    and produce a result. (Providing the expected arity is needed because you have
    no way of determining it on your own.)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 7.4\. **取消柯里化**。编写一个函数`unCurry(fn,arity)`，它接收一个（柯里化的）函数和其预期的arity作为参数，并返回`fn()`的一个非柯里化版本；也就是说，一个将接收*n*个参数并产生结果的函数。（提供预期的arity是必要的，因为您无法自行确定它。）
- en: '[PRE56]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Summary
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have considered a new way of producing functions, by fixing
    the arguments to an existing function in several different ways: currying, a theoretical
    way; partial application, with more flexibility; and partial currying, which combines
    good aspects from both previous methods. Using these transformations, you can
    simplify your coding, because you can generate more specialized versions of general
    functions, without any hassle.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们考虑了一种新的生成函数的方式，即通过多种不同的方式固定现有函数的参数：柯里化，一种理论方式；部分应用，更灵活；以及部分柯里化，结合了前两种方法的优点。使用这些转换，您可以简化编码，因为您可以生成更专门的通用函数版本，而无需任何麻烦。
- en: In [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions
    - Pipelining and Composition*, we will turn back to some concepts we saw in the
    chapter on pure functions, and we will be considering ways of ensuring that functions
    cannot become *impure by accident*, by seeking for ways to make their arguments
    immutable, making them impossible to mutate.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)中，*连接函数 - 管道和组合*，我们将回顾一些我们在纯函数章节中看到的概念，并考虑确保函数不会因为意外变得*不纯*的方法，通过寻找使它们的参数不可变的方式，使它们不可能被改变。
