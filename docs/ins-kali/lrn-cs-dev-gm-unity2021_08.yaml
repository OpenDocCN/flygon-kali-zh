- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Scripting Game Mechanics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本化游戏机制
- en: In the last chapter, we focused on using code to move the player and camera,
    with a trip into Unity physics on the side. However, controlling a playable character
    isn't enough to make a compelling game; in fact, it's probably the one area that
    remains fairly constant across different titles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们专注于使用代码移动玩家和摄像机，并在旁边进行了Unity物理的探索。然而，控制可玩角色并不足以制作一个引人入胜的游戏；事实上，这可能是在不同游戏中保持相对恒定的一个领域。
- en: A game's unique spark comes from its core mechanics, and the feeling of power
    and agency those mechanics give to the players. Without fun and engrossing ways
    to affect the virtual environment you've created, your game doesn't stand a chance
    of repeat play, to say nothing of fun. As we venture into implementing the game's
    mechanics, we'll also be upgrading our knowledge of C# and its intermediate-level
    features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的独特魅力来自其核心机制，以及这些机制赋予玩家的力量和代理感。如果没有有趣和引人入胜的方式来影响你所创建的虚拟环境，你的游戏就没有重复玩的机会，更不用说有趣了。当我们着手实现游戏机制时，我们也将提升我们对C#及其中级特性的了解。
- en: 'This chapter will build on the *Hero Born* prototype by focusing on individually
    implemented game mechanics, as well as the basics of system design and **user
    interfaces** (**UIs**). You''ll be diving into the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将在*英雄诞生*原型的基础上，重点关注单独实现的游戏机制，以及系统设计和用户界面（UI）。你将深入以下主题：
- en: Adding jumps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加跳跃
- en: Shooting projectiles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 射击抛射物
- en: Creating a game manager
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建游戏管理器
- en: Creating a GUI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建GUI
- en: Adding jumps
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加跳跃
- en: Remember from the last chapter that Rigidbody components add simulated real-world
    physics to GameObjects, and Collider components interact with each other using
    Rigidbody objects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得上一章中Rigidbody组件为游戏对象添加了模拟真实世界物理，Collider组件使用Rigidbody对象相互交互的内容。
- en: Another great thing that we didn't discuss in the previous chapter about using
    a Rigidbody component to control player movement is that we can easily add in
    different mechanics that rely on applied force, such as jumping. In this section,
    we'll get our player jumping and write our first utility function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章没有讨论的另一个很棒的事情是，使用Rigidbody组件来控制玩家移动，我们可以很容易地添加依赖于施加力的不同机制，比如跳跃。在本节中，我们将让玩家跳跃，并编写我们的第一个实用函数。
- en: A utility function is a class method that performs some kind of grunt work so
    that we don't clutter up gameplay code—for instance, wanting to check whether
    the player capsule is touching the ground to jump.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实用函数是执行某种繁重工作的类方法，这样我们就不会在游戏代码中弄乱了——比如，想要检查玩家胶囊是否接触地面以进行跳跃。
- en: Before that, you'll need to get acquainted with a new data type called enumerations,
    which you'll do in the following section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，你需要熟悉一种称为枚举的新数据类型，你将在下一节中进行。
- en: Introducing enumerations
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入枚举
- en: By definition, an enumeration type is a set, or collection, of named constants
    that belong to the same variable. These are useful when you want a collection
    of different values, but with the added benefit of them all being of the same
    parent type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，枚举类型是属于同一变量的一组或集合命名常量。当你想要一组不同值的集合，但又希望它们都属于相同的父类型时，这些是很有用的。
- en: 'It''s easier to show rather than tell with enumerations, so let''s take a look
    at their syntax in the following code snippet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举更容易通过展示而不是告诉来理解，所以让我们看一下以下代码片段中它们的语法。
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s break down how this works, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下它是如何工作的，如下所示：
- en: The `enum` keyword declares the type followed by the variable name.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum`关键字声明了类型，后面跟着变量名。'
- en: The different values an enum can have are written inside curly brackets, separated
    by a comma (except for the last item).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举可以具有的不同值写在花括号内，用逗号分隔（最后一项除外）。
- en: The `enum` has to end with a semicolon, just like all other data types we've
    worked with.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enum`必须以分号结尾，就像我们处理过的所有其他数据类型一样。'
- en: In this case, we're declaring a variable called `PlayerAction`, of type `enum`,
    which can be set to one of three values—`Attack`, `Defend`, or `Flee`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们声明了一个名为`PlayerAction`的变量，类型为`enum`，可以设置为三个值之一——`Attack`、`Defend`或`Flee`。
- en: 'To declare an enumeration variable, we use the following syntax:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个枚举变量，我们使用以下语法：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Again, we can break this down, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以将其分解如下：
- en: The type is set as `PlayerAction`, since our enumeration is just like any other
    type, like a string or integer.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型设置为`PlayerAction`，因为我们的枚举就像任何其他类型一样，比如字符串或整数。
- en: The variable is named `currentAction` and set equal to a `PlayerAction` value.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名为`currentAction`，设置为`PlayerAction`值。
- en: Each enum constant can be accessed using dot notation.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个枚举常量都可以使用点表示法访问。
- en: Our c`urrentAction` variable is now set to `Defend`, but it can be changed to
    `Attack` or `Flee` at any time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`currentAction`变量现在设置为`Defend`，但随时可以更改为`Attack`或`Flee`。
- en: Enumerations may look simple at first glance, but they are extremely powerful
    in the right situations. One of their most useful features is the ability to store
    underlying types, which is the next subject you'll be jumping into.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举乍看起来可能很简单，但在适当的情况下它们非常强大。它们最有用的特性之一是能够存储底层类型，这也是你将要学习的下一个主题。
- en: Underlying types
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 底层类型
- en: Enums come with an *underlying type*, meaning that each constant inside the
    curly brackets has an associated value. The default underlying type is `int` and
    starts at 0, just like arrays, with each sequential constant getting the next
    highest number.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举带有*底层类型*，意味着花括号内的每个常量都有一个关联值。默认的底层类型是`int`，从0开始，就像数组一样，每个连续的常量都得到下一个最高的数字。
- en: Not all types are created equal—underlying types for enumerations are limited
    to `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, and `ulong`. These
    are called integral types, which are used to specify the size of numeric values
    that a variable can store.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有类型都是平等的——枚举的底层类型限制为`byte`、`sbyte`、`short`、`ushort`、`int`、`uint`、`long`和`ulong`。这些被称为整数类型，用于指定变量可以存储的数值的大小。
- en: 'This is a bit advanced for this book, but you''ll be using `int` in most cases.
    More information on these types can be found here: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于本书来说有点高级，但在大多数情况下，您将使用`int`。有关这些类型的更多信息可以在这里找到：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/enum)。
- en: 'For example, our `PlayerAction` enumeration values right now are listed as
    follows, even though they aren''t explicitly written out:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的`PlayerAction`枚举值现在列出如下，尽管它们没有明确写出：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There''s no rule that says underlying values need to start at `0`; in fact,
    all you have to do is specify the first value and then C# increments the rest
    of the values for us, as illustrated in the following code snippet:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 没有规定基础值需要从`0`开始；实际上，您只需要指定第一个值，然后C#会为我们递增其余的值，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, `Defend` equals `6`, and `Flee` equals `7` automatically.
    However, if we wanted the `PlayerAction` enum to hold non-sequential values, we
    could explicitly add them in, like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`Defend`等于`6`，`Flee`等于`7`。但是，如果我们希望`PlayerAction`枚举包含非连续的值，我们可以显式添加它们，就像这样：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can even change the underlying type of `PlayerAction` to any of the approved
    types by adding a colon after the enum name, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过在枚举名称后添加冒号来将`PlayerAction`的基础类型更改为任何经批准的类型，如下所示：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Retrieving an enum''s underlying type takes an explicit conversion, but we''ve
    already covered those, so the following syntax shouldn''t be a surprise:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 检索枚举的基础类型需要显式转换，但我们已经涵盖了这些内容，所以下面的语法不应该让人感到意外：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since `CurrentAction` is set to `Attack`, `ActionCost` would be `10` in the
    above example code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CurrentAction`设置为`Attack`，在上面的示例代码中，`ActionCost`将是`10`。
- en: Enumerations are extremely powerful tools in your programming arsenal. Your
    next challenge is to use your knowledge of enumerations to gather more specific
    user input from the keyboard.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是您编程工具中非常强大的工具。您下一个挑战是利用您对枚举的了解，从键盘上收集更具体的用户输入。
- en: 'Now that we have a basic grasp of enumeration types, we can capture keyboard
    input using the `KeyCode` enum. Update the `PlayerBehavior` script with the following
    highlighted code, save it, and hit play:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经基本掌握了枚举类型，我们可以使用`KeyCode`枚举来捕获键盘输入。更新`PlayerBehavior`脚本，添加以下突出显示的代码，保存并点击播放：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s break down this code, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解这段代码：
- en: First, we create two new variables—a public variable to hold the amount of applied
    jump force we want and a private boolean to check if our player should be jumping.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建两个新变量——一个公共变量来保存我们想要应用的跳跃力量的数量，一个私有布尔变量来检查我们的玩家是否应该跳跃。
- en: We set the value of `_isJumping` to the `Input.GetKeyDown()` method, which returns
    a `bool` value depending on whether a specified key is pressed.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`_isJumping`的值设置为`Input.GetKeyDown()`方法，根据指定的键是否被按下返回一个`bool`值。
- en: We use the `|=` operator to set `_isJumping`, which is the logical `or` condition.
    This operator makes sure that we don't have consecutive input checks override
    each other when the player is jumping.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`|=`运算符来设置`_isJumping`，这是逻辑`或`条件。该运算符确保当玩家跳跃时，连续的输入检查不会互相覆盖。
- en: The method accepts a key parameter as either a `string` or a `KeyCode`, which
    is an enumeration type. We specify that we want to check for `KeyCode.Space`.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法接受一个键参数，可以是`string`或`KeyCode`，它是一个枚举类型。我们指定要检查`KeyCode.Space`。
- en: Checking for inputs in `FixedUpdate` can sometimes lead to input loss or even
    double inputs because it doesn't run once per frame. This is why we're checking
    for inputs in `Update` and then applying force or setting the velocity in `FixedUpdate`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FixedUpdate`中检查输入有时会导致输入丢失，甚至会导致双重输入，因为它不是每帧运行一次。这就是为什么我们在`Update`中检查输入，然后在`FixedUpdate`中应用力或设置速度。
- en: We use an `if` statement to check if `_isJumping` is true, and trigger the jump
    mechanic if it is.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`if`语句来检查`_isJumping`是否为真，并在其为真时触发跳跃机制。
- en: Since we already have the Rigidbody component stored, we can pass the `Vector3`
    and `ForceMode` parameters to `RigidBody.AddForce()` and make the player jump.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经存储了Rigidbody组件，我们可以将`Vector3`和`ForceMode`参数传递给`RigidBody.AddForce()`，使玩家跳跃。
- en: We specify that the vector (or applied force) should be in the `up` direction,
    multiplied by `JumpVelocity`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们指定向量（或应用的力）应该是“上”方向，乘以`JumpVelocity`。
- en: The `ForceMode` parameter determines how the force is applied and is also an
    enumeration type. `Impulse` delivers an instant force to an object while taking
    its mass into account, which is perfect for a jump mechanic.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForceMode`参数确定了如何应用力，并且也是一个枚举类型。`Impulse`会立即对物体施加力，同时考虑其质量，这非常适合跳跃机制。'
- en: 'Other `ForceMode` choices can be useful in different situations, all of which
    are detailed here: [https://docs.unity3d.com/ScriptReference/ForceMode.html](https://docs.unity3d.com/ScriptReference/ForceMode.html).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 其他`ForceMode`选择在不同情况下可能会有用，所有这些都在这里详细说明：[https://docs.unity3d.com/ScriptReference/ForceMode.html](https://docs.unity3d.com/ScriptReference/ForceMode.html)。
- en: At the end of every `FixedUpdate` frame, we reset `_isJumping` to false so the
    input check knows a complete jump and the landing cycle has been completed.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个`FixedUpdate`帧的末尾，我们将`_isJumping`重置为false，以便输入检查知道完成了一次跳跃和着陆循环。
- en: If you play the game now, you'll be able to move around and jump when you hit
    the spacebar. However, the mechanic allows you to keep jumping indefinitely, which
    isn't what we want. We'll work on limiting our jump mechanic to one at a time
    in the next section, using something called a layer mask.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在玩游戏，您将能够在按下空格键时移动和跳跃。但是，该机制允许您无限跳跃，这不是我们想要的。在下一节中，我们将通过使用称为层蒙版的东西来限制我们的跳跃机制一次跳跃。
- en: Working with layer masks
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用层蒙版
- en: Think of layer masks as invisible groups that a GameObject can belong to, used
    by the physics system to determine anything from navigation to intersecting collider
    components. While more advanced uses of layer masks are outside the scope of this
    book, we'll create and use one to perform a simple check—whether the player capsule
    is touching the ground, in order to limit the player to one jump at a time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将图层蒙版视为游戏对象可以属于的不可见组，由物理系统用于确定从导航到相交碰撞器组件的任何内容。虽然图层蒙版的更高级用法超出了本书的范围，但我们将创建并使用一个来执行一个简单的检查——玩家胶囊是否接触地面，以限制玩家一次只能跳一次。
- en: 'Before we can check that the player capsule is touching the ground, we need
    to add all the environment objects in our level to a custom layer mask. This will
    let us perform the actual collision calculation with the Capsule Collider component
    that''s already attached to the player. Proceed as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们检查玩家胶囊是否接触地面之前，我们需要将我们级别中的所有环境对象添加到一个自定义图层蒙版中。这将让我们执行与已经附加到玩家的胶囊碰撞体组件的实际碰撞计算。操作如下：
- en: Select any environment GameObject in the **Hierarchy** and in the corresponding
    **Inspector** pane, click on **Layer** | **Add Layer...**, as illustrated in the
    following screenshot:![](img/B17573_08_01.png)
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择任何环境游戏对象，并在相应的**检视器**窗格中，单击**层** | **添加图层...**，如下截图所示：![](img/B17573_08_01.png)
- en: 'Figure 8.1: Selecting layers in the Inspector pane'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：在检视器窗格中选择图层
- en: Add a new layer called `Ground` by typing the name into the first available
    slot, which is Layer 6\. Layers 0-5 are reserved for Unity's default layers, even
    though Layer 3 is empty, as illustrated in the following screenshot:![](img/B17573_08_02.png)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在第一个可用的槽中输入名称来添加一个名为“Ground”的新图层，该槽是第6层。尽管第3层为空，但层0-5保留给Unity的默认层，如下截图所示：![](img/B17573_08_02.png)
- en: 'Figure 8.2: Adding layers in the Inspector pane'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：在检视器窗格中添加图层
- en: Select the **Environment** parent GameObject in the **Hierarchy**, click on
    the **Layer** dropdown, and select **Ground**.![](img/B17573_08_03.png)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“层次结构”中选择**环境**父游戏对象，单击**层**下拉菜单，然后选择**Ground**。![](img/B17573_08_03.png)
- en: 'Figure 8.3: Setting a custom layer'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：设置自定义图层
- en: After you have selected the **Ground** option shown in the following screenshot,
    click **Yes, change children** when a dialog appears asking you if you want to
    change all child objects. Here, you've defined a new layer called **Ground** and
    assigned every child object of **Environment** to that layer.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择了下图中显示的**Ground**选项后，当出现对话框询问是否要更改所有子对象时，单击**是，更改子对象**。在这里，您已经定义了一个名为**Ground**的新图层，并将**环境**的每个子对象分配到该图层。
- en: Going forward, all the objects on the **Ground** layer can be checked to see
    if they intersect with a specific object. You'll use this in the following challenge
    to make sure the player can perform a jump if it's on the ground; no unlimited
    jump hacks here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，所有**Ground**图层上的对象都可以被检查是否与特定对象相交。您将在接下来的挑战中使用这个功能，以确保玩家只能在地面上执行跳跃；这里没有无限跳跃的作弊。
- en: 'Since we don''t want code cluttering up the `Update()` method, we''ll do our
    layer mask calculations in a utility function and return a `true` or `false` value
    based on the outcome. To do so, proceed as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望代码混乱`Update()`方法，我们将在实用函数中进行图层蒙版计算，并根据结果返回`true`或`false`值。操作如下：
- en: 'Add the following highlighted code to `PlayerBehavior` and play the scene again:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下突出显示的代码添加到`PlayerBehavior`中，然后再次播放场景：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the `PlayerBehavior` script selected, set **Ground Layer** in the **Inspector**
    pane to **Ground** from the **Ground Layer** dropdown, as illustrated in the following
    screenshot:![](img/B17573_08_04.png)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`PlayerBehavior`脚本，将**检视器**窗格中的**Ground Layer**设置为**Ground**，从**Ground Layer**下拉菜单中选择，如下截图所示：![](img/B17573_08_04.png)
- en: 'Figure 8.4: Setting the Ground Layer'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：设置地面图层
- en: 'Let''s break down the preceding code, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式分解前面的代码：
- en: We create a new variable for the distance we'll check between the player Capsule
    Collider and any **Ground Layer** object.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为将检查玩家胶囊碰撞体与任何**Ground Layer**对象之间的距离创建一个新变量。
- en: We create a `LayerMask` variable that we can set in the **Inspector** and use
    for the collider detection.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个`LayerMask`变量，可以在**检视器**中设置，并用于碰撞体检测。
- en: We create a variable to store the player's Capsule Collider component.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个变量来存储玩家的胶囊碰撞体组件。
- en: We use `GetComponent()` to find and return the Capsule Collider attached to
    the player.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`GetComponent()`来查找并返回附加到玩家的胶囊碰撞体。
- en: We update the `if` statement to check whether `IsGrounded` returns `true` and
    the spacebar is pressed before executing the jump code.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更新`if`语句，以检查`IsGrounded`是否返回`true`并且在执行跳跃代码之前按下了空格键。
- en: We declare the `IsGrounded()` method with a `bool` return type.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了`IsGrounded()`方法，返回类型为`bool`。
- en: We create a local `Vector3` variable to store the position at the bottom of
    the player's Capsule Collider, which we'll use to check for collisions with any
    objects on the **Ground** layer.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个本地的`Vector3`变量来存储玩家胶囊碰撞体底部的位置，我们将用它来检查与**Ground**图层上的任何对象的碰撞。
- en: All Collider components have a `bounds` property, which gives us access to the
    min, max, and center positions of its *x*, *y*, and *z* axes.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有碰撞体组件都有一个`bounds`属性，它使我们可以访问其*x*、*y*和*z*轴的最小、最大和中心位置。
- en: The bottom of the collider is the 3D point at center *x*, min *y*, and center
    *z*.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞体的底部是3D点，在中心*x*，最小*y*和中心*z*。
- en: 'We create a local `bool` to store the result of the `CheckCapsule()` method
    that we call from the `Physics` class, which takes in the following five arguments:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个本地的`bool`来存储我们从`Physics`类中调用的`CheckCapsule()`方法的结果，该方法接受以下五个参数：
- en: The start of the capsule, which we set to the middle of the Capsule Collider
    since we only care about checking whether the bottom touches the ground.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胶囊的开始，我们将其设置为胶囊碰撞体的中间，因为我们只关心底部是否接触地面。
- en: The end of the capsule, which is the `capsuleBottom` position we've already
    calculated.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胶囊的末端，即我们已经计算过的`capsuleBottom`位置。
- en: The radius of the capsule, which is the `DistanceToGround` already set.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 胶囊体的半径，即已设置的`DistanceToGround`。
- en: The layer mask we want to check collisions on, set to `GroundLayer` in the **Inspector**.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要检查碰撞的图层蒙版，设置为**检视器**中的`GroundLayer`。
- en: The query trigger interaction, which determines whether the method should ignore
    colliders that are set as triggers. Since we want to ignore all triggers, we used
    the `QueryTriggerInteraction.Ignore` enum.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询触发交互，确定方法是否应忽略设置为触发器的碰撞体。由于我们想要忽略所有触发器，我们使用了`QueryTriggerInteraction.Ignore`枚举。
- en: We could also use the `Distance` method from the `Vector3` class to determine
    how far we are from the ground since we know the height of the player capsule.
    However, we're going to stick with using the `Physics` class since that's the
    focus of this chapter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`Vector3`类的`Distance`方法来确定我们离地面有多远，因为我们知道玩家胶囊的高度。然而，我们将继续使用`Physics`类，因为这是本章的重点。
- en: We return the value stored in `grounded` at the end of the calculation.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在计算结束时返回存储在`grounded`中的值。
- en: We could have done the collision calculation manually, but that would require
    more complex 3D math than we have time to cover here. However, it's always a good
    idea to use built-in methods when available.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以手动进行碰撞计算，但那将需要比我们在这里有时间涵盖的更复杂的3D数学。然而，使用内置方法总是一个好主意。
- en: That was an involved piece of code that we just added into `PlayerBehavior`,
    but when you break it down, the only new thing we did was use a method from the
    `Physics` class. In plain English, we supplied `CheckCapsule()` with a start and
    endpoint, a collision radius, and a layer mask. If the endpoint gets closer than
    the collision radius to an object on the layer mask, the method returns `true`—meaning
    the player is touching the ground. If the player is in a mid-jump position, `CheckCapsule()`
    returns `false`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在`PlayerBehavior`中添加的代码是一个复杂的代码片段，但是当你分解它时，我们做的唯一新的事情就是使用了`Physics`类的一个方法。简单来说，我们向`CheckCapsule()`提供了起始点和终点、碰撞半径和图层蒙版。如果终点距离图层蒙版上的对象的碰撞半径更近，该方法将返回`true`——这意味着玩家正在接触地面。如果玩家处于跳跃中的位置，`CheckCapsule()`将返回`false`。
- en: Since we're checking `IsGround` in the `if` statement every frame in `Update()`,
    our player's jump skills are only allowed when touching the ground.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`Update()`中的`if`语句中每帧检查`IsGround`，所以我们的玩家的跳跃技能只有在接触地面时才允许。
- en: That's all you're going to do with the jump mechanic, but the player still needs
    a way to interact and defend themself against the hordes of enemies that will
    eventually populate the arena. In the following section, you'll fix that gap by
    implementing a simple shooting mechanic.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你要用跳跃机制做的一切，但玩家仍然需要一种方式来与并最终占领竞技场的敌人进行互动和自卫。在接下来的部分，你将通过实现一个简单的射击机制来填补这个空白。
- en: Shooting projectiles
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发射抛射物
- en: Shooting mechanics are so common that it's hard to think of a first-person game
    without some variation present, and *Hero Born* is no different. In this section,
    we'll talk about how to instantiate GameObjects from Prefabs while the game is
    running, and use the skills we've learned to propel them forward using Unity physics.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 射击机制是如此普遍，以至于很难想象一个没有某种变化的第一人称游戏，*Hero Born*也不例外。在本节中，我们将讨论如何在游戏运行时从预制件中实例化游戏对象，并使用我们学到的技能来利用Unity物理学将它们向前推进。
- en: Instantiating objects
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化对象
- en: The concept of instantiating a GameObject in the game is similar to instantiating
    an instance of a class—both require starting values so that C# knows what kind
    of object we want to create and where it needs to be created. To create objects
    in the scene at runtime, we use the `Instantiate()` method and provide a Prefab
    object, a starting position, and a starting rotation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中实例化一个游戏对象的概念类似于实例化一个类的实例——都需要起始值，以便C#知道我们要创建什么类型的对象以及需要在哪里创建它。为了在运行时在场景中创建对象，我们使用`Instantiate()`方法，并提供一个预制对象、一个起始位置和一个起始旋转。
- en: Essentially, we can tell Unity to create a given object with all its components
    and scripts at this spot, looking in this direction, and then manipulate it as
    needed once it's born in the 3D space. Before we instantiate an object, you'll
    need to create the object Prefab itself, which is your next task.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们可以告诉Unity在这个位置创建一个给定的对象，带有所有的组件和脚本，朝着这个方向，然后一旦它在3D空间中诞生，就可以根据需要对其进行操作。在我们实例化一个对象之前，你需要创建对象的预制本身，这是你的下一个任务。
- en: 'Before we can shoot any projectiles, we''ll need a Prefab to use as a reference,
    so let''s create that now, as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们射击任何抛射物之前，我们需要一个预制件作为参考，所以现在让我们创建它，如下所示：
- en: Select **+** | **3D** **Object** | **Sphere** in the **Hierarchy** panel and
    name it `Bullet`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择**+** | **3D** **对象** | **球体**，并将其命名为`Bullet`。
- en: Change its **Scale** to 0.15 in the *x*, *y*, and *z* axes in the **Transform**
    component.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**Transform**组件中将其**比例**在*x*、*y*和*z*轴上更改为0.15。
- en: Select the **Bullet** in the **Inspector** and use the **Add Component** button
    at the bottom to search for and add a **Rigidbody** component, leaving all default
    properties as they are.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检视器**中选择**Bullet**，并在底部使用**添加组件**按钮搜索并添加一个**刚体**组件，将所有默认属性保持不变。
- en: 'Create a new material in the `Materials` folder using **Create** | **Material**,
    and name it `Bullet_Mat`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`材质`文件夹中使用**创建** | **材质**创建一个新的材质，并将其命名为`Bullet_Mat`：
- en: Change the **Albedo** property to a deep yellow.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**Albedo**属性更改为深黄色。
- en: Drag and drop the material from the **Materials** folder onto the `Bullet` GameObject
    in the **Hierarchy** pane.![](img/B17573_08_05.png)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中，将**材质**文件夹中的材质拖放到`Bullet`游戏对象上。![](img/B17573_08_05.png)
- en: 'Figure 8.5: Setting projectile properties'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：设置抛射物属性
- en: Select the **Bullet** in the **Hierarchy** panel and drag it into the `Prefabs`
    folder in the **Project** panel. Then, delete it from the **Hierarchy** to clean
    up the scene:![](img/B17573_08_06.png)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择**Bullet**，并将其拖放到**项目**面板中的`预制件`文件夹中。然后，从**层次结构**中删除它以清理场景:![](img/B17573_08_06.png)
- en: 'Figure 8.6: Creating a projectile Prefab'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：创建一个抛射物预制件
- en: You created and configured a **Bullet** Prefab GameObject that can be instantiated
    as many times as we need in the game and updated as needed. This means you're
    ready for the next challenge—shooting projectiles.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建并配置了一个可以根据需要在游戏中实例化多次并根据需要更新的**Bullet**预制体游戏对象。这意味着您已经准备好迎接下一个挑战——射击抛射物。
- en: Adding the shooting mechanic
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加射击机制
- en: 'Now that we have a Prefab object to work with, we can instantiate and move
    copies of the Prefab whenever we hit the left mouse button to create a shooting
    mechanic, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个预制体对象可以使用，我们可以在按下鼠标左键时实例化并移动预制体的副本，以创建射击机制，如下所示：
- en: 'Update the `PlayerBehavior` script with the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`PlayerBehavior`脚本：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the **Inspector**, drag the **Bullet** Prefab from the **Project** panel
    into the **Bullet** property of `PlayerBehavior`, as illustrated in the following
    screenshot:![](img/B17573_08_07.png)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，将**Bullet**预制体从**项目**面板拖放到`PlayerBehavior`的**Bullet**属性中，如下截图所示：![](img/B17573_08_07.png)
- en: 'Figure 8.7: Setting the Bullet Prefab'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：设置子弹预制体
- en: Play the game and use the left mouse button to fire projectiles in the direction
    the player is facing!
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏，并使用鼠标左键向玩家面对的方向发射抛射物！
- en: 'Let''s break down the code, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解这段代码，如下所示：
- en: 'We create two variables: one to store the Bullet Prefab, the other to hold
    the Bullet speed.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了两个变量：一个用于存储子弹预制体，另一个用于保存子弹速度。
- en: Like our jumping mechanic, we use a boolean in the `Update` method to check
    if our player should be shooting.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像我们的跳跃机制一样，我们在`Update`方法中使用布尔值来检查我们的玩家是否应该射击。
- en: We set the value of `_isShooting` using the `or` logical operator and `Input.GetMouseButtonDown()`,
    which returns `true` if we're pushing the specified button, just like with `Input.GetKeyDown()`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`or`逻辑运算符和`Input.GetMouseButtonDown()`来设置`_isShooting`的值，如果我们按下指定的按钮，则返回`true`，就像使用`Input.GetKeyDown()`一样。
- en: '`GetMouseButtonDown()` takes an `int` parameter to determine which mouse button
    we want to check for; `0` is the left button, `1` is the right button, and `2`
    is the middle button or scroll wheel.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetMouseButtonDown()`接受一个`int`参数来确定我们要检查哪个鼠标按钮；`0`是左键，`1`是右键，`2`是中间按钮或滚轮。'
- en: Then we check if our player is supposed to be shooting using the `_isShooting`
    input check variable.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们检查我们的玩家是否应该使用`_isShooting`输入检查变量进行射击。
- en: 'We create a local GameObject variable every time the left mouse button is pressed:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次按下鼠标左键时，我们创建一个本地的GameObject变量：
- en: We use the `Instantiate()` method to assign a GameObject to `newBullet` by passing
    in the `Bullet` Prefab. We also use the player capsule's position to place the
    new `Bullet` Prefab in front of the player to avoid any collisions.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`Instantiate()`方法通过传入`Bullet`预制体来为`newBullet`分配一个GameObject。我们还使用玩家胶囊体的位置将新的`Bullet`预制体放在玩家前面，以避免任何碰撞。
- en: We append it as a `GameObject` to explicitly cast the returned object to the
    same type as `newBullet`, which in this case is a GameObject.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将其附加为`GameObject`，以将返回的对象显式转换为与`newBullet`相同类型的对象，这种情况下是一个GameObject。
- en: We call `GetComponent()` to return and store the Rigidbody component on `newBullet`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`GetComponent()`来返回并存储`newBullet`上的Rigidbody组件。
- en: 'We set the `velocity` property of the Rigidbody component to the player''s
    `transform.forward` direction multiplied by `BulletSpeed`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将Rigidbody组件的`velocity`属性设置为玩家的`transform.forward`方向乘以`BulletSpeed`：
- en: Changing the `velocity` instead of using `AddForce()` ensures that gravity doesn't
    pull our bullets down in an arc when fired.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变`velocity`而不是使用`AddForce()`确保我们的子弹在被射出时不会被重力拉成弧线。
- en: Finally, we set the `_isShooting` value to `false` so our shooting input is
    reset for the next input event.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将`_isShooting`的值设置为`false`，这样我们的射击输入就会为下一个输入事件重置。
- en: Again, you've significantly upgraded the logic the player script is using. You
    should now be able to use the mouse to shoot projectiles that fly straight out
    from the player's position.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，您显著升级了玩家脚本正在使用的逻辑。现在，您应该能够使用鼠标射击抛射物，这些抛射物直线飞出玩家的位置。
- en: However, the problem now is that your game scene, and hierarchy, are flooded
    with spent Bullet objects. Your next task is to clean those objects up once they've
    been fired, to avoid any performance issues.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在的问题是，您的游戏场景和层次结构中充斥着已使用的子弹对象。您的下一个任务是在它们被发射后清理这些对象，以避免任何性能问题。
- en: Managing object build-up
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理对象的积累
- en: Whether you're writing a completely code-based application or a 3D game, it's
    important to make sure that unused objects are regularly deleted to avoid overloading
    the program. Our bullets don't exactly play an important role after they are shot;
    they sort of just keep existing on the floor near whatever wall or object they
    collided with.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是编写完全基于代码的应用程序还是3D游戏，都很重要确保定期删除未使用的对象，以避免过载程序。我们的子弹在被射出后并不起重要作用；它们只是继续存在于靠近它们碰撞的墙壁或物体附近的地板上。
- en: With a mechanic such as shooting, this could result in hundreds, if not thousands,
    of bullets down the line, which is something we don't want. Your next challenge
    is to destroy each bullet after a set delay time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的射击机制，这可能导致成百上千甚至数千颗子弹，这是我们不想要的。你的下一个挑战是在设定延迟时间后销毁每颗子弹。
- en: 'For this task, we can take the skills we''ve already learned and make the bullets
    responsible for their self-destructive behavior, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个任务，我们可以利用已经学到的技能，让子弹自己负责其自毁行为，如下所示：
- en: Create a new C# script in the `Scripts` folder and name it `BulletBehavior`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，命名为`BulletBehavior`。
- en: 'Drag and drop the `BulletBehavior` script onto the `Bullet` Prefab in the `Prefabs`
    folder and add the following code:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BulletBehavior`脚本拖放到`Prefabs`文件夹中的`Bullet`预制体上，并添加以下代码：
- en: '[PRE10]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s break down this code, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解这段代码，如下所示：
- en: We declare a `float` variable to store how long we want the Bullet Prefabs to
    remain in the scene after they are instantiated.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明一个`float`变量来存储我们希望子弹预制体在被实例化后场景中保留多长时间。
- en: We use the `Destroy()` method to delete the GameObject.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Destroy()`方法来删除GameObject。
- en: '`Destroy()` always needs an object as a parameter. In this case, we use the
    `this` keyword to specify the object that the script is attached to.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Destroy()`总是需要一个对象作为参数。在这种情况下，我们使用`this`关键字来指定脚本所附加的对象。'
- en: '`Destroy()` can optionally take an additional `float` parameter as a delay,
    which we use to keep the bullets on screen for a short amount of time.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Destroy()`可以选择以额外的`float`参数作为延迟，我们用它来让子弹在屏幕上停留一小段时间。'
- en: Play the game again, shoot some bullets, and watch as they are deleted from
    the **Hierarchy** by themselves in the scene after a specific delay. This means
    that the bullet executes its defined behavior, without another script having to
    tell it what to do, which is an ideal application of the *Component* design pattern.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 再次玩游戏，射击一些子弹，观察它们在特定延迟后自动从**层次结构**中删除。这意味着子弹执行了其定义的行为，而不需要另一个脚本告诉它该做什么，这是*组件*设计模式的理想应用。
- en: Now that our housekeeping is done, you're going to learn about a key component
    of any well-designed and organized project—the manager class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的清理工作已经完成，你将学习到任何精心设计和组织的项目中的一个关键组件——管理器类。
- en: Creating a game manager
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏管理器
- en: A common misconception when learning to program is that all variables should
    automatically be made public, but in general, this is not a good idea. In my experience,
    variables should be thought of as protected and private from the start, and only
    made public if necessary. One way you'll see experienced programmers protect their
    data is through manager classes, and since we want to build good habits, we'll
    be following suit. Think of manager classes as a funnel where important variables
    and methods can be accessed safely.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习编程时一个常见的误解是所有变量都应该自动设为公共的，但一般来说，这不是一个好主意。根据我的经验，变量应该从一开始就被视为受保护和私有的，只有在必要时才设为公共的。你会看到有经验的程序员通过管理器类来保护他们的数据，因为我们想养成良好的习惯，所以我们也会这样做。把管理器类看作一个漏斗，重要的变量和方法可以安全地被访问。
- en: When I say safely, I mean just that, which might seem unfamiliar in a programming
    context. However, when you have different classes communicating and updating data
    with each other, things can get messy. That's why having a single contact point,
    such as a manager class, can keep this to a minimum. We'll get into how to do
    that effectively in the following section.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说安全时，我的意思就是这样，这在编程环境中可能看起来不熟悉。然而，当你有不同的类相互通信和更新数据时，情况可能会变得混乱。这就是为什么有一个单一的联系点，比如一个管理器类，可以将这种情况降到最低。我们将在下一节中学习如何有效地做到这一点。
- en: Tracking player properties
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪玩家属性
- en: '*Hero Born* is a simple game, so the only two data points we need to keep track
    of are how many items the player has collected and how much health they have left.
    We want these variables to be private so that they can only be modified from the
    manager class, giving us control and safety. Your next challenge is to create
    a game manager for *Hero Born* and populate it with helpful functionality.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*英雄诞生*是一个简单的游戏，所以我们需要跟踪的唯一两个数据点是玩家收集了多少物品和剩余多少生命值。我们希望这些变量是私有的，这样它们只能从管理器类中修改，给我们控制和安全性。你的下一个挑战是为*英雄诞生*创建一个游戏管理器，并为其添加有用的功能。'
- en: 'Game manager classes will be a constant facet of any project you develop in
    the future, so let''s learn how to properly create one, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏管理器类将是你未来开发的任何项目中的一个不变的组成部分，所以让我们学习如何正确地创建一个，如下所示：
- en: Create a new C# script in the `Scripts` folder and name it `GameBehavior`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，并命名为`GameBehavior`。
- en: Usually, this script would be named `GameManager`, but Unity reserves that name
    for its own scripts. If you ever create a script and a cogwheel icon shows up
    next to its name instead of the C# file icon, that tells you it's restricted.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这个脚本会被命名为`GameManager`，但Unity保留了这个名称用于自己的脚本。如果你创建了一个脚本，而其名称旁边出现了齿轮图标而不是C#文件图标，那就表示它是受限制的。
- en: Create a new empty game object in the **Hierarchy** by using **+** | **Create
    Empty**, and name it `Game_Manager`.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**+** | **创建空对象**在**层次结构**中创建一个新的空游戏对象，并命名为`Game_Manager`。
- en: Drag and drop the `GameBehavior.cs` script from the **Scripts** folder onto
    the `Game_Manager` object, as illustrated in the following screenshot:![](img/B17573_08_08.png)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Scripts**文件夹中将`GameBehavior.cs`脚本拖放到`Game_Manager`对象上，如下截图所示：![](img/B17573_08_08.png)
- en: 'Figure 8.8: Attaching the game manager script'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：附加游戏管理器脚本
- en: Manager scripts, and other non-game files, are set up on empty objects to put
    them in the scene, even though they don't interact with the actual 3D space.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 管理器脚本和其他非游戏文件被设置在空对象上，尽管它们不与实际的3D空间交互。
- en: 'Add the following code to `GameBehavior.cs`:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`GameBehavior.cs`中：
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's break down this code. We added two new `private` variables to hold the
    number of items picked up and how many lives the player has left; these are `private`
    because they should only be modifiable in this class. If they were made `public`,
    other classes could change them at will, which could lead to the variables storing
    incorrect or concurrent data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解这段代码。我们添加了两个新的`private`变量来保存捡起的物品数量和玩家剩余的生命值；这些是`private`的，因为它们只能在这个类中被修改。如果它们被设为`public`，其他类可以随意改变它们，这可能导致变量存储不正确或并发数据。
- en: Having these variables declared as `private` means that you are responsible
    for how they are accessed. The following topic on `get` and `set` properties will
    introduce you to a standard, safe way to accomplish this task going forward.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些变量声明为`private`意味着你有责任控制它们的访问。下一个关于`get`和`set`属性的主题将向你介绍一种标准、安全的方法来完成这项任务。
- en: The get and set properties
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取和设置属性
- en: We've got our manager script and private variables set up, but how do we access
    them from other classes if they're private? While we could write separate public
    methods in `GameBehavior` to handle passing new values to the private variables,
    let's see whether there is a better way of doing things.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置好了管理器脚本和私有变量，但如果它们是私有的，我们如何从其他类中访问它们呢？虽然我们可以在`GameBehavior`中编写单独的公共方法来处理将新值传递给私有变量，但让我们看看是否有更好的方法来做这些事情。
- en: In this case, C# provides all variables with `get` and `set` properties, which
    are perfectly suited to our task. Think of these as methods that are automatically
    fired by the C# compiler whether we explicitly call them or not, similar to how
    `Start()` and `Update()` are executed by Unity when a scene starts.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，C#为所有变量提供了`get`和`set`属性，这非常适合我们的任务。将这些视为方法，无论我们是否显式调用它们，C#编译器都会自动触发它们，类似于Unity在场景启动时执行`Start()`和`Update()`。
- en: '`get` and `set` properties can be added to any variable, with or without an
    initial value, as illustrated in the following code snippet:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`和`set`属性可以添加到任何变量中，无论是否有初始值，如下面的代码片段所示：'
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, using them like this doesn''t add any additional benefits; for that,
    you need to include a code block for each property, as illustrated in the following
    code snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像这样使用它们并没有添加任何额外的好处；为此，您需要为每个属性包括一个代码块，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, the `get` and `set` properties are set up to execute additional logic,
    depending on where it's needed. We're not done yet though, as we still need to
    handle the new logic.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`get`和`set`属性已经设置好，可以根据需要执行额外的逻辑。然而，我们还没有完成，因为我们仍然需要处理新逻辑。
- en: Every `get` code block needs to return a value, while every `set` block needs
    to
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`get`代码块都需要返回一个值，而每个`set`代码块都需要
- en: 'assign a value; this is where having a combination of a private variable, called
    a backing variable, and a public variable with `get` and `set` properties comes
    into play. The private variable remains protected, while the public variable allows
    controlled access from other classes, as shown in the following code snippet:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 分配一个值；这就是拥有一个私有变量（称为支持变量）和具有`get`和`set`属性的公共变量的组合发挥作用的地方。私有变量保持受保护状态，而公共变量允许从其他类进行受控访问，如下面的代码片段所示：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s break this down, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下，如下所示：
- en: We can `return` the value stored in the private variable from the `get` property
    anytime another class needs it, without actually giving that outside class direct
    access.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`get`属性随时从私有变量中`return`值，而不实际给予外部类直接访问。
- en: We can update the private variable any time an outside class assigns a new value
    to the public variable, keeping them in sync.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当外部类分配新值给公共变量时，我们可以随时更新私有变量，使它们保持同步。
- en: The `value` keyword is a stand-in for whatever new value is assigned.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`关键字是被分配的任何新值的替代品。'
- en: This can seem a little esoteric without an actual application, so let's update
    `GameBehavior` with public variables with getter and setter properties to go along
    with our existing private variables.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有实际应用，这可能看起来有点晦涩，所以让我们使用具有getter和setter属性的公共变量来更新`GameBehavior`中的私有变量。
- en: Now that we understand the syntax of the `get` and `set` property accessors,
    we can implement them in our manager class for greater efficiency and code readability.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了`get`和`set`属性访问器的语法，我们可以在我们的管理器类中实现它们，以提高效率和代码可读性。
- en: 'Update the code in `GameBehavior`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下方式更新`GameBehavior`中的代码：
- en: '[PRE15]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s break down the code, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码，如下所示：
- en: We declare a new `public` variable called `Items` with `get` and `set` properties.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了一个名为`Items`的新`public`变量，带有`get`和`set`属性。
- en: We use the `get` property to `return` the value stored in `_itemsCollected`
    whenever `Items` are accessed from an outside class.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当从外部类访问`Items`时，我们使用`get`属性来`return`存储在`_itemsCollected`中的值。
- en: We use the `set` property to assign `_itemsCollected` to the new `value` of
    `Items` whenever it's updated, with an added `Debug.LogFormat()` call to print
    out the modified value of `_itemsCollected`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`set`属性将`_itemsCollected`分配给`Items`的新`value`，每当它更新时，还添加了`Debug.LogFormat()`调用以打印出`_itemsCollected`的修改值。
- en: We set up a `public` variable called `HP` with `get` and `set` properties to
    complement the private `_playerHP` backing variable.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了一个名为`HP`的`public`变量，带有`get`和`set`属性，以补充私有的`_playerHP`支持变量。
- en: Both private variables are now readable, but only through their public counterparts;
    they can only be changed in `GameBehavior`. With this setup, we ensure that our
    private data can only be accessed and modified from specific contact points. This
    makes it easier to communicate with `GameBehavior` from our other mechanical scripts,
    as well as to display the real-time data in the simple UI we'll create at the
    end of the chapter.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个私有变量都是可读的，但只能通过它们的公共对应变量进行访问；它们只能在`GameBehavior`中进行更改。通过这种设置，我们确保我们的私有数据只能从特定的接触点进行访问和修改。这使得我们更容易从其他机械脚本与`GameBehavior`进行通信，以及在本章末尾创建的简单UI中显示实时数据。
- en: Let's test this out by updating the `Items` property when we successfully interact
    with an item pickup in the arena.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在竞技场成功与物品拾取交互时更新`Items`属性来测试一下。
- en: Updating item collection
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新物品集合
- en: 'Now that we have our variables set up in `GameBehavior`, we can update `Items`
    every time we collect an `Item` in the scene, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`GameBehavior`中设置了变量，我们可以在场景中每次收集一个`Item`时更新`Items`，如下所示：
- en: 'Add the following highlighted code to the `ItemBehavior` script:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下突出显示的代码添加到`ItemBehavior`脚本中：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Hit play and collect the pickup item to see the new console log print out from
    the manager script, as illustrated in the following screenshot:![](img/B17573_08_09.png)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放并收集拾取物品，以查看经理脚本中的新控制台日志打印输出，如下面的屏幕截图所示：![](img/B17573_08_09.png)
- en: 'Figure 8.9: Collecting a pickup item'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：收集拾取物品
- en: 'Let''s break down the code, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码，如下所示：
- en: We create a new variable of the `GameBehavior` type to store a reference to
    the attached script.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的`GameBehavior`类型变量来存储对附加脚本的引用。
- en: We use `Start()` to initialize `GameManager` by looking it up in the scene with
    `Find()` and adding a call to `GetComponent()`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Start()`来通过`Find()`在场景中查找`GameManager`并添加一个`GetComponent()`调用来初始化它。
- en: You'll see this kind of code done in a single line quite often in Unity documentation
    and community projects. This is done for simplicity, but if you feel more comfortable
    writing out the `Find()` and `GetComponent()` calls separately, go right ahead;
    there's nothing wrong with clear, explicit formatting.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常在Unity文档和社区项目中看到这种代码以一行的形式完成。这是为了简单起见，但如果你更喜欢单独编写`Find()`和`GetComponent()`调用，那就尽管去做吧；清晰、明确的格式没有错。
- en: We increment the `Items` property in the `GameManager` class in `OnCollisionEnter()`
    after the Item Prefab is destroyed.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnCollisionEnter()`中，在Item Prefab被销毁后，我们会在`GameManager`类中递增`Items`属性。
- en: Since we already set up `ItemBehavior` to take care of collision logic, it's
    easy to modify `OnCollisionEnter()` to communicate with our manager class when
    an item is picked up by the player. Keep in mind that separating functionality
    like this is what makes the code more flexible and less likely to break as you
    make changes during development.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经设置了`ItemBehavior`来处理碰撞逻辑，修改`OnCollisionEnter()`以在玩家拾取物品时与我们的管理类通信变得很容易。请记住，像这样分离功能是使代码更灵活，并且在开发过程中进行更改时不太可能出错的原因。
- en: The last piece *Hero Born* is missing is some kind of interface that displays
    game data to the player. In programming and game development, this is called a
    UI. Your final task in this chapter is to familiarize yourself with how Unity
    creates and handles the UI code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '*英雄诞生*缺少的最后一部分是一种向玩家显示游戏数据的接口。在编程和游戏开发中，这被称为UI。本章的最后一个任务是熟悉Unity如何创建和处理UI代码。'
- en: Creating a GUI
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建GUI
- en: At this point, we have several scripts working together to give players access
    to movement, jumping, collecting, and shooting mechanics. However, we're still
    missing any kind of display or visual cue that shows our player's stats, as well
    as a way to win and lose the game. We'll focus on these two topics as we close
    out this last section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有几个脚本一起工作，让玩家可以移动、跳跃、收集和射击。然而，我们仍然缺少任何一种显示或视觉提示，来显示我们玩家的统计数据，以及赢得和输掉游戏的方法。在我们结束这一节时，我们将专注于这两个主题。
- en: Displaying player stats
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示玩家统计数据
- en: UIs are the visual components of any computer system. The mouse cursor, folder
    icons, and programs on your laptop are all UI elements. For our game, we want
    a simple display to let our players know how many items they've collected, their
    current health, and a textbox to give them updates when certain events happen.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: UI是任何计算机系统的视觉组件。鼠标光标、文件夹图标和笔记本电脑上的程序都是UI元素。对于我们的游戏，我们希望有一个简单的显示，让我们的玩家知道他们收集了多少物品，他们当前的生命值，并且在某些事件发生时给他们更新的文本框。
- en: 'UI elements in Unity can be added in the following two ways:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的UI元素可以通过以下两种方式添加：
- en: Directly from the **+** menu in the **Hierarchy** panel, like with any other
    GameObject
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从**层次结构**面板中的**+**菜单中，就像任何其他GameObject一样
- en: Using the built-in GUI class in code
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码中内置的GUI类
- en: We're going to stick with the first option, since the built-in GUI classes are
    part of the Unity legacy UI system, and we want to stay current, right? This isn't
    to say that you can't do everything programmatically, but for our prototype, the
    newer UI systems are a better fit.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将坚持第一种选择，因为内置的GUI类是Unity传统UI系统的一部分，我们希望保持最新，对吧？这并不是说你不能通过编程的方式做任何事情，但对于我们的原型来说，更新的UI系统更合适。
- en: 'If you''re curious about programmatic UI in Unity, take a look at the documentation
    yourself: [https://docs.unity3d.com/ScriptReference/GUI.html](https://docs.unity3d.com/ScriptReference/GUI.html).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对Unity中的程序化UI感兴趣，请自行查看文档：[https://docs.unity3d.com/ScriptReference/GUI.html](https://docs.unity3d.com/ScriptReference/GUI.html)。
- en: Your next task is to add a simple UI to the game scene that displays the items
    collected, player health, and progress information variables that are stored in
    `GameBehavior.cs`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一个任务是在游戏场景中添加一个简单的UI，显示存储在`GameBehavior.cs`中的已收集物品、玩家生命和进度信息变量。
- en: First, let's create three text objects in our scene. User interfaces in Unity
    work off of a canvas, which is exactly what it sounds like. Think of the canvas
    as a blank painting that you can draw on that Unity will render on top of the
    game world for you. Whenever you create your first UI element in the **Hierarchy**
    panel, a **Canvas** parent object is created along with it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的场景中创建三个文本对象。Unity中的用户界面是基于画布的，这正是它的名字。把画布想象成一块空白的画布，你可以在上面绘画，Unity会在游戏世界的顶部渲染它。每当你在**层次结构**面板中创建你的第一个UI元素时，一个**Canvas**父对象会与之一起创建。
- en: Right-click in the **Hierarchy** panel and select **UI** | **Text** and name
    the new object **Health**. This will create a **Canvas** parent object and the
    new **Text** object all at once:![](img/B17573_08_10.png)
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中右键单击，选择**UI** | **Text**，并将新对象命名为**Health**。这将同时创建一个**Canvas**父对象和新的**Text**对象：![](img/B17573_08_10.png)
- en: 'Figure 8.10: Creating a Text element'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：创建一个文本元素
- en: To see the canvas correctly, select **2D** mode at the top of the **Scene**
    tab. From this view, our entire level is that tiny white line in the lower-left
    hand corner.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了正确查看画布，请在“场景”选项卡顶部选择**2D**模式。从这个视图中，我们整个级别就是左下角的那条微小的白线。
- en: Even though the **Canvas** and level don't overlap in the scene, when the game
    plays Unity will automatically overlay them correctly.![](img/B17573_08_11.png)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使**Canvas**和级别在场景中不重叠，当游戏运行时Unity会自动正确地叠加它们。![](img/B17573_08_11.png)
- en: 'Figure 8.11: Canvas in the Unity editor'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：Unity编辑器中的Canvas
- en: If you select the **Health** object in the **Hierarchy**, you'll see that the
    new text object was created in the lower-left corner of the canvas by default,
    and it has a whole list of customizable properties, like text and color, in the
    **Inspector** pane:![](img/B17573_08_12.png)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在“层次结构”中选择**Health**对象，你会看到默认情况下新的文本对象被创建在画布的左下角，并且它有一整套可定制的属性，比如文本和颜色，在**检视器**窗格中：![](img/B17573_08_12.png)
- en: 'Figure 8.12: Text element on the Unity Canvas'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：Unity画布上的文本元素
- en: With the **Health** object selected in the **Hierarchy** pane, click on the
    **Anchor** presets in the **Rect Transform** component of the **Inspector** and
    choose **Top Left**.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗格中选择**Health**对象，单击**检视器**中**Rect Transform**组件的**Anchor**预设，选择**左上角**。
- en: Anchors set a UI element's point of reference on the canvas, meaning that whatever
    the size of the device screen, our health points will always be anchored to the
    top left of the screen:![](img/B17573_08_13.png)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锚点设置了UI元素在画布上的参考点，这意味着无论设备屏幕的大小如何，我们的健康点始终锚定在屏幕的左上角！[](img/B17573_08_13.png)
- en: 'Figure 8.13: Setting anchor presets'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：设置锚点预设
- en: In the **Inspector** pane, change the **Rect Transform** position to **100**
    on the **X** axis and **–30** on the **Y** axis to position the text in the upper-right
    corner. Also change the **Text** property to say **Player Health:**. We'll be
    setting the actual value in code in a later step:![](img/B17573_08_14.png)
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检视器**窗格中，将**Rect Transform**位置更改为**X**轴上的**100**和**Y**轴上的**-30**，以将文本定位在右上角。还将**Text**属性更改为**Player
    Health:**。我们将在以后的步骤中在代码中设置实际值！[](img/B17573_08_14.png)
- en: 'Figure 8.14: Setting text properties'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：设置文本属性
- en: 'Repeat steps 1-5 to create a new UI **Text** object and name it **Items**:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤1-5以创建一个新的UI **Text**对象，并命名为**Items**：
- en: Set the anchor presets to **Top Left**, the **Pos X** to **100**, and the **Pos
    Y** to **–60**
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将锚点预设设置为**左上角**，**Pos X**设置为**100**，**Pos Y**设置为**-60**
- en: Set **Text** to **Items Collected:**![](img/B17573_08_15.png)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**Text**设置为**Items Collected:**![](img/B17573_08_15.png)
- en: 'Figure 8.15: Creating another Text element'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：创建另一个文本元素
- en: 'Repeat *steps 1-5* to create a new UI **Text** object and name it **Progress**:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤1-5*以创建一个新的UI **Text**对象，并命名为**Progress**：
- en: Set the anchor presets to **Bottom Center**, the **Pos X** to **0**, the **Pos
    Y** to **15**, and the **Width** to **280**
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将锚点预设设置为**底部中心**，**Pos X**设置为**0**，**Pos Y**设置为**15**，**Width**设置为**280**
- en: Set **Text** to **Collect all the items and win your freedom!**![](img/B17573_08_16.png)
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**Text**设置为**收集所有物品并赢得你的自由！**![](img/B17573_08_16.png)
- en: 'Figure 8.16: Creating a progress text element'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：创建进度文本元素
- en: 'Now that we have our UI set up, let''s connect the variables we already have
    in our game manager script. Proceed as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的UI已经设置好了，让我们连接已经在游戏管理器脚本中拥有的变量。请按照以下步骤进行：
- en: 'Update `GameBehavior` with the following code to collect an item and display
    on-screen text when items are collected:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新`GameBehavior`以收集物品并在屏幕上显示文本：
- en: '[PRE17]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Select **Game_Manager** in the **Hierarchy** and drag over our three text objects
    one by one into their corresponding `GameBehavior` script fields in the **Inspector**:![](img/B17573_08_17.png)
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**中选择**Game_Manager**，并将我们的三个文本对象依次拖到**检视器**中的相应`GameBehavior`脚本字段中：![](img/B17573_08_17.png)
- en: 'Figure 8.17: Dragging text elements to script components'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：将文本元素拖到脚本组件
- en: Run the game and take a look at our new onscreen GUI boxes, shown in the following
    screenshot:![](img/B17573_08_18.png)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏，看看我们新的屏幕GUI框，如下截图所示：![](img/B17573_08_18.png)
- en: 'Figure 8.18: Testing UI elements in play mode'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18：在播放模式中测试UI元素
- en: 'Let''s break down the code, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解代码，如下所示：
- en: We add the `UnityEngine.UI` namespace so we have access to the **Text** variable
    type.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了`UnityEngine.UI`命名空间，以便可以访问**Text**变量类型。
- en: We create a new public variable for the max number of items in the level.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为关卡中物品的最大数量创建了一个新的公共变量。
- en: We create three new **Text** variables, which we connect in the **Inspector**
    panel.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了三个新的**Text**变量，将它们连接到**检视器**面板中。
- en: Then, we use the `Start` method to set the initial values of our health and
    items text using the **+=** operator.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用`Start`方法使用**+=**运算符设置我们的健康和物品文本的初始值。
- en: Every time an item is collected, we update the `text` property of **ItemText**
    to show the updated `items` count.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次收集一个物品，我们都会更新**ItemText**的`text`属性，显示更新后的`items`计数。
- en: We declare an `if` statement in the set property of `_itemsCollected`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`_itemsCollected`的设置属性中声明了一个`if`语句。
- en: If the player has gathered more than or equal to `MaxItems`, they've won, and
    `ProgressText.text` is updated.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家收集的物品数量大于或等于`MaxItems`，他们就赢了，`ProgressText.text`会更新。
- en: Otherwise, `ProgressText.text` shows how many items are still left to collect.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，`ProgressText.text`显示还有多少物品可以收集。
- en: Every time the player's health is damaged, which we'll cover in the next chapter,
    we update the `text` property of `HealthText` with the new value.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当玩家的健康受到损害时，我们将在下一章中介绍，我们都会更新`HealthText`的`text`属性，显示新值。
- en: 'When we play the game now, our three UI elements show up with the correct values;
    when an Item is collected, the `ProgressText` and `_itemsCollected` counts update,
    as illustrated in the following screenshot:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩游戏时，我们的三个UI元素显示出了正确的值；当收集一个物品时，`ProgressText`和`_itemsCollected`计数会更新，如下截图所示：
- en: '![](img/B17573_08_19.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_08_19.png)'
- en: 'Figure 8.19: Updating the UI text'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19：更新UI文本
- en: Every game can either be won or lost. In the last section of this chapter, your
    task is to implement those conditions and the UI that goes along with them.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏都可以赢得或输掉。在本章的最后一节，您的任务是实现这些条件以及与之相关的UI。
- en: Win and loss conditions
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 胜利和失败条件
- en: 'We''ve implemented our core game mechanics and a simple UI, but *Hero Born*
    is still missing an important game design element: its win and loss conditions.
    These conditions will manage how the player wins or loses the game and execute
    different code depending on the situation.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了核心游戏机制和简单的UI，但是*Hero Born*仍然缺少一个重要的游戏设计元素：胜利和失败条件。这些条件将管理玩家如何赢得或输掉游戏，并根据情况执行不同的代码。
- en: 'Back in the game document from *Chapter 6*, *Getting Your Hands Dirty with
    Unity*, we set out our win and loss conditions as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*第6章*的游戏文档，*使用Unity忙碌起来*，我们将我们的胜利和失败条件设置如下：
- en: Collecting all items in the level with at least 1 health point remaining to
    win
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在剩余至少1个健康点的情况下收集所有物品以获胜
- en: Taking damage from enemies until health points are at 0 to lose
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从敌人那里受到伤害，直到健康点数为0为止
- en: These conditions are going to affect both our UI and game mechanics, but we've
    already set up `GameBehavior` to handle this efficiently. Our `get` and `set`
    properties will handle any game-related logic and changes to the UI when a player
    wins or loses.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条件将影响我们的UI和游戏机制，但我们已经设置了`GameBehavior`来有效处理这一点。我们的`get`和`set`属性将处理任何与游戏相关的逻辑和UI更改，当玩家赢得或输掉游戏时。
- en: We're going to implement the win condition logic in this section because we
    have the pickup system already in place. When we get to the enemy AI behavior
    in the next chapter, we'll add in the loss condition logic. Your next task is
    to determine when the game is won in code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节中实现赢得游戏的逻辑，因为我们已经有了拾取系统。当我们在下一章中处理敌人AI行为时，我们将添加失败条件逻辑。您的下一个任务是在代码中确定游戏何时赢得。
- en: 'We always want to give players clear and immediate feedback, so we''ll start
    by adding in the logic for a win condition, as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们始终希望给玩家清晰和即时的反馈，因此我们将首先添加赢得游戏的逻辑，如下所示：
- en: 'Update `GameBehavior` to match the following code:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`GameBehavior`以匹配以下代码：
- en: '[PRE18]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Right-click in the **Hierarchy** and select **UI** | **Button**, then name
    it **Win Condition**:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**Hierarchy**，然后选择**UI** | **Button**，然后将其命名为**Win Condition**：
- en: Select **Win Condition** and set the **Pos X** and **Pos Y** to **0**, its **Width**
    to **225**, and its **Height** to **115**.![](img/B17573_08_20.png)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择**Win Condition**，将**Pos X**和**Pos Y**设置为**0**，将**Width**设置为**225**，将**Height**设置为**115**。![](img/B17573_08_20.png)
- en: 'Figure 8.20: Creating a UI button'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20：创建UI按钮
- en: Click on the arrow to the right of the **Win Condition** button to expand its
    text child object, then change the text to say **You won!**:![](img/B17573_08_21.png)
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**Win Condition**按钮右侧的箭头以展开其文本子对象，然后更改文本为**You won!**：![](img/B17573_08_21.png)
- en: 'Figure 8.21: Updating button text'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21：更新按钮文本
- en: Select the **Win Condition** parent object again and click the checkmark icon
    in the upper right of the **Inspector**.![](img/B17573_08_22.png)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择**Win Condition**父对象，然后单击**Inspector**右上角的复选标志。![](img/B17573_08_22.png)
- en: 'Figure 8.22: Deactivating the game object'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22：停用游戏对象
- en: 'This will hide the button until we''ve won the game:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们赢得游戏之前隐藏按钮：
- en: '![](img/B17573_08_23.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_08_23.png)'
- en: 'Figure 8.23: Testing the hidden UI button'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23：测试隐藏的UI按钮
- en: Select **Game_Manager** in the **Hierarchy** and drag the **Win Condition**
    button from the **Hierarchy** to the **Game Behavior (Script)** in the **Inspector**,
    just like we did with the text objects:![](img/B17573_08_24.png)
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**中选择**Game_Manager**，然后将**Win Condition**按钮从**Hierarchy**拖动到**Inspector**中的**Game
    Behavior (Script)**，就像我们在文本对象中所做的那样！[](img/B17573_08_24.png)
- en: 'Figure 8.24: Dragging the UI button onto the script component'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24：将UI按钮拖动到脚本组件上
- en: Change **Max Items** to `1` in the **Inspector** to test out the new screen,
    as illustrated in the following screenshot:![](img/B17573_08_25.png)
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**中将**Max Items**更改为`1`，以测试新屏幕，如下截图所示：![](img/B17573_08_25.png)
- en: 'Figure 8.25: Showing the win screen'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25：显示赢得游戏的屏幕
- en: 'Let''s break down the code, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解代码，如下所示：
- en: We created a UI button variable to connect to our Win Condition button in the
    **Hierarchy**.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个UI按钮变量，以连接到**Hierarchy**中的**Win Condition**按钮。
- en: Since we set the Win Condition button as **Hidden** when the game starts, we
    reactivate it when the game is won.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们在游戏开始时将Win Condition按钮设置为**隐藏**，因此当游戏赢得时，我们会重新激活它。
- en: With **Max Items** set to `1`, the **Win** button will show up on collecting
    the only `Pickup_Item` in the scene. Clicking the button doesn't do anything right
    now, but we'll address that in the following section.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将**Max Items**设置为`1`，**Win**按钮将在收集场景中唯一的`Pickup_Item`时显示出来。目前单击按钮不会产生任何效果，但我们将在下一节中解决这个问题。
- en: Pausing and restarting the game with using directives and namespaces
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用指令和命名空间暂停和重新开始游戏
- en: Right now, our win condition works as expected, but the player still has control
    over the capsule and doesn't have a way of restarting the game once it's over.
    Unity provides a property in the `Time` class called `timeScale`, which when set
    to `0` freezes the game scene. However, to restart the game, we need access to
    a **namespace** called `SceneManagement` that isn't accessible from our classes
    by default.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的赢得条件按预期工作，但玩家仍然可以控制胶囊，并且在游戏结束后没有重新开始游戏的方法。Unity在`Time`类中提供了一个名为`timeScale`的属性，当设置为`0`时，会冻结游戏场景。但是，要重新开始游戏，我们需要访问一个名为`SceneManagement`的**命名空间**，这在默认情况下无法从我们的类中访问。
- en: A namespace collects and groups a set of classes under a specific name to organize
    large projects and avoid conflicts between scripts that may share the same names.
    A `using` directive needs to be added to a class to access a namespace's classes.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间收集并将一组类分组到特定名称下，以组织大型项目并避免可能共享相同名称的脚本之间的冲突。需要向类中添加`using`指令才能访问命名空间的类。
- en: 'All C# scripts created from Unity come with three default `using` directives,
    shown in the following code snippet:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 从Unity创建的所有C#脚本都带有三个默认的`using`指令，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: These allow access to common namespaces, but Unity and C# offer plenty more
    that can be added with the `using` keyword followed by the name of the namespace.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这些允许访问常见的命名空间，但Unity和C#还提供了许多其他可以使用`using`关键字后跟命名空间名称添加的命名空间。
- en: Since our game will need to be paused and restarted when a player wins or loses,
    this is a good time to use a namespace that isn't included in new C# scripts by
    default.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的游戏在玩家赢或输时需要暂停和重新开始，这是一个很好的时机来使用默认情况下新的C#脚本中不包括的命名空间。
- en: 'Add the following code to `GameBehavior` and play:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`GameBehavior`并播放：
- en: '[PRE20]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Select **Win Condition** from the **Hierarchy**, scroll down in the **Inspector**
    to the **OnClick** section of the **Button** component, and hit the plus icon:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Hierarchy**中选择**Win Condition**，在**Inspector**中向下滚动到**Button**组件的**OnClick**部分，然后单击加号图标：
- en: Every UI button has an **OnClick** event, which means you can assign a method
    from a script to execute when the button is pushed.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个UI按钮都有一个**OnClick**事件，这意味着您可以将来自脚本的方法分配给在按钮被按下时执行。
- en: You can have multiple methods fire when a button is clicked, but we only need
    one in this case:![](img/B17573_08_26.png)
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在单击按钮时触发多个方法，但在这种情况下我们只需要一个！[](img/B17573_08_26.png)
- en: 'Figure 8.26: OnClick section of the button'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26：按钮的OnClick部分
- en: From the **Hierarchy**, drag the **Game_Manager** into the slot underneath **Runtime**
    to tell the button we want to choose a method from our manager script to fire
    when the button is pushed:![](img/B17573_08_27.png)
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Hierarchy**中，将**Game_Manager**拖放到**Runtime**下方的插槽中，告诉按钮我们要选择一个来自我们管理器脚本的方法在按钮被按下时触发！[](img/B17573_08_27.png)
- en: 'Figure 8.27: Setting the game manager object in On Click'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27：在点击时设置游戏管理器对象
- en: Select the **No Function** dropdown and choose **GameBehavior** | **RestartScene
    ()** to set the method we want the button to execute:![](img/B17573_08_28.png)
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**No Function**下拉菜单，选择**GameBehavior** | **RestartScene ()**来设置我们希望按钮执行的方法！[](img/B17573_08_28.png)
- en: 'Figure 8.28: Choosing the restart method for the button click'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.28：选择按钮点击的重新启动方法
- en: 'Go to **Window** | **Rendering** | **Lighting** and select **Generate Lighting**
    at the bottom. Make sure **Auto Generate** is not selected:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**Window** | **Rendering** | **Lighting**，并在底部选择**Generate Lighting**。确保未选择**Auto
    Generate**：
- en: This step is necessary to address a Unity issue that reloads scenes without
    any lighting.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步是必要的，以解决Unity重新加载场景时没有任何照明的问题。
- en: '![](img/B17573_08_29.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_08_29.png)'
- en: 'Figure 8.29: Lighting panel in the Unity editor'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.29：Unity编辑器中的照明面板
- en: 'Let''s break down the code, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解代码，如下所示：
- en: We add the `SceneManagement` namespace with the `using` keyword, which handles
    all scene-related logic like creating loading scenes.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`using`关键字添加了`SceneManagement`命名空间，该命名空间处理所有与场景相关的逻辑，如创建加载场景。
- en: We set `Time.timeScale` to `0` to pause the game when the win screen is displayed,
    which disables any input or movement.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当显示胜利屏幕时，我们将`Time.timeScale`设置为`0`，这将暂停游戏，禁用任何输入或移动。
- en: 'We create a new method called `RestartScene` and call `LoadScene()` when the
    win screen button is clicked:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`RestartScene`的新方法，并在单击胜利屏幕按钮时调用`LoadScene()`：
- en: '`LoadScene()` takes in a scene index as an `int` parameter.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadScene()`以`int`参数形式接受场景索引。'
- en: Because there is only one scene in our project, we use index `0` to restart
    the game from the beginning.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们的项目中只有一个场景，所以我们使用索引`0`从头开始重新启动游戏。
- en: We reset `Time.timeScale` to the default value of `1` so that when the scene
    restarts, all controls and behaviors will be able to execute again.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`Time.timeScale`重置为默认值`1`，以便在场景重新启动时，所有控件和行为都能够再次执行。
- en: Now, when you collect an item and click on the win screen button, the level
    restarts, with all scripts and components restored to their original values and
    set up for another round!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您收集物品并单击胜利屏幕按钮时，关卡将重新开始，所有脚本和组件都将恢复到其原始值，并准备好进行另一轮！
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! *Hero Born* is now a playable prototype. We implemented jumping
    and shooting mechanics, managed physics collisions and spawning objects, and added
    in a few basic UI elements to display feedback. We even got as far as resetting
    the level when the player wins.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！*英雄诞生*现在是一个可玩的原型。我们实现了跳跃和射击机制，管理了物理碰撞和生成对象，并添加了一些基本的UI元素来显示反馈。我们甚至已经实现了玩家赢得比赛时重置关卡的功能。
- en: A lot of new topics were introduced in this chapter, and it's important to go
    back and make sure you understand what went into the code we wrote. Pay special
    attention to our discussions on enumerations, `get` and `set` properties, and
    namespaces. From here on in, the code is only going to get more complex as we
    dive further into the possibilities of the C# language.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了许多新主题，重要的是要回过头去确保您理解了我们编写的代码中包含了什么。特别注意我们对枚举、`get`和`set`属性以及命名空间的讨论。从现在开始，随着我们进一步深入C#语言的可能性，代码将变得更加复杂。
- en: In the next chapter, we'll start working on getting our enemy GameObjects to
    take notice of our player when we get too close, resulting in a follow-and-shoot
    protocol that will up the stakes for our player.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始着手让我们的敌人游戏对象在我们离得太近时注意到我们的玩家，从而导致一种跟随和射击协议，这将提高我们玩家的赌注。
- en: Pop quiz – working with mechanics
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速测验-与机械一起工作
- en: What type of data do enumerations store?
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 枚举类型的数据存储什么类型的数据？
- en: How would you create a copy of a Prefab GameObject in an active scene?
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将如何在活动场景中创建预制游戏对象的副本？
- en: Which variable properties allow you to add functionality when their value is
    referenced or modified?
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪些变量属性允许您在引用或修改它们的值时添加功能？
- en: Which Unity method displays all UI objects in the scene?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个Unity方法显示场景中的所有UI对象？
- en: JOIN us on Discord!
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户一起阅读本书，与Unity/C#专家和Harrison Ferrone一起阅读，通过*问我任何事*会话与作者交流，提出问题，为其他读者提供解决方案，等等。
- en: Join Now!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
