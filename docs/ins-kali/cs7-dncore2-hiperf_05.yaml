- en: Designing Guidelines for .NET Core Application Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core应用程序性能设计指南
- en: Architecture and design are the core foundations for any application. Conforming
    to the best practices and guidelines makes the application highly maintainable,
    performant, and scalable. Applications can vary from a web-based application,
    Web APIs, a server/client TCP-based messaging application, a mission-critical
    application, and so on. However, all of these applications should follow certain
    practices that benefit in various ways. In this chapter, we will learn certain
    practices that are common in almost all of our applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 架构和设计是任何应用程序的核心基础。遵循最佳实践和指南使应用程序具有高可维护性、高性能和可扩展性。应用程序可以是基于Web的应用程序、Web API、服务器/客户端基于TCP的消息传递应用程序、关键任务应用程序等等。然而，所有这些应用程序都应该遵循一定的实践，从而在各种方面获益。在本章中，我们将学习几种几乎所有应用程序中常见的实践。
- en: 'Here are some of the principles we will learn in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将学习的一些原则：
- en: 'Coding principles:'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码原则：
- en: Naming convention
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名约定
- en: Code comments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码注释
- en: One class per file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个文件一个类
- en: One logic per method
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个方法一个逻辑
- en: 'Design principles:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计原则：
- en: KISS (Keep It Simple, Stupid)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KISS（保持简单，愚蠢）
- en: YAGNI (You Aren't Gonna Need It)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAGNI（你不会需要它）
- en: DRY (Don't Repeat Yourself)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DRY（不要重复自己）
- en: Separation of Concerns
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点分离
- en: SOLID principles
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID原则
- en: Caching
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Data structures
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构
- en: Communication
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信
- en: Resource management
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源管理
- en: Concurrency
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: Coding principles
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码原则
- en: In this section, we will cover some of the basic coding principles that help
    in writing quality code that improves the overall performance and scalability
    of the application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些基本的编码原则，这些原则有助于编写提高应用程序整体性能和可扩展性的优质代码。
- en: Naming convention
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名约定
- en: Always use the proper naming convention in every application, starting with
    the solution name, which should provide meaningful information about the project
    you are working on. The project name specifies the layer or component part of
    the application. Finally, classes should be nouns or noun phrases, and methods
    should represent the actions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个应用程序中始终使用适当的命名约定，从解决方案名称开始，解决方案名称应提供有关您正在工作的项目的有意义的信息。项目名称指定应用程序的层或组件部分。最后，类应该是名词或名词短语，方法应该代表动作。
- en: 'When we create a new project in Visual Studio, the default solution name is
    set to what you specify for the project name. The solution name should always
    be different from the project name as one solution may contain multiple projects.
    The project name should always represent the specific part of the system. For
    example, suppose we are developing a messaging gateway that sends different types
    of messages to different parties and contains three components, namely, listener,
    processor, and dispatcher; the listener listens for incoming requests, the processor
    processes the incoming message, and the dispatcher sends the message to the destination.
    The naming convention could be as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Visual Studio中创建一个新项目时，默认的解决方案名称设置为您为项目名称指定的内容。解决方案名称应始终与项目名称不同，因为一个解决方案可能包含多个项目。项目名称应始终代表系统的特定部分。例如，假设我们正在开发一个消息网关，该网关向不同的方发送不同类型的消息，并包含三个组件，即监听器、处理器和调度器；监听器监听传入的请求，处理器处理传入的消息，调度器将消息发送到目的地。命名约定可以如下：
- en: 'Solution name: `MessagingGatewa`*y* (or any code word)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决方案名称：`MessagingGateway`（或任何代码词）
- en: 'Listener project name: `ListenerApp`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听器项目名称：`ListenerApp`
- en: 'Processor project name: `ProcessorAPI` (if it''s an API)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器项目名称：`ProcessorAPI`（如果是API）
- en: 'Dispatcher project name: `DispatcherApp`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调度项目名称：`DispatcherApp`
- en: 'In .NET, the naming convention we usually follow is Pascal casing for class
    and method names. In Pascal casing, the first character of every word is a capital
    letter, whereas the parameters and other variables follow Camel casing. Here is
    some sample code showing how casing should be used in .NET.:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，我们通常遵循的命名约定是类和方法名称使用帕斯卡命名法。在帕斯卡命名法中，每个单词的第一个字符都是大写字母，而参数和其他变量则使用骆驼命名法。以下是一些示例代码，显示了在.NET中应如何使用命名法。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we have a constant field, `SmtpAddress`, and a `SendEmail`
    method that is cased using Pascal casing, whereas the parameters are cased using
    Camel casing.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们有一个常量字段`SmtpAddress`和一个使用帕斯卡命名法的`SendEmail`方法，而参数则使用骆驼命名法。
- en: 'The following table summarizes the naming conventions for different artifacts
    in .NET:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了.NET中不同工件的命名约定：
- en: '| **Attribute** | **Naming Convention** | **Example** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **命名约定** | **示例** |'
- en: '| Class | Pascal casing | `class PersonManager {}` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 类 | 帕斯卡命名法 | `class PersonManager {}` |'
- en: '| Method | Pascal casing | `void SaveRecord(Person person) {}` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 帕斯卡命名法 | `void SaveRecord(Person person) {}` |'
- en: '| Parameters/Member variables | Camel casing | `bool isActive;` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 参数/成员变量 | 骆驼命名法 | `bool isActive;` |'
- en: '| Interface | Pascal casing; starts with letter I | `IPerson` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | 帕斯卡命名法；以字母I开头 | `IPerson` |'
- en: '| Enum | Pascal casing | `enum Status {InProgress, New, Completed}` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 枚举 | 帕斯卡命名法 | `enum Status {InProgress, New, Completed}` |'
- en: Code comments
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码注释
- en: Any code that contains proper comments assists developers in many ways. It not
    only reduces the time to understand the code thoroughly, but can also give leverage
    with certain tools like *Sandcastle* or *DocFx* to generate complete code documentation
    on the fly that can be shared with other developers across the team. Also, when
    talking about APIs, Swagger is widely used and popular in the developer community.
    Swagger empowers API consumers by providing complete information about the API,
    available methods, parameters each method takes, and so on. Swagger also reads
    these comments to provide the complete documentation and interface to test any
    API.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 任何包含适当注释的代码都可以在许多方面帮助开发人员。它不仅减少了理解代码的时间，还可以利用诸如*Sandcastle*或*DocFx*之类的工具，在生成完整的代码文档时即时共享给团队中的其他开发人员。此外，在谈论API时，Swagger在开发人员社区中被广泛使用和受欢迎。Swagger通过提供有关API的完整信息，可用方法，每个方法所需的参数等，来赋予API使用者权力。Swagger还读取这些注释，以提供完整的文档和接口，以测试任何API。
- en: One class per file
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个文件一个类
- en: Unlike many other languages, in .NET we are not restricted to create separate
    files for each class. We can create one single `.cs` file and create numbers of
    classes inside it. Conversely, this is a bad practice and painful when working
    with large applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他语言不同，在.NET中，我们不受限于为每个类创建单独的文件。我们可以创建一个单独的`.cs`文件，并在其中创建多个类。相反，这是一种不好的做法，当处理大型应用程序时会很痛苦。
- en: One logic per method
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个方法一个逻辑
- en: 'Always write methods to do one thing at a time. Let''s suppose we have a method
    that reads the user ID from the database and then calls an API to retrieve the
    list of documents the user has uploaded. The best approach with this scenario
    is to have two separate methods, `GetUserID` and `GetUserDocuments`, to retrieve
    the user ID first and then the documents, respectively:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 始终编写一次只执行一件事的方法。假设我们有一个方法，它从数据库中读取用户ID，然后调用API来检索用户上传的文档列表。在这种情况下，最好的方法是有两个单独的方法，`GetUserID`和`GetUserDocuments`，分别首先检索用户ID，然后检索文档：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The benefit of this approach is that it reduces code repetition. In the future,
    if we wanted to change the logic of either method, we just have to change it in
    one place rather than replicating it everywhere and increasing the chances of
    error.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处在于减少了代码重复。将来，如果我们想要更改任一方法的逻辑，我们只需在一个地方进行更改，而不是在所有地方复制它并增加错误的机会。
- en: Design principles
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计原则
- en: Developing a clean architecture adhering to the best practices adds several
    benefits, and application performance is one of them. We have seen many times
    that the technologies used behind an application are robust and powerful, but
    the application's performance remains unsatisfactory or poor, which is usually
    because of bad architecture design and investing less time on the application's
    design.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循最佳实践开发清晰的架构会带来多种好处，应用程序性能就是其中之一。我们经常看到，应用程序背后使用的技术是强大而有效的，但应用程序的性能仍然不尽人意或不佳，这通常是因为糟糕的架构设计和在应用程序设计上投入较少的时间。
- en: 'In this section, we will discuss a few common design principles that should
    be addressed when designing and developing applications in .NET Core:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论一些在.NET Core中设计和开发应用程序时应该解决的常见设计原则：
- en: KISS (Keep It Simple, Stupid)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KISS（保持简单，愚蠢）
- en: YAGNI (You Aren't Gonna Need It)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAGNI（你不会需要它）
- en: DRY (Don't Repeat Yourself)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DRY（不要重复自己）
- en: Separation of Concerns
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点分离
- en: SOLID principles
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID原则
- en: Caching
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Data structures
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构
- en: Communication
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信
- en: Resource management
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源管理
- en: Concurrency
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发
- en: KISS (Keep It Simple, Stupid)
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KISS（保持简单，愚蠢）
- en: Writing cleaner code and keeping it simple always helps developers understand
    and maintain it in the long run. Adding needless complexity in the code does not
    only make it less understandable, but also hard to maintain and change when required.
    This is what KISS states. In a software context, KISS can be considered while
    designing software architecture, using **Object Oriented Principles** (**OOP**),
    designing the database, user interfaces, integration, and so on. Adding unnecessary
    complexity complicates the software's design and may affect the application's
    maintainability and performance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 编写更清洁的代码并始终保持简单有助于开发人员在长期内理解和维护它。在代码中添加不必要的复杂性不仅使其难以理解，而且在需要时也难以维护和更改。这就是KISS所说的。在软件上下文中，KISS可以在设计软件架构时考虑，使用**面向对象原则**（**OOP**），设计数据库，用户界面，集成等。添加不必要的复杂性会使软件的设计复杂化，并可能影响应用程序的可维护性和性能。
- en: YAGNI (You Aren't Gonna Need It)
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: YAGNI（你不会需要它）
- en: YAGNI is one of the core principles of XP (extreme programming). XP is a software
    methodology that contains short spans of iterations to meet customer requirements
    and welcomes changes when they are required or initiated by the customer. The
    primary goal is meeting the customer's expectation, and keeping the quality and
    responsiveness the customer needs. It involves pair programming and code reviews
    to keep the quality intact and to satisfy the customer's expectations.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: YAGNI是XP（极限编程）的核心原则之一。XP是一种软件方法，包含短期迭代，以满足客户需求，并在需要或由客户发起时欢迎变更。主要目标是满足客户的期望，并保持客户所需的质量和响应能力。它涉及成对编程和代码审查，以保持质量完整，并满足客户的期望。
- en: YAGNI is best suited for the extreme programming methodology, which helps developers
    focus on the features that are part of the application's functionality or customer's
    requirements. Doing something extra that is not communicated to the customer or
    is not part of the iteration or requirement may end up needing a rework and being
    a waste of time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: YAGNI最适合极限编程方法，该方法帮助开发人员专注于应用程序功能或客户需求的特性。做一些额外的事情，如果没有告知客户或不是迭代或需求的一部分，最终可能需要重新工作，并且会浪费时间。
- en: DRY (Don't Repeat Yourself)
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DRY（不要重复自己）
- en: DRY (Don't Repeat Yourself) is also one of the core principles of writing cleaner
    code. It addresses the challenges developers face in big applications when they
    are constantly changing or extending with respect to functionality or underlying
    logic. As per the principle, it states that "*Every piece of knowledge must have
    a single dependable representation within the system.*"
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: DRY（不要重复自己）也是编写更清晰代码的核心原则之一。它解决了开发人员在大型应用程序中不断更改或扩展功能或基础逻辑时所面临的挑战。根据该原则，它规定“系统中的每个知识片段必须有一个可靠的表示”。
- en: When writing an application, we can use abstractions and avoid repetition of
    code to avoid redundancy. This benefits in accommodating changes and lets developers
    focus on one area where the change is required. If the same code is repeated in multiple
    areas, changes at one place need to be done in other places as well, and this
    eliminates good architecture practice, thus initiating higher risks of errors
    and making the application code more buggy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写应用程序时，我们可以使用抽象来避免代码的重复，以避免冗余。这有助于适应变化，并让开发人员专注于需要更改的一个领域。如果相同的代码在多个地方重复，那么在一个地方进行更改需要在其他地方进行更改，这会消除良好的架构实践，从而引发更高的错误风险，并使应用程序代码更加错误。
- en: Separation of Concerns (SoC)
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关注点分离（SoC）
- en: One of the core principles for developing clean architecture is **Separation
    of Concerns** (**SoC**). This pattern states that each distinct type of work application
    that is performing should be built separately as a separate component with little
    or no tight coupling with other components. For example, if a program saves the
    user message into the database and then a service randomly picks up the message
    and chooses the winner, you can see that these are two separate operations, and
    this is known as Separation of Concerns. With SoC, the code is considered a separate
    component and any customization, if needed, can be done at one place. Reusability
    is another factor that helps developers change code in one place so that they
    can use it in multiple places. Nevertheless, testing is far easier and bugs can
    be secluded and fixed later in case of predicament scenarios.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 开发清晰架构的核心原则之一是**关注点分离**（**SoC**）。这种模式规定，每种不同类型的应用程序应该作为一个独立的组件单独构建，与其他组件几乎没有或没有紧密耦合。例如，如果一个程序将用户消息保存到数据库，然后一个服务随机选择消息并选择获胜者，你可以看到这是两个独立的操作，这就是所谓的关注点分离。通过关注点分离，代码被视为一个独立的组件，如果需要，任何定制都可以在一个地方完成。可重用性是另一个因素，它帮助开发人员在一个地方更改代码，以便在多个地方使用。然而，测试要容易得多，而且在出现问题的情况下，错误可以被隔离和延后修复。
- en: SOLID principles
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: 'SOLID is a collection of 5 principles, which are listed as follows. They are
    common design principles that are highly used when developing software design:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID是5个原则的集合，列举如下。这些是在开发软件设计时经常使用的常见设计原则：
- en: '**Single Responsibility Principle** (**SRP**)'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一责任原则**（**SRP**）'
- en: '**Open Closed Principle** (**OCP**)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开闭原则**（**OCP**）'
- en: '**Liskov Substitution Principle** (**LSP**)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**里氏替换原则**（**LSP**）'
- en: '**Interface Segregation Principle** (**ISP**)'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口隔离原则**（**ISP**）'
- en: '**Dependency Inversion Principle** (**DIP**)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（**DIP**）'
- en: Single Responsibility Principle
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一责任原则
- en: The Single Responsibility Principle states that the class should only have one
    particular objective and that responsibility should be entirely encapsulated from
    the class. If there is any change or a new objective has to be accommodated for,
    a new class or interface should be created.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 单一责任原则规定类应该只有一个特定的目标，并且该责任应该完全封装在类中。如果有任何更改或需要适应新目标，应创建一个新的类或接口。
- en: Applying this principle in software design makes our code maintainable and easier
    to understand. Architects usually follow this principle when designing software
    architecture, but, with the passage of time when many developers work and incorporate
    changes into that code/class, it becomes bloated and disaffirms the single responsibility
    principle, thus eventually making our code unmaintainable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计中应用这一原则使我们的代码易于维护和理解。架构师通常在设计软件架构时遵循这一原则，但随着时间的推移，当许多开发人员在该代码/类中工作并进行更改时，它变得臃肿，并且违反了单一责任原则，最终使我们的代码难以维护。
- en: This also relates to the concepts of Cohesion and Coupling. Cohesion refers
    to the measure of how strongly related the responsibilities in the class are,
    whereas coupling refers to the degree to which each class relies on one another.
    We should always focus on maintaining low coupling between classes and high cohesion
    within the class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这也涉及到内聚性和耦合的概念。内聚性指的是类中责任之间的关联程度，而耦合指的是每个类相互依赖的程度。我们应该始终专注于保持类之间的低耦合和类内的高内聚。
- en: 'Here is the basic `PersonManager` class that contains four methods, namely
    `GetPerson`, `SavePerson`, `LogError`, and `LogInformation`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的`PersonManager`类，包含四个方法，即`GetPerson`、`SavePerson`、`LogError`和`LogInformation`：
- en: '![](img/00056.gif)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00056.gif)'
- en: All of these methods use the database persistence manager to read/write the
    record into the database. As you may have noticed, `LogError` and `LogInformation`
    are not highly cohesive to the `PersonManager` class, and are tightly coupled
    with the `PersonManager` class. If we wanted to reuse these methods in other classes,
    we have to use the `PersonManager` class, and changing the logic of internal logging
    requires this `PersonManager` class to be changed as well. Hence, `PersonManager`
    violates the single responsibility principle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都使用数据库持久性管理器来读取/写入数据库中的记录。正如你可能已经注意到的那样，`LogError`和`LogInformation`与`PersonManager`类的内聚性不高，并且与`PersonManager`类紧密耦合。如果我们想在其他类中重用这些方法，我们必须使用`PersonManager`类，并且更改内部日志记录的逻辑也需要更改`PersonManager`类。因此，`PersonManager`违反了单一责任原则。
- en: 'To fix this design, we can create a separate `LogManager` class that can be
    used by the `PersonManager` to log information or errors when executing operations.
    Here is the updated class diagram representing the associations:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个设计，我们可以创建一个单独的`LogManager`类，可以被`PersonManager`使用来记录执行操作时的信息或错误。下面是更新后的类图，表示关联关系：
- en: '![](img/00057.gif)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.gif)'
- en: Open Closed principle
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则
- en: As per the definition, the Open Closed principle states that software entities
    like classes, methods, interfaces, and others should be closed for modification
    and open for extension. This means we cannot modify the existing code and extend
    the functionality by adding additional classes, interfaces, methods, and so on
    to address any changes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，开闭原则规定，类、方法、接口等软件实体应该对修改封闭，对扩展开放。这意味着我们不能修改现有代码，并通过添加额外的类、接口、方法等来扩展功能，以应对任何变化。
- en: 'Using this principle in any application solves various problems, which are
    listed as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序中使用这个原则可以解决各种问题，列举如下：
- en: Adding new functionality without changing existing code produces fewer errors
    and does not require thorough testing
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不改变现有代码的情况下添加新功能会产生更少的错误，并且不需要彻底测试
- en: Less of a ripple effect that is usually experienced when changing existing code
    to add or update functionalities
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更少的涟漪效应通常在更改现有代码以添加或更新功能时经历
- en: Extensions are mostly implemented using new interfaces or abstract classes where
    the existing code is unnecessary and has a lesser chance to break existing functionality
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展通常使用新接口或抽象类来实现，其中现有代码是不必要的，而且破坏现有功能的可能性较小
- en: To implement the Open Closed Principle, we should use abstractions which is
    possible through parameters, inheritance, and composition approaches.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现开闭原则，我们应该使用抽象化，这是通过参数、继承和组合方法实现的。
- en: Parameters
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数
- en: 'Special parameters can be set in the methods, which can be used to control
    the behavior of the body written in that method. Suppose there is a `LogException`
    method that saves the exception into the database and also sends an email. Now,
    whenever this method is called, both the tasks will be performed. There is no
    way to stop sending an email for a particular exception from the code. However,
    if it is articulated in a way and uses some parameters to decide whether the email
    has to be sent out or not, it can be controlled. Nonetheless, if the existing
    code doesn''t support this parameter, then customization is required, but, while
    designing, we can keep this approach to expose certain parameters so that we can
    handle the internal behavior of the method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中可以设置特殊参数，用于控制该方法中编写的代码的行为。假设有一个`LogException`方法，它将异常保存到数据库，并发送电子邮件。现在，每当调用这个方法时，两个任务都会执行。没有办法从代码中停止发送电子邮件来处理特定的异常。然而，如果以某种方式表达，并使用一些参数来决定是否发送电子邮件，就可以控制。然而，如果现有代码不支持这个参数，那么就需要定制，但是在设计时，我们可以采用这种方法来暴露某些参数，以便处理方法的内部行为：
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The recommended implementation is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的实现如下：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inheritance
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: With the inheritence approach, we can use the Template method pattern. Using
    the Template method pattern, we can create a default behavior in the root class
    and then create child classes to override the default behavior and implement new
    functionality.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用继承方法，我们可以使用模板方法模式。使用模板方法模式，我们可以在根类中创建默认行为，然后创建子类来覆盖默认行为并实现新功能。
- en: 'For example, here is a `Logger` class that logs information into the file system:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一个`Logger`类，它将信息记录到文件系统中：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have one `LogMessage` method that logs the message into the file system by
    calling the `LogToFileSystem` method. This method works fine until we wanted to
    extend the functionality. Suppose, later on, we come up with the requirement to
    log this information into the database as well. We have to change the existing
    `LogMessage` method and write the code into the same class itself. Later on, if
    any other requirement comes along, we have to add that functionality again and
    again and modify this class. As per the Open Closed Principle, this is a violation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`LogMessage`方法，通过调用`LogToFileSystem`方法将消息记录到文件系统中。这个方法一直工作得很好，直到我们想要扩展功能。假设，以后我们提出了将这些信息也记录到数据库的要求。我们必须更改现有的`LogMessage`方法，并将代码编写到同一个类中。以后，如果出现其他要求，我们必须一遍又一遍地添加功能并修改这个类。根据开闭原则，这是一种违反。
- en: With the Template method pattern, we can redesign this code to follow the Open
    Closed Principle so that we can make it open for extension and closed for customization.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板方法模式，我们可以重新设计这段代码，遵循开闭原则，使其对扩展开放，对定制封闭。
- en: 'Following the OCP, here is the new design where we have one abstract class
    that contains the `LogMessage` abstract method, and two child classes that have
    their own implementations:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循OCP，这里是新设计，我们有一个包含`LogMessage`抽象方法的抽象类，以及两个具有自己实现的子类：
- en: '![](img/00058.gif)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00058.gif)'
- en: 'With this design, we can add the nth number of extensions without changing
    the existing `Logger` class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设计，我们可以在不改变现有`Logger`类的情况下添加第n个扩展：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Composition
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: The third approach is composition, and this can be achieved using the Strategy
    pattern. With this approach, the client code is dependent on the abstraction,
    and the actual implementation is encapsulated in a separate class which is injected
    into the class exposed to the client.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是组合，这可以通过策略模式实现。通过这种方法，客户端代码依赖于抽象，实际实现封装在一个单独的类中，该类被注入到暴露给客户端的类中。
- en: 'Let''s look into the following example that implements the strategy pattern.
    The basic requirement is to send messages that could be either emails or SMSes,
    and we need to construct it in a way so that new message types can be added in
    the future without any modification to the main class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个实现策略模式的例子。基本要求是发送可能是电子邮件或短信的消息，并且我们需要以一种方式构造它，以便将来可以添加新的消息类型而不对主类进行任何修改：
- en: '![](img/00059.gif)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00059.gif)'
- en: As per the strategy pattern, we have one `MessageStrategy` abstract class that
    exposes one abstract method. Each type of work is encapsulated into the separate
    class that inherits the `MessageStrategy` base abstract class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 根据策略模式，我们有一个`MessageStrategy`抽象类，它公开一个抽象方法。每种工作类型都封装到继承`MessageStrategy`基本抽象类的单独类中。
- en: 'Here is the code for the `MessageStrategy` abstract class:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`MessageStrategy`抽象类的代码：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have two concrete implementations of `MessageStrategy`; one to send an email
    and another to send an SMS, which is shown as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个`MessageStrategy`的具体实现；一个用于发送电子邮件，另一个用于发送短信，如下所示：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we have the `MessageSender` class, which will be used by the client.
    In this class, the client can set the message strategy and call the `SendMessage`
    method that invokes the particular concrete implementation type to send the message:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`MessageSender`类，客户端将使用它。在这个类中，客户端可以设置消息策略并调用`SendMessage`方法，该方法调用特定的具体实现类型来发送消息：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'From the Main program, we can use `MessageSender`, which is shown as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从主程序中，我们可以使用`MessageSender`，如下所示：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Liskov principle
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Liskov原则
- en: As per the Liskov principle, the function that uses the references of derived
    classes through the base class object must comply with the behavior of the base
    class.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Liskov原则，通过基类对象使用派生类引用的函数必须符合基类的行为。
- en: This means that the child classes should not remove the behavior of the base
    class since this violates the invariants of it. Typically, the calling code should
    completely rely on the methods exposed in a base class without knowing its derived
    implementations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着子类不应该删除基类的行为，因为这违反了它的不变性。通常，调用代码应该完全依赖于基类中公开的方法，而不知道其派生实现。
- en: 'Let''s take an example where we first violate the definition of the Liskov
    principle and then fix it to learn what it is particularly designed for:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，首先违反Liskov原则的定义，然后修复它以了解它特别设计用于什么：
- en: '![](img/00060.gif)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00060.gif)'
- en: 'The `IMultiFunctionPrinter` interface exposes two methods as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMultiFunctionPrinter`接口公开了两种方法，如下所示：'
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is an interface that can be implemented by different kinds of printers.
    The following are two kinds of printers that implement the `IMultiFunctionPrinter`
    interface, and they are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可以由不同类型的打印机实现的接口。以下是实现`IMultiFunctionPrinter`接口的两种打印机，它们分别是：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding implementations, we have one `OfficePrinter` that provides
    printing and scanning functionalities, whereas the other home purpose `DeskjetPrinter`
    only provides the printing functionality. This `DeskjetPrinter` actually violates
    the Liskov principle as it throws the `NotImplementedException` when the `Scan`
    method is called.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的实现中，我们有一个提供打印和扫描功能的`OfficePrinter`，而另一个家用`DeskjetPrinter`只提供打印功能。当调用`Scan`方法时，`DeskjetPrinter`实际上违反了Liskov原则，因为它会抛出`NotImplementedException`。
- en: 'As a remedy to the preceding problem, we can split the `IMultiFunctionPrinter`
    into two interfaces, namely `IPrinter` and `IScanner`, whereas `IMultiFunctionPrinter`
    can also implement both the interfaces to support both functionalities. The `DeskjetPrinter`
    only implements the `IPrinter` interface as it does not support scanning:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对前面问题的补救，我们可以将`IMultiFunctionPrinter`拆分为两个接口，即`IPrinter`和`IScanner`，而`IMultiFunctionPrinter`也可以实现这两个接口以支持两种功能。`DeskjetPrinter`只实现了`IPrinter`接口，因为它不支持扫描：
- en: '![](img/00061.gif)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.gif)'
- en: 'Here is the code for the three interfaces, `IPrinter`, `IScanner`, and `IMultiFunctionPrinter`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是三个接口`IPrinter`，`IScanner`和`IMultiFunctionPrinter`的代码：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the concrete implementation will be as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，具体实现将如下所示：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Interface Segregation principle
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: The Interface Segregation principle states that the client code should only
    depend on the things the client use and should not depend on anything they do
    not use. This means you cannot force client code to depend on certain methods
    which are not required.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离原则规定，客户端代码只应依赖于客户端使用的东西，不应依赖于他们不使用的任何东西。这意味着你不能强迫客户端代码依赖于不需要的某些方法。
- en: 'Let''s take an example that first violates the Interface Segregation principle:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个首先违反接口隔离原则的例子：
- en: '![](img/00062.gif)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00062.gif)'
- en: In the preceding diagram, we have the ILogger interface that contains two methods,
    namely `WriteLog` and `GetLogs`. The `ConsoleLogger` class writes the message
    into the application console window, whereas the `DatabaseLogger` class stores
    the message into the database. The `ConsoleLogger` prints the message on the console
    windows and does not persist it; it throws the `NotImplementedException` for the
    `GetLogs` method, and so this violates the Interface Segregation principle.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们有一个包含两种方法`WriteLog`和`GetLogs`的ILogger接口。`ConsoleLogger`类将消息写入应用程序控制台窗口，而`DatabaseLogger`类将消息存储到数据库中。`ConsoleLogger`在控制台窗口上打印消息并不持久化它；对于`GetLogs`方法，它抛出`NotImplementedException`，因此违反了接口隔离原则。
- en: 'Here is the code for the preceding problem:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面问题的代码：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To obey the **Interface Segregation Principle** (**ISP**), we split the ILogger
    interface and make it more precise and pertinent with other implementers. The
    ILogger interface will only contain the `WriteLog` method and a new `IPersistenceLogger`
    interface is introduced that inherits the ILogger interface and provides the `GetLogs`
    method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了遵守**接口隔离原则**（**ISP**），我们分割了ILogger接口，并使其更精确和相关于其他实现者。ILogger接口将仅包含`WriteLog`方法，并引入了一个新的`IPersistenceLogger`接口，它继承了ILogger接口并提供了`GetLogs`方法：
- en: '![](img/00063.gif)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00063.gif)'
- en: 'Here is the modified example, which is shown as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是修改后的示例，如下所示：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The Dependency Inversion principle
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: The Dependency Inversion principle states that high-level modules should not
    depend on low-level modules and both of them should depend on abstractions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖倒置原则规定，高级模块不应依赖于低级模块，它们两者都应该依赖于抽象。
- en: The software application contains numerous types of dependencies. A dependency
    could be a framework dependency, a third-party libraries dependency, a web service
    dependency, a database dependency, a class dependency, and so on. As per the Dependency
    Inversion principle, the dependencies should not be tightly coupled with one another.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应用程序包含许多类型的依赖关系。依赖关系可以是框架依赖关系、第三方库依赖关系、Web服务依赖关系、数据库依赖关系、类依赖关系等。根据依赖倒置原则，这些依赖关系不应该紧密耦合在一起。
- en: 'For example, in the layered architecture approach we have a presentation layer
    where all the views are defined; the service layer that exposes certain methods
    used by the presentation layer; the business layer that contains core business
    logic of the system; and the database layer where the backend database connectors
    and the repository classes are defined. Consider this an ASP.NET MVC application
    where the controller invokes the service that references the business layer, where
    the business layer contains the core business logic of the system, and where it
    uses the database layer to perform CRUD (Create, Read, Update and Delete) operations
    on the database. The dependency tree will look as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在分层架构方法中，我们有一个表示层，其中定义了所有视图；服务层公开了表示层使用的某些方法；业务层包含系统的核心业务逻辑；数据库层定义了后端数据库连接器和存储库类。将其视为ASP.NET
    MVC应用程序，其中控制器调用服务，服务引用业务层，业务层包含系统的核心业务逻辑，并使用数据库层对数据库执行CRUD（创建、读取、更新和删除）操作。依赖树将如下所示：
- en: '![](img/00064.gif)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00064.gif)'
- en: 'As per the Dependency Inversion principle, it is not recommended to instantiate
    the objects directly from each layer. This creates a tight coupling between the
    layers. To break this coupling, we can implement abstraction through interfaces
    or abstract classes. We may use some instantiation patterns like factory or dependency
    injection to instantiate objects. Moreover, we should always use interfaces rather
    than classes. Suppose in our service layer we have a reference to our business
    layer, and our service contract is using `EmployeeManager` to perform some CRUD
    operations. `EmployeeManager` contains the following methods:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 根据依赖倒置原则，不建议直接从每个层实例化对象。这会在层之间创建紧密耦合。为了打破这种耦合，我们可以通过接口或抽象类实现抽象化。我们可以使用一些实例化模式，如工厂或依赖注入来实例化对象。此外，我们应该始终使用接口而不是类。假设在我们的服务层中，我们引用了我们的业务层，并且我们的服务契约正在使用`EmployeeManager`来执行一些CRUD操作。`EmployeeManager`包含以下方法：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the service layer, we can instantiate the business layer `EmployeeManager`
    object using the new keyword. Adding more methods in the `EmployeeManager` class
    will directly use the service layer based on the access modifiers being set at
    each method. Moreover, any changes in the existing methods will break the service
    layer code. If we expose the interface to the service layer and use some factory
    or **Dependency Injection** (**DI**) patterns, it encapsulates the underlying
    implementation and exposes only those methods that are needed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务层中，我们可以使用new关键字实例化业务层`EmployeeManager`对象。在`EmployeeManager`类中添加更多方法将直接基于访问修饰符在服务层中使用。此外，对现有方法的任何更改都将破坏服务层代码。如果我们将接口暴露给服务层并使用一些工厂或**依赖注入**（**DI**）模式，它将封装底层实现并仅暴露所需的方法。
- en: 'The following code shows the `IEmployeeManager` interface being extracted from
    the `EmployeeManager` class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了从`EmployeeManager`类中提取出`IEmployeeManager`接口：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Considering the preceding example, we can inject types using dependency injection,
    so whenever the service manager is invoked, the business manager instance will
    be initialized.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到上述示例，我们可以使用依赖注入来注入类型，因此每当服务管理器被调用时，业务管理器实例将被初始化。
- en: Caching
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: Caching is one of the best practices that can be used to increase application
    performance. It is often used with data where changes are less frequent. There
    are many caching providers available that we can consider to save data and retrieve
    it when needed. It is faster than the database operation. In ASP.NET Core, we
    can use in-memory caching that stores the data in the memory of the server, but
    for a web farm or a load balancing scenario where an application is deployed to
    multiple places, it is recommended to use a distributed cache. Microsoft Azure
    also provides a Redis cache which is a distributed cache that exposes an endpoint
    that can be used to store values on the cloud and can be retrieved when they are
    needed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是可以用来提高应用程序性能的最佳实践之一。它通常与数据一起使用，其中更改不太频繁。有许多可用的缓存提供程序，我们可以考虑使用它们来保存数据并在需要时检索数据。它比数据库操作更快。在ASP.NET
    Core中，我们可以使用内存缓存，它将数据存储在服务器的内存中，但对于部署到多个地方的Web农场或负载平衡场景，建议使用分布式缓存。Microsoft Azure还提供了Redis缓存，它是一个分布式缓存，提供了一个端点，可以用来在云上存储值，并在需要时检索。
- en: 'To use the in-memory cache in the ASP.NET Core project, we can simply add the
    memory cache in the `ConfigureServices` method, which is shown as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要在ASP.NET Core项目中使用内存缓存，我们可以简单地在`ConfigureServices`方法中添加内存缓存，如下所示：
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, we can inject `IMemoryCache` in our controllers or page models through
    dependency injection and set or get values using the `Set` and `Get` methods.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过依赖注入在我们的控制器或页面模型中注入`IMemoryCache`，并使用`Set`和`Get`方法设置或获取值。
- en: Data structures
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: 'Choosing the right data structure plays a vital role in application performance.
    Before choosing any data structure, it is highly recommended to think about whether
    it is an overhead or it literally solves a particular use case. Some key factors
    to be considered while choosing an appropriate data structure are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的数据结构在应用程序性能中起着至关重要的作用。在选择任何数据结构之前，强烈建议考虑它是否是一种负担，或者它是否真正解决了特定的用例。在选择适当的数据结构时需要考虑的一些关键因素如下：
- en: Know about the type of data you need to store
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解您需要存储的数据类型
- en: Know how the data grows and whether there is any drawback when it grows
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解数据增长的方式以及在增长时是否存在任何缺点
- en: Know if you need to access your data through an index or key/value pairs and
    choose the appropriate data structure
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解是否需要通过索引或键/值对访问数据，并选择适当的数据结构
- en: Know if you need synchronized access and choose thread-safe collections
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解是否需要同步访问，并选择线程安全的集合
- en: There are many other factors when choosing the right data structure, and they
    have already been covered in [Chapter 4](part0107.html#361C60-84c100e6bea3438e8844d99ae7f5dfa9), *Data
    Structures and Writing Optimized Code in C#.*
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的数据结构时还有许多其他因素，这些因素已经在[第4章](part0107.html#361C60-84c100e6bea3438e8844d99ae7f5dfa9)中涵盖，*C#中的数据结构和编写优化代码。*
- en: Communication
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信
- en: 'Nowadays, communication has become an important epitome in any application,
    and the primary factor is the rapid evolution of technology. Applications such
    as web-based applications, mobile applications, IoT applications, and other distributed
    applications perform different types of communication over the wire. We can take
    an example of an application that has a web frontend deployed on some cloud instance,
    invoking some service deployed on a separate instance in the cloud and performing
    some backend connectivity to the database which is hosted locally. Besides this,
    we can have an IoT application that sends the room temperature by calling some
    service over the internet, and many more. Certain factors that need to be considered
    when designing distributed application are as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，通信已经成为任何应用程序中的重要缩影，主要因素是技术的快速发展。诸如基于Web的应用程序、移动应用程序、物联网应用程序和其他分布式应用程序在网络上执行不同类型的通信。我们可以以一个应用程序为例，该应用程序在某个云实例上部署了Web前端，调用了云中另一个实例上部署的某个服务，并对本地托管的数据库执行一些后端连接。此外，我们可以有一个物联网应用程序，通过互联网调用某个服务发送室温，等等。设计分布式应用程序时需要考虑的某些因素如下：
- en: Using lighter interfaces
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用轻量级接口
- en: Avoid multiple round trips to the server that adds more network latency and
    decreases application performance. Using the unit of work pattern avoids sending
    redundant operations to the server and performs one single operation to communicate
    to the backend service. The unit of work groups all the messages as a single unit
    and processes them as one unit.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 避免多次往返服务器造成更多的网络延迟，降低应用程序性能。使用工作单元模式避免向服务器发送冗余操作，并执行一次单一操作以与后端服务通信。工作单元将所有消息分组为一个单元并将它们作为一个单元进行处理。
- en: Minimizing message size
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化消息大小
- en: Use as little data as possible to communicate to the service. For example, there
    is a Person API that provides some `GET`, `POST`, `PUT`, and `DELETE` methods
    to perform a CRUD operation on that backend database. To delete a person’s record,
    we can just pass the `ID` (primary key) of the person as a parameter to the service
    rather than passing the whole object as a parameter. Moreover, use objects that
    are less bloated with properties or methods that offer a minimal set of artifacts.
    The best case is to use **POCO** (**Plain Old CLR object**) entities that have
    minimal dependencies on other objects which contain only those properties that
    are necessary to be sent across the wire.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量减少与服务通信的数据量。例如，有一个Person API提供一些`GET`、`POST`、`PUT`和`DELETE`方法来对后端数据库执行CRUD操作。要删除一个人的记录，我们可以只传递该人的`ID`（主键）作为参数传递给服务，而不是将整个对象作为参数传递。此外，使用少量属性或方法的对象，提供最小的工件集。最好的情况是使用**POCO**（**Plain
    Old CLR object**）实体，它们对其他对象的依赖性很小，只包含必须发送到网络的属性。
- en: Queuing communication
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排队通信
- en: For larger object or complex operation, decoupling the single request/response
    channel from the distributed messaging channel increases the application's performance.
    For large, chunky operations, we can design and distribute communication into
    multiple components. For example, there is a website that calls a service to upload
    an image, and, once it is uploaded, it does some processing to extract a thumbnail
    and saves it in the database. One way is to do both uploading and processing in
    a single call, but at times when the user uploads a larger image or if the image
    processing takes a longer time, the user may face a request timeout exception,
    and the request will terminate.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大的对象或复杂操作，将单一的请求/响应通道与分布式消息通道解耦会提高应用程序的性能。对于大型、笨重的操作，我们可以将通信设计和分发到多个组件中。例如，有一个网站调用一个服务来上传图像，一旦上传完成，它会进行一些处理以提取缩略图并将其保存在数据库中。一种方法是在单个调用中同时进行上传和处理，但有时当用户上传较大的图像或图像处理需要更长时间时，用户可能会遇到请求超时异常，请求将终止。
- en: 'With the queuing architecture, we can distribute these two operations into
    separate calls. The user uploads the image which is saved in the filesystem, and
    the image path will be saved into storage. A service running in the background
    will pick up that file and do the processing asynchronously. Meanwhile, when the
    backend service is processing, the control is returned to the user, where the
    user can see some in-progress notification. Finally, when the thumbnail is generated,
    the user will be notified:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过排队架构，我们可以将这两个操作分开进行。用户上传图像，该图像将保存在文件系统中，并且图像路径将保存到存储中。后台运行的服务将获取该文件并异步进行处理。与此同时，当后端服务在处理时，控制权将返回给用户，用户可以看到一些正在进行的通知。最后，当缩略图生成时，用户将收到通知：
- en: '![](img/00065.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.jpeg)'
- en: Resource management
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源管理
- en: Every server has a limited set of resources. No matter how good the server specification,
    if the application is not designed to utilize resources in an efficient manner,
    this leads to performance issues. There are certain best practices that need to
    be addressed to optimally use server resources when designing .NET Core applications.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每台服务器都有一组有限的资源。无论服务器规格多么好，如果应用程序没有设计成以高效的方式利用资源，就会导致性能问题。在设计.NET Core应用程序时，有一些需要注意的最佳实践来最大程度地利用服务器资源。
- en: Avoiding improper use of threads
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免线程的不当使用
- en: Creating a new thread for each task without monitoring or aborting the lifecycle
    of the thread is a bad practice. Threads are good to perform multitasking and
    to utilize multiple resources of the server to run things in parallel. However,
    if the design is to create threads for each request, this can slow down the application's
    performance, as the CPU will take more time in the context of switching between
    the threads rather than executing the actual job.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个任务创建一个新线程，而不监视或中止线程的生命周期是一种不好的做法。线程适合执行多任务和利用服务器的多个资源并行运行。然而，如果设计是为每个请求创建线程，这会减慢应用程序的性能，因为CPU在线程之间切换的上下文中花费的时间比执行实际工作更多。
- en: Whenever we use threads, we should always try to keep a shared thread pool where
    any new item that needs to be executed waits in the queue if the thread is busy,
    and is acquired when it is available. This way, thread management is easy and
    server resources will be used efficiently.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每当使用线程时，我们应该尽量保持一个共享的线程池，任何需要执行的新项目都会在队列中等待，如果线程忙碌，则在可用时获取。这样，线程管理就变得简单，服务器资源也会被有效利用。
- en: Disposing objects in a timely fashion
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 及时释放对象
- en: '**CLR** (**Common Language Runtime**) provides automatic memory management,
    and the objects instantiated with a new keyword do not require to be garbage collected
    explicitly; **GC** (**Garbage Collection**) does the job. However, non-managed
    resources are not automatically released by the GC and should be explicitly collected
    by implementing the `IDisposable` interface. Such resources could be database
    connections, file handlers, sockets, and so on. To learn more about disposing
    of unmanaged resources in .NET Core, please refer to [Chapter 6](part0161.html#4PHAI0-84c100e6bea3438e8844d99ae7f5dfa9),
    *Memory Management Techniques in .NET Core.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**CLR**（**公共语言运行时**）提供自动内存管理，使用new关键字实例化的对象不需要显式进行垃圾回收；**GC**（**垃圾回收**）会处理。然而，非托管资源不会被GC自动释放，应该通过实现`IDisposable`接口来显式进行回收。这些资源可能是数据库连接、文件处理程序、套接字等。要了解更多关于在.NET
    Core中处理非托管资源的信息，请参考[第6章](part0161.html#4PHAI0-84c100e6bea3438e8844d99ae7f5dfa9)，*在.NET
    Core中的内存管理技术*。'
- en: Acquiring resources when they are required
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在需要时获取资源
- en: Always acquire resources only when they are required. Instantiating objects
    ahead of time is not a good practice. It takes unnecessary memory and utilizes
    resources of the system. Furthermore, use *try*, *catch,* and *finally* to block
    and release objects in the *finally* block. This way, if any exception occurs,
    the objects which have been instantiated within the method will be released.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在需要时才获取资源。提前实例化对象不是一个好的做法。这会占用不必要的内存并利用系统资源。此外，使用*try*、*catch*和*finally*来阻塞和释放*finally*块中的对象。这样，如果发生任何异常，方法内部实例化的对象将被释放。
- en: Concurrency
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: In concurrent programming, many objects may access the same resource at the
    same time, and keeping them thread-safe is the primary objective. In .NET Core,
    we can use locks to provide synchronized access. However, there are cases where
    a thread has to wait for a longer time to get access to resources, and this makes
    applications unresponsive.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发编程中，许多对象可能同时访问同一资源，保持它们线程安全是主要目标。在.NET Core中，我们可以使用锁来提供同步访问。然而，有些情况下，线程必须等待较长时间才能访问资源，这会导致应用程序无响应。
- en: The best practice is to apply for synchronized access only for those specific
    lines of code where the actual resource needs to be thread-safe, for example,
    where the locks can be used, which are the database operations, file handling,
    bank account access, and many other critical sections in the application. These
    need synchronized access so that they can be handled one thread at a time.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是仅对那些需要线程安全的特定代码行应用同步访问，例如可以使用锁的地方，这些是数据库操作、文件处理、银行账户访问以及应用程序中许多其他关键部分。这些需要同步访问，以便一次处理一个线程。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Writing cleaner code, following the architecture and design principles, and
    adhering to the best practices play a significant role in application performance.
    If the code if baggy and repetitive, it can increase the chances of errors, increase
    complexity, and affect performance.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 编写更清洁的代码，遵循架构和设计原则，并遵循最佳实践在应用程序性能中起着重要作用。如果代码臃肿和重复，会增加错误的机会，增加复杂性，并影响性能。
- en: In this chapter, we have learned some coding principles that make the application
    code look cleaner and easier to understand. If the code is clean, it offers other
    developers a way to understand it completely and helps in many other ways. Later
    on, we learned some basic design principles that are considered to be the core
    principles when designing applications. Principles such as KISS, YAGNI, DRY, Separation
    of Concerns, and SOLID are highly essential in software design, and caching and
    choosing the right data structure have a significant impact on performance and
    increase performance if they are used properly. Finally, we learned some best
    practices that should be considered when handling communication, resource management,
    and concurrency.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一些编码原则，使应用程序代码看起来更清晰，更容易理解。如果代码干净，它可以让其他开发人员完全理解，并在许多其他方面提供帮助。随后，我们学习了一些被认为是设计应用程序时的核心原则的基本设计原则。诸如KISS、YAGNI、DRY、关注分离和SOLID等原则在软件设计中非常重要，缓存和选择正确的数据结构对性能有重大影响，如果使用得当可以提高性能。最后，我们学习了一些在处理通信、资源管理和并发时应考虑的最佳实践。
- en: The next chapter is a detailed introduction to memory management, where we will
    explore some techniques of memory management in .NET Core.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是对内存管理的详细介绍，在这里我们将探讨.NET Core中的一些内存管理技术。
