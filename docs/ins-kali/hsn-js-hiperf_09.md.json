["```js\n{\n    \"version\" : \"0.0.1\",\n    \"name\"    : \"microserver\",\n    \"type\"    : \"module\"\n}\n```", "```js\nimport http2 from 'http2'\nimport fs from 'fs'\n```", "```js\nconst server = http2.createSecureServer({\n    key: fs.readFileSync('selfsignedkey.pem'),\n    cert: fs.readFileSync('selfsignedcertificate.pem')\n});\n```", "```js\nserver.on('error', (err) => {\n    console.error(err);\n    process.exit();\n});\nserver.on('stream', (stream, headers) => {\n    stream.respond({\n       'content-type': 'text/html',\n        ':status': 200\n    });\n    stream.end(\"A okay!\");\n});\n```", "```js\nError: ENOENT: no such file or directory, open 'selfsignedkey.pem'\n```", "```js\n> openssl req -newkey rsa:2048 -nodes -keyout selfsignedkey.pem -x509 -days 365 -out selfsignedcertificate.pem\n```", "```js\n\"config\" : {\n    \"port\" : 50000,\n    \"key\"  : \"selfsignedkey.pem\",\n    \"certificate\" : \"selfsignedcertificate.pem\",\n    \"template\" : \"template\",\n    \"body_files\" : \"publish\"\n},\n\"scripts\" : {\n   \"start\": \"node --experimental-modules main.js\"   \n}\n```", "```js\nconst ENV_VARS = process.env;\nconst port = ENV_VARS.npm_package_config_port || 80;\nconst key  = ENV_VARS.npm_package_config_key || 'key.pem';\nconst cert = ENV_VARS.npm_package_config_certificate || 'cert.pem';\nconst templateDirectory = ENV_VARS.npm_package_config_template || 'template';\nconst publishedDirectory = ENV_VARS.npm_package_config_bodyFiles || 'body';\n```", "```js\n<header>\n    <h1>Our Website</h1>\n    <nav>\n        <a href=\"/all\">All Articles</a>\n        <a href=\"/contact\">Contact Us</a>\n        <a href=\"/about\">About Us</a>\n    </nav>\n</header>\n```", "```js\n<footer>\n    <p>Created by: Me</p>\n    <p>Contact: <a href=\"mailto:me@example.com\">Me</a></p>\n</footer>\n```", "```js\n<nav>\n    <% loop 5\n    <a href=\"article/${location}\">${name}</a>\n    %>\n</nav>\n```", "```js\n*, html {\n    margin : 0;\n    padding : 0;\n}\n:root {\n   --main-color : \"#003A21\"; \n   --text-color : \"#efefef\";\n}\n/* header styles */\nheader {\n    background : var(--main-color);\n    color      : var(--text-color);\n}\n/* Footer styles */\nfooter {\n    background : var(--main-color);\n    color  : var(--text-color);\n}\n```", "```js\n<!DOCTYPE html>\n<html>\n    <head>\n        <link rel=\"stylesheet\"  type=\"text/css\" href=\"css/main.css\" />\n    </head>\n    <body>\n        <% from html header %>\n        <% from html sidebar %>\n        <% from html footer %>\n    </body>\n</html>\n```", "```js\nimport { Transform } from 'stream'\nclass Pair {\n    start = -1\n    end = -1\n}\nexport default class TemplateBuilder extends Transform {\n    #pattern = []\n    #pair = new Pair()\n    #beforePattern = Buffer.from(\"<%\")\n    #afterPattern = Buffer.from(\"%>\")\n    constructor(opts={}) {\n        super(opts);\n    }\n    _transform(chunk, encoding, cb) {\n        // process data\n    }\n}\n```", "```js\n// inside the _transform function\nif(!this.#pattern.length && !this.#pair.start) {\n    location = chunk.indexOf(this.#beforePattern, location);\n    if( location !== -1 ) {\n        this.#pair.start = location;\n        location += 2;\n    } else {\n        return cb();\n   }\n}\n```", "```js\nif( this.#pair.start !== -1 ) {\n    location = chunk.indexOf(this.#afterPattern, location);\n    if( location !== -1 ) {\n        this.#pair.end = location;\n        this.push(processPattern(chunk.slice(this.#pair.start,this.#pair.end)));\n        this.#pair = new Pair();\n    } else {\n        this.#pattern.push(chunk.slice(this.#pair.start));\n    }\n}\n```", "```js\nlocation = chunk.indexOf(this.#afterPattern, location);\nif( location !== -1 ) {\n    this.#pattern.push(chunk.slice(0, location));\n    this.push(processPattern(Buffer.concat(this.#pattern)));\n    this.#pattern = [];\n} else {\n    this.#pattern.push(chunk);\n}\n```", "```js\ndo {\n  // transformation code\n} while( location !== -1 );\ncb();\n```", "```js\nconsole.log(pattern.toString('utf8'));\n```", "```js\nimport TemplateStream from './template.js';\nconst file = fs.createReadStream('./template/main.html');\nconst tStream = new TemplateStream();\nfile.pipe(tStream);\n```", "```js\nloop 5\n    <a href=\"article\"/${location}\">${name}</a>\n```", "```js\n#template = null\nconstructor(opts={}) {\n    if( opts.templateDirectory ) {\n        this.#template = opts.templateDirectory;\n    }\n    super(opts);\n}\n```", "```js\nconst _process = pattern.toString('utf8').trim();\nconst LOOP = \"loop\";\nconst FIND = \"from\";\nconst breakdown = _process.split(' ');\nswitch(breakdown[0]) {\n    case LOOP:\n        const num = parseInt(breakdown[1]);\n        const bufs = new Array(num);\n        for(let i = 0; i < num; i++) {             \n           bufs[i] = Buffer.from(breakdown.slice(2).join(''));\n        }\n        break;\n   case FIND:\n        console.log('we have a find loop', breakdown);\n        break;\n   default:\n        return new Error(\"No keyword found for processing! \" + \n         breakdown[0]);\n}\n```", "```js\n<% loop 5 articles\n    <a href=\"article/${location}\">${name}</a>\n%>\n```", "```js\nconst tStream = new TemplateStream({\n    templateDirectory,\n    templateVariables : {\n        sidebar : [\n            {\n                location : temp1,\n                name     : 'article 1'\n            }\n        ]\n    }\n}\n```", "```js\nconst num = parseInt(breakdown[1]);\nconst bufs = new Array(num);\nconst varName = breakdown[2].trim();\nfor(let i = 0; i < num; i++) {\n    let temp = breakdown.slice(3).join(' ');\n    const replace = /\\${([0-9a-zA-Z]+)}/\n    let results = replace.exec(temp);           \n    while( results ) {\n        if( vars[varName][i][results[1]] ) {\n            temp = temp.replace(results[0], vars[varName][i][results[1]]);\n        }\n       results = replace.exec(temp);                \n    }\n    bufs[i] = Buffer.from(temp);\n}\nreturn Buffer.concat(bufs);\n```", "```js\ncase FIND: {\n    const type = breakdown[1];\n    const HTML = 'html';\n    const CSS  = 'css';\n    if(!(type === HTML || type === CSS)) return new Error(\"This is not a\n     valid template type! \" + breakdown[1]);\n    return fs.readFileSync(path.join(templateDirectory, type, `${breakdown[2]}.${type}`));\n}\n```", "```js\nimport { Transform, PassThrough } from 'stream'\nimport { once } from 'events'\n```", "```js\nexport class LoopingStream extends Transform {\n    #numberOfRolls = 1\n    #data = []\n    #dir = null\n    #vars = null\n    constructor(opts={}) {\n        super(opts);\n        if( 'loopAmount' in opts ) {\n            this.#numberOfRolls = opts.loopAmount\n        }\n        if( opts.vars ) {\n            this.#vars = opts.vars;\n        }\n        if( opts.dir) {\n            this.#dir = opts.dir;\n        }\n    }\n    _transform(chunk, encoding, cb) {\n        this.#data.push(chunk);\n        cb();\n    }\n    _flush(cb) {\n    }\n}\n```", "```js\nasync _flush(cb) {\n    let tData = Buffer.concat(this.#data);\n    let tempBuf = [];\n    for(let i = 0; i < this.#numberOfRolls; i++) {\n        const passThrough = new PassThrough();\n        const templateBuilder = new TemplateBuilder({ templateDirectory :\n        this.#dir, templateVariables : this.#vars });\n        passThrough.pipe(templateBuilder);\n        templateBuilder.on('data', (data) => {\n            tempBuf.push(data);\n        });\n        passThrough.end(tData);\n        await once(templateBuilder, 'end');\n        tData = Buffer.concat(tempBuf);\n        tempBuf = [];\n    }\n    this.push(tData);\n    cb();\n}\n```", "```js\nconst file = fs.createReadStream('./template/main.html');\nconst testOut = fs.createWriteStream('test.html');\nconst tStream = new LoopingStream({\n    dir : templateDirectory,\n    vars : { //removed for simplicity sake },\n    loopAmount : 2\n});\nfile.pipe(tStream).pipe(testOut);\n```", "```js\nstream.respond({\n        'content-type': 'text/html',\n        ':status': 200\n    });\n    const file = fs.createReadStream('./template/main.html');\n    const tStream = new LoopingStream({\n        dir: templateDirectory,\n        vars : { //removed for readability }\n},\n        loopAmount : 2\n    })\n    file.pipe(tStream).pipe(stream);\n});\n```", "```js\nconst FILE_TYPES = new Map([\n    ['.css', path.join('.', templateDirectory, 'css')],\n    ['.html', path.join('.', templateDirectory, 'html')]\n]);\n```", "```js\nconst p = headers[':path'];\nfor(const [fileType, loc] of FILE_TYPES) {\n    if( p.endsWith(fileType) ) {\n        stream.respondWithFile(\n            path.join(loc, path.posix.basename(p)),\n            {\n                'content-type': `text/${fileType.slice(1)}`,\n                ':status': 200\n            }\n        );\n        return;\n    }     \n}\n```", "```js\nhttps:localhost:50000/articles/1 maps to <publishedDirectory>/articles/1.md\n```", "```js\ntry {\n    const f = fs.statSync(path.join('.', publishedDirectory, p));\n    stream.respond({\n        'content-type': 'text/html',\n        ':status': 200\n    });\n    const file = fs.createReadStream('./template/main.html');\n    const tStream = new LoopingStream({\n        dir: templateDirectory,\n        vars : { },\n        loopAmount : 2\n    })\n    file.pipe(tStream).pipe(stream);\n} catch(e) {\n    stream.respond({\n        'content-type': 'text/html',\n        ':status' : 404\n    });\n    stream.end('File Not Found! Turn Back!');\n    console.warn('following file requested and not found! ', p);\n}\n```", "```js\nconst f = fs.statSync(path.join('.', publishedDirectory, `${p}.md`));\n```", "```js\nimport Remarkable from 'remarkable'\n```", "```js\nconst processPattern = function(pattern, templateDir, publishDir, vars=null) {\n    const process = pattern.toString('utf8').trim();\n    const LOOP = \"loop\";\n    const FIND = \"from\";\n    const FILE = \"file\";\n    const breakdown = process.split(' ');\n    switch(breakdown[0]) {\n      // previous case statements removed for readability\n        case FILE: {\n            const file = breakdown[1];\n            return fs.readFileSync(path.join(publishDir, file));\n        }\n        default:\n            return new Error(\"Process directory not found! \" +  \n             breakdown[0]);\n    }\n}\n```", "```js\nexport default class TemplateBuilder extends Transform {\n    #pattern = []\n    #publish = null\n    constructor(opts={}) {\n        super(opts);\n        if( opts.publishDirectory ) {\n            this.#publish = opts.publishDirectory;\n        }\n    }\n    _transform(chunk, encoding, cb) {\n        let location = 0;\n        do {\n            if(!this.#pattern.length && this.#pair.start === -1 ) {\n                // code from before\n            } else {\n                if( this.#pair.start !== -1 ) {\n                        this.push(processPattern(chunk.slice(this.#pair.start,\nthis.#pair.end), this.#template, this.#publish, this.#vars)); //add publish to our processPattern function\n                } \n            } \n        } while( location !== -1 );\n    }\n}\n```", "```js\nexport class LoopingStream extends Transform {\n    #publish = null\n    constructor(opts={}) {\n        super(opts);\n        if( opts.publish ) {\n            this.#publish = opts.publish;\n        }\n    }\n    async _flush(cb) {\n        for(let i = 0; i < this.#numberOfRolls; i++) {\n            const passThrough = new PassThrough();\n            const templateBuilder = new TemplateBuilder({\n                templateDirectory : this.#dir,\n                templateVariables : this.#vars,\n                publishDirectory  :this.#publish\n            });\n        }\n        cb();\n    }\n}\n```", "```js\n<!DOCTYPE html>\n<html>\n    <head>\n        <link rel=\"stylesheet\"  type=\"text/css\" href=\"css/main.css\" />\n    </head>\n    <body>\n        <% from html header %>\n        <% from html sidebar %>\n        <% file first.md %>\n        <% from html footer %>\n    </body>\n</html>\n```", "```js\nconst tStream = new LoopingStream({\n        dir: templateDirectory,\n        publish: publishedDirectory,\n        vars : {\n}});\n```", "```js\nconst MarkdownRenderer = new Remarkable.Remarkable();\nconst processPattern = function(\u2026) {\n      switch(breakdown[0]) {\n            case FILE: {\n                  const file = breakdown[1];\n                  const html =\nMarkdownRenderer.render(fs.readfileSync(path.join(publishDir, file)\n).toString('utf8'));\n            return Buffer.from(html);\n            }\n      }\n}\n```", "```js\ncase FILE: {\n    const file = breakdown[1];\n    const html =\n    MarkdownRenderer.render(fs.readFileSync(path.join(publishDir,  \n    vars.fileToProcess || file)).toString('utf8'));\n    return Buffer.from(html);\n}\n```", "```js\nconst p = headers[':path'];\nconst tStream = new LoopingStream({\n    dir: templateDirectory,\n    publish: publishedDirectory,\n    vars : {\n        articles : [ ],\n        fileToProcess : `${p}.md`\n    },\n    loopAmount : 2\n});\n```", "```js\n<body>\n    <% from html header %>\n    <% from html sidebar %>\n    <% file base.md %>\n    <% from html footer %>\n</body>\n```", "```js\nexport default class LRUCache {\n    #cache = new Map()\n}\n```", "```js\n#numEntries = 10\nconstructor(num=10) {\n    this.#numEntries = num\n}\n```", "```js\nadd(file, url) {\n    const val = {\n        page : file,\n        time : Date.now()\n    }\n    if( this.#cache.size === this.#numEntries ) {\n        // do something\n        return;\n    }\n    this.#cache.set(url, val);\n}\n```", "```js\nget(url) {\n    const val = this.#cache.get(url);\n    if( val ) {\n        val.time = Date.now();\n        this.#cache.set(url, val);\n        return val.page;\n    }\n    return null;\n}\n```", "```js\nif( this.#cache.size === this.#numEntries ) {\n    let top = Number.MAX_VALUE;\n    let earliest = null;\n    for(const [key, val] of this.#cache) {\n        if( val.time < top ) {\n            top = val.time;\n            earliest = key;\n        }\n    }\n    this.#cache.delete(earliest);\n}\n```", "```js\nimport cache from './cache.js'\nconst serverCache = new cache();\n```", "```js\nconst cacheHit = serverCache.get(p);\nif( cacheHit ) {\n    stream.end(cacheHit);\n} else {\n    const file = fs.createReadStream('./template/main.html');\n    const tStream = new LoopingStream({\n        dir: templateDirectory,\n        publish: publishedDirectory,\n        vars : { /* shortened for readability */ },\n        loopAmount : 2\n    });\n    file.pipe(tStream);\n    tStream.once('data', (data) => {\n        serverCache.add(data, p);\n        stream.end(data);\n    });\n}\n```", "```js\nconst serverCache = new cache(1);\n```", "```js\nimport cluster from 'cluster'\n```", "```js\nif( cluster.isMaster ) {\n    const numCpus = os.cpus().length;\n    for(let i = 0; i < numCpus; i++) {\n        cluster.fork();\n    }\n    cluster.on('exit', (worker, code, signal) => {\n        console.log(`worker ${worker.process.pid} died`);\n    });\n} else {\n    const serverCache = new cache();\n    // all previous server logic\n}\n```"]