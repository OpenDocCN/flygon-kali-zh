- en: Basic GUI Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本GUI开发
- en: Sometimes, we write programs that are all about raw functionality. However,
    we often write programs that are generally used by us or other users who expect
    the process of their interaction with us to be streamlined. In this chapter, we
    will see the basic functions of the **Graphical User Interface **(**GUI**) in
    NetBeans. A couple of things that define truly amazing software programs are their
    GUI and user experience. You will learn how to create an application window with
    the `JFrame` class by setting its size, adding labels to it, and closing the application
    on the whole. Then comes the topic of the GUI editor, that is, palette; here,
    we'll see a working instance of palette and the components available in it. Finally,
    you'll learn how to trigger events by adding a button and adding functionality
    to it.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们编写的程序完全关乎原始功能。然而，我们经常编写的程序通常由我们或其他用户使用，他们期望与我们互动的过程变得流畅。在本章中，我们将看到NetBeans中**图形用户界面**（**GUI**）的基本功能。真正了不起的软件程序的几个定义是它们的GUI和用户体验。您将学习如何使用`JFrame`类创建应用程序窗口，设置其大小，向其添加标签，并关闭整个应用程序。然后是GUI编辑器的主题，即调色板；在这里，我们将看到调色板的工作实例以及其中可用的组件。最后，您将学习如何通过添加按钮并向其添加功能来触发事件。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Swing GUIs
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swing GUI
- en: A visual GUI editor tool – palette
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可视化GUI编辑工具 - 调色板
- en: Event handling
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理
- en: Swing GUIs
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swing GUI
- en: NetBeans is a powerful program that offers a lot of functionality, and we access
    this functionality through a GUI and the menus and buttons provided by NetBeans.
    In theory, we could have chosen to operate NetBeans as a command-line program,
    but in order to use NetBeans like that, we would have to memorize or look up a
    large library of specific commands for every action we would want to take. A powerful
    and well-written application has a streamlined interface that will guide us toward
    important functionality and make it easy for us to access it. The JDK contains
    a Java extension library, the `swing` library, which makes it very easy for us
    to wrap our own code in GUIs like the one NetBeans has.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans是一个功能强大的程序，提供了许多功能，我们通过NetBeans提供的GUI、菜单和按钮来访问这些功能。理论上，我们可以选择将NetBeans作为一个命令行程序来操作，但是为了像那样使用NetBeans，我们将不得不记住或查找一个大型的特定命令库，以执行我们想要执行的每个操作。一个功能强大且写得很好的应用程序具有流畅的界面，将引导我们进入重要的功能，并使我们轻松访问它。JDK包含一个Java扩展库，即`swing`库，它使我们能够非常容易地将我们自己的代码包装在像NetBeans这样的GUI中。
- en: The JFrame class
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JFrame类
- en: 'To start off on this track, we''re going to write a program that will open
    up a new GUI window. The steps are as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这个跟踪，我们将编写一个程序，将打开一个新的GUI窗口。步骤如下：
- en: 'At the heart of the `swing` Java GUIs is the `JFrame` class. In our case, this
    class will be the actual window object that our operating system will handle and
    that we could move around our screen. We can create a new `JFrame` class as we
    might create any other object. We can even pass some parameters to this `JFrame`
    class''s creation. If we just give it a string parameter, we''ll be telling the
    `JFrame` class what to present as its name:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`swing` Java GUI中心是`JFrame`类。在我们的情况下，这个类将是我们的操作系统处理的实际窗口对象，我们可以在屏幕上移动它。我们可以创建一个新的`JFrame`类，就像创建任何其他对象一样。我们甚至可以向这个`JFrame`类的创建传递一些参数。如果我们只给它一个字符串参数，我们将告诉`JFrame`类要将什么作为它的名称呈现出来：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we''ve declared a `JFrame` class, it''s simply going to exist in Java''s
    memory like any other object. It won''t present itself to the user until we explicitly
    tell it to. It will simply be a function call to the `setVisible` function and
    we will assign the value `true` to this function, pretty easy right:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们声明了`JFrame`类，它就会像任何其他对象一样存在于Java的内存中。除非我们明确告诉它，否则它不会呈现给用户。它只是一个对`setVisible`函数的函数调用，我们将为这个函数分配值`true`，非常简单对吧：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There''s one more thing we should do before we make JFrame window visible and
    that''s to call the `pack` method:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们使JFrame窗口可见之前，我们还应该调用`pack`方法：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we create more complicated frames, they may contain a lot of information,
    and in a GUI, much of this information takes up visible space. The `pack` method
    basically prebuilds the physical relationships between the objects in the frame
    and ensures that the frame doesn''t behave oddly when it actually appears visible
    to the user. So we''ve written a really simple program so far – only three lines
    of code and no real thought required on our part:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建更复杂的框架时，它们可能包含大量信息，在GUI中，这些信息占据了可见空间。`pack`方法基本上预先构建了框架中对象之间的物理关系，并确保当它实际对用户可见时，框架不会表现出奇怪的行为。到目前为止，我们已经编写了一个非常简单的程序
    - 只有三行代码，我们不需要考虑太多：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we run this program, it might appear that nothing has happened, but something
    has. In the top left-hand corner of the screen, a new window has appeared. If
    we click on the right-hand side of this window, we can, in theory, drag it around
    or just resize the window:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，可能会看起来什么都没有发生，但实际上是有的。在屏幕的左上角，出现了一个新窗口。如果我们点击这个窗口的右侧，理论上我们可以拖动它或者调整窗口的大小：
- en: '![](img/6e502859-8e4b-4bb0-b330-c85e7d2c2665.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e502859-8e4b-4bb0-b330-c85e7d2c2665.png)'
- en: This is a fully fledged window that our operating system can now handle, allowing
    us to move around; it even supports dynamic resizing. You'll see that our header
    has also been appended to our window. So that's super basic.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全成熟的窗口，我们的操作系统现在可以处理，允许我们移动; 它甚至支持动态调整大小。您会看到我们的标题也已附加到我们的窗口上。所以这非常基础。
- en: Setting the size of our window
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置窗口的大小
- en: Now let's see what else we can do with our existing `JFrame` class. When our
    JFrame window appeared, it was very small and hard to see. A program window of
    such a size is never really going to be useful to anyone, so let's see what powers
    `frame` gives us in terms of setting the window's size. Often, we're going to
    use the `setPreferredSize` method to apply a size to our `JFrame` class. There
    is also a `setSize` method, but this method will not give us exactly what we expect
    it to at all times. This is because right now our `JFrame` class is set to be
    resizable, and it's not appropriate for us to explicitly assign a size to it;
    rather, we should instruct it that given no other input from the user, meaning
    resizing JFrame window, the window should be a certain size.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们的现有`JFrame`类还能做些什么。当我们的JFrame窗口出现时，它非常小而且很难看到。这样大小的程序窗口永远不会对任何人有用，所以让我们看看`frame`在设置窗口大小方面给我们的能力。通常，我们会使用`setPreferredSize`方法来为我们的`JFrame`类应用大小。还有一个`setSize`方法，但是这个方法并不总是给我们期望的结果。这是因为现在我们的`JFrame`类被设置为可调整大小，我们不应该明确地为它分配一个大小；相反，我们应该指示它在没有用户的其他输入的情况下，即调整JFrame窗口大小，窗口应该是某个大小。
- en: 'We can store, manipulate, and create size information using the `Dimension`
    class. To construct a new dimension, we can simply give it a width and height.
    So let''s set `JFrame` class''s preferred size, the size it would like to be until
    we stretch it, to `400 x 400`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Dimension`类来存储、操作和创建大小信息。要构造一个新的维度，我们只需给它一个宽度和高度。所以让我们将`JFrame`类的首选大小，即在拉伸之前它想要的大小，设置为`400
    x 400`：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Dimension` class lives in another library, so we''ll have to import the `java.awt.*;`
    package, then we should be able to build and compile our project and once again
    open up our new GUI:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dimension`类位于另一个库中，所以我们需要导入`java.awt.*;`包，然后我们应该能够构建和编译我们的项目，然后再次打开我们的新GUI：'
- en: '![](img/c0714f29-7547-4158-ae40-3f7895cf4d19.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0714f29-7547-4158-ae40-3f7895cf4d19.png)'
- en: Now we get a nice squared GUI to start with; however, it's still pretty useless
    as there's nothing contained within this GUI.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个不错的正方形GUI来开始；但是，因为里面没有任何内容，它仍然相当无用。
- en: Adding a label
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个标签
- en: 'Now let''s take a quick look at how to add elements to our GUI from a programming
    standpoint. Quite possibly the simplest element that we could put inside `JFrame`
    is `JLabel`. Labels are responsible for containing text, and instantiating them
    is extremely simple. We simply tell them what text they should contain. Of course,
    in more complicated programs and GUIs, this text can become dynamic and may change,
    but for now, let''s just get some text to display:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从编程角度快速看一下如何向我们的GUI添加元素。可能我们可以放在`JFrame`中的最简单的元素是`JLabel`。标签负责包含文本，实例化它们非常简单。我们只需告诉它们应该包含什么文本。当然，在更复杂的程序和GUI中，这个文本可能会变得动态并且可能会改变，但现在，让我们只是显示一些文本：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Simply declaring that we have a `JLabel` class is not enough. We have not yet
    associated this label object in any way with our existing frame. Our frame, as
    you can probably tell by the vast array of methods and members it exposes, has
    a whole lot of components, and we need to know in which of these components we
    need to place our new `JLabel` class:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅声明我们有一个`JLabel`类是不够的。我们还没有以任何方式将这个标签对象与我们现有的窗口关联起来。我们的窗口，你可能可以通过它公开的大量方法和成员来看出来，有很多组件，我们需要知道我们需要将我们的新`JLabel`类放在这些组件中的哪一个：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'One of the components within our `JFrame` class is `contentPane`; that''s the
    area that we visibly see inside the window where things normally go in a program''s
    GUI. This seems like a reasonable place for us to add a new component, in this
    case, `label`. Once again, let''s build our program, kill the old instance, and
    run the new program:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`JFrame`类中的一个组件是`contentPane`；那是我们在窗口内可见的区域，通常程序的GUI中的东西都放在那里。这似乎是我们添加新组件的一个合理位置，在这种情况下是`label`。再一次，让我们构建我们的程序，关闭旧实例，然后运行新程序：
- en: '![](img/9ceda3ee-3b74-470a-b2be-eddfffad4092.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ceda3ee-3b74-470a-b2be-eddfffad4092.png)'
- en: There we go! Now we have text in our GUI; we've successfully added an element
    to the content of our JFrame window.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的GUI中有文本了！我们成功地向我们的JFrame窗口的内容中添加了一个元素。
- en: Closing our application
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭我们的应用程序
- en: 'One thing that''s kind of annoying is that our program is continuing to run
    even after we close the associated GUI. That''s a little silly. When I press the
    close button on the NetBeans GUI, NetBeans closes itself and stops running as
    a process on my system. We can instruct our frame to terminate the associated
    process using its `setDefaultCloseOperation` method. This method has the return
    type `void` and takes an integer as a value. This integer is an enumerator, and
    there''s lots of options available to us. All of these options are statically
    declared by the `JFrame` class, and the one we''re probably looking for is `EXIT_ON_CLOSE`,
    which will exit our application when we close our window. Build and run the program,
    and terminate the GUI, and there goes our process, which is not quietly running
    in the background anymore:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有点烦人的是，我们的程序在关闭关联的GUI后仍在继续运行。这有点傻。当我在NetBeans GUI上按关闭按钮时，NetBeans关闭自身，并在我的系统上停止运行作为一个进程。我们可以使用它的`setDefaultCloseOperation`方法指示我们的窗口终止关联的进程。这个方法的返回类型是`void`，并且以整数值作为参数。这个整数是一个枚举器，有很多选项可供我们选择。所有这些选项都是由`JFrame`类静态声明的，我们可能正在寻找的是`EXIT_ON_CLOSE`，当我们关闭窗口时，它将退出我们的应用程序。构建和运行程序，终止GUI，我们的进程也随之结束，不再悄悄地在后台运行：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That's our basic introduction to GUIs in Java. Creating a GUI is complicated,
    but it is exciting as well because it's visual and immediate; also, it is really
    powerful.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们对Java中GUI的基本介绍。创建GUI很复杂，但也很令人兴奋，因为它是视觉和即时的；而且它真的很强大。
- en: As our program stands right now as shown in the following code block, it's functional,
    but were we to extend it, we might eventually run into some very odd and confusing
    issues. What we've done now flies in the face of the recommended practices when
    creating a new GUI. These recommended practices are in place to protect us from
    some very low-level issues that can occur when our programs become multithreaded.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如下面的代码块所示，我们的程序现在是功能性的，但如果我们要扩展它，我们可能最终会遇到一些非常奇怪和令人困惑的问题。我们现在所做的与创建新GUI时的推荐做法相悖。这些推荐做法是为了保护我们免受程序变得多线程时可能出现的一些非常低级的问题。
- en: 'What does it mean when we say that our program is multithreaded? Well, when
    we create our GUI, when we cause it to come into being, our program goes from
    performing a single task, which is simply executing the `main` method from start
    to finish, to performing multiple tasks. This is because we are now executing
    the following code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说我们的程序是多线程的时，这是什么意思？嗯，当我们创建我们的GUI，当我们使它出现时，我们的程序从执行单个任务，即简单地从头到尾执行`main`方法，变成执行多个任务。这是因为我们现在正在执行以下代码：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, in addition, the code is also managing the new window we've created
    and any functionality performed by that window. To protect ourselves from the
    complexities of multithreaded code, it's recommended that we create our new Swing
    GUI by allowing one of the Swing utilities to construct this GUI for us asynchronously.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，此外，该代码还管理了我们创建的新窗口以及该窗口执行的任何功能。为了保护自己免受多线程代码的复杂性，建议我们通过允许Swing实用程序异步地为我们构建此GUI来创建我们的新Swing
    GUI。
- en: 'In order to make this happen, we''re actually going to need to pull all of
    the code we''ve written out of our `main` method and place it in one place where
    we can reference it from our `main` method. This will be a new function as shown
    in the following code line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们实际上需要将我们写的所有代码从`main`方法中提取出来，放在一个地方，我们可以从`main`方法中引用它。这将是一个新的函数，如下面的代码行所示：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can just paste all of this code back to our new function:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把所有这些代码都粘贴回我们的新函数中：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The SwingUtilities class
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SwingUtilities类
- en: 'Now, let''s take a look at how Swing recommends we cause our GUI to come into
    being. As I said, the `swing` package provides us some functionality that will
    perform this vast amount of work and thinking for us. The `SwingUtilities` class
    has a static `invokeLater` method that will create our GUI when no other thread
    really needs to be processed or when all of the other thinking is done for a bit:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看Swing建议我们如何使我们的GUI出现。正如我所说，`swing`包为我们提供了一些功能，可以为我们执行这么多的工作和思考。`SwingUtilities`类有一个静态的`invokeLater`方法，当没有其他线程真正需要被处理或者所有其他思考都做完一会儿时，它将创建我们的GUI：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This `invokeLater` method expects us to pass in a `Runnable` object to it,
    so we''re going to have to create one of the `Runnable` objects for ourselves:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`invokeLater`方法希望我们向它传递一个`Runnable`对象，所以我们将不得不为自己创建一个`Runnable`对象：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Runnable` objects are those that can be converted into a thread of their
    own. They have a method that we''re going to override, called `run`, and the `SwingUtilities.invokeLater`
    method will call the `run` method of `Runnable` when appropriate. When this occurs,
    all we want it to do is call our `MakeGUI` method and begin executing the code
    that we''ve just tested out, the one that will create a GUI. We''ll add the `Override`
    notation to be good Java programmers and pass our new `Runnable` object to the
    `invokeLater` method of `SwingUtilities`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runnable`对象是可以转换为自己的线程的对象。它们有一个我们将要重写的方法，叫做`run`，`SwingUtilities.invokeLater`方法将在适当时调用`Runnable`的`run`方法。当这发生时，我们希望它只是调用我们的`MakeGUI`方法并开始执行我们刚刚测试过的代码，那个将创建GUI的代码。我们将添加`Override`注释以成为良好的Java程序员，并将我们的新`Runnable`对象传递给`SwingUtilities`的`invokeLater`方法：'
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run the preceding program and there we go! The functionality is exactly the
    same, and what we''ve done could arguably be overkill for a program this small;
    however, it''s really good for us to take a look at what we should expect to see
    in a larger software project, where things such as multithreading could become
    a concern. We went through this a bit quickly, so let''s stop and take a look
    at this section once again:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述程序，我们成功了！功能完全相同，我们所做的可能对于这么小的程序来说有点过度；然而，对于我们来说，看看我们在一个更大的软件项目中应该期望看到的东西是非常有益的，比如多线程可能会成为一个问题。我们走得有点快，所以让我们停下来再看一下这一部分：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: What we've done in this bit of code is create an anonymous class. While it looks
    like we've created a new `Runnable` object, we've really created a new subclass
    of the `Runnable` object with its own special overridden version of the `run`
    method, and we just put it right in the middle of our code. This is a powerful
    methodology that allows us to cut down on the amount of code needed. Of course,
    if we overuse it, our code can quickly become very complicated for us or another
    programmer to read and understand.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们创建了一个匿名类。虽然看起来我们创建了一个新的`Runnable`对象，但实际上我们创建了`Runnable`对象的一个新子类，它有自己特殊的重写版本的`run`方法，并且我们把它放在了我们的代码中间。这是一种强大的方法，可以减少所需的代码量。当然，如果我们过度使用它，我们的代码很快就会变得非常复杂，对我们或其他程序员来说很难阅读和理解。
- en: A visual GUI editor tool – palette
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个可视化GUI编辑器工具 - 调色板
- en: The Java programming language, a GUI extension library such as `Swing`, and
    a development environment – a powerful one such as NetBeans – can be a really
    strong combo. Now we're going to take a look at how to create GUIs using a GUI
    editor like the one found in NetBeans.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Java编程语言，GUI扩展库如`Swing`，以及一个强大的开发环境 - 如NetBeans - 可以是一个非常强大的组合。现在我们将看看如何使用NetBeans中的GUI编辑器来创建GUI。
- en: To follow along, I highly recommend that you utilize the NetBeans IDE for this
    section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟上，我强烈建议您在本节中使用NetBeans IDE。
- en: 'So, to get started, let''s create a Java application like we normally would
    and give it a name and we''re good to go. We''re going to start off by simply
    deleting the default Java file that NetBeans provides and instead ask NetBeans
    to create a new file. We''re going to ask it to create a JFrame Form for us:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始创建一个Java应用程序，就像我们通常做的那样，并给它一个名称，然后我们就可以开始了。我们将从简单地删除NetBeans提供的默认Java文件，而是要求NetBeans创建一个新文件。我们要求它为我们创建一个JFrame表单：
- en: '![](img/7d295170-a12e-45ef-9cdf-9a4e8cde07a6.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d295170-a12e-45ef-9cdf-9a4e8cde07a6.png)'
- en: 'We''ll give this JFrame form a name and keep it in the same package. When NetBeans
    creates this file, even though it''s a `.java` file, the window that pops up will
    look really different to us. In fact, our file is still just Java code. Click
    on the Source tab to see the code as shown in the following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为这个JFrame表单命名，并将其保留在同一个包中。当NetBeans创建此文件时，即使它是一个`.java`文件，弹出的窗口对我们来说看起来会非常不同。事实上，我们的文件仍然只是Java代码。单击“源”选项卡，以查看代码，如下图所示：
- en: '![](img/99501467-d025-4a83-b179-fc4612e6cf97.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/99501467-d025-4a83-b179-fc4612e6cf97.png)'
- en: How palette works
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调色板的工作原理
- en: We can see the Java code that comprises our file in the Source code tab; there's
    actually a whole lot of code in this file if we expand it out. It's all been generated
    for us by the NetBeans GUI editor called Palette as shown in the following screenshot.
    Changes we make to this Java file will affect our `Design` file and vice versa.
    From this `Design` file, we have access to a drag and drop editor, and we can
    also edit the properties of individual elements without having to jump into our
    Java code, that is, the `Source` file. Eventually, in pretty much any application
    we ever create, we're going to have to drop into our Java code to provide the
    backend programming functionality to the pieces we put into our editor; for now,
    let's just take a quick look at how the editor works.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在“源代码”选项卡中看到组成我们文件的Java代码；如果我们展开它，这个文件中实际上有很多代码。这些代码都是由NetBeans的调色板GUI编辑器为我们生成的，如下图所示。我们对这个Java文件所做的更改将影响我们的“设计”文件，反之亦然。从这个“设计”文件中，我们可以访问拖放编辑器，并且还可以编辑单个元素的属性，而无需跳转到我们的Java代码，也就是“源”文件。最终，在我们创建的任何应用程序中，我们都将不得不进入我们的Java代码，以为我们放入编辑器的部分提供后端编程功能；现在，让我们快速看一下编辑器的工作原理。
- en: 'I''d like to set up the framework for a password protection dialog. This isn''t
    going to be too complicated, so we''ll make the JFrame form a little smaller than
    it is right now. Then, take a look at some of the Swing Controls available; there''s
    a whole lot of them. In fact, courtesy of NetBeans, we can use some other GUI
    extension systems as well:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我想为密码保护对话框设置框架。这不会太复杂，所以我们将使JFrame表单比现在小一点。然后，看一下可用的Swing控件；有很多。事实上，借助NetBeans，我们还可以使用其他GUI扩展系统：
- en: '![](img/873a5355-84b0-4a53-8575-362b7d63fafb.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/873a5355-84b0-4a53-8575-362b7d63fafb.png)'
- en: 'The following are the steps for setting up the framework for a password protection
    dialog:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是设置密码保护对话框框架的步骤：
- en: Let's just stick with Swing Controls and stay pretty basic. Label is about as
    basic as you can get. Our password dialog is going to need some text:![](img/a16451a4-5988-4b39-9d35-b2817feac122.png)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们只使用Swing控件，保持相当基本。标签是最基本的。我们的密码对话框需要一些文本：![](img/a16451a4-5988-4b39-9d35-b2817feac122.png)
- en: Now, a password dialog is also going to need some user interaction. We're going
    to need not only a password, but also a username for the user. To get the username,
    we will have to decide between a couple of options under Swing Controls:![](img/55194655-5992-418a-8d1d-e6b6c975b19f.png)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，密码对话框还需要一些用户交互。我们不仅需要密码，还需要用户的用户名。要获取用户名，我们将不得不在Swing控件下选择几个选项：![](img/55194655-5992-418a-8d1d-e6b6c975b19f.png)
- en: TextArea is a good one. It lets the user put text in a box, unlike Label, which
    only developers can edit. The user can click on the box and type some text into
    it. Unfortunately, this box is pretty big, and if we click on it and try to make
    it smaller, we'll get scroll bars to allow the user to bounce around its size.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 文本区是一个好选择。它允许用户在框中输入文本，不像标签，只有开发人员可以编辑。用户可以点击框并在其中输入一些文本。不幸的是，这个框相当大，如果我们点击它并尝试使其变小，我们将得到滚动条，以允许用户在其大小周围移动。
- en: 'We could modify the default sizes of this box when the scroll bars appear by
    changing any number of its properties that we can access from the editor. However,
    a much simpler solution would be to simply use Text Field, which doesn''t have
    all of the multiline functionality of our box. Also, put Label next to Text Field
    and you''ll notice that the graphical editor helps line things up. If we properly
    double-click on fields such as Label, we can edit their text right there:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当滚动条出现时，我们可以通过更改我们可以从编辑器访问的任意数量的属性来修改此框的默认大小。然而，一个更简单的解决方案是简单地使用文本字段，它没有我们的框的所有多行功能。此外，在文本字段旁边放置标签，您会注意到图形编辑器有助于对齐事物。如果我们正确地双击诸如标签之类的字段，我们可以在那里编辑它们的文本：
- en: '![](img/c7f3d1c1-bc6b-468d-a71d-067bea20b62c.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7f3d1c1-bc6b-468d-a71d-067bea20b62c.png)'
- en: One of the cool things about modern GUIs is that there's some really specialized
    controls. One of these is Password Field. In many ways, it's going to act just
    like our TextField control, except that it's going to replace whatever text the
    user puts in there visually with dots so that someone looking over their shoulder
    will not be able to learn their password. If you fail to double-click on an editable
    element, it will bring you back to the source.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现代GUI的一个很酷的功能是有一些非常专业化的控件。其中之一是密码字段。在许多方面，它将表现得就像我们的文本字段控件一样，只是它会用点来替换用户在其中输入的任何文本，以便正在旁边看的人无法学到他们的密码。如果您未能双击可编辑元素，它将带您返回到源代码。
- en: 'We''re going to edit the two components – the text and password fields – that
    our user can place text in so that they don''t appear to our user with their default
    values initially. We can double-click on the password field, or we can just edit
    the properties of our controls:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编辑两个组件 - 文本和密码字段 - 以便我们的用户可以在其中放置文本，以便它们最初不会显示为默认值。我们可以双击密码字段，或者只需编辑控件的属性：
- en: '![](img/09bad6b6-2965-4cf9-815f-1b666cc7b99b.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/09bad6b6-2965-4cf9-815f-1b666cc7b99b.png)'
- en: 'Here, the text value of our Text Field control can be modified to nothing at
    all to start off with, and we can do the same thing with our password. You''ll
    notice that the text value of our password actually has text in it, but it is
    just displayed as a bunch of dots. However, programmers can access this value
    to validate the user''s password. There''s a whole lot of other options in the
    Properties tab: we can do things such as change the font and the foreground and
    background colors, give it borders, and all that.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的文本字段控件的文本值可以被修改为一开始什么都没有，我们的密码也可以做同样的事情。您会注意到我们的密码的文本值实际上有文本，但它只显示为一堆点。但是，程序员可以访问此值以验证用户的密码。在属性选项卡中还有很多其他选项：我们可以做诸如更改字体和前景和背景颜色，给它边框等等的事情。
- en: 'When we run our program, you will see that it actually does exist and that
    the user can put values into these fields:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行程序时，您将看到它实际上存在，并且用户可以将值放入这些字段中：
- en: '![](img/5252847a-208d-427e-84be-3e1cd8f8de03.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5252847a-208d-427e-84be-3e1cd8f8de03.png)'
- en: 'Of course, we haven''t written any backend code to do anything useful with
    them yet, but the GUI itself is up and working. There''s nothing magical happening
    here. If we jump into the source of this code and drop down to its `main` method,
    we''ll see the code where the GUI is actually created and displayed to the user
    (see the following screenshot):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还没有编写任何后端代码来对它们进行有用的操作，但GUI本身已经可以运行。这里没有发生任何魔法。如果我们跳转到这段代码的源代码并转到其`main`方法，我们将看到实际创建和显示给用户的GUI的代码（请参见以下屏幕截图）：
- en: '![](img/cfa02b3a-44c3-4a72-8105-967356878cba.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfa02b3a-44c3-4a72-8105-967356878cba.png)'
- en: The important thing to realize is when we access the elements within our source
    code, all of this methodology is also available to us through raw Java. That's
    all I really wanted to show you in this section, just the raw power and how quickly
    we set up a GUI window for the system using the NetBeans graphical editor.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，当我们访问源代码中的元素时，所有这些方法论也可以通过原始Java提供给我们。这就是我在这一部分真正想向您展示的内容，只是原始的力量以及我们如何快速使用NetBeans图形编辑器为系统设置GUI窗口。
- en: Event handling
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件处理
- en: 'One of the best things about working in Java is how powerful its GUI extension
    libraries are and just how quickly we can get a program up and running that not
    only has functional code, but also has a slick, professional-looking user interface
    to back it up that would help anyone interact with our program. That''s what we''re
    going to do now: connect the design interface for basic username and password
    validation with some backend code that we''re going to write which will actually
    check two text fields to see whether they''re the ones we''re looking for.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '在Java中工作的最好的事情之一是它的GUI扩展库有多么强大，以及我们可以多快地让一个程序运行起来，不仅具有功能代码，而且还有一个漂亮的专业外观的用户界面，可以帮助任何人与我们的程序交互。这就是我们现在要做的：将基本用户名和密码验证的设计界面与我们将要编写的一些后端代码连接起来，这些代码实际上将检查两个文本字段，看它们是否是我们正在寻找的。 '
- en: 'To start off, we have the basic GUI with a text field where someone can put
    a username and password, which will just show up as stars:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个基本的GUI，其中有一个文本字段，用户可以在其中放置用户名和密码，这些将显示为星号：
- en: '![](img/646c18ba-71b4-4b60-8c02-efa1ba424d8f.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/646c18ba-71b4-4b60-8c02-efa1ba424d8f.png)'
- en: Adding a button
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加按钮
- en: The source code for this GUI is so far completely autogenerated. We haven't
    touched it at all yet; it's just reflecting the design decisions we've made here.
    Before we can start writing backend code to do username and password validation,
    our user is going to need a way to tell us that they've put in a username and
    password and they'd like it to be validated. This seems like an apt job for the
    all-powerful button. So let's add a button to our GUI from the Swing Controls
    menu. We'll change its text to `Submit` in the Properties option, and the user
    will need to click on this button to submit their information. Now, when the button
    is clicked, we'd like it to perform some programming logic. We want to check the
    username and password fields for this section because we're just learning and
    doing things simply and easily; we'll just check them against some hardcoded text.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，此GUI的源代码完全是自动生成的。我们还没有触及它；它只是反映了我们在这里做出的设计决策。在我们开始编写后端代码来验证用户名和密码之前，我们的用户需要一种方式告诉我们，他们已经输入了用户名和密码，并且希望对其进行验证。这似乎是一个适合全能按钮的工作。因此，让我们从Swing
    Controls菜单中向我们的GUI添加一个按钮。我们将在属性选项中将其文本更改为`提交`，用户需要单击此按钮以提交他们的信息。现在，当单击按钮时，我们希望它执行一些编程逻辑。我们要检查用户名和密码字段，因为我们只是在学习和简单易行的事情；我们将只检查它们是否与一些硬编码的文本匹配。
- en: The question is how do we get from GUI to functional Java code? Generally, we're
    going to do this through the **event-driven** programming mode, where the interactions
    that our user has with the GUI determine what Java code is executed and what backend
    logic occurs. Another way to think of this is that we can set up pieces of our
    Java code, or methods, to listen for specific GUI-related events to occur and
    then execute when they do. You'll notice that our GUI components, or controls
    like our button, have a field under their properties called Events. These are
    all the things that could occur in relation to our control here. In theory, we
    could bind each one of these events to a method in our Java source code, and when
    a particular event occurs, either because of user interaction or other code we
    wrote, our related Java method would be called.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们如何从GUI到功能性的Java代码？一般来说，我们将通过**事件驱动**编程模式来实现这一点，用户与GUI的交互决定了执行哪些Java代码以及发生了什么后端逻辑。另一种思考方式是，我们可以设置我们的Java代码的片段或方法来监听特定的与GUI相关的事件，并在它们发生时执行。您会注意到我们的GUI组件或控件，比如我们的按钮，其属性下有一个名为事件的字段。这些都是与我们的控件相关的可能发生的事情。理论上，我们可以将这些事件中的每一个绑定到我们Java源代码中的一个方法，当特定事件发生时，无论是因为用户交互还是我们编写的其他代码，我们相关的Java方法都会被调用。
- en: Adding functionality to our button
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的按钮添加功能
- en: 'To let users click on our button field and perform some coded action, we''re
    going to assign an event handler to our `actionPerformed` event. If we click on
    this field, we get an option already. Our GUI designer is suggesting we add a
    handler, namely `jButton1ActionPerformed`. That''s an awful name for a method
    that''s going to sit in our code; `jBbutton1` is pretty nondescript. However,
    it has been chosen because it is the variable name assigned to `jButton` when
    it''s created in the actual Java code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户点击我们的按钮字段并执行一些编码操作，我们将为我们的`actionPerformed`事件分配一个事件处理程序。如果我们点击这个字段，我们已经有一个选项。我们的GUI设计师建议我们添加一个处理程序，即`jButton1ActionPerformed`。这是一个糟糕的方法名称，它将在我们的代码中存在；`jBbutton1`相当不具描述性。然而，它被选择是因为它是在实际的Java代码中创建`jButton`时分配的变量名：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we scroll down in the source code, we''ll see the actual declaration there.
    I''m sure we can change these settings, but NetBeans will let us know that we
    probably shouldn''t modify this directly. This is because the designer is going
    to modify it too. So we''ll just change the name of our button from the non-descriptive
    `jButton1` to `SubmitButton`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在源代码中向下滚动，我们会看到实际的声明。我相信我们可以更改这些设置，但NetBeans会让我们知道我们可能不应该直接修改这个。这是因为设计师也将对其进行修改。所以我们只需将按钮的名称从不具描述性的`jButton1`更改为`SubmitButton`：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When we make this change, we'll see that NetBeans will update our source code
    and there's a `SubmitButton` object bouncing around. This is a variable that starts
    with a capital letter, so we'll make one more change in the Events section by
    changing it to `submitButton`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行这个更改时，我们会看到NetBeans会更新我们的源代码，有一个`SubmitButton`对象在那里跳来跳去。这是一个以大写字母开头的变量，所以我们将在事件部分进行一次更改，将其更改为`submitButton`。
- en: 'Now the suggested action performed by NetBeans is `submitButtonActionPerformed`.
    When we head down to our source code, we''ll see that an event would have been
    created and linked to `jButton` in a massive block of generated code that NetBeans
    has created to mimic our GUI, which we''ve been creating through their tools.
    If we search for our `submitButtonActionPerformed` method in the source code,
    we''ll actually see it added to the generated code in the source code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在NetBeans建议执行的操作是`submitButtonActionPerformed`。当我们转到源代码时，我们会看到一个事件已经被创建，并且链接到了一个巨大的生成代码块中的`jButton`，这是NetBeans为了模仿我们通过他们的工具创建的GUI而创建的。如果我们在源代码中搜索我们的`submitButtonActionPerformed`方法，我们实际上会看到它被添加到生成的代码中：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our `submitButtonActionPerformed` method has been added as the final call of
    `ActionListener` placed in `submitButton`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`submitButtonActionPerformed`方法已被添加为`submitButton`中放置的`ActionListener`的最终调用：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`ActionListener`, of course, has one job and one job only and that''s to see
    whether our button has been clicked. If clicked, it will call our `submitButtonActionPerformed`
    method. So, in this `submitButtonActionPerformed` method, we can put some good
    old functional Java code. For this, we need to do two things:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionListener`当然只有一个工作，那就是看我们的按钮是否被点击。如果被点击，它将调用我们的`submitButtonActionPerformed`方法。因此，在这个`submitButtonActionPerformed`方法中，我们可以放一些老式的功能性Java代码。为此，我们需要做两件事：'
- en: Check the value of the password field
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查密码字段的值
- en: Check the value of the username field
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查用户名字段的值
- en: 'Only `ActionEvent` (as seen in the preceding code block) is passed into our
    `submitButtonActionPerformed` method. While there''s a lot of interesting and
    useful methodologies attached to this event, the context of the action that caused
    our method to be called, it''s not going to give us what we really need. What
    we really need is our password field and our text field, which fortunately are
    private members of our current class. The steps for validating the value of our
    text fields are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`ActionEvent`（如前面的代码块中所示）被传递到我们的`submitButtonActionPerformed`方法中。虽然与这个事件相关联的有很多有趣和有用的方法，但是导致我们的方法被调用的动作的上下文，它不会给我们我们真正需要的东西。我们真正需要的是我们的密码字段和我们的文本字段，幸运的是它们是我们当前类的私有成员。验证我们文本字段的值的步骤如下：
- en: 'Start with the username, that is, `jTextField1`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从用户名开始，也就是`jTextField1`：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We should probably rename this when we get the chance, but we''ll just roll
    with it for now because we only have one text field:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有机会时，我们应该重命名它，但现在我们只能接受它，因为我们只有一个文本字段：
- en: '![](img/72f5504b-bdad-42e3-a5ea-abd2e589fe14.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72f5504b-bdad-42e3-a5ea-abd2e589fe14.png)'
- en: If you remember, in the editor under Properties tab, this text field had a text
    property. We got rid of the text in this because we didn't want our username text
    field to start with any text. We want it to be blank so that users would know
    they have to put their own information there.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得，在属性选项卡下的编辑器中，这个文本字段有一个文本属性。我们去掉了这个文本，因为我们不希望我们的用户名文本字段以任何文本开头。我们希望它是空白的，这样用户就会知道他们必须在那里放入自己的信息。
- en: 'Now, it stands to reason if that''s the property exposed to us in the designer,
    there should be a related property exposed by the object itself, and there is,
    namely `getText()`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果这是设计师向我们公开的属性，那么对象本身应该有一个相关的属性，确实有，即`getText()`：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When we call `getText`, of course, we return the text currently stored in our
    text field, and we'll make our super secret username the very "creative" word
    `username`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们调用`getText`时，当然，我们返回当前存储在文本字段中的文本，并且我们将我们的超级秘密用户名设置为非常“有创意”的单词`username`。
- en: 'This is a conditional statement, and we''re going to want to make another conditional
    statement. We want to ask our program whether the text field and password field
    – which is going to expose a similar method, `getPassword` in this case – are
    both equal to the hardcoded string. Our secret password will be `java`. Note that
    `getPassword` actually returns a character array, not a string, so to keep things
    simple, let''s just assign the password value to a string and then we''re good
    to utilize it as a string. Put `if` in front of our conditional statement, within
    parentheses, and we''re good to go:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个条件语句，我们将要做另一个条件语句。我们想要询问我们的程序文本字段和密码字段 - 在这种情况下将暴露一个类似的方法`getPassword` -
    是否都等于硬编码的字符串。我们的秘密密码将是`java`。请注意，`getPassword`实际上返回一个字符数组，而不是一个字符串，所以为了保持简单，让我们将密码值分配给一个字符串，然后我们就可以将其用作字符串。在我们的条件语句前面加上`if`，在括号内，我们就可以开始了：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now we need to give our user some indication whether or not they've succeeded
    in providing the proper username and password. OK, what to do if the user has
    successfully input a good username and a good password? Well, I think it would
    be cool if we showed a pop-up dialog here.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要给我们的用户一些指示，无论他们是否成功提供了正确的用户名和密码。好的，如果用户成功输入了一个好的用户名和一个好的密码，我们该怎么办呢？嗯，我认为如果我们在这里显示一个弹出对话框会很酷。
- en: '`JOptionPane` provides us with the `showMessageDialog` method, which is a pretty
    cool way to impart really important and immediate information to the user. It''ll
    show a pop-up box, and it''s pretty lightweight and easy to use. You may have
    to fix the imports on this one:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`JOptionPane`为我们提供了`showMessageDialog`方法，这是一种非常酷的方式，可以向用户传达非常重要和即时的信息。它会显示一个弹出框，非常轻量级且易于使用。您可能需要修复这个导入：'
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The only heavyweight information `MessageDialog` needs to create itself is
    a GUI component to attach itself to, to be its parent. We could acquire `button
    evt` through `ActionEvent`, but this doesn''t make a lot of sense because the
    dialog is not tied just to the button; it''s tied to the entirety of what this
    GUI is about, which is validating a username and password. So it''d be nice if
    we could tie the message dialog box to JFrame form itself, the GUI''s top-level
    element, and in fact we can:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageDialog`需要创建自己的唯一重量级信息是要附加到的GUI组件，作为其父级。我们可以通过`ActionEvent`获取`button
    evt`，但这并没有太多意义，因为对话框不仅仅与按钮绑定；它与这个GUI的整体相关，这是验证用户名和密码。因此，如果我们可以将消息对话框绑定到JFrame表单本身，GUI的顶级元素，那将是很好的，实际上我们可以：'
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we scroll up a bit to our source code section to check exactly where we''re
    writing code, we''ll see that we''re in a class, called `MyGUI`, that extends
    the `JFrame` class. This entire class is associated with the `JFrame` class we''re
    working with. So, to pass `JFrame` as a variable to our `showMessageDialog` method,
    we simply use the `this` keyword. Now just type in a message to show the user
    upon password and username validation:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们向上滚动一点到我们的源代码部分，检查我们正在写代码的确切位置，我们会看到我们在一个名为`MyGUI`的类中，它扩展了`JFrame`类。整个类与我们正在使用的`JFrame`类相关联。因此，要将`JFrame`作为变量传递给我们的`showMessageDialog`方法，我们只需使用`this`关键字。现在只需输入一条消息，以便在验证密码和用户名时向用户显示：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s run our program and see what we''ve built. The dialogue box appears,
    which we''ve seen before and which we expect, and then perform the following steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的程序，看看我们建立了什么。对话框出现了，这是我们之前见过的，也是我们期望的，然后执行以下步骤：
- en: 1\. Type in our valid username, that is, `username`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 输入我们的有效用户名，即`username`。
- en: 2\. Type in our valid password, that is `java`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 输入我们的有效密码，即`java`。
- en: 3\. Then, hit the Submit button.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 然后，点击提交按钮。
- en: '![](img/9fec4b08-91f9-4b42-8b45-a5be7830e506.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9fec4b08-91f9-4b42-8b45-a5be7830e506.png)'
- en: 'We get a dialog box that looks like the following screenshot. We can freely
    move this box in our JFrame instance:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个对话框，看起来像下面的截图。我们可以自由地在我们的JFrame实例中移动这个框：
- en: '![](img/25daa1f0-039a-4e94-9c79-6c17cd0d5def.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25daa1f0-039a-4e94-9c79-6c17cd0d5def.png)'
- en: Just to test things out, let's put in some gobbledygook. We get nothing no matter
    how many times we click on Submit. Also, a good username and no password also
    gets us nothing, pretty cool! We've only scratched the surface of what is possible
    with Java GUIs and, of course, Java itself.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了测试一下，让我们输入一些胡言乱语。无论我们点击多少次提交，我们都得不到任何东西。而且一个好的用户名和没有密码也得不到任何东西，非常酷！我们只是触及了Java
    GUI可能性的表面，当然，也是Java本身。
- en: Creating Java GUIs for our programs is easy and, in many cases, painless. Sometimes,
    the event handling model that GUIs force us to implement to some degree can even
    make creating our Java programs, which are heavily reliant on user interaction,
    easier than it would otherwise be.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的程序创建Java GUI是容易的，在许多情况下，也是无痛的。有时，GUI强制我们实现事件处理模型，在某种程度上甚至可以使我们创建依赖用户交互的Java程序变得更容易。
- en: The other important thing that I cannot stress enough is that even though the
    GUI designer is awesome, it's possible for us to create this exact same project
    by simply sitting down and writing the Java code in the Source code section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个我无法再强调的重要事情是，尽管GUI设计师很棒，我们也可以通过简单地坐下来在源代码部分编写Java代码来创建完全相同的项目。
- en: I'm not saying we shouldn't use the GUI designer – especially because there's
    a lot of code and a lot of well-written code that's been generated for us by the
    GUI designer, which can save us a whole lot of time – but there's absolutely no
    magic happening here at all. This is all Java code making use of the `Swing` extension
    library.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说我们不应该使用GUI设计师 - 尤其是因为有很多代码和很多由GUI设计师为我们生成的精心编写的代码，这可以节省我们大量的时间 - 但这里绝对没有任何魔法发生。这都是使用`Swing`扩展库的Java代码。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw the basic functions of GUI in NetBeans. You learned
    how to create an application window with the `JFrame` class by setting its size,
    adding labels to it, and closing the application. Then, we dived into the topic
    of the GUI editor, palette. We saw a working palette and the components available
    in it. Lastly, you learned how to trigger events by adding a button and adding
    functionality to it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了NetBeans中GUI的基本功能。您学会了如何使用`JFrame`类创建应用程序窗口，设置其大小，向其添加标签，并关闭应用程序。然后，我们深入讨论了GUI编辑器，调色板的主题。我们看到了一个工作的调色板以及其中可用的组件。最后，您学会了如何通过添加按钮并为其添加功能来触发事件。
- en: In the next chapter, you'll learn about XML.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习有关XML的知识。
