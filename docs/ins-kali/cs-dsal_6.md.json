["```cs\npublic class Node<T> \n{ \n    public int Index { get; set; } \n    public T Data { get; set; } \n    public List<Node<T>> Neighbors { get; set; }  \n        = new List<Node<T>>(); \n    public List<int> Weights { get; set; } = new List<int>(); \n\n    public override string ToString() \n    { \n        return $\"Node with index {Index}: {Data}, \n            neighbors: {Neighbors.Count}\"; \n    } \n} \n```", "```cs\npublic class Edge<T> \n{ \n    public Node<T> From { get; set; } \n    public Node<T> To { get; set; } \n    public int Weight { get; set; } \n\n    public override string ToString() \n    { \n        return $\"Edge: {From.Data} -> {To.Data},  \n            weight: {Weight}\"; \n    } \n} \n```", "```cs\npublic class Graph<T> \n{ \n    private bool _isDirected = false; \n    private bool _isWeighted = false; \n    public List<Node<T>> Nodes { get; set; }  \n        = new List<Node<T>>(); \n} \n```", "```cs\npublic Graph(bool isDirected, bool isWeighted) \n{ \n    _isDirected = isDirected; \n    _isWeighted = isWeighted; \n} \n```", "```cs\npublic Edge<T> this[int from, int to] \n{ \n    get \n    { \n        Node<T> nodeFrom = Nodes[from]; \n        Node<T> nodeTo = Nodes[to]; \n        int i = nodeFrom.Neighbors.IndexOf(nodeTo); \n        if (i >= 0) \n        { \n            Edge<T> edge = new Edge<T>() \n            { \n                From = nodeFrom, \n                To = nodeTo, \n                Weight = i < nodeFrom.Weights.Count  \n                    ? nodeFrom.Weights[i] : 0 \n            }; \n            return edge; \n        } \n\n        return null; \n    } \n} \n```", "```cs\npublic Node<T> AddNode(T value) \n{ \n    Node<T> node = new Node<T>() { Data = value }; \n    Nodes.Add(node); \n    UpdateIndices(); \n    return node; \n} \n```", "```cs\npublic void RemoveNode(Node<T> nodeToRemove) \n{ \n    Nodes.Remove(nodeToRemove); \n    UpdateIndices(); \n    foreach (Node<T> node in Nodes) \n    { \n        RemoveEdge(node, nodeToRemove); \n    } \n} \n```", "```cs\npublic void AddEdge(Node<T> from, Node<T> to, int weight = 0) \n{ \n    from.Neighbors.Add(to); \n    if (_isWeighted) \n    { \n        from.Weights.Add(weight); \n    } \n\n    if (!_isDirected) \n    { \n        to.Neighbors.Add(from); \n        if (_isWeighted) \n        { \n            to.Weights.Add(weight); \n        } \n    } \n} \n```", "```cs\npublic void RemoveEdge(Node<T> from, Node<T> to) \n{ \n    int index = from.Neighbors.FindIndex(n => n == to); \n    if (index >= 0) \n    { \n        from.Neighbors.RemoveAt(index);\n        if (_isWeighted)\n        { \n            from.Weights.RemoveAt(index); \n        }\n    } \n} \n```", "```cs\npublic List<Edge<T>> GetEdges() \n{ \n    List<Edge<T>> edges = new List<Edge<T>>(); \n    foreach (Node<T> from in Nodes) \n    { \n        for (int i = 0; i < from.Neighbors.Count; i++) \n        { \n            Edge<T> edge = new Edge<T>() \n            { \n                From = from, \n                To = from.Neighbors[i], \n                Weight = i < from.Weights.Count  \n                    ? from.Weights[i] : 0 \n            }; \n            edges.Add(edge); \n        } \n    } \n    return edges; \n} \n```", "```cs\nprivate void UpdateIndices() \n{ \n    int i = 0; \n    Nodes.ForEach(n => n.Index = i++); \n} \n```", "```cs\nGraph<int> graph = new Graph<int>(false, false); \n```", "```cs\nNode<int> n1 = graph.AddNode(1); \nNode<int> n2 = graph.AddNode(2); \nNode<int> n3 = graph.AddNode(3); \nNode<int> n4 = graph.AddNode(4); \nNode<int> n5 = graph.AddNode(5); \nNode<int> n6 = graph.AddNode(6); \nNode<int> n7 = graph.AddNode(7); \nNode<int> n8 = graph.AddNode(8); \n```", "```cs\ngraph.AddEdge(n1, n2); \ngraph.AddEdge(n1, n3); \ngraph.AddEdge(n2, n4); \ngraph.AddEdge(n3, n4); \ngraph.AddEdge(n4, n5); \ngraph.AddEdge(n5, n6); \ngraph.AddEdge(n5, n7); \ngraph.AddEdge(n5, n8); \ngraph.AddEdge(n6, n7); \ngraph.AddEdge(n7, n8); \n```", "```cs\nGraph<int> graph = new Graph<int>(true, true); \n```", "```cs\nNode<int> n1 = graph.AddNode(1); \nNode<int> n2 = graph.AddNode(2); \nNode<int> n3 = graph.AddNode(3); \nNode<int> n4 = graph.AddNode(4); \nNode<int> n5 = graph.AddNode(5); \nNode<int> n6 = graph.AddNode(6); \nNode<int> n7 = graph.AddNode(7); \nNode<int> n8 = graph.AddNode(8); \n```", "```cs\ngraph.AddEdge(n1, n2, 9); \ngraph.AddEdge(n1, n3, 5); \ngraph.AddEdge(n2, n1, 3); \ngraph.AddEdge(n2, n4, 18); \ngraph.AddEdge(n3, n4, 12); \ngraph.AddEdge(n4, n2, 2); \ngraph.AddEdge(n4, n8, 8); \ngraph.AddEdge(n5, n4, 9); \ngraph.AddEdge(n5, n6, 2); \ngraph.AddEdge(n5, n7, 5); \ngraph.AddEdge(n5, n8, 3); \ngraph.AddEdge(n6, n7, 1); \ngraph.AddEdge(n7, n5, 4); \ngraph.AddEdge(n7, n8, 6); \ngraph.AddEdge(n8, n5, 3); \n```", "```cs\npublic List<Node<T>> DFS() \n{ \n    bool[] isVisited = new bool[Nodes.Count]; \n    List<Node<T>> result = new List<Node<T>>(); \n    DFS(isVisited, Nodes[0], result); \n    return result; \n} \n```", "```cs\nprivate void DFS(bool[] isVisited, Node<T> node,  \n    List<Node<T>> result) \n{ \n    result.Add(node); \n    isVisited[node.Index] = true; \n\n    foreach (Node<T> neighbor in node.Neighbors) \n    { \n        if (!isVisited[neighbor.Index]) \n        { \n            DFS(isVisited, neighbor, result); \n        } \n    } \n} \n```", "```cs\nGraph<int> graph = new Graph<int>(true, true); \nNode<int> n1 = graph.AddNode(1); (...) \nNode<int> n8 = graph.AddNode(8); \ngraph.AddEdge(n1, n2, 9); (...) \ngraph.AddEdge(n8, n5, 3); \nList<Node<int>> dfsNodes = graph.DFS(); \ndfsNodes.ForEach(n => Console.WriteLine(n)); \n```", "```cs\n    Node with index 0: 1, neighbors: 2\n    Node with index 1: 2, neighbors: 2\n    Node with index 3: 4, neighbors: 2\n    Node with index 7: 8, neighbors: 1\n    Node with index 4: 5, neighbors: 4\n    Node with index 5: 6, neighbors: 1\n    Node with index 6: 7, neighbors: 2\n    Node with index 2: 3, neighbors: 1\n\n```", "```cs\npublic List<Node<T>> BFS() \n{ \n    return BFS(Nodes[0]); \n} \n```", "```cs\nprivate List<Node<T>> BFS(Node<T> node) \n{ \n    bool[] isVisited = new bool[Nodes.Count]; \n    isVisited[node.Index] = true; \n\n    List<Node<T>> result = new List<Node<T>>(); \n    Queue<Node<T>> queue = new Queue<Node<T>>(); \n    queue.Enqueue(node); \n    while (queue.Count > 0) \n    { \n        Node<T> next = queue.Dequeue(); \n        result.Add(next); \n\n        foreach (Node<T> neighbor in next.Neighbors) \n        { \n            if (!isVisited[neighbor.Index]) \n            { \n                isVisited[neighbor.Index] = true; \n                queue.Enqueue(neighbor); \n            } \n        } \n    } \n\n    return result; \n} \n```", "```cs\nGraph<int> graph = new Graph<int>(true, true); \nNode<int> n1 = graph.AddNode(1); (...) \nNode<int> n8 = graph.AddNode(8); \ngraph.AddEdge(n1, n2, 9); (...) \ngraph.AddEdge(n8, n5, 3); \nList<Node<int>> bfsNodes = graph.BFS(); \nbfsNodes.ForEach(n => Console.WriteLine(n)); \n```", "```cs\n Node with index 0: 1, neighbors: 2\n Node with index 1: 2, neighbors: 2\n Node with index 2: 3, neighbors: 1\n Node with index 3: 4, neighbors: 2\n Node with index 7: 8, neighbors: 1\n Node with index 4: 5, neighbors: 4\n Node with index 5: 6, neighbors: 1\n Node with index 6: 7, neighbors: 2\n```", "```cs\npublic List<Edge<T>> MinimumSpanningTreeKruskal() \n{ \n    List<Edge<T>> edges = GetEdges(); \n    edges.Sort((a, b) => a.Weight.CompareTo(b.Weight)); \n    Queue<Edge<T>> queue = new Queue<Edge<T>>(edges); \n\n    Subset<T>[] subsets = new Subset<T>[Nodes.Count]; \n    for (int i = 0; i < Nodes.Count; i++) \n    { \n        subsets[i] = new Subset<T>() { Parent = Nodes[i] }; \n    } \n\n    List<Edge<T>> result = new List<Edge<T>>(); \n    while (result.Count < Nodes.Count - 1) \n    { \n        Edge<T> edge = queue.Dequeue(); \n        Node<T> from = GetRoot(subsets, edge.From); \n        Node<T> to = GetRoot(subsets, edge.To); \n        if (from != to) \n        { \n            result.Add(edge); \n            Union(subsets, from, to); \n        } \n    } \n\n    return result; \n} \n```", "```cs\nprivate Node<T> GetRoot(Subset<T>[] subsets, Node<T> node) \n{ \n    if (subsets[node.Index].Parent != node) \n    { \n        subsets[node.Index].Parent = GetRoot( \n            subsets, \n            subsets[node.Index].Parent); \n    } \n\n    return subsets[node.Index].Parent; \n} \n```", "```cs\nprivate void Union(Subset<T>[] subsets, Node<T> a, Node<T> b) \n{ \n    if (subsets[a.Index].Rank > subsets[b.Index].Rank) \n    { \n        subsets[b.Index].Parent = a; \n    } \n    else if (subsets[a.Index].Rank < subsets[b.Index].Rank) \n    { \n        subsets[a.Index].Parent = b; \n    } \n    else \n    { \n        subsets[b.Index].Parent = a; \n        subsets[a.Index].Rank++; \n    } \n} \n```", "```cs\npublic class Subset<T> \n{ \n    public Node<T> Parent { get; set; } \n    public int Rank { get; set; } \n\n    public override string ToString() \n    { \n        return $\"Subset with rank {Rank}, parent: {Parent.Data}  \n            (index: {Parent.Index})\"; \n    } \n} \n```", "```cs\nGraph<int> graph = new Graph<int>(false, true); \nNode<int> n1 = graph.AddNode(1); (...) \nNode<int> n8 = graph.AddNode(8); \ngraph.AddEdge(n1, n2, 3); (...) \ngraph.AddEdge(n7, n8, 20); \nList<Edge<int>> mstKruskal = graph.MinimumSpanningTreeKruskal(); \nmstKruskal.ForEach(e => Console.WriteLine(e)); \n```", "```cs\npublic List<Edge<T>> MinimumSpanningTreePrim() \n{ \n    int[] previous = new int[Nodes.Count]; \n    previous[0] = -1; \n\n    int[] minWeight = new int[Nodes.Count]; \n    Fill(minWeight, int.MaxValue); \n    minWeight[0] = 0; \n\n    bool[] isInMST = new bool[Nodes.Count]; \n    Fill(isInMST, false); \n\n    for (int i = 0; i < Nodes.Count - 1; i++) \n    { \n        int minWeightIndex = GetMinimumWeightIndex( \n            minWeight, isInMST); \n        isInMST[minWeightIndex] = true; \n\n        for (int j = 0; j < Nodes.Count; j++) \n        { \n            Edge<T> edge = this[minWeightIndex, j]; \n            int weight = edge != null ? edge.Weight : -1; \n            if (edge != null \n                && !isInMST[j] \n                && weight < minWeight[j]) \n            { \n                previous[j] = minWeightIndex; \n                minWeight[j] = weight; \n            } \n        } \n    } \n\n    List<Edge<T>> result = new List<Edge<T>>(); \n    for (int i = 1; i < Nodes.Count; i++) \n    { \n        Edge<T> edge = this[previous[i], i]; \n        result.Add(edge); \n    } \n    return result; \n} \n```", "```cs\nprivate int GetMinimumWeightIndex(int[] weights, bool[] isInMST) \n{ \n    int minValue = int.MaxValue; \n    int minIndex = 0; \n\n    for (int i = 0; i < Nodes.Count; i++) \n    { \n        if (!isInMST[i] && weights[i] < minValue) \n        { \n            minValue = weights[i]; \n            minIndex = i; \n        } \n    } \n\n    return minIndex; \n} \n```", "```cs\nprivate void Fill<Q>(Q[] array, Q value) \n{ \n    for (int i = 0; i < array.Length; i++) \n    { \n        array[i] = value; \n    } \n} \n```", "```cs\nGraph<int> graph = new Graph<int>(false, true); \nNode<int> n1 = graph.AddNode(1); (...) \nNode<int> n8 = graph.AddNode(8); \ngraph.AddEdge(n1, n2, 3); (...) \ngraph.AddEdge(n7, n8, 20); \nList<Edge<int>> mstPrim = graph.MinimumSpanningTreePrim(); \nmstPrim.ForEach(e => Console.WriteLine(e)); \n```", "```cs\nGraph<string> graph = new Graph<string>(false, true); \nNode<string> nodeB1 = graph.AddNode(\"B1\"); (...) \nNode<string> nodeR6 = graph.AddNode(\"R6\"); \ngraph.AddEdge(nodeB1, nodeB2, 2); (...) \ngraph.AddEdge(nodeR6, nodeB6, 10); \n```", "```cs\nConsole.WriteLine(\"Minimum Spanning Tree - Kruskal's Algorithm:\"); \nList<Edge<string>> mstKruskal =  \n    graph.MinimumSpanningTreeKruskal(); \nmstKruskal.ForEach(e => Console.WriteLine(e)); \nConsole.WriteLine(\"Total cost: \" + mstKruskal.Sum(e => e.Weight)); \n```", "```cs\n    Minimum Spanning Tree - Kruskal's Algorithm:\n    Edge: R4 -> R3, weight: 1\n    Edge: R3 -> R2, weight: 1\n    Edge: R2 -> R1, weight: 1\n    Edge: B1 -> B2, weight: 2\n    Edge: B3 -> B4, weight: 2\n    Edge: R6 -> R5, weight: 3\n    Edge: R6 -> B5, weight: 3\n    Edge: B5 -> B6, weight: 6\n    Edge: B1 -> B3, weight: 20\n    Edge: B2 -> R2, weight: 25\n    Edge: R1 -> R5, weight: 75\n    Total cost: 139\n\n```", "```cs\nConsole.WriteLine(\"nMinimum Spanning Tree - Prim's Algorithm:\"); \nList<Edge<string>> mstPrim = graph.MinimumSpanningTreePrim(); \nmstPrim.ForEach(e => Console.WriteLine(e)); \nConsole.WriteLine(\"Total cost: \" + mstPrim.Sum(e => e.Weight)); \n```", "```cs\n    Minimum Spanning Tree - Prim's Algorithm:\n    Edge: B1 -> B2, weight: 2\n    Edge: B1 -> B3, weight: 20\n    Edge: B3 -> B4, weight: 2\n    Edge: R6 -> B5, weight: 3\n    Edge: B5 -> B6, weight: 6\n    Edge: R2 -> R1, weight: 1\n    Edge: B2 -> R2, weight: 25\n    Edge: R2 -> R3, weight: 1\n    Edge: R3 -> R4, weight: 1\n    Edge: R1 -> R5, weight: 75\n    Edge: R5 -> R6, weight: 3\n    Total cost: 139\n\n```", "```cs\npublic int[] Color() \n{ \n    int[] colors = new int[Nodes.Count]; \n    Fill(colors, -1); \n    colors[0] = 0; \n\n    bool[] availability = new bool[Nodes.Count]; \n    for (int i = 1; i < Nodes.Count; i++) \n    { \n        Fill(availability, true); \n\n        int colorIndex = 0; \n        foreach (Node<T> neighbor in Nodes[i].Neighbors) \n        { \n            colorIndex = colors[neighbor.Index]; \n            if (colorIndex >= 0) \n            { \n                availability[colorIndex] = false; \n            } \n        } \n\n        colorIndex = 0; \n        for (int j = 0; j < availability.Length; j++) \n        { \n            if (availability[j]) \n            { \n                colorIndex = j; \n                break; \n            } \n        } \n\n        colors[i] = colorIndex; \n    } \n\n    return colors; \n} \n```", "```cs\nprivate void Fill<Q>(Q[] array, Q value) \n{ \n    for (int i = 0; i < array.Length; i++) \n    { \n        array[i] = value; \n    } \n} \n```", "```cs\nGraph<int> graph = new Graph<int>(false, false); \nNode<int> n1 = graph.AddNode(1); (...) \nNode<int> n8 = graph.AddNode(8); \ngraph.AddEdge(n1, n2); (...) \ngraph.AddEdge(n7, n8); \n\nint[] colors = graph.Color(); \nfor (int i = 0; i < colors.Length; i++) \n{ \n    Console.WriteLine($\"Node {graph.Nodes[i].Data}: {colors[i]}\"); \n} \n```", "```cs\n    Node 1: 0\n    Node 2: 1\n    Node 3: 1\n    Node 4: 0\n    Node 5: 1\n    Node 6: 0\n    Node 7: 2\n    Node 8: 3\n```", "```cs\nGraph<string> graph = new Graph<string>(false, false); \nNode<string> nodePK = graph.AddNode(\"PK\"); (...) \nNode<string> nodeOP = graph.AddNode(\"OP\"); \ngraph.AddEdge(nodePK, nodeLU); (...) \ngraph.AddEdge(nodeDS, nodeOP);\n```", "```cs\nint[] colors = graph.Color(); \nfor (int i = 0; i < colors.Length; i++) \n{ \n    Console.WriteLine($\"{graph.Nodes[i].Data}: {colors[i]}\"); \n} \n```", "```cs\n    PK: 0\n    LU: 1 (...)\n    OP: 2\n\n```", "```cs\npublic List<Edge<T>> GetShortestPathDijkstra( \n    Node<T> source, Node<T> target) \n{ \n    int[] previous = new int[Nodes.Count]; \n    Fill(previous, -1); \n\n    int[] distances = new int[Nodes.Count]; \n    Fill(distances, int.MaxValue); \n    distances[source.Index] = 0; \n\n    SimplePriorityQueue<Node<T>> nodes =  \n        new SimplePriorityQueue<Node<T>>(); \n    for (int i = 0; i < Nodes.Count; i++) \n    { \n        nodes.Enqueue(Nodes[i], distances[i]); \n    } \n\n    while (nodes.Count != 0) \n    { \n        Node<T> node = nodes.Dequeue(); \n        for (int i = 0; i < node.Neighbors.Count; i++) \n        { \n            Node<T> neighbor = node.Neighbors[i]; \n            int weight = i < node.Weights.Count  \n                ? node.Weights[i] : 0; \n            int weightTotal = distances[node.Index] + weight; \n\n            if (distances[neighbor.Index] > weightTotal) \n            { \n                distances[neighbor.Index] = weightTotal; \n                previous[neighbor.Index] = node.Index; \n                nodes.UpdatePriority(neighbor,  \n                    distances[neighbor.Index]); \n            } \n        } \n    } \n\n    List<int> indices = new List<int>(); \n    int index = target.Index; \n    while (index >= 0) \n    { \n        indices.Add(index); \n        index = previous[index]; \n    } \n\n    indices.Reverse(); \n    List<Edge<T>> result = new List<Edge<T>>(); \n    for (int i = 0; i < indices.Count - 1; i++) \n    { \n        Edge<T> edge = this[indices[i], indices[i + 1]]; \n        result.Add(edge); \n    } \n    return result; \n} \n```", "```cs\nGraph<int> graph = new Graph<int>(true, true); \nNode<int> n1 = graph.AddNode(1); (...) \nNode<int> n8 = graph.AddNode(8); \ngraph.AddEdge(n1, n2, 9); (...) \ngraph.AddEdge(n8, n5, 3); \nList<Edge<int>> path = graph.GetShortestPathDijkstra(n1, n5); \npath.ForEach(e => Console.WriteLine(e)); \n```", "```cs\n    Edge: 1 -> 3, weight: 5\n    Edge: 3 -> 4, weight: 12\n    Edge: 4 -> 8, weight: 8\n    Edge: 8 -> 5, weight: 3\n```", "```cs\nstring[] lines = new string[] \n{ \n    \"0011100000111110000011111\", \n    \"0011100000111110000011111\", \n    \"0011100000111110000011111\", \n    \"0000000000011100000011111\", \n    \"0000001110000000000011111\", \n    \"0001001110011100000011111\", \n    \"1111111111111110111111100\", \n    \"1111111111111110111111101\", \n    \"1111111111111110111111100\", \n    \"0000000000000000111111110\", \n    \"0000000000000000111111100\", \n    \"0001111111001100000001101\", \n    \"0001111111001100000001100\", \n    \"0001100000000000111111110\", \n    \"1111100000000000111111100\", \n    \"1111100011001100100010001\", \n    \"1111100011001100001000100\" \n}; \nbool[][] map = new bool[lines.Length][]; \nfor (int i = 0; i < lines.Length; i++) \n{ \n    map[i] = lines[i] \n        .Select(c => int.Parse(c.ToString()) == 0) \n        .ToArray(); \n} \n```", "```cs\nGraph<string> graph = new Graph<string>(false, true); \nfor (int i = 0; i < map.Length; i++) \n{ \n    for (int j = 0; j < map[i].Length; j++) \n    { \n        if (map[i][j]) \n        { \n            Node<string> from = graph.AddNode($\"{i}-{j}\"); \n\n            if (i > 0 && map[i - 1][j]) \n            { \n                Node<string> to = graph.Nodes.Find( \n                    n => n.Data == $\"{i - 1}-{j}\"); \n                graph.AddEdge(from, to, 1); \n            } \n\n            if (j > 0 && map[i][j - 1]) \n            { \n                Node<string> to = graph.Nodes.Find( \n                    n => n.Data == $\"{i}-{j - 1}\"); \n                graph.AddEdge(from, to, 1); \n            } \n        } \n    } \n} \n```", "```cs\nNode<string> source = graph.Nodes.Find(n => n.Data == \"0-0\"); \nNode<string> target = graph.Nodes.Find(n => n.Data == \"16-24\"); \nList<Edge<string>> path = graph.GetShortestPathDijkstra( \n   source, target); \n```", "```cs\nConsole.OutputEncoding = Encoding.UTF8; \nfor (int row = 0; row < map.Length; row++) \n{ \n    for (int column = 0; column < map[row].Length; column++) \n    { \n        ConsoleColor color = map[row][column]  \n            ? ConsoleColor.Green : ConsoleColor.Red; \n        if (path.Any(e => e.From.Data == $\"{row}-{column}\"  \n            || e.To.Data == $\"{row}-{column}\")) \n        { \n            color = ConsoleColor.White; \n        } \n\n        Console.ForegroundColor = color; \n        Console.Write(\"\\u25cf \"); \n    } \n    Console.WriteLine(); \n} \nConsole.ForegroundColor = ConsoleColor.Gray; \n```"]