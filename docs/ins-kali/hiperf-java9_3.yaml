- en: Chapter 3. Multithreading and Reactive Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。多线程和响应式编程
- en: In this lesson, we will look at an approach to support a high performance of
    an application by programmatically splitting the task between several workers.
    That was how the pyramids were built 4,500 years ago, and this method has not
    failed to deliver since then. But there is a limitation on how many laborers can
    be brought to work on the same project. The shared resources provide a ceiling
    to how much the workforce can be increased, whether the resources are counted
    in square feet and gallons (as the living quarters and water in the time of the
    pyramids) or in gigabytes and gigahertz (as the memory and processing power of
    a computer).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们将探讨一种通过在多个工作线程之间编程地分割任务来支持应用程序高性能的方法。这就是4,500年前建造金字塔的方法，自那时以来，这种方法从未失败。但是，可以参与同一项目的劳动者数量是有限制的。共享资源为工作人员的增加提供了上限，无论资源是以平方英尺和加仑（如金字塔时代的居住区和水）计算，还是以千兆字节和千兆赫（如计算机的内存和处理能力）计算。
- en: Allocation, usage, and limitations of a living space and computer memory are
    very similar. However, we perceive the processing power of the human workforce
    and CPU quite differently. Historians tell us that thousands of ancient Egyptians
    worked on cutting and moving massive stone blocks at the same time. We do not
    have any problem understanding what they mean even if we know that these workers
    rotated all the time, some of them resting or attending to other matters temporarily
    and then coming back to replace the ones who have finished their annual assignment,
    others died or got injured and were replaced by the new recruits.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 生活空间和计算机内存的分配、使用和限制非常相似。但是，我们对人力和CPU的处理能力的感知却大不相同。历史学家告诉我们，数千年前的古埃及人同时工作于切割和移动大型石块。即使我们知道这些工人一直在轮换，有些人暂时休息或处理其他事务，然后回来取代完成年度任务的人，其他人死亡或受伤并被新兵取代，我们也不会有任何问题理解他们的意思。
- en: But in case of computer data processing, when we hear about working threads
    executing at the same time, we automatically assume that they literally do what
    they are programmed to do in parallel. Only after we look under the hood of such
    a system we realize that such parallel processing is possible only when the threads
    are executed each by a different CPU. Otherwise, they time share the same processing
    power, and we perceive them working at the same time only because the time slots
    they use are very short--a fraction of the time units we have used in our everyday
    life. When the threads share the same resource, in computer science we say they
    do it concurrently.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在计算机数据处理的情况下，当我们听到工作线程同时执行时，我们自动假设它们确实并行执行其编程的任务。只有在我们深入了解这样的系统之后，我们才意识到，只有在每个线程由不同的CPU执行时，才可能进行这样的并行处理。否则，它们共享相同的处理能力，并且我们认为它们同时工作，只是因为它们使用的时间段非常短——是我们在日常生活中使用的时间单位的一小部分。当线程共享相同的资源时，在计算机科学中，我们说它们是并发执行的。
- en: In this lesson, we will discuss the ways to increase Java application performance
    by using the workers (threads) that process data concurrently. We will show how
    to use threads effectively by pooling them, how to synchronize the concurrently
    accessed data, how to monitor and tune worker threads at runtime, and how to take
    advantage of the reactive programming concept.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们将讨论通过使用同时处理数据的工作线程（线程）来增加Java应用程序性能的方法。我们将展示如何通过对线程进行池化来有效地使用线程，如何同步同时访问的数据，如何在运行时监视和调整工作线程，以及如何利用响应式编程概念。
- en: But before doing that, let's revisit the basics of creating and running multiple
    threads in the same Java process.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这之前，让我们重新学习在同一个Java进程中创建和运行多个线程的基础知识。
- en: Prerequisites
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'There are principally two ways to create worker threads--by extending the `java.lang.Thread`
    class and by implementing the `java.lang.Runnable` interface. While extending
    the `java.lang.Thread` class, we are not required to implement anything:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有两种方法可以创建工作线程——通过扩展`java.lang.Thread`类和通过实现`java.lang.Runnable`接口。在扩展`java.lang.Thread`类时，我们不需要实现任何内容：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our `MyThread` class inherits the `name` property with an automatically generated
    value and the `start()` method. We can run this method and check the `name`:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`MyThread`类继承了自动生成值的`name`属性和`start（）`方法。我们可以运行此方法并检查`name`：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we run this code, the result will be as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，结果将如下所示：
- en: '![Prerequisites](img/03_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_01.jpg)'
- en: As you can see, the generated `name` is `Thread-0`. If we created another thread
    in the same Java process, the `name` would be `Thread-1` and so on. The `start()`
    method does nothing. The source code shows that it calls the `run()` method if
    such a method is implemented.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，生成的`name`是`Thread-0`。如果我们在同一个Java进程中创建另一个线程，`name`将是`Thread-1`等等。`start（）`方法什么也不做。源代码显示，如果实现了`run（）`方法，它会调用`run（）`方法。
- en: 'We can add any other method to the `MyThread` class as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何其他方法添加到`MyThread`类中，如下所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `calculateAverageSqrt()` method calculates the average square root of the
    first 99,999 integers and assigns the result to a property that can be accessed
    anytime. The following code demonstrates how we can use it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateAverageSqrt（）`方法计算前99,999个整数的平均平方根，并将结果分配给可以随时访问的属性。以下代码演示了我们如何使用它：'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running this brings up the following result:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此方法将产生以下结果：
- en: '![Prerequisites](img/03_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_02.jpg)'
- en: 'As you would expect, the `calculateAverageSqrt()` method blocks until the calculations
    are completed. It was executed in the main thread without it taking advantage
    of multithreading. To do this, we move the functionality in the `run()` method:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的，`calculateAverageSqrt（）`方法会阻塞，直到计算完成。它是在主线程中执行的，没有利用多线程。为了做到这一点，我们将功能移动到`run（）`方法中：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we call the `start()` method again, as in the first example and expect
    the result to be calculated:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们再次调用`start（）`方法，就像第一个示例中一样，并期望计算结果：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, the output of this code may surprise you:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码的输出可能会让您感到惊讶：
- en: '![Prerequisites](img/03_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_03.jpg)'
- en: 'This means that the main thread accessed (and printed) the `t1.getResult()`
    function before the new `t1` thread finished its calculations. We can experiment
    and change the implementation of the `run()` method to see if the `t1.getResult()`
    function can get a partial result:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着主线程在新的`t1`线程完成计算之前访问（并打印）了`t1.getResult()`函数。我们可以尝试改变`run()`方法的实现，看看`t1.getResult()`函数是否可以获得部分结果：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'However, if we run the `demo_thread_03()` method again, the result remains
    the same:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们再次运行`demo_thread_03()`方法，结果仍然是相同的：
- en: '![Prerequisites](img/03_04.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_04.jpg)'
- en: It takes time to create a new thread and get it going. Meanwhile, the `main`
    thread calls the `t1.getResult()` function immediately, thus getting no results
    yet.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新线程并使其运行需要时间。与此同时，`main`线程立即调用`t1.getResult()`函数，因此还没有得到结果。
- en: 'To give the new (child) thread time to complete the calculations, we add the
    following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给新的（子）线程完成计算的时间，我们添加了以下代码：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You have noticed that we have paused the main thread by 100 ms and added printing
    of the current thread name, to illustrate what we mean by `main` thread, the name
    that is assigned automatically to the thread that executes the `main()` method.
    The output of the previous code is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经注意到我们通过100毫秒暂停了主线程，并添加了打印当前线程名称，以说明我们所说的`main`线程，这个名称是自动分配给执行`main()`方法的线程。前面代码的输出如下：
- en: '![Prerequisites](img/03_05.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_05.jpg)'
- en: 'The delay of 100 ms was enough for the `t1` thread to finish the calculations.
    That was the first of two ways of creating threads for multithreaded calculation.
    The second way is to implement the `Runnable` interface. It may be the only way
    possible if the class that does calculations already extends some other class
    and you cannot or don''t want to use composition for some reasons. The `Runnable`
    interface is a functional interface (has only one abstract method) with the `run()`
    method that has to be implemented:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 100毫秒的延迟足以让`t1`线程完成计算。这是创建多线程计算的两种方式中的第一种。第二种方式是实现`Runnable`接口。如果进行计算的类已经扩展了其他类，并且由于某些原因您不能或不想使用组合，那么可能是唯一的可能方式。`Runnable`接口是一个函数接口（只有一个抽象方法），必须实现`run()`方法：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We implement this interface in the `MyRunnable` class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`MyRunnable`类中实现了这个接口：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It has the same functionality as the `Thread01` class earlier plus we have added
    id that allows identifying the thread if necessary since the `Runnable` interface
    does not have the built-in `getName()` method like the `Thread` class has.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有与之前的`Thread01`类相同的功能，另外我们添加了id，以便在必要时识别线程，因为`Runnable`接口没有像`Thread`类那样内置的`getName()`方法。
- en: 'Similarly, if we execute this class without pausing the `main` thread, like
    this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们执行这个类而不暂停`main`线程，就像这样：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output will be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Prerequisites](img/03_06.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_06.jpg)'
- en: 'We will now add the pause as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加暂停如下：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The result is exactly the same as the one produced by the `Thread01` class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与`Thread01`类产生的结果完全相同：
- en: '![Prerequisites](img/3_07.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/3_07.jpg)'
- en: 'All the previous examples stored the generated result in the class property.
    But it is not always the case. Typically, the worker thread either passes its
    value to another thread or stores it in a database or somewhere else externally.
    In such a case, one can take advantage of the `Runnable` interface being a functional
    interface and pass the necessary processing function into a new thread as a lambda
    expression:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所有先前的示例都将生成的结果存储在类属性中。但情况并非总是如此。通常，工作线程要么将其值传递给另一个线程，要么将其存储在数据库或其他外部位置。在这种情况下，可以利用`Runnable`接口作为函数接口，并将必要的处理函数作为lambda表达式传递到新线程中：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The result is going to be exactly the same, as shown here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将会完全相同，如下所示：
- en: '![Prerequisites](img/03_08.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_08.jpg)'
- en: 'Depending on the preferred style, you can re-arrange the code and isolate the
    lambda expression in a variable, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 根据首选的样式，您可以重新排列代码，并将lambda表达式隔离在一个变量中，如下所示：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, you can put the lambda expression in a separate method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将lambda表达式放在一个单独的方法中：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result is going to be the same, as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是相同的，如下所示：
- en: '![Prerequisites](img/03_09.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![先决条件](img/03_09.jpg)'
- en: With the basic understanding of threads creation in place, we can now return
    to the discussion about using the multithreading for building a high-performance
    application. In other words, after we understand the abilities and resources needed
    for each worker, we can now talk about logistics of bringing in many of them for
    such a big-scale project as the Great Pyramid of Giza.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有了对线程创建的基本理解，我们现在可以回到讨论如何使用多线程来构建高性能应用程序。换句话说，在我们了解了每个工作线程所需的能力和资源之后，我们现在可以讨论如何为像吉萨金字塔这样的大型项目引入许多工作线程的后勤问题。
- en: To write code that manages the life cycle of worker threads and their access
    to the shared resources is possible, but it is quite the same from one application
    to another. That's why, after several releases of Java, the thread management
    plumbing became part of the standard JDK library as the `java.util.concurrent`
    package. This package has a wealth of interfaces and classes that support multithreading
    and concurrency. We will discuss how to use most of this functionality in the
    subsequent sections, while talking about thread pools, threads monitoring, thread
    synchronization, and the related subjects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 编写管理工作线程的生命周期和它们对共享资源的访问的代码是可能的，但在一个应用程序到另一个应用程序中几乎是相同的。这就是为什么在Java的几个版本发布之后，线程管理的管道成为标准JDK库的一部分，作为`java.util.concurrent`包。这个包有丰富的接口和类，支持多线程和并发。我们将在后续章节中讨论如何使用大部分这些功能，同时讨论线程池、线程监视、线程同步和相关主题。
- en: Thread Pools
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池
- en: In this section, we will look into the `Executor` interfaces and their implementations
    provided in the `java.util.concurrent` package. They encapsulate thread management
    and minimize the time an application developer spends on the writing code related
    to threads' life cycles.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究`java.util.concurrent`包中提供的`Executor`接口及其实现。它们封装了线程管理，并最大程度地减少了应用程序开发人员在编写与线程生命周期相关的代码上所花费的时间。
- en: 'There are three `Executor` interfaces defined in the `java.util.concurrent`
    package. The first is the base `Executor` interface has only one `void execute(Runnable
    r)` method in it. It basically replaces the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor`接口在`java.util.concurrent`包中定义了三个。第一个是基本的`Executor`接口，其中只有一个`void
    execute(Runnable r)`方法。它基本上替代了以下内容：'
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, we can also avoid a new thread creation by getting it from a pool.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们也可以通过从池中获取线程来避免创建新线程。
- en: 'The second is the `ExecutorService` interface extends `Executor` and adds the
    following groups of methods that manage the life cycle of the worker threads and
    of the executor itself:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`ExecutorService`接口，它扩展了`Executor`并添加了以下管理工作线程和执行器本身生命周期的方法组：
- en: '`submit()`: Place in the queue for the execution of an object of the interface
    `Runnable` or interface `Callable` (allows the worker thread to return a value);
    return object of `Future` interface, which can be used to access the value returned
    by the `Callable` and to manage the status of the worker thread'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit()`: 将对象的执行放入接口`Runnable`或接口`Callable`的队列中（允许工作线程返回值）；返回`Future`接口的对象，可用于访问`Callable`返回的值并管理工作线程的状态'
- en: '`invokeAll()`: Place in the queue for the execution of a collection of interface
    `Callable` objects return, list of `Future` objects when all the worker threads
    are complete (there is also an overloaded `invokeAll()` method with timeout)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAll()`: 将一组接口`Callable`对象的执行放入队列中，当所有工作线程都完成时返回`Future`对象的列表（还有一个带有超时的重载`invokeAll()`方法）'
- en: '`invokeAny()`: Place in the queue for the execution of a collection of interface
    `Callable` objects; return one `Future` object of any of the worker threads, which
    has completed (there is also an overloaded `invokeAny()` method with timeout)'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invokeAny()`: 将一组接口`Callable`对象的执行放入队列中；返回任何已完成的工作线程的一个`Future`对象（还有一个带有超时的重载`invokeAny()`方法）'
- en: 'Methods that manage the worker threads status and the service itself:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 管理工作线程状态和服务本身的方法：
- en: '`shutdown()`: This prevents new worker threads from being submitted to the
    service'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown()`: 防止新的工作线程被提交到服务'
- en: '`isShutdown()`: This checks whether the shutdown of the executor was initiated'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isShutdown()`: 检查执行器是否已启动关闭'
- en: '`awaitTermination(long timeout, TimeUnit timeUnit)`: This waits until all worker
    threads have completed execution after a shutdown request, or the timeout occurs,
    or the current thread is interrupted, whichever happens first'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awaitTermination(long timeout, TimeUnit timeUnit)`: 在关闭请求后等待，直到所有工作线程完成执行，或超时发生，或当前线程被中断，以先发生的为准'
- en: '`isTerminated()`: This checks whether all the worker threads have completed
    after the shutdown was initiated; it never returns `true` unless either `shutdown()`
    or `shutdownNow()` was called first'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated()`: 在关闭被启动后检查所有工作线程是否已完成；除非首先调用了`shutdown()`或`shutdownNow()`，否则它永远不会返回`true`'
- en: '`shutdownNow()`: This interrupts each worker thread that is not completed;
    a worker thread should be written so that it checks its own status (using `Thread.currentThread().isInterrupted()`,
    for example) periodically and gracefully shuts down on its own; otherwise, it
    will continue running even after `shutdownNow()` was called'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdownNow()`: 中断每个未完成的工作线程；工作线程应该定期检查自己的状态（例如使用`Thread.currentThread().isInterrupted()`），并在自己上优雅地关闭；否则，即使调用了`shutdownNow()`，它也会继续运行'
- en: The third interface is `ScheduledExecutorService` that extends `ExecutorService`
    and adds methods that allow scheduling of the execution (one-time and periodic
    one) of the worker threads.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个接口是`ScheduledExecutorService`，它扩展了`ExecutorService`并添加了允许调度工作线程执行（一次性和周期性）的方法。
- en: 'A pool-based implementation of `ExecutorService` can be created using the `java.util.concurrent.ThreadPoolExecutor`
    or `java.util.concurrent.ScheduledThreadPoolExecutor` class. There is also a `java.util.concurrent.Executors`
    factory class that covers most of the practical cases. So, before writing a custom
    code for worker threads pool creation, we highly recommend looking into using
    the following factory methods of the `java.util.concurrent.Executors` class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`java.util.concurrent.ThreadPoolExecutor`或`java.util.concurrent.ScheduledThreadPoolExecutor`类创建基于池的`ExecutorService`实现。还有一个`java.util.concurrent.Executors`工厂类，涵盖了大部分实际情况。因此，在编写自定义代码创建工作线程池之前，我们强烈建议查看`java.util.concurrent.Executors`类的以下工厂方法：
- en: '`newSingleThreadExecutor()`: This creates an `ExecutorService` (pool) instance
    that executes worker threads sequentially'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadExecutor()`: 创建一个按顺序执行工作线程的`ExecutorService`（池）实例'
- en: '`newFixedThreadPool()`: This creates a thread pool that reuses a fixed number
    of worker threads; if a new task is submitted when all the worker threads are
    still executing, it will be set into the queue until a worker thread is available'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newFixedThreadPool()`: 创建一个重用固定数量的工作线程的线程池；如果在所有工作线程仍在执行时提交了新任务，它将被放入队列，直到有工作线程可用'
- en: '`newCachedThreadPool()`: This creates a thread pool that adds a new thread
    as needed, unless there is an idle thread created before; threads that have been
    idle for sixty seconds are removed from the cache'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newCachedThreadPool()`: 创建一个线程池，根据需要添加新线程，除非之前已创建了空闲线程；空闲了六十秒的线程将从缓存中移除'
- en: '`newScheduledThreadPool()`: This creates a thread pool of a fixed size that
    can schedule commands to run after a given delay, or to execute periodically'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newScheduledThreadPool()`: 创建一个固定大小的线程池，可以安排命令在给定延迟后运行，或定期执行'
- en: '`newSingleThreadScheduledExecutor()`: This creates a single-threaded executor
    that can schedule commands to run after a given delay, or to execute periodically'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newSingleThreadScheduledExecutor()`: 这将创建一个可以在给定延迟后调度命令运行或定期执行的单线程执行程序。'
- en: '`newWorkStealingThreadPool()`: This creates a thread pool that uses the same
    work-stealing mechanism used by `ForkJoinPool`, which is particularly useful in
    case the worker threads generate other threads, such as in recursive algorithms'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newWorkStealingThreadPool()`: 这将创建一个使用与`ForkJoinPool`相同的工作窃取机制的线程池，对于工作线程生成其他线程的情况特别有用，比如递归算法。'
- en: Each of these methods has an overloaded version that allows passing in a `ThreadFactory`
    that is used to create a new thread when needed. Let's see how it all works in
    a code sample.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都有一个重载版本，允许传入一个`ThreadFactory`，在需要时用于创建新线程。让我们看看在代码示例中如何运行。
- en: 'First, we create a `MyRunnable02` class that implements `Runnable`—our future
    worker threads:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个实现`Runnable`接口的`MyRunnable02`类——我们未来的工作线程：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice the important difference of this implementation from the previous examples--the
    `takeWhile(i -> !Thread.currentThread().isInterrupted())` operation allows the
    stream flowing as long as the thread worker status is not set to interrupted,
    which happens when the `shutdownNow()` method is called. As soon as the predicate
    of the `takeWhile()` returns `false` (the worker thread is interrupted), the thread
    stops producing the result (just ignores the current `result` value). In a real
    system, it would equate to skipping storing `result` value in the database, for
    example.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种实现与之前的示例有一个重要的区别——`takeWhile(i -> !Thread.currentThread().isInterrupted())`操作允许流继续流动，只要线程工作状态未被设置为中断，这在调用`shutdownNow()`方法时会发生。一旦`takeWhile()`的谓词返回`false`（工作线程被中断），线程就会停止产生结果（只是忽略当前的`result`值）。在实际系统中，这相当于跳过将`result`值存储在数据库中，例如。
- en: It is worth noting here that using the `interrupted()` status method for checking
    the thread status in the preceding code may lead to inconsistent results. Since
    the `interrupted()` method returns the correct state value and then clears the
    thread state, the second call to this method (or the call to the method `isInterrupted()`
    after the call to the method `interrupted()`) always returns `false`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在前面的代码中使用`interrupted()`状态方法来检查线程状态可能会导致不一致的结果。由于`interrupted()`方法返回正确的状态值，然后清除线程状态，因此对该方法的第二次调用（或在调用`interrupted()`方法后调用`isInterrupted()`方法）总是返回`false`。
- en: 'Although it is not the case in this code, we would like to mention here a mistake
    some developers make while implementing `try/catch` block in a worker thread.
    For example, if the worker needs to pause and wait for an interrupt signal, the
    code often looks like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这段代码中不是这种情况，但我们想在这里提到一些开发人员在实现工作线程的`try/catch`块时常犯的错误。例如，如果工作线程需要暂停并等待中断信号，代码通常如下所示：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can show how to execute the earlier `MyRunnable02` class with a cached
    pool implementation of the `ExecutiveService` pool (other types of thread pool
    are used similarly). First, we create the pool, submit three instances of the
    `MyRunnable02` class for execution and shut down the pool:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以展示如何使用`ExecutiveService`池的缓存池实现来执行之前的`MyRunnable02`类（其他类型的线程池使用方式类似）。首先，我们创建池，提交三个`MyRunnable02`类的实例进行执行，然后关闭池：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we run these lines, we will see the following output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行这些代码，将会看到以下输出：
- en: '![Thread Pools](img/03_10.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![线程池](img/03_10.jpg)'
- en: No surprises here! The `isShutdown()` method returns a `false` value before
    the `shutdown()` method is called and a `true` value afterward. The `isTerminated()`
    method returns a `false` value, because none of the worker threads has completed
    yet.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么意外！在调用`shutdown()`方法之前，`isShutdown()`方法返回`false`值，之后返回`true`值。`isTerminated()`方法返回`false`值，因为没有任何工作线程已经完成。
- en: 'Let''s test the `shutdown()` method by adding the following code after it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`shutdown()`方法后添加以下代码来测试`shutdown()`方法：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output will now have the following message (the screenshot would be either
    too big for this page or not readable when fitting):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出将包含以下消息（如果截图对于此页面来说太大或者在适应时不可读）。
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As expected, after the `shutdown()` method is called, no more worker threads
    can be added to the pool.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的是，在调用`shutdown()`方法后，将无法再向线程池中添加更多的工作线程。
- en: 'Now, let''s see what we can do after the shutdown was initiated:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看在启动关闭之后我们能做些什么：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `printRunningThreadIds()` method looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`printRunningThreadIds()`方法如下所示：'
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出将如下所示：
- en: '![Thread Pools](img/03_11.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![线程池](img/03_11.jpg)'
- en: This means that 100 ms was enough for each worker thread to complete the calculations.
    (Notice, if you try to reproduce this data on your computer, the results might
    be slightly different because of the difference in performance, so you would need
    to adjust the timeout.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个工作线程完成计算所需的时间为100毫秒。（请注意，如果您尝试在您的计算机上重现这些数据，由于性能差异，结果可能会略有不同，因此您需要调整超时时间。）
- en: 'When we have decreased the wait time to 75 ms, the output became as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将等待时间减少到75毫秒时，输出如下：
- en: '![Thread Pools](img/03_12.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![线程池](img/03_12.jpg)'
- en: The 75 ms on our computer was not enough to let all the threads complete, so
    they were interrupted by `shutdownNow()` and their partial results were ignored.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的计算机上，75毫秒不足以让所有线程完成，因此它们被`shutdownNow()`中断，并且它们的部分结果被忽略。
- en: 'Let''s now remove the check of the interrupted status in the `MyRunnable01`
    class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们移除`MyRunnable01`类中对中断状态的检查：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Without the check, even if we decrease the timeout to 1 ms, the result will
    be as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这个检查，即使我们将超时时间减少到1毫秒，结果也将如下所示：
- en: '![Thread Pools](img/03_13.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![线程池](img/03_13.jpg)'
- en: That is because the worker threads have never noticed that somebody tried to
    interrupt them and completed their assigned calculations. This last test demonstrates
    the importance of watching for the interrupted state in a work thread in order
    to avoid many possible problems, namely, data corruption and memory leak.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为工作线程从未注意到有人试图中断它们并完成了它们分配的计算。这最后的测试演示了在工作线程中观察中断状态的重要性，以避免许多可能的问题，即数据损坏和内存泄漏。
- en: The demonstrated cached pool works fine and poses no problem if the worker threads
    perform short tasks and their number cannot grow excessively large. If you need
    to have more control over the max number of worker threads running at any time,
    use the fixed size thread pool. We will discuss how to choose the pool size in
    one of the following sections of this lesson.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 演示的缓存池在工作线程执行短任务且其数量不会过多增长时运行良好，不会出现问题。如果您需要更多地控制任何时候运行的工作线程的最大数量，请使用固定大小的线程池。我们将在本课程的以下部分讨论如何选择池的大小。
- en: The single-thread pool is a good fit for executing tasks in a certain order
    or in the case when each of them requires so many resources that cannot be executed
    in parallel with another. Yet another case for using a single-thread execution
    would be for workers that modify the same data, but the data cannot be protected
    from the parallel access another way. The thread synchronization will be discussed
    in more detail in one of the following sections of this lesson, too.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 单线程池非常适合按特定顺序执行任务的情况，或者当每个任务需要的资源太多，无法与其他任务并行执行时。使用单线程执行的另一个情况是对修改相同数据的工作线程，但数据无法以其他方式受到并行访问的保护。线程同步也将在本课程的以下部分中更详细地讨论。
- en: In our sample code, so far we have only included the `execute()` method of the
    `Executor` interface. We will demonstrate the other methods of the `ExecutorService`
    pool in the following section while discussing threads monitoring.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例代码中，到目前为止，我们只包括了`Executor`接口的`execute()`方法。在接下来的部分中，我们将演示`ExecutorService`池的其他方法，同时讨论线程监控。
- en: And the last remark in this section. The worker threads are not required to
    be objects of the same class. They may represent completely different functionality
    and still be managed by one pool.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的最后一条备注。工作线程不需要是同一个类的对象。它们可以代表完全不同的功能，仍然可以由一个池管理。
- en: Monitoring Threads
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控线程
- en: 'There are two ways to monitor threads, programmatically and using the external
    tools. We have already seen how the result of a worker calculation could be checked.
    Let''s revisit that code. We will also slightly modify our worker implementation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种监控线程的方法，即通过编程和使用外部工具。我们已经看到了如何检查工作计算的结果。让我们重新访问一下那段代码。我们还将稍微修改我们的工作实现：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'For the worker thread identification, instead of custom ID, we now use the
    thread name assigned automatically at the time of the execution (that is why we
    assign the `name` property in the `run()` method that is called in the context
    of the execution when the thread acquires its name). The new class `MyRunnable03`
    can be used like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工作线程的标识，我们现在使用在执行时自动分配的线程名称，而不是自定义ID（这就是为什么我们在`run()`方法中分配`name`属性，在线程获取其名称时调用该方法）。新的`MyRunnable03`类可以像这样使用：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `shutdown()` method contains the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutdown()`方法包含以下代码：'
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we run the preceding code, the output will be as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，输出将如下所示：
- en: '![Monitoring Threads](img/03_14.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_14.jpg)'
- en: If the result on your computer is different, try to increase the input value
    to the `sleepMs()` method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机上的结果不同，请尝试增加`sleepMs()`方法的输入值。
- en: 'Another way to get information about the application worker threads is by using
    the `Future` interface. We can access this interface using the `submit()` method
    of the `ExecutorService` pool, instead of the `execute()`, `invokeAll()`, or `invokeAny()`
    methods. This code shows how to use the `submit()` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 获取有关应用程序工作线程的信息的另一种方法是使用`Future`接口。我们可以使用`ExecutorService`池的`submit()`方法访问此接口，而不是`execute()`、`invokeAll()`或`invokeAny()`方法。以下代码显示了如何使用`submit()`方法：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `printFuture()` method has the following implementation:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`printFuture()`方法的实现如下：'
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `sleepMs()` method contains the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleepMs()`方法包含以下代码：'
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We prefer this implementation instead of the traditional `Thread.sleep()` because
    it is explicit about the time units used.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更喜欢这种实现而不是传统的`Thread.sleep()`，因为它明确指定了使用的时间单位。
- en: 'If we execute the previous code, the result will be similar to the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行前面的代码，结果将类似于以下内容：
- en: '![Monitoring Threads](img/03_15.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_15.jpg)'
- en: 'The `printFuture()` method has blocked the main thread execution until the
    first thread has completed. Meanwhile, the second thread has completed too. If
    we call the `printFuture()` method after the `shutdown()` method, both the threads
    would complete by that time already because we have set a wait time of 1 second
    (see the `pool.awaitTermination()` method), which is enough for them to finish
    their job:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`printFuture()`方法已经阻塞了主线程的执行，直到第一个线程完成。与此同时，第二个线程也已经完成。如果我们在`shutdown()`方法之后调用`printFuture()`方法，那么两个线程在那时已经完成了，因为我们设置了1秒的等待时间（参见`pool.awaitTermination()`方法），这足够让它们完成工作。'
- en: '![Monitoring Threads](img/03_16.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_16.jpg)'
- en: 'If you think it is not much information from a threads monitoring point of
    view, the `java.util.concurrent` package provides more capabilities via the `Callable`
    interface. It is a functional interface that allows returning any object (containing
    results of the worker thread calculations) via the `Future` object using `ExecutiveService`
    methods--`submit()`, `invokeAll()`, and `invokeAny()`. For example, we can create
    a class that contains the result of a worker thread:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为这不是从线程监视的角度来看的太多信息，`java.util.concurrent`包通过`Callable`接口提供了更多功能。这是一个允许通过`Future`对象返回任何对象（包含工作线程计算结果的结果）的功能接口，使用`ExecutiveService`方法--`submit()`、`invokeAll()`和`invokeAny()`。例如，我们可以创建一个包含工作线程结果的类：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We have included the name of the worker thread too for monitoring which thread
    generated the result that is presented. The class that implements the `Callable`
    interface may look like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包括了工作线程的名称，以便监视生成的结果。实现`Callable`接口的类可能如下所示：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And here is the code that uses the `MyCallable01` class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`MyCallable01`类的代码：
- en: '[PRE35]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `printResult()` method contains the following code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`printResult()` 方法包含以下代码：'
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of this code may look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出可能如下所示：
- en: '![Monitoring Threads](img/03_17.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![监视线程](img/03_17.jpg)'
- en: The earlier output shows, as in the previous examples, that the `printResult()`
    method waits until the first of the worker threads finishes, so the second thread
    manages to finish its job at the same time. The advantage of using `Callable`,
    as you can see, is that we can retrieve the actual result from a `Future` object,
    if we need it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的输出显示，与之前的示例一样，`printResult()`方法会等待工作线程中的第一个完成，因此第二个线程成功在同一时间完成其工作。正如您所看到的，使用`Callable`的优点是，我们可以从`Future`对象中检索实际结果，如果需要的话。
- en: 'The usage of the `invokeAll()` and `invokeAny()` methods looks similar:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeAll()`和`invokeAny()`方法的使用看起来很相似：'
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `printResults()` method is using the `printResult()` method, which you
    already know:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`printResults()`方法使用了您已经了解的`printResult()`方法：'
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If we run the preceding code, the output will be as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，输出将如下所示：
- en: '![Monitoring Threads](img/03_18.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![监视线程](img/03_18.jpg)'
- en: As you can see, there is no more waiting for the worker thread completing the
    job. That is so because the `invokeAll()` method returns the collection of the
    `Future` object after all the jobs have completed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，不再等待工作线程完成工作。这是因为`invokeAll()`方法在所有作业完成后返回`Future`对象的集合。
- en: 'The `invokeAny()` method behaves similarly. If we run the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokeAny()`方法的行为类似。如果我们运行以下代码：'
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following will be the output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将是输出：
- en: '![Monitoring Threads](img/03_19.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![监视线程](img/03_19.jpg)'
- en: These are the basic techniques for monitoring the threads programmatically,
    but one can easily extend our examples to cover more complicated cases tailored
    to the needs of a specific application. In [Lesson 5](ch05.xhtml "Chapter 5. Making
    Use of New APIs to Improve Your Code"), *Making Use of New APIs to Improve Your
    Code*, we will also discuss another way to programmatically monitor worker threads
    using the `java.util.concurrent.CompletableFuture` class introduced in JDK 8 and
    extended in JDK 9.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是以编程方式监视线程的基本技术，但可以轻松地扩展我们的示例，以涵盖更复杂的情况，以满足特定应用程序的需求。在[第5课](ch05.xhtml "第5章
    利用新的API改进您的代码")中，*利用新的API改进您的代码*，我们还将讨论另一种以编程方式监视工作线程的方法，即JDK 8中引入并在JDK 9中扩展的`java.util.concurrent.CompletableFuture`类。
- en: 'If necessary, it is possible to get information not only about the application
    worker threads, but also about all other threads in the JVM process using the
    `java.lang.Thread` class:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以使用`java.lang.Thread`类获取有关JVM进程中的应用程序工作线程以及所有其他线程的信息：
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s call this method as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按如下方式调用此方法：
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The result looks like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Monitoring Threads](img/03_20.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![监视线程](img/03_20.jpg)'
- en: 'We took advantage of the `toString()` method of the `Thread` class that prints
    only the thread name, priority, and the thread group it belongs to. And we see
    the two application threads we have created explicitly (in addition to the `main`
    thread) in the list under the names `pool-1-thread-1` and `pool-1-thread-2`. But
    if we call the `printAllThreads()` method after calling the `shutdown()` method,
    the output will be as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用了`Thread`类的`toString()`方法，该方法仅打印线程名称、优先级和线程所属的线程组。我们可以在名称为`pool-1-thread-1`和`pool-1-thread-2`的列表中明确看到我们创建的两个应用程序线程（除了`main`线程）。但是，如果我们在调用`shutdown()`方法后调用`printAllThreads()`方法，输出将如下所示：
- en: '![Monitoring Threads](img/03_21.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![监视线程](img/03_21.jpg)'
- en: We do not see the `pool-1-thread-1` and `pool-1-thread-2` threads in the list
    anymore because the `ExecutorService` pool has been shut down.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再在列表中看到`pool-1-thread-1`和`pool-1-thread-2`线程，因为`ExecutorService`池已关闭。
- en: 'We could easily add the stack trace information pulled from the same map:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地添加从相同映射中提取的堆栈跟踪信息：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: However, that would take too much space on the book page. In [Lesson 5](ch05.xhtml
    "Chapter 5. Making Use of New APIs to Improve Your Code"), *Making Use of New
    APIs to Improve Your Code*, while presenting new Java capabilities that came with
    JDK 9, we will also discuss a better way to access a stack trace via the `java.lang.StackWalker`
    class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将占用书页太多空间。在[第5课](ch05.xhtml "第5章 利用新的API改进您的代码")中，*利用新的API改进您的代码*，我们将介绍随JDK
    9一起提供的新的Java功能，并讨论通过`java.lang.StackWalker`类更好地访问堆栈跟踪的方法。
- en: 'The `Thread` class object has several other methods that provide information
    about the thread, which are as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类对象还有其他几个方法，提供有关线程的信息，如下所示：'
- en: '`dumpStack()`: This prints a stack trace to the standard error stream'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dumpStack()`: 这将堆栈跟踪打印到标准错误流'
- en: '`enumerate(Thread[] arr)`: This copies active threads in the current thread''s
    thread group and its subgroups into the specified array `arr`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerate(Thread[] arr)`: 这将当前线程的线程组中的活动线程及其子组复制到指定的数组`arr`中'
- en: '`getId()`: This provides the thread''s ID'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getId()`: 这提供了线程的ID'
- en: '`getState()`: This reads the state of the thread; the possible values from
    `enum Thread.State` can be one of the following:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getState()`：这读取线程的状态；`enum Thread.State`的可能值可以是以下之一：'
- en: '`NEW`: This is the thread that has not yet started'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEW`：这是尚未启动的线程'
- en: '`RUNNABLE`: This is the thread that is currently being executed'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNNABLE`：这是当前正在执行的线程'
- en: '`BLOCKED`: This is the thread that is blocked waiting for a monitor lock to
    be released'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLOCKED`：这是正在等待监视器锁释放的线程'
- en: '`WAITING`: This is the thread that is waiting for an interrupt signal'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WAITING`：这是正在等待中断信号的线程'
- en: '`TIMED_WAITING`: This is the thread that is waiting for an interrupt signal
    up to a specified waiting time'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMED_WAITING`：这是等待中断信号直到指定等待时间的线程'
- en: '`TERMINATED`: This is the thread that has exited'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TERMINATED`：这是已退出的线程'
- en: '`holdsLock(Object obj)`: This indicates whether the thread holds the monitor
    lock on the specified object'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`holdsLock(Object obj)`：这表示线程是否持有指定对象的监视器锁'
- en: '`interrupted()` or `isInterrupted()`: This indicates whether the thread has
    been interrupted (received an interrupt signal, meaning that the flag interrupted
    was set to `true`)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interrupted()`或`isInterrupted()`：这表示线程是否已被中断（收到中断信号，意味着中断标志被设置为`true`）'
- en: '`isAlive()`: This indicates whether the thread is alive'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAlive()`：这表示线程是否存活'
- en: '`isDaemon()`: This indicates whether the thread is a daemon thread.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isDaemon()`：这表示线程是否为守护线程。'
- en: 'The `java.lang.management` package provides similar capabilities for monitoring
    threads. Let''s run this code snippet, for example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.management`包为监视线程提供了类似的功能。例如，让我们运行这段代码片段：'
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'For better presentation, we took advantage of having thread IDs listed and,
    as you could see previously, have sorted the output by ID. If we call the `printThreadsInfo()`
    method before the `shutdown()` method the output will be as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地呈现，我们利用了列出的线程ID，并且如您之前所见，已按ID对输出进行了排序。如果我们在`shutdown()`方法之前调用`printThreadsInfo()`方法，输出将如下所示：
- en: '![Monitoring Threads](img/03_22.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_22.jpg)'
- en: 'However, if we call the `printThreadsInfo()` method after the `shutdown()`
    method, the output will not include our worker threads anymore, exactly as in
    the case of using the `Thread` class API:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们在`shutdown()`方法之后调用`printThreadsInfo()`方法，输出将不再包括我们的工作线程，就像使用`Thread`类API的情况一样：
- en: '![Monitoring Threads](img/03_23.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![监控线程](img/03_23.jpg)'
- en: 'The `java.lang.management.ThreadMXBean` interface provides a lot of other useful
    data about threads. You can refer to the official API on the Oracle website about
    this interface for more information check this link: [https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/management/ThreadMXBean.html](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/management/ThreadMXBean.html).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.lang.management.ThreadMXBean`接口提供了关于线程的许多其他有用数据。您可以参考Oracle网站上关于此接口的官方API，了解更多信息，请查看此链接：[https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/management/ThreadMXBean.html](https://docs.oracle.com/javase/8/docs/api/index.html?java/lang/management/ThreadMXBean.html)。'
- en: In the list of threads mentioned earlier, you may have noticed the `Monitor
    Ctrl-Break` thread. This thread provides another way to monitor the threads in
    the JVM process. Pressing the *Ctrl* and *Break* keys on Windows causes the JVM
    to print a thread dump to the application's standard output. On Oracle Solaris
    or Linux operating systems, the same effect has the combination of the *Ctrl*
    key and the backslash *\*. This brings us to the external tools for thread monitoring.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面提到的线程列表中，您可能已经注意到`Monitor Ctrl-Break`线程。此线程提供了另一种监视JVM进程中线程的方法。在Windows上按下*Ctrl*和*Break*键会导致JVM将线程转储打印到应用程序的标准输出。在Oracle
    Solaris或Linux操作系统上，*Ctrl*键和反斜杠*\*的组合具有相同的效果。这将我们带到了用于线程监视的外部工具。
- en: 'In case you don''t have access to the source code or prefer to use the external
    tools for the threads monitoring, there are several diagnostic utilities available
    with the JDK installation. In the following list, we mention only the tools that
    allow for thread monitoring and describe only this capability of the listed tools
    (although they have other extensive functionality too):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法访问源代码或更喜欢使用外部工具进行线程监视，则JDK安装中提供了几种诊断实用程序。在以下列表中，我们仅提到允许线程监视的工具，并仅描述所列工具的此功能（尽管它们还具有其他广泛的功能）：
- en: 'The `jcmd` utility sends diagnostic command requests to the JVM on the same
    machine using the JVM process ID or the name of the main class: `jcmd <process
    id/main class> <command> [options]`, where the `Thread.print` option prints the
    stack traces of all the threads in the process.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jcmd`实用程序使用JVM进程ID或主类的名称向同一台机器上的JVM发送诊断命令请求：`jcmd <process id/main class>
    <command> [options]`，其中`Thread.print`选项打印进程中所有线程的堆栈跟踪。'
- en: The JConsole monitoring tool uses the built-in JMX instrumentation in the JVM
    to provide information about the performance and resource consumption of running
    applications. It has a thread tab pane that shows thread usage over time, the
    current number of live threads, the highest number of live threads since the JVM
    started. It is possible to select the thread and its name, state, and stack trace,
    as well as, for a blocked thread, the synchronizer that the thread is waiting
    to acquire, and the thread owning the lock. Use the **Deadlock Detection** button
    to identify the deadlock. The command to run the tool is `jconsole <process id>`
    or (for remote application) `jconsole <hostname>:<port>` , where `port` is the
    port number specified with the JVM start command that enabled the JMX agent.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JConsole监控工具使用JVM中的内置JMX工具来提供有关运行应用程序的性能和资源消耗的信息。它有一个线程选项卡窗格，显示随时间变化的线程使用情况，当前活动线程数，自JVM启动以来的最高活动线程数。可以选择线程及其名称、状态和堆栈跟踪，以及对于阻塞线程，线程正在等待获取的同步器以及拥有锁的线程。使用**死锁检测**按钮来识别死锁。运行该工具的命令是`jconsole
    <process id>`或（对于远程应用程序）`jconsole <hostname>:<port>`，其中`port`是使用启用JMX代理的JVM启动命令指定的端口号。
- en: The `jdb` utility is an example command line debugger. It can be attached to
    the JVM process and allows you to examine threads.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jdb`实用程序是一个示例命令行调试器。它可以附加到JVM进程并允许您检查线程。'
- en: The `jstack` command line utility can be attached to the JVM process and print
    the stack traces of all threads, including JVM internal threads, and optionally
    native stack frames. It allows you to detect deadlocks too.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jstack`命令行实用程序可以附加到JVM进程并打印所有线程的堆栈跟踪，包括JVM内部线程，还可以选择打印本地堆栈帧。它还允许您检测死锁。'
- en: '**Java Flight Recorder** (**JFR**) provides information about the Java process,
    including threads waiting for locks, garbage collections, and so on. It also allows
    getting thread dumps, which are similar to the one generated by the `Thread.print`
    diagnostic command or by using the jstack tool. It is possible to set up **Java
    Mission Control** (**JMC**) to dump a flight recording if a condition is met.
    JMC UI contains information about threads, lock contention, and other latencies.
    Although JFR is a commercial feature, it is free for developer desktops/laptops,
    and for evaluation purposes in test, development, and production environments.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java Flight Recorder**（**JFR**）提供有关Java进程的信息，包括等待锁的线程，垃圾收集等。它还允许获取线程转储，这类似于使用`Thread.print`诊断命令或使用jstack工具生成的线程转储。如果满足条件，可以设置**Java
    Mission Control**（**JMC**）来转储飞行记录。JMC UI包含有关线程、锁争用和其他延迟的信息。尽管JFR是商业功能，但对于开发人员的台式机/笔记本电脑以及测试、开发和生产环境中的评估目的，它是免费的。'
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more details about these and other diagnostic tools in the official
    Oracle documentation at [https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm](https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方Oracle文档[https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm](https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm)中找到有关这些和其他诊断工具的更多详细信息。
- en: Sizing Thread Pool Executors
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池执行器的大小
- en: In our examples, we have used a cached thread pool that creates a new thread
    as needed or, if available, reuses the thread already used, but which completed
    its job and returned to the pool for a new assignment. We did not worry about
    too many threads created because our demo application had two worker threads at
    the most and they were quite short lived.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了一个缓存线程池，根据需要创建新线程，或者如果可用，重用已经使用过的线程，但是完成了工作并返回到池中以便新的分配。我们不担心创建太多线程，因为我们的演示应用程序最多只有两个工作线程，并且它们的生命周期非常短。
- en: 'But in the case where an application does not have a fixed limit of the worker
    threads it might need or there is no good way to predict how much memory a thread
    may take or how long it can execute, setting a ceiling on the worker thread count
    prevents an unexpected degradation of the application performance, running out
    of memory or depletion of any other resources the worker threads use. If the thread
    behavior is extremely unpredictable, a single thread pool might be the only solution,
    with an option of using a custom thread pool executor (more about this last option
    is explained later). But in most of the cases, a fixed-size thread pool executor
    is a good practical compromise between the application needs and the code complexity.
    Depending on the specific requirements, such an executor might be one of these
    three flavors:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在应用程序没有固定的工作线程限制或者没有好的方法来预测线程可能占用多少内存或执行多长时间的情况下，设置工作线程计数的上限可以防止应用程序性能意外下降，内存耗尽或工作线程使用的其他任何资源枯竭。如果线程行为非常不可预测，单个线程池可能是唯一的解决方案，并且可以选择使用自定义线程池执行器（稍后将对此最后一个选项进行解释）。但在大多数情况下，固定大小的线程池执行器是应用程序需求和代码复杂性之间的一个很好的实际折衷。根据具体要求，这样的执行器可能是以下三种类型之一：
- en: A straightforward, fixed-sized `ExecutorService.newFixedThreadPool(int nThreads)`
    pool that does not grow beyond the specified size, but does not adopt either
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个直接的、固定大小的`ExecutorService.newFixedThreadPool(int nThreads)`池，不会超出指定的大小，也不会采用其他方式
- en: Several `ExecutorService.newScheduledThreadPool(int nThreads)` pools that allow
    scheduling different groups of threads with a different delay or cycle of execution
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService.newScheduledThreadPool(int nThreads)` 提供了几个允许调度不同线程组的线程池，具有不同的延迟或执行周期'
- en: '`ExecutorService.newWorkStealingPool(int parallelism)` that adapts to the specified
    number of CPUs, which you may set higher or smaller than the actual CPUs count
    on your computer'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutorService.newWorkStealingPool(int parallelism)`，它适应于指定数量的CPU，您可以将其设置为高于或低于计算机上实际CPU数量'
- en: Setting the fixed size in any of the preceding pools too low may deprive the
    application of the chance to utilize the available resources effectively. So,
    before selecting the pool size, it is advisable to spend some time on monitoring
    it and tuning JVM (see how to do it in one of the sections of this lesson) with
    the goal of the identification of the idiosyncrasy of the application behavior.
    In fact, the cycle deploy-monitor-tune-adjust has to be repeated throughout the
    application life cycle in order to accommodate and take advantage of the changes
    that happened in the code or the executing environment.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何上述池中设置固定大小过低可能会剥夺应用程序有效利用可用资源的机会。因此，在选择池大小之前，建议花一些时间对其进行监视和调整JVM（请参阅本课程的某个部分中如何执行此操作），以便识别应用程序行为的特殊性。实际上，部署-监视-调整-调整的周期必须在整个应用程序生命周期中重复进行，以适应并利用代码或执行环境中发生的变化。
- en: The first parameter you take into account is the number of CPUs in your system,
    so the thread pool size can be at least as big as the CPU's count. Then, you can
    monitor the application and see how much time each thread engages the CPU and
    how much of the time it uses other resources (such as I/O operations). If the
    time spent not using the CPU is comparable with the total executing time of the
    thread, then you can increase the pool size by **time not using CPU/total executing
    time**. But that is in the case that another resource (disk or database) is not
    a subject of contention between the threads. If the latter is the case, then you
    can use that resource instead of the CPU as the delineating factor.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您考虑的第一个参数是系统中的CPU数量，因此线程池大小至少可以与CPU数量一样大。然后，您可以监视应用程序，查看每个线程使用CPU的时间以及使用其他资源（如I/O操作）的时间。如果未使用CPU的时间与线程的总执行时间相当，那么可以通过**未使用CPU的时间/总执行时间**来增加池大小。但前提是另一个资源（磁盘或数据库）不是线程之间争用的主题。如果是后者的情况，那么可以使用该资源而不是CPU作为界定因素。
- en: Assuming the worker threads of your application are not too big or too long
    executing and belong to the mainstream population of the typical working threads
    that complete their job in a reasonably short period of time, you can increase
    the pool size by adding the (rounded up) ratio of the desired response time and
    the time a thread uses CPU or another most contentious resource. This means that,
    with the same desired response time, the less a thread uses CPU or another concurrently
    accessed resource, the bigger the pool size should be. If the contentious resource
    has its own ability to improve concurrent access (like a connection pool in the
    database), consider utilizing that feature first.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的应用程序的工作线程不是太大或执行时间不太长，并且属于典型工作线程的主流人口，可以通过增加期望响应时间和线程使用CPU或其他最具争议资源的时间的比率（四舍五入）来增加池大小。这意味着，对于相同的期望响应时间，线程使用CPU或其他同时访问的资源越少，池大小就应该越大。如果具有改善并发访问能力的争议资源（如数据库中的连接池），请首先考虑利用该功能。
- en: If the required number of threads running at the same time changes at runtime
    under the different circumstances, you can make the pool size dynamic and create
    a new pool with a new size (shutting down the old pool after all its threads have
    completed). The recalculation of the size of a new pool might be necessary also
    after you add to remove the available resources. You can use `Runtime.getRuntime().availableProcessors()`
    to programmatically adjust the pool size based on the current count of the available
    CPUs, for example.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在不同情况下运行的同时所需的线程数量在运行时发生变化，可以使池大小动态化，并创建一个新大小的池（在所有线程完成后关闭旧池）。在添加或删除可用资源后，可能还需要重新计算新池的大小。例如，您可以使用`Runtime.getRuntime().availableProcessors()`根据当前可用CPU的数量来以编程方式调整池大小。
- en: If none of the ready-to-use thread pool executor implementations that come with
    the JDK suit the needs of a particular application, before writing the thread
    managing code from scratch, try to use the `java.util.concurrent.ThreadPoolExecutor`
    class first. It has several overloaded constructors.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JDK提供的现成线程池执行器实现都不适合特定应用程序的需求，在从头开始编写线程管理代码之前，可以尝试首先使用`java.util.concurrent.ThreadPoolExecutor`类。它有几个重载的构造函数。
- en: 'To give you an idea of its capabilities, here is the constructor with the biggest
    number of options:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您了解其功能，这是具有最多选项的构造函数：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The earlier mentioned parameters are (quoting from the JavaDoc):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的参数是（引用自JavaDoc）：
- en: '`corePoolSize`: This is the number of threads to keep in the pool, even if
    they are idle unless `allowCoreThreadTimeOut` is set'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`corePoolSize`: 这是保留在池中的线程数，即使它们处于空闲状态，除非设置了`allowCoreThreadTimeOut`'
- en: '`maximumPoolSize`: This is the maximum number of threads to allow in the pool'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maximumPoolSize`: 这是允许在池中的最大线程数'
- en: '`keepAliveTime`: When the number of threads is greater than the core, this
    is the maximum time that excess idle threads will wait for new tasks before terminating'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keepAliveTime`: 当线程数大于核心数时，这是多余的空闲线程在终止之前等待新任务的最长时间'
- en: '`unit`: This is the time unit for the `keepAliveTime` argument'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unit`: 这是`keepAliveTime`参数的时间单位'
- en: '`workQueue`: This is the queue to use for holding tasks before they are executed,
    this queue will hold only the `Runnable` tasks submitted by the execute method'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workQueue`: 这是在执行任务之前用于保存任务的队列，该队列将仅保存由`execute`方法提交的`Runnable`任务'
- en: '`threadFactory`: This is the factory to use when the executor creates a new
    thread'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threadFactory`: 这是执行器创建新线程时要使用的工厂'
- en: '`handler`: This is the handler to use when the execution is blocked because
    the thread bounds and queue capacities are reached'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handler`: 这是在执行受阻时要使用的处理程序，因为已达到线程边界和队列容量'
- en: Each of the previous constructor parameters except the `workQueue` parameter
    can also be set via the corresponding setter after the object of the `ThreadPoolExecutor`
    method has been created, thus allowing more flexibility in dynamic adjustment
    of the existing pool characteristics.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`workQueue`参数之外，以前的构造函数参数也可以在创建`ThreadPoolExecutor`对象后通过相应的setter进行设置，从而在动态调整现有池特性时提供更大的灵活性。
- en: Thread Synchronization
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程同步
- en: We have collected enough people and resources such as food, water, and tools
    for the pyramid building. We have divided people into teams and assigned each
    team a task. A number (a pool) of people are living in the nearby village on a
    standby mode, ready to replace the ones that got sick or injured on their assignment.
    We adjusted the workforce count so that there are only a few people who will remain
    idle in the village. We rotate the teams through the work-rest cycle to keep the
    project going at maximum speed. We monitored the process and have adjusted the
    number of teams and the flow of supplies they need so that there are no visible
    delays and there is steady measurable progress in the project as a whole. Yet,
    there are many moving parts overall and various small and big unexpected incidents
    and problems happen all the time.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经收集了足够的人员和资源，如食物、水和工具，用于金字塔的建造。我们将人员分成团队，并为每个团队分配了一个任务。一个（池）人住在附近的村庄，处于待命状态，随时准备取代在任务中生病或受伤的人。我们调整了劳动力数量，以便只有少数人会在村庄中闲置。我们通过工作-休息周期轮换团队，以保持项目以最大速度进行。我们监控了整个过程，并调整了团队数量和他们所需的供应流量，以确保没有明显的延迟，并且整个项目中有稳定的可测量的进展。然而，整体上有许多活动部分和各种大小的意外事件和问题经常发生。
- en: To make sure that the workers and teams do not step on each other and that there
    is some kind of traffic regulation so that the next technological step does not
    start until the previous one is finished, the main architect sends his representatives
    to all the critical points of the construction site. These representatives make
    sure that the tasks are executed with the expected quality and in the prescribed
    order. They have the power to stop the next team from starting their job until
    the previous team has not finished yet. They act like traffic cops or the locks
    that can shut down the access to the workplace or allow it, if/when necessary.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保工人和团队不会互相干扰，并且有某种交通规则，以便下一个技术步骤在前一个完成之前不会开始，主建筑师派遣他的代表到建筑工地的所有关键点。这些代表确保任务以预期的质量和规定的顺序执行。他们有权力阻止下一个团队开始工作，直到前一个团队尚未完成。他们就像交通警察或可以关闭工作场所的锁，或者在必要时允许它。
- en: The job these representatives are doing can be defined in the modern language
    as a coordination or synchronization of actions of the executing units. Without
    it, the results of the efforts of the thousands of workers would be unpredictable.
    The big picture from ten thousand feet would look smooth and harmonious, as the
    farmers' fields from the windows of an airplane. But without closer inspection
    and attention to the critical details, this perfect looking picture may bring
    a poor harvest, if any.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代表正在做的工作可以用现代语言定义为执行单元的协调或同步。没有它，成千上万的工人的努力结果将是不可预测的。从一万英尺高的大局观看起来平稳和和谐，就像飞机窗户外的农田一样。但是，如果不仔细检查和关注关键细节，这个看起来完美的画面可能会带来一次糟糕的收成，甚至没有收成。
- en: 'Similarly, in the quiet electronic space of the multithreaded execution environment,
    the working threads have to be synchronized if they share access to the same working
    place. For example, let''s create the following class-worker for a thread:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在多线程执行环境的安静电子空间中，如果它们共享对同一工作场所的访问权，工作线程必须进行同步。例如，让我们为一个线程创建以下类-工作者：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see, it sequentially adds 1, 2, 3, 4, 5 (so, that the resulting
    total is expected to be 15) to the static property of the `Demo04Synchronization`
    class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它依次将1、2、3、4、5（因此，预期的总和应该是15）添加到`Demo04Synchronization`类的静态属性中：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the earlier code, while the main thread pauses for 100 ms the first time,
    the thread `t1` brings the value of the variable result to 15, then the thread
    `t2` adds another 15 to get the total of 30\. Here is the output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的代码中，当主线程第一次暂停100毫秒时，线程`t1`将变量result的值带到15，然后线程`t2`再添加15，得到总和30。以下是输出：
- en: '![Thread Synchronization](img/03_24.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![线程同步](img/03_24.jpg)'
- en: 'If we remove the first pause of 100 ms, the threads will work concurrently:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们去掉100毫秒的第一个暂停，线程将同时工作：
- en: '![Thread Synchronization](img/03_25.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![线程同步](img/03_25.jpg)'
- en: 'The final result is still 30\. We feel good about this code and deploy it to
    production as a well-tested code. However, if we increase the number of additions
    from 5 to 250, for example, the result becomes unstable and changes from run to
    run. Here is the first run (we commented out the printout in each thread in order
    to save space):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果仍然是30。我们对这段代码感到满意，并将其部署到生产环境中作为经过充分测试的代码。然而，如果我们将添加的次数从5增加到250，例如，结果将变得不稳定，并且每次运行都会发生变化。以下是第一次运行（我们注释掉了每个线程的打印输出，以节省空间）：
- en: '![Thread Synchronization](img/03_26.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![线程同步](img/03_26.jpg)'
- en: 'And here is the output of another run:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一次运行的输出：
- en: '![Thread Synchronization](img/03_27.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![线程同步](img/03_27.jpg)'
- en: 'It demonstrates the fact that the `Demo04Synchronization.result += i` operation
    is not atomic. This means it consists of several steps, reading the value from
    the `result` property, adding a value to it, assigning the resulting sum back
    to the `result` property. This allows the following scenario, for example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 它证明了`Demo04Synchronization.result += i`操作不是原子的。这意味着它包括几个步骤，从`result`属性中读取值，向其添加值，将得到的总和分配回`result`属性。这允许以下情景，例如：
- en: Both the threads have read the current value of `result` (so each of the threads
    has a copy of the same original `result` value)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个线程都读取了`result`的当前值（因此每个线程都有相同原始`result`值的副本）
- en: Each thread adds another integer to the same original one
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个线程都向相同的原始整数添加另一个整数
- en: The first thread assigns the sum to the `result` property
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个线程将总和分配给`result`属性
- en: The second thread assigns its sum to the `result` property
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个线程将其总和分配给`result`属性
- en: As you can see, the second thread did not know about the addition the first
    thread made and has overwritten the value assigned to the `result` property by
    the first thread. But such thread interleaving does not happen every time. It
    is just a game of chance. That's why we did not see such an effect with five numbers
    only. But the probability of this happening increases with the growth of the number
    of concurrent actions.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，第二个线程不知道第一个线程所做的加法，并且覆盖了第一个线程分配给`result`属性的值。但是这种线程交错并不是每次都会发生。这只是一个机会游戏。这就是为什么我们只看到五个数字时没有看到这样的效果。但是随着并发操作数量的增加，这种情况发生的概率会增加。
- en: 'A similar thing could happen during the pyramid building too. The second team
    could start doing something before the first team has finished their task. We
    definitely need a **synchronizer** and it comes with a `synchronized` keyword.
    Using it, we can create a method (an architect representative) in the `Demo04Synchronization`
    class that will control access to the `result` property and add to it this keyword:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在建造金字塔的过程中也可能发生类似的情况。第二个团队可能在第一个团队完成任务之前开始做一些事情。我们绝对需要一个**同步器**，它使用`synchronized`关键字。通过使用它，我们可以在`Demo04Synchronization`类中创建一个方法（建筑师代表），控制对`result`属性的访问，并向其添加这个关键字。
- en: '[PRE47]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now we have to modify the `run()` method in the worker thread too:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们也需要修改工作线程中的`run()`方法：
- en: '[PRE48]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The output now shows the same final number for every run:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出显示每次运行都有相同的最终数字：
- en: '![Thread Synchronization](img/03_28.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![线程同步](img/03_28.jpg)'
- en: The `synchronized` keyword tells JVM that only one thread at a time is allowed
    to enter this method. All the other threads will wait until the current visitor
    of the method exits from it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`synchronized`关键字告诉JVM一次只允许一个线程进入这个方法。所有其他线程将等待，直到当前访问者退出该方法。'
- en: 'The same effect could be achieved by adding the `synchronized` keyword to a
    block of code:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向代码块添加`synchronized`关键字也可以实现相同的效果：
- en: '[PRE49]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The difference is that the block synchronization requires an object--a class
    object in the case of static property synchronization (as in our case) or any
    other object in the case of an instance property synchronization. Each object
    has an intrinsic lock or monitor lock, often referred to simply as a monitor.
    Once a thread acquires a lock on an object, no other thread can acquire it on
    the same object until the first thread releases the lock after normal exit from
    the locked code or if the code throws an exception.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，代码块同步需要一个对象--在静态属性同步的情况下是一个类对象（就像我们的情况一样），或者在实例属性同步的情况下是任何其他对象。每个对象都有一个固有锁或监视器锁，通常简称为监视器。一旦一个线程在对象上获取了锁，直到第一个线程从锁定的代码中正常退出或代码抛出异常后释放锁，其他线程就无法在同一个对象上获取锁。
- en: In fact, in the case of a synchronized method, an object (the one to which the
    method belongs) is used for locking, too. It just happens behind the scene automatically
    and does not require the programmer to use an object's lock explicitly.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在同步方法的情况下，一个对象（方法所属的对象）也被用于锁定。它只是在幕后自动发生，不需要程序员明确地使用对象的锁。
- en: 'In case you do not have access to the `main` class code (as in the example
    earlier) you can keep the `result` property public and add a synchronized method
    to the worker thread (instead of the class as we have done):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有访问`main`类代码（就像之前的例子一样），您可以将`result`属性保持为公共，并在工作线程中添加一个同步方法（而不是像我们所做的那样添加到类中）：
- en: '[PRE50]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this case, the object of the `MyRunnable05` worker class provides its intrinsic
    lock by default. This means, you need to use the same object of the `MyRunnable05`
    class for all the threads:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`MyRunnable05`工作类的对象默认提供其固有锁。这意味着，您需要为所有线程使用`MyRunnable05`类的相同对象：
- en: '[PRE51]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output of the preceding code is the same as before:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出与之前相同：
- en: '![Thread Synchronization](img/03_29.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![线程同步](img/03_29.jpg)'
- en: One can argue that this last implementation is preferable because it allocates
    the responsibility of the synchronization with the thread (and the author of its
    code) and not with the shared resource. This way the need for synchronization
    changes along with the thread implementation evolution, provided that the client
    code (that uses the same or different objects for the threads) can be changed
    as needed as well.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有人可能会认为这种最后的实现更可取，因为它将同步的责任分配给了线程（以及其代码的作者），而不是共享资源。这样，随着线程实现的演变，同步的需求也会发生变化，只要客户端代码（使用相同或不同的对象进行线程）也可以根据需要进行更改。
- en: There is another possible concurrency issue that may happen in some operating
    systems. Depending on how the thread caching is implemented, a thread might preserve
    a local copy of the property `result` and not update it after another thread has
    changed its value. By adding the `volatile` keyword to the shared (between threads)
    property guarantees that its current value will be always read from the main memory,
    so each thread will see the updates done by the other threads. In our previous
    examples, we just set the `Demo04Synchronization` class property as `private static
    volatile int result`, add a synchronized `incrementResult()` method to the same
    class or to the thread and do not worry anymore about threads stepping on each
    other.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个可能发生在某些操作系统中的并发问题。根据线程缓存的实现方式，一个线程可能会保留`result`属性的本地副本，并且在另一个线程更改其值后不会更新它。通过向共享（在线程之间）属性添加`volatile`关键字，可以保证其当前值始终从主内存中读取，因此每个线程都将看到其他线程所做的更新。在我们之前的例子中，我们只是将`Demo04Synchronization`类的属性设置为`private
    static volatile int result`，在同一类或线程中添加一个同步的`incrementResult()`方法，不再担心线程相互干扰。
- en: The described thread synchronization is usually sufficient for the mainstream
    application. But the higher performance and highly concurrent processing often
    require looking closer into the thread dump, which typically shows that method
    synchronization is more efficient than block synchronization. Naturally, it also
    depends on the size of the method and the block. Since all the other threads that
    try to access the synchronized method or block are going to stop execution until
    the current visitor of the method or block exits it, it is possible that despite
    the overhead a small synchronized block yields better performance than the big
    synchronized method.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 所描述的线程同步通常对主流应用程序来说已经足够了。但是，更高性能和高并发处理通常需要更仔细地查看线程转储，这通常显示方法同步比块同步更有效。当然，这也取决于方法和块的大小。由于所有其他尝试访问同步方法或块的线程都将停止执行，直到当前访问者退出该方法或块，因此尽管有开销，但小的同步块可能比大的同步方法性能更好。
- en: 'For some applications, the behavior of the default intrinsic lock, which just
    blocks until the lock is released, maybe not well suited. If that is the case,
    consider using locks from the `java.util.concurrent.locks` package. The access
    control based on locks from that package has several differences if compared with
    using the default intrinsic lock. These differences may be advantageous for your
    application or provide the unnecessary complication, but it''s important to know
    them, so you can make an informed decision:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用程序，默认的内部锁的行为可能不太合适，因为它只会在锁被释放之前阻塞。如果是这种情况，请考虑使用`java.util.concurrent.locks`包中的锁。与使用默认的内部锁相比，该包中的锁所基于的访问控制有几个不同之处。这些差异可能对您的应用程序有利，也可能提供不必要的复杂性，但重要的是要了解它们，以便您可以做出明智的决定：
- en: The synchronized fragment of code does not need to belong to one method; it
    can span several methods, delineated by the calls to the `lock()` and `unlock()`
    methods (invoked on the object that implements the `Lock` interface)
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的同步片段不需要属于一个方法；它可以跨越几个方法，由实现`Lock`接口的对象上调用`lock()`和`unlock()`方法来界定
- en: While creating an object of the `Lock` interface called `ReentrantLock`, it
    is possible to pass into the constructor a `fair` flag that makes the lock able
    to grant an access to the longest-waiting thread first, which helps to avoid starvation
    (when the low priority thread never can get access to the lock)
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建名为`ReentrantLock`的`Lock`接口对象时，可以在构造函数中传递一个`fair`标志，使锁能够首先授予等待时间最长的线程访问，这有助于避免饥饿（低优先级线程永远无法访问锁）
- en: Allows a thread to test whether the lock is accessible before committing to
    be blocked
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许线程在承诺被阻塞之前测试锁是否可访问
- en: Allows interrupting a thread waiting for the lock, so it does not remain blocked
    indefinitely
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许中断等待锁的线程，以便它不会无限期地保持阻塞
- en: You can implement the `Lock` interface yourself with whatever features you need
    for your application
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以根据应用程序需要自己实现`Lock`接口
- en: 'A typical pattern of usage of the `Lock` interface looks like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lock`接口的典型使用模式如下：'
- en: '[PRE52]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice the `finally` block. It is the way to guarantee that the `lock` is released
    eventually. Otherwise, the code inside the `try-catch` block can throw an exception
    and the lock is never released.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`finally`块。这是确保最终释放`lock`的方法。否则，在`try-catch`块内的代码可能会抛出异常，而锁却永远不会被释放。
- en: 'In addition to the `lock()` and `unlock()` methods, the `Lock` interface has
    the following methods:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`lock()`和`unlock()`方法之外，`Lock`接口还有以下方法：
- en: '`lockInterruptibly()`: This acquires the lock unless the current thread is
    interrupted. Similar to the `lock()` method, this method blocks while waiting
    until the lock is acquired, in difference to the `lock()` method, if another thread
    interrupts the waiting thread, this method throws the `InterruptedException` exception'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lockInterruptibly()`: 除非当前线程被中断，否则获取锁。与`lock()`方法类似，此方法在等待锁被获取时阻塞，与`lock()`方法不同的是，如果另一个线程中断等待线程，此方法会抛出`InterruptedException`异常'
- en: '`tryLock()`: This acquires the lock immediately if it is free at the time of
    invocation'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tryLock()`: 如果在调用时空闲，立即获取锁'
- en: '`tryLock(long time, TimeUnit unit)`: This acquires the lock if it is free within
    the given waiting time and the current thread has not been interrupted'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tryLock(long time, TimeUnit unit)`: 如果在给定的等待时间内空闲，并且当前线程未被中断，则获取锁'
- en: '`newCondition()`: This returns a new `Condition` instance that is bound to
    this `Lock` instance, after acquiring the lock, the thread can release it (calling
    the `await()` method on the `Condition` object) until some other thread calls
    `signal()` or `signalAll()` on the same `Condition` object, it is also possible
    to specify the timeout period (by using an overloaded `await()` method), so the
    thread will resume after the timeout if there was no signal received, see the
    `Condition` API for more details'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newCondition()`: 返回一个绑定到此`Lock`实例的新`Condition`实例，获取锁后，线程可以释放它（在`Condition`对象上调用`await()`方法），直到其他线程在相同的`Condition`对象上调用`signal()`或`signalAll()`，还可以指定超时期限（使用重载的`await()`方法），因此如果没有收到信号，线程将在超时后恢复，有关更多详细信息，请参阅`Condition`
    API'
- en: The scope of this book does not allow us to show all the possibilities for thread
    synchronization provided in the `java.util.concurrent.locks` package. It would
    take several lessons to describe all of them. But even from this short description,
    you can see that one would be hard pressed to find a synchronization problem that
    cannot be solved using the `java.util.concurrent.locks` package.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的范围不允许我们展示`java.util.concurrent.locks`包中提供的所有线程同步可能性。描述所有这些可能需要几节课。但即使从这个简短的描述中，您也可以看到很难找到一个不能使用`java.util.concurrent.locks`包解决的同步问题。
- en: The synchronization of a method or block of code makes sense when several lines
    of code have to be isolated as an atomic (all or nothing) operation. But in the
    case of a simple assignment to a variable or increment/decrement of a number (as
    in our earlier examples), there is a much better way to synchronize this operation
    by using classes from the `java.util.concurrent.atomic` package that support lock-free
    thread-safe programming on a single variable. The variety of classes covers all
    the numbers and even arrays and reference types such as `AtomicBoolean`, `AtomicInteger`,
    `AtomicIntegerArray`, `AtomicReference`, and `AtomicReferenceArray`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要隔离几行代码作为原子（全有或全无）操作时，方法或代码块的同步才有意义。但是在简单的变量赋值或数字的增加/减少的情况下（就像我们之前的例子中一样），有一种更好的方式可以通过使用`java.util.concurrent.atomic`包中支持无锁线程安全编程的类来同步这个操作。各种类涵盖了所有的数字，甚至是数组和引用类型，比如`AtomicBoolean`、`AtomicInteger`、`AtomicIntegerArray`、`AtomicReference`和`AtomicReferenceArray`。
- en: There are 16 classes in total. Depending on the value type, each of them allows
    a full imaginable range of operations, that is, `set()`, `get()`, `addAndGet()`,
    `compareAndSet()`, `incrementAndGet()`, `decrementAndGet()`, and many others.
    Each operation is implemented much more efficiently than the same operations implemented
    with the `synchronized` keyword. And there is no need for the `volatile` keyword
    because it uses it under the hood.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有16个类。根据值类型的不同，每个类都允许进行全方位的操作，即`set()`、`get()`、`addAndGet()`、`compareAndSet()`、`incrementAndGet()`、`decrementAndGet()`等等。每个操作的实现要比使用`synchronized`关键字实现的同样操作要高效得多。而且不需要`volatile`关键字，因为它在底层使用了它。
- en: If the concurrently accessed resource is a collection, the `java.util.concurrent`
    package offers a variety of thread-safe implementations that perform better than
    synchronized `HashMap`, `Hashtable`, `HashSet`, `Vector`, and `ArrayList` (if
    we compare the corresponding `ConcurrentHashMap`, `CopyOnWriteArrayList`, and
    `CopyOnWriteHashSet`). The traditional synchronized collections lock the whole
    collection while concurrent collections use such advanced techniques such as lock
    stripping to achieve thread safety. The concurrent collections especially shine
    with more reading and fewer updates and they are much more scalable than synchronized
    collections. But if the size of your shared collection is small and writes dominate,
    the advantage of concurrent collections is not as obvious.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同时访问的资源是一个集合，`java.util.concurrent`包提供了各种线程安全的实现，其性能优于同步的`HashMap`、`Hashtable`、`HashSet`、`Vector`和`ArrayList`（如果我们比较相应的`ConcurrentHashMap`、`CopyOnWriteArrayList`和`CopyOnWriteHashSet`）。传统的同步集合会锁定整个集合，而并发集合使用诸如锁分离之类的先进技术来实现线程安全。并发集合在更多读取和较少更新时特别出色，并且比同步集合更具可伸缩性。但是，如果您的共享集合的大小较小且写入占主导地位，那么并发集合的优势就不那么明显了。
- en: Tuning JVM
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整JVM
- en: Each pyramid building, as any big project, goes through the same life cycle
    of design, planning, execution, and delivery. And throughout each of these phases,
    a continuous tuning is going on, a complex project is called so for a reason.
    A software system is not different in this respect. We design, plan and build
    it, then change and tune continuously. If we are lucky, then the new changes do
    not go too far back to the initial stages and do not require changing the design.
    To hedge against such drastic steps, we use prototypes (if the waterfall model
    is used) or iterative delivery (if the agile process is adopted) for early detection
    of possible problems. Like young parents, we are always on alert, monitoring the
    progress of our child, day and night.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 每座金字塔建筑，就像任何大型项目一样，都经历着设计、规划、执行和交付的相同生命周期。在每个阶段，都在进行持续的调整，一个复杂的项目之所以被称为如此，是有原因的。软件系统在这方面并没有什么不同。我们设计、规划和构建它，然后不断地进行更改和调整。如果我们幸运的话，新的更改不会太大地回到最初的阶段，也不需要改变设计。为了防范这种激烈的步骤，我们使用原型（如果采用瀑布模型）或迭代交付（如果采用敏捷过程）来尽早发现可能的问题。就像年轻的父母一样，我们总是警惕地监视着我们孩子的进展，日夜不停。
- en: 'As we mentioned already in one of the previous sections, there are several
    diagnostic tools that come with each JDK 9 installation or can be used in addition
    to them for monitoring your Java application. The full list of these tools (and
    the recommendations how to create a custom tool, if needed) can be found in official
    Java SE documentation on the Oracle site: [https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm](https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的某个部分中已经提到的，每个JDK 9安装都附带了几个诊断工具，或者可以额外使用这些工具来监视您的Java应用程序。这些工具的完整列表（以及如何创建自定义工具的建议，如果需要的话）可以在Oracle网站的官方Java
    SE文档中找到：[https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm](https://docs.oracle.com/javase/9/troubleshoot/diagnostic-tools.htm)。
- en: Using these tools one identifies the bottleneck of the application and addresses
    it either programmatically or by tuning the JVM itself or both. The biggest gain
    usually comes with the good design decisions and from using certain programming
    techniques and frameworks, some of which we have described in other sections.
    In this section, we are going to look at the options available after all possible
    code changes are applied or when changing code is not an option, so all we can
    do is to tune JVM itself.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些工具，可以识别应用程序的瓶颈，并通过编程或调整JVM本身或两者兼而行之来解决。最大的收益通常来自良好的设计决策以及使用某些编程技术和框架，其中一些我们在其他部分中已经描述过。在本节中，我们将看看在应用所有可能的代码更改后或者当更改代码不是一个选项时可用的选项，因此我们所能做的就是调整JVM本身。
- en: 'The goal of the effort depends on the results of the application profiling
    and the nonfunctional requirements for:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 努力的目标取决于应用程序的分析结果和非功能性需求：
- en: Latency, or how responsive the application is to the input
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟，或者说应用程序对输入的响应速度
- en: Throughput, or how much work the application is doing in a given unit of time
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吞吐量，或者说应用程序在给定时间单位内所做的工作量
- en: Memory footprint, or how much memory the application requires
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存占用，或者说应用程序需要多少内存
- en: The improvements in one of them often are possible only at the expense of the
    one or both of the others. The decrease in the memory consumption may bring down
    the throughput and latency, while the decrease in latency typically can be achieved
    only via the increase in memory footprint unless you can bring in faster CPUs
    thus improving all three characteristics.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个的改进通常只能以牺牲另一个或两者的方式实现。内存消耗的减少可能会降低吞吐量和延迟，而延迟的减少通常只能通过增加内存占用来实现，除非你可以引入更快的CPU，从而改善这三个特性。
- en: Application profiling may show that one particular operation keeps allocating
    a lot of memory in the loop. If you have an access to the code, you can try to
    optimize this section of the code and thus ease the pressure on JVM. Alternatively,
    it may show that there is an I/O or another interaction with a low device is involved,
    and there is nothing you can do in the code to improve it.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序分析可能会显示，一个特定的操作在循环中不断分配大量内存。如果你可以访问代码，可以尝试优化代码的这一部分，从而减轻JVM的压力。另外，它可能会显示涉及I/O或其他与低性能设备的交互，并且在代码中无法做任何改进。
- en: Defining the goal of the application and JVM tuning requires establishing metrics.
    For example, it is well known already that the traditional measure of latency
    as the average response time hides more than it reveals about the performance.
    The better latency metrics would be the maximum response time in conjunction with
    99% best response time. For throughput, a good metrics would be the number of
    transactions per a unit of time. Often the inverse of this metrics (time per transaction)
    closely reflects latency. For the memory footprint, the maximum allocated memory
    (under the load) allows for the hardware planning and setting guards against the
    dreaded `OutOfMemoryError` exception. Avoiding full (stop-the-world) garbage collection
    cycle would be ideal. In practice, though, it would be good enough if **Full GC**
    happens not often, does not visibly affect the performance and ends up with approximately
    the same heap size after several cycles.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 定义应用程序和JVM调优的目标需要建立指标。例如，已经众所周知，将延迟作为平均响应时间的传统度量隐藏了更多关于性能的信息。更好的延迟指标将是最大响应时间与99%最佳响应时间的结合。对于吞吐量，一个好的指标将是单位时间内的交易数量。通常，这些指标的倒数（每个交易的时间）会反映延迟。对于内存占用，最大分配的内存（在负载下）允许进行硬件规划，并设置防范可怕的`OutOfMemoryError`异常。避免完整（停止一切）的垃圾收集循环将是理想的。然而，在实践中，如果**Full
    GC**不经常发生，不明显影响性能，并且在几个周期后最终堆大小大致相同，那就足够了。
- en: 'Unfortunately, such simplicity of the requirements does happen in practice.
    Real life brings more questions all the time as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种简单的需求在实践中确实会发生。现实生活中不断出现更多的问题，如下：
- en: Can the target latency (response time) be ever exceeded?
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标延迟（响应时间）是否会被超过？
- en: If yes, how often and by how much?
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是，频率是多少，幅度是多少？
- en: How long can the period of the poor response time last?
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应时间不佳的时间段可以持续多久？
- en: Who/what measures the latency in production?
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁/什么在生产中测量延迟？
- en: Is the target performance the peak performance?
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标性能是峰值性能吗？
- en: What is the expected peak load?
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期的峰值负载是多少？
- en: How long is the expected peak load going to last?
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期的峰值负载将持续多久？
- en: Only after all these and similar questions are answered and the metrics (that
    reflect the nonfunctional requirements) are established, we can start tweaking
    the code, running it and profiling again and again, then tweaking the code and
    repeating the cycle. This activity has to consume most of the efforts because
    tuning of the JVM itself can bring only the fraction of the performance improvements
    by comparison with the performance gained by the code changes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在回答了所有这些类似的问题并建立了反映非功能性需求的指标之后，我们才能开始调整代码，运行它并一遍又一遍地进行分析，然后调整代码并重复这个循环。这项活动必须占用大部分的努力，因为与通过代码更改获得的性能改进相比，调整JVM本身只能带来一小部分性能改进。
- en: Nevertheless, several passes of the JVM tuning must happen early in order to
    avoid wasting of the efforts and trying to force the code in the not well-configured
    environment. The JVM configuration has to be as generous as possible for the code
    to take advantage of all the available resources.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JVM调优的几次尝试必须在早期进行，以避免浪费努力并试图将代码强行放入配置不良的环境中。JVM配置必须尽可能慷慨，以便代码能够充分利用所有可用资源。
- en: 'First of all, select garbage collector from the four that JVM 9 supports, which
    are as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从JVM 9支持的四种垃圾收集器中选择一个，它们分别是：
- en: '**Serial collector**: This uses a single thread to perform all the garbage
    collection work'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行收集器**：这使用单个线程执行所有垃圾收集工作。'
- en: '**Parallel collector**: This uses multiple threads to speed up garbage collection'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行收集器**：这使用多个线程加速垃圾收集。'
- en: '**Concurrent Mark Sweep (CMS) collector**: This uses shorter garbage collection
    pauses at the expense of taking more of the processor time'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发标记清除（CMS）收集器**：这使用更短的垃圾收集暂停来换取更多的处理器时间。'
- en: '**Garbage-First (G1) collector**: This is intended for multiprocessor machines
    with a large memory, but meets garbage collection pause-time goals with high probability,
    while achieving high throughput.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾优先（G1）收集器**：这是为多处理器机器和大内存设计的，但在高概率下达到垃圾收集暂停时间目标，同时实现高吞吐量。'
- en: 'The official Oracle documentation ([https://docs.oracle.com/javase/9/gctuning/available-collectors.htm](https://docs.oracle.com/javase/9/gctuning/available-collectors.htm))
    provides the following initial guidelines for the garbage collection selection:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的Oracle文档（[https://docs.oracle.com/javase/9/gctuning/available-collectors.htm](https://docs.oracle.com/javase/9/gctuning/available-collectors.htm)）提供了垃圾收集选择的初始指南：
- en: If the application has a small dataset (up to approximately 100 MB), then select
    the serial collector with the `-XX:+UseSerialGC` option
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序的数据集很小（大约100MB以下），则选择带有`-XX:+UseSerialGC`选项的串行收集器。
- en: If the application will be run on a single processor and there are no pause-time
    requirements, then select the serial collector with the `-XX:+UseSerialGC` option
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果应用程序将在单个处理器上运行，并且没有暂停时间要求，则选择带有`-XX:+UseSerialGC`选项的串行收集器。
- en: If (a) peak application performance is the first priority and (b) there are
    no pause-time requirements or pauses of one second or longer are acceptable, then
    let the VM select the collector or select the parallel collector with `-XX:+UseParallelGC`
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果（a）峰值应用程序性能是第一优先级，（b）没有暂停时间要求或者接受一秒或更长时间的暂停，那么让虚拟机选择收集器或者选择并行收集器与`-XX:+UseParallelGC`
- en: If the response time is more important than the overall throughput and garbage
    collection pauses must be kept shorter than approximately one second, then select
    a concurrent collector with `-XX:+UseG1GC or -XX:+UseConcMarkSweepGC`
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果响应时间比整体吞吐量更重要，并且垃圾收集暂停必须保持在大约一秒以下，则选择带有`-XX:+UseG1GC`或`-XX:+UseConcMarkSweepGC`的并发收集器。
- en: But if you do not have particular preferences yet, let the JVM select garbage
    collector until you learn more about your application's needs. In JDK 9, the G1
    is selected by default on certain platforms, and it is a good start if the hardware
    you use has enough resources.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您还没有特定的偏好，让JVM选择垃圾收集器，直到您更多地了解您的应用程序的需求。在JDK 9中，G1在某些平台上是默认选择的，如果您使用的硬件资源足够，这是一个很好的开始。
- en: Oracle also recommends using G1 with its default settings, then later playing
    with a different pause-time goal using the `-XX:MaxGCPauseMillis` option and maximum
    Java heap size using the `-Xmx` option. Increasing either the pause-time goal
    or the heap size typically leads to a higher throughput. The latency is affected
    by the change of the pause-time goal too.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle还建议使用G1的默认设置，然后使用`-XX:MaxGCPauseMillis`选项和`-Xmx`选项来尝试不同的暂停时间目标和最大Java堆大小。增加暂停时间目标或堆大小通常会导致更高的吞吐量。延迟也受暂停时间目标的改变影响。
- en: 'While tuning the GC, it is beneficial to keep the `-Xlog:gc*=debug` logging
    option. It provides many useful details about garbage collection activity. The
    first goal of JVM tuning is to decrease the number of full heap GC cycles (Full
    GC) because they are very resource consuming and thus may slow down the application.
    It is caused by too high occupancy of the old generation area. In the log, it
    is identified by the words `Pause Full (Allocation Failure)`. The following are
    the possible steps to reduce chances of Full GC:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整GC时，保持`-Xlog:gc*=debug`日志选项是有益的。它提供了许多有关垃圾收集活动的有用细节。JVM调优的第一个目标是减少完整堆GC周期（Full
    GC）的数量，因为它们非常消耗资源，因此可能会减慢应用程序的速度。这是由老年代区域的占用率过高引起的。在日志中，它被识别为`Pause Full (Allocation
    Failure)`。以下是减少Full GC机会的可能步骤：
- en: Bring up the size of the heap using `-Xmx`. But make sure it does not exceed
    the physical size of RAM. Better yet, leave some RAM space for other applications.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-Xmx`增加堆的大小。但要确保它不超过物理内存的大小。最好留一些RAM空间给其他应用程序。
- en: Increase the number of concurrent marking threads explicitly using `-XX:ConcGCThreads`.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式增加并发标记线程的数量，使用`-XX:ConcGCThreads`。
- en: 'If the humongous objects take too much of the heap (watch for **gc+heap=info**
    logging that shows the number next to humongous regions) try to increase the region
    size using `-XX: G1HeapRegionSize`.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果庞大的对象占用了太多堆空间（观察显示在**gc+heap=info**日志中的巨大区域旁边的数字），尝试使用`-XX:G1HeapRegionSize`来增加区域大小。
- en: Watch the GC log and modify the code so that almost all the objects created
    by your application are not moved beyond the young generation (dying young).
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察GC日志，并修改代码，以便您的应用程序创建的几乎所有对象都不会超出年轻代（早夭）。
- en: Add or change one option at a time, so you can understand the causes of the
    change in the JVM's behavior clearly.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次添加或更改一个选项，这样您就可以清楚地了解JVM行为变化的原因。
- en: These few steps will help you go and create a trial-and-error cycle that will
    bring you a better understanding of the platform you are using, the needs of your
    application, and the sensitivity of the JVM and the selected GC to different options.
    Equipped with this knowledge, you will then be able to meet the nonfunctional
    performance requirements whether by changing the code, tuning the JVM, or reconfiguring
    the hardware.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将帮助您创建一个试错循环，让您更好地了解您正在使用的平台，应用程序的需求，以及JVM和所选GC对不同选项的敏感性。掌握了这些知识，您将能够通过更改代码、调整JVM或重新配置硬件来满足非功能性能要求。
- en: Reactive Programming
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: After several false starts and a few disastrous disruptions, followed by heroic
    recoveries, the process of pyramid building took shape and ancient builders were
    able to complete a few projects. The final shape sometimes did not look exactly
    as envisioned (the first pyramids have ended up bent), but, nevertheless, the
    pyramids still decorate the desert today. The experience was passed from generation
    to generation, and the design and the process were tuned well enough to produce
    something magnificent and pleasant to look at more than 4,000 years later.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几次失败的尝试和一些灾难性的中断，然后是英勇的恢复，金字塔建造的过程形成了，古代建筑师们能够完成一些项目。最终的形状有时并不完全如预期（第一座金字塔最终弯曲了），但是，金字塔至今仍然装饰着沙漠。经验代代相传，设计和工艺经过调整，能够在4000多年后产生一些宏伟而令人愉悦的东西。
- en: The software practices also change over time, albeit we have had only some 70
    years since Mr. Turing wrote the first modern program. In the beginning, when
    there were only a handful of programmers in the world, a computer program used
    to be a continuous list of instructions. Functional programming (pushing a function
    around like a first-class citizen) was introduced very early too but has not become
    a mainstream. Instead, the **GOTO** instruction allowed you to roll code in a
    spaghetti bowl. Structural programming followed, then object-oriented programming,
    with functional programming moving along and even thriving in certain areas. Asynchronous
    processing of the events generated by the pressed keys became routine for many
    programmers. JavaScript tried to use all of the best practices and gained a lot
    of power, even if at the expense of programmers' frustration during the debugging
    (fun) phase. Finally, with thread pools and lambda expressions being part of JDK
    SE, adding reactive streams API to JDK 9 made Java part of the family that allows
    reactive programming with asynchronous data streams.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 软件实践也随着时间而改变，尽管图灵先生编写了第一个现代程序只有大约70年。起初，当世界上只有少数程序员时，计算机程序通常是一连串的指令。函数式编程（像第一类公民一样推动函数）也很早就被引入，但并没有成为主流。相反，**GOTO**指令允许您将代码卷入意大利面条般的混乱中。接着是结构化编程，然后是面向对象编程，函数式编程也在某些领域蓬勃发展。许多程序员已经习惯了异步处理按键生成的事件。JavaScript试图使用所有最佳实践，并获得了很大的力量，尽管在调试（有趣）阶段程序员会感到沮丧。最后，随着线程池和lambda表达式成为JDK
    SE的一部分，将响应式流API添加到JDK 9中，使Java成为允许使用异步数据流进行响应式编程的家庭的一部分。
- en: 'To be fair, we were able to process data asynchronously even without this new
    API--by spinning worker threads and using thread pools and callables (as we described
    in the previous sections) or by passing the callbacks (even if lost once in a
    while in the maze of the one who-calls-whom). But, after writing such a code a
    few times, one notices that most of such code is just a plumbing that can be wrapped
    inside a framework that can significantly simplify asynchronous processing. That''s
    how the Reactive Streams initiative ([http://www.reactive-streams.org](http://www.reactive-streams.org))
    came to be created and the scope of the effort is defined as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，即使没有这个新的API，我们也能够异步处理数据--通过旋转工作线程和使用线程池和可调用对象（正如我们在前面的部分中所描述的）或通过传递回调（即使偶尔在谁调用谁的迷宫中迷失）。但是，在几次编写这样的代码之后，人们会注意到大多数这样的代码只是一个可以包装在框架中的管道，可以显著简化异步处理。这就是响应式流倡议（[http://www.reactive-streams.org](http://www.reactive-streams.org)）的创建背景和努力的范围定义如下：
- en: The scope of Reactive Streams is to find a minimal set of interfaces, methods
    and protocols that will describe the necessary operations and entities to achieve
    the goal--asynchronous streams of data with non-blocking back pressure.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式流的范围是找到一组最小的接口、方法和协议，描述必要的操作和实体以实现异步数据流和非阻塞背压。
- en: The term **non-blocking back pressure** is an important one because it identifies
    one of the problems of the existed asynchronous processing--coordination of the
    speed rate of the incoming data with the ability of the system to process them
    without the need of stopping (blocking) the data input. The solution would still
    include some back pressure by informing the source that the consumer has difficulty
    in keeping up with the input, but the new framework should react to the change
    of the rate of the incoming data in a more flexible manner than just blocking
    the flow, thus the name **reactive**.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**非阻塞背压**是重要的，因为它确定了现有异步处理的问题之一--协调传入数据的速率与系统处理这些数据的能力，而无需停止（阻塞）数据输入。解决方案仍然会包括一些背压，通过通知源消费者在跟不上输入时存在困难，但新框架应该以更灵活的方式对传入数据的速率变化做出反应，而不仅仅是阻止流动，因此称为**响应式**。
- en: 'The Reactive Streams API consists of the five interfaces included in the class
    which are `java.util.concurrent.Flow`, `Publisher`, `Subscriber`, `Subscription`,
    and `Processor`:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式流API由包含在类中的五个接口组成，它们是`java.util.concurrent.Flow`、`Publisher`、`Subscriber`、`Subscription`和`Processor`：
- en: '[PRE53]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: A `Flow.Subscriber` object becomes a subscriber of the data produced by the
    object of `Flow.Publisher` after the object of `Flow.Subscriber` is passed as
    a parameter into the `subscribe()` method. The publisher (object of `Flow.Publisher`)
    calls the subscriber's `onSubscribe()` method and passes as a parameter a `Flow.Subsctiption`
    object. Now, the subscriber can request `numberOffItems` of data from the publisher
    by calling the subscription's `request()` method. That is the way to implement
    the pull model when a subscriber decides when to request another item for processing.
    The subscriber can unsubscribe from the publisher services by calling the `cancel()`
    subscription method.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Flow.Publisher`对象的`subscribe()`方法中将`Flow.Subscriber`对象作为参数传递后，`Flow.Subscriber`对象成为`Flow.Publisher`对象产生的数据的订阅者。发布者（`Flow.Publisher`对象）调用订阅者的`onSubscribe()`方法，并将`Flow.Subscription`对象作为参数传递。现在，订阅者可以通过调用订阅的`request()`方法从发布者那里请求`numberOffItems`个数据。这是实现拉模型的方式，订阅者决定何时请求另一个项目进行处理。订阅者可以通过调用`cancel()`订阅方法取消订阅发布者的服务。
- en: In return (or without any request, if the implementer has decided to do so,
    that would be a push model), the publisher can pass to the subscriber a new item
    by calling the subscriber's `onNext()` method. The publisher can also tell the
    subscriber that the item production has encountered a problem (by calling the
    subscriber's `onError()` method) or that no more data will be coming (by calling
    the subscriber's `onComplete()` method).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回报（或者如果实现者决定这样做，那将是一种推送模型），发布者可以通过调用订阅者的`onNext()`方法向订阅者传递一个新项目。发布者还可以告诉订阅者，项目生产遇到了问题（通过调用订阅者的`onError()`方法）或者不会再有数据传入（通过调用订阅者的`onComplete()`方法）。
- en: The `Flow.Processor` interface describes an entity that can act as both a subscriber
    and a publisher. It allows creating chains (pipelines) of such processors, so
    a subscriber can receive an item from a publisher, tweak it, and then pass the
    result to the next subscriber.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flow.Processor`接口描述了一个既可以充当订阅者又可以充当发布者的实体。它允许创建这些处理器的链（管道），因此订阅者可以从发布者那里接收一个项目，对其进行调整，然后将结果传递给下一个订阅者。'
- en: This is the minimal set of interfaces the Reactive Streams initiative has defined
    (and it is a part of JDK 9 now) in support of the asynchronous data streams with
    non-blocking back pressure. As you can see, it allows the subscriber and publisher
    to talk to each other and coordinate, if need be, the rate of incoming data, thus
    making possible a variety of solutions for the back pressure problem we discussed
    in the beginning.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Reactive Streams倡议定义的最小接口集（现在是JDK 9的一部分），支持非阻塞背压的异步数据流。正如您所看到的，它允许订阅者和发布者相互交流和协调，如果需要的话，协调传入数据的速率，从而使我们在开始讨论时所讨论的背压问题有可能有各种解决方案。
- en: 'There are many ways to implement these interfaces. Currently, in JDK 9, there
    is only one example of implementation of one of the interfaces--the `SubmissionPublisher`
    class implements `Flow.Publisher`. But several other libraries already exist that
    implemented Reactive Streams API: RxJava, Reactor, Akka Streams, and Vert.x are
    among the most known. We will use RxJava 2.1.3 in our examples. You can find the
    RxJava 2.x API on [http://reactivex.io](http://reactivex.io) under the name ReactiveX,
    which stands for Reactive Extension.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多实现这些接口的方法。目前，在JDK 9中，只有一个接口实现的例子——`SubmissionPublisher`类实现了`Flow.Publisher`。但已经存在几个其他库实现了Reactive
    Streams API：RxJava、Reactor、Akka Streams和Vert.x是其中最知名的。我们将在我们的示例中使用RxJava 2.1.3。您可以在[http://reactivex.io](http://reactivex.io)上找到RxJava
    2.x API，名称为ReactiveX，代表Reactive Extension。
- en: While doing that, we would also like to address the difference between the streams
    of the `java.util.stream` package and Reactive Streams (as implemented in RxJava,
    for example). It is possible to write very similar code using any of the streams.
    Let's look at an example. Here is a program that iterates over five integers,
    selects even numbers only (2 and 4), transforms each of them (takes a square root
    of each of the selected numbers) and then calculates an average of the two square
    roots. It is based on the traditional `for` loop.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做的同时，我们也想解释一下`java.util.stream`包和响应式流（例如RxJava中实现的）之间的区别。可以使用任何一种流编写非常相似的代码。让我们看一个例子。这是一个程序，它遍历五个整数，只选择偶数（2和4），对每个偶数进行转换（对每个选定的数字取平方根），然后计算两个平方根的平均值。它基于传统的`for`循环。
- en: 'Let''s start with the similarity. It is possible to implement the same functionality
    using any of the streams. For example, here is a method that iterates over five
    integers, selects even numbers only (2 and 4, in this case), transforms each of
    them (takes a square root of each of the even numbers) and then calculates an
    average of the two square roots. It is based on the traditional `for` loop:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从相似性开始。可以使用任何一种流来实现相同的功能。例如，这是一个方法，它遍历五个整数，只选择偶数（在这种情况下是2和4），对每个偶数进行转换（对每个偶数取平方根），然后计算两个平方根的平均值。它基于传统的`for`循环：
- en: '[PRE54]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we run this program, the result will be as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，结果将如下所示：
- en: '![Reactive Programming](img/03_30.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![响应式编程](img/03_30.jpg)'
- en: 'The same functionality (with the same output) can be implemented using the
    package `java.util.stream` as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的功能（具有相同的输出）也可以使用`java.util.stream`包来实现，如下所示：
- en: '[PRE55]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The same functionality can be implemented with RxJava:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的功能也可以使用RxJava实现：
- en: '[PRE56]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: RxJava is based on the `Observable` object (which plays the role of `Publisher`)
    and `Observer` that subscribes to the `Observable` and waits for data to be emitted.
    Each item of the emitted data (on the way from the `Observable` to the `Observer`)
    can be processed by the operations chained in a fluent style (see the previous
    code). Each operation takes a lambda expression. The operation functionality is
    obvious from its name.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava基于`Observable`对象（扮演`Publisher`的角色）和订阅`Observable`并等待数据被发射的`Observer`。从`Observable`到`Observer`的每个发射数据项都可以通过以流畅的方式链接的操作进行处理（参见之前的代码）。每个操作都采用lambda表达式。操作功能从其名称中很明显。
- en: 'Despite being able to behave similarly to the streams, an `Observable` has
    significantly different capabilities. For example, a stream, once closed, cannot
    be reopened, while an `Observable` can be reused. Here is an example:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管能够表现得与流类似，但`Observable`具有显着不同的功能。例如，流一旦关闭，就无法重新打开，而`Observable`可以被重复使用。这是一个例子：
- en: '[PRE57]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the previous code, we use `Observable` twice--for average value calculation
    and for the summing all the square roots of the even numbers. The output is as
    shown in the following screenshot:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们两次使用了`Observable`——一次用于计算平均值，一次用于对偶数的平方根求和。输出如下截图所示：
- en: '![Reactive Programming](img/03_31.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![响应式编程](img/03_31.jpg)'
- en: 'If we do not want `Observable` to run twice, we can cache its data, by adding
    the `.cache()` operation:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望`Observable`运行两次，可以通过添加`.cache()`操作来缓存其数据：
- en: '[PRE58]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The result of the previous code is as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的结果如下：
- en: '![Reactive Programming](img/03_32.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![响应式编程](img/03_32.jpg)'
- en: You can see that the second usage of the same `Observable` took advantage of
    the cached data, thus allowing for better performance.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到同一个`Observable`的第二次使用利用了缓存的数据，从而实现了更好的性能。
- en: 'Another `Observable` advantage is that the exception can be caught by `Observer`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`Observable`的优势是异常可以被`Observer`捕获：
- en: '[PRE59]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `subscribe()` method is overloaded and allows to pass in one, two, or three
    functions:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe()`方法是重载的，允许传入一个、两个或三个函数：'
- en: The first is to be used in case of success
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个用于成功的情况
- en: The second is to be used in case of an exception
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个用于异常情况
- en: The third is to be called after all the data is processed
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个在所有数据处理完毕后调用
- en: 'The `Observable` model also allows more control over multithreaded processing.
    Using `.parallel()` in the streams does not allow you to specify the thread pool
    to be used. But, in RxJava, you can set the type of pool you prefer using the
    method `subscribeOn()` in `Observable`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable`模型还允许更多控制多线程处理。在流中使用`.parallel()`不允许您指定要使用的线程池。但是，在RxJava中，您可以使用`Observable`中的`subscribeOn()`方法设置您喜欢的池类型：'
- en: '[PRE60]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `subscribeOn()` method tells `Observable` on which thread to put the data.
    The `Schedulers` class has methods that generate thread pools dealing mostly with
    I/O operations (as in our example), or heavy on computation (method `computation()`),
    or creating a new thread for each unit of work (method `newThread()`), and several
    others, including passing in a custom thread pool (method `from(Executor executor)`).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeOn()`方法告诉`Observable`在哪个线程上放置数据。`Schedulers`类有生成线程池的方法，主要处理I/O操作（如我们的示例中），或者处理计算密集型操作（`computation()`方法），或者为每个工作单元创建一个新线程（`newThread()`方法），以及其他几种方法，包括传入自定义线程池（`from(Executor
    executor)`方法）。'
- en: 'The format of this book does not allow us to describe all the richness of RxJava
    API and other Reactive Streams implementations. Their main thrust is reflected
    in Reactive Manifesto ([http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/))
    that describes Reactive Systems as a new generation of high performing software
    solutions. Built on asynchronous message-driven processes and Reactive Streams,
    such systems are able to demonstrate the qualities declared in the Reactive Manifesto:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的格式不允许我们描述RxJava API和其他响应式流实现的所有丰富性。它们的主要目的反映在响应式宣言（[http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/)）中，该宣言将响应式系统描述为新一代高性能软件解决方案。建立在异步消息驱动进程和响应式流上，这些系统能够展示响应式宣言中声明的特性：
- en: '**Elasticity**: This has the ability to expand and contract as needed based
    on the load'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：具有根据负载需要扩展和收缩的能力'
- en: '**Better responsiveness**: Here, the processing can be parallelized using asynchronous
    calls'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的响应性**：在这里，处理可以使用异步调用进行并行化'
- en: '**Resilience**: Here, the system is broken into multiple (loosely coupled via
    messages) components, thus facilitating flexible replication, containment, and
    isolation'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：在这里，系统被分解为多个（通过消息松耦合）组件，从而促进灵活的复制、封装和隔离'
- en: Writing code for Reactive Systems using Reactive Streams for implementing the
    previously mentioned qualities constitutes reactive programming. The typical application
    of such systems today is microservices, which is described in the next lesson.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用响应式流来编写响应式系统的代码，以实现先前提到的特性，构成了响应式编程。这种系统今天的典型应用是微服务，下一课将对此进行描述。
- en: Summary
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, we have discussed the ways to improve Java application performance
    by using multithreading. We described how to decrease an overhead of creating
    the threads using thread pools and various types of such pools suited for different
    processing requirements. We also brought up the considerations used for selecting
    the pool size and how to synchronize threads so that they do not interfere with
    each other and yield the best performance results. We pointed out that every decision
    on the performance improvements has to be made and tested through direct monitoring
    of the application, and we discussed the possible options for such monitoring
    programmatically and using various external tools. The final step, the JVM tuning,
    can be done via Java tool flags that we listed and commented in the corresponding
    section. Yet more gains in Java application performance might be achieved by adopting
    the concept of reactive programming, which we presented as the strong contender
    among most effective moves toward highly scalable and highly performing Java applications.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们讨论了通过使用多线程来改善Java应用程序性能的方法。我们描述了如何通过使用线程池和适用于不同处理需求的各种类型的线程池来减少创建线程的开销。我们还提出了用于选择池大小的考虑因素，以及如何同步线程，使它们不会相互干扰，并产生最佳性能结果。我们指出，对性能改进的每个决定都必须通过直接监视应用程序进行制定和测试，并讨论了通过编程和使用各种外部工具进行此类监视的可能选项。最后一步，JVM调优，可以通过我们在相应部分列出并评论的Java工具标志来完成。采用响应式编程的概念可能会使Java应用程序的性能获得更多收益，我们将其作为朝着高度可伸缩和高性能Java应用程序的最有效举措之一。
- en: In the next lesson, we will talk about adding more workers by splitting the
    application into several microservices, each deployed independently and each using
    multiple threads and reactive programming for better performance, response, scalability,
    and fault-tolerance.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，我们将讨论通过将应用程序拆分为多个微服务来添加更多的工作线程，每个微服务都独立部署，并且每个微服务都使用多个线程和响应式编程以获得更好的性能、响应、可伸缩性和容错性。
- en: Assessments
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Name the method that calculates the average square root of the first 99,999
    integers and assigns the result to a property that can be accessed anytime.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名一个方法，计算前99,999个整数的平均平方根，并将结果分配给可以随时访问的属性。
- en: 'Which of the following methods creates a thread pool of a fixed size that can
    schedule commands to run after a given delay, or to execute periodically:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种方法创建了一个固定大小的线程池，可以在给定延迟后安排命令运行，或定期执行：
- en: '`newscheduledThreadPool()`'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的调度线程池()
- en: '`newWorkStealingThreadPool()`'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的工作窃取线程池()
- en: '`newSingleThreadScheduledExecutor()`'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的单线程调度执行器()
- en: '`newFixedThreadPool()`'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的固定线程池()
- en: 'State whether True or False: One can take advantage of the `Runnable` interface
    being a functional interface and pass the necessary processing function into a
    new thread as a lambda expression.'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 陈述是否正确：可以利用`Runnable`接口是一个函数式接口，并将必要的处理函数作为lambda表达式传递到新线程中。
- en: After the `__________` method is called, no more worker threads can be added
    to the pool.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用`__________`方法之后，不能再向池中添加更多的工作线程。
- en: '`shutdownNow()`'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: shutdownNow()
- en: '`shutdown()`'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: shutdown()
- en: '`isShutdown()`'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: isShutdown()
- en: '`isShutdownComplete()`'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: isShutdownComplete()
- en: ________ is based on the `Observable` object, which plays the role of a Publisher.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ________基于`Observable`对象，它扮演着发布者的角色。
