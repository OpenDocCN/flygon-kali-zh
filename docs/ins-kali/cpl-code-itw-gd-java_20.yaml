- en: '*Chapter 16*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第16章*：'
- en: Concurrency
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: Developing single-threaded Java applications is rarely feasible. Therefore,
    most of your projects will be multithreaded (that is, they will run in a multithreaded
    environment). This means that, sooner or later, you'll have to tackle certain
    multithreading problems. In other words, at some point, you'll have to get your
    hands dirty with code that manipulates Java threads directly or via dedicated
    APIs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 开发单线程的Java应用程序很少可行。因此，大多数项目将是多线程的（即它们将在多线程环境中运行）。这意味着，迟早，您将不得不解决某些多线程问题。换句话说，您将不得不动手编写直接或通过专用API操纵Java线程的代码。
- en: 'This chapter covers the most popular questions about Java concurrency (multithreading)
    that occur in general interviews about the Java language. As usual, we will start
    with a brief introduction that covers the main aspects of Java concurrency. Therefore,
    our agenda is straightforward, covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了关于Java并发（多线程）的最常见问题，这些问题在关于Java语言的一般面试中经常出现。和往常一样，我们将从简要介绍开始，介绍Java并发的主要方面。因此，我们的议程很简单，涵盖以下主题：
- en: Java concurrency (multithreading) in a nutshell
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java并发（多线程）简介
- en: Questions and coding challenges
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题和编码挑战
- en: Let's begin with the fundamental knowledge of our topic, Java concurrency. Use
    the following nutshell section to extract answers to some basic questions about
    concurrency, such as *What is concurrency?*, *What is a Java thread?, What is
    multithreading?*, and more.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从我们的主题Java并发的基本知识开始。使用以下简介部分提取一些关于并发的基本问题的答案，比如*什么是并发？*，*什么是Java线程？*，*什么是多线程？*等。
- en: Technical Requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The codes used in this chapter can be found on GitHub on: [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter16](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter16)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在GitHub上找到：[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter16](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter16)
- en: Java concurrency (multithreading) in a nutshell
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java并发（多线程）简介
- en: Our computers can run multiple *programs* or *applications* at the same time
    (for example, we can listen to music on a media player and navigate the internet
    at the same time). A *process* is an executing instance of a program or application
    (for example, by double-clicking on the NetBeans icon on your computer, you start
    a process that will run the NetBeans program). Additionally, a *thread* is a *lightweight
    subprocess* that represents the smallest executable unit of work of a process.
    A Java thread has relatively low overhead, and it shares common memory space with
    other threads. A process can have multiple threads with one *main thread*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算机可以同时运行多个*程序*或*应用程序*（例如，我们可以同时在媒体播放器上听音乐并浏览互联网）。*进程*是程序或应用程序的执行实例（例如，通过在计算机上双击NetBeans图标，您启动将运行NetBeans程序的进程）。此外，*线程*是*轻量级子进程*，表示进程的最小可执行工作单元。Java线程的开销相对较低，并且它与其他线程共享公共内存空间。一个进程可以有多个线程，其中一个是*主线程*。
- en: Important note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The main difference between processes and threads is the fact that threads share
    common memory space while processes don't. By sharing memory, threads shave off
    lots of overhead.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 进程和线程之间的主要区别在于线程共享公共内存空间，而进程不共享。通过共享内存，线程减少了大量开销。
- en: '*Concurrency* is the ability of an application to handle the multiple tasks
    it works on. The program or application can process one task at a time (*sequential
    processing*) or process multiple tasks at the same time (*concurrent processing*).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发*是应用程序处理其工作的多个任务的能力。程序或应用程序可以一次处理一个任务（*顺序处理*）或同时处理多个任务（*并发处理*）。'
- en: Do not confuse concurrency with *parallelism*. *Parallelism* is the ability
    of an application to handle each individual task. The application can process
    each task serially, or it can split the task up into subtasks that can be processed
    in parallel.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将并发与*并行*混淆。*并行*是应用程序处理每个单独任务的能力。应用程序可以串行处理每个任务，也可以将任务分割成可以并行处理的子任务。
- en: Important note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Concurrency is about **handling** (not doing) lots of things at once, while
    parallelism is about **doing** lots of things at once.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是关于**处理**（而不是执行）多个事情，而并行是关于**执行**多个事情。
- en: Concurrency is achieved via *multithreading*. *Multithreading* is a technique
    that enables a program or application to handle more than one task at a time and
    to also synchronize those tasks. This means that multithreading allows the maximum
    utilization of a CPU by executing two or more tasks virtually at the same time.
    We say *virtually at the same time* here because the tasks only look like they
    are running simultaneously; however, essentially, they cannot do that. They take
    advantage of CPU *context switching* or the *time slicing* feature of the operating
    system. In other words, CPU time is shared across all running tasks, and each
    task is scheduled to run for a certain period of time. Hence, multithreading is
    the key to *multitasking*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过*多线程*实现并发。*多线程*是一种技术，使程序或应用程序能够同时处理多个任务，并同步这些任务。这意味着多线程允许通过在同一时间执行两个或更多任务来最大程度地利用CPU。我们在这里说*在同一时间*是因为这些任务看起来像是同时运行；然而，实质上，它们不能这样做。它们利用操作系统的CPU
    *上下文切换*或*时间片*功能。换句话说，CPU时间被所有运行的任务共享，并且每个任务被安排在一定时间内运行。因此，多线程是*多任务处理*的关键。
- en: Important note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: With a single-core CPU, we may achieve concurrency but *not* parallelism.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在单核CPU上，我们可以实现并发但*不是*并行。
- en: In conclusion, threads can create the illusion of multitasking; however, at
    any given point in time, the CPU is executing only one thread. The CPU switches
    control between the threads so quickly that it creates the illusion that the tasks
    are executed (or advance) in parallel. Actually, they are executed concurrently.
    Nevertheless, with advances in hardware technology, it is now common to have multi-core
    machines and computers. This means that applications can take advantage of these
    architectures and have a dedicated CPU running each thread.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，线程可以产生多任务的错觉；然而，在任何给定的时间点，CPU只执行一个线程。CPU在线程之间快速切换控制，从而产生任务并行执行（或推进）的错觉。实际上，它们是并发执行的。然而，随着硬件技术的进步，现在普遍拥有多核机器和计算机。这意味着应用程序可以利用这些架构，并且每个线程都有一个专用的CPU在运行。
- en: 'The following diagram clarifies the confusion between concurrency and parallelism
    via four threads (**T1**, **T2**, **T3**, and **T4**):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表通过四个线程（**T1**、**T2**、**T3**和**T4**）澄清了并发和并行之间的混淆：
- en: '![16.1 – Concurrency versus parallelism'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 16.1-并发与并行
- en: '](img/Figure_16.1_B15403.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.1_B15403.jpg)'
- en: 16.1 – Concurrency versus parallelism
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 16.1-并发与并行
- en: 'So, an application can be one of the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个应用程序可以是以下之一：
- en: '**Concurrent but not parallel**: It executes more than one task at the same
    time, but no two tasks are executed at the same time.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发但不是并行：它同时执行多个任务，但没有两个任务同时执行。
- en: '**Parallel but not concurrent**: It executes multiple subtasks of a task in
    a multi-core CPU at the same time.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行但不是并发：它在多核CPU中同时执行一个任务的多个子任务。
- en: '**Neither parallel nor concurrent**: It executes all of the tasks one at a
    time (sequential execution).'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 既不是并行也不是并发：它一次执行所有任务（顺序执行）。
- en: '**Both parallel and concurrent**: It executes multiple tasks concurrently in
    a multi-core CPU at the same time.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行和并发：它在多核CPU中同时并发执行多个任务。
- en: A set of homogenous worker threads that are assigned to execute tasks is called
    a *thread pool*. A worker thread that finishes a task is returned to the pool.
    Typically, thread pools are bound to a queue of tasks and can be tuned to the
    size of the threads they hold. Commonly, for optimal performance, the size of
    a thread pool is equal to the number of CPU cores.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 被分配执行任务的一组同质工作线程称为*线程池*。完成任务的工作线程将返回到池中。通常，线程池绑定到任务队列，并且可以调整到它们持有的线程的大小。通常情况下，为了获得最佳性能，线程池的大小应等于CPU核心的数量。
- en: The *synchronization* of a multithreaded environment is achieved via *locking*.
    Locking is used to orchestrate and limit access to a resource in a multithreaded
    environment.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中*同步*是通过*锁定*实现的。锁定用于在多线程环境中协调和限制对资源的访问。
- en: If multiple threads can access the same resource without causing errors or unpredictable
    behaviors/results, then we are in a *thread-safe context*. *Thread safety* can
    be achieved via various synchronization techniques (for example, the Java `synchronized`
    keyword).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个线程可以访问相同的资源而不会导致错误或不可预测的行为/结果，那么我们处于*线程安全的上下文*。可以通过各种同步技术（例如Java `synchronized`关键字）实现*线程安全*。
- en: Next, let's tackle several questions and coding challenges regarding concurrency
    in Java.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们解决一些关于Java并发的问题和编码挑战。
- en: Questions and coding challenges
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和编码挑战
- en: In this section, we will cover 20 concurrency questions and coding challenges
    that are very popular in interviews.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖20个关于并发的问题和编码挑战，这在面试中非常流行。
- en: You should be aware that Java concurrency is a wide and complex topic that needs
    to be covered in great detail by any Java developer. Having fundamental insights
    about Java concurrency should be enough to pass a general Java language interview,
    but it is not enough for specific interviews (for example, if you apply for a
    job that will imply developing a concurrency API, then you must deep dive into
    this topic and learn advanced concepts – most probably, the interview will be
    concurrency-centric).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，Java并发是一个广泛而复杂的主题，任何Java开发人员都需要详细了解。对Java并发的基本见解应该足以通过一般的Java语言面试，但对于特定的面试来说还不够（例如，如果您申请一个将涉及开发并发API的工作，那么您必须深入研究这个主题并学习高级概念-很可能，面试将以并发为中心）。
- en: Coding challenge 1 – Thread life cycle states
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战1-线程生命周期状态
- en: '`Thread`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`线程`。'
- en: '`Thread.State` enumeration. The possible states of a Java thread can be seen
    in the following diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.State`枚举。Java线程的可能状态可以在以下图表中看到：'
- en: '![16.2 – Java thread states'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![16.2-Java线程状态'
- en: '](img/Figure_16.2_B15403.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.2_B15403.jpg)'
- en: 16.2 – Java thread states
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 16.2-Java线程状态
- en: 'The different lifecycle states of a Java `Thread` are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Java `Thread`的不同生命周期状态如下：
- en: '`NEW` `Thread#start()` method is invoked).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NEW` `Thread#start()`方法被调用）。'
- en: '`RUNNABLE` `Thread#start()` method, the thread passes from `NEW` to `RUNNABLE`.
    In the `RUNNABLE` state, a thread can be running or ready to run. A thread that
    is waiting for the **JVM** (**Java Virtual Machine**) thread scheduler to allocate
    the necessary resources and time to run is ready to run, but it is not running
    yet. As soon as the CPU is available, the thread scheduler will run the thread.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUNNABLE` `Thread#start()`方法，线程从`NEW`到`RUNNABLE`。在`RUNNABLE`状态下，线程可以运行或准备运行。等待**JVM**（Java虚拟机）线程调度程序分配必要的资源和时间来运行的线程是准备运行的，但尚未运行。一旦CPU可用，线程调度程序将运行线程。'
- en: '`BLOCKED` `BLOCKED` state. For example, if a thread, *t1*, attempts to enter
    into a synchronized block of code (for example, a block of code marked `synchronized`)
    that is already being accessed by another thread, *t2*, then *t1* is held in the
    `BLOCKED` state until it can acquire the required lock.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BLOCKED` `BLOCKED`状态。例如，如果一个线程*t1*试图进入另一个线程*t2*已经访问的同步代码块（例如，标记为`synchronized`的代码块），那么*t1*将被保持在`BLOCKED`状态，直到它可以获取所需的锁。'
- en: '`WAITING` `WAITING` state.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WAITING` `WAITING`状态。'
- en: '`TIMED WAITING` `TIMED_WAITING` state.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMED WAITING` `TIMED_WAITING`状态。'
- en: '`TERMINATED` `TERMINATE` state.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TERMINATED` `TERMINATE`状态。'
- en: Besides describing the possible states of a Java thread, the interviewer might
    ask you to code an example for each state. This is why I highly recommended that
    you take your time and analyze the application named *ThreadLifecycleState* (for
    brevity, the code is not listed in the book). The application is structured in
    a very intuitive way, and the leading comments explain each scenario/state.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了描述Java线程的可能状态之外，面试官可能会要求您为每个状态编写一个示例。这就是为什么我强烈建议您花时间分析名为*ThreadLifecycleState*的应用程序（为简洁起见，书中未列出代码）。该应用程序的结构非常直观，主要注释解释了每种情景/状态。
- en: Coding challenge 2 – Deadlocks
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战2 - 死锁
- en: '**Problem**: Explain deadlock to us and we''ll hire you!'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：向我们解释一下死锁，我们会雇佣你！'
- en: '**Solution**: Hire me, and I''ll explain it to you.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：雇佣我，我会向您解释。'
- en: Here, we've just described a deadlock.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们刚刚描述了一个死锁。
- en: 'A deadlock can be explained like this: thread *T1* holds the lock, *P*, and
    is trying to acquire the lock, *Q*. At the same time, there is thread *T2* that
    holds the lock, *Q*, and is trying to acquire the lock, *P*. This kind of deadlock
    is known as *circular wait* or *deadly embrace*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁可以这样解释：线程*T1*持有锁*P*，并尝试获取锁*Q*。与此同时，有一个线程*T2*持有锁*Q*，并尝试获取锁*P*。这种死锁被称为*循环等待*或*致命拥抱*。
- en: Java doesn't provide deadlock detection and/or a resolving mechanism (like databases
    have, for example). This means that a deadlock can be very embarrassing for an
    application. A deadlock can partially or completely block an application. This
    leads to significant performance penalties, unexpected behaviors/results, and
    more. Commonly, deadlocks are hard to find and debug, and they force you to restart
    the application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Java不提供死锁检测和/或解决机制（例如数据库有）。这意味着死锁对应用程序来说可能非常尴尬。死锁可能部分或完全阻塞应用程序。这导致显著的性能惩罚，意外的行为/结果等。通常，死锁很难找到和调试，并且会迫使您重新启动应用程序。
- en: The best way to avoid race deadlocks is to avoid using nested locks or unnecessary
    locks. Nested locks are quite prone to deadlocks.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 避免竞争死锁的最佳方法是避免使用嵌套锁或不必要的锁。嵌套锁很容易导致死锁。
- en: A common problem of simulating a deadlock is **The Dining Philosophers** problem.
    You can find a detailed explanation and implementation of this problem in the
    *Java Coding Problems* book ([https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)).
    *Java Coding Problems* contains two chapters that are dedicated to Java concurrency
    and are meant to dive deep into this topic using specific problems.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟死锁的常见问题是**哲学家就餐**问题。您可以在*Java编码问题*书中找到对这个问题的详细解释和实现（[https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)）。*Java编码问题*包含两章专门讨论Java并发，并旨在使用特定问题深入探讨这个主题。
- en: In the code bundle for this book, you can find a simple example of causing a
    deadlock named *Deadlock*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的代码包中，您可以找到一个名为*Deadlock*的死锁示例。
- en: Coding challenge 3 – Race conditions
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战3 - 竞争条件
- en: '**Problem**: Explain what *race conditions* are.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：解释一下*竞争条件*是什么。'
- en: '**Solution**: First of all, we must mention that a snippet/block of code that
    can be executed by multiple threads (that is, executed concurrently) and exposes
    shared resources (for example, shared data) is known as a *critical section*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：首先，我们必须提到可以由多个线程执行（即并发执行）并公开共享资源（例如共享数据）的代码片段/块被称为*关键部分*。'
- en: '*Race conditions* occur when threads pass through such critical sections without
    thread synchronization. The threads *race* through the critical section attempting
    to read/write shared resources. Depending on the order in which threads finish
    this race, the application''s output changes (two runs of the application may
    produce different outputs). This leads to inconsistent behavior in the application.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*竞争条件*发生在线程在没有线程同步的情况下通过这样的关键部分。线程在关键部分中*竞争*尝试读取/写入共享资源。根据线程完成这场竞赛的顺序，应用程序的输出会发生变化（应用程序的两次运行可能会产生不同的输出）。这导致应用程序的行为不一致。'
- en: The best way to avoid race conditions involves the proper synchronization of
    critical sections by using locks, synchronized blocks, atomic/volatile variables,
    synchronizers, and/or message passing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 避免竞争条件的最佳方法是通过使用锁、同步块、原子/易失性变量、同步器和/或消息传递来正确同步关键部分。
- en: Coding challenge 4 – reentrant locking
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战4 - 可重入锁
- en: '**Problem**: Explain what is the *reentrant locking* concept.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：解释什么是*可重入锁*概念。'
- en: '**Solution**: Generally speaking, *reentrant locking* refers to a process that
    can acquire a lock multiple times without deadlocking itself. If a lock is not
    reentrant, then the process can still acquire it. However, when the process tries
    to acquire the lock again, it will be blocked (deadlock). A reentrant lock can
    be acquired by another thread or recursively by the same thread.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：一般来说，*可重入锁*指的是一个进程可以多次获取锁而不会使自身陷入死锁的过程。如果锁不是可重入的，那么进程仍然可以获取它。但是，当进程尝试再次获取锁时，它将被阻塞（死锁）。可重入锁可以被另一个线程获取，或者被同一个线程递归地获取。'
- en: A reentrant lock can be used for a piece of code that doesn't contain updates
    that could break it. If the code contains a shared state that can be updated,
    then acquiring the lock again will corrupt the shared state since the code is
    called while it is executing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可重入锁可以用于不包含可能破坏它的更新的代码片段。如果代码包含可以更新的共享状态，那么再次获取锁将会破坏共享状态，因为在执行代码时调用了该代码。
- en: 'In Java, a reentrant lock is implemented via the `ReentrantLock` class. A reentrant
    lock acts like this: when the thread enters the lock for the first time, a hold
    count is set to one. Before unlocking, the thread can re-enter the lock causing
    the hold count to be incremented by one for each entry. Each unlock request decrements
    the hold count by one, and, when the hold count is zero, the locked resource is
    opened.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，可重入锁是通过`ReentrantLock`类实现的。可重入锁的工作方式是：当线程第一次进入锁时，保持计数设置为1。在解锁之前，线程可以重新进入锁，导致每次进入时保持计数增加一。每个解锁请求将保持计数减少一，当保持计数为零时，锁定的资源被打开。
- en: Coding challenge 5 – Executor and ExecutorService
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战5 - Executor和ExecutorService
- en: '`Executor` and `ExecutorService`?'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor`和`ExecutorService`？'
- en: '`java.util.concurrent` package, there are a number of interfaces that are dedicated
    to executing tasks. The simplest one is named `Executor`. This interface exposes
    a single method named `execute (Runnable command)`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`java.util.concurrent`包中，有许多专用于执行任务的接口。最简单的一个被命名为`Executor`。这个接口公开了一个名为`execute
    (Runnable command)`的方法。
- en: A more complex and comprehensive interface, which provides many additional methods,
    is `ExecutorService`. This is an enriched version of `Executor`. Java comes with
    a full-fledged implementation of `ExecutorService`, named `ThreadPoolExecutor`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂和全面的接口，提供了许多额外的方法，是`ExecutorService`。这是`Executor`的增强版本。Java带有一个完整的`ExecutorService`实现，名为`ThreadPoolExecutor`。
- en: In the code bundle for this book, you can find simple examples of using `Executor`
    and `ThreadPoolExecutor` in the application named *ExecutorAndExecutorService*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的代码包中，您可以找到在名为*ExecutorAndExecutorService*的应用程序中使用`Executor`和`ThreadPoolExecutor`的简单示例。
- en: Coding challenge 6 – Runnable versus Callable
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战6 - Runnable与Callable的比较
- en: '`Callable` interface and the `Runnable` interface?'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable`接口和`Runnable`接口？'
- en: '`Runnable` interface is a functional interface that contains a single method
    named `run()`. The `run()` method doesn''t take any parameters and returns `void`.
    Moreover, it cannot throw checked exceptions (only `RuntimeException`). These
    statements make `Runnable` suitable in scenarios where we are not looking for
    the result of the thread execution. The `run()` signature is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runnable`接口是一个包含一个名为`run()`的方法的函数接口。`run()`方法不接受任何参数，返回`void`。此外，它不能抛出已检查的异常（只能抛出`RuntimeException`）。这些陈述使`Runnable`适用于我们不寻找线程执行结果的情况。`run()`签名如下：'
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On the other hand, the `Callable` interface is a functional interface that
    contains a single method named `call()`. The `call()` method returns a generic
    value and can throw checked exceptions. Typically, `Callable` is used in `ExecutorService`
    instances. It is useful for starting an asynchronous task and then calling the
    returned `Future` instance to get its value. The `Future` interface defines methods
    for obtaining the result generated by a `Callable` object and for managing its
    state. The `call()` signature is as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Callable`接口是一个包含一个名为`call()`的方法的函数接口。`call()`方法返回一个通用值，并且可以抛出已检查的异常。通常，`Callable`用于`ExecutorService`实例。它用于启动异步任务，然后调用返回的`Future`实例来获取其值。`Future`接口定义了用于获取`Callable`对象生成的结果和管理其状态的方法。`call()`签名如下：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that both of these interfaces represent a task that is intended to be
    executed concurrently by a separate thread.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个接口都代表一个任务，该任务旨在由单独的线程并发执行。
- en: In the code bundle for this book, you can find simple examples of using `Runnable`
    and `Callable` in the application named *RunnableAndCallable*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的代码包中，您可以找到在名为*RunnableAndCallable*的应用程序中使用`Runnable`和`Callable`的简单示例。
- en: Coding challenge 7 – Starvation
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战7 - 饥饿
- en: '**Problem**: Explain what thread *starvation* is.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：解释什么是线程*饥饿*。'
- en: '**Solution**: A thread that never (or very rarely) gets CPU time or access
    to the shared resources is a thread that experiences *starvation*. Since it cannot
    obtain regular access to shared resources, this thread cannot progress its job.
    This happens because other threads (so-called *greedy* threads) get access before
    this thread and make the resources unavailable for long periods of time.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：一个永远（或很少）得不到CPU时间或访问共享资源的线程是经历*饥饿*的线程。由于它无法定期访问共享资源，这个线程无法推进其工作。这是因为其他线程（所谓的*贪婪*线程）在这个线程之前获得访问，并使资源长时间不可用。'
- en: The best way to avoid thread starvation is to use *fair* locks, such as Java
    `ReentrantLock`. A *fair* lock grants access to the thread that has been waiting
    the longest. Having multiple threads run at once while preventing starvation can
    be accomplished via Java `Semaphore`. A *fair* `Semaphore` guarantees the granting
    of permits under contention using FIFO.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 避免线程饥饿的最佳方法是使用*公平*锁，比如Java的`ReentrantLock`。*公平*锁授予等待时间最长的线程访问权限。通过Java的`Semaphore`可以实现多个线程同时运行而避免饥饿。*公平*`Semaphore`使用FIFO来保证在争用情况下授予许可。
- en: Coding challenge 8 – Livelocks
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战8 - 活锁
- en: '**Problem**: Explain what thread *livelock* is.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：解释什么是线程*活锁*。'
- en: '**Solution**: A livelock takes place when two threads keep taking actions in
    response to another thread. The threads don''t make any progress with their own
    jobs. Notice that the threads are not blocked; both of them are too busy responding
    to each other to resume work.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：当两个线程不断采取行动以响应另一个线程时，就会发生活锁。这些线程不会在自己的工作中取得任何进展。请注意，这些线程没有被阻塞；它们都忙于相互响应而无法恢复工作。'
- en: 'Here is an example of a livelock: imagine two people trying to cross each other
    in a hallway. Mark moves to his right to let Oliver pass, and Oliver moves to
    his left to let Mark pass. Both are now blocking each other. Mark sees that he''s
    blocking Oliver and moves to his left, and Oliver moves to his right after seeing
    that he''s blocking Mark. They never manage to cross each other and keep blocking
    each other.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个活锁的例子：想象两个人试图在走廊上互相让对方通过。马克向右移动让奥利弗通过，奥利弗向左移动让马克通过。现在他们互相阻塞。马克看到自己挡住了奥利弗，向左移动，奥利弗看到自己挡住了马克，向右移动。他们永远无法互相通过并一直阻塞对方。
- en: We can avoid livelocks via `ReentrantLock`. This way, we can determine which
    thread has been waiting the longest and assign it a lock. If a thread can't acquire
    a lock, it should release the previously acquired locks and try again later.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `ReentrantLock` 避免活锁。这样，我们可以确定哪个线程等待的时间最长，并为其分配一个锁。如果一个线程无法获取锁，它应该释放先前获取的锁，然后稍后再试。
- en: Coding challenge 9 – Start() versus run()
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战9 – Start() 与 run()
- en: '`start()` method and the `run()` method in a Java `Thread`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Java `Thread` 中的 `start()` 方法和 `run()` 方法。
- en: '`start()` and `run()` is the fact that the `start()` method creates a new thread
    while the `run()` method doesn''t. The `start()` method creates a new thread and
    calls the block of code written inside the `run()` method of this new thread.
    The `run()` method executes that code on the same thread (that is, the calling
    thread) without creating a new thread.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`start()` 和 `run()` 的区别在于 `start()` 方法创建一个新的线程，而 `run()` 方法不会。`start()` 方法创建一个新的线程，并调用在这个新线程中写的
    `run()` 方法内的代码块。`run()` 方法在同一个线程上执行该代码（即调用线程），而不创建新线程。'
- en: Another difference is that calling `start()` twice on the thread object will
    throw an `IllegalStateException`. On the other hand, calling the `run()` method
    twice doesn't lead to an exception.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是在线程对象上两次调用 `start()` 将抛出 `IllegalStateException`。另一方面，两次调用 `run()` 方法不会导致异常。
- en: Typically, novices ignore these differences, and, since the `start()` method
    eventually calls the `run()` method, they believe there is no reason to call the
    `start()` method. Therefore, they call the `run()` method directly.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，新手会忽略这些区别，并且，由于 `start()` 方法最终调用 `run()` 方法，他们认为没有理由调用 `start()` 方法。因此，他们直接调用
    `run()` 方法。
- en: Coding challenge 10 – Thread versus Runnable
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战10 – 线程与可运行
- en: '`Thread` or implement `Runnable`?'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread` 或实现 `Runnable`？'
- en: '`java.lang.Thread` or by implementing `java.lang.Runnable`. The preferred way
    to go is to implement `Runnable`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `java.lang.Thread` 或实现 `java.lang.Runnable`。首选的方法是实现 `Runnable`。
- en: Most of the time, we implement a thread just to give it something to run, not
    to overwrite the behavior of the `Thread`. As long as all we want is to give something
    to run to a thread, we definitely should stick to implementing `Runnable`. In
    fact, using `Callable` or `FutureTask` is an even better choice.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们实现一个线程只是为了让它运行一些东西，而不是覆盖 `Thread` 的行为。只要我们想要给一个线程运行一些东西，我们肯定应该坚持实现
    `Runnable`。事实上，使用 `Callable` 或 `FutureTask` 更好。
- en: In addition to this, by implementing `Runnable`, you can still extend another
    class. By extending `Thread`, you cannot extend another class since Java doesn't
    support multiple inheritances.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过实现 `Runnable`，你仍然可以扩展另一个类。通过扩展 `Thread`，你不能扩展另一个类，因为Java不支持多重继承。
- en: Finally, by implementing `Runnable`, we separate the task definition from the
    task execution.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过实现 `Runnable`，我们将任务定义与任务执行分离。
- en: Coding challenge 11 – CountDownLatch versus CyclicBarrier
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战11 – CountDownLatch 与 CyclicBarrier
- en: '`CountDownLatch` and `CyclicBarrier`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountDownLatch` 和 `CyclicBarrier`。'
- en: '`CountDownLatch` and `CyclicBarrier` are two of the five Java *synchronizers*
    next to `Exchanger`, `Semaphore`, and `Phaser`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountDownLatch` 和 `CyclicBarrier` 是 Java *同步器* 中的五个之一，另外还有 `Exchanger`、`Semaphore`
    和 `Phaser`。'
- en: The main difference between `CountDownLatch` and `CyclicBarrier` is the fact
    that a `CountDownLatch` instance cannot be reused once the countdown reaches zero.
    On the other hand, a `CyclicBarrier` instance is reusable. A `CyclicBarrier` instance
    is cyclical because it can be reset and reused. To do this, call the `reset()`
    method after all of the threads waiting at the barrier are released; otherwise,
    `BrokenBarrierException` will be thrown.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`CountDownLatch` 和 `CyclicBarrier` 之间的主要区别在于 `CountDownLatch` 实例在倒计时达到零后无法重用。另一方面，`CyclicBarrier`
    实例是可重用的。`CyclicBarrier` 实例是循环的，因为它可以被重置和重用。要做到这一点，在所有等待在屏障处的线程被释放后调用 `reset()`
    方法；否则，将抛出 `BrokenBarrierException`。'
- en: Coding challenge 12 – wait() versus sleep()
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战12 – wait() 与 sleep()
- en: '`wait()` method and the `sleep()` method.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait()` 方法和 `sleep()` 方法。'
- en: '`wait()` method and the `sleep()` method is that `wait()` must be called from
    a synchronized context (for example, from a `synchronized` method), while the
    `sleep()` method doesn''t need a synchronized context. Calling `wait()` from a
    non-synchronized context will throw an `IllegalMonitorStateException`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait()` 方法和 `sleep()` 方法的区别在于 `wait()` 必须从同步上下文（例如，从 `synchronized` 方法）中调用，而
    `sleep()` 方法不需要同步上下文。从非同步上下文调用 `wait()` 将抛出 `IllegalMonitorStateException`。'
- en: Additionally, it is important to mention that `wait()` works on `Object`, while
    `sleep()` works on the current thread. Essentially, `wait()` is a non-`static`
    method defined in `java.lang.Object`, while `sleep()` is a `static` method defined
    in `java.lang.Thread`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，重要的是要提到 `wait()` 在 `Object` 上工作，而 `sleep()` 在当前线程上工作。实质上，`wait()` 是在 `java.lang.Object`
    中定义的非`static`方法，而 `sleep()` 是在 `java.lang.Thread` 中定义的`static`方法。
- en: Moreover, the `wait()` method releases the lock, while the `sleep()` method
    doesn't release the lock. The `sleep()` method only pauses the current thread
    for a certain period of time. Both of them throw `IntrupptedException` and can
    be interrupted.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`wait()` 方法释放锁，而 `sleep()` 方法不释放锁。`sleep()` 方法只是暂停当前线程一段时间。它们都会抛出 `IntrupptedException`
    并且可以被中断。
- en: Finally, the `wait()` method should be called in a loop that decides when the
    lock should be released. On the other hand, it is not recommended that you call
    the `sleep()` method in a loop.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应该在决定何时释放锁的循环中调用`wait()`方法。另一方面，不建议在循环中调用`sleep()`方法。
- en: Coding challenge 13 – ConcurrentHashMap versus Hashtable
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战13 - ConcurrentHashMap与Hashtable
- en: '`ConcurrentHashMap` faster than `Hashtable`?'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`比`Hashtable`快吗？'
- en: '`ConcurrentHashMap` is faster than `Hashtable` because of its special internal
    design. `ConcurrentHashMap` internally divides a map into segments (or buckets),
    and it locks only a particular segment during an update operation. On the other
    hand, `Hashtable` locks the whole map during an update operation. So, `Hashtable`
    uses a single lock for the whole data, while `ConcurrentHashMap` uses multiple
    locks on different segments (buckets).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`比`Hashtable`更快，因为它具有特殊的内部设计。`ConcurrentHashMap`在内部将映射分成段（或桶），并且在更新操作期间仅锁定特定段。另一方面，`Hashtable`在更新操作期间锁定整个映射。因此，`Hashtable`对整个数据使用单个锁，而`ConcurrentHashMap`对不同段（桶）使用多个锁。'
- en: Moreover, reading from a `ConcurrentHashMap` using `get()` is lock-free (no
    locks), while all the `Hashtable` operations are simply `synchronized`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用`get()`从`ConcurrentHashMap`中读取是无锁的（无锁），而所有`Hashtable`操作都是简单的`synchronized`。
- en: Coding challenge 14 – ThreadLocal
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战14 - ThreadLocal
- en: '`ThreadLocal`?'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadLocal`？'
- en: '`ThreadLocal` as a means to store and retrieve values for each thread separately.
    A single instance of `ThreadLocal` can store and retrieve the values of multiple
    threads. If thread *A* stores the *x* value and thread *B* stores the *y* value
    in the same instance of `ThreadLocal`, then, later on, thread *A* retrieves the
    *x* value, and thread *B* retrieves the *y* value. Java `ThreadLocal` is typically
    used in the following two scenarios:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadLocal`用作分别存储和检索每个线程的值的手段。单个`ThreadLocal`实例可以存储和检索多个线程的值。如果线程*A*存储*x*值，线程*B*在同一个`ThreadLocal`实例中存储*y*值，那么后来线程*A*检索*x*值，线程*B*检索*y*值。Java
    `ThreadLocal`通常用于以下两种情况：'
- en: To provide per-thread instances (thread safety and memory efficiency)
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个线程提供实例（线程安全和内存效率）
- en: To provide per-thread context
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个线程提供上下文
- en: Coding challenge 15 – submit() versus execute()
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战15 - submit()与execute()
- en: '`ExecutorService#submit()` and `Executor#execute()` methods.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecutorService#submit()`和`Executor#execute()`方法。'
- en: '`Runnable` task for execution, they are not the same. The main difference can
    be observed by simply checking their signatures. Notice that `submit()` returns
    a result (that is, a `Future` object representing the task), while `execute()`
    returns `void`. The returned `Future` object can be used to programmatically cancel
    the running thread later on (prematurely). Moreover, by using the `Future#get()`
    method, we can wait for the task to complete. If we submit a `Callable`, then
    the `Future#get()` method will return the result of calling the `Callable#call()`
    method.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 用于执行的`Runnable`任务，它们并不相同。主要区别可以通过简单检查它们的签名来观察。注意，`submit()`返回一个结果（即代表任务的`Future`对象），而`execute()`返回`void`。返回的`Future`对象可以用于在以后（过早地）以编程方式取消运行的线程。此外，通过使用`Future#get()`方法，我们可以等待任务完成。如果我们提交一个`Callable`，那么`Future#get()`方法将返回调用`Callable#call()`方法的结果。
- en: Coding challenge 16 – interrupted() and isInterrupted()
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战16 - interrupted()和isInterrupted()
- en: '`interrupted()` and `isInterrupted()` methods.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`interrupted()`和`isInterrupted()`方法。'
- en: '`Thread.interrupt()` method interrupts the current thread and sets this flag
    to `true`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread.interrupt()`方法中断当前线程并将此标志设置为`true`。'
- en: The main difference between the `interrupted()` and `isInterrupted()` methods
    is the fact that the `interrupted()` method clears the interrupt status while
    `isInterrupted()` doesn't.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`interrupted()`和`isInterrupted()`方法之间的主要区别在于`interrupted()`方法会清除中断状态，而`isInterrupted()`不会。'
- en: If the thread was interrupted, then `Thread.interrupted()` will return `true`.
    However, besides testing, if the current thread was interrupted, `Thread.interrupted()`
    clears the interrupted status of the thread (that is, sets it to `false`).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程被中断，则`Thread.interrupted()`将返回`true`。但是，除了测试当前线程是否被中断外，`Thread.interrupted()`还会清除线程的中断状态（即将其设置为`false`）。
- en: The non-`static isInterrupted()` method doesn't change the interrupt status
    flag.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 非`static isInterrupted()`方法不会更改中断状态标志。
- en: As a rule of thumb, after catching `InterruptedException`, don't forget to restore
    the interrupt by calling `Thread.currentThread().interrupt()`. This way, the caller
    of our code will be aware of the interruption.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，在捕获`InterruptedException`后，不要忘记通过调用`Thread.currentThread().interrupt()`来恢复中断。这样，我们的代码的调用者将意识到中断。
- en: Coding challenge 17 – Canceling a thread
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战17 - 取消线程
- en: '**Problem**: How can we stop or cancel a thread?'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：如何停止或取消线程？'
- en: '`volatile` (also known as the lightweight synchronization mechanism). Being
    a `volatile` flag, it is not cached by threads, and operations on it are not reordered
    in memory; therefore, a thread cannot see an old value. Any thread that reads
    a `volatile` field will see the most recently written value. This is exactly what
    we need in order to communicate the cancellation action to all running threads
    that are interested in this action. The following diagram illustrates this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`volatile`（也称为轻量级同步机制）。作为`volatile`标志，它不会被线程缓存，并且对它的操作不会在内存中重新排序；因此，线程无法看到旧值。读取`volatile`字段的任何线程都将看到最近写入的值。这正是我们需要的，以便将取消操作通知给所有对此操作感兴趣的运行中的线程。以下图表说明了这一点：'
- en: '![16.3 – Volatile flag read/write'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![16.3 - Volatile标志读/写'
- en: '](img/Figure_16.3_B15403.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.3_B15403.jpg)'
- en: 16.3 – Volatile flag read/write
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 16.3 - Volatile标志读/写
- en: Notice that the `volatile` variables are not a good fit for read-modify-write
    scenarios. For such scenarios, we will rely on atomic variables (for example,
    `AtomicBoolean`, `AtomicInteger`, and `AtomicReference`).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`volatile`变量不适合读-修改-写场景。对于这种场景，我们将依赖原子变量（例如`AtomicBoolean`、`AtomicInteger`和`AtomicReference`）。
- en: In the code bundle for this book, you can find an example of canceling a thread.
    The application is named *CancelThread*.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的代码包中，您可以找到一个取消线程的示例。该应用程序名为*CancelThread*。
- en: Coding challenge 18 – sharing data between threads
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战18 - 在线程之间共享数据
- en: '**Problem**: How can we share data between two threads?'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：如何在两个线程之间共享数据？
- en: '`BlockingQueue`, `LinkedBlockingQueue`, and `ConcurrentLinkedDeque`. It is
    very convenient to rely on these data structures to share data between threads
    because you don''t have to bother about thread safety and inter-thread communication.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingQueue`，`LinkedBlockingQueue`和`ConcurrentLinkedDeque`。依赖于这些数据结构在线程之间共享数据非常方便，因为您不必担心线程安全和线程间通信。'
- en: Coding challenge 19 – ReadWriteLock
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 编码挑战19 - ReadWriteLock
- en: '`ReadWriteLock` is in Java.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadWriteLock`是在Java中的。'
- en: '`ReadWriteLock` is to sustain the efficiency and thread safety of reading and
    writing operations in a concurrent environment. It accomplishes this goal via
    the *lock striping* concept. In other words, `ReadWriteLock` uses separate locks
    for reads and writes. More precisely, `ReadWriteLock` keeps a pair of locks: one
    for read-only operations and one for writing operations. As long as there are
    no writer threads, multiple reader threads can hold the read lock simultaneously
    (shared pessimistic lock). A single writer can write at a time (exclusive/pessimistic
    locking). So, `ReadWriteLock` can significantly improve the performance of the
    application.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadWriteLock`用于在并发环境中维护读写操作的效率和线程安全性。它通过*锁分段*的概念实现这一目标。换句话说，`ReadWriteLock`为读和写使用单独的锁。更确切地说，`ReadWriteLock`保持一对锁：一个用于只读操作，一个用于写操作。只要没有写线程，多个读线程可以同时持有读锁（共享悲观锁）。一个写线程可以一次写入（独占/悲观锁）。因此，`ReadWriteLock`可以显著提高应用程序的性能。'
- en: Besides `ReadWriteLock`, Java comes with `ReentrantReadWriteLock` and `StampedLock`.
    The `ReentrantReadWriteLock` class adds the *reentrant locking* concept (refer
    to *Coding challenge 4*) to `ReadWriteLock`. On the other hand, `StampedLock`
    performs better than `ReentrantReadWriteLock` and supports optimistic reads. But
    it is not *reentrant*; therefore, it is prone to deadlocks.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ReadWriteLock`，Java还提供了`ReentrantReadWriteLock`和`StampedLock`。`ReentrantReadWriteLock`类将*可重入锁*概念（参见*编码挑战4*）添加到`ReadWriteLock`中。另一方面，`StampedLock`比`ReentrantReadWriteLock`表现更好，并支持乐观读取。但它不是*可重入*的；因此，它容易发生死锁。
- en: Coding challenge 20 – Producer-Consumer
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战20 - 生产者-消费者
- en: '**Problem**: Provide an implementation for the famous Producer-Consumer problem.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：为著名的生产者-消费者问题提供一个实现。'
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This is a favorite problem during any Java multithreading interview!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任何Java多线程面试中的一个常见问题！
- en: '**Solution**: The Producer-Consumer problem is a design pattern that can be
    represented as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：生产者-消费者问题是一个可以表示为以下形式的设计模式：'
- en: '![16.4 – Producer-Consumer design pattern'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![16.4 - 生产者-消费者设计模式'
- en: '](img/Figure_16.4_B15403.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.4_B15403.jpg)'
- en: 16.4 – Producer-Consumer design pattern
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 16.4 - 生产者-消费者设计模式
- en: Most commonly, in this pattern, the producer thread and the consumer thread
    communicate via a queue (the producer enqueues data and the consumer dequeues
    data) and a set of rules specific to the modeled business. This queue is known
    as the *data buffer*. Of course, depending on the process design, other data structures
    can play the role of data buffer as well.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式中，生产者线程和消费者线程通常通过一个队列进行通信（生产者将数据入队，消费者将数据出队），并遵循特定于建模业务的一组规则。这个队列被称为*数据缓冲区*。当然，根据流程设计，其他数据结构也可以扮演数据缓冲区的角色。
- en: 'Now, let''s assume the following scenario (set of rules):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设以下情景（一组规则）：
- en: If the data buffer is empty, then the producer produces one product (by adding
    it to the data buffer).
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据缓冲区为空，那么生产者会生产一个产品（将其添加到数据缓冲区）。
- en: If the data buffer is not empty, then the consumer consumes one product (by
    removing it from the data buffer).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据缓冲区不为空，那么消费者会消费一个产品（从数据缓冲区中移除它）。
- en: As long as the data buffer is not empty, the producer waits.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要数据缓冲区不为空，生产者就会等待。
- en: As long as the data buffer is empty, the consumer waits.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要数据缓冲区为空，消费者就会等待。
- en: Next, let's solve this scenario via two common approaches. We will start with
    a solution that is based on the `wait()` and `notify()` methods.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过两种常见的方法解决这种情况。我们将从基于`wait()`和`notify()`方法的解决方案开始。
- en: Producer-Consumer via wait() and notify()
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过`wait()`和`notify()`实现生产者-消费者
- en: Some interviewers may ask you to implement a `wait()` and `notify()` methods.
    In other words, they don't allow you to use a built-in thread-safe queue such
    as `BlockingQueue`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一些面试官可能会要求您实现`wait()`和`notify()`方法。换句话说，他们不允许您使用内置的线程安全队列，如`BlockingQueue`。
- en: For example, let's consider that the data buffer (`queue`) is represented by
    a `LinkedList`, that is, a non-thread-safe data structure. To ensure that this
    shared `LinkedList` is accessible in a thread-safe manner by the producer and
    the consumer, we rely on the `synchronized` keyword.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑数据缓冲区（`queue`）由`LinkedList`表示，即非线程安全的数据结构。为了确保生产者和消费者以线程安全的方式访问这个共享的`LinkedList`，我们依赖于`Synchronized`关键字。
- en: The producer
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生产者
- en: 'If the queue is not empty, then the producer waits until the consumer finishes.
    To do this, the producer relies on the `wait()` method, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列不为空，那么生产者会等待，直到消费者完成。为此，生产者依赖于`wait()`方法，如下所示：
- en: '[PRE2]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On the other hand, if the queue is empty, then the producer enqueues one product
    and notifies the consumer thread via `notify()`, as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果队列为空，那么生产者会将一个产品入队，并通过`notify()`通知消费者线程，如下所示：
- en: '[PRE3]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After adding a product to the queue, the consumer should be ready to consume
    it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在将产品添加到队列后，消费者应该准备好消费它。
- en: The consumer
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消费者
- en: 'If the queue is empty, then the consumer waits until the producer finishes.
    For this, the producer relies on the `wait()` method, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果队列为空，那么消费者会等待，直到生产者完成。为此，生产者依赖于`wait()`方法，如下所示：
- en: '[PRE4]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On the other hand, if the queue is not empty, then the consumer dequeues one
    product and notifies the producer thread via `notify()`, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果队列不为空，则消费者将出列一个产品并通过`notify()`通知生产者线程，如下所示：
- en: '[PRE5]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The complete code is available in the bundled code, *ProducerConsumerWaitNotify*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码在捆绑代码*ProducerConsumerWaitNotify*中可用。
- en: Producer-Consumer via built-in blocking queues
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过内置的阻塞队列进行生产者-消费者
- en: If you can use a built-in blocking queue, then you can choose a `BlockingQueue`
    or even a `TransferQueue`. Both of them are thread-safe. In the following code,
    we use a `TransferQueue` or, more precisely, a `LinkedTransferQueue`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以使用内置的阻塞队列，那么您可以选择`BlockingQueue`甚至`TransferQueue`。它们两者都是线程安全的。在下面的代码中，我们使用了`TransferQueue`，更确切地说是`LinkedTransferQueue`。
- en: The producer
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生产者
- en: 'The producer waits for the consumer to be available via `hasWaitingConsumer()`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者等待消费者通过`hasWaitingConsumer()`可用：
- en: '[PRE6]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After adding a product to the queue, the consumer should be ready to consume
    it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在将产品添加到队列后，消费者应准备好消费它。
- en: The consumer
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消费者
- en: 'The consumer uses the `poll()` method with a timeout to extract the product:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者使用`poll()`方法并设置超时来提取产品：
- en: '[PRE7]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The complete code is available in the bundled code, *ProducerConsumerQueue*
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码在捆绑代码*ProducerConsumerQueue*中可用
- en: Summary
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered the most popular questions that occur in Java multithreading
    interviews. Nevertheless, Java concurrency is a vast topic, and it is very important
    to deep dive into it. I strongly suggest that you read *Java Concurrency in Practice*
    by Brian Goetz. This is a must-read for any Java developer.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了在Java多线程面试中经常出现的最受欢迎的问题。然而，Java并发是一个广泛的主题，深入研究它非常重要。我强烈建议您阅读Brian
    Goetz的*Java并发实践*。这对于任何Java开发人员来说都是必读之书。
- en: 'In the next chapter, we will cover a hot topic: Java functional-style programming.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖一个热门话题：Java函数式编程。
