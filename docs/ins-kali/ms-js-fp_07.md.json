["```js\nconst make3 = (a, b, c) => String(100 * a + 10 * b + c);\n```", "```js\nconst make3curried = a => b => c => String(100 * a + 10 * b + c);\n```", "```js\nconst make3curried2 = function(a) {\n return function(b) {\n return function(c) {\n return String(100 * a + 10 * b + c);\n };\n };\n};\n```", "```js\nconst addVAT = (rate, amount) => amount * (1 + rate / 100);\naddVAT(20, 500); // 600 -- *that is,* 500 + 20%\naddVAT(15, 200); // 230 -- 200 +15%\n```", "```js\nconst addVATcurried = rate => amount => amount * (1 + rate / 100);\nconst addNationalVAT = addVATcurried(6);\naddNationalVAT(1500); // 1590 -- 1500 + 6%\n```", "```js\nlet myLog = (severity, logText) => {\n // *display logText in an appropriate way,*\n // *according to its severity (\"NORMAL\", \"WARNING\", or \"ERROR\")*\n};\n```", "```js\nmyLog = curry(myLog);\n// *replace myLog by a curried version of itself*\n\nconst myNormalLog = myLog(\"NORMAL\");\nconst myWarningLog = myLog(\"WARNING\");\nconst myErrorLog = myLog(\"ERROR\");\n```", "```js\nconst myNormalLog2 = curry(myLog)(\"NORMAL\");\nconst myWarningLog2 = curry(myLog)(\"WARNING\");\nconst myErrorLog2 = curry(myLog)(\"ERROR\");\n```", "```js\nsum(3, 5); // 8; *did you expect otherwise?*\n\nconst add2 = sum(2);\nadd2(3); // 5\n\nsum(2)(7); // 9 -- *as if it were curried*\n```", "```js\nconst sum = (x, y) => {\n if (x !== undefined && y !== undefined) {\n return x + y;\n } else if (x !== undefined && y == undefined) {\n return z => sum(x, z);\n } else {\n return sum;\n }\n};\n```", "```js\nconst curryByBind = fn =>\n fn.length === 0 ? fn() : p => curryByBind(fn.bind(null, p));\n```", "```js\nconst make3 = (a, b, c) => String(100 * a + 10 * b + c);\n\nconst f1 = curryByBind(make3); // *f1 is a function, that will fix make3's 1st parameter*\nconst f2 = f1(6); // *f2 is a function, that will fix make3's 2nd parameter*\nconst f3 = f2(5); // *f3 is a function, that will fix make3's last parameter*\nconst f4 = f3(8); // *\"658\" is calculated, since there are no more parameters to fix*\n```", "```js\nconst step1 = make3.bind(null, 6);\nconst step2 = step1.bind(null, 5);\nconst step3 = step2.bind(null, 8);\nstep3(); // *\"658\"*\n```", "```js\nconst make3 = (a, b, c) => String(100 * a + 10 * b + c);\n\ndescribe(\"with curryByBind\", function() {\n it(\"you fix arguments one by one\", () => {\n const make3a = curryByBind(make3);\n const make3b = make3a(1)(2);\n const make3c = make3b(3);\n expect(make3c).toBe(make3(1, 2, 3));\n });\n});\n```", "```js\nconst curryByBind2 = (fn, len = fn.length) =>\n len === 0 ? fn() : p => curryByBind2(fn.bind(null, p), len - 1);\n\nconst sum2 = (...args) => args.reduce((x, y) => x + y, 0);\nsum2.length; // *0;* *curryByBind() wouldn't work*\n\nsum2(1, 5, 3); // 9\nsum2(1, 5, 3, 7); // 16\nsum2(1, 5, 3, 7, 4); // 20\n\ncurriedSum5 = curryByBind2(sum2, 5); // *curriedSum5 will expect 5 parameters*\ncurriedSum5(1)(5)(3)(7)(4); // *20*\n```", "```js\nconst sum2 = (...args) => args.reduce((x, y) => x + y, 0);\n\ndescribe(\"with curryByBind2\", function() {\n it(\"you fix arguments one by one\", () => {\n const suma = curryByBind2(sum2, 5);\n const sumb = suma(1)(2)(3)(4)(5);\n expect(sumb).toBe(sum(1, 2, 3, 4, 5));\n });\n\n it(\"you can also work with arity 1\", () => {\n const suma = curryByBind2(sum2, 1);\n const sumb = suma(111);\n expect(sumb).toBe(sum(111));\n });\n});\n```", "```js\nconst make3 = (a, b, c) => String(100 * a + 10 * b + c);\n\nconst make3curried = a => b => c => String(100 * a + 10 * b + c);\n```", "```js\nconst make3curried = x1 => x2 => x3 => make3(x1, x2, x3);\n```", "```js\nconst range = (start, stop) =>\n new Array(stop - start).fill(0).map((v, i) => start + i);\n\nconst curryByEval = (fn, len = fn.length) =>\n eval(`**${range(0, len).map(i => `x${i}`).join(\"=>\")}** **=> \n ${fn.name}(${range(0, len).map(i => `x${i}`).join(\",\")})**`);\n```", "```js\ncurryByEval(make3); // x0=>x1=>x2=> make3(x0,x1,x2)\n```", "```js\nconst curryByEval2 = (fn, len = fn.length) =>\n eval(`${range(0, len).map(i => `x${i}`).join(\"=>\")} => \n **(${fn.toString()})**(${range(0, len).map(i => `x${i}`).join(\",\")})`);\n```", "```js\ncurryByEval2(make3); // x0=>x1=>x2=> ((a,b,c) => 100*a+10*b+c)(x0,x1,x2)\n```", "```js\nconst add = (x, y) => x + y;\nadd(2, 5); // 7\n((x, y) => x + y)(2, 5); // *7*\n```", "```js\nconst myParameters = {\n method: \"GET\",\n headers: new Headers(),\n cache: \"default\"\n};\n\nconst myFetch = partial(fetch, undefined, myParameters);\n// *undefined means the first argument for fetch is not yet defined*\n// *the second argument for fetch() is set to myParameters*\n\nmyFetch(\"a/first/url\").then(/* do something */).catch(/* on error */);\nmyFetch(\"a/second/url\")\n .then(/* do something else */)\n .catch(/* on error */);\n```", "```js\nconst nonsense = (a, b, c, d, e) => `${a}/${b}/${c}/${d}/${e}`;\n\nconst fix2and5 = (a, c, d) => nonsense(a, 22, c, d, 1960);\n```", "```js\nconst fixLast = (a, c) => fix2and5(a, c, 9);\n```", "```js\nconst fix2and5 = _.partial(nonsense, _, 22, _, _, 1960);\n```", "```js\nconst nonsense = (a, b, c, d, e) => `${a}/${b}/${c}/${d}/${e}`;\n\nconst fix2and5 = partialByEval(\n nonsense,\n undefined,\n 22,\n undefined,\n undefined,\n 1960\n);\n// *fix2and5 would become* (X0, X2, X3) => nonsense(X0, 22, X2, X3, 1960);\n```", "```js\nconst range = (start, stop) =>\n new Array(stop - start).fill(0).map((v, i) => start + i);\n\nconst partialByEval = (fn, ...args) => {\n const rangeArgs = range(0, fn.length);\n const leftList = rangeArgs\n .map(v => (args[v] === undefined ? `x${v}` : null))\n .filter(v => !!v)\n .join(\",\");\n const rightList = rangeArgs\n .map(v => (args[v] === undefined ? `x${v}` : args[v]))\n .join(\",\");\n return eval(`(${leftList}) => ${fn.name}(${rightList})`);\n};\n```", "```js\nconst partialByEval2 = (fn, ...args) =>\n eval(\n `(${range(0, fn.length)\n .map(v => (args[v] === undefined ? `x${v}` : null))\n .filter(v => !!v)\n .join(\",\")}) => ${fn.name}(${range(0, fn.length)\n .map(v => (args[v] == undefined ? `x${v}` : args[v]))\n .join(\",\")})`\n );\n```", "```js\nconst nonsense = (a, b, c, d, e) => `${a}/${b}/${c}/${d}/${e}`;\n\ndescribe(\"with partialByEval()\", function() {\n it(\"you could fix no arguments\", () => {\n const nonsensePC0 = partialByEval(nonsense);\n expect(nonsensePC0.length).toBe(5);\n expect(nonsensePC0(0, 1, 2, 3, 4)).toBe(nonsense(0, 1, 2, 3, 4));\n });\n\n it(\"you could fix only some initial arguments\", () => {\n const nonsensePC1 = partialByEval(nonsense, 1, 2, 3);\n expect(nonsensePC1.length).toBe(2);\n expect(nonsensePC1(4, 5)).toBe(nonsense(1, 2, 3, 4, 5));\n });\n\n it(\"you could skip some arguments\", () => {\n const nonsensePC2 = partialByEval(\n nonsense,\n undefined,\n 22,\n undefined,\n 44\n );\n expect(nonsensePC2.length).toBe(3);\n expect(nonsensePC2(11, 33, 55)).toBe(nonsense(11, 22, 33, 44, 55));\n });\n\n it(\"you could fix only some last arguments\", () => {\n const nonsensePC3 = partialByEval(\n nonsense,\n undefined,\n undefined,\n undefined,\n 444,\n 555\n );\n expect(nonsensePC3.length).toBe(3);\n expect(nonsensePC3(111, 222, 333)).toBe(\n nonsense(111, 222, 333, 444, 555)\n );\n });\n\n it(\"you could fix ALL the arguments\", () => {\n const nonsensePC4 = partialByEval(nonsense, 6, 7, 8, 9, 0);\n expect(nonsensePC4.length).toBe(0);\n expect(nonsensePC4()).toBe(nonsense(6, 7, 8, 9, 0));\n });\n});\n```", "```js\nconst partialByClosure = (fn, ...args) => {\n const partialize = (...args1) => (...args2) => {\n for (let i = 0; i < args1.length && args2.length; i++) {\n if (args1[i] === undefined) {\n args1[i] = args2.shift();\n }\n }\n const allParams = [...args1, ...args2];\n return (allParams.includes(undefined) ||\n allParams.length < fn.length\n ? partialize\n : fn)(...allParams);\n };\n\n return partialize(...args);\n};\n```", "```js\nconst make3 = (a, b, c) => String(100 * a + 10 * b + c);\nconst f1 = partialByClosure(make3, undefined, 4);\n```", "```js\nconst f2 = f1(7);\n```", "```js\nconst f3 = f2(9);\n```", "```js\ndescribe(\"with partialByClosure()\", function() {\n it(\"you could fix no arguments\", () => {\n const nonsensePC0 = partialByClosure(nonsense);\n expect(nonsensePC0(0, 1, 2, 3, 4)).toBe(nonsense(0, 1, 2, 3, 4));\n });\n\n it(\"you could fix only some initial arguments, and then some more\", () => {\n const nonsensePC1 = partialByClosure(nonsense, 1, 2, 3);\n const nonsensePC1b = nonsensePC1(undefined, 5);\n expect(nonsensePC1b(4)).toBe(nonsense(1, 2, 3, 4, 5));\n });\n\n it(\"you could skip some arguments\", () => {\n const nonsensePC2 = partialByClosure(\n nonsense,\n undefined,\n 22,\n undefined,\n 44\n );\n expect(nonsensePC2(11, 33, 55)).toBe(nonsense(11, 22, 33, 44, 55));\n });\n\n it(\"you could fix only some last arguments\", () => {\n const nonsensePC3 = partialByClosure(\n nonsense,\n undefined,\n undefined,\n undefined,\n 444,\n 555\n );\n expect(nonsensePC3(111)(222, 333)).toBe(\n nonsense(111, 222, 333, 444, 555)\n );\n });\n\n it(\"you could simulate currying\", () => {\n const nonsensePC4 = partialByClosure(nonsense);\n expect(nonsensePC4(6)(7)(8)(9)(0)).toBe(nonsense(6, 7, 8, 9, 0));\n });\n\n it(\"you could fix ALL the arguments\", () => {\n const nonsensePC5 = partialByClosure(nonsense, 16, 17, 18, 19, 20);\n expect(nonsensePC5()).toBe(nonsense(16, 17, 18, 19, 20));\n });\n});\n```", "```js\nconst nonsense = (a, b, c, d, e) => `${a}/${b}/${c}/${d}/${e}`;\n\nconst pcNonsense = partialCurry(nonsense);\nconst fix1And2 = pcNonsense(9, 22); // fix1And2 is now a ternary function\nconst fix3 = fix1And2(60); // fix3 is a binary function\nconst fix4and5 = fix3(12, 4); // fix4and5 === nonsense(9,22,60,12,4), \"9/22/60/12/4\"\n```", "```js\nconst partialCurryingByBind = fn =>\n fn.length === 0\n ? fn()\n : (...pp) => partialCurryingByBind(**fn.bind(null, ...pp)**);\n```", "```js\nconst curryByBind = fn =>\n fn.length === 0 \n ? fn() \n : p => curryByBind(fn.bind(null, p));\n```", "```js\nconst make3 = (a, b, c) => String(100 * a + 10 * b + c);\n\nconst f1 = partialCurryingByBind(make3);\nconst f2 = f1(6, 5); // *f2 is a function, that fixes make3's first two arguments*\nconst f3 = f2(8); // *\"658\" is calculated, since there are no more parameters to fix*\n```", "```js\nconst g1 = partialCurryingByBind(make3)(8, 7);\nconst g2 = g1(6); // \"876\"\n```", "```js\nconst make3 = (a, b, c) => String(100 * a + 10 * b + c);\n\ndescribe(\"with partialCurryingByBind\", function() {\n it(\"you could fix arguments in several steps\", () => {\n const make3a = partialCurryingByBind(make3);\n const make3b = make3a(1, 2);\n const make3c = make3b(3);\n expect(make3c).toBe(make3(1, 2, 3));\n });\n\n it(\"you could fix arguments in a single step\", () => {\n const make3a = partialCurryingByBind(make3);\n const make3b = make3a(10, 11, 12);\n expect(make3b).toBe(make3(10, 11, 12));\n });\n\n it(\"you could fix ALL the arguments\", () => {\n const make3all = partialCurryingByBind(make3);\n expect(make3all(20, 21, 22)).toBe(make3(20, 21, 22));\n });\n\n it(\"you could fix one argument at a time\", () => {\n const make3one = partialCurryingByBind(make3)(30)(31)(32);\n expect(make3one).toBe(make3(30, 31, 32));\n });\n});\n```", "```js\nconst partialCurryingByBind2 = (fn, len = fn.length) =>\n    len === 0\n ? fn()\n : (...pp) =>\n partialCurryingByBind2(\n fn.bind(null, ...pp),\n                  len - pp.length\n );\n```", "```js\nconst sum = (...args) => args.reduce((x, y) => x + y, 0);\n\npcSum5 = partialCurryingByBind2(sum2, 5); // curriedSum5 will expect 5 parameters\npcSum5(1, 5)(3)(7, 4); // 20\n```", "```js\nconst sum2 = (...args) => args.reduce((x, y) => x + y, 0);\n\ndescribe(\"with partialCurryingByBind2\", function() {\n it(\"you could fix arguments in several steps\", () => {\n const suma = partialCurryingByBind2(sum2, 3);\n const sumb = suma(1, 2);\n const sumc = sumb(3);\n expect(sumc).toBe(sum2(1, 2, 3));\n });\n\n it(\"you could fix arguments in a single step\", () => {\n const suma = partialCurryingByBind2(sum2, 4);\n const sumb = suma(10, 11, 12, 13);\n expect(sumb).toBe(sum(10, 11, 12, 13));\n });\n\n it(\"you could fix ALL the arguments\", () => {\n const sumall = partialCurryingByBind2(sum2, 5);\n expect(sumall(20, 21, 22, 23, 24)).toBe(sum2(20, 21, 22, 23, 24));\n });\n\n it(\"you could fix one argument at a time\", () => {\n const sumone = partialCurryingByBind2(sum2, 6)(30)(31)(32)(33)(34)(\n 35\n );\n expect(sumone).toBe(sum2(30, 31, 32, 33, 34, 35));\n });\n});\n```", "```js\nconst partialCurryByClosure = fn => {\n const curryize = (...args1) => (...args2) => {\n const allParams = [...args1, ...args2];\n return (allParams.length < func.length ? curryize : fn)(\n ...allParams\n );\n };\n return curryize();\n};\n```", "```js\nconst partialCurryByClosure2 = (fn, len = fn.length) => {\n const curryize = (...args1) => (...args2) => {\n const allParams = [...args1, ...args2];\n return (allParams.length < len ? curryize : fn)(...allParams);\n };\n return curried();\n};\n```", "```js\nconst flipTwo = fn => (p1, p2) => fn(p2, p1);\n```", "```js\nconst myMap = curry(flipTwo(demethodize(map)));\nconst makeString = v => String(v);\n\nconst stringify = myMap(makeString);\nlet x = stringify(anArray);\nlet y = stringify(anotherArray);\nlet z = stringify(yetAnotherArray);\n```", "```js\nconst flip3 = fn => (p1, p2, p3) => fn(p2, p3, p1);\n\nconst myReduce = partialCurry(flip3(demethodize(reduce)));\nconst sum = (x, y) => x + y;\n\nconst sumAll = myReduce(sum, 0);\nsumAll(anArray);\nsumAll(anotherArray);\n```", "```js\nconst myFunction = (a, b, c) => { ... };\nconst myCurriedFunction = curry(myFunction)(fixed_first_argument);\n\n// *and later in the code...*\nmyCurriedFunction(second_argument)(third_argument);\n```", "```js\nconst myFunction = (a, b, c) => { ... };\nconst myFixedFirst = (b, c) => myFunction(fixed_first_argument, b, c);\n\n// *and later...*\nmyFixedFirst(second_argument, third_argument);\n```", "```js\nconst _plainMap = demethodize(map);\nconst myMap = curry(_plainMap, 2);\nconst myMapX = curry(flipTwo(_plainMap));\n\nconst _plainReduce = demethodize(reduce);\nconst myReduce = curry(_plainReduce, 3);\nconst myReduceX = curry(flip3(_plainReduce));\n\nconst _plainFilter = demethodize(filter);\nconst myFilter = curry(_plainFilter, 2);\nconst myFilterX = curry(flipTwo(_plainFilter));\n\n// *...and more functions in the same vein*\n```", "```js\n let result = sumMany((9)(2)(3)(1)(4)(3)());\n // *22*\n```", "```js\n const makeBold = applyStyle(\"b\");\n document.getElementById(\"myCity\").innerHTML = \n makeBold(\"Montevideo\");\n // <b>Montevideo</b>, *to produce* Montevideo\n\n const makeUnderline = applyStyle(\"u\");\n document.getElementById(\"myCountry\").innerHTML = \n makeUnderline(\"Uruguay\");\n // <u>Uruguay</u>, *to produce* Uruguay\n```", "```js\n Function.prototype.curry = function() {\n // ...*your code goes here...*\n };\n\n const sum3 = (a, b, c) => 100 * a + 10 * b + c;\n sum3.curry()(1)(2)(4); // *124*\n\n const sum3C = sum3.curry()(2)(2);\n sum3C(9); // *229*\n```", "```js\n const make3 = (a, b, c) => String(100 * a + 10 * b + c);\n\n const make3c = curry(make3);\n console.log(make3c(1)(2)(3)); // 123\n\n const remake3 = uncurry(make3c, 3);\n console.log(remake3(1, 2, 3)); // 123\n```"]