- en: Chapter 4. Encapsulation of Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。数据的封装
- en: 'In this chapter, we will learn the different members of a class in Java 9 and
    how they are reflected in members of the instances generated from a class. We
    will work with instance fields, class fields, setters, getters, instance methods,
    and class methods. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Java 9中类的不同成员以及它们如何在从类生成的实例的成员中反映出来。我们将使用实例字段、类字段、setter、getter、实例方法和类方法。我们将：
- en: Understand the members that compose a class in Java 9
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Java 9中组成类的成员
- en: Declare immutable fields
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明不可变字段
- en: Work with setters and getters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用setter和getter
- en: Understand access modifiers in Java 9
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java 9中理解访问修饰符
- en: Combine setters, getters, and a related field
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合setter、getter和相关字段
- en: Transform values with setters and getters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用setter和getter转换值
- en: Use static fields and static methods to create values shared by all the instances
    of a class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态字段和静态方法来创建所有类实例共享的值
- en: Understanding members composing a class
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解组成类的成员
- en: So far, we have been working with a very simple `Rectangle` class. We created
    many instances of this class in JShell and we understood how the garbage collection
    works. Now, it is time to dive deeper into the different members that compose
    a class in Java 9.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用一个非常简单的`Rectangle`类。我们在JShell中创建了许多这个类的实例，并且理解了垃圾回收的工作原理。现在，是时候深入了解Java
    9中组成类的不同成员了。
- en: 'The following list enumerates the most common element types that we can include
    in a class definition in Java 9\. Each member includes its equivalent in other
    programming languages to make it easy to translate our experience with other object-oriented
    languages into Java 9\. We have already worked with a few of these members:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表列举了我们可以在Java 9类定义中包含的最常见元素类型。每个成员都包括其在其他编程语言中的等价物，以便于将我们在其他面向对象语言中的经验转化为Java
    9。我们已经使用了其中的一些成员：
- en: '**Constructors**: A class might define one or more constructors. They are equivalent
    to initializers in other programming languages.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数**：一个类可能定义一个或多个构造函数。它们等价于其他编程语言中的初始化器。'
- en: '**Class variables or class fields**: These variables are common to all the
    instances of the class, that is, their value is the same for all the instances.
    In Java 9, it is possible to access class variables from the class and from its
    instances. We don''t need to create a specific instance to access a class variable.
    Class variables are also known as static variables because they use the `static`
    modifier in their declarations. Class variables are equivalent to class attributes,
    class properties, and type properties in other programming languages.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类变量或类字段**：这些变量对类的所有实例都是共同的，也就是说，它们的值对所有实例都是相同的。在Java 9中，可以从类和其实例中访问类变量。我们不需要创建特定实例来访问类变量。类变量也被称为静态变量，因为它们在声明中使用`static`修饰符。类变量等价于其他编程语言中的类属性和类型属性。'
- en: '**Class methods**: These methods can be invoked with the class name. In Java
    9, it is possible to access class methods from the class and from its instances.
    We don''t need to create a specific instance to access a class method. Class methods
    are also known as static methods because they use the `static` modifier in their
    declarations. Class methods are equivalent to class functions and type methods
    in other programming languages. Class methods operate on a class as a whole, and
    have access to class variables, class constants, and other class methods, but
    they don''t have access to any instance members, such as instance fields or methods,
    because they operate at the class level with no instances at all. Class methods
    are useful when we want to include methods related to a class and we don''t want
    to generate an instance to call them.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类方法**：这些方法可以使用类名调用。在Java 9中，可以从类和其实例中访问类方法。我们不需要创建特定实例来访问类方法。类方法也被称为静态方法，因为它们在声明中使用`static`修饰符。类方法等价于其他编程语言中的类函数和类型方法。类方法作用于整个类，并且可以访问类变量、类常量和其他类方法，但它们无法访问任何实例成员，如实例字段或方法，因为它们在类级别上操作，根本没有实例。当我们想要包含与类相关的方法并且不想生成实例来调用它们时，类方法非常有用。'
- en: '**Constants**: When we declare class variables or class fields with the `final`
    modifier, we define constants whose value cannot be changed.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常量**：当我们用`final`修饰符声明类变量或类字段时，我们定义了值不可更改的常量。'
- en: '**Fields, member variables, instance variables, or instance fields**: We worked
    with these in the previous examples. Each instance of the class has its own distinct
    copies of the instance fields, with their own values. Instance fields are equivalent
    to attributes and instance properties in other programming languages.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字段、成员变量、实例变量或实例字段**：我们在之前的例子中使用了这些。类的每个实例都有自己独特的实例字段副本，具有自己的值。实例字段等价于其他编程语言中的属性和实例属性。'
- en: '**Methods or instance methods**: These methods require an instance to be invoked
    and they can access the fields for the specific instance. Instance methods are
    equivalent to instance functions in other programming languages.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方法或实例方法**：这些方法需要一个实例来调用，并且它们可以访问特定实例的字段。实例方法等价于其他编程语言中的实例函数。'
- en: '**Nested classes**: These classes are defined within another class. Static
    nested classes use the `static` modifier. Nested classes that do not use the `static`
    modifier are also known as **inner classes**. Nested classes are also known as
    nested types in other programming languages.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套类**：这些类在另一个类中定义。静态嵌套类使用`static`修饰符。不使用`static`修饰符的嵌套类也被称为**内部类**。嵌套类在其他编程语言中也被称为嵌套类型。'
- en: Declaring immutable fields
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明不可变字段
- en: Pokemon Go is a location-based augmented-reality game in which players use the
    mobile device's GPS capability to locate, capture, train, and make virtual creatures
    fight. This game had great success and popularized location-based and augmented-reality
    gaming. After its great success, imagine that we have to develop a Web Service
    that will be consumed by a similar game that makes virtual creatures battle.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Pokemon Go是一款基于位置的增强现实游戏，玩家使用移动设备的GPS功能来定位、捕捉、训练和让虚拟生物进行战斗。这款游戏取得了巨大的成功，并推广了基于位置和增强现实的游戏。在其巨大成功之后，想象一下我们必须开发一个Web服务，供类似的游戏使用，让虚拟生物进行战斗。
- en: We have to move to the world of virtual creatures. We will definitely have a
    `VirtualCreature` base class. Each specific type of virtual creature with unique
    characteristics that can participate in battles will be a subclass of `VirtualCreature`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须进入虚拟生物的世界。我们肯定会有一个`VirtualCreature`基类。每种特定类型的虚拟生物都具有独特的特征，可以参与战斗，将是`VirtualCreature`的子类。
- en: All the virtual creatures will have a name and they will be born in a specific
    year. The age is going to be extremely important for their performance in battles.
    Thus, our base class will have the `name` and `birthYear` fields that all the
    subclasses will inherit.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有虚拟生物都将有一个名字，并且它们将在特定年份出生。年龄对于它们在战斗中的表现将非常重要。因此，我们的基类将拥有`name`和`birthYear`字段，所有子类都将继承这些字段。
- en: When we design classes, we want to make sure that all the necessary data is
    available to the methods that will operate on this data. For this reason, we encapsulate
    data. However, we just want relevant information to be visible to the users of
    our classes that will create instances, change the values of accessible fields,
    and call the available methods. We want to hide or protect some data that is just
    needed for internal use, that is, for our methods. We don't want to make accidental
    changes to sensitive data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计类时，我们希望确保所有必要的数据对将操作这些数据的方法是可用的。因此，我们封装数据。然而，我们只希望相关信息对我们的类的用户可见，这些用户将创建实例，更改可访问字段的值，并调用可用的方法。我们希望隐藏或保护一些仅需要内部使用的数据，也就是说，对于我们的方法。我们不希望对敏感数据进行意外更改。
- en: 'For example, when we create a new instance of any virtual creature, we can
    use both its name and birth year as two parameters for the constructor. The constructor
    initializes the values of two properties: `name` and `birthYear`. The following
    lines show a sample code that declares the `VirtualCreature` class. The code file
    for the sample is included in the `java_9_oop_chapter_04_01` folder, in the `example04_01.java`
    file.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们创建任何虚拟生物的新实例时，我们可以将其名字和出生年份作为构造函数的两个参数。构造函数初始化了两个属性的值：`name`和`birthYear`。以下几行显示了声明`VirtualCreature`类的示例代码。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_01.java`文件中。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The next lines create two instances that initialize the values of the two fields
    and then use the `System.out.printf` method to display their values in JShell.
    The code file for the sample is included in the `java_9_oop_chapter_04_01` folder,
    in the `example04_01.java` file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行创建了两个实例，初始化了两个字段的值，然后使用`System.out.printf`方法在JShell中显示它们的值。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_01.java`文件中。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot shows the results of the declaration of the class
    and the execution of the previous lines in JShell:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中声明类和执行先前行的结果：
- en: '![Declaring immutable fields](img/00045.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![声明不可变字段](img/00045.jpeg)'
- en: We don't want a user of our `VirtualCreature` class to be able to change the
    name for a virtual creature after an instance is initialized because the name
    is not supposed to change. Well, some people change their names but this never
    happens with virtual creatures. There is a simple way to achieve this goal in
    our previously declared class. We can add the `final` keyword before the type
    (`String`) to define an immutable `name` field of type `String`. We can also add
    the `final` keyword before the type (`int`) when we define the `birthYear` field
    because the birth year will never change after we initialize a virtual creature
    instance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望`VirtualCreature`类的用户能够在初始化实例后更改虚拟生物的名字，因为名字不应该改变。好吧，有些人改名字，但虚拟生物永远不会这样做。在我们之前声明的类中，有一种简单的方法可以实现这个目标。我们可以在类型（`String`）之前添加`final`关键字，以定义一个不可变的`name`字段，类型为`String`。当我们定义`birthYear`字段时，也可以在类型（`int`）之前添加`final`关键字，因为在初始化虚拟生物实例后，出生年份将永远不会改变。
- en: 'The following lines show the new code that declares the `VirtualCreature` class
    with two immutable instance fields: `name` and `birthYear`. Note that the constructor
    code doesn''t need to be changed, and it is possible to initialize the two immutable
    instance fields with the same code. The code file for the sample is included in
    the `java_9_oop_chapter_04_01` folder, in the `example04_02.java` file.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了声明`VirtualCreature`类的新代码，其中包含两个不可变的实例字段：`name`和`birthYear`。请注意，构造函数的代码不需要更改，并且可以使用相同的代码初始化这两个不可变的实例字段。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_02.java`文件中。
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Immutable instance fields are also known as non-mutating instance fields.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变的实例字段也被称为非变异的实例字段。
- en: The next lines create an instance that initializes the values of the two immutable
    instance fields and then use the `System.out.printf` method to display their values
    in JShell. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_02.java` file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行创建了一个实例，初始化了两个不可变的实例字段的值，然后使用`System.out.printf`方法在JShell中显示它们的值。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_02.java`文件中。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The next two lines of code try to assign a new value to the `name` and `birthYear`
    immutable instance fields. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_03.java` file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行代码尝试为`name`和`birthYear`不可变的实例字段分配新值。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_03.java`文件中。
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The two lines will fail to do so because Java doesn''t allow us to assign a
    value to a field declared with the `final` modifier that transforms it into an
    immutable field. The next screenshot shows the errors displayed in JShell after
    each line that tries to set a new value to the immutable fields:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行将无法成功，因为Java不允许我们为使用`final`修饰符声明的字段赋值，这会将其转换为不可变字段。下一张截图显示了在每行尝试为不可变字段设置新值后在JShell中显示的错误：
- en: '![Declaring immutable fields](img/00046.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![声明不可变字段](img/00046.jpeg)'
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When we use the `final` keyword to declare an instance field, we can initialize
    the field but it becomes immutable, that is, a constant, after its initialization.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`final`关键字声明一个实例字段时，我们可以初始化该字段，但在初始化后，它将变为不可变的，也就是常量。
- en: Working with setters and getters
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用setter和getter
- en: So far, we have been working with fields to encapsulate data in our instances.
    We could access the fields without any kind of restrictions as member variables
    for an instance. However, as it happens sometimes in real-world situations, restrictions
    are necessary to avoid serious problems. Sometimes, we want to restrict access
    or transform specific fields into read-only fields. We can combine the access
    restrictions to an underlying field with methods known as setters and getters.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用字段来封装实例中的数据。我们可以像实例的成员变量一样访问这些字段，没有任何限制。然而，有时在现实世界的情况下，需要限制以避免严重问题。有时，我们希望限制访问或将特定字段转换为只读字段。我们可以将对底层字段的访问限制与称为setter和getter的方法相结合。
- en: '**Setters** are methods that allow us to control how values are set; that is,
    these methods are used to change the values of related fields. **Getters** allow
    us to control the values that we return when we want to retrieve the value for
    a related field. Getters don''t change the values of related fields.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**Setter**是允许我们控制如何设置值的方法；也就是说，这些方法用于改变相关字段的值。**Getter**允许我们控制在想要检索相关字段的值时返回的值。Getter不会改变相关字段的值。'
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While some frameworks such as JavaBeans force you to work with setters and getters
    for each related field to be accessible, in other cases, setters and getters won't
    be necessary. In the next examples we will work with mutable objects. In the next
    chapter, [Chapter 5](part0052_split_000.html#1HIT81-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 5. Mutable and Immutable Classes"), *Mutable and Immutable Classes*,
    we will work with both mutable and immutable objects. When working with immutable
    objects, getters and setters are useless.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有些框架（比如JavaBeans）强制你使用setter和getter来让每个相关字段都可以访问，但在其他情况下，setter和getter是不必要的。在接下来的例子中，我们将使用可变对象。在下一章，[第5章](part0052_split_000.html#1HIT81-bc1530b4c4784270ae8a31a7038f8341
    "第5章。可变和不可变类")，“可变和不可变类”，我们将同时使用可变和不可变对象。当使用不可变对象时，getter和setter是无用的。
- en: As previously explained, we don't want a user of our `VirtualCreature` class
    to be able to change the birth year for a virtual creature after an instance is
    initialized because the virtual creature won't be born again at a different date.
    In fact, we want to calculate and make the age for the virtual creature available
    to users. Because we only take into account the birth year, we will calculate
    an approximated age. We keep the example simple to keep the focus on the getters
    and setters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们不希望`VirtualCreature`类的用户能够在初始化实例后更改虚拟生物的出生年份，因为虚拟生物不会在不同日期再次出生。实际上，我们希望计算并使虚拟生物的年龄对用户可用。因为我们只考虑出生年份，所以我们将计算一个近似的年龄。我们保持示例简单，以便专注于getter和setter。
- en: We can define a getter method called `getAge` without defining a setter method.
    This way, it is possible to retrieve the age for the virtual creature, but we
    cannot change it because there isn't a setter method. The getter method returns
    the result of calculating the age for the virtual creature age based on the current
    year and the value of the `birthYear` immutable instance field.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个名为`getAge`的getter方法，而不定义setter方法。这样，我们可以检索虚拟生物的年龄，但我们无法改变它，因为没有setter方法。getter方法返回基于当前年份和`birthYear`不可变实例字段的值计算出的虚拟生物年龄的结果。
- en: The following lines show the new version of the `VirtualCreature` class with
    the new `getAge` method. Notice that it is necessary to import `java.time.Year`
    to use the `Year` class that was introduced in Java 8\. The code for the `getAge`
    method is highlighted in the next lines. The method calls `Year.now().getValue`
    to retrieve the year component for the current date and returns the difference
    between the current year and the value of the `birthYear` field. The code file
    for the sample is included in the `java_9_oop_chapter_04_01` folder, in the `example04_04.java`
    file.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的行显示了具有新`getAge`方法的`VirtualCreature`类的新版本。请注意，需要导入`java.time.Year`以使用在Java
    8中引入的`Year`类。`getAge`方法的代码在下面的行中突出显示。该方法调用`Year.now().getValue`来检索当前日期的年份组件，并返回当前年份与`birthYear`字段的值之间的差值。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中，名为`example04_04.java`。
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The next lines create an instance that initializes the values of the two immutable
    instance fields and then use the `System.out.printf` method to display the value
    returned by the `getAge` method in JShell. Enter the lines after the code that
    creates the new version of the `VirtualCreature` class. The code file for the
    sample is included in the `java_9_oop_chapter_04_01` folder, in the `example04_04.java`
    file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '下面的行创建一个实例，初始化了两个不可变实例字段的值，然后使用`System.out.printf`方法在JShell中显示`getAge`方法返回的值。在创建`VirtualCreature`类的新版本的代码之后输入这些行。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中，名为`example04_04.java`。 '
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next screenshot shows the results of executing the previous lines in JShell:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图显示了在JShell中执行前面几行的结果：
- en: '![Working with setters and getters](img/00047.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![使用setter和getter](img/00047.jpeg)'
- en: After a few meetings with experts in virtual creatures, we realize that some
    of them go to a planet to evolve and are born again from an egg after evolving.
    Because the evolution happens in a different planet, the birth year for the virtual
    creature changes to have an equivalent birth year in the Earth. Thus, it is necessary
    to allow the user to customize either the age or the birth year for a virtual
    creature. We will add a setter method with code that calculates the birth year
    based on the specified age and assigns this value to the `birthYear` field. First,
    we must remove the `final` keyword when we declare the `birthYear` field because
    we want it to become a mutable field.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在与虚拟生物专家的几次会议后，我们意识到其中一些虚拟生物会前往其他星球进化，并在进化后从蛋中再次诞生。由于进化发生在不同的星球，虚拟生物的出生年份会改变，以在地球上具有等效的出生年份。因此，有必要允许用户自定义虚拟生物的年龄或出生年份。我们将添加一个带有计算出生年份的代码的setter方法，并将这个值分配给`birthYear`字段。首先，我们必须在声明`birthYear`字段时删除`final`关键字，因为我们希望它成为一个可变字段。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There is another way of working with the evolution of a virtual creature. We
    can create another instance that represents the evolved virtual creature. We will
    use this immutable approach in the next chapter, [Chapter 5](part0052_split_000.html#1HIT81-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 5. Mutable and Immutable Classes"), *Mutable and Immutable Classes*.
    In this case, we will work with a mutable object. After we understand all the
    possibilities, we can decide the best option based on our specific needs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种处理虚拟生物进化的方法。我们可以创建另一个实例来代表进化后的虚拟生物。我们将在下一章[第5章](part0052_split_000.html#1HIT81-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 5. Mutable and Immutable Classes")中使用这种不可变的方法，*可变和不可变的类*。在这种情况下，我们将使用一个可变对象。在了解所有可能性之后，我们可以根据我们的具体需求决定最佳选项。
- en: The following lines show the new version of the `VirtualCreature` class with
    the new `setAge` method. The code for the `setAge` method is highlighted in the
    next lines. The method receives the new age we want for the virtual creature in
    the `age` parameter. The code calls `Year.now().getValue` to retrieve the year
    component for the current date and assigns the difference between the current
    year and the value received in `age`. This way, the `birthYear` field will save
    the year in which the virtual creature was born based on the received `age` value.
    The code file for the sample is included in the `java_9_oop_chapter_04_01` folder,
    in the `example04_05.java` file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了带有新`setAge`方法的`VirtualCreature`类的新版本。`setAge`方法的代码在下面的代码中突出显示。该方法接收我们想要为虚拟生物设置的新年龄，并调用`Year.now().getValue`来获取当前日期的年份组件，并将当前年份与`age`参数中接收到的值之间的差值分配给`birthYear`字段。这样，`birthYear`字段将根据接收到的`age`值保存虚拟生物出生的年份。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_05.java`文件中。
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The next lines create two instances of the new version of the `VirtualCreature`
    class, call the `setAge` method with the desired age for the virtual creature,
    and then use the `System.out.printf` method to display the value returned by the
    `getAge` method and the `birthYear` field in JShell. Enter the lines after the
    code that creates the new version of the `VirtualCreature` class. The code file
    for the sample is included in the `java_9_oop_chapter_04_01` folder, in the `example04_05.java`
    file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码创建了`VirtualCreature`类的新版本的两个实例，调用`setAge`方法并为虚拟生物设置所需的年龄，然后使用`System.out.printf`方法在JShell中显示`getAge`方法返回的值和`birthYear`字段的值。在创建`VirtualCreature`类的新版本的代码之后输入这些代码。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_05.java`文件中。
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As a result of calling the `setAge` method with a new age value, the method
    changes the value of the `birthYear` field. Based on the current year value, the
    results of running the code will be different. The next screenshot shows the results
    of executing the previous lines in JShell:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`setAge`方法并传入新的年龄值后，该方法会改变`birthYear`字段的值。根据当前年份的值，运行代码的结果将会不同。下一张截图显示了在JShell中执行前几行代码的结果：
- en: '![Working with setters and getters](img/00048.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![使用setter和getter](img/00048.jpeg)'
- en: Both the getter and setter methods use the same code to retrieve the current
    year. We can add a new method that retrieves the current year and call it from
    both the `getAge` and `setAge` methods. In this case, it is just a line of code,
    but the new method provides us with an example of how we can add methods that
    will be consumed in our class and help other methods to do their job. Later, we
    will learn how to avoid these methods being called from an instance because they
    are intended for internal use only.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: getter和setter方法都使用相同的代码来获取当前年份。我们可以添加一个新的方法来获取当前年份，并从`getAge`和`setAge`方法中调用它。在这种情况下，这只是一行代码，但是新方法为我们提供了一个示例，说明我们可以添加方法来在我们的类中使用，并帮助其他方法完成它们的工作。稍后，我们将学习如何避免从实例中调用这些方法，因为它们只用于内部使用。
- en: The following lines show the new version of the `SuperHero` class with the new
    `getCurrentYear` method. The new code for the `getAge` and `setAge` methods calls
    the new `getCurrentYear` method instead of repeating code that was intended to
    retrieve the current year. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_06.java` file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了带有新`getCurrentYear`方法的`SuperHero`类的新版本。`getAge`和`setAge`方法的新代码调用了新的`getCurrentYear`方法，而不是重复用于获取当前年份的代码。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_06.java`文件中。
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The next lines create two instances of the `VirtualCreature` class, call the
    `setAge` method with the desired age for the virtual creature, and then use the
    `System.out.printf` method to display the value returned by the `getAge` method
    and the `birthYear` field in JShell. Enter the lines after the code that creates
    the new version of the `VirtualCreature` class. The code file for the sample is
    included in the `java_9_oop_chapter_04_01` folder, in the `example04_06.java`
    file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码创建了`VirtualCreature`类的两个实例，调用`setAge`方法设置虚拟生物的年龄，然后使用`System.out.printf`方法在JShell中显示`getAge`方法返回的值和`birthYear`字段的值。在创建`VirtualCreature`类的新版本的代码之后输入这些行。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_06.java`文件中。
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next screenshot shows the results of executing the previous lines in JShell:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图显示了在JShell中执行前面几行的结果：
- en: '![Working with setters and getters](img/00049.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![使用setter和getter](img/00049.jpeg)'
- en: Exploring access modifiers in Java 9
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Java 9中探索访问修饰符
- en: The previously declared `VirtualCreature` class exposes all of its members (fields
    and methods) without any kind of restriction because we declared them without
    using any access modifier. Thus, the user of our class can access any of the fields
    and call any of the declared methods after the user creates an instance of the
    class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 先前声明的`VirtualCreature`类公开了所有成员（字段和方法），没有任何限制，因为我们声明它们时没有使用任何访问修饰符。因此，我们的类的用户可以在创建类的实例后访问任何字段并调用任何已声明的方法。
- en: Java 9 allows us to control access to members of a call by using access level
    modifiers. Different keywords allow us to control which code has access to a specific
    member of a class. So far, we could access fields and methods within a class definition
    and outside of a class declaration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9允许我们通过使用访问级别修饰符来控制对调用成员的访问。不同的关键字允许我们控制哪些代码可以访问类的特定成员。到目前为止，我们可以在类定义内部和类声明之外访问字段和方法。
- en: 'We can use any of the following access modifiers instead of `public` to restrict
    access to any field:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下任何访问修饰符来限制对任何字段的访问，而不是`public`：
- en: '`protected`: Java doesn''t allow users to access the member outside of the
    class definition. Only the code within the class or its derived classes can access
    the field. Any subclass of a class that declares a member with the `protected`
    access modifier will be able to access the member.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`：Java不允许用户在类定义之外访问成员。只有类内部或其派生类的代码才能访问字段。声明了带有`protected`访问修饰符的成员的类的任何子类都可以访问该成员。'
- en: '`private`: Java doesn''t allow users to access the field outside of the class
    definition. Only the code within the class can access the field. Its derived classes
    cannot access the field. Thus, any subclass of a class that declares a member
    with the `private` access modifier won''t be able to access the member.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`：Java不允许用户在类定义之外访问字段。只有类内部的代码才能访问字段。它的派生类无法访问字段。因此，声明了带有`private`访问修饰符的成员的类的任何子类将无法访问该成员。'
- en: The following line shows how we can change the declaration of the `birthYear`
    instance field to a `protected` field. We just need to add the `protected` keyword
    to the field declaration.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行显示了如何将`birthYear`实例字段的声明更改为`protected`字段。我们只需要在字段声明中添加`protected`关键字。
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Whenever we use the `protected` access modifier in a field declaration, we restrict
    access to this field to the code written within the class definition and within
    subclasses. Java 9 generates a real shield for the fields marked as `protected`
    and there is no way to access them outside of the explained boundaries.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在字段声明中使用`protected`访问修饰符时，我们限制对该字段的访问仅限于类定义内部和子类内部编写的代码。Java 9为标记为`protected`的字段生成了真正的保护，没有办法在解释的边界之外访问它们。
- en: The following line shows how we can change the declaration of the `birthYear`
    protected instance field to a `private` field. We replace the `protected` access
    modifier with `private`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行显示了如何将`birthYear`受保护的实例字段的声明更改为`private`字段。我们用`private`替换了`protected`访问修饰符。
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Whenever we use the `private` access modifier in a field declaration, we restrict
    access to this field to the code written within the class definition and within
    subclasses. Java generates a real shield for the fields marked as `private` and
    there is no way to access them outside of the class definition. The restriction
    also applies to subclasses, and therefore, only the code written within the class
    can access attributes marked as private.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在字段声明中使用`private`访问修饰符时，我们限制对该字段的访问仅限于类定义内部和子类内部编写的代码。Java为标记为`private`的字段生成了真正的保护，没有办法在类定义之外访问它们。这个限制也适用于子类，因此，只有类内部编写的代码才能访问标记为私有的属性。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We can apply the previously explained access modifiers for any type member,
    including class variables, class methods, constants, fields, methods, and nested
    classes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对任何类型成员应用先前解释的访问修饰符，包括类变量、类方法、常量、字段、方法和嵌套类。
- en: Combining setters, getters, and fields
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合setter、getter和字段
- en: Sometimes, we want to have more control over the values that are set to related
    fields and retrieved from them, and we can take advantage of getters and setters
    to do so. We can combine a getter, a setter, a related field that stores a computed
    value, and the access protection mechanisms to prevent the user from making changes
    to the related field. This way, we will force the user to always use the getters
    and setters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望对设置到相关字段和从中检索的值有更多的控制，并且我们可以利用getter和setter来做到这一点。我们可以结合使用getter、setter、存储计算值的相关字段以及访问保护机制，防止用户对相关字段进行更改。这样，我们将强制用户始终使用getter和setter。
- en: Virtual creatures love any kind of hat. The hat for a virtual creature can change
    over time. We have to make sure that the hat's name is in capital letters, that
    is, an uppercased `String`. We will define a `setHat` method that always generates
    an uppercased `String` from the received `String` and stores it in a private `hat`
    field.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟生物喜欢任何类型的帽子。虚拟生物的帽子可以随着时间改变。我们必须确保帽子的名称是大写字母，也就是大写的`String`。我们将定义一个`setHat`方法，始终从接收到的`String`生成一个大写的`String`并将其存储在私有的`hat`字段中。
- en: We will provide a `getHat` method to retrieve the value stored in the private
    `hat` field. The following lines show a new version of the `VirtualCreature` class
    that adds a `hat` private instance field and the `getHat` and `setHat` methods.
    We use the previously learned access modifiers for the different members of the
    class. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_07.java` file.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提供一个`getHat`方法来检索存储在私有`hat`字段中的值。下面的几行显示了`VirtualCreature`类的新版本，其中添加了一个`hat`私有实例字段和`getHat`和`setHat`方法。我们使用之前学到的访问修饰符来为类的不同成员设置。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中，名为`example04_07.java`。
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you work with specific early versions of JDK, when you enter the previous
    code in JShell, you might see the following warning message:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用特定的JDK早期版本，在JShell中输入前面的代码时，你可能会看到以下警告消息：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: JShell doesn't allow us to use access modifiers in top-level declarations, such
    as a class declaration. However, we specify the access modifier because we want
    to code as if we were writing the class declaration outside of JShell. JShell
    simply ignores the `public` access modifier for the class and some versions of
    the JDK that incuded JShell made the REPL display the previously shown warning
    message. If you see these messages, you should upgrade the installed JDK to the
    newest version that doesn't display the warning messages anymore.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: JShell不允许我们在顶层声明中使用访问修饰符，比如类声明。然而，我们指定访问修饰符是因为我们希望编写的代码就好像我们是在JShell之外编写类声明一样。JShell只是忽略了类的`public`访问修饰符，而一些包含JShell的JDK版本会在REPL中显示先前显示的警告消息。如果你看到这些消息，你应该升级已安装的JDK到不再显示警告消息的最新版本。
- en: We declared both the `birthyear` and `hat` instance fields as `private`. We
    declared the `getCurrentYear` method as `protected`. When a user creates an instance
    of the `VirtualCreature` class, the user won't be able to access any of these
    `private` members. This way, the `private` members will be hidden for those who
    create instances of the `VirtualCreature` class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`birthyear`和`hat`实例字段都声明为`private`。我们将`getCurrentYear`方法声明为`protected`。当用户创建`VirtualCreature`类的实例时，用户将无法访问这些`private`成员。这样，`private`成员将对创建`VirtualCreature`类实例的用户隐藏起来。
- en: 'We declared `name` as a `public` immutable instance field. We declared the
    following methods as `public`: `getAge`, `setAge`, `getHat`, and `setHat`. When
    a user creates an instance of the `VirtualCreature` class, he will be able to
    access all of these `public` members.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`name`声明为`public`的不可变实例字段。我们将以下方法声明为`public`：`getAge`、`setAge`、`getHat`和`setHat`。当用户创建`VirtualCreature`类的实例时，他将能够访问所有这些`public`成员。
- en: The constructor added a new argument that provides an initial value for the
    new `hat` field. The code in the constructor calls the `setHat` method with the
    received `hat` argument as a parameter to make sure that an uppercase `String`
    is generated from the received `String` and the resulting `String` is assigned
    to the `hat` field.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数添加了一个新的参数，为新的`hat`字段提供了一个初始值。构造函数中的代码调用`setHat`方法，将接收到的`hat`参数作为参数，以确保从接收到的`String`生成一个大写的`String`，并将生成的`String`分配给`hat`字段。
- en: The next lines create two instances of the `VirtualCreature` class, use the
    `printf` method to display the value returned by the `getHat` method, call the
    `setHat` method with the desired new hat for the virtual creature, and then use
    the `System.out.printf` method to display the value returned by the `getHat` method
    again. Enter the lines after the code that creates the new version of the `VirtualCreature`
    class. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_07.java` file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的几行创建了`VirtualCreature`类的两个实例，使用`printf`方法显示`getHat`方法返回的值，调用`setHat`方法设置虚拟生物的新帽子，然后使用`System.out.printf`方法再次显示`getHat`方法返回的值。在创建`VirtualCreature`类的新版本的代码之后输入这些行。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中，名为`example04_07.java`。
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The next screenshot shows the results of executing the previous lines in JShell:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张截图显示了在JShell中执行前面几行的结果：
- en: '![Combining setters, getters, and fields](img/00050.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![组合setter、getter和字段](img/00050.jpeg)'
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We can combine the getter and setter methods, along with access protection mechanisms
    and a related field that acts as an underlying field, to have absolute control
    over how values are set to and retrieved from the underlying field in mutable
    objects. However, we must make sure that the initialization must also use the
    setter method, as we did when we set the initial value received in the constructor.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以结合getter和setter方法，以及访问保护机制和作为底层字段的相关字段，来绝对控制可变对象中的值如何被设置和检索。然而，我们必须确保初始化也必须使用setter方法，就像我们在构造函数中设置初始值时所做的那样。
- en: The next lines will try to access a private field and a private method for the
    instances of the `VirtualCreature` class we have created. Both lines will fail
    to compile because we cannot access private members in an instance. The first
    line tries to access the `hat` instance field and the second line tries to call
    the `getCurrentYear` instance method. The code file for the sample is included
    in the `java_9_oop_chapter_04_01` folder, in the `example04_08.java` file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的几行将尝试访问我们创建的`VirtualCreature`类实例的私有字段和私有方法。这两行都将无法编译，因为我们不能在实例中访问私有成员。第一行尝试访问`hat`实例字段，第二行尝试调用`getCurrentYear`实例方法。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中，名为`example04_08.java`。
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The next screenshot shows the error messages generated in JShell when we try
    to execute the previous lines.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕截图显示了在JShell中执行前面几行时生成的错误消息。
- en: '![Combining setters, getters, and fields](img/00051.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![结合setter、getter和字段](img/00051.jpeg)'
- en: Transforming values with setters and getters
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用setter和getter转换值
- en: We can define a setter method that transforms a received value to a valid value
    for a related field. The getter method would just need to return the value of
    the related field. The user will only be able to work with the setter and getter
    methods and our related field will always have a valid value. This way, we can
    make sure that whenever we require the value, we will retrieve a valid value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个setter方法，将接收到的值转换为相关字段的有效值。getter方法只需要返回相关字段的值。用户只能使用setter和getter方法，我们的相关字段将始终具有有效值。这样，我们可以确保每当需要该值时，我们将检索到有效的值。
- en: Each virtual creature has a visibility level that determines how easy it is
    for anybody to visualize the virtual creature's body. We will add a private `visibilityLevel`
    field, a `setVisibility` method, and a `getVisibility` method. We will change
    the constructor code to call the `setVisiblity` method to set an initial value
    for the `visibilityLevel` field.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个虚拟生物都有一个可见级别，确定任何人能够多容易地看到虚拟生物的身体。我们将添加一个私有的`visibilityLevel`字段，一个`setVisibility`方法和一个`getVisibility`方法。我们将更改构造函数代码，调用`setVisiblity`方法来为`visibilityLevel`字段设置初始值。
- en: We want to make sure that the visibility level is a number from `0` to `100`
    (inclusive). Thus, we will code the setter method to transform the values lower
    than `0` to `0` and values higher than `100` to `100`. The `setVisibility` method
    saves either the transformed or the original value that is in a valid range in
    the related private `visibilityLevel` field.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确保可见级别是一个从`0`到`100`（包括）的数字。因此，我们将编写setter方法来将低于`0`的值转换为`0`，将高于`100`的值转换为`100`。`setVisibility`方法保存相关私有`visibilityLevel`字段中的转换后或原始值，该值在有效范围内。
- en: The edited lines and the new lines are highlighted. The code file for the sample
    is included in the `java_9_oop_chapter_04_01` folder, in the `example04_09.java`
    file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑过的行和新行已经高亮显示。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_09.java`文件中。
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The next lines create an instance of `VirtualCreature` that specifies `150`
    as the value for the `visibilityLevel` argument. Then, the next line uses the
    `System.out.printf` method to display the value returned by the `getVisibilityLevel`
    method in JShell. Then, we call `setVisibilityLevel` and `getVisibilityLevel`
    three times, to set values to `visibilityLevel,` and then check the values that
    were finally set. Enter the lines after the code that creates the new version
    of the `VirtualCreature` class. The code file for the sample is included in the
    `java_9_oop_chapter_04_01` folder, in the `example04_09.java` file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的行创建了一个`VirtualCreature`的实例，指定`150`作为`visibilityLevel`参数的值。然后，下一行使用`System.out.printf`方法在JShell中显示`getVisibilityLevel`方法返回的值。然后，我们调用`setVisibilityLevel`和`getVisibilityLevel`三次，设置`visibilityLevel`的值，然后检查最终设置的值。在创建`VirtualCreature`类的新版本的代码之后输入这些行。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_09.java`文件中。
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The constructor calls the `setVisibilityLevel` method to set the initial value
    for the `visibilityLevel` related private field, and therefore, the method makes
    sure that the value is in the valid range. The code specified `150` but the maximum
    value is `100`, and therefore, the `setVisibilityLevel` assigned `100` to the
    `visibilityLevel` related private field.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用`setVisibilityLevel`方法来为`visibilityLevel`相关的私有字段设置初始值，因此，该方法确保值在有效范围内。代码指定了`150`，但最大值是`100`，因此`setVisibilityLevel`将`100`分配给了`visibilityLevel`相关的私有字段。
- en: 'After we called the `setVisibilityLevel` with `-6` as an argument, we printed
    the value returned by `getVisibilityLevel` and the result was `0`. After we specified
    `320`, the actual printed value was `100`. Finally, after we specified `25`, the
    actual printed value was `25`. The next screenshot shows the results of executing
    the previous lines in JShell:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用`-6`作为参数调用`setVisibilityLevel`后，我们打印了`getVisibilityLevel`返回的值，结果是`0`。在我们指定`320`后，实际打印的值是`100`。最后，在我们指定`25`后，实际打印的值是`25`。下一个屏幕截图显示了在JShell中执行前面几行的结果：
- en: '![Transforming values with setters and getters](img/00052.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![使用setter和getter转换值](img/00052.jpeg)'
- en: Using static fields to provide class-level values
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态字段提供类级别的值
- en: 'Sometimes, all the members of a class share the same attribute, and we don''t
    need to have a specific value for each instance. For example, virtual creature
    types have the following profile values:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，类的所有成员共享相同的属性，我们不需要为每个实例设置特定的值。例如，虚拟生物类型具有以下配置值：
- en: Attack power
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击力
- en: Defense power
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防御力
- en: Special attack power
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊攻击力
- en: Special defense power
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特殊防御力
- en: Average speed
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平均速度
- en: Catch rate
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕捉率
- en: Growth rate
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增长率
- en: 'A first approach we might think useful for this situation is to define the
    following class constants to store the values that are shared by all the instances:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，我们可能认为有用的第一种方法是定义以下类常量来存储所有实例共享的值：
- en: '`ATTACK_POWER`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ATTACK_POWER`'
- en: '`DEFENSE_POWER`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEFENSE_POWER`'
- en: '`SPECIAL_ATTACK_POWER`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPECIAL_ATTACK_POWER`'
- en: '`SPECIAL_DEFENSE_POWER`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SPECIAL_DEFENSE_POWER`'
- en: '`AVERAGE_SPEED`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AVERAGE_SPEED`'
- en: '`CATCH_RATE`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATCH_RATE`'
- en: '`GROWTH_RATE`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GROWTH_RATE`'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the usage of uppercase and words separated by underscores (`_`) for class
    constant names. This is a naming convention in Java 9.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Java 9中，类常量名称使用大写字母和下划线（`_`）分隔单词。这是一种命名约定。
- en: The following lines show a new version of the `VirtualCreature` class that defines
    the seven previously listed class constants with the `public` access modifier.
    Notice that the combination of the `final` and `static` keywords makes them class
    constants. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_10.java` file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`VirtualCreature`类的新版本，该版本使用`public`访问修饰符定义了先前列出的七个类常量。请注意，`final`和`static`关键字的组合使它们成为类常量。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_10.java`文件中。
- en: '[PRE19]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The code initializes each class constant in the same line that declares them.
    The following lines print the value of the previously declared `SPECIAL_ATTACK_POWER`
    and `SPECIAL_DEFENSE_POWER` class constants. Notice that we didn't create any
    instance of the `VirtualCreature` class and that we specified the class constant
    name after the class name and a dot (`.`). The code file for the sample is included
    in the `java_9_oop_chapter_04_01` folder, in the `example04_10.java` file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在同一行中初始化了每个类常量。以下行打印了先前声明的`SPECIAL_ATTACK_POWER`和`SPECIAL_DEFENSE_POWER`类常量的值。请注意，我们没有创建`VirtualCreature`类的任何实例，并且在类名和点(`.`)之后指定了类常量名称。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_10.java`文件中。
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Java 9 allows us to access a class constant from an instance, and therefore,
    we can use either the class name or an instance to access a class constant. The
    following line creates an instance of the new version of the `VirtualCreature`
    class named `golbat` and prints the value of the `GROWTH_RATE` class constant,
    accessed from this new instance. The code file for the sample is included in the
    `java_9_oop_chapter_04_01` folder, in the `example04_10.java` file.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9允许我们从实例中访问类常量，因此，我们可以使用类名或实例来访问类常量。以下行创建了一个名为`golbat`的新版本`VirtualCreature`类的实例，并打印了从这个新实例访问的`GROWTH_RATE`类常量的值。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_10.java`文件中。
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The next screenshot shows the results of executing the previous lines in JShell.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕截图显示了在JShell中执行先前行的结果。
- en: '![Using static fields to provide class-level values](img/00053.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![使用静态字段提供类级值](img/00053.jpeg)'
- en: Using static methods to provide overridable class-level values
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态方法提供可重写的类级值
- en: 'Class constants have a great limitation: we cannot provide new values to them
    in future subclasses of the `VirtualCreature` class that represent specific types
    of virtual creatures. It makes sense, because they are constants. These subclasses
    need to set a different value for `ATTACK_POWER` or `AVERAGE_SPEED`. Instead of
    working with class constants, we can create the following class methods that return
    the average values for each profile value. We will be able to make these methods
    return a different value in subclasses of the `VirtualCreature` class.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类常量有一个很大的限制：我们不能在代表特定类型的虚拟生物的`VirtualCreature`类的未来子类中为它们提供新值。这是有道理的，因为它们是常量。这些子类需要为`ATTACK_POWER`或`AVERAGE_SPEED`设置不同的值。我们可以创建以下类方法来返回每个配置文件值的平均值，而不是使用类常量。我们将能够使这些方法在`VirtualCreature`类的子类中返回不同的值。
- en: '`getAttackPower`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAttackPower`'
- en: '`getDefensePower`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDefensePower`'
- en: '`getSpecialAttackPower`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSpecialAttackPower`'
- en: '`getSpecialDefensePower`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSpecialDefensePower`'
- en: '`getAverageSpeed`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAverageSpeed`'
- en: '`getCatchRate`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCatchRate`'
- en: '`getGrowthRate`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getGrowthRate`'
- en: The following lines show a new version of the `VirtualCreature` class that defines
    the seven previously listed class methods with the `public` access modifier. Notice
    that the usage of the `static` keyword in the method declarations makes them class
    methods. The code file for the sample is included in the `java_9_oop_chapter_04_01`
    folder, in the `example04_11.java` file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`VirtualCreature`类的新版本，该版本使用`public`访问修饰符定义了先前列出的七个类方法。请注意，方法声明中`static`关键字的使用使它们成为类方法。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_11.java`文件中。
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The following lines print the value returned by the previously declared `getSpecialAttackPower`
    and `getSpecialDefensePower` class methods. Notice that we didn't create any instance
    of the `VirtualCreature` class and that we specified the class method name after
    the class name and a dot (`.`). The code file for the sample is included in the
    `java_9_oop_chapter_04_01` folder, in the `example04_11.java` file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行打印了先前声明的`getSpecialAttackPower`和`getSpecialDefensePower`类方法返回的值。请注意，我们没有创建`VirtualCreature`类的任何实例，并且在类名和点(`.`)之后指定了类方法名称。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_11.java`文件中。
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As happened with class constants, Java 9 allows us to access a class method
    from an instance, and therefore, we can use either the class name or an instance
    to access a class method. The following line creates an instance of the new version
    of the `VirtualCreature` class named `vulpix` and prints the value returned by
    the `getGrowthRate` class method, accessed from this new instance. The code file
    for the sample is included in the `java_9_oop_chapter_04_01` folder, in the `example04_11.java`
    file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与类常量一样，Java 9允许我们从实例中访问类方法，因此，我们可以使用类名或实例来访问类方法。以下行创建了一个名为`vulpix`的新版本`VirtualCreature`类的实例，并打印了从这个新实例访问的`getGrowthRate`类方法返回的值。示例的代码文件包含在`java_9_oop_chapter_04_01`文件夹中的`example04_11.java`文件中。
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next screenshot shows the results of executing the previous lines in JShell:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个屏幕截图显示了在JShell中执行先前行的结果：
- en: '![Using static methods to provide overridable class-level values](img/00054.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![使用静态方法提供可重写的类级值](img/00054.jpeg)'
- en: Test your knowledge
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'We use the `static` keyword followed by a method declaration to define:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`static`关键字后跟方法声明来定义：
- en: An instance method.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例方法。
- en: A class method.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个类方法。
- en: A class constant.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个类常量。
- en: 'We use the `final` static keywords followed by an initialized variable declaration
    to define a:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`final` static关键字后跟初始化的变量声明来定义：
- en: Class constant.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类常量。
- en: Class variable.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类变量。
- en: Instance constant.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例常量。
- en: 'A class constant:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类常量：
- en: Has its own and independent value for each instance of the class.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于类的每个实例都有自己独立的值。
- en: Has the same value for all the instances of the class.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于类的所有实例具有相同的值。
- en: Has the same value for all the instances of a class, unless it is accessed through
    the class name followed by a dot (`.`) and the constant name.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非通过类名后跟一个点（`.`）和常量名来访问，否则对于类的所有实例具有相同的值。
- en: 'An instance field:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个实例字段：
- en: Has its own and independent value for each instance of the class.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于类的每个实例都有自己独立的值。
- en: Has the same value for all the instances of the class.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于类的所有实例具有相同的值。
- en: Has the same value for all the instances of a class, unless it is accessed through
    the class name followed by a dot (`.`) and the instance field name.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除非通过类名后跟一个点（`.`）和实例字段名来访问，否则对于类的所有实例具有相同的值。
- en: 'In Java 9, `public`, `protected`, and `private` are:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java 9中，`public`、`protected`和`private`是：
- en: Three different classes defined in `java.lang`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`java.lang`中定义的三个不同的类。
- en: Three equivalent access modifiers.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三种等效的访问修饰符。
- en: Three different access modifiers.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三种不同的访问修饰符。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about the different members that can compose a
    class declaration in Java 9\. We worked with instance fields, instance methods,
    class constants, and class methods. We worked with getters and setters, and we
    took advantage of access modifiers to hide data that we didn't want the users
    of our classes to be able to access.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Java 9中可以组成类声明的不同成员。我们使用实例字段、实例方法、类常量和类方法。我们使用getter和setter，并利用访问修饰符来隐藏我们不希望类的用户能够访问的数据。
- en: We worked with virtual creatures. First, we declared a simple class and then
    we made it evolve with additional features. We tested how everything worked in
    JShell.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们与虚拟生物一起工作。首先，我们声明了一个简单的类，然后通过添加功能使其进化。我们在JShell中测试了一切是如何工作的。
- en: Now that you have learned about data encapsulation, you are ready to work with
    mutable and immutable versions of classes in Java 9, which is what we are going
    to discuss in the next chapter.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了数据封装，可以开始在Java 9中使用可变和不可变版本的类，这是我们将在下一章中讨论的内容。
