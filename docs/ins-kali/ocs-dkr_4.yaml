- en: Chapter 4. Automation and Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。自动化和最佳实践
- en: At this point, we now know how to set up Docker in our development environments,
    are comfortable with the Docker commands, and have a good idea about the kind
    of situations Docker is suitable for. We also have an idea on how to configure
    Docker and its containers to suit all our needs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们现在知道如何在开发环境中设置Docker，熟悉Docker命令，并且对Docker适用的情况有一个很好的了解。我们还知道如何配置Docker及其容器以满足我们所有的需求。
- en: In this chapter, we will focus on the various usage patterns that will help
    us deploy our web applications in production environments. We will begin with
    Docker's remote API because logging in to a production server and running commands
    is always considered dangerous. So, it is best to run an application that monitors
    and orchestrates the containers in a host. There are a host of orchestration tools
    available for Docker today, and with the announcement of v1.0, Docker also announced
    a new project, **libswarm**, which gives a standard interface to manage and orchestrate
    distributed systems, which will be another topic we will be delving into.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将专注于各种使用模式，这些模式将帮助我们在生产环境中部署我们的Web应用程序。我们将从Docker的远程API开始，因为登录到生产服务器并运行命令总是被认为是危险的。因此，最好运行一个监视和编排主机中容器的应用程序。如今有许多用于Docker的编排工具，并且随着v1.0的宣布，Docker还宣布了一个新项目**libswarm**，它提供了一个标准接口来管理和编排分布式系统，这将是我们将要深入探讨的另一个主题。
- en: Docker developers recommend running only one process per container. This is
    difficult if you want to inspect an already running container. We will look at
    a command that allows us to inject a process into an already running container.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Docker开发人员建议每个容器只运行一个进程。如果您想要检查已经运行的容器，这可能有些困难。我们将看一下一个允许我们将进程注入到已经运行的容器中的命令。
- en: As your organization grows, so does the load, and you will need to start thinking
    about scaling. Docker in itself is meant to be used in a single host, but by using
    a host of tools such as `etcd` and `coreos`, you can easily run a bunch of Docker
    hosts in a cluster and discover every other container in that cluster.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着组织的发展，负载也会增加，您将需要开始考虑扩展。Docker本身是用于在单个主机中使用的，但是通过使用一系列工具，如`etcd`和`coreos`，您可以轻松地在集群中运行一堆Docker主机并发现该集群中的每个其他容器。
- en: 'Every organization that has a web application running in production knows the
    importance of security. In this chapter, we are going to talk about the security
    aspects with respect to not only the `docker` daemon, but also the various Linux
    features used by Docker. To summarize, in this chapter, we will look at the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 每个在生产环境中运行Web应用程序的组织都知道安全性的重要性。在本章中，我们将讨论与`docker`守护程序相关的安全方面，以及Docker使用的各种Linux功能。总之，在本章中，我们将看到以下内容：
- en: Docker remote API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker远程API
- en: Injecting processes into containers with the Docker exec command
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker exec命令将进程注入容器
- en: Service discovery
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现
- en: Security
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Docker remote API
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker远程API
- en: The Docker binary can run both as a client and as a daemon. When Docker is run
    as a daemon, it attaches itself to a Unix socket at `unix:///var/run/docker.sock`
    by default (this can be changed when starting docker, of course) and accepts commands
    over REST. The same Docker binary can then be used to run all the other commands
    (which is nothing but the client making REST calls to the `docker` daemon).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Docker二进制文件可以同时作为客户端和守护程序运行。当Docker作为守护程序运行时，默认情况下会将自己附加到Unix套接字`unix:///var/run/docker.sock`（当然，在启动docker时可以更改此设置），并接受REST命令。然后，相同的Docker二进制文件可以用于运行所有其他命令（这只是客户端向`docker`守护程序发出REST调用）。
- en: 'A diagram of the `docker` daemon is shown as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了`docker`守护程序的图表：
- en: '![Docker remote API](graphics/4787OS_04_04.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![Docker远程API](graphics/4787OS_04_04.jpg)'
- en: This section will mainly be explained with examples as we have already encountered
    the working of these operations when we looked at the Docker commands.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将主要通过示例来解释，因为我们在查看Docker命令时已经遇到了这些操作的工作原理。
- en: 'To test these APIs, run the `docker` daemon at a TCP port like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这些API，运行`docker`守护程序，使用TCP端口，如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is not going to be a reference guide, since we have already covered the
    features available with Docker when we disussed Docker commands in [Chapter 2](ch02.html
    "Chapter 2. Docker CLI and Dockerfile"), *Docker CLI and Dockerfile*. Instead,
    we will be covering a select few APIs and you can look up the rest at [docs.docker.com/reference/api/docker_remote_api](http://docs.docker.com/reference/api/docker_remote_api).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会是一个参考指南，因为我们在[第2章](ch02.html "第2章。Docker CLI和Dockerfile")中已经涵盖了Docker可用的功能，*Docker
    CLI和Dockerfile*。相反，我们将涵盖一些API，并且您可以在[docs.docker.com/reference/api/docker_remote_api](http://docs.docker.com/reference/api/docker_remote_api)上查找其余部分。
- en: 'Before we start, let''s ensure that the `docker` daemon is responding to our
    requests:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们确保`docker`守护程序正在响应我们的请求：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Alright, everything is fine. Let's get going.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，一切都很好。让我们开始吧。
- en: Remote API for containers
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器的远程API
- en: Let's first look at the a few endpoints available that help create and manage
    containers.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下可用的一些端点，这些端点有助于创建和管理容器。
- en: The create command
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建命令
- en: 'The `create` command creates a container:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`create`命令创建一个容器：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `curl` utility is a simple Unix utility that can be used to construct HTTP
    requests and analyze responses.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl`实用程序是一个简单的Unix实用程序，可用于构造HTTP请求和分析响应。'
- en: Here we make a `POST` request to the `/containers/create` endpoint and pass
    a `JSON` object containing the details of the image we want the container to be
    based upon and the command we expect the container to run.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向`/containers/create`端点发出`POST`请求，并传递一个包含我们希望容器基于的镜像的详细信息以及我们期望容器运行的命令的`JSON`对象。
- en: 'Type of request: POST'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请求类型：POST
- en: 'The `JSON` data sent along with the `POST` request:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 与`POST`请求一起发送的`JSON`数据：
- en: '| Parameter | Type | Explanation |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 | 说明 |'
- en: '| --- | --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '| `JSON` | Describes the configuration of the container to start |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `JSON` | 描述要启动的容器的配置 |'
- en: 'Query parameters for the POST request:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: POST请求的查询参数：
- en: '| Parameter | Type | Explanation |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 | 说明 |'
- en: '| --- | --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '| `String` | This assigns a name to the container. It must match the `/?[a-zA-Z0-9_-]+`
    regular expression. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `String` | 这为容器分配一个名称。它必须匹配`/?[a-zA-Z0-9_-]+`正则表达式。 |'
- en: 'The following table shows the status code of the responses:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了响应的状态码：
- en: '| Status code | Meaning |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 状态码 | 意义 |'
- en: '| --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| No error |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 无错误 |'
- en: '|'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '| No such container |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 没有这样的容器 |'
- en: '|'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '| Impossible to attach (container not running) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 无法附加（容器未运行） |'
- en: '|'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| Internal server error |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 内部服务器错误 |'
- en: The list command
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表命令
- en: 'The `list` command gets a list of containers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`命令获取容器列表：'
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a `GET` request API. A request to `/containers/json` will return a `JSON`
    response containing a list of containers that fulfill the criteria. Here, passing
    the `all` query parameter will list containers that are not running as well. The
    `limit` parameter is the number of containers that will be listed in the response.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`GET`请求API。对`/containers/json`的请求将返回一个`JSON`响应，其中包含满足条件的容器列表。在这里，传递`all`查询参数将列出未运行的容器。`limit`参数是响应中将列出的容器数量。
- en: There are query parameters that you can provide with these API calls, which
    can fine-tune the responses.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些查询参数可以与这些API调用一起提供，可以微调响应。
- en: 'Type of Request: GET'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请求类型：GET
- en: '| Parameter | Type | Explanation |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 | 说明 |'
- en: '| --- | --- | --- |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| 1/`True`/`true` or 0/`False`/`false` | This tells whether all containers
    should be shown. Only running containers are shown by default. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 1/`True`/`true` 或 0/`False`/`false` | 这告诉是否显示所有容器。默认情况下只显示正在运行的容器。 |'
- en: '|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '| `Integer` | This shows the last [*n*] containers, including non running containers.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `整数` | 这显示最后 [*n*] 个容器，包括非运行中的容器。 |'
- en: '|'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '| `Container` `ID` | This only shows containers started since [x], including
    non running ones. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `容器` `ID` | 这只显示自 [x] 以来启动的容器，包括非运行中的容器。 |'
- en: '|'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '| `Container` `ID` | This only shows containers started before [x], including
    non running ones. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `容器` `ID` | 这只显示在 [x] 之前启动的容器，包括非运行中的容器。 |'
- en: '|'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| 1/`True`/`true` or 0/`False`/`false` | This tells whether container sizes
    should be shown in the responses or not. |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 1/`True`/`true` 或 0/`False`/`false` | 这告诉是否在响应中显示容器大小。 |'
- en: 'Status codes of the response follow relevant **Request** **For** **Comments**
    (**RFC**) 2616:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的状态码遵循相关的 **请求** **评论** (**RFC**) 2616：
- en: '| Status code | Meaning |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 状态码 | 意义 |'
- en: '| --- | --- |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| No error |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 没有错误 |'
- en: '|'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| Bad parameter and client error |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 错误的参数和客户端错误 |'
- en: '|'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '| Server error |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 服务器错误 |'
- en: Other endpoints for containers can be read about at [docs.docker.com/reference/api/docker_remote_api_v1.13/#21-containers](http://docs.docker.com/reference/api/docker_remote_api_v1.13/#21-containers).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有关容器的其他端点可以在[docs.docker.com/reference/api/docker_remote_api_v1.13/#21-containers](http://docs.docker.com/reference/api/docker_remote_api_v1.13/#21-containers)上阅读。
- en: Remote API for images
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像的远程 API
- en: Similar to containers, there are APIs to build and manage images as well.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器类似，还有用于构建和管理图像的 API。
- en: Listing the local Docker images
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出本地 Docker 图像
- en: 'The following command lists the local images:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令列出本地图像：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is a `GET` request API. A request to `/images/json` will return a `JSON`
    response containing a list that contains details of the images that fulfill the
    criteria.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `GET` 请求 API。对 `/images/json` 的请求将返回一个包含满足条件的图像详细信息列表的 `JSON` 响应。
- en: 'Type of request: GET'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请求类型：GET
- en: '| Parameter | Type | Explanation |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 | 解释 |'
- en: '| --- | --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '| 1/`True`/`true` or 0/`False`/`false` | This tells whether even intermediary
    containers should be shown. False by default. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 1/`True`/`true` 或 0/`False`/`false` | 这告诉是否显示中间容器。默认为假。 |'
- en: '|'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '| `JSON` | These are used to provide a filtered list of images. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `JSON` | 这些用于提供图像的筛选列表。 |'
- en: Other endpoints for images can be read about at [docs.docker.com/reference/api/docker_remote_api_v1.13/#22-images](http://docs.docker.com/reference/api/docker_remote_api_v1.13/#22-images).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有关图像的其他端点可以在[docs.docker.com/reference/api/docker_remote_api_v1.13/#22-images](http://docs.docker.com/reference/api/docker_remote_api_v1.13/#22-images)上阅读。
- en: Other operations
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他操作
- en: There are other APIs too, such as the ping API we checked at the beginning of
    this section. Some of them are explored in the following section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他 API，比如我们在本节开头检查的 ping API。其中一些在下一节中探讨。
- en: Getting system-wide information
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取系统范围的信息
- en: 'The following command gets the system-wide information on Docker. This is the
    endpoint that handles the `docker info` command:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令获取 Docker 的系统范围信息。这是处理 `docker info` 命令的端点：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Committing an image from a container
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从容器中提交图像
- en: 'The following command commits an image from a container:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令从容器中提交图像：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Commit is a `POST` request to the `/commit` parameter with data about the image
    it's based on and the command associated with the image that will be created on
    commit. Key pieces of information include the `container` `ID` parameter to commit,
    the commit message, and the repository it belongs to, all of which are passed
    as query parameters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 提交是对`/commit`参数的`POST`请求，其中包含有关其基础图像和与将在提交时创建的图像相关联的命令的数据。关键信息包括要提交的`container`
    `ID`参数，提交消息以及它所属的存储库，所有这些都作为查询参数传递。
- en: 'Type of request: POST'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请求类型：POST
- en: 'The `JSON` data sent along with the `POST` request:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与`POST`请求一起发送的`JSON`数据：
- en: '| Parameter | Type | Explanation |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 | 解释 |'
- en: '| --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '| `JSON` | This describes the configuration of the container to commit |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `JSON` | 这描述了要提交的容器的配置 |'
- en: 'The following table shows query parameters for the `POST` request:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了`POST`请求的查询参数：
- en: '| Parameter | Type | Explanation |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 | 解释 |'
- en: '| --- | --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| `Container ID` | The `ID` of the container you intend to commit |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `Container ID` | 您打算提交的容器的`ID` |'
- en: '|'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '| `String` | The repository to create the image in |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `String` | 要在其中创建图像的存储库 |'
- en: '|'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '| `String` | The tag for the new image |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `String` | 新图像的标签 |'
- en: '|'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '| `String` | Commit message |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `String` | 提交消息 |'
- en: '|'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '| `String` | Author information |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `String` | 作者信息 |'
- en: 'The following table shows the status code of the responses:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了响应的状态码：
- en: '| Status code | Meaning |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 状态码 | 意义 |'
- en: '| --- | --- |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '| No error |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 没有错误 |'
- en: '|'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '| No such container |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 没有这样的容器 |'
- en: '|'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| Internal server error |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 内部服务器错误 |'
- en: Saving the image
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存图像
- en: 'Get a tarball backup of all the images and metadata of a repository from the
    following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下命令获取存储库的所有图像和元数据的tarball备份：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will take some time, as the image has to be first compressed into a tarball
    and then streamed, but then it will be saved in the tar archive.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要一些时间，因为图像首先必须被压缩成一个tarball，然后被流式传输，但然后它将被保存在tar存档中。
- en: Other endpoints can be read about at [docs.docker.com/reference/api/docker_remote_api_v1.13/#23-misc](http://docs.docker.com/reference/api/docker_remote_api_v1.13/#23-misc).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 其他端点可以在[docs.docker.com/reference/api/docker_remote_api_v1.13/#23-misc](http://docs.docker.com/reference/api/docker_remote_api_v1.13/#23-misc)上了解。
- en: How docker run works
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker run的工作原理
- en: 'Now that we have realized that every Docker command that we run is nothing
    but a series of RESTful operations carried out by the client, let''s enhance our
    understanding of what happens when you run a `docker run` command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们意识到我们运行的每个Docker命令实际上都是客户端执行的一系列RESTful操作，让我们加深一下对运行`docker run`命令时发生的事情的理解：
- en: To create an API, `/containers/``create` parameter is called.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个API，需要调用`/containers/``create`参数。
- en: If the status code of the response is 404, it means the image doesn't exist.
    Try to pull the image using `/images/create` parameter and go back to step 1.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果响应的状态码是404，则表示图像不存在。尝试使用`/images/create`参数拉取图像，然后返回到步骤1。
- en: Get the `ID` of the created container and start it using `/containers/(id)/start`
    parameter.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建的容器的`ID`并使用`/containers/(id)/start`参数启动它。
- en: The query parameters to these API calls will depend on the flags and arguments
    passed to the `docker run` command.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API调用的查询参数将取决于传递给`docker run`命令的标志和参数。
- en: Injecting processes into containers with the Docker execute command
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker execute命令将进程注入容器
- en: During the course of your explorations of Docker, you may have wondered whether
    the single command per container rule enforced by Docker is limiting its capabilities.
    In fact, you might be forgiven for assuming that a Docker container runs only
    a single process. But no! A container can run any number of processes, but can
    only start with one command and the container lives as long as the process associated
    with the command does. This restriction has been enforced because Docker believes
    in the philosophy of one app per container. Instead of loading everything in a
    single container, a typical Docker-reliant application architecture will consist
    of multiple containers, each running a specialized service, all linked together.
    This helps keep the container light, makes debugging easier, reduces the attack
    vectors, and ensures that if one service goes down, others aren't affected.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在您探索Docker的过程中，您可能会想知道Docker强制执行的每个容器规则是否限制了其功能。事实上，您可能会原谅认为Docker容器只运行一个进程。但不是！一个容器可以运行任意数量的进程，但只能以一个命令启动，并且与命令相关联的进程存在的时间就是容器的生存时间。这种限制是因为Docker相信一个容器一个应用程序的理念。与其将所有内容加载到单个容器中，典型的依赖于Docker的应用程序架构将包括多个容器，每个容器运行一个专门的服务，所有这些服务都链接在一起。这有助于保持容器轻便，使调试更容易，减少攻击向量，并确保如果一个服务崩溃，其他服务不受影响。
- en: Sometimes, however, you might need to look into the container while it is running.
    Over time, a number of approaches have been taken by the Docker community to debug
    running containers. Some members loaded SSH into the container and ran a process
    management solution such as **supervisor** to run the SSH + application server.
    Then came tools such as **nsinit** and **nsenter** that helped spawn a shell in
    the namespace the container was running in. However, all of these solutions were
    hacks. So with v1.3, Docker decided to provide the `docker exec` command, a safe
    alternative that could debug running containers.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时您可能需要在容器运行时查看容器。随着时间的推移，Docker社区采取了许多方法来调试运行中的容器。一些成员将SSH加载到容器中，并运行了一个进程管理解决方案，如**supervisor**来运行SSH
    +应用程序服务器。然后出现了诸如**nsinit**和**nsenter**之类的工具，这些工具帮助在容器正在运行的命名空间中生成一个shell。然而，所有这些解决方案都是黑客攻击。因此，随着v1.3的到来，Docker决定提供`docker
    exec`命令，这是一个安全的替代方案，可以调试运行中的容器。
- en: 'The `docker exec` command, allows a user to spawn a process inside their Docker
    container via the Docker API and CLI, for example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker exec`命令允许用户通过Docker API和CLI在其Docker容器中生成一个进程，例如：'
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first command starts a simple file server container. The container is sent
    to the background with the `-d` option. In the second command, with `docker` `exec`,
    we log in to the container by creating a bash process inside it. Now we will be
    able to inspect the container, read the log (if we have logged in to a file),
    run diagnostics (if the need to inspect arises because of a bug), and so on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令启动一个简单的文件服务器容器。使用`-d`选项将容器发送到后台。在第二个命令中，使用`docker exec`，我们通过在其中创建一个bash进程来登录到容器。现在我们将能够检查容器，读取日志（如果我们已经登录到文件中），运行诊断（如果需要检查是因为错误而出现），等等。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Docker still hasn't moved from its one-app-per-container philosophy. The `docker
    exec` command exists just to provide us with a way to inspect containers, which
    otherwise would've required workarounds or hacks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Docker仍然没有从其一个应用程序每个容器的理念中移动。 `docker exec`命令存在只是为了提供一种检查容器的方法，否则将需要变通或黑客攻击。
- en: Service discovery
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务发现
- en: Docker assigns an IP to a container dynamically from a pool of available addresses.
    While this is good in some ways, it creates a problem when you are running containers
    that need to communicate with each other. You just cannot know when building an
    image what its IP address is going to be. Your first instinct might be to start
    the containers, then log in to them (via `docker` `exec`), and set the IP addresses
    of the other containers manually. But remember, this IP address can change when
    a container restarts, so then you would have to manually log in to each container
    and enter the new IP address. Could there be a better way? Yes, there is.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Docker会动态地从可用地址池中为容器分配IP。虽然在某些方面这很好，但当您运行需要相互通信的容器时，就会产生问题。在构建镜像时，您无法知道其IP地址将是什么。您可能的第一反应是启动容器，然后通过`docker
    exec`登录到它们，并手动设置其他容器的IP地址。但请记住，当容器重新启动时，此IP地址可能会更改，因此您将不得不手动登录到每个容器并输入新的IP地址。有没有更好的方法？是的，有。
- en: Service discovery is a collection of everything that needs to be done to let
    services know how to find and communicate with other services. Under service discovery,
    containers do not know their peers when they are just started. Instead, they discover
    them dynamically. This should work both when the containers are in the same host
    as well as when they are in a cluster.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现是一系列需要完成的工作，让服务知道如何找到并与其他服务通信。在服务发现下，容器在刚启动时并不知道它们的对等体。相反，它们会动态地发现它们。这应该在容器位于同一主机以及位于集群中时都能正常工作。
- en: 'There are two techniques to achieve service discovery:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种技术可以实现服务发现：
- en: Using default Docker features such as names and links
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认的Docker功能，如名称和链接
- en: Using a dedicated service such as `Etcd` or `Consul`
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用专用服务，如`Etcd`或`Consul`
- en: Using Docker names, links, and ambassador containers
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker名称、链接和大使容器
- en: We learned how to link conatiners in the section titled *Linking Containers*
    in [Chapter 3](ch03.html "Chapter 3. Configuring Docker Containers"), *Configuring
    Docker Containers*. To refresh your memory, this is how it works.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章 配置Docker容器")的*链接容器*部分学习了如何链接容器。为了提醒您，这就是它的工作原理。
- en: Using links to make containers visible to each other
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用链接使容器彼此可见
- en: 'The use of links is shown in the following diagram:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了链接的使用：
- en: '![Using links to make containers visible to each other](graphics/4787OS_04_05.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![使用链接使容器彼此可见](graphics/4787OS_04_05.jpg)'
- en: Link allows a container to connect to another container without any need to
    hardcode its IP address. It is achieved by inserting the first container's IP
    address in `/etc/hosts` when starting the second container.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 链接允许容器连接到另一个容器，而无需硬编码其IP地址。在启动第二个容器时，将第一个容器的IP地址插入`/etc/hosts`中即可实现这一点。
- en: 'A link can be specified when starting the container using the `--link` option:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在启动容器时使用`--link`选项指定链接：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can find out more about linking in [Chapter 3](ch03.html "Chapter 3. Configuring
    Docker Containers"), *Configuring Docker Containers*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[第3章](ch03.html "第3章 配置Docker容器")中了解更多关于链接的信息。
- en: Cross-host linking using ambassador containers
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用大使容器进行跨主机链接
- en: 'The following diagram represents cross-host linking using ambassador containers:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表代表了使用大使容器进行跨主机链接：
- en: '![Cross-host linking using ambassador containers](graphics/4787OS_04_03.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![使用大使容器进行跨主机链接](graphics/4787OS_04_03.jpg)'
- en: Ambassador containers are used to link containers across hosts. In this architecture,
    you can restart/replace the database container without needing to restart the
    application container.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 大使容器用于链接跨主机的容器。在这种架构中，您可以重新启动/替换数据库容器，而无需重新启动应用程序容器。
- en: You can find out more about ambassador containers in [Chapter 3](ch03.html "Chapter 3. Configuring
    Docker Containers"), *Configuring Docker Containers*.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[第3章](ch03.html "第3章。配置Docker容器")*配置Docker容器*中了解有关ambassador容器的更多信息。
- en: Service discovery using etcd
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用etcd进行服务发现
- en: Why do we need specialized solutions for service discovery? While ambassador
    containers and links solve the problem of finding containers without needing to
    know their IP addresses, they do have one fatal flaw. You still need to manually
    monitor the health of the containers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们需要专门的服务发现解决方案？虽然ambassador容器和链接解决了在不需要知道其IP地址的情况下找到容器的问题，但它们确实有一个致命的缺陷。您仍然需要手动监视容器的健康状况。
- en: Imagine a situation where you have a cluster of backend servers and frontend
    servers linked to them via ambassador containers. If one of the servers goes down,
    the frontend servers still keep trying to connect to the backend server, because
    as far as they are concerned, that is the only available backend server, which
    is of course wrong.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一种情况，您有一组后端服务器和通过ambassador容器与它们连接的前端服务器的集群。如果其中一个服务器宕机，前端服务器仍然会继续尝试连接到后端服务器，因为在它们看来，那是唯一可用的后端服务器，这显然是错误的。
- en: Modern service discovery solutions such as `etcd`, `Consul`, and `doozerd` do
    more than merely providing the right IP addresses and ports. They are, in effect,
    distributed key-value stores, but are fault tolerant and consistent and handle
    master election in the event of failure. They can even act as lock servers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现代服务发现解决方案，如`etcd`、`Consul`和`doozerd`，不仅提供正确的IP地址和端口，它们实际上是分布式键值存储，具有容错和一致性，并在故障发生时处理主节点选举。它们甚至可以充当锁服务器。
- en: The `etcd` service is an open source, distributed key-value store developed
    by **CoreOS**. In a cluster, the `etcd` client runs on each machine in the cluster.
    The `etcd` service gracefully handles master election during network partitions
    and the loss of the current master.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`etcd`服务是由**CoreOS**开发的开源分布式键值存储。在集群中，`etcd`客户端在集群中的每台机器上运行。`etcd`服务在网络分区和当前主节点丢失期间优雅地处理主节点选举。'
- en: Your applications can read and write data to the `etcd` service. Common examples
    for `etcd` services are storing database connection details, cache settings, and
    so on.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序可以读取和写入`etcd`服务中的数据。`etcd`服务的常见示例包括存储数据库连接详细信息、缓存设置等。
- en: 'Features of the `etcd` service are listed here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`etcd`服务的特点在这里列出：'
- en: Simple, curlable API (HTTP + JSON)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的可curl API（HTTP + JSON）
- en: Optional **Secure** **Sockets** **Layer** (**SSL**) client certificate authentication
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的**安全**套接字层（**SSL**）客户端证书认证
- en: Keys support **Time** **To** **Live** (**TTL**)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键支持**生存时间**（**TTL**）
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Consul` service is a great alternative to the `etcd` service. There is
    no reason why one should be chosen over the other. This section is just meant
    to introduce you to the concept of service discovery.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consul`服务是`etcd`服务的一个很好的替代方案。没有理由选择其中一个而不是另一个。本节只是为了向您介绍服务发现的概念。'
- en: 'We use the `etcd` service in two stages as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两个阶段使用`etcd`服务如下：
- en: We register our services with the `etcd` service.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`etcd`服务注册我们的服务。
- en: We do a lookup to find services thus registered.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们进行查找以查找已注册的服务。
- en: 'The following diagram shows the `etcd` service:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了`etcd`服务：
- en: '![Service discovery using etcd](graphics/4787OS_04_06.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![使用etcd进行服务发现](graphics/4787OS_04_06.jpg)'
- en: This seems like a simple task to do, but building a solution that is fault tolerant
    and consistent is not simple. You will also need to be notified in case of failure
    of a service. If you run the service discovery solution itself in a naive centralized
    manner, it might become a single point of failure. So, all instances in a cluster
    of service discovery servers need to be synchronized with the right answer, which
    makes for interesting approaches. The team at CoreOS developed a consensus algorithm
    called **Raft** to solve this problem. You can read more about it at [http://raftconsensus.github.io](http://raftconsensus.github.io).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个简单的任务，但构建一个容错和一致的解决方案并不简单。您还需要在服务失败时收到通知。如果以天真的集中方式运行服务发现解决方案本身，它可能会成为单点故障。因此，服务发现服务器集群中的所有实例都需要与正确的答案同步，这就需要有趣的方法。CoreOS团队开发了一种称为**Raft**的共识算法来解决这个问题。您可以在[http://raftconsensus.github.io](http://raftconsensus.github.io)上阅读更多信息。
- en: Let's look at an example to get a lay of the land. In this example, we will
    run the `etcd` server in a container and see how easy it is to register a service
    and discover it.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，了解一下情况。在这个例子中，我们将在一个容器中运行`etcd`服务器，并看看注册服务和发现服务有多么容易。
- en: 'Step 1: Run the `etcd` server:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步骤1：运行`etcd`服务器：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Step 2: Once the image is downloaded and the server starts, run the following
    command to register a message:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步骤2：一旦镜像下载完成并且服务器启动，运行以下命令注册一条消息：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is nothing but a `PUT` request to the server at the `/v2/keys/message`
    path (`message` being the key here).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对`/v2/keys/message`路径上的服务器发出的`PUT`请求（这里的密钥是`message`）。
- en: 'Step 3: Get the key back with the following command:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 步骤3：使用以下命令获取密钥：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can go ahead and experiment by changing the value, trying an invalid key,
    and so on. You will find that the responses are in `JSON`, which means you can
    easily integrate it with your application without needing to use any libraries.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续尝试更改值，尝试无效的密钥等。您会发现响应是`JSON`格式的，这意味着您可以轻松地将其与应用程序集成，而无需使用任何库。
- en: But how would I use it in my application? If your application needs to run multiple
    services, they can be connected together with links and ambassador containers,
    but if one of them becomes unavailable or needs to be redeployed, a lot of work
    needs to be done to restore the links.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我该如何在我的应用程序中使用它呢？如果您的应用程序需要运行多个服务，它们可以通过链接和大使容器连接在一起，但如果其中一个变得不可用或需要重新部署，就需要做很多工作来恢复链接。
- en: Now imagine that your services use the `etcd` service. Every service registers
    its IP address and port number against its name and discovers other services by
    their names (that are constant). Now, if a container restarts because of a crash/redeployment,
    the new container will register against the modified IP address. This will update
    the value that the `etcd` service returns for subsequent discovery requests. However,
    this means that a single `etcd` server can also be a single point of failure.
    The solution for this is to run a cluster of `etcd` servers. This is where the
    Raft consensus algorithm, developed by CoreOS (the team that created `etcd` service),
    comes in. A complete example of an application service being deployed with the
    `etcd` service can be found at [http://jasonwilder.com/blog/2014/07/15/docker-service-discovery/](http://jasonwilder.com/blog/2014/07/15/docker-service-discovery/)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，您的服务使用`etcd`服务。每个服务都会根据其名称注册其IP地址和端口号，并通过其名称（恒定的）发现其他服务。现在，如果容器因崩溃/重新部署而重新启动，新容器将根据修改后的IP地址进行注册。这将更新`etcd`服务返回的值，以供后续发现请求使用。但是，这意味着单个`etcd`服务器也可能是单点故障。解决此问题的方法是运行一组`etcd`服务器。这就是CoreOS（创建`etcd`服务的团队）开发的Raft一致性算法发挥作用的地方。可以在[http://jasonwilder.com/blog/2014/07/15/docker-service-discovery/](http://jasonwilder.com/blog/2014/07/15/docker-service-discovery/)找到使用`etcd`服务部署的应用服务的完整示例。
- en: Docker Orchestration
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker编排
- en: As soon as you go beyond simple applications to complex architectures, you will
    start using tools and services such as `etcd`, `consul`, and `serf`, and you will
    notice that all of them come with their own set of APIs, even though they have
    overlapping features. If you set up your infrastructure to one set of tooling
    and find a need to switch, it takes considerable effort, sometimes even changes
    in the code, to switch vendors. Such situations can lead to vendor lock-in, which
    would ruin a promising ecosystem that Docker has managed to create. To provide
    a standard interface to these service providers so that they can almost be used
    as plug-and-play solutions, Docker has released a suite of orchestration services.
    In this section, we will take a look at them. Note, however, that at the time
    of writing this book, these projects (Machine, Swarm, and Compose) are still in
    Alpha and in active development.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您超越简单的应用程序进入复杂的架构，您将开始使用诸如`etcd`、`consul`和`serf`之类的工具和服务，并且您会注意到它们都具有自己的一套API，即使它们具有重叠的功能。如果您设置基础设施为一组工具，并发现需要切换，这需要相当大的努力，有时甚至需要更改代码才能切换供应商。这种情况可能导致供应商锁定，这将破坏Docker设法创建的有前途的生态系统。为了为这些服务提供商提供标准接口，以便它们几乎可以用作即插即用的解决方案，Docker发布了一套编排服务。在本节中，我们将对它们进行介绍。但是，请注意，在撰写本书时，这些项目（Machine、Swarm和Compose）仍处于Alpha阶段，并且正在积极开发中。
- en: Docker Machine
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Machine
- en: Docker Machine aims to provide a single command to take you from zero-to-Docker
    project.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Machine旨在提供一个命令，让您从零开始进行Docker项目。
- en: Before Docker Machine, if you intended to start working with Docker on a new
    host, be it a virtual machine or a remote host in an infrastructure provider such
    as **Amazon** **Web** **Services** (**AWS**) or Digital Ocean, you would have
    to log in to the instance, and run the setup and configuration commands specific
    to the operating system running in it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Machine之前，如果您打算在新主机上开始使用Docker，无论是虚拟机还是基础设施提供商（如亚马逊网络服务（AWS）或Digital
    Ocean）上的远程主机，您都必须登录到实例，并运行特定于其中运行的操作系统的设置和配置命令。
- en: 'With Docker Machine, whether provisioning the `docker` daemon on a new laptop,
    on virtual machines in the data center, or on a public cloud instance, the same,
    single command gets the target host ready to run Docker containers:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Machine，无论是在新笔记本电脑上、数据中心的虚拟机上，还是在公共云实例上配置`docker`守护程序，都可以使用相同的单个命令准备目标主机以运行Docker容器：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Then you can manage multiple Docker hosts from the same interface regardless
    of their location and run any Docker command on them.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以从相同的界面管理多个Docker主机，而不管它们的位置，并在它们上运行任何Docker命令。
- en: Apart from this, the machine also has pluggable backends, which makes adding
    support to infrastructure providers easy, while retaining the common user-facing
    API. Machine ships by default with drivers to provision Docker locally with Virtualbox
    as well as remotely on Digital Ocean instances.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，该机器还具有可插拔的后端，这使得很容易为基础设施提供商添加支持，同时保留了常见的用户界面API。Machine默认提供了用于在Virtualbox上本地配置Docker以及在Digital
    Ocean实例上远程配置的驱动程序。
- en: Note that Docker Machine is a separate project from the Docker Engine. You can
    find the updated details about this project on its Github page at [https://github.com/docker/machine](https://github.com/docker/machine).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Docker Machine是Docker Engine的一个独立项目。您可以在其Github页面上找到有关该项目的更新详细信息：[https://github.com/docker/machine](https://github.com/docker/machine)。
- en: Swarm
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swarm
- en: '**Swarm** is a native clustering solution provided by Docker. It takes Docker
    Engine and extends it to enable you to work on a cluster of containers. With Swarm,
    you can manage a resource pool of Docker hosts and schedule containers to run
    transparently on top, automatically managing workload and providing failover services.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swarm**是Docker提供的本地集群解决方案。它使用Docker Engine并对其进行扩展，以使您能够在容器集群上工作。使用Swarm，您可以管理Docker主机的资源池，并安排容器在其上透明地运行，自动管理工作负载并提供故障转移服务。'
- en: To schedule, it takes the container's resource requirements, looks at the available
    resources in the hosts, and tries to optimize placement of workloads.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行安排，它需要容器的资源需求，查看主机上的可用资源，并尝试优化工作负载的放置。
- en: 'For example, if you wanted to schedule a Redis container requiring 1 GB of
    memory, here is how you would schedule it with Swarm:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想要安排一个需要1GB内存的Redis容器，可以使用Swarm进行安排：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Apart from resource scheduling, Swarm also supports policy-based scheduling
    with standard and custom constraints. For instance, if you want to run your **MySQL**
    container on an SSD-backed host (in order to ensure better write and read performance),
    you can specify that as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 除了资源调度，Swarm还支持基于策略的调度，具有标准和自定义约束。例如，如果您想在支持SSD的主机上运行您的**MySQL**容器（以确保更好的写入和读取性能），可以按照以下方式指定：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In addition to all of this, Swarm provides high-availability and failover. It
    continuously monitors the health of the containers, and if one were to suffer
    an outage, automatically rebalances by moving and restarting the Docker containers
    from the failed host to a new one. The best part is that regardless of whether
    you are just starting with one instance or have scaled up to 100 instances, the
    interface remains the same.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些，Swarm还提供了高可用性和故障转移。它不断监视容器的健康状况，如果一个容器发生故障，会自动重新平衡，将失败主机上的Docker容器移动并重新启动到新主机上。最好的部分是，无论您是刚开始使用一个实例还是扩展到100个实例，界面都保持不变。
- en: 'Like Docker Machine, Docker Swarm is in Alpha and is continuously evolving.
    Head over to its repository on Github to know more about it: [https://github.com/docker/swarm/](https://github.com/docker/swarm/).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与Docker Machine一样，Docker Swarm处于Alpha阶段，并不断发展。请前往其Github存储库了解更多信息：[https://github.com/docker/swarm/](https://github.com/docker/swarm/)。
- en: Docker Compose
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Compose
- en: '**Compose** is the last piece of the puzzle. With Docker Machine, we have provisioned
    the Docker daemons. With Docker Swarm, we can rest assured that we''ll be able
    to control our containers from anywhere and that they''ll remain available if
    there are any failures. Compose helps us compose our distributed applications
    on top of this cluster.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**Compose**是这个谜题的最后一块。通过Docker Machine，我们已经配置了Docker守护程序。通过Docker Swarm，我们可以放心，我们将能够从任何地方控制我们的容器，并且如果有任何故障，它们将保持可用。Compose帮助我们在这个集群上组合我们的分布式应用程序。'
- en: Comparing this to something we already know might help us understand how all
    of this works together. Docker Machine acts just as an operating system acts with
    respect to a program. It provides a place for containers to run. Docker Swarm
    acts like a programming language runtime to a program. It manages resources, provides
    exception handling, and so on for containers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 将这与我们已经了解的东西进行比较，可能有助于我们理解所有这些是如何一起工作的。Docker Machine的作用就像操作系统对程序的作用一样。它提供了容器运行的地方。Docker
    Swarm就像程序的编程语言运行时一样。它管理资源，提供异常处理等等。
- en: Docker Compose is more like an IDE, or a language syntax, that provides a way
    to express what the program needs to do. With Compose, we specify how our distributed
    apps must run in the cluster.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose更像是一个IDE，或者是一种语言语法，它提供了一种表达程序需要做什么的方式。通过Compose，我们指定了我们的分布式应用程序在集群中的运行方式。
- en: 'We use Docker Compose by writing a `YAML` file to declare the configurations
    and states of our multi-container app. For example, let''s assume we have a Python
    app that uses a Redis DB. Here is how we would write the `YAML` file for Compose:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Docker Compose通过编写`YAML`文件来声明我们的多容器应用程序的配置和状态。例如，假设我们有一个使用Redis数据库的Python应用程序。以下是我们为Compose编写`YAML`文件的方式：
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding example, we defined two applications. One is a Python application
    that needs to be built from the Dockerfile in the current directory. It has a
    port (`5000`) exposed and has either a volume or a piece of code bind mounted
    to the current working directory. It also has an environment variable defined
    and is linked to the second application container, `redis`. The second container
    uses the `redis` container from the Docker registry.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们定义了两个应用程序。一个是需要从当前目录的Dockerfile构建的Python应用程序。它暴露了一个端口（`5000`），并且要么有一个卷，要么有一段代码绑定到当前工作目录。它还定义了一个环境变量，并且与第二个应用程序容器`redis`链接。第二个容器使用了Docker注册表中的`redis`容器。
- en: 'With the configuration defined, we can start both the containers with the following
    command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 有了定义的配置，我们可以使用以下命令启动两个容器：
- en: '[PRE42]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this single command, the Python container gets built using the Dockerfile,
    and the `redis` image gets pulled from the registry. However, the `redis` container
    is started first, because of the links directive in the Python container's specification
    and because the Python container depends on it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个单一的命令，Python容器使用Dockerfile构建，并且`redis`镜像从注册表中拉取。然而，`redis`容器首先启动，因为Python容器的规范中有links指令，并且Python容器依赖于它。
- en: As with Docker Machine and Docker Swarm, Docker Compose is a "work in progress"
    and its development can be tracked at [https://github.com/docker/docker/issues/9459](https://github.com/docker/docker/issues/9459).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与Docker Machine和Docker Swarm一样，Docker Compose是一个“正在进行中”的项目，其开发可以在[https://github.com/docker/docker/issues/9459](https://github.com/docker/docker/issues/9459)上跟踪。
- en: More information about swarm can be found at [http://blog.docker.com/2014/12/announcing-docker-machine-swarm-and-compose-for-orchestrating-distributed-apps/](http://blog.docker.com/2014/12/announcing-docker-machine-swarm-and-compose-for-orchestrating-distributed-apps/).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有关swarm的更多信息可以在[http://blog.docker.com/2014/12/announcing-docker-machine-swarm-and-compose-for-orchestrating-distributed-apps/](http://blog.docker.com/2014/12/announcing-docker-machine-swarm-and-compose-for-orchestrating-distributed-apps/)找到。
- en: Security
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: Security is of prime importance when it comes to deciding whether to invest
    in a technology, especially when that technology has implications on the infrastructure
    and workflow. Docker containers are mostly secure, and since Docker doesn't interfere
    with other systems, you can use additional security measures to harden the security
    around the `docker` daemon. It is better to run the `docker` daemon in a dedicated
    host and run other services as containers (except services such as `ssh`, `cron`,
    and so on).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性在决定是否投资于技术时至关重要，特别是当该技术对基础设施和工作流程有影响时。Docker容器大多是安全的，而且由于Docker不会干扰其他系统，您可以使用额外的安全措施来加固`docker`守护程序周围的安全性。最好在专用主机上运行`docker`守护程序，并将其他服务作为容器运行（除了诸如`ssh`、`cron`等服务）。
- en: In this section, we will discuss Kernel features used in Docker that are pertinent
    to security. We will also consider the `docker` daemon itself as a possible attack
    vector.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论Docker中用于安全性的内核特性。我们还将考虑`docker`守护程序本身作为可能的攻击向量。
- en: Image credit [http://xkcd.com/424/](http://xkcd.com/424/)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源[http://xkcd.com/424/](http://xkcd.com/424/)
- en: '![Security](graphics/4787OS_04_01.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![安全性](graphics/4787OS_04_01.jpg)'
- en: Kernel namespaces
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核命名空间
- en: Namespaces provide sandboxing to containers. When a container is started, Docker
    creates a set of namespaces and cgroups for the container. Thus, a container that
    belongs to a particular namespace cannot see or affect the behavior of another
    container that belongs to other namespaces or the host.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间为容器提供了沙盒功能。当容器启动时，Docker会为容器创建一组命名空间和控制组。因此，属于特定命名空间的容器无法看到或影响属于其他命名空间或主机的另一个容器的行为。
- en: 'The following diagram explains containers in Docker:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表解释了Docker中的容器：
- en: '![Kernel namespaces](graphics/4787OS_04_07.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![内核命名空间](graphics/4787OS_04_07.jpg)'
- en: The kernel namespace also creates a network stack for the container, which can
    be configured to the last detail. The default Docker network setup resembles a
    simple network, with the host acting as the router and the `docker0` bridge acting
    as an Ethernet switch.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 内核命名空间还为容器创建了一个网络堆栈，可以进行最后的详细配置。默认的Docker网络设置类似于简单的网络，主机充当路由器，`docker0`桥充当以太网交换机。
- en: The namespace feature is modeled after OpenVZ, which is an operating system
    level virtualization technology based on the Linux kernel and operating system.
    OpenVZ is what is used in most of the cheap VPSes available in market today. It
    has been around since 2005, and the namespace feature was added to the kernel
    in 2008\. It has been subjected to production use since then, so it can be called
    "battle hardened."
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间功能是模仿OpenVZ而设计的，OpenVZ是基于Linux内核和操作系统的操作系统级虚拟化技术。OpenVZ是目前市场上大多数廉价VPS所使用的技术。它自2005年以来就存在，命名空间功能是在2008年添加到内核中的。从那时起就被用于生产环境，因此可以称之为“经过严峻考验的”。
- en: Control groups
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制组
- en: Control groups provide resource management features. Although this has nothing
    to do with privileges, it is relevant to security because of its potential to
    act as the first line of defence against denial-of-service attacks. Control groups
    have been around for quite some time as well, so can be considered safe for production
    use.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 控制组提供资源管理功能。虽然这与特权无关，但由于其可能作为拒绝服务攻击的第一道防线，因此与安全性相关。控制组也存在已经相当长时间，因此可以认为在生产环境中是安全的。
- en: For further reading for control groups, refer to [https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt](https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有关控制组的进一步阅读，请参阅[https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt](https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt)。
- en: The root in a container
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器中的根
- en: The `root` command in a container is stripped of many privileges. For instance,
    you cannot mount a device using the `mount` command by default. On the other end
    of the spectrum, running a container with the `--privileged flag` flag will give
    the `root` user in the container complete access to all the privileges that the
    root user in the host does. How does docker achieve this?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 容器中的`root`命令被剥夺了许多特权。例如，默认情况下，您无法使用`mount`命令挂载设备。另一方面，使用`--privileged`标志运行容器将使容器中的`root`用户完全访问主机中`root`用户拥有的所有特权。Docker是如何实现这一点的呢？
- en: You can think of the standard `root` user as someone having a wide range of
    capabilities. One of them, is the `net_bind_service` service that binds to any
    port (even below 1024). Another, the `cap_sys_admin` service, is what is needed
    to mount physical drives. These are called capabilities, tokens used by a process
    to prove that it is allowed to perform an operation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将标准的`root`用户视为具有广泛能力的人。其中之一是`net_bind_service`服务，它绑定到任何端口（甚至低于1024）。另一个是`cap_sys_admin`服务，这是挂载物理驱动器所需的。这些被称为功能，是进程用来证明其被允许执行操作的令牌。
- en: 'Docker containers are started with a reduced capability set. Hence, you will
    find that you can perform some root operations but not others. Specifically, it
    is not possible for a `root` user in an unprivileged container to do the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器是以减少的能力集启动的。因此，您会发现您可以执行一些root操作，但不能执行其他操作。具体来说，在非特权容器中，`root`用户无法执行以下操作：
- en: Mount/unmount devices
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂载/卸载设备
- en: Managing raw sockets
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理原始套接字
- en: Filesystem operations such as creating device nodes and changing file ownerships
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统操作，如创建设备节点和更改文件所有权
- en: Before v1.2, if you needed to use any capability that was blacklisted, the only
    solution was to run the container with the `--privileged` flag. But v1.2 introduced
    three new flags, `--cap-add`, `--cap-drop`, and `--device`, to aid us to run a
    container that needed specific capabilities without compromising on the security
    of the host.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在v1.2之前，如果您需要使用任何被列入黑名单的功能，唯一的解决方案就是使用`--privileged`标志运行容器。但是v1.2引入了三个新标志，`--cap-add`，`--cap-drop`和`--device`，帮助我们运行需要特定功能的容器，而不会影响主机的安全性。
- en: 'The `--cap-add` flag adds a capability to the container. For example, let''s
    change the status of a container''s interface (which requires the `NET_ADMIN`
    service capability):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`--cap-add`标志向容器添加功能。例如，让我们改变容器接口的状态（这需要`NET_ADMIN`服务功能）：'
- en: '[PRE43]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `--cap-drop` flag blacklists a capability in a container. For example,
    let''s blacklist all but the `chown` command in a container, and then try to add
    a user. This will fail as it needs the `CAP_CHOWN` service:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`--cap-drop`标志在容器中列入黑名单功能。例如，让我们在容器中列入黑名单除`chown`命令之外的所有功能，然后尝试添加用户。这将失败，因为它需要`CAP_CHOWN`服务。'
- en: '[PRE44]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `--devices` flag is used to mount an external/virtual device directly on
    the container. Before v1.2, we had to mount it on the host and bind mount with
    the `-v` flag in a `--privileged` container. With the `--device` flag, you can
    now use a device in a container without needing to use the `--privileged` container.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`--devices`标志用于直接在容器上挂载外部/虚拟设备。在v1.2之前，我们必须在主机上挂载它，并在`--privileged`容器中使用`-v`标志进行绑定挂载。使用`--device`标志，您现在可以在容器中使用设备，而无需使用`--privileged`容器。'
- en: 'For example, to mount the DVD-RW device of your laptop on the container, run
    this command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在容器上挂载笔记本电脑的DVD-RW设备，请运行以下命令：
- en: '[PRE45]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: More information about the flags can be found at [http://blog.docker.com/tag/docker-1-2/](http://blog.docker.com/tag/docker-1-2/).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些标志的更多信息，请访问[http://blog.docker.com/tag/docker-1-2/](http://blog.docker.com/tag/docker-1-2/)。
- en: 'There were additional improvements introduced with the Docker 1.3 release.
    A `--security-opts` flag was added to the CLI, which allows you to set custom
    **SELinux** and **AppArmor** labels and profiles. For example, suppose you had
    a policy that allowed a container process to listen only to Apache ports. Assuming
    you had defined this policy in `svirt_apache`, you can apply it to the container
    as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 1.3版本还引入了其他改进。CLI中添加了`--security-opts`标志，允许您设置自定义的**SELinux**和**AppArmor**标签和配置文件。例如，假设您有一个策略，允许容器进程仅监听Apache端口。假设您在`svirt_apache`中定义了此策略，您可以将其应用于容器，如下所示：
- en: '[PRE46]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: One of benefits of this feature is that users will be able to run Docker in
    Docker without having to use the `docker run --privileged` container on the kernels
    supporting SELinux or AppArmor. Not giving the running container all the host
    access rights as the `--privileged` container significantly reduces the surface
    area of potential threats.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这一功能的好处之一是，用户将能够在支持SELinux或AppArmor的内核上运行Docker，而无需在容器上使用`docker run --privileged`。不像`--privileged`容器一样给予运行容器所有主机访问权限，这显著减少了潜在威胁的范围。
- en: 'Source: [http://blog.docker.com/2014/10/docker-1-3-signed-images-process-injection-security-options-mac-shared-directories/](http://blog.docker.com/2014/10/docker-1-3-signed-images-process-injection-security-options-mac-shared-directories/).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://blog.docker.com/2014/10/docker-1-3-signed-images-process-injection-security-options-mac-shared-directories/](http://blog.docker.com/2014/10/docker-1-3-signed-images-process-injection-security-options-mac-shared-directories/)。
- en: You can see the complete list of enabled capabilities at [https://github.com/docker/docker/blob/master/daemon/execdriver/native/template/default_template.go](https://github.com/docker/docker/blob/master/daemon/execdriver/native/template/default_template.go).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/docker/docker/blob/master/daemon/execdriver/native/template/default_template.go](https://github.com/docker/docker/blob/master/daemon/execdriver/native/template/default_template.go)上查看已启用功能的完整列表。
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the inquisitive mind, the complete list of all available capabilities can
    be found in the Linux manual page for capabilities. It can also be found online
    at [http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于好奇的人，所有可用功能的完整列表可以在Linux功能手册页中找到。也可以在[http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)上找到。
- en: Docker daemon attack surface
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker守护程序攻击面
- en: The `docker` daemon takes care of creating and managing containers, which includes
    creating filesystems, assigning IP addresses, routing packets, managing processes,
    and many more tasks that require root privileges. So it is imperative to start
    the daemon as a `sudo` user. This is the reason the `docker` daemon binds itself
    to a Unix socket by default, instead of a TCP socket, which it used until v5.2.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker`守护程序负责创建和管理容器，包括创建文件系统，分配IP地址，路由数据包，管理进程等需要root权限的许多任务。因此，将守护程序作为`sudo`用户启动是必不可少的。这就是为什么`docker`守护程序默认绑定到Unix套接字，而不是像v5.2之前那样绑定到TCP套接字的原因。'
- en: One of the end goals of Docker is to be able to run even the daemon as a non-root
    user, without affecting its functionalities, and delegate operations that do require
    root (such as filesystem operations and networking) to a dedicated subprocess
    with elevated privileges.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的最终目标之一是能够将守护程序作为非root用户运行，而不影响其功能，并将确实需要root的操作（如文件系统操作和网络）委托给具有提升权限的专用子进程。
- en: If you do want to expose Docker's port to the outside world (to make use of
    the remote API), it is advised to ensure that only trusted clients are allowed
    access. One straightforward way is to secure Docker with SSL. You can find ways
    of setting this up at [https://docs.docker.com/articles/https](https://docs.docker.com/articles/https).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实希望将Docker的端口暴露给外部世界（以利用远程API），建议确保只允许受信任的客户端访问。一个简单的方法是使用SSL保护Docker。您可以在[https://docs.docker.com/articles/https](https://docs.docker.com/articles/https)找到设置此项的方法。
- en: Best practices for security
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全最佳实践
- en: 'Now let''s summarize some key security best practices when running Docker in
    your infrastructure:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们总结一些在您的基础设施中运行Docker时的关键安全最佳实践：
- en: Always run the `docker` daemon in a dedicated server.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终在专用服务器上运行`docker`守护程序。
- en: Unless you have a multiple-instance setup, run the `docker` daemon on a Unix
    socket.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非您有多个实例设置，否则在Unix套接字上运行`docker`守护程序。
- en: Take special care about bind mounting host directories as volumes as it is possible
    for a container to gain complete read-write access and perform irreversible operations
    in these directories.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别注意将主机目录作为卷进行绑定挂载，因为容器有可能获得完全的读写访问权限，并在这些目录中执行不可逆的操作。
- en: If you have to bind to a TCP port, secure it with SSL-based authentication.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果必须绑定到TCP端口，请使用基于SSL的身份验证进行安全保护。
- en: Avoid running processes with root privileges in your containers.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免在容器中以root权限运行进程。
- en: There is absolutely no sane reason why you will ever need to run a privileged
    container in production.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产中绝对没有理智的理由需要运行特权容器。
- en: Consider enabling AppArmor/SELinux profiles in the host. This enables you to
    add an additional layer of security to the host.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑在主机上启用AppArmor/SELinux配置文件。这使您可以为主机添加额外的安全层。
- en: Unlike virtual machines, all containers share the host's kernel. So it is important
    to keep the kernel updated with the latest security patches.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与虚拟机不同，所有容器共享主机的内核。因此，保持内核更新以获取最新的安全补丁非常重要。
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the various tools, APIs, and practices that
    help us deploy our application in a Docker-based environment. Initially, we looked
    at the Remote API and realized that all Docker commands are nothing but a result
    of REST-based calls to the `docker` daemon.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了各种工具、API和实践，这些工具、API和实践帮助我们在基于Docker的环境中部署应用程序。最初，我们研究了远程API，并意识到所有Docker命令都不过是对`docker`守护程序的基于REST的调用的结果。
- en: Then we saw how to inject processes to help debug running containers.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们看到如何注入进程来帮助调试运行中的容器。
- en: We then looked at various methods to achieve service discovery, both using native
    Docker features such as links, and with the help of specialized `config` stores
    such as the `etcd` services.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看了各种方法来实现服务发现，既使用本机Docker功能，如链接，又借助专门的`config`存储，如`etcd`服务。
- en: Finally, we discussed various aspects of security when using Docker, the various
    kernel features it relies on, their reliability, and their implications on the
    security of the host the containers run on.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了在使用Docker时的各种安全方面，它所依赖的各种内核特性，它们的可靠性以及它们对容器所在主机安全性的影响。
- en: In the next chapter, we will be taking the approach of this chapter further,
    and checking out various open source projects. We will learn how to integrate
    or use them to fully realize the potential of Docker.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步采取本章的方法，并查看各种开源项目。我们将学习如何集成或使用它们，以充分实现Docker的潜力。
