- en: Chapter 8. Handling Exceptions in an Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。在应用程序中处理异常
- en: Exceptions are objects that are thrown by an application or the **Java Virtual
    Machine** (**JVM**) when an error of some sort occurs. Java provides a wide range
    of predefined exceptions and allows the developer to declare and create their
    own exception classes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是由应用程序或**Java虚拟机**（**JVM**）在发生某种错误时抛出的对象。Java提供了各种预定义的异常，并允许开发人员声明和创建自己的异常类。
- en: 'While there are a number of ways of classifying exceptions, one scheme classifies
    them into three types:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多分类异常的方法，但其中一种方案将它们分类为三种类型：
- en: Program errors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序错误
- en: Improper use of code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的不当使用
- en: Resource-related failures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与资源相关的故障
- en: Program errors are internal flaws in a code sequence. The programmer may or
    may not be able to do much about these types of errors. For example, a common
    exception is `NullPointerException` . This is frequently a result of not properly
    initializing or assigning a value to a reference variable. This type of error
    can be hard to avoid and anticipate when first writing a piece of code. However,
    once detected, the code can be revised to correct the situation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 程序错误是代码序列中的内部缺陷。程序员可能对这些类型的错误无能为力。例如，常见的异常是`NullPointerException`。这通常是由于未正确初始化或分配值给引用变量。在编写代码时，这种错误很难避免和预料。然而，一旦检测到，可以修改代码以纠正情况。
- en: Code may be improperly used. Most libraries are designed to be used in a specific
    manner. They may expect data to be organized in one way and if the user of the
    library fails to follow the format, an exception may be thrown. For example, the
    parameter of a method may not be structured as expected by the method or may be
    of the wrong type.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能被错误地使用。大多数库都是设计用于特定方式的。它们可能期望数据以某种方式组织，如果库的用户未能遵循格式，就可能引发异常。例如，方法的参数可能未按方法所期望的结构化，或者可能是错误的类型。
- en: Some errors are related to resource failure. When the underlying system is not
    able to satisfy the program's needs, a resource type of exception can occur. For
    example, a failure in the network may prevent the program from executing properly.
    This type of error may require re-executing the program at a later time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一些错误与资源故障有关。当底层系统无法满足程序的需求时，可能会发生资源类型的异常。例如，网络故障可能会阻止程序正常执行。这种类型的错误可能需要在以后的时间重新执行程序。
- en: 'A traditional approach to handling exceptions is to return an error code from
    a procedure. For example, a function may normally return a zero if it executed
    without an error. If an error did not occur, a non-zero value would be returned.
    The problem with this approach is that the calling of the function may either:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常的传统方法是从过程中返回错误代码。例如，如果函数执行时没有错误，则通常会返回零。如果发生错误，则会返回非零值。这种方法的问题在于函数的调用可能会出现以下情况：
- en: Be unaware that the function returns an error code (for example, C's `printf`
    function)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不知道函数返回错误代码（例如，C的`printf`函数）
- en: Forget to check for an error
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忘记检查错误
- en: Ignore the error completely
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全忽略错误
- en: When the error is not caught, the continued execution of the program can lead
    to unpredictably and possibly disastrous consequences.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当错误没有被捕获时，程序的继续执行可能会导致不可预测的，可能是灾难性的后果。
- en: An alternative to this method is to "catch" errors. Most modern block structured
    languages such as Java use this approach. This technique requires less coding
    and is more readable and robust. When a routine detects an error, it "throws"
    an exception object. The exception object is then returned to the caller which
    then catches and handles the error.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的替代方法是“捕获”错误。大多数现代的块结构化语言，如Java，使用这种方法。这种技术需要更少的编码，更易读和更健壮。当一个例程检测到错误时，它会“抛出”一个异常对象。然后将异常对象返回给调用者，调用者捕获并处理错误。
- en: Exceptions should be caught for a number of reasons. Failure to deal with exceptions
    can result in the application failing, or ending up in an invalid state with incorrect
    output. It is always a good idea to maintain a consistent environment. Also, if
    you open a resource, such as a file, you should always close the resource when
    you are done except for the most trivial programs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 异常应该被捕获有许多原因。未能处理异常可能导致应用程序失败，或者以不正确的输出结束处于无效状态。保持一致的环境总是一个好主意。此外，如果打开了资源，比如文件，在完成后应该始终关闭资源，除了最琐碎的程序。
- en: The exception handling mechanisms available in Java allow you to do this. When
    a resource is opened, it can be closed even if an exception occurs in the program.
    To accomplish this task, a resource is opened in a `try` block and closed in a
    `catch` or `finally` block. The `try`, `catch`, and `finally` blocks constitute
    the core of the exception handling mechanism used in Java.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Java中提供的异常处理机制允许您这样做。当打开资源时，即使程序中发生异常，也可以关闭资源。为了完成这个任务，资源在`try`块中打开，并在`catch`或`finally`块中关闭。`try`、`catch`和`finally`块构成了Java中使用的异常处理机制的核心。
- en: Exception types
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常类型
- en: 'Java has provided an extensive set of classes to support exception handling
    in Java. An exception is an instance of a class derived directly, or indirectly,
    from the `Throwable` class. Two predefined Java classes are derived from `Throwable`—`Error`
    and `Exception`. From the `Exception` class is derived a `RuntimeException` class.
    As we will see shortly, programmer-defined exceptions are normally derived from
    the `Exception` class:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java已经提供了一套广泛的类来支持Java中的异常处理。异常是直接或间接从`Throwable`类派生的类的实例。从`Throwable`派生了两个预定义的Java类——`Error`和`Exception`。从`Exception`类派生了一个`RuntimeException`类。正如我们将很快看到的，程序员定义的异常通常是从`Exception`类派生的：
- en: '![Exception types](img/7324_08_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![异常类型](img/7324_08_01.jpg)'
- en: 'There are numerous pre-defined errors that are derived from the `Error` and
    `RuntimeException` classes. There is little that a programmer will do with the
    exceptions derived from the `Error` object. These exceptions represent problems
    with the JVM and normally can''t be recovered. The `Exception` class is different.
    The two classes that derive from the `Exception` class support two types of exceptions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多预定义的错误，它们源自`Error`和`RuntimeException`类。程序员对于从`Error`对象派生的异常几乎不会做任何处理。这些异常代表了JVM的问题，通常无法恢复。`Exception`类是不同的。从`Exception`类派生的两个类支持两种类型的异常：
- en: '**Checked**: These are exceptions that need to be dealt with in the code'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经过检查的异常**：这些异常在代码中需要处理'
- en: '**Unchecked**: These are exceptions that do not need to be dealt with in the
    code'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未经检查的异常**：这些异常在代码中不需要处理'
- en: Checked exceptions include all exceptions derived from the `Exception` class
    and are not derived from the `RuntimeException` class. These must be handled in
    code or the code will not compile cleanly, resulting in compile-time errors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 经过检查的异常包括所有从`Exception`类派生而不是从`RuntimeException`类派生的异常。这些必须在代码中处理，否则代码将无法编译，导致编译时错误。
- en: Unchecked exceptions are all other exceptions. They include exceptions, such
    as division by zero and array subscripting errors. These do not have to be caught
    but like the `Error` exceptions, if they are not caught, the program will terminate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 未经检查的异常是所有其他异常。它们包括除零和数组下标错误等异常。这些异常不必被捕获，但是像`Error`异常一样，如果它们没有被捕获，程序将终止。
- en: We can create our own exception classes. When we do, we need to decide whether
    to create a checked or unchecked exception. A general rule of thumb is to declare
    the exception as an unchecked exception if the client code cannot do anything
    to recover from the exception. Otherwise, if they can handle it, make it a checked
    exception.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的异常类。当我们这样做时，我们需要决定是创建一个经过检查的异常还是未经检查的异常。一个经验法则是，如果客户端代码无法从异常中恢复，将异常声明为未经检查的异常。否则，如果他们可以处理它，就将其作为经过检查的异常。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The users of a class do not have to account for unchecked exceptions that can
    result in the program terminating, if the client program does not ever deal with
    them. A checked exception requires the client to either catch the exception or
    explicitly pass it up the call hierarchy.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类的用户不必考虑未经检查的异常，这些异常可能导致程序终止，如果客户端程序从未处理它们。一个经过检查的异常要求客户端要么捕获异常，要么显式地将其传递到调用层次结构中。
- en: Exception handling techniques in Java
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java中的异常处理技术
- en: 'There are three general techniques we can use when dealing with exceptions
    in Java:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Java异常时，我们可以使用三种常规技术：
- en: Traditional `try` block
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统的`try`块
- en: The new "try-with-resources" block introduced in Java 7
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 7中引入的新的“try-with-resources”块
- en: Pass the buck
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推卸责任
- en: 'The third technique is used when the current method is not the appropriate
    place to handle the exception. It allows the exception to be propagated higher
    into the sequence of method calls. In the following example, `anotherMethod` may
    encounter some condition where it may throw `IOException`. Instead of dealing
    with the exception in `someMethod` , the `throws` keyword in the `someMethod`
    definition results in the exception being passed to the code that called this
    method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种技术是在当前方法不适合处理异常时使用的。它允许异常传播到方法调用序列中更高的位置。在以下示例中，`anotherMethod`可能会遇到一些条件，导致它可能抛出`IOException`。在`someMethod`中不处理异常，而是在`someMethod`定义中使用`throws`关键字，结果是将异常传递给调用此方法的代码：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The method will skip all of the remaining lines of code in the method and immediately
    return to the caller. Uncaught exceptions are propagated to the next higher context
    until they are caught or they are thrown from `main`, where an error message and
    stack trace will be printed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将跳过方法中剩余的所有代码行，并立即返回给调用者。未捕获的异常会传播到下一个更高的上下文，直到它们被捕获，或者它们从`main`中抛出，那里将打印错误消息和堆栈跟踪。
- en: Stack trace
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆栈跟踪
- en: The `printStackTrace` is a method of the `Throwable` class that will display
    the program stack at that point in the program. It is used automatically when
    an exception is not caught or can be called explicitly. The output of the method
    pinpoints the line and method that caused the program to fail. You have seen this
    method in action before, whenever you had an unhandled runtime exception. The
    method is automatically called when an exception is not handled.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`printStackTrace`是`Throwable`类的一个方法，它将显示程序在该点的堆栈。当异常未被捕获时，它会自动使用，或者可以显式调用。该方法的输出指出了导致程序失败的行和方法。您以前已经看到过这种方法的使用，每当您遇到未处理的运行时异常时。当异常未被处理时，该方法会自动调用。'
- en: 'The `ExceptionDemo` program illustrates the explicit use of the method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExceptionDemo`程序说明了该方法的显式使用：'
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output is shown as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using Throwable methods
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Throwable方法
- en: 'The `Throwable` class possesses a number of other methods that can provide
    more insight in to the nature of the exception. To illustrate the use of many
    of these methods we will use the following code sequence. In this sequence we
    attempt to open a non-existent file and examine the exception thrown:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Throwable`类拥有许多其他方法，可以提供更多关于异常性质的见解。为了说明这些方法的使用，我们将使用以下代码序列。在这个序列中，我们尝试打开一个不存在的文件并检查抛出的异常：'
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Due to the nature of some IDEs, an application''s standard output and standard
    error output can be interleaved. For example, the execution of the above sequence
    may result in the following output. You may not or may see the interleaving in
    your output. The dashes in front of the output are used to help see the interleaving
    behavior:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一些IDE的性质，应用程序的标准输出和标准错误输出可能会交错。例如，上述序列的执行可能导致以下输出。您可能会在输出中看到交错，也可能不会看到。输出前面的破折号用于帮助查看交错行为：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The methods used in this example are summarized in the following table:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中使用的方法总结在以下表中：
- en: '| Method | Meaning |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 意义 |'
- en: '| --- | --- |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `getCause` | Returns the cause of the exception. If it cannot be determined
    it returns null. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `getCause` | 返回异常的原因。如果无法确定原因，则返回null。'
- en: '| `getMessage` | Returns a detailed message. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `getMessage` | 返回详细消息。|'
- en: '| `getLocalizedMessage` | Returns a localized version of the message. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `getLocalizedMessage` | 返回消息的本地化版本。|'
- en: '| `toString` | Returns the string version of the message. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `toString` | 返回消息的字符串版本。|'
- en: Notice that the first line of the `printStackTrace` method is the output of
    the `toString` method.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`printStackTrace`方法的第一行是`toString`方法的输出。
- en: 'The `getStackTrace` method returns an array of `StackTraceElement` objects
    where each element represents a line of the stack trace. We can duplicate the
    effect of the `printStackTrace` method with the following code sequence:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`getStackTrace`方法返回一个`StackTraceElement`对象数组，其中每个元素表示堆栈跟踪的一行。我们可以使用以下代码序列复制`printStackTrace`方法的效果：'
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When executed we get the following output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们得到以下输出：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The traditional try-catch block
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统的try-catch块
- en: The traditional technique to handle exceptions uses a combination of a `try`,
    `catch`, and `finally` blocks. A `try` block is used to surround code that might
    throw exceptions and is followed by zero or more `catch` blocks and then, optionally,
    by a single `finally` block.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常的传统技术使用`try`、`catch`和`finally`块的组合。`try`块用于包围可能引发异常的代码，然后是零个或多个`catch`块，最后是一个可选的`finally`块。
- en: The `catch` blocks are added after a `try` block to "catch" exceptions. The
    statements in the `catch` block provide blocks of code to "handle" the error.
    A `finally` clause can optionally be used after the catch blocks. It is guaranteed
    to execute even if code within a `try` or a `catch` block throws or does not throw
    an exception.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`块在`try`块之后添加以“捕获”异常。`catch`块中的语句提供了“处理”错误的代码块。在`catch`块之后可以选择使用`finally`子句。它保证即使`try`或`catch`块中的代码引发或不引发异常，也会执行。'
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: However, a finally block will not execute if the `System.exit` method is invoked
    in a try or catch block.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果在try或catch块中调用`System.exit`方法，则finally块将不会执行。
- en: 'The following sequence illustrates the use of these blocks. Within the try
    block, a line is read in and an integer is extracted. Two catch blocks are used
    to handle the exceptions that might be thrown:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下序列说明了这些块的使用。在try块内，读取一行并提取一个整数。使用两个catch块来处理可能抛出的异常：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'One of two types of errors is possible in this code sequence:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码序列中可能出现两种错误中的一种：
- en: Either an error will occur trying to read a line of input or
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么尝试读取输入行时会发生错误，要么
- en: An error will occur trying to convert the string to an integer
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试将字符串转换为整数时将发生错误
- en: The first catch block will catch IO errors and the second catch block will catch
    conversion errors. Only one catch block is ever executed when an exception is
    thrown.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个catch块将捕获IO错误，第二个catch块将捕获转换错误。当抛出异常时，只有一个catch块会被执行。
- en: An error may, or may not, occur. Regardless, the finally block will execute
    either after the try block completes or after a catch block executes. The `finally`
    clause is guaranteed to run and generally contains "clean-up" code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生错误，也可能不会。无论如何，finally块将在try块完成或catch块执行后执行。`finally`子句保证运行，并通常包含“清理”代码。
- en: Using the try-with-resource block
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用try-with-resource块
- en: The use of the previous technique can be cumbersome when multiple resources
    are opened and a failure occurs. It can result in multiple try-catch blocks that
    become hard to follow. In Java 7, the try-with-resources block was introduced
    to address this situation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个资源被打开并发生故障时，使用先前的技术可能会很麻烦。它可能导致多个难以跟踪的try-catch块。在Java 7中，引入了try-with-resources块来解决这种情况。
- en: The advantage of the try-with-resources block is that all resources opened with
    the block are automatically closed upon exit from the block. Any resources used
    with the try-with-resources block must implement the interface `java.lang.AutoCloseable`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: try-with-resources块的优势在于，块中打开的所有资源在退出块时会自动关闭。使用try-with-resources块的任何资源都必须实现`java.lang.AutoCloseable`接口。
- en: 'We will illustrate this approach by creating a simple method to copy one file
    to another. In the following example, one file is opened for reading and the other
    is opened for writing. Notice how they are created between the `try` keyword and
    the block''s open curly brace:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个简单的方法来将一个文件复制到另一个文件来说明这种方法。在下面的示例中，一个文件用于读取，另一个文件用于写入。请注意，它们是在`try`关键字和块的左花括号之间创建的：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Resources to be managed are declared and initialized inside a set of parentheses
    and are placed between the `try` keyword and the opening curly brace of the try
    block. The first resource is a `BufferedReader` object that uses the `data.txt`
    file and the second resource is a `BufferedWriter` object used with the `data.bak`
    file. The `Paths` class is new to Java 7 and provides improved IO support.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理的资源在一对括号内声明和初始化，并放在`try`关键字和try块的左花括号之间。第一个资源是使用`data.txt`文件的`BufferedReader`对象，第二个资源是与`data.bak`文件一起使用的`BufferedWriter`对象。`Paths`类是Java
    7中的新功能，提供了改进的IO支持。
- en: Resources declared with a try-with-resources block must be separated by semicolons
    otherwise a compile-time error will be generated. More in-depth coverage of the
    try-with-resources block can be found in The Java 7 Cookbook.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用try-with-resources块声明的资源必须用分号分隔，否则将生成编译时错误。有关try-with-resources块的更深入覆盖可以在《Java
    7 Cookbook》中找到。
- en: The use of the vertical bar in the catch block is new to Java 7 and allows us
    to catch multiple exceptions in a single catch block. This is explained in the
    *Using the | operator in a catch block* section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在catch块中使用竖线是Java 7中的新功能，允许我们在单个catch块中捕获多个异常。这在*在catch块中使用|运算符*部分有解释。
- en: Catch statement
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: catch语句
- en: 'The catch statement has exactly one argument. The catch statement will trap
    the exception if its parameter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: catch语句只有一个参数。如果catch语句的参数：
- en: Exactly matches the exception type
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全匹配异常类型
- en: Is a base of the exception type
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是异常类型的基类
- en: Is an interface that the exception type implements
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是异常类型实现的接口
- en: Only the first catch statement that matches the exception will execute. If no
    matches are made, the method will terminate and the exception will bubble up to
    the calling method where it may be handled.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 只有与异常匹配的第一个catch语句将被执行。如果没有匹配，方法将终止，并且异常将冒泡到调用方法，那里可能会处理它。
- en: 'A part of the earlier `try` block is duplicated as follows. The format of the
    `catch` statement consists of the `catch` keyword followed by a set of open and
    close parentheses enclosing an exception declaration. The set of parentheses is
    then followed by zero or more statements in a block statement:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`try`块的一部分如下所示重复。`catch`语句的格式由`catch`关键字后面跟着一组括号括起来的异常声明组成。然后是一个块语句中的零个或多个语句：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The process of handling an error is up to the programmer. It may be as simple
    as displaying an error message or it can be quite complex. The programmer may
    use the error object to retry the operation or otherwise deal with it. This may
    involve propagating it back to the calling method in some situations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 处理错误的过程由程序员决定。它可能只是简单地显示一个错误消息，也可能非常复杂。程序员可以使用错误对象重试操作或以其他方式处理它。在某些情况下，这可能涉及将其传播回调用方法。
- en: Order of the catch blocks
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: catch块的顺序
- en: The order in which catch blocks are listed after a try block can be significant.
    When an exception is thrown, the exception object is compared to the catch blocks
    in the order that they are listed. The comparison checks to see if the thrown
    exception is a type of the exception in the catch block.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在try块后列出catch块的顺序可能很重要。当抛出异常时，异常对象将按照它们的顺序与catch块进行比较。比较检查抛出的异常是否是catch块中异常的类型。
- en: For example, if a `FileNotFoundException` is thrown, it will match either a
    catch block that has an `IOException` or a `FileNotFoundException` exception because
    `FileNotFoundException` is a sub-type of `IOException`. As the comparison is stopped
    when the first match is found, if the catch block for `IOException` is listed
    before the catch block for `FileNotFoundException`, the `FileNotFoundException`
    block will never be executed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果抛出了`FileNotFoundException`，它将匹配具有`IOException`或`FileNotFoundException`异常的catch块，因为`FileNotFoundException`是`IOException`的子类型。由于在找到第一个匹配项时比较会停止，如果`IOException`的catch块在`FileNotFoundException`的catch块之前列出，`FileNotFoundException`块将永远不会被执行。
- en: 'Consider the following hierarchy of exception classes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下异常类的层次结构：
- en: '![Order of the catch blocks](img/7324_08_02.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![catch块的顺序](img/7324_08_02.jpg)'
- en: 'Given the following code sequence:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下代码序列：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If an exception is thrown that is one of these types of exceptions, the `AException`
    catch block will always be executed. This is because an `AException`, `BException`,
    `CException`, or a `DException` are all of the `AException` type. The exception
    will always match the `AException` exception. The other `catch` blocks will never
    be executed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出的异常是这些类型的异常之一，`AException` catch块将始终被执行。这是因为`AException`、`BException`、`CException`或`DException`都是`AException`类型。异常将始终匹配`AException`异常。其他`catch`块将永远不会被执行。
- en: 'The general rule is always to list the "most-derived" exceptions first. The
    following is the correct way of listing the exceptions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通常规则是始终首先列出“最派生”的异常。以下是列出异常的正确方式：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice, that it doesn't make any difference with this hierarchy of exceptions
    whether the `BException` immediately precedes or follows the `CException`, as
    they are at the same level.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于异常的这种层次结构，无论`BException`是紧接着还是跟在`CException`之后，都没有任何区别，因为它们处于同一级别。
- en: Using the | operator in a catch block
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在catch块中使用|运算符
- en: Sometimes it is desirable to handle multiple exceptions in the same way. Instead
    of duplicating the code in each catch block, we can use a vertical bar to permit
    one catch block to capture more than one exception.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有时希望以相同的方式处理多个异常。我们可以使用竖线来允许一个catch块捕获多个异常，而不是在每个catch块中重复代码。
- en: 'Consider the situation where two exceptions are potentially thrown and are
    handled in the same way:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑可能抛出两个异常并以相同方式处理的情况：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A vertical bar can be used to catch two or more exceptions in the same `catch`
    statement as illustrated in the following code snippet. This can reduce the amount
    of code needed to handle two exceptions that are handled in the same way.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 竖线可以用于在相同的`catch`语句中捕获两个或更多的异常，如下面的代码片段所示。这可以减少处理以相同方式处理的两个异常所需的代码量。
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This approach works when more than one exception can be handled in the same
    way. Keep in mind that the catch block''s parameter is implicitly final. It is
    not possible to assign a different exception to the parameter. The following attempt
    is illegal and will not compile:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个异常可以以相同方式处理时，这种方法是有效的。请记住，catch块的参数是隐式final的。无法将不同的异常赋值给该参数。以下尝试是非法的，不会编译通过：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The finally block
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: finally块
- en: The `finally` block follows a series of `catch` blocks and consists of the `finally`
    keyword followed by a block of statements. It contains one or more statements
    that will always be executed to clean up previous actions. The `finally` block
    will always execute regardless of the existence or non-existence of exceptions.
    However, if a `try` or `catch` block invokes the `System.exit` method, the program
    immediately terminates and the `finally` block does not execute.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块跟在一系列`catch`块后面，由`finally`关键字后面跟着一系列语句组成。它包含一个或多个语句，这些语句将始终被执行以清理之前的操作。`finally`块将始终执行，无论异常是否存在。但是，如果`try`或`catch`块调用了`System.exit`方法，程序将立即终止，`finally`块将不会执行。'
- en: The purpose of a `finally` block is to close or otherwise handle any resources
    that were opened within the `try` block. It is always a good practice to close
    resources after they have been opened and are no longer needed. We will this in
    the next example.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块的目的是关闭或以其他方式处理在`try`块中打开的任何资源。关闭不再需要的资源是一种良好的实践。我们将在下一个例子中看到这一点。'
- en: However, in practice this is often tedious and can be error prone if it is necessary
    to close multiple resources where the close process may also generate exceptions.
    In addition, if one resource throws an exception while being opened and another
    one was not opened, we have to be careful not to attempt to close the second one.
    As a result, in Java 7 the try-with-resources block has been introduced to address
    this type of problem. This block was discussed in the *Using the try-with-resource
    block* section. Here, we will cover the simplified use of the `finally` block.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实践中，这通常是繁琐的，如果需要关闭多个资源，关闭过程可能也会生成异常，这可能会导致错误。此外，如果一个资源在打开时抛出异常，而另一个资源没有打开，我们必须小心不要尝试关闭第二个资源。因此，在Java
    7中引入了try-with-resources块来解决这种问题。这个块在*使用try-with-resources块*部分中进行了讨论。在这里，我们将介绍`finally`块的简化使用。
- en: 'A simple example of using the `finally` block is shown as follows. In this
    sequence we will open a file for input and then display its content:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用`finally`块的简单示例如下所示。在这个序列中，我们将打开一个文件进行输入，然后显示其内容：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The file will be closed regardless of whether an exception was thrown or not.
    If the file does not exist, a `FileNotFoundException` will be thrown. This will
    be caught in the `catch` block. Notice how we checked the `reader` variable to
    make sure it was not null.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是否抛出异常，文件都将被关闭。如果文件不存在，将抛出`FileNotFoundException`。这将在`catch`块中捕获。请注意我们如何检查`reader`变量以确保它不是null。
- en: 'In the following example, we open two files and then try to copy one file to
    another. The finally block is used to close the resources. This illustrates a
    problem with the finally block when dealing with multiple resources:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们打开两个文件，然后尝试将一个文件复制到另一个文件。`finally`块用于关闭资源。这说明了在处理多个资源时`finally`块的问题：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice, that the `close` methods may also throw a `IOException`. We must also
    handle these exceptions. This may require a more complicated exception handling
    sequence which can be error prone. In this case, note that the second file will
    not be closed if an exception is thrown when the first file is closed. In this
    situation it is better to use the try-with-resources block, as discussed in the
    *Using the try-with-resources block* section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`close`方法也可能会抛出`IOException`。我们也必须处理这些异常。这可能需要一个更复杂的异常处理序列，这可能会导致错误。在这种情况下，请注意，如果在关闭第一个文件时抛出异常，第二个文件将不会被关闭。在这种情况下，最好使用try-with-resources块，如*使用try-with-resources块*部分所述。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A try block needs either a catch block or a finally block. Without one or both
    a compile time error will be generated.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: try块需要一个catch块或一个finally块。如果没有一个或两个，将生成编译时错误。
- en: Nested try-catch blocks
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套的try-catch块
- en: 'Exception handling can be nested. This can become necessary when methods are
    used in a `catch` or `finally` block that also throws exceptions. The following
    illustrates using a nested `try` block inside of a `catch` block:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理可以嵌套。当在`catch`或`finally`块中使用也会抛出异常的方法时，这可能是必要的。以下是在`catch`块中使用嵌套`try`块的示例：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the last example of the previous section, we used the `close` method inside
    a `finally` block. However, the `close` method may throw a `IOException`. As it
    is a checked exception, we will need to catch it. This results in a `try` block
    being nested inside of a `finally` block. In addition, when we try to close the
    `BufferedReader`, a `NullPointerException` will be thrown in the second `try`
    block because we attempted to execute the close method against the `reader` variable
    which was never assigned a value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的最后一个例子中，我们在`finally`块中使用了`close`方法。然而，`close`方法可能会抛出`IOException`。由于它是一个受检异常，我们需要捕获它。这导致了一个`try`块嵌套在一个`finally`块中。此外，当我们尝试关闭`BufferedReader`时，第二个`try`块将抛出`NullPointerException`，因为我们尝试执行关闭方法针对从未分配值的`reader`变量。
- en: 'To complete the previous example, consider the following implementation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成前面的例子，考虑以下实现：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We used the `|` bar to simplify the capture of both exceptions as detailed in
    the *Using the | operator in a catch block* section. This is also another example
    where we may lose the original exception. In this case, the `FileNotFoundException`
    was lost to a `NullPointerException`. This will be discussed in the *Losing the
    stack trace* section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`|`符号来简化捕获两个异常，如*在catch块中使用|操作符*部分所述。这也是我们可能丢失原始异常的另一个例子。在这种情况下，`FileNotFoundException`丢失为`NullPointerException`。这将在*丢失堆栈跟踪*部分中讨论。
- en: Exception handling guidelines
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理指南
- en: This section addresses general guidelines for working with exceptions. It is
    intended to provide examples of how to use exception handling in a more useful
    and productive manner. While poor techniques may not result in a compile-time
    error, or an incorrect program, they often reflect a poor design.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了处理异常的一般指导方针。它旨在提供如何以更有用和更有效的方式使用异常处理的示例。虽然糟糕的技术可能不会导致编译时错误或不正确的程序，但它们通常反映了糟糕的设计。
- en: Repeating code that threw an exception
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复抛出异常的代码
- en: When an exception is thrown and then caught we will sometimes want to try and
    re-execute the offending code. This is not difficult if the code is structured
    properly.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当抛出异常然后捕获时，我们有时会想尝试重新执行有问题的代码。如果代码结构良好，这并不困难。
- en: 'In this code sequence, errors are assumed to be present when the `try` block
    is entered. If an error is generated it is caught and handled by the `catch` block.
    As the `errorsArePresent` is still set to true, the try block will be repeated.
    However, if no errors occur, at the end of the try block the `errorsArePresent`
    flag is set to false which will allow the program to execute the while loop and
    continue executing:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码序列中，假设`try`块进入时存在错误。如果生成错误，它将被`catch`块捕获并处理。由于`errorsArePresent`仍然设置为true，`try`块将被重复执行。然而，如果没有发生错误，在`try`块结束时，`errorsArePresent`标志将被设置为false，这将允许程序执行while循环并继续执行：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: An assumption is made, in this example, that the code used to process the error
    will necessitate that the `try` block be re-executed. This may be the case when
    all we do in the process error code sequence is to display an error message that
    identifies the error, such as when the user enters a bad filename.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假设用于处理错误的代码将需要重新执行`try`块。当我们在处理错误代码序列中所做的一切就是显示一个标识错误的错误消息时，比如用户输入了一个错误的文件名时，这可能是情况。
- en: You need to be careful using this approach if the resource needed is not available.
    This can result in an infinite loop where we check for a resource that is not
    available, throw an exception, and then do it all over again. A loop counter can
    be added to specify the number of times we try to handle the exception.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所需的资源不可用，使用这种方法时需要小心。这可能导致一个无限循环，我们检查一个不可用的资源，抛出异常，然后再次执行。可以添加一个循环计数器来指定我们尝试处理异常的次数。
- en: Not being specific in which exception you are catching
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不具体指明捕获的异常
- en: 'When catching an exception, be specific about the one you need to catch. For
    example, in the following example the generic `Exception` is caught. There is
    nothing specific that will reveal more useful information about what caused the
    exception:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获异常时，要具体指明需要捕获的异常。例如，在以下示例中捕获了通用的`Exception`。没有具体的信息可以显示异常的原因：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A more useful version follows which catches the actual exception thrown:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个更有用的版本，它捕获了实际抛出的异常：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Losing the stack trace
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丢失堆栈跟踪
- en: 'Sometimes an exception is caught and then a different one is re-thrown. Consider
    the following method where a `FileNotFoundException` exception is thrown:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会捕获异常，然后重新抛出不同的异常。考虑以下方法，其中抛出了一个`FileNotFoundException`异常：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Assuming that the file does not exist, the following stack trace is generated:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设文件不存在，将生成以下堆栈跟踪：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can tell what the precise exception was and where it occurred. Next, consider
    the use of using the `MyException` class instead of the `FileNotFoundException`
    exception:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以知道确切的异常是什么，以及它发生在哪里。接下来，考虑使用`MyException`类而不是`FileNotFoundException`异常：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we re-throw the exception, as shown in the following code snippet, we will
    lose information about the original exception:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新抛出异常，就像下面的代码片段所示，我们将丢失有关原始异常的信息：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The stack trace that results from this implementation is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由此实现产生的堆栈跟踪如下：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice, that the details of the actual exception have been lost. In general
    it is a good idea not to use this approach as information crucial for debugging
    is lost. Another example of this problem is found in the *Nested try-catch blocks*
    section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实际异常的细节已经丢失。一般来说，最好不要使用这种方法，因为丢失了用于调试的关键信息。这个问题的另一个例子可以在*嵌套的try-catch块*部分找到。
- en: 'It is possible to re-throw and preserve the stack trace. To do this we need
    to do the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 可以重新抛出并保留堆栈跟踪。为此，我们需要做以下操作：
- en: Add a constructor with a `Throwable` object as a parameter.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个带有`Throwable`对象作为参数的构造函数。
- en: Use this when we want to preserve the stack trace.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在需要保留堆栈跟踪时使用这个。
- en: 'The following shows such a constructor added to the `MyException` class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了将此构造函数添加到`MyException`类中：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the `catch` block we will use this constructor, as shown below.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`catch`块中，我们将使用下面显示的这个构造函数。
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We could have thrown the exception. Instead, we use the `printStackTrace` method,
    shown as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以抛出异常。相反，我们使用了`printStackTrace`方法，如下所示：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Scoping and block lengths
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域和块长度
- en: 'The scope of any variable declared within a `try`, `catch`, or `finally` block
    is limited to that block. It is a good idea to limit the scope of a variable as
    much as possible. In the following example, it is necessary to define the `reader`
    variable outside of the try and catch blocks because it is needed in the `finally`
    block:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try`、`catch`或`finally`块中声明的任何变量的作用域都限于该块。尽可能地限制变量的作用域是一个好主意。在下面的示例中，由于在`finally`块中需要，所以需要在`try`和`catch`块之外定义`reader`变量：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The length of a block should be limited. However, blocks that are too small
    can result in your code becoming cluttered with the exception handling code. Let''s
    assume there are four methods that can each throw distinct exceptions. If we use
    separate try blocks for each method we will wind up with code similar to the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 块的长度应该是有限的。然而，块太小可能会导致您的代码变得混乱，异常处理代码也会变得混乱。假设有四种方法，每种方法都可能抛出不同的异常。如果我们为每个方法使用单独的try块，我们最终会得到类似以下的代码：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is somewhat unwieldy and also presents problems if a `finally` block is
    needed for each `try` block. A better approach, if these are logically related,
    uses a single `try` block, shown as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点笨拙，而且如果每个`try`块都需要一个`finally`块，也会出现问题。如果这些在逻辑上相关，一个更好的方法是使用一个单独的`try`块，如下所示：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Depending on the nature of the exceptions we can also use a common base class
    exception or, as introduced in Java 7, we can use the `|` operator with a single
    catch block. This is particularly useful if the exceptions can be dealt with in
    the same way.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据异常的性质，我们还可以使用一个通用的基类异常，或者在Java 7中引入的`|`运算符与单个catch块。如果异常可以以相同的方式处理，这是特别有用的。
- en: However, it is a bad practice to place the entire body of a method in a try/catch
    block which contains code not related to the exception. It is better to separate
    the exception handling code from the non-execution handling code if possible.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将整个方法体放在一个包含与异常无关的代码的try/catch块中是一个不好的做法。如果可能的话，最好将异常处理代码与非执行处理代码分开。
- en: A general rule of thumb is to keep the length of the exception handling code
    to a size that can be seen all at once. It is perfectly acceptable to use multiple
    try blocks. However, make sure that each block contains operations that are logically
    related. This helps modularize your code and makes it more readable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个经验法则是将异常处理代码的长度保持在一次可以看到的大小。使用多个try块是完全可以接受的。但是，请确保每个块包含逻辑相关的操作。这有助于模块化代码并使其更易读。
- en: Throwing a UnsupportedOperationException object
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出UnsupportedOperationException对象
- en: 'Methods that are intended to be overridden will sometimes return an "invalid"
    value to indicate that the method needs to be implemented. For example, in the
    following code sequence the `getAttribute` method returns `null`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，打算被覆盖的方法会返回一个“无效”的值，以指示需要实现该方法。例如，在以下代码序列中，`getAttribute`方法返回`null`：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: However, if the method is not overridden and the base class method is used,
    problems such as an incorrect result may result, or a `NullPointerException` may
    be generated, if a method is executed against the return value.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果该方法没有被覆盖并且使用了基类方法，可能会出现问题，例如产生不正确的结果，或者如果针对返回值执行方法，则可能生成`NullPointerException`。
- en: 'A better approach is to throw an `UnsupportedOperationException` to indicate
    that the method functionality has not yet been implemented. This is illustrated
    in the following code sequence:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是抛出`UnsupportedOperationException`来指示该方法的功能尚未实现。这在以下代码序列中有所体现：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The method cannot be used successfully until a valid implementation is provided.
    This approach is used frequently in the Java API. The `java.util.Collection` class'
    `unmodifiableList` method uses this technique ([http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Collections.html#unmodifiableList%28java.util.List%29](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Collections.html#unmodifiableList%28java.util.List%29)).
    Similar effects can be achieved by declaring the method as abstract.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供有效的实现之前，该方法无法成功使用。这种方法在Java API中经常使用。`java.util.Collection`类的`unmodifiableList`方法使用了这种技术（[http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Collections.html#unmodifiableList%28java.util.List%29](http://docs.oracle.com/javase/1.5.0/docs/api/java/util/Collections.html#unmodifiableList%28java.util.List%29)）。通过将方法声明为抽象，也可以实现类似的效果。
- en: Ignoring exceptions
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略异常
- en: It is generally a bad practice to ignore exceptions. They are thrown for a reason
    and if there is something you can do to recover, then you should deal with it.
    Otherwise, at minimum, you can gracefully terminate your application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通常忽略异常是一个不好的做法。它们被抛出是有原因的，如果有什么可以做来恢复，那么你应该处理它。否则，至少可以优雅地终止应用程序。
- en: 'For example, it is common to ignore an `InterruptedException`, as illustrated
    in the following code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通常会忽略`InterruptedException`，如下面的代码片段所示：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: However, even here something went wrong. For example, if the thread is a part
    of a thread pool, the pool may be terminating and you should handle this event.
    Always understand the environment in which your program is running in and expect
    the unexpected.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在这里也出了问题。例如，如果线程是线程池的一部分，池可能正在终止，你应该处理这个事件。始终了解程序运行的环境，并且预料到意外。
- en: 'Another example of poor error handling is shown in the following code snippet.
    In this example we ignore the `FileNotFoundException` exception that may be thrown:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个糟糕的错误处理示例在以下代码片段中显示。在这个例子中，我们忽略了可能抛出的`FileNotFoundException`异常：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This user is not aware that an exception was ever encountered. This is rarely
    an acceptable approach.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户并不知道曾经遇到异常。这很少是一个可以接受的方法。
- en: Handle exceptions as late as you can
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尽可能晚处理异常
- en: When an exception is thrown by a method, the user of the method can either deal
    with it at that point or pass the exception up the call sequence to another method.
    The trick is to handle the exception at the appropriate level. That level is typically
    the one that can do something about the exception.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法抛出异常时，方法的使用者可以在那一点处理它，或者将异常传递到调用序列中的另一个方法。诀窍是在适当的级别处理异常。通常，该级别是可以处理异常的级别。
- en: For example, if input is needed from the application's user to successfully
    handle the exception, then the level best suited for interacting with the user
    should be used. If the method is part of a library, then it may not be appropriate
    to assume that the user should be prompted. When we try to open a file and the
    file does not exist, we don't expect, or want the method we called, to prompt
    the user for a different file name. Instead, we are more inclined to do it ourselves.
    In some cases there may not even be a user to prompt as is the case with many
    server applications.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果需要应用程序用户的输入才能成功处理异常，那么应该使用最适合与用户交互的级别。如果该方法是库的一部分，那么假设用户应该被提示可能不合适。当我们尝试打开一个文件而文件不存在时，我们不希望调用的方法提示用户输入不同的文件名。相反，我们更倾向于自己处理。在某些情况下，甚至可能没有用户可以提示，就像许多服务器应用程序一样。
- en: Catching too much in a single block
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在单个块中捕获太多
- en: 'When we add catch blocks to an application, we are frequently tempted to use
    a minimal number of catch blocks by using a base class exception class to capture
    them. This is illustrated below where the catch block uses the `Exception` class
    to capture multiple exceptions. Here, we assume that multiple checked exceptions
    can be thrown and need to be handled:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向应用程序添加catch块时，我们经常会诱使使用最少数量的catch块，通过使用基类异常类来捕获它们。下面的示例中，catch块使用`Exception`类来捕获多个异常。在这里，我们假设可能会抛出多个已检查的异常，并且需要处理它们：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If they are all handled exactly the same way, this might be alright. However,
    if they differ in how they should be handled then we need to include additional
    logic to determine what actually happened. If we ignore the differences, then
    it can make any debugging process more difficult because we may have lost useful
    information about the exception. In addition, not only is this approach too coarse
    but we also catch all `RuntimeException`s which we may not be able to handle.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们都以完全相同的方式处理，那可能没问题。但是，如果它们在处理方式上有所不同，那么我们需要包含额外的逻辑来确定实际发生了什么。如果我们忽略了这些差异，那么它可能会使任何调试过程更加困难，因为我们可能已经丢失了有关异常的有用信息。此外，这种方法不仅太粗糙，而且我们还捕获了所有的
    `RuntimeException`，而这些可能无法处理。
- en: 'Instead, it is generally better to catch multiple exceptions in their own catch
    block, as illustrated in the following code snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，通常最好在它们自己的捕获块中捕获多个异常，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Logging exceptions
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录异常
- en: A common practice is to log exceptions even if they are handled successfully.
    This can be useful in assessing the behavior of an application. Of course, if
    we cannot handle the exception and need to gracefully terminate the application,
    error logs can be quite useful in determining what went wrong in the application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的做法是即使成功处理了异常，也要记录异常。这对评估应用程序的行为很有用。当然，如果我们无法处理异常并需要优雅地终止应用程序，错误日志可以帮助确定应用程序出了什么问题。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Log the exception only once. Logging multiple times can confuse whoever is trying
    to see what happened and create log files larger than they need to be.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 异常只记录一次。多次记录可能会让试图查看发生了什么的人感到困惑，并创建比必要更大的日志文件。
- en: Do not use exceptions to control normal logic flow
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要使用异常来控制正常的逻辑流程
- en: 'It is a poor practice to use exceptions where validation should be performed.
    In addition, throwing an exception uses up additional resources. For example,
    the `NullPointerException` is a common exception that results when a method is
    attempted to be executed against a reference variable that has a null value assigned
    to it. Instead of catching this exception, we should detect this condition and
    handle it in the normal logic sequence. Consider the following where we catch
    a `NullPointerException`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在应该进行验证的地方使用异常是不好的做法。此外，抛出异常会消耗额外的资源。例如，`NullPointerException` 是一种常见的异常，当尝试对一个具有空值分配的引用变量执行方法时会出现。我们应该检测这种情况并在正常的逻辑序列中处理它，而不是捕获这个异常。考虑以下情况，我们捕获了一个
    `NullPointerException`：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Instead, we should check the value of the state variable before it is used:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在使用状态变量之前应该检查它的值：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The need for the `try` block is eliminated altogether. An alternate approach
    uses short-circuiting as illustrated in the following code snippet and is covered
    in the *Short circuit evaluation* section of [Chapter 3](ch03.html "Chapter 3. Decision
    Constructs"), *Decision Constructs*. The use of the `equals` method is avoided
    if the `state` variable is null:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 完全消除了 `try` 块的需要。另一种方法使用短路评估，如下面的代码片段所示，并在 [第 3 章](ch03.html "第 3 章. 决策结构")
    的 *决策结构* 部分进行了介绍。如果 `state` 变量为空，则避免使用 `equals` 方法：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Do not try to handle unchecked exceptions
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要尝试处理未经检查的异常
- en: It is usually not worth the effort to deal with unchecked exceptions. Most of
    these are beyond the control of the programmer and would require significant effort
    to recover from. For example, a `ArrayIndexOutOfBoundsException`, while the result
    of a programming error, is not easily dealt with at runtime. Assuming that it
    would be feasible to modify the array index variable, it may not be clear what
    new value should be assigned to it or how to re-execute the offending code sequence.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不值得花费精力处理未经检查的异常。这些大多数是程序员无法控制的，并且需要大量的努力才能从中恢复。例如，`ArrayIndexOutOfBoundsException`，虽然是编程错误的结果，但在运行时很难处理。假设修改数组索引变量是可行的，可能不清楚应该为其分配什么新值，或者如何重新执行有问题的代码序列。
- en: Note
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Never catch `Throwable` or `Error` exceptions. These should never be handled
    or suppressed.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要捕获 `Throwable` 或 `Error` 异常。这些异常不应该被处理或抑制。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Proper exception handling in your program will enhance its robustness and reliability.
    The `try`, `catch`, and `finally` blocks can be used to implement exception handling
    within an application. In Java 7, the try-with-resources block has been added
    which more easily handles the opening and closing of resources. It is also possible
    to propagate an exception back up the call sequence.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 程序中的正确异常处理将增强其健壮性和可靠性。`try`、`catch` 和 `finally` 块可用于在应用程序中实现异常处理。在 Java 7 中，添加了
    try-with-resources 块，更容易处理资源的打开和关闭。还可以将异常传播回调用序列。
- en: We learned that the order of catch blocks is important in order to properly
    handle exceptions. In addition, the `|` operator can be used in a catch block
    to handle more than one exception in the same way.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了捕获块的顺序很重要，以便正确处理异常。此外，`|` 运算符可以在捕获块中使用，以相同的方式处理多个异常。
- en: Exception handling may be nested to address problems where the code within a
    catch, or finally block, may also throw an exception. When this happens, the programmer
    needs to be careful to insure that previous exceptions are not lost and that the
    new exceptions are handled appropriately.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理可能嵌套以解决在捕获块或 finally 块中的代码可能也会抛出异常的问题。当这种情况发生时，程序员需要小心确保之前的异常不会丢失，并且新的异常会得到适当处理。
- en: We also addressed a number of common problems that can occur when handling exceptions.
    They provided guidance as to avoid poorly structured and error prone code. These
    included not ignoring exceptions when they occur and to handle exceptions at the
    appropriate level.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还解决了处理异常时可能出现的一些常见问题。它们提供了避免结构不良和容易出错的代码的指导。这包括在异常发生时不要忽略异常，并在适当的级别处理异常。
- en: Now that we've learned about the exception handling process, we're ready to
    wrap up our coverage of the Java certification objectives in the next chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了异常处理过程，我们准备在下一章结束我们对Java认证目标的覆盖。
- en: Certification objectives covered
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涵盖的认证目标
- en: 'The certification objectives covered in this chapter include:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的认证目标包括：
- en: Describe what exceptions are used for in Java
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述Java中异常的用途
- en: Differentiate among checked exceptions, runtime exceptions, and errors
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分已检查的异常、运行时异常和错误
- en: Create a try-catch block and determine how exceptions alter normal program flow
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个try-catch块，并确定异常如何改变正常的程序流程
- en: Invoke a method that throws an exception
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用一个抛出异常的方法
- en: Recognize common exception classes and categories
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别常见的异常类和类别
- en: Test your knowledge
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: Which of the following implement checked exceptions?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些实现了已检查的异常？
- en: a. `Class A extends RuntimeException`
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: a. `Class A extends RuntimeException`
- en: b. `Class A extends Throwable`
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: b. `Class A extends Throwable`
- en: c. `Class A extends Exception`
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: c. `Class A extends Exception`
- en: d. `Class A extends IOException`
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: d. `Class A extends IOException`
- en: 'Given the following set of classes:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定以下一组类：
- en: '`class Exception A extends Exception {}`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`class Exception A extends Exception {}`'
- en: '`class Exception B extends A {}`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`class Exception B extends A {}`'
- en: '`class Exception C extends A {}`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`class Exception C extends A {}`'
- en: '`class Exception D extends C {}`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`class Exception D extends C {}`'
- en: 'What is the correct sequence of catch blocks for the following `try` block:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`try`块的catch块的正确顺序是什么？
- en: '[PRE42]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: a. Catch `A`, `B`, `C`, and `D`
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: a. 捕获`A`、`B`、`C`和`D`
- en: b. Catch `D`, `C`, `B`, and `A`
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: b. 捕获`D`、`C`、`B`和`A`
- en: c. Catch `D`, `B`, `C`, and `A`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: c. 捕获`D`、`B`、`C`和`A`
- en: d. Catch `C`, `D`, `B`, and `A`
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: d. 捕获`C`、`D`、`B`和`A`
- en: Which of the following statements are true?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些陈述是真的？
- en: a. Checked exceptions are those derived from the `Error` class.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: a. 已检查的异常是从`Error`类派生的异常。
- en: b. Checked exceptions should normally be ignored as we cannot not handle them.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: b. 应该通常忽略已检查的异常，因为我们无法处理它们。
- en: c. Checked exceptions must be re-thrown.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: c. 必须重新抛出已检查的异常。
- en: d. Checked exceptions should be handled at the appropriate method in the call
    stack.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: d. 应该在调用堆栈中的适当方法中处理已检查的异常。
- en: When a method throws a checked exception which of the following are valid responses?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个方法抛出一个已检查的异常时，以下哪些是有效的响应？
- en: a. Place the method in a try-catch block.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: a. 将方法放在try-catch块中。
- en: b. Do not use these types of methods.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: b. 不要使用这些类型的方法。
- en: c. Do nothing as we normally cannot handle checked exceptions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: c. 通常无法处理已检查的异常，因此不做任何处理。
- en: d. Use the `throws` clause on the method which calls this method.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: d. 在调用这个方法的方法上使用`throws`子句。
- en: What exceptions may the following code generate at runtime?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码可能在运行时生成什么异常？
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: a. `ArithmeticException`
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: a. `ArithmeticException`
- en: b. `DivisionByZeroException`
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: b. `DivisionByZeroException`
- en: c. `FileNotFoundException`
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: c. `FileNotFoundException`
- en: d. `NullPointerException`
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: d. `NullPointerException`
