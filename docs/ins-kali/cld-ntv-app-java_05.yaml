- en: Designing Your Cloud-Native Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计您的云原生应用程序
- en: In this chapter, we pause application development and take a step back to look
    at the bigger picture of designing cloud applications. As seen in the first chapter,
    applications in the cloud have more unique challenges than the traditional enterprise
    applications that we have been developing so far. Also, the business requirement
    of agility has to be met by not compromising on performance, stability, and resiliency.
    Hence, a look at the first principles becomes important.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们暂停应用程序开发，退一步看设计云应用的整体情况。正如在第一章中所看到的，云中的应用比我们迄今为止开发的传统企业应用有更多独特的挑战。此外，敏捷的业务需求必须在不牺牲性能、稳定性和弹性的情况下得到满足。因此，看待第一原则变得重要。
- en: In the first chapter, we had a look at the differences between cloud environments
    and traditional enterprises, and how the concepts of DevOps, 12-factor app, microservices,
    and ecosystems are important. Here, we will look at the various principles and
    techniques that enable us to design robust, scalable, and agile applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们看到了云环境和传统企业之间的差异，以及DevOps、12因素应用程序、微服务和生态系统的概念是如何重要的。在这里，我们将看一下各种原则和技术，使我们能够设计健壮、可扩展和敏捷的应用程序。
- en: Some of the areas we will cover include the dominance of the REST, HTTP, and
    JSON for building APIs, the role of the API gateways, how to decouple applications,
    how to identify microservices, various microservice design guidelines, the role
    of the data architecture, and the role of security in designing the APIs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖的一些领域包括使用REST、HTTP和JSON构建API的主导地位，API网关的作用，如何解耦应用程序，如何识别微服务，各种微服务设计指南，数据架构的作用，以及在设计API时安全性的作用。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Popularity of REST, HTTP, and JSON
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST、HTTP和JSON的流行
- en: Rise and popularity of the APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API的兴起和流行
- en: Role of API gateways
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关的角色
- en: Decoupling—the need for smaller application boundaries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解耦-需要更小的应用边界
- en: Microservice identifications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务识别
- en: Microservice design guidelines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务设计指南
- en: Microservice patterns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务模式
- en: Data architecture
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据架构
- en: Role of security
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全角色
- en: The trio – REST, HTTP, and JSON
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三者-REST、HTTP和JSON
- en: The web has made HTTP tremendously popular and is the de facto integration mechanism
    for accessing content on the internet. Interestingly, this technology was not
    hugely popular within applications that relied on native and binary protocols,
    such as RMI and CORBA for inter-application access.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 网络使得HTTP变得非常流行，并成为访问互联网内容的事实集成机制。有趣的是，这项技术在依赖本地和二进制协议（如RMI和CORBA）进行应用程序访问的应用程序中并不是非常流行。
- en: When social consumer companies, such as Google, Amazon, Facebook, and Twitter,
    started publishing APIs to connect/integrate with their products, the de facto
    standard for integration across the web became HTTP/REST. Social consumer companies
    started investing in platforms for onboard developers to develop various applications
    leading to the proliferation of applications that relied on HTTP as the protocol.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当社交消费公司（如Google、Amazon、Facebook和Twitter）开始发布API以连接/集成其产品时，跨网络的集成的事实标准变成了HTTP/REST。社交消费公司开始投资于平台，以吸引开发人员开发各种应用程序，从而导致依赖HTTP作为协议的应用程序的大量增加。
- en: The applications on the browser side are a mix of HTML and JavaScript. Information
    returned from the server or across other applications needs to be in a simple
    and usable format. JavaScript supports data manipulation, and the data format
    that it suited most is **JavaScript Object Notation** (**JSON**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器端的应用程序是HTML和JavaScript的混合。从服务器返回的信息或其他应用程序需要以简单和可用的格式。 JavaScript支持数据操作，最适合的数据格式是**JavaScript对象表示**（**JSON**）。
- en: 'REST is a state representational style that provides a way to deal with interchange
    over HTTP. REST has a lot factors in its favor:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种状态表示风格，提供了一种处理HTTP交换的方式。 REST有很多优势：
- en: Utilizes the HTTP protocol standard, giving it an immense leg up for anything
    and everything on WWW
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用HTTP协议标准，为WWW上的任何事物提供了巨大的优势
- en: Mechanism to isolate the access to entities (`GET`/`PUT`/`POST`/`DELETE`) while
    still utilizing the same HTTP request model
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离对实体的访问（`GET`/`PUT`/`POST`/`DELETE`）的机制，同时利用相同的HTTP请求模型
- en: Supports JSON as the data format
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持JSON作为数据格式
- en: 'REST with JSON has become the dominant model over the SOAP/XML model. According
    to one statistic from ProgrammableWeb:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: REST与JSON已经成为主导模型，超过了SOAP/XML模型。根据可编程Web的统计数据：
- en: 73% of the APIs on Programmable Web use REST. SOAP is far behind but is still
    represented in 17% of the APIs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 73%的可编程Web API使用REST。 SOAP远远落后，但在17%的API中仍有所体现。
- en: 'Let''s cover some high-level reasons why the REST/JSON model is favored over
    the SOAP/XML model of service development:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些REST/JSON模型受欢迎的高级原因：
- en: SOAP model of contract first approach makes crafting web services difficult.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOAP的契约优先方法使得制作Web服务变得困难。
- en: SOAP is complex compared to REST, giving a steeper learning curve as compared
    to REST.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与REST相比，SOAP更复杂，学习曲线更陡。
- en: REST is lightweight compared to SOAP and does not tax the bandwidth as much
    as SOAP.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与SOAP相比，REST更轻量级，不会像SOAP那样占用带宽。
- en: Support for SOAP outside of the Java world is limited, relegating SOAP primarily
    to the enterprise world.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java世界之外，对SOAP的支持有限，主要将SOAP局限于企业世界。
- en: XML parsing on the client side is memory and compute intensive, which does not
    lend well to the mobile world.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端上的XML解析需要大量内存和计算资源，这不适合移动世界。
- en: XML Schema/markup provides structure definitions and validation models but at
    the expense of additional parsing. JSON has a loose syntax allowing rapid iterations
    on the data model.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML模式/标记提供了结构定义和验证模型，但需要额外的解析。 JSON具有松散的语法，允许对数据模型进行快速迭代。
- en: Today, the reality is REST/JSON has been adopted as the standard for integration
    across programming languages providing an easy and simple way to integrate APIs
    over the internet.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，现实是REST/JSON已经成为跨编程语言集成的标准，为通过互联网集成API提供了一种简单易行的方式。
- en: Rise and popularity of the APIs
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API的兴起和流行
- en: An **Application Programming Interface** (**API**) provides a standard interface
    or contract to consume its services over the internet. The API defines the structure
    of the input and output and remains constant over the life of an API version.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**API**）提供了一个标准的接口或契约，以通过互联网消费其服务。API定义了输入和输出的结构，并在API版本的整个生命周期内保持不变。'
- en: APIs are the contract between the client layer and the enterprise. They are
    consumer-oriented, that is, designed by the client, and they abstract the service
    implementation details from the client.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: API是客户端层和企业之间的契约。它们是面向消费者的，即由客户端设计，并且将服务实现细节从客户端抽象出来。
- en: Coming back to the advent of social consumer companies, creating new applications
    meant not starting from scratch. For example, if my application needs to use geographical
    maps, I can make use of the Google Map APIs and build my application on top of
    that. Similarly, instead of building my own authentication model, I can make use
    of OAuth and use Google, Facebook, or Twitter as some of the OAuth providers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 回到社交消费者公司的出现，创建新的应用程序并不意味着从头开始。例如，如果我的应用程序需要使用地理地图，我可以利用Google地图API并在此基础上构建我的应用程序。同样，我可以利用OAuth而不是构建自己的身份验证模型，并使用Google、Facebook或Twitter作为一些OAuth提供者。
- en: This entire model of making a repeatable but often complex functionality available
    as a reusable service led to a model where the developer started building the
    applications using these pre-existing APIs, which in turn led to increased developer
    productivity and evolution of the modern day applications or mobile applications
    economy.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个可重复但通常复杂的功能作为可重用服务提供的整个模型，导致开发人员开始使用这些现有的API构建应用程序，从而提高了开发人员的生产力，并推动了现代应用程序或移动应用程序经济的发展。
- en: Companies started to look to see if they could monetize the APIs, which meant
    multiple companies were writing/publishing APIs that provided similar functionalities.
    This led to the democratization of the APIs allowing anyone and everyone access
    to features/functions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 公司开始寻求是否可以将API商品化，这意味着多家公司正在编写/发布提供类似功能的API。这导致了API的民主化，使任何人都可以访问功能/函数。
- en: This whole democratization of the API meant, suddenly, every process or functionality
    could be provided as a set of APIs that could be orchestrated or choreographed
    to build new features or functions. What took months or years earlier, now only
    takes weeks or days. All this productivity means shorter development cycles, allowing
    rapid iteration to provide new and innovative features.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: API的整个民主化意味着，突然之间，每个流程或功能都可以作为一组API来提供，可以编排或编排以构建新的功能。以前需要几个月甚至几年的时间，现在只需要几周甚至几天。所有这些生产力意味着更短的开发周期，允许快速迭代提供新的创新功能。
- en: 'Today, all kinds of APIs are available: from social companies such as Facebook,
    Google, and Twitter to enterprises such as Salesforce, NetSuite, and PaaS/IaaS
    providers, such as AWS, Azure, **Google Cloud Engine** (**GCE**), and so on, that
    all provide functionality from provisioning a VM to a database instance, to AI
    providers such as Watson, AWS AI, and Azure ML.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，各种类型的API都可以使用：从Facebook、Google和Twitter等社交公司到Salesforce、NetSuite和PaaS/IaaS提供商，如AWS、Azure、**Google
    Cloud Engine**（**GCE**）等，它们都提供从提供虚拟机到数据库实例，再到Watson、AWS AI和Azure ML等AI提供商的功能。
- en: Role of API gateways
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关的作用
- en: 'An API gateway is a singular interface that handles all the incoming requests
    before redirecting to the internal servers. An API gateway typically provides
    the following functions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: API网关是一个单一的接口，它在重定向到内部服务器之前处理所有传入的请求。API网关通常提供以下功能：
- en: Routes the incoming traffic to the appropriate service hosted with the provider's
    data center/cloud. Provides a reverse proxy model to limit the exposure of various
    APIs and services hosted within the provider's data center/cloud.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将传入流量路由到提供者的数据中心/云中托管的适当服务。提供反向代理模型，限制提供者数据中心/云中托管的各种API和服务的暴露。
- en: Filters all the incoming traffic from all kind of channels—web, mobile, and
    so on.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤来自各种渠道的所有传入流量——Web、移动等。
- en: Implements security mechanisms (such as OAuth) to authenticate and log the service
    usage.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施安全机制（如OAuth）来验证和记录服务的使用情况。
- en: Provides ability to throttle and limit traffic to certain services.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了对某些服务的流量控制和限制能力。
- en: Transforms data between the service consumer and provider.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务消费者和提供者之间转换数据。
- en: 'Provides one or more APIs that map to an underlying service provider. For example,
    for different kind of consumers—mobile, web, paid service, or a free service,
    the same underlying service can be split into multiple custom APIs that are exposed
    to a different set of consumers, so that the consumer sees only the features it
    needs:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个或多个API，映射到底层的服务提供者。例如，对于不同类型的消费者——移动、Web、付费服务或免费服务，相同的底层服务可以分成多个自定义API，暴露给不同的消费者，以便消费者只看到它需要的功能：
- en: '![](img/5215f408-cc6f-4926-ad6a-70890fc44f04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5215f408-cc6f-4926-ad6a-70890fc44f04.jpg)'
- en: Benefits of an API gateway
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关的好处
- en: 'Use of API gateways provides the following benefits:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API网关提供以下好处：
- en: '**Separation of concerns**: Insulates the microservice providers from the service
    consumers on the application side. This allows the separation of the application
    tier from the service requesting clients.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：在应用程序端将微服务提供者与服务消费者隔离开来。这允许将应用程序层与服务请求客户端分离。'
- en: '**Consumer oriented**: API gateways provide a unified hub for a large number
    of APIs and microservices. This allows the consumer to focus on API utility instead
    of locating where a service is hosted, managing service request limits, security,
    and so on.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向消费者：API网关为大量的API和微服务提供了一个统一的中心。这使得消费者可以专注于API的实用性，而不是寻找服务的托管位置，管理服务请求限制，安全性等。
- en: '**API oriented**: Provides an optimum API based on the type of the client and
    required protocols.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向API：根据客户端的类型和所需的协议提供最佳的API。
- en: '**Orchestration**: Provides the ability to orchestrate multiple services calls
    into one API call, which in turn simplifies the logic for a client. Now, instead
    of calling multiple services, it can invoke one API. Fewer requests means less
    invocation overhead and improve the consumer experience overall. An API gateway
    is essential for mobile applications.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编排：提供了将多个服务调用编排成一个API调用的能力，从而简化了客户端的逻辑。现在，它可以调用一个API而不是调用多个服务。较少的请求意味着较少的调用开销，从而提高了消费者的整体体验。API网关对移动应用程序至关重要。
- en: '**Monitor**: An API gateway also provides the ability to monitor API invocations,
    which in turn allows enterprises to evaluate the success of APIs and their usage.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控：API网关还提供了监控API调用的能力，从而使企业能够评估API的成功和使用情况。
- en: Besides the overall benefits, API gateways add more pieces to the overall puzzle.
    Meaning more infrastructure to manage, more configurations to manage, more points
    of failure, and additional hops to the requests. So, unless the benefits outweigh
    the drawbacks, use of API gateways needs be carefully scrutinized for the business
    requirements and benefits.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了总体利益外，API网关为整体拼图增加了更多的部分。这意味着需要管理更多的基础设施、更多的配置、更多的故障点和额外的请求跳转。因此，除非利益超过了缺点，否则需要仔细审查API网关的使用，以满足业务需求和利益。
- en: Next, we will see the process of breaking down the application functionalities
    as a set of APIs or microservices.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到将应用程序功能拆分为一组API或微服务的过程。
- en: Application decoupling
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序解耦
- en: The traditional model of application development, where all the features and
    functionalities were bundled in a large package called a monolithic application,
    is becoming less popular for multiple reasons. Monolith applications take on too
    many responsibilities in the form of function and logic. It is this characteristic
    which leaves them with high coupling and low cohesion. The reuse factor in monoliths
    tends to be low since one part of the functionality cannot be separated from the
    rest of the function and logic.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的应用程序开发模型，将所有功能和功能捆绑在一个称为单体应用程序的大型包中，由于多种原因而变得不太受欢迎。单体应用程序以功能和逻辑的形式承担了太多的责任。正是这一特征使它们具有高耦合和低内聚。单体应用程序中的重用因子往往较低，因为功能的一部分无法与其余的功能和逻辑分离。
- en: As we start breaking down the monolith functionality or even designing a new
    application, the focus needs to be on defining the service boundaries. Defining
    the right set of service boundaries and their related interactions is what leads
    to high cohesion and low coupling models.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始拆分单体功能或设计新应用程序时，重点需要放在定义服务边界上。定义正确的服务边界及其相关的交互是导致高内聚和低耦合模型的关键。
- en: The question becomes, what is the basis on which the application should be decoupled
    into services and defined service boundaries?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，应用程序应该根据什么基础被解耦为服务，并定义服务边界？
- en: Bounded context/domain-driven design
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有界上下文/领域驱动设计
- en: As part of the application design, the business domain needs to be broken down
    into smaller subdomains or business capabilities. We need to carefully examine
    the business entities and their attributes to define service boundaries. For example,
    in the case of customer ID entity, the address of the customer might be integral
    to the customer. Within the context of the application, address maintenance might
    be a separate activity and might need to be handled separately. Similarly, customer
    preferences or shopping habits might be required for personalization. In this
    case, the personalization engine is more interested in this set of attributes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序设计的一部分，业务领域需要被拆分为更小的子领域或业务能力。我们需要仔细审查业务实体及其属性，以定义服务边界。例如，在客户ID实体的情况下，客户的地址可能是客户的一部分。在应用程序的上下文中，地址维护可能是一个单独的活动，可能需要单独处理。同样，个性化可能需要客户偏好或购物习惯。在这种情况下，个性化引擎更感兴趣这一系列属性。
- en: Should we be slapping together one big customer service having all kind of attributes
    or can it be divided based on the perspectives derived from the business? These
    different perspectives are what led to the definition of bounded context as part
    of the domain-driven design.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该组合一个包含所有属性的大型客户服务，还是可以根据业务派生的不同视角进行划分？这些不同的视角导致了领域驱动设计中有界上下文的定义。
- en: 'The bounded context is a domain-driven design paradigm that helps to add a
    seam and create service groups. Bounded contexts work in solution-space to indicate
    that the services are related and belong to a common functional domain. It is
    built by one team that works with one business unit as per Inverse Conway''s law.
    A bounded context may communicate with the other services/business capabilities
    through:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有界上下文是一种领域驱动设计范式，有助于添加一个接缝并创建服务组。有界上下文在解决方案空间中工作，表明服务相关并属于一个共同的功能域。它是由一个团队根据反向康威定律与一个业务单元一起构建的。有界上下文可以通过以下方式与其他服务/业务能力进行通信：
- en: Exposing internal APIs or services
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露内部API或服务
- en: Emitting events on the Event Bus
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事件总线上发出事件
- en: A bounded context may have its own data store common to services or adopt a
    data store per service paradigm.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有界上下文可以拥有自己的数据存储，服务共用，或采用每个服务一个数据存储的范式。
- en: Each bounded context has a life of its own and forms a product. Teams are organized
    around these bounded contexts and they take the full responsibility of the full
    stack implementation of the services. The teams are cross-functional and bring
    skills from development, testing, user experience, database, deployment, and project
    management. Each product might be split into smaller sets of services that communicate
    asynchronously with each other. Remember, the focus is not on a set of functionalities
    but rather on business capability.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个有界上下文都有自己的生命周期，并形成一个产品。团队围绕这些有界上下文组织，并全权负责服务的全栈实现。团队是跨职能的，并从开发、测试、用户体验、数据库、部署和项目管理中带来技能。每个产品可能会被拆分成较小的服务集，它们之间异步通信。请记住，重点不是一组功能，而是业务能力。
- en: We start building our services around business capabilities. The service owns
    its business data and functionality. The service is the master of such data, and
    other services cannot own any of this service data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始围绕业务能力构建我们的服务。服务拥有其业务数据和功能。服务是这些数据的主人，其他服务不能拥有该服务的任何数据。
- en: Classification into up/downstream services
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上游/下游服务的分类
- en: Another way to break down the application systems is to categorize them by upstream
    and downstream data flow models. Core entities in the system comprise the upstream
    services. These upstream services than raise events that are subscribed by the
    downstream services to augment their functionality. This is aimed at decoupling
    the systems and help improve the overall business agility. This works well with
    Reactive, also known as event-driven, architecture concepts.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种拆分应用系统的方法是通过上游和下游数据流模型对其进行分类。系统中的核心实体包括上游服务。这些上游服务会触发事件，下游服务会订阅这些事件以增强其功能。这旨在解耦系统，并有助于提高整体业务敏捷性。这与反应式架构概念相吻合，也被称为事件驱动架构。
- en: 'Let''s take a simplified view of an e-commerce application, where the core
    entities are **CUSTOMER** and **PRODUCT**. The **ORDER** service depends on information
    about customers and products from the core entities. Next, we are building services
    that provide **RECOMMENDATION** and **PERSONALIZATION** services to the customer.
    The **RECOMMENDATION** and **PERSONALIZATION** services depend upon data from
    the core entities—**CUSTOMER**, **PRODUCT**, and **ORDER**. When there is a change
    to any of the core entities, changes are published. These changes are picked up
    by the **RECOMMENDATION** and **PERSONALIZATION** services, where they augment
    this data with additional attributes to provide relevant services. The **RECOMMENDATION**
    and **PERSONALIZATION** services downstream these services:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以电子商务应用程序为例，其中核心实体是客户和产品。订单服务依赖于核心实体客户和产品的信息。接下来，我们正在构建为客户提供推荐和个性化服务的服务。推荐和个性化服务依赖于核心实体客户、产品和订单的数据。当核心实体发生变化时，变化会被发布。这些变化会被推荐和个性化服务接收，它们会使用额外的属性来提供相关服务。推荐和个性化服务是这些服务的下游服务。
- en: '![](img/6188e3d5-a83d-41a7-a81e-9ae52fde7529.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6188e3d5-a83d-41a7-a81e-9ae52fde7529.jpg)'
- en: This model of classifying the business capabilities into **UPSTREAM** and **DOWNSTREAM**
    help define the dependency relationships between services and change the impact
    of any upstream services on the downstream services.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将业务能力分类为上游和下游的模型有助于定义服务之间的依赖关系，并改变上游服务对下游服务的影响。
- en: Business events
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务事件
- en: As the system evolves, the services will start aggregating into natural allies.
    This means finding out whether the services are depending on a similar set of
    data elements or providing overlapping/side-kick functionality, and can potentially
    be part of the same bounded context.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的发展，服务将开始聚集成自然的盟友。这意味着找出服务是否依赖于类似的数据元素或提供重叠/配角功能，并且可能成为同一有界上下文的一部分。
- en: Services within the bounded context working within the same domain might need
    to rely on the master for accurate functioning. This might mean, some of the master
    service data attributes need to be made available to the associated bounded context
    services. For example, in our previous example, we talked of customer preferences.
    Now, these preferences might need to be mapped to the location (address) of the
    customer. In this case, should the customer preference call the customer address
    service every time to build the preferences or can it copy the relevant attributes
    to its own domain? Without duplication of data, the two services start getting
    coupled tightly, leading to a two-way communication model. To break this tight
    coupling, we allow the customer preferences service to cache or duplicate the
    relevant customer attributes using the events. This asynchronous model breaks
    the temporal tight coupling between the services. Whenever there is a change of
    customer address, the service publishes a business event for the requisite change.
    The change is subscribed by the customer preferences, which picks up the change
    to update its preferences model.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一领域内工作的有界上下文服务可能需要依赖于主服务以实现准确的功能。这可能意味着一些主服务数据属性需要提供给相关的有界上下文服务。例如，在我们之前的例子中，我们谈到了客户偏好。现在，这些偏好可能需要映射到客户的位置（地址）。在这种情况下，客户偏好是否需要每次调用客户地址服务来构建偏好，还是可以将相关属性复制到自己的领域中？在不重复数据的情况下，这两个服务开始紧密耦合，导致双向通信模型。为了打破这种紧密耦合，我们允许客户偏好服务使用事件来缓存或复制相关的客户属性。这种异步模型打破了服务之间的时间紧密耦合。每当客户地址发生变化时，服务都会发布一个业务事件进行必要的更改。客户偏好服务会订阅这个变化，以更新其偏好模型。
- en: 'This asynchronous model allows us to make sure:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种异步模型使我们能够确保：
- en: Ownership of data is still clear. Any change to data is declared to the dependent
    services. The dependent services are allowed to hold or duplicate data, but not
    change the local copy unless the master copy is updated (golden source principle).
    The dependent services store only the subset of data that is required and functionally
    relevant (need-to-know principle).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据所有权仍然清晰。对数据的任何更改都会通知依赖服务。允许依赖服务保存或复制数据，但不更改本地副本，除非更新主副本（黄金源原则）。依赖服务仅存储所需和功能相关的数据子集（需要知道原则）。
- en: Asynchronous business events lead to low coupling between services. Core service
    changes result in an event. Events travel downstream to interested dependent services.
    The only dependency is the format of the business event published.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步业务事件导致服务之间的低耦合。核心服务的更改会导致事件。事件向下游传递给感兴趣的依赖服务。唯一的依赖是发布的业务事件的格式。
- en: Downstream services follow the eventual consistency principle; all business
    events are stored in a sequential manner to construct/state a later time (event
    sourcing/CQRS). Query models can be different from the system of record.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下游服务遵循最终一致性原则；所有业务事件都以顺序方式存储，以构建/状态一个较晚的时间（事件源/CQRS）。查询模型可以与记录系统不同。
- en: Asynchronous models of business events also promote choreography over orchestration,
    leading to loosely coupled systems/services.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务事件的异步模型也促进了编排而不是管弦乐，从而导致了松散耦合的系统/服务。
- en: At times, when teams start on a new product, an upfront definition of bounded
    context or services decomposition might not be possible. So, teams start building
    the application as a monolithic application by exposing its functionality as a
    set of services. As the team implements more stories, they can identify pieces
    of functionality that are changing at a fast pace (typically experience or channel
    services) versus slow changing pieces (typically core services or entity services).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当团队开始一个新产品时，可能无法事先定义界限上下文或服务分解。因此，团队开始构建应用程序作为一个单片应用程序，通过将其功能公开为一组服务。随着团队实施更多的故事，他们可以确定功能的部分，这些功能以快速的速度变化（通常是体验或渠道服务）与变化缓慢的部分（通常是核心服务或实体服务）。
- en: The team can start putting the services into two categories—experience and system
    services. System services can further be grouped together around entities and
    interrelations. Experience services are mapped to the customer journeys. Teams
    will typically have sprints just to clean/refactor the code to clear the technical
    debt that accumulates with every cycle.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 团队可以开始将服务分为两类——体验和系统服务。系统服务可以进一步围绕实体和相互关系进行分组。体验服务映射到客户旅程。团队通常会有冲刺来清理/重构代码，以清除每个周期积累的技术债务。
- en: So, the next question is, what identifies a service as a microservice?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，下一个问题是，什么标识一个服务为微服务？
- en: Microservice identification
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务识别
- en: 'The name microservice does not necessarily mean that the service has to be
    small in size. But it has the following characteristics:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的名称并不一定意味着服务必须体积小。但它具有以下特点：
- en: '**Single responsibility principle**: This is the core design principle of microservices.
    They should do one business unit of a task and do it completely. If there is low
    coupling, the services will be easier to modify and deploy or even replace altogether.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一责任原则：这是微服务的核心设计原则。它们应该完成一个业务任务单元并完全完成它。如果耦合度低，服务将更容易修改和部署，甚至完全替换。
- en: '**Granular**: Microservice granularity is contained within the intersection
    of a single functional domain, a single data domain and its immediate dependencies,
    a self-sufficient packaging, and a technology domain.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 粒度：微服务的粒度包含在单个功能域、单个数据域及其直接依赖、自包含的打包和技术域的交集中。
- en: '**Bounded**: A service should have access to resources within its bounded context,
    which is managed by the same team. However, it should not access resources of
    other modules, such as cache and databases, directly. If a service needs to access
    other modules it should do so through an internal API or service layer. This helps
    reduce coupling and promotes agility.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 界限：服务应该可以访问其界限上下文中由同一团队管理的资源。但是，它不应直接访问其他模块的资源，如缓存和数据库。如果服务需要访问其他模块，应通过内部API或服务层进行。这有助于减少耦合并促进敏捷性。
- en: '**Independent**: Each microservice is developed, tested, and deployed independently,
    in its own source. It can use third-party or shared libraries.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立：每个微服务都是独立开发、测试和部署的，在其自己的源中。它可以使用第三方或共享库。
- en: Differences between microservices and service-oriented architecture (SOA)
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务和服务导向架构（SOA）之间的区别
- en: 'Here are the differences between microservices and **service-oriented architecture**
    (**SOA**):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是微服务和服务导向架构（SOA）之间的区别：
- en: A service executes the entire business unit of work. For example, if a service
    requires customer or product data, it is preferable to store it within the service
    data stores. Typically, there is no need to go to a customer service for getting
    a customer record through ESB.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务执行整个业务工作单元。例如，如果一个服务需要客户或产品数据，最好将其存储在服务数据存储中。通常，不需要通过ESB获取客户记录。
- en: A service has its own private database or a database that is shared only in
    its bounded context and can store the information required to service the business
    unit of work.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务有自己的私有数据库或仅在其界限上下文中共享的数据库，并且可以存储为服务业务工作单元提供所需的信息。
- en: A service is a smart endpoint and typically exposes a REST interface with a
    contract definition in Swagger or similar repository. Some of the services that
    are consumed by other divisions or clients are exposed through an API platform.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务是一个智能端点，通常通过Swagger或类似的存储库中的合同定义公开REST接口。一些被其他部门或客户使用的服务通过API平台公开。
- en: Service granularity
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务粒度
- en: 'Here are the types of services:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务的类型：
- en: '**Atomic or system services**: These are the services that do a unit level
    of work and are enough to service the request by either referring to a database
    or a downstream source.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子或系统服务**：这些服务执行单元级别的工作，并且足以通过引用数据库或下游源来服务请求。'
- en: '**Composite or process services**: These services depend on the coordination
    between two or more atomic services. Typically, composite microservices are discouraged
    unless the business case already involves using existing atomic services. An example
    is a credit card payment from a savings account that calls two services, one to
    debit the savings account, and an other to credit the card account. Composite
    microservices also introduce inherent complexity such as state management and
    transactions that are difficult in a distributed scenario.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复合或过程服务**：这些服务依赖于两个或多个原子服务之间的协调。通常情况下，除非业务案例已经涉及使用现有的原子服务，否则不鼓励使用复合微服务。例如，从储蓄账户进行信用卡支付需要调用两个服务，一个是借记储蓄账户，另一个是贷记信用卡账户。复合微服务还引入了固有的复杂性，例如在分布式场景中难以处理的状态管理和事务。'
- en: '**Experience services**: These services are tied to the customer journey and
    are deployed at the edge of the infrastructure. These services handle requests
    from the mobile and web applications. These services are exposed through a reverse
    proxy using tools such as API gateways.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**体验服务**：这些服务与客户旅程相关，并部署在基础架构的边缘。这些服务处理来自移动和Web应用程序的请求。这些服务通过使用诸如API网关之类的工具，通过反向代理公开。'
- en: Microservice design guidelines
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务设计指南
- en: The whole notion of microservices is about the separation of concerns. This
    requires a logical and architectural separation between the services with different
    responsibilities. Here are a few guidelines to design the microservices.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 整个微服务的概念是关于关注点的分离。这需要在具有不同责任的服务之间进行逻辑和架构上的分离。以下是设计微服务的一些建议。
- en: 'These guidelines are in line with the 12-factor applications guidelines given
    by Heroku engineers:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指南符合Heroku工程师提出的12因素应用程序指南。
- en: '**Lightweight**: Microservices have to be lightweight in order to facilitate
    smaller memory footprints and faster startup times. This facilitates faster MTTR,
    and allows for services to be deployed on smaller runtime instances, hence horizontally
    scaling better. Compared to heavy runtime times, such as application servers,
    smaller runtimes such as Tomcat, Netty, Node.js, and Undertow are more suited.
    Also, the services should exchange data in lightweight text formats, such as JSON,
    or binary formats, such as Avro, Thrift, or Protocol Buffers.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻量级**：微服务必须轻量级，以便实现更小的内存占用和更快的启动时间。这有助于更快的MTTR，并允许服务部署在更小的运行时实例上，因此在水平方面更好地扩展。与重型运行时（如应用服务器）相比，更适合的是较小的运行时，如Tomcat、Netty、Node.js和Undertow。此外，服务应该使用轻量级文本格式（如JSON）或二进制格式（如Avro、Thrift或Protocol
    Buffers）交换数据。'
- en: '**Reactive**: This is applicable to services with highly concurrent loads or
    slightly longer response times. Typical server implementations block threads to
    execute imperative programming styles. As microservices could depend on other
    microservices or I/O resources such as a database, blocking threads could increase
    operating system overheads. The Reactive style operates on non-blocking I/O, uses
    call back handlers, and reacts to events. This does not block threads and as a
    result, increases the scalability and load handling characteristics of the microservices
    much better. Database drivers have started supporting reactive paradigms, for
    example, MongoDB Reactive Streams Java Driver.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式**：这适用于具有高并发负载或稍长的响应时间的服务。典型的服务器实现会阻塞线程以执行命令式编程风格。由于微服务可能依赖于其他微服务或I/O资源（如数据库），阻塞线程可能会增加操作系统的开销。响应式风格采用非阻塞I/O，使用回调处理程序，并对事件做出反应。这不会阻塞线程，因此可以更好地增加微服务的可伸缩性和负载处理特性。例如，数据库驱动程序已开始支持响应式范例，比如MongoDB响应式流Java驱动程序。'
- en: '**Stateless**: Stateless services scale better and start faster as there is
    no state to be stored on disk on shutdown or activated on start-up. They are also
    more resilient, as termination of a service will not result in a loss of data.
    Being stateless is also a step towards being lightweight. If a state is required,
    a service can delegate state storage to a high speed persistent (key value) store,
    or hold it in distributed caches.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：无状态服务具有更好的扩展性和更快的启动速度，因为在关闭或启动时不需要在磁盘上存储状态。它们也更具弹性，因为终止服务不会导致数据丢失。无状态也是朝着轻量级的一步。如果需要状态，服务可以将状态存储委托给高速持久（键值）存储，或者将其保存在分布式缓存中。'
- en: '**Atomic**: This is the core design principle of microservices. They should
    be easy to change, test, and deploy. All these can be achieved if the services
    are reasonably small and do the smallest business unit of work that can be done
    independently. If there is low coupling, the services will be easier to modify
    and independently deploy. Composite microservices may be required on a need basis
    but should be limited in design.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性**：这是微服务的核心设计原则。如果服务足够小并且执行可以独立完成的最小业务单元，那么它们应该易于更改、测试和部署。如果耦合度低，服务将更容易修改和独立部署。可能需要根据需要使用复合微服务，但设计应该受到限制。'
- en: '**Externalized configuration**: Typical application properties and configurations
    were traditionally managed as configuration files. Given the multiple and large
    deployments of microservices, this practice will start getting cumbersome, as
    the scale of the services increase. Hence, it is better to externalize the configurations
    in the configuration server, so that it can be maintained in a hierarchical structure
    per environment. Features such as hot changes can also be easier to reflect many
    services at once.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部化配置**：传统上，典型的应用程序属性和配置是作为配置文件进行管理的。鉴于微服务的多个和大规模部署，随着服务规模的增加，这种做法将变得繁琐。因此，最好将配置外部化到配置服务器中，以便可以按环境在分层结构中进行维护。诸如热更改之类的功能也可以更容易地同时反映多个服务。'
- en: '**Consistent**: Services should be written in a consistent style as per the
    coding standards and naming convention guidelines. Common concerns such as serialization,
    REST, exception handling, logging, configuration, property access, metering, monitoring,
    provisioning, validations, and data access should be consistently done through
    reusable assets, annotations, and so on. It should be easier for another developer
    from the same team to understand the intent and operation of the service.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：服务应该按照编码标准和命名约定指南以一致的风格编写。常见关注点，如序列化、REST、异常处理、日志记录、配置、属性访问、计量、监控、供应、验证和数据访问应该通过可重用资产、注释等一致地完成。另一个团队的开发人员应该更容易理解服务的意图和操作。 '
- en: '**Resilient**: Services should handle exceptions arising from technical reasons
    (connectivity, runtime), and business reasons (invalid inputs) and not crash.
    They should use patterns such as timeouts and circuit breakers to ensure that
    the failures are handled carefully.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有弹性**：服务应该处理由技术原因（连接性、运行时）和业务原因（无效输入）引起的异常，并且不会崩溃。它们应该使用超时和断路器等模式来确保故障得到谨慎处理。'
- en: '**Good citizens**: Report their usage statistics, number of times accessed,
    average response times, and so on through JMX API, and/or publish it through libraries
    to central monitoring infrastructures, log audit, error, and business events in
    the standards prescribed. Expose their condition through health check interfaces,
    for example, as done by Spring Actuator.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**良好的服务对象**：通过JMX API报告其使用统计数据、访问次数、平均响应时间等，并/或通过库发布到中央监控基础设施、日志审计、错误和业务事件中。通过健康检查接口公开其状态，例如Spring
    Actuator所做的那样。'
- en: '**Versioned**: Microservices may need to support multiple versions for different
    clients, till all clients migrate to higher versions. Hence the deployments and
    URL should support semantic versioning, that is, X.X.X.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本化**：微服务可能需要支持不同客户端的多个版本，直到所有客户端迁移到更高版本。因此，部署和URL应该支持语义版本控制，即X.X.X。'
- en: 'In addition, microservices will need to leverage additional capabilities that
    are typically built at an enterprise level such as:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，微服务还需要利用通常在企业级别构建的额外能力，比如：
- en: '**Dynamic service registry**: Microservice registers itself with a service
    registry when up.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态服务注册表**：微服务在启动时会向服务注册表注册自己。'
- en: '**Log aggregation**: The logs generated by a microservice can be aggregated
    for central analysis and troubleshooting. The log aggregation is a separate infrastructure
    and typically built as an async model. Products such as Splunk and ELK Stack in
    conjunction with event streams such as Kafka are used to build/deploy the log
    aggregation systems.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志聚合**：微服务生成的日志可以被聚合起来进行集中分析和故障排除。日志聚合是一个独立的基础设施，通常建立为异步模型。产品如Splunk和ELK
    Stack与事件流（如Kafka）一起被用来构建/部署日志聚合系统。'
- en: '**External configuration**: The microservice can get the parameters and properties
    from an external configuration such as Consul and Zookeeper to initialize and
    run.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部配置**：微服务可以从外部配置（如Consul和Zookeeper）中获取参数和属性以初始化和运行。'
- en: '**Provisioning and auto-scaling**: The service is automatically started by
    a PaaS environment if it detects a need to start an additional instance based
    on incoming load, some services failing, or not responding in time.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应和自动扩展**：如果PaaS环境检测到需要根据传入负载启动额外实例、某些服务失败或未及时响应，则服务将自动启动。'
- en: '**API gateway**: A microservice interface can be exposed to the clients or
    other divisions through an API gateway that provides abstraction, security, throttling,
    and service aggregation.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API网关**：微服务接口可以通过API网关向客户端或其他部门公开，提供抽象、安全性、限流和服务聚合。'
- en: We cover all the service design guidelines in subsequent chapters as we start
    building and deploying the services.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建和部署服务时，我们将在后续章节中涵盖所有服务设计指南。
- en: Design and deployment patterns
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计和部署模式
- en: As you start designing the applications, you need to be aware of the various
    service design and integration patterns.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始设计应用程序时，您需要了解各种服务设计和集成模式。
- en: Design patterns
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: The microservice design patterns can be categorized into multiple categories
    depending upon the problem being solved. The most common categories and the relevant
    patterns are discussed in the following sections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务设计模式可以根据所解决的问题进行多种分类。最常见的分类和相关模式将在以下部分讨论。
- en: Content aggregation patterns
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容聚合模式
- en: With microservices and bounded context, there is an additional responsibility
    of content aggregation. A client may need information that spans multiple domains
    or business areas (or in solution terms, the bounded contexts). The content required
    may not be available with one service. These patterns help identify and model
    the experience services category mostly. Hence there are various patterns for
    aggregation that can be applied.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随着微服务和有界上下文，内容聚合有了额外的责任。客户端可能需要跨多个领域或业务领域（或在解决方案术语中，有界上下文）获取信息。所需的内容可能无法由一个服务提供。这些模式有助于识别和建模体验服务类别。因此，有各种聚合模式可以应用。
- en: Aggregation by client
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端聚合
- en: 'Aggregation at the last mile. This applies to web browsers or a reasonable
    *processing capable* user interface, which is showing content from various domains.
    This pattern is typically used in the home page that aggregates various subject
    areas. Also, it''s the pattern popularly used by Amazon:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一英里的聚合。这适用于Web浏览器或合理的*处理能力*用户界面，它显示来自各个领域的内容。这种模式通常用于聚合各种主题领域的主页。此外，这是亚马逊广泛使用的模式。
- en: '![](img/b012f926-e78e-4ed4-852f-7da40ffff847.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b012f926-e78e-4ed4-852f-7da40ffff847.jpg)'
- en: '**Benefits**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**好处**'
- en: 'The benefits of using the aggregation by the client pattern are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用客户端模式进行聚合的好处如下：
- en: Decoupled approach at the services layer. Easier for agility and maintainability
    at each individual service.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务层的解耦方法。更容易实现每个单独服务的灵活性和可维护性。
- en: Faster perceived performance at the UI layer, since the requests, can run in
    parallel to populate the various areas on the screen. More enhanced when there
    is a higher bandwidth available to fetch data in parallel.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UI层面，感知性能更快，因为请求可以并行运行，以填充屏幕上的各个区域。当有更高的带宽可用于并行获取数据时，效果更好。
- en: '**Trade-offs**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**权衡**'
- en: 'The trade-offs associated with the aggregation by the client pattern are as
    follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户端模式相关的权衡如下：
- en: Sophisticated user interface processing capabilities, such as Ajax and single-page
    application required
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要复杂的用户界面处理能力，如Ajax和单页面应用程序。
- en: The knowledge of aggregation is exposed at the UI layer, hence if the similar
    output was given as a dataset to a third-party, aggregation would be required
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合的知识暴露在UI层，因此，如果类似的输出被作为数据集提供给第三方，就需要进行聚合。
- en: API aggregation
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API聚合
- en: 'Aggregation at the gates. This applies to mobile or third-party use cases that
    do not want to know the details of the aggregation and instead would want to expect
    one data structure over a single request. The API gateways are designed to do
    this aggregation and then expose a unified service to the client. The API gateways
    can also select to eliminate any data sections in the aggregate service if it
    is not required to be shown during content aggregation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在门上进行聚合。这适用于不想了解聚合细节的移动或第三方用例，而是希望在单个请求中期望一个数据结构。API网关被设计用于进行此聚合，然后向客户端公开统一的服务。如果在内容聚合期间不需要显示任何数据部分，API网关也可以选择消除这些数据部分：
- en: '![](img/6350e60c-8796-421c-854a-487e27090da7.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/6350e60c-8796-421c-854a-487e27090da7.jpg)
- en: '**Benefits**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**好处**'
- en: 'The benefits of using the API aggregation pattern are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用API聚合模式的好处如下：
- en: The individual service details are abstracted from the client by the API gateway.
    Hence it gives the flexibility to change the services internally without affecting
    the client tier.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关将客户端与个别服务的细节抽象出来。因此，它可以在不影响客户端层的情况下灵活更改服务。
- en: Better in bandwidth constrained scenarios where running parallel HTTP requests
    may not be a good idea.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在带宽受限的情况下更好，不适合运行并行HTTP请求的情况。
- en: Better in UI processing constrained scenarios where processing power might not
    be enough for concurrent page generation.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在UI处理受限的情况下更好，处理能力可能不足以进行并发页面生成。
- en: '**Trade-offs**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**权衡**'
- en: 'The trade-offs associated with the API aggregation pattern are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与API聚合模式相关的权衡如下：
- en: Where there is sufficient bandwidth, the latency of this option is higher than
    the aggregation by the client. This is because the API gateway waits for all the
    content to be aggregated before sending the data out to the client.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有足够带宽的情况下，此选项的延迟高于客户端的聚合。这是因为API网关在发送数据给客户端之前需要等待所有内容被聚合。
- en: Microservice aggregation
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务聚合
- en: 'Aggregation at the business tier. In this approach, a microservice aggregates
    the responses from the various constituent microservices. This pattern is useful
    if there is any real-time business logic to be applied while aggregating data.
    For example, showing the total value of customer holdings across various businesses:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 业务层的聚合。在这种方法中，一个微服务聚合来自各个组成微服务的响应。如果在聚合数据时需要应用任何实时业务逻辑，这种模式非常有用。例如，显示跨各种业务的客户持有总价值：
- en: '![](img/2a298f28-adc3-4fa9-890d-e21915cb946c.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/2a298f28-adc3-4fa9-890d-e21915cb946c.jpg)
- en: '**Benefits**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**好处**'
- en: 'The benefits of using the microservice aggregation pattern are as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务聚合模式的好处如下：
- en: Finer control on the aggregation. Also, there is a possibility of incorporating
    the business logic based on aggregated data. Thus, offering richer content aggregation
    capabilities.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对聚合的更精细控制。此外，还有可能根据聚合数据应用业务逻辑。因此，提供了更丰富的内容聚合能力。
- en: Lower dependency on API gateway capabilities.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对API网关能力的依赖较低。
- en: '**Trade-offs**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**权衡**'
- en: 'The trade-offs associated with the microservice aggregation pattern are as
    follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与微服务聚合模式相关的权衡如下：
- en: Lower latency and more code, as there is an additional hop introduced due to
    an additional step.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于引入了额外的步骤，延迟更低，代码更多。
- en: More chances of failure or making mistakes. Parallel aggregation from microservices
    will need sophisticated code such as reactive or call back mechanisms.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败或出错的机会更多。来自微服务的并行聚合将需要诸如响应式或回调机制等复杂的代码。
- en: Database aggregation
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库聚合
- en: 'Aggregation at the data tier. In this approach, data is pre-aggregated into
    an **operational data store** (**ODS**) typically a document database. This approach
    is useful for scenarios where there is additional business inference on the aggregated
    data that is difficult to compute in real time through a microservice, and hence
    can be pre-computed by an analytical engine:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层的聚合。在这种方法中，数据被预先聚合到一个**运营数据存储**（**ODS**）中，通常是文档数据库。这种方法对于存在额外业务推断的情况非常有用，这些推断很难通过微服务实时计算，因此可以由分析引擎预先计算：
- en: '![](img/bf820d8a-153c-4fe8-b19b-349ca501f6e3.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/bf820d8a-153c-4fe8-b19b-349ca501f6e3.jpg)
- en: '**Benefits**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**好处**'
- en: 'The benefits of using the database aggregation pattern are as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据库聚合模式的好处如下：
- en: Additional enrichment of data by analytical jobs is possible. For example, in
    a customer 360° view, based on the customer portfolio aggregated in the ODS, additional
    analytics can be applied for **next-best-action** (**NBA**) scenarios.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过分析作业对数据进行额外丰富。例如，在基于ODS中聚合的客户投资组合的客户360°视图中，可以应用额外的分析来实现**下一步最佳行动**（**NBA**）场景。
- en: More flexible and capable as compared to the earlier approaches, and finer control
    on the data model can be exercised.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与早期方法相比更灵活和功能更强，对数据模型可以进行更精细的控制。
- en: '**Trade-offs**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**权衡**'
- en: 'The trade-offs associated with the database aggregation pattern are as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库聚合模式相关的权衡如下：
- en: Higher complexity
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更高的复杂性
- en: Data duplication and more data storage requirements
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据重复和更多的数据存储需求
- en: Additional ETL or **change data capture** (**CDC**) tools required to send the
    data from the system of a record to a central ODS store
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要额外的ETL或**变更数据捕获**（**CDC**）工具来将数据从记录系统发送到中央ODS存储
- en: Coordination patterns
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协调模式
- en: Ideally, microservices should be capable of doing a business unit of work. However,
    in some business scenarios, microservices have to leverage other services as a
    dependency, or as a composition. For example, consider a credit card payment that
    first debits a savings account and then credits a card account. In this case,
    the two underlying services, such as debit and credit, could be exposed by the
    respective savings account and credit card domains and coordination is required
    between them.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，微服务应该能够执行业务工作单元。然而，在某些业务场景中，微服务必须利用其他服务作为依赖项或组合。例如，考虑首先从储蓄账户借记，然后向信用卡账户贷记的信用卡支付。在这种情况下，两个基础服务，如借记和贷记，可以由各自的储蓄账户和信用卡领域公开，并且它们之间需要协调。
- en: Business process management (BPM)
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务流程管理（BPM）
- en: Complex coordination that involves long-running processes are better done by
    BPM. An enterprise might already have a BPM product. However, BPM might be overkill
    for simple two- or three-step coordination.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及长时间运行过程的复杂协调最好由BPM完成。企业可能已经拥有BPM产品。然而，对于简单的两步或三步协调，BPM可能过于复杂。
- en: Composite services
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合服务
- en: The guideline is to use composite services for low complexity (or simple) coordination
    that is high in volume. Such coordination can be referred to as microflows for
    the rest of the discussion.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 指导方针是对于低复杂度（或简单）但高容量的协调使用复合服务。在讨论的其余部分，这样的协调可以被称为微流程。
- en: Why composite services?
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用复合服务？
- en: In microservices architecture, the implementation of the service definition
    is done by smaller deployable units instead of large monolith applications that
    run in application servers. This makes the services easier to write, faster to
    change and test, and quicker to deploy. But this also creates a challenge for
    microflows that span two or more microservices, perhaps across multiple bounded
    contexts. In a monolith application, such microflows could be coordinated as a
    single transaction across two modules deployed in a single deployable unit. In
    microservices architecture, distributed transactions are discouraged and hence,
    microflows have to be solved using a composition approach.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，服务定义的实现是通过较小的可部署单元而不是在应用服务器中运行的大型单体应用程序来完成的。这使得服务更容易编写，更快更改和测试，以及更快部署。但这也为跨两个或多个微服务的微流程，甚至跨多个有界上下文的微流程带来了挑战。在单体应用程序中，这样的微流程可以作为单个事务在单个可部署单元中部署的两个模块之间的协调。在微服务架构中，分布式事务是不鼓励的，因此，微流程必须使用组合方法来解决。
- en: Capabilities for microservices coordination
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务协调的能力
- en: 'This section lists the capabilities that the composite services require:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本节列出了复合服务所需的能力：
- en: '**State management**: Often the state manager component is required to manage
    the output state of the services that it is coordinating. This state will need
    to be held in a persistent store that is immune to **server-side state management**
    (**SSM**) failure. Another SSM instance should be able to retrieve the state and
    start where it left off.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态管理**：通常需要状态管理器组件来管理它协调的服务的输出状态。这种状态将需要保存在对**服务器端状态管理**（**SSM**）故障免疫的持久存储中。另一个SSM实例应该能够检索状态并从上次离开的地方开始。'
- en: '**Transaction control**: Transaction boundaries are affected by microservices.
    Two separate function calls to two methods in a single transaction now become
    two separate service calls through a composite service. There are two approaches
    to handle this scenario.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务控制**：微服务会影响事务边界。现在，对单个事务中的两个方法进行两个独立的函数调用，现在变成了通过复合服务进行两个独立的服务调用。有两种方法来处理这种情况。'
- en: '**Distributed transactions**: These support the two-phase commit protocol.
    They are not scalable, increase latency and deadlocking scenarios, and need expensive
    products and infrastructure to support them. They may not be supported over selected
    protocols, such as REST or messaging. The benefit of this style is that the system
    is always in a consistent state.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式事务**：这些支持两阶段提交协议。它们不具有可伸缩性，会增加延迟和死锁情况，并且需要昂贵的产品和基础设施来支持它们。它们可能不受选定协议的支持，例如REST或消息传递。这种风格的好处是系统始终处于一致的状态。'
- en: '**Compensating transactions**: Where the transaction control is functionally
    enforced by running functionally reverse transactions instead of trying to roll
    back to an earlier transaction. This is a more decoupled, and hence scalable,
    approach.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**补偿事务**：在这种情况下，事务控制是通过运行功能性反向事务来实现，而不是尝试回滚到较早的事务。这是一种更解耦的，因此可扩展的方法。'
- en: We would recommend compensating transactions over distributed transactions due
    to simplification in the technical product requirements.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于技术产品要求的简化，我们建议使用补偿事务而不是分布式事务。
- en: '**Post service call coordination**: Atomic service calls can result in success,
    that is, when the constituent services have finished their work successfully;
    or a failure, when either of the coordination services has either not responded
    or failed in processing due to a technical or functional error. The composite
    service will need to get the response of the completed services and decide on
    the next step of action.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**邮件服务调度**：原子服务调用可能会成功，也就是说，当组成服务成功完成其工作时；或者失败，当协调服务之一未响应或由于技术或功能错误而在处理中失败时。复合服务将需要获取已完成服务的响应，并决定下一步的行动。'
- en: '**Timeout handling**: Initiate a timer when starting a microflow. If the services
    do not respond in a particular time from starting the microflow, then raise an
    event to send to the event bus.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**超时处理**：在启动微流程时启动计时器。如果服务在启动微流程后的特定时间内没有响应，则触发一个事件发送到事件总线。'
- en: '**Configurability**: Multiple instances of the SSM component will run to cater
    for various microflows. In each of the microflows, the service coordination, timer,
    and actions will differ. Hence, it is important to provide a framework that can
    have parameterized configuration of the timers, compensation transactions, and
    post-processing actions.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可配置性**：SSM组件的多个实例将运行以满足各种微流程。在每个微流程中，服务协调、计时器和操作都会有所不同。因此，提供一个可以对计时器、补偿事务和后处理操作进行参数化配置的框架非常重要。'
- en: Coordination models
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协调模型
- en: We will discuss the following coordination styles of composite service micro
    flows.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论复合服务微流程的以下协调样式。
- en: Asynchronous parallel
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步并行
- en: A composite service initiates the service calls asynchronously to the constituent
    atomic services and then listens to the service response. If either services fails,
    it sends a compensating transaction to the other service.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 复合服务异步地启动对组成原子服务的服务调用，然后监听服务响应。如果任一服务失败，它会向另一个服务发送补偿事务。
- en: 'This is similar to the Scatter-Gather or Composed Message Processor patterns
    of the EIP:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于EIP的散射-聚集或组合消息处理器模式：
- en: '![](img/e0536935-ad8e-4c6e-81b2-f071cd6a3f31.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0536935-ad8e-4c6e-81b2-f071cd6a3f31.jpg)'
- en: Asynchronous sequential
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步顺序
- en: 'In pipeline processing, composite services send messages to atomic services
    sequentially. It waits for the previous service to return success before calling
    the next service. If anyone service fails, then the composite service sends the
    compensating transaction to previously successful services. This is similar to
    the Process Manager pattern in the EIP:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道处理中，复合服务按顺序向原子服务发送消息。它在调用下一个服务之前等待前一个服务返回成功。如果任何一个服务失败，那么复合服务将向先前成功的服务发送补偿事务。这类似于EIP中的过程管理器模式：
- en: '![](img/70b88b81-c1d8-4343-9436-a0291742dc0c.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/70b88b81-c1d8-4343-9436-a0291742dc0c.jpg)'
- en: Orchestration using request/response
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用请求/响应进行编排
- en: Similar to the preceding section, but in request/response and sync fashion instead
    of async messaging.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的部分类似，但是以请求/响应和同步方式进行，而不是异步消息传递。
- en: '![](img/3730ee35-9058-4174-931c-36a88e596599.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3730ee35-9058-4174-931c-36a88e596599.jpg)'
- en: Collapsing the microservices
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并微服务
- en: 'An option for when there seems to be a coupling between composite and its constituent
    microservice collapsing the services, and run as a single component. For example,
    transferring funds can be implemented by an account service, with an additional
    method `transferFunds` accepting `fromAcc`, `toAcc`, and the fund amount. It can
    then issue the `debit` and `credit` method calls as part of a single transaction.
    However, this approach needs to be decided after due consideration. The drawbacks
    include coupling deploying of debit and credit services of the credit card and
    savings domain:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当复合服务与其组成微服务之间存在耦合时，可以将服务合并并作为单个组件运行。例如，可以通过账户服务实现资金转移，额外的`transferFunds`方法接受`fromAcc`、`toAcc`和资金金额。然后，它可以作为单个事务的一部分发出`debit`和`credit`方法调用。然而，这种方法需要经过充分考虑后才能决定。缺点包括耦合部署信用卡和储蓄领域的借记和贷记服务：
- en: '![](img/eb3a11c8-fbb0-4660-b108-c5e79c1cbfcc.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb3a11c8-fbb0-4660-b108-c5e79c1cbfcc.jpg)'
- en: Deployment patterns
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署模式
- en: Microservices attempt to solve monolith problems such as dependencies, and achieve
    agility by having separate deployable units. We can deploy the microservices on
    the target runtime in various styles. The options are described in the order of
    increasing isolation (good) and cost (bad).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务试图解决单体应用程序的问题，如依赖关系，并通过具有单独的可部署单元来实现敏捷性。我们可以以各种风格将微服务部署到目标运行时。这些选项按照隔离度（好）和成本（坏）的增加顺序进行描述。
- en: Multiple services per WAR file
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个WAR文件中的多个服务
- en: 'Although development might be in a microservice style (separate code base for
    services, different teams working on different services), the deployment essentially
    follows the monolith style:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管开发可能是以微服务风格进行的（为服务单独的代码库，不同的团队负责不同的服务），但部署基本上遵循单体应用程序的风格：
- en: '![](img/f48fa51a-45b9-43f8-8dd5-9ce28884b1af.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f48fa51a-45b9-43f8-8dd5-9ce28884b1af.jpg)'
- en: Benefits and trade-offs
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利弊
- en: The only benefit compared to a complete monolith style is that due to separate
    code bases and lesser dependencies, there is lower dependency on common code elements.
    However, it does not offer any runtime isolation between service behavior, and
    hence does not have the true benefits of a microservice architecture model such
    as independent releases, scaling individual services, or limiting the impact of
    one service problem on the other services.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与完全的单体应用程序风格相比，唯一的好处是由于有单独的代码库和较少的依赖关系，对通用代码元素的依赖较低。然而，它并不提供服务行为之间的运行时隔离，因此没有真正的微服务架构模型的好处，如独立发布、扩展单个服务或限制一个服务问题对其他服务的影响。
- en: Suitability
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用性
- en: There are not many scenarios in which this is useful as it does not offer runtime
    isolation. However, it might be an intermediary step toward releasing the full
    separation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是很有用的情况，因为它并不提供运行时隔离。然而，它可能是释放完全分离的中间步骤。
- en: Service per WAR/EAR
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个WAR/EAR的服务
- en: 'This model separates the build process for the services to create separate
    `.war`/`.ear` files per service. However, they end up being deployed to the same
    web container or application server:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型将服务的构建过程分离，以创建每个服务的单独`.war`/`.ear`文件。然而，它们最终被部署到同一个Web容器或应用服务器中：
- en: '![](img/c52a556c-117e-49b5-9ab9-f38453782e33.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c52a556c-117e-49b5-9ab9-f38453782e33.jpg)'
- en: Benefits and trade-offs
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利弊
- en: This style takes the isolation a step further, by separating the build process
    for each service to create a deployable unit. However, since they are deployed
    on the same web container or application server, they share the same process.
    Hence, there is no runtime isolation between the services.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格通过将每个服务的构建过程分开来创建可部署单元，进一步提高了隔离。然而，由于它们部署在同一个Web容器或应用服务器上，它们共享相同的进程。因此，服务之间没有运行时隔离。
- en: Suitability
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用性
- en: Some teams might experience constraints on target deployment to use the same
    software or hardware that they were using in monolith style development. In this
    case, this deployment style is suitable, as the teams can still do independent
    development without getting under each other's feet, but will have to coordinate
    the releases with other teams during deployment to their traditional production
    infrastructure.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一些团队可能会在目标部署上遇到约束，使用与单体风格开发中使用的相同软件或硬件。在这种情况下，这种部署风格是合适的，因为团队仍然可以独立开发，而不会互相干扰，但在部署到传统生产基础设施时，他们将不得不与其他团队协调发布。
- en: Service per process
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个进程的服务
- en: 'This style uses the concept of the fat JAR discussed earlier to include the
    application server or web container as part of the deployment unit. Thus, the
    target runtime environment only needs a JVM to run the service. Dropwizard and
    Spring Boot frameworks encourage this type of deployment build. We have also seen
    an example of creating such a deployment unit in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格使用了之前讨论过的fat JAR的概念，将应用服务器或Web容器作为部署单元的一部分。因此，目标运行环境只需要一个JVM来运行服务。Dropwizard和Spring
    Boot框架鼓励这种类型的部署构建。我们还在[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中看到了创建这样一个部署单元的示例，*编写您的第一个云原生应用程序*：
- en: '![](img/c8fe032a-2988-45d1-a845-256cfb2f8eba.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8fe032a-2988-45d1-a845-256cfb2f8eba.jpg)'
- en: Benefits and trade-offs
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好处和权衡
- en: 'The benefits and trade-offs associated with the service per process style are
    as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个进程风格相关的服务的好处和权衡如下：
- en: This approach helps in separating the runtime processes on which the services
    run. Thus, it creates an isolation between the services, so that a memory leak
    or fat exception in one process does not affect the other services to some extent.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法有助于分离服务运行的运行时进程。因此，它在服务之间创建了隔离，这样一个进程中的内存泄漏或fat异常不会在一定程度上影响其他服务。
- en: This allows for selective scaling of service, by allowing more deployments of
    a service compared to other services on the existing hardware.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这允许有选择地扩展服务，允许在现有硬件上部署更多的服务，与其他服务相比。
- en: It also gives the freedom to teams of using a different application server/web
    container based on specific use cases or the needs of the team.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还给团队自由，可以根据特定用例或团队需求使用不同的应用服务器/ Web容器。
- en: However, it cannot prevent any one service from hogging system resources (such
    as CPU, I/O, and memory) that can affect the performance of the other services.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，它无法阻止任何一个服务占用系统资源（如CPU、I/O和内存），从而影响其他服务的性能。
- en: It also reduces the control over the runtime of the operations team, as there
    is no central web container or application server present in this model.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还减少了运维团队对运行时的控制，因为在这种模型中没有中央Web容器或应用服务器。
- en: This style requires good governance to limit variability in the deployment estate
    and having substantial use cases to support the divergence.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种风格需要良好的治理来限制部署环境的变化，并且需要有实质性的用例来支持分歧。
- en: Suitability
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用性
- en: This style offers the best compromise for teams that are constrained to using
    their existing production infrastructure and do not have Docker containers or
    small VM configurations in place yet.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格为那些受限于使用现有生产基础设施并且尚未拥有Docker容器或小型VM配置的团队提供了最佳折衷方案。
- en: Service per Docker container
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个Docker容器的服务
- en: 'In this style, a service deploys as a fat JAR in a Docker container, which
    has the necessary prerequisites, such as JVM. It takes the isolation a step higher
    than that provided by the Linux container technology:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种风格中，服务以一个带有必要先决条件（如JVM）的Docker容器中的fat JAR部署。它比Linux容器技术提供的隔离更高一步：
- en: '![](img/7f1a6c81-2592-44fa-8dc1-e9c7150e9978.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f1a6c81-2592-44fa-8dc1-e9c7150e9978.jpg)'
- en: Benefits and trade-offs
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好处和权衡
- en: 'The benefits and trade-offs associated with the service per Docker container
    style are as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个Docker容器风格相关的服务的好处和权衡如下：
- en: The Linux container technology limits the CPU and memory consumption of the
    service in addition to providing networking and file access isolation. This level
    of isolation is sufficient for many services.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux容器技术限制了服务的CPU和内存消耗，同时提供了网络和文件访问隔离。这种隔离程度对许多服务来说是足够的。
- en: Containers are fast to start up from an image. Hence, new containers based on
    an application or service image can be spawned very quickly to address the fluctuating
    demands of the application.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器从镜像启动速度快。因此，可以非常快速地生成基于应用程序或服务镜像的新容器，以满足应用程序的波动需求。
- en: Containers can be orchestrated through various orchestration mechanisms, such
    as Kubernetes, Swarm, and DC/OS so that the entire application configuration can
    be created automatically based on a well-defined application blueprint.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器可以通过各种编排机制进行编排，例如Kubernetes、Swarm和DC/OS，以便根据明确定义的应用蓝图自动创建整个应用程序配置。
- en: As in the previous style, it is possible to run a variety of service technologies
    within a container. For example, running Node.js services in addition to Java
    services is possible as the container image would be at OS level and hence can
    be started seamlessly by the orchestration framework.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与之前的风格一样，可以在容器中运行各种服务技术。例如，除了Java服务外，还可以运行Node.js服务，因为容器镜像将位于操作系统级别，因此可以由编排框架无缝启动。
- en: Containers have much lower overheads compared to the virtual machines in terms
    of resource requirements, as they are more lightweight. Hence, they are cheaper
    compared to running each service in its own virtual machine.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器在资源需求方面的开销比虚拟机低得多，因为它们更轻量级。因此，与在自己的虚拟机中运行每个服务相比，它们更便宜。
- en: However, containers reuse the kernel of the host system. Hence, it is not possible
    to run workloads demanding different operating systems, for example, Windows or
    Solaris on container technology.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，容器重用主机系统的内核。因此，无法在容器技术上运行需要不同操作系统的工作负载，例如 Windows 或 Solaris。
- en: Suitability
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用性
- en: This style of deployment is a good balance of isolation and cost. It is the
    recommended style and suitable for most service deployments.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这种部署风格在隔离和成本之间取得了很好的平衡。这是推荐的风格，适用于大多数服务部署。
- en: Service per VM
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个虚拟机一个服务
- en: In this style, the fat JAR is deployed directly on the VM, as in the *Service
    per process* section. However, here there is only one service deployed per VM.
    This ensures a complete isolation of the service from the other services.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种风格中，fat JAR 直接部署在虚拟机上，就像*每个进程一个服务*部分一样。然而，在这里，每个虚拟机只部署一个服务。这确保了该服务与其他服务完全隔离。
- en: 'The deployment is automated through tools such as Chef and Puppet, that can
    take a base image (such as having Java installed) and then run through a series
    of steps to install the application JAR and other utilities on the VM:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 部署是通过诸如 Chef 和 Puppet 等工具自动化的，这些工具可以获取基础镜像（例如已安装 Java）然后运行一系列步骤在虚拟机上安装应用程序 JAR
    和其他实用程序：
- en: '![](img/297b14b8-8750-453a-9710-d2145cab55a1.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/297b14b8-8750-453a-9710-d2145cab55a1.png)'
- en: Benefits and trade-offs
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和权衡
- en: 'The benefits and trade-offs associated with the service per VM style are as
    follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个虚拟机一个服务风格相关的优点和权衡如下：
- en: If there are any use cases that require a complete OS level isolation, then
    this style is suitable
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有任何需要完全 OS 级别隔离的用例，那么这种风格是合适的
- en: This style also allows us to mix completely different workloads, such as Linux,
    Windows and Solaris, together on the VMs
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种风格还允许我们在虚拟机上混合完全不同的工作负载，例如 Linux、Windows 和 Solaris
- en: However, this style is more resource-intensive and slower to start up as compared
    to the previous style, as VMs include a complete guest OS start-up
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然而，与前一种风格相比，这种风格更加资源密集，启动速度更慢，因为虚拟机包括完整的客户操作系统启动
- en: As a result, it is less cost efficient as compared to earlier options
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，与之前的选项相比，它的成本效率较低
- en: Suitability
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用性
- en: This style of deployment is tilting toward the increased cost. It is the recommended
    style, and suitable for cloud image based deployments such as creating **Amazon
    Machine Images** (**AMI**).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这种部署风格倾向于增加成本。这是推荐的风格，适用于云镜像部署，例如创建**Amazon Machine Images**（**AMI**）。
- en: Service per host
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个主机一个服务
- en: This takes the isolation from the hypervisor (for VMs) to the hardware level
    by deploying the services on different physical hosts. The concept of microservers
    or specialized appliances can be used for this purpose.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这将隔离从虚拟机的 hypervisor（对于虚拟机）提升到硬件级别，通过在不同的物理主机上部署服务。可以使用微服务器或专门的设备概念来实现这一目的。
- en: Benefits and trade-offs
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优点和权衡
- en: 'The benefits and trade-offs associated with the service per host style are
    as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个主机一个服务风格相关的优点和权衡如下：
- en: The hardware (such as processors, memory, and I/O) can be exactly tuned to the
    use case of the service. Intel offers a range of microservers that are tuned for
    specific tasks such as graphics processing, web content serving, and so on.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件（如处理器、内存和 I/O）可以完全调整到服务的用例。英特尔提供了一系列微服务器，针对特定任务进行了调整，例如图形处理、Web 内容服务等。
- en: A very high density of components can be achieved in this solution.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种解决方案可以实现非常高的组件密度。
- en: This style of deployment is for very few use cases that would benefit from hardware-level
    isolation or specialized hardware needs.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种部署风格适用于非常少数需要从硬件级别隔离或专门硬件需求中受益的用例。
- en: This is a maturing technology and hence not many data center cloud providers
    offer it yet. However, it will have matured by the time this book gets published.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种成熟的技术，因此目前还没有很多数据中心云提供商提供。然而，到本书出版时，它将已经成熟。
- en: Suitability
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用性
- en: This style of deployment is extremely rare, as very few use cases require this
    high level of isolation or specialized hardware requirements. Appliances for web
    content or graphics processing are a few, specialized use cases that will benefit
    from this deployment style.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这种部署风格非常罕见，因为很少有用例需要这种高级别的隔离或专门的硬件要求。Web 内容或图形处理的设备是一些受益于这种部署风格的专门用例。
- en: Release patterns
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布模式
- en: 'Following are the different release patterns used in services:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务中使用的不同发布模式：
- en: '**Fat JAR**: As discussed in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application* the fat JAR helps to bundle the
    web container with the deployable. This ensures that there is no inconsistency
    between the versions of the deployment in the development, test, and production
    environment.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fat JAR**：如[第 2 章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中所讨论的，*编写您的第一个云原生应用程序*，fat
    JAR 有助于将 Web 容器与可部署内容捆绑在一起。这确保了在开发、测试和生产环境中部署版本之间没有不一致。'
- en: '**Blue-green deployment**: This pattern suggests maintaining two production
    environments that are identical. A new release goes to one of the unused environments,
    say green. The switch is done from a router to send traffic to the green deployment.
    If successful, the green environment becomes the new production environment and
    the blue environment can be made inactive. If there is an issue, rollback is easier.
    The next cycle happens in reverse, with deployment to the blue environment, thus
    alternating between the two environments. There are a few challenges such as databases
    upgrades. For async microservices, this technique can be used to release one microservice
    or a set of microservices with different input queues. The configuration loaded
    from connection parameters decides to drop the request message in one queue versus
    the other.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝绿部署**：这种模式建议维护两个相同的生产环境。新版本发布到一个未使用的环境，比如绿色环境。从路由器切换流量到绿色部署。如果成功，绿色环境将成为新的生产环境，蓝色环境可以被停用。如果出现问题，回滚更容易。下一个周期将以相反的方式进行，部署到蓝色环境，因此在两个环境之间交替。存在一些挑战，比如数据库升级。对于异步微服务，可以使用这种技术来发布一个微服务或一组具有不同输入队列的微服务。从连接参数加载的配置决定将请求消息放入一个队列还是另一个队列。'
- en: '**Semantic versioning**: Semantic versioning is about releasing software with
    version numbers, the way they change the meaning of the underlying code, and what
    has been modified from one version to the next. Refer to [http://semver.org/](http://semver.org/)
    for more details. In async microservices, a similar strategy of using an input
    queue per microservice applies. However, in this case, both services are active,
    one for the legacy and one with the new changes. Based on the request, content-based
    routing pattern can be used to switch the queue to send the request.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语义化版本控制**：语义化版本控制是关于使用版本号发布软件，以及它们如何改变底层代码的含义，以及从一个版本到下一个版本进行了什么修改。有关更多详细信息，请参阅[http://semver.org/](http://semver.org/)。在异步微服务中，使用每个微服务一个输入队列的类似策略适用。然而，在这种情况下，两个服务都是活动的，一个用于传统的服务，一个用于新的更改。根据请求，可以使用基于内容的路由模式来切换队列以发送请求。'
- en: '**Canary release**: This pattern is used to introduce a change to a small set
    of users using a routing logic that selects a group of customers for a new service.
    In terms of asynchronous services, this can be handled by two sets of input queues,
    and the redirection logic now decides the queue to drop the request message to.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金丝雀发布**：这种模式用于向一小部分用户引入变更，使用选择一组客户的路由逻辑来实现。在异步服务方面，可以通过两组输入队列来处理，重定向逻辑现在决定将请求消息放入哪个队列。'
- en: '**Immutable server / immutable delivery**: Immutable Server and Immutable Delivery
    are related. The intent is to automatically build the server, (VM or container)
    and its software and applications from the configuration management repository.
    Once built, it is not changed, not even when moving from one environment to other.
    Only the configuration parameters are injected via the environment, JNDI, or separate
    config servers, such as Consul or using Git. This ensures that there are no ad-hoc
    changes made to the production deployment that are not recorded in the version
    control system.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变服务器/不可变交付**：不可变服务器和不可变交付是相关的。其目的是从配置管理存储库自动构建服务器（虚拟机或容器）及其软件和应用程序。构建后，它不会被改变，即使在从一个环境移动到另一个环境时也不会改变。只有配置参数通过环境、JNDI或独立的配置服务器注入，比如Consul或使用Git。这确保在生产部署中没有未记录在版本控制系统中的临时更改。'
- en: '**Feature toggle**: This allows features released in production to be toggled
    on or off from some configuration settings. This toggle is typically implemented
    at the frontend or API gates so that it can be made visible or not visible to
    the end users of the service/feature. This pattern is very useful for a dark launch
    capability, which is discussed in the following sections.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能切换**：这允许在生产中发布的功能从一些配置设置中切换开或关。这个切换通常在前端或API网关实现，以便可以对服务/功能的最终用户可见或不可见。这种模式对于暗黑发布能力非常有用，这将在接下来的部分中讨论。'
- en: '**Dark launch**: Popularized by Facebook. Dark launch means releasing the service/capability
    into the production well before its scheduled release. This gives the opportunity
    to test out the integration points and complex services in production environments.
    Only frontend or API changes are done using a Canary release and feature toggle
    as discussed earlier.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暗黑发布**：由Facebook推广。暗黑发布意味着在计划发布之前很长时间将服务/能力发布到生产中。这为在生产环境中测试集成点和复杂服务提供了机会。只有前端或API的更改使用了之前讨论的金丝雀发布和功能切换。'
- en: Data architecture for microservices
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的数据架构
- en: One of the key design philosophies of microservices is the bounded context and
    the service(s) managing the data store. Within a bounded context, multiple services
    might have access to a common data store, or adopt a per service data store paradigm.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的一个关键设计理念是有界上下文和管理数据存储的服务。在有界上下文中，多个服务可能访问一个共同的数据存储，或者采用每个服务一个数据存储的范式。
- en: Since there are potentially multiple instances of a service running, how do
    we make sure the data read/update operations do not lead to a deadlock in resources?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能有多个服务实例在运行，我们如何确保数据读取/更新操作不会导致资源死锁？
- en: Command Query Responsibility Segregation (CQRS)
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令查询职责分离（CQRS）
- en: CQRS introduces an interesting paradigm challenging the conventional thought
    of using the same data store to create/update and also query the systems. The
    idea is to separate the commands that change the state of the system from the
    queries that are idempotent. The materialized view is an example of this pattern.
    The separation also gives the flexibility to use a different data model for updates
    and queries. For example, the relational model could be used for updates, but
    the events generated from the updates can be used to update caches or document
    databases that are more read-friendly.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS引入了一个有趣的范例，挑战了使用相同数据存储来创建/更新和查询系统的传统思想。其思想是将改变系统状态的命令与幂等的查询分开。物化视图就是这种模式的一个例子。这种分离还提供了使用不同的数据模型进行更新和查询的灵活性。例如，关系模型可以用于更新，但从更新生成的事件可以用于更新更适合读取的缓存或文档数据库。
- en: 'The user requests can be broadly classified into two parts, such as commands
    that change the state of the system, and queries that get the state of the system
    for user consumption. For the command processing, the system of engagement collects
    enough business data so that it can call the respective service on a system of
    record to execute the commands. For queries, the system of engagement can choose
    to either call the system of record, or get the information from a local store
    that is designed for read workloads. This separation of strategy can yield immense
    benefits, such as reducing the load on the system of record and reducing the latency:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 用户请求可以广泛分类为两部分，即改变系统状态的命令和为用户获取系统状态的查询。对于命令处理，参与系统收集足够的业务数据，以便可以调用系统记录上的相应服务来执行命令。对于查询，参与系统可以选择要么调用系统记录，要么从专为读取工作负载而设计的本地存储获取信息。这种策略的分离可以产生巨大的好处，例如减少对系统记录的负载和减少延迟：
- en: '![](img/c93f51b6-b83a-48e0-82f8-bc87cf924514.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c93f51b6-b83a-48e0-82f8-bc87cf924514.jpg)'
- en: The CQRS pattern helps to leverage legacy systems of records in conjunction
    with the newer document databases, and caches as well. We will cover how to implement
    CQRS in your service in the next chapter.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS模式有助于利用旧的记录系统以及较新的文档数据库和缓存。我们将在下一章中介绍如何在您的服务中实现CQRS。
- en: Duplicating data
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据重复
- en: 'Within the bounded context, the services are the custodians of the data. But
    what if another service requires a subset of your data? Some of the questions/solutions
    that arise are as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在有界上下文内，服务是数据的监护人。但是如果另一个服务需要您数据的子集怎么办？一些可能出现的问题/解决方案如下：
- en: Should I invoke the service to get that data?
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我应该调用服务来获取那些数据吗？
- en: Increased chattiness among the services
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务之间的通信增加
- en: Tight coupling of two services
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个服务之间的紧密耦合
- en: Can I access the data store directly from another bounded context?
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我可以直接从另一个有界上下文中访问数据存储吗？
- en: Breaks the bounded context model
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打破了有界上下文模型
- en: So, how does another service (residing in another bounded context) get access
    to the subset of the data? (For example, requiring address attributes for a customer
    (from customer service) in the personalization services.)
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，另一个服务（驻留在另一个有界上下文中）如何访问数据的子集？（例如，在个性化服务中需要客户的地址属性（来自客户服务）。）
- en: 'In this case, the best way is to duplicate data from the master domain. The
    required changes are published as events by the master domain, which are subscribed
    to by any domain interested in those changes. The events are picked up from the
    event bus, and data from the event is used to update the changes in the duplicate
    data store:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最好的方法是从主域中复制数据。所需的更改由主域发布为事件，任何对这些更改感兴趣的域都会订阅这些事件。事件从事件总线中获取，并且使用事件中的数据来更新重复数据存储中的更改：
- en: '![](img/6bcb5d57-6147-4089-91aa-1730ea807be3.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bcb5d57-6147-4089-91aa-1730ea807be3.jpg)'
- en: Benefits
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好处
- en: 'The benefits of duplicating data are as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 复制数据的好处如下：
- en: Helps decouple the service boundaries
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于解耦服务边界
- en: A business event containing the data is the only relationship between the services
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含数据的业务事件是服务之间唯一的关系
- en: Helps avoid expensive distributed transaction models across boundaries
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于避免跨边界的昂贵分布式事务模型
- en: Allows us to make changes to our service boundaries without impeding progress
    of other parts of the system
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们在不妨碍系统其他部分进展的情况下对服务边界进行更改
- en: We can decide how quickly or slowly we want to see the rest of the outside world
    and eventually become consistent
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以决定希望多快或多慢地看到外部世界的其余部分，并最终变得一致
- en: Ability to store the data in our own databases using the technology appropriate
    for our service model
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用适合我们服务模型的技术在我们自己的数据库中存储数据的能力
- en: Flexibility to make changes to our schema/databases
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活性使我们能够对架构/数据库进行更改
- en: Allows us to become much more scalable, fault tolerant, and flexible
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使我们变得更具可伸缩性、容错性和灵活性
- en: Cons
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺点
- en: 'The cons associated with duplicating data are as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 复制数据相关的缺点如下：
- en: Large volume of data changes might mean a more robust infrastructure at both
    ends and the ability to handle lost events requires event durability
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大量数据更改可能意味着两端需要更强大的基础设施，并且处理丢失事件的能力需要事件的持久性
- en: Leads to an eventual consistency model
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致最终一致性模型
- en: Complicated system and very difficult to debug
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的系统，非常难以调试
- en: Fit for purpose
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用于特定目的
- en: The bounded context model means the data encompassed can be modified only through
    the defined service interfaces or APIs. This means the actual schema or the storage
    technology used to store the data has no bearing on the API functionality. This
    opens us up to the possibility of using a fit for purpose data store. If we are
    building a search functionality and an in-memory data store is a better fit for
    the given business requirement, we can go ahead with it.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 有界上下文模型意味着所包含的数据只能通过定义的服务接口或API进行修改。这意味着实际的模式或用于存储数据的存储技术对API功能没有影响。这使我们有可能使用适合特定目的的数据存储。如果我们正在构建搜索功能，并且内存数据存储对于给定的业务需求更合适，我们可以继续使用它。
- en: 'Since, access to the data is governed by the service APIs, the choice and structure
    of the data store is immaterial to the actual service consumers:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据访问受服务API的管理，数据存储的选择和结构对实际服务消费者来说并不重要：
- en: '![](img/4d5744e3-2db6-470b-9e66-1f0c55d6aef7.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d5744e3-2db6-470b-9e66-1f0c55d6aef7.jpg)'
- en: The service APIs model also provides the flexibility to move from one data store
    to another, without an impact on the other consuming services, as long as the
    service contracts are maintained. Martin Fowler has termed it, polyglot persistence.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 服务API模型还提供了灵活性，可以在不影响其他消费服务的情况下从一个数据存储转移到另一个数据存储，只要服务契约得到维护。Martin Fowler将其称为多语言持久性。
- en: The role of security
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性的作用
- en: 'With the proliferation of microservices, the challenges of managing security
    for these services becomes a challenge. Some of the questions that need to be
    answered, besides the **Open Web Application Security Project** (**OWASP**) top
    ten web vulnerabilities, are as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 随着微服务的普及，管理这些服务的安全性的挑战变得更加困难。除了**开放式Web应用安全项目**（**OWASP**）十大网络漏洞之外，还需要回答一些问题，例如：
- en: Does the service require the client to authenticate before service invocation
    (such as OAuth)?
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务在服务调用之前是否需要客户端进行身份验证（例如OAuth）？
- en: Can a client call any service or only the service for which it is authorized?
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端是否可以调用任何服务，还是只能调用其被授权的服务？
- en: Does the service know the identity of the client from where the request originated
    and does it get passed down to the downstream services? Do the downstream services
    have a mechanism to verify the authorization of their invocation?
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务是否知道请求的发起客户端的身份，并且是否将其传递给下游服务？下游服务是否有机制来验证其调用的授权？
- en: Is the traffic between service to service invocation secured (HTTPS)?
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务之间的流量调用是否安全（HTTPS）？
- en: How do we verify that a request received from an authenticated user hasn't been
    tampered with?
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何验证来自经过身份验证的用户的请求是否未被篡改？
- en: How do we detect and reject a replay of a request?
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何检测并拒绝请求的重放？
- en: In the distributed microservice model, we need to control and limit the privileges
    the calling party has, and how much data is accessible (least privilege) on each
    call in case of a security breach. A large number of microservices and supporting
    databases means there is a large attack surface that need to be protected. Server
    hardening across the services becomes an important and key activity to secure
    the network. It is very important to monitor the service access and model the
    threats to break down the processes where we are most vulnerable and focus our
    effort there. We will see the role of API gateways in addressing some of the security
    concerns.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式微服务模型中，我们需要控制和限制调用方的特权，以及在安全漏洞的情况下每次调用可访问的数据量（最小特权）。大量的微服务和支持数据库意味着存在需要保护的大攻击面。服务之间的服务器加固变成了保护网络的重要和关键活动。监控服务访问并对威胁进行建模非常重要，以分解我们最脆弱的流程并集中精力进行防范。我们将看到API网关在解决一些安全问题方面的作用。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This brings us to the conclusion of the design principles for your cloud applications.
    In this chapter, you learned about the reasons for the popularity of the APIs,
    how to decouple your monolith application, and various categories of microservice
    patterns and data architecture principles for microservices design. We also saw
    the role of security in microservices and the role of API gateways.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们得出了云应用程序的设计原则的结论。在本章中，您了解了API受欢迎的原因，如何解耦您的单体应用程序，以及微服务设计的各种模式和数据架构原则。我们还看到了微服务中安全性的作用以及API网关的作用。
- en: In the next chapter, we will take our example from [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*, and start adding more meat to it
    to make it more production grade. We will add data access, options to do caching
    and their considerations, applying CQRS, and error handling.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将以[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中的示例，*编写您的第一个云原生应用程序*，并开始添加更多内容，使其更适合生产。我们将添加数据访问，缓存选项及其考虑因素，应用CQRS和错误处理。
