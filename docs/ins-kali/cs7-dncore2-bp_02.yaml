- en: Cricket Score Calculator and Tracker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 板球比分计算器和跟踪器
- en: '**Object-oriented programming** (**OOP**) is a crucial element of writing .NET
    applications. Proper OOP ensures that developers can share code easily between
    projects. You don''t have to rewrite code that has already been written. This
    is called **inheritance**.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）是编写.NET应用程序的关键要素。正确的面向对象编程确保开发人员可以在项目之间轻松共享代码。你不必重写已经编写过的代码。这就是**继承**。'
- en: A lot has been written throughout the years on the topic of OOP. In fact, doing
    a search on the internet on the benefits of OOP will return countless results.
    The fundamental benefits of OOP, however, are the modular approach to writing
    code, the ease with which code can be shared, and the ability to extend the functionality
    of shared code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来关于面向对象编程的话题已经写了很多。事实上，在互联网上搜索面向对象编程的好处将返回无数的结果。然而，面向对象编程的基本好处是编写代码的模块化方法，代码共享的便利性以及扩展共享代码的功能。
- en: These little building blocks (or classes) are self-contained units of code that
    each perform a function. Developers do not need to know what goes on inside the
    class when they use it. They can just assume that the class will function on its
    own and will always work. Should the class they implement not provide a specific
    functionality, the developer is free to extend the functionality of the class.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小构建块（或类）是自包含的代码单元，每个都执行一个功能。开发人员在使用它时不需要知道类内部发生了什么。他们可以假设类将自行运行并始终工作。如果他们实现的类没有提供特定功能，开发人员可以自由扩展类的功能。
- en: 'We will have a look at the features that define OOP, which are:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下定义面向对象编程的特性，它们是：
- en: Inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Abstraction
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: Encapsulation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Polymorphism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: 'We will also have a look at:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看一下：
- en: Single responsibility
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责
- en: The open/closed principle
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开闭原则
- en: In this chapter, we will have a little fun. We will create an ASP.NET Bootstrap
    web application that keeps track of the cricket scores of your two favorite teams.
    It is with this app that the principles of OOP will become evident.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将玩得开心。我们将创建一个ASP.NET Bootstrap Web应用程序，用于跟踪你两个最喜欢的球队的板球比分。正是通过这个应用程序，面向对象编程的原则将变得明显。
- en: The *Cricket Score Tracker* app can be found on GitHub, and I encourage you
    to download the source code and make it your own. The GitHub repository URL is—[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/cricketScoreTrack](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/cricketScoreTrack).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*板球比分跟踪器*应用程序可以在GitHub上找到，我鼓励你下载源代码并将其作为你自己的应用程序。GitHub存储库的URL是-[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/cricketScoreTrack](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/cricketScoreTrack)。'
- en: There are so many features that a person can build into an application such
    as this, but the topic of OOP has only a single chapter in this book to convey
    this topic. Therefore, the focus is on OOP (more than the hard and fast rules
    of cricket) and some liberties have been taken with certain functionalities.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的应用程序中，一个人可以构建很多功能，但是关于面向对象编程的话题在本书中只有一个章节来传达这个话题。因此，重点是面向对象编程（而不是板球的硬性规则），并且对某些功能进行了一些自由处理。
- en: Let the games begin!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让游戏开始！
- en: Setting up the project
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: Using Visual Studio 2017, we will create an ASP.NET Web Application project.
    You can call the application anything you like, but I called mine `cricketScoreTrack`.
    When you click on the new ASP.NET Web Application template, you will be presented
    with a few ASP.NET templates.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Visual Studio 2017，我们将创建一个ASP.NET Web应用程序项目。你可以给应用程序起任何你喜欢的名字，但我把我的叫做`cricketScoreTrack`。当你点击新的ASP.NET
    Web应用程序模板时，你将看到一些ASP.NET模板。
- en: 'The ASP.NET templates are:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET模板有：
- en: Empty
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空
- en: Web Forms
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web Forms
- en: MVC
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVC
- en: Web API
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web API
- en: Single Page Application
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单页应用程序
- en: Azure API App
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure API应用
- en: Azure Mobile App
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure移动应用程序
- en: 'We are just going to select the Web Forms template. For this application, we
    don''t need authentication, so don''t change this setting:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会选择Web Forms模板。对于这个应用程序，我们不需要身份验证，所以不要更改这个设置：
- en: '![](img/6620368d-7a9f-4d12-a455-f8799ff7d0e4.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6620368d-7a9f-4d12-a455-f8799ff7d0e4.png)'
- en: I will assume that you have also downloaded the application from GitHub for
    this chapter, because you will need it as we discuss the architecture. The URL
    is—[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/cricketScoreTrack](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/cricketScoreTrack).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你也已经从GitHub下载了本章的应用程序，因为在讨论架构时你会需要它。URL是-[https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/cricketScoreTrack](https://github.com/PacktPublishing/CSharp7-and-.NET-Core-2.0-Blueprints/tree/master/cricketScoreTrack)。
- en: 'Click on OK to create the web application. The project will be created and
    will look as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 点击确定创建Web应用程序。项目将被创建，并将如下所示：
- en: '![](img/6294d3c4-b08d-41e6-9398-b510fd9e7ad0.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6294d3c4-b08d-41e6-9398-b510fd9e7ad0.png)'
- en: 'To give you an idea of what we are building, the UI will look as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你了解我们正在构建的东西，UI将如下所示：
- en: '![](img/bc166801-1c83-4a73-90e6-ada22b17a5cb.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc166801-1c83-4a73-90e6-ada22b17a5cb.png)'
- en: 'The various sections are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 各个部分如下：
- en: Batsmen selection (**1** in the preceding screenshot)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 击球手选择（**1**在上面的截图中）
- en: Bowler selection (**2** in the preceding screenshot)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投手选择（**2**在上面的截图中）
- en: Batsmen game statistics—Runs, Balls, 4's, 6's, Strike Rate (**3** in the preceding
    screenshot)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 击球手比赛统计-得分、球数、4分、6分、打击率（**3**在上面的截图中）
- en: Bowler game statistics—Overs, Maidens, Runs, Wickets, Economy (**4** in the
    preceding screenshot)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 投手比赛统计-投掷数、无得分局数、得分、击球、经济（**4**在上面的截图中）
- en: Batsmen runs (**5** in the preceding screenshot)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 击球手得分（**5**在上面的截图中）
- en: Game actions (**6** in the preceding screenshot)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏动作（**6**在上面的截图中）
- en: Game score and teams (**7** in the preceding screenshot)
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比赛得分和球队（**7**在上面的截图中）
- en: Current batsmen details (**8** in the preceding screenshot)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前击球手详情（**8**在上面的截图中）
- en: Runs per ball and over (**9** in the preceding screenshot)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每球和每局的得分（**9**在上面的截图中）
- en: As you can see, there is a lot going on here. There are obviously a lot of areas
    that you can still expand on. Another fun idea is to have an in-game statistics
    panel and even a Duckworth-Lewis calculation, if you have the time to try and
    implement it. I say try, because the actual algorithm of the calculation is a
    secret.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这里有很多事情。显然还有很多地方可以继续扩展。另一个有趣的想法是添加一个游戏统计面板，甚至是Duckworth-Lewis计算，如果你有时间去尝试实现的话。我说尝试，因为实际的计算算法是一个秘密。
- en: There are, however, a lot of implementations online, and one of particular interest
    to me was the article by Sarvashrestha Paliwal, *Azure Business Lead for Microsoft
    India*. They used machine learning to analyze historical cricket games and thereby
    provide a continually improving Duckworth-Lewis calculation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在网上有很多实现，我特别感兴趣的是Sarvashrestha Paliwal的文章，他是*微软印度的Azure业务负责人*。他们使用机器学习来分析历史板球比赛，从而提供不断改进的Duckworth-Lewis计算。
- en: You can read his article at the following link—[https://azure.microsoft.com/en-us/blog/improving-the-d-l-method-using-machine-learning/](https://azure.microsoft.com/en-us/blog/improving-the-d-l-method-using-machine-learning/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下链接阅读他的文章-[https://azure.microsoft.com/en-us/blog/improving-the-d-l-method-using-machine-learning/](https://azure.microsoft.com/en-us/blog/improving-the-d-l-method-using-machine-learning/)。
- en: 'Let''s have a closer look at the application structure. Expanding the `Scripts`
    folder, you will notice that the application uses jQuery and Bootstrap:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看一下应用程序结构。展开`Scripts`文件夹，你会注意到应用程序使用了jQuery和Bootstrap：
- en: '![](img/473de118-1184-455a-9a14-86930a820014.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/473de118-1184-455a-9a14-86930a820014.png)'
- en: 'Expanding the `Content` folder, you will see the CSS files in use:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 展开`Content`文件夹，你会看到正在使用的CSS文件：
- en: '![](img/62e33e7b-96ef-42a3-8da5-5689289bd1bb.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62e33e7b-96ef-42a3-8da5-5689289bd1bb.png)'
- en: 'Note that there is a `custom.css` file in this folder that I added:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个文件夹中有一个我添加的`custom.css`文件：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This CSS file basically styles the buttons and some other text font on the form.
    There is nothing complicated about this CSS. The reason for the Bootstrap, jQuery, JavaScript,
    and CSS files is to enable the Bootstrap functionality on the web page.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CSS文件基本上是为表单上的按钮和一些其他文本字体设置样式。这个CSS并不复杂。Bootstrap、jQuery、JavaScript和CSS文件的原因是为了在网页上启用Bootstrap功能。
- en: To see Bootstrap in action, we will use Chrome to run the web application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到Bootstrap的效果，我们将使用Chrome来运行Web应用程序。
- en: The version of Chrome used for this book was Version 60.0.3112.90 (Official
    Build) (64-bit).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的Chrome版本是Version 60.0.3112.90 (Official Build) (64-bit)。
- en: 'Run the Cricket Score Tracker Bootstrap web application by going to Debug on
    the menu and clicking on Start Without Debugging or by pressing *Ctrl* + *F5*.
    When the web application has loaded in Chrome, press *Ctrl* + *Shift* + *I* to
    open the developer tools:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在菜单上点击Debug并点击Start Without Debugging或按*Ctrl* + *F5*来运行板球比分跟踪器Bootstrap Web应用程序。当Web应用程序在Chrome中加载后，按*Ctrl*
    + *Shift* + *I*打开开发者工具：
- en: '![](img/6931fb6e-bc77-4d29-8e6b-0bcb05c5bdc4.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6931fb6e-bc77-4d29-8e6b-0bcb05c5bdc4.png)'
- en: At the top left of the screen, click on the Toggle device toolbar button or
    press *Ctrl* + *Shift* + *M*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕左上角，点击切换设备工具栏按钮或按*Ctrl* + *Shift* + *M*。
- en: 'Chrome will then render the application as it would look on a mobile device.
    From the toolbar to the top, you will see that the application has been rendered
    as it would appear on an iPhone 6 Plus:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome然后会将应用程序呈现为在移动设备上看到的样子。从工具栏到顶部，你会看到应用程序已经呈现为在iPhone 6 Plus上的样子：
- en: '![](img/f16a8689-f7ad-4465-b426-72538c93894b.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f16a8689-f7ad-4465-b426-72538c93894b.png)'
- en: 'Clicking on the device type, you can change the device you want to render the
    page for. Changing it to an iPad Pro renders the page accordingly. You can also
    simulate the rotation of the device:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 点击设备类型，你可以改变你想要呈现页面的设备。将其改为iPad Pro会相应地呈现页面。你也可以模拟设备的旋转：
- en: '![](img/f466ea4f-806e-41b5-81de-c3696caf128b.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f466ea4f-806e-41b5-81de-c3696caf128b.png)'
- en: This feature is very powerful and allows modern web developers to test the responsiveness
    of their web applications. If something doesn't look quite right after you have
    rendered your application for a particular device, you need to go and investigate
    where you went wrong.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能非常强大，允许现代Web开发人员测试他们的Web应用程序的响应性。如果在为特定设备呈现应用程序后，发现有些地方看起来不太对劲，你需要去调查你哪里出错了。
- en: 'At the time of writing, the devices supported were:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，支持的设备有：
- en: BlackBerry Z30 and PlayBook
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BlackBerry Z30和PlayBook
- en: Galaxy Note 3, Note II, S3, and S5
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Galaxy Note 3，Note II，S3和S5
- en: Kindle Fire HDX
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kindle Fire HDX
- en: LG Optimus L70
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LG Optimus L70
- en: Laptop with HiDPI screen and MDPI screen
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有HiDPI屏幕和MDPI屏幕的笔记本电脑
- en: Laptop with touch
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带触摸的笔记本电脑
- en: Microsoft Lumina 550 and 950
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Lumina 550和950
- en: Nexus 7, 6, 5, 4, 10, 5X, and 6P
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nexus 7, 6, 5, 4, 10, 5X和6P
- en: Nokia Lumina 520
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nokia Lumina 520
- en: Nokia N9
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nokia N9
- en: iPad Mini
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPad Mini
- en: iPhone 4, 5, 6, and 6 Plus
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPhone 4, 5, 6和6 Plus
- en: iPad and iPad Pro
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPad和iPad Pro
- en: To add devices, go to the bottom of the device menu. Following the separator,
    there is an Edit... menu item. Clicking that will take you to the Emulated Devices
    screen.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加设备，转到设备菜单底部。在分隔符之后，有一个Edit...菜单项。点击它将带你到模拟设备屏幕。
- en: 'Looking at the Emulated Devices screen, you will notice that there are additional
    Settings to the right of the form:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 查看模拟设备屏幕，你会注意到表单右侧有额外的设置：
- en: '![](img/816cbc41-8bdd-4247-b941-06be608bb54a.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/816cbc41-8bdd-4247-b941-06be608bb54a.png)'
- en: 'One that stands out for a developer should be the Throttling setting:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发人员来说，一个突出的设置应该是Throttling设置：
- en: '![](img/0430460b-e316-4064-813a-dff88ef69e44.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0430460b-e316-4064-813a-dff88ef69e44.png)'
- en: As the name suggests, Throttling allows you to test your application as if it
    were running on a slower connection. You can then test functionality and ensure
    that your web application is as optimized as possible to allow it to work well
    on slower connections.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名字所示，Throttling允许你测试你的应用程序，就好像它在一个较慢的连接上运行一样。然后你可以测试功能，并确保你的Web应用程序尽可能地优化，以确保它在较慢的连接上能够良好运行。
- en: 'Swing back to the Solution Explorer in Visual Studio 2017 and have a look at
    the folders called `BaseClasses`, `Classes`, and `Interfaces`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Visual Studio 2017中的解决方案资源管理器，看看名为`BaseClasses`、`Classes`和`Interfaces`的文件夹：
- en: '![](img/252af8f1-e776-45f9-9554-3497d45a8f46.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/252af8f1-e776-45f9-9554-3497d45a8f46.png)'
- en: These folders contain the crux of this whole chapter. It is here where we will
    see what OOP is all about and how OOP works to provide a better approach to modeling
    a real-world scenario (a cricket match) in code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件夹包含了整个章节的精髓。在这里，我们将看到面向对象编程的本质以及面向对象编程如何提供更好的方法来在代码中建模现实世界的场景（板球比赛）。
- en: Object-oriented programming
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: As briefly mentioned earlier, OOP provides a modular approach to writing self-contained
    units of code. The concept of OOP centers around what we call the **four pillars
    of object-oriented programming**.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面简要提到的，面向对象编程提供了一种模块化的方法来编写自包含的代码单元。面向对象编程的概念围绕着我们所说的**面向对象编程的四大支柱**。
- en: 'They are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它们如下：
- en: Abstraction
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: Polymorphism
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态性
- en: Inheritance
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Encapsulation
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: The order doesn't really matter, but I always write the four pillars in this
    order because I use the mnemonic **A PIE** to remember each one. Let's discuss
    each of these concepts in more detail.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序并不重要，但我总是按照这个顺序写四大支柱，因为我使用**A PIE**这个记忆法来记住每一个。让我们更详细地讨论每个概念。
- en: Abstraction
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象
- en: 'An abstraction describes what something should do without actually showing
    you how to do it. According to the Microsoft documentation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象描述了某件事应该做什么，而不实际展示如何做。根据微软文档：
- en: '"An abstraction is a type that describes a contract but does not provide a
    full implementation of the contract."'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: “抽象是描述合同但不提供合同完整实现的类型。”
- en: Included as examples of abstractions are **abstract classes** and **interfaces**.
    Examples of abstractions in the .NET Framework include `Stream`, `IEnumerable<T>`,
    and `Object`. If the topic of abstraction seems a bit fuzzy now, don't worry.
    I will go into much more detail in the section on encapsulation and the difference
    between encapsulation and abstraction.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 作为抽象的示例包括**抽象类**和**接口**。.NET Framework中的抽象示例包括`Stream`、`IEnumerable<T>`和`Object`。如果抽象主题现在看起来有点模糊，不要担心。我将在封装和封装与抽象之间的区别部分中更详细地讨论。
- en: Polymorphism
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: You might hear of polymorphism referred to as the third pillar of OOP. But if
    I wrote it in that order above, my mnemonic would no longer work!
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过多态性被称为面向对象编程的第三支柱。但如果我按照上面的顺序写，我的记忆法就不再起作用了！
- en: 'Polymorphism is a Greek word that refers to something that has many shapes
    or forms. We will see an example of this in the *Cricket Score Tracking* app later
    on. Just remember that it has two distinct aspects:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性是一个希腊词，指的是具有许多形状或形式的东西。我们将在稍后的*板球比分跟踪*应用中看到这一点的例子。只需记住它有两个明显的方面：
- en: During runtime, a class that is derived from a base class may be treated as
    an object of the class it inherits. This is seen in parameters, collections, and
    arrays.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时，从基类派生的类可以被视为继承的类的对象。这在参数、集合和数组中都可以看到。
- en: The base class can define **virtual methods** that the derived class would then
    override. The derived class then provides their own implementation of the overridden
    methods.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类可以定义派生类将覆盖的**虚拟方法**。派生类然后提供它们自己对被覆盖方法的实现。
- en: Polymorphism is a very powerful feature in OOP.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性是面向对象编程中非常强大的特性。
- en: Compile-time polymorphism versus run-time polymorphism
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时多态性与运行时多态性
- en: Before we go further, let me pause for a minute and explain the previous two
    bullet points on polymorphism.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我停顿一分钟，解释一下前面两个关于多态性的要点。
- en: When we say **compile-time polymorphism**, we are saying that we will be declaring
    methods with the same name but with different signatures. Therefore, the same
    method can perform different functions based on the signature (parameters) it
    receives. This is also known as early binding, overloading, or static binding.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说**编译时多态**时，我们是说我们将声明具有相同名称但不同签名的方法。因此，相同的方法可以根据接收到的签名（参数）执行不同的功能。这也被称为早期绑定、重载或静态绑定。
- en: When we say **run-time polymorphism**, we are saying that we will be declaring
    methods with the same name and with the same signature. In a base class, for example,
    the method is overridden by the method in a derived class. This is achieved by
    what we call inheritance and by using the `virtual` or `override` keywords. Run-time
    polymorphism is also known as *late binding*, *overriding*, or *dynamic binding*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说**运行时多态**时，我们是说我们将声明具有相同名称和相同签名的方法。例如，在基类中，该方法被派生类中的方法覆盖。这是通过我们所谓的继承和使用`virtual`或`override`关键字实现的。运行时多态也被称为*延迟绑定*、*覆盖*或*动态绑定*。
- en: Inheritance
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: The ability to be able to create your own classes that reuse, extend, and modify
    the behavior that the base class defines is called **inheritance**. Another important
    aspect to understand is that a derived class can only directly inherit a single
    base class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 能够创建自己的类，重用、扩展和修改基类定义的行为的能力被称为**继承**。另一个重要的方面是理解派生类只能直接继承单个基类。
- en: Does this then mean that you can only inherit the behavior defined in a single
    base class? Well, yes and no. Inheritance is transitive in nature.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着你只能继承单个基类中定义的行为？是的，也不是。继承是具有传递性的。
- en: 'To explain this, imagine that you have three classes:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释这一点，想象一下你有三个类：
- en: '`Person`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person`'
- en: '`Pedestrian`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pedestrian`'
- en: '`Driver`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Driver`'
- en: 'The `Person` class is the base class. `Pedestrian` inherits from the `Person`
    class and therefore `Pedestrian` inherits the members declared in the `Person`
    class. The `Driver` class inherits from the `Pedestrian` class and therefore `Driver`
    inherits the members declared in `Pedestrian` and `Person`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类是基类。`Pedestrian`继承自`Person`类，因此`Pedestrian`继承了`Person`类中声明的成员。`Driver`类继承自`Pedestrian`类，因此`Driver`继承了`Pedestrian`和`Person`中声明的成员：'
- en: '![](img/7e123f4c-baf2-4cb9-af71-e25b62f56cb4.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e123f4c-baf2-4cb9-af71-e25b62f56cb4.png)'
- en: This is what is meant when we say that inheritance is transitive. You can only
    inherit from a single class, but you get all the members that the class you inherit
    from, inherits itself. You can only inherit from a single class, but you get all
    the members that the class you are inheriting from, inherits from its base class.
    Put another way, the `Driver` class can only inherit from a single base class
    (in the preceding image, the `Pedestrian` class). This means that because the
    `Pedestrian` class inherits from the `Person` class, and the `Driver` class inherits
    from the `Pedestrian` class, that the `Driver` class also inherits the members
    in the `Person` class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的继承是传递的意思。您只能从一个类继承，但您会得到从您继承的类本身继承的所有成员。 换句话说，`Driver`类只能从一个基类继承（在前面的图像中，`Pedestrian`类）。这意味着因为`Pedestrian`类继承自`Person`类，而`Driver`类继承自`Pedestrian`类，所以`Driver`类也继承了`Person`类中的成员。
- en: Encapsulation
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: Simply put, this means that the inner workings of the class (the implementation
    details) are not necessarily shared with outside code. Remember that we mentioned
    earlier that a class is something that you just want to use and expect it to work.
    The class exposes what it needs to to the calling code, but it maintains tight
    control over the inner workings it implements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这意味着类的内部工作（实现细节）不一定与外部代码共享。请记住，我们之前提到过类是您只想要使用并期望它能够工作的东西。类向调用代码公开它需要的内容，但它对实现的内部工作保持严格控制。
- en: You can, therefore, hide the variables, properties, and methods by scoping them
    as `private`. This way, you protect the data contained inside the class from accidental
    corruption.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以通过将变量、属性和方法作用域设置为`private`来隐藏它们。这样，您可以保护类内部包含的数据免受意外损坏。
- en: Encapsulation versus abstraction
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装与抽象
- en: 'Let''s pause for a minute again to have a look at this concept, as it confuses
    developers (and it is a bit confusing, so examples help a lot). Part of the problem
    stems from the definitions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次停下来看看这个概念，因为它会让开发人员感到困惑（而且有点令人困惑，所以例子会帮助很多）。问题的一部分源于定义：
- en: '**Abstraction**: only showing what is necessary'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**：只显示必要的内容'
- en: '**Encapsulation**: hiding complexity'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：隐藏复杂性'
- en: 'If we had to think of a basic class to encrypt some text, we''d need to take
    a minute to decide exactly what the class must do. I would imagine that the class
    needs to:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须考虑一个基本的类来加密一些文本，我们需要花一点时间来决定这个类必须做什么。我想象这个类需要：
- en: Take a string value for the text
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为文本获取一个字符串值
- en: Have a method to encrypt the text
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一种方法可以加密文本
- en: 'So, let''s code this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们编写代码：
- en: '[PRE1]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I also know that if I wanted to encrypt some text, that I would need a randomly
    generated byte array to salt the text to be encrypted. Let''s add that method:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我也知道，如果我想要加密一些文本，我需要一个随机生成的字节数组来给要加密的文本加盐。让我们添加这个方法：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, taking a look at the class again, I realize that the encrypted text will
    need to be saved in a database. So, I add a method to do just that:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再看一下类，我意识到加密文本需要保存在数据库中。所以，我添加了一个方法来做到这一点：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we had to implement this class, it would look something like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须实现这个类，它会看起来像这样：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Okay, but now we see that there is a problem. The `salt` needs to be used by
    the encryption method, so naturally we would think to add a parameter to the `Encrypt()`
    method to take the `salt`. We would therefore do the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，但现在我们看到有一个问题。`salt`需要被加密方法使用，所以自然我们会想要在`Encrypt()`方法中添加一个参数来接受`salt`。因此，我们会这样做：
- en: '[PRE5]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is here that the code starts to become a bit blurred. We are calling a method
    on the class to generate a `salt`. We are then passing the `salt` we generated
    from the class, back to the class. Imagine a class with many more methods. Which
    methods need to be called when, and in what order?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码开始变得有点模糊。我们在类上调用一个方法来生成一个`salt`。然后我们将从类中生成的`salt`传回类。想象一个有许多方法的类。哪些方法需要在何时调用，以及以什么顺序？
- en: 'So, let''s take a step back and think. What exactly are we wanting to do here?
    We want to encrypt some text. Therefore, we just want the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们退一步思考。我们到底想要做什么？我们想要加密一些文本。因此，我们只想要以下内容：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is what we call **abstraction**. Looking back at the definition of abstraction,
    what we are doing in code fits with the definition because we are only showing
    what is necessary.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的**抽象**。回顾抽象的定义，我们在代码中所做的与定义相符，因为我们只显示必要的内容。
- en: 'Then what about the other methods in the class? Well, quite simply put...make
    them `private`. The developer implementing your class does not need to know how
    to encrypt a string of text. The developer implementing your class just wants
    to encrypt the string and have it saved. The code can then be **encapsulated**
    as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 那么类中的其他方法呢？很简单地说...将它们设为`private`。实现您的类的开发人员不需要知道如何加密文本字符串。实现您的类的开发人员只想要加密字符串并将其保存。代码可以这样**封装**：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The code that calls the encrypt class is now also much simpler. It looks like
    this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 调用加密类的代码现在也简单得多。它看起来像这样：
- en: '[PRE8]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Again, this fits with the definition of **encapsulation**, which is to hide
    complexity.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这符合**封装**的定义，即隐藏复杂性。
- en: Please note that the code in the preceding encryption example does not have
    any implementation. I was only illustrating a concept here. You are free to add
    your own implementation, should you want to.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面加密示例中的代码没有任何实现。我只是在这里阐述一个概念。如果您愿意，您可以自由添加自己的实现。
- en: Lastly, do not confuse abstraction with abstract classes. These are different
    things. Abstraction is a way of thinking. We will take a look at abstract classes
    in the next section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要将抽象与抽象类混淆。这些是不同的东西。抽象是一种思维方式。我们将在下一节中看看抽象类。
- en: So, take a 5-minute break, grab some fresh air or a cup of coffee, come back,
    and buckle up! It's about to get interesting.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请休息5分钟，呼吸新鲜空气或喝杯咖啡，然后回来，做好准备！事情即将变得有趣。
- en: Classes in Cricket Score Tracker
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 板球比分跟踪器中的类
- en: Taking what we have already learned about the four pillars of OOP, we will have
    a look at the areas in our application that make use of these concepts to provide
    the building blocks of *Cricket Score Tracker*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们已经学到的面向对象编程的四大支柱，我们将看看我们的应用程序中使用这些概念提供*板球比分跟踪器*的构建模块的领域。
- en: Abstract classes
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: 'Open up the `BaseClasses` folder and double click on the `Player.cs` file.
    You will see the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`BaseClasses`文件夹，双击`Player.cs`文件。您将看到以下代码：
- en: '[PRE9]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is our **abstract class**. The `abstract` modifier in the class declaration
    and the properties tells us that this thing we are going to modify has missing
    or incomplete implementation. It, therefore, is only intended for use as a base
    class. Any member marked as abstract must be implemented by classes that are derived
    from our `Player` abstract class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的**抽象类**。类声明中的`abstract`修饰符和属性告诉我们，我们将要修改的东西具有缺失或不完整的实现。因此，它只用作基类。任何标记为抽象的成员必须由派生自我们的`Player`抽象类的类实现。
- en: 'The abstract modifier is used with:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象修饰符与以下内容一起使用：
- en: Classes
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Methods
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Properties
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Indexers
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引器
- en: Events
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: If we had to include a method called `CalculatePlayerRank()` in our abstract
    `Player` class, then we would need to provide an implementation of this method
    in any class that is derived from `Player`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在抽象的`Player`类中包含一个名为`CalculatePlayerRank()`的方法，那么我们需要在任何从`Player`派生的类中提供该方法的实现。
- en: 'Therefore, in the `Player` abstract class, this method would be defined as
    follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`Player`抽象类中，该方法将被定义如下：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In any derived classes, Visual Studio 2017 will be running code analyzers to
    determine if all the members of the abstract class have been implemented by the
    derived classes. When you let Visual Studio 2017 implement the abstract class
    in a derived class, it is defaulted with `NotImplementedException()` in the method
    body:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何派生类中，Visual Studio 2017将运行代码分析器，以确定抽象类的所有成员是否已被派生类实现。当您让Visual Studio 2017在派生类中实现抽象类时，方法主体默认为`NotImplementedException()`：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is done because you haven't actually provided any implementation for the
    `CalculatePlayerRank()` method yet. To do this, you need to replace `throw new
    NotImplementedException();` with actual working code to calculate the rank of
    the current player.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为您尚未为`CalculatePlayerRank()`方法提供任何实现。要做到这一点，您需要用实际的工作代码替换`throw new NotImplementedException();`来计算当前球员的排名。
- en: It is interesting to note is that while `NotImplementedException()` is within
    the body of the `CalculatePlayerRank()` method, it does not warn you that the
    method isn't returning an int value.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，虽然`NotImplementedException()`在`CalculatePlayerRank()`方法的主体内部，但它并没有警告您该方法没有返回int值。
- en: Abstract classes can be seen as a blueprint of what needs to be done. The way
    you do it is up to you as a developer.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类可以被视为需要完成的蓝图。如何完成由开发人员决定。
- en: Interfaces
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: 'Open up the `Interfaces` folder and have a look at the `IBatter.cs` and `IBowler.cs`
    files. The `IBatter` interface looks as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Interfaces`文件夹，查看`IBatter.cs`和`IBowler.cs`文件。`IBatter`接口如下所示：
- en: '[PRE12]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Looking at the `IBowler` interface, you will see the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`IBowler`接口，您将看到以下内容：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'An interface will only contain the signatures of methods, properties, events,
    or indexers. If we had to add a method to the interface to calculate the spin
    of the ball, it would look something like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接口将仅包含方法、属性、事件或索引器的签名。如果我们需要向接口添加一个计算球旋转的方法，它将如下所示：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On the implementation, we would see the code implemented as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现上，我们会看到以下代码实现：
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The next logical question would probably be what the difference is between an
    **abstract class** and an **interface**. Let's turn to the excellent Microsoft
    documentation at—[https://docs.microsoft.com/en-us/](https://docs.microsoft.com/en-us/).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个合乎逻辑的问题可能是**抽象类**和**接口**之间的区别是什么。让我们转向微软的优秀文档网站—[https://docs.microsoft.com/en-us/](https://docs.microsoft.com/en-us/)。
- en: After opening Microsoft Docs, try the dark theme. The theme toggle is to the
    right of the page, just below the Comments, Edit, and Share links. It's really
    great for us night owls.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 打开微软文档后，尝试使用深色主题。主题切换在页面右侧，评论、编辑和分享链接的下方。对于夜猫子来说，这真的很棒。
- en: 'Microsoft sums up an interface very nicely with the following statement:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 微软用以下语句简洁地总结了接口：
- en: An interface is like an abstract base class. Any class or struct that implements
    the interface must implement all its members.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 接口就像抽象基类。实现接口的任何类或结构都必须实现其所有成员。
- en: Think of interfaces as verbs; that is to say, interfaces describe some sort
    of action. Something that a cricket player does. In this case, the actions are
    batting and bowling. The interfaces in *Cricket Score Tracker* are therefore `IBatter`
    and `IBowler`. Note that convention dictates that interfaces begin with the letter
    `I`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将接口视为动词；也就是说，接口描述某种动作。板球运动员所做的事情。在这种情况下，动作是击球和投球。因此，在*板球比分跟踪器*中，接口分别是`IBatter`和`IBowler`。请注意，约定规定接口以字母`I`开头。
- en: Abstract classes on the other hand, act as a noun that tells you what something
    is. We have Batsmen and All-Rounders. We can say that both these cricketers are
    players. That is the common noun that describes the cricketers in a cricket match.
    Therefore, the `Player` abstract class makes sense here.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，抽象类充当告诉您某物是什么的名词。我们有击球手和全能选手。我们可以说这两位板球运动员都是球员。这是描述板球比赛中板球运动员的普通名词。因此，在这里使用`Player`抽象类是有意义的。
- en: Classes
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: The classes used in the *Cricket Score Tracker* app are then created in the
    `Classes` folder. Here you will see a `Batsman` class and an `AllRounder` class.
    For the sake of simplicity, I only created these two classes. In cricket, all
    bowlers must bat, but not all batsmen have to bowl. You then get bowlers who can
    bowl and bat equally well, and they are defined as all-rounders. This is what
    I have modeled here.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cricket Score Tracker*应用程序中使用的类都在`Classes`文件夹中创建。在这里，你会看到一个`Batsman`类和一个`AllRounder`类。为了简单起见，我只创建了这两个类。在板球中，所有投手都必须击球，但并非所有击球手都必须投球。然后你会得到能够击球和投球同样出色的投手，他们被定义为全能手。这就是我在这里建模的内容。'
- en: 'Let''s have a look at the `Batsman` class first. We want a batsman to have
    the abstract properties of a player, but he must also be a batter. Our class,
    therefore, inherits the `Player` base class (remember, we can only inherit from
    a single class) and implements the properties of the `IBatter` interface:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看一下`Batsman`类。我们希望击球手具有球员的抽象属性，但他也必须是击球手。因此，我们的类继承了`Player`基类（记住，我们只能继承自一个类），并实现了`IBatter`接口的属性：
- en: '![](img/831a0232-6c6d-4224-b12e-78c3279d9347.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/831a0232-6c6d-4224-b12e-78c3279d9347.png)'
- en: 'The class definition, therefore, reads as a `Batsman` public class, inherits
    a `Player`, and implements the `IBatter` interface. The `Batsman` class, therefore,
    looks as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类定义读作`Batsman`公共类，继承自`Player`，并实现`IBatter`接口。因此，`Batsman`类如下所示：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the `Batsman` class implements the properties of the abstract class
    and the interface. Also note that, at this point in time, I do not want to add
    an implementation for the `CalculatePlayerRank()` method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Batsman`类实现了抽象类和接口的属性。同时，请注意，此时我不想为`CalculatePlayerRank()`方法添加实现。
- en: 'Let''s have a look at the `AllRounder` class. We want the all-rounders to also
    have the abstract properties of a player, but they must also be a batter and a
    bowler. Our class, therefore, inherits the `Player` base class but now implements
    the properties of the `IBatter` and the `IBowler` interfaces:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下`AllRounder`类。我们希望全能手也具有球员的抽象属性，但他们也必须是击球手和投球手。因此，我们的类继承了`Player`基类，但现在实现了`IBatter`和`IBowler`接口的属性：
- en: '![](img/e3e9d4d8-759e-4f37-985a-6deca302a550.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3e9d4d8-759e-4f37-985a-6deca302a550.png)'
- en: 'The class definition, therefore, reads as an `AllRounder` public class, inherits
    a `Player`, and implements the `IBatter` and `IBowler` interfaces. The `AllRounder`
    class, therefore, looks as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类定义读作`AllRounder`公共类，继承自`Player`，并实现`IBatter`和`IBowler`接口。因此，`AllRounder`类如下所示：
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You will notice once again that I didn't add in any implementation for the `CalculatePlayerRank()`
    method. Because the abstract class defines this method, all classes that inherit
    from the abstract class must implement this method.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你会再次注意到，我没有为`CalculatePlayerRank()`方法添加任何实现。因为抽象类定义了这个方法，所有继承自抽象类的类都必须实现这个方法。
- en: You now also see that this `AllRounder` class must implement the properties
    of both `IBowler` and `IBatter`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你也看到`AllRounder`类必须实现`IBowler`和`IBatter`的属性。
- en: Putting it all together
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: Now, let's have a look how we use the classes to create the *Cricket Score Tracker*
    app. The buttons below the Batters section and Bowler section are used to select
    batsmen and a bowler for the specific over.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下如何使用这些类来创建*Cricket Score Tracker*应用程序。在击球手部分和投球手部分下面的按钮用于选择特定局的击球手和投球手。
- en: 'While each button is taken care of by its own click event, they all call the
    exact same method. We will have a look at how that is accomplished in a moment:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个按钮都由自己的点击事件处理，但它们都调用完全相同的方法。我们稍后将看一下是如何实现的：
- en: '![](img/24028b13-060e-4243-a892-b968a5e3f407.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/24028b13-060e-4243-a892-b968a5e3f407.png)'
- en: 'Clicking on either button under the Batsmen section will display a modal dialog
    with a drop-down list populated with the batsmen in the team:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 点击Batsmen部分下的任一按钮将显示一个带有填充有该队伍中击球手的下拉列表的模态对话框：
- en: '![](img/56998740-9ac9-4b01-a6cc-f02e7f824cb1.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/56998740-9ac9-4b01-a6cc-f02e7f824cb1.png)'
- en: 'Similarly, when we click on the Select Bowler button, we will see the exact
    same modal dialog screen displayed. This time, however, it will be a list of bowlers
    displayed for selection:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们点击选择投球手按钮时，我们将看到完全相同的模态对话框屏幕显示。不过这次，它将显示可供选择的投球手列表：
- en: '![](img/1d699c73-6536-43c9-bc12-bd70d4f5b03d.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1d699c73-6536-43c9-bc12-bd70d4f5b03d.png)'
- en: Selecting players from the drop-down lists will populate the text on the button
    clicked with that player's name. This then sets up the current over with the players
    involved.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从下拉列表中选择球员将填充按钮点击时显示的文本为该球员的名字。然后设置当前局的参与球员。
- en: Take note that we are talking in terms of the classes here. We have players,
    but they can be batsmen or all-rounders (bowlers).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里谈论的是类。我们有球员，但他们可以是击球手或全能手（投球手）。
- en: 'Each player will be either a batsman or a bowler (`AllRounder` class):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每个球员都是击球手或投球手（`AllRounder`类）：
- en: '![](img/bd46254e-7dde-40a7-b76a-eb1e22968cbd.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd46254e-7dde-40a7-b76a-eb1e22968cbd.png)'
- en: So how did we manage to make a single method return two different players? I
    used a method called `GeneratePlayerList()`. This method is responsible for creating
    the player list in the modal dialog that pops up. That is all that method is responsible
    for. In other words, it performs no other function apart from generating the player
    list.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们是如何让一个方法返回两个不同的球员的呢？我使用了一个叫做`GeneratePlayerList()`的方法。这个方法负责在弹出的模态对话框中创建球员列表。这就是这个方法的全部责任。换句话说，它除了生成球员列表之外不执行任何其他功能。
- en: 'Let''s look at how the `Default.aspx.cs` file is created. For simplicity''s
    sake, I just created two lists for each team. I also created an `enum` for the
    player selection. The code looks as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`Default.aspx.cs`文件是如何创建的。为了简单起见，我只为每个队伍创建了两个列表。我还创建了一个用于选择球员的`enum`。代码如下：
- en: '[PRE18]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In reality, however, you would probably make the list names `team1` and `team2`,
    and allow the user to select the teams from a setup screen for this game. I have
    not added this functionality as I am merely trying to illustrate the concepts
    of OOP here.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，实际上，你可能会将列表名称命名为`team1`和`team2`，并允许用户从设置屏幕上选择这场比赛的队伍。我没有添加这个功能，因为我只是想在这里说明面向对象编程的概念。
- en: 'In `Page_Load`, I then populate the lists with players, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Page_Load`中，我用以下方法填充列表：
- en: '[PRE19]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Again, for simplicity, I have hard-coded the player names and manually added
    them to the lists.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 再次为了简单起见，我已经将球员的名字硬编码并手动添加到列表中。
- en: The `Get_India_Players()` method is identical to that of the `Get_SA_Players()`
    method. You can then just copy the method and change the names to your favorite
    cricket players or favorite cricket teams.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get_India_Players()`方法与`Get_SA_Players()`方法是相同的。然后你可以复制这个方法，将名字改成你最喜欢的板球运动员或最喜欢的板球队。'
- en: In reality, you would probably read this from a database of teams and players.
    So instead of `Get_SA_Players()` and `Get_India_Players()`, you would have a single
    `Get_Players()` method that would be responsible for reading the players into
    the lists.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可能会从一个团队和球员的数据库中读取这些信息。所以，你不会有`Get_SA_Players()`和`Get_India_Players()`，而是会有一个单一的`Get_Players()`方法，负责将球员读入列表中。
- en: 'For now, looking at the `Get_SA_Players()` method, we simply do the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看`Get_SA_Players()`方法，我们只是做以下操作：
- en: '[PRE20]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice now that the `players` list is of type `List<Player>`, and that we are
    adding `Batsman` and `AllRounder` types to it. This is what the term **polymorphism**
    means. Remember that one of the aspects of polymorphism we mentioned earlier was:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在注意到`players`列表的类型是`List<Player>`，我们正在向其中添加`Batsman`和`AllRounder`类型。这就是**多态性**的含义。记住我们之前提到的多态性的一个方面是：
- en: During run time, a class that is derived from a base class may be treated as
    an object of the class it inherits. This is seen in parameters, collections or
    arrays.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，从基类派生的类可以被视为它继承的类的对象。这在参数、集合或数组中可以看到。
- en: Therefore, because `Batsman` and `AllRounder` inherit from the `Player` abstract
    class, they are treated as objects of `Player` for the `List<Player>`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，因为`Batsman`和`AllRounder`都继承自`Player`抽象类，它们被视为`List<Player>`的对象。
- en: If you swing back to the section on polymorphism earlier in the chapter, you
    will see that this is an example of run-time polymorphism.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到本章前面关于多态性的部分，你会发现这是运行时多态性的一个例子。
- en: 'Moving back to the logic to select the batsman or bowler, we look to a method
    to generate the player list called `GeneratePlayerList()`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 回到选择击球手或投球手的逻辑，我们寻找一个生成球员列表的方法，称为`GeneratePlayerList()`：
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You will notice that the method takes a `List<Player>` argument as well as a
    `Type`. The method checks whether `type` is a `Batsman` or `AllRounder` and based
    on that, reads the first and last names of the players in the list.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这个方法接受一个`List<Player>`参数和一个`Type`。该方法检查`type`是`Batsman`还是`AllRounder`，并基于此读取列表中球员的名字。
- en: I believe that this method can be simplified even further, but I wanted to illustrate
    the concept of polymorphism at work.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信这种方法甚至可以进一步简化，但我想说明多态性的概念。
- en: The actual aim is to try and write the least amount of code for the maximum
    required effect. As a rule of thumb, some developers maintain that if a method's
    length is longer than the code page you are looking at in the IDE, you need to
    do some refactoring.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 实际目标是尽量用最少的代码实现最大的效果。作为一个经验法则，一些开发人员认为，如果一个方法的长度超过了你在IDE中看到的代码页，你需要进行一些重构。
- en: Having less code and smaller methods allows the code to be easier to read and
    understand. It also allows better maintainability of that code because smaller
    sections of code are easier to debug. In fact, you might experience fewer bugs
    because you are writing smaller, more manageable pieces of code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 更少的代码和更小的方法使得代码更易于阅读和理解。它还使得代码更易于维护，因为更小的代码段更容易调试。事实上，你可能会遇到更少的bug，因为你正在编写更小、更易管理的代码片段。
- en: Many years ago, I was part of a team that worked on a project for a large corporation
    in Cape Town. They had a systems architect called *Uthmaan Hendrix*. I will never
    forget this guy. He was the humblest bloke I had ever come across. The documentation
    he created for the system we worked on was simply incredible. It took almost all
    the think work out of the code we had to write. The developers didn't have to
    decide how to architect the project at all.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 许多年前，我曾是开普敦一家大公司项目团队的一员。他们有一个名叫*乌斯曼·亨德里克斯*的系统架构师。我永远不会忘记这个家伙。他是我见过的最谦逊的家伙。他为我们所做系统的文档简直令人难以置信。几乎所有的思考工作都已经包含在我们需要编写的代码中。开发人员根本不需要决定如何设计项目。
- en: This project implemented SOLID principles, and understanding the code was really
    easy. I still have a copy of that document. I still refer to it from time to time.
    Unfortunately, not all developers have the luxury of having a dedicated systems
    architect on the project they are working with. It is, however, good for developers
    to understand what the SOLID design principles are.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目实现了SOLID原则，理解代码真的很容易。我现在还有那份文档的副本。我时不时地会参考它。不幸的是，并不是所有的开发人员都有幸在他们所工作的项目中有一个专门的系统架构师。然而，开发人员了解SOLID设计原则是很有好处的。
- en: SOLID design principles
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID设计原则
- en: This brings us to another interesting concept in OOP called **SOLID** design
    principles. These design principles apply to any OOP design and are intended to
    make software easier to understand, more flexible, and easily maintainable.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了面向对象编程中另一个有趣的概念，叫做**SOLID**设计原则。这些设计原则适用于任何面向对象的设计，旨在使软件更易于理解、更灵活和更易于维护。
- en: 'The term SOLID is a mnemonic for:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID是一个记忆术，代表：
- en: Single responsibility principle
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Open/closed principle
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: Liskov substitution principle
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 里氏替换原则
- en: Interface segregation principle
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: Dependency inversion principle
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖反转原则
- en: In this chapter, we will only take a look at the first two principles—the **single
    responsibility principle** and the **open/closed principle**. Let's look at the
    single responsibility principle next.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只会看一下前两个原则——**单一责任原则**和**开闭原则**。让我们接下来看一下单一责任原则。
- en: Single responsibility principle
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一责任原则
- en: 'Simply put, a module or class should have the following characteristics only:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，一个模块或类应该只具有以下特征：
- en: It should do one single thing and only have a single reason to change
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该只做一件事情，并且只有一个改变的原因
- en: It should do its one single thing well
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该很好地完成它的单一任务
- en: The functionality provided needs to be entirely encapsulated by that class or
    module
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供的功能需要完全由该类或模块封装
- en: 'What is meant when saying that a module must be responsible for a single thing?
    The Google definition of a module is:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 说一个模块必须负责一件事情是什么意思？谷歌对模块的定义是：
- en: '"Each of a set of standardized parts or independent units that can be used
    to construct a more complex structure, such as an item of furniture or a building."'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: “一组标准化的部分或独立单元，可以用来构建更复杂的结构，比如家具或建筑物。”
- en: From this, we can understand that a module is a simple building block. It can
    be used or reused to create something bigger and more complex when used with other
    modules. In C# therefore, the module does closely resemble a class, but I will
    go so far as to say that a module can also be extended to be a method.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 由此，我们可以理解模块是一个简单的构建块。当与其他模块一起使用时，它可以被使用或重复使用来创建更大更复杂的东西。因此，在C#中，模块确实与类非常相似，但我会说模块也可以扩展为一个方法。
- en: The function that the class or module performs can only be one thing. That is
    to say that it has a **narrow responsibility**. It is not concerned with anything
    else other than doing that one thing it was designed to do.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 类或模块执行的功能只能是一件事情。也就是说，它有一个**狭窄的责任**。它只关心它被设计来做的那一件事情，而不关心其他任何事情。
- en: If we had to apply the single responsibility principle to a person, then that
    person would be only a software developer, for example. But what if a software
    developer also was a doctor and a mechanic and a school teacher? Would that person
    be effective in any of those roles? That would contravene the single responsibility
    principle. The same is true for code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须将单一责任原则应用于一个人，那么这个人只能是一个软件开发人员，例如。但如果一个软件开发人员也是医生、机械师和学校老师呢？那这个人在任何一个角色中都会有效吗？这将违反单一责任原则。对于代码也是如此。
- en: 'Having a look at our `AllRounder` and `Batsman` classes, you will notice that
    in `AllRounder`, we have the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下我们的`AllRounder`和`Batsman`类，你会注意到在`AllRounder`中，我们有以下代码：
- en: '[PRE22]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In `Batsman`, we have the following code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Batsman`中，我们有以下代码：
- en: '[PRE23]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using what we have learned about the single responsibility principle, we notice
    that there is an issue here. To illustrate the problem, let''s compare the code
    side by side:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们对单一责任原则的了解，我们注意到这里存在一个问题。为了说明问题，让我们将代码并排比较：
- en: '![](img/25126aec-6d16-4015-be30-41596360896f.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/25126aec-6d16-4015-be30-41596360896f.png)'
- en: We are essentially repeating code in the `Batsman` and `AllRounder` classes.
    This doesn't really bode well for single responsibility, does it? I mean, the
    one principle is that a class must only have a single function to perform. At
    the moment, both the `Batsman` and `AllRounder` classes are taking care of calculating
    strike rates. They also both take care of calculating the player rank. They even
    both have exactly the same code for calculating the strike rate of a batsman!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Batsman`和`AllRounder`类中，我们实际上在重复代码。这对于单一责任来说并不是一个好兆头，对吧？我的意思是，一个类只能有一个功能。目前，`Batsman`和`AllRounder`类都负责计算击球率。它们也都负责计算球员排名。它们甚至都有完全相同的代码来计算击球手的击球率！
- en: The problem comes in when the strike rate calculation changes (not that it easily
    would, but let's assume it does). We now know that we have to change the calculation
    in both places. As soon as the developer changes one calculation and not the other,
    a bug is introduced into our application.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出现在击球率计算发生变化时（虽然不太容易发生，但让我们假设它发生了）。我们现在知道我们必须在两个地方改变计算。一旦开发人员只改变了一个计算而没有改变另一个，就会在我们的应用程序中引入一个bug。
- en: 'Let''s simplify our classes. In the `BaseClasses` folder, create a new abstract
    class called `Statistics`. The code should look as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简化我们的类。在`BaseClasses`文件夹中，创建一个名为`Statistics`的新的抽象类。代码应该如下所示：
- en: '[PRE24]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the `Classes` folder, create a new derived class called `PlayerStatistics`
    (that is to say it inherits from the `Statistics` abstract class). The code should
    look as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Classes`文件夹中，创建一个名为`PlayerStatistics`的新派生类（也就是它继承自`Statistics`抽象类）。代码应该如下所示：
- en: '[PRE25]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You will see that the `PlayerStatistics` class is now solely responsible for
    calculating player statistics for the player's rank and the player's strike rate.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到`PlayerStatistics`类现在完全负责计算球员的排名和击球率的统计数据。
- en: You will see that I have not included much of an implementation for calculating
    the player's rank. I briefly commented the code on GitHub for this method on how
    a player's rank is determined. It is quite a complicated calculation and differs
    for batsmen and bowlers. I have therefore omitted it for the purposes of this
    chapter on OOP.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我没有包括计算球员排名的实现。我在GitHub上简要评论了这个方法，说明了球员排名是如何确定的。这是一个相当复杂的计算，对于击球手和投球手是不同的。因此，我在这一章关于面向对象编程的目的上省略了它。
- en: 'Your Solution should now look as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你的解决方案现在应该如下所示：
- en: '![](img/61d01824-3ddf-4b48-b0bb-9888f267f147.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/61d01824-3ddf-4b48-b0bb-9888f267f147.png)'
- en: Swing back over to your `Player` abstract class and remove `abstract public
    int CalculatePlayerRank();` from the class. In the `IBowler` interface, remove
    the `double BowlerStrikeRate { get; }` property. In the `IBatter` interface, remove
    the `double BatsmanBattingStrikeRate { get; }` property.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 回到你的`Player`抽象类，从类中移除`abstract public int CalculatePlayerRank();`。在`IBowler`接口中，移除`double
    BowlerStrikeRate { get; }`属性。在`IBatter`接口中，移除`double BatsmanBattingStrikeRate
    { get; }`属性。
- en: 'In the `Batsman` class, remove `public double BatsmanBattingStrikeRate` and
    `public override int CalculatePlayerRank()` from the class. The code in the `Batsman`
    class will now look as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Batsman`类中，从类中移除`public double BatsmanBattingStrikeRate`和`public override
    int CalculatePlayerRank()`。现在`Batsman`类的代码如下：
- en: '[PRE26]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Looking at the `AllRounder` class, remove the `public enum StrikeRate { Bowling
    = 0, Batting = 1 }` enum as well as the `public double BatsmanBattingStrikeRate`
    and `public double BowlerStrikeRate` properties.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`AllRounder`类，移除`public enum StrikeRate { Bowling = 0, Batting = 1 }`枚举，以及`public
    double BatsmanBattingStrikeRate`和`public double BowlerStrikeRate`属性。
- en: 'Lastly, remove the `private double CalculateStrikeRate(StrikeRate strikeRateType)`
    and `public override int CalculatePlayerRank()` methods. The code for the `AllRounder`
    class now looks as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，移除`private double CalculateStrikeRate(StrikeRate strikeRateType)`和`public
    override int CalculatePlayerRank()`方法。现在`AllRounder`类的代码如下：
- en: '[PRE27]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Looking back at our `AllRounder` and `Batsman` classes, the code is clearly
    simplified. It is definitely more flexible and is starting to look like a well-constructed
    set of classes. Give your solution a rebuild and make sure that it is all working.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下我们的`AllRounder`和`Batsman`类，代码显然更简化了。它肯定更灵活，开始看起来像一组构建良好的类。重新构建你的解决方案，确保一切正常运行。
- en: Open/closed principle
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Previously, we had a look at the **single responsibility principle**. Hand in
    hand with this is the **open/closed principle**.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们已经看过**单一职责原则**。与此相辅相成的是**开闭原则**。
- en: 'Bertrand Meyer stated that software entities (classes, modules, functions,
    and so on):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Bertrand Meyer说过，软件实体（类、模块、函数等）：
- en: Should be open for extension
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该对扩展开放
- en: Should be closed for modification
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该对修改关闭
- en: What exactly does this mean? Let's take the `PlayerStatistics` class as an example.
    Inside this class, you know that we have a method to calculate the strike rate
    of a particular player. This is included in the class because it inherits from
    the `Statistics` abstract class. That is correct, but the fact that the `CalculateStrikeRate(Player
    player)` method caters for two player types (all-rounders and batsmen) is already
    a hint of a problem.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这到底意味着什么？让我们以`PlayerStatistics`类为例。在这个类中，你知道我们有一个方法来计算特定球员的击球率。这是因为它继承自`Statistics`抽象类。这是正确的，但`CalculateStrikeRate(Player
    player)`方法为两种球员类型（全能选手和击球手）提供服务，这已经是一个问题的暗示。
- en: Let's assume that we have introduced new player types—different bowler types
    (for example, fast bowlers and spin bowlers). In order for us to accommodate the
    new player type, we must change the code in the `CalculateStrikeRate()` method.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们引入了新的球员类型——不同的投球手类型（例如快速投球手和旋转投球手）。为了适应新的球员类型，我们必须改变`CalculateStrikeRate()`方法中的代码。
- en: What if we wanted to pass through a collection of batsmen to calculate the average
    strike rate between all of them? We would need to modify the `CalculateStrikeRate()`
    method again to accommodate this. As time goes by and the complexities increase,
    it will become very difficult to keep on catering for different player types that
    need the strike rate calculation. This means that our `CalculateStrikeRate()`
    method is **open for modification** and **closed for extension**. This is in contravention
    of the principles stated previously in the bullet list.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要传递一组击球手来计算他们之间的平均击球率，我们需要再次修改`CalculateStrikeRate()`方法来适应这一点。随着时间的推移和复杂性的增加，为不同需要击球率计算的球员类型提供服务将变得非常困难。这意味着我们的`CalculateStrikeRate()`方法是**对修改开放**但**对扩展关闭**。这违反了之前列出的原则。
- en: 'So, what can we do to fix this? In truth, we are already halfway there. Start
    by creating a new `Bowler` class in the `Classes` folder:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该怎么做才能解决这个问题呢？事实上，我们已经走了一半的路。首先，在`Classes`文件夹中创建一个新的`Bowler`类：
- en: '[PRE28]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can see how easy it is to construct new player types—we have only to tell
    the class that it needs to inherit the `Player` abstract class and implement the
    `IBowler` interface.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到构建新的球员类型有多么容易——我们只需要告诉类它需要继承`Player`抽象类并实现`IBowler`接口。
- en: 'Next, we need to create new player statistics classes—namely, `BatsmanStatistics`,
    `BowlerStatistics`, and `AllRounderStatistics`. The code for the `BatsmanStatistics`
    class will look as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建新的球员统计类，即`BatsmanStatistics`、`BowlerStatistics`和`AllRounderStatistics`。`BatsmanStatistics`类的代码如下：
- en: '[PRE29]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we add the `AllRounderStatistics` class:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加`AllRounderStatistics`类：
- en: '[PRE30]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Lastly, we add the new player type statistics class called `BowlerStatistics`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了名为`BowlerStatistics`的新球员类型统计类：
- en: '[PRE31]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Moving the responsibility of calculating the strike rates for all players away
    from the `PlayerStatistics` class makes our code cleaner and more robust. In fact,
    the `PlayerStatistics` class is all but obsolete.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 将计算所有球员击球率的责任从`PlayerStatistics`类中移开，使我们的代码更清晰、更健壮。事实上，`PlayerStatistics`类已经几乎过时了。
- en: By adding another player type, we were able to easily define the logic of this
    new player by implementing the correct interface. Our code is smaller and easier
    to maintain. We can see this by comparing the previous code for `CalculateStrikeRate()`
    with the new code we wrote.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加另一种球员类型，我们能够通过实现正确的接口轻松定义这个新球员的逻辑。我们的代码更小，更容易维护。通过比较我们之前编写的`CalculateStrikeRate()`的代码和新代码，我们可以看到这一点。
- en: 'To illustrate more clearly, take a look at the following code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明，看一下下面的代码：
- en: '[PRE32]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code is much more complex and less maintainable than the following:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码比下面的代码复杂得多，难以维护：
- en: '[PRE33]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The benefit of creating a `BowlerStatistics` class, for example, is that you
    know that throughout the class we are only dealing with a bowler and nothing else...a
    single responsibility that is open for extension without having to modify the
    code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，创建一个`BowlerStatistics`类的好处是，你知道在整个类中我们只处理球员，没有别的东西……一个单一的责任，可以在不修改代码的情况下进行扩展。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: While the principles of SOLID programming are great guidelines to follow, very
    few systems that you come across will actually implement them throughout the application.
    This is especially true if you inherit a system and that system has been in production
    for a number of years.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SOLID编程原则是很好的指导方针，但你遇到的很少有系统会在整个应用程序中实际实现它们。特别是如果你继承了一个已经投入生产多年的系统。
- en: I will admit that I have come across applications designed with SOLID in mind.
    These were really easy to work on and the bar is set high for other developers
    in a team to maintain the same level of code quality.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，我遇到过一些以SOLID为设计理念的应用程序。这些应用程序非常容易操作，对团队中的其他开发人员设定了很高的代码质量标准。
- en: Peer code reviews and a thorough understanding of SOLID principles by every
    developer on the team ensure that the same level of code is maintained.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 同行代码审查和团队中每个开发人员对SOLID原则的深入理解，确保了保持相同水平的代码质量。
- en: This chapter has had a lot going on. Apart from laying the foundation for a
    really nice *Cricket Score Tracking* app, we have had a look at what OOP really
    means.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章内容非常丰富。除了为一个非常好的*板球比分跟踪*应用程序奠定基础外，我们还深入了解了面向对象编程的真正含义。
- en: We had a look at abstraction and the difference between abstraction and encapsulation.
    We discussed polymorphism, and we looked at what run-time polymorphism is versus
    compile-time polymorphism. We also had a look at inheritance, which was creating
    a derived class by inheriting a base class.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了抽象和封装之间的区别。我们讨论了多态性，并了解了运行时多态性与编译时多态性的区别。我们还研究了继承，即通过继承基类来创建派生类。
- en: We then discussed classes, abstract classes (which are not to be confused with
    abstraction), and interfaces. The difference between abstract classes and interfaces
    were (hopefully) clearly explained. Remember, an interface acts as a verb or action
    whereas an abstract class acts as a noun which states what something is.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了类、抽象类（不要与抽象混淆）和接口。希望清楚地解释了抽象类和接口之间的区别。记住，接口充当动词或行为，而抽象类充当名词，说明某物是什么。
- en: In the last section, we briefly discussed SOLID design principles and highlighted
    the single responsibility and open/closed principles.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们简要讨论了SOLID设计原则，并强调了单一责任和开闭原则。
- en: In the next chapter, we will be delving into cross-platform development using
    .NET Core. You will see that .NET Core is a very important skill to master and
    that it will be with us for a long time to come. As .NET Core and the .NET Standard
    evolve, developers will be empowered to create—well, I will leave that up to you
    to imagine. The sky's the limit.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨使用.NET Core进行跨平台开发。你会发现.NET Core是一个非常重要的技能，它将伴随我们很长一段时间。随着.NET
    Core和.NET标准的发展，开发人员将有能力创造——好吧，我会留给你来想象。天空是极限。
