- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Getting Your Hands Dirty with Unity
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中动手实践
- en: Creating a game involves much more than just simulating actions in code. Design,
    story, environment, lighting, and animation all play an important part in setting
    the stage for your players. A game is, first and foremost, an experience, which
    code alone can't deliver.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 创建游戏涉及的远不止在代码中模拟动作。设计、故事、环境、灯光和动画都在为玩家设定舞台中扮演着重要的角色。游戏首先是一种体验，单靠代码是无法实现的。
- en: Unity has placed itself at the forefront of game development over the past decade
    by bringing advanced tools to programmers and non-programmers alike. Animation
    and effects, audio, environment design, and much more are all available directly
    from the Unity Editor without a single line of code. We'll discuss these topics
    as we define the requirements, environment, and game mechanics of our game. However,
    first, we need a topical introduction to game design.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年里，Unity通过为程序员和非程序员带来先进的工具，将自己置于游戏开发的最前沿。动画和特效、音频、环境设计等等，所有这些都可以直接从Unity编辑器中获得，而不需要一行代码。我们将在定义我们的游戏的需求、环境和游戏机制时讨论这些话题。然而，首先，我们需要一个游戏设计的主题介绍。
- en: 'Game design theory is a big area of study and learning all its secrets can
    consume an entire career. However, we''ll only be getting hands-on with the basics;
    everything else is up to you to explore! This chapter will set us up for the rest
    of the book and will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏设计理论是一个庞大的研究领域，学习它的所有秘密可能需要整个职业生涯。然而，我们只会动手实践基础知识；其他一切都取决于你去探索！这一章将为我们打下基础，并涵盖以下话题：
- en: A game design primer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏设计入门
- en: Building a level
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建造一个关卡
- en: Lighting basics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灯光基础
- en: Animating in Unity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中制作动画
- en: A game design primer
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏设计入门
- en: 'Before jumping into any game project, it''s important to have a blueprint of
    what you want to build. Sometimes, ideas will start crystal clear in your mind,
    but the minute you start creating character classes or environments, things seem
    to drift away from your original intention. This is where the game''s design allows
    you to plan out the following touchpoints:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在着手任何游戏项目之前，重要的是要有一个你想要构建的蓝图。有时，想法会在你的脑海中变得清晰明了，但一旦你开始创建角色类别或环境，事情似乎会偏离你最初的意图。这就是游戏设计允许你规划以下接触点的地方：
- en: '**Concept**: The big-picture idea and design of a game, including its genre
    and play style.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概念**：游戏的大局观念和设计，包括它的类型和玩法风格。'
- en: '**Core mechanics**: The playable features or interactions that a character
    can take in-game. Common gameplay mechanics include jumping, shooting, puzzle-solving,
    or driving.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心机制**：角色在游戏中可以进行的可玩特性或互动。常见的游戏机制包括跳跃、射击、解谜或驾驶。'
- en: '**Control schemes**: A map of the buttons and/or keys that give players control
    over their character, environment interactions, and other executable actions.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制方案**：给玩家控制他们的角色、环境互动和其他可执行动作的按钮和/或键的地图。'
- en: '**Story**: The underlying narrative that fuels a game, creating empathy and
    a connection between players and the game world they play in.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故事**：推动游戏的潜在叙事，创造玩家和他们所玩的游戏世界之间的共鸣和连接。'
- en: '**Art style**: The game''s overarching look and feel, consistent across everything
    from characters and menu art to the levels and environment.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**艺术风格**：游戏的整体外观和感觉，从角色和菜单艺术到关卡和环境都保持一致。'
- en: '**Win and lose conditions**: The rules that govern how the game is won or lost,
    usually consisting of objectives or goals that carry the weight of potential failure.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**胜利和失败条件**：规定游戏如何获胜或失败的规则，通常包括潜在失败的目标或目标。'
- en: These topics are by no means an exhaustive list of what goes into designing
    a game. However, they're a good place to start fleshing out something called a
    game design document, which is your next task!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些话题绝不是游戏设计所涉及的全部内容的详尽列表。然而，它们是开始构思所谓的游戏设计文件的好地方，这是你下一个任务！
- en: Game design documents
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏设计文件
- en: Googling game design documents will result in a flood of templates, formatting
    rules, and content guidelines that can leave a new programmer ready to give it
    all up. The truth is, design documents are tailored to the team or company that
    creates them, making them much easier to draft than the internet would have you
    think.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌游戏设计文件会得到一大堆模板、格式规则和内容指南，这可能会让新程序员准备放弃。事实上，设计文件是根据创建它们的团队或公司量身定制的，比互联网上的想象要容易得多。
- en: 'In general, there are three types of design documentation, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，有三种类型的设计文档，如下：
- en: '**Game Design Document** (**GDD**): The GDD houses everything from how the
    game is played to its atmosphere, story, and the experience it''s trying to create.
    Depending on the game, this document can be a few pages long or several hundred.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏设计文件**（**GDD**）：GDD包含了游戏的玩法、氛围、故事以及它试图创造的体验。根据游戏的不同，这个文件可能只有几页长，也可能有几百页。'
- en: '**Technical Design Document** (**TDD**): This document focuses on all the technical
    aspects of the game, from the hardware it will run on to how the classes and program
    architecture need to be built out. Like a GDD, the length will vary based on the
    project.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术设计文件**（**TDD**）：这个文件关注游戏的所有技术方面，从它将在哪种硬件上运行到类别和程序架构需要如何构建。和GDD一样，长度会根据项目的不同而变化。'
- en: '**One-page**: Usually used for marketing or promotional situations, a one-page
    is essentially a snapshot of your game. As the name suggests, it should only take
    up a single page.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一页纸**：通常用于营销或推广情况，一页纸本质上是你游戏的快照。顾名思义，它应该只占据一页纸。'
- en: There's no right or wrong way to format a GDD, so it's a good place to let your
    brand of creativity thrive. Throw in pictures of reference material that inspires
    you; get creative with the layout—this is your place to define your vision.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种正确或错误的方式来格式化GDD，所以这是一个让你的创造力茁壮成长的好地方。加入一些启发你的参考材料的图片；在布局上发挥创意——这是你定义你的愿景的地方。
- en: The game we'll be working on throughout the rest of this book is fairly simple
    and won't require anything as detailed as a GDD or TDD. Instead, we'll create
    a one-page to keep track of our project objectives and some background information.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的其余部分中一直致力于开发的游戏相当简单，不需要像GDD或TDD那样详细的东西。相反，我们将创建一个一页来跟踪我们的项目目标和一些背景信息。
- en: The Hero Born one-page
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Hero Born一页
- en: 'To keep us on track going forward, I''ve put together a simple document that
    lays out the basics of the game prototype. Read through it before moving on, and
    try to start imagining some of the programming concepts that we''ve learned so
    far being put into practice:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们在前进时保持在正确的轨道上，我已经准备了一个简单的文档，概述了游戏原型的基础知识。在继续之前，请仔细阅读一遍，并尝试想象我们迄今学到的一些编程概念如何付诸实践：
- en: '![](img/B17573_06_01.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_01.png)'
- en: 'Figure 6.1: Hero Born one-page document'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：Hero Born一页文档
- en: Now that you have a high-level view of the bones of our game, you're ready to
    start building a prototype level to house the game experience.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对我们游戏的骨架有了一个高层次的了解，你可以开始建立一个原型关卡来容纳游戏体验。
- en: Building a level
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立一个关卡
- en: When building your game levels, it's always a good idea to try to see things
    from the perspective of your players. How do you want them to see the environment,
    interact with it, and feel while walking around in it? You're literally building
    the world your game exists in, so be consistent.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建游戏关卡时，尝试从玩家的角度看事物总是一个好主意。你希望他们如何看待环境，如何与之交互，以及在其中行走时的感受？你实际上正在构建你的游戏存在的世界，所以要保持一致。
- en: With Unity, you have the option of creating outdoor environments using the Terrain
    tool, blocking out something set indoors with basic shapes and geometry, or a
    mixture of the two. You can even import 3D models from other programs, such as
    Blender, to use as objects in your scenes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Unity，你可以选择使用地形工具创建室外环境，用基本形状和几何图形来阻挡室内设置，或者两者的混合。你甚至可以从其他程序（如Blender）导入3D模型，用作场景中的对象。
- en: Unity has a great introduction to the Terrain tool at [https://docs.unity3d.com/Manual/script-Terrain.html](https://docs.unity3d.com/Manual/script-Terrain.html).
    If you're going down that route, there's also a wonderful free asset on the Unity
    Asset Store called Terrain Toolkit 2017, available at [https://assetstore.unity.com/packages/tools/terrain/terrain-toolkit-2017-83490](https://assetstore.unity.com/packages/tools/terrain/terrain-toolkit-2017-83490).
    You can also use tools like Blender to create your game assets, which you can
    find at [https://www.blender.org/features/modeling/](https://www.blender.org/features/modeling/).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Unity在[https://docs.unity3d.com/Manual/script-Terrain.html](https://docs.unity3d.com/Manual/script-Terrain.html)上有一个很好的地形工具介绍。如果你选择这条路线，Unity
    Asset Store上还有一个名为Terrain Toolkit 2017的免费资产，可以在[https://assetstore.unity.com/packages/tools/terrain/terrain-toolkit-2017-83490](https://assetstore.unity.com/packages/tools/terrain/terrain-toolkit-2017-83490)找到。你也可以使用Blender等工具来创建你的游戏资产，可以在[https://www.blender.org/features/modeling/](https://www.blender.org/features/modeling/)找到。
- en: For *Hero Born*, we'll stick with a simple indoor arena-like setting that's
    easy to get around, but with a few corners to hide in. You'll cobble all this
    together using **primitives**—base object shapes provided in Unity—because of
    how easy they are to create, scale, and position in a scene.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*Hero Born*，我们将坚持简单的室内竞技场设置，这样可以轻松移动，但也有一些角落可以藏身。你将使用**primitives**——Unity提供的基本对象形状——将所有这些组合在一起，因为它们在场景中创建、缩放和定位起来非常容易。
- en: Creating primitives
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建primitives
- en: Looking at games you might play regularly, you're probably wondering how you'll
    ever create models and objects that look so realistic that it seems you could
    reach through the screen and grab them. Fortunately, Unity has a set of primitive
    GameObjects that you can select from to prototype faster. These won't be super
    fancy or high-definition, but they are a lifesaver when you're learning the ropes
    or don't have a 3D artist on your development team.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 看着你经常玩的游戏，你可能会想知道如何才能创建看起来如此逼真，以至于似乎可以伸手进屏幕抓住它们的模型和物体。幸运的是，Unity有一组基本的GameObject可以供你选择，以便更快地创建原型。这些可能不会很华丽或高清，但当你在学习或开发团队中没有3D艺术家时，它们是救命稻草。
- en: 'If you open up Unity, you can go into the **Hierarchy** panel and click on
    **+** | **3D Object**, and you''ll see all the available options, but only about
    half of these are primitives or common shapes, indicated in the following screenshot
    by a red highlight:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开Unity，你可以进入**Hierarchy**面板，点击**+** | **3D Object**，你会看到所有可用的选项，但其中只有大约一半是primitives或常见形状，如下面的截图所示，用红色标出：
- en: '![](img/B17573_06_02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_02.png)'
- en: 'Figure 6.2: Unity Hierarchy window with the Create option selected'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：Unity Hierarchy窗口，选择Create选项
- en: Other 3D object options, such as **Terrain**, **Wind Zone**, and **Tree**, are
    a bit too advanced for what we need, but feel free to experiment with them if
    you're interested.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其他3D对象选项，如**Terrain**，**Wind Zone**和**Tree**，对我们的需求来说有点太高级了，但如果你感兴趣，可以随意尝试它们。
- en: You can find out more about building Unity environments at [https://docs.unity3d.com/Manual/CreatingEnvironments.html](https://docs.unity3d.com/Manual/CreatingEnvironments.html).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.unity3d.com/Manual/CreatingEnvironments.html](https://docs.unity3d.com/Manual/CreatingEnvironments.html)找到更多关于构建Unity环境的信息。
- en: 'Before we jump too far ahead, it''s usually easier to walk around when you''ve
    got a floor underneath you, so let''s start by creating a ground plane for our
    arena using the following steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们跳得太远之前，当你脚下有地板时，四处走动通常更容易，所以让我们从以下步骤开始为我们的竞技场创建一个地面平面：
- en: In the **Hierarchy** panel, click on **+** | **3D Object** | **Plane**
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**面板中，点击**+** | **3D Object** | **Plane**
- en: Ensuring the new object is selected in the **Hierarchy** tab, rename the GameObject
    to `Ground` in the **Inspector** tab
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**Hierarchy**选项卡中选择了新对象，在**Inspector**选项卡中将GameObject重命名为`Ground`
- en: In the **Transform** dropdown, change **Scale** to `3` in the **X**, **Y**,
    and **Z** axes:![](img/B17573_06_03.png)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Transform**下拉菜单中，将**Scale**更改为`3`，在**X**，**Y**和**Z**轴上：![](img/B17573_06_03.png)
- en: 'Figure 6.3: Unity Editor with a ground plane'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：Unity编辑器中的地面平面
- en: If the lighting in your scene looks dimmer or different from the preceding screenshot,
    select **Directional Light** in the **Hierarchy** panel, and set the **Intensity**
    value of the **Directional Light** component to 1:![](img/B17573_06_04.png)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的场景中的光线看起来比之前的截图暗或不同，选择**层次**面板中的**定向光**，并将**定向光**组件的**强度**值设置为1：![](img/B17573_06_04.png)
- en: 'Figure 6.4: Directional Light object selected in the Inspector pane'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：在检视器窗格中选择定向光对象
- en: We created a plane GameObject and increased its size to make more room for our
    future character to walk around. This plane will act like a 3D object bound by
    real-life physics, meaning other objects can't just fall through. We'll talk more
    about the Unity physics system and how it works in *Chapter 7*, *Movement, Camera
    Controls, and Collisions*. Right now, we need to start thinking in 3D.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个平面GameObject，并增加了它的大小，以便为我们未来的角色提供更多活动空间。这个平面将像一个受现实物理约束的3D对象一样，意味着其他物体不能穿过它。我们将在*第7章*“移动、摄像机控制和碰撞”中更多地讨论Unity物理系统及其工作原理。现在，我们需要开始以3D思维。
- en: Thinking in 3D
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以3D思考
- en: Now that we have our first object in the scene, we can talk about 3D space—specifically,
    how an object's position, rotation, and scale behave in three dimensions. If you
    think back to high school geometry, a graph with an *x* and *y* coordinate system
    should be familiar. To put a point on the graph, you had to have an *x* value
    and a *y* value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在场景中有了第一个对象，我们可以谈论3D空间——具体来说，一个对象的位置、旋转和比例在三维空间中的行为。如果你回想一下高中几何学，应该对具有*x*和*y*坐标系的图表很熟悉。要在图表上标出一个点，你必须有一个*x*值和一个*y*值。
- en: Unity supports both 2D and 3D game development, and if we were making a 2D game,
    we could leave our explanation there. However, when dealing with 3D space in the
    Unity Editor, we have an extra axis, called the *z* axis. The *z* axis maps depth,
    or perspective, giving our space and the objects in it their 3D quality.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Unity支持2D和3D游戏开发，如果我们制作2D游戏，我们可以在这里结束解释。然而，在Unity编辑器中处理3D空间时，我们有一个额外的轴，称为*z*轴。*z*轴映射深度或透视，赋予了我们的空间和其中的物体3D的特性。
- en: 'This might be confusing at first, but Unity has some nice visual aids to help
    you get your head on straight. In the top right of the **Scene** panel, you''ll
    see a geometric-looking icon with the *x*, *y*, and *z* axes marked in red, green,
    and blue, respectively. All GameObjects in the scene will show their axis arrows
    when they''re selected in the **Hierarchy** window:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能一开始会让人困惑，但Unity有一些很好的视觉辅助工具，可以帮助你理清思路。在**场景**面板的右上方，你会看到一个几何图标，上面标有红色、绿色和蓝色的*x*、*y*和*z*轴。当在**层次**窗口中选择GameObject时，场景中的所有GameObject都会显示它们的轴箭头：
- en: '![](img/B17573_06_05.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_05.png)'
- en: 'Figure 6.5: Scene view with the orientation gizmo highlighted'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：带有定向图标的场景视图
- en: This will always show the current orientation of the scene and the objects placed
    inside it. Clicking on any of these colored axes will switch the scene orientation
    to the selected axis. Give this a go by yourself to get comfortable with switching
    perspectives.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将始终显示场景的当前方向和放置在其中的对象的方向。单击任何这些彩色轴将切换场景方向到所选轴。自己尝试一下，以便熟悉切换视角。
- en: If you take a look at the **Ground** object's **Transform** component in the
    **Inspector** pane, you'll see that the position, rotation, and scale are all
    determined by these three axes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在**检视器**窗格中查看**Ground**对象的**Transform**组件，你会看到位置、旋转和比例都由这三个轴决定。
- en: 'The position determines where the object is placed in the scene, its rotation
    governs how it''s angled, and its scale takes care of its size. These values can
    be changed at any time in the **Inspector** pane or in a C# script:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 位置决定了物体在场景中的放置位置，旋转决定了它的角度，而比例则决定了它的大小。这些值可以随时在**检视器**窗格或C#脚本中进行更改：
- en: '![](img/B17573_06_06.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_06.png)'
- en: 'Figure 6.6: Ground object selected in Hierarchy'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：在层次中选择的地面对象
- en: Right now, the ground is looking a little boring. Let's change that with a material.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，地面看起来有点无聊。让我们用材质来改变它。
- en: Materials
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 材质
- en: Our ground plane isn't very interesting right now, but we can use **materials**
    to breathe a little life into the level. Materials control how GameObjects are
    rendered in the scene, which is determined by the material's Shader. Think of
    **Shaders** as being responsible for combining lighting and texture data into
    a representation of how the material looks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的地面平面现在并不是很有趣，但我们可以使用**材质**为关卡注入一些生气。材质控制着GameObject在场景中的渲染方式，这由材质的着色器决定。将**着色器**视为负责将光照和纹理数据组合成材质外观的部分。
- en: 'Each GameObject starts with a default **Material** and **Shader** (pictured
    here from the **Inspector** pane), setting its color to a standard white:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GameObject都以默认的**材质**和**着色器**开始（在此处从**检视器**窗格中显示），将其颜色设置为标准白色：
- en: '![](img/B17573_06_07.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_07.png)'
- en: 'Figure 6.7: Default material on an object'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：对象上的默认材质
- en: To change an object's color, we need to create a material and drag it to the
    object that we want to modify. Remember, everything is an object in Unity—materials
    are no different. Materials can be reused on as many GameObjects as needed, but
    any change to a material will also carry through to any objects the material is
    attached to. If we had several enemy objects in the scene with a material that
    set them all to red, and we changed that base material color to blue, all our
    enemies would then be blue.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变对象的颜色，我们需要创建一个材质并将其拖到我们想要修改的对象上。记住，在Unity中一切都是对象——材质也不例外。材质可以在需要时重复使用在许多GameObject上，但对材质的任何更改也会传递到附加了该材质的任何对象上。如果我们在场景中有几个敌人对象，它们都使用一个将它们都设置为红色的材质，然后我们将基础材质颜色更改为蓝色，那么所有的敌人都会变成蓝色。
- en: 'Blue is eye-catching; let''s change the color of the ground plane to match,
    and create a new material to turn the ground plane from a dull white to a dark
    and vibrant blue:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色很吸引人；让我们将地面平面的颜色改成蓝色，并创建一个新的材质，将地面平面从沉闷的白色变成深沉而充满活力的蓝色：
- en: Create a new folder in the **Project** panel and name it `Materials`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板中创建一个新文件夹，并将其命名为`Materials`。
- en: Inside the **Materials** folder, right-click **+** | **Material**, and name
    it `Ground_Mat`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**材质**文件夹中，右键单击**+** | **材质**，并将其命名为`Ground_Mat`。
- en: Click on the color box next to the **Albedo** property, select your color from
    the color picker window that pops up, and then close it.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**反照率**属性旁边的颜色框，从弹出的颜色选择窗口中选择您的颜色，然后关闭它。
- en: Drag the `Ground_Mat` object from the **Project** pane, and drop it onto the
    `Ground` GameObject in the **Hierarchy** panel:![](img/B17573_06_08.png)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**面板中拖动`Ground_Mat`对象，并将其放到**层次结构**面板中的`Ground`游戏对象上：![](img/B17573_06_08.png)
- en: 'Figure 6.8: Material color picker'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：材质颜色选择器
- en: 'The new material you created is now a project asset. Dragging and dropping
    `Ground_Mat` into the `Ground` GameObject changed the color of the plane, which
    means any changes to `Ground_Mat` will be reflected in the `Ground`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建的新材质现在是一个项目资产。将`Ground_Mat`拖放到`Ground`游戏对象中改变了平面的颜色，这意味着对`Ground_Mat`的任何更改都将反映在`Ground`中。
- en: '![](img/B17573_06_09.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_09.png)'
- en: 'Figure 6.9: Ground plane with the updated color material'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：更新颜色材质的地面平面
- en: The ground is our canvas; however, in 3D space, it can support other 3D objects
    on its surface. It'll be up to you to populate it with fun and interesting obstacles
    for your future players.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 地面是我们的画布；然而，在3D空间中，它可以支持其表面上的其他3D对象。将由您来用有趣的障碍物来填充它，以供未来的玩家使用。
- en: White-boxing
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 白盒设计
- en: White-boxing is a design term for laying out ideas using placeholders, usually
    with the intent of replacing them with finished assets at a later date. In level
    design, the practice of white-boxing is to block out an environment with primitive
    GameObjects to get a sense of how you want it to look. This is a great way to
    start things off, especially during the prototyping stages of your game.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒设计是一个设计术语，用于使用占位符布置想法，通常是为了在以后用成品替换它们。在关卡设计中，白盒设计的做法是用原始游戏对象来阻挡环境，以便了解你想要它看起来的感觉。这是一个很好的开始方式，特别是在游戏原型阶段。
- en: Before diving into Unity, I'd like to start with a simple sketch of the basic
    layout and position of my level. This gives us a bit of direction and will help
    to get our environment laid out quicker.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究Unity之前，我想先用简单的草图来描述我的关卡的基本布局和位置。这给了我们一点方向，并将有助于更快地布置我们的环境。
- en: 'In the following drawing, you''ll be able to see the arena I have in mind,
    with a raised platform in the middle that is accessible by ramps, complete with
    small turrets in each corner:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，您将能够看到我心目中的竞技场，中间有一个可以通过坡道进入的高台，每个角落都有小炮塔：
- en: '![](img/B17573_06_10.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_10.png)'
- en: 'Figure 6.10: Sketch of the Hero Born level arena'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10：《英雄诞生》关卡竞技场的草图
- en: Don't worry if you're not an artist—neither am I. The important thing is to
    get your ideas down on paper to solidify them in your mind and work out any kinks
    before getting busy in Unity.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心如果你不是一个艺术家——我也不是。重要的是把你的想法写下来，巩固在你的脑海中，并在忙于在Unity中工作之前解决任何问题。
- en: Before you go ahead full steam and put this sketch into production, you'll need
    to familiarize yourself with a few Unity Editor shortcuts to make white-boxing
    easier.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在全力以赴之前，您需要熟悉一些Unity编辑器的快捷方式，以使白盒设计更容易。
- en: Editor tools
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑器工具
- en: 'When we discussed the Unity interface in *Chapter 1*, *Getting to Know Your
    Environment*, we skimmed over some of the Toolbar functionality, which we need
    to revisit so that we know how to efficiently manipulate GameObjects. You can
    find these in the upper-left corner of the Unity Editor:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*第1章*中讨论Unity界面时，我们略过了一些工具栏功能，现在我们需要重新讨论一下，以便知道如何有效地操作游戏对象。你可以在Unity编辑器的左上角找到它们：
- en: '![](img/B17573_06_11.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_11.png)'
- en: 'Figure 6.11: Unity Editor toolbar'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：Unity编辑器工具栏
- en: 'Let''s break down the different tools that are available to us from the toolbar
    in the preceding screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下在前面截图中从工具栏中可以使用的不同工具：
- en: '**Hand**: This allows you to pan and change your position in the scene by clicking
    and dragging your mouse.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**手**: 这允许您通过单击和拖动鼠标来平移和改变场景中的位置。'
- en: '**Move**: This lets you move objects along the *x*, *y*, and *z* axes by dragging
    their respective arrows.'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**移动**：这让你通过拖动它们的相应箭头来沿着*x*、*y*和*z*轴移动物体。'
- en: '**Rotate**: This lets you adjust an object''s rotation by turning or dragging
    its respective markers.'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**旋转**：这让你通过转动或拖动其相应的标记来调整物体的旋转。'
- en: '**Scale**: This lets you modify an object''s scale by dragging it to specific
    axes.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**缩放**：这让你通过将其拖动到特定轴来修改物体的比例。'
- en: '**Rect Transform**: This combines the move, rotate, and scale tool functionality
    into one package.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**矩形变换**：这将移动、旋转和缩放工具功能合并为一个包。'
- en: '**Transform**: This gives you access to the position, rotation, and scale of
    an object all at once.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**变换**：这让你一次性访问物体的位置、旋转和缩放。'
- en: '**Custom Editor Tools**: This allows you to access any custom tools you''ve
    built for the editor. Don''t worry about this one, as it''s way beyond our scope.
    If you want to know more, please refer to the documentation at [https://docs.unity3d.com/2020.1/Documentation/ScriptReference/EditorTools.EditorTool.html](https://docs.unity3d.com/2020.1/Documentation/ScriptReference/EditorTools.EditorTool.html).'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**自定义编辑器工具**：这允许您访问您为编辑器构建的任何自定义工具。不用担心这个，因为它远远超出了我们的范围。如果您想了解更多，请参阅[https://docs.unity3d.com/2020.1/Documentation/ScriptReference/EditorTools.EditorTool.html](https://docs.unity3d.com/2020.1/Documentation/ScriptReference/EditorTools.EditorTool.html)中的文档。'
- en: You can find more information about navigating and positioning GameObjects in
    the **Scene** panel at [https://docs.unity3d.com/Manual/PositioningGameObjects.html](https://docs.unity3d.com/Manual/PositioningGameObjects.html).
    It's also worth noting that you can move, position, and scale objects using the
    **Transform** component, as we discussed earlier in the chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**场景**面板中找到有关导航和定位游戏对象的更多信息，网址是[https://docs.unity3d.com/Manual/PositioningGameObjects.html](https://docs.unity3d.com/Manual/PositioningGameObjects.html)。值得注意的是，你可以使用**Transform**组件来移动、定位和缩放对象，就像我们在本章前面讨论的那样。
- en: 'Panning and navigating the Scene can be done with similar tools, although not
    from the Unity Editor itself:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中进行平移和导航可以使用类似的工具，尽管不是来自Unity编辑器本身：
- en: To look around, hold down the right mouse button and drag it to pan the camera
    around.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要四处看，按住鼠标右键并拖动以使相机移动。
- en: To move around while using the camera, continue to hold the right mouse button
    and use the *W*, *A*, *S*, and *D* keys to move forward, back, left, and right,
    respectively.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用相机时移动，继续按住鼠标右键，使用*W*、*A*、*S*和*D*键分别向前、向后、向左和向右移动。
- en: Hit the *F* key to zoom in and focus on a GameObject that has been selected
    in the **Hierarchy** panel.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下*F*键，可以放大并聚焦在**层次**面板中已选择的游戏对象上。
- en: This kind of scene navigation is more commonly known as fly-through mode, so
    when I ask you to focus on or navigate to a particular object or viewpoint, use
    a combination of these features.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景导航更常被称为飞行模式，所以当我要求你专注于或导航到特定对象或视点时，请使用这些功能的组合。
- en: Getting around the Scene view can be a task in itself sometimes, but it all
    comes down to repeated practice. For a more detailed list of scene navigation
    features, visit [https://docs.unity3d.com/Manual/SceneViewNavigation.html](https://docs.unity3d.com/Manual/SceneViewNavigation.html).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景视图中移动有时可能是一项任务，但这一切都归结于反复练习。有关场景导航功能的更详细列表，请访问[https://docs.unity3d.com/Manual/SceneViewNavigation.html](https://docs.unity3d.com/Manual/SceneViewNavigation.html)。
- en: Even though the ground plane won't allow our character to fall through it, we
    could still walk off the edge at this point. Your job is to wall in the arena
    so that the player has a confined locomotion area.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管地面平面不会让我们的角色穿过它，但在这一点上我们仍然可以走到边缘。你的任务是将竞技场围起来，这样玩家就有了一个有限的移动区域。
- en: Hero's trial – putting up drywall
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 英雄的试炼——安装石膏板
- en: 'Using primitive cubes and the toolbar, position four walls around the level
    using the **Move**, **Rotate**, and **Scale** tools to section off the main arena:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基本立方体和工具栏，使用**移动**、**旋转**和**缩放**工具将四面墙围绕主竞技场分隔开：
- en: In the **Hierarchy** panel, select **+** | **3D Object** | **Cube** to create
    the first wall and name it `Wall_01`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中，选择**+** | **3D对象** | **立方体**来创建第一面墙，并将其命名为`Wall_01`。
- en: Set its scale value to 30 for the *x* axis, 1.5 for the *y* axis, and 0.2 for
    the *z* axis.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其比例值设置为*x*轴30，*y*轴1.5，*z*轴0.2。
- en: Note that planes operate on a scale 10 times larger than objects—so our plane
    with a length of 3 is the same length as an object of length 30.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，平面的操作比对象大10倍——所以我们的长度为3的平面与长度为30的对象长度相同。
- en: With the `Wall_01` object selected in the **Hierarchy** panel, switch to the
    position tool in the upper-left corner and use the red, green, and blue arrows
    to position the wall at the edge of the ground plane.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**面板中选择`Wall_01`对象，切换到左上角的位置工具，并使用红色、绿色和蓝色箭头将墙定位在地面平面的边缘。
- en: Repeat *steps 1-3* until you have four walls surrounding your area:![](img/B17573_06_12.png)
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤1-3*，直到你的区域周围有四面墙为止：![](img/B17573_06_12.png)
- en: 'Figure 6.12: Level arena with four walls and a ground plane'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：四面墙和地面平面的竞技场
- en: From this chapter onward, I'll be giving some basic values for wall position,
    rotation, and scale, but feel free to be adventurous and use your own creativity.
    I want you to experiment with the Unity Editor tools so you get comfortable faster.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从本章开始，我将给出一些墙的位置、旋转和缩放的基本值，但请随意尝试并发挥你的创造力。我希望你能尝试使用Unity编辑器工具，这样你就能更快地熟悉它们。
- en: That was a bit of construction, but the arena is starting to take shape! Before
    we move on to adding in obstacles and platforms, you'll want to get into the habit
    of cleaning up your object hierarchy. We'll talk about how that works in the following
    section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点施工，但竞技场开始成形了！在继续添加障碍和平台之前，你需要养成整理对象层次结构的习惯。我们将在下一节讨论这是如何工作的。
- en: Keeping the hierarchy clean
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持层次结构清晰
- en: Normally, I would put this sort of advice in a blurb at the end of a section,
    but making sure your project hierarchy is as organized as possible is so important
    that it needs its own subsection. Ideally, you'll want all related GameObjects
    to be under a single **parent object**. Right now, it's not a risk because we
    only have a few objects in the scene; however, when that gets into the hundreds
    on a big project, you'll be struggling.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我会把这种建议放在部分的结尾，但确保你的项目层次结构尽可能有条理是非常重要的，所以它需要有自己的小节。理想情况下，你会希望所有相关的游戏对象都在一个**父对象**下面。现在，这并不是一个风险，因为我们场景中只有几个对象；然而，在一个大型项目中，当数量增加到几百个时，你会很吃力。
- en: The easiest way to keep your hierarchy clean is to store related objects in
    a parent object, just as you would with files inside a folder on your desktop.
    Our level has a few objects that could use some organization, and Unity makes
    this easy by letting us create empty GameObjects. An empty object is a perfect
    container (or folder) for holding related groups of objects because it doesn't
    come with any components attached—it's a shell.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 保持层次结构清晰的最简单方法是将相关对象存储在一个父对象中，就像你在桌面上的文件夹中一样。我们的场景有一些需要组织的对象，Unity通过让我们创建空的游戏对象来使这变得容易。空对象是一个完美的容器（或文件夹），用于保存相关的对象组，因为它不附带任何组件——它只是一个外壳。
- en: 'Let''s take our ground plane and four walls and group them all under a common
    empty GameObject:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把我们的地面平面和四面墙都放在一个共同的空游戏对象下：
- en: Select **+** | **Create Empty** in the **Hierarchy** panel and name the new
    object `Environment`
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中选择**+** | **创建空对象**，并将新对象命名为`环境`
- en: Drag and drop the ground plane and the four walls into **Environment**, making
    them child objects
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将地面和四面墙拖放到**环境**中，使它们成为子对象
- en: Select the **Environment** empty object and check that its **X**, **Y**, and
    **Z** positions are all set to 0:![](img/B17573_06_13.png)
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**环境**空对象，并检查其**X**、**Y**和**Z**位置是否都设置为 0：![](img/B17573_06_13.png)
- en: 'Figure 6.13: Hierarchy panel showing the empty GameObject parent'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13：显示空 GameObject 父对象的层次结构面板
- en: The environment exists in the **Hierarchy** tab as a parent object, with the
    arena objects as its children. Now we're able to expand or close the **Environment**
    object drop-down list with the arrow icon, making the **Hierarchy** panel less
    cluttered.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 环境在**层次结构**选项卡中作为父对象存在，其子对象是竞技场对象。现在我们可以通过箭头图标展开或关闭**环境**对象的下拉列表，使**层次结构**面板变得不那么凌乱。
- en: 'It''s important to set the **Environment** object''s **X**, **Y**, and **Z**
    positions to 0 because the child object positions are now relative to the parent
    position. This leads to an interesting question: what are the origin points of
    these positions, rotations, and scales that we''re setting? The answer is that
    they depend on what relative space we''re using, which, in Unity, is either **World**
    or **Local**:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将**环境**对象的**X**、**Y**和**Z**位置设置为 0 是很重要的，因为子对象的位置现在是相对于父对象位置的。这带来了一个有趣的问题：我们设置的这些位置、旋转和缩放的原点是什么？答案是它们取决于我们使用的相对空间，而在
    Unity 中，这些空间要么是**世界**空间，要么是**本地**空间：
- en: '**World space** uses a set origin point in the scene as a constant reference
    for all GameObjects. In Unity, this origin point is (0, 0, 0), or 0 on the *x*,
    *y*, and *z* axes.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**世界空间**使用场景中的一个固定原点作为所有 GameObject 的恒定参考。在 Unity 中，这个原点是 (0, 0, 0)，或者 *x*、*y*
    和 *z* 轴上的 0。'
- en: '**Local space** uses the object''s parent `Transform` component as its origin,
    essentially changing the perspective of the scene. Unity also sets this local
    origin to (0, 0, 0). Think of this as the parent transform being the center of
    the universe, with everything else orbiting in relation to it.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地空间**使用对象的父级`Transform`组件作为其原点，从本质上改变了场景的透视。Unity 还将本地原点设置为 (0, 0, 0)。可以将其视为父级变换是宇宙的中心，其他所有东西都围绕它而轨道运行。'
- en: Both of these orientations are useful in different situations, but right now,
    resetting it at this point starts everyone on an even playing field.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方向在不同情况下都很有用，但是现在，在这一点上重置它会让每个人都从同一起跑线开始。
- en: Working with Prefabs
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Prefabs
- en: Prefabs are one of the most powerful components you'll come across in Unity.
    They come in handy not only in level building but in scripting as well. Think
    of Prefabs as GameObjects that can be saved and reused with every child object,
    component, C# script, and property setting intact. Once created, a Prefab is like
    a class blueprint; each copy used in a scene is a separate instance of that Prefab.
    Consequently, any change to the base Prefab will also change all of the active
    instances in the scene.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Prefabs 是 Unity 中最强大的组件之一。它们不仅在关卡构建中很有用，而且在脚本编写中也很有用。将 Prefabs 视为 GameObject，可以保存并重复使用每个子对象、组件、C#脚本和属性设置。创建后，Prefab
    就像一个类蓝图；在场景中使用的每个副本都是该 Prefab 的单独实例。因此，对基本 Prefab 的任何更改也会更改场景中所有活动实例。
- en: 'The arena looks a little too simple and completely wide open, making it a perfect
    place to test out creating and editing Prefabs. Since we want four identical turrets
    in each corner of the arena, they''re a perfect case for a Prefab, which we can
    create with the following steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 竞技场看起来有点太简单，完全是敞开的，这使得它成为测试创建和编辑 Prefabs 的完美场所。由于我们希望在竞技场的每个角落都有四个相同的炮塔，它们是
    Prefab 的完美案例，我们可以通过以下步骤创建：
- en: Again, I haven't included any precise barrier position, rotation, or scale values
    because I want you to get up close and personal with the Unity Editor tools.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有包含任何精确的屏障位置、旋转或缩放值，因为我希望你能亲自接触 Unity 编辑器工具。
- en: Going forward, when you see a task ahead of you that doesn't include specific
    position, rotation, or scale values, I'm expecting you to learn by doing.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，当你看到一个任务在你面前时，不包括特定的位置、旋转或缩放值，我希望你能通过实践学习。
- en: Create an empty parent object inside the **Environment** parent object by selecting
    **+** | **Create Empty** and naming it `Barrier_01`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**+** | **创建空对象**在**环境**父对象内创建一个空的父对象，并将其命名为`屏障_01`。
- en: Create two cubes by selecting **+** | **3D Object** | **Cube** and position
    and scale them as a v-shaped base.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**+** | **3D对象** | **立方体**选择创建两个立方体，并将它们定位和缩放成V形的底座。
- en: Create two more cube primitives and place them on the ends of the turret base:![](img/B17573_06_14.png)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个更多的立方体原语，并将它们放在炮塔底座的两端：![](img/B17573_06_14.png)
- en: 'Figure 6.14: Screenshot of the turret composed of cubes'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14：由立方体组成的炮塔的屏幕截图
- en: Create a new folder in the **Project** panel under **Assets** and name it `Prefabs`.
    Then, drag the **Barrier_01** GameObject from the **Hierarchy** panel to the **Prefabs**
    folder in the project view:![](img/B17573_06_15.png)
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**面板下的**资产**下创建一个名为`Prefabs`的新文件夹。然后，将**层次结构**面板中的**屏障_01** GameObject
    拖到项目视图中的**Prefabs**文件夹中：![](img/B17573_06_15.png)
- en: 'Figure 6.15: Barrier Prefab in the Prefabs folder'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15：Prefabs 文件夹中的屏障 Prefab
- en: '**Barrier_01**, and all its child objects, are now Prefabs, meaning that we
    can reuse it by dragging copies from the `Prefabs` folder or duplicating the one
    in the scene. **Barrier_01** turned blue in the **Hierarchy** tab to signify its
    status change, and also added a row of Prefab function buttons in the **Inspector**
    tab underneath its name:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**屏障_01** 及其所有子对象现在都是 Prefabs，这意味着我们可以通过从`Prefabs`文件夹中拖动副本或复制场景中的副本来重复使用它。**屏障_01**
    在**层次结构**选项卡中变成蓝色，表示其状态发生了变化，并在**检查器**选项卡中其名称下方添加了一排 Prefab 功能按钮：'
- en: '![](img/B17573_06_16.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_16.png)'
- en: 'Figure 6.16: Barrier_01 Prefab highlighted in the Inspector pane'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16：在检查器窗格中突出显示的屏障_01 Prefab
- en: Any edits to the original Prefab object, **Barrier_01**, will now affect any
    copies in the Scene. Since we need a fifth cube to complete the barrier, let's
    update and save the Prefab to see this in action.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对原始预制件对象**Barrier_01**的任何编辑现在都会影响场景中的任何副本。由于我们需要第五个立方体来完成屏障，让我们更新并保存预制件，看看它的效果。
- en: 'Now our turret has a huge gap in the middle, which isn''t ideal for covering
    our character, so let''s update the **Barrier_01** Prefab by adding another cube
    and applying the change:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的炮塔中间有一个巨大的缺口，这对于保护我们的角色来说并不理想，所以让我们通过添加另一个立方体并应用更改来更新**Barrier_01**预制件：
- en: Create a **Cube** primitive and place it at the intersection of the turret base.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**立方体**原始对象，并将其放置在炮塔底座的交叉点处。
- en: The new **Cube** primitive will be marked as gray with a little **+** icon next
    to its name in the **Hierarchy** tab. This means it's not officially part of the
    Prefab yet:![](img/B17573_06_17.png)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的**立方体**原始对象将在**层次结构**选项卡中以灰色标记，并在其名称旁边有一个小**+**图标。这意味着它还没有正式成为预制件的一部分！[](img/B17573_06_17.png)
- en: 'Figure 6.17: New Prefab update marked in the Hierarchy window'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17：层次结构窗口中标记的新预制件更新
- en: Right-click on the new Cube primitive in the **Hierarchy** panel and select
    **Added** **GameObject** | **Apply to Prefab 'Barrier_01'**:![](img/B17573_06_18.png)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**面板中右键单击新的立方体原始对象，然后选择**添加** **游戏对象** | **应用于预制件'Barrier_01'**：![](img/B17573_06_18.png)
- en: 'Figure 6.18: Option to apply Prefab changes to the base Prefab'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18：将预制件更改应用到基本预制件的选项
- en: The **Barrier_01** Prefab is now updated to include the new cube, and the entire
    Prefab hierarchy should be blue again. You now have a turret Prefab that looks
    like the preceding screenshot or, if you're feeling adventurous, something more
    creative. However, we want these to be in every corner of the arena. It's going
    to be your job to add them!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**Barrier_01**预制件现在已更新，包括新的立方体，并且整个预制件层次结构应该再次变为蓝色。现在你有一个看起来像前面截图的炮塔预制件，或者如果你感到有冒险精神，也可以是更有创意的东西。然而，我们希望这些在竞技场的每个角落都有。你的任务是添加它们！'
- en: 'Now that we''ve got a reusable barrier Prefab, let''s build out the rest of
    the level to match the rough sketch that we had at the beginning of the section:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可重复使用的屏障预制件，让我们构建出与本节开头的草图相匹配的关卡的其余部分：
- en: Duplicate the **Barrier_01** Prefab three times and place each one in a different
    corner of the arena. You can do this by dragging multiple **Barrier_01** objects
    from the **Prefabs** folder into the scene, or right-clicking on **Barrier_01**
    in the **Hierarchy** and selecting duplicate.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制**Barrier_01**预制件三次，并将每个预制件放置在竞技场的不同角落。你可以通过将多个**Barrier_01**对象从**预制件**文件夹拖放到场景中，或者在**层次结构**中右键单击**Barrier_01**并选择复制来完成这个操作。
- en: Create a new empty GameObject inside the **Environment** parent object and name
    it `Raised_Platform`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**环境**父对象内创建一个新的空游戏对象，并将其命名为`Raised_Platform`。
- en: Create a **Cube** and scale it to form a platform as shown in *Figure 6.19*
    below.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**立方体**，并按下面的*图6.19*所示进行缩放，形成一个平台。
- en: 'Create a **Plane** and scale it into a ramp:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**平面**，并将其缩放成一个斜坡：
- en: 'Hint: Rotate the plane around the *x* or *y* axis to create an angled plane'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示：围绕*x*或*y*轴旋转平面，可以创建一个倾斜的平面
- en: Then, position it so that it connects the platform to the ground
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，将其位置调整，使其连接平台和地面。
- en: Duplicate the ramp object by using `Cmd` + `D` on a Mac, or `Ctrl` + `D` on
    Windows. Then, repeat the rotation and positioning steps.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Mac上使用`Cmd` + `D`，或在Windows上使用`Ctrl` + `D`，复制斜坡对象。然后，重复旋转和定位步骤。
- en: Repeat the previous step twice more, until you have four ramps in total leading
    to the platform:![](img/B17573_06_19.png)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复上一步骤两次，直到总共有四个斜坡通向平台！[](img/B17573_06_19.png)
- en: 'Figure 6.19: Raised platform parent GameObject'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19：提升平台父游戏对象
- en: You've now successfully white-boxed your first game level! Don't get too caught
    up in it yet, though—we're just getting started. All good games have items that
    players can pick up or interact with. In the following challenge, it's your job
    to create a health item and make it a Prefab.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经成功地创建了你的第一个游戏关卡的白盒模型！不过，不要太沉迷其中——我们只是刚刚开始。所有好的游戏都有玩家可以拾取或与之交互的物品。在接下来的挑战中，你的任务是创建一个生命值道具并将其制作成预制件。
- en: Hero's trial – creating a health pickup
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 英雄的试炼-创建一个生命值道具
- en: 'Putting together everything we''ve learned so far in this chapter might take
    you a few minutes, but it''s well worth the time. Create the pickup item as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们在本章中学到的一切放在一起可能需要你花费几分钟的时间，但这是非常值得的。按照以下步骤创建拾取物品：
- en: Create a **Capsule** GameObject by selecting **+** | **3D Object** | **Capsule**
    and name it `Health_Pickup`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**+** | **3D对象** | **胶囊体**，创建一个名为`Health_Pickup`的**胶囊体**游戏对象。
- en: Set the scale to 0.3 for the *x*, *y*, and *z* axes, and then switch to the
    **Move** tool and position it near one of your barriers.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*x*、*y*和*z*轴的比例设置为0.3，然后切换到**移动**工具，并将其位置放置在你的屏障之一附近。
- en: Create and attach a new yellow-colored **Material** to the **Health_Pickup**
    object.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为**Health_Pickup**对象创建并附加一个新的黄色**材质**。
- en: Drag the **Health_Pickup** object from the **Hierarchy** pane into the **Prefab**
    folder.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Health_Pickup**对象从**层次结构**面板拖动到**预制件**文件夹中。
- en: 'Refer to the following screenshot for an example of what the finished product
    should look like:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下截图，了解最终产品的样子：
- en: '![](img/B17573_06_20.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_20.png)'
- en: 'Figure 6.20: Pickup item and barrier Prefab in Scene'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20：场景中的拾取物品和屏障预制件
- en: That wraps up our work with level design and layout for now. Next up, you're
    going to get a crash course in lighting with Unity, and we'll learn about animating
    our item later on in the chapter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这就暂时结束了我们对关卡设计和布局的工作。接下来，你将在Unity中快速学习灯光，并且我们将在本章后面学习如何为我们的物品添加动画。
- en: Lighting basics
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灯光基础知识
- en: 'Lighting in Unity is a broad topic, but it can be boiled down into two categories:
    real-time and precomputed. Both types of lights take into account properties such
    as the color and intensity of the light, as well as the direction it is facing
    in the scene, which can all be configured in the **Inspector** pane. The difference
    is how the Unity engine computes how the lights act.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的照明是一个广泛的主题，但可以归结为两类：实时和预计算。这两种类型的光都考虑了光的颜色和强度等属性，以及它在场景中的方向，这些都可以在**检视器**窗格中配置。区别在于Unity引擎计算光的方式。
- en: '*Real-time lighting* is computed every frame, meaning that any object that
    passes in its path will cast realistic shadows and generally behave like a real-world
    light source. However, this can significantly slow down your game and cost an
    exponential amount of computing power, depending on the number of lights in your
    Scene. *Precomputed lighting*, on the other hand, stores the Scene''s lighting
    in a texture called a **lightmap**, which is then applied, or baked, into the
    scene. While this saves computing power, baked lighting is static. This means
    that it doesn''t react realistically or change when objects move in the scene.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*实时照明*是每帧计算的，这意味着任何通过其路径的物体都会投射出逼真的阴影，并且通常会像真实世界的光源一样行为。然而，这可能会显著减慢游戏速度，并且根据场景中的光源数量，会消耗大量的计算资源。另一方面，*预计算照明*将场景的照明存储在称为**光照贴图**的纹理中，然后将其应用或烘烤到场景中。虽然这节省了计算资源，但烘烤的照明是静态的。这意味着当物体在场景中移动时，它不会实时反应或改变。'
- en: There is also a mixed type of lighting called Precomputed Realtime Global Illumination,
    which bridges the gap between real-time and precomputed processes. This is an
    advanced Unity-specific topic, so we won't cover it in this book, but feel free
    to view the documentation at [https://docs.unity3d.com/Manual/GIIntro.html](https://docs.unity3d.com/Manual/GIIntro.html).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种混合类型的照明称为预计算实时全局照明，它弥合了实时和预计算过程之间的差距。这是一个高级的Unity特定主题，所以我们不会在本书中涵盖它，但可以随时查看[https://docs.unity3d.com/Manual/GIIntro.html](https://docs.unity3d.com/Manual/GIIntro.html)上的文档。
- en: Let's now take a look at how to create light objects in the Unity Scene itself.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何在Unity场景中创建光对象。
- en: Creating lights
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建光
- en: 'By default, every Scene comes with a directional light component to act as
    a main source of illumination, but lights can be created in the hierarchy like
    any other GameObject. Even though the idea of controlling light sources might
    be new to you, they are objects in Unity, which means they can be positioned,
    scaled, and rotated to fit your needs:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个场景都带有一个定向光组件，用作主要的照明源，但光可以像其他游戏对象一样在层次结构中创建。尽管控制光源的概念可能对您来说是新的，但它们是Unity中的对象，这意味着它们可以被定位，缩放和旋转以适应您的需求。
- en: '![](img/B17573_06_21.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_21.png)'
- en: 'Figure 6.21: Lighting creation menu option'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21：光照创建菜单选项
- en: 'Let''s take a look at some examples of real-time light objects and their performance:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些实时光对象及其性能的例子：
- en: '**Directional** **lights** are great for simulating natural light, such as
    sunshine. They don''t have an actual position in the scene, but their light hits
    everything as if it''s always pointed in the same direction.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定向光**非常适合模拟自然光，比如阳光。它们在场景中没有实际位置，但它们的光会像永远指向同一个方向一样照射到所有物体上。'
- en: '**Point** **lights** are essentially floating globes, sending light rays out
    from a central point in all directions. These have defined positions and intensities
    in the scene.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点光源**本质上是浮动的球体，从球体的中心点向所有方向发出光线。它们在场景中有定义的位置和强度。'
- en: '**Spotlights** send light out in a given direction, but they are locked in
    by their angle and focused on a specific area of the scene. Think of these as
    spotlights or floodlights in the real world.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚光灯**向特定方向发出光线，但它们受其角度的限制，并专注于场景的特定区域。可以将其视为现实世界中的聚光灯或泛光灯。'
- en: '**Area lights** are shaped like rectangles, sending out light from their surface
    from a single side of the rectangle.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域光**的形状类似矩形，从矩形的一侧表面发出光线。'
- en: '**Reflection Probes** and **Light Probe Groups** are beyond what we need for
    *Hero Born*;however, if you''re interested, you can find out more at [https://docs.unity3d.com/Manual/ReflectionProbes.html](https://docs.unity3d.com/Manual/ReflectionProbes.html)
    and [https://docs.unity3d.com/Manual/LightProbes.html](https://docs.unity3d.com/Manual/LightProbes.html).'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**反射探针**和**光探针组**超出了我们在*英雄诞生*中所需的范围；但是，如果您感兴趣，可以在[https://docs.unity3d.com/Manual/ReflectionProbes.html](https://docs.unity3d.com/Manual/ReflectionProbes.html)和[https://docs.unity3d.com/Manual/LightProbes.html](https://docs.unity3d.com/Manual/LightProbes.html)上了解更多。'
- en: Like all GameObjects in Unity, lights have properties that can be adjusted to
    give a Scene a specific ambiance or theme.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 像Unity中的所有游戏对象一样，光具有可以调整的属性，以赋予场景特定的氛围或主题。
- en: Light component properties
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光组件属性
- en: 'The following screenshot shows the **Light** component on the directional light
    in our Scene. All of these properties can be configured to create immersive environments,
    but the basic ones we need to be aware of are **Color**, **Mode**, and **Intensity**.
    These properties govern the light''s tint, real-time or computed effects, and
    general strength:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们场景中定向光的**光**组件。所有这些属性都可以配置，以创建沉浸式环境，但我们需要注意的基本属性是**颜色**，**模式**和**强度**。这些属性控制光的色调，实时或计算效果以及一般强度：
- en: '![](img/B17573_06_22.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_22.png)'
- en: 'Figure 6.22: Light component in the Inspector window'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22：检视器窗口中的光组件
- en: Like other Unity components, these properties can be accessed through scripts
    and the `Light` class, which can be found at [https://docs.unity3d.com/ScriptReference/Light.html](https://docs.unity3d.com/ScriptReference/Light.html).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他Unity组件一样，这些属性可以通过脚本和`Light`类访问，该类可以在[https://docs.unity3d.com/ScriptReference/Light.html](https://docs.unity3d.com/ScriptReference/Light.html)找到。
- en: Try this out for yourself by selecting **+** | **Light** | **Point Light** and
    seeing how it affects the area lighting. After you've played around with the settings,
    delete the point light by right-clicking on it in the **Hierarchy** panel and
    choosing **Delete**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择**+** | **Light** | **Point Light**来尝试一下，看看它对区域照明有什么影响。在调整了设置之后，通过在**Hierarchy**面板中右键单击它并选择**Delete**来删除点光源。
- en: Now that we know a little more about what goes into lighting up a game scene,
    let's turn our attention to adding some animations!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对如何点亮游戏场景有了更多了解，让我们把注意力转向添加一些动画！
- en: Animating in Unity
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中制作动画
- en: 'Animating objects in Unity can range from a simple rotation effect to complex
    character movements and actions. You can create animations in code or with the
    Animation and Animator windows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中对对象进行动画处理可以从简单的旋转效果到复杂的角色移动和动作。你可以在代码中创建动画，也可以使用Animation和Animator窗口：
- en: The **Animation** window is where animation segments, called clips, are created
    and managed using a timeline. Object properties are recorded along this timeline
    and are then played back to create an animated effect.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画**窗口是动画片段（称为片段）使用时间轴创建和管理的地方。对象属性沿着这个时间轴记录，然后播放回来创建动画效果。'
- en: The **Animator** window manages these clips and their transitions using objects
    called animation controllers.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Animator**窗口使用叫做动画控制器的对象来管理这些片段及其转换。'
- en: You can find more information about the Animator window and its controllers
    at [https://docs.unity3d.com/Manual/AnimatorControllers.html](https://docs.unity3d.com/Manual/AnimatorControllers.html).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.unity3d.com/Manual/AnimatorControllers.html](https://docs.unity3d.com/Manual/AnimatorControllers.html)找到有关Animator窗口及其控制器的更多信息。
- en: Creating and manipulating your target objects in clips will have your game moving
    in no time. For our short trip into Unity animations, we'll create the same rotation
    effect in code and using the Animator.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段中创建和操作目标对象将使你的游戏很快就动起来。对于我们在Unity动画中的短暂旅程，我们将在代码中和使用Animator创建相同的旋转效果。
- en: Creating animations in code
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在代码中创建动画
- en: To start, we're going to create an animation in code to rotate our health item
    pickup. Since all GameObjects have a `Transform` component, we can grab our item's
    `Transform` component and rotate it indefinitely.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在代码中创建一个动画来旋转我们的生命物品拾取。由于所有的GameObject都有一个`Transform`组件，我们可以获取我们物品的`Transform`组件并无限旋转它。
- en: 'To create an animation in code, you need to perform the following steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中创建动画，需要执行以下步骤：
- en: Create a new script inside the `Scripts` folder, name it `ItemRotation`, and
    open it in Visual Studio Code.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的脚本，命名为`ItemRotation`，并在Visual Studio Code中打开它。
- en: At the top of the new script and inside the class, add in an `int` variable
    containing the value `100` called `RotationSpeed`, and a `Transform` variable
    called `ItemTransform:`
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新脚本的顶部和类内部，添加一个包含值`100`的`int`变量，名为`RotationSpeed`，和一个名为`ItemTransform`的`Transform`变量：
- en: '[PRE0]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Inside the `Start()` method body, grab the GameObject's `Transform` component
    and assign it to `ItemTransform:`
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start()`方法体内，获取GameObject的`Transform`组件并将其分配给`ItemTransform`：
- en: '[PRE1]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the `Update()` method body, call `ItemTransform.Rotate`. This `Transform`
    class method takes in three axes, one for the *X*, *Y*, and *Z* rotations you
    want to execute. Since we want the item to rotate end over end, we''ll use the
    *x* axis and leave the others set to `0`:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update()`方法体内，调用`ItemTransform.Rotate`。这个`Transform`类方法接受三个轴，分别是*X*、*Y*和*Z*旋转，你想要执行。由于我们希望物品绕着末端旋转，我们将使用*x*轴，其他轴设置为`0`：
- en: '[PRE2]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You'll notice that we're multiplying our `RotationSpeed` by something called
    `Time.deltaTime`. This is the standard way of normalizing movement effects in
    Unity so that they look smooth no matter how fast or slow the player's computer
    is running. In general, you should always multiply your movement or rotation speeds
    by `Time.deltaTime`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们将`RotationSpeed`乘以一个叫做`Time.deltaTime`的东西。这是在Unity中标准化移动效果的方法，这样无论玩家的电脑运行速度快慢，效果都会看起来很平滑。一般来说，你应该总是将你的移动或旋转速度乘以`Time.deltaTime`。
- en: Back in Unity, select the `Health_Pickup` object in the `Prefabs` folder in
    the **Projects** pane and scroll down to the bottom of the **Inspector** window.
    Click **Add Component**, search for the `ItemRotation` script, and then press
    `Enter`:![](img/B17573_06_23.png)
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Unity，在**项目**面板的`Prefabs`文件夹中选择`Health_Pickup`对象，滚动到**检视**窗口的底部。点击**添加组件**，搜索`ItemRotation`脚本，然后按`Enter`：![](img/B17573_06_23.png)
- en: 'Figure 6.23: Add Component button in the Inspector panel'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23：检视面板中的添加组件按钮
- en: Now that our Prefab is updated, move the **Main Camera** so that you can see
    the `Health_Pickup` object and click on play!![](img/B17573_06_24.png)
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的预制已经更新，移动**Main Camera**，这样你就可以看到`Health_Pickup`对象并点击播放！[](img/B17573_06_24.png)
- en: 'Figure 6.24: Screenshot of the camera focused on the health item'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24：焦点在生命物品上的相机截图
- en: As you can see, the health pickup now spins around its *x* axis in a continuous
    and smooth animation! Now that you've animated the item in code, we'll duplicate
    our animation using Unity's built-in animation system.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，生命物品现在围绕其*x*轴连续而平滑地旋转！现在你已经在代码中为物品添加了动画，我们将使用Unity内置的动画系统来复制我们的动画。
- en: Creating animations in the Unity Animation window
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Unity动画窗口中创建动画
- en: Any GameObject that you want to apply an animation clip to needs to be attached
    to an Animator component with an **Animation Controller** set. If there is no
    controller in the project when a new clip is created, Unity will create one and
    save it in the project panel, which you can then use to manage your clips. Your
    next challenge is to create a new animation clip for the pickup item.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 任何你想要应用动画片段的GameObject都需要附加到一个设置了**动画控制器**的Animator组件上。如果在创建新片段时项目中没有控制器，Unity将创建一个并保存在项目面板中，然后你可以用它来管理你的片段。你的下一个挑战是为拾取物品创建一个新的动画片段。
- en: 'We''re going to start animating the `Health_Pickup` Prefab by creating a new
    animation clip, which will spin the object around in an infinite loop. To create
    a new animation clip, we need to perform the following steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始通过创建一个新的动画片段来为`Health_Pickup`Prefab添加动画，该动画将使对象无限循环旋转。要创建一个新的动画片段，我们需要执行以下步骤：
- en: Navigate to **Window** | **Animation** | **Animation** to open up the **Animation**
    panel and drag and drop the **Animation** tab next to the **Console**.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**窗口** | **动画** | **动画**，打开**动画**面板，并将**动画**选项卡拖放到**控制台**旁边。
- en: Make sure the `Health_Pickup` item is selected in **Hierarchy** and then click
    on **Create** in the **Animation** panel:![](img/B17573_06_25.png)
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**Hierarchy**中选择了`Health_Pickup`项目，然后在**Animation**面板中单击**Create**：![](img/B17573_06_25.png)
- en: 'Figure 6.25: Screenshot of the Unity Animation window'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25：Unity动画窗口的屏幕截图
- en: Create a new folder from the following drop-down list, name it `Animations`,
    and then name the new clip `Pickup_Spin`:![](img/B17573_06_26.png)
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉列表中创建一个名为`Animations`的新文件夹，然后将新片段命名为`Pickup_Spin`：![](img/B17573_06_26.png)
- en: 'Figure 6.26: Screenshot of the Create New Animation window'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.26：创建新动画窗口的屏幕截图
- en: Make sure the new clip shows up in the **Animation** panel:![](img/B17573_06_27.png)
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保新片段出现在**Animation**面板中：![](img/B17573_06_27.png)
- en: 'Figure 6.27: Screenshot of the Animation window with a clip selected'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.27：动画窗口的屏幕截图，选择了一个片段
- en: Since we didn't have any **Animator** controllers, Unity created one for us
    in the `Animation` folder called **Health_Pickup**. With **Health_Pickup** selected,
    note in the **Inspector** pane that when we created the clip, an **Animator**
    component was also added to the Prefab for us but hasn't been officially saved
    to the Prefab yet with the **Health_Pickup** controller set.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们没有任何**Animator**控制器，Unity为我们在`Animation`文件夹中创建了一个名为**Health_Pickup**的控制器。选择**Health_Pickup**后，在**检查器**窗格中注意到，当我们创建了片段时，**Animator**组件也被添加到了Prefab中，但尚未使用**Health_Pickup**控制器正式保存到Prefab中。
- en: Notice that the **+** icon is showing in the top left of the **Animator** component,
    meaning it's not yet part of the **Health_Pickup** Prefab:![](img/B17573_06_28.png)
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，**+**图标显示在**Animator**组件的左上角，这意味着它还没有成为**Health_Pickup**Prefab的一部分：![](img/B17573_06_28.png)
- en: 'Figure 6.28: Animator component in the Inspector panel'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.28：检查器面板中的Animator组件
- en: Select the three-vertical-dots icon at the top right and choose **Added Component**
    | **Apply to Prefab 'Health_Pickup'**:![](img/B17573_06_29.png)
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择右上角的三个垂直点图标，选择**添加组件** | **应用于Prefab 'Health_Pickup'**：![](img/B17573_06_29.png)
- en: 'Figure 6.29: Screenshot of a new component being applied to the Prefab'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.29：应用于Prefab的新组件的屏幕截图
- en: Now that you've created and added an Animator component to the **Health_Pickup**Prefab,
    it's time to start recording some animation frames. When you think of motion clips,
    as in movies, you may think of frames. As the clip moves through its frames, the
    animation advances, giving the effect of movement. It's no different in Unity;
    we need to record our target object in different positions throughout different
    frames so that Unity can play the clip.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经创建并添加了一个Animator组件到**Health_Pickup**Prefab，是时候开始记录一些动画帧了。当您想到动作片段时，就像电影一样，您可能会想到帧。当片段通过其帧移动时，动画会前进，产生移动的效果。在Unity中也是一样的；我们需要在不同的帧中记录我们的目标对象在不同的位置，这样Unity才能播放片段。
- en: Recording keyframes
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录关键帧
- en: Now that we have a clip to work with, you'll see a blank timeline in the **Animation**
    window. Essentially, when we modify our **Health_Pickup** Prefab's *z* rotation,
    or any other property that can be animated, the timeline will record those changes
    as keyframes. Unity then assembles those keyframes into your complete animation,
    similar to how individual frames on analog film play together into a moving picture.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可以使用的片段，您将在**Animation**窗口中看到一个空白的时间轴。基本上，当我们修改**Health_Pickup**Prefab的*z*旋转，或者任何其他可以被动画化的属性时，时间轴将记录这些更改作为关键帧。然后Unity将这些关键帧组合成完整的动画，类似于模拟电影中的单个帧一起播放成为移动图片。
- en: 'Take a look at the following screenshot and remember the locations of the record
    button and the timeline:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下的屏幕截图，并记住记录按钮和时间轴的位置：
- en: '![](img/B17573_06_30.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_30.png)'
- en: 'Figure 6.30: Screenshot of the Animation window and keyframe timeline'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.30：动画窗口和关键帧时间轴的屏幕截图
- en: 'Now, let''s get our item spinning. For the spinning animation, we want the
    **Health_Pickup** Prefab to make a complete 360-degree rotation on its *z* axis
    every second, which can be done by setting three keyframes and letting Unity take
    care of the rest:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们让我们的物品旋转起来。对于旋转动画，我们希望**Health_Pickup**Prefab在其*z*轴上每秒完成360度的旋转，这可以通过设置三个关键帧并让Unity处理其余部分来完成：
- en: Select the **Health_Pickup** object in the **Hierarchy** window, choose **Add
    Property** | **Transform**, and then click on the **+** sign next to **Rotation**:![](img/B17573_06_31.png)
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗口中选择**Health_Pickup**对象，选择**添加属性** | **变换**，然后单击**旋转**旁边的**+**号：![](img/B17573_06_31.png)
- en: 'Figure 6.31: Screenshot of adding a Transform property for animation'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.31：添加用于动画的变换属性的屏幕截图
- en: 'Click on the record button to start the animation:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击记录按钮开始动画：
- en: Place your cursor at **0:00** on the timeline but leave the **Health_Pickup**
    Prefab's *z* rotation at 0
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将光标放在时间轴上的**0:00**处，但将**Health_Pickup**Prefab的*z*旋转保持在0
- en: Place your cursor at **0:30** on the timeline and set the *z* rotation to **180**
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将光标放在时间轴上的**0:30**处，并将*z*旋转设置为**180**
- en: Place your cursor at **1:00** on the timeline and set the *z* rotation to **360**![](img/B17573_06_32.png)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将光标放在时间轴上的**1:00**处，并将*z*旋转设置为**360**![](img/B17573_06_32.png)
- en: 'Figure 6.32: Screenshot of Animation keyframes being recorded'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.32：记录动画关键帧的屏幕截图
- en: Click on the record button to finish the animation
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击记录按钮完成动画
- en: Click on the play button to the right of the record button to see the animation
    loop
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击记录按钮右侧的播放按钮，查看动画循环
- en: You'll notice that our **Animator** animation overrides the one we wrote in
    code earlier. Don't worry; this is expected behavior. You can click the small
    checkbox to the right of any component in the **Inspector** panel to activate
    or deactivate it. If you deactivate the **Animator** component, **Health_Pickup**
    will rotate around the *x* axis again using our code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们的**Animator**动画覆盖了我们之前在代码中编写的动画。不用担心，这是预期的行为。您可以单击**Inspector**面板中任何组件右侧的小复选框来激活或停用它。如果停用**Animator**组件，**Health_Pickup**将再次使用我们的代码围绕*x*轴旋转。
- en: 'The **Health_Pickup** object now rotates on the *z* axis between 0, 180, and
    360 degrees every second, creating the looping spin animation. If you play the
    game now, the animation will run indefinitely until the game is stopped:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**Health_Pickup**对象现在在*z*轴上每秒在0、180和360度之间旋转，创建循环旋转动画。如果您现在播放游戏，动画将无限期地运行，直到游戏停止：'
- en: '![](img/B17573_06_33.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_33.png)'
- en: 'Figure 6.33: Screenshot of an animation playing in the Animation window'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.33：在动画窗口中播放动画的屏幕截图
- en: All animations have curves, which determine specific properties of how an animation
    executes. We won't be doing too much with these, but it's important to understand
    the basics. We'll get into them in the following section.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所有动画都有曲线，这些曲线决定了动画执行的特定属性。我们不会对这些做太多处理，但了解基础知识很重要。我们将在下一节中深入了解它们。
- en: Curves and tangents
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 曲线和切线
- en: In addition to animating an object property, Unity lets us manage how the animation
    plays out over time with animation curves. So far, we've been in **Dopesheet**
    mode, which you can change at the bottom of the Animation window. If you click
    on the **Curves** view (pictured in the following screenshot), you'll see a different
    graph with accent points in place of our recorded keyframes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对对象属性进行动画处理外，Unity还允许我们使用动画曲线管理动画随时间的播放方式。到目前为止，我们一直处于**Dopesheet**模式，您可以在动画窗口底部进行更改。如果您点击**Curves**视图（如下屏幕截图所示），您将看到一个不同的图形，其中有重点放置在我们记录的关键帧的位置。
- en: 'We want the spinning animation to be smooth—what we call linear—so we''ll leave
    everything as is. However, speeding up, slowing down, or altering the animation
    at any point in its run can be done by dragging or adjusting the points on the
    curve graph in any direction:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望旋转动画是平滑的，也就是我们所说的线性，所以我们会保持一切不变。然而，可以通过拖动或调整曲线图上的点来加快、减慢或改变动画的运行过程中的任何时点的动画：
- en: '![](img/B17573_06_34.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_34.png)'
- en: 'Figure 6.34: Screenshot of the Curves timeline in the Animation window'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.34：动画窗口中曲线时间轴的屏幕截图
- en: With animation curves handling how properties act over time, we still need a
    way to fix the stutter that occurs every time the **Health_Pickup** animation
    repeats. For that, we need to change the animation's tangent, which manages how
    keyframes blend from one into another.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然动画曲线处理了属性随时间的变化，但我们仍然需要一种方法来解决每次**Health_Pickup**动画重复时出现的停滞。为此，我们需要更改动画的切线，这会管理关键帧之间的平滑过渡。
- en: 'These options can be accessed by right-clicking on any keyframe on the timeline
    in **Dopesheet** mode, which you can see here:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项可以通过在**Dopesheet**模式下右键单击时间轴上的任何关键帧来访问，您可以在这里看到：
- en: '![](img/B17573_06_35.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_06_35.png)'
- en: 'Figure 6.35: Screenshot of keyframe smoothing options'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.35：关键帧平滑选项的屏幕截图
- en: Both curves and tangents are intermediate/advanced, so we won't be delving too
    deeply into them. If you're interested, you can take a look at the documentation
    on animation curves and tangent options at [https://docs.unity3d.com/Manual/animeditor-AnimationCurves.html](https://docs.unity3d.com/Manual/animeditor-AnimationCurves.html).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线和切线都是中级/高级内容，所以我们不会深入研究它们。如果您感兴趣，可以查看有关动画曲线和切线选项的文档：[https://docs.unity3d.com/Manual/animeditor-AnimationCurves.html](https://docs.unity3d.com/Manual/animeditor-AnimationCurves.html)。
- en: If you play the spinning animation as it is now, there's a slight pause between
    when the item completes its full rotation and starts a new one. Your job is to
    smooth that out, which is the subject of the next challenge.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照现在的旋转动画播放，物品完成完整旋转并开始新旋转之间会有轻微的暂停。您的任务是使其平滑，这是下一个挑战的主题。
- en: 'Let''s adjust the tangents on the first and last frames of the animation so
    that the spinning animation blends seamlessly together when it repeats:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整动画的第一帧和最后一帧的切线，使得旋转动画在重复时能无缝衔接：
- en: Right-click on the first and last keyframes' diamond icons on the animation
    timeline and select **Auto**:![](img/B17573_06_36.png)
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击动画时间轴上第一个和最后一个关键帧的菱形图标，然后选择**Auto**：![](img/B17573_06_36.png)
- en: 'Figure 6.36: Changing keyframe smoothing options'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.36：更改关键帧平滑选项的屏幕截图
- en: If you haven't already done so, move the **Main Camera** so that you can see
    the `Health_Pickup` object and click on play:![](img/B17573_06_37.png)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请移动**Main Camera**，以便您可以看到`Health_Pickup`对象并点击播放：![](img/B17573_06_37.png)
- en: 'Figure 6.37: Screenshot of the final smoothed animation playing'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.37：最终平滑动画播放的屏幕截图
- en: Changing the first and last keyframe tangents to **Auto** tells Unity to make
    their transitions smooth, which eliminates the jerky stop/start motion when the
    animation loops.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 将第一个和最后一个关键帧的切线更改为**Auto**告诉Unity使它们的过渡平滑，从而消除动画循环时的突然停止/开始运动。
- en: That's all the animation you'll need for this book, but I'd encourage you to
    check out the full toolbox that Unity offers in this area. Your games will be
    more engaging and your players will thank you!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本书中您需要的所有动画，但我鼓励您查看Unity在这个领域提供的全部工具。您的游戏将更具吸引力，您的玩家会感谢您！
- en: Summary
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We made it to the end of another chapter that had a lot of moving parts, which
    might especially be a lot for those of you who are new to Unity.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了另一个章节，其中有很多组成部分，对于那些对Unity还不太熟悉的人来说可能会有很多内容。
- en: Even though this book is focused on the C# language and its implementation in
    Unity, we still need to take time to get an overview of game development, documentation,
    and the non-scripting features of the engine. While we didn't have time for in-depth
    coverage of the lighting and animation, it's worth getting to know them if you're
    thinking about continuing to create Unity projects.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这本书侧重于C#语言及其在Unity中的实现，我们仍然需要花时间来了解游戏开发、文档和引擎的非脚本功能。虽然我们没有时间深入涉及照明和动画，但如果您打算继续创建Unity项目，了解它们是值得的。
- en: In the next chapter, we'll be switching our focus back to programming *Hero
    Born*'s core mechanics, starting with setting up a moveable player object, controlling
    the camera, and understanding how Unity's physics system governs the game world.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把重点转回到编程《英雄诞生》的核心机制，从设置可移动的玩家对象、控制摄像机，以及理解Unity的物理系统如何管理游戏世界开始。
- en: Pop quiz – basic Unity features
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹出测验-基本Unity功能
- en: Cubes, capsules, and spheres are examples of what kind of GameObject?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 立方体、胶囊体和球体是什么类型的GameObject的例子？
- en: What axis does Unity use to represent depth, which gives scenes their 3D appearance?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity使用哪个轴来表示深度，从而赋予场景其3D外观？
- en: How do you turn a GameObject into a reusable Prefab?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将GameObject转换为可重用的Prefab？
- en: What unit of measurement does the Unity animation system use to record object
    animations?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Unity动画系统使用什么单位来记录对象动画？
- en: JOIN us on Discord!
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C#专家和Harrison Ferrone一起阅读本书。通过*问我任何事*会话与作者交流，提出问题，为其他读者提供解决方案，等等。
- en: Join Now!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
