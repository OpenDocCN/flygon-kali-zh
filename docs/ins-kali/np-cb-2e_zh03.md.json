["```py\nimport numpy as np\n\n#Each new term in the Fibonacci sequence is generated by adding the previous two terms.\n#By starting with 1 and 2, the first 10 terms will be:\n\n#1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\n\n#By considering the terms in the Fibonacci sequence whose values do not exceed four million,\n#find the sum of the even-valued terms.\n\n#1\\. Calculate phi\nphi = (1 + np.sqrt(5))/2\nprint(\"Phi\", phi)\n\n#2\\. Find the index below 4 million\nn = np.log(4 * 10 ** 6 * np.sqrt(5) + 0.5)/np.log(phi)\nprint(n)\n\n#3\\. Create an array of 1-n\nn = np.arange(1, n)\nprint(n)\n\n#4\\. Compute Fibonacci numbers\nfib = (phi**n - (-1/phi)**n)/np.sqrt(5)\nprint(\"First 9 Fibonacci Numbers\", fib[:9])\n\n#5\\. Convert to integers\n# optional\nfib = fib.astype(int)\nprint(\"Integers\", fib)\n\n#6\\. Select even-valued terms\neventerms = fib[fib % 2 == 0]\nprint(eventerms)\n\n#7\\. Sum the selected terms\nprint(eventerms.sum())\n```", "```py\n    phi = (1 + np.sqrt(5))/2\n    print(\"Phi\", phi)\n\n    ```", "```py\n    Phi 1.61803398875\n\n    ```", "```py\n    n = np.log(4 * 10 ** 6 * np.sqrt(5) + 0.5)/np.log(phi)\n    print(n)\n\n    ```", "```py\n    33.2629480359\n\n    ```", "```py\n    n = np.arange(1, n)\n\n    ```", "```py\n    fib = (phi**n - (-1/phi)**n)/np.sqrt(5)\n    print(\"First 9 Fibonacci Numbers\", fib[:9])\n\n    ```", "```py\n    First 9 Fibonacci Numbers [  1\\.   1\\.   2\\.   3\\.   5\\.   8\\.  13\\.  21\\.  34.]\n\n    ```", "```py\n    fib = fib.astype(int)\n    print(\"Integers\", fib)\n\n    ```", "```py\n    Integers [      1       1       2       3       5       8      13      21      34\n     ... snip ... snip ...\n     317811  514229  832040 1346269 2178309 3524578]\n\n    ```", "```py\n    eventerms = fib[fib % 2 == 0]\n    print(eventerms)\n\n    ```", "```py\n    [      2       8      34     144     610    2584   10946   46368  196418  832040 3524578]\n\n    ```", "```py\nfrom __future__ import print_function\nimport numpy as np\n\n#The prime factors of 13195 are 5, 7, 13 and 29.\n\n#What is the largest prime factor of the number 600851475143 ?\n\nN = 600851475143\nLIM = 10 ** 6\n\ndef factor(n):\n   #1\\. Create array of trial values\n   a = np.ceil(np.sqrt(n))\n   lim = min(n, LIM)\n   a = np.arange(a, a + lim)\n   b2 = a ** 2 - n\n\n   #2\\. Check whether b is a square\n   fractions = np.modf(np.sqrt(b2))[0]\n\n   #3\\. Find 0 fractions\n   indices = np.where(fractions == 0)\n\n   #4\\. Find the first occurrence of a 0 fraction\n   a = np.ravel(np.take(a, indices))[0]\n              # Or a = a[indices][0]\n\n   a = int(a)\n   b = np.sqrt(a ** 2 - n) \n   b = int(b)\n   c = a + b\n   d = a - b\n\n   if c == 1 or d == 1:\n      return\n\n   print(c, d)\n   factor(c)\n   factor(d)\n\nfactor(N)\n```", "```py\n    a = np.ceil(np.sqrt(n))\n    lim = min(n, LIM)\n    a = np.arange(a, a + lim)\n    b2 = a ** 2 - n\n    ```", "```py\n    fractions = np.modf(np.sqrt(b2))[0]\n    ```", "```py\n    indices = np.where(fractions == 0)\n    ```", "```py\n    a = np.ravel(np.take(a, indices))[0]\n    ```", "```py\n    1234169 486847\n    1471 839\n    6857 71\n\n    ```", "```py\nimport numpy as np\n\n#A palindromic number reads the same both ways. \n#The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 x 99.\n\n#Find the largest palindrome made from the product of two 3-digit numbers.\n\n#1\\. Create  3-digits numbers array\na = np.arange(100, 1000)\nnp.testing.assert_equal(100, a[0])\nnp.testing.assert_equal(999, a[-1])\n\n#2\\. Create products array\nnumbers = np.outer(a, a)\nnumbers = np.ravel(numbers)\nnumbers.sort()\nnp.testing.assert_equal(810000, len(numbers))\nnp.testing.assert_equal(10000, numbers[0])\nnp.testing.assert_equal(998001, numbers[-1])\n\n#3\\. Find largest palindromic number\nfor number in numbers[::-1]:\n   s = str(numbers[i])\n\n   if s == s[::-1]:\n      print(s)\n      break\n```", "```py\n    a = np.arange(100, 1000)\n    np.testing.assert_equal(100, a[0])\n    np.testing.assert_equal(999, a[-1])\n    ```", "```py\n    numbers = np.outer(a, a)\n    numbers = np.ravel(numbers)\n    numbers.sort()\n    np.testing.assert_equal(810000, len(numbers))\n    np.testing.assert_equal(10000, numbers[0])\n    np.testing.assert_equal(998001, numbers[-1])\n    ```", "```py\nfrom __future__ import print_function\nfrom matplotlib.finance import quotes_historical_yahoo\nfrom datetime import date\nimport numpy as np\n\ntoday = date.today()\nstart = (today.year - 1, today.month, today.day)\n\nquotes = quotes_historical_yahoo('AAPL', start, today)\nclose =  [q[4] for q in quotes]\n\nstates = np.sign(np.diff(close))\n\nNDIM = 3\nSM = np.zeros((NDIM, NDIM))\n\nsigns = [-1, 0, 1]\nk = 1\n\nfor i, signi in enumerate(signs):\n   #we start the transition from the state with the specified sign\n   start_indices = np.where(states[:-1] == signi)[0]\n\n   N = len(start_indices) + k * NDIM\n\n   # skip since there are no transitions possible\n   if N == 0:\n      continue\n\n   #find the values of states at the end positions\n   end_values = states[start_indices + 1]\n\n   for j, signj in enumerate(signs):\n      # number of occurrences of this transition \n      occurrences = len(end_values[end_values == signj])\n      SM[i][j] = (occurrences + k)/float(N)\n\nprint(SM)\neig_out = np.linalg.eig(SM)\nprint(eig_out)\n\nidx_vec = np.where(np.abs(eig_out[0] - 1) < 0.1)\nprint(\"Index eigenvalue 1\", idx_vec)\n\nx = eig_out[1][:,idx_vec].flatten()\nprint(\"Steady state vector\", x)\nprint(\"Check\", np.dot(SM, x))\n```", "```py\n    today = date.today()\n    start = (today.year - 1, today.month, today.day)\n    quotes = quotes_historical_yahoo('AAPL', start, today)\n    ```", "```py\n    close =  [q[4] for q in quotes]\n    ```", "```py\n    states = np.sign(np.diff(close))\n    ```", "```py\n    NDIM = 3\n    SM = np.zeros((NDIM, NDIM))\n    ```", "```py\n    signs = [-1, 0, 1]\n    k = 1\n\n    for i, signi in enumerate(signs):\n       #we start the transition from the state with the specified sign\n        start_indices = np.where(states[:-1] == signi)[0]\n    ```", "```py\n    N = len(start_indices) + k * NDIM\n\n    # skip since there are no transitions possible\n    if N == 0:\n        continue\n\n    #find the values of states at the end positions\n    end_values = states[start_indices + 1]\n\n    for j, signj in enumerate(signs):\n        # number of occurrences of this transition \n        occurrences = len(end_values[end_values == signj])\n        SM[i][j] = (occurrences + k)/float(N)\n\n    print(SM)\n    ```", "```py\n    [[ 0.5047619   0.00952381  0.48571429]\n     [ 0.33333333  0.33333333  0.33333333]\n     [ 0.33774834  0.00662252  0.65562914]]\n\n    ```", "```py\n    eig_out = numpy.linalg.eig(SM)\n    print(eig_out)\n    ```", "```py\n    (array([ 1\\.        ,  0.16709381,  0.32663057]), array([[  5.77350269e-01,   7.31108409e-01,   7.90138877e-04],\n     [  5.77350269e-01,  -4.65117036e-01,  -9.99813147e-01],\n     [  5.77350269e-01,  -4.99145907e-01,   1.93144030e-02]]))\n\n    ```", "```py\n    idx_vec = np.where(np.abs(eig_out[0] - 1) < 0.1)\n    print(\"Index eigenvalue 1\", idx_vec)\n\n    x = eig_out[1][:,idx_vec].flatten()\n    ```", "```py\n    Index eigenvalue 1 (array([0]),)\n    Steady state vector [ 0.57735027  0.57735027  0.57735027]\n    Check [ 0.57735027  0.57735027  0.57735027]\n\n    ```", "```py\nfrom matplotlib.finance import quotes_historical_yahoo\nfrom datetime import date\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n#1\\. Get close prices.\ntoday = date.today()\nstart = (today.year - 1, today.month, today.day)\n\nquotes = quotes_historical_yahoo('IBM', start, today)\nclose =  np.array([q[4] for q in quotes])\n\n#2\\. Get positive log returns.\nlogreturns = np.diff(np.log(close))\npos = logreturns[logreturns > 0]\n\n#3\\. Get frequencies of returns.\ncounts, rets = np.histogram(pos)\n# 0 counts indices\nindices0 = np.where(counts != 0)\nrets = rets[:-1] + (rets[1] - rets[0])/2\n# Could generate divide by 0 warning\nfreqs = 1.0/counts\nfreqs = np.take(freqs, indices0)[0]\nrets = np.take(rets, indices0)[0]\nfreqs =  np.log(freqs)\n\n#4\\. Fit the frequencies and returns to a line.\np = np.polyfit(rets,freqs, 1)\n\n#5\\. Plot the results.\nplt.title('Power Law')\nplt.plot(rets, freqs, 'o', label='Data')\nplt.plot(rets, p[0] * rets + p[1], label='Fit')\nplt.xlabel('Log Returns')\nplt.ylabel('Log Frequencies')\nplt.legend()\nplt.grid()\nplt.show()\n```", "```py\n    logreturns = np.diff(np.log(close))\n    pos = logreturns[logreturns > 0]\n    ```", "```py\n    counts, rets = np.histogram(pos)\n    # 0 counts indices\n    indices0 = np.where(counts != 0)\n    rets = rets[:-1] + (rets[1] - rets[0])/2\n    # Could generate divide by 0 warning\n    freqs = 1.0/counts\n    freqs = np.take(freqs, indices0)[0]\n    rets = np.take(rets, indices0)[0]\n    freqs =  np.log(freqs)\n    ```", "```py\n    p = np.polyfit(rets,freqs, 1)\n    ```", "```py\n    plt.title('Power Law')\n    plt.plot(rets, freqs, 'o', label='Data')\n    plt.plot(rets, p[0] * rets + p[1], label='Fit')\n    plt.xlabel('Log Returns')\n    plt.ylabel('Log Frequencies')\n    plt.legend()\n    plt.grid()\n    plt.show()\n    ```", "```py\nfrom __future__ import print_function\nfrom matplotlib.finance import quotes_historical_yahoo\nfrom datetime import date\nimport numpy as np\nimport scipy.stats\nimport matplotlib.pyplot as plt\n\n#1\\. Get close prices.\ntoday = date.today()\nstart = (today.year - 1, today.month, today.day)\n\nquotes = quotes_historical_yahoo('AAPL', start, today)\nclose =  np.array([q[4] for q in quotes])\n\n#2\\. Get log returns.\nlogreturns = np.diff(np.log(close))\n\n#3\\. Calculate breakout and pullback\nfreq = 0.02\nbreakout = scipy.stats.scoreatpercentile(logreturns, 100 * (1 - freq) )\npullback = scipy.stats.scoreatpercentile(logreturns, 100 * freq)\n\n#4\\. Generate buys and sells\nbuys = np.compress(logreturns < pullback, close)\nsells = np.compress(logreturns > breakout, close)\nprint(buys)\nprint(sells)\nprint(len(buys), len(sells))\nprint(sells.sum() - buys.sum())\n\n#5\\. Plot a histogram of the log returns\nplt.title('Periodic Trading')\nplt.hist(logreturns)\nplt.grid()\nplt.xlabel('Log Returns')\nplt.ylabel('Counts')\nplt.show()\n```", "```py\n    freq = 0.02\n    breakout = scipy.stats.scoreatpercentile(logreturns, 100 * (1 - freq) )\n    pullback = scipy.stats.scoreatpercentile(logreturns, 100 * freq)\n    ```", "```py\n    buys = np.compress(logreturns < pullback, close)\n    sells = np.compress(logreturns > breakout, close)\n    print(buys)\n    print(sells)\n    print(len(buys), len(sells))\n    print(sells.sum() - buys.sum())\n    ```", "```py\n    [  77.76375466   76.69249773  102.72        101.2          98.57      ]\n    [ 74.95502967  76.55980292  74.13759123  80.93512599  98.22      ]\n    5 5\n    -52.1387025726\n\n    ```", "```py\n    plt.title('Periodic Trading')\n    plt.hist(logreturns)\n    plt.grid()\n    plt.xlabel('Log Returns')\n    plt.ylabel('Counts')\n    plt.show()\n    ```", "```py\nfrom __future__ import print_function\nfrom matplotlib.finance import quotes_historical_yahoo\nfrom datetime import date\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef get_indices(high, size):\n   #2\\. Generate random indices\n   return np.random.randint(0, high, size)\n\n#1\\. Get close prices.\ntoday = date.today()\nstart = (today.year - 1, today.month, today.day)\n\nquotes = quotes_historical_yahoo('AAPL', start, today)\nclose =  np.array([q[4] for q in quotes])\n\nnbuys = 5\nN = 2000\nprofits = np.zeros(N)\n\nfor i in xrange(N):\n   #3\\. Simulate trades\n   buys = np.take(close, get_indices(len(close), nbuys))\n   sells = np.take(close, get_indices(len(close), nbuys))\n   profits[i] = sells.sum() - buys.sum()\n\nprint(\"Mean\", profits.mean())\nprint(\"Std\", profits.std())\n\n#4\\. Plot a histogram of the profits\nplt.title('Simulation')\nplt.hist(profits)\nplt.xlabel('Profits')\nplt.ylabel('Counts')\nplt.grid()\nplt.show()\n```", "```py\n    return np.random.randint(0, high, size)\n    ```", "```py\n    buys = np.take(close, get_indices(len(close), nbuys))\n    sells = np.take(close, get_indices(len(close), nbuys))\n    profits[i] = sells.sum() - buys.sum()\n    ```", "```py\n    plt.title('Simulation')\n    plt.hist(profits)\n    plt.xlabel('Profits')\n    plt.ylabel('Counts')\n    plt.grid()\n    plt.show()\n    ```", "```py\n    a = np.arange(i, i + LIM, 2)\n    ```", "```py\n    a = a[a % p != 0]\n    ```", "```py\n    from __future__ import print_function\n    import numpy as np\n\n    LIM = 10 ** 6\n    N = 10 ** 9\n    P = 10001\n    primes = []\n    p = 2\n\n    #By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.\n\n    #What is the 10 001st prime number?\n\n    def sieve_primes(a, p):\n       #2\\. Sieve out multiples of p\n       a = a[a % p != 0]\n\n       return a\n\n    for i in xrange(3, N, LIM):\n       #1\\. Create a list of consecutive integers\n       a = np.arange(i, i + LIM, 2)\n\n       while len(primes) < P:\n          a = sieve_primes(a, p)\n          primes.append(p)\n\n          p = a[0]\n\n    print(len(primes), primes[P-1])\n    ```"]