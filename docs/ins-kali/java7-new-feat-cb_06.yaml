- en: Chapter 6. Stream IO in Java 7
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。Java 7中的流IO
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Managing simple files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理简单文件
- en: Using buffered IO for files
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓冲IO处理文件
- en: Random access IO using the `SeekableByteChannel`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SeekableByteChannel`进行随机访问IO
- en: Managing asynchronous communication using the `AsynchronousServerSocketChannel`
    class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AsynchronousServerSocketChannel`类管理异步通信
- en: Writing to a file using the `AsynchronousFileChannel` class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AsynchronousFileChannel`类写入文件
- en: Reading from a file using the `AsynchronousFileChannel` class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AsynchronousFileChannel`类从文件中读取
- en: Using the `SecureDirectoryStream` class
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SecureDirectoryStream`类
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In Java 7, we found that there are numerous improvements to its IO capabilities.
    Most of these are found in the `java.nio` package, which has been dubbed as **NIO2**.
    In this chapter, we will focus on the new support for streaming and channel-based
    IO. A **stream** is a contiguous sequence of data. **Stream IO** acts on a single
    character at a time, while **channel IO** works with a buffer for each operation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中，我们发现它的IO功能有许多改进。其中大部分都在`java.nio`包中，被称为**NIO2**。在本章中，我们将专注于对流和基于通道的IO的新支持。**流**是一系列连续的数据。**流IO**一次处理一个字符，而**通道IO**对每个操作使用一个缓冲区。
- en: We start with the new techniques used to work with simple files. These are supported
    by the `Files` class and are discussed in the *Managing simple files* recipe.
    **Buffered IO** is usually more efficient and is explained in the *Using buffered
    IO for files* recipe.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从用于处理简单文件的新技术开始。这些技术由`Files`类支持，并在*管理简单文件*配方中有讨论。**缓冲IO**通常更有效，并在*使用缓冲IO处理文件*配方中有解释。
- en: The `java.nio.channels` package's `ByteChannel` interface is a channel that
    can read and write bytes. The `SeekableByteChannel` interface extends the `ByteChannel`
    interface to maintain a position within the channel. The position can be changed
    using seek type random IO operations. This capability is discussed in the *Random
    access IO using the SeekableByteChannel* recipe.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.channels`包的`ByteChannel`接口是一个可以读写字节的通道。`SeekableByteChannel`接口扩展了`ByteChannel`接口以在通道内保持位置。位置可以使用寻找类型的随机IO操作进行更改。这个功能在*使用SeekableByteChannel进行随机访问IO*配方中有讨论。'
- en: 'Java 7 has added support for asynchronous channel functionality. The asynchronous
    nature of these operations is that they do not block. An asynchronous application
    can continue executing without the need to wait for an IO operation to complete.
    When the IO completes, a method of the application is called. There are four new
    `java.nio.channels` package asynchronous channel classes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7增加了对异步通道功能的支持。这些操作的异步性在于它们不会阻塞。异步应用可以继续执行而不需要等待IO操作完成。当IO完成时，应用的一个方法会被调用。有四个新的`java.nio.channels`包异步通道类：
- en: '`AsynchronousSocketChannel`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsynchronousSocketChannel`'
- en: '`AsynchronousServerSocketChannel`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsynchronousServerSocketChannel`'
- en: '`AsynchronousFileChannel`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsynchronousFileChannel`'
- en: '`AsynchronousChannelGroup`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsynchronousChannelGroup`'
- en: The first two are used together in a server/client environment and are detailed
    in the *Managing asynchronous communication using the AsynchronousServerSocketChannel
    class* recipe.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前两者在服务器/客户端环境中一起使用，并在*使用AsynchronousServerSocketChannel类管理异步通信*配方中有详细说明。
- en: The `AsynchronousFileChannel` class is used for file manipulation operations
    that need to be performed in an asynchronous manner. The methods supporting the
    write and read operations are illustrated in the *Writing to a file using the
    AsynchronousFileChannel class* and *Reading from a file using the AsynchronousFileChannel
    class* recipes, respectively.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsynchronousFileChannel`类用于需要以异步方式执行的文件操作。支持写和读操作的方法分别在*使用AsynchronousFileChannel类写入文件*和*使用AsynchronousFileChannel类从文件中读取*配方中有说明。'
- en: The `AsynchronousChannelGroup` class provides a means of grouping asynchronous
    channels together in order to share resources. The use of this class is shown
    in the *There's more* section of the *Reading from a file using the AsynchronousFileChannel
    class* recipe.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsynchronousChannelGroup`类提供了一种将异步通道组合在一起以共享资源的方法。这个类的使用在*更多内容*部分的*使用AsynchronousFileChannel类从文件中读取*配方中有展示。'
- en: The `java.nio.file` package's `SecureDirectoryStream` class provides support
    for more secure access to directories. The use of this class is explained in the
    *Using the SecureDirectoryStream* recipe. However, the underlying operating system
    must provide local support for this class.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.file`包的`SecureDirectoryStream`类提供了对目录的更安全访问的支持。这个类的使用在*使用SecureDirectoryStream*配方中有解释。然而，底层操作系统必须为这个类提供本地支持。'
- en: 'The `users.txt` file is used for several examples found in this chapter. The
    contents of the `users.txt` file are assumed to initially contain the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`users.txt`文件在本章中的几个示例中使用。假定`users.txt`文件的内容最初包含以下内容：'
- en: Bob
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bob
- en: Mary
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mary
- en: Sally
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sally
- en: Tom
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tom
- en: Ted
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ted
- en: Should your file's content differ, then the output of the examples will vary
    accordingly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的文件内容不同，那么示例的输出将相应地有所不同。
- en: 'Several of the recipes in this chapter open a file. Some of these open methods
    that will use an enumeration argument to specify how the file should be opened.
    The `java.nio.file` package''s `OpenOption` interface specifies how the file is
    opened and the `StandardOpenOption` enumeration implements this interface. The
    values of the enumeration are summarized in the following table:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些配方打开了一个文件。其中一些打开方法将使用一个枚举参数来指定文件应该如何打开。`java.nio.file`包的`OpenOption`接口指定了文件的打开方式，`StandardOpenOption`枚举实现了这个接口。枚举的值总结在下表中：
- en: '| Enumeration | Meaning |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 枚举 | 含义 |'
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `APPEND` | Bytes are written to the end of the file |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `APPEND` | 字节被写入文件的末尾 |'
- en: '| `CREATE` | Creates a new file if it does not exist |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `CREATE` | 如果文件不存在则创建一个新文件 |'
- en: '| `CREATE_NEW` | Creates a new file only if the file does not exist |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `CREATE_NEW` | 仅在文件不存在时创建新文件 |'
- en: '| `DELETE_ON_CLOSE` | Deletes the file when it is closed |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE_ON_CLOSE` | 关闭文件时删除文件 |'
- en: '| `DSYNC` | Every update to a file is written synchronously |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `DSYNC` | 对文件的每次更新都是同步写入的 |'
- en: '| `READ` | Open for read access |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `READ` | 以读取访问权限打开 |'
- en: '| `SPARSE` | Sparse file |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `SPARSE` | 稀疏文件 |'
- en: '| `SYNC` | Every update to the file or metadata is written synchronously |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `SYNC` | 对文件或元数据的每次更新都是同步写入的 |'
- en: '| `TRUNCATE_EXISTING` | Truncates the length of a file to 0 when opening a
    file |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `TRUNCATE_EXISTING` | 打开文件时将文件长度截断为0 |'
- en: '| `WRITE` | Opens the file for write access |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `WRITE` | 以写入访问权限打开文件 |'
- en: While not discussed here, the `java.nio.channels` package's `NetworkChannel`
    interface was introduced in Java 7\. This represents a channel to a network socket.
    Several classes including the `AsynchronousServerSocketChannel` and `AsynchronousSocketChannel`
    classes that are discussed in this chapter implement it. It has a `bind` method
    that binds a socket to a local address, allowing the retrieval and setting of
    various query socket options. It permits the use of operating system-specific
    options, which could be used for high performance servers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里没有讨论，但是`java.nio.channels`包的`NetworkChannel`接口是在Java 7中引入的。这代表了一个到网络套接字的通道。包括`AsynchronousServerSocketChannel`和`AsynchronousSocketChannel`在内的几个类在本章中实现了它。它有一个`bind`方法，用于将套接字绑定到本地地址，允许检索和设置各种查询套接字选项。它允许使用操作系统特定的选项，这可以用于高性能服务器。
- en: The `java.nio.channels` package's `MulticastChannel` is also new to Java 7\.
    It is used to support multicast operations for a group. It is implemented by the
    `DatagramChannel` class. Methods of this interface support the joining and leaving
    of members from a group.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.channels`包的`MulticastChannel`也是Java 7中的新功能。它用于支持组的多播操作。它由`DatagramChannel`类实现。该接口的方法支持从组中加入和离开成员。'
- en: The **Sockets Direct Protocol** (**SDP**) is a network protocol, which supports
    stream connections using **InfiniBand** (**IB**). The IB technology supports point-to-point
    bi-directional serial links between high-speed peripherals, such as disks. A significant
    part of IB is its ability to move data from the memory of one computer directly
    to the memory of another computer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sockets Direct Protocol**（**SDP**）是一种网络协议，支持使用**InfiniBand**（**IB**）进行流连接。IB技术支持高速外围设备之间的点对点双向串行链接，例如磁盘。IB的一个重要部分是它能够将数据从一台计算机的内存直接移动到另一台计算机的内存。'
- en: SDP is supported in Java 7 on Solaris and Linux operating systems. Several classes
    in the `java.net` and `java.nio.channels` packages support it transparently. However,
    SDP must be enabled before it can be used. Details on how to enable IB and then
    create a SDP configuration file are found at [http://download.oracle.com/javase/tutorial/sdp/sockets/index.html](http://download.oracle.com/javase/tutorial/sdp/sockets/index.html).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SDP在Solaris和Linux操作系统上的Java 7中得到支持。`java.net`和`java.nio.channels`包中的几个类支持它的透明使用。但是，在使用之前必须启用SDP。有关如何启用IB，然后创建SDP配置文件的详细信息，请参阅[http://download.oracle.com/javase/tutorial/sdp/sockets/index.html](http://download.oracle.com/javase/tutorial/sdp/sockets/index.html)。
- en: Managing simple files
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理简单文件
- en: Some files are small and contain simple data. This is usually true for text
    files. When it is feasible to read or write the entire contents of the file at
    one time, there are a few `Files` class methods that will work quite well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一些文件很小，包含简单的数据。这通常适用于文本文件。当可以一次性读取或写入文件的全部内容时，有一些`Files`类的方法可以很好地工作。
- en: In this recipe, we will examine techniques for processing simple files. Initially,
    we will examine how to read the contents of these types of files. In the *There's
    more* section, we will demonstrate how to write to them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将研究处理简单文件的技术。首先，我们将研究如何读取这些类型文件的内容。在*还有更多*部分，我们将演示如何向它们写入。
- en: Getting ready
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To read the entire contents of a file at once:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性读取文件的全部内容：
- en: Create a `java.nio.file.Path` object representing the file.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表文件的`java.nio.file.Path`对象。
- en: Use the `java.nio.file.Files` class' `readAllBytes` method.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`java.nio.file.Files`类的`readAllBytes`方法。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application. We will read and display the contents of
    the `users.txt` file found in the docs directory. Add the following main method
    to the application:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。我们将读取并显示在docs目录中找到的`users.txt`文件的内容。将以下主要方法添加到应用程序中：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Execute the application. Your output should reflect the contents of the file.
    Here is one possible output:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您的输出应该反映文件的内容。以下是一个可能的输出：
- en: '**Bob**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 鲍勃
- en: '**Mary**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 玛丽
- en: '**Sally**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 莎莉
- en: '**Tom**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 汤姆
- en: '**Ted**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 泰德
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We started by creating a `Path` object, which represents the `users.txt` file.
    The `Files` class' `readAllBytes` method was executed using the `path` object
    as its argument. The method returned an array of bytes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建了一个代表`users.txt`文件的`Path`对象。使用`Files`类的`readAllBytes`方法，使用`path`对象作为其参数执行了该方法。该方法返回一个字节数组。
- en: Next, a for statement was used to iterate through the array. Each `byte` was
    cast to a `char` and then displayed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用for语句来遍历数组。每个`byte`都被转换为`char`，然后显示出来。
- en: There's more...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The method will automatically close the file once all of the bytes have been
    read or should an exception occur. In addition to an `IOException` that might
    occur, an `OutOfMemoryError` may be thrown, if it is not possible to create an
    array of sufficient size to hold the contents of the file. Should this happen,
    then an alternative approach should be used.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有字节都被读取或发生异常，该方法将自动关闭文件。除了可能发生的`IOException`之外，还可能抛出`OutOfMemoryError`，如果不可能创建足够大的数组来容纳文件的内容。如果发生这种情况，则应使用另一种方法。
- en: 'We are also concerned with:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还关注：
- en: Writing to a simple file
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入简单文件
- en: Reading all of the lines of a file returned as a list
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件的所有行作为列表返回
- en: Writing to a simple file
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入简单文件
- en: In the following example, we are going to take the contents of the `users.txt`
    file and add a new name to the list. Using the previous code, comment out the
    for loop that prints out the values of contents. Then, after invoking the `readAllBytes`
    method on the `Path` object, create a new `path` object directed to a new, non-existent
    text file. Then declare a `String` variable called `name` and invoke the `getBytes`
    method on the string to return a new `byte` array.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将获取`users.txt`文件的内容，并向列表中添加一个新的名字。使用前面的代码，在打印出内容值的for循环之后加上注释。然后，在`Path`对象上调用`readAllBytes`方法后，创建一个指向一个新的不存在的文本文件的新`path`对象。然后声明一个名为`name`的`String`变量，并在字符串上调用`getBytes`方法返回一个新的`byte`数组。
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, we are going to use the `Files` class write method to create a new file
    with the same contents as our `users.txt` file, and then append our `String` name
    to this list. In the first invocation of the `write` method, we use `newPath`
    to specify where the file should be created, the contents byte array to specify
    what information should be used, and the `StandardOpenOption.CREATE` argument
    to specify that the file should be created if it does not exist. In the second
    invocation of the `write` method, we again use `newPath`, but then we use the
    byte array `newContents` and the `StandardOpenOption.APPEND` to specify that the
    name should be appended to the existing file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`Files`类的写入方法创建一个与我们的`users.txt`文件内容相同的新文件，然后将我们的`String`名字追加到这个列表中。在第一次调用`write`方法时，我们使用`newPath`指定文件应该创建在哪里，使用内容字节数组指定应该使用什么信息，使用`StandardOpenOption.CREATE`参数指定如果文件不存在则应该创建文件。在第二次调用`write`方法时，我们再次使用`newPath`，然后使用字节数组`newContents`和`StandardOpenOption.APPEND`指定应该将名字追加到现有文件中。
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you open the `newUsers.txt` file, you will see the list of names from your
    `users.txt` file, appended by the name you specified using the `newContents` byte
    array.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开`newUsers.txt`文件，你会看到从你的`users.txt`文件中获取的名单，以及使用`newContents`字节数组指定的名字。
- en: There is also an overloaded `write` method that uses the same `Path` object
    for its first parameter and uses the `Iterable` interface to iterate over a `CharSequence`
    as its second parameter. The third parameter of this method defines the `Charset`
    to use. The `StandardOpenOptions` are available as optional parameters as shown
    in the previous version. The open options were listed in the introduction to this
    chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个重载的`write`方法，它使用相同的`Path`对象作为第一个参数，并使用`Iterable`接口作为第二个参数来迭代`CharSequence`。该方法的第三个参数定义了要使用的`Charset`。`StandardOpenOptions`作为可选参数可用，如前一个版本所示。在本章的介绍中列出了打开选项。
- en: Reading all of the lines of a file returned as a list
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将文件的所有行作为列表返回
- en: In instances where you have a simple file you wish to read from, it can be efficient
    to use the `readAllLines` method. The method takes two arguments, namely, a `Path`
    object and a `Charset`. The method may throw an `IOException`. In the following
    example, we use the path to our `users.txt` file and the `Charset` class' `defaultCharset`
    method to execute the `readAllLines` method. The method returns a list of strings,
    which we print out within a for loop.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在你希望从一个简单的文件中读取时，使用`readAllLines`方法可能是有效的。该方法接受两个参数，即`Path`对象和`Charset`。该方法可能会抛出`IOException`。在下面的例子中，我们使用我们的`users.txt`文件的路径和`Charset`类的`defaultCharset`方法来执行`readAllLines`方法。该方法返回一个字符串列表，我们在for循环中打印出来。
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Your output should look similar to this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应该类似于这样：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the strings returned from the `readAllLines` method does not include
    the end of line character.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`readAllLines`方法返回的字符串不包括行结束符。
- en: 'The `readAllLines` method recognizes the following line terminators:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`readAllLines`方法识别以下行终止符：'
- en: '`\u000D` followed by `\u000A` (CR/LF)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\u000D`后跟`\u000A` (CR/LF)'
- en: '`\u000A`, (LF)'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\u000A`，(LF)'
- en: '`\u000D`, (CR)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\u000D`，(CR)'
- en: See also
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'In this chapter:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Using buffered* IO *for files:* This recipe examines how buffered IO is handled
    in Java 7'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用缓冲IO处理文件：*这个示例说明了在Java 7中如何处理缓冲IO'
- en: '*Writing to a file using the AsynchronousFileChannel class:* This recipe illustrates
    how IO to a file can be performed in an asynchronous fashion'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用AsynchronousFileChannel类写入文件：*这个示例说明了如何以异步方式对文件进行IO操作'
- en: '*Reading from a file using the AsynchronousFileChannel class:* This recipe
    illustrates how IO to a file can be performed in an asynchronous fashion'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用AsynchronousFileChannel类从文件中读取：*这个示例说明了如何以异步方式对文件进行IO操作'
- en: Using buffered IO for files
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用缓冲IO处理文件
- en: Buffered IO provides a more efficient technique for accessing files. Two methods
    of the `java.nio.file` package's `Files` class return either a `java.io` package
    `BufferedReader` or a `BufferedWriter` object. These classes provide an easy to
    use and efficient technique for working with text files.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲IO提供了一种更有效的访问文件的技术。`java.nio.file`包的`Files`类的两种方法返回`java.io`包的`BufferedReader`或`BufferedWriter`对象。这些类提供了一种易于使用和高效的处理文本文件的技术。
- en: We will illustrate the read operation first. In the *There's more* section,
    we will demonstrate how to write to a file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先说明读取操作。在*还有更多*部分，我们将演示如何写入文件。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To read from a file using a `BufferedReader` object:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BufferedReader`对象从文件中读取：
- en: Create a `Path` object representing the file of interest
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表感兴趣的文件的`Path`对象
- en: Create a new `BufferedReader` object using the `newBufferedReader` method
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`newBufferedReader`方法创建一个新的`BufferedReader`对象
- en: Use the appropriate `read` method to read from the file
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的`read`方法从文件中读取
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: Create a new console application using the following `main` method. In this
    method, we will read the contents of the `users.txt` file and then display its
    contents.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`main`方法创建一个新的控制台应用程序。在这个方法中，我们将读取`users.txt`文件的内容，然后显示它的内容。
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Execute the application. Your output should reflect the contents of the `users.txt`
    file, which should be similar to the following:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。你的输出应该反映出`users.txt`文件的内容，应该类似于以下内容：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A `Path` object representing the `users.txt` file was created followed by the
    creation of a `Charset`. The ISO Latin Alphabet No. 1 was used for this example.
    Other character sets can be used, depending on the platform used.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 创建代表`users.txt`文件的`Path`对象，然后创建`Charset`。在此示例中使用ISO Latin Alphabet No. 1。可以根据所使用的平台使用其他字符集。
- en: A try-with-resource block was used to create the `BufferedReader` object. This
    type of `try` block is new to Java 7 and is detailed in the *Using the try-with-resource
    block to improve exception handling code* recipe in [Chapter 1](ch01.html "Chapter 1. Java
    Language Improvements"), *Java Language Improvements*. This will result in the
    `BufferedReader` object automatically being closed when the block completes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用try-with-resource块创建了`BufferedReader`对象。这种类型的`try`块是Java 7中的新功能，并在[第1章](ch01.html
    "第1章。Java语言改进")的*使用try-with-resource块改进异常处理代码*中有详细说明，*Java语言改进*。这将导致`BufferedReader`对象在块完成时自动关闭。
- en: The while loop reads each line of the file. and then displays each line to the
    console. Any `IOExceptions` is thrown as needed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: while循环读取文件的每一行，然后将每一行显示到控制台。任何`IOExceptions`都将根据需要抛出。
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When a byte is stored in a file, its meaning can differ depending upon the intended
    encoding scheme. The `java.nio.charset` package's `Charset` class provides a mapping
    between a sequence of bytes and 16-bit Unicode code units. The second argument
    of the `newBufferedReader` method specifies the encoding to use. There is a standard
    set of character sets supported by the JVM, as detailed in the Java documentation
    for the `Charset` class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当字节存储在文件中时，其含义可能取决于预期的编码方案。`java.nio.charset`包的`Charset`类提供了字节序列和16位Unicode代码单元之间的映射。`newBufferedReader`方法的第二个参数指定要使用的编码。JVM支持一组标准字符集，详细信息请参阅`Charset`类的Java文档。
- en: 'We also need to consider:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要考虑：
- en: Writing to a file using the `BufferedWriter` class
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`BufferedWriter`类写入文件
- en: Unbuffered IO support in the `Files` class
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Files`类中的非缓冲IO支持'
- en: Writing to a file using the BufferedWriter class
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用BufferedWriter类写入文件
- en: The `newBufferedWriter` method opens or creates a file for writing and returns
    a `BufferedWriter` object. The method requires two arguments, a `Path` object
    and a specified `Charset`, and can use an optional third argument. The third argument
    specifies an `OpenOption` as detailed in the table found in the *Introduction*.
    If no option is specified, the method will behave as though the `CREATE, TRUNCATE_EXISTING`,
    and `WRITE` options were specified, and will either create a new file or truncate
    an existing file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`newBufferedWriter`方法打开或创建一个文件进行写入，并返回一个`BufferedWriter`对象。该方法需要两个参数，一个是`Path`对象，一个是指定的`Charset`，还可以使用可选的第三个参数。第三个参数指定一个`OpenOption`，如*Introduction*中的表中所述。如果未指定选项，该方法将表现为`CREATE,
    TRUNCATE_EXISTING`和`WRITE`选项被指定，将创建一个新文件或截断现有文件。'
- en: In the following example, we specify a new `String` object containing a name
    to add to our `users.txt` file. After declaring our `Path` object, we use a try-with-resource
    block to open a new `BufferedWriter`. In this example, we are using the default
    system charset and `StandardOpenOption.APPEND` to specify that we want to append
    the name to the end of our `users.txt` file. Within the try block, we first invoke
    the `newline` method against our `BufferedWriter` object to ensure that our name
    goes on a new line. Then we invoke the `write` method against our `BufferedWriter`
    object, using our `String` as the first argument, a zero to denote the beginning
    character of the String, and the length of our `String` to denote that the entire
    `String` should be written.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们指定一个包含要添加到我们的`users.txt`文件中的名称的新`String`对象。声明了我们的`Path`对象后，我们使用try-with-resource块打开了一个新的`BufferedWriter`。在此示例中，我们使用默认系统字符集和`StandardOpenOption.APPEND`来指定我们要将名称追加到我们的`users.txt`文件的末尾。在try块内，我们首先针对我们的`BufferedWriter`对象调用`newline`方法，以确保我们的名称放在新行上。然后我们针对我们的`BufferedWriter`对象调用`write`方法，使用我们的`String`作为第一个参数，零来表示字符串的开始字符，以及我们的`String`的长度来表示整个`String`应该被写入。
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you examine the contents of the `users.txt` file, the new name should be
    appended to the end of the other names in the file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查`users.txt`文件的内容，新名称应该附加到文件中的其他名称的末尾。
- en: Un-buffered IO support in the Files class
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`Files`类中的非缓冲IO支持'
- en: While un-buffered IO is not as efficient as buffered IO, it is still useful
    at times. The `Files` class provides support for the `InputStream` and `OutputStream`
    classes through its `newInputStream` and `newOutputStream` methods. These methods
    are useful in instances where you need to access very small files or where a method
    or constructor requires an `InputStream` or `OutputStream` as an argument.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然非缓冲IO不如缓冲IO高效，但有时仍然很有用。`Files`类通过其`newInputStream`和`newOutputStream`方法为`InputStream`和`OutputStream`类提供支持。这些方法在需要访问非常小的文件或方法或构造函数需要`InputStream`或`OutputStream`作为参数时非常有用。
- en: In the following example, we are going to perform a simple copy operation where
    we copy the contents of the `users.txt` file to a `newUsers.txt` file. We first
    declare two `Path` objects, one referencing the source file, `users.txt`, and
    one specifying our destination file, `newUsers.txt`. Then, within a try-with-resource
    block, we open both an `InputStream` and an `OutputStream`, using the `newInputStream`
    and `newOutputStream` methods. Within the block, we read in the data from our
    source file and write it to the destination file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将执行一个简单的复制操作，将`users.txt`文件的内容复制到`newUsers.txt`文件中。我们首先声明两个`Path`对象，一个引用源文件`users.txt`，一个指定我们的目标文件`newUsers.txt`。然后，在try-with-resource块内，我们打开了一个`InputStream`和一个`OutputStream`，使用`newInputStream`和`newOutputStream`方法。在块内，我们从源文件中读取数据并将其写入目标文件。
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Upon examining the `newUsers.txt` file, you should see that the content matches
    that of the `users.txt` file.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`newUsers.txt`文件后，您应该看到内容与`users.txt`文件相匹配。
- en: See also
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'In this chapter:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Managing simple files:* This recipe shows how non-buffered IO is handled in
    Java 7'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*管理简单文件：*此示例显示了如何在Java 7中处理非缓冲IO'
- en: '*Writing to a file using the AsynchronousFileChannel class:* This recipe illustrates
    how IO to a file can be performed in an asynchronous fashion'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用AsynchronousFileChannel类向文件写入：*此示例说明了如何以异步方式对文件进行IO操作'
- en: '*Reading from a file using the AsynchronousFileChannel class:* This recipe
    illustrates how IO to a file can be performed in an asynchronous fashion'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用AsynchronousFileChannel类从文件中读取：*此示例说明了如何以异步方式对文件进行IO操作'
- en: Random access IO using the SeekableByteChannel
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SeekableByteChannel进行随机访问IO
- en: Random access to a file is useful for more complex files. It allows access to
    specific positions within the file in a non-sequential fashion. The `java.nio.channels`
    package's `SeekableByteChannel` interface provides this support, based on channel
    IO. Channels provide a low-level approach for bulk data transfers. In this recipe
    we will use a `SeekableByteChannel` to access a file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对文件的随机访问对于更复杂的文件很有用。它允许以非顺序方式访问文件中的特定位置。`java.nio.channels`包的`SeekableByteChannel`接口提供了这种支持，基于通道IO。通道提供了用于大容量数据传输的低级方法。在此示例中，我们将使用`SeekableByteChannel`来访问文件。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To obtain a `SeekableByteChannel` object:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`SeekableByteChannel`对象：
- en: Create a `Path` object representing a file.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示文件的`Path`对象。
- en: Get a `SeekableByteChannel` object using the `Files` class' static `newByteChannel`
    method.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Files`类的静态`newByteChannel`方法获取`SeekableByteChannel`对象。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: Create a new console application using the following `main` method. We will
    define a `bufferSize` variable to control the size of the buffer used by the channel.
    We will create a `SeekableByteChannel` object and use it to display the first
    two names in the `users.txt` file.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`main`方法创建一个新的控制台应用程序。我们将定义一个`bufferSize`变量来控制通道使用的缓冲区的大小。我们将创建一个`SeekableByteChannel`对象，并使用它来显示`users.txt`文件中的前两个名称。
- en: '[PRE9]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Make sure that the `users.txt` file contains the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 确保`users.txt`文件包含以下内容：
- en: '[PRE10]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Execute the application. The output should display the first two names in reverse
    order:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。输出应显示前两个名称的相反顺序：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We created a `bufferSize` variable to control the size of the buffer, used by
    the channel. Next, a `Path` object was created for the `users.txt` file. This
    path was used as the argument to the `newByteChannel` method, which returned a
    `SeekableByteChannel` object.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`bufferSize`变量来控制通道使用的缓冲区的大小。接下来，为`users.txt`文件创建了一个`Path`对象。该路径被用作`newByteChannel`方法的参数，该方法返回了一个`SeekableByteChannel`对象。
- en: We moved the read position in the file to the fourth position. This placed us
    at the beginning of the second name in the file. The `read` method was then used,
    which read approximately eight bytes into buffer. The first five bytes of the
    buffer were then displayed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件中的读取位置移动到第四个位置。这将我们放置在文件中第二个名称的开头。然后使用`read`方法，将大约八个字节读入缓冲区。然后显示缓冲区的前五个字节。
- en: We repeated this sequence, but moved the position to zero, that is, the beginning
    of the file. A `read` operation was performed again, and then we displayed the
    first four characters, which were the first name in the file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复了这个序列，但将位置移动到零，即文件的开头。然后再次执行了一个`read`操作，然后显示了前四个字符，这是文件中的第一个名称。
- en: This example used explicit knowledge of the size of the names in the file. Normally,
    this knowledge is not available unless obtained by some other technique. We used
    this knowledge here simply to demonstrate the nature of the `SeekableByteChannel`
    interface.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用了对文件中名称大小的明确了解。通常，除非通过其他技术获得，否则不会获得这种了解。我们在这里使用这些知识只是为了演示`SeekableByteChannel`接口的性质。
- en: There's more...
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `read` method will start reading from the current position in the file.
    It will read until either the buffer is filled or the end of file is reached.
    The method returns an integer, indicating how many bytes were read. A `-1` is
    returned when the end of stream is reached.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`方法将从文件中的当前位置开始读取。它将读取直到缓冲区填满或达到文件末尾。该方法返回一个整数，指示读取了多少字节。当达到流的末尾时，返回`-1`。'
- en: The read and write operations may be accessing the same `SeekableByteChannel`
    object used by multiple threads. As a result, an `AsynchronousCloseException`
    or a `ClosedByInterruptException` exception may be thrown when another thread
    closes the channel or otherwise interrupts the current thread.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 读取和写入操作可能会访问由多个线程使用的相同的`SeekableByteChannel`对象。因此，当另一个线程关闭通道或以其他方式中断当前线程时，可能会抛出`AsynchronousCloseException`或`ClosedByInterruptException`异常。
- en: There is a `size` method that returns the size of the stream. A `truncate` method
    is available that discards all bytes past a specific position in the file. This
    position is passed as a long argument to the method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个返回流大小的`size`方法。还有一个可用的`truncate`方法，它会丢弃文件中特定位置之后的所有字节。该位置作为长参数传递给该方法。
- en: The `Files` class' static `newByteChannel` method can take a second argument,
    which specifies the option used when opening the file. These are detailed in the
    *There's more* section, *Writing to a file using the BufferedWriter class*, of
    the *Using buffered IO for files* recipe.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files`类的静态`newByteChannel`方法可以接受第二个参数，该参数指定打开文件时使用的选项。这些选项在*还有更多*部分的*使用Buffered
    IO for files*示例的*使用BufferedWriter类向文件写入*中有详细说明。'
- en: 'In addition, we need to consider:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要考虑：
- en: Processing the contents of the entire file
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理整个文件的内容
- en: Writing to a file using the `SeekableByteChannel` interface
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SeekableByteChannel`接口向文件写入
- en: Querying the position
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询位置
- en: Processing the contents of the entire file
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 处理整个文件的内容
- en: Add the following code to the application. The purpose is to demonstrate how
    to process the entire file in a sequential fashion and to gain an understanding
    of various `SeekableByteChannel` interface methods.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到应用程序中。其目的是演示如何以顺序方式处理整个文件，并了解各种`SeekableByteChannel`接口方法。
- en: '[PRE12]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Execute the application. Your output should be similar to the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 执行应用程序。您的输出应该类似于以下内容：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We started by repositioning the `read` to the beginning of the file, using
    the `position` method. The encoding string for the system was determined for the
    system by accessing the `system` property: `file.encoding`. We kept track of how
    many bytes are read with each read operation and displayed this count.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过使用`position`方法将`read`重新定位到文件的开头。通过访问`system`属性：`file.encoding`来确定系统的编码字符串。我们跟踪了每次读取操作读取了多少字节，并显示了这个计数。
- en: In the while loop, we displayed the contents of the buffer by enclosing it in
    a set of brackets. This made it easier to see what was read in. The `rewind` method
    sets the position within the buffer to `0`. This is not to be confused with the
    position within the file.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在while循环中，我们通过将其括在一对括号中显示了缓冲区的内容。这样更容易看到读取的内容。`rewind`方法将缓冲区内的位置设置为`0`。这不应与文件内的位置混淆。
- en: To display the actual buffer, we need to apply the `forName` method to obtain
    a `Charset` object, and then use the `decode` method against it to convert the
    bytes in the buffer into Unicode characters. This was followed by the `flip` method,
    which sets the limit of the buffer to the current position and then sets the position
    in the buffer to `0`. This sets up the buffer for subsequent reads.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示实际的缓冲区，我们需要应用`forName`方法来获取`Charset`对象，然后使用`decode`方法将缓冲区中的字节转换为Unicode字符。然后是`flip`方法，它将缓冲区的限制设置为当前位置，然后将缓冲区的位置设置为`0`。这为后续读取设置了缓冲区。
- en: You may want to adjust the `bufferSize` value to see how the application behaves
    with different values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望调整`bufferSize`值，以查看应用程序在不同值下的行为。
- en: Writing to a file using the SeekableByteChannel interface
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用SeekableByteChannel接口向文件写入
- en: The `write` method takes a `java.nio` package's `ByteBuffer` object and writes
    it to the channel. The operation starts at the current position in the file. For
    example, if the file was opened with an append option, the first write will be
    at the end of the file. The method returns the number of bytes written.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`write`方法接受`java.nio`包的`ByteBuffer`对象，并将其写入通道。操作从文件中的当前位置开始。例如，如果文件以追加选项打开，则第一次写入将在文件末尾进行。该方法返回写入的字节数。'
- en: In the following example, we will append three names to the end of the `users.txt`
    file. We use the `StandardOpenOption.APPEND` as the open option for the `newByteChannel`
    method. This will move the cursor to the end of the file and begin writing at
    that position. A `ByteBuffer` is created with three names separated by the system
    line separator property. Using this property makes the code more portable. The
    `write` method is then executed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将向`users.txt`文件的末尾追加三个名称。我们使用`StandardOpenOption.APPEND`作为`newByteChannel`方法的打开选项。这将把光标移动到文件的末尾，并从该位置开始写入。创建了一个`ByteBuffer`，其中包含三个名称，由系统行分隔符属性分隔。使用此属性使代码更具可移植性。然后执行`write`方法。
- en: '[PRE14]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The initial contents of the `users.txt` file should be:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`users.txt`文件的初始内容应该是：'
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the code sequence to the application and execute the program. Examine the
    contents of the `users.txt` file. It should now appear as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码序列添加到应用程序并执行该程序。检查`users.txt`文件的内容。现在应该如下所示：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Query the position
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查询位置
- en: The overloaded `position` method returns a long value indicating the position
    within the file. This is complemented by a `position` method that takes a long
    argument and sets the position to that value. If the value exceeds the size of
    the stream, then the position is set to the end of the stream. The `size` method
    will return the size of the file used by the channel.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重载的`position`方法返回一个长值，指示文件内的位置。这由一个接受长参数的`position`方法补充，并将位置设置为该值。如果该值超过流的大小，则位置将设置为流的末尾。`size`方法将返回通道使用的文件的大小。
- en: To demonstrate the use of these methods, we will duplicate the example in the
    previous section. This means we will position the file cursor to the end of the
    `users.txt` file and then write three different names on separate lines.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这些方法的使用，我们将复制上一节中的示例。这意味着我们将把文件光标定位到`users.txt`文件的末尾，然后在单独的行上写入三个不同的名称。
- en: In the following code sequence, we use the `size` method to determine how big
    the file is, and then use this value as the argument to the `position` method.
    This moves the cursor to the end of the file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码序列中，我们使用`size`方法来确定文件的大小，然后将此值作为`position`方法的参数。这将把光标移动到文件的末尾。
- en: Next, a `ByteBuffer` is created thrice, and written to the file each time using
    a different name. The position is displayed for informational purposes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建了三次`ByteBuffer`，并且每次使用不同的名称写入文件。位置是为了信息目的而显示的。
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The contents of the `users.txt` file should initially contain:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`users.txt`文件的内容应该最初包含：'
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add this sequence to the application and execute the program. Examine the contents
    of the `users.txt` file. It should now appear as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将此序列添加到应用程序并执行该程序。检查`users.txt`文件的内容。现在应该如下所示：
- en: '**Bob**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bob**'
- en: '**Mary**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mary**'
- en: '**Sally**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sally**'
- en: '**Tom**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tom**'
- en: '**Ted**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ted**'
- en: '**Paul**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**Paul**'
- en: '**Carol**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**Carol**'
- en: '**Fred**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fred**'
- en: See also
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In this chapter
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中
- en: '*There''s more* section of the *Random access IO using the SeekableByteChannel*
    recipe: This recipe briefs you on the options used to open a file'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随后*的*使用SeekableByteChannel进行随机访问IO*配方：此配方简要介绍了用于打开文件的选项'
- en: '*Writing to a file using the BufferedWriter class* of the *Using buffered IO
    for files* recipe.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用BufferedWriter类向文件写入*的*使用缓冲IO进行文件*配方。'
- en: Managing asynchronous communication using the AsynchronousServerSocketChannel
    class
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用AsynchronousServerSocketChannel类管理异步通信
- en: Java 7 supports asynchronous communications between a server and a client. The
    `java.nio.channels` package's `AsynchronousServerSocketChannel` class supports
    server operations for streaming IO in a thread-safe manner. Communication is conducted
    using an `AsynchronousSocketChannel` object that acts as a client. Together we
    can use these classes to build a server/client application that communicates in
    an asynchronous fashion.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7支持服务器和客户端之间的异步通信。`java.nio.channels`包的`AsynchronousServerSocketChannel`类支持以线程安全的方式进行流IO的服务器操作。通信是使用充当客户端的`AsynchronousSocketChannel`对象进行的。我们可以一起使用这些类来构建一个以异步方式通信的服务器/客户端应用程序。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Both a server and a client need to be created. To create a server:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建服务器和客户端。要创建服务器：
- en: Use the static `AsynchronousServerSocketChannel` class' `open` method to get
    an instance of a `AsynchronousServerSocketChannel` object
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用静态的`AsynchronousServerSocketChannel`类的`open`方法来获取`AsynchronousServerSocketChannel`对象的实例
- en: Bind the channel to a local address and port number
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将通道绑定到本地地址和端口号
- en: Use the `accept` method to accept a connection request from a client
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`accept`方法来接受来自客户端的连接请求
- en: Process messages as they are received
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接收到消息时处理消息
- en: 'To create a client:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建客户端：
- en: Create an `AsynchronousSocketChannel` object using the static `open` method
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用静态的`open`方法创建一个`AsynchronousSocketChannel`对象
- en: Create an instance of an `InetSocketAddress` object for the server
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为服务器创建一个`InetSocketAddress`对象的实例
- en: Connect to the server
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到服务器
- en: Send messages as needed
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要发送消息
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create two applications: one on the server and one on the client. Together,
    they will support a simple server/client application, which will explain how asynchronous
    communication is performed using an `AsynchronousSocketChannel`.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将创建两个应用程序：一个在服务器上，一个在客户端上。它们将一起支持一个简单的服务器/客户端应用程序，这将解释如何使用`AsynchronousSocketChannel`执行异步通信。 '
- en: Create a new console application that will be on the server and add the following
    `main` method. The server will simply display any messages sent to it. It opens
    a server socket and binds it to an address. It will then use the `accept` method
    with a `CompletionHandler` to process any requests from a client.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序，将作为服务器，并添加以下`main`方法。服务器将简单地显示发送到它的任何消息。它打开一个服务器套接字并将其绑定到一个地址。然后，它将使用`accept`方法和`CompletionHandler`来处理来自客户端的任何请求。
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, create a second console application that will act as a client. It will
    use the `open` method to create an `AsynchronousSocketChannel` object and then
    connect to the server. A `java.util.concurrent` package's `Future` object's `get`
    method is used to block until the connection is complete, and then a message is
    sent to the server.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个作为客户端的第二个控制台应用程序。它将使用`open`方法来创建一个`AsynchronousSocketChannel`对象，然后连接到服务器。使用`java.util.concurrent`包的`Future`对象的`get`方法来阻塞，直到连接完成，然后向服务器发送消息。
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You will need to execute both the applications. Depending on your environment,
    you may need to execute one of the applications in a command window and the second
    in your IDE. This will be the case if you can have only one instance of your IDE
    running at a time.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要执行这两个应用程序。根据您的环境，您可能需要在命令窗口中执行一个应用程序，然后在IDE中执行第二个应用程序。如果您一次只能运行一个IDE实例，就会出现这种情况。
- en: 'Execute the server application first. Next, execute the client application.
    It should prompt you for a message and then send the message to the server where
    it will be displayed. Your output should have the following general output. The
    client and the server output are shown in separate columns in the following table:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先执行服务器应用程序。然后执行客户端应用程序。它应提示您输入消息，然后将消息发送到服务器，在那里将显示。您的输出应该具有以下一般输出。客户端和服务器的输出显示在以下表格中的不同列中：
- en: '| Client | Server |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 客户端 | 服务器 |'
- en: '| --- | --- |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Client: Waiting for the connection to completeEnter a message: First messageClient:
    Sending ...Client: Message sent: First message |   |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 客户端：等待连接完成输入消息：第一条消息客户端：发送...客户端：消息已发送：第一条消息 |   |'
- en: '|   | Server: completed method executingServer: Message received: First message
    |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|   | 服务器：完成方法执行中服务器：收到消息：第一条消息 |'
- en: '| Enter a message: `Most excellent message`Client: Sending ...Client: Message
    sent: Most excellent message |  |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 输入消息：`最优秀的消息`客户端：发送...客户端：消息已发送：最优秀的消息 |  |'
- en: '|   | Server: Message received: Most excellent message |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|   | 服务器：收到消息：最优秀的消息 |'
- en: '| Enter a message: `quit`Client: Sending ...Client: Message sent: quit |  
    |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 输入消息：`退出`客户端：发送...客户端：消息已发送：退出 |  |'
- en: '|   | Server: Message received: quitjava.util.concurrent.ExecutionException:
    java.io.IOException: The specified network name is no longer available.... |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|   | 服务器：收到消息：退出java.util.concurrent.ExecutionException: java.io.IOException:指定的网络名称不再可用...
    |'
- en: Notice that when the client application was terminated, an `ExecutionException`
    occurred in the server. Normally, we would handle this exception more gracefully
    in a production application.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，当客户端应用程序终止时，服务器中发生了`ExecutionException`。通常，我们会在生产应用程序中更优雅地处理此异常。
- en: How it works...
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's examine the server application first. An `AsynchronousServerSocketChannel`
    object was created using the `open` method. The `bind` method was then used to
    associate the socket with a socket address, determined by the system and a port
    number of `5000`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先检查服务器应用程序。使用`open`方法创建了一个`AsynchronousServerSocketChannel`对象。然后使用`bind`方法将套接字与由系统确定的套接字地址和端口号`5000`关联起来。
- en: Next, the `accept` method was invoked to accept a connection. The first argument
    specified a `null` value, which was used for attachments. Later, we will see how
    to use an attachment. The second argument was a `CompletionHandler` object. This
    object was created as an anonymous inner class, and its methods will be called
    when a communication request made by a client makes a communication request.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，调用`accept`方法来接受一个连接。第一个参数指定了一个`null`值，用于附件。稍后，我们将看到如何使用附件。第二个参数是一个`CompletionHandler`对象。这个对象被创建为一个匿名内部类，当客户端发出通信请求时，它的方法将被调用。
- en: In the `completed` method, we displayed a message indicating that the method
    is executing. We then entered an infinite while loop where we allocated 32 bytes
    to a buffer, and then attempted to read from a client. The `read` method returned
    a `Future` object that we subsequently used the `get` method against. This effectively
    blocked the execution until the client sent a message. The message was then displayed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在`completed`方法中，我们显示了一个消息，指示该方法正在执行。然后我们进入了一个无限循环，在循环中我们为一个缓冲区分配了32个字节，然后尝试从客户端读取。`read`方法返回了一个`Future`对象，随后我们使用`get`方法。这有效地阻塞了执行，直到客户端发送了一条消息。然后显示了这条消息。
- en: Notice that the `get` method returned a generic `Future object` of type `Integer`.
    We could have used this to determine how many bytes were actually read. It was
    used here simply to block until the IO was complete. The `failed` method would
    have been called if an exception had occurred with the channel communication.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`get`方法返回了一个泛型`Future对象`，类型为`Integer`。我们可以使用这个来确定实际读取了多少字节。这里只是用来阻塞，直到IO完成。如果通道通信发生异常，将调用`failed`方法。
- en: The infinite while loop at the end of the try block prevents the server from
    terminating. This is acceptable here for simplicity's sake, but normally, we would
    handle this in a more graceful fashion.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在try块的末尾进入了一个无限循环，防止服务器终止。这在这里是可以接受的，为了简单起见，但通常我们会以更优雅的方式处理这个问题。
- en: In the client application, we used the `open` method to create an `AsynchronousSocketChannel`
    object. A network address corresponding to the server was created and then used
    with the connect method to connect to the server. This method returned a `Future`
    object. We used this object with the `get` method to block until a connection
    with the server was established.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端应用程序中，我们使用`open`方法创建了一个`AsynchronousSocketChannel`对象。创建了一个与服务器对应的网络地址，然后与`connect`方法一起使用以连接到服务器。这个方法返回了一个`Future`对象。我们使用这个对象与`get`方法来阻塞，直到与服务器建立连接。
- en: Notice that the `connect` method returned a `Future` object of the type `Void`.
    The `Void` class is found in the `java.lang` package and is a wrapper class for
    `void`. It was used here as nothing was effectively returned by the `connect`
    method.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`connect`方法返回了一个`Void`类型的`Future`对象。`Void`类位于`java.lang`包中，是`void`的包装类。这里使用它是因为`connect`方法实际上没有返回任何东西。
- en: A while loop was entered, which terminated when the user entered `quit`. The
    user was prompted for a message, and then a `ByteBuffer` object was created using
    the message. The buffer was then written to the server.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 进入了一个while循环，当用户输入`quit`时终止。用户被提示输入一条消息，然后使用该消息创建了一个`ByteBuffer`对象。然后将缓冲区写入服务器。
- en: Notice the use of multiple exceptions in the catch blocks of both applications.
    This is a new Java 7 language improvement and is discussed in the *Catching multiple
    exception types to improve type checking* recipe in [Chapter 1](ch01.html "Chapter 1. Java
    Language Improvements"), *Java Language Improvements*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在两个应用程序的catch块中使用了多个异常。这是Java 7的新语言改进，可以在[第1章](ch01.html "第1章. Java语言改进")的*Catching
    multiple exception types to improve type checking*中找到。
- en: There's more...
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `bind` method is overloaded. Both versions' first argument is a `SocketAddress`
    object, corresponding to a local address. A `null` value can be used, which will
    automatically assign a socket address. The second `bind` method accepts an integer
    value for the second argument. This configures the maximum number of pending connections
    allowed in an implementation-dependent manner. A value less than or equal to zero
    will use an implementation-specific default value.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind`方法是重载的。两个版本的第一个参数都是一个`SocketAddress`对象，对应一个本地地址。可以使用`null`值，这将自动分配一个套接字地址。第二个`bind`方法接受一个整数值作为第二个参数。这样可以以实现相关的方式配置允许的最大挂起连接数。小于或等于零的值将使用特定于实现的默认值。'
- en: 'There are two aspects of this communication technique that we should address:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个方面的通信技术我们应该注意：
- en: Using the `Future` object in a server
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器中使用`Future`对象
- en: Understanding the `AsynchronousServerSocketChannel` class options
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`AsynchronousServerSocketChannel`类的选项
- en: Using the Future object in a server
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在服务器中使用Future对象
- en: The `AsynchronousServerSocketChannel` class' `accept` method is overloaded.
    There is a no argument method that accepts a connection and returns a `Future`
    object for the channel. The `Future` object's `get` method will return an `AsynchronousSocketChannel`
    object for the connection. The advantage of this approach is that it returns an
    `AsynchronousSocketChannel` object, which can be used in other contexts.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsynchronousServerSocketChannel`类的`accept`方法是重载的。有一个不带参数的方法接受一个连接并返回通道的`Future`对象。`Future`对象的`get`方法将返回一个连接的`AsynchronousSocketChannel`对象。这种方法的优势是返回一个`AsynchronousSocketChannel`对象，可以在其他上下文中使用。'
- en: 'Instead of using the `accept` method, which uses a `CompletionHandler`, we
    can use the following sequence to do the same thing. Comment out the previous
    `accept` method and add the following code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`CompletionHandler`的`accept`方法不同，我们可以使用以下顺序来做同样的事情。注释掉之前的`accept`方法，添加以下代码：
- en: '[PRE21]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Execute the applications again. You should get the same output as before.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行应用程序。你应该得到与之前相同的输出。
- en: Understanding the AsynchronousServerSocketChannel class options
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理解AsynchronousServerSocketChannel类的选项
- en: 'The `supportedOptions` method returns a set of options used by the `AsynchronousServerSocketChannel`
    class. The `getOption` method will return the value of the option. Add the following
    code after the use of the `bind` method in the previous example:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`supportedOptions`方法返回`AsynchronousServerSocketChannel`类使用的一组选项。`getOption`方法将返回选项的值。在上一个示例中的`bind`方法之后添加以下代码：'
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Execute the code. The default values will be displayed and should be similar
    to the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码。将显示默认值，并且应该类似于以下内容：
- en: '[PRE23]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The options can be set using the `setOption` method. This method takes the
    name of the option and a value. The following illustrates how to set the receive
    buffer size to 16,384 bytes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`setOption`方法设置选项。此方法接受选项的名称和值。以下说明了如何将接收缓冲区大小设置为16,384字节：
- en: '[PRE24]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `StandardSocketOptions` class defines socket options. Only the `SO_REUSEADDR`
    and `SO_RCVBUF` options are supported for the `AsynchronousServerSocketChannel`
    channel.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`StandardSocketOptions`类定义了套接字选项。仅支持`AsynchronousServerSocketChannel`通道的`SO_REUSEADDR`和`SO_RCVBUF`选项。'
- en: See also
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 另请参见
- en: 'In this chapter: There''s more section, of the *Reading from a file using the
    AsynchronousFileChannel class* recipe: This recipe explains the use of attachments
    with a completion handler and the use of the `AsynchronousChannelGroup` class'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中：*使用`AsynchronousFileChannel`类从文件中读取*部分的*还有更多*部分：本示例解释了完成处理程序的附件使用以及`AsynchronousChannelGroup`类的使用
- en: Writing to a file using the AsynchronousFileChannel class
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`AsynchronousFileChannel`类写入文件
- en: The `java.nio.channels` package's `AsynchronousFileChannel` class permits file
    IO operations to be performed in an asynchronous manner. When an IO method is
    invoked, it will return immediately. The actual operation may occur at some other
    time (and potentially using a different thread). In this recipe, we will explore
    how the `AsynchronousFileChannel` class performs asynchronous **write** operations.
    **Read** operations will be demonstrated in the *Reading from a file using the
    AsynchronousFileChannel class* recipe.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.channels`包的`AsynchronousFileChannel`类允许以异步方式执行文件IO操作。当调用IO方法时，它将立即返回。实际操作可能会在其他时间发生（可能使用不同的线程）。在本示例中，我们将探讨`AsynchronousFileChannel`类如何执行异步**写**操作。**读**操作将在*使用`AsynchronousFileChannel`类从文件中读取*示例中进行演示。'
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To perform a write operation:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 执行写操作：
- en: Create a `Path` object representing the file to be read from.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表要从中读取的文件的`Path`对象。
- en: Use this path with the `open` method to open a file channel.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此路径和`open`方法打开文件通道。
- en: Use the `write` method to write data to the file, optionally using a completion
    handler.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`write`方法向文件写入数据，可以选择使用完成处理程序。
- en: How to do it...
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何做...
- en: In this example, we will perform a series of write operations against a file.
    There are two overloaded `write` methods. Both take as their initial arguments
    a `java.nio` package's `ByteBuffer`, containing the data to be written and a second
    argument specifying the position to write to in the file.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将对文件执行一系列写操作。有两个重载的`write`方法。它们的初始参数都是`java.nio`包的`ByteBuffer`，包含要写入的数据，以及指定要写入文件的位置的第二个参数。
- en: The two arguments' `write` method returns a `java.util.concurrent` package's
    `Future<Integer>` object, which can also be used to write to a file, as demonstrated
    in the *There's more* section. The second `write` method has a third argument,
    an attachment, and a fourth argument, a `CompletionHandler` object. The completion
    handler is executed when the write operation completes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 两个参数的`write`方法返回一个`java.util.concurrent`包的`Future<Integer>`对象，也可以用于向文件写入，如*还有更多*部分所示。第二个`write`方法有第三个参数，一个附件，和第四个参数，一个`CompletionHandler`对象。当写操作完成时，执行完成处理程序。
- en: Create a new console application. Use the following `main` method. We open a
    file called `asynchronous.txt` for writing. A completion handler is created and
    used with the `write` method. Two write operations are performed. Thread information
    is displayed to explain the asynchronous nature of the operation and how completion
    handlers work.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。使用以下`main`方法。我们打开一个名为`asynchronous.txt`的文件进行写入。创建并使用了一个完成处理程序与`write`方法。执行了两次写操作。显示线程信息以解释操作的异步性质以及完成处理程序的工作原理。
- en: '[PRE25]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Execute the application. Your application may not behave as you expect. Due
    to the asynchronous nature of the operations, the order of execution of the various
    elements may vary from execution to execution. The following is one possible output:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您的应用程序可能不会按您的预期行为。由于操作的异步性质，各个元素的执行顺序可能会因执行而异。以下是一个可能的输出：
- en: '[PRE26]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Re-executing the application may give a different order of execution. This behavior
    is explained in the following section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 重新执行应用程序可能会给出不同的执行顺序。这种行为在下一节中有解释。
- en: How it works...
  id: totrans-269
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We started by creating an `AsynchronousFileChannel` object using a `Path` object
    for the `asynchronous.txt` file in the `docs` directory. The file was opened for
    read and write operations, and was supposed to be created if it did not already
    exist. A `CompletionHandler` object was created. This was used in this example
    to confirm the execution of the write operations.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`docs`目录中的`asynchronous.txt`文件的`Path`对象创建了一个`AsynchronousFileChannel`对象。该文件被打开以进行读写操作，并且如果文件不存在，则应该被创建。创建了一个`CompletionHandler`对象。在本例中，它用于确认写操作的执行。
- en: The `write` method was executed twice. The first time the string, `Sample`,
    was written to the file, starting at position `0` in the file. The second write
    operation wrote the string, `Box`, to the file, also starting at position `0`.
    This resulted in an overwrite, with the contents of the file containing the string,
    `Boxple`. This was intentional, and illustrates the use of the `position` argument
    of the `write` method.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`write`方法被执行了两次。第一次将字符串`Sample`从文件的位置`0`开始写入。第二次写操作将字符串`Box`写入文件，也从位置`0`开始。这导致覆盖，文件的内容包含字符串`Boxple`。这是有意的，并且说明了`write`方法的`position`参数的使用。'
- en: The ID of the current thread was displayed at various points in the code. It
    shows one thread used for the `main` method, and two other threads used for the
    content handlers. When the `write` method was executed, it was performed in an
    asynchronous fashion. The `write` method executes and immediately returns. The
    actual write may occur at a later time. Upon completion of the write operation,
    a successful completion results in the content handler's `completed` method executing.
    This displays the ID for its thread, and a message showing the attachment and
    the number of bytes written. If an exception occurs, the `failed` method will
    be executed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当前线程的ID在代码的各个地方都有显示。它显示了一个线程用于`main`方法，另外两个线程用于内容处理程序。当执行`write`方法时，它是以异步方式执行的。`write`方法执行并立即返回。实际的写操作可能会在稍后发生。写操作完成后，成功完成会导致内容处理程序的`completed`方法执行。这会显示其线程的ID，并显示一个消息，显示附件和写入的字节数。如果发生异常，将执行`failed`方法。
- en: As you can see from the output, a separate thread was used to execute the completion
    handler. The completion handler was defined to return an `Integer` value. This
    value represents the number of bytes written. The attachment can be any object
    needed. In this case, we used it to show which `write` method has completed. The
    asynchronous nature of the write operations resulted in an unpredictable execution
    order of the content handlers. However, the `write` methods did execute in the
    anticipated order.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看到，一个单独的线程被用来执行完成处理程序。完成处理程序被定义为返回一个`Integer`值。这个值代表写入的字节数。附件可以是任何需要的对象。在这种情况下，我们用它来显示哪个`write`方法已经完成。写操作的异步性导致内容处理程序的执行顺序不可预测。然而，`write`方法确实按预期的顺序执行了。
- en: Notice the use of the try-with-resource block. This Java 7 feature is explored
    in the *Using the try-with-resource block to improve exception handling code*
    recipe in [Chapter 1](ch01.html "Chapter 1. Java Language Improvements"), *Java
    Language Improvements*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用try-with-resource块。这是Java 7的一个特性，在[第1章](ch01.html "第1章. Java语言改进")的*使用try-with-resource块改进异常处理代码*示例中进行了探讨，*Java语言改进*。
- en: There's more...
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The two arguments'' `write` method returns a `Future<Integer>` object. Later,
    in the program, we can use its `get` method, which blocks until the write operation
    has completed. Comment out the previous example''s write operations, and replace
    them with the following code sequence:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 两个参数的`write`方法返回一个`Future<Integer>`对象。稍后在程序中，我们可以使用它的`get`方法，它会阻塞，直到写操作完成。注释掉前面示例的写操作，并用以下代码序列替换它们：
- en: '[PRE27]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Execute the application. The output should be similar to the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 执行应用程序。输出应该类似于以下内容：
- en: '[PRE28]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `write` methods returned a `Future` object. The `get` method was blocked
    until the write operation was completed. We used the result to display a message
    indicating which write operation executed and how many bytes were written.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`write`方法返回了一个`Future`对象。`get`方法被阻塞，直到写操作完成。我们用结果来显示一个消息，指示哪个写操作执行了，以及写入了多少字节。'
- en: 'There are considerably more aspects of asynchronous file channel IO that could
    be addressed. Other aspects that may be of interest include:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多关于异步文件通道IO的方面可以讨论。可能感兴趣的其他方面包括：
- en: Forcing the updates to a channel to be written
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制将对通道的更新写入
- en: Locking parts or all of a file for exclusive access
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定文件的部分或全部以独占方式访问
- en: Using `AsynchronousChannelGroup` to manage related asynchronous operations
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AsynchronousChannelGroup`来管理相关的异步操作
- en: See also
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 另请参阅
- en: In this chapter *Reading from a file using the AsynchronousFileChannel class:*
    This recipe demonstrates how to perform asynchronous reads, and the use of the
    `AsynchronousChannelGroup` class.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章*使用AsynchronousFileChannel类从文件中读取:* 这个示例演示了如何执行异步读取，并使用`AsynchronousChannelGroup`类。
- en: Reading from a file using the AsynchronousFileChannel class
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用AsynchronousFileChannel类从文件中读取
- en: Asynchronous read operations are also possible using either of two overloaded
    `read` methods. We will demonstrate how this is accomplished using a `java.nio.channels`
    package's `AsynchronousChannelGroup` object. This will provide us with a way of
    observing these methods in action and provide an example of an `AsynchronousChannelGroup`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用两个重载的`read`方法来进行异步读取操作。我们将演示如何使用`java.nio.channels`包的`AsynchronousChannelGroup`对象来实现这一点。这将为我们提供一种观察这些方法的方式，并提供一个`AsynchronousChannelGroup`的示例。
- en: Getting ready
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To perform a write operation:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 执行写操作：
- en: Create a `Path` object representing the file to be read from.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表要从中读取的文件的`Path`对象。
- en: Use this path with the `open` method to open a file channel.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个路径和`open`方法来打开一个文件通道。
- en: Use the `read` method to read data from the file.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`read`方法从文件中读取数据。
- en: How to do it...
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new console application. In the `main` method, create an instance of
    a `java.util.concurrent` package's `ScheduledThreadPoolExecutor` object of size
    three. We will use the `ScheduledThreadPoolExecutor` class primarily because it
    is easy to create. A size of three will help illustrate how threads are managed.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。在`main`方法中，创建一个大小为三的`java.util.concurrent`包的`ScheduledThreadPoolExecutor`对象的实例。我们将主要使用`ScheduledThreadPoolExecutor`类，因为它很容易创建。大小为三将有助于说明线程是如何管理的。
- en: '[PRE29]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, add a try-with-resource block and create an `AsynchronousFileChannel`
    object for the file `items.txt`. Use an `open` option of `StandardOpenOption.READ`,
    and the previously created pool object.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个try-with-resource块，并为文件`items.txt`创建一个`AsynchronousFileChannel`对象。使用`StandardOpenOption.READ`的`open`选项，以及之前创建的pool对象。
- en: '[PRE30]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Next, display the main thread ID and then create a `CompletionHandler` object,
    which we will use to display the results of the asynchronous read operation.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，显示主线程ID，然后创建一个`CompletionHandler`对象，我们将用它来显示异步读操作的结果。
- en: '[PRE31]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Next, add code to create an array of `ByteBuffer` objects. Allocate `10` bytes
    for each buffer, and then use a buffer as the first argument of the `read` method
    and as the attachment. Using it as the attachment, allows us to access the result
    of the read operation in the completion handler. The starting read position is
    specified in the second argument, and is set up to read every 10-byte segment
    of the file.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加代码来创建一个`ByteBuffer`对象数组。为每个缓冲区分配`10`字节，然后使用一个缓冲区作为`read`方法的第一个参数和附件。将其用作附件，允许我们在完成处理程序中访问读操作的结果。第二个参数指定了起始读取位置，并设置为读取文件的每个10字节段。
- en: '[PRE32]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Add a call to the `awaitTermination` method to allow the read operations to
    complete. Then display the buffers a second time.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个调用`awaitTermination`方法，以允许读取操作完成。然后再次显示缓冲区。
- en: '[PRE33]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Use the following as the content of the `items.txt` file, where each entry
    is a 10-byte sequence consisting of an item and a quantity:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下内容作为`items.txt`文件的内容，其中每个条目都是一个包含商品和数量的10字节序列：
- en: '[PRE34]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Execute the application. Your output should be similar to the following:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您的输出应该类似于以下内容：
- en: '[PRE35]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice the use of three IDs for the completion handler threads. These correspond
    to the three threads created as part of the thread pool.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 注意完成处理程序线程的三个ID的使用。这些对应于作为线程池的一部分创建的三个线程。
- en: How it works...
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: A `java.util.concurrent` package's `ExecutorService` was created with a thread
    pool of size three to demonstrate the use of a thread group and to force the reuse
    of threads. The `items.txt` file contained data of equal lengths. This simplified
    the example.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大小为三的线程池创建了一个`java.util.concurrent`包的`ExecutorService`，以演示线程组的使用并强制重用线程。`items.txt`文件包含了相等长度的数据。这简化了示例。
- en: In the content handler, upon successful completion, the `completed` method was
    executed. The attachment contained the buffer `read`, which was then displayed
    along with the content handler's thread ID. Notice the use of the `synchronized`
    keyword for the `completed` method. While not always required for the method,
    it was used here, so that the output would be more readable. The removal of the
    keyword would result in an interleaving of the buffer's output, making it unreadable.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在内容处理程序中，成功完成后，将执行`completed`方法。附件包含了缓冲区`read`，然后与内容处理程序的线程ID一起显示。请注意`completed`方法中`synchronized`关键字的使用。虽然不是每个方法都需要，但在这里使用了，以使输出更易读。删除关键字将导致缓冲区输出交错，使其无法阅读。
- en: Notice the non-deterministic behavior of the completion handler threads. They
    did not execute in the order that the corresponding `read` methods were executed.
    Repeated execution of the application should produce differing output.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意完成处理程序线程的非确定性行为。它们并没有按照相应的`read`方法执行的顺序执行。重复执行应用程序应该产生不同的输出。
- en: Knowing that the input file contained only five items, we created five `ByteBuffer`
    objects each of size `10`. The `read` method was executed five times using a different
    buffer.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 知道输入文件只包含五个项目，我们创建了五个大小为`10`的`ByteBuffer`对象。`read`方法使用不同的缓冲区执行了五次。
- en: The `awaitTermination` method was executed, which effectively paused the application
    for a second. This allowed the completion handler's threads to complete. The buffers
    were then displayed a second time to verify the operation.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 执行了`awaitTermination`方法，有效地暂停了应用程序一秒钟。这允许完成处理程序的线程完成。然后再次显示缓冲区以验证操作。
- en: There's more...
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Whenever an asynchronous channel is created, it is assigned to a channel group.
    By defining your own group, you can exercise better control over the threads used
    in the group. When a channel is created using an `open` method, it belongs to
    a global channel group.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建一个异步通道时，它都被分配到一个通道组。通过定义自己的组，可以更好地控制组中使用的线程。使用`open`方法创建通道时，它属于全局通道组。
- en: An asynchronous channel group provides techniques needed for the completion
    of asynchronous IO operations that are bound to a group. Each group has a thread
    pool. These threads are used for the IO operations and `CompletionHandler` objects.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 异步通道组提供了完成绑定到组的异步IO操作所需的技术。每个组都有一个线程池。这些线程用于IO操作和`CompletionHandler`对象。
- en: 'In the previous example, we used the `open` method to associate a thread pool
    with the asynchronous operations. An asynchronous channel group can also be created
    using one of the following static `AsynchronousChannelGroup` methods:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们使用`open`方法将线程池与异步操作关联起来。也可以使用以下静态`AsynchronousChannelGroup`方法之一来创建异步通道组：
- en: '`withFixedThreadPool:` A fixed size pool that uses a `ThreadFactory` to create
    new threads. The size of the pool is specified by its first argument.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withFixedThreadPool:` 使用`ThreadFactory`创建新线程的固定大小池。池的大小由其第一个参数指定。'
- en: '`withCachedThreadPool:` This pool uses an `ExecutorService` to create new threads.
    The second argument specifies a suggested number of initial threads for the pool.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withCachedThreadPool:` 这个池使用`ExecutorService`来创建新线程。第二个参数指定了池的建议初始线程数。'
- en: '`withThreadPool:` This also uses an `ExecutorService`, but without an initial
    size specified.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withThreadPool:` 这也使用`ExecutorService`，但没有指定初始大小。'
- en: 'An asynchronous channel group provides the ability to perform an orderly shutdown
    of a group. Once the shutdown is initiated:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 异步通道组提供了对组进行有序关闭的能力。一旦关闭被启动：
- en: Its attempts to create a new channel result in a `ShutdownChannelGroupException`
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它尝试创建一个新通道的结果是`ShutdownChannelGroupException`
- en: Threads running completion handlers are not interrupted
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行完成处理程序的线程不会被中断
- en: 'A group terminates when:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 当组终止时：
- en: All of its channels are closed
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有通道都已关闭
- en: All completion handlers have run to completion
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有完成处理程序都已经完成
- en: All group resources have been released
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有组资源都已被释放
- en: 'Other methods of interest include:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 其他感兴趣的方法包括：
- en: The `isShutdown` method, which will determine if a group is shutdown or not.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isShutdown`方法，用于确定组是否已关闭。'
- en: The `isTerminated` method, which will determine if a group has been terminated.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isTerminated`方法，用于确定组是否已终止。'
- en: The `shutdownNow` method, which will force the shutdown of a group. All channels
    are closed but content handlers are not interrupted.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdownNow`方法，用于强制关闭组。所有通道都将关闭，但内容处理程序不会被中断。'
- en: See also
  id: totrans-334
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'In this chapter:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Writing to a file using the AsynchronousFileChannel class:* This recipe demonstrates
    how to perform asynchronous writes'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用AsynchronousFileChannel类写入文件：*此示例演示了如何执行异步写入'
- en: Using the SecureDirectoryStream class
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SecureDirectoryStream类
- en: The `java.nio.file` package's `SecureDirectoryStream` class is designed to be
    used with applications that depend on tighter security than that provided by other
    IO classes. It supports race-free (sequentially consistent) operations on a directory,
    where the operations are performed concurrently with other applications.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.nio.file`包的`SecureDirectoryStream`类设计用于与依赖于比其他IO类提供的更严格安全性的应用程序一起使用。它支持在目录上进行无竞争（顺序一致）操作，其中操作与其他应用程序同时进行。'
- en: This class requires support from the operating system. An instance of the class
    is obtained by casting the return value of the `Files` class' `newDirectoryStream`
    method to a `SecureDirectoryStream` object. If the cast fails, then the underlying
    operating system does not support this type of stream.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 该类需要操作系统的支持。通过将`Files`类的`newDirectoryStream`方法的返回值转换为`SecureDirectoryStream`对象来获取类的实例。如果转换失败，则底层操作系统不支持此类型的流。
- en: Getting ready
  id: totrans-340
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'To get and use a `SecureDirectoryStream` object:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 获取并使用`SecureDirectoryStream`对象：
- en: Create a `Path` object representing the directory of interest.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建表示感兴趣目录的`Path`对象。
- en: Use the `Files` class' `newDirectoryStream` method, and cast the result to a
    `SecureDirectoryStream`.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Files`类的`newDirectoryStream`方法，并将结果转换为`SecureDirectoryStream`。
- en: Use this object to affect `SecureDirectoryStream` operations.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此对象来影响`SecureDirectoryStream`操作。
- en: How to do it...
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new console application. In the `main` method, add the following code.
    We will create a `Path` object for the `docs` directory and then obtain a `SecureDirectoryStream`
    object for it. This will be used to view the POSIX permissions for the directory.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。在`main`方法中，添加以下代码。我们将为`docs`目录创建一个`Path`对象，然后获取一个`SecureDirectoryStream`对象。这将用于查看目录的POSIX权限。
- en: '[PRE36]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Execute the application on a system that supports the `SecureDirectoryStream`
    class. The following output was obtained by running the application on an Ubuntu
    system:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在支持`SecureDirectoryStream`类的系统上执行应用程序。在Ubuntu系统上运行应用程序后获得以下输出：
- en: '[PRE37]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: How it works...
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 工作原理...
- en: A `Path` object for the `docs` directory was obtained and then used as the argument
    of the `Files` class' `newDirectoryStream` method. The result of the method was
    cast to a `SecureDirectoryStream` class. The `getFileAttributeView` method was
    then executed to obtain a view, which was used to display the POSIX file permissions
    for the directory. The use of the `PosixFileAttributeView` class is discussed
    in the *Using the PosixFileAttributeView to maintain POSIX file attributes* recipe,
    in [Chapter 3](ch03.html "Chapter 3. Obtaining File and Directory Information"),
    *Obtaining File and Directory Information*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`docs`目录的`Path`对象，然后将其用作`Files`类的`newDirectoryStream`方法的参数。该方法的结果被转换为`SecureDirectoryStream`类。然后执行`getFileAttributeView`方法以获取一个视图，该视图用于显示目录的POSIX文件权限。`PosixFileAttributeView`类的使用在*使用PosixFileAttributeView维护POSIX文件属性*中有所讨论，在[第3章](ch03.html
    "第3章. 获取文件和目录信息") *获取文件和目录信息*。
- en: There's more...
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Other methods supported by the SecureDirectoryStream class include the ability
    to delete a file or directory, a move method to move a file to a different directory,
    and the creation of a `SeekableByteChannel` to access a file.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: SecureDirectoryStream类支持的其他方法包括删除文件或目录的能力，将文件移动到不同目录的移动方法，以及创建`SeekableByteChannel`以访问文件。
