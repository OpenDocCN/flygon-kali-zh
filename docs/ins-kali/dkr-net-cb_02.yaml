- en: Chapter 2. Configuring and Monitoring Docker Networks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 配置和监控Docker网络
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Verifying host-level settings that impact Docker networking
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证影响Docker网络的主机级设置
- en: Connecting containers in bridge mode
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在桥接模式下连接容器
- en: Exposing and publishing ports
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露和发布端口
- en: Connecting containers to existing containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接容器到现有容器
- en: Connecting containers in host mode
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机模式下连接容器
- en: Configuring service-level settings
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务级设置
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Docker makes consuming container technology easier than it's ever been before.
    Known for its ease of use, Docker offers many advanced features but installs with
    a sane set of defaults that make it easy to quickly start building containers.
    And while network configuration is typically the one area that requires additional
    attention before use, Docker makes it easy to get your containers up and on the
    network.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使得使用容器技术比以往任何时候都更容易。Docker以其易用性而闻名，提供了许多高级功能，但安装时使用了一组合理的默认设置，使得快速开始构建容器变得容易。虽然网络配置通常是需要在使用之前额外关注的一个领域，但Docker使得让容器上线并连接到网络变得容易。
- en: Verifying host-level settings that impact Docker networking
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证影响Docker网络的主机级设置
- en: Docker relies on the host being capable of performing certain functions to make
    Docker networking work. Namely, your Linux host must be configured to allow IP
    forwarding. In addition, since the release of Docker 1.7, you may now choose to
    use hairpin **Network Address Translation** (**NAT**) rather than the default
    Docker user land proxy. In this recipe, we'll review the requirement for the host
    to have IP forwarding enabled. We'll also talk about NAT hairpin and discuss the
    host-level requirements for that option as well. In both cases, we'll show Docker's
    default behavior with regard to its settings as well as how you can alter them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Docker依赖于主机能够执行某些功能来使Docker网络工作。换句话说，您的Linux主机必须配置为允许IP转发。此外，自Docker 1.7发布以来，您现在可以选择使用hairpin
    Network Address Translation（NAT）而不是默认的Docker用户空间代理。在本教程中，我们将回顾主机必须启用IP转发的要求。我们还将讨论NAT
    hairpin，并讨论该选项的主机级要求。在这两种情况下，我们将展示Docker对其设置的默认行为，以及您如何更改它们。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll need access to a Linux host running Docker and the ability to stop and
    restart the service. Since we'll be modifying system-level kernel parameters,
    you'll also need root-level access to the system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问运行Docker的Linux主机，并能够停止和重新启动服务。由于我们将修改系统级内核参数，您还需要对系统具有根级访问权限。
- en: How to do it…
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'As we saw in [Chapter 1](ch01.html "Chapter 1. Linux Networking Constructs"),
    *Linux Networking Constructs*, a Linux host must have IP forwarding enabled to
    be able to route traffic between interfaces. Since Docker does just that, IP forwarding
    must be enabled for Docker networking to function as desired. If Docker detects
    that IP forwarding is disabled, it will warn you of the issue when you attempt
    to run a container:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](ch01.html "第1章 Linux网络构造")中所看到的，Linux主机必须启用IP转发才能够在接口之间路由流量。由于Docker正是这样做的，因此Docker网络需要启用IP转发才能正常工作。如果Docker检测到IP转发被禁用，当您尝试运行容器时，它将警告您存在问题：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Most Linux distributions default the IP forward value to `disabled` or `0`.
    Fortunately for us, in a default configuration, Docker takes care of updating
    this setting to the correct value when the Docker service starts. For instance,
    let''s take a look at a freshly rebooted host that doesn''t have the Docker service
    enabled at boot time. If we check the value of the setting before starting Docker,
    we can see that it''s disabled. Starting the Docker engine automatically enables
    the setting for us:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Linux发行版将IP转发值默认为`disabled`或`0`。幸运的是，在默认配置中，Docker会在Docker服务启动时负责更新此设置为正确的值。例如，让我们看一个刚刚重启过并且没有在启动时启用Docker服务的主机。如果我们在启动Docker之前检查设置的值，我们会发现它是禁用的。启动Docker引擎会自动为我们启用该设置：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This default behavior in Docker can be changed by passing `--ip-forward=false`
    as a runtime option to the Docker service.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Docker中的这种默认行为可以通过在运行时选项中传递`--ip-forward=false`来更改为否。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The configuration of Docker-specific parameters varies widely based on the **init
    system** used. At the time of writing, many newer Linux operating systems use
    `systemd` as their init system. Always consult the Docker documentation to see
    its recommendation for service configuration based on the operating system you
    are using. Docker service configuration and options are talked about in greater
    detail as part of an upcoming recipe in this chapter. In this recipe, just focus
    on the impact changing these settings has on both Docker and the host itself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Docker特定参数的配置根据使用的**init系统**而有很大不同。在撰写本文时，许多较新的Linux操作系统使用`systemd`作为其init系统。始终请查阅Docker文档，以了解其针对您使用的操作系统的服务配置建议。Docker服务配置和选项将在本章的即将推出的食谱中更详细地讨论。在本食谱中，只需关注更改这些设置对Docker和主机本身的影响。
- en: Further discussion on the kernel IP forward parameter can be found in the recipe
    *Configuring Linux host routing* in [Chapter 1](ch01.html "Chapter 1. Linux Networking
    Constructs"), *Linux Networking Constructs*. There you'll find how to update the
    parameter yourself as well as how to make the setting persistent through reboots.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有关内核IP转发参数的进一步讨论可以在[第1章](ch01.html "第1章. Linux网络构造")的*配置Linux主机路由*食谱中找到，*Linux网络构造*。在那里，您将找到如何自己更新参数以及如何通过重新启动使设置持久化。
- en: 'Another recent feature of Docker that relies on a kernel-level parameter is
    the hairpin NAT functionality. Earlier versions of Docker implemented, and relied
    on, what''s known as the Docker **userland proxy** to facilitate intercontainer
    and published port communication. By default, any containers exposing ports did
    so through the userland proxy process. For instance, if we start an example container
    we can see that in addition to the Docker process itself, we also now have a `docker-proxy`
    process:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的另一个最近的功能依赖于内核级参数，即hairpin NAT功能。较早版本的Docker实现并依赖于所谓的Docker **用户态代理**来促进容器间和发布端口的通信。默认情况下，任何暴露端口的容器都是通过用户态代理进程来实现的。例如，如果我们启动一个示例容器，我们会发现除了Docker进程本身外，我们还有一个`docker-proxy`进程：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Every published port will start a new `docker-proxy` process on the Docker host.
    As an alternative to the userland proxy, you have the option to have Docker use
    hairpin NAT rather than userland proxies. Hairpin NAT relies on the host system
    being configured to enable routing on the host's local loopback interfaces. Again,
    the Docker service takes care of updating the correct host parameter to enable
    this functionality when the Docker service starts if it's told to do so.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个发布的端口都会在Docker主机上启动一个新的`docker-proxy`进程。作为用户态代理的替代方案，您可以选择让Docker使用hairpin
    NAT而不是用户态代理。Hairpin NAT依赖于主机系统配置为在主机的本地环回接口上启用路由。同样，当Docker服务启动时，Docker服务会负责更新正确的主机参数以启用此功能，如果被告知这样做的话。
- en: 'Hairpin NAT relies on the kernel parameter `net.ipv4.conf.docker0.route_localnet`
    being enabled (set to `1`) in order for the host machine to access container services
    through the hosts loopback interface. This can be achieved in the same way as
    we described with the IP forward parameter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Hairpin NAT依赖于内核参数`net.ipv4.conf.docker0.route_localnet`被启用（设置为`1`），以便主机可以通过主机的环回接口访问容器服务。这可以通过与我们描述IP转发参数的方式实现：
- en: 'Using the `sysctl` command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sysctl`命令：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'By querying the `/proc/` filesystem directly:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接查询`/proc/`文件系统：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the returned value is `0`, it's likely that Docker is in its default configuration
    and is relying on the userland proxy. Since you have the option to run Docker
    in either mode, we need to do more than change the kernel parameters in order
    to make the change to hairpin NAT. We also need to tell Docker to change the way
    it publishes ports by passing the option `--userland-proxy=false` as a runtime
    option to the Docker service. Doing so will enable hairpin NAT and also tell Docker
    to update the kernel parameter to the correct setting for hairpin NAT to work.
    Let's enable hairpin NAT to validate that Docker is doing what it should be doing.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回的值是`0`，那么Docker很可能处于其默认配置，并依赖于用户态代理。由于您可以选择在两种模式下运行Docker，我们需要做的不仅仅是更改内核参数，以便对hairpin
    NAT进行更改。我们还需要告诉Docker通过将选项`--userland-proxy=false`作为运行时选项传递给Docker服务来更改其发布端口的方式。这样做将启用hairpin
    NAT，并告诉Docker更新内核参数以使hairpin NAT正常工作。让我们启用hairpin NAT以验证Docker是否正在执行其应该执行的操作。
- en: 'First, let''s check the value of the kernel parameter:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们检查内核参数的值：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s currently disabled. Now we can tell Docker to disable the userland proxy
    by passing the `--userland-proxy=false` as a parameter to the Docker service.
    Once the Docker service is told to disable the userland proxy, and the service
    is restarted, we should see that the parameter is enabled on the host:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 它目前被禁用。现在我们可以告诉Docker通过将`--userland-proxy=false`作为参数传递给Docker服务来禁用用户态代理。一旦Docker服务被告知禁用用户态代理，并且服务被重新启动，我们应该看到参数在主机上被启用：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running a container with a mapped port at this point will not create additional
    `docker-proxy` process instances:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此时运行具有映射端口的容器将不会创建额外的`docker-proxy`进程实例：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In addition, we are still able to access the container through the host''s
    local interface:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们仍然可以通过主机的本地接口访问容器：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Disabling the parameter once again causes this connection to fail:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 再次禁用参数会导致此连接失败：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Connecting containers in bridge mode
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在桥接模式下连接容器
- en: As we mentioned earlier, Docker comes with a set of sensible defaults to get
    your containers communicating on the network. From a network perspective, the
    Docker default is to attach any spawned container to the `docker0` bridge. In
    this recipe, we'll show how to connect containers in the default bridge mode and
    explain how network traffic leaving and destined for the container is handled.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Docker带有一组合理的默认值，可以使您的容器在网络上进行通信。从网络的角度来看，Docker的默认设置是将任何生成的容器连接到`docker0`桥接器上。在本教程中，我们将展示如何在默认桥接模式下连接容器，并解释离开容器和目的地容器的网络流量是如何处理的。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'You''ll need access to a Docker host and an understanding of how your Docker
    host is connected to the network. In our example, we''ll be using a Docker host
    that has two physical network interfaces, like the one shown in the following
    diagram:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Docker主机，并了解您的Docker主机如何连接到网络。在我们的示例中，我们将使用一个具有两个物理网络接口的Docker主机，就像下图所示的那样：
- en: '![Getting ready](graphics/B05453_02_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![做好准备](graphics/B05453_02_01.jpg)'
- en: You'll want to make sure that you have access to view `iptables` rules to verify
    **netfilter** policies. If you wish to download and run example containers, your
    Docker host will also need access to the Internet. In some cases, the changes
    we make may require you to have root-level access to the system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要确保可以查看`iptables`规则以验证**netfilter**策略。如果您希望下载和运行示例容器，您的Docker主机还需要访问互联网。在某些情况下，我们所做的更改可能需要您具有系统的根级访问权限。
- en: How to do it…
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'After installing and starting Docker, you should notice the addition of a new
    Linux bridge named `docker0`. By default, the `docker0` bridge has an IP address
    of `172.17.0.1/16`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并启动Docker后，您应该注意到添加了一个名为`docker0`的新Linux桥。默认情况下，`docker0`桥的IP地址为`172.17.0.1/16`：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Docker will place any containers that are started without specifying a network
    on the `docker0` bridge. Now, let''s look at an example container running on this
    host:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将在未指定网络的情况下启动的任何容器放置在`docker0`桥上。现在，让我们看一个在此主机上运行的示例容器：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By running the container in interactive mode, we can examine what the container
    believes its network configuration to be. In this case, we can see that the container
    has a single non-loopback network adapter (`eth0`) with an IP address of `172.17.0.2/16`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以交互模式运行容器，我们可以查看容器认为自己的网络配置是什么。在这种情况下，我们可以看到容器有一个非回环网络适配器（`eth0`），IP地址为`172.17.0.2/16`。
- en: 'In addition, we can see that the container believes its default gateway is
    the `docker0` bridge interface on the Docker host:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以看到容器认为其默认网关是Docker主机上的`docker0`桥接口：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By running some basic tests, we can see that the container has access to physical
    interface of the Docker host as well as Internet-based resources.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行一些基本测试，我们可以看到容器可以访问Docker主机的物理接口以及基于互联网的资源。
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Internet-based access for the container itself is predicated on the fact that
    the Docker host has access to the Internet.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 基于互联网的访问容器本身的前提是Docker主机可以访问互联网。
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Given that the network the container lives on was created by Docker, we can
    safely assume that the rest of network is not aware of it. That is, the outside
    network has no knowledge of the `172.17.0.0/16` network since it''s local to the
    Docker host. That being said, it seems curious that the container is able to reach
    resources that live beyond the `docker0` bridge. Docker makes this work by hiding
    container''s IP addresses behind the Docker host''s IP interfaces. The traffic
    flow is shown in the following image:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到容器所在的网络是由Docker创建的，我们可以安全地假设网络的其余部分不知道它。也就是说，外部网络不知道`172.17.0.0/16`网络，因为它是本地的Docker主机。也就是说，容器能够访问`docker0`桥之外的资源似乎有些奇怪。Docker通过将容器的IP地址隐藏在Docker主机的IP接口后使其工作。流量流向如下图所示：
- en: '![How to do it…](graphics/B05453_02_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_02_02.jpg)'
- en: 'Since the containers'' traffic is seen on the physical network as the Docker
    host''s IP address, other network resources know how to return the traffic to
    the container. To perform this outbound NAT, Docker uses the Linux netfilter framework.
    We can see these rules using the netfilter command-line tool `iptables`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器的流量在物理网络上被视为Docker主机的IP地址，其他网络资源知道如何将流量返回到容器。为了执行这种出站NAT，Docker使用Linux netfilter框架。我们可以使用netfilter命令行工具`iptables`来查看这些规则：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, we have a rule in the `POSTROUTING` chain that masquerades or
    hides, anything sourced from our `docker0` bridge (`172.17.0.0/16`) behind the
    host's interface.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在`POSTROUTING`链中有一个规则，它将来自我们的`docker0`桥（`172.17.0.0/16`）的任何东西伪装或隐藏在主机接口的背后。
- en: 'Although outbound connectivity is configured and allowed by default, Docker
    does not by default provide a means to access services in the containers from
    outside the Docker host. In order to do this, we must pass Docker additional flags
    at container runtime. Specifically, we can pass the `-P` flag when we run the
    container. To examine this behavior, let''s look at a container image that exposes
    a port:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管出站连接是默认配置和允许的，但Docker默认情况下不提供一种从Docker主机外部访问容器中的服务的方法。为了做到这一点，我们必须在容器运行时传递额外的标志给Docker。具体来说，当我们运行容器时，我们可以传递`-P`标志。为了检查这种行为，让我们看一个暴露端口的容器镜像：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This tells Docker to map a random port to any ports that the container image
    exposes. In the case of this demo container, the image exposes port `80`. After
    running the container, we can see the host port mapped to the container:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Docker将一个随机端口映射到容器镜像暴露的任何端口。在这个演示容器的情况下，镜像暴露端口`80`。运行容器后，我们可以看到主机端口映射到容器：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see, the containers port `80` has been mapped to host port `32768`.
    This means that we can access the service running on port `80` of the container
    through the host''s interfaces at port `32768`. Much like the outbound container
    access, inbound connectivity also uses netfilter to create the port mapping. We
    can see this by checking the NAT and filter table:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，容器端口`80`已经映射到主机端口`32768`。这意味着我们可以通过主机的接口在端口`32768`上访问容器上运行的端口`80`的服务。与出站容器访问类似，入站连接也使用netfilter来创建端口映射。我们可以通过检查NAT和过滤表来看到这一点：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since the connectivity is being exposed on all interfaces (`0.0.0.0`), our
    inbound diagram will look like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于连接在所有接口（`0.0.0.0`）上暴露，我们的入站图将如下所示：
- en: '![How to do it…](graphics/B05453_02_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B05453_02_03.jpg)'
- en: If not defined otherwise containers that live on the same host, and hence the
    same `docker0` bridge, can inherently communicate with each other by their assigned
    IP address on any port, which is bound to a service. Allowing this communication
    is the default behavior and can be changed as we'll see in a later chapters when
    we discuss **Inter-Container Communication** (**ICC**) configuration.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有另行定义，生活在同一主机上的容器，因此是相同的`docker0`桥，可以通过它们分配的IP地址在任何端口上固有地相互通信，这些端口绑定到服务。允许这种通信是默认行为，并且可以在后面的章节中更改，当我们讨论**容器间通信**（**ICC**）配置时会看到。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It should be noted that this is the default behavior for containers that are
    run without specifying any additional network parameters, that is, containers
    that use the Docker default bridge network. Later chapters will introduce other
    options that allow you to place containers living on the same host on different
    networks.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，这是在没有指定任何额外网络参数的情况下运行的容器的默认行为，也就是说，使用Docker默认桥接网络的容器。后面的章节将介绍其他选项，允许您将生活在同一主机上的容器放置在不同的网络上。
- en: 'Communication between containers that live on different hosts requires using
    a combination of both the previously discussed flows. To test this out, let''s
    expand our lab by adding a second host named `docker2`. Let''s assume container
    `web2` on the host `docker2` wishes to access the container `web1` living on host
    `docker1`, which is hosting a service on port `80`. The flow will look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 生活在不同主机上的容器之间的通信需要使用先前讨论的流程的组合。为了测试这一点，让我们通过添加一个名为`docker2`的第二个主机来扩展我们的实验。假设主机`docker2`上的容器`web2`希望访问主机`docker1`上的容器`web1`，后者在端口`80`上托管服务。流程将如下所示：
- en: '![How to do it…](graphics/B05453_02_04.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B05453_02_04.jpg)'
- en: Let's walk through the flow at each step and show what the packets look like
    as they hit the wire in each step. In this case, the container `web1` is exposing
    port `80`, which has been published to port `32771` on the host `docker1`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在每个步骤中走一遍流程，并展示数据包在每个步骤中传输时的样子。在这种情况下，容器`web1`正在暴露端口`80`，该端口已发布到主机`docker1`的端口`32771`。
- en: Traffic leaves the container `web2` destined for the exposed port (`32771`)
    on the `10.10.10.101` interface of host `docker1`:![How to do it…](graphics/B05453_02_05.jpg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流量离开容器`web2`，目的地是主机`docker1`的`10.10.10.101`接口上的暴露端口（`32771`）：![操作步骤…](graphics/B05453_02_05.jpg)
- en: Traffic arrives at the container's default gateway, which is the IP interface
    of the `docker0` bridge (`172.17.0.1`). The host does a route lookup and determines
    that the destination lives out of its `10.10.10.102` interface, so it hides the
    container's real source IP behind that interface's IP address:![How to do it…](graphics/B05453_02_06.jpg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流量到达容器的默认网关，即`docker0`桥接的IP接口（`172.17.0.1`）。主机进行路由查找，并确定目的地位于其`10.10.10.102`接口之外，因此它将容器的真实源IP隐藏在该接口的IP地址后面：![操作步骤…](graphics/B05453_02_06.jpg)
- en: Traffic arrives at the `docker1` host and is examined by the netfilter rules.
    `docker1` has a rule that exposes the service port of container 1 (`80`) on port
    `32271` of the host:![How to do it…](graphics/B05453_02_07.jpg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 流量到达`docker1`主机，并由netfilter规则检查。`docker1`有一个规则，将容器1的服务端口（`80`）暴露在主机的端口`32271`上：![操作步骤…](graphics/B05453_02_07.jpg)
- en: The destination port is changed from `32771` to `80` and passed along to the
    `web1` container, which receives the traffic on the correct port `80`:![How to
    do it…](graphics/B05453_02_08.jpg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标端口从`32771`更改为`80`，并传递到`web1`容器，该容器在正确的端口`80`上接收流量：![操作步骤…](graphics/B05453_02_08.jpg)
- en: 'To try this out for ourselves, let''s first run the `web1` container and check
    what port the service is exposed on:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自己尝试一下，让我们首先运行`web1`容器并检查服务暴露在哪个端口上：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now let's run a second container called web2 on the host docker2 and attempt
    to access web1's service on port 32771…
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在主机docker2上运行一个名为web2的第二个容器，并尝试访问端口32771上的web1服务…
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Exposing and publishing ports
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露和发布端口
- en: As we've seen in the previous examples, exposing services living in containers
    to the outside world is a critical component of Docker. Up until this point, we've
    let the images and the Docker engine do the heavy lifting for us in terms of the
    actual port mapping. To do this, Docker uses a combination of metadata from container
    images as well as a built-in system for tracking port allocations. In this recipe,
    we'll walk through the process for defining ports to be exposed as well as options
    for publishing ports.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的例子中看到的，将容器中的服务暴露给外部世界是Docker的一个关键组成部分。到目前为止，我们已经让镜像和Docker引擎在实际端口映射方面为我们做了大部分工作。为了做到这一点，Docker使用了容器镜像的元数据以及用于跟踪端口分配的内置系统的组合。在这个示例中，我们将介绍定义要暴露的端口以及发布端口的选项的过程。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll need access to a Docker host and an understanding of how your Docker
    host is connected to the network. In this recipe, we'll be using the `docker1`
    host that we used in previous recipes. You'll want to make sure that you have
    access to view `iptables` rules to verify netfilter policies. If you wish to download
    and run example containers, your Docker host will also need access to the Internet.
    In some cases, the changes we make may require you to have root-level access to
    the system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问一个Docker主机，并了解您的Docker主机如何连接到网络。在这个示例中，我们将使用之前示例中使用的`docker1`主机。您需要确保可以查看`iptables`规则以验证netfilter策略。如果您希望下载和运行示例容器，您的Docker主机还需要访问互联网。在某些情况下，我们所做的更改可能需要您具有系统的root级别访问权限。
- en: How to do it…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: While often confused, exposing ports and publishing ports are two totally different
    actions. Exposing ports is really just a way of documenting what ports a container
    might offer services on. These definitions are stored in the container metadata
    as part of the image and can be read by the Docker engine. Publishing ports is
    the actual process of mapping a container port to a host port. This can either
    be done automatically using the exposed port definitions, or it can be done manually
    without the use of exposed ports.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然经常混淆，但暴露端口和发布端口是两个完全不同的操作。暴露端口实际上只是一种记录容器可能提供服务的端口的方式。这些定义存储在容器元数据中作为镜像的一部分，并可以被Docker引擎读取。发布端口是将容器端口映射到主机端口的实际过程。这可以通过使用暴露的端口定义自动完成，也可以在不使用暴露端口的情况下手动完成。
- en: 'Let''s first discuss how ports are exposed. The most common mechanism for exposing
    ports is to define them in an image''s **Dockerfile**. When you build a container
    image, you''re given the opportunity to define ports to be exposed. Consider this
    Dockerfile definition that I used to build some of the demo containers for this
    book:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论端口是如何暴露的。暴露端口的最常见机制是在镜像的**Dockerfile**中定义它们。当您构建一个容器镜像时，您有机会定义要暴露的端口。考虑一下我用来构建本书一些演示容器的Dockerfile定义：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As part of the Dockerfile, I can define ports I wish to expose. In this case,
    I know that Apache will, by default, offer its web server on port `80` so that's
    the port I wish to expose.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Dockerfile的一部分，我可以定义我希望暴露的端口。在这种情况下，我知道Apache默认会在端口`80`上提供其Web服务器，所以这是我希望暴露的端口。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, by default, Docker always assumes the ports you're referring to are
    TCP. If you wish to expose UDP ports, you can do so by including the `/udp` flag
    at the end of the port definition. For instance, `EXPOSE 80/udp`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，Docker始终假定您所指的端口是TCP。如果您希望暴露UDP端口，可以在端口定义的末尾包括`/udp`标志来实现。例如，`EXPOSE
    80/udp`。
- en: 'Now, let''s run a container built with this Dockerfile to see what happens:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行一个使用这个Dockerfile构建的容器，看看会发生什么：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As we can see, despite having a defined port to expose, Docker has not actually
    mapped any ports between the host and the container. If you recall from earlier
    recipe where a container provided a service, we included the `-P` flag in the
    `docker run` command syntax. The `-P` flag tells Docker to publish all exposed
    ports. Let''s try running this container with the `-P` flag set:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，尽管有一个定义的要暴露的端口，Docker实际上并没有在主机和容器之间映射任何端口。如果您回忆一下之前的示例，其中容器提供了一个服务，我们在`docker
    run`命令语法中包含了`-P`标志。`-P`标志告诉Docker发布所有暴露的端口。让我们尝试使用设置了`-P`标志的容器运行此容器：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we can see that Docker has now automatically mapped the exposed port to
    a random high port on the host. Port `80` will now be considered published.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到Docker现在已经自动将暴露的端口映射到主机上的一个随机高端口。端口`80`现在将被视为已发布。
- en: 'In addition to exposing ports through the image Dockerfile, we can also expose
    them at container runtime. Any ports that are exposed in this manner are combined
    with the ports exposed in the Dockerfile. For example, let''s run the same container
    again and expose port `80` UDP as part of the `docker run` command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过镜像Dockerfile暴露端口，我们还可以在容器运行时暴露它们。以这种方式暴露的任何端口都将与Dockerfile中暴露的端口合并。例如，让我们再次运行相同的容器，并在`docker
    run`命令中暴露端口`80` UDP：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, we have published not only the port from the Dockerfile (`80/tcp`)
    but also the port from the `docker run` command (`80/udp`).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不仅发布了来自Dockerfile的端口（`80/tcp`），还发布了来自`docker run`命令的端口（`80/udp`）。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Exposing ports at container runtime allows you some extra flexibility as you
    can define port ranges to be exposed. This is not currently possible during image
    creation with the Dockerfile `expose` syntax. When exposing a wide range of ports,
    you can filter the output of the `docker port` command by adding the container
    port you are looking for to the end of the command.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器运行时暴露端口允许您有一些额外的灵活性，因为您可以定义要暴露的端口范围。这在Dockerfile的`expose`语法中目前是不可能的。当暴露一系列端口时，您可以通过在命令的末尾添加您要查找的容器端口来过滤`docker
    port`命令的输出。
- en: 'While the expose method is certainly handy, it doesn''t solve all of our needs.
    For cases where you want more control over ports and interfaces used, you can
    bypass `expose` and directly publish ports when starting a container. While passing
    the `-P` flag publishes all exposed ports, passing the `-p` flag allows you to
    specify specific ports and interfaces to use when mapping ports. The `-p` flag
    can take several different forms with the syntax looking like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然暴露方法确实很方便，但它并不能满足我们所有的需求。对于您想要更多控制使用的端口和接口的情况，您可以在启动容器时绕过`expose`并直接发布端口。通过传递`-P`标志发布所有暴露的端口，通过传递`-p`标志允许您指定映射端口时要使用的特定端口和接口。`-p`标志可以采用几种不同的形式，语法看起来像这样：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Any of the options may be omitted with the only required field being the container
    port. For example, here are a couple of different ways you could use this syntax:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 任何选项都可以省略，唯一需要的字段是容器端口。例如，以下是您可以使用此语法的几种不同方式：
- en: 'Specify the host port and container port:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定主机端口和容器端口：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Specify the host interface, host port, and container port:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定主机接口、主机端口和容器端口：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Specify the host interface, have Docker choose a random host port, and specify
    the container port:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定主机接口，让Docker选择一个随机的主机端口，并指定容器端口：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Specify only a container port and have Docker use a random host port:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只指定一个容器端口，让Docker使用一个随机的主机端口：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All the published ports we've seen up until this point have used a destination
    IP address of (`0.0.0.0`), which means that they are bound to all IP interfaces
    of the Docker host. By default, the Docker service always binds published ports
    to all host interfaces. However, as we'll see in the following recipe of this
    chapter, we can tell Docker to use a specific interface by passing the Docker
    service the `--ip` parameter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的所有发布的端口都使用了目标IP地址（`0.0.0.0`），这意味着它们绑定到Docker主机的所有IP接口。默认情况下，Docker服务始终将发布的端口绑定到所有主机接口。然而，正如我们将在本章的下一个示例中看到的那样，我们可以告诉Docker通过传递`--ip`参数来使用特定的接口。
- en: 'Given that we can also define which interface to bind published ports to as
    part of the `docker run` command, we need to know which option takes priority.
    The general rule is that any option defined at container runtime wins. For instance,
    let''s look at an example where we tell the Docker service to bind to the `192.168.10.101`
    IP address of the `docker1` host by passing the following option to the service:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们还可以在`docker run`命令中定义要绑定的发布端口的接口，我们需要知道哪个选项优先级更高。一般规则是，在容器运行时定义的任何选项都会获胜。例如，让我们看一个例子，我们告诉Docker服务通过向服务传递以下选项来绑定到`docker1`主机的`192.168.10.101`
    IP地址：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let''s run a container in a couple of different ways and see the outcome:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们以几种不同的方式运行一个容器，并查看结果：
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding example, we see the expected behavior. Ports that are published
    are bound to the IP address specified in the service level `--ip` option (`10.10.10.101`).
    However, if we specify an IP address at container runtime, we can override the
    service-level settings:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了预期的行为。发布的端口绑定到服务级别`--ip`选项（`10.10.10.101`）中指定的IP地址。然而，如果我们在容器运行时指定IP地址，我们可以覆盖服务级别的设置：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It''s possible that you won''t find a use for exposed ports and instead rely
    solely on manually publishing them. The `EXPOSE` command is not a requirement
    of the Dockerfile for image creation. Container images that don''t define an exposed
    port can be directly published as shown in the following commands:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不会发现暴露端口的用途，而是完全依赖手动发布它们。`EXPOSE`命令不是创建镜像的Dockerfile的要求。不定义暴露端口的容器镜像可以直接发布，如以下命令所示：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding example, the container image `jonlangemak/web_server_noexpose`
    is a container that does not expose any ports as part of its definition.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，容器镜像`jonlangemak/web_server_noexpose`是一个不在其定义中暴露任何端口的容器。
- en: Connecting containers to existing containers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接容器到现有容器
- en: Docker network connectivity up until this point has relied on exposing individual
    services hosted in a container to the physical network. However, what if you want
    to expose a service from one container to another without exposing it to the Docker
    host? In this recipe we'll walk through how to map services between two containers
    running on the same Docker host.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Docker网络连接依赖于将托管在容器中的单个服务暴露给物理网络。但是，如果您想将一个容器中的服务暴露给另一个容器而不暴露给Docker主机怎么办？在本教程中，我们将介绍如何在同一Docker主机上运行的两个容器之间映射服务。
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll need access to a Docker host and an understanding of how your Docker
    host is connected to the network. In this recipe, we'll be using the `docker1`
    host that we used in previous recipes. You'll want to make sure that you have
    access to view `iptables` rules to verify netfilter policies. If you wish to download
    and run example containers, your Docker host will also need access to the Internet.
    In some cases, the changes we make may require you to have root-level access to
    the system.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您将需要访问Docker主机，并了解您的Docker主机如何连接到网络。在本教程中，我们将使用之前教程中使用过的`docker1`主机。您需要确保可以访问`iptables`规则以验证netfilter策略。如果您希望下载和运行示例容器，您的Docker主机还需要访问互联网。在某些情况下，我们所做的更改可能需要您具有系统的根级访问权限。
- en: How to do it…
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Mapping services from one container to another is sometimes referred to as
    mapped container mode. Mapped container mode allows you to start a container that
    utilizes an existing, or primary, container''s network configuration. That is,
    a mapped container will use the same IP and port configuration as the primary
    container. For the sake of example, let''s consider running the following container:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将一个容器中的服务映射到另一个容器中被称为映射容器模式。映射容器模式允许您启动一个利用现有或主要容器网络配置的容器。也就是说，映射容器将使用与主容器相同的IP和端口配置。举个例子，让我们考虑运行以下容器：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Running this container starts the container in bridge mode and attaches it to
    the `docker0` bridge as we would expect.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此容器将以桥接模式启动容器，并将其附加到`docker0`桥接，正如我们所期望的那样。
- en: 'The topology will look pretty standard at this point, something like what is
    shown in the following topology:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，拓扑看起来非常标准，类似于以下拓扑所示：
- en: '![How to do it…](graphics/B05453_02_09.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B05453_02_09.jpg)'
- en: 'Now run a second container on the same host, but this time specify that the
    network should be that of the primary container `web4`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在同一主机上运行第二个容器，但这次指定网络应该是主容器`web4`的网络：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Our topology now looks as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的拓扑现在如下所示：
- en: '![How to do it…](graphics/B05453_02_10.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/B05453_02_10.jpg)'
- en: 'Note how the container `web3` is now depicted as being attached directly to
    `web4` rather than to the `docker0` bridge. By looking at the networking configuration
    of each container, we can validate that this is actually the case:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，容器`web3`现在被描述为直接连接到`web4`，而不是`docker0`桥接。通过查看每个容器的网络配置，我们可以验证这是否属实：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As we can see, the interfaces are identical both in IP configuration as well
    as MAC addresses. Using the syntax of `--net:container<container name/ID>` in
    the `docker run` command joins the new container to the same network construct
    that the referenced container is in. This means that the mapped container has
    the same network configuration as the primary container.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，接口在IP配置和MAC地址方面都是相同的。在`docker run`命令中使用`--net:container<container name/ID>`的语法将新容器加入到与所引用容器相同的网络结构中。这意味着映射的容器具有与主容器相同的网络配置。
- en: 'There is a limitation to this configuration that is worth noting. A container
    that joins another container''s network cannot publish any of its own ports. So
    while this means that we can''t publish ports of mapped containers to the host,
    we can consume them locally. Going back to our example, this means that we can''t
    publish port `8080` of container `web3` to the host. However, container `web4`
    can consume nonpublished services of the container `web3` locally. For instance,
    each of the containers in this example hosts a web service:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置有一个值得注意的限制。加入另一个容器网络的容器无法发布自己的任何端口。因此，这意味着我们无法将映射容器的端口发布到主机，但我们可以在本地使用它们。回到我们的例子，这意味着我们无法将容器`web3`的端口`8080`发布到主机。但是，容器`web4`可以在本地使用容器`web3`的未发布服务。例如，这个例子中的每个容器都托管一个Web服务：
- en: '`web3` hosts a web server running on port `8080`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web3`托管在端口`8080`上运行的Web服务器'
- en: '`web4` hosts a web server running on port `80`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`web4`托管在端口`80`上运行的Web服务器'
- en: 'From an external host perspective, there is no way to access the web service
    of the container `web3`. We can however, access these services through the container
    `web4`. The container `web4` is hosting a PHP script named `test.php` that pulls
    the index pages of its own web server as well as that of a web server running
    on port `8080`. The script is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部主机的角度来看，无法访问容器`web3`的Web服务。但是，我们可以通过容器`web4`访问这些服务。容器`web4`托管一个名为`test.php`的PHP脚本，该脚本提取其自己的Web服务器以及在端口`8080`上运行的Web服务器的索引页面。脚本如下：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The script lives in the web server''s root hosting directory (`/var/www/`),
    so we can access the port by browsing to the `web4` container''s published port
    followed by `test.php`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本位于Web服务器的根托管目录（`/var/www/`）中，因此我们可以通过浏览`web4`容器的发布端口，然后跟上`test.php`来访问端口：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see, the script is able to pull the index page from both containers.
    Let''s stop the container `web3` and run this test again to prove that it''s really
    the one providing this index page response:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，脚本能够从两个容器中提取索引页面。让我们停止容器`web3`，然后再次运行此测试，以证明它确实是提供此索引页面响应的容器：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, we no longer get the response from the mapped container. Mapped
    container mode is useful for scenarios where you need to provide a service to
    an existing container, but don't need to publish any of the mapped container's
    ports directly to the Docker host or outside network. Although there is a limitation
    that mapped containers cannot publish any of their own ports, this does not mean
    we can't publish them ahead of time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不再从映射的容器中获得响应。映射容器模式对于需要向现有容器提供服务但不需要直接将映射容器的任何端口发布到Docker主机或外部网络的情况非常有用。尽管映射容器无法发布自己的任何端口，但这并不意味着我们不能提前发布它们。
- en: 'For instance, we could expose port `8080` when we run the primary container:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们运行主容器时，我们可以暴露端口`8080`：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Because we published the port for the mapped container when we ran the primary
    container (`web4`), we don''t need to publish it when we run our mapped container
    (`web3`). We should now be able to access each service directly through its published
    port:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在运行主容器（`web4`）时发布了映射容器的端口，所以在运行映射容器（`web3`）时就不需要再次发布它。现在我们应该能够通过其发布的端口直接访问每个服务：
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Care should be taken in mapped container mode to not attempt to expose or publish
    the same port on different containers. Since the mapped containers share the same
    network construct as the primary container, this would cause a port conflict.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射容器模式下，应注意不要尝试在不同的容器上公开或发布相同的端口。由于映射容器与主容器共享相同的网络结构，这将导致端口冲突。
- en: Connecting containers in host mode
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在主机模式下连接容器
- en: All the configurations we have done up until this point have relied on using
    the `docker0` bridge to facilitate connectivity between containers. We've had
    to consider port mappings, NATing, and container connection points. These considerations
    had to be made because of the nature of how we connect and address containers
    and to ensure a flexible deployment model. Host mode takes a different approach
    and binds containers directly to the Docker host's interfaces. This not only removes
    the need for inbound and outbound NAT but also restricts how we can deploy containers.
    Since the containers will be in the same network construct as the physical host,
    we cannot overlap service ports as this would cause a conflict. In this recipe,
    we'll walk through deploying a container in host mode and describe the pros and
    cons of this approach.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的所有配置都依赖于使用`docker0`桥来促进容器之间的连接。我们不得不考虑端口映射、NAT和容器连接点。由于我们连接和寻址容器的方式的性质以及确保灵活的部署模型，必须考虑这些因素。主机模式采用了一种不同的方法，直接将容器绑定到Docker主机的接口上。这不仅消除了入站和出站NAT的需要，还限制了我们可以部署容器的方式。由于容器将位于与物理主机相同的网络结构中，我们不能重叠服务端口，因为这将导致冲突。在本教程中，我们将介绍在主机模式下部署容器，并描述这种方法的优缺点。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll need access to a Docker host and an understanding of how your Docker
    host is connected to the network. In this recipe, we'll be using the `docker1`
    and `docker2` hosts that we used in previous recipes. You'll want to make sure
    that you have access to view `iptables` rules to verify netfilter policies. If
    you wish to download and run example containers, your Docker host will also need
    access to the Internet. In some cases, the changes we make may require you to
    have root-level access to the system.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问一个Docker主机，并了解您的Docker主机如何连接到网络。在本教程中，我们将使用之前教程中使用过的`docker1`和`docker2`主机。您需要确保可以查看`iptables`规则以验证netfilter策略。如果您希望下载和运行示例容器，您的Docker主机还需要访问互联网。在某些情况下，我们所做的更改可能需要您具有系统的根级访问权限。
- en: How to do it…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Deploying containers in this mode is rather easy from a Docker point of view.
    Much like mapped container mode where we put one container into another's network
    construct; host mode puts a container directly into the Docker host's network
    construct. Ports no longer need to be published and exposed since you're mapping
    the container directly onto the host's network interfaces. This means that container
    processes can do certain privileged actions such as open lower level ports on
    the host. For this reason, this option should be used with caution as the container
    will have more access to the system in this configuration.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 从Docker的角度来看，在这种模式下部署容器相当容易。就像映射容器模式一样，我们将一个容器放入另一个容器的网络结构中；主机模式直接将一个容器放入Docker主机的网络结构中。不再需要发布和暴露端口，因为你将容器直接映射到主机的网络接口上。这意味着容器进程可以执行某些特权操作，比如在主机上打开较低级别的端口。因此，这个选项应该谨慎使用，因为在这种配置下容器将对系统有更多的访问权限。
- en: 'This also means that Docker is not aware of what port your container is using
    and is unable to prevent you from deploying containers that have overlapping ports.
    Let''s deploy a test container in host mode, so you can see what I mean:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着Docker不知道你的容器在使用什么端口，并且无法阻止你部署具有重叠端口的容器。让我们在主机模式下部署一个测试容器，这样你就能明白我的意思了：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To achieve host mode, we pass the `--net=host` flag at container runtime. In
    this case, you can see that without any port mapping, we can still access the
    service living in the container. Docker is simply binding the container to the
    Docker host, which means that any services the container offers are automatically
    mapped to the Docker host's interfaces.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用主机模式，我们在容器运行时传递`--net=host`标志。在这种情况下，你可以看到没有任何端口映射，我们仍然可以访问容器中的服务。Docker只是将容器绑定到Docker主机，这意味着容器提供的任何服务都会自动映射到Docker主机的接口上。
- en: 'If we try to run another container offering services on port `80`, we''ll see
    that Docker doesn''t try and stop us:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在端口`80`上运行另一个提供服务的容器，我们会发现Docker并不会阻止我们：
- en: '[PRE42]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'While that looks like a successful container start from a Docker perspective,
    the container actually died right after being spawned. If we check the logs for
    container `web2`, we''ll see that it ran into a conflict and was unable to start:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从Docker的角度来看，这看起来像是一个成功的容器启动，但实际上容器在被生成后立即死掉了。如果我们检查容器`web2`的日志，我们会发现它遇到了冲突，无法启动：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Deploying containers in host mode limits the number of services you can run
    unless your containers are built to offer the same service on different ports.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机模式下部署容器会限制你可以运行的服务数量，除非你的容器被构建为在不同端口上提供相同的服务。
- en: 'Since the configuration of the service and what ports it consumes are the responsibility
    of the container, there is a means by which we can deploy multiple containers
    each using the same service port. Take for example our earlier example of two
    Docker hosts, each with two network interfaces:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务的配置和它所使用的端口是容器的责任，我们可以通过一种方式部署多个使用相同服务端口的容器。举个例子，我们之前提到的两个Docker主机，每个主机有两个网络接口：
- en: '![How to do it…](graphics/B05453_02_11.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_02_11.jpg)'
- en: In a scenario where your Docker host has multiple network interfaces, you can
    have containers binding to the same port but on different interfaces. Again, since
    this is the responsibility of the container, Docker doesn't have any visibility
    into how you achieve this as long as you don't try to bind the same port to multiple
    interfaces.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个场景中，你的Docker主机有多个网络接口，你可以让容器绑定到不同接口上的相同端口。同样，由于这是容器的责任，只要你不尝试将相同的端口绑定到多个接口上，Docker就不会知道你是如何实现这一点的。
- en: 'The solution is to change how services bind to the interfaces. Most services
    bind to all interfaces (`0.0.0.0`) when the service starts. For instance, we can
    see that our container `web1` is bound to `0.0.0.0:80` on the Docker host:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是更改服务绑定到接口的方式。大多数服务在启动时绑定到所有接口（`0.0.0.0`）。例如，我们可以看到我们的容器`web1`绑定到Docker主机上的`0.0.0.0:80`：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Rather than having the service bind to all interfaces, we can limit the scope
    of the service by having it bind to a specific interface. If we can bind a container
    service to only one interface, we can bind the same port to a different interface
    without causing conflict. For the purpose of this example, I''ve created two container
    images that allow you to pass them an environmental variable (`$APACHE_IPADDRESS`).
    The variable is referenced in the Apache configuration and specifies which interface
    the service should bind to. We can test this by deploying two containers in host
    mode to the same host:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以限制服务的范围，而不是让服务绑定到所有接口。如果我们可以将容器服务绑定到一个接口，我们就可以将相同的端口绑定到不同的接口而不会引起冲突。在这个例子中，我创建了两个容器镜像，允许您向它们传递一个环境变量（`$APACHE_IPADDRESS`）。该变量在Apache配置中被引用，并指定服务应该绑定到哪个接口。我们可以通过在主机模式下部署两个容器来测试这一点：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that in each case, I pass the container a different IP address for it
    to bind to. A quick look at port bindings on the host should confirm the containers
    are no longer binding to all interfaces:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在每种情况下，我都会向容器传递一个不同的IP地址，以便它绑定到。快速查看主机上的端口绑定应该可以确认容器不再绑定到所有接口：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Note that Apache is no longer binding to all interfaces and that we have two
    Apache processes, one bound to each interface of the Docker host. A test from
    the other Docker host will prove that each container is serving Apache on its
    respective interface:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Apache不再绑定到所有接口，我们有两个Apache进程，一个绑定到Docker主机的每个接口。来自另一个Docker主机的测试将证明每个容器在其各自的接口上提供Apache：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: While there are some limitations to host mode, it is also less complicated and
    likely offers higher performance because of the lack of NAT and the use of the
    `docker0` bridge.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然主机模式有一些限制，但它也更简单，可能因为缺乏NAT和使用`docker0`桥而提供更高的性能。
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that since Docker isn't involved in host mode that you may need
    to manually open firewall ports if you have a host-based firewall that is enforcing
    policy in order for the containers to be reachable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于Docker不涉及主机模式，如果您有一个基于主机的防火墙来执行策略，您可能需要手动打开防火墙端口，以便容器可以被访问。
- en: Configuring service-level settings
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务级设置
- en: While many settings can be configured at container runtime, there are some settings
    that must be configured as part of starting the Docker service. That is, they
    need to be defined as a Docker option in the service configuration. In earlier
    recipes, we were exposed to some of these service-level options, such as `--ip-forward`,
    `--userland-proxy`, and `--ip`. In this recipe, we'll cover how you can pass service-level
    parameters to the Docker service as well as discuss the functionality of a few
    key parameters.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多设置可以在容器运行时配置，但有一些设置必须作为启动Docker服务的一部分进行配置。也就是说，它们需要在服务配置中定义为Docker选项。在之前的示例中，我们接触到了一些这些服务级选项，比如`--ip-forward`、`--userland-proxy`和`--ip`。在这个示例中，我们将介绍如何将服务级参数传递给Docker服务，以及讨论一些关键参数的功能。
- en: Getting ready
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You'll need access to a Docker host and an understanding of how your Docker
    host is connected to the network. In this recipe, we'll be using the `docker1`
    and `docker2` hosts that we used in previous recipes. You'll want to make sure
    that you have access to view `iptables` rules to verify netfilter policies. If
    you wish to download and run example containers, your Docker host will also need
    access to the Internet.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Docker主机，并了解您的Docker主机如何连接到网络。在本教程中，我们将使用之前教程中使用的`docker1`和`docker2`主机。您需要确保可以访问`iptables`规则以验证netfilter策略。如果您希望下载和运行示例容器，您的Docker主机还需要访问互联网。
- en: How to do it…
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤…
- en: 'In order to pass runtime options or parameters to the Docker, we need to modify
    the service configuration. In our case, we''re using Ubuntu version 16.04, which
    uses `systemd` to manage services running on the Linux host. The recommended approach
    to passing parameters to Docker is to use a `systemd` drop in file. To create
    the drop in file we can follow these steps to create a service directory and a
    Docker configuration file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了传递运行时选项或参数给Docker，我们需要修改服务配置。在我们的情况下，我们使用的是Ubuntu 16.04版本，它使用`systemd`来管理在Linux主机上运行的服务。向Docker传递参数的推荐方法是使用`systemd`的附加文件。要创建附加文件，我们可以按照以下步骤创建一个服务目录和一个Docker配置文件：
- en: '[PRE48]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Insert the following lines into the `docker.conf` configuration file:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行插入`docker.conf`配置文件中：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you wish to pass any parameters to Docker service, you can do so by appending
    them to the third line. For instance, if I wanted to disable Docker automatically
    enabling IP forwarding on the host when the service starts, my file would look
    like:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望向Docker服务传递任何参数，可以通过将它们附加到第三行来实现。例如，如果我想在服务启动时禁用Docker自动启用主机上的IP转发，我的文件将如下所示：
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After making changes to system-related files, you need to ask `systemd` to
    reload the configuration. This is done with the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在对系统相关文件进行更改后，您需要要求`systemd`重新加载配置。使用以下命令完成：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And finally, you can restart the service for the settings to take effect:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以重新启动服务以使设置生效：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Each time you change the configuration, you will need to reload the `systemd`
    configuration as well as restart the service.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每次更改配置后，您需要重新加载`systemd`配置以及重新启动服务。
- en: docker0 bridge addressing
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: docker0桥接地址
- en: 'As we saw earlier, the IP address of the `docker0` bridge is by default `172.17.0.1/16`.
    However, if you wish, you can change this IP address using the `--bip` configuration
    flag. For example, you might wish to change the `docker0` bridge subnet to be
    `192.168.127.1/24`. This can be done by passing the following option to the Docker
    service:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所看到的，`docker0`桥的IP地址默认为`172.17.0.1/16`。但是，如果您希望，可以使用`--bip`配置标志更改此IP地址。例如，您可能希望将`docker0`桥的子网更改为`192.168.127.1/24`。这可以通过将以下选项传递给Docker服务来完成：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'When changing this setting make sure that you configure the IP address (`192.168.127.1/24`)
    rather than the subnet (`192.168.127.0/24`) you wish to define. Previous versions
    of Docker required the host to be rebooted or the existing bridge be manually
    deleted before a new bridge IP could be assigned. In newer versions, you simply
    reload the `systemd` configuration and restart the service for the new bridge
    IP to be assigned:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 更改此设置时，请确保配置IP地址（`192.168.127.1/24`）而不是您希望定义的子网（`192.168.127.0/24`）。以前的Docker版本需要重新启动主机或手动删除现有的桥接才能分配新的桥接IP。在较新的版本中，您只需重新加载`systemd`配置并重新启动服务，新的桥接IP就会被分配：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In addition to changing the IP address of the `docker0` bridge, you may also
    define which IP addresses Docker can assign to containers. This is done by using
    the `--fixed-cidr` configuration flag. For instance, assume the following configuration:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改`docker0`桥的IP地址，您还可以定义Docker可以分配给容器的IP地址。这是通过使用`--fixed-cidr`配置标志来完成的。例如，假设以下配置：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In this scenario, the `docker0` bridge interface itself lives in the `192.168.127.0/24`
    subnet, but we are telling Docker to only assign container IP addresses out of
    the subnet `192.168.127.128/25`. If we add this configuration and once again reload
    `systemd` and restart the service, we can see that Docker will assign the first
    container an IP address of `192.168.127.128`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`docker0`桥接口本身位于`192.168.127.0/24`子网中，但我们告诉Docker只从子网`192.168.127.128/25`中分配容器IP地址。如果我们添加这个配置，再次重新加载`systemd`并重新启动服务，我们可以看到Docker将为第一个容器分配IP地址`192.168.127.128`：
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Since the containers use the defined `docker0` bridge IP address as their default
    gateway, the fixed CIDR range must be a smaller subnet of the one defined on the
    `docker0` bridge itself.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器使用定义的`docker0`桥接IP地址作为它们的默认网关，固定的CIDR范围必须是`docker0`桥本身上定义的子网的较小子网。
- en: Docker interface binding for published ports
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布端口的Docker接口绑定
- en: 'In some scenarios, you may have a Docker host that has multiple network interfaces
    that live in different network segments. For instance, consider the example where
    you have two hosts that both have two network interfaces:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能有一个Docker主机，它有多个位于不同网络段的网络接口。例如，考虑这样一个例子，您有两个主机，它们都有两个网络接口：
- en: '![Docker interface binding for published ports](graphics/B05453_02_12.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![Docker接口绑定用于发布端口](graphics/B05453_02_12.jpg)'
- en: 'Consider the case where we start a container providing a web service on the
    host `docker1` using this syntax:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况，我们在主机`docker1`上启动一个提供Web服务的容器，使用以下语法：
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As you can see, we''ve passed the `-P` flag telling Docker to publish any exposed
    ports present in the image to the Docker host on a random port. If we examine
    the port mapping, we note that while there''s a dynamic port assignment, there
    is not a host IP address assignment:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们传递了`-P`标志，告诉Docker将图像中存在的任何暴露端口发布到Docker主机上的随机端口。如果我们检查端口映射，我们注意到虽然有动态端口分配，但没有主机IP地址分配：
- en: '[PRE58]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Rather than specifying a specific IP address, Docker specifies all interfaces
    with `0.0.0.0`. This means that the service in the container can be accessed on
    port `32768` on any of the Docker host''s IP interfaces. We can prove this by
    testing from the `docker2` host:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Docker不是指定特定的IP地址，而是用`0.0.0.0`指定所有接口。这意味着容器中的服务可以在Docker主机的任何IP接口上的端口`32768`上访问。我们可以通过从`docker2`主机进行测试来证明这一点：
- en: '[PRE59]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If we wish to limit the interface Docker publishes ports on by default, we
    can pass the `--ip` option to the Docker service. To continue the example, my
    options could now look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望限制Docker默认发布端口的接口，我们可以将`--ip`选项传递给Docker服务。继续上面的例子，我的选项现在可能是这样的：
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Passing these options to the Docker service, and rerunning our container, will
    cause ports to only be mapped to the defined IP address:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些选项传递给Docker服务，并重新运行我们的容器，将导致端口只映射到定义的IP地址：
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And if we run our test from the `docker2` host a second time, we should see
    that the service is only exposed on the `192.168.10.101` interface and not on
    the `10.10.10.101` interface:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从`docker2`主机再次运行我们的测试，我们应该看到服务只暴露在`192.168.10.101`接口上，而不是`10.10.10.101`接口上：
- en: '[PRE62]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Keep in mind that this setting only applies to published ports. This does not
    impact the interface a container might use for outbound connectivity. That is
    dictated by the host's routing table.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此设置仅适用于已发布的端口。 这不会影响容器可能用于出站连接的接口。 这由主机的路由表决定。
- en: Container interface MTU
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器接口MTU
- en: 'In some cases, it may be necessary to change the MTU of the container''s network
    interface. This can be done by passing the `--mtu` option to the Docker service.
    For instance, we may wish to lower the MTU of the container''s interface to `1450`
    to account for some type of encapsulation. To do this, you could pass the following
    flag:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能需要更改容器的网络接口的MTU。 这可以通过向Docker服务传递`--mtu`选项来完成。 例如，我们可能希望将容器的接口MTU降低到`1450`以适应某种封装。
    要做到这一点，您可以传递以下标志：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After adding this option, you might examine the `docker0` bridge MTU and find
    it unchanged as shown in the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此选项后，您可能会检查`docker0`桥MTU并发现它保持不变，如下面的代码所示：
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This is actually expected behavior. Linux bridges, by default, automatically
    use the lowest MTU of any slave interface associated with it. When we told Docker
    to use a MTU of `1450`, we were really telling it to start any containers with
    a MTU of `1450`. Since we have no containers running at this point, the MTU of
    the bridge is unchanged. Let''s start a container to validate this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是预期行为。 Linux桥默认情况下会自动使用与其关联的任何从属接口中的最低MTU。 当我们告诉Docker使用MTU为`1450`时，我们实际上是在告诉它以MTU为`1450`启动任何容器。
    由于此时没有运行任何容器，桥的MTU保持不变。 让我们启动一个容器来验证这一点：
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can see that the container has the correct MTU of `1450`. Checking the Docker
    host we should see that the MTU of the bridge is now also lower:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到容器的MTU正确为`1450`。 检查Docker主机，我们应该看到桥的MTU现在也较低：
- en: '[PRE66]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Starting the container with a lower MTU automatically impacted the bridge MTU
    as we expected.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以较低的MTU启动容器自动影响了桥的MTU，正如我们所预期的那样。
- en: Container default gateway
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器默认网关
- en: By default, Docker sets the default gateway of any containers to that of the
    `docker0` bridge IP address. This makes sense because the containers need to route
    through the `docker0` bridge to reach the outside network. It is, however, possible
    to override this setting and have Docker set the default gateway to another IP
    address on the `docker0` bridge network.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker将任何容器的默认网关设置为`docker0`桥的IP地址。 这是有道理的，因为容器需要通过`docker0`桥进行路由才能到达外部网络。
    但是，可以覆盖此设置，并让Docker将默认网关设置为`docker0`桥网络上的另一个IP地址。
- en: For instance, we can change the default gateway to `192.168.127.50` by passing
    the Docker service these configuration options.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过传递这些配置选项给Docker服务来将默认网关更改为`192.168.127.50`。
- en: '[PRE67]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we add these settings, restart the service, and spawn a container, we can
    see that the new container has a default gateway of `192.168.127.50` as configured:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加这些设置，重新启动服务并生成一个容器，我们可以看到新容器的默认网关已配置为`192.168.127.50`：
- en: '[PRE68]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Keep in mind that at this point, this container has no connectivity off it's
    current subnet because that gateway does not currently exist. In order for the
    container to have connectivity off its local subnet `192.168.127.50` would need
    to be reachable from the containers and have connectivity to the outside network.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此时此容器在其当前子网之外没有连接性，因为该网关目前不存在。 为了使容器在其本地子网之外具有连接性，需要从容器中访问`192.168.127.50`并具有连接到外部网络的能力。
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are other options configured at the service level such as `--iptables`
    and `--icc`. Those will be discussed in later chapters as we discuss their relevant
    use cases.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 服务级别还有其他配置选项，例如`--iptables`和`--icc`。 这些将在后面的章节中讨论它们的相关用例。
