- en: Creating Images with Java Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java应用程序创建镜像
- en: Now that we have a simple, but functional Java microservice based on Spring
    Bootstrap, we can go further. Before we deploy it using Kubernetes, let's package
    it as a Docker image. In this chapter, we will create a Docker image containing
    our application, and we will dockerize a Spring Boot application to run it in
    an isolated environment, a container.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个简单但功能齐全的基于Spring Bootstrap的Java微服务，我们可以进一步进行。在使用Kubernetes部署之前，让我们将其打包为Docker镜像。在本章中，我们将创建一个包含我们应用程序的Docker镜像，并将Spring
    Boot应用程序docker化以在隔离环境中运行，即容器中。
- en: 'Topics covered in this chapter will be:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题将是：
- en: Creating a Dockerfile
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Dockerfile
- en: Dockerfile instructions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile指令
- en: Building the image
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建镜像
- en: Creating and removing images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和删除镜像
- en: Let's begin with the definition of a `Dockerfile` , which will be the definition
    of our container.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义一个`Dockerfile`开始，这将是我们容器的定义。
- en: Dockerfile
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile
- en: 'As you will remember from [Chapter 1](text00022.html) , *Introduction to Docker*
    , the `Dockerfile` is kind of a recipe to build an image. It''s a plain text file
    containing instructions which are executed by Docker in the order they are placed.
    Each `Dockerfile` has a base image that the Docker engine will use to build upon.
    A resulting image will be a specific state of a file system: a read-only, frozen
    immutable snapshot of a live container, composed of layers representing changes
    in the filesystem at various points in time.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第1章](text00022.html)中所记得的，*Docker简介*，`Dockerfile`是一种构建镜像的配方。它是一个纯文本文件，包含按顺序由Docker执行的指令。每个`Dockerfile`都有一个基础镜像，Docker引擎将用它来构建。生成的镜像将是文件系统的特定状态：一个只读的、冻结的不可变的快照，由代表文件系统在不同时间点上的更改的层组成。
- en: 'The image creation flow in Docker is pretty straightforward and consists basically
    of two steps:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Docker中的镜像创建流程非常简单，基本上包括两个步骤：
- en: First, you prepare a text file named `Dockerfile` , which contains a series
    of instructions on how to build the image. The set of instructions you can use
    in the `Dockerfile` is not very broad, but sufficient to fully instruct Docker
    how to create an image.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您准备一个名为`Dockerfile`的文本文件，其中包含一系列关于如何构建镜像的指令。您可以在`Dockerfile`中使用的指令集并不是很广泛，但足以充分指导Docker如何创建镜像。
- en: Next, you execute the `docker build` command to create a Docker image based
    on the `Dockerfile` that you have just created. The `docker build` command runs
    within the context. The build's context is the files at a specified location,
    which can be a `PATH` or a URL. The `PATH` is a directory on your local filesystem
    and the URL is a Git repository location. A context is processed recursively.
    `PATH` will include any subdirectories. The URL will include the repository and
    its submodules.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您执行`docker build`命令，基于您刚刚创建的`Dockerfile`创建一个Docker镜像。`docker build`命令在上下文中运行。构建的上下文是指定位置的文件，可以是`PATH`或URL。`PATH`是本地文件系统上的目录，URL是Git存储库位置。上下文会递归处理。`PATH`将包括任何子目录。URL将包括存储库及其子模块。
- en: If you create an image containing a Java application, you can also skip the
    second step and utilize one of the Docker Maven plugins available. After we learn
    how to build images using the `docker build` command, we will also create our
    image using Maven. When building using Maven, the context to the `docker build`
    command (or a build process, in this case) will be provided automatically by Maven
    itself. Actually, there is no need for the `Dockerfile` at all, it will be created
    automatically during the build process. We will get to this in a short while.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您创建一个包含Java应用程序的镜像，您也可以跳过第二步，并利用其中一个可用的Docker Maven插件。在学习如何使用`docker build`命令构建镜像之后，我们还将使用Maven创建我们的镜像。在使用Maven构建时，上下文将由Maven自动提供给`docker
    build`命令（或者在这种情况下是一个构建过程）。实际上，根本不需要`Dockerfile`，它将在构建过程中自动创建。我们将在短时间内了解这一点。
- en: The standard name for a `Dockerfile` is just `Dockerfile` . It's just a plain
    text file. Depending on the IDE you use, there are plugins to provide Dockerfile
    syntax highlighting and autocompletion, which makes editing them a breeze. Dockerfile
    instructions use simple and clear syntax which makes them quite easy to understand,
    create, and use. They are designed to be self-explanatory, especially because
    they allow commenting just as properly written application source code. Let's
    get to know the `Dockerfile` instructions now.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`的标准名称就是`Dockerfile`。它只是一个纯文本文件。根据您使用的IDE，有插件可以提供Dockerfile语法高亮和自动补全，这使得编辑它们变得轻而易举。Dockerfile指令使用简单明了的语法，使它们非常容易理解、创建和使用。它们被设计为自解释的，特别是因为它们允许像正确编写的应用程序源代码一样进行注释。现在让我们来了解一下`Dockerfile`指令。'
- en: Dockerfile instructions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile指令
- en: We will begin with the instruction that every Dockerfile must have at the top,
    the `FROM` instruction.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从每个Dockerfile顶部必须具有的指令`FROM`开始。
- en: FROM
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FROM
- en: 'This is the first instruction in the Dockerfile. It sets the base image for
    every subsequent instruction coming next in the file. The syntax for the `FROM`
    instruction is straightforward. It''s just:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Dockerfile中的第一条指令。它为文件中接下来的每个后续指令设置基础镜像。`FROM`指令的语法很简单。就是：
- en: '`FROM <image>` , or `FROM <image>:<tag>` , or `FROM <image>@<digest>`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM <image>`，或`FROM <image>:<tag>`，或`FROM <image>@<digest>`'
- en: The `FROM` instruction takes a `tag` or `digest` as a parameter. If you decide
    to skip them, Docker will assume you want to build your image from the `latest`
    tag. Be aware that `latest` will not always be the latest version of the image
    you want to build upon. The `latest` tag is kind of a special one. Also, it may
    not work as you may expect. Well, to cut a long story short, it doesn't mean anything
    special unless the image creator (`openjdk` or `fabric8` , for example) has a
    specific `build` , `tag` , and `push` pattern. The `latest` tag assigned to an
    image simply means that it's the image that was last built and executed without
    a specific tag provided. It's easy to understand that it may be confusing, pulling
    the image tagged `latest` will not fetch the latest version of the software.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`指令以`tag`或`digest`作为参数。如果您决定跳过它们，Docker将假定您想要从`latest`标签构建您的镜像。请注意，`latest`并不总是您想要构建的镜像的最新版本。`latest`标签有点特殊。而且它可能不会像您期望的那样工作。总之，除非镜像创建者（例如`openjdk`或`fabric8`）有特定的`build`、`tag`和`push`模式，否则`latest`标签并不意味着任何特殊含义。分配给镜像的`latest`标签只是意味着它是最后构建并执行的镜像，没有提供特定标签。很容易理解，这可能会令人困惑，拉取标记为`latest`的镜像将不会获取软件的最新版本。'
- en: Docker will not take care of checking if you are getting the newest version
    of the software when pulling the image tagged `latest` .
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当拉取标记为`latest`的镜像时，Docker不会检查您是否获取了软件的最新版本。
- en: Docker will throw an error during the build if it cannot find a tag or digest
    you provide. You should choose the base image wisely. My recommendation would
    be to always prefer the official repositories that can be found on Docker Hub.
    By choosing an official image you can be pretty sure it will be of high quality,
    tested, supported, and maintained.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Docker在构建过程中找不到你提供的标签或摘要，将会抛出错误。你应该明智地选择基础镜像。我的建议是始终优先选择在Docker Hub上找到的官方仓库。通过选择官方镜像，你可以相当确信它的质量高，经过测试，得到支持和维护。
- en: 'For containerizing a Java application, we have two options. The first one is
    to use a base Linux image and install Java using the `RUN` instruction (we will
    cover `RUN` in a while). The second option will be to pull an image containing
    the Java runtime already installed. Here you have a lot more to choose from. For
    example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于容器化Java应用程序，我们有两个选项。第一个是使用基础Linux镜像，并使用`RUN`指令安装Java（我们将在稍后介绍`RUN`）。第二个选项是拉取已经安装了Java运行时的镜像。在这里，你有更多选择。例如：
- en: '`openjdk` : An official repository containing an open-source implementation
    of the Java platform, Standard Edition. The tag `latest` , which will be used
    if you do not specify any tag, points to the `8u121-alpine` OpenJDK release, as
    of the time of writing this book'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openjdk`：一个官方仓库，包含了Java平台标准版的开源实现。标签`latest`指向了`8u121-alpine` OpenJDK版本，这是在撰写本书时的最新版本。'
- en: '`fabric8/java-alpine-openjdk8-jdk` : This base image is actually also being
    used by the fabric8 Maven plugin'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fabric8/java-alpine-openjdk8-jdk`：这个基础镜像实际上也被fabric8 Maven插件使用。'
- en: '`frolvlad/alpine-oraclejdk8` : There are three tags you can choose from: full
    (only src tarballs get removed), cleaned (desktop parts get cleaned), slim, everything
    but the compiler and JVM is removed. The tag latest points to the cleaned one'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frolvlad/alpine-oraclejdk8`：有三个标签可供选择：full（只删除源代码tarballs），cleaned（清理桌面部分），slim（删除除编译器和JVM之外的所有内容）。标签latest指向了cleaned版本。'
- en: '`jeanblanchard/java` : A repository containing images based on Alpine Linux
    to keep the size minimal (about 25% of an Ubuntu-based image). The tag `latest`
    points to Oracle Java 8 (Server JRE)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jeanblanchard/java`：一个包含基于Alpine Linux的镜像的仓库，以保持尺寸最小（大约是基于Ubuntu的镜像的25%）。标签`latest`指向了Oracle
    Java 8（Server JRE）。'
- en: By registering and creating your account on the Docker Hub at [https://hub.docker.com](https://hub.docker.com)
    , you will get access to the Docker Store. It's available at [https://store.docker.com](https://store.docker.com)
    . Try searching the Docker Store for Java-related images. You will find a lot
    of useful images to choose from, and one of them is the official Oracle Java 8
    SE (Server JRE) image. This Docker image provides the Server JRE, a runtime environment
    specifically targeted for deploying Java in server environments. The Server JRE
    includes tools for JVM monitoring and tools commonly required for server applications.
    You can get this official Java Docker image by buying it on the Docker Store.
    Click Get Content, it's priced $0.00, so it will be available for your development
    purposes free of charge.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Docker Hub上注册并创建账户，你将获得访问Docker Store的权限。它可以在[https://store.docker.com](https://store.docker.com)找到。尝试在Docker
    Store中搜索与Java相关的镜像。你会找到许多有用的镜像可供选择，其中之一就是官方的Oracle Java 8 SE（Server JRE）镜像。这个Docker镜像提供了Server
    JRE，这是专门针对在服务器环境中部署Java的运行时环境。Server JRE包括用于JVM监控和服务器应用程序常用的工具。你可以通过在Docker Store购买官方Java
    Docker镜像来获取这个官方Java Docker镜像。点击获取内容，价格为$0.00，因此可以免费用于开发目的。
- en: Take note that images coming from the Docker Store are bound to your Docker
    Hub account. Before you pull them or build your own images having them as the
    base image, you will need to the authenticate to Docker Store using the `docker
    login` command and your Docker Hub credentials.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，来自 Docker Store 的镜像与您的 Docker Hub 帐户绑定。在拉取它们或构建以它们为基础镜像的自己的镜像之前，您需要使用 `docker
    login` 命令和您的 Docker Hub 凭据对 Docker Store 进行身份验证。
- en: 'For our purposes, let''s choose `jeanblanchard/java` . It''s the official Oracle
    Java running on top of the Alpine Linux distribution. The base image is small
    and fast to download. Our `FROM` instruction will look the same as this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们的目的，让我们选择 `jeanblanchard/java`。这是官方的 Oracle Java 运行在 Alpine Linux 发行版之上。基础镜像小巧且下载速度快。我们的
    `FROM` 指令将与此相同：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If a `FROM` image is not found on your Docker host (on your local machine, for
    example), Docker will try to find and pull it out from the Docker Hub (or your
    private repository if you have it set up). All subsequent instructions in the
    `Dockerfile` will use the image specified in the `FROM` as a base starting point.
    That's why it's mandatory; a valid `Dockerfile` must have it at the top.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在您的 Docker 主机上（例如在您的本地计算机上）找不到 `FROM` 镜像，Docker 将尝试从 Docker Hub（或者如果您已经设置了私有仓库，则从私有仓库）中找到并拉取它。`Dockerfile`
    中的所有后续指令将使用 `FROM` 中指定的镜像作为基础起点。这就是为什么它是强制性的；一个有效的 `Dockerfile` 必须在顶部有它。
- en: MAINTAINER
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MAINTAINER
- en: 'By using the `MAINTAINER` instruction, you set the `Author` field of the generated
    image. This can be your name, username, or whatever you would like as an author
    of the image that will be created by using the `Dockerfile` you are writing. This
    command can be placed anywhere in a `Dockerfile` , but good practice is to place
    it on the top of the file, just after the `FROM` instruction. This is a so-called,
    non-executing command, meaning that it will not make any changes to the generated
    image. The syntax, again, is very simple:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `MAINTAINER` 指令，您可以设置生成的镜像的 `Author` 字段。这可以是您的姓名、用户名，或者您希望作为您正在编写的 `Dockerfile`
    创建的镜像的作者。这个命令可以放在 `Dockerfile` 的任何位置，但最好的做法是将其放在文件顶部，在 `FROM` 指令之后。这是一个所谓的非执行命令，意味着它不会对生成的镜像进行任何更改。语法非常简单：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: WORKDIR
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WORKDIR
- en: The `WORKDIR` instruction adds a working directory for any `CMD` , `RUN` , `ENTRYPOINT`
    , `COPY` , and `ADD` instructions that comes after it in the Dockerfile. The syntax
    for the instruction is `WORKDIR /PATH.` You can have multiple `WORKDIR` instructions
    in one Dockerfile, if the relative path is provided; it will be relative to the
    path of the previous `WORKDIR` instruction.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR` 指令为 Dockerfile 中在它之后出现的任何 `CMD` 、`RUN` 、`ENTRYPOINT` 、`COPY` 和 `ADD`
    指令添加一个工作目录。该指令的语法是 `WORKDIR /PATH`。如果提供了相对路径，可以在一个 Dockerfile 中有多个 `WORKDIR` 指令；它将相对于前一个
    `WORKDIR` 指令的路径。'
- en: ADD
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ADD
- en: 'What `ADD` basically does is copy the files from the source into the container''s
    own filesystem at the desired destination. It takes two arguments: the source
    (`<source path or URL>` ) and a destination (`<destination path>` ):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD` 的基本作用是将文件从源复制到容器自己的文件系统中的所需目的地。它接受两个参数：源（`<source path or URL>`）和目的地（`<destination
    path>`）：'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The source can have two forms: it can be a path to a file, a directory, or
    the URL. The path is relative to the directory in which the build process is going
    to be started (the build context we have mentioned earlier). This means you cannot
    have, for example `"../../config.json"` placed as a source path parameter of the
    `ADD` instruction.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 源可以有两种形式：它可以是文件、目录或 URL 的路径。路径是相对于构建过程将要启动的目录（我们之前提到的构建上下文）的。这意味着您不能将例如 `"../../config.json"`
    放置为 `ADD` 指令的源路径参数。
- en: 'The source and destination paths can contain wildcards. Those are the same
    as in a conventional file system: `*` for any text string, or `?` for any single
    character.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 源路径和目标路径可以包含通配符。这些与常规文件系统中的通配符相同：`*`表示任何文本字符串，`?`表示任何单个字符。
- en: For example, `ADD target/*.jar /` will add all files ending with `.jar` into
    the root directory in the image's file system.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`ADD target/*.jar /`将所有以`.jar`结尾的文件添加到镜像文件系统的根目录中。
- en: 'If you need, you can specify multiple source paths, and separate them with
    a comma. All of them must be relative to the build context, the same as if you
    have just a single source path. If your source or destination paths contain spaces,
    you will need to use a special syntax, adding the square brackets around:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以指定多个源路径，并用逗号分隔。它们都必须相对于构建上下文，就像只有一个源路径一样。如果您的源路径或目标路径包含空格，您需要使用特殊的语法，添加方括号：
- en: '`ADD ["<source path or URL>" "<destination path>"]`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD ["<source path or URL>" "<destination path>"]`'
- en: 'If the source path doesn''t end with a trailing slash, it will be considered
    a single file and just copied into the destination. If the source path ends with
    a trailing slash, it will be considered a directory: its whole contents will then
    be copied into the destination path, but the directory itself will not be created
    at the destination path. So, as you can see, a trailing slash `/` is quite important
    when adding files or directories to an image. If the source path points to the
    compressed archive in one of the common formats such as ZIP, TAR, and so on, it
    will be decompressed into the destination path. Docker doesn''t recognize an archive
    by the filename, it checks the contents of the file.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源路径不以斜杠结尾，它将被视为单个文件，并且只会被复制到目标路径中。如果源路径以斜杠结尾，它将被视为目录：然后将其整个内容复制到目标路径中，但目录本身不会在目标路径中创建。因此，可以看到，当向镜像添加文件或目录时，斜杠`/`非常重要。如果源路径指向常见格式（如ZIP、TAR等）的压缩存档，它将被解压缩到目标路径中。Docker不是通过文件名来识别存档，而是检查文件的内容。
- en: If the archive is damaged or unreadable by Docker in any other way, it will
    not be extracted and you will not be given an error message. The file will just
    be copied into the destination path.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存档损坏或者以其他方式无法被Docker读取，它将不会被解压缩，也不会给出错误消息。文件将被复制到目标路径中。
- en: The same trailing slash rules apply to the destination path; if it ends with
    a trailing slash, it means that it's a directory. Otherwise, it will be considered
    a single file. This gives you great flexibility when constructing the file system
    content of your image; you can add files into directories, add files as single
    files (with the same or different names), or just add whole directories.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的尾部斜杠规则适用于目标路径；如果以斜杠结尾，表示它是一个目录。否则，它将被视为单个文件。这在构建镜像的文件系统内容时为您提供了很大的灵活性；您可以将文件添加到目录中，将文件添加为单个文件（使用相同或不同的名称），或者只添加整个目录。
- en: The `ADD` command is not only about copying files from the local file system,
    you can use it to get the file from the network. If the source is a URL then the
    contents of the URL will be automatically downloaded and placed at the destination.
    Note that file archives that were downloaded from the network will not be decompressed.
    Again, the trailing slash is important when downloading files; if the destination
    path ends with a slash, the file will be downloaded into the directory. Otherwise,
    the downloaded file will just be saved under the name you provided as the destination
    path.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD` 命令不仅仅是从本地文件系统复制文件，您还可以使用它从网络获取文件。如果源是一个 URL，那么 URL 的内容将自动下载并放置在目标位置。请注意，从网络下载的文件存档将不会被解压缩。再次强调，当下载文件时，尾部的斜杠很重要；如果目标路径以斜杠结尾，文件将被下载到该目录中。否则，下载的文件将只是保存在您提供的目标路径下的名称。'
- en: 'The `<destination directory>` is either an absolute path or a path which is
    relative to the directory specific by the `WORKDIR` instruction (we will cover
    it in a while). The source (or multiple sources) will just be copied into the
    destination specified. For example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`<destination directory>` 可以是绝对路径，也可以是相对于 `WORKDIR` 指令指定的目录的路径（我们将在稍后介绍）。源（或多个源）将被复制到指定的目标位置。例如：'
- en: '`ADD config.json projectRoot/` will add the `config.json` file to `<WORKDIR>/projectRoot/`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD config.json projectRoot/` 将把 `config.json` 文件添加到 `<WORKDIR>/projectRoot/`
    中'
- en: '`ADD config.json /absoluteDirectory/` will add the `config.json` file to the
    `/absoluteDirectory/`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD config.json /absoluteDirectory/` 将把 `config.json` 文件添加到 `/absoluteDirectory/`
    中'
- en: 'When it comes to the ownership of the files created in the image, they will
    always be created with the user ID (`UID` ) `0` and group ID (`GID` ) `0` . Permissions
    will be the same as in the source file, unless it''s a file downloaded from the
    remote URL: in this case, it will get permissions value `600` (only the owner
    can read and write the file). If you need to change these values (ownership or
    permissions), you will need to provide more instructions in your Dockerfile, after
    the `ADD` instruction.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 关于镜像中创建的文件的所有权，它们将始终以用户 ID（`UID`）`0` 和组 ID（`GID`）`0` 创建。权限将与源文件相同，除非它是从远程 URL
    下载的文件：在这种情况下，它将获得权限值 `600`（只有所有者可以读写该文件）。如果您需要更改这些值（所有权或权限），您需要在 `ADD` 指令之后在您的
    Dockerfile 中提供更多的指令。
- en: If the files that you need to add to the image are placed on the URL that needs
    authentication, the `ADD` instruction will not work. You will need to use a shell
    command to download the file, such as `wget` or `curl` .
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要添加到镜像的文件位于需要身份验证的 URL 上，`ADD` 指令将无法工作。您需要使用 shell 命令来下载文件，比如 `wget` 或 `curl`。
- en: Note that `ADD` shouldn't be used if you don't need its special features, such
    as unpacking archives, you should use `COPY` instead.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您不需要其特殊功能，比如解压缩存档，就不应该使用 `ADD`，而应该使用 `COPY`。
- en: COPY
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: COPY
- en: The `COPY` instruction will copy new files or directories from `<source path>`
    and add them to the file system of the container at the path `<destination path>`
    .
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 指令将从 `<source path>` 复制新文件或目录，并将它们添加到容器的文件系统中的路径 `<destination path>`。'
- en: 'It''s very similar to the `ADD` instruction, even the syntax is no different:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它与 `ADD` 指令非常相似，甚至语法也没有区别：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The same rules from `ADD` apply to `COPY` : all source paths must be relative
    to the context of the build. Again the presence of the trailing slash at the end
    of the source and destination path is important: if it''s present, the path will
    be considered a file; otherwise, it will be treated as a directory.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY` 也适用于 `ADD` 的所有规则：所有源路径必须相对于构建的上下文。再次强调，源路径和目标路径末尾的斜杠的存在很重要：如果存在，路径将被视为文件；否则，它将被视为目录。'
- en: 'Of course, as in `ADD` , you can have multiple source paths. If source or destination
    paths contain spaces, you will need to wrap them in square brackets:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，就像`ADD`一样，你可以有多个源路径。如果源路径或目标路径包含空格，你需要用方括号括起来：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `<destination path>` is an absolute path (if begins with a slash), or a
    path relative to the path specified by the `WORKDIR` instruction.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`<destination path>`是一个绝对路径（如果以斜杠开头），或者是相对于`WORKDIR`指令指定的路径的路径。'
- en: As you can see, the functionality of `COPY` is almost the same as the `ADD`
    instruction, with one difference. `COPY` supports only the basic copying of local
    files into the container. On the other hand, `ADD` gives some more features, such
    as archive extraction, downloading files through URL, and so on. Docker's best
    practices say that you should prefer `COPY` if you do not need those additional
    features of `ADD` . The `Dockerfile` will be cleaner and easier to understand
    thanks to the transparency of the `COPY` command.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`COPY`的功能与`ADD`指令几乎相同，只有一个区别。`COPY`仅支持将本地文件基本复制到容器中。另一方面，`ADD`提供了一些更多的功能，比如归档解压、通过URL下载文件等。Docker的最佳实践建议，如果你不需要`ADD`的这些附加功能，应该优先使用`COPY`。由于`COPY`命令的透明性，`Dockerfile`将更清洁、更易于理解。
- en: There is one common, important aspect for both `ADD` and `COPY` instructions,
    a cache. Basically, Docker caches the files that go into the image during the
    build. The contents of the file or files in the image are examined and a checksum
    is calculated for each file. During the cache lookup, the checksum is compared
    against the checksum in the existing images. If anything has changed in the file(s),
    such as the contents and metadata, then the cache is being invalidated. Otherwise,
    if the source file has not changed, an existing image layer is being reused.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`和`COPY`指令有一个共同的重要方面，即缓存。基本上，Docker在构建过程中缓存进入镜像的文件。镜像中文件或文件的内容被检查，并为每个文件计算校验和。在缓存查找期间，校验和与现有镜像中的校验和进行比较。如果文件的内容和元数据发生了变化，缓存就会失效。否则，如果源文件没有发生变化，现有的镜像层就会被重用。'
- en: If you have multiple Dockerfile steps that use different files from your context,
    `COPY` them individually, rather than all at once. This will ensure that each
    step's build cache is only invalidated (forcing the step to be re-run) if the
    specifically required files change.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多个Dockerfile步骤使用来自你的上下文的不同文件，单独`COPY`它们，而不是一次性全部复制。这将确保每个步骤的构建缓存只有在特定所需文件发生变化时才会失效（强制步骤重新运行）。
- en: As you can see, the `COPY` instruction has almost identical syntax and behavior
    to the `ADD` instruction, but their feature set is somehow different. For files
    and directories that do not require the `ADD` feature of archive unpacking or
    fetching from the URL, you should always use `COPY` .
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`COPY`指令的语法和行为几乎与`ADD`指令相同，但它们的功能集有些不同。对于不需要`ADD`功能的归档解压或从URL获取文件的文件和目录，你应该始终使用`COPY`。
- en: RUN
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行
- en: The `RUN` instruction is the central executing instruction for the `Dockerfile`
    . In essence, the `RUN` instruction will execute a command (or commands) in a
    new layer on top of the current image and then commit the results. The resulting
    committed image will be used as a base for the next instruction in the `Dockerfile`
    . As you will remember from [Chapter 1](text00022.html) , *Introduction to Docker*
    , layering is the core concept in Docker. `RUN` , takes a command as its argument
    and runs it to create the new layer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令是`Dockerfile`的中心执行指令。实质上，`RUN`指令将在当前镜像的新层上执行一个命令（或多个命令），然后提交结果。生成的提交镜像将作为`Dockerfile`中下一条指令的基础。正如你从[第1章](text00022.html)中记得的，*Docker简介*，分层是Docker的核心概念。`RUN`以命令作为其参数，并运行它以创建新的层。'
- en: This also means that `COPY` and `ENTRYPOINT` set parameters can be overridden
    at runtime, so if you don't change anything after starting your container, the
    result will always be the same. `RUN` however, will be executed at build time
    and no matter what you do at runtime, its effects will be here.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着`COPY`和`ENTRYPOINT`设置的参数可以在运行时被覆盖，所以如果你在启动容器后没有改变任何东西，结果将始终相同。然而，`RUN`将在构建时执行，无论你在运行时做什么，其效果都会存在。
- en: To make your Dockerfile more readable and easier to maintain, you can split
    long or complex `RUN` statements on multiple lines separating them with a backslash.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使你的Dockerfile更易读和更易维护，你可以将长或复杂的`RUN`语句拆分成多行，用反斜杠分隔它们。
- en: The `RUN` commands from the `Dockerfile` will be executed in the order they
    appear in it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`中的`RUN`命令将按照它们在其中出现的顺序执行。'
- en: Each `RUN` instruction creates a new layer in the image.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`RUN`指令在镜像中创建一个新的层。
- en: As you already know from [Chapter 1](text00022.html) , *Introduction to Docker*
    , layers are being cached and reused by Docker. The cache for `RUN` instructions
    isn't invalidated automatically during the next build. For example, the cache
    for an instruction the same as `RUN apt-get upgrade -y` will be reused during
    the next build. What makes the cache important? For the most part, the cache is
    exceptionally helpful and can save you a tremendous amount of time while building
    your image. It makes building a new container really, really fast. However, there
    is a word of warning. There are times when the caching can be dangerous and provide
    unexpected results. The cache is used pretty heavily during the build process
    and this may cause issues when you want the updated output of a `RUN` command
    to make it into the new container. If the `RUN` command doesn't change between
    two builds, Docker's cache will not get invalidated. In effect, Docker will reuse
    the previous results from the cache. This is clearly harmful. Imagine a case when
    you use the `RUN` command for pulling source code from the Git repository, by
    using the `git clone` as the first step of building the image.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经从[第1章](text00022.html)中了解的那样，*Docker简介*，层被Docker缓存和重用。在下一次构建期间，`RUN`指令的缓存不会自动失效。例如，`RUN
    apt-get upgrade -y`的指令的缓存将在下一次构建中被重用。缓存为什么重要？在大多数情况下，缓存非常有用，可以节省大量构建镜像的时间。它使构建新容器变得非常快速。然而，需要警惕。有时缓存可能会带来意外的结果。在构建过程中，缓存被大量使用，当你希望`RUN`命令的更新输出进入新容器时，可能会出现问题。如果`RUN`命令在两次构建之间没有改变，Docker的缓存将不会失效。实际上，Docker将重用缓存中的先前结果。这显然是有害的。想象一种情况，当你使用`RUN`命令从Git仓库中拉取源代码时，通过使用`git
    clone`作为构建镜像的第一步。
- en: Be aware when the Docker cache needs to be invalidated, otherwise you will get
    unexpected results with your image builds.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker缓存需要失效时要注意，否则你将在镜像构建中得到意外的结果。
- en: That's why it's good to know how to selectively invalidate the cache. In the
    Docker world, this is called cache busting.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么知道如何选择性地使缓存失效很重要。在Docker世界中，这被称为缓存破坏。
- en: 'Consider the following example. Probably the most common usecase for `RUN`
    is an application of `apt-get` , which is a package manager command for downloading
    packages on Ubuntu. Let''s say we have the following Dockerfile, installing Java
    runtime:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。`RUN`最常见的用例可能是`apt-get`的应用，它是Ubuntu上用于下载软件包的包管理器命令。假设我们有以下Dockerfile，安装Java运行时：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we build an image from this `Dockerfile` , all layers from two `RUN` instructions
    will be put into the layers cache. But, after a while you decide you want the
    `node.js` package in your image, so now the Dockerfile looks the same as this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从这个`Dockerfile`构建一个镜像，两个`RUN`指令的所有层将被放入层缓存中。但是，过了一会儿，您决定在镜像中加入`node.js`包，所以现在`Dockerfile`看起来和这样一样：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you run the `docker build` for the second time, Docker will reuse the layers
    by taking them from the cache. As a result, the `apt-get update` will not be executed,
    because the cached version will be used. In effect, your newly created image will
    potentially have an outdated version of the `java` and `node.js` packages. You
    should always have the cache concept in mind when creating `RUN` instructions.
    In our example, we should always combine `RUN apt-get update` with `apt-get install`
    in the same `RUN` statement, which will create just a single layer; for example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您第二次运行`docker build`，Docker将通过从缓存中获取它们来重用层。因此，`apt-get update`将不会被执行，因为将使用缓存的版本。实际上，您新创建的镜像可能会有`java`和`node.js`包的过时版本。在创建`RUN`指令时，您应该始终牢记缓存的概念。在我们的例子中，我们应该始终将`RUN
    apt-get update`与`apt-get install`结合在同一个`RUN`语句中，这将创建一个单独的层；例如：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Better than this, you can also use a technique called "version pinning" to avoid
    cache problems. It's nothing more than just providing a specific, concrete version
    for the package you want to install.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 比这更好的是，您还可以使用一种称为“版本固定”的技术来避免缓存问题。这只是为要安装的包提供一个具体的版本。
- en: CMD
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMD
- en: 'The purpose of a `CMD` instruction is to provide defaults for an executing
    container. You can think of the `CMD` instruction as a starting point of your
    image, when the container is being run later on. This can be an executable, or,
    if you specify the `ENTRYPOINT` instruction (we are going to explain it next),
    you can omit the executable and provide the default parameters only. The `CMD`
    instruction syntax can have two forms:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`指令的目的是为执行容器提供默认值。您可以将`CMD`指令视为镜像的起点，当容器稍后运行时。这可以是一个可执行文件，或者，如果您指定了`ENTRYPOINT`指令（我们将在下面解释），您可以省略可执行文件，只提供默认参数。`CMD`指令的语法可以有两种形式：'
- en: '`CMD ["executable","parameter1","parameter2"]` : This is a so called `exec`
    form. It''s also the preferred and recommended form. The parameters are JSON array,
    and they need to be enclosed in square brackets. The important note is that the
    `exec` form does not invoke a command shell when the container is run. It just
    runs the executable provided as the first parameter. If the `ENTRYPOINT` instruction
    is present in the `Dockerfile` , `CMD` provides a default set of parameters for
    the `ENTRYPOINT` instruction.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD ["executable","parameter1","parameter2"]`：这是所谓的`exec`形式。这也是首选和推荐的形式。参数是JSON数组，它们需要用方括号括起来。重要的一点是，当容器运行时，`exec`形式不会调用命令shell。它只是运行提供的可执行文件作为第一个参数。如果`Dockerfile`中存在`ENTRYPOINT`指令，`CMD`为`ENTRYPOINT`指令提供了一组默认参数。'
- en: '`CMD command parameter1 parameter2` : This a shell form of the instruction.
    This time, the shell (if present in the image) will be processing the provided
    command. The specified binary will be executed with an invocation of the shell
    using `/bin/sh -c` . It means that if you display the container''s hostname, for
    example, using `CMD echo $HOSTNAME` , you should use the shell form of the instruction.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD command parameter1 parameter2`：这是指令的shell形式。这次，shell（如果存在于镜像中）将处理提供的命令。指定的二进制文件将使用`/bin/sh
    -c`调用shell来执行。这意味着，如果您使用`CMD echo $HOSTNAME`来显示容器的主机名，您应该使用指令的shell形式。'
- en: 'We have said before that the recommended form of `CMD` instruction is the `exec`
    form. Here''s why: everything started through the shell will be started as a subcommand
    of `/bin/sh -c` , which does not pass signals. This means that the executable
    will not be the container''s PID 1, and will not receive Unix signals, so your
    executable will not receive a `SIGTERM` from `docker stop <container>` . There
    is another drawback: you will need a shell in your container. If you''re building
    a minimal image, it doesn''t need to contain a shell binary. The `CMD` instruction
    using the shell form will simply fail.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，`CMD`指令的推荐形式是`exec`形式。原因在于：通过shell启动的所有内容都将作为`/bin/sh -c`的子命令启动，这不会传递信号。这意味着可执行文件不会成为容器的PID
    1，并且不会接收Unix信号，因此您的可执行文件将无法接收来自`docker stop <container>`的`SIGTERM`。还有另一个缺点：您将需要在容器中使用shell。如果您正在构建一个最小的镜像，它不需要包含shell二进制文件。使用shell形式的`CMD`指令将会简单失败。
- en: When Docker is executing the command, it doesn't check if the shell is available
    inside the container. If there is no `/bin/sh` in the image, the container will
    fail to start.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker执行命令时，它不会检查容器内是否有shell可用。如果镜像中没有`/bin/sh`，容器将无法启动。
- en: On the other hand, if we change the `CMD` to the `exec` form, Docker will be
    looking for an executable named `echo` , which, of course, will fail, because
    `echo` is a shell command.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们将`CMD`更改为`exec`形式，Docker将寻找一个名为`echo`的可执行文件，这当然会失败，因为`echo`是一个shell命令。
- en: Because `CMD` is the same as a starting point for the Docker engine when running
    a container, there can only be one single `CMD` instruction in a Dockerfile.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`CMD`在运行容器时与Docker引擎的起点相同，Dockerfile中只能有一个单独的`CMD`指令。
- en: If there are more than one `CMD` instruction in a Dockerfile, only the last
    one will take effect.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Dockerfile中有多个`CMD`指令，只有最后一个会生效。
- en: 'You may notice that the `CMD` instruction is very similar to `RUN` . They both
    can run any command (or application). There is a key important difference: the
    time of execution. The command supplied through the `RUN` instruction is executed
    during the build time, whereas the command specified through the `CMD` instruction
    is executed when the container is launched by executing `docker run` on the newly
    created image. Unlike `CMD` , the `RUN` instruction is actually used to build
    the image, by creating a new layer on top of the previous one which is committed.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到`CMD`指令与`RUN`非常相似。它们都可以运行任何命令（或应用程序）。但有一个重要的区别：执行时间。通过`RUN`指令提供的命令在构建时执行，而通过`CMD`指令指定的命令在通过`docker
    run`在新创建的镜像上启动容器时执行。与`CMD`不同，`RUN`指令实际上用于构建镜像，通过在之前的层上创建一个新的层来提交。
- en: '`RUN` is a build-time instruction, the `CMD` is a runtime instruction.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`是一个构建时指令，`CMD`是一个运行时指令。'
- en: 'Believe it or not, we can now have our REST example microservice containerized.
    Let''s check if it builds by executing the `mvn clean install` on the `pom.xml`
    file created in [Chapter 4](text00063.html) , *Creating Java Microservices* .
    After the successful build, we should have a target directory with the `rest-example-0.1.0.jar`
    file created. The Spring Boot application JAR in the `target` directory is an
    executable, fat JAR. We are going to run it from within the Docker container.
    Let''s write the basic `Dockerfile` using the command we already know and place
    it in the root of our project (this will be the context for our `docker build`
    command):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，我们现在可以将我们的REST示例微服务容器化。让我们通过在[第4章](text00063.html)中创建的`pom.xml`文件上执行`mvn
    clean install`来检查它是否构建成功，*创建Java微服务*。构建成功后，我们应该有一个包含`rest-example-0.1.0.jar`文件的`target`目录。`target`目录中的Spring
    Boot应用程序JAR是一个可执行的、厚重的JAR。我们将从Docker容器内运行它。让我们编写基本的`Dockerfile`，使用我们已经知道的命令，并将其放在我们项目的根目录（这将是我们`docker
    build`命令的上下文）：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now run the `docker build` command, using `rest-example` as the image
    name, omitting the tag (as you will remember, omitting a tag when building an
    image will result in creating the `latest` tag):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行`docker build`命令，使用`rest-example`作为镜像名称，省略标签（你会记得，在构建镜像时省略标签会导致创建`latest`标签）：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The dot as the first parameter specifies the context for the `docker build`
    command. In our case, it will be just a root directory of our little microservice.
    During the build process, Docker will output all the steps and layer IDs. Notice
    that almost every `Dockerfile` instruction creates a new layer. If you remember
    from [Chapter 1](text00022.html) , *Introduction to Docker* , Docker utilizes
    the layer cache. If a specific layer can be reused, it will be taken from the
    cache. It greatly improves the build process performance. At the end, Docker will
    output the ID of the newly created image, as you can see in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个参数的点指定了`docker build`命令的上下文。在我们的情况下，它将只是我们小微服务的根目录。在构建过程中，Docker将输出所有的步骤和层ID。请注意，几乎每个`Dockerfile`指令都会创建一个新的层。如果你还记得[第1章](text00022.html)，*Docker简介*，Docker利用了层缓存。如果特定的层可以被重用，它将从缓存中取出。这极大地提高了构建过程的性能。最后，Docker将输出新创建的镜像的ID，如下截图所示：
- en: '![](Image00068.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00068.jpg)'
- en: 'An image has been created, so it should be present on the images available
    to run. To list images, execute the following Docker command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像已经创建，所以应该可以运行。要列出镜像，执行以下Docker命令：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see in the following screenshot, our `rest-example` image is present
    and ready to be run:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如下截图所示，我们的`rest-example`镜像已经准备好可以运行了：
- en: '![](Image00069.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00069.jpg)'
- en: 'So far, so good. We have a basic form of our image built. Although the process
    of running images is the topic for [Chapter 6](text00108.html) , *Running Containers
    with Java Applications* , let''s quickly run it now to prove it''s working. To
    run the image, execute the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利。我们已经构建了我们的镜像的基本形式。虽然运行镜像的过程是[第6章](text00108.html)的主题，*使用Java应用程序运行容器*，让我们现在快速运行它来证明它正在工作。要运行镜像，执行以下命令：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After a while, you should see the familiar Spring Boot banner as a sign that
    our service is running from inside the Docker container:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 过一会儿，你应该会看到熟悉的Spring Boot横幅，这表明我们的服务是从Docker容器内部运行的：
- en: '![](Image00070.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00070.jpg)'
- en: That wasn't very tricky, right? The basic `Dockerfile` contains just three lines,
    the base image definition using `FROM` , `COPY` to transfer the executable jar
    into the image's filesystem, and a `CMD` instruction to run the service.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是很复杂，对吧？基本的`Dockerfile`只包含三行，使用`FROM`定义基础镜像，使用`COPY`将可执行的jar传输到镜像的文件系统中，以及使用`CMD`指令来运行服务。
- en: 'Building an application jar archive using Maven and then copying it using a
    Dockerfile `COPY` instruction simply works. What about delegating the build process
    to the Docker daemon itself? Well, we can do it, using the `Dockerfile` instructions
    we already know. The drawback of building a Java app using the Docker daemon is
    that the image will contain all of the JDK (including the Java compiler), Maven
    binaries, and our application source code. I would recommend building a single
    artifact (a JAR or WAR file), testing it thoroughly (using a release-oriented
    QA cycle), and deploying the sole artifact (with its dependencies of course) onto
    the target machine. However, to have an idea what''s possible with a `Dockerfile`
    , take a look at the following example, assuming that our application code in
    the `/app` folder on the local disk:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Maven构建应用程序jar存档，然后使用Dockerfile的`COPY`指令进行复制就可以了。那么，将构建过程委托给Docker守护进程本身呢？嗯，我们可以使用我们已经知道的`Dockerfile`指令来做到这一点。使用Docker守护进程构建Java应用程序的缺点是镜像将包含所有的JDK（包括Java编译器）、Maven二进制文件和我们的应用程序源代码。我建议构建一个单一的构件（JAR或WAR文件），进行彻底的测试（使用面向发布的QA周期），并将唯一的构件（当然还有它的依赖项）部署到目标机器上。然而，为了了解`Dockerfile`可能实现的功能，让我们看看以下示例，假设我们的应用程序代码在本地磁盘上的`/app`文件夹中：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the previous example, the Maven build process will be executed by Docker.
    We just run the `apt-get` command to install Maven, add our application source
    code to the image, execute the Maven `package` command, and then run our service.
    It will behave exactly the same as if we just copy the already-built artifact
    into the image's file system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，Maven构建过程将由Docker执行。我们只需运行`apt-get`命令来安装Maven，将我们的应用程序源代码添加到镜像中，执行Maven的`package`命令，然后运行我们的服务。它的行为将与我们将已构建的构件复制到镜像文件系统中完全相同。
- en: 'There''s a Dockerfile instruction which is kind of related to `CMD` instruction:
    the `ENTRYPOINT` . Let''s look at it now.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个Dockerfile指令与`CMD`指令有点相关：`ENTRYPOINT`。现在让我们来看看它。
- en: The ENTRYPOINT
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ENTRYPOINT
- en: 'The official Docker documentation says that the `ENTRYPOINT` instruction allows
    you to configure a container that will run as an executable. It''s not very clear,
    at least for the first time. The `ENTRYPOINT` instruction is related to the `CMD`
    instruction. In fact, it can be confusing at the beginning. The reason for that
    is simple: `CMD` was developed first, then `ENTRYPOINT` was developed for more
    customization, and some functionality overlaps between those two instructions.
    Let''s explain it a bit. The `ENTRYPOINT` specifies a command that will always
    be executed when the container starts. The `CMD` , on the other hand, specifies
    the arguments that will be fed to the `ENTRYPOINT` . Docker has a default `ENTRYPOINT`
    which is `/bin/sh -c` but does not have a default `CMD` . For example, consider
    this Docker command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的Docker文档说`ENTRYPOINT`指令允许您配置一个将作为可执行文件运行的容器。至少在第一次使用时，这并不是很清楚。`ENTRYPOINT`指令与`CMD`指令有关。实际上，起初可能会有些混淆。其原因很简单：`CMD`首先开发，然后为了更多的定制开发了`ENTRYPOINT`，这两个指令之间的一些功能重叠。让我们解释一下。`ENTRYPOINT`指定容器启动时将始终执行的命令。另一方面，`CMD`指定将传递给`ENTRYPOINT`的参数。Docker有一个默认的`ENTRYPOINT`，即`/bin/sh
    -c`，但没有默认的`CMD`。例如，考虑这个Docker命令：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, the image will be the latest `ubuntu` , the `ENTRYPOINT` will
    be the default `/bin/sh -c` , and the command passed to the `ENTRYPOINT` will
    be `echo "hello world"` .
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，镜像将是最新的`ubuntu`，`ENTRYPOINT`将是默认的`/bin/sh -c`，传递给`ENTRYPOINT`的命令将是`echo
    "hello world"`。
- en: The syntax for the `ENTRYPOINT` instruction can have two forms, similar to `CMD`
    .
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`指令的语法可以有两种形式，类似于`CMD`。'
- en: '`ENTRYPOINT ["executable", "parameter1", "parameter2"]` is the `exec` form,
    preferred and recommended. Exactly the same as the `exec` form of the `CMD` instruction,
    this will not invoke a command shell. This means that the normal shell processing
    will not happen. For example, `ENTRYPOINT [ "echo", "$HOSTNAME" ]` will not do
    variable substitution on the `$HOSTNAME` variable. If you want shell processing
    then you need either to use the shell form or execute a shell directly. For example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT ["executable", "parameter1", "parameter2"]`是`exec`形式，首选和推荐。与`CMD`指令的`exec`形式一样，这不会调用命令shell。这意味着不会发生正常的shell处理。例如，`ENTRYPOINT
    [ "echo", "$HOSTNAME" ]`将不会对`$HOSTNAME`变量进行变量替换。如果您需要shell处理，那么您需要使用shell形式或直接执行shell。例如：'
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Variables that are defined in the Dockerfile using `ENV` (we are going to cover
    this in a while), will be substituted by the Dockerfile parser.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dockerfile中使用`ENV`定义的变量（我们稍后会介绍），将被Dockerfile解析器替换。
- en: '`ENTRYPOINT command parameter1 parameter2` is a a shell form. Normal shell
    processing will occur. This form will also ignore any `CMD` or `docker run` command
    line arguments. Also, your command will not be PID 1, because it will be executed
    by the shell. As a result, if you then `run docker stop <container>` , the container
    will not exit cleanly, and the stop command will be forced to send a `SIGKILL`
    after the timeout.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT command parameter1 parameter2`是一个shell形式。将发生正常的shell处理。这种形式还将忽略任何`CMD`或`docker
    run`命令行参数。此外，您的命令将不会成为PID 1，因为它将由shell执行。因此，如果您然后运行`docker stop <container>`，容器将无法干净地退出，并且在超时后停止命令将被迫发送`SIGKILL`。'
- en: 'Exactly the same as with the `CMD` instruction, only the last `ENTRYPOINT`
    instruction in the Dockerfile will have an effect. Overriding the `ENTRYPOINT`
    in the Dockerfile allows you to have a different command processing your arguments
    when the container is run. If you need to change the default shell in your image,
    you can do this by changing an `ENTRYPOINT` :'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与`CMD`指令一样，Dockerfile中的最后一个`ENTRYPOINT`指令才会生效。在Dockerfile中覆盖`ENTRYPOINT`允许您在运行容器时有不同的命令处理您的参数。如果您需要更改图像中的默认shell，可以通过更改`ENTRYPOINT`来实现：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: From now on, all parameters from `CMD` , or provided when starting the container
    using `docker run` , will be processed by the Bash shell instead of the default
    `/bin/sh -c` .
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，所有来自`CMD`的参数，或者在使用`docker run`启动容器时提供的参数，将由Bash shell处理，而不是默认的`/bin/sh
    -c`。
- en: 'Consider this simple `Dockerfile` based on BusyBox. BusyBox is software that
    provides several stripped-down Unix tools in a single executable file. To demonstrate
    `ENTRYPOINT` , we are going to use a `ping` command from BusyBox:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个基于BusyBox的简单`Dockerfile`。BusyBox是一个软件，它在一个可执行文件中提供了几个精简的Unix工具。为了演示`ENTRYPOINT`，我们将使用BusyBox中的`ping`命令：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s build the image using the previous Dockerfile, by executing the command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用先前的Dockerfile构建镜像，执行以下命令：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you now run the container using the `ping` image, the `ENTRYPOINT` instruction
    will be processing arguments from the supplied `CMD` argument: it will be `localhost`
    by default in our case. Let''s run it, using the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在使用`ping`镜像运行容器，`ENTRYPOINT`指令将处理提供的`CMD`参数：在我们的情况下，默认情况下将是`localhost`。让我们运行它，使用以下命令：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As a result, you will have a `/bin/ping localhost` command-line response, as
    you can see in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您将得到一个`/bin/ping localhost`的命令行响应，如您在以下截图中所见：
- en: '![](Image00071.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00071.jpg)'
- en: The `CMD` instruction, as you will remember from its description, sets the default
    command and/or parameters, which can be overwritten from the command line when
    you run the container. The `ENTRYPOINT` is different, its command and parameters
    cannot be overwritten using the command line. Instead, all command line arguments
    will be appended after the `ENTRYPOINT` parameters. This way you can, kind of,
    lock the command that will be executed always during the container start.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`指令，正如你从描述中记得的那样，设置了默认命令和/或参数，当你运行容器时，可以从命令行覆盖它们。`ENTRYPOINT`不同，它的命令和参数不能被命令行覆盖。相反，所有命令行参数将被附加到`ENTRYPOINT`参数之后。这样你可以锁定在容器启动时始终执行的命令。'
- en: Unlike the `CMD` parameters, the `ENTRYPOINT` command and parameters are not
    ignored when a Docker container runs with command-line parameters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与`CMD`参数不同，当Docker容器使用命令行参数运行时，`ENTRYPOINT`命令和参数不会被忽略。
- en: 'Because the command-line parameter will be appended to the `ENTRYPOINT` parameters,
    we can run our `ping` image with different parameters passed to the `ENTRYPOINT`
    . Let''s try it, by running our ping example with different input:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因为命令行参数将被附加到`ENTRYPOINT`参数，我们可以通过传递给`ENTRYPOINT`的不同参数来运行我们的`ping`镜像。让我们尝试一下，通过使用不同的输入来运行我们的ping示例：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This time it will behave differently. The provided argument value `www.google.com`
    will be appended to the `ENTRYPOINT` , instead of the default `CMD` value provided
    in the Dockerfile. The total command line that will be executed will be `/bin/ping
    www.google.com` , as you can see in the following screenshot:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这次它的行为会有所不同。提供的参数值`www.google.com`将被附加到`ENTRYPOINT`，而不是Dockerfile中提供的默认`CMD`值。将执行的总命令行将是`/bin/ping
    www.google.com`，如你在下面的截图中所见：
- en: '![](Image00072.jpg)You can use the `exec` form of `ENTRYPOINT` to set fairly
    stable default commands and arguments and then use either form of `CMD` to set
    additional defaults that are more likely to be changed.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Image00072.jpg)您可以使用`exec`形式的`ENTRYPOINT`来设置相当稳定的默认命令和参数，然后使用`CMD`的任一形式来设置更有可能被更改的附加默认值。'
- en: 'Having the `ENTRYPOINT` instruction gives us a lot of flexibility. And, last
    but not least, an `ENTRYPOINT` can be also overridden when starting the container
    using the `--entrypoint` parameter for the `docker run` command. Note that you
    can override the `ENTRYPOINT` setting using `--entrypoint` , but this can only
    set the binary to execute (no `sh -c` will be used). As you can see, both `CMD`
    and `ENTRYPOINT` instructions define what command gets executed when running a
    container. Let''s summarize what we have learned about the differences and their
    cooperation:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`ENTRYPOINT`指令，我们就有了很多的灵活性。最后但并非最不重要的是，当使用`docker run`命令的`--entrypoint`参数启动容器时，`ENTRYPOINT`也可以被覆盖。请注意，你可以使用`--entrypoint`来覆盖`ENTRYPOINT`设置，但这只能设置要执行的二进制文件（不会使用`sh
    -c`）。正如你所见，`CMD`和`ENTRYPOINT`指令都定义了在运行容器时执行的命令。让我们总结一下我们对它们之间的区别和合作所学到的内容：
- en: A Dockerfile should specify at least one `CMD` or `ENTRYPOINT` instruction
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Dockerfile应该指定至少一个`CMD`或`ENTRYPOINT`指令
- en: Only the last `CMD` and `ENTRYPOINT` in a Dockerfile will be used
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile中只有最后一个`CMD`和`ENTRYPOINT`将被使用
- en: '`ENTRYPOINT` should be defined when using the container as an executable'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用容器作为可执行文件时，应该定义`ENTRYPOINT`
- en: You should use the `CMD` instruction as a way of defining default arguments
    for the command defined as `ENTRYPOINT` or for executing an `ad-hoc` command in
    a container
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该使用`CMD`指令来定义作为`ENTRYPOINT`定义的命令的默认参数，或者在容器中执行`ad-hoc`命令的方式
- en: '`CMD` will be overridden when running the container with alternative arguments'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用替代参数运行容器时，`CMD`将被覆盖
- en: '`ENTRYPOINT` sets the concrete default application that is used every time
    a container is created using the image'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`设置了每次使用该镜像创建容器时使用的具体默认应用程序。'
- en: If you couple `ENTRYPOINT` with `CMD` , you can remove an executable from `CMD`
    and just leave its arguments which will be passed to `ENTRYPOINT`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将`ENTRYPOINT`与`CMD`配对，你可以从`CMD`中删除一个可执行文件，只留下它的参数，这些参数将传递给`ENTRYPOINT`。
- en: The best use for `ENTRYPOINT` is to set the image's main command, allowing that
    image to be run as though it was that command (and then use `CMD` as the default
    flags)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`的最佳用法是设置镜像的主要命令，允许该镜像像执行该命令一样运行（然后使用`CMD`作为默认标志）。'
- en: Well, our service is running fine, but it's not very useful. First, it involves
    a lot of manual steps to get it running, that's why we are going to automate it
    later in this chapter using Maven. Second, as you will remember, our service listens
    for `HTTP` requests incoming on port number `8080` . Our basic image runs, but
    doesn't expose any network ports so no one and nothing can access the service.
    Let's continue learning about the remaining Dockerfile instructions to fix it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务运行正常，但并不是很有用。首先，启动它涉及许多手动步骤，这就是为什么我们将在本章后面使用Maven自动化它。其次，正如你会记得的，我们的服务监听着端口号为8080的HTTP请求。我们的基本镜像运行了，但没有暴露任何网络端口，因此没有人和没有东西可以访问该服务。让我们继续学习有关剩余的Dockerfile指令来修复它。
- en: EXPOSE
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EXPOSE
- en: The `EXPOSE` instruction informs Docker that the container listens on the specified
    network ports at runtime. We have already mentioned the `EXPOSE` instruction in
    [Chapter 2](text00037.html) , *Networking and Persistent Storage* . As you will
    remember, `EXPOSE` in a Dockerfile is the equivalent to the `--expose` command-line
    option. Docker uses the `EXPOSE` command followed by a port number to allow incoming
    traffic to the container. We already know that `EXPOSE` does not make the ports
    of the container automatically accessible on the host. To do that, you must use
    either the `-p` flag to publish a range of ports or the `-P` flag to publish all
    of the exposed ports at once.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`指令通知Docker容器在运行时监听指定的网络端口。我们已经在[第2章](text00037.html)中提到了`EXPOSE`指令，*网络和持久存储*。正如你会记得的，Dockerfile中的`EXPOSE`相当于`--expose`命令行选项。Docker使用`EXPOSE`命令后跟端口号来允许流入的流量到达容器。我们已经知道`EXPOSE`不会自动使容器的端口在主机上可访问。要做到这一点，你必须使用`-p`标志来发布一系列端口，或者使用`-P`标志一次发布所有暴露的端口。'
- en: 'Let''s get back to our `Dockerfile` and expose a port:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`Dockerfile`并暴露一个端口：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you now re-build the image using the same command, `docker build . -t rest-example`
    , you''ll notice that Docker outputs the fourth layer, saying that port `8080`
    has been exposed. Exposed ports will be available for the other containers on
    this Docker host, and, if you map them during runtime, also for the external world.
    Well, let''s try it, using the following `docker run` command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在使用相同的命令重新构建镜像，`docker build . -t rest-example`，你会注意到Docker输出了第四层，表示端口8080已经被暴露。暴露的端口将对此Docker主机上的其他容器可用，并且如果在运行时映射它们，也对外部世界可用。好吧，让我们尝试一下，使用以下`docker
    run`命令：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you now call the localhost with a `HTTP` request such as `POST` (for saving
    our book entities) or `GET` (for getting the list of books or a single book) as
    we have done in [Chapter 4](text00063.html) , *Creating Java Microservices* ,
    using any of the HTTP tools such as HTTPie or Postman, it will respond the same
    as before. This time, however, from with the Docker container. Now, this is something.
    Let's get to know the remaining important Dockerfile instructions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在使用`HTTP`请求调用本地主机，比如`POST`（用于保存我们的图书实体）或`GET`（用于获取图书列表或单本图书），就像我们在[第4章](text00063.html)中所做的那样，*创建Java微服务*，使用任何HTTP工具，比如HTTPie或Postman，它将像以前一样做出响应。但是，这一次是来自Docker容器。现在，这是一件了不起的事情。让我们了解剩下的重要的Dockerfile指令。
- en: VOLUME
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VOLUME
- en: As you will remember from [Chapter 1](text00022.html) , *Introduction to Docker*
    , container file systems are kind of temporary by default. If you start a Docker
    image up (that is, run the container), you'll end up with a read-write layer on
    top of the layer's stack. You can create, modify, and delete files as you wish,
    then commit the layer to persist the changes. In [Chapter 2](text00037.html) ,
    *Networking and Persistent Storage,* we have learned how to create volumes, which
    is a great way of storing and retrieving data from the Docker container. We can
    do the same in the `Dockerfile` , using the `VOLUME` instruction.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第1章](text00022.html)中所记得的，*Docker简介*，容器文件系统默认是临时的。如果您启动Docker镜像（即运行容器），您将得到一个读写层，该层位于堆栈的顶部。您可以随意创建，修改和删除文件，然后提交该层以保留更改。在[第2章](text00037.html)中，*网络和持久存储*，我们已经学会了如何创建卷，这是一种很好的存储和检索数据的方法。我们可以在`Dockerfile`中使用`VOLUME`指令做同样的事情。
- en: 'The syntax couldn''t be simpler: it''s just `VOLUME ["/volumeName"]` .'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 语法再简单不过了：就是`VOLUME ["/volumeName"]`。
- en: 'The parameter for `VOLUME` can be a JSON array, a plain string with one or
    more arguments. For example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME`的参数可以是JSON数组，也可以是一个带有一个或多个参数的普通字符串。例如：'
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `VOLUME` instruction creates a mount point with the specified name and marks
    it as holding externally mounted volumes from a native host or other containers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME`指令创建一个具有指定名称的挂载点，并将其标记为包含来自本机主机或其他容器的外部挂载卷。'
- en: 'The `VOLUME` command will mount a directory inside your container and store
    any files created or edited inside that directory on your host''s disk outside
    the container file structure. Using `VOLUME` in the `Dockerfile` let''s Docker
    know that a certain directory contains permanent data. Docker will create a volume
    for that data and never delete it, even if you remove all the containers that
    use it. It also bypasses the union file system, so that the volume is in fact
    an actual directory that gets mounted, either read-write or read-only, in the
    right place, in all the containers that share it (if they are started with the
    `--volumes-from` option, for example). To understand `VOLUME` , let''s look at
    the simple Dockerfile:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME`命令将在容器内部挂载一个目录，并将在该目录内创建或编辑的任何文件存储在容器文件结构之外的主机磁盘上。在`Dockerfile`中使用`VOLUME`让Docker知道某个目录包含永久数据。Docker将为该数据创建一个卷，并且即使删除使用它的所有容器，也不会删除它。它还绕过了联合文件系统，因此该卷实际上是一个实际的目录，它会在所有共享它的容器中（例如，如果它们使用`--volumes-from`选项启动）以正确的方式挂载，无论是读写还是只读。要理解`VOLUME`，让我们看一个简单的Dockerfile：'
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you now run your container and save some files in the `/var/myVolume` , they
    will be available for other containers for sharing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行容器并在`/var/myVolume`中保存一些文件，它们将可供其他容器共享。
- en: Basically, `VOLUME` and `-v` are almost equal. The difference between `VOLUME`
    and `-v` is that you can use `-v` dynamically and mount your `host` directory
    on your container when starting it by executing `docker run` . The reason for
    that is Dockerfiles are meant to be portable and shared. The host directory volume
    is 100% host dependent and will break on any other machine, which is a little
    bit off the Docker idea. Because of this, it is only possible to use portable
    instructions within a Dockerfile.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`VOLUME`和`-v`几乎是相等的。`VOLUME`和`-v`之间的区别在于，您可以在执行`docker run`启动容器时动态使用`-v`并将您的`host`目录挂载到容器上。这样做的原因是Dockerfile旨在具有可移植性和共享性。主机目录卷是100%依赖于主机的，并且在任何其他机器上都会出现问题，这与Docker的理念有些不符。因此，在Dockerfile中只能使用可移植指令。
- en: 'The fundamental difference between `VOLUME` and `-v` is this: `-v` will mount
    existing files from your operating system inside your Docker container and `VOLUME`
    will create a new, empty volume on your host and mount it inside your container.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME`和`-v`之间的根本区别在于：`-v`会将操作系统中现有的文件挂载到Docker容器内，而`VOLUME`会在主机上创建一个新的空卷，并将其挂载到容器内。'
- en: LABEL
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LABEL
- en: 'To add the metadata to our image, we use the `LABEL` instruction. A single
    label is a key-value pair. If you need to have spaces in the label value, you
    will need to wrap it in a pair of quotes. Labels are additive, they include all
    labels taken from an image that is the base of your own image (the one from the
    `FROM` instruction). If Docker encounters a label that already exists, it will
    override the label having the same key with the new value. There are some rules
    that you must stick to when defining labels: keys can only consist of lowercase
    alphanumeric characters, dots, and dashes, and must begin and end with alphanumeric
    characters. To prevent naming conflicts, Docker recommends using namespaces to
    label keys using reverse domain notation. On the other hand, keys without namespaces
    (dots) are reserved for command-line use.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向我们的镜像添加元数据，我们使用`LABEL`指令。单个标签是一个键值对。如果标签值中需要有空格，您需要用引号将其包裹起来。标签是可累加的，它们包括从作为您自己镜像基础的镜像（`FROM`指令中的镜像）中获取的所有标签。如果Docker遇到已经存在的标签，它将用新值覆盖具有相同键的标签。在定义标签时，有一些规则必须遵守：键只能由小写字母数字字符、点和破折号组成，并且必须以字母数字字符开头和结尾。为了防止命名冲突，Docker建议使用反向域表示法为标签键使用命名空间。另一方面，没有命名空间（点）的键保留供命令行使用。
- en: 'The syntax of the `LABEL` instruction is straightforward:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`LABEL`指令的语法很简单：'
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To have a multiline value, separate the lines with backslashes; for example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用多行值，请使用反斜杠将行分隔开；例如：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can have multiple labels in a single image. Provide them separated with
    a space or a backslash; for example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在单个镜像中拥有多个标签。用空格或反斜杠分隔它们；例如：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Actually, if you need to have multiple labels in your image, it's recommended
    to use the multi-label form of the `LABEL` instruction, because it will result
    in just one additional layer in the image.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果您的镜像中需要有多个标签，建议使用`LABEL`指令的多标签形式，因为这样会在镜像中只产生一个额外的层。
- en: Each `LABEL` instruction creates a new layer. If your image has many labels,
    use the multiple form of the single `LABEL` instruction.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`LABEL`指令都会创建一个新的层。如果您的镜像有很多标签，请使用单个`LABEL`指令的多重形式。
- en: If you want to inspect what labels an image has, use the `docker inspect` command
    you already know about from the previous chapters.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要查看镜像具有哪些标签，可以使用您已经在之前章节中了解过的`docker inspect`命令。
- en: ENV
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ENV
- en: '`ENV` is a `Dockerfile` instruction that sets the environment variable `<key>`
    to the value `<value>` . You have two options for using `ENV` :'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV`是一个`Dockerfile`指令，它将环境变量`<key>`设置为值`<value>`。您可以有两种选项来使用`ENV`：'
- en: 'The first one, `ENV <key> <value>` , will set a single variable to a value.
    The entire string after the first space will be treated as the `<value>` . This
    will include any character, and also spaces and quotes. For example:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个，`ENV <key> <value>` ，将一个单一变量设置为一个值。第一个空格后的整个字符串将被视为 `<value>` 。这将包括任何字符，还有空格和引号。例如：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The second one, with an equal sign, is `ENV <key>=<value>` . This form allows
    setting multiple environment variables at once. If you need to provide spaces
    in the values, you will need to use quotes. If you need quotes in the values,
    use backslashes:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个，带有等号的是 `ENV <key>=<value>` 。这种形式允许一次设置多个环境变量。如果需要在值中提供空格，您需要使用引号。如果需要在值中使用引号，使用反斜杠：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that you can use `ENV` to update the `PATH` environment variable, and
    then `CMD` parameters will be aware of that setting. This will result in a cleaner
    form of `CMD` parameters in the `Dockerfile` . For example, set the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以使用 `ENV` 更新 `PATH` 环境变量，然后 `CMD` 参数将意识到该设置。这将导致 `Dockerfile` 中 `CMD`
    参数的更清晰形式。例如，设置如下：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will ensure that `CMD ["startup.sh"]` will work, because it will find
    the `startup.sh` file in the system `PATH` . You can also use `ENV` to set the
    often-modified version numbers so that upgrades are easier to handle, as seen
    in the following example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保 `CMD ["startup.sh"]` 起作用，因为它将在系统 `PATH` 中找到 `startup.sh` 文件。您还可以使用 `ENV`
    设置经常修改的版本号，以便更容易处理升级，如下例所示：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the previous example, Docker will download the version of Tomcat specified
    in the `ENV` variable, extract it to the new directory with that version in its
    name, and also set up the system `PATH` to make it available for running.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，Docker 将下载 `ENV` 变量中指定的 Tomcat 版本，将其提取到具有该版本名称的新目录中，并设置系统 `PATH` 以使其可用于运行。
- en: The environment variables set using `ENV` will persist when a container is run
    from the resulting image. The same as with labels created with `LABEL` , you can
    view the `ENV` values using the `docker inspect` command. The `ENV` values can
    also be overridden just before the start of the container, using `docker run --env
    <key>=<value>` .
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ENV` 设置的环境变量将在从生成的镜像运行容器时持续存在。与使用 `LABEL` 创建的标签一样，您可以使用 `docker inspect`
    命令查看 `ENV` 值。`ENV` 值也可以在容器启动之前使用 `docker run --env <key>=<value>` 覆盖。
- en: USER
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: USER
- en: The `USER` instruction sets the username or UID to use when running the image.
    It will affect the user for any `RUN` , `CMD` , and `ENTRYPOINT` instructions
    that will come next in the `Dockerfile` .
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER` 指令设置运行镜像时要使用的用户名或 UID。它将影响 `Dockerfile` 中接下来的任何 `RUN` 、`CMD` 和 `ENTRYPOINT`
    指令的用户。'
- en: 'The syntax of the instruction is just `USER <user name or UID>` ; for example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 指令的语法只是 `USER <用户名或 UID>` ；例如：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can use the `USER` command if an executable can be run without privileges.
    The Dockerfile can contain the user and group creation instruction the same as
    this one:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可执行文件可以在没有特权的情况下运行，可以使用 `USER` 命令。Dockerfile 可以包含与此相同的用户和组创建指令：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Switching USER back and forth frequently will increase the number of layers
    in the resulting image and also will make the Dockerfile more complex.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 频繁切换用户将增加生成镜像中的层数，并使 Dockerfile 更加复杂。
- en: ARG
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARG
- en: 'The `ARG` instruction is being used to pass an argument to the Docker daemon
    during the `docker build` command. An `ARG` variable definition comes into effect
    from the line on which it is defined in the `Dockerfile` . By using the `--build-arg`
    switch, you can assign a value to the defined variable:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARG` 指令用于在 `docker build` 命令期间向 Docker 守护程序传递参数。`ARG` 变量定义从 `Dockerfile` 中定义的行开始生效。通过使用
    `--build-arg` 开关，您可以为已定义的变量分配一个值：'
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The value from the `--build-arg` will be passed to the daemon building the
    image. You can specify multiple arguments using multiple `ARG` instructions. If
    you specify a build time argument that is not defined using `ARG` , the build
    will fail with an error, but the default value can be specified in the `Dockerfile`
    . You specify the default argument value this way:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从`--build-arg`中的值将传递给构建图像的守护程序。您可以使用多个`ARG`指令指定多个参数。如果您指定了未使用`ARG`定义的构建时间参数，构建将失败并显示错误，但可以在`Dockerfile`中指定默认值。您可以通过以下方式指定默认参数值：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If no argument will be specified before starting the build, the default value
    will be used:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在开始构建之前未指定任何参数，则将使用默认值：
- en: It is not recommended to use `ARG` for passing secrets as GitHub keys, user
    credentials, passwords, and so on, as all of them will be visible to any user
    of the image by using the `docker history` command!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议使用`ARG`传递秘密，如GitHub密钥、用户凭据、密码等，因为所有这些都将通过使用`docker history`命令对图像的任何用户可见！
- en: ONBUILD
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ONBUILD
- en: The `ONBUILD` instruction specifies an additional instruction which will be
    triggered when some other image is built by using this image as its base image.
    In other words, the `ONBUILD` instruction is an instruction the parent `Dockerfile`
    gives to the child `Dockerfile` ( downstream build). Any build instruction can
    be registered as a trigger and those instructions will be triggered immediately
    after the `FROM` instruction in the `Dockerfile` .
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令指定了另一个指令，当使用此图像作为其基础图像构建其他图像时将触发该指令。换句话说，`ONBUILD`指令是父`Dockerfile`给子`Dockerfile`（下游构建）的指令。任何构建指令都可以注册为触发器，并且这些指令将在`Dockerfile`中的`FROM`指令之后立即触发。'
- en: 'The syntax of the `ONBUILD` instruction is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令的语法如下：'
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Within this, `<INSTRUCTION>` is another Dockerfile build instruction, which
    will be triggered later when the child image is going to be built. There are some
    limitations: the `ONBUILD` instruction does not allow the chaining of another
    `ONBUILD` instruction and it does not allow the `FROM` and `MAINTAINER` instructions
    as `ONBUILD` triggers.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，`<INSTRUCTION>`是另一个Dockerfile构建指令，稍后将在构建子图像时触发。有一些限制：`ONBUILD`指令不允许链接另一个`ONBUILD`指令，也不允许`FROM`和`MAINTAINER`指令作为`ONBUILD`触发器。
- en: 'This is useful if you are building an image which will be used as a base to
    build other images. For example, an application build environment or a daemon
    which may be customized with a user-specific configuration. The `ONBUILD` instruction
    is very useful ([https://docs.docker.com/engine/reference/builder/#onbuild](https://docs.docker.com/engine/reference/builder/#onbuild)
    and [https://docs.docker.com/engine/reference/builder/#maintainer-deprecated](https://docs.docker.com/engine/reference/builder/#maintainer-deprecated)
    ), for automating the build of your chosen software stack. Consider the following
    example with Maven and building Java applications (yes, Maven is also available
    as a Docker container). Basically, all your project''s Dockerfile needs to do
    is reference the base container containing the `ONBUILD` instructions:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这在构建将用作基础构建其他图像的图像时非常有用。例如，应用程序构建环境或可能使用用户特定配置进行定制的守护程序。`ONBUILD`指令非常有用（[https://docs.docker.com/engine/reference/builder/#onbuild](https://docs.docker.com/engine/reference/builder/#onbuild)和[https://docs.docker.com/engine/reference/builder/#maintainer-deprecated](https://docs.docker.com/engine/reference/builder/#maintainer-deprecated)），用于自动构建所选软件堆栈。考虑以下使用Maven构建Java应用程序的示例（是的，Maven也可以作为Docker容器使用）。基本上，您项目的Dockerfile只需要引用包含`ONBUILD`指令的基础容器即可：
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'There''s no magic, and everything becomes clear if you look into the parent''s
    Dockerfile. In our case, it will be a `docker-maven` Dockerfile available on GitHub:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 没有魔法，如果您查看父级的Dockerfile，一切都会变得清晰。在我们的情况下，它将是GitHub上可用的`docker-maven` Dockerfile：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There's a base image that has both Java and Maven installed and a series of
    instructions to copy files and run Maven.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个基础镜像，其中安装了Java和Maven，并有一系列指令来复制文件和运行Maven。
- en: The `ONBUILD` instruction adds to the image a trigger instruction to be executed
    at a later time, when the image is used as the base for another build. The trigger
    will be executed in the context of the child build, as if it had been inserted
    immediately after the `FROM` instruction in the child `Dockerfile` .
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令会向镜像添加一个触发指令，以便在将来作为另一个构建的基础时执行。触发器将在子构建的上下文中执行，就好像它被立即插入到子`Dockerfile`中的`FROM`指令之后一样。'
- en: When Docker encounters an `ONBUILD` instruction during the build process, the
    builder adds a kind of trigger to the metadata of the image being built. But this
    is the only way this image is being affected. At the end of the build, a list
    of all triggers is stored in the image manifest, under the key `OnBuild` . You
    can see them using the `docker inspect` command, which we already know.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker在构建过程中遇到`ONBUILD`指令时，构建器会向正在构建的镜像的元数据中添加一种触发器。但这是影响到该镜像的唯一方式。在构建结束时，所有触发器的列表将存储在镜像清单中，键为`OnBuild`。您可以使用我们已经知道的`docker
    inspect`命令来查看它们。
- en: Later the image may be used as a base for a new build, using the `FROM` instruction.
    As part of processing the `FROM` instruction, the Docker builder looks for `ONBUILD`
    triggers, and executes them in the same order they were registered. If any of
    the triggers fail, the `FROM` instruction is aborted which will make the build
    fail. If all triggers succeed, the `FROM` instruction completes and the build
    resumes.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，该镜像可以作为新构建的基础，使用`FROM`指令。在处理`FROM`指令时，Docker构建器会寻找`ONBUILD`触发器，并按照它们注册的顺序执行它们。如果任何触发器失败，`FROM`指令将被中止，这将导致构建失败。如果所有触发器成功，`FROM`指令完成，构建继续进行。
- en: STOPSIGNAL
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: STOPSIGNAL
- en: 'To specify what system call signal should be sent to the container to exit,
    use the `STOPSIGNAL` instruction. This signal can be a valid unsigned number that
    matches a position in the kernel''s `syscall` table: for instance `9` , or a signal
    name in the format `SIGNAME` , for instance `SIGKILL` .'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定应发送哪个系统调用信号以退出容器，请使用`STOPSIGNAL`指令。该信号可以是与内核的`syscall`表中的位置匹配的有效无符号数字，例如`9`，或者是格式为`SIGNAME`的信号名称，例如`SIGKILL`。
- en: HEALTHCHECK
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HEALTHCHECK
- en: The `HEALTHCHECK` instruction can be used to inform Docker how to test a container
    to check that it is still working. This can be checking if our rest service responds
    to `HTTP` calls or just listens on a specified port.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEALTHCHECK`指令可用于通知Docker如何测试容器以检查其是否仍在工作。这可以是检查我们的REST服务是否响应`HTTP`调用，或者只是监听指定的端口。'
- en: A container can have several statuses which can be listed using the `docker
    ps` command. These can be `created` , `restarting` , `running` , `paused` , `exited`
    , or `dead` . But sometimes this is not enough; a container may be still alive
    from Docker's point of view, but the application can hang or fail in some other
    way. An additional checking for the application status can be useful and `HEALTHCHECK`
    comes in handy.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 容器可以有几种状态，可以使用`docker ps`命令列出。这些可以是`created`，`restarting`，`running`，`paused`，`exited`或`dead`。但有时这还不够；从Docker的角度来看，容器可能仍然存活，但应用程序可能会挂起或以其他方式失败。对应用程序状态的额外检查可能很有用，`HEALTHCHECK`非常方便。
- en: The `HEALTHCHECK` status is initially starting. Whenever a health check passes,
    it becomes `healthy` (whatever state it was previously in). After a certain number
    of consecutive failures, it becomes `unhealthy` .
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEALTHCHECK`状态最初为starting。每当健康检查通过时，它就变为`healthy`（无论之前处于什么状态）。在连续失败一定次数后，它就会变为`unhealthy`。'
- en: 'The syntax for a `HEALTHCHECK` instruction is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEALTHCHECK`指令的语法如下：'
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `<interval>` (the default value is 30 seconds) and `<timeout>` (again,
    the default is 30 seconds) are time values, specifying the checking interval and
    timeout accordingly. The `<command>` is the command actually being used to check
    if the application is still running. The exit code of the `<command>` is being
    used by Docker to determine if a health check failed or succeeded. The values
    can be `0` , meaning the container is healthy and ready for use and `1` meaning
    that something is wrong and the container is not working correctly. The Java microservice
    `healthcheck` implementation could be just a simple `/ping` REST endpoint, returning
    whatever (as a timestamp) or even returning an empty response with `HTTP 200`
    status code proving it''s alive. Our `HEALTHCHECK` could execute a `GET` method
    on this endpoint, checking if the service is responding:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`<interval>`（默认值为30秒）和`<timeout>`（同样，默认值为30秒）是时间值，分别指定检查间隔和超时时间。`<command>`是实际用于检查应用程序是否仍在运行的命令。`<command>`的退出代码被Docker用来确定健康检查是失败还是成功。值可以是`0`，表示容器健康并且可以使用，也可以是`1`，表示出现了问题，容器无法正常工作。Java微服务的`healthcheck`实现可以是一个简单的`/ping`
    REST端点，返回任何内容（如时间戳），甚至可以返回一个空响应和`HTTP 200`状态码，证明它还活着。我们的`HEALTHCHECK`可以执行对这个端点的`GET`方法，检查服务是否响应。'
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the previous example, the command `curl -f http://localhost/ping` will be
    executed every 5 minutes, for the maximum timeout of 2 seconds. If a single run
    of the check takes longer than 2 seconds then the check is considered to have
    failed. If three consecutive retries fail, the container will get the `unhealthy`
    status.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，命令`curl -f http://localhost/ping`将每5分钟执行一次，最长超时时间为2秒。如果检查的单次运行时间超过2秒，则认为检查失败。如果连续三次重试失败，容器将获得`unhealthy`状态。
- en: There can only be one `HEALTHCHECK` instruction in a Dockerfile. If you list
    more than one then only the last `HEALTHCHECK` will take effect.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile中只能有一个`HEALTHCHECK`指令。如果列出多个，则只有最后一个`HEALTHCHECK`会生效。
- en: The `HEALTCHECK` instruction gives you the possibility to fine tune the container
    monitoring, and thus be sure that your container is working fine. It's better
    than just `running` , `exited` or `dead` standard Docker status.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEALTHCHECK`指令使您有可能微调容器监控，从而确保容器正常工作。这比仅有`running`、`exited`或`dead`标准Docker状态要好。'
- en: Now that we have an understanding of `Dockerfile` instructions, we are ready
    to prepare our images. Let's automate things a bit. We are going to create and
    run our image using Maven.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`Dockerfile`指令，我们准备好准备我们的图像。让我们自动化一些事情。我们将使用Maven创建和运行我们的图像。
- en: Creating an image using Maven
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven创建图像
- en: 'Naturally, we could build our Docker image using Docker itself. But this is
    not a typical use case for Spring developers. A typical use case for us would
    be to use Maven. This can be especially useful, if you have continuous integration
    flow set up, using Jenkins for example. Delegating the image build process to
    Maven gives you a lot of flexibility and also saves a lot of time. There is at
    least a couple of Docker Maven plugins available for free on GitHub, such as:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用Docker本身来构建我们的Docker镜像。但这不是Spring开发人员的典型用例。对我们来说，典型的用例是使用Maven。如果你已经设置了持续集成流程，例如使用Jenkins，这将特别有用。将镜像构建过程委托给Maven可以给你很大的灵活性，也可以节省大量时间。目前在GitHub上至少有几个免费的Docker
    Maven插件可用，例如：
- en: '[https://github.com/spotify/docker-maven-plugin](https://github.com/spotify/docker-maven-plugin)
    : A Maven plugin for building and pushing Docker images by Spotify.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/spotify/docker-maven-plugin](https://github.com/spotify/docker-maven-plugin)：Spotify提供的用于构建和推送Docker镜像的Maven插件。'
- en: "[https://github.com/alexec/docker-maven-plugin](https://github.com/alexec/docker-maven-plugin)\
    \ . [\uFEFF](https://github.com/alexec/docker-maven-plugin)"
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/alexec/docker-maven-plugin](https://github.com/alexec/docker-maven-plugin)。'
- en: '[https://github.com/fabric8io/docker-maven-plugin](https://github.com/fabric8io/docker-maven-plugin)
    : This is the one I find to be most useful and configurable. Of all the Maven
    plugins for Docker at the time of writing, Fabric8 seems to be the most robust.
    Fabric8 is an integrated open source DevOps and integration platform which works
    out of the box on any Kubernetes or OpenShift environment and provides continuous
    delivery, management, ChatOps, and a Chaos Monkey. We are going to use this one
    for the rest of the chapter.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/fabric8io/docker-maven-plugin](https://github.com/fabric8io/docker-maven-plugin)：这是我发现最有用和可配置的插件。在撰写本文时，Fabric8似乎是最健壮的Maven
    Docker插件。Fabric8是一个集成的开源DevOps和集成平台，可以在任何Kubernetes或OpenShift环境上即插即用，并提供持续交付、管理、ChatOps和Chaos
    Monkey。我们将在本章的其余部分使用这个插件。'
- en: 'Our use case will be using Maven to package the Spring Boot executable JAR,
    and then have that build artifact copied into the Docker image. Using the Maven
    plugin for Docker focuses on two major aspects:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用例将使用Maven打包Spring Boot可执行JAR文件，然后将构建产物复制到Docker镜像中。使用Maven插件来构建Docker主要关注两个方面：
- en: Building and pushing Docker images which contain build artifacts
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和推送包含构建产物的Docker镜像
- en: Starting and stopping Docker containers for integration testing and development.
    This is what we are going to focus on in [Chapter 6](text00108.html) , *Running
    Containers with Java Applications*
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和停止Docker容器进行集成测试和开发。这是我们将在[第6章](text00108.html)中专注的内容，*使用Java应用程序运行容器*
- en: Let's focus on creating an image now starting with the plugin goals and possible
    configuration options.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在专注于创建一个镜像，从插件目标和可能的配置选项开始。
- en: 'The fabric8 Docker plugin provides a couple of Maven goals:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: fabric8 Docker插件提供了一些Maven目标：
- en: '`docker:build` : This uses the assembly descriptor format from the maven-assembly-plugin
    to specify the content which will be added from a sub-directory in the image (`/maven`
    by default)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker:build`：这使用maven-assembly-plugin的装配描述符格式来指定将从子目录（默认为`/maven`）添加到镜像中的内容'
- en: '`docker:push` : Images that are built with this plugin can be pushed to public
    or private Docker registries'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker:push`：使用此插件构建的镜像可以推送到公共或私有的Docker注册表'
- en: '`docker:start` and `docker:stop` : For or starting and stopping the container'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker:start`和`docker:stop`：用于启动和停止容器'
- en: '`docker:watch` : This will execute `docker:build` and `docker:run` sequentially.
    It can run forever in the background (separate console), unless you stop it with
    CTRL+C. It can watch for assembly files changing and re-run the build. It saves
    a lot of time'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker:watch`：这将依次执行`docker:build`和`docker:run`。它可以在后台永远运行（单独的控制台），除非您使用CTRL+C停止它。它可以监视装配文件的更改并重新运行构建。这样可以节省很多时间。'
- en: '`docker:remove` : This is for cleaning up the images and containers'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker:remove`：用于清理镜像和容器'
- en: '`docker:logs` : This prints out the output of the running containers'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker:logs`：这会打印出正在运行的容器的输出'
- en: '`docker:volume-create` and `docker:volume-remove` : For creating and removing
    volumes, respectively. We will get back to these later in this chapter'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker:volume-create`和`docker:volume-remove`：分别用于创建和删除卷。我们将在本章后面再回到这些内容'
- en: 'Before we can run these targets, we need to instruct the plugin how it should
    behave. We do it in the plugin configuration in the project''s `pom.xml` file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行这些目标之前，我们需要告诉插件它应该如何行为。我们在项目的`pom.xml`文件中的插件配置中进行配置：
- en: Maven Docker plugin configuration
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven Docker插件配置
- en: 'The important part in the plugin definition is the `<configuration>` element.
    This is where you set up the plugin''s behavior. There are two main elements in
    the `<configuration>` :'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 插件定义中的重要部分是`<configuration>`元素。这是您设置插件行为的地方。`<configuration>`中有两个主要元素：
- en: A `<build>` configuration specifying how images are built
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定如何构建镜像的`<build>`配置
- en: A `<run>` configuration describing how containers should be created and started
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述如何创建和启动容器的`<run>`配置
- en: 'Here is a simplest example of the configuration for the `fabric8` Maven plugin
    for Docker:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`fabric8` Maven插件的Docker的配置的最简单的示例：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `<dockerHost>` specifies the IP address and the port of the running Docker
    engine, so of course, to make it build you will need to have Docker running first.
    In the previous case, if you run the `mvn clean package docker:build` command
    from the shell, the Fabric8 Docker plugin will build the image using the `Dockerfile`
    you provide. But there is another way of building the image, using no `Dockerfile`
    at all, at least not defined explicitly. To do this, we need to change the plugin
    configuration a bit. Take a look at the modified configuration:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`<dockerHost>`指定正在运行的Docker引擎的IP地址和端口，因此，当然，要使其构建，您首先需要运行Docker。在前面的情况下，如果您从shell运行`mvn
    clean package docker:build`命令，Fabric8 Docker插件将使用您提供的`Dockerfile`构建镜像。但是还有另一种构建图像的方法，根本不使用`Dockerfile`，至少不是显式定义的。要做到这一点，我们需要稍微更改插件配置。看一下修改后的配置：'
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, we no longer deliver a `Dockerfile` . Instead, we just provide
    the `Dockerfile` instructions as plugin configuration elements. It''s very convenient
    because we no longer need to hardcode an executable jar name, version, and so
    on. It will be taken from the Maven build scope. For example, the name of the
    jar will be provided for the `<cmd>` element. It will result in the generation
    of a valid `CMD` instruction in the `Dockerfile` automatically. If we now build
    the project using the `mvn clean package docker:build` command, Docker will build
    an image with our application. Let''s list the configuration elements available
    for us, alphabetically:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们不再提供`Dockerfile`。相反，我们只提供`Dockerfile`指令作为插件配置元素。这非常方便，因为我们不再需要硬编码可执行jar名称、版本等。它将从Maven构建范围中获取。例如，jar的名称将被提供给`<cmd>`元素。这将自动导致在`Dockerfile`中生成有效的`CMD`指令。如果我们现在使用`mvn
    clean package docker:build`命令构建项目，Docker将使用我们的应用程序构建一个镜像。让我们按字母顺序列出我们可用的配置元素：
- en: '| **Element** | **Description** |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| **元素** | **描述** |'
- en: '| `assembly` | The `<assembly>` element defines how to build artifacts and
    other files that can enter the Docker image. You can use `targetDir` element to
    provide a directory under which the files and artifacts contained in the assembly
    will be copied into the image. The default value for this is `/maven` . In our
    example, we will use `<descriptorRef>` to provide one of the predefined assembly
    descriptors. The `<descriptorRef>` is kind of a handy shortcut, which can take
    the following values:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '| `assembly` | `<assembly>` 元素定义了如何构建进入 Docker 镜像的构件和其他文件。您可以使用 `targetDir`
    元素提供一个目录，其中包含装配中包含的文件和构件将被复制到镜像中。这个元素的默认值是 `/maven`。在我们的示例中，我们将使用 `<descriptorRef>`
    提供预定义装配描述符之一。`<descriptorRef>` 是一种方便的快捷方式，可以取以下值：'
- en: '`artifact-with-dependencies` : Attaches a project''s artifact and all its dependencies.
    Also, when a classpath file exists in the target directory, this will be added
    to.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`artifact-with-dependencies` : 附加项目的构件和所有依赖项。此外，当类路径文件存在于目标目录中时，它将被添加进去。'
- en: '`artifact` : Attaches only the project''s artifact but no dependencies.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`artifact` : 仅附加项目的构件，而不包括依赖项。'
- en: '`project` : Attaches the whole Maven project but without the `target/` directory.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project` : 附加整个 Maven 项目，但不包括 `target/` 目录。'
- en: '`rootWar` : Copies the artifact as `ROOT.war` to the `exposed` directory. For
    example, Tomcat can then deploy the war under `root` context.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rootWar` : 将构件复制为 `ROOT.war` 到 `exposed` 目录。例如，Tomcat 可以在 `root` 上下文中部署 war
    文件。'
- en: '|'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `buildArgs` | Allows for providing a map specifying the value of Docker `buildArgs`
    , which should be used when building the image with an external Dockerfile which
    uses build arguments. The key-value syntax is the same as when defining Maven
    properties (or `labels` or `env` ). |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `buildArgs` | 允许提供一个映射，指定 Docker `buildArgs` 的值，在使用构建参数的外部 Dockerfile 构建镜像时使用。键值语法与定义
    Maven 属性（或 `labels` 或 `env`）时相同。 |'
- en: '| `buildOptions` | A map specifying the build options to provide to the Docker
    daemon when building the image. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `buildOptions` | 一个映射，用于指定构建选项，提供给 Docker 守护程序在构建镜像时使用。 |'
- en: '| `cleanup` | This is useful to clean up untagged images after each build (including
    any containers created from them). The default value is `try` which tries to remove
    the old image, but doesn''t fail the build if this is not possible because, for
    example, the image is still used by a running container. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `cleanup` | 这对于在每次构建后清理未标记的镜像很有用（包括从中创建的任何容器）。默认值是 `try`，它尝试删除旧镜像，但如果不可能，例如，镜像仍然被运行中的容器使用，则不会使构建失败。|'
- en: '| `cmd` | This is equivalent to the `CMD` instruction we already know about,
    for providing a command to execute by default. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `cmd` | 这相当于我们已经了解的 `CMD` 指令，用于提供默认执行的命令。 |'
- en: '| `compression` | Can take `none` (which is the default), `gzip` , or `bzip2`
    values. It allows us to specify the compression mode and how the build archive
    is transmitted to the Docker daemon (`docker:build` ). |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `compression` | 可以取 `none`（默认值）、`gzip` 或 `bzip2` 值。它允许我们指定压缩模式以及构建存档如何传输到
    Docker 守护程序（`docker:build`）。 |'
- en: '| `entryPoint` | Equivalent to `ENTRYPOINT` in a Dockerfile. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `entryPoint` | 等同于 Dockerfile 中的 `ENTRYPOINT`。 |'
- en: '| `env` | Equivalent to `ENV` in a Dockerfile. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `env` | 等同于 Dockerfile 中的 `ENV`。 |'
- en: '| `from` | Equivalent to `FROM` in a Dockerfile, for specifying a base image.
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `from` | 等同于 Dockerfile 中的 `FROM`，用于指定基础镜像。 |'
- en: '| `healthCheck` | Equivalent to `HEALTHCHECK` in a Dockerfile. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `healthCheck` | 等同于 Dockerfile 中的 `HEALTHCHECK`。 |'
- en: '| `labels` | For defining labels, the same as `LABEL` in a Dockerfile. |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `labels` | 用于定义标签，与 Dockerfile 中的 `LABEL` 相同。 |'
- en: '| `maintainer` | Equivalent to `MAINTAINER` in a Dockerfile. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `maintainer` | 等同于 Dockerfile 中的 `MAINTAINER`。 |'
- en: '| `nocache` | Used to disable Docker''s build layer cache. This can be overwritten
    by setting a system property `docker.nocache` , when running a Maven command.
    |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `nocache` | 用于禁用 Docker 的构建层缓存。可以通过设置系统属性 `docker.nocache` 来覆盖，当运行 Maven
    命令时。|'
- en: '| `optimize` | If set to true then it will compress all the `runCmds` into
    a single `RUN` directive. Highly recommended to minimize the number of image layers
    created. |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `optimize` | 如果设置为 true，则会将所有 `runCmds` 压缩成单个 `RUN` 指令。强烈建议最小化创建的镜像层的数量。|'
- en: '| `ports` | The equivalent of `EXPOSE` in a Dockerfile. This is a list of `<port>`
    elements, one for each port to expose. The format can be either pure numerical
    as `"8080"` or with the protocol attached, as `"8080/tcp"` . |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `ports` | 在 Dockerfile 中的 `EXPOSE` 的等效。这是一个 `<port>` 元素的列表，每个元素表示要暴露的一个端口。格式可以是纯数字，如
    `"8080"`，也可以附加协议，如 `"8080/tcp"`。|'
- en: '| `runCmds` | Equivalent to `RUN` , commands to be run during the build process.
    It contains `<run>` elements which will be passed to the shell. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `runCmds` | 等效于 `RUN`，在构建过程中要运行的命令。它包含要传递给 shell 的 `<run>` 元素。|'
- en: '| `tags` | Can contain a list of `<tag>` elements to provide additional tags
    which an image is to be tagged with after the build. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `tags` | 可以包含一系列 `<tag>` 元素，提供构建后要标记的额外标签。|'
- en: '| `user` | Equivalent to `USER` in a Dockerfile, it specifies the user to which
    the Dockerfile should switch. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `user` | 等效于 Dockerfile 中的 `USER`，指定 Dockerfile 应切换到的用户。|'
- en: '| `volumes` | Contains a list of `VOLUME` equivalents, a list of `<volume>`
    elements to create a container volume. |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `volumes` | 包含一系列 `VOLUME` 等效，一个 `<volume>` 元素的列表，用于创建容器卷。|'
- en: '| `workdir` | Equivalent to `WORKDIR` from a Dockerfile, a directory to change
    into when starting the container. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `workdir` | 与 Dockerfile 中的 `WORKDIR` 等效，表示启动容器时要切换到的目录。|'
- en: As you can see, the plugin configuration is very flexible, it contains a complete
    set of equivalents for Dockerfile instructions. Let's see how our `pom.xml` can
    look with the proper configuration.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，插件配置非常灵活，包含了 Dockerfile 指令的完整等效集。让我们看看我们的 `pom.xml` 在正确配置下是什么样子。
- en: The complete `pom.xml` .
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `pom.xml`。
- en: 'If you have been following our project from the beginning, the complete Maven
    POM is the same as the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从头开始关注我们的项目，完整的 Maven POM 与以下内容相同：
- en: '[PRE42]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Building the image
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建镜像
- en: 'To build the Docker image with our Spring Boot artifact, run this command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的 Spring Boot 构件构建 Docker 镜像，请运行以下命令：
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `clean` tells Maven to delete the `target` directory. Maven will always
    compile your classes with the `package` command. It is very important to run the
    `package` command with the `docker:build` command. You''ll encounter errors if
    you try to run these in two separate steps. While the Docker image is building,
    you will see the following output in the console:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`clean` 告诉 Maven 删除 `target` 目录。Maven 将始终使用 `package` 命令编译您的类。使用 `docker:build`
    命令运行 `package` 命令非常重要。如果尝试在两个单独的步骤中运行这些命令，将会遇到错误。在构建 Docker 镜像时，您将在控制台中看到以下输出：'
- en: '![](Image00073.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00073.jpg)'
- en: The ID of a new image will be presented in the console output. If you wonder
    how the automatically generated Dockerfile looks the same as, you will find it
    in the `target/docker/rest-example/0.1.0/build` directory in your project. The
    first time you build this Docker image, it will take longer since all the layers
    are being downloaded. But every build will be a lot faster thanks to layer caching.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 新镜像的 ID 将显示在控制台输出中。如果您想知道自动生成的 Dockerfile 看起来和什么一样，您可以在项目的 `target/docker/rest-example/0.1.0/build`
    目录中找到它。第一次构建此 Docker 镜像时，由于正在下载所有层，所以会花费更长时间。但由于层缓存的原因，每次构建都会快得多。
- en: Creating and removing volumes
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和删除卷
- en: 'The Fabric8 Maven Docker plugin couldn''t be a complete solution without the
    possibility of managing volumes. Indeed, it provides two ways to handle volumes:
    `docker:volume-create` and `docker:volume-remove` . As you probably remember from
    [Chapter 2](text00037.html) , *Networking and Persistent Storage* , Docker uses
    a plugin-like architecture when handling volumes and their drivers. The `fabric8`
    plugin can be configured to pass a specific volume driver and its parameters to
    the Docker daemon. Consider the following fragment of the plugin configuration:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric8 Maven Docker插件如果没有管理卷的可能性，就不可能成为一个完整的解决方案。实际上，它提供了两种处理卷的方式：`docker:volume-create`和`docker:volume-remove`。正如你可能还记得的那样，来自[第2章](text00037.html)的*网络和持久存储*，Docker在处理卷和它们的驱动程序时使用了类似插件的架构。`fabric8`插件可以配置为将特定的卷驱动程序及其参数传递给Docker守护程序。考虑一下插件配置的以下片段：
- en: '[PRE44]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the previous example, we create a named volume using the local filesystem
    driver. It can be mounted during the startup of the container, as specified in
    the `<run>` section of the `pom.xml` file.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，我们使用本地文件系统驱动程序创建了一个命名卷。它可以在容器启动期间挂载，如`pom.xml`文件的`<run>`部分中指定的那样。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at how to get started with Docker containers and
    packaging Java applications. We can do it manually by hand using the `docker build`
    command and a `Dockerfile` or we can use Maven to automate things. For Java developers,
    Docker helps isolate our apps in a clean environment. Isolation is important because
    it reduces the complexity of the software environment we're using. The Fabric8
    Maven Docker plugin is a great tool which we can use to automate our image builds
    using Maven, especially when dealing with Java applications. No more writing Dockerfiles
    by hand, we just configure the plugin using the extensive set of options and we
    are done. Additionally, having this working with Maven allows us to easily incorporate
    Docker builds into our existing development flows, as continuous delivery using
    Jenkins, for example. In [Chapter 6](text00108.html) , *Running Containers with
    Java Applications* , we will go into more detail about running our Java applications
    from within a container. Of course, we will use Maven for this, as well.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了如何开始使用Docker容器和打包Java应用程序。我们可以通过手动使用`docker build`命令和`Dockerfile`来手动完成，也可以使用Maven来自动化。对于Java开发人员，Docker有助于将我们的应用程序隔离在一个干净的环境中。隔离很重要，因为它减少了我们使用的软件环境的复杂性。Fabric8
    Maven Docker插件是一个很好的工具，我们可以使用它来使用Maven自动构建我们的镜像，特别是在处理Java应用程序时。不再需要手动编写Dockerfile，我们只需使用广泛的选项配置插件，就可以完成。此外，使用Maven使我们可以轻松地将Docker构建纳入我们现有的开发流程中，例如使用Jenkins进行持续交付。在[第6章](text00108.html)中，*使用Java应用程序运行容器*，我们将更详细地讨论如何从容器内部运行我们的Java应用程序。当然，我们也会使用Maven来完成这个过程。
