- en: 7\. Android Permissions and Google Maps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. Android权限和Google地图
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will provide you with knowledge of how to request and obtain app
    permissions in Android. You will gain a solid understanding of how to include
    local and global interactive maps in your app, as well as how to request permissions
    to use device features that provide richer functionality by using the Google Maps
    API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为您提供如何在Android中请求和获取应用程序权限的知识。您将深入了解如何在应用程序中包含本地和全局交互地图，以及如何请求使用Google Maps
    API提供更丰富功能的设备功能的权限。
- en: By the end of the chapter, you will be able to create permission requests for
    your app and handle missing permissions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够为您的应用程序创建权限请求并处理缺失的权限。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned how to present data in lists using `RecyclerView`.
    We used that knowledge to present the user with a list of Secret Cat Agents. In
    this chapter, we will learn how to find the user's location on the map, and how
    to deploy cat agents to the field by selecting locations on the map.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用`RecyclerView`在列表中呈现数据。我们利用这些知识向用户展示了一个秘密猫特工列表。在本章中，我们将学习如何在地图上找到用户的位置，以及如何通过在地图上选择位置来部署猫特工。
- en: First, we will look into the Android permissions system. Many Android features
    are not immediately available to us. To protect the user, these features are gated
    behind a permission system. For us to access those features, we have to ask the
    user to allow us to do so. Some such features include, but are not limited to,
    obtaining the user's location, accessing the user's contacts, accessing their
    camera, and establishing a Bluetooth connection. Different Android versions enforce
    different permission rules. When Android 6 (Marshmallow) was introduced in 2015,
    for example, a number of permissions were deemed insecure (those you could silently
    obtain on installation) and became runtime permissions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将研究Android权限系统。许多Android功能对我们来说并不是立即可用的。为了保护用户，这些功能被放在权限系统的后面。为了访问这些功能，我们必须请求用户允许我们这样做。一些这样的功能包括但不限于获取用户的位置，访问用户的联系人，访问他们的相机，以及建立蓝牙连接。不同的Android版本实施不同的权限规则。例如，当2015年引入Android
    6（Marshmallow）时，一些权限被认为是不安全的（您可以在安装时悄悄获得）并成为运行时权限。
- en: We will then look at the Google Maps API. This API allows us to present the
    user with a map of any desired location, add data to that map, and let the user
    interact with the map. It also lets you show points of interest and render a street
    view of supported locations, though we will not go into these features in this
    book.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看一下Google Maps API。这个API允许我们向用户展示任何所需位置的地图，向地图添加数据，并让用户与地图进行交互。它还可以让你显示感兴趣的点，并在支持的位置呈现街景，尽管在本书中我们不会涉及这些功能。
- en: Requesting Permissions from the User
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向用户请求权限
- en: Our app might want to implement certain features that are deemed to be dangerous
    by Google. This usually means access to those features could risk the user's privacy.
    Those permissions may, for example, allow you to read users' messages or determine
    their current location.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序可能希望实现一些被Google认为是危险的功能。这通常意味着访问这些功能可能会危及用户的隐私。例如，这些权限可能允许您读取用户的消息或确定他们当前的位置。
- en: Depending on the particular permission and the target Android API level we are
    developing, we may need to request that permission from the user. If the device
    is running on Android 6 (Marshmallow, or API level 23), and the target API of
    our app is 23 or higher, which it almost certainly will be, as most devices by
    now will run newer versions of Android, there will be no user notifications alerting
    the user of any permissions requested by the app at install time. Instead, our
    app must ask the user to grant it those permissions at runtime.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据特定权限和我们正在开发的目标Android API级别，我们可能需要向用户请求该权限。如果设备运行在Android 6（Marshmallow，或API级别23）上，并且我们应用的目标API是23或更高，几乎肯定会是这样，因为现在大多数设备都会运行更新版本的Android，那么在安装时不会有用户通知警告用户应用程序请求的任何权限。相反，我们的应用必须在运行时要求用户授予它这些权限。
- en: 'When we request a permission, the user sees a dialog much like the one shown
    in the following screenshot:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们请求权限时，用户会看到一个对话框，类似于以下截图所示：
- en: '![Figure 7.1 Permission dialog for device location access'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 设备位置访问权限对话框'
- en: '](img/B15216_07_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_01.jpg)'
- en: Figure 7.1 Permission dialog for device location access
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 设备位置访问权限对话框
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For a full list of permissions and their protection level, see here: [https://developer.android.com/reference/android/Manifest.permission](https://developer.android.com/reference/android/Manifest.permission)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有关权限及其保护级别的完整列表，请参见这里：[https://developer.android.com/reference/android/Manifest.permission](https://developer.android.com/reference/android/Manifest.permission)
- en: 'When we intend to use a permission, we must include that permission in our
    manifest file. A manifest with the `SEND_SMS` permission would look something
    like the following snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打算使用某个权限时，我们必须在清单文件中包含该权限。具有`SEND_SMS`权限的清单将类似于以下代码片段：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Safe permissions (or normal permissions, as Google refers to them) would get
    automatically granted to the user. Dangerous ones, however, would only be granted
    if explicitly approved by the user. If we fail to request permission from the
    user and try to execute an action that requires that permission, the result would
    be the action not running at best, and our app crashing at worst.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安全权限（或正常权限，如Google所称）将自动授予用户。然而，危险权限只有在用户明确批准的情况下才会被授予。如果我们未能向用户请求权限并尝试执行需要该权限的操作，结果最好是该操作不会运行，最坏的情况是我们的应用程序崩溃。
- en: To ask the user for permission, we should first check whether the user has already
    granted us that permission.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要向用户请求权限，我们应该首先检查用户是否已经授予我们该权限。
- en: If the user has not yet granted us permission, we may need to check whether
    a rationale dialog should be shown prior to the permission request. This depends
    on how obvious the justification for the request would be to the user. For example,
    if a camera app requests permission to access the camera, we can safely assume
    the reason would be clear to the user. However, some cases may not be as clear
    to the user, especially if the user is not tech-savvy. In those cases, we may
    have to justify the request to the user. Google provides us with a function called
    `shouldShowRequestPermissionRationale(Activity, String)` for this purpose. Under
    the hood, this function checks whether the user has previously denied the permission,
    but also whether the user has selected `Don't ask again` in the permission request
    dialog. The idea is to give us an opportunity to justify our request to the user
    for permission prior to requesting it, thus increasing the likelihood of them
    approving it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尚未授予我们权限，我们可能需要检查是否需要在请求权限之前显示理由对话框。这取决于请求的理由对用户来说是否显而易见。例如，如果相机应用请求访问相机的权限，我们可以安全地假设用户会清楚理由。然而，有些情况对用户来说可能不那么清晰，特别是如果用户不精通技术。在这些情况下，我们可能需要向用户解释请求的理由。Google为我们提供了一个名为`shouldShowRequestPermissionRationale(Activity,
    String)`的函数来实现这个目的。在幕后，这个函数检查用户是否先前拒绝了权限，但也检查用户是否在权限请求对话框中选择了`不再询问`。这个想法是给我们一个机会，在请求之前向用户解释我们请求权限的理由，从而增加他们批准的可能性。
- en: Once we determine whether a permission rationale should be presented to the
    user, or whether the user should accept our rationale or no rationale was required,
    we can proceed to request the permission.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定是否应向用户呈现权限理由，或者用户是否应接受我们的理由或者不需要理由，我们就可以继续请求权限。
- en: Let's see how we can request a permission.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何请求权限。
- en: 'The `Activity` class from which we request the permission must implement the
    `OnRequestPermissionsResultCallback` interface. This is because once the user
    is granted (or denied) the permission, the `onRequestPermissionsResult(Int, Array<String>,
    IntArray)` function will be called. The `FragmentActivity` class, which `AppCompatActivity`
    extends, already implements this interface, so we only have to override the `onRequestPermissionsResult`
    function to process the response of the user to the permission request. The following
    is an example of an `Activity` class requesting the `Location` permission:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们请求权限的`Activity`类必须实现`OnRequestPermissionsResultCallback`接口。这是因为一旦用户被授予（或拒绝）权限，将调用`onRequestPermissionsResult(Int,
    Array<String>, IntArray)`函数。`FragmentActivity`类，`AppCompatActivity`扩展自它，已经实现了这个接口，所以我们只需要重写`onRequestPermissionsResult`函数来处理用户对权限请求的响应。以下是一个请求`Location`权限的`Activity`类的示例：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When our `Activity` class resumes, we check whether we have the location permission
    (`ACCESS_FINE_LOCATION`) by calling `getHasLocationPermissions()`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的`Activity`类恢复时，我们通过调用`getHasLocationPermissions()`来检查我们是否有位置权限（`ACCESS_FINE_LOCATION`）：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function first checks whether the user has already granted us the requested
    permissions by calling `checkSelfPermission(Context, String)` with the requested
    permission. If the user hasn't, we call `shouldShowRequestPermissionRationale(Activity,
    String)`, which we mentioned earlier, to check whether a rationale dialog should
    be presented to the user.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数首先通过调用`checkSelfPermission(Context, String)`来检查用户是否已经授予了我们请求的权限。如果用户没有授予，我们调用我们之前提到的`shouldShowRequestPermissionRationale(Activity,
    String)`来检查是否应向用户呈现理由对话框。
- en: 'If showing our rationale is needed, we call `showPermissionRationale(() ->
    Unit)`, passing in a lambda that will call `requestLocationPermission()` after
    the user dismisses our rationale dialog. If no rationale is needed, we call `requestLocationPermission()`
    directly:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要显示我们的理由，我们调用`showPermissionRationale(() -> Unit)`，传入一个在用户关闭我们的理由对话框后将调用`requestLocationPermission()`的lambda。如果不需要理由，我们直接调用`requestLocationPermission()`：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our `showPermissionRationale` function simply presents the user with a dialog
    with a brief explanation about why we need their permission. The confirmation
    button will execute the positive action provided:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`showPermissionRationale`函数简单地向用户呈现一个对话框，简要解释为什么我们需要他们的权限。确认按钮将执行积极的操作：
- en: '![Figure 7.2 Rationale dialog'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 理由对话框'
- en: '](img/B15216_07_02.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_02.jpg)'
- en: Figure 7.2 Rationale dialog
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 理由对话框
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Lastly, our `requestLocationPermission()` function calls `requestPermissions(Activity,
    Array<out String>, Int)`, passing our activity an array containing the requested
    permission and our unique request code. We will use this code to later identify
    the response as belonging to this request.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`requestLocationPermission()`函数调用`requestPermissions(Activity, Array<out
    String>, Int)`，向我们的活动传递一个包含请求的权限和我们独特的请求代码的数组。我们将使用这个代码来稍后识别响应属于这个请求。
- en: 'If we''ve requested the location permission from the user, we now need to process
    the response. This is done by overriding the `onRequestPermissionsResult(Int,
    Array<out String>, IntArray)` function, as shown in the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经向用户请求了位置权限，现在我们需要处理响应。这是通过重写`onRequestPermissionsResult(Int, Array<out
    String>, IntArray)`函数来完成的，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When `onRequestPermissionsResult` gets called, three values are passed in. The
    first is the request code, which will be the same request code we provided when
    calling `requestPermissions`. The second is the array of requested permissions.
    The third is an array of results for our request. For each permission requested,
    this array will contain either `PackageManager.PERMISSION_GRANTED` or `PackageManager.PERMISSION_DENIED`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当`onRequestPermissionsResult`被调用时，会传入三个值。第一个是请求代码，将与我们调用`requestPermissions`时提供的请求代码相同。第二个是请求的权限数组。第三个是我们请求的结果数组。对于每个请求的权限，这个数组将包含`PackageManager.PERMISSION_GRANTED`或`PackageManager.PERMISSION_DENIED`。
- en: This chapter will take us through the development of an app that shows us our
    current location on a map and allows us to place a marker where we want to deploy
    our Secret Cat Agent. Let's start with our first exercise.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将带领我们开发一个应用程序，在地图上显示我们当前的位置，并允许我们在想要部署我们的秘密猫特工的地方放置一个标记。让我们从我们的第一个练习开始。
- en: 'Exercise 7.01: Requesting the Location Permission'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.01：请求位置权限
- en: 'In this exercise, we will request that the user provides the location permission.
    We will first create a Google Maps Activity project. We will define the permission
    required in the manifest file. To get started, let''s implement the code required
    to request permission from the user to access their location:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将请求用户提供位置权限。我们将首先创建一个Google Maps Activity项目。我们将在清单文件中定义所需的权限。让我们开始实现所需的代码，以请求用户访问其位置的权限：
- en: 'Start by creating a new Google Maps Activity project (`File` | `New` | `New
    Project` | `Google Maps Activity`). We''re not using Google Maps in this exercise.
    However, the Google Maps Activity is still a good choice in this case. It will
    save you a lot of boilerplate coding in the next exercise (*Exercise 7.02*). Don''t
    worry; it will have no impact on your current exercise. Click `Next`, as shown
    in the following screenshot:![Figure 7.3: Choose your project'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个新的Google Maps Activity项目（`文件` | `新建` | `新项目` | `Google Maps Activity`）。在这个练习中我们不会使用Google
    Maps。然而，在这种情况下，Google Maps Activity仍然是一个不错的选择。它将在下一个练习（*练习7.02*）中为你节省大量样板代码。不用担心；这不会对你当前的练习产生影响。点击`下一步`，如下截图所示：![图7.3：选择你的项目
- en: '](img/B15216_07_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_03.jpg)'
- en: 'Figure 7.3: Choose your project'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：选择你的项目
- en: Name your application `Cat Agent Deployer`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的应用程序命名为`Cat Agent Deployer`。
- en: Make sure your package name is `com.example.catagentdeployer`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的包名是`com.example.catagentdeployer`。
- en: Set the save location to where you want to save your project.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将保存位置设置为你想要保存项目的位置。
- en: Leave everything else at its default values and click `Finish`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其他所有内容保持默认值，然后点击`完成`。
- en: 'Make sure you are on the `Android` view in your `Project` pane:![Figure 7.4:
    Android view'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的`Project`窗格中处于`Android`视图：![图7.4：Android视图
- en: '](img/B15216_07_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_04.jpg)'
- en: 'Figure 7.4: Android view'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：Android视图
- en: 'Open your `AndroidManifest.xml` file. Make sure the location permission was
    already added to your app:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`AndroidManifest.xml`文件。确保位置权限已经添加到你的应用程序中：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open your `MapsActivity.kt` file. At the bottom of the `MapsActivity` class
    block, add an empty `getLastLocation()` function:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的`MapsActivity.kt`文件。在`MapsActivity`类块的底部添加一个空的`getLastLocation()`函数：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will be the function you will call when you have made sure the user has
    granted you the location permission.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是当你确保用户已经授予了位置权限时你将调用的函数。
- en: 'Next, add the request code constant to the top of the file, between the imports
    and the class definition:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在文件顶部的导入和类定义之间添加请求代码常量：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will be the code we pass when we request the location permission. Whatever
    value we define here will be returned to us when the user has finished interacting
    with the request dialog by granting or denying us the permission.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们在请求位置权限时传递的代码。无论我们在这里定义什么值，当用户完成与请求对话框的交互并授予或拒绝我们权限时，都将返回给我们。
- en: 'Now add the `requestLocationPermission()` function right before the `getLastLocation()`
    function:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`getLastLocation()`函数之前添加`requestLocationPermission()`函数：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This function will present a standard permission request dialog to the user
    (as shown in the following figure), asking them to allow the app to access their
    location. We pass the activity, which will receive the callback (`this`), an array
    of the requested permissions you want the user to grant your app (`Manifest.permission.ACCESS_FINE_LOCATION`),
    and the `PERMISSION_CODE_REQUEST_LOCATION` constant you defined a moment ago to
    associate it with the permission request:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将向用户呈现一个标准的权限请求对话框（如下图所示），要求他们允许应用程序访问他们的位置。我们传递了将接收回调的活动（`this`），你希望用户授予你的应用程序的请求权限的数组（`Manifest.permission.ACCESS_FINE_LOCATION`），以及你刚刚定义的`PERMISSION_CODE_REQUEST_LOCATION`常量，以将其与权限请求关联起来：
- en: '![Figure 7.5: Permission dialog'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5：权限对话框'
- en: '](img/B15216_07_05.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_05.jpg)'
- en: 'Figure 7.5: Permission dialog'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：权限对话框
- en: 'Override the `onRequestPermissionsResult(Int, Array<String>, IntArray)` function
    of your `MapsActivity` class:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写你的`MapsActivity`类的`onRequestPermissionsResult(Int, Array<String>, IntArray)`函数：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should first call the super implementation (this should already be done
    for you as soon as you override the function). This will handle the delegation
    of permission response processing to child fragments where relevant.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该首先调用super实现（当你重写函数时，这应该已经为你完成）。这将处理权限响应处理的委托给相关的子片段。
- en: Then, you can check the `requestCode` parameter and see if it matches the `requestCode`
    parameter you passed to the `requestPermissions(Activity, Array<out String>, Int)`
    function (`PERMISSION_CODE_REQUEST_LOCATION`). If it does, since you know you
    only requested one permission, you can check the first `grantResults` value. If
    it equals `PackageManager.PERMISSION_GRANTED`, the user has granted your app permission,
    and you can proceed to get their last location by calling `getLastLocation()`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以检查`requestCode`参数，看看它是否与你传递给`requestPermissions(Activity, Array<out String>,
    Int)`函数的`requestCode`参数匹配（`PERMISSION_CODE_REQUEST_LOCATION`）。如果匹配，由于你知道你只请求了一个权限，你可以检查第一个`grantResults`值。如果它等于`PackageManager.PERMISSION_GRANTED`，则用户已经授予了你的应用程序权限，你可以通过调用`getLastLocation()`来继续获取他们的最后位置。
- en: 'If the user denied your app the requested permission, you can present them
    with the rationale for the request. Implement the `showPermissionRationale(()
    -> Unit)` function right before the `requestLocationPermission()` function:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户拒绝了你的应用程序请求的权限，你可以向他们提出请求的理由。在`requestLocationPermission()`函数之前实现`showPermissionRationale(()
    -> Unit)`函数：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This function will present the user with a simple alert dialog explaining the
    app would not work without knowing their current location, as shown in the following
    screenshot. Clicking `OK` will execute the provided `positiveAction` lambda:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将向用户呈现一个简单的警报对话框，解释应用程序如果不知道其当前位置将无法工作，如下截图所示。单击“确定”将执行提供的`positiveAction`
    lambda：
- en: '![Figure 7.6: Rationale dialog'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6：理由对话框'
- en: '](img/B15216_07_06.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_06.jpg)'
- en: 'Figure 7.6: Rationale dialog'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：理由对话框
- en: 'Add the logic required to determine whether to show the permission request
    dialog or the rationale one. Create the `requestPermissionWithRationaleIfNeeded()`
    function right before the `showPermissionRationale(() -> Unit)` function:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的逻辑来确定是显示权限请求对话框还是理由对话框。在`showPermissionRationale(() -> Unit)`函数之前创建`requestPermissionWithRationaleIfNeeded()`函数：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This function checks whether your app should display the rationale dialog. If
    it should, it calls `showPermissionRationale(() -> Unit)`, passing in a lambda
    that will request the location permission by calling `requestLocationPermission()`.
    Otherwise, it requests the location permission by calling the `requestLocationPermission()`
    function directly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数检查您的应用程序是否应显示理由对话框。如果应该，它将调用`showPermissionRationale(() -> Unit)`，传入一个lambda，该lambda将通过调用`requestLocationPermission()`来请求位置权限。否则，它将直接通过调用`requestLocationPermission()`函数来请求位置权限。
- en: 'To determine whether or not your app already has the location permission, introduce
    the `hasLocationPermission()` function shown here right before the `requestPermissionWithRationaleIfNeeded()`
    function:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定您的应用程序是否已经具有位置权限，请在`requestPermissionWithRationaleIfNeeded()`函数之前引入此处所示的`hasLocationPermission()`函数：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, update the `onMapReady()` function of your `MapsActivity` class to
    request permission or get the user''s current location as soon as the map is ready:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`MapsActivity`类的`onMapReady()`函数，以在地图准备就绪时请求权限或获取用户的当前位置：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To make sure you present the rationale when the user denies the permission,
    update `onRequestPermissionsResult(Int, Array<String>, IntArray)` with an `else`
    condition:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保在用户拒绝权限时呈现理由，更新`onRequestPermissionsResult(Int, Array<String>, IntArray)`，加入一个`else`条件：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run your app. You should now see a system permission dialog requesting you
    to allow the app to access the location of the device:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序。现在，您应该看到一个系统权限对话框，请求您允许应用程序访问设备的位置：
- en: '![Figure 7.7: App requesting the location permission'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7：应用程序请求位置权限'
- en: '](img/B15216_07_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_07.jpg)'
- en: 'Figure 7.7: App requesting the location permission'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：应用程序请求位置权限
- en: 'If you deny the permission, the rationale dialog will appear, followed by another
    system permission dialog requesting permission, as shown in the following screenshot.
    This time, the user has the option to choose not to let the app ask for permission
    again. Every time the user chooses to deny the permission, the rationale dialog
    will be presented to them again, until they choose to allow the permission or
    tick the `Don''t ask again` option:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您拒绝权限，将出现理由对话框，然后是另一个系统权限对话框，请求权限，如下截图所示。这次，用户可以选择不让应用程序再次请求权限。每当用户选择拒绝权限时，理由对话框将再次呈现给他们，直到他们选择允许权限或选中`不再询问`选项：
- en: '![Figure 7.8: Don’t ask again'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8：不再询问'
- en: '](img/B15216_07_08.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_08.jpg)'
- en: 'Figure 7.8: Don''t ask again'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：不再询问
- en: Once the user has allowed or permanently denied the permission, the dialog will
    never show again. To reset the state of your app permissions, you would have to
    manually grant it the permission via the `App Info` interface.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户允许或永久拒绝权限，对话框将不会再次显示。要重置应用程序权限的状态，您必须通过`应用信息`界面手动授予该权限。
- en: Now that we can get the location permission, we will now look into obtaining
    the user's current location.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以获取位置权限，接下来我们将查看如何获取用户的当前位置。
- en: Showing a Map of the User's Location
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示用户位置的地图
- en: Having successfully obtained permission from the user to access their location,
    we can now ask the user's device to provide us with its last known location, which
    would also usually be the user's current location. We will then use this location
    to present the user with a map of their current location.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 成功获得用户访问其位置的权限后，我们现在可以要求用户的设备提供其上次已知的位置，这通常也是用户的当前位置。然后，我们将使用此位置向用户呈现其当前位置的地图。
- en: To obtain the user's last known location, Google has provided us with the Google
    Play Location service, and more specifically, with the `FusedLocationProviderClient`
    class. The `FusedLocationProviderClient` class helps us interact with Google's
    Fused Location Provider API, which is a location API that intelligently combines
    different signals from multiple device sensors to provide us with device location
    information.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取用户的上次已知位置，Google为我们提供了Google Play位置服务，更具体地说是`FusedLocationProviderClient`类。`FusedLocationProviderClient`类帮助我们与Google的Fused位置提供程序API进行交互，这是一个智能地结合来自多个设备传感器的不同信号以向我们提供设备位置信息的位置API。
- en: 'To access the `FusedLocationProviderClient` class, we must first include the
    Google Play Location service library in our project. This simply means adding
    the following code snippet to the `dependencies` block of our app `build.gradle`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问`FusedLocationProviderClient`类，我们必须首先在项目中包含Google Play位置服务库。这意味着将以下代码片段添加到应用程序`build.gradle`的`dependencies`块中：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With the location service imported, we can now obtain an instance of the `FusedLocationProviderClient`
    class by calling `LocationServices.getFusedLocationProviderClient(this@MainActivity)`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 导入位置服务后，我们现在可以通过调用`LocationServices.getFusedLocationProviderClient(this@MainActivity)`来获取`FusedLocationProviderClient`类的实例。
- en: 'Once we have a fused location client, given that we have already received the
    location permission from the user, we can obtain the user''s last location by
    calling `fusedLocationClient.lastLocation`. Since this is an asynchronous call,
    we should also provide a success listener at a minimum. If we wanted to, we could
    also add listeners for cancellation, failure, and the completion of requests.
    The `getLastLocation()` call (`lastLocation` for short in Kotlin) returns a `Task<Location>`.
    A Task is a Google API abstract class whose implementations perform async operations.
    In this case, that operation is returning a location. So adding listeners is simply
    a matter of chaining. We will add the following code snippet to our call:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了融合位置客户端，并且已经从用户那里获得了位置权限，我们可以通过调用`fusedLocationClient.lastLocation`来获取用户的最后位置。由于这是一个异步调用，我们至少应该提供一个成功的监听器。如果需要的话，我们还可以添加取消、失败和请求完成的监听器。`getLastLocation()`调用（在Kotlin中为`lastLocation`）返回一个`Task<Location>`。Task是一个Google
    API的抽象类，其实现执行异步操作。在这种情况下，该操作是返回一个位置。因此，添加监听器只是简单地进行链接。我们将在我们的调用中添加以下代码片段：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the `location` parameter could be `null` if the client failed to obtain
    the user's current location. This is not very common but could happen if, for
    example, the user disabled their location services during the call.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果客户端未能获取用户的当前位置，则`location`参数可能为`null`。这并不常见，但如果例如用户在通话期间禁用了其位置服务，这种情况可能发生。
- en: Once the code inside our success listener block is executed and `location` is
    not null, we have the user's current location in the form of a `Location` instance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们成功监听器块内的代码被执行并且`location`不为null，我们就可以得到用户当前位置的`Location`实例。
- en: 'A `Location` instance holds a single coordinate on Earth, expressed using longitude
    and latitude. For our purpose, it is sufficient to know that each point on the
    surface of the Earth is mapped to a single pair of longitude (abbreviation: Lng)
    and latitude (abbreviation: Lat) values.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`Location`实例保存地球上的单个坐标，使用经度和纬度表示。对于我们的目的，知道地球表面上的每个点都映射到一对经度（缩写：Lng）和纬度（缩写：Lat）值就足够了。'
- en: This is where it gets really exciting. Google lets us present any location on
    an interactive map by using a `SupportMapFragment` class. All it takes is signing
    up for a free API key. When you create your application with a Google Maps Activity,
    Google generates an extra file for us, named `google_maps_api.xml`, which can
    be found under `res/values`. That file is required for our `SupportMapFragment`
    class to work, as it contains our API key. It also contains clear instructions
    on how to obtain a new API key. Conveniently, it also contains a link that will
    prefill much of the required sign-up data for us. The link looks something like
    `https://console.developers.google.com/flows/enableapi?apiid=...`. Copy it from
    the `google_maps_api.xml` file to your browser (or *CMD* + *click* on the link),
    follow the directions on the page once the page loads, and click `Create`. Once
    you have a key, replace the `YOUR_KEY_HERE` string at the bottom of the file with
    your newly obtained key.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是真正令人兴奋的地方。谷歌让我们可以使用`SupportMapFragment`类在交互式地图上呈现任何位置。只需注册一个免费的API密钥。当您使用Google
    Maps Activity创建应用程序时，Google会为我们生成一个额外的文件，名为`google_maps_api.xml`，可以在`res/values`下找到。该文件对于我们的`SupportMapFragment`类是必需的，因为它包含我们的API密钥。它还包含如何获取新API密钥的清晰说明。方便的是，它还包含一个链接，该链接将为我们填写大部分所需的注册数据。链接看起来类似于`https://console.developers.google.com/flows/enableapi?apiid=...`。从`google_maps_api.xml`文件中复制它到您的浏览器（或在链接上*CMD*
    + *click*），一旦页面加载，按照页面上的说明操作，然后点击`Create`。一旦您获得了密钥，用您新获得的密钥替换文件底部的`YOUR_KEY_HERE`字符串。
- en: 'At this point, if you run your app, you will already see an interactive map
    on your screen:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果您运行您的应用程序，您将在屏幕上看到一个交互式地图：
- en: '![Figure 7.9: Interactive map'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9：交互式地图'
- en: '](img/B15216_07_09.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_09.jpg)'
- en: 'Figure 7.9: Interactive map'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：交互式地图
- en: 'To position the map based on our current location, we create a `LatLng` instance
    with the coordinates from our `Location` instance, and call `moveCamera(CameraUpdate)`
    on the `GoogleMap` instance. To satisfy the `CameraUpdate` requirement, we call
    `CameraUpdateFactory.newLatLng(LatLng)`, passing in the `LatLng` parameter created
    earlier. The call would look something like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据我们的当前位置定位地图，我们使用来自我们的`Location`实例的坐标创建一个`LatLng`实例，并在`GoogleMap`实例上调用`moveCamera(CameraUpdate)`。为满足`CameraUpdate`的要求，我们调用`CameraUpdateFactory.newLatLng(LatLng)`，传入之前创建的`LatLng`参数。调用看起来会像这样：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We could also call `newLatLngZoom(LatLng, Float)` to modify the zoom-in and
    zoom-out feature of the map.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以调用`newLatLngZoom(LatLng, Float)`来修改地图的放大和缩小功能。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Valid zoom values range between `2.0` (farthest) and `21.0` (closest). Values
    outside of that range are capped.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的缩放值范围在`2.0`（最远）和`21.0`（最近）之间。超出该范围的值将被限制。
- en: Some areas may not have tiles to render the closest zoom values. To discover
    the rest of the available `CameraUpdateFactory` options, visit [https://developers.google.com/android/reference/com/google/android/gms/maps/CameraUpdateFactory.html](https://developers.google.com/android/reference/com/google/android/gms/maps/CameraUpdateFactory.html).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 某些区域可能没有瓦片来渲染最接近的缩放值。要了解其他可用的`CameraUpdateFactory`选项，请访问[https://developers.google.com/android/reference/com/google/android/gms/maps/CameraUpdateFactory.html](https://developers.google.com/android/reference/com/google/android/gms/maps/CameraUpdateFactory.html)。
- en: 'To add a pin (called a marker in Google''s Map APIs) at the user''s coordinate,
    we call `addMarker(MarkerOptions)` on the `GoogleMap` instance. `MarkerOptions`
    parameters are configured by chaining calls to a `MarkerOptions()` instance. For
    a simple marker at our desired position, we could call `position(LatLng)` and
    `title(String)`. The call would look similar to the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要在用户的坐标处添加一个标记（在Google的地图API中称为标记），我们在`GoogleMap`实例上调用`addMarker(MarkerOptions)`。`MarkerOptions`参数通过链接到`MarkerOptions()`实例的调用进行配置。对于我们所需位置的简单标记，我们可以调用`position(LatLng)`和`title(String)`。调用看起来类似于以下内容：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The order in which we chain the calls does not matter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们链接调用的顺序并不重要。
- en: Let's practice this in the following exercise.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下练习中练习一下。
- en: 'Exercise 7.02: Obtaining the User''s Current Location'
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.02：获取用户的当前位置
- en: 'Now that your app can be granted location permission, you can proceed to utilize
    the location permission to get the user''s current location. You will then display
    the map and update it to zoom into the user''s current location and show a pin
    at that location. Perform the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的应用程序可以被授予位置权限，您可以继续利用位置权限来获取用户的当前位置。然后，您将显示地图并更新地图以放大到用户的当前位置并在该位置显示一个图钉。执行以下步骤：
- en: 'First, add the Google Play location service to your `build.gradle` file. You
    should add it within the `dependencies` block:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将Google Play位置服务添加到您的`build.gradle`文件中。您应该在`dependencies`块内添加它：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Click the `Sync Project with Gradle Files` button in Android Studio for Gradle
    to fetch the newly added dependency.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击Android Studio中的`Sync Project with Gradle Files`按钮，以便Gradle获取新添加的依赖项。
- en: 'Obtain an API key: start by opening the generated `google_maps_api.xml` file
    (`app/src/debug/res/values/google_maps_api.xml`) and *CMD* + *click* the link
    that starts with `https://console.developers.google.com/flows/enableapi?apiid=`.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取API密钥：首先打开生成的`google_maps_api.xml`文件（`app/src/debug/res/values/google_maps_api.xml`），然后*CMD*
    + *点击*以开始的链接，该链接以`https://console.developers.google.com/flows/enableapi?apiid=`开头。
- en: Follow the instructions on the website until you have generated a new API key.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照网站上的说明操作，直到生成一个新的API密钥。
- en: 'Update your `google_maps_api.xml` file by replacing `YOUR_KEY_HERE` with your
    new API key in the following line:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将以下行中的`YOUR_KEY_HERE`替换为您的新API密钥来更新您的`google_maps_api.xml`文件：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open your `MapsActivity.kt` file. At the top of your `MapsActivity` class,
    define a lazily initialized fused location provider client:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的`MapsActivity.kt`文件。在您的`MapsActivity`类的顶部，定义一个延迟初始化的融合位置提供程序客户端：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Introduce an `updateMapLocation(LatLng)` function and an `addMarkerAtLocation(LatLng,
    String)` function immediately after the `getLastLocation()` function to zoom the
    map at a given location and add a marker at that location, respectively:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`getLastLocation()`函数之后立即引入一个`updateMapLocation(LatLng)`函数和一个`addMarkerAtLocation(LatLng,
    String)`函数，以在给定位置放大地图并在该位置添加一个标记：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now update your `getLastLocation()` function to retrieve the user''s location:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新您的`getLastLocation()`函数以检索用户的位置：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Your code requests the last location in a Kotlin concise way by calling `lastLocation`,
    and then attaches a `lambda` function as an `OnSuccessListener` interface. Once
    a location is obtained, the `lambda` function is executed, updating the map location
    and adding a marker at that location with the title `You` if a non-null location
    was returned.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码通过调用`lastLocation`以Kotlin简洁的方式请求最后的位置，然后将`lambda`函数附加为`OnSuccessListener`接口。一旦获得位置，`lambda`函数将被执行，更新地图位置并在该位置添加一个标题为`You`的标记（如果返回的位置不为空）。
- en: 'Run your app:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序：
- en: '![Figure 7.10: Interactive map with a marker at the current location'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10：带有当前位置标记的交互式地图'
- en: '](img/B15216_07_10.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_10.jpg)'
- en: 'Figure 7.10: Interactive map with a marker at the current location'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：带有当前位置标记的交互式地图
- en: Once the app has been granted permission, it can request the user's last location
    from the Google Play location service via the fused location provider client.
    This gives you an easy and concise way to fetch the user's current location. Remember
    to turn on location on your device for the app to work.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序获得了权限，它可以通过融合位置提供程序客户端从Google Play位置服务获取用户的最后位置。这为您提供了一种轻松简洁的方式来获取用户的当前位置。请记住在设备上打开位置以使应用程序正常工作。
- en: With the user's location, your app can tell the map where to zoom and where
    to place a pin. If the user clicks on the pin, they will see the title you assigned
    to it (`You` in the exercise).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有了用户的位置，您的应用程序可以告诉地图在哪里放大并在哪里放置一个图钉。如果用户点击图钉，他们将看到您分配给它的标题（在练习中为`You`）。
- en: In the next section, we will learn how to respond to clicks on the map and how
    to move markers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何响应地图上的点击事件以及如何移动标记。
- en: Map Clicks and Custom Markers
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地图点击和自定义标记
- en: With a map showing the user's current location by zooming in at the right location
    and placing a pin there, we have rudimentary knowledge of how to render the desired
    map, as well as knowledge of how to obtain the required permissions and the user's
    current location.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在正确的位置放大并放置一个图钉来显示用户当前位置的地图，我们已经初步了解了如何渲染所需的地图，以及如何获取所需的权限和用户当前位置。
- en: In this section, we will learn how to respond to a user interacting with the
    map, and how to use markers more extensively. We will learn how to move markers
    on the map and how to replace the default pin with custom icons. When we know
    how to let the user place a marker anywhere on the map, we can let them choose
    where to deploy the Secret Cat Agent.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何响应用户与地图的交互，以及如何更广泛地使用标记。我们将学习如何在地图上移动标记以及如何用自定义图标替换默认的图钉。当我们知道如何让用户在地图上任何地方放置一个标记时，我们可以让他们选择在哪里部署秘密猫特工。
- en: 'To listen for clicks on the map, we need to add a listener to the `GoogleMap`
    instance. Looking at our `MapsActivity.kt` file, the best place to do so would
    be in `onMapReady(GoogleMap)`. A naïve implementation would look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 监听地图上的点击事件，我们需要向`GoogleMap`实例添加一个监听器。查看我们的`MapsActivity.kt`文件，最好的地方是在`onMapReady(GoogleMap)`中这样做。一个天真的实现看起来像这样：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, if we ran this code, we'd find that for every click on the map, a new
    marker is added. This is not our desired behavior.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们运行此代码，我们会发现对地图上的每次点击都会添加一个新的标记。这不是我们期望的行为。
- en: To control a marker on the map, we need to keep a reference to that marker.
    That is achieved easily enough by keeping a reference to the output of `GoogleMap.addMarker(MarkerOptions)`.
    The `addMarker` function returns a `Marker` instance. To move a marker on the
    map, we simply assign a new value by calling its `position` setter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制地图上的标记，我们需要保留对该标记的引用。这可以通过保留对`GoogleMap.addMarker(MarkerOptions)`的输出的引用来轻松实现。`addMarker`函数返回一个`Marker`实例。要在地图上移动标记，我们只需通过调用其`position`设置器为其分配一个新值。
- en: To replace the default pin icon with a custom icon, we need to provide `BitmapDescriptor`
    to the marker or the `MarkerOptions()` instance. `BitmapDescriptor` wrappers work
    around Bitmaps used by `GoogleMap` to render markers (and ground overlays, but
    we won't cover that in this book). We obtain `BitmapDescriptor` by using `BitmapDescriptorFactory`.
    The factory will require an asset, which can be provided in a number of ways.
    You can provide it with the name of a bitmap in the `assets` directory, a `Bitmap`,
    a filename of a file in the internal storage, or a resource ID. The factory can
    also create default markers of different colors. We are interested in the `Bitmap`
    option because we intend to use a vector drawable, and those are not directly
    supported by the factory. In addition, when converting the drawable to a `Bitmap`,
    we can manipulate it to suit our needs (for example, we could change its color).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要用自定义图标替换默认的标记图标，我们需要为标记或`MarkerOptions()`实例提供`BitmapDescriptor`。`BitmapDescriptor`包装器可以解决`GoogleMap`用于渲染标记（和地面覆盖，但我们不会在本书中涵盖）的位图。我们通过使用`BitmapDescriptorFactory`来获取`BitmapDescriptor`。工厂将需要一个资产，可以通过多种方式提供。您可以使用`assets`目录中位图的名称、`Bitmap`、内部存储中文件的文件名或资源ID来提供它。工厂还可以创建不同颜色的默认标记。我们对`Bitmap`选项感兴趣，因为我们打算使用矢量可绘制，而这些不是工厂直接支持的。此外，当将可绘制对象转换为`Bitmap`时，我们可以对其进行操作以满足我们的需求（例如，我们可以更改其颜色）。
- en: Android Studio offers us quite a wide range of free vector `Drawables` out of
    the box. For this example, we want the `paw` drawable. To do this, right-click
    anywhere in the left Android pane, and select `New` | `Vector Asset`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio为我们提供了相当广泛的免费矢量`Drawables`。在这个例子中，我们想要`paw`可绘制。为此，右键单击左侧Android窗格中的任何位置，然后选择`New`
    | `Vector Asset`。
- en: 'Now, click the Android icon next to the `Clip Art` label for the list of icons:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击`Clip Art`标签旁边的Android图标，查看图标列表：
- en: '![Figure 7.11: Asset Studio'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11：资产工作室'
- en: '](img/B15216_07_11.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_11.jpg)'
- en: 'Figure 7.11: Asset Studio'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：资产工作室
- en: 'We''ll now access a window in which we can choose from the offered pool of
    clip art:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将访问一个窗口，我们可以从提供的剪贴画池中选择：
- en: '![Figure 7.12: Selecting an icon'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.12：选择图标'
- en: '](img/B15216_07_12.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_12.jpg)'
- en: 'Figure 7.12: Selecting an icon'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：选择图标
- en: Once we choose an icon, we can name it, and it will be created for us as a vector
    drawable XML file. We will name it `target_icon`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了一个图标，我们可以给它命名，它将作为一个矢量可绘制的XML文件为我们创建。我们将它命名为`target_icon`。
- en: To use the created asset, we must first get it as a `Drawable` instance. This
    is done by calling `ContextCompat.getDrawable(Context, Int)`, passing in the activity
    and `R.drawable.target_icon` as a reference to our asset. Next, we need to define
    bounds for the `Drawable` instance to draw in. Calling `Drawable.setBound(Int,
    Int, Int, Int)` with (`0`, `0`, `drawable.intrinsicWidth`, `drawable.intrinsicHeight`)
    will tell it to draw within its intrinsic size.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用创建的资产，我们必须首先将其作为`Drawable`实例获取。这是通过调用`ContextCompat.getDrawable(Context,
    Int)`来实现的，传入活动和`R.drawable.target_icon`作为对我们资产的引用。接下来，我们需要为`Drawable`实例定义绘制的边界。调用`Drawable.setBound(Int,
    Int, Int, Int)`，参数为(`0`, `0`, `drawable.intrinsicWidth`, `drawable.intrinsicHeight`)，告诉它在其固有大小内绘制。
- en: To change the color of our icon, we have to tint it. To tint a `Drawable` instance
    in a way that is supported by devices running APIs older than `21`, we must first
    wrap our `Drawable` instance with `DrawableCompat` by calling `DrawableCompat.wrap(Drawable)`.
    The returned `Drawable` can then be tinted using `DrawableCompat.setTint(Drawable,
    Int)`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改图标的颜色，我们必须对其进行着色。要以一种受到早于`21`的API运行的设备支持的方式对`Drawable`实例进行着色，我们必须首先通过调用`DrawableCompat.wrap(Drawable)`将我们的`Drawable`实例包装在`DrawableCompat`中。然后可以使用`DrawableCompat.setTint(Drawable,
    Int)`对返回的`Drawable`进行着色。
- en: 'Next, we need to create a `Bitmap` to hold our icon. Its dimensions can match
    those of the `Drawable` bounds, and we want its `Config` to be `Bitmap.Config.ARGB_8888`
    – which means full red, green, blue, and alpha channels. We then create a `Canvas`
    for the `Bitmap`, allowing us to draw our `Drawable` instance by calling… you
    guessed it, `Drawable.draw(Canvas)`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个`Bitmap`来容纳我们的图标。它的尺寸可以与`Drawable`的边界匹配，我们希望它的`Config`是`Bitmap.Config.ARGB_8888`
    - 这意味着完整的红色、绿色、蓝色和alpha通道。然后我们为`Bitmap`创建一个`Canvas`，允许我们通过调用`Drawable.draw(Canvas)`来绘制我们的`Drawable`实例：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With the `Bitmap` containing our icon, we are now ready to obtain a `BitmapDescriptor`
    instance from `BitmapDescriptorFactory`. Don't forget to recycle your `Bitmap`
    afterward. This will avoid a memory leak.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有了包含我们图标的`Bitmap`，我们现在可以从`BitmapDescriptorFactory`中获取一个`BitmapDescriptor`实例。不要忘记在之后回收您的`Bitmap`。这将避免内存泄漏。
- en: You learned how to present the user with a meaningful map by centering it on
    their current location and showing their current location using a pin marker.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何通过将地图居中在用户的当前位置并使用标记标记显示他们的当前位置来向用户呈现有意义的地图。
- en: 'Exercise 7.03: Adding a Custom Marker Where the Map Was Clicked'
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.03：在地图被点击的地方添加自定义标记
- en: 'In this exercise, you will respond to a user''s map click by placing a red
    paw-shaped marker at the location on the map the user clicked:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将通过在地图上的用户点击位置放置一个红色的爪形标记来响应用户的地图点击：
- en: 'In `MapsActivity.kt` (found under `app/src/main/java/com/example/catagentdeployer`),
    right below the definition of the `mMap` variable, define a nullable `Marker`
    variable to hold a reference to the paw marker on the map:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MapsActivity.kt`（位于`app/src/main/java/com/example/catagentdeployer`下），在`mMap`变量的定义下面，定义一个可空的`Marker`变量，用于在地图上保存爪标记的引用：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Update `addMarkerAtLocation(LatLng, String)` to also accept a nullable `BitmapDescriptor`
    with a default value of `null`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`addMarkerAtLocation(LatLng, String)`，也接受一个可空的`BitmapDescriptor`，默认值为`null`：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create a `getBitmapDescriptorFromVector(Int): BitmapDescriptor?` function below
    your `addMarkerAtLocation(LatLng, String, BitmapDescriptor?): Marker` function
    to provide `BitmapDescriptor` given a `Drawable` resource ID:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在您的`addMarkerAtLocation(LatLng, String, BitmapDescriptor?): Marker`函数下面创建一个`getBitmapDescriptorFromVector(Int):
    BitmapDescriptor?`函数，以提供给定`Drawable`资源ID的`BitmapDescriptor`：'
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function first obtains a drawable using `ContextCompat` by passing in the
    provided resource ID. It then sets the drawing bounds for the drawable, wraps
    it in `DrawableCompat`, and sets its tint to red.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先使用`ContextCompat`获取可绘制对象，通过传入提供的资源ID。然后为可绘制对象设置绘制边界，将其包装在`DrawableCompat`中，并将其色调设置为红色。
- en: Then, it creates a `Bitmap` and a `Canvas` for that `Bitmap`, upon which it
    draws the tinted drawable. The bitmap is then returned to be used by `BitmapDescriptorFactory`
    to build `BitmapDescriptor`. Lastly, `Bitmap` is recycled to avoid a memory leak.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它为该`Bitmap`创建了一个`Canvas`，在其上绘制了着色的可绘制对象。然后将位图返回以供`BitmapDescriptorFactory`使用以构建`BitmapDescriptor`。最后，为了避免内存泄漏，回收`Bitmap`。
- en: Before you can use the `Drawable` instance, you must first create it. Right-click
    on the Android pane, and then select `New` | `Vector Asset`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您可以使用`Drawable`实例之前，您必须首先创建它。右键单击Android窗格，然后选择`New` | `Vector Asset`。
- en: 'In the window that opens, click on the Android icon next to the `Clip Art`
    label to select a different icon:![Figure 7.13: Asset Studio'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的窗口中，单击“剪贴画”标签旁边的Android图标，以选择不同的图标：![图7.13：资源工作室
- en: '](img/B15216_07_13.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_13.jpg)'
- en: 'Figure 7.13: Asset Studio'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：资源工作室
- en: 'From the list of icons, select the `pets` icon. You can type `pets` into the
    search field if you can''t find the icon. Once you select the `pets` icon, click
    `OK`:![Figure 7.14: Selecting an icon'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从图标列表中，选择`pets`图标。如果找不到图标，可以在搜索框中输入`pets`。选择`pets`图标后，单击“确定”：![图7.14：选择图标
- en: '](img/B15216_07_14.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_14.jpg)'
- en: 'Figure 7.14: Selecting an icon'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：选择图标
- en: Name your icon `target_icon`. Click `Next` and `Finish`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的图标命名为`target_icon`。单击“下一步”和“完成”。
- en: 'Define an `addOrMoveSelectedPositionMarker(LatLng)` function to create a new
    marker or, if one has already been created, move it to the provided location.
    Add it after the `getBitmapDescriptorFromVector(Int)` function:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`addOrMoveSelectedPositionMarker(LatLng)`函数来创建一个新的标记，或者如果已经创建了一个标记，则将其移动到提供的位置。在`getBitmapDescriptorFromVector(Int)`函数之后添加它：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Update your `onMapReady(GoogleMap)` function to set an `OnMapClickListener`
    event on `mMap`, which will add a marker to the clicked location or move the existing
    marker to the clicked location:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新您的`onMapReady(GoogleMap)`函数，为`mMap`设置一个`OnMapClickListener`事件，该事件将在点击的位置添加一个标记，或将现有标记移动到点击的位置：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run your app:![Figure 7.15: The complete app'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序：![图7.15：完整的应用程序
- en: '](img/B15216_07_15.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_07_15.jpg)'
- en: 'Figure 7.15: The complete app'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15：完整的应用程序
- en: Clicking anywhere on the map will now move the paw icon to that location. Clicking
    the paw icon will show the `Deploy here` label. Note that the location of the
    paw is a geographical one, not a screen one. That means if you drag your map or
    zoom in, the paw will move with the map and remain in the same geographical location.
    You now know how to respond to user clicks on the map and how to add and move
    markers around. You also know how to customize the appearance of markers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，单击地图上的任何位置将会将爪印图标移动到该位置。单击爪印图标将显示“部署在这里”标签。请注意，爪印的位置是地理位置，而不是屏幕位置。这意味着如果您拖动地图或放大地图，爪印将随地图移动并保持在相同的地理位置。您现在知道如何响应用户在地图上的点击，以及如何添加和移动标记。您还知道如何自定义标记的外观。
- en: 'Activity 7.01: Creating an App to Find the Location of a Parked Car'
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动7.01：创建一个查找停放汽车位置的应用程序
- en: Some people often forget where it was that they parked their car. Let's say
    you want to help these individuals by developing an app that lets the user store
    the last place they parked. When the user launches the app, it will show a pin
    at the last place the user told the app about the car's location. The user can
    click an `I'm parked here` button to update the pin location to the current location
    the next time they park.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人经常忘记他们停放汽车的地方。假设您想通过开发一个应用程序来帮助这些人，让用户存储他们上次停放的地方。当用户启动应用程序时，它将显示一个在用户告诉应用程序汽车位置的最后一个地方的标记。用户可以单击“我停在这里”按钮，以便在下次停放时将标记位置更新为当前位置。
- en: Your goal in this activity is to develop an app that shows the user a map with
    the current location. It will first have to ask the user for permission to access
    their location. Make sure to also provide a rationale dialog if needed, according
    to the SDK. The app will show a car icon where the user last told it the car was.
    The user can click a button labeled `I'm parked here` to move the car icon to
    the current location. When the user relaunches the app, it will show the user's
    current location and the car icon where the car was last parked.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您在此活动中的目标是开发一个应用程序，向用户显示带有当前位置的地图。它首先必须要求用户允许访问其位置。根据SDK，确保在需要时还提供合理的对话框。该应用程序将在用户上次告诉它汽车位置的地方显示汽车图标。用户可以单击标有“我停在这里”的按钮，将汽车图标移动到当前位置。当用户重新启动应用程序时，它将显示用户的当前位置和汽车上次停放的位置。
- en: As a bonus feature of your app, you can choose to add functionality that stores
    the car's location so that it can be restored after the user has killed and then
    re-opened the app. This bonus functionality relies on using `SharedPreferences`;
    a concept that will be covered in *Chapter 11*, *Persisting Data*. As such, steps
    9 and 10 below will give you the required implementation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 作为应用程序的额外功能，您可以选择添加存储汽车位置的功能，以便在用户关闭然后重新打开应用程序后可以恢复该位置。此额外功能依赖于使用`SharedPreferences`；这是*第11章*“持久化数据”中将介绍的一个概念。因此，下面的第9和第10步将为您提供所需的实现。
- en: 'The following steps will help you complete the activity:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成此活动：
- en: Create a Google Maps Activity app.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Google Maps Activity应用程序。
- en: Obtain an API key for the app and update your `google_maps_api.xml` file with
    that key.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取应用程序的API密钥，并使用该密钥更新您的`google_maps_api.xml`文件。
- en: Show a button at the bottom with an `I'm parked here` label.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在底部显示一个标有“我停在这里”的按钮。
- en: Include the location service in your app.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用程序中包含位置服务。
- en: Request the user's permission to access their location.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求用户的位置访问权限。
- en: Obtain the user's location and place a pin on the map at that location.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取用户的位置并在地图上放置一个标记。
- en: Add a car icon to your project.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将汽车图标添加到您的项目中。
- en: Add functionality to move the car icon to the user's current location.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为汽车图标添加功能，将其移动到用户当前位置。
- en: 'Store the selected location in `SharedPreferences`. This function, placed in
    your activity, will help:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选定的位置存储在`SharedPreferences`中。放置在您的活动中的此函数将有所帮助：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Restore any saved location from `SharedPreferences`. You can use the following
    function:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`SharedPreferences`中恢复任何保存的位置。您可以使用以下函数：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：http://packt.live/3sKj1cp
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about Android permissions. We touched on the
    reasons for having them and saw how we could request the user's permission to
    perform certain tasks. We also learned how to use Google's Maps API and how to
    present the user with an interactive map. Lastly, we leveraged our knowledge of
    presenting a map and requesting permissions to find out the user's current location
    and present it on the map. There is a lot more that can be done with the Google
    Maps API, and you could explore a lot more possibilities with certain permissions.
    You should now have enough understanding of the foundations of both to explore
    further. To read more about permissions, visit https://developer.android.com/reference/android/Manifest.permission.
    To read more about the Maps API, visit [https://developers.google.com/maps/documentation/android-sdk/intro](https://developers.google.com/maps/documentation/android-sdk/intro).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于Android权限的知识。我们谈到了拥有这些权限的原因，并看到了如何请求用户的权限来执行某些任务。我们还学习了如何使用谷歌的地图API以及如何向用户呈现交互式地图。最后，我们利用了呈现地图和请求权限的知识，找出用户当前的位置并在地图上呈现出来。使用谷歌地图API还有很多可以做的事情，您可以通过某些权限探索更多可能性。现在您应该有足够的基础理解来进一步探索。要了解更多关于权限的信息，请访问https://developer.android.com/reference/android/Manifest.permission。要了解更多关于地图API的信息，请访问[https://developers.google.com/maps/documentation/android-sdk/intro](https://developers.google.com/maps/documentation/android-sdk/intro)。
- en: In the next chapter, we will learn how to perform background tasks using `Services`
    and `WorkManager`. We will also learn how to present the user with notifications,
    even when the app is not running. These are powerful tools to have in your arsenal
    as a mobile developer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用`Services`和`WorkManager`执行后台任务。我们还将学习如何在应用程序未运行时向用户呈现通知。作为移动开发人员，拥有这些强大的工具是非常重要的。
