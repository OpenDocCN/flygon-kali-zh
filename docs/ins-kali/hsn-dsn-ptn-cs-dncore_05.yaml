- en: Implementing Design Patterns - Basics Part 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施设计模式 - 基础部分1
- en: In the previous two chapters, we introduced and defined a wide range of modern
    patterns and practices pertaining to the **software development life cycle** (**SDLC**),
    from lower-level development patterns to high-level solution architectural patterns.
    This chapter applies some of those patterns in a sample scenario in order to provide
    context and further understanding of the definitions. The scenario is the creation
    of a solution to manage the inventory of an e-commerce bookseller.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们介绍并定义了与软件开发生命周期（SDLC）相关的现代模式和实践的广泛范围，从较低级别的开发模式到高级解决方案架构模式。本章将在一个示例场景中应用其中一些模式，以便提供上下文和进一步理解这些定义。该场景是创建一个解决方案来管理电子商务书商的库存。
- en: The scenario was chosen as it provides enough complexity to illustrate the patterns
    while the concept is relatively simple. The company needs a way of managing their
    inventory, including allowing users to order their products. The organization
    needs to get an application in place, as soon as possible, to allow them to track
    their inventory, but there are many additional features, including allowing customers
    to order products and provide reviews. As the scenario plays out, the number of
    features requested grows to the point where the development team does not know
    where to start. Fortunately, by applying some good practices to help manage the
    expectations and requirements, the development team is able to simplify their
    initial delivery and get back on track. Also, by using patterns, they are able
    to build a solid foundation in order to help the expansion of the solution as
    new features are added.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 选择了这个场景，因为它提供了足够的复杂性来说明这些模式，同时概念相对简单。公司需要一种管理他们的库存的方式，包括允许用户订购他们的产品。组织需要尽快建立一个应用程序，以便他们能够跟踪他们的库存，但还有许多其他功能，包括允许客户订购产品并提供评论。随着场景的发展，所请求的功能数量增长到开发团队不知道从何处开始的地步。幸运的是，通过应用一些良好的实践来帮助管理期望和需求，开发团队能够简化他们的初始交付并重新回到正轨。此外，通过使用模式，他们能够建立一个坚实的基础，以帮助解决方案的扩展，随着新功能的添加。
- en: 'This chapter will cover the kickoff of a new project and the creation of the
    first release of the application. The following patterns are illustrated in this
    chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖一个新项目的启动和应用程序的第一个发布。本章中将演示以下模式：
- en: '**Minimal Viable Product** (**MVP**)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小可行产品（MVP）
- en: '**Test-driven development** (**TDD**)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试驱动开发（TDD）
- en: Abstract Factory pattern (Gang of Four)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂模式（四人帮）
- en: SOLID principles
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID原则
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain the concepts. The code
    is kept simple and is just for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例来解释概念。代码保持简单，仅用于演示目的。大多数示例涉及使用C#编写的.NET Core控制台应用程序。
- en: 'To run and execute the code, you need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，您需要以下内容：
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017 version
    3 or later)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（您也可以使用Visual Studio 2017版本3或更高版本来运行应用程序）
- en: .NET Core
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core
- en: SQL Server (Express Edition is used in this chapter)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章中使用Express Edition）
- en: Installing Visual Studio
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: 'To run these code examples, you need to install Visual Studio or you can use
    your preferred IDE. To do this, follow these instructions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些代码示例，您需要安装Visual Studio或者您可以使用您喜欢的集成开发环境。要做到这一点，请按照以下说明操作：
- en: Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载Visual Studio：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions included. Multiple versions are available
    for Visual Studio installation. In this chapter, we are using Visual Studio for
    Windows.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照包含的安装说明操作。Visual Studio有多个版本可供安装。在本章中，我们使用的是Windows版的Visual Studio。
- en: Setting up .NET Core
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: 'If you do not have .NET Core installed, you need to follow these instructions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尚未安装.NET Core，则需要按照以下说明操作：
- en: Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载.NET Core：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)。
- en: Follow the installation instructions and related library: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照安装说明和相关库：[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: The complete source code is available in GitHub. The source code shown in the
    chapter might not be complete, so it is advisable to retrieve the source in order
    to run the examples: [https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter3](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter3).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在GitHub上找到。本章中显示的源代码可能不完整，因此建议检索源代码以运行示例：[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter3](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter3)。
- en: Minimum Viable Product
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小可行产品
- en: This section covers the initial phase of starting a new project to build a software
    application. This is sometimes referred to as a project kickoff or project launch,
    where the initial features and capabilities of the application are collected (in
    other words, requirement gathering).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖了启动新项目以构建软件应用程序的初始阶段。这有时被称为项目启动或项目启动，其中收集应用程序的初始特性和功能（换句话说，需求收集）。
- en: Many approaches, which can be viewed as patterns, exist for the determining
    the features of a software application. Best practices around how to effectively
    model, conduct interviews and workshops, brainstorm and other techniques are outside
    the scope of this book. Instead, one approach, Minimum Viable Product, is described
    to provide an example of what these patterns might contain.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以视为模式，用于确定软件应用程序的功能。关于如何有效地建模、进行面试和研讨会、头脑风暴和其他技术的最佳实践超出了本书的范围。相反，本书描述了一种方法，即最小可行产品，以提供这些模式可能包含的示例。
- en: The project is for a hypothetical situation where a company, FlixOne, wants
    to use an inventory management application to manage its growing collection of
    books. This new application will be used both by the staff to manage the inventory,
    and by customers to browse and create new orders. The application will need to
    be scalable, and, as an essential system to the business, it is planned to be
    used for a foreseeable future.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目是针对一个假设情况，一个名为FlixOne的公司希望使用库存管理应用程序来管理其不断增长的图书收藏。这个新应用程序将被员工用于管理库存，也将被客户用于浏览和创建新订单。该应用程序需要具有可扩展性，并且作为业务的重要系统，计划在可预见的未来使用。
- en: The company is broadly broken down into *business users* and the *development
    team,* where business users are primarily concerned with the functionality of
    the system and the development team is concerned about satisfying the requirements,
    as well as keeping a tab on the maintainability of the system. This is a simplification;
    however, organizations are not necessarily so tidily organized, and individuals
    might not fit correctly into one classification or another. For example, a **Business
    Analyst** (**BA**) or **Subject Matter Expert** (**SME**) often represent both
    a business user and a member of the development team.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 公司主要分为*业务用户*和*开发团队*，业务用户主要关注系统的功能，开发团队关注满足需求，以及保持系统的可维护性。这是一个简化；然而，组织并不一定如此整洁地组织，个人可能无法正确地归入一个分类或另一个分类。例如，**业务分析师**（**BA**）或**主题专家**（**SME**）经常代表业务用户和开发团队的成员。
- en: As this is a technical book, we will mostly view the scenario from the development
    team's perspective and discuss the patterns and practices used to implement the
    inventory management application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本技术书籍，我们将主要从开发团队的角度来看待这个情景，并讨论用于实现库存管理应用程序的模式和实践。
- en: Requirements
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求
- en: Over the course of several meetings, the business and the development teams
    discussed the requirements of the new inventory management system. Progress toward
    defining a clear set of requirements was slow and the vision of the final product
    was not clear. The development team decided to pare down the enormous list of
    requirements to enough functionality that a key individual could start to record
    some inventory information. This would allow for simple inventory management and
    provide a basis that the business could extend upon. Each new set of requirements
    could then be added to the initial release.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在几次会议中，业务和开发团队讨论了新库存管理系统的需求。定义一组清晰的需求的进展缓慢，最终产品的愿景也不清晰。开发团队决定将庞大的需求列表削减到足够的功能，以便一个关键人物可以开始记录一些库存信息。这将允许简单的库存管理，并为业务提供一个可以扩展的基础。然后，每组新的需求都可以添加到初始发布中。
- en: Minimum Viable Product (MVP)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最小可行产品（MVP）
- en: A Minimum Viable Product is the smallest set of features of an application that
    can still be released and have enough value for a user base.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最小可行产品是应用程序的最小功能集，仍然可以发布并为用户群体提供足够的价值。
- en: An advantage of the MVP approach is it gives the business and development teams
    a simplified vision of what needs to be delivered by narrowing the scope of an
    application. By reducing the features that will be delivered, the effort in determining
    what needs to be done becomes more focused. In the FlixOne scenario, a meeting's
    value would often degrade into discussing the particulars of a feature that, although
    important for the final version of the product, would require several features
    to be released before it. For example, the design around a customer-facing website
    was distracting the team from focusing on the data to be stored in the inventory
    management system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: MVP方法的优势在于它通过缩小应用程序的范围，为业务和开发团队提供了一个简化的交付需求的愿景。通过减少要交付的功能，确定需要做什么的工作变得更加集中。在FlixOne的情况下，会议的价值经常会降低到讨论一个功能的细节，尽管这个功能对产品的最终版本很重要，但需要在发布几个功能之前。例如，围绕面向客户的网站的设计让团队分散注意力，无法专注于存储在库存管理系统中的数据。
- en: MVP is very useful in situations where the complexity of requirements is not
    fully understood and/or the final vision is not well defined. It is important
    though to still maintain a product vision to avoid the risk of developing functionality
    that may not be required in the final version of the application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: MVP在需求复杂性不完全理解和/或最终愿景不明确的情况下非常有用。然而，仍然很重要要保持产品愿景，以避免开发可能在应用程序的最终版本中不需要的功能。
- en: 'The business and development teams were able to define the following functional
    requirements for the initial inventory management application:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 业务和开发团队能够为初始库存管理应用程序定义以下功能需求：
- en: 'The application should be a console application:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序应该是一个控制台应用程序：
- en: It should print a welcome message that includes the version of the assembly.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该打印包含程序集版本的欢迎消息。
- en: It should loop until a quit command is given.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该循环直到给出退出命令。
- en: If a given command is not successful or not understood, then it should print
    a helpful message.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给定的命令不成功或不被理解，那么它应该打印一个有用的消息。
- en: The application should respond to simple case-insensitive text commands.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应该对简单的不区分大小写的文本命令做出响应。
- en: Each command should have a short form, of a single character, and a long form.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个命令都应该有一个短形式，一个字符，和一个长形式。
- en: 'If a command has additional parameters:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果命令有额外的参数：
- en: Each one should be entered in sequence and submitted with the return key.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个都应按顺序输入，并使用回车键提交。
- en: Each one should have a prompt `Enter {parameter}:` where `{parameter}` is the
    name of the parameter.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个都应该有一个提示`输入{参数}：`，其中`{参数}`是参数的名称。
- en: 'A help command (`?`) should be available:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个帮助命令（`?`）：
- en: Prints a summary of the commands available.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印可用命令的摘要。
- en: Prints example usage of each command.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印每个命令的示例用法。
- en: 'A quit command (`q`, `quit`) should be available:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个退出命令（`q`，`quit`）：
- en: Prints a farewell message
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印一条告别消息
- en: Ends the application
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束应用程序
- en: 'An add inventory command (`"a"`, `"addinventory"`) should be available:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个添加库存命令（`"a"`，`"addinventory"`）：
- en: The `name` parameter of type string.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为字符串的`name`参数。
- en: It should add an entry into the database with the given name and a 0 quantity.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该向数据库中添加一个具有给定名称和0数量的条目。
- en: 'An update quantity command (`"u"`, `"updatequantity"`) should be available
    :'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个更新数量命令（`"u"`，`"updatequantity"`）：
- en: The `name` parameter of type string.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型为字符串的`name`参数。
- en: The `quantity` parameter of a positive or negative integer.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quantity`参数为正整数或负整数。'
- en: It should update the quantity value of the book with the given name by adding
    the given quantity.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该通过添加给定数量来更新具有给定名称的书的数量值。
- en: 'A get inventory command (`"g"`, `"getinventory"`) should be available:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该有一个获取库存命令（`"g"`，`"getinventory"`）：
- en: Returns all the books and their quantities in the database.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回数据库中所有书籍及其数量。
- en: 'And the following non-functional requirements were defined:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 并且定义了以下非功能性要求：
- en: No security is required other than what was supplied by the operating system.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了操作系统提供的安全性外，不需要其他安全性。
- en: The short form of a command is for usability while the long form of a command
    is for readability.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令的短格式是为了可用性，而命令的长格式是为了可读性。
- en: The FlixOne example is an illustration of how MVP could be used to help focus
    and streamline the SDLC. It is worth emphasizing that the difference between a
    **Proof of Concept** (**PoC**) and an MVP will differ with each organization.
    In this book, a PoC is different from MVP in that the resulting application is
    not viewed as disposable or incomplete. For a commercial product, this would mean
    the end product could be sold, and for an internal enterprise solution, the application
    could add value to the organization.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: FlixOne示例是如何使用MVP来帮助聚焦和简化SDLC的示例。值得强调的是**概念验证**（PoC）和MVP之间的区别在每个组织中都会有所不同。在本书中，PoC与MVP的不同之处在于所得到的应用程序不被视为一次性或不完整的。对于商业产品，这意味着最终产品可以出售，对于内部企业解决方案，该应用程序可以为组织增加价值。
- en: How does MVP fit with future development?
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVP如何与未来的开发相适应？
- en: Another benefit to using MVP to focus and contain requirements is its synergy
    with Agile software development. Breaking development cycles into smaller cycles
    of development is a software development technique that has gained popularity
    over traditional Waterfall development. The driving concept is that requirements
    and solutions evolve during the life cycle of an application and involve a collaboration
    between the development team and the end users. Typically, the agile software
    development framework has a short release cycle where new functionality is designed,
    developed, tested, and released. Release cycles are then repeated as the application
    includes additional functionality. MVP fits well within agile development when
    the scope of work fits within a release cycle.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MVP聚焦和包含需求的另一个好处是它与敏捷软件开发的协同作用。将开发周期分解为较小的开发周期是一种在传统瀑布式开发中获得流行的软件开发技术。驱动概念是需求和解决方案在应用程序的生命周期中演变，并涉及开发团队和最终用户之间的协作。通常，敏捷软件开发框架具有较短的发布周期，其中设计、开发、测试和发布新功能。然后重复发布周期，以包含额外的功能。当工作范围适合发布周期时，MVP在敏捷开发中表现良好。
- en: Scrum and Kanban are popular software development frameworks based on agile
    software development.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Scrum和Kanban是基于敏捷软件开发的流行软件开发框架。
- en: The scope of the initial MVP requirements was kept to a size that could be designed,
    developed, tested, and released with an agile cycle. In the next cycle, additional
    requirements will be added to the application. The challenge is to limit the scope
    of new functionality to what can be accomplished within a cycle. Each new release
    of functionality is limited to essential requirements or to its MVP. The principle
    here is that, by using an iterative approach to software development, the final
    version of the application will have a greater benefit to the end user than by
    using a single release that requires all requirements to be defined up front.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 初始MVP要求的范围被保持在可以在敏捷周期内设计、开发、测试和发布的范围内。在下一个周期中，将向应用程序添加其他要求。挑战在于限制新功能的范围，使其能够在一个周期内完成。每个新功能的发布都限于基本要求或其MVP。这里的原则是，通过使用迭代方法进行软件开发，应用程序的最终版本将对最终用户产生比使用需要提前定义所有要求的单个发布更大的好处。
- en: 'The following diagram sums up the difference between Agile and Waterfall software
    development methods:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了敏捷和瀑布式软件开发方法之间的区别：
- en: '![](img/e56ad7fa-bc0c-4584-83f4-976b9a32daf3.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e56ad7fa-bc0c-4584-83f4-976b9a32daf3.png)'
- en: Test-driven development
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: Different approaches to **test-driven development** (**TDD**) exist, and a *test*
    can vary from a unit test that is run on demand during development, to a unit
    test that is run during the build of a project, to a test script that will be
    run as a part of **user acceptance testing** (**UAT**). Similarly, a *test* can
    be code or a document describing the steps to be performed by a user in order
    to verify a requirement. A reason for this is that there are different views as
    to what TDD is trying to achieve. TDD for some teams is a technique to refine
    requirements before writing code, while others view TDD as a way of measuring
    or validating the code that is delivered.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 存在不同的**测试驱动开发**（**TDD**）方法，*测试*可以是在开发过程中按需运行的单元测试，也可以是在项目构建期间运行的单元测试，还可以是作为**用户验收测试**（**UAT**）一部分运行的测试脚本。同样，*测试*可以是代码，也可以是描述用户执行步骤以验证需求的文档。这是因为对于TDD试图实现的目标有不同的看法。对于一些团队来说，TDD是一种在编写代码之前完善需求的技术，而对于其他人来说，TDD是一种衡量或验证交付的代码的方式。
- en: UAT
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: UAT
- en: UAT is a term used for the activity during the SDLC where the product or project
    is verified to fulfill specified requirements. This is typically performed by
    members of the business or a selection of customers. Depending on the circumstances,
    this phase can be broken further into alpha and beta stages where alpha testing
    is performed by the development team and beta by the end users.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: UAT是在SDLC期间用于验证产品或项目是否满足指定要求的活动的术语。这通常由业务成员或一些客户执行。根据情况，这个阶段可以进一步分为alpha和beta阶段，其中alpha测试由开发团队执行，beta测试由最终用户执行。
- en: Why did the team choose TDD?
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队为什么选择TDD？
- en: The development team decided to use TDD for several reasons. First, the team
    wanted a way to clearly measure progress during the development process. Second,
    they wanted to be able to reuse the tests in subsequent development cycles in
    order to continue to validate existing functionality while new functionality is
    added. For these reasons, the team will use unit tests to verify that the functionality
    written satisfies the given requirements of the team.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队决定使用TDD有几个原因。首先，团队希望在开发过程中清晰地衡量进展。其次，他们希望能够在后续的开发周期中重复使用测试，以便在添加新功能的同时继续验证现有功能。出于这些原因，团队将使用单元测试来验证编写的功能是否满足团队给定的要求。
- en: 'The following diagram illustrates the basics of TDD:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了TDD的基础知识：
- en: '![](img/4bfd18c6-4755-4bbf-8cf1-e0caff120847.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4bfd18c6-4755-4bbf-8cf1-e0caff120847.png)'
- en: Tests are added and the code base is updated until all the defined tests pass.
    It is important to note that this is repeated. In each iteration, new tests are
    added and the tests are not considered passed until all tests, new and existing,
    pass.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 测试被添加并且代码库被更新，直到所有定义的测试都通过为止。重要的是要注意这是重复的。在每次迭代中，都会添加新的测试，并且在所有测试，新的和现有的，都通过之前，测试都不被认为是通过的。
- en: The FlixOne development team decided to incorporate both unit tests and UAT
    into a single agile cycle. At the beginning of each cycle, new acceptance criteria
    would be determined. This would include the functionality to be delivered, as
    well as how it would be verified or accepted at the end of the development cycle.
    These acceptance criteria would then be used to add tests to the project. The
    development team would then build the solution until the new and existing tests
    passed, and then prepare a build for acceptance testing. Then, the acceptance
    testing would be run, and if any issues were detected, the development team would
    define new tests or amend existing tests based on the failures. The application
    would be developed again until all tests passed and a new build would be prepared.
    This would be repeated until acceptance testing passed. Then, the application
    would be deployed and a new development cycle would begin.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: FlixOne开发团队决定将单元测试和UAT结合到一个敏捷周期中。在每个周期开始时，将确定新的验收标准。这将包括要交付的功能，以及在开发周期结束时如何验证或接受。这些验收标准将用于向项目添加测试。然后，开发团队将构建解决方案，直到新的和现有的测试都通过，然后准备一个用于验收测试的构建。然后，将运行验收测试，如果检测到任何问题，开发团队将根据失败定义新的测试或修改现有测试。应用程序将再次开发，直到所有测试都通过并准备一个新的构建。这将重复直到验收测试通过。然后，应用程序将部署，并开始一个新的开发周期。
- en: 'The following diagram illustrates this approach:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了这种方法：
- en: '![](img/9798b545-4ea5-418d-91d5-5963745c9089.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9798b545-4ea5-418d-91d5-5963745c9089.png)'
- en: The team now has a plan, so let's start coding!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 团队现在有了一个计划，让我们开始编码吧！
- en: Setting up the projects
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: In this scenario, we will use the **Microsoft Unit Test** (**MSTest**) framework. This
    section provides some instructions to create the initial project using the .NET
    Core **command-line interface** (**CLI**) tools. These steps could have been completed
    using an **integrated development environment** (**IDE**) such as Visual Studio
    or Visual Studio Code. The instructions are supplied here to illustrate how the
    CLI can be used to complement the IDE.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用**Microsoft Unit Test**（**MSTest**）框架。本节提供了一些使用.NET Core **命令行界面**（**CLI**）工具创建初始项目的说明。这些步骤也可以使用集成开发环境（IDE）如Visual
    Studio或Visual Studio Code完成。这里提供这些说明是为了说明CLI如何用于补充IDE。
- en: CLI
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: CLI
- en: .NET Core CLI tools are cross-platform utilities for developing .NET applications
    and are the basis for more sophisticated tooling, such as IDEs. Please see the
    documentation for more information: [https://docs.microsoft.com/en-us/dotnet/core/tools](https://docs.microsoft.com/en-us/dotnet/core/tools).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core CLI工具是用于开发.NET应用程序的跨平台实用程序，并且是更复杂工具的基础，例如IDE。请参阅文档以获取更多信息：[https://docs.microsoft.com/en-us/dotnet/core/tools](https://docs.microsoft.com/en-us/dotnet/core/tools)。
- en: 'The solution for this chapter will consist of three projects: a console application,
    a class library, and a test project. Let''s create the solution directory, FlixOne,
    to contain the solution and sub-directories for the three projects. Within the
    created directory, the following command will create a new solution file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的解决方案将包括三个项目：控制台应用程序、类库和测试项目。让我们创建解决方案目录FlixOne，以包含解决方案和三个项目的子目录。在创建的目录中，以下命令将创建一个新的解决方案文件：
- en: '[PRE0]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following screenshot illustrates creating the directory and solution (note:
    only an empty solution file has been created so far):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了创建目录和解决方案（注意：目前只创建了一个空解决方案文件）：
- en: '![](img/c5472945-a2fe-4251-8d8a-7a9c1dd8b2c9.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5472945-a2fe-4251-8d8a-7a9c1dd8b2c9.png)'
- en: 'The class library, `FlixOne.InventoryManagement`, will contain our business
    entities and logic. In later chapters, we will split these into separate libraries
    but, as our application is still small, they are contained in a single assembly.
    The `dotnet` core CLI command to create the project is shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类库`FlixOne.InventoryManagement`将包含我们的业务实体和逻辑。在后面的章节中，我们将把它们拆分成单独的库，但是由于我们的应用程序还很小，它们包含在一个单独的程序集中。创建项目的`dotnet`核心CLI命令如下所示：
- en: '[PRE1]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note, in the following screenshot, that a new directory is created containing
    the new class library project file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在以下截图中，创建了一个包含新类库项目文件的新目录：
- en: '![](img/7206ccd0-c6be-432b-bd5c-799896c79687.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7206ccd0-c6be-432b-bd5c-799896c79687.png)'
- en: 'References should be made from the solution to the new class library with the
    following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 应该从解决方案到新类库进行引用，使用以下命令：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create a new console application project, the following command should be
    used:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的控制台应用程序项目，应使用以下命令：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot shows the `console` template being restored:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了`console`模板的恢复：
- en: '![](img/d4670643-d4de-4934-b042-0772541e3e0d.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4670643-d4de-4934-b042-0772541e3e0d.png)'
- en: 'The console application requires a reference to the class library (note: the
    command needs to be run in the directory with the project file that will have
    the reference added to it):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序需要引用类库（注意：该命令需要在将引用添加到其中的项目文件所在的目录中运行）：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A new `MSTest` project will be created using the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用以下命令创建一个新的`MSTest`项目：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows the creation of the MSTest project and should
    be run in the same folder as the solution, FlixOne (note the packages restored
    as part of the command containing the required MSTest NuGet packages):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了创建MSTest项目，并应在与解决方案相同的文件夹中运行，FlixOne（注意包含所需MSTest NuGet包的命令中恢复的包）：
- en: '![](img/f0e033e2-5bda-4b22-9b5e-5fa2600001ff.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f0e033e2-5bda-4b22-9b5e-5fa2600001ff.png)'
- en: 'The test project also requires a reference to the class library (note: this
    command needs to be run in the same folder as the MSTest project file):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 测试项目还需要引用类库（注意：此命令需要在与MSTest项目文件相同的文件夹中运行）：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, both the console application and the MSTest project should be added
    to the solution by running the following commands in the same directory as the
    solution file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过在与解决方案文件相同的目录中运行以下命令，将控制台应用程序和MSTest项目添加到解决方案中：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Visually, the solution is shown as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，解决方案如下所示：
- en: '![](img/7e47db76-ac52-4e8b-8866-1db9a03d4ebf.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e47db76-ac52-4e8b-8866-1db9a03d4ebf.png)'
- en: Now that the initial structure of our solution is ready, let's first start by
    adding to our unit test definitions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的解决方案的初始结构已经准备好了，让我们首先开始添加到我们的单元测试定义。
- en: Initial unit test definitions
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始单元测试定义
- en: 'The development team first transcribed the requirements into some basic unit
    tests. As nothing had been designed or written yet, these mostly take the form
    of noting what functionality should be validated. As the design and development
    progress, these tests will also evolve toward completion; for example, there is
    a requirement for adding inventory:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队首先将需求转录成一些基本的单元测试。由于还没有设计或编写任何内容，因此这些测试大多以记录应该验证的功能为形式。随着设计和开发的进展，这些测试也将朝着完成的方向发展；例如，需要添加库存：
- en: 'An add inventory command ("a", "addinventory") is available:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 添加库存命令（“a”，“addinventory”）可用：
- en: The `name` parameter of type string.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`参数为字符串类型。'
- en: Add an entry into the database with the given name and a `0` quantity.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用给定的名称和`0`数量向数据库添加条目。
- en: 'To capture this requirement, the development team created the following unit
    test to serve as a placeholder:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这个需求，开发团队创建了以下单元测试作为占位符：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As the application design becomes known and development starts, the existing
    tests will expand and new tests will be created, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序设计的逐渐明确和开发的开始，现有的测试将扩展，新的测试将被创建，如下所示：
- en: '![](img/b2f6bef0-f8e8-481c-bc9c-83761e6bb255.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2f6bef0-f8e8-481c-bc9c-83761e6bb255.png)'
- en: The importance of the inconclusive tests is that they communicate what needs
    to be accomplished to the team and provide a measure as the development proceeds.
    As the development progresses, inconclusive and failing tests will indicate work
    to be undertaken and successful tests will indicate progress toward completing
    the current set of tasks.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不确定测试的重要性在于它们向团队传达了需要完成的任务，并且在开发进行时提供了一种衡量。随着开发的进行，不确定和失败的测试将表明需要进行的工作，而成功的测试将表明朝着完成当前一组任务的进展。
- en: Abstract Factory design pattern
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂设计模式
- en: 'To illustrate our first pattern, let''s walk through the development of the
    help command and the initial console application. The initial version of the console
    application is shown as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们的第一个模式，让我们通过开发帮助命令和初始控制台应用程序来走一遍。初始版本的控制台应用程序如下所示：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the application starts, both a greeting and the result of a help command
    are shown. The application will then process entered commands until the quit command
    is entered.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序启动时，会显示问候语和帮助命令的结果。然后，应用程序将处理输入的命令，直到输入退出命令为止。
- en: 'The following shows the detail of handling commands:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了处理命令的详细信息：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Until the application solution quits, the application will continue to prompt
    the user for command and, if a command was not successfully handled, then help
    text is shown.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 直到应用程序解决方案退出，应用程序将继续提示用户输入命令，如果命令没有成功处理，那么将显示帮助文本。
- en: RunCommand(out bool shouldQuit)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: RunCommand(out bool shouldQuit)
- en: C# 7.0 introduces a more fluid syntax for creating `out` parameters. This will
    declare the variables in the scope of the command block. This is illustrated with
    the following, where the `shouldQuit` Boolean is not declared ahead of time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7.0引入了一种更流畅的语法，用于创建`out`参数。这将在命令块的范围内声明变量。下面的示例说明了这一点，其中`shouldQuit`布尔值不是提前声明的。
- en: InventoryCommand abstract class
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InventoryCommand抽象类
- en: 'The first thing to point out about the initial console application is that the
    team is using **object-oriented programming** (**OOP**) to create a standard way
    of handling commands. What the team learned from this initial design is that all
    commands will contain a `RunCommand()` method that will return two Booleans indicating
    whether the command was successful and whether the program should terminate. For
    example, the `HelpCommand()` will simply display a help message to the console
    and should not cause the program to end. The two return Booleans would then be
    *true*, to indicate that the command ran successfully and *false, *to indicate
    that the application should not terminate. The following shows the initial version:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关于初始控制台应用程序的第一件事是，团队正在使用**面向对象编程**（**OOP**）来创建处理命令的标准方式。团队从这个初始设计中学到的是，所有命令都将包含一个`RunCommand()`方法，该方法将返回两个布尔值，指示命令是否成功以及程序是否应该终止。例如，`HelpCommand()`将简单地在控制台上显示帮助消息，并且不应该导致程序结束。然后两个返回的布尔值将是*true*，表示命令成功运行，*false*，表示应用程序不应该终止。以下显示了初始版本：
- en: The ... indicates additional statements and, in this particular example, additional `Console.WriteLine()`
    statements.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个...表示额外的声明，在这个特定的例子中，额外的`Console.WriteLine()`声明。
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `QuitCommand` will display a message and then cause the program to end.
    The initial `QuitCommand` was as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuitCommand`将显示一条消息，然后导致程序结束。最初的`QuitCommand`如下：'
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The team decided to either create an interface that both classes implement,
    or an abstract class that both classes inherit from. Both could have achieved
    the desired dynamic polymorphism but the team chose to use an abstract class as
    all commands will have shared functionality.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 团队决定要么创建一个接口，两个类都实现，要么创建一个抽象类，两个类都继承。两者都可以实现所需的动态多态性，但团队选择使用抽象类，因为所有命令都将具有共享功能。
- en: 'In OOP and in particular C#, polymorphism is supported in three main ways:
    function overloading, generics, and subtyping or dynamic polymorphism.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在OOP中，特别是在C#中，多态性以三种主要方式得到支持：函数重载、泛型和子类型或动态多态性。
- en: 'Using the Abstract Factory Design pattern, the team created an abstract class
    that commands would inherit from, `InventoryCommand`. The `InventoryCommand` class
    has a single method, `RunCommand`, that will perform the command and return whether
    the command was successfully executed and whether the application should quit.
    The class is abstract, meaning the class contains one or more abstract methods.
    In this case, the `InternalCommand()` method is abstract and the intent is that
    classes deriving from the `InventoryCommand` class will implement the `InternalCommand`
    method with the specific command functionality. For example, `QuitCommand` will
    extend `InventoryCommand` and provide a concrete implementation for the `InternalCommand()`
    method. The following snippet shows the `InventoryCommand` abstract class with
    the abstract `InternalCommand()` method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抽象工厂设计模式，团队创建了一个抽象类，命令将从中继承，`InventoryCommand`。`InventoryCommand`类有一个单一的方法，`RunCommand`，将执行命令并返回命令是否成功执行以及应用程序是否应该退出。该类是抽象的，意味着类包含一个或多个抽象方法。在这种情况下，`InternalCommand()`方法是抽象的，意图是从`InventoryCommand`类派生的类将使用特定命令功能实现`InternalCommand`方法。例如，`QuitCommand`将扩展`InventoryCommand`并为`InternalCommand()`方法提供具体实现。以下片段显示了带有抽象`InternalCommand()`方法的`InventoryCommand`抽象类：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The abstract method would then be implemented in each derived class, as illustrated
    with the `HelpCommand`. The `HelpCommand` simply prints some information to the
    console and then returns `true`, indicating that the command was executed successfully:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后抽象方法将在每个派生类中实现，就像`HelpCommand`所示。`HelpCommand`简单地向控制台打印一些信息，然后返回`true`，表示命令成功执行：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The development team then decided on making two additional changes to the `InventoryCommand`.
    The first thing they did not like was how the `shouldQuit` Boolean was being returned
    as an *out* variable. Thus, they decided to use the new tuples feature of C# 7
    to instead return a single `Tuple<bool,bool>` object as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队随后决定对`InventoryCommand`进行两个额外的更改。他们不喜欢的第一件事是`shouldQuit`布尔值作为*out*变量返回。因此，他们决定使用C#
    7的新元组功能，而不是返回一个单一的`Tuple<bool,bool>`对象，如下所示：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tuple
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 元组
- en: The tuple is a C# type that provides a lightweight syntax for packaging multiple
    values into a single object easily. The disadvantage over defining a class is
    you lose inheritance and other object-oriented functionality. For more information,
    please see [https://docs.microsoft.com/en-us/dotnet/csharp/tuples](https://docs.microsoft.com/en-us/dotnet/csharp/tuples).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 元组是C#类型，提供了一种轻量级的语法，可以将多个值打包成一个单一对象。与定义类的缺点是你失去了继承和其他面向对象的功能。更多信息，请参见[https://docs.microsoft.com/en-us/dotnet/csharp/tuples](https://docs.microsoft.com/en-us/dotnet/csharp/tuples)。
- en: The other change was to introduce another abstract class to indicate whether
    the command was a non-terminating command; in other words, a command that does
    not cause the solution to quit or end.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个变化是引入另一个抽象类，指示命令是否是一个非终止命令；换句话说，不会导致解决方案退出或结束的命令。
- en: 'As shown in the following code, this command is still abstract as it does not
    implement the `InternalCommand` method of `InventoryCommand`, but it passes a
    false value to the base class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如下代码所示，这个命令仍然是抽象的，因为它没有实现“InventoryCommand”的“InternalCommand”方法，但它向基类传递了一个false值：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The advantage here is now commands that do not cause the application to end
    – in other words, are non-terminating – now have a simpler definition:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的优势是现在不会导致应用程序终止的命令 - 换句话说，非终止命令 - 现在有了更简单的定义：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following class diagram shows the inheritance of the `InventoryCommand`
    abstract class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图显示了“InventoryCommand”抽象类的继承：
- en: '![](img/bc1bd371-98d9-4fec-8acc-1f26d74eb3ac.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc1bd371-98d9-4fec-8acc-1f26d74eb3ac.png)'
- en: There is only one terminating command, `QuitCommand`, while the other commands
    extend the `NonTerminatingCommand` abstract class. It is also worth noting that
    only the `AddInventoryCommand` and `UpdateQuantityCommand` require parameters
    and the use of the `IParameterisedCommand` is explained later in the *Liskov Substitution
    Principle* section. Another subtle point in the diagram is that all the types,
    other than the base `InventoryCommand`, are not public (visible to external assemblies).
    This will become relevant in the *Access modifiers* section later in the chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个终止命令，“QuitCommand”，而其他命令扩展了“NonTerminatingCommand”抽象类。还值得注意的是，“AddInventoryCommand”和“UpdateQuantityCommand”需要参数，并且“IParameterisedCommand”的使用将在*Liskov替换原则*部分中解释。图表中的另一个微妙之处是除了基本的“InventoryCommand”之外，所有类型都不是公共的（对外部程序集可见）。这将在本章后面的*访问修饰符*部分变得相关。
- en: SOLID principles
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: As the team simplifies the code by using patterns, they also use SOLID principles
    to help identify problems. By simplifying the code, the team aims to make the
    code more maintainable and easier for new team members to understand. This approach
    of reviewing the code with a set of principles is very useful in writing concise
    classes that only do what they need to achieve, and putting in a layer of abstraction
    that helps to write code that is easier to modify and understand.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 随着团队使用模式简化代码，他们还使用SOLID原则来帮助识别问题。通过简化代码，团队的目标是使代码更易于维护，并且更容易让新团队成员理解。通过使用一套原则审查代码的方法，在编写只做必要的事情并提供一层抽象的类时非常有用，这有助于编写更容易修改和理解的代码。
- en: Single responsibility principle (SRP)
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）
- en: The first principle that the team applies is the **single responsibility principle**
    (**SRP**). The team identified that the actual mechanism of writing to the console
    is not the responsibility of the `InventoryCommand` classes. Because of this,
    a `ConsoleUserInterface` class is introduced that is responsible for the interaction
    with the user. SRP will help keep the `InventoryCommand` classes smaller and avoid
    situations where the same code is duplicated. For example, the application should
    have a uniform way of prompting the user for information and displaying messages
    and warnings. Instead of repeating this in the `InventoryCommand` classes, this
    logic is encapsulated in the `ConsoleUserInterface` class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 团队应用的第一个原则是**单一职责原则**（**SRP**）。团队发现写入控制台的实际机制不是“InventoryCommand”类的责任。因此，引入了一个负责与用户交互的“ConsoleUserInterface”类。SRP将有助于保持“InventoryCommand”类更小，并避免重复相同的代码的情况。例如，应用程序应该有一种统一的方式提示用户输入信息和显示消息和警告。这种逻辑不是在“InventoryCommand”类中重复，而是封装在“ConsoleUserInterface”类中。
- en: 'The `ConsoleUserInteraface` will consist of three methods, as indicated in
    the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: “ConsoleUserInteraface”将包括三种方法，如下所示：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first method will be used to read input from the console:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法将用于从控制台读取输入：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second method will print a message to the console using the color green:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法将使用绿色在控制台上打印一条消息：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The final method will print a message to the console using a dark yellow color
    indicating a warning message:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的方法将使用深黄色在控制台上打印一条警告消息：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the `ConsoleUserInterface` class, we can reduce the impact of changes to
    how we interact with the user. As our solution develops, we might find that the
    interface changes from a console to a web application. In theory, we would replace
    the `ConsoleUserInterface` with a `WebUserInterface`. If we had not reduced the
    user interface to a single class, the impact of such a change would most likely
    be more disruptive.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过“ConsoleUserInterface”类，我们可以减少与用户交互方式的变化对我们的影响。随着解决方案的发展，我们可能会发现界面从控制台变为Web应用程序。理论上，我们将用“WebUserInterface”替换“ConsoleUserInterface”。如果我们没有将用户界面简化为单个类，这种变化的影响很可能会更加破坏性。
- en: Open/closed principle (OCP)
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则（OCP）
- en: 'The **open/closed principle**, the O in SOLID, is represented by the different
    `InventoryCommand` classes. Instead of having an implementation of the `InventoryCommand`
    class per command, the team could have defined a single class containing multiple
    `if` statements. Each `if` statement would determine what functionality to execute. For
    example, the following illustrates how the team could have broken this principle:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 开闭原则，SOLID中的O，由不同的“InventoryCommand”类表示。团队可以定义一个包含多个“if”语句的单个类，而不是为每个命令定义一个“InventoryCommand”类的实现。每个“if”语句将确定要执行的功能。例如，以下说明了团队如何打破这个原则：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The above method breaks this principle because adding a new command would alter
    the behavior of the code. The idea of the principle is that it is **closed** to
    modification that would *alter* its behavior and instead is **open** to extend
    the class to support additional behavior. This is what is accomplished by having
    the abstract `InventoryCommand` and derived classes (for example, `QuitCommand`,
    `HelpCommand`, and `AddInventoryCommand`). A compelling reason for this, especially
    when combined with the other principles, is that it leads to succinct code that
    is easier to maintain and understand.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法违反了这一原则，因为添加新命令会改变代码的行为。该原则的理念是它对于会*改变*其行为的修改是**封闭**的，而是**开放**的，以扩展类以支持附加行为。通过具有抽象的`InventoryCommand`和派生类（例如`QuitCommand`、`HelpCommand`和`AddInventoryCommand`）来实现这一点。尤其是与其他原则结合使用时，这是一个令人信服的理由，因为它导致简洁的代码，更易于维护和理解。
- en: Liskov substitution principle (LSP)
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 里氏替换原则（LSP）
- en: 'The commands for quit, help, and get inventory do not require parameters, while
    the `AddInventory` and `UpdateQuantityCommand` do. There are several ways to handle
    this and the team decided to introduce an interface to identify those commands
    as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 退出、帮助和获取库存的命令不需要参数，而`AddInventory`和`UpdateQuantityCommand`需要。有几种处理方式，团队决定引入一个接口来标识这些命令，如下所示：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'By applying the **Liskov substitution principle** (**LSP**), only those commands
    that require parameters should implement the `GetParameters()` method. For example,
    on the `AddInventory` command, the `IParameterisedCommand` is implemented using
    a method defined on the base `InventoryCommand`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用**里氏替换原则**（**LSP**），只有需要参数的命令应该实现`GetParameters()`方法。例如，在`AddInventory`命令上，使用在基类`InventoryCommand`上定义的方法来实现`IParameterisedCommand`：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `GetParameter` method on the `InventoryCommand` class simply uses the `ConsoleUserInterface`
    to read a value from the console. The method will be shown later in this chapter.
    In C#, there is handy syntax that shows well how LSP can be used to apply functionality
    to only objects of a specific interface. On the first line of the `RunCommand`
    method, the `is` keyword is used to both test whether the current object implements
    the `IParameterisedCommand` interface as well as cast the object as a new object:
    `parameterisedCommand`. This is shown in bold in the following code snippet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommand`类上的`GetParameter`方法简单地使用`ConsoleUserInterface`从控制台读取值。该方法将在本章后面显示。在C#中，有一个方便的语法，可以很好地显示LSP如何用于仅将功能应用于特定接口的对象。在`RunCommand`方法的第一行，使用`is`关键字来测试当前对象是否实现了`IParameterisedCommand`接口，并将对象强制转换为新对象：`parameterisedCommand`。以下代码片段中的粗体显示了这一点：'
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Interface segregation principle (ISP)
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则（ISP）
- en: 'One approach to handling commands with and without parameters would have been
    to define another method, `GetParameters`, on the `InventoryCommand` abstract
    class, and for those that do not require parameters to just return true to indicate
    that all, in this case no, parameters have been received. For example, the `QuitCommand`,
    `**HelpCommand**`, and `GetInventoryCommand` would all have an implementation
    similar to the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 处理带参数和不带参数的命令的一种方法是在`InventoryCommand`抽象类上定义另一个方法`GetParameters`，对于不需要参数的命令，只需返回true以指示已接收到所有（在本例中为零）参数。例如，`QuitCommand`、`**HelpCommand**`和`GetInventoryCommand`都将有类似以下实现：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This would work but it does break the **interface segregation principle** (**ISP**),
    which states that an interface should only contain methods and properties that
    are required. Similar to SRP, which applies to classes, ISP applies to interfaces
    and is effective in keeping interfaces small and focused. In our example, only
    the `AddInventoryCommand` and `UpdateQuantityCommand` classes will implement the
    `InventoryCommand` interface.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这将起作用，但它违反了**接口隔离原则**（**ISP**），该原则规定接口应仅包含所需的方法和属性。与SRP类似，适用于类的ISP适用于接口，并且在保持接口小型和专注方面非常有效。在我们的示例中，只有`AddInventoryCommand`和`UpdateQuantityCommand`类将实现`InventoryCommand`接口。
- en: Dependency inversion principle
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖反转原则
- en: The **dependency inversion principle** (**DIP**), also referred to as the **dependency
    injection** **principle** (**DIP**), modules should not depend on details but,
    instead, on abstractions. This principle encourages writing loosely coupled code
    to enhance both readability as well as maintenance, especially in a large complex
    code base.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖反转原则**（**DIP**），也称为**依赖注入原则**（**DIP**），模块不应依赖于细节，而应依赖于抽象。该原则鼓励编写松散耦合的代码，以增强可读性和维护性，特别是在大型复杂的代码库中。'
- en: 'If we revisit the `ConsoleUserInterface` class that was introduced earlier
    (in the *Single responsibility principle* section), we could use the class without
    the `QuitCommand` as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新访问之前介绍的`ConsoleUserInterface`类（在*单一职责原则*部分），我们可以在没有`QuitCommand`的情况下使用该类如下：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This breaks several SOLID principles, but in regards to DIP, it makes a tight
    coupling between the `QuitCommand` and the `ConsoleUserInterface`. Imagine the
    scenario where the console is no longer the means to display information to the
    user, or what if the constructor of the `ConsoleUserInterface` requires additional
    parameters?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这违反了几个SOLID原则，但就DIP而言，它在`QuitCommand`和`ConsoleUserInterface`之间形成了紧密耦合。想象一下，如果控制台不再是向用户显示信息的手段，或者如果`ConsoleUserInterface`的构造函数需要额外的参数会怎么样？
- en: By applying the DIP principle, the following refactor was performed. First a
    new interface, `IUserInterface`, was introduced that contained the definitions
    of the methods implemented in the `ConsoleUserInterface`. Next, the interface,
    and not the concrete class, is used in the `InventoryCommand` classes. Finally,
    a reference to an object implementing the `IUserInterface` is passed into the
    constructor of the `InventoryCommand` classes. This approach protects the `InventoryCommand`
    classes from changes to the implementation details of `IUserInterface` classes,
    as well as providing a mechanism for more easily replacing different implementations
    of `IUserInterface` as the code base evolves.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用DIP原则，进行了以下重构。首先引入了一个新的接口`IUserInterface`，其中包含了`ConsoleUserInterface`中实现的方法的定义。接下来，在`InventoryCommand`类中使用接口而不是具体类。最后，在`InventoryCommand`类的构造函数中传递了一个实现`IUserInterface`的对象的引用。这种方法保护了`InventoryCommand`类免受对`IUserInterface`类实现细节的更改，并为更轻松地替换`IUserInterface`的不同实现提供了一种机制，使代码库得以发展。
- en: 'The DIP is illustrated as follows with the `QuitCommand` and is our final version
    of the class for this chapter:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: DIP如下图所示，`QuitCommand`是本章的最终版本：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that the class extends the `InventoryCommand` abstract class, providing
    both a common way of handling commands, as well as providing shared functionality.
    The constructor requires the `IUserInterface` dependency to be injected when the
    object is instantiated. Also note the `QuitCommand` implements a single method,
    `InternalCommand()`, keeping the `QuitCommand` lean and easy to read and understand.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该类扩展了`InventoryCommand`抽象类，提供了处理命令的通用方式，同时提供了共享功能。构造函数要求在实例化对象时注入`IUserInterface`依赖项。还要注意，`QuitCommand`实现了一个方法`InternalCommand()`，使`QuitCommand`简洁易读易懂。
- en: 'To complete the picture, let''s view the final `InventoryCommand` base class.
    The following shows the constructor and properties:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成整个图片，让我们来看最终的`InventoryCommand`基类。以下显示了构造函数和属性：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note the `IUserInterface` is passed into the constructor as well as a Boolean
    indicating whether the command is terminating or not. The `IUserInterface` is
    then made available to all implementation of `InventoryCommand` as the `Interface` property.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`IUserInterface`被传递到构造函数中，以及一个布尔值，指示命令是否终止。然后，`IUserInterface`对于所有`InventoryCommand`的实现都可用作`Interface`属性。
- en: 'The `RunCommand` is the only public method on the class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`RunCommand`是该类上唯一的公共方法：'
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Furthermore, the `GetParameter` method is a method common to all implementations
    of `InventoryCommand`, so it is made internal:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`GetParameter`方法是所有`InventoryCommand`实现的公共方法，因此它被设置为内部方法：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: DIP and IoC
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: DIP和IoC
- en: The DIP and **Inversion of Control** (**IoC**) are closely related and all address
    the same issues but in slightly different ways. IoC and its specialized form,
    the **Service Locator Pattern** (**SLP**), use a mechanism to supply an implementation
    of an abstraction on demand. So, instead of injecting the implementation, IoC
    acts as a proxy to supply the details that are required. In the next chapter,
    .NET Core support for these patterns will be explored.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: DIP和**控制反转**（IoC）密切相关，都以稍微不同的方式解决相同的问题。IoC及其专门形式的**服务定位器模式**（SLP）使用机制按需提供抽象的实现。因此，IoC充当代理以提供所需的细节，而不是注入实现。在下一章中，将探讨.NET
    Core对这些模式的支持。
- en: InventoryCommand unit tests
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InventoryCommand单元测试
- en: 'With the `InventoryCommand` classes taking shape, let''s revisit the unit tests
    so we can start to validate what has been written so far and identify any missing
    requirements. The SOLID principles will show their value here. Because we kept
    our classes (SRP) and interfaces (ISP) small, and focused on just the minimum
    amount of functionality required (LSP), our tests should also be simpler to write
    and validate. For example, a test regarding one of the commands will not need
    to validate the display of the messages on the console (for example, color or
    text size) as that is not the responsibility of the `InventoryCommand` classes
    but of the implementation of the `IUserInterface`. Also, with dependency injection,
    we will be able to isolate the test to just the inventory command. The following
    diagram illustrates this, as the unit test will only validate what is contained
    in the green box:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 随着`InventoryCommand`类的形成，让我们重新审视单元测试，以便开始验证到目前为止编写的内容，并确定任何缺失的要求。在这里，SOLID原则将显示其价值。因为我们保持了类（SRP）和接口（ISP）的小型化，并且专注于所需的最小功能量（LSP），我们的测试也应该更容易编写和验证。例如，关于其中一个命令的测试将不需要验证控制台上消息的显示（例如颜色或文本大小），因为这不是`InventoryCommand`类的责任，而是`IUserInterface`的实现的责任。此外，通过依赖注入，我们将能够将测试隔离到仅涉及库存命令。以下图表说明了这一点，因为单元测试将仅验证绿色框中包含的内容：
- en: '![](img/4cfda6fb-5968-451a-af94-5bee807667a1.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4cfda6fb-5968-451a-af94-5bee807667a1.png)'
- en: By keeping the unit test's scope limited, it will be easier to handle change
    as the application changes. In some situations where it is more difficult to separate
    the functionality due to interdependencies within classes (in other words, when
    SOLID is not followed), a test can span a larger section of the application including
    repositories. These tests are usually referred to as integration tests instead
    of unit tests.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过保持单元测试的范围有限，将更容易处理应用程序的变化。在某些情况下，由于类之间的相互依赖关系（换句话说，当未遵循SOLID原则时），更难以分离功能，测试可能会跨应用程序的较大部分，包括存储库。这些测试通常被称为集成测试，而不是单元测试。
- en: Access modifiers
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: Access modifiers are an important way of handling the visibility of types and
    type members by encapsulating code. By using a clear access strategy, the intent
    of how an assembly and its types should be used can be communicated and enforced.
    For example, in the FlixOne application, only types that should be accessed directly
    by the console are marked as public. This means that the console application should
    have visibility of a limited number of types and methods. These types and methods
    have been marked as public while types and methods that the console should not
    have access to, have been marked as internal, private, or protected.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符是处理类型和类型成员可见性的重要方式，通过封装代码来实现。通过使用清晰的访问策略，可以传达和强制执行程序集及其类型应该如何使用的意图。例如，在FlixOne应用程序中，只有应该由控制台直接访问的类型被标记为公共。这意味着控制台应用程序应该能够看到有限数量的类型和方法。这些类型和方法已标记为公共，而控制台不应该访问的类型和方法已标记为内部、私有或受保护。
- en: 'Please see the Microsoft docs programming guide for more information on access
    modifiers:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅Microsoft文档编程指南，了解有关访问修饰符的更多信息：
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers)'
- en: The `InventoryCommand` abstract class is made public as the console application
    will use the `RunCommand` method to handle the command.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommand`抽象类被公开，因为控制台应用程序将使用`RunCommand`方法来处理命令。'
- en: 'In the following snippet, note how the constructor and interface are made protected
    to give access to the sub-classes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的片段中，请注意构造函数和接口被标记为受保护，以便给予子类访问权限：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the following snippet, note that the `RunCommand` method is made public
    while the `InternalCommand` is made internal:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的片段中，请注意`RunCommand`方法被标记为公共，而`InternalCommand`被标记为内部：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Similarly, the implementations of `InventoryCommand` are marked as internal
    to prevent them from being directly referenced outside of the assembly. This is
    illustrated as follows with the `QuitCommand`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`InventoryCommand`的实现被标记为内部，以防止它们被直接引用到程序集外部。这在`QuitCommand`中有所体现：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Because the access of the different implementations will not be visible directly
    to the unit test project, an additional step is required to make the internal
    types visible. The `assembly` directive could be placed in any compiled file and,
    for the FlixOne application, an `assembly.cs` was added containing the assembly
    attribute:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因为不同实现的访问对于单元测试项目来说不会直接可见，所以需要额外的步骤来使内部类型可见。`assembly`指令可以放置在任何已编译的文件中，对于FlixOne应用程序，添加了一个包含程序集属性的`assembly.cs`文件：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In situations where the assembly is signed, the `InternalsVisibleTo()` requires
    a public key. Please see the Microsoft Docs C# Guide for more information: [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序集已签名的情况下，`InternalsVisibleTo()`需要一个公钥。请参阅Microsoft Docs C#指南，了解更多信息：[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/assemblies-gac/how-to-create-signed-friend-assemblies)。
- en: Helper TestUserInterface
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helper TestUserInterface
- en: 'As part of a unit test of one of the `InventoryCommand` implementations, we
    do not want to test the referenced dependencies. Fortunately, because the commands
    adhere to the DIP, we can create a `helper`class to validate the implementation
    interactions with the dependencies. One of the dependencies is the `IUserInterface`,
    which is passed into the implementation in the constructor. The following is a
    reminder of the methods of the interface:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对`InventoryCommand`实现之一的单元测试的一部分，我们不希望测试引用的依赖关系。幸运的是，由于命令遵循DIP，我们可以创建一个`helper`类来验证实现与依赖关系的交互。其中一个依赖是`IUserInterface`，它在构造函数中传递给实现。以下是接口的方法的提醒：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By implementing a `helper` class, we can supply the information required by
    the `ReadValue` method as well as verify that the appropriate messages are received
    in the `WriteMessage` and `WriteWarning` methods. In the test project, a new class
    called `TestUserInterface` was created that implements the `IUserInterface` interface.
    The class contains three lists containing the expected `WriteMessage`, `WriteWarning`,
    and `ReadValue` calls, and keeps track of the number of times it has been called.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现一个`helper`类，我们可以提供`ReadValue`方法所需的信息，并验证`WriteMessage`和`WriteWarning`方法中是否收到了适当的消息。在测试项目中，创建了一个名为`TestUserInterface`的新类，该类实现了`IUserInterface`接口。该类包含三个列表，包含预期的`WriteMessage`、`WriteWarning`和`ReadValue`调用，并跟踪调用次数。
- en: 'For example, the `WriteWarning` method is shown as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`WriteWarning`方法显示如下：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `WriteWarning` method performs two asserts. The first verifies that the
    method is not called more times than expected and the second verifies that the
    message received matches the expected message.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteWarning`方法执行两个断言。第一个断言验证方法调用的次数不超过预期，第二个断言验证接收到的消息是否与预期消息匹配。'
- en: 'The `ReadValue` method is similar but it additionally returns a value back
    to the calling `InventoryCommand` implementation. This will simulate the user
    entering information into the console:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadValue`方法类似，但它还将一个值返回给调用的`InventoryCommand`实现。这将模拟用户在控制台输入信息：'
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As an extra validation step, at the end of a test method, the `TestUserInterface`
    is called to verify that the expected number of `ReadValue`, `WriteMessage`, and
    `WriteWarning` requests were received:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的验证步骤，在测试方法结束时，调用`TestUserInterface`来验证是否收到了预期数量的`ReadValue`、`WriteMessage`和`WriteWarning`请求：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `TestUserInterface` class illustrates how a dependency can be mocked to
    provide stubbed functionality as well as provide assertions to help verify the
    expected behavior. In later chapters, we will use a third-party package to provide
    a more sophisticated framework for mocking the dependencies.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestUserInterface`类说明了如何模拟依赖项以提供存根功能，并提供断言来帮助验证预期的行为。在后面的章节中，我们将使用第三方包提供更复杂的模拟依赖项的框架。'
- en: Example unit test – QuitCommand
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试示例 - QuitCommand
- en: 'Starting with the `QuitCommand`, the requirements are pretty straightforward:
    the command should print a farewell message and then cause the application to
    end. We have designed the `InventoryCommand` to return two Booleans to indicate
    whether the application should quit and whether the command ended successfully:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从`QuitCommand`开始，要求非常明确：命令应打印告别消息，然后导致应用程序结束。我们已经设计了`InventoryCommand`来返回两个布尔值，以指示应用程序是否应该退出以及命令是否成功结束：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The test uses the `TestUserInterface` to verify that the text `"Thank you for
    using FlixOne Inventory Management System"`is sent to the `WriteMessage` method
    and no `ReadValue` or `WriteWarning` requests are received. These last two criteria
    are verified by the `expectedInterface.Validate()` call. The result of the `QuitCommand`
    is verified by checking that the `shouldQuit` and `wasSuccessful` Booleans are
    true.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 测试使用`TestUserInterface`来验证文本`"感谢您使用FlixOne库存管理系统"`是否发送到`WriteMessage`方法，并且没有接收到`ReadValue`或`WriteWarning`请求。这两个标准通过`expectedInterface.Validate()`调用进行验证。通过检查`shouldQuit`和`wasSuccessful`布尔值为true来验证`QuitCommand`的结果。
- en: In the FlixOne scenario, the text to be shown is *hardcoded* in the solution
    for simplicity. A better approach would be to use resource files. Resource files
    provide a way of maintaining the text separate from the functionality as well
    as supporting localizing the data for different cultures.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在FlixOne场景中，为了简化，要显示的文本在解决方案中是*硬编码*的。更好的方法是使用资源文件。资源文件提供了一种将文本与功能分开维护的方式，同时支持为不同文化本地化数据。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced the scenario of an online bookseller, FlixOne, wanting
    to build an application for managing their inventory. The chapter covered a range
    of patterns and practices that the development team can use while developing the
    application. The team used MVP to help keep the scope of the initial delivery
    to a manageable level and to help focus the business onto determining the requirements
    that had the maximum benefit to the organization. The team decided to use TDD
    to validate that the delivery matches the requirements and to help the team measure
    progress. The basic project, as well as the unit testing framework, MSTest, was
    created. The team also used SOLID principles to help structure the code in a way
    that will both help readability as well as the maintenance of the code base, as
    new enhancements to the application are added. The first Gang of Four pattern,
    the Abstract Factory design pattern, was used to provide a base for all inventory
    commands.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在线书商FlixOne想要构建一个管理其库存的应用程序的情景。本章涵盖了开发团队在开发应用程序时可以使用的一系列模式和实践。团队使用MVP来帮助将初始交付的范围保持在可管理的水平，并帮助业务集中确定对组织最有益的需求。团队决定使用TDD来验证交付是否符合要求，并帮助团队衡量进展。基本项目以及单元测试框架MSTest已创建。团队还使用了SOLID原则来帮助以一种既有利于可读性又有利于代码库的维护的方式构建代码，随着对应用程序的新增增强。第一个四人帮模式，抽象工厂设计模式，用于为所有库存命令提供基础。
- en: In the next chapter, the team will continue to build the initial inventory management
    project to fit the requirements defined in the MVP. The Gang of Four's Singleton
    pattern and the Factory Method pattern will be used by the team. These will be
    shown both with and without the mechanisms supported in .NET Core for these features.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，团队将继续构建初始库存管理项目，以满足MVP中定义的要求。团队将使用四人帮的Singleton模式和Factory Method模式。这些将在.NET
    Core中支持这些功能的机制的情况下展示。
- en: Questions
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章中包含的信息：
- en: In developing software for an organization, why is it sometimes difficult to
    determine requirements?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为组织开发软件时，为什么有时很难确定需求？
- en: What are two advantages and disadvantages of Waterfall software development
    versus Agile software development?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 瀑布软件开发与敏捷软件开发的两个优点和缺点是什么？
- en: How does dependency injection help when writing unit tests?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写单元测试时，依赖注入如何帮助？
- en: Why is the following statement false? With TDD, you no longer need people to
    test a new software deployment.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么以下陈述是错误的？使用TDD，您不再需要人们测试新软件部署。
