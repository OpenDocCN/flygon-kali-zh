- en: .NET Core Unit Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core单元测试
- en: '**Unit testing** has been one of the most discussed concepts in software development
    in the last few years. Unit testing is not a new concept in software development;
    it has been around for quite a while, since the early days of the Smalltalk programming
    language. Based on the increased advocacy for quality and robust software applications,
    software developers and testers have come to realize the great benefits unit testing
    can offer in terms of software product quality improvement.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是软件开发领域最近几年讨论最多的概念之一。单元测试并不是软件开发中的新概念；它已经存在了相当长的时间，自Smalltalk编程语言的早期。基于对质量和健壮软件应用程序的增加倡导，软件开发人员和测试人员已经意识到单元测试在软件产品质量改进方面所能提供的巨大好处。'
- en: Through unit testing, developers are able to identify errors in code quickly,
    which increases the development team's confidence in the quality of the software
    product being shipped. Unit testing is primarily carried out by programmers and
    tests, and this activity involves the breaking down of the requirements and functionalities
    of an application into units that can be tested separately.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单元测试，开发人员能够快速识别代码中的错误，从而增加开发团队对正在发布的软件产品质量的信心。单元测试主要由程序员和测试人员进行，这项活动涉及将应用程序的要求和功能分解为可以单独测试的单元。
- en: Unit tests are meant to be small and run frequently, especially when changes
    are made to the code, to ensure the working functionalities in a code base are
    not broken. When doing TDD, the unit test must be written before writing the code
    to be tested. The test usually serves as an aid for designing and writing the
    code, and is effectively a documentation for the design and specification of the
    code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试旨在保持小型并经常运行，特别是在对代码进行更改时，以确保代码库中的工作功能不会出现故障。在进行TDD时，必须在编写要测试的代码之前编写单元测试。测试通常用作设计和编写代码的辅助工具，并且有效地是代码设计和规范的文档。
- en: 'In this chapter, we will explain how to create basic unit tests and prove the
    results of our unit tests with xUnit assertions. This following topics will be
    covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释如何创建基本单元测试，并使用xUnit断言证明我们的单元测试结果。本章将涵盖以下主题：
- en: The attributes of a good unit test
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好单元测试的属性
- en: The current unit testing framework ecosystem for .NET Core and C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core和C#的当前单元测试框架生态系统
- en: Unit testing considerations for ASP.NET MVC Core
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET MVC Core的单元测试考虑因素
- en: Structuring unit tests with xUnit
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用xUnit构建单元测试
- en: Proving unit test results with xUnit assertions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用xUnit断言证明单元测试结果
- en: The test runners available on both .NET Core and Windows
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core和Windows上可用的测试运行器
- en: The attributes of a good unit test
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好单元测试的属性
- en: A unit test is a piece of code written to test another code. It is sometimes
    referred to as the lowest-level test because it is used to test code at the lowest
    level of an application. The unit test calls the method or class under test to
    validate and assert assumptions about the logic, function, and behavior of the
    code being tested.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是编写用于测试另一段代码的代码。有时它被称为最低级别的测试，因为它用于测试应用程序的最低级别的代码。单元测试调用要测试的方法或类来验证和断言有关被测试代码的逻辑、功能和行为的假设。
- en: The main purpose of unit testing is to validate a unit of code under test, to
    ascertain that the piece of code does what it is designed to do and not otherwise.
    Through unit testing, the correctness of a unit of code can be proven, this can
    be achieved only if the unit test is written well. While unit testing will prove
    the correctness and help to discover bugs in code, code quality might not be improved
    if the code being tested is poorly designed and written.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的主要目的是验证被测试代码单元，以确保代码片段执行其设计用途而不是其他用途。通过单元测试，可以证明代码单元的正确性，只有当单元测试编写得好时才能实现。虽然单元测试将证明正确性并有助于发现代码中的错误，但如果被测试的代码设计和编写不佳，代码质量可能不会得到改善。
- en: When you write your unit tests properly, you can to a certain degree, have confidence
    that your application will behave correctly when shipped. Through the test coverage
    obtainable from test suites, you can have the metrics of tests written for methods,
    classes, and other objects in your code base, and you are provided with meaningful
    information on how frequently they are being run, along with counts of how many
    times the tests pass or fail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当您正确编写单元测试时，您可以在一定程度上确信您的应用程序在发布时会正确运行。通过测试套件获得的测试覆盖率，您可以获得有关代码库中方法、类和其他对象的测试写入频率的指标，并且您将获得有关测试运行频率以及测试通过或失败次数的有意义信息。
- en: With the available test metrics, every stakeholder involved in software development
    can have access to objective information that can be used to improve the software
    development process. Unit testing, when iteratively done, can add value to the
    code by improving the reliability and quality of the code. This is possible through
    testing the code for errors—the test is run repeatedly many times, a concept known
    as **regression testing**, to locate errors that might occur as the software application
    matures and components that were working earlier break.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过可用的测试指标，参与软件开发的每个利益相关者都可以获得客观信息，这些信息可用于改进软件开发过程。迭代进行单元测试可以通过测试代码中的错误来增加代码的价值，从而提高代码的可靠性和质量。这是通过对代码进行错误测试来实现的——测试会多次重复运行，这是一个被称为**回归测试**的概念，以便在软件应用程序成熟并且之前工作的组件出现故障时找到可能发生的错误。
- en: Readable
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可读性
- en: 'This characteristic of unit tests can not be overemphasized. Similar to the
    code under test, unit tests should be easy to read and understand. The coding
    standards and principles are also applicable to tests. Anti-patterns, such as
    magic numbers or constants, should be avoided as they can clutter tests and make
    them difficult to read. Integer `10` in the following test is a magic number,
    as it was directly used. This affects the test readability and clearity:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的这一特性不容忽视。与被测试的代码类似，单元测试应该易于阅读和理解。编码标准和原则也适用于测试。应该避免使用魔术数字或常量等反模式，因为它们会使测试混乱并且难以阅读。在下面的测试中，整数`10`是一个魔术数字，因为它直接使用。这影响了测试的可读性和清晰度：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There is a good test structuring pattern that can be adopted, it''s widely
    known as the **triple A** or **3A pattern**—`Arrange`, `Act`, and `Assert`—which
    separates the test setup from its verification. You are to ensure that the required
    data input by the test is arranged, followed by the lines of code to act on the
    method under test, and assert that the results from the method under test meet
    the expectation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个良好的测试结构模式可以采用，它被广泛称为**三A模式**或**3A模式**——`安排`，`行动`和`断言`——它将测试设置与验证分开。您需要确保测试所需的数据被安排好，然后是对被测试方法进行操作的代码行，最后断言被测试方法的结果是否符合预期：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While there is no strict naming convention for tests, you should ensure that
    the name of a test represents a specific business requirement. The test name should
    have the expected input as well as state the expected output, `Test_CheckPasswordLength_ShouldReturnTrue`,
    this is because, besides serving the purpose of testing application-specific functionality,
    unit tests are also a rich source of documentation of the source code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然测试没有严格的命名约定，但您应确保测试的名称代表特定的业务需求。测试名称应包含预期的输入以及预期的输出，“Test_CheckPasswordLength_ShouldReturnTrue”，这是因为除了用于测试特定应用功能之外，单元测试还是源代码的丰富文档来源。
- en: Unit independence
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元独立性
- en: A unit test should basically be a unit, it should be designed and written in
    a form that allows it to run independently. The unit under test, in this case
    a method, should have been written to depend subtly on other methods. If possible,
    the data needed by the methods should be taken through the method parameters or
    should be provided within the unit, it should not have to request or set up data
    externally for it to function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试基本上应该是一个单元，它应该被设计和编写成可以独立运行的形式。在这种情况下，被测试的单元，即一个方法，应该已经被编写成微妙地依赖于其他方法。如果可能的话，方法所需的数据应该通过方法参数传递，或者应该在单元内提供，它不应该需要外部请求或设置数据来进行功能。
- en: The unit test should not depend on or be affected by any other tests. When unit
    tests are dependent on each other, if one of the tests fails when run, all other
    dependent tests will also fail. All the needed data by the code under test should
    be provided by the unit test.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试不应该依赖于或受到任何其他测试的影响。当单元测试相互依赖时，如果其中一个测试在运行时失败，所有其他依赖测试也会失败。代码所需的所有数据应该由单元测试提供。
- en: 'Similar to the *Single Responsibility Principle* discussed in [Chapter 2](fc097d14-900c-4069-a503-5ea22795abaf.xhtml),
    *Getting Started with .NET Core*, a unit should have only one responsibility and
    only once concern at any time. The unit should have a single task at any point
    in time to allow it to be testable as a unit. When you have a method that practically
    does more than a single task, it is simply a wrapper for units and should be decomposed
    into the basic units for easy testing:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第2章](fc097d14-900c-4069-a503-5ea22795abaf.xhtml)中讨论的*单一职责原则*类似，*开始使用.NET Core*，一个单元应该只有一个职责，任何时候只有一个关注点。单元在任何时候应该只有一个任务，以便作为一个单元进行测试。当您有一个方法实际上执行多个任务时，它只是单元的包装器，应该分解为基本单元以便进行简单的测试：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The issue with the test in this snippet is that there is a lot happening at
    the same time. And if the test fails, there is no specific way to check which
    of the method calls caused the failure. This test can be broken down into different
    tests for clarity and easy maintenance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此片段中测试的问题在于同时发生了很多事情。如果测试失败，没有特定的方法来检查哪个方法调用导致了失败。为了清晰和易于维护，这个测试可以分解成不同的测试。
- en: Repeatable
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重复
- en: 'A unit test should be easy to run without having to modify it each time it
    is to run. In essence, a test should be ready to run repeatedly without modification.
    In the following test, the `Test_DeleteLoan_ShouldReturnNull` test method is not
    repeatable, because the test has to be modified each time it is run. To avoid
    this scenario, it is preferable to mock the `loanRepository` object:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该易于运行，而无需每次运行时都进行修改。实质上，测试应该准备好重复运行而无需修改。在下面的测试中，`Test_DeleteLoan_ShouldReturnNull`测试方法是不可重复的，因为每次运行测试都必须进行修改。为了避免这种情况，最好模拟`loanRepository`对象：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Maintainable and runs fast
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 易维护且运行速度快
- en: Unit tests should be written in a manner that allows them to run quickly. The
    test should be easy to implement and any member of a development team should be
    able to run it. Because software applications are dynamic and continue to evolve,
    tests for the code base should be easy to maintain as the underlying code under
    test changes. To have tests that run faster, try to minimize dependencies as much
    as you can.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该以一种允许它们快速运行的方式编写。测试应该易于实现，任何开发团队的成员都应该能够运行它。因为软件应用是动态的，不断发展的，所以代码库的测试应该易于维护，因为被测试的底层代码发生变化。为了使测试运行更快，尽量减少依赖关系。
- en: Oftentimes, most programmers get this aspect of unit testing wrong, they write
    unit tests that have inherent dependencies, which in turn makes the tests slower
    to run. A quick rule of thumb to give you a clue that you are doing something
    wrong with your unit test, is that they are very slow to run. Also, when you have
    unit tests that make calls to backend servers or perform some tedious I/O operations,
    it is an indication of test smells.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，大多数程序员在单元测试方面做错了，他们编写具有固有依赖关系的单元测试，这反过来使得测试运行变得更慢。一个快速的经验法则可以给你一个线索，表明你在单元测试中做错了什么，那就是测试运行得非常慢。此外，当你的单元测试调用后端服务器或执行一些繁琐的I/O操作时，这表明存在测试问题。
- en: Easy to set up, non-trivial, and with good coverage
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 易于设置，非琐碎，并具有良好的覆盖率
- en: Unit tests should be easy to set up and decoupled from any direct or external
    dependencies. The external dependencies should be mocked using a suitable mocking
    framework. Appropriate object setup should be done in setup methods or test class
    constructors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该易于设置，并且与任何直接或外部依赖项解耦。应使用适当的模拟框架对外部依赖项进行模拟。适当的对象设置应在设置方法或测试类构造函数中完成。
- en: Avoid redundant codes that can clog the tests and ensure the tests contain only
    codes that are relevant to the methods being tested. Also, tests should be written
    for units or methods. For example, writing tests for class getters and setters
    might be considered too trivial.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 避免冗余代码，这可能会使测试变得混乱，并确保测试只包含与被测试方法相关的代码。此外，应该为单元或方法编写测试。例如，为类的getter和setter编写测试可能被认为太琐碎。
- en: Lastly, good unit tests should have good code coverage. All execution paths
    in a method under test should be covered and all the tests should have defined
    criteria that can be tested.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，良好的单元测试应该具有良好的代码覆盖率。测试方法中的所有执行路径都应该被覆盖，所有测试都应该有定义的可测试标准。
- en: Unit testing framework ecosystem for .NET Core and C#
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core和C#的单元测试框架生态系统
- en: The .NET Core development platform has been designed to fully support testing.
    This can be attributed to the adopted architecture. It makes TDD on the .NET Core
    platform relatively easy and worthwhile.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core开发平台已经被设计为完全支持测试。这可以归因于采用的架构。这使得在.NET Core平台上进行TDD相对容易且值得。
- en: There are several unit testing frameworks available for use in .NET and .NET
    Core. The frameworks essentially provide easy and flexible ways of writing and
    executing unit tests directly from your preferred IDEs, code editors, through
    dedicated test runners, or sometimes through the command line.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET和.NET Core中有几个可用的单元测试框架。这些框架基本上提供了从您喜欢的IDE、代码编辑器、专用测试运行器，或者有时通过命令行直接编写和执行单元测试的简单和灵活的方式。
- en: There exists a thriving ecosystem of test frameworks and suites on the .NET
    platform. The frameworks contain a variety of adapters that are available for
    use in creating unit test projects and for continuous integration and deployment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: .NET平台上存在着蓬勃发展的测试框架和套件生态系统。这些框架包含各种适配器，可用于创建单元测试项目以及用于持续集成和部署。
- en: This ecosystem of frameworks has been inherited by the .NET Core platform. This
    makes practicing TDDs on .NET Core very easy. Visual Studio IDE is open and extensive,
    making it faster and easy to install test plugins and adapters from different
    test frameworks from NuGet for use in test projects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架生态系统已经被.NET Core平台继承。这使得在.NET Core上实践TDD非常容易。Visual Studio IDE是开放且广泛的，可以更快、更容易地从NuGet安装测试插件和适配器，用于测试项目。
- en: There are quite a number of testing frameworks that are free and open source,
    used for various types of tests. The most popular of the frameworks are MSTest,
    NUnit, and xUnit.net.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多免费和开源的测试框架，用于各种类型的测试。最流行的框架是MSTest、NUnit和xUnit.net。
- en: .NET Core testing with MSTest
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core测试与MSTest
- en: Microsoft MSTest is the default testing framework that ships with Visual Studio
    and is developed by Microsoft, which originally was part of the .NET framework
    but is also included in .NET Core. The MSTest framework is used to write load,
    functional, UI, and unit tests.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft MSTest是随Visual Studio一起提供的默认测试框架，由微软开发，最初是.NET框架的一部分，但也包含在.NET Core中。MSTest框架用于编写负载、功能、UI和单元测试。
- en: MSTest can be used as a uniform application platform support as well as in testing
    a wide range of applications—Desktop, Store, **Universal Windows Platform** (**UWP**),
    and ASP.NET Core. MSTest is delivered as a NuGet package.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: MSTest可以作为统一的应用程序平台支持，也可以用于测试各种应用程序——桌面、商店、通用Windows平台（UWP）和ASP.NET Core。MSTest作为NuGet软件包提供。
- en: 'MSTest-based unit test projects can be added to an existing solution containing
    projects to be tested following the steps of adding a new project to a solution
    in Visual Studio 2017:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 基于MSTest的单元测试项目可以添加到包含要测试的项目的现有解决方案中，按照在Visual Studio 2017中向解决方案添加新项目的步骤进行操作：
- en: Right-click the existing solution in Solution Explorer, select Add and select
    New Project. Or, to create a new test project from scratch, click on the File
    menu, select New, and select Project.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击现有解决方案，选择添加，然后选择新项目。或者，要从头开始创建一个新的测试项目，点击“文件”菜单，选择“新建”，然后选择“项目”。
- en: In the displayed dialog box, select Visual C#, click the .NET Core option.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在显示的对话框中，选择Visual C#，点击.NET Core选项。
- en: 'Select MSTest Test Project (.NET Core) and give a desired name to the project.
    Then click OK:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择MSTest测试项目（.NET Core）并为项目指定一个名称。然后点击确定：
- en: '![](img/d5683380-b9e2-453a-a8e8-cfa978ed3e2a.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d5683380-b9e2-453a-a8e8-cfa978ed3e2a.png)'
- en: 'Alternatively, when creating a new project or adding a new project to an existing
    solution, select the Class Libary (.NET Core) option and add references to MSTest
    from NuGet. Install the following packages to the class library project from NuGet,
    using the NuGet package manager console or GUI option. You can run the following
    command from the NuGet package manager console:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在创建新项目或向现有解决方案添加新项目时，选择“类库（.NET Core）”选项，并从NuGet添加对MSTest的引用。从NuGet安装以下软件包到类库项目中，使用NuGet软件包管理器控制台或GUI选项。您可以从NuGet软件包管理器控制台运行以下命令：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Irrespective of which method was used to create the MSTest test project, Visual
    Studio will automatically create a `UnitTest1` or `Class1.cs` file. You can rename
    the class or delete it to create a new test class, which will be decorated with
    an MSTest `TestClass` attribute, which indicates that the class will contain test
    methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种方法创建MSTest测试项目，Visual Studio都会自动创建一个`UnitTest1`或`Class1.cs`文件。您可以重命名类或删除它以创建一个新的测试类，该类将使用MSTest的`TestClass`属性进行修饰，表示该类将包含测试方法。
- en: 'The actual test methods will be decorated with the `TestMethod` attribute,
    marking them as tests, which will make the tests runnable by the MSTest test runner.
    MSTest has a rich collection of `Assert` helper classes that can be used to verify
    the expectations of unit tests:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的测试方法将使用`TestMethod`属性进行修饰，将它们标记为测试，这将使得MSTest测试运行器可以运行这些测试。MSTest有丰富的`Assert`辅助类集合，可用于验证单元测试的期望结果：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can run the `Test_GetLoanById_ShouldReturnLoan` test method from the Test
    Explorer window in Visual Studio 2017\. This window can be opened from the `Test`
    menu, select Windows, and select Test Explorer. Right-click on the test and select
    Run Selected Tests:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Visual Studio 2017的测试资源管理器窗口中运行`Test_GetLoanById_ShouldReturnLoan`测试方法。可以从`测试`菜单中打开此窗口，选择`窗口`，然后选择`测试资源管理器`。右键单击测试并选择运行选定的测试：
- en: '![](img/a243401d-f9c6-4f6d-a09f-e70a5cbcfda9.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a243401d-f9c6-4f6d-a09f-e70a5cbcfda9.png)'
- en: 'You can also run the tests from the console. Open the command prompt window
    and change the directory to the folder containing the test project, or the solution
    folder if you want to run all test projects in the solution. Run the `dotnet test` command.
    The projects will be built, while the available tests are discovered and executed:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从控制台运行测试。打开命令提示窗口并将目录更改为包含测试项目的文件夹，或者如果要运行解决方案中的所有测试项目，则更改为解决方案文件夹。运行`dotnet
    test`命令。项目将被构建，同时可用的测试将被发现和执行：
- en: '![](img/d43da412-1305-4b9b-a03a-09e0d22ea6cf.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d43da412-1305-4b9b-a03a-09e0d22ea6cf.png)'
- en: .NET Core testing with NUnit
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NUnit进行.NET Core测试
- en: '**NUnit** is a testing framework originally ported from Java''s JUnit and can
    be used to test projects written in all programming languages available on the
    .NET platform. Currently on Version 3, its open source testing framework was released
    under MIT License.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**NUnit**是一个最初从Java的JUnit移植的测试框架，可用于测试.NET平台上所有编程语言编写的项目。目前是第3版，其开源测试框架是在MIT许可下发布的。'
- en: NUnit testing framework includes an engine and console runners. Additionally,
    it has test runners that are used for testing applications that run on mobile
    devices—**Xamarin Runners**. The NUnit test adapters and generator can essentially
    make testing using Visual Studio IDE seamless and relatively easy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: NUnit测试框架包括引擎和控制台运行器。此外，它还有用于测试在移动设备上运行的应用程序的测试运行器—**Xamarin Runners**。NUnit测试适配器和生成器基本上可以使使用Visual
    Studio IDE进行测试变得无缝和相对容易。
- en: Testing .NET Core or .NET Standards applications using NUnit requires that the
    NUnit 3 Version of Visual Studio test adapter be used. The NUnit test project
    template needs to be installed in order to be able to create an NUnit test project,
    which is usually done once.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NUnit测试.NET Core或.NET标准应用程序需要使用Visual Studio测试适配器的NUnit 3版本。需要安装NUnit测试项目模板，以便能够创建NUnit测试项目，通常只需要进行一次。
- en: 'NUnit adapters can be installed into Visual Studio 2017 with these steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: NUnit适配器可以通过以下步骤安装到Visual Studio 2017中：
- en: Click the Tools menu, then select Extension and Updates
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`工具`菜单，然后选择`扩展和更新`
- en: Click on the Online option and in the search text box, type `nunit` to filter
    to available NUnit adapters
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击在线选项，并在搜索文本框中键入`nunit`以过滤可用的NUnit适配器
- en: Select NUnit 3 Test Adapter and click Download
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择NUnit 3测试适配器并单击下载
- en: 'This will download the adapter and install it as a template into Visual Studio
    2017, you have to restart Visual Studio for this to take effect:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载适配器并将其安装为Visual Studio 2017的模板，您必须重新启动Visual Studio才能生效：
- en: '![](img/9c1256ab-f478-4a5d-8a8c-8b11f2352d06.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c1256ab-f478-4a5d-8a8c-8b11f2352d06.png)'
- en: Alternatively, you can install the NUnit 3 Test Adapter directly from NuGet
    each time you want to create a test project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以每次要创建测试项目时直接从NuGet安装NUnit 3测试适配器。
- en: 'To add an NUnit test project to your existing solution, follow these steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要将NUnit测试项目添加到现有解决方案中，请按照以下步骤操作：
- en: Right-click the solution in Solution Explorer, select Add, New Project.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击解决方案，选择添加，新建项目。
- en: In the dialog box, select Visual C#, then select the .NET Core option.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框中，选择Visual C#，然后选择.NET Core选项。
- en: Select Class Library (.NET Core) then give the desired name to the project.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择类库(.NET Core)，然后为项目指定所需的名称。
- en: 'Add `NUnit3TestAdapter` and `NUnit.ConsoleRunner` packages to the project from
    NuGet:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从NuGet向项目添加`NUnit3TestAdapter`和`NUnit.ConsoleRunner`包：
- en: '![](img/22d45be3-58b5-45d9-91bc-90fdc32e8332.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22d45be3-58b5-45d9-91bc-90fdc32e8332.png)'
- en: After the project setup is complete, you can write and run unit tests. Similar
    to MSTest, NUnit has attributes that are used to set up test methods and test
    classes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 项目设置完成后，可以编写和运行单元测试。与MSTest类似，NUnit也有用于设置测试方法和测试类的属性。
- en: The `TestFixture` attribute is used to mark a class as a container for test
    methods. The `Test` attribute is used to decorate test methods and make the methods
    callable from the NUnit test runner.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestFixture`属性用于标记一个类作为测试方法的容器。`Test`属性用于修饰测试方法，并使这些方法可以从NUnit测试运行器中调用。'
- en: 'NUnit has other attributes that are used for some setup and testing purposes.
    The `OneTimeSetup` attribute is used to decorate a method that is called one time
    only before all child tests are run. A similar attribute is `SetUp`, which is
    used to decorate a method that is called before each test is run:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: NUnit还有其他用于一些设置和测试目的的属性。`OneTimeSetup`属性用于修饰一个方法，该方法仅在运行所有子测试之前调用一次。类似的属性是`SetUp`，用于修饰在运行每个测试之前调用的方法：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The test can be run from the Test Explorer window, similar to the way it was
    run with the MSTest test project. Also, the test can be run from the command line,
    using `dotnet test`. However, you have to add **Microsoft.NET.Test.Sdk Version
    15.5.0** as reference to the NUnit test project:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以从“测试资源管理器”窗口运行，类似于在MSTest测试项目中运行的方式。此外，可以使用`dotnet test`从命令行运行测试。但是，您必须将**Microsoft.NET.Test.Sdk
    Version 15.5.0**添加为NUnit测试项目的引用：
- en: '![](img/8082dc4c-2b2e-4fbb-91c8-3194d14ad38e.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8082dc4c-2b2e-4fbb-91c8-3194d14ad38e.png)'
- en: xUnit.net
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: xUnit.net
- en: '**xUnit.net** is an open source unit testing framework for the .NET platform
    that is used to test projects written in F#, VB.NET, C#, and other .NET-compliant
    programming languages. xUnit.net was written by the inventor of Version 2 of NUnit
    and is licensed under Apache 2.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**xUnit.net**是用于测试使用F＃，VB.NET，C＃和其他符合.NET的编程语言编写的项目的.NET平台的开源单元测试框架。xUnit.net是由NUnit的第2版的发明者编写的，并根据Apache
    2许可证获得许可。'
- en: xUnit.net can be used to test traditional .NET platform applications, which
    includes console and ASP.NET applications, the UWP Application, mobile device
    applications, and .NET Core applications with ASP.NET Core inclusive.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit.net可用于测试传统的.NET平台应用程序，包括控制台和ASP.NET应用程序，UWP应用程序，移动设备应用程序以及包括ASP.NET Core的.NET
    Core应用程序。
- en: Unlike in NUnit or MSTest, where the test class is decorated with `TestFixture`
    and `TestClass` attributes, respectively, the xUnit.net test class does not require
    attribute decoration. The framework automatically detects all test methods in
    all public classes in the test project or assembly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与NUnit或MSTest不同，测试类分别使用`TestFixture`和`TestClass`属性进行装饰，xUnit.net测试类不需要属性装饰。该框架会自动检测测试项目或程序集中所有公共类中的所有测试方法。
- en: 'Also, the test setup and tear down attributes are not available in xUnit.net,
    a parameterless constructor can be used instead to set up test objects or mock
    dependencies. The test class can implement the `IDisposable` interface and do
    objects or dependencies cleanup in the `Dispose` method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在xUnit.net中不提供测试设置和拆卸属性，可以使用无参数构造函数来设置测试对象或模拟依赖项。测试类可以实现`IDisposable`接口，并在`Dispose`方法中清理对象或依赖项：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'xUnit.net supports two major types of tests—facts and theories. **Facts** are
    tests that are always true; they are tests without parameters. **Theories** are
    tests that will only be true when passed a particular set of data; they are essentially
    parameterized tests. `[Fact]` and `[Theory]` attributes are used to decorate facts
    and theories tests, respectively:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit.net支持两种主要类型的测试-事实和理论。**事实**是始终为真的测试；它们是没有参数的测试。**理论**是只有在传递特定数据集时才为真的测试；它们本质上是参数化测试。分别使用`[Fact]`和`[Theory]`属性来装饰事实和理论测试：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `[InlineData]` attribute is used in `TestMethod2` to decorate a theory test
    to supply test data to the test methods to be used during test execution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`[InlineData]`属性用于在`TestMethod2`中装饰理论测试，以向测试方法提供测试数据，以在测试执行期间使用。'
- en: How to configure xUnit.net
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何配置xUnit.net
- en: Configuration of xUnit.net comes in two flavors. xUnit.net allows the configuration
    file to be JSON or XML-based. The xUnit.net configuration must be done for each
    assembly under test. The configuration file to be used for xUnit.net is dependent
    on the development platform of the application being tested, though the JSON configuration
    file can be used on all platforms.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit.net的配置有两种类型。xUnit.net允许配置文件为基于JSON或XML。必须为要测试的每个程序集进行xUnit.net配置。用于xUnit.net的配置文件取决于被测试应用程序的开发平台，尽管JSON配置文件可用于所有平台。
- en: 'To use a JSON configuration file, after creating your test project in Visual
    Studio 2017, you should add a new JSON file to the root folder of the test project
    and name it `xunit.runner.json`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用JSON配置文件，在Visual Studio 2017中创建测试项目后，应向测试项目的根文件夹添加一个新的JSON文件，并将其命名为`xunit.runner.json`：
- en: '![](img/79a25dcb-05de-4af9-8986-68d0114476bd.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/79a25dcb-05de-4af9-8986-68d0114476bd.png)'
- en: 'After adding the file to the project, you must instruct Visual Studio to copy
    the `.json` file to the output folder of your project, where it can be located
    by xUnit test runners. To do this, you should follow these steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件添加到项目后，必须指示Visual Studio将`.json`文件复制到项目的输出文件夹中，以便xUnit测试运行程序找到它。为此，应按照以下步骤操作：
- en: Right-click the JSON configuration file from Solution Explorer. Select Properties
    from the Menu option, this will display a dialog with title xunit.runner.json
    Property Pages.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从“解决方案资源管理器”中右键单击JSON配置文件。从菜单选项中选择“属性”，这将显示一个名为xunit.runner.json属性页的对话框。
- en: 'On the Properties Window page, change the option of Copy to Output Directory
    from Never to Copy if newer and click the OK button:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“属性”窗口页面上，将“复制到输出目录”选项从“从不”更改为“如果较新则复制”，然后单击“确定”按钮：
- en: '**![](img/ab8daaf8-0d7b-4cc1-94be-e036ec31aa6c.png)**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/ab8daaf8-0d7b-4cc1-94be-e036ec31aa6c.png)**'
- en: 'This will ensure that the configuration file is always copied to the output
    folder when changes are made. The supported configuration elements in xUnit are
    placed inside a top-level JSON object in the configuration file, as seen in the
    configuration here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保在更改时配置文件始终被复制到输出文件夹。 xUnit中支持的配置元素放置在配置文件中的顶级JSON对象中，如此处所见：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When a version of Visual Studio that has JSON support is used, it will automatically
    detect the schema based on the configuration file name. Also, context help will
    be made available in Visual Studio IntelliSense while editing the `xunit.runner.json`
    file. The various configuration elements with their acceptable values are explained
    in this table:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用支持JSON的Visual Studio版本时，它将根据配置文件名称自动检测模式。此外，在编辑`xunit.runner.json`文件时，Visual
    Studio IntelliSense中将提供上下文帮助。此表中解释了各种配置元素及其可接受的值：
- en: '| **Key** | **Values** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **键** | **值** |'
- en: '| `appDomain` | The `appDomain` configuration element is the `enum` JSON schema
    type, which can take three values to determine whether application domains are
    used—`ifAvailable`, `required`, and `denied`. Application domains are used by
    desktop runners only and will be ignored by non-desktop runners.Default value
    should always be `ifAvailable`, which indicates that the application domain should
    be used if available. When set to `required`, it will require the use of application
    domains, and if set to `denied`, application domains will not be used. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `appDomain` | `appDomain`配置元素是`enum` JSON模式类型，可以采用三个值来确定是否使用应用程序域——`ifAvailable`、`required`和`denied`。应用程序域仅由桌面运行器使用，并且将被非桌面运行器忽略。默认值应始终为`ifAvailable`，表示如果可用应该使用应用程序域。当设置为`required`时，将需要使用应用程序域，如果设置为`denied`，将不使用应用程序域。
    |'
- en: '| `diagnosticMessages`  | The `diagnosticMessages` configuration element is
    the `boolean` JSON schema type and should be set to `true` if you want to enable
    diagnostic messages during test discovery and execution. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `diagnosticMessages` | `diagnosticMessages`配置元素是`boolean` JSON模式类型，如果要在测试发现和执行期间启用诊断消息，应将其设置为`true`。
    |'
- en: '| `internalDiagnosticMessages` | The `internalDiagnosticMessages` configuration
    element is the `boolean` JSON schema type and should be set to `true` if you want
    to enable internal diagnostic messages during test discovery and execution. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `internalDiagnosticMessages` | `internalDiagnosticMessages`配置元素是`boolean`
    JSON模式类型，如果要在测试发现和执行期间启用内部诊断消息，应将其设置为`true`。 |'
- en: '| `longRunningTestSeconds`  | The `longRunningTestSeconds` configuration element
    is the `integer` JSON schema type. You should set this value to a positive integer
    if you want to enable a long-running test; setting the value to `0` disables the
    configuration. You should enable `diagnosticMessages` to get notifications for
    long-running tests. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `longRunningTestSeconds` | `longRunningTestSeconds`配置元素是`integer` JSON模式类型。如果要启用长时间运行的测试，应将此值设置为正整数；将值设置为`0`会禁用该配置。您应该启用`diagnosticMessages`以获取长时间运行测试的通知。
    |'
- en: '| `maxParallelThreads`  | The `maxParallelThreads` configuration element is
    the `integer` JSON schema type. Set the value to the maximum number of threads
    to be used when parallelizing. Setting the value to `0` will maintain the default
    behavior, which is the number of logical processors on your computer. Setting
    to `-1` implies that you do not wish to set a limit to the number of threads used
    for tests parallelization. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `maxParallelThreads` | `maxParallelThreads`配置元素是`integer` JSON模式类型。将值设置为要在并行化时使用的最大线程数。将值设置为`0`将保持默认行为，即计算机上的逻辑处理器数量。设置为`-1`意味着您不希望限制用于测试并行化的线程数。
    |'
- en: '| `methodDisplay` | The `methodDisplay` configuration element is the `enum`
    JSON schema type. When this is set to `method`, the display name will be the method
    excluding the class name. Set the value to `classAndMethod`, which is the default
    value, indicating that the default display name will be used, which is the class
    name and method name. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `methodDisplay` | `methodDisplay`配置元素是`enum` JSON模式类型。当设置为`method`时，显示名称将是方法，不包括类名。将值设置为`classAndMethod`，这是默认值，表示将使用默认显示名称，即类名和方法名。
    |'
- en: '| `parallelizeAssembly` | The `parallelizeAssembly` configuration element is
    the `boolean` JSON schema type. Setting the value to `true` will make the test
    assembly parallelize with other assemblies. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `parallelizeAssembly` | `parallelizeAssembly`配置元素是`boolean` JSON模式类型。将值设置为`true`将使测试程序集与其他程序集并行化。
    |'
- en: '| `parallelizeTestCollections` | The `parallelizeTestCollections` configuration
    element is the `boolean` JSON schema type. Setting the value to true will make
    the tests run in parallel in the assembly, which allows tests in the different
    test collections to be run in parallel. Tests in the same test collection will
    still run sequentially. Setting this to `false` will disable parallelization in
    the test assembly. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `parallelizeTestCollections` | `parallelizeTestCollections`配置元素是`boolean`
    JSON模式类型。将值设置为true将使测试在程序集中并行运行，这允许不同测试集中的测试并行运行。同一测试集中的测试仍将按顺序运行。将其设置为`false`将禁用测试程序集中的并行化。
    |'
- en: '| `preEnumerateTheories` | The `preEnumerateTheories` configuration element
    is the `boolean` JSON schema type and should be set to `true` to pre-enumerate
    theories to ensure there is an individual test case for each theory data row.
    When this is set to `false`, a single test case for each theory is returned without
    pre-enumerating the data ahead of time. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `preEnumerateTheories` | `preEnumerateTheories`配置元素是`boolean` JSON模式类型，如果要预先枚举理论以确保每个理论数据行都有一个单独的测试用例，应将其设置为`true`。当设置为`false`时，将返回每个理论的单个测试用例，而不会提前枚举数据。
    |'
- en: '| `shadowCopy` | The `shadowCopy` configuration element is the `boolean` JSON
    schema type and should be set to `true` if you want to enable shadow copying when
    running tests in different application domains. This configuration element is
    ignored if the tests are being run without application domains. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `shadowCopy` | `shadowCopy`配置元素是`boolean` JSON模式类型，如果要在不同应用程序域中运行测试时启用影子复制，应将其设置为`true`。如果测试在没有应用程序域的情况下运行，则将忽略此配置元素。
    |'
- en: The other configuration file option that can be used for desktop and PCL test
    projects in xUnit.net is the XML configuration. You should add an `App.Config`
    file to your test project if it does not already have one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit.net用于桌面和PCL测试项目的另一个配置文件选项是XML配置。如果测试项目尚未具有`App.Config`文件，则应将其添加到测试项目中。
- en: 'In the `App.Config` file, under the `appSettings` section, you can add the
    configuration elements with their values. When using the XML configuration file,
    xUnit has to be appended to the configuration elements explained in the preceding
    table. For example, the `appDomain` element in the JSON configuration file will
    be written as `xunit.appDomain`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App.Config`文件的`appSettings`部分下，您可以添加配置元素及其值。在使用XML配置文件时，必须在前面表中解释的配置元素后面添加xUnit。例如，JSON配置文件中的`appDomain`元素将写为`xunit.appDomain`：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: xUnit.net test runners
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: xUnit.net测试运行器
- en: In xUnit.net, there are two actors responsible for running unit tests written
    using the framework—xUnit.net runner and the test framework. A **test runner**
    is the program that can also be a third-party plugin that searches for tests in
    assemblies and activates the tests discovered. The xUnit.net test runner depends
    on the `xunit.runner.utility` library to discover and execute tests.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在xUnit.net中，有两个负责运行使用该框架编写的单元测试的角色——xUnit.net运行器和测试框架。**测试运行器**是一个程序，也可以是搜索程序集中的测试并激活发现的测试的第三方插件。xUnit.net测试运行器依赖于`xunit.runner.utility`库来发现和执行测试。
- en: The test framework is the code with the implementation of test discovery and
    execution. The test framework links the discovered test against the `xunit.core.dll`
    and `xunit.execution.dll` libraries. The libraries live alongside the unit tests.
    `xunit.abstractions.dll` is another useful library of xUnit.net that contains
    the abstractions that the test runners and tests frameworks use in communicating.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架是实现测试发现和执行的代码。测试框架将发现的测试链接到`xunit.core.dll`和`xunit.execution.dll`库。这些库与单元测试一起存在。`xunit.abstractions.dll`是xUnit.net的另一个有用的库，其中包含测试运行器和测试框架在通信中使用的抽象。
- en: Test parallelism
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试并行
- en: '**Test parallelization** was introduced in xUnit.net as of Version 2\. This
    feature allows developers to run multiple tests in parallel. Test parallelization
    is needed because large code bases usually have several thousand tests running,
    which need to be run multiple times.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试并行化**是在xUnit.net的2.0版本中引入的。这个功能允许开发人员并行运行多个测试。测试并行化是必要的，因为大型代码库通常有数千个测试运行，需要多次运行。'
- en: These code bases have this huge number of tests because there needs to be assurance
    that the code for the features works and is not broken. They also take advantage
    of the super-fast computing resources now available to run parallel tests, thanks
    to advancements in computer hardware technology.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码库有大量的测试，因为需要确保功能代码的工作正常且没有问题。它们还利用了现在可用的超快计算资源来运行并行测试，这要归功于计算机硬件技术的进步。
- en: You can write tests that use parallelization and take advantage of the cores
    available on the computer, thereby making tests run faster, or let xUnit.net run
    multiple tests in parallel. The latter is usually preferred, which ensures tests
    can be run at the speed of the computer running them. In xUnit.net, test parallelism
    can be at the framework level, where the framework support is running multiple
    tests in the same assembly in parallel, or parallelism in test runners, where
    a runner can run multiple test assemblies in parallel.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编写使用并行化的测试，并利用计算机上可用的核心，从而使测试运行更快，或者让xUnit.net并行运行多个测试。通常情况下，后者更受欢迎，这可以确保测试以计算机运行它们的速度运行。在xUnit.net中，测试并行可以在框架级别进行，其中框架支持在同一程序集中并行运行多个测试，或者在测试运行器中进行并行化，其中运行器可以并行运行多个测试程序集。
- en: 'Tests are run in parallel using test collections. Each test class is a test
    collection, and tests within a test collection will not be run in parallel against
    each other. For example, if the tests in `LoanCalculatorTest` are run, the test
    runner will run the two tests in the class sequentially because they belong to
    the same test collection:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是使用测试集合并行运行的。每个测试类都是一个测试集合，测试集合内的测试不会相互并行运行。例如，如果运行`LoanCalculatorTest`中的测试，测试运行器将按顺序运行类中的两个测试，因为它们属于同一个测试集合：
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Tests in separate test classes can run in parallel because they belong to separate
    test collections. Let''s modify `LoanCalculatorTest` and take the `TestCalculateRate`
    test method into a separate test class, `RateCalculatorTest`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的测试类中的测试可以并行运行，因为它们属于不同的测试集合。让我们修改`LoanCalculatorTest`，将`TestCalculateRate`测试方法放入一个单独的测试类`RateCalculatorTest`中：
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we run the tests, the total time spent running both `TestCalculateLoan`
    and `TestCalculateRate` will be reduced because they are in different test classes,
    which puts them in different test collections. Also, from the Test Explorer window,
    you can observe the running icon used to mark both tests, to indicate they are
    both running:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行测试，运行`TestCalculateLoan`和`TestCalculateRate`的总时间将会减少，因为它们位于不同的测试类中，这将使它们位于不同的测试集合中。此外，从测试资源管理器窗口，您可以观察到用于标记两个测试正在运行的图标：
- en: '![](img/2b7a8086-5a87-443e-8d60-bb4c47a776ed.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b7a8086-5a87-443e-8d60-bb4c47a776ed.png)'
- en: 'Tests in separate test classes can be configured to not run in parallel. This
    is done by decorating the classes using the `Collection` attribute with the same
    name. If the `Collection` attribute is added to `LoanCalculatorTest` and `RateCalculatorTest`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的测试类中的测试可以配置为不并行运行。这可以通过使用相同名称的`Collection`属性对类进行装饰来实现。如果将`Collection`属性添加到`LoanCalculatorTest`和`RateCalculatorTest`中：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tests in the `LoanCalculatorTest` and `RateCalculatorTest` classes will not
    be run in parallel because the classes belong to the same test collection based
    on the attribute decoration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoanCalculatorTest`和`RateCalculatorTest`类中的测试不会并行运行，因为这些类基于属性装饰属于同一个测试集合。'
- en: Unit testing consideration for ASP.NET MVC Core
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET MVC Core的单元测试考虑
- en: The ASP.NET Core MVC development paradigm breaks a web application down into
    three distinct parts—the `Model`, `View`, and `Controller`, as per the tenets
    of the MVC architectural pattern. The **Model-View-Controller** (**MVC**) pattern
    facilitates the creation of web applications that are easy to test and maintain,
    and have a clear separation of concerns and boundaries.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC开发范式将Web应用程序分解为三个不同的部分——`Model`、`View`和`Controller`，符合MVC架构模式的原则。**Model-View-Controller**（MVC）模式有助于创建易于测试和维护的Web应用程序，并且具有明确的关注点和边界分离。
- en: The MVC pattern provides a clear separation between presentation logic and business
    logic, with easy scalability and maintainability. It was originally designed for
    use with desktop applications but has since gained much use and popularity with
    web applications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 模式提供了清晰的演示逻辑和业务逻辑之间的分离，易于扩展和维护。它最初是为桌面应用程序设计的，但后来在 Web 应用程序中得到了广泛的使用和流行。
- en: The ASP.NET Core MVC projects can be tested in the same manner that you test
    other types of .NET Core projects. ASP.NET Core supports the unit testing of controller
    classes, razor pages, page models, business logic, and the application data access
    layer. To build robust MVC applications, the various application components have
    to be tested in isolation and later tested when integrated.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 项目可以以与测试其他类型的 .NET Core 项目相同的方式进行测试。ASP.NET Core 支持对控制器类、razor
    页面、页面模型、业务逻辑和应用程序数据访问层进行单元测试。为了构建健壮的 MVC 应用程序，各种应用程序组件必须在隔离环境中进行测试，并在集成后进行测试。
- en: Unit testing controllers
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器单元测试
- en: The ASP.NET Core MVC Controller classes handle users interactions, which translates
    to the request on the browser. The controller gets the appropriate model and selects
    a view to render that displays the user interface. The controller reads a user's
    input data, events, and interactions from the view, and passes it to the model.
    The controller validates the input it receives from the view and then performs
    the business operation that modifies the state of the data model.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 控制器类处理用户交互，这转化为浏览器上的请求。控制器获取适当的模型并选择要呈现的视图，以显示用户界面。控制器从视图中读取用户的输入数据、事件和交互，并将其传递给模型。控制器验证来自视图的输入，然后执行修改数据模型状态的业务操作。
- en: The `Controller` classes should be lightweight and contain the minimal logic
    needed to render the view based on a user's interactions to allow easy testing
    and maintenance. The controller should verify the state of the model and ascertain
    the validity, call the appropriate code that performs business logic validation
    and manages data persistence, and later display the appropriate view to the user.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Controller` 类应该轻量级，并包含渲染视图所需的最小逻辑，以便进行简单的测试和维护。控制器应该验证模型的状态并确定有效性，调用执行业务逻辑验证和管理数据持久性的适当代码，然后向用户显示适当的视图。'
- en: When unit testing the `Controller` class, the main aim is to test the controller
    action method's behavior in isolation, this should be done without muddling up
    the test with other important MVC constructs such as model binding, routing, filters,
    and other custom controller utility objects. These other constructs, if custom-written,
    should be unit tested differently and later tested as a whole with the controller
    using integration testing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 `Controller` 类进行单元测试时，主要目的是在隔离环境中测试控制器动作方法的行为，这应该在不混淆测试与其他重要的 MVC 构造（如模型绑定、路由、过滤器和其他自定义控制器实用对象）的情况下进行。这些其他构造（如果是自定义编写的）应该以不同的方式进行单元测试，并在集成测试中与控制器一起进行整体测试。
- en: 'Review the `HomeController` class of the `LoanApplication` project, the `Controller`
    class contains the four action methods that are added when the project is created
    in Visual Studio:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 审查 `LoanApplication` 项目的 `HomeController` 类，`Controller` 类包含在 Visual Studio
    中创建项目时添加的四个动作方法：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `HomeController` class currently contains action methods with the basic
    logic of returning views. In order to unit test the MVC project, a new xUnit.net
    test project should be added to the solution, to keep the tests separate from
    the actual project code. Add the `HomeControllerTest` test class to the newly
    created test project.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`HomeController` 类当前包含具有返回视图的基本逻辑的动作方法。为了对 MVC 项目进行单元测试，应向解决方案添加一个新的 xUnit.net
    测试项目，以便将测试与实际项目代码分开。将 `HomeControllerTest` 测试类添加到新创建的测试项目中。'
- en: 'The tests methods to be written in will verify that the `viewResult` objects
    are returned by both the `Index` and `About` action methods of the `HomeController`
    class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将要编写的测试方法将验证 `HomeController` 类的 `Index` 和 `About` 动作方法返回的 `viewResult` 对象：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The tests written in the preceding controller test are basic and very simplistic.
    To demonstrate controller unit testing further, the `Controller` class code can
    be updated to support dependency injection, which will allow the methods to be
    tested through object mocking. Also, by using `AddModelError` to add errors, the
    invalid model state can be tested:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的控制器测试中编写的测试是基本的和非常简单的。为了进一步演示控制器单元测试，可以更新 `Controller` 类代码以支持依赖注入，这将允许通过对象模拟来测试方法。此外，通过使用
    `AddModelError` 来添加错误，可以测试无效的模型状态：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ILoanRepository` was injected into `HomeController` through the class constructor,
    and in the test class, `ILoanRepository` will be mocked using the Moq Framework.
    In the `TestIndex` test method, the mock object is set up with the list of `LoanType`
    required by the `Index` method in the `HomeController` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`ILoanRepository` 通过类构造函数注入到 `HomeController` 中，在测试类中，`ILoanRepository` 将使用
    Moq 框架进行模拟。在 `TestIndex` 测试方法中，使用 `LoanType` 列表设置了 `HomeController` 类中 `Index`
    方法所需的模拟对象：'
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unit testing razor pages
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: razor 页面单元测试
- en: In ASP.NET MVC, views are the components that are used for rendering a web application's
    user interface. The view presents information contained in the model in a suitable
    and easy-to-understand output format, such as HTML, XML, XHTML, or JSON. The view
    generates output to the user based on the update performed on the model.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET MVC 中，视图是用于呈现 Web 应用程序用户界面的组件。视图以适当且易于理解的输出格式（如 HTML、XML、XHTML 或 JSON）呈现模型中包含的信息。视图根据对模型执行的更新向用户生成输出。
- en: '**Razor pages** make coding features on pages relatively easier. A razor page
    is similar to a razor view, with the addition of the `@page` directive. The `@page`
    directive must be the first directive in the page, it automatically converts the
    file into an MVC action handling requests without going through the controller.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**Razor页面**使得在页面上编写功能相对容易。Razor页面类似于Razor视图，但增加了`@page`指令。`@page`指令必须是页面中的第一个指令，它会自动将文件转换为MVC操作，处理请求而无需经过控制器。'
- en: In ASP.NET Core, razor pages can be tested to ensure they work correctly in
    isolation and as an integrated application. Razor page testing can involve testing
    the data access layer codes, page components, and page models.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中，可以测试Razor页面，以确保它们在隔离和集成应用程序中正常工作。Razor页面测试可以涉及测试数据访问层代码、页面组件和页面模型。
- en: 'The following code snippet shows a unit test that verifies that a page model
    redirects correctly:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了一个单元测试，用于验证页面模型是否正确重定向：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Structuring unit tests with xUnit
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用xUnit构建单元测试
- en: Similar to the manner in which an application's code base is structured to allow
    easy readability and for effective source code maintenance, unit tests should
    be structured. This is to facilitate easy maintenance and quick running of tests
    using the test runners from Visual Studio IDE.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用程序代码库结构化方式类似，以便易于阅读和有效地维护源代码，单元测试也应该被结构化。这是为了便于维护和使用Visual Studio IDE中的测试运行器快速运行测试。
- en: A **testcase** is a test class containing test methods. It is usually common
    to have one test class per class under test. Another common practice of structuring
    tests among developers is to have a nested class for each method being tested
    or to have one base test class for the class under test and one subclass for every
    tested method. Also, there is the test class per feature approach, where all the
    test methods that collectively validate a feature of an application are grouped
    in a testcase.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试用例**是包含测试方法的测试类。通常，每个被测试类都有一个测试类。开发人员在测试中构建测试的另一种常见做法是为每个被测试的方法创建一个嵌套类，或者为被测试的类创建一个基类测试类，为每个被测试的方法创建一个子类。此外，还有每个功能一个测试类的方法，其中所有共同验证应用程序功能的测试方法都分组在一个测试用例中。'
- en: These test-structuring approaches promote the DRY principle and essentially
    faciliate code reusability while writing tests. There is no single approach that
    is best suited for all purposes, choosing a particular approach should be based
    on circumstances around the application development and come after effective communication
    with team members.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试结构方法促进了DRY原则，并在编写测试时实现了代码的可重用性。没有一种方法适用于所有目的，选择特定的方法应该基于应用程序开发周围的情况，并在与团队成员进行有效沟通后进行。
- en: 'Going the one-class-per-test or one-class-per-method route depends on individual
    preference and sometimes convention or agreement when working in a team, with
    each approach having it pros and cons. When you use the one-class-per-test approach,
    you have tests for methods in the class being tested all in the test class, as
    opposed to the one-class-per-method approach, where you have one test in the class
    as they pertain to the method being tested, though sometimes it is possible to
    have more than one test in the class as long as they are relevant to the method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 选择每个测试一个类或每个方法一个类的路线取决于个人偏好，有时也取决于团队合作时的惯例或协议，每种方法都有其利弊。当您使用每个测试一个类的方法时，您会在测试类中为被测试的类中的方法编写测试，而不是每个方法一个类的方法，其中您只在类中编写一个与被测试方法相关的测试，尽管有时可能会在类中编写多个测试，只要它们与方法相关即可：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Two test classes, `IndexMethod` and `AboutMethod`, will be created. Both classes
    will extend the `HomeControllerTest` class and will have a method each, following
    the unit testing approach of one method per test class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建两个测试类`IndexMethod`和`AboutMethod`。这两个类都将扩展`HomeControllerTest`类，并将分别拥有一个方法，遵循每个测试类一个方法的单元测试方法：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is important to note that giving test cases and test methods meaningful
    and descriptive names can go a long way in making them meaningful and easy to
    understand. It is appropriate that the name of the test methods should contain
    the names of the method or feature being tested. Optionally, it can be further
    descriptive to add the expected result in the name of the test method, prefixed
    by `Should`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，给测试用例和测试方法赋予有意义和描述性的名称可以在使它们有意义和易于理解方面起到很大作用。测试方法的名称应包含被测试的方法或功能的名称。可选地，可以在测试方法的名称中进一步描述性地添加预期结果，以`Should`为前缀：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: xUnit.net shared test context
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: xUnit.net共享测试上下文
- en: The test context setup is done in the test class constructor, since the test
    setup is not applicable in xUnit. For every test, xUnit creates a new instance
    of the test class, which implies that the codes in the class constructor are run
    for each test.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 测试上下文设置是在测试类构造函数中完成的，因为测试设置在xUnit中不适用。对于每个测试，xUnit会创建测试类的新实例，这意味着类构造函数中的代码将为每个测试运行。
- en: 'Oftentimes, it is desirable for unit test classes to share a test context because
    it can be expensive to create and clean up test contexts. xUnit offers three approaches
    to achieve this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 往往，单元测试类希望共享测试上下文，因为创建和清理测试上下文可能很昂贵。xUnit提供了三种方法来实现这一点：
- en: '**Constructor and dispose**: Sharing setup or cleanup code without having to
    share the object instances'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造函数和dispose**：共享设置或清理代码，而无需共享对象实例'
- en: '**Class fixtures**: Sharing object instances across tests in a single class'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类装置**：在单个类中跨测试共享对象实例'
- en: '**Collection fixtures**: Sharing object instances across multiple test classes'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合装置**：在多个测试类之间共享对象实例'
- en: 'You should use constructor and dispose when you want a fresh test context for
    every test in a test class. In the following code, the context object will be
    constructed and disposed for every test method in the `LoanModuleTest` class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望每个测试类中的每个测试都有一个新的测试上下文时，您应该使用构造函数和dispose。在下面的代码中，上下文对象将为`LoanModuleTest`类中的每个测试方法构造和处理：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The class fixtures approach is used when you intend to create a test context
    that will be shared among all the tests in the class and will be cleaned up when
    the all the tests have finished running. To use the class fixture, you have to
    create a fixture class with a constructor that will contain the codes for the
    objects to be shared. The test class should implement `IClassFixture<>` and you
    should add the fixture class as a constructor argument to the test class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打算创建将在类中的所有测试之间共享的测试上下文，并在所有测试运行完成后进行清理时，可以使用类装置方法。要使用类装置，您必须创建一个具有包含要共享的对象代码的构造函数的装置类。测试类应该实现`IClassFixture<>`，并且您应该将装置类作为测试类的构造函数参数添加：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `LoanModuleTest` class in the following snippet implements `IClassFixture`
    with `EFCoreFixture` passed as the parameter. `EFCoreFixture` is injected into
    the test class constructor:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段中的`LoanModuleTest`类实现了`IClassFixture`，并将`EFCoreFixture`作为参数传递。`EFCoreFixture`被注入到测试类构造函数中：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Similar to class fixtures, collection fixtures is used to create a test context
    that is shared among tests, but this time the tests can be in several classes.
    The test context creation will be done once for all the test classes and the cleanup,
    if implemented, will be executed after all the tests in the test classes have
    finished running.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与类装置类似，集合装置用于创建在多个类中共享的测试上下文。测试上下文的创建将一次性完成所有测试类，并且如果实现了清理，则将在测试类中的所有测试运行完成后执行。
- en: 'To use the collection fixture:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合装置：
- en: Create a fixture class with a constructor similar to the way you created it
    with class fixture.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与类装置类似的构造函数的装置类。
- en: 'You can implement `IDisposable` on the fixture class if there should be a code
    cleanup, which will be put in the `Dispose` method:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应该进行代码清理，则可以在装置类上实现`IDisposable`，这将放在`Dispose`方法中：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A definition class will be created that will have no code and have `ICollectionFixture<>`
    added, since it''s purpose is for defining the collection definition. Decorate
    the class with the `[CollectionDefinition]` attribute and give a name for the
    test collection:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建一个定义类，该类将没有代码，并添加`ICollectionFixture<>`，因为其目的是定义集合定义。使用`[CollectionDefinition]`属性装饰类，并为测试集合指定名称：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Add the `[Collection]` attribute to the test classes and use the name earlier
    used for the collection definition class attribute.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向测试类添加`[Collection]`属性，并使用先前用于集合定义类属性的名称。
- en: 'Add a constructor with the fixture as argument if the test classes will require
    instances of the fixture:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试类需要实例化的装置，则添加一个以装置为参数的构造函数：
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Live unit testing with Visual Studio 2017 Enterprise
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Visual Studio 2017企业版进行实时单元测试
- en: Visual Studio 2017, Enterprise edition, has a live unit testing feature that
    automatically runs tests that are affected by the changes you make to your code
    base in real time. The tests are run in the background and the results are presented
    in Visual Studio. This is a cool IDE feature that provides you with instant feedback
    on the changes you are making to a project's source code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2017企业版具有实时单元测试功能，可以自动运行受您对代码库所做更改影响的测试。测试在后台运行，并且结果在Visual Studio中呈现。这是一个很酷的IDE功能，可以为您对项目源代码所做的更改提供即时反馈。
- en: 'Live unit testing in Visual Studio currently supports NUnit, MSTest, and xUnit.
    Live unit testing can be configured from the Tools menu—select Options from the
    top-level menu, and select Live Unit Testing in the left pane of the Options dialog.
    The Live Unit Testing configuration options available can be tweaked from the
    Options dialog:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 2017企业版目前支持NUnit、MSTest和xUnit的实时单元测试。可以从工具菜单配置实时单元测试——从顶级菜单选择选项，并在选项对话框的左窗格中选择实时单元测试。可以从选项对话框调整可用的实时单元测试配置选项：
- en: '**![](img/3326490e-3774-439d-a37a-544084bbfe44.png)**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/3326490e-3774-439d-a37a-544084bbfe44.png)**'
- en: 'Live Unit Testing can be enabled from the Test menu by selecting Live Unit
    Testing, and selecting Start:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过选择实时单元测试并选择开始来从测试菜单启用实时单元测试：
- en: '![](img/7eae808b-dd25-42d2-93e2-13286fdbdbf1.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eae808b-dd25-42d2-93e2-13286fdbdbf1.png)'
- en: 'After Live Unit Testing is enabled, other available options on the Live Unit
    Testing menu will be displayed. In addition to Start, there will be Pause, Stop,
    and Reset Clean. The menus functions are described here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 启用实时单元测试后，实时单元测试菜单上的其他可用选项将显示。除了开始，还将有暂停、停止和重置清理。菜单功能在此处描述：
- en: 'Pause: This temporarily suspends Live Unit Testing, which preservs unit testing
    data collected but hides the test coverage `visualization.rk` to catch up with
    all the edits that have been made while it was paused, and updates the glyphs
    appropriately'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停：这暂时暂停实时单元测试，保留单元测试数据，但隐藏测试覆盖`visualization.rk`以赶上在暂停时所做的所有编辑，并相应地更新图标
- en: 'Stop: Stops Live Unit Testing and deletes all collected unit test data'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止：停止实时单元测试并删除所有收集的单元测试数据
- en: 'Reset Clean: Restarts Live Unit Testing by stopping it and starting it again'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重置清理：通过停止并重新启动来重新启动实时单元测试
- en: 'Options: Opens the Options dialog to configure Live Unit Testing'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项：打开选项对话框以配置实时单元测试
- en: 'In the following screenshot, the coverage visualization can be seen when Live
    Unit Testing is enabled. Every line of code is updated and decorated with green,
    red, and blue to indicate that the line of code is covered by a passing test,
    a failing test, or not covered by any test:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，可以在启用实时单元测试时看到覆盖可视化。每行代码都会更新并用绿色、红色和蓝色装饰，以指示该行代码是由通过的测试、失败的测试覆盖还是未被任何测试覆盖的：
- en: '**![](img/8b8669dc-1d2d-43d3-9227-2662e2819334.png)**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**![](img/8b8669dc-1d2d-43d3-9227-2662e2819334.png)**'
- en: Proving unit test results with xUnit.net assertions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用xUnit.net断言证明单元测试结果
- en: 'xUnit.net assertions verify the behavior of methods under tests. An assertion
    validates the condition that is expected to be true for the results being expected.
    When an assertion fails, the current execution of the test is terminated and an
    exception is thrown. The following table explains the assertions available in
    xUnit.net:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit.net断言验证测试方法的行为。断言验证了预期结果应为真的条件。当断言失败时，当前测试的执行将终止，并抛出异常。以下表格解释了xUnit.net中可用的断言：
- en: '| **Assertion** | **Description** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| **断言** | **描述** |'
- en: '| --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Equal` | Validates that an object equals another object |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '`相等` | 验证对象是否等于另一个对象'
- en: '| `NotEqual` | Validates that an object does not equal another object |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '`NotEqual` | 验证对象不等于另一个对象'
- en: '| `Same` | Verifies that two objects are of the same type |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '`相同` | 验证两个对象是否是相同类型的'
- en: '| `NotSame` | Verifies that two objects are not of the same type |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '`NotSame` | 验证两个对象不是相同类型的'
- en: '| `Contains` | Is an overloaded assertion/method and verifies that a stringcontains
    a given substring or a collection contains an object |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '`包含` | 是一个重载的断言/方法，验证字符串包含给定的子字符串或集合包含对象'
- en: '| `DoesNotContain` | Is an overloaded assertion/method and verifies that a
    stringdoes not contain a given substring or a collection does not contain an object
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '`DoesNotContain` | 是一个重载的断言/方法，验证字符串不包含给定的子字符串或集合不包含对象'
- en: '| `DoesNotThrow` | Verifies that the code does not throw exceptions |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '`DoesNotThrow` | 验证代码不会抛出异常'
- en: '| `InRange` | Verifies that a value is in a given inclusive range |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '`InRange` | 验证值在给定的包容范围内'
- en: '| `IsAssignableFrom` | Verifies that an object is of a given type or derived
    type |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '`IsAssignableFrom` | 验证对象是否是给定类型或派生类型的'
- en: '| `Empty` | Verifies that a collection is empty |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '`空` | 验证集合为空'
- en: '| `NotEmpty` | Verifies that a collection is not empty |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '`NotEmpty` | 验证集合不为空'
- en: '| `False` | Verifies that an expression is false |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '`假` | 验证表达式是否为假'
- en: '| `True` | Verifies that an expression is true |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '`真` | 验证表达式是否为真'
- en: '| `IsType<T>` | Verifies that an object is of a given type |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '`IsType<T>` | 验证对象是否是给定类型的'
- en: '| `IsNotType<T>` | Verifies that an object is not of a given type |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '`IsNotType<T>` | 验证对象不是给定类型的'
- en: '| `Null` | Verifies that an object reference is null |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '`空` | 验证对象引用是否为空'
- en: '| `NotNull` | Verifies that an object reference is not null |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '`NotNull` | 验证对象引用不为空'
- en: '| `NotInRange` | Verifies that a value is not in a given inclusive range |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '`NotInRange` | 验证值不在给定的包容范围内'
- en: '| `Throws<T>` | Verifies that the code throws an exact exception |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '`Throws<T>` | 验证代码是否抛出精确异常'
- en: 'The following snippet uses some of the xUnit.net assertion methods described
    in the preceding table. The `Assertions` unit test method shows how assertion
    methods can be used when doing unit testing in xUnit.net, to verify methods behaviors:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段使用了前面表格中描述的一些xUnit.net断言方法。`Assertions`单元测试方法展示了在xUnit.net中进行单元测试时如何使用断言方法来验证方法的行为：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The test runners available on both .NET Core and Windows
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在.NET Core和Windows上可用的测试运行器
- en: The .NET platform has a large ecosystem of test runners that can be used with
    the popular test platforms NUnit, MSTest, and xUnit. The test frameworks have
    test runners shipped with them that facilitate the smooth running of the tests.
    Additionally, there are also several open source and commercial test runners that
    can be used with the available test platforms, one of which is ReSharper.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: .NET平台有一个庞大的测试运行器生态系统，可以与流行的测试平台NUnit、MSTest和xUnit一起使用。测试框架都有随附的测试运行器，可以促进测试的顺利运行。此外，还有几个开源和商业测试运行器可以与可用的测试平台一起使用，其中之一就是ReSharper。
- en: ReSharper
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReSharper
- en: '**ReSharper** is a Visual Studio extension for .NET Developers, developed by
    JetBrains. Its test runner is by far the most popular among the test runners available
    on the .NET platform, the ReSharper productivity tool provides other functionalities
    that enhance programmers'' productivity. It has a unit test runner that can assist
    you in running and debugging unit tests based on xUnit.net, NUnit, MSTest, and
    couple of other test frameworks.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**ReSharper**是JetBrains开发的.NET开发人员的Visual Studio扩展。它的测试运行器是.NET平台上可用的测试运行器中最受欢迎的，ReSharper生产工具提供了增强程序员生产力的其他功能。它有一个单元测试运行器，可以帮助您基于xUnit.net、NUnit、MSTest和其他几个测试框架运行和调试单元测试。'
- en: 'ReShaper can detect tests written on the .NET and .NET Core platforms for the
    available test frameworks. ReSharper adds icons to the editor, which can be clicked
    to Debug or Run tests:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ReShaper可以检测到.NET和.NET Core平台上使用的测试框架编写的测试。ReSharper在编辑器中添加图标，可以单击以调试或运行测试：
- en: '![](img/1a7fe848-c074-4287-b547-2afc8e084063.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a7fe848-c074-4287-b547-2afc8e084063.png)'
- en: Unit tests are run by ReSharper using the *Unit Test Sessions* window. **ReSharper's
    Unit Test Sessions** window allows you to run any number of unit test sessions
    in parallel, independently of each other. But only one session can be run at a
    time when running in the debugging mode.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ReSharper使用*Unit Test Sessions*窗口运行单元测试。**ReSharper的单元测试会话**窗口允许您并行运行任意数量的单元测试会话，彼此独立。但是在调试模式下只能运行一个会话。
- en: 'You can filter the tests using the unit test tree, which gives you a structure
    of your tests. It shows which tests failed, passed, or have not been run. Also,
    by double-clicking on a test, you can directly navigate to the source:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用单元测试树来过滤测试，这样可以获得测试的结构。它显示了哪些测试失败、通过或尚未运行。此外，通过双击测试，您可以直接导航到源代码：
- en: '![](img/c1435338-2fa0-4ef3-8cd4-7d648e60e84a.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1435338-2fa0-4ef3-8cd4-7d648e60e84a.png)'
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Unit tests can improve the quality of your code and the overall quality of your
    application. The tests can also serve as a rich source of commentary and documentation
    for the source code. Creating high-quality unit tests is a skill that should be
    consciously learned following the guidelines discussed in this chapter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试可以提高代码的质量和应用程序的整体质量。这些测试也可以作为源代码的丰富评论和文档。创建高质量的单元测试是一个应该有意识学习的技能，遵循本章讨论的准则。
- en: In this chapter, attributes of a good unit test were discussed. We also extensively
    discussed unit testing procedures using the testing features available in the
    xUnit.net framework. The live unit testing feature in Visual Studio 2017 was explained
    and, using the xUnit.net `Fact` attribute, assertions were used to create basic
    unit tests.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，讨论了良好单元测试的属性。我们还广泛讨论了使用xUnit.net框架中可用的测试功能的单元测试程序。解释了Visual Studio 2017中的实时单元测试功能，并使用xUnit.net的`Fact`属性，使用断言来创建基本的单元测试。
- en: In the next chapter, we will explore data-driven unit tests, another important
    aspect of unit testing, which facilitates using data from different sources, such
    as from database or CSV files, to execute unit tests. This is made possible through
    the xUnit.net `Theory` attribute.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨数据驱动的单元测试，这是单元测试的另一个重要方面，它可以方便地使用来自不同来源的数据，比如来自数据库或CSV文件，来执行单元测试。这是通过xUnit.net的`Theory`属性实现的。
