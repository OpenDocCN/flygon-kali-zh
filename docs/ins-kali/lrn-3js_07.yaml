- en: Chapter 7. Particles, Sprites, and the Point Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 粒子、精灵和点云
- en: 'In the previous chapters, we discussed the most important concepts, objects,
    and APIs that Three.js has to offer. In this chapter, we''ll look into the only
    concept we''ve skipped until now: particles. With particles (sometimes also called
    sprites), it is very easy to create many small objects that you can use to simulate
    rain, snow, smoke, and other interesting effects. For instance, you can render
    individual geometries as a set of particles and control these particles separately.
    In this chapter, we''ll explore the various particle features provided by Three.js.
    To be more specific, we''ll look at the following subjects in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们讨论了Three.js提供的最重要的概念、对象和API。在本章中，我们将研究到目前为止我们跳过的唯一概念：粒子。使用粒子（有时也称为精灵），非常容易创建许多小对象，你可以用来模拟雨、雪、烟雾和其他有趣的效果。例如，你可以将单个几何体渲染为一组粒子，并分别控制这些粒子。在本章中，我们将探索Three.js提供的各种粒子特性。更具体地说，在本章中，我们将研究以下主题：
- en: Creating and styling particles using `THREE.SpriteMaterial`
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.SpriteMaterial`创建和设置粒子的样式
- en: Using a point cloud to create a grouped set of particles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用点云创建一组分组的粒子
- en: Creating a point cloud from existing geometries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现有几何体创建点云
- en: Animating particles and the particle system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画粒子和粒子系统
- en: Using a texture to style the particles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用纹理来设置粒子的样式
- en: Using the canvas to style a particle with `THREE.SpriteCanvasMaterial`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.SpriteCanvasMaterial`使用画布设置粒子的样式
- en: Let's start by exploring what a particle is and how you can create one. Before
    we get started, though, a quick note on some of the names used in this chapter.
    In recent versions of Three.js, the names of the objects related to particles
    have changed. `THREE.PointCloud`, which we use in this chapter, used to be called
    `THREE.ParticleSystem`, `THREE.Sprite` used to be called `THREE.Particle`, and
    also the materials have undergone some name changes. So, if you see online examples
    using these old names, remember that they are talking about the same concepts.
    In this chapter, we use the new naming convention introduced in the latest versions
    of Three.js.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先来探讨一下什么是粒子，以及如何创建一个。不过，在我们开始之前，关于本章中使用的一些名称，有一个快速说明。在最近的Three.js版本中，与粒子相关的对象的名称已经发生了变化。我们在本章中使用的`THREE.PointCloud`，以前被称为`THREE.ParticleSystem`，`THREE.Sprite`以前被称为`THREE.Particle`，材质也经历了一些名称的变化。因此，如果你看到使用这些旧名称的在线示例，请记住它们谈论的是相同的概念。在本章中，我们使用了最新版本Three.js引入的新命名约定。
- en: Understanding particles
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解粒子
- en: 'Like we do with most new concepts, we''ll start with an example. In the sources
    for this chapter, you''ll find an example with the name `01-particles.html`. Open
    this example and you''ll see a grid of very uninteresting-looking white cubes,
    as shown in the following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对大多数新概念一样，我们将从一个例子开始。在本章的源代码中，你会找到一个名为`01-particles.html`的例子。打开这个例子，你会看到一个非常不起眼的白色立方体网格，如下面的截图所示：
- en: '![Understanding particles](graphics/2215OS_07_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![理解粒子](graphics/2215OS_07_01.jpg)'
- en: 'What you see in this screenshot are 100 sprites. A sprite is a 2D plane that
    always faces the camera. If you create a sprite without any properties, they are
    rendered as small, white, two-dimensional squares. These sprites were created
    with the following lines of code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，你看到的是100个精灵。精灵是一个始终面向摄像机的二维平面。如果你创建一个没有任何属性的精灵，它们会被渲染为小的、白色的、二维的正方形。这些精灵是用以下代码创建的：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we create the sprites manually using the `THREE.Sprite(material)`
    constructor. The only item we pass in is a material. This has to be either `THREE.SpriteMaterial`
    or `THREE.SpriteCanvasMaterial`. We'll look at both of these materials in more
    depth in the rest of this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`THREE.Sprite(material)`构造函数手动创建精灵。我们传入的唯一项是一个材质。这必须是`THREE.SpriteMaterial`或`THREE.SpriteCanvasMaterial`。我们将在本章的其余部分更深入地研究这两种材质。
- en: Before we move on to more interesting particles, let's look a bit closer at
    the `THREE.Sprite` object. A `THREE.Sprite` object extends from the `THREE.Object3D`
    object just as `THREE.Mesh` does. This means that most of the properties and functions
    you know from `THREE.Mesh` can be used on `THREE.Sprite`. You can set its position
    using the `position` attribute, scale it using the `scale` property, and move
    it relatively using the `translate` properties.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续研究更有趣的粒子之前，让我们更仔细地看一看`THREE.Sprite`对象。`THREE.Sprite`对象扩展自`THREE.Object3D`对象，就像`THREE.Mesh`一样。这意味着你可以使用大多数从`THREE.Mesh`中了解的属性和函数在`THREE.Sprite`上。你可以使用`position`属性设置其位置，使用`scale`属性缩放它，并使用`translate`属性相对移动它。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that in older versions of Three.js, you were unable to use `THREE.Sprite`
    objects with `THREE.WebGLRenderer` and could use it only with `THREE.CanvasRenderer`.
    In the current version, `THREE.Sprite` objects can be used with both renderers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在较旧版本的Three.js中，你无法使用`THREE.Sprite`对象与`THREE.WebGLRenderer`一起使用，只能与`THREE.CanvasRenderer`一起使用。在当前版本中，`THREE.Sprite`对象可以与两种渲染器一起使用。
- en: With `THREE.Sprite`, you can very easily create a set of objects and move them
    around the scene. This works great when you're working with a small number of
    objects, but you'll quickly run into performance issues when you want to work
    with a high number of `THREE.Sprite` objects because each of the objects needs
    to be managed separately by Three.js. Three.js provides an alternative way of
    handling a large number of sprites (or particles) using `THREE.PointCloud`. With
    `THREE.PointCloud`, Three.js doesn't have to manage many individual `THREE.Sprite`
    objects, but only the `THREE.PointCloud` instance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`THREE.Sprite`，你可以非常容易地创建一组对象并在场景中移动它们。当你使用少量对象时，这很有效，但是当你想要使用大量`THREE.Sprite`对象时，你很快就会遇到性能问题，因为每个对象都需要被Three.js单独管理。Three.js提供了另一种处理大量精灵（或粒子）的方法，使用`THREE.PointCloud`。使用`THREE.PointCloud`，Three.js不需要单独管理许多个`THREE.Sprite`对象，而只需要管理`THREE.PointCloud`实例。
- en: 'To get the same result as the screenshot we saw earlier, but this time using
    `THREE.PointCloud`, we do the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得与之前看到的屏幕截图相同的结果，但这次使用`THREE.PointCloud`，我们执行以下操作：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, for each particle (each point in the cloud), we need to create
    a vertex (represented by `THREE.Vector3`), add it to `THREE.Geometry`, use `THREE.Geometry`
    together with `THREE.PointCloudMaterial` to create `THREE.PointCloud`, and add
    cloud to the scene. An example of `THREE.PointCloud` in action (with colored squares)
    can be found in the `02-particles-webgl.html` example. The following screenshot
    shows this example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，对于每个粒子（云中的每个点），我们需要创建一个顶点（由`THREE.Vector3`表示），将其添加到`THREE.Geometry`中，使用`THREE.Geometry`和`THREE.PointCloudMaterial`创建`THREE.PointCloud`，并将云添加到场景中。`THREE.PointCloud`的示例（带有彩色方块）可以在`02-particles-webgl.html`示例中找到。以下屏幕截图显示了此示例：
- en: '![Understanding particles](graphics/2215OS_07_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![理解粒子](graphics/2215OS_07_02.jpg)'
- en: In the following sections, we'll explore `THREE.PointCloud` further.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将进一步探讨`THREE.PointCloud`。
- en: Particles, THREE.PointCloud, and THREE.PointCloudMaterial
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子，THREE.PointCloud和THREE.PointCloudMaterial
- en: 'At the end of the previous section, we quickly introduced `THREE.PointCloud`.
    The constructor of `THREE.PointCloud` takes two properties: a geometry and a material.
    The material is used to color and texture the particles (as we''ll see later on),
    and the geometry defines where the individual particles are positioned. Each vertex
    and each point used to define the geometry is shown as a particle. When we create
    `THREE.PointCloud` based on `THREE.BoxGeometry`, we get 8 particles, one for each
    corner of the cube. Normally, though, you won''t create `THREE.PointCloud` from
    one of the standard Three.js geometries, but add the vertices manually to a geometry
    created from scratch (or use an externally loaded model) just like we did at the
    end of the previous section. In this section, we''ll dive a bit deeper into this
    approach and look at how you can use `THREE.PointCloudMaterial` to style the particles.
    We''ll explore this using the `03-basic-point-cloud.html` example. The following
    screenshot shows this example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节的最后，我们快速介绍了`THREE.PointCloud`。`THREE.PointCloud`的构造函数接受两个属性：几何体和材质。材质用于着色和纹理粒子（稍后我们将看到），几何体定义了单个粒子的位置。用于定义几何体的每个顶点和每个点都显示为一个粒子。当我们基于`THREE.BoxGeometry`创建`THREE.PointCloud`时，我们会得到8个粒子，每个粒子代表立方体的每个角落。不过，通常情况下，您不会从标准的Three.js几何体之一创建`THREE.PointCloud`，而是手动将顶点添加到从头创建的几何体中（或使用外部加载的模型），就像我们在上一节的最后所做的那样。在本节中，我们将深入探讨这种方法，并查看如何使用`THREE.PointCloudMaterial`来设置粒子的样式。我们将使用`03-basic-point-cloud.html`示例来探索这一点。以下屏幕截图显示了此示例：
- en: '![Particles, THREE.PointCloud, and THREE.PointCloudMaterial](graphics/2215OS_07_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![粒子，THREE.PointCloud和THREE.PointCloudMaterial](graphics/2215OS_07_03.jpg)'
- en: 'In this example, we create `THREE.PointCloud`, which we fill with 15,000 particles.
    All the particles are styled with `THREE.PointCloudMaterial`. To create `THREE.PointCloud`,
    we used the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们创建了`THREE.PointCloud`，并用15000个粒子填充它。所有粒子都使用`THREE.PointCloudMaterial`进行样式设置。要创建`THREE.PointCloud`，我们使用了以下代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this listing, we first create `THREE.Geometry`. We'll add the particles,
    represented as `THREE.Vector3`, to this geometry. For this, we've created a simple
    loop that creates `THREE.Vector3` at a random position and adds it. In this same
    loop, we also specify the array of colors, `geom.colors`, that are used when we
    set the `vertexColors` property of `THREE.PointCloudMaterial` to `true`. The last
    thing to do is create `THREE.PointCloudMaterial` and add it to the scene.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列表中，我们首先创建`THREE.Geometry`。我们将粒子表示为`THREE.Vector3`添加到此几何体中。为此，我们创建了一个简单的循环，以随机位置创建`THREE.Vector3`并将其添加。在同一个循环中，我们还指定了颜色数组`geom.colors`，当我们将`THREE.PointCloudMaterial`的`vertexColors`属性设置为`true`时使用。最后要做的是创建`THREE.PointCloudMaterial`并将其添加到场景中。
- en: 'The following table explains all the properties you can set on `THREE.PointCloudMaterial`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下表解释了您可以在`THREE.PointCloudMaterial`上设置的所有属性：
- en: '| Name | Description |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `color` | This is the color of all the particles in `ParticleSystem`. Setting
    the `vertexColors` property to true and specifying the colors using the colors
    property of the geometry overrides this property (to be more precise, the color
    of a vertex will be multiplied with this value to determine the final color).
    The default value is `0xFFFFFF`. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这是`ParticleSystem`中所有粒子的颜色。将`vertexColors`属性设置为true，并使用几何体的颜色属性指定颜色会覆盖此属性（更准确地说，顶点的颜色将与此值相乘以确定最终颜色）。默认值为`0xFFFFFF`。|'
- en: '| map | With this property, you can apply a texture to the particles. You can,
    for instance, make them look like snowflakes. This property isn''t shown in this
    example but is explained later on in this chapter. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| map | 使用此属性，您可以将纹理应用于粒子。例如，您可以使它们看起来像雪花。此属性在此示例中未显示，但在本章后面会有解释。'
- en: '| size | This is the size of the particle. The default value is `1`. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| size | 这是粒子的大小。默认值为`1`。|'
- en: '| sizeAnnutation | If this is set to false, all the particles will have the
    same size regardless of how far from the camera they are positioned. If this is
    set to true, the size is based on the distance from the camera. The default value
    is `true`. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| sizeAnnutation | 如果将其设置为false，则所有粒子的大小都将相同，而不管它们距离摄像机的位置有多远。如果将其设置为true，则大小基于距离摄像机的距离。默认值为`true`。|'
- en: '| vertexColors | Normally, all the particles in `THREE.PointCloud` have the
    same color. If this property is set to `THREE.VertexColors` and the colors array
    in the geometry has been filled, the colors from that array will be used instead
    (also see the color entry in this table). The default value is `THREE.NoColors`.
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| vertexColors | 通常，`THREE.PointCloud`中的所有粒子都具有相同的颜色。如果将此属性设置为`THREE.VertexColors`并且填充了几何体中的颜色数组，则将使用该数组中的颜色（还请参阅此表中的颜色条目）。默认值为`THREE.NoColors`。|'
- en: '| opacity | This, together with the transparent property, sets the opacity
    of the particle. The default value is `1` (no opacity). |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| opacity | 这与transparent属性一起设置了粒子的不透明度。默认值为`1`（不透明）。|'
- en: '| transparent | If this is set to true, the particle will be rendered with
    the opacity set by the opacity property. The default value is `false`. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 透明 | 如果设置为true，则粒子将以不透明度属性设置的不透明度进行渲染。默认值为`false`。 |'
- en: '| blending | This is the blend mode to use when rendering the particle. See
    [Chapter 9](ch09.html "Chapter 9. Animations and Moving the Camera"), *Animations
    and Moving the Camera*, for more information on blend modes. |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 混合 | 这是渲染粒子时使用的混合模式。有关混合模式的更多信息，请参见[第9章](ch09.html "第9章。动画和移动摄像机")*动画和移动摄像机*。
    |'
- en: '| fog | This determines whether the particles are affected by fog added to
    the scene. This defaults to `true`. |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 雾 | 这决定了粒子是否受到添加到场景中的雾的影响。默认值为`true`。 |'
- en: The previous example provides a simple control menu that you can use to experiment
    with the properties specific to `THREE.ParticleCloudMaterial`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例提供了一个简单的控制菜单，您可以使用它来实验特定于`THREE.ParticleCloudMaterial`的属性。
- en: 'So far, we''ve only rendered the particles as small cubes, which is the default
    behavior. There are, however, a few additional ways you can use to style the particles:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只将粒子呈现为小立方体，这是默认行为。然而，您还有一些其他方式可以用来设置粒子的样式：
- en: We can apply `THREE.SpriteCanvasMaterial` (which only works for `THREE.CanvasRenderer`)
    to use the results from an HTML canvas element as a texture
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以应用`THREE.SpriteCanvasMaterial`（仅适用于`THREE.CanvasRenderer`）来使用HTML画布元素的结果作为纹理
- en: Use `THREE.SpriteMaterial` and a HTML5-based texture to use the output of an
    HTML canvas when working with `THREE.WebGLRenderer`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.SpriteMaterial`和基于HTML5的纹理在使用`THREE.WebGLRenderer`时使用HTML画布的输出
- en: Load an external image file (or use the HTML5 canvas) with the `map` property
    of `THREE.PointCloudMaterial` to style all particles of `THREE.ParticleCloud`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`THREE.PointCloudMaterial`的`map`属性加载外部图像文件（或使用HTML5画布）来为`THREE.ParticleCloud`的所有粒子设置样式
- en: In the next section, we look into how you can do this.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看如何做到这一点。
- en: Styling particles with the HTML5 canvas
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTML5画布对粒子进行样式设置
- en: Three.js offers three different ways you can use an HTML5 canvas to style your
    particles. If you use `THREE.CanvasRenderer`, you can directly reference an HTML5
    canvas from `THREE.SpriteCanvasMaterial`. When you use `THREE.WebGLRenderer`,
    you need to take a couple of extra steps to use an HTML5 canvas to style your
    particles. In the following two sections, we'll show you the different approaches.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了三种不同的方式，您可以使用HTML5画布来设置粒子的样式。如果您使用`THREE.CanvasRenderer`，您可以直接从`THREE.SpriteCanvasMaterial`引用HTML5画布。当您使用`THREE.WebGLRenderer`时，您需要采取一些额外的步骤来使用HTML5画布来设置粒子的样式。在接下来的两节中，我们将向您展示不同的方法。
- en: Using HTML5 canvas with THREE.CanvasRenderer
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTML5画布与THREE.CanvasRenderer
- en: 'With `THREE.SpriteCanvasMaterial`, you can use the output from an HTML5 canvas
    as a texture for your particles. This material is specifically created for `THREE.CanvasRenderer`
    and only works when you use this specific renderer. Before we look at how to use
    this material, let''s first look at the attributes you can set on this material:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`THREE.SpriteCanvasMaterial`，您可以使用HTML5画布的输出作为粒子的纹理。这种材质是专门为`THREE.CanvasRenderer`创建的，并且只在使用这个特定的渲染器时才有效。在我们看如何使用这种材质之前，让我们先看看您可以在这种材质上设置的属性：
- en: '| Name | Description |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `color` | This is the color of the particle. Depending on the specified `blending`
    mode, this affects the color of the canvas image. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `颜色` | 这是粒子的颜色。根据指定的`混合`模式，这会影响画布图像的颜色。 |'
- en: '| `program` | This is a function that takes a canvas context as a parameter.
    This function is called when the particle is rendered. The output from the calls
    to this 2D drawing context is shown as the particle. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `program` | 这是一个以画布上下文作为参数的函数。当粒子被渲染时，将调用此函数。对这个2D绘图上下文的调用的输出显示为粒子。 |'
- en: '| `opacity` | This determines the opacity of the particle. The default value
    is `1`, and there is no opacity. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `不透明度` | 这决定了粒子的不透明度。默认值为`1`，即不透明。 |'
- en: '| `transparent` | This determines whether the particle is transparent or not.
    This works together with the `opacity` property. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `透明` | 这决定了粒子是否是透明的。这与`不透明度`属性一起使用。 |'
- en: '| `blending` | This is the blend mode to be used. See [Chapter 9](ch09.html
    "Chapter 9. Animations and Moving the Camera"), *Animations and Moving the Camera*
    for more details. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `混合` | 这是要使用的混合模式。有关更多详细信息，请参见[第9章](ch09.html "第9章。动画和移动摄像机")*动画和移动摄像机*。
    |'
- en: '| `rotation` | This property allows you to rotate the contents of the canvas.
    You''ll usually need to set this to PI to correctly align the contents of the
    canvas. Note that this property can''t be passed in to the constructor of the
    material, but needs to be set explicitly. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `旋转` | 这个属性允许您旋转画布的内容。通常需要将其设置为PI，以正确对齐画布的内容。请注意，这个属性不能传递给材质的构造函数，而需要显式设置。
    |'
- en: 'To see `THREE.SpriteCanvasMaterial` in action, you can open the `04-program-based-sprites.html`
    example. The following screenshot shows this example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`THREE.SpriteCanvasMaterial`的实际效果，您可以打开`04-program-based-sprites.html`示例。以下屏幕截图显示了这个例子：
- en: '![Using HTML5 canvas with THREE.CanvasRenderer](graphics/2215OS_07_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用HTML5画布与THREE.CanvasRenderer](graphics/2215OS_07_04.jpg)'
- en: 'In this example, the particles are created in the `createSprites` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，粒子是在`createSprites`函数中创建的：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code looks a lot like the code we saw in the previous section. The main
    change is that because we''re working with `THREE.CanvasRenderer`, we create `THREE.Sprite`
    objects directly, instead of using `THREE.PointCloud`. In this code, we also define
    `THREE.SpriteCanvasMaterial` with a `program` attribute that points to the `draw`
    function. This `draw` function defines what a particle will look like (in our
    case, a ghost from *Pac-Man*):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来很像我们在上一节中看到的代码。主要变化是，因为我们正在使用`THREE.CanvasRenderer`，我们直接创建`THREE.Sprite`对象，而不是使用`THREE.PointCloud`。在这段代码中，我们还使用`program`属性定义了`THREE.SpriteCanvasMaterial`，该属性指向`draw`函数。这个`draw`函数定义了粒子的外观（在我们的例子中，是*Pac-Man*中的幽灵）：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We won't dive into the actual canvas code required to draw our shape. What's
    important here is that we define a function that accepts a 2D canvas context (`ctx`)
    as its parameter. Everything that is drawn onto that context is used as the shape
    for `THREE.Sprite`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论绘制形状所需的实际画布代码。这里重要的是我们定义了一个接受2D画布上下文（`ctx`）作为参数的函数。在该上下文中绘制的一切都被用作`THREE.Sprite`的形状。
- en: Using HTML5 canvas with WebGLRenderer
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用HTML5画布与WebGLRenderer
- en: If we want to use an HTML5 canvas with `THREE.WebGLRenderer`, we can take two
    different approaches. We can use `THREE.PointCloudMaterial` and create `THREE.PointCloud`,
    or we can use `THREE.Sprite` and the `map` property of `THREE.SpriteMaterial`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在`THREE.WebGLRenderer`中使用HTML5画布，我们可以采取两种不同的方法。我们可以使用`THREE.PointCloudMaterial`并创建`THREE.PointCloud`，或者我们可以使用`THREE.Sprite`和`THREE.SpriteMaterial`的`map`属性。
- en: 'Let''s start with the first approach and create `THREE.PointCloud`. In the
    attributes for `THREE.PointCloudMaterial`, we mentioned the `map` property. With
    the `map` property, we can load a texture for the particle. With Three.js, this
    texture can also be the output from an HTML5 canvas. An example showing this concept
    is `05a-program-based-point-cloud-webgl.html`. The following screenshot shows
    this example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一种方法开始创建`THREE.PointCloud`。在`THREE.PointCloudMaterial`的属性中，我们提到了`map`属性。使用`map`属性，我们可以为粒子加载纹理。在Three.js中，这个纹理也可以是来自HTML5画布的输出。一个展示这个概念的例子是`05a-program-based-point-cloud-webgl.html`。以下截图显示了这个例子：
- en: '![Using HTML5 canvas with WebGLRenderer](graphics/2215OS_07_05.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用HTML5画布与WebGLRenderer](graphics/2215OS_07_05.jpg)'
- en: 'Let''s look at the code we wrote to get this effect. Most of the code is the
    same as our previous WebGL example, so we won''t go into too much detail. The
    important code changes that were made to get this example are shown here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们编写的代码来实现这个效果。大部分代码与我们之前的WebGL示例相同，所以我们不会详细介绍。为了得到这个例子所做的重要代码更改如下所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In `getTexture`, the first of these two JavaScript functions, we create `THREE.Texture`
    based on an HTML5 canvas element. In the second function, `createPointCloud`,
    we assign this texture to the `map` property of `THREE.PointCloudMaterial`. In
    this function, you can also see that we set the `sortParticles` property of `THREE.PointCloud`
    to `true`. This property makes sure that before the particles are rendered, they
    are sorted according to their *z* position on screen. If you see partly overlapping
    particles or incorrect transparency, setting this property to `true` will (in
    most cases) fix that. You should note, though, that setting this property to `true`
    will affect the performance of your scene. When this is set to true, Three.js
    will have to determine the distance to the camera for each individual particle.
    For a `THREE.PointCloud` object that is very large, this can have a big impact
    on performance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getTexture`中，这两个JavaScript函数中的第一个，我们基于HTML5画布元素创建了`THREE.Texture`。在第二个函数`createPointCloud`中，我们将这个纹理分配给了`THREE.PointCloudMaterial`的`map`属性。在这个函数中，您还可以看到我们将`THREE.PointCloud`的`sortParticles`属性设置为`true`。这个属性确保在粒子被渲染之前，它们根据屏幕上的*z*位置进行排序。如果您看到部分重叠的粒子或不正确的透明度，将此属性设置为`true`（在大多数情况下）可以解决这个问题。不过，您应该注意，将此属性设置为`true`会影响场景的性能。当这个属性设置为true时，Three.js将不得不确定每个单独粒子到相机的距离。对于一个非常大的`THREE.PointCloud`对象，这可能会对性能产生很大的影响。
- en: 'While we''re talking about the properties of `THREE.PointCloud`, there is one
    additional property you can set on `THREE.PointCloud: FrustumCulled`. If this
    property is set to true, it means that if particles fall outside the visible camera
    range, they aren''t rendered. This can be used to improve performance and frame
    rate if needed.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论`THREE.PointCloud`的属性时，还有一个额外的属性可以设置在`THREE.PointCloud`上：`FrustumCulled`。如果将此属性设置为true，这意味着如果粒子超出可见相机范围，它们将不会被渲染。这可以用来提高性能和帧速率。
- en: The result of this is that everything we draw to the canvas in the `getTexture()`
    method is used for the particles in `THREE.PointCloud`. In the following section,
    we'll look a bit deeper into how this works with textures we load from external
    files. Note that in this example, we only see a very small part of what is possible
    with textures. In [Chapter 10](ch10.html "Chapter 10. Loading and Working with
    Textures"), *Loading and Working with Textures*, we'll dive into the details of
    what can be done with textures.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的结果是，我们在`getTexture()`方法中绘制到画布上的一切都用于`THREE.PointCloud`中的粒子。在接下来的部分中，我们将更深入地了解从外部文件加载的纹理是如何工作的。请注意，在这个例子中，我们只看到了纹理可能实现的一小部分。在[第10章](ch10.html
    "第10章。加载和使用纹理")中，*加载和使用纹理*，我们将深入了解纹理的可能性。
- en: 'At the beginning of this section, we mentioned that we could also use `THREE.Sprite`
    together with the `map` property to create a canvas-based particle. For this,
    we use the same approach to create `THREE.Texture` as we saw in the previous example.
    This time, however, we assign it to `THREE.Sprite` like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的开头，我们提到我们也可以使用`THREE.Sprite`与`map`属性一起创建基于画布的粒子。为此，我们使用了与前面示例中相同的方法创建`THREE.Texture`。然而，这一次，我们将它分配给`THREE.Sprite`，如下所示：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you can see that we use a standard `THREE.SpriteMaterial` object and assign
    the output of the canvas as `THREE.Texture` to the `map` property of the material.
    You can view an example of this by opening `05b-program-based-sprites-webgl.html`
    in your browser. Both of these approaches have their own advantages and disadvantages.
    With `THREE.Sprite`, you have more control over the individual particle, but it
    becomes less performant and more complex when you're working with a large number
    of particles. With `THREE.PointCloud`, you can easily manage a large number of
    particles, but have less control over each individual particle.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们使用了一个标准的`THREE.SpriteMaterial`对象，并将画布的输出作为`THREE.Texture`分配给了材质的`map`属性。您可以通过在浏览器中打开`05b-program-based-sprites-webgl.html`来查看这个例子。这两种方法各有优缺点。使用`THREE.Sprite`，您可以更好地控制每个粒子，但当您处理大量粒子时，性能会降低，复杂性会增加。使用`THREE.PointCloud`，您可以轻松管理大量粒子，但对每个单独的粒子的控制较少。
- en: Using textures to style particles
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理来设置粒子的样式
- en: In the previous example, we saw how you could style `THREE.PointCloud` and individual
    `THREE.Sprite` objects using an HTML5 canvas. Since you can draw anything you
    want and even load external images, you can use this approach to add all kinds
    of styles to the particle system. There is, however, a more direct way to use
    an image to style your particles. You can use the `THREE.ImageUtils.loadTexture()`
    function to load an image as `THREE.Texture`. `THREE.Texture` can then be assigned
    to the `map` property of a material.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们看到了如何使用HTML5画布来设置`THREE.PointCloud`和单个`THREE.Sprite`对象的样式。由于您可以绘制任何您想要的东西，甚至加载外部图像，您可以使用这种方法向粒子系统添加各种样式。然而，有一种更直接的方法可以使用图像来设置您的粒子的样式。您可以使用`THREE.ImageUtils.loadTexture()`函数将图像加载为`THREE.Texture`。然后可以将`THREE.Texture`分配给材质的`map`属性。
- en: 'In this section, we''ll show you two examples and explain how to create them.
    Both these examples use an image as a texture for your particles. In the first
    example, we create a simulation of rain, `06-rainy-scene.html`. The following
    screenshot shows this example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示两个示例并解释如何创建它们。这两个示例都使用图像作为粒子的纹理。在第一个示例中，我们创建了一个模拟雨的场景，`06-rainy-scene.html`。以下屏幕截图显示了这个示例：
- en: '![Using textures to style particles](graphics/2215OS_07_06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理来设置粒子的样式](graphics/2215OS_07_06.jpg)'
- en: 'The first thing we need to do is get a texture that will represent our raindrop.
    You can find a couple of examples in the `assets/textures/particles` folder. In
    [Chapter 9](ch09.html "Chapter 9. Animations and Moving the Camera"), *Animations
    and Moving the Camera*, we will explain all the details and requirements for textures.
    For now, all you need to know is that the texture should be square and preferably
    a power of 2 (for example, 64 x 64, 128 x 128, 256 x 256). For this example, we''ll
    use this texture:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是获取一个代表雨滴的纹理。您可以在`assets/textures/particles`文件夹中找到一些示例。在[第9章](ch09.html
    "第9章。动画和移动相机")*动画和移动相机*中，我们将解释纹理的所有细节和要求。现在，您需要知道的是纹理应该是正方形的，最好是2的幂（例如，64 x 64，128
    x 128，256 x 256）。对于这个例子，我们将使用这个纹理：
- en: '![Using textures to style particles](graphics/2215OS_07_07.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理来设置粒子的样式](graphics/2215OS_07_07.jpg)'
- en: 'This image uses a black background (needed for correct blending) and shows
    the shape and color of a raindrop. Before we can use this texture in `THREE.PointCloudMaterial`,
    we first need to load it. This can be done with the following line of code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图像使用了黑色背景（需要正确混合）并显示了雨滴的形状和颜色。在我们可以在`THREE.PointCloudMaterial`中使用这个纹理之前，我们首先需要加载它。可以用以下代码行来完成：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this line of code, Three.js will load the texture, and we can use it in
    our material. For this example, we defined the material like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这行代码，Three.js将加载纹理，我们可以在我们的材质中使用它。对于这个例子，我们定义了这样的材质：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this chapter, we've discussed all of these properties. The main thing to
    understand here is that the `map` property points to the texture we loaded with
    the `THREE.ImageUtils.loadTexture()` function, and we specify `THREE.AdditiveBlending`
    as the `blending` mode. This `blending` mode means that when a new pixel is drawn,
    the color of the background pixel is added to the color of this new pixel. For
    our raindrop texture, this means that the black background won't be shown. A logical
    alternative would be to replace the black from our texture with a transparent
    background, but that doesn't work with particles and WebGL unfortunately.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经讨论了所有这些属性。这里需要理解的主要是`map`属性指向我们使用`THREE.ImageUtils.loadTexture()`函数加载的纹理，并且我们将`THREE.AdditiveBlending`指定为`blending`模式。这种`blending`模式意味着当绘制新像素时，背景像素的颜色会添加到这个新像素的颜色中。对于我们的雨滴纹理，这意味着黑色背景不会显示出来。一个合理的替代方案是用透明背景替换我们纹理中的黑色，但遗憾的是这在粒子和WebGL中不起作用。
- en: 'That takes care of styling `THREE.PointCloud`. What you''ll also see when you
    open up this example is that the particles themselves are moving. In the previous
    examples, we moved the entire particle system; this time, we position the individual
    particles within `THREE.PointCloud`. Doing this is actually very simple. Each
    particle is represented as a vertex that makes up the geometry that was used to
    create `THREE.PointCloud`. Let''s look at how we add the particles for `THREE.PointCloud`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了`THREE.PointCloud`的样式。当您打开这个例子时，您还会看到粒子本身在移动。在之前的例子中，我们移动了整个粒子系统；这一次，我们在`THREE.PointCloud`内部定位了单个粒子。这样做实际上非常简单。每个粒子都表示为构成用于创建`THREE.PointCloud`的几何体的顶点。让我们看看如何为`THREE.PointCloud`添加粒子：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This isn''t that different from the previous examples we saw. Here, we added
    two additional properties to each particle (`THREE.Vector3`): `velocityX` and
    `velocityY`. The first one defines how a particle (a raindrop) moves horizontally,
    and the second one defines how fast the raindrop falls down. The horizontal velocity
    ranges from -0.16 to +0.16, and the vertical speed ranges from 0.1 to 0.3\. Now
    that each raindrop has its own speed, we can move the individual particles inside
    the render loop:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前看到的例子并没有太大不同。在这里，我们为每个粒子（`THREE.Vector3`）添加了两个额外的属性：`velocityX`和`velocityY`。第一个定义了粒子（雨滴）水平移动的方式，第二个定义了雨滴下落的速度。水平速度范围从-0.16到+0.16，垂直速度范围从0.1到0.3。现在每个雨滴都有自己的速度，我们可以在渲染循环中移动单个粒子：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this piece of code, we get all `vertices` (particles) from the geometry that
    was used to create `THREE.PointCloud`. For each of the particles, we take `velocityX`
    and `velocityY` and use them to change the current position of the particle. The
    last two lines make sure the particles stay within the range we've defined. If
    the `v.y` position drops below zero, we add the raindrop back to the top, and
    if the `v.x` position reaches any of the edges, we make it bounce back by inverting
    the horizontal velocity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们从用于创建`THREE.PointCloud`的几何体中获取所有`vertices`（粒子）。对于每个粒子，我们取`velocityX`和`velocityY`并使用它们来改变粒子的当前位置。最后两行确保粒子保持在我们定义的范围内。如果`v.y`位置低于零，我们将雨滴添加回顶部，如果`v.x`位置达到任何边缘，我们通过反转水平速度使其反弹回来。
- en: 'Let''s look at another example. This time, we won''t make rain, but we''ll
    make snow. Additionally, we won''t be using just a single texture, but we''ll
    use five separate images (taken from the Three.js examples). Let''s start by looking
    at the result again (see `07-snowy-scene.html`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。这一次，我们不会下雨，而是下雪。此外，我们不仅使用单一纹理，还将使用五个单独的图像（来自Three.js示例）。让我们首先再次看一下结果（参见`07-snowy-scene.html`）：
- en: '![Using textures to style particles](graphics/2215OS_07_08.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理来设置粒子样式](graphics/2215OS_07_08.jpg)'
- en: 'In the preceding screenshot, you can see that instead of using just a single
    image as texture, we''ve used multiple images. You might wonder how we did this.
    As you probably remember, we can only have a single material for `THREE.PointCloud`.
    If we want to have multiple materials, we just have to make multiple particle
    systems, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，您可以看到我们不仅使用单个图像作为纹理，还使用了多个图像。您可能想知道我们是如何做到这一点的。您可能还记得，我们只能为`THREE.PointCloud`有一个单一的材质。如果我们想要有多个材质，我们只需要创建多个粒子系统，如下所示：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, you can see that we load the textures separately and pass all the information
    on how to create `THREE.PointCloud` to the `createPointCloud` function. This function
    looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们分别加载纹理，并将创建`THREE.PointCloud`的所有信息传递给`createPointCloud`函数。这个函数看起来像这样：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first thing we do in this function is define the color in which the particles
    for this specific texture should be rendered. This is done by randomly changing
    the *lightness* of the passed-in color. Next, the material is created in the same
    manner we did before. The only change here is that the `depthWrite` property is
    set to `false`. This property defines whether this object affects the WebGL depth
    buffer. By setting this to `false`, we make sure that the various point clouds
    don''t interfere with each other. If this property isn''t set to `false`, you''ll
    see that the black background from the texture is sometimes shown when a particle
    is in front of a particle from another `THREE.PointCloud` object. The last step
    taken in this piece of code is randomly placing the particles and adding a random
    speed to each particle. In the render loop, we can now update the position of
    all the particles from each `THREE.PointCloud` object like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先定义了应该渲染为特定纹理的粒子的颜色。这是通过随机改变传入颜色的*亮度*来完成的。接下来，材质以与之前相同的方式创建。这里唯一的变化是`depthWrite`属性设置为`false`。这个属性定义了这个对象是否影响WebGL深度缓冲区。通过将其设置为`false`，我们确保各种点云不会相互干扰。如果这个属性没有设置为`false`，您会看到当一个粒子在另一个`THREE.PointCloud`对象的粒子前面时，有时会显示纹理的黑色背景。这段代码的最后一步是随机放置粒子并为每个粒子添加随机速度。在渲染循环中，我们现在可以像这样更新每个`THREE.PointCloud`对象的所有粒子的位置：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With this approach, we can have particles that have different textures. This
    approach, however, is a bit limited. The more different textures we want, the
    more point clouds we'll have to create and manage. If you have a limited set of
    particles with different styles, you'd better use the `THREE.Sprite` object we
    showed at the beginning of this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，我们可以拥有不同纹理的粒子。然而，这种方法有点受限。我们想要的不同纹理越多，我们就必须创建和管理更多的点云。如果您有一组不同样式的有限粒子，最好使用我们在本章开头展示的`THREE.Sprite`对象。
- en: Working with sprite maps
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用精灵地图
- en: At the beginning of this chapter, we used a `THREE.Sprite` object to render
    single particles with `THREE.CanvasRenderer` and `THREE.WebGLRenderer`. These
    sprites were positioned somewhere in the 3D world, and their size was based on
    the distance from the camera (this is also sometimes called **billboarding**).
    In this section, we'll show an alternative use of the `THREE.Sprite` object. We'll
    show you how you can use `THREE.Sprite` to create a layer similar to **head-up
    display** (**HUD**) for your 3D content using an extra `THREE.OrthographicCamera`
    instance. We will also show you how to select the image for a `THREE.Sprite` object
    using a sprite map.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们使用了`THREE.Sprite`对象来使用`THREE.CanvasRenderer`和`THREE.WebGLRenderer`渲染单个粒子。这些精灵被放置在3D世界的某个地方，并且它们的大小是基于与摄像机的距离（有时也称为**billboarding**）。在本节中，我们将展示`THREE.Sprite`对象的另一种用法。我们将向您展示如何使用`THREE.Sprite`创建类似于**抬头显示**（**HUD**）的3D内容的图层，使用额外的`THREE.OrthographicCamera`实例。我们还将向您展示如何使用精灵地图为`THREE.Sprite`对象选择图像。
- en: 'As an example, we''re going to create a simple `THREE.Sprite` object that moves
    from left to right over the screen. In the background, we''ll render a 3D scene
    with a moving camera to illustrate that `THREE.Sprite` moves independently of
    the camera. The following screenshot shows what we''ll be creating for the first
    example (`08-sprites.html`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们将创建一个简单的`THREE.Sprite`对象，它从屏幕左侧移动到右侧。在背景中，我们将渲染一个带有移动摄像机的3D场景，以说明`THREE.Sprite`独立于摄像机移动。以下截图显示了我们将为第一个示例创建的内容（`08-sprites.html`）：
- en: '![Working with sprite maps](graphics/2215OS_07_09.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![使用精灵地图](graphics/2215OS_07_09.jpg)'
- en: 'If you open this example in your browser, you''ll see a Pac-Man ghost-like
    sprite moving across the screen and changing color and form whenever it hits the
    right edge. The first thing we''ll do is look at how we create `THREE.OrthographicCamera`
    and a separate scene to render `THREE.Sprite` in:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开此示例，您将看到类似Pac-Man幽灵的精灵在屏幕上移动，并且每当它碰到右边缘时，颜色和形状都会发生变化。我们首先要做的是看一下我们如何创建`THREE.OrthographicCamera`和一个单独的场景来渲染`THREE.Sprite`：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, let''s look at the construction of `THREE.Sprite` and how the various
    shapes the sprite can take are loaded:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看`THREE.Sprite`的构造以及精灵可以采用的各种形状是如何加载的：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `getTexture()` function, we load a texture. However, instead of loading
    five different images for each *ghost*, we load a single texture that contains
    all the sprites. The texture looks like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getTexture()`函数中，我们加载了一个纹理。但是，我们加载的不是每个*ghost*的五个不同图像，而是加载了一个包含所有精灵的单个纹理。纹理看起来像这样：
- en: '![Working with sprite maps](graphics/2215OS_07_10.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![使用精灵地图](graphics/2215OS_07_10.jpg)'
- en: With the `map.offset` and the `map.repeat` properties, we select the correct
    sprite to show on screen. With the `map.offset` property, we determine the offset
    for the *x* axis (u) and the *y* axis (v) for the texture we loaded. The scale
    for these properties runs from 0 to 1\. In our example, if we want to select the
    third ghost, we set the u-offset (*x* axis) to 0.4, and, because we've only got
    one row, we don't need to change the v-offset (*y* axis). If we only set this
    property, the texture shows the third, fourth, and fifth ghosts compressed together
    on screen. To only show one ghost, we need to zoom in. We do this by setting the
    `map.repeat` property for the u-value to 1/5\. This means that we zoom in (only
    for the *x* axis) to only show 20 percent of the texture, which is exactly one
    ghost.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`map.offset`和`map.repeat`属性，我们选择要在屏幕上显示的正确精灵。使用`map.offset`属性，我们确定了我们加载的纹理在*x*轴（u）和*y*轴（v）上的偏移量。这些属性的比例范围从0到1。在我们的示例中，如果我们想选择第三个幽灵，我们将u偏移（*x*轴）设置为0.4，因为我们只有一行，所以我们不需要改变v偏移（*y*轴）。如果我们只设置这个属性，纹理会在屏幕上压缩显示第三、第四和第五个幽灵。要只显示一个幽灵，我们需要放大。我们通过将u值的`map.repeat`属性设置为1/5来实现这一点。这意味着我们放大（仅对*x*轴）以仅显示纹理的20％，这正好是一个幽灵。
- en: 'The final step we need to take is update the `render` function:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要采取的最后一步是更新`render`函数：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We first render the scene with the normal camera and the moving sphere, and
    after that, we render the scene containing our sprite. Note that we need to set
    the `autoClear` property of the WebGLRenderer to `false`. If we don't do this,
    Three.js will clear the scene before it renders the sprite, and the sphere wouldn't
    show up.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用普通相机和移动的球体渲染场景，然后再渲染包含我们的精灵的场景。请注意，我们需要将WebGLRenderer的`autoClear`属性设置为`false`。如果不这样做，Three.js将在渲染精灵之前清除场景，并且球体将不会显示出来。
- en: 'The following table shows an overview of all the properties of `THREE.SpriteMaterial`
    we used in the previous examples:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们在前面示例中使用的`THREE.SpriteMaterial`的所有属性的概述：
- en: '| Name | Description |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `color` | This is the color of the sprite. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `color` | 这是精灵的颜色。 |'
- en: '| `map` | This is the texture to be used for this sprite. This can be a sprite
    sheet, as shown in the example in this section. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `map` | 这是要用于此精灵的纹理。这可以是一个精灵表，就像本节示例中所示的那样。 |'
- en: '| `sizeAnnutation` | If this is set to `false`, the size of the sprite won''t
    be affected by the distance it''s removed from the camera. The default value is
    `true`. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `sizeAnnutation` | 如果设置为`false`，精灵的大小不会受到其与相机的距离影响。默认值为`true`。 |'
- en: '| `opacity` | This sets the transparency of the sprite. The default value is
    `1` (no opacity). |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `opacity` | 这设置了精灵的透明度。默认值为`1`（不透明）。 |'
- en: '| `blending` | This defines the blend mode to be used when rendering the sprite.
    See [Chapter 9](ch09.html "Chapter 9. Animations and Moving the Camera"), *Animations
    and Moving the Camera*, for more information on blend modes. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `blending` | 这定义了在渲染精灵时要使用的混合模式。有关混合模式的更多信息，请参见[第9章](ch09.html "第9章。动画和移动相机")*动画和移动相机*。
    |'
- en: '| `fog` | This determines whether the sprite is affected by fog added to the
    scene. This defaults to `true`. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `fog` | 这确定精灵是否受到添加到场景中的雾的影响。默认为`true`。 |'
- en: You can also set the `depthTest` and `depthWrite` properties on this material.
    For more information on these properties, see [Chapter 4](ch04.html "Chapter 4. Working
    with Three.js Materials"), *Working with Three.js Materials*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在此材质上设置`depthTest`和`depthWrite`属性。有关这些属性的更多信息，请参见[第4章](ch04.html "第4章。使用Three.js材质")*使用Three.js材质*。
- en: 'We can, of course, also use a sprite map when positioning `THREE.Sprites` in
    3D (as we did at the beginning of this chapter). An example (`09-sprites-3D.html`)
    of this is shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在3D中定位`THREE.Sprites`时，我们也可以使用精灵地图（就像本章开头所做的那样）。以下是一个示例（`09-sprites-3D.html`）的屏幕截图：
- en: '![Working with sprite maps](graphics/2215OS_07_11.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![使用精灵地图](graphics/2215OS_07_11.jpg)'
- en: 'With the properties we saw in the previous table, we can very easily create
    the effect we see in the preceding screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前表中的属性，我们可以很容易地创建前面屏幕截图中看到的效果：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this example, we create 400 sprites based on the sprite sheet we showed
    earlier. You''ll probably know and understand most of the properties and concepts
    shown here. As we''ve added the separate sprites to a group, rotating them is
    very easy and can be done like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们基于我们之前展示的精灵表创建了400个精灵。您可能已经了解并理解了这里显示的大多数属性和概念。由于我们已经将单独的精灵添加到了一个组中，因此旋转它们非常容易，可以像这样完成：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this chapter, so far we've mainly looked at creating sprites and point clouds
    from scratch. An interesting option, though, is to create `THREE.PointCloud` from
    an existing geometry.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们主要是从头开始创建精灵和点云。不过，一个有趣的选择是从现有几何体创建`THREE.PointCloud`。
- en: Creating THREE.PointCloud from an advanced geometry
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从高级几何体创建THREE.PointCloud
- en: As you remember, `THREE.PointCloud` renders each particle based on the vertices
    from the supplied geometry. This means that if we provide a complex geometry (for
    example, a torus knot or a tube), we can create `THREE.PointCloud` based on the
    vertices from that specific geometry. For this last section of this chapter, we'll
    create a torus knot, like the one we saw in the previous chapter, and render it
    as `THREE.PointCloud`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您记得的那样，`THREE.PointCloud`根据提供的几何体的顶点渲染每个粒子。这意味着，如果我们提供一个复杂的几何体（例如环结或管道），我们可以基于该特定几何体的顶点创建`THREE.PointCloud`。在本章的最后一节中，我们将创建一个环结，就像我们在上一章中看到的那样，并将其渲染为`THREE.PointCloud`。
- en: 'We''ve already explained the torus knot in the previous chapter, so we won''t
    go into much detail here. We''re using the exact code from the previous chapter,
    and we''ve added a single menu option that you can use to transform the rendered
    mesh into `THREE.PointCloud`. You can find the example (`10-create-particle-system-from-model.html`)
    in the sources for this chapter. The following screenshot shows the example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在上一章中解释了环结，所以在这里我们不会详细介绍。我们使用了上一章的确切代码，并添加了一个单一的菜单选项，您可以使用它将渲染的网格转换为`THREE.PointCloud`。您可以在本章的源代码中找到示例（`10-create-particle-system-from-model.html`）。以下截图显示了示例：
- en: '![Creating THREE.PointCloud from an advanced geometry](graphics/2215OS_07_12.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![从高级几何创建THREE.PointCloud](graphics/2215OS_07_12.jpg)'
- en: 'As you can see in the preceding screenshot, every vertex used to generate the
    torus knot is used as a particle. In this example, we''ve added a nice-looking
    material, based on a HTML canvas, to create this glowing effect. We''ll only look
    at the code to the create the material and the particle system as we''ve already
    discussed the other properties in this chapter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，您可以看到用于生成环结的每个顶点都被用作粒子。在这个例子中，我们添加了一个漂亮的材质，基于HTML画布，以创建这种发光效果。我们只会看一下创建材质和粒子系统的代码，因为在本章中我们已经讨论了其他属性：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this code fragment, you can see two functions: `createPointCloud()` and
    `generateSprite()`. In the first function, we create a simple `THREE.PointCloud`
    object directly from the geometry provided (in this example, a torus knot) and
    set the texture (the `map` property) to a glowing dot (generated on an HTML5 canvas
    element) with the `generateSprite()` function, which looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，您可以看到两个函数：`createPointCloud()`和`generateSprite()`。在第一个函数中，我们直接从提供的几何体（在本例中是一个环结）创建了一个简单的`THREE.PointCloud`对象，并使用`generateSprite()`函数设置了纹理（`map`属性）为一个发光的点（在HTML5画布元素上生成）。`generateSprite()`函数如下：
- en: '![Creating THREE.PointCloud from an advanced geometry](graphics/2215OS_07_13.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![从高级几何创建THREE.PointCloud](graphics/2215OS_07_13.jpg)'
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: That's a wrap for this chapter. We've explained what particles, sprites, and
    particle systems are and how you can style these objects with the available materials.
    In this chapter, you saw how you can use `THREE.Sprite` directly with `THREE.CanvasRenderer`
    and `THREE.WebGLRenderer`. If you want to create a large number of particles,
    however, you should use `THREE.PointCloud`. With `THREE.PointCloud`, all the particles
    share the same material, and the only property you can change for an individual
    particle is their color by setting the `vertexColors` property of the material
    to `THREE.VertexColors` and providing a color value in the `colors` array of `THREE.Geometry`
    used to create `THREE.PointCloud`. We also showed how you can easily animate particles
    by changing their position. This works the same for an individual `THREE.Sprite`
    instance and the vertices from the geometry used to create `THREE.PointCloud`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章就到这里了。我们解释了粒子、精灵和粒子系统是什么，以及如何使用可用的材质来设计这些对象。在本章中，您看到了如何直接在`THREE.CanvasRenderer`和`THREE.WebGLRenderer`中使用`THREE.Sprite`。然而，如果您想创建大量的粒子，您应该使用`THREE.PointCloud`。使用`THREE.PointCloud`，所有粒子共享相同的材质，您可以通过将材质的`vertexColors`属性设置为`THREE.VertexColors`，并在用于创建`THREE.PointCloud`的`THREE.Geometry`的`colors`数组中提供颜色值来更改单个粒子的颜色。我们还展示了如何通过改变它们的位置轻松地对粒子进行动画。这对于单个`THREE.Sprite`实例和用于创建`THREE.PointCloud`的几何体的顶点是一样的。
- en: So far, we have created meshes based on geometries provided by Three.js. This
    works great for simple models such as spheres and cubes but isn't the best approach
    when you want to create complex 3D models. For those models, you'd usually use
    a 3D modeling application such as Blender or 3D Studio Max. In the next chapter,
    you'll learn how you can load and display models created by such 3D modeling applications.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经根据Three.js提供的几何创建了网格。这对于简单的模型如球体和立方体非常有效，但当您想要创建复杂的3D模型时，并不是最佳方法。对于这些模型，通常会使用3D建模应用程序，如Blender或3D
    Studio Max。在下一章中，您将学习如何加载和显示这些3D建模应用程序创建的模型。
