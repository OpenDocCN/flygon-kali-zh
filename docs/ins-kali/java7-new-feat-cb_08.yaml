- en: Chapter 8. Handling Events
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。处理事件
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Managing extra mouse buttons and high resolution mouse wheels
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理额外的鼠标按钮和高分辨率鼠标滚轮
- en: Controlling focus when displaying a window
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在显示窗口时控制焦点
- en: Using secondary loops to mimic modal dialog boxes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用辅助循环模拟模态对话框
- en: Handling spurious thread wakeups
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理虚假线程唤醒
- en: Handling applet initialization status with event handlers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件处理程序处理小程序初始化状态
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: There have been several additions to Java 7 that address events or are related
    to events. This includes the handling of mouse events where enhanced support is
    provided for the detection of mouse buttons and for using high resolution mouse
    wheels, as we will see in the *Managing extra mouse buttons and high resolution
    mouse wheels* recipe.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7还增加了几个与事件相关的事件或与事件相关的事件。这包括对鼠标事件的处理，其中提供了增强的支持来检测鼠标按钮和使用高分辨率鼠标滚轮，正如我们将在*管理额外的鼠标按钮和高分辨率鼠标滚轮*示例中看到的。
- en: When a window is made visible with either the `setVisible` or `toFront` methods,
    we now have the ability to control whether they should gain focus or not. Some
    windows may be displayed for informational or status purposes and do not necessarily
    need or warrant focus. How to control this behavior is explained in the *Controlling
    AutoRequestFocus* recipe.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`setVisible`或`toFront`方法使窗口可见时，现在我们可以控制它们是否应该获得焦点。有些窗口可能是为了信息或状态而显示的，并不一定需要或有权获得焦点。如何控制这种行为在*控制AutoRequestFocus*示例中有解释。
- en: The reader should be familiar with the behavior of modal dialog boxes. Essentially,
    the modal dialog box will not return focus to the main window until it is closed.
    There are times when it is desirable to mimic this behavior without using a dialog
    box. For example, the selection of a button that performs a relatively long running
    calculation may benefit from this behavior. The *Using secondary loops to mimic
    modal dialog boxes* recipe examines how this can be done.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应该熟悉模态对话框的行为。基本上，模态对话框在关闭之前不会将焦点返回到主窗口。有时候，希望模仿这种行为而不使用对话框。例如，执行相对较长的计算的按钮的选择可能会受益于这种行为。*使用辅助循环模拟模态对话框*示例探讨了如何实现这一点。
- en: While not common, spurious interrupts can occur when using the `wait` method.
    The `java.awt.event.InvocationEvent` class' `isDispatched` method can be used
    to handle spurious interrupts as detailed in the *Handling spurious thread wakeups*
    recipe.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不常见，但在使用`wait`方法时可能会发生虚假中断。`java.awt.event.InvocationEvent`类的`isDispatched`方法可用于处理虚假中断，详细信息请参阅*处理虚假线程唤醒*示例。
- en: Applets have also been enhanced with regards to their ability to communicate
    with JavaScript code. The *Handling Applet initialization status with event handlers*
    recipe describes how JavaScript code can be made aware of and take advantage of
    knowing when an applet loads.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 小程序在与JavaScript代码通信方面也得到了增强。*使用事件处理程序处理小程序初始化状态*示例描述了JavaScript代码如何能够意识到并利用小程序加载的时间。
- en: Other minor event-related improvements in Java 7 that don't warrant recipes
    include the availability of accessing extended key codes and the implementation
    of the `java.awt.iamg.ImageObserver` interface for the `JSlider` class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7中还有一些与事件相关的小改进，不值得列入示例的包括访问扩展键代码和为`JSlider`类实现`java.awt.iamg.ImageObserver`接口的可用性。
- en: 'The `KeyEvent` class has been augmented with two new methods: `getExtendedKeyCode`
    and `getExtendedKeyCodeForChar`. The first method returns a unique integer for
    a key, but unlike the `getKeyCode` method, its value depends on how the keyboard
    is currently configured. The second method returns the extended key code for a
    given Unicode character.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyEvent`类已增加了两个新方法：`getExtendedKeyCode`和`getExtendedKeyCodeForChar`。第一个方法返回一个键的唯一整数，但与`getKeyCode`方法不同，它的值取决于键盘当前的配置。第二个方法返回给定Unicode字符的扩展键代码。'
- en: The `imageUpdate` method has been added to the `JSlider` class. This permits
    the class to monitor the status of an image being loaded, though this capability
    is probably best used with classes that are derived from `JSlider`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`imageUpdate`方法已添加到`JSlider`类中。这允许该类监视正在加载的图像的状态，尽管这种能力可能最好与从`JSlider`派生的类一起使用。'
- en: Managing extra mouse buttons and high resolution mouse wheels
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理额外的鼠标按钮和高分辨率鼠标滚轮
- en: Java 7 has provided more options for handling mouse events. The `java.awt.Toolkit`
    class' `areExtraMouseButtonsEnabled` method allows you to determine whether more
    than the standard set of buttons is supported by the system. The `java.awt.event.MouseWheelEvent`
    class' `getPreciseWheelRotation` method can be used to control action on high
    resolution mouse wheels. In this recipe we will write a simple application to
    determine the number of mouse buttons enabled and test the mouse wheel rotation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7提供了更多处理鼠标事件的选项。`java.awt.Toolkit`类的`areExtraMouseButtonsEnabled`方法允许您确定系统是否支持标准按钮集之外的更多按钮。`java.awt.event.MouseWheelEvent`类的`getPreciseWheelRotation`方法可用于控制高分辨率鼠标滚轮的操作。在这个示例中，我们将编写一个简单的应用程序来确定启用的鼠标按钮数量并测试鼠标滚轮旋转。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, create a new application using the starter classes `ApplicationWindow`
    and `ApplicationDriver` found in the introduction of [Chapter 7](ch07.html "Chapter 7. Graphical
    User Interface Improvements"), *Graphical User Interface Improvements*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用[第7章](ch07.html "第7章。图形用户界面改进")*图形用户界面改进*中的入门处找到的`ApplicationWindow`和`ApplicationDriver`起始类创建一个新的应用程序。
- en: Implement the `MouseListener` and `MouseWheelListener` interfaces to capture
    mouse events.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`MouseListener`和`MouseWheelListener`接口以捕获鼠标事件。
- en: Use the `areExtraMouseButtonsEnabled` and `getPreciseWheelRotation` methods
    to determine specific information about the mouse.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`areExtraMouseButtonsEnabled`和`getPreciseWheelRotation`方法来确定鼠标的具体信息。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we will set up basic information about the `JFrame` we are creating,
    using the following code example:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将使用以下代码示例设置关于我们正在创建的`JFrame`的基本信息：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we want to gather some information about the mouse. We execute the `getNumberOfButtons`
    method to determine how many buttons are present on our mouse. Then we use the
    `areExtraMouseButtonsEnabled` method to determine how many buttons on our mouse
    are available to us. We print this information to the console as follows:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要收集有关鼠标的一些信息。我们执行`getNumberOfButtons`方法来确定鼠标上有多少个按钮。然后我们使用`areExtraMouseButtonsEnabled`方法来确定我们鼠标上有多少个按钮可供我们使用。我们将这些信息打印到控制台上，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we enable our listeners:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们启用我们的监听器：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `mousePressed` event method, simply print out the button number pressed
    using the `getButton` method as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mousePressed`事件方法中，只需使用`getButton`方法打印出按下的按钮编号，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Implement the remainder of the `MouseListener` interface methods. In the `mouseWheelMoved`
    event method, use both the `getPreciseWheelRotation` and the `getWheelRotation`
    methods to print out specific information about the movement of the mouse wheel:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`MouseListener`接口方法的其余部分。在`mouseWheelMoved`事件方法中，使用`getPreciseWheelRotation`和`getWheelRotation`方法打印有关鼠标滚轮移动的具体信息：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Execute the application. You should see a `JFrame` window similar to the following:![How
    to do it...](img/5627_08_01.jpg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您应该看到一个类似以下的`JFrame`窗口：![操作步骤...](img/5627_08_01.jpg)
- en: 'When you click in the window, you will see varying output in your console depending
    upon your mouse, which button you click, and in which direction you move your
    mouse wheel. Here is one possible output:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您在窗口中单击时，您将在控制台中看到不同的输出，具体取决于您的鼠标、您单击的按钮以及您移动鼠标滚轮的方向。以下是可能的输出之一：
- en: '**true**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 'true'
- en: '**You have 5 total buttons**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您总共有5个按钮
- en: '**1**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '1'
- en: '**2**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: '**3**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '3'
- en: '**4**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '4'
- en: '**5**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '5'
- en: '**0.75 - 0**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 0.75 - 0
- en: '**1.0 - 1**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0 - 1
- en: '**1.0 - 1**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0 - 1
- en: '**1.1166666666666667 - 1**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1166666666666667 - 1
- en: '**-1.0 - 0**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: -1.0 - 0
- en: '**-1.0 - -1**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: -1.0 - -1
- en: '**-1.2916666666666667 - -1**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: -1.2916666666666667 - -1
- en: '**-1.225 - -1**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: -1.225 - -1
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `getNumberOfButtons` method returned the total number of buttons on our
    mouse. In the previous example, there were five buttons, but if the application
    was executed on a system with no mouse, it would have returned a `-1`. In our
    `mousePressed` method, we printed the name of the button clicked, as returned
    by the `getButton` method.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`getNumberOfButtons`方法返回了鼠标上的按钮总数。在先前的示例中，有五个按钮，但如果在没有鼠标的系统上执行该应用程序，它将返回`-1`。在我们的`mousePressed`方法中，我们打印了由`getButton`方法返回的点击的按钮的名称。'
- en: We executed the `areExtraMouseButtonsEnabled` method to determine that extra
    buttons are, in fact, supported and allowed to be added to an `EventQueue`. If
    you want to change the value of this, you must do so before the `Toolkit` class
    is initialized as explained in the *There's more..*. section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行了`areExtraMouseButtonsEnabled`方法来确定实际上支持额外的按钮，并且允许将它们添加到`EventQueue`中。如果要更改此值，必须在`Toolkit`类初始化之前进行，如*还有更多..*部分所述。
- en: Because multiple mouse buttons were enabled, our output displayed the number
    for all five mouse buttons. In most instances, the mouse wheel is also considered
    a button and is included in the count.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因为启用了多个鼠标按钮，我们的输出显示了所有五个鼠标按钮的编号。在大多数情况下，鼠标滚轮也被视为按钮，并包括在计数中。
- en: The last several lines of the previous console output are indications of movement
    of the mouse wheel. The first one, **0.75 - 0**, is an indication that the mouse
    wheel was moved backwards, or toward the user. This is evident by the return value
    of 0.75 from the `getPreciseWheelRotation` method and the 0 from the `getWheelRotation`
    method. The last line of output, **-1.225 - -1**, is conversely an indication
    of forward mouse wheel movement, or away from the user. This is indicated by a
    negative return value by both methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 先前控制台输出的最后几行是鼠标滚轮的移动指示。第一行，**0.75 - 0**，表示鼠标滚轮向后移动，或者向用户方向移动。这是通过`getPreciseWheelRotation`方法返回值0.75和`getWheelRotation`方法返回值0来表明的。输出的最后一行，**-1.225
    - -1**，相反表示鼠标滚轮向前移动，或者远离用户。这是通过两种方法的负返回值来表示的。
- en: This application was executed using a high resolution mouse wheel. A lower resolution
    mouse wheel will only return integer values.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高分辨率鼠标滚轮执行了此应用程序。低分辨率鼠标滚轮将只返回整数值。
- en: There's more...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are two ways of controlling whether extra mouse buttons are enabled or
    not. The first technique is to start the application with the following command
    line and set the `sun.awt.enableExtraMouseButtons` property to either `true` or
    `false:`
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种控制是否启用额外鼠标按钮的方法。第一种技术是使用以下命令行启动应用程序，并将`sun.awt.enableExtraMouseButtons`属性设置为`true`或`false`：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `D` option used a `false` value specifying that the extra mouse buttons
    were not to be enabled. The second approach is to set the same property before
    the `Toolkit` class is initialized. This can be accomplished with the following
    code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 选项`D`使用了一个`false`值，指定不启用额外的鼠标按钮。第二种方法是在`Toolkit`类初始化之前设置相同的属性。可以使用以下代码实现：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Controlling a focus when displaying a window
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在显示窗口时控制焦点
- en: The `setAutoRequestFocus` method has been added to the `java.awt.Window` class
    and is used to specify whether a window should receive focus when it is displayed
    using either the `setVisible` or `toFront` methods. There may be times when a
    window is made visible, but we don't want the window to have focus. For example,
    if the window being displayed contains status information, making it visible will
    be sufficient. Giving it focus may not make sense and may frustrate the user by
    forcing them to change focus back to the original window.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`setAutoRequestFocus`方法已添加到`java.awt.Window`类中，用于指定窗口在使用`setVisible`或`toFront`方法显示时是否应该接收焦点。有时候，窗口被显示出来，但我们不希望窗口获得焦点。例如，如果显示的窗口包含状态信息，使其可见就足够了。让它获得焦点可能没有意义，并且可能会让用户感到沮丧，因为他们被迫将焦点切换回原始窗口。'
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: To control the focus when a window is made visible, we will invoke the `setAutoRequestFocus`
    method with `true` if it should receive focus and a `false` value otherwise.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口可见时控制焦点，如果应该接收焦点则调用`setAutoRequestFocus`方法并传入`true`，否则传入`false`。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To demonstrate this technique we will create two windows. One will be used to
    hide and then display a second window. By using the `setAutoRequestFocus` method
    in the second window, we can control whether it receives focus or not.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示这种技术，我们将创建两个窗口。一个用于隐藏然后显示第二个窗口。通过在第二个窗口中使用`setAutoRequestFocus`方法，我们可以控制它是否接收焦点。
- en: 'Start by creating a new project with the following driver. In the driver, we
    will create the first window as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下驱动程序创建一个新项目。在驱动程序中，我们将创建第一个窗口如下：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, add the `ApplicationWindow` class. In this class, we add two buttons
    to hide and reveal the second window and a third one to exit the application as
    follows:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加`ApplicationWindow`类。在这个类中，我们添加了两个按钮来隐藏和显示第二个窗口，以及一个用于退出应用程序的第三个按钮，如下所示：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the `SecondWindow` class next. This simple window does nothing but use
    the `setAutoRequestFocus` method to control how it behaves:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来添加`SecondWindow`类。这个简单的窗口除了使用`setAutoRequestFocus`方法来控制其行为外，什么也不做：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Execute the application. Both windows should appear with the focus on the first
    window, as shown in the following screenshot:![How to do it...](img/5627_08_02.jpg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。两个窗口应该都出现，并且焦点在第一个窗口上，如下截图所示：![如何做...](img/5627_08_02.jpg)
- en: The second window appears as follows:![How to do it...](img/5627_08_03.jpg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个窗口显示如下：![如何做...](img/5627_08_03.jpg)
- en: Select the **Hide** button. The second window should disappear. Next, select
    the **Reveal** button. The second window should reappear and should not have focus.
    This is the effect of the `setAutoRequestFocus` method, when used with a value
    of `false`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**隐藏**按钮。第二个窗口应该消失。接下来，选择**显示**按钮。第二个窗口应该重新出现，并且不应该有焦点。这是`setAutoRequestFocus`方法与`false`值一起使用时的效果。
- en: Stop the application and change the argument of the `setAutoRequestFocus` method
    to `true`. Re-execute the application and hide and then reveal the second window.
    When it is revealed, the second window should receive focus.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止应用程序并将`setAutoRequestFocus`方法的参数更改为`true`。重新执行应用程序，隐藏然后显示第二个窗口。当它显示时，第二个窗口应该接收焦点。
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The application driver displayed the application window. In the `ApplicationWindow`
    class, the second window was created and displayed. Also, the three buttons were
    created and inner classes were created to affect each of their operations. The
    `setAutoRequestFocus` method was passed a value of `false` to specify that focus
    was not to be retained when the window was displayed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序驱动程序显示了应用程序窗口。在`ApplicationWindow`类中，创建并显示了第二个窗口。此外，创建了三个按钮和内部类来影响它们的操作。`setAutoRequestFocus`方法传递了一个`false`值，指定在窗口显示时不保留焦点。
- en: There's more...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This approach may be useful for applications that run from the system tray.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可能对从系统托盘运行的应用程序有用。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that the `isAutoRequestFocus` method is available to determine the
    value of the `autoRequestFocus` value.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`isAutoRequestFocus`方法可用于确定`autoRequestFocus`值的值。
- en: Using secondary loops to mimic modal dialog boxes
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用次要循环模拟模态对话框
- en: The `java.awt.EventQueue` class' `SecondaryLoop` interface provides a convenient
    technique for mimicking the behavior of a modal dialog box. A modal dialog box
    has two behaviors. The first one is from the user's perspective. The user is not
    permitted to interact with the main window, until the dialog box is complete.
    The second perspective is from the program execution standpoint. The thread in
    which the dialog box is called is blocked until the dialog box is closed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.awt.EventQueue`类的`SecondaryLoop`接口提供了一种方便的技术来模拟模态对话框的行为。模态对话框有两种行为。第一种是从用户的角度来看。在对话框完成之前，用户不被允许与主窗口交互。第二个角度是从程序执行的角度来看。调用对话框的线程在对话框关闭之前被阻塞。'
- en: A `SecondaryLoop` permits the execution of some task while blocking the current
    thread, until the secondary loop is complete. It may not have a user interface
    associated with it. This can be useful when the user selects a button that, while
    it does not display a dialog box, does involve a long running calculation. In
    this recipe we will demonstrate how to use a secondary loop and examine its behavior.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`SecondaryLoop`允许在阻塞当前线程的同时执行某些任务，直到次要循环完成。它可能没有与之关联的用户界面。当用户选择一个按钮时，虽然它不显示对话框，但涉及到长时间运行的计算时，这可能会很有用。在本教程中，我们将演示如何使用次要循环并检查其行为。'
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To create and use a secondary loop, the following steps need to be followed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和使用次要循环，需要按照以下步骤进行：
- en: Get an instance of the default `java.awt.Toolkit` for the application.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取应用程序的默认`java.awt.Toolkit`实例。
- en: Use this to obtain a reference to the system event queue.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此方法获取系统事件队列的引用。
- en: Create a `SecondaryLoop` object using the event queue.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用事件队列创建一个`SecondaryLoop`对象。
- en: Use the `SecondaryLoop` interface's `enter` method to start the loop.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SecondaryLoop`接口的`enter`方法来启动循环。
- en: Implement the desired behavior in the secondary loop.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在次要循环中实现所需的行为。
- en: Use the `SecondaryLoop` interface's `exit` method to terminate the loop.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SecondaryLoop`接口的`exit`方法来终止循环。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new application with the following `ApplicationDriver` class. It simply
    displays the application''s window as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`ApplicationDriver`类创建一个新的应用程序。它简单地显示应用程序的窗口如下：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following `ApplicationWindow` class. It creates two buttons, which
    will be used to demonstrate the behavior of secondary loops:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`ApplicationWindow`类。它创建了两个按钮，用于演示次要循环的行为：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, add the following `actionPerformed` method. A `SecondaryLoop` object
    is created and, depending on the button selected, `WorkerThread` objects are created
    as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下的`actionPerformed`方法。创建一个`SecondaryLoop`对象，并根据所选的按钮创建`WorkerThread`对象如下：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following `WorkerThread` class as an inner class. Its constructor saves
    the `SecondaryLoop` object and a message is passed to it. The message will be
    used to help us interpret the results. The `run` method displays the messages
    before and after it sleeps for two seconds:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下的`WorkerThread`类作为内部类。它的构造函数保存了`SecondaryLoop`对象，并传递了一条消息。这条消息将被用来帮助我们解释结果。`run`方法在睡眠两秒之前显示消息：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Execute the application. The following window should appear. It has been resized
    here:![How to do it...](img/5627_08_04.jpg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。应该会出现以下窗口。这里已经调整了大小：![操作步骤...](img/5627_08_04.jpg)
- en: 'Next, select the **First** button. The following console output should illustrate
    the execution of the secondary loop. The number following **First-** will probably
    differ from your output:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，选择**First**按钮。以下控制台输出应该说明了次级循环的执行。跟在**First-**后面的数字可能与您的输出不同：
- en: '**First-433 Loop Sleeping ...**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**First-433 Loop Sleeping ...**'
- en: '**First-433 Secondary loop completed with a result of true**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**First-433 Secondary loop completed with a result of true**'
- en: '**First-433 Secondary loop returned**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**First-433 Secondary loop returned**'
- en: 'While a secondary loop blocks the current thread, it does not prevent the window
    from continuing to execute. The window''s UI thread is still active. To demonstrate
    this, restart the application and select the **First** button. Before two seconds
    have elapsed, select the **Second** button. The console output should be similar
    to the following:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然次级循环阻塞了当前线程，但并不妨碍窗口继续执行。窗口的UI线程仍然活动。为了证明这一点，重新启动应用程序并选择**First**按钮。在两秒内未过去之前，选择**Second**按钮。控制台输出应该类似于以下内容：
- en: '**First-360 Loop Sleeping ...**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**First-360 Loop Sleeping ...**'
- en: '**Second-416 Loop Sleeping ...**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**Second-416 Loop Sleeping ...**'
- en: '**First-360 Secondary loop completed with a result of true**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**First-360 Secondary loop completed with a result of true**'
- en: '**Second-416 Secondary loop completed with a result of true**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**Second-416 Secondary loop completed with a result of true**'
- en: '**Second-416 Secondary loop returned**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**Second-416 Secondary loop returned**'
- en: '**First-360 Secondary loop returned**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**First-360 Secondary loop returned**'
- en: This illustrates two aspects of secondary loops. The first is that the application
    can still interact with the user, and the second is the behavior of two secondary
    loops executing at the same time. Specifically, if a second secondary loop is
    started before the first one is complete, the first one will not resume until
    the nested (second) one is terminated.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了次级循环的两个方面。第一是应用程序仍然可以与用户交互，第二是同时执行两个次级循环的行为。具体来说，如果在第一个次级循环完成之前启动第二个次级循环，第一个次级循环将不会恢复，直到嵌套的（第二个）循环终止。
- en: Notice that the application still responds to user input. Also, notice that
    the **Second-416** loop started execution after the **First-360**. However, while
    the **First-360** completed before the **Second-416**, as you would expect, the
    **First-360** loop did not return and resume the execution of the blocked thread,
    until after the **Second-416** loop returned. We will witness the same behavior
    if the **First** button is selected twice within two seconds.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，应用程序仍然响应用户输入。另外，请注意**Second-416**循环在**First-360**之后开始执行。然而，虽然**First-360**在**Second-416**之前完成，正如你所期望的那样，**First-360**循环直到**Second-416**循环返回后才返回并恢复被阻塞的线程的执行。如果在两秒内两次选择**First**按钮，将会看到相同的行为。
- en: How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In the `ApplicationWindow`, we created two buttons. The buttons were added to
    the application and then associated with the application's implementation of the
    `ActionListener` interface. We used the **First** button to illustrate the execution
    of a secondary loop.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ApplicationWindow`中，我们创建了两个按钮。这些按钮被添加到应用程序中，并与应用程序对`ActionListener`接口的实现相关联。我们使用**First**按钮来说明执行次级循环。
- en: In the `actionPerformed` method, we used the `Toolkit` class' `getSystemEventQueue`
    method to get an instance of the `EventQueue`. This queue was then used with the
    `createSecondaryLoop` method to create a secondary loop.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在`actionPerformed`方法中，我们使用`Toolkit`类的`getSystemEventQueue`方法来获取`EventQueue`的实例。然后使用`createSecondaryLoop`方法创建了一个次级循环。
- en: In order to keep track of potential multiple secondary loops, we created an
    instance of the `Calendar` class and created a unique name derived from either
    **First-** or **Second-** suffixed with the current time in milliseconds. While
    this technique would not guarantee unique names, it is unlikely that two loops
    will have the same name and this is sufficient for our example.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪潜在的多个次级循环，我们创建了`Calendar`类的一个实例，并根据当前毫秒数派生了一个以**First-**或**Second-**为后缀的唯一名称。虽然这种技术不能保证唯一的名称，但是两个循环具有相同的名称是不太可能的，这对我们的示例来说已经足够了。
- en: Depending on which button was pressed, an instance of `WorkerThread` was created
    using `secondaryLoop` object and a unique name. The worker thread was then started
    and the `enter` method was executed against `secondaryLoop`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 根据按下的按钮，使用`secondaryLoop`对象和一个唯一的名称创建了`WorkerThread`的实例。然后启动了工作线程，并对`secondaryLoop`执行了`enter`方法。
- en: At this point, the secondary loop will execute and the current thread will be
    blocked. In the `WorkerThread` class, a message was displayed indicating which
    secondary loop was executed. It was then suspended for two seconds followed by
    a second message indicating that the secondary loop completed along with the `exit`
    method return value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，次级循环将执行，当前线程将被阻塞。在`WorkerThread`类中，显示了执行了哪个次级循环的消息。然后暂停两秒，随后显示了次级循环完成以及`exit`方法的返回值。
- en: The `actionPerformed` method's thread was then unblocked and a last message
    was displayed indicating that the secondary loop completed Notice that this thread
    blocked until the secondary loop completed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`actionPerformed`方法的线程被解除阻塞，并显示了一条最后的消息，指示次级循环已完成。请注意，此线程在次级循环完成之前被阻塞。
- en: This mimicked the behavior of a modal dialog box from the application's perspective.
    The thread where the secondary loop was created is blocked until the loop is completed.
    While other threading approaches could have been used to achieve a similar result,
    this approach is convenient and easy to use.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这模仿了从应用程序角度看模态对话框的行为。创建次级循环的线程将被阻塞，直到循环完成。虽然其他线程方法也可以用来实现类似的结果，但这种方法方便且易于使用。
- en: There's more...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is not possible to use the same `SecondaryLoop` object to start a new loop
    if one is already active. Any attempt to do so will result in the `enter` method
    returning a value of `false`. However, once the loop has completed, the loop can
    be reused for other loops. This means the `enter` method can subsequently be executed
    against the same `SecondaryLoop` object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个`SecondaryLoop`对象已经处于活动状态，则不可能使用相同的`SecondaryLoop`对象启动一个新的循环。任何尝试这样做都将导致`enter`方法返回`false`。然而，一旦循环完成，循环可以被重用于其他循环。这意味着`enter`方法随后可以针对相同的`SecondaryLoop`对象执行。
- en: See also
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Using the new JLayer Decorator for a password field* recipe in [Chapter
    7](ch07.html "Chapter 7. Graphical User Interface Improvements"), *Graphical User
    Interface Improvements*. This recipe can be useful if you need to create a timer-hour
    hourglass type animation that could be displayed over the button indicating a
    long running process.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章. 图形用户界面改进")中查看*使用新的JLayer装饰器为密码字段*的示例，*图形用户界面改进*。如果需要创建一个可以显示在指示长时间运行进程的按钮上的计时器-沙漏类型动画，这个示例可能会有用。
- en: Handling spurious thread wakeups
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理虚假线程唤醒
- en: When multiple threads are used, one thread may need to wait until the completion
    of one or more other threads. When this is necessary, one approach is to use the
    `Object` class' `wait` method to wait for the other threads to complete. These
    other threads need to use either the `Object` class' `notify` or `notifyAll` methods
    to permit the thread that is waiting to continue.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多个线程时，一个线程可能需要等待一个或多个其他线程完成。在这种情况下，一种方法是使用`Object`类的`wait`方法等待其他线程完成。这些其他线程需要使用`Object`类的`notify`或`notifyAll`方法来允许等待的线程继续。
- en: However, spurious wakeup calls can occur in some situations. In Java 7, the
    `java.awt.event.InvocationEvent` class' `isDispatched` method has been introduced
    to address this problem.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下可能会发生虚假唤醒。在Java 7中，引入了`java.awt.event.InvocationEvent`类的`isDispatched`方法来解决这个问题。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To avoid spurious wakeup calls:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 避免虚假唤醒：
- en: Add a synchronized block.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个同步块。
- en: Create a `while` loop based on the results of an application-specific condition
    and the `isDispatched` method.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据特定于应用程序的条件和`isDispatched`方法创建一个`while`循环。
- en: Use the `wait` method in the body of the loop.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环体中使用`wait`方法。
- en: How to do it...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Due to the nature of spurious interrupts, it is not feasible to create a demonstration
    application that will consistently demonstrate this behavior. The recommended
    way of handling a `wait` is illustrated as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于虚假中断的性质，不可能创建一个能够始终展示这种行为的演示应用程序。处理`wait`的推荐方法如下所示：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This approach will eliminate spurious interrupts.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这种方法将消除虚假中断。
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we used a synchronized block for the object we are working with. Next,
    we obtain an instance of the `EventQueue`. The `while` loop will test an application-specific
    condition to determine if it should be in a `wait` state. This could be simply
    a Boolean variable indicating that a queue is ready to be processed. The loop
    will continue executing while the condition is `true` and the `isDispatched` method
    returns `false`. This means if the method returns `true`, then the event was actually
    dispatched from the event queue. This will also occur with the `EventQueue.invokeAndWait`
    method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为我们正在处理的对象使用了一个同步块。接下来，我们获取了`EventQueue`的一个实例。`while`循环将测试一个特定于应用程序的条件，以确定是否应处于`wait`状态。这可能只是一个布尔变量，指示队列已准备好被处理。循环将在条件为`true`且`isDispatched`方法返回`false`时继续执行。这意味着如果方法返回`true`，则事件实际上是从事件队列中分派出来的。这也将发生在`EventQueue.invokeAndWait`方法中。
- en: A thread may wake up from a `wait` method for no reason at all. The `notify`
    or `notifyAll` methods may not have been called. This can occur due to conditions
    external to the JVM that are usually low-level and subtle.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 线程可能会无缘无故地从`wait`方法中醒来。可能没有调用`notify`或`notifyAll`方法。这可能是由于通常是低级和微妙的JVM外部条件引起的。
- en: In earlier versions of the **Java Language Specification**, this issue was not
    mentioned. However, in Java 5 the `wait` method documentation included a discussion
    of this issue. Clarification of this issue is found in the third edition of the
    Java Language Specification, **section 17.8.1 Wait**, found at [http://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.8.1](http://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.8.1).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期版本的**Java语言规范**中，没有提到这个问题。然而，在Java 5中，`wait`方法的文档中包括了对这个问题的讨论。对这个问题的澄清可以在Java语言规范的第三版中找到，**第17.8.1节等待**，位于[http://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.8.1](http://java.sun.com/docs/books/jls/third_edition/html/memory.html#17.8.1)。
- en: Handling applet initialization status with event handlers
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事件处理程序处理小程序初始化状态
- en: JavaScript code is able to call applet methods. However, this is not possible
    until the applet has been initialized. Any attempt to communicate with the applet
    will be blocked until the applet is loaded. In order to determine when the applet
    has been loaded, Java 7 has introduced a load status variable, which is accessible
    from JavaScript code. We will explore how to set up an HTML file to detect and
    respond to these events.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript代码能够调用小程序方法。但是，在小程序初始化之前是不可能的。任何尝试与小程序通信都将被阻塞，直到小程序加载完成。为了确定小程序何时已加载，Java
    7引入了一个加载状态变量，可以从JavaScript代码中访问。我们将探讨如何设置HTML文件以检测和响应这些事件。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use the loading status of an applet:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用小程序的加载状态：
- en: Create JavaScript functions to handle applet load events.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建JavaScript函数来处理applet加载事件。
- en: Deploy the applet, setting the parameter `java_status_events` to `true`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署applet，将参数`java_status_events`设置为`true`。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new application for the Java applet. In the `java.applet.Applet` class''
    `init` method, we will create a `Graphics` object to display a simple blue rectangle
    and then sleep for two seconds. This delay will simulate the loading of the applet:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Java applet创建一个新的应用程序。在`java.applet.Applet`类的`init`方法中，我们将创建一个`Graphics`对象来显示一个简单的蓝色矩形，然后延迟两秒。这个延迟将模拟applet的加载：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Package the applet in a `SampleApplet.jar` file. Next, create an HTML file
    as follows. The first part consists of declaring a title and creating the `determineAppletState`
    function to check on the load status of the applet as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将applet打包在`SampleApplet.jar`文件中。接下来，创建一个HTML文件如下。第一部分包括声明一个标题和创建`determineAppletState`函数来检查applet的加载状态如下：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Follow this with the body of the HTML file. It uses an `onload` event to call
    the `determineAppletState` function. This is followed by a header field and two
    division tags. The divisions will be used for display purposes as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML文件的body部分之后。它使用`onload`事件调用`determineAppletState`函数。然后是一个标题字段和两个分区标签。这些分区将用于显示目的如下：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Complete the HTML file with a JavaScript sequence that configures and executes
    the applet as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JavaScript序列完成HTML文件，配置和执行applet如下：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Load the applet into a browser. Here, it is loaded into Chrome as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将applet加载到浏览器中。这里，它加载到Chrome中如下：
- en: '![How to do it...](img/5627_08_05.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5627_08_05.jpg)'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `SampleApplet` possessed two methods: `init` and `paint`. The `init` method
    created a `BufferedImage` object, which it used to display a blue square whose
    size is determined by the area allocated to the applet. Initially, the load was
    delayed for two seconds using the `sleep` method to simulate a slow loading applet.
    The `paint` method simply displayed the image. When the status is loading, the
    `onLoadHandler` was specified as the function to invoke when the applet completes
    loading. When this function is executed, a message to that effect was displayed
    in the `loadeddiv` division element.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`SampleApplet`拥有两个方法：`init`和`paint`。`init`方法创建了一个`BufferedImage`对象，用于显示一个蓝色的正方形，其大小由分配给applet的区域确定。最初，使用`sleep`方法延迟加载两秒，以模拟加载缓慢的applet。`paint`方法只是显示图像。当状态为加载时，指定`onLoadHandler`作为applet加载完成时要调用的函数。执行此函数时，在`loadeddiv`分区元素中显示相应的消息。'
- en: In the body tag of the HTML file, the `determineAppletState` function was specified
    as the function to execute when the HTML was loaded into the browser. This ensured
    that the load status was checked when the HTML file was loaded.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML文件的body标签中，指定了`determineAppletState`函数作为在HTML加载到浏览器时执行的函数。这确保了在加载HTML文件时检查加载状态。
- en: The variable and attributes associated the `sampleApplet` ID with the `SampleApplet`
    class. The archive file containing the class and the size of the applet were also
    specified. In order to take advantage of this capability, the applet needed to
    be deployed with the `java_status_events` parameter set to `true`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量和属性与`SampleApplet`类相关联的`sampleApplet` ID。还指定了包含类的存档文件和applet的大小。为了利用这一功能，applet需要使用`java_status_events`参数设置为`true`进行部署。
- en: The function `determineAppletState` used the load status variable, status to
    display the status of the load process. Messages displayed in HTML division elements
    showed the sequence of operations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`determineAppletState`函数使用加载状态变量status来显示加载过程的状态。在HTML分区元素中显示的消息显示了操作的顺序。'
- en: The `deployJava.js` is part of the **Java Deployment Toolkit** and is used to
    detect the presence of a JRE, install one if necessary, and then run an applet.
    It can also be used for other **Web Start** programs. In this case, it was used
    to execute the applet using the attributes and parameters along with the version
    of JRE to use, that is Java 7.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`deployJava.js`是**Java部署工具包**的一部分，用于检测JRE的存在，如果需要则安装一个，然后运行applet。它也可以用于其他**Web
    Start**程序。在这种情况下，它被用来使用属性和参数以及要使用的JRE版本（即Java 7）来执行applet。'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information about executing Java applications deployment using `deployJava.js`
    is found at [http://download.oracle.com/javase/7/docs/technotes/guides/jweb/index.html.](http://download.oracle.com/javase/7/docs/technotes/guides/jweb/index.html.)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用`deployJava.js`执行Java应用程序部署的更多信息，请访问[http://download.oracle.com/javase/7/docs/technotes/guides/jweb/index.html.](http://download.oracle.com/javase/7/docs/technotes/guides/jweb/index.html.)
- en: 'There are three applet status values as detailed in the following table:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格详细介绍了三种applet状态值：
- en: '| Status | Value | Meaning |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 值 | 含义 |'
- en: '| --- | --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `LOADING` | *1* | The applet is loading |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `LOADING` | *1* | applet正在加载 |'
- en: '| `READY` | *2* | The applet has loaded |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `READY` | *2* | applet已加载 |'
