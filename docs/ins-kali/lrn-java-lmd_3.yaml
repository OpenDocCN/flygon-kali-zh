- en: Chapter 3. Lambdas in Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。深入了解Lambda
- en: 'In this section, we''ll take a look at things in a little more detail and talk
    about some related topics, things like:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更详细地看一些相关主题，比如：
- en: Functional interfaces
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数接口
- en: Method and constructor references
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法和构造函数引用
- en: Scope and effectively final variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围和有效的最终变量
- en: Exception transparency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常透明度
- en: The differences between lambdas and closures
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda和闭包之间的区别
- en: As we've talked about how lambdas aren't just syntactic sugar, we'll have a
    look at the bytecode lambdas produce
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们谈到的，lambda不仅仅是语法糖，我们将看一下lambda生成的字节码
- en: Functional interfaces
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数接口
- en: Java treats lambdas as an instance of an interface type. It formalizes this
    into something it calls *functional interfaces*. A functional interface is just
    an interface with a single method. Java calls the method a "functional method"
    but the name "single abstract method" or SAM is often used.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Java将lambda视为接口类型的实例。它将这个形式化为它所谓的*函数接口*。函数接口只是一个具有单一方法的接口。Java将这个方法称为"函数方法"，但通常使用"单一抽象方法"或SAM。
- en: All the existing single method interfaces like `Runnable` and `Callable` in
    the JDK are now functional interfaces and lambdas can be used anywhere a single
    abstract method interface is used. In fact, it's functional interfaces that allow
    for what's called *target typing*; they provide enough information for the compiler
    to infer argument and return types.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JDK中所有现有的单一方法接口，如`Runnable`和`Callable`，现在都是函数接口，lambda可以在任何使用单一抽象方法接口的地方使用。事实上，正是函数接口允许了所谓的*目标类型*；它们提供了足够的信息，以便编译器推断参数和返回类型。
- en: '@FunctionalInterface'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '@FunctionalInterface'
- en: Oracle have introduced a new annotation `@FunctionalInterface` to mark an interface
    as such. It's basically to communicate intent but also allows the compiler to
    do some additional checks.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle引入了一个新的注解`@FunctionalInterface`来标记一个接口。这基本上是为了传达意图，但也允许编译器进行一些额外的检查。
- en: 'For example, this interface compiles:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个接口可以编译通过：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: but when you indicate that it should be a *functional interface* by adding the
    new annotation,
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但当你通过添加新的注解来指示它应该是一个*函数接口*时，
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: the compiler will raise an error. It tells us "Example is not a functional interface"
    as "no abstract method was found". Often the IDE will also hint, [IntelliJ](http://www.jetbrains.com/idea/)
    will say something like "no target method was found". It's hinting that we left
    off the functional method. A "single abstract method" needs a single, `abstract`
    method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会报错。它告诉我们"Example不是一个函数接口"，因为"没有找到抽象方法"。通常IDE也会提示，[IntelliJ](http://www.jetbrains.com/idea/)会说类似"没有找到目标方法"。它在暗示我们忘了函数方法。"单一抽象方法"需要一个`abstract`方法。
- en: So what if we try and add a second method to the interface?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如果我们尝试向接口添加第二个方法会怎样呢？
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The compiler will error again, this time with a message along the lines of "multiple,
    non-overriding abstract methods were found". Functional interfaces can have only
    **one** method.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器会再次报错，这次的错误信息是"找到多个非覆盖的抽象方法"。函数接口只能有**一个**方法。
- en: Extension
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展
- en: What about the case of an interfaces that extends another interface?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么接口扩展另一个接口的情况呢？
- en: 'Let''s create a new functional interface called `A` and another called `B`
    which extends `A`. The  `B` interface is still a functional interface. It inherits
    the parents `apply` method as you''d expect:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`A`的新函数接口，另一个名为`B`的函数接口，它扩展了`A`。`B`接口仍然是一个函数接口。它继承了父类的`apply`方法，正如你所期望的那样：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you wanted to make this clearer, you can also override the functional method
    from the parent:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更清晰地表达这一点，你也可以覆盖父类的函数方法：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can verify it works as a functional interface if we use it as a lambda. We'll
    implement a method to show that a lambda can be assigned to a type of A and a
    type of B below. The implementation just prints out `"A"` or `"B"`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将它作为lambda使用，我们可以验证它作为函数接口是否有效。我们将实现一个方法来展示lambda可以分配给类型A和类型B。实现只是打印出`"A"`或`"B"`。
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can't add a new `abstract` method to the extending interface (B) though,
    as the resulting type would have two `abstract` methods and the IDE would warn
    us and the compiler would error.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能向扩展接口（B）添加新的`abstract`方法，因为结果类型会有两个`abstract`方法，IDE会警告我们，编译器会报错。
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In both cases, you can override methods from `Object` without causing problems.
    You can also add default methods (also new from Java 8 onward). As you'd probably
    expect, it doesn't make sense to try and mark an abstract class as a functional
    interface.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你可以覆盖`Object`中的方法而不会引起问题。你也可以添加默认方法（从Java 8开始的新功能）。正如你可能期望的那样，将抽象类标记为函数接口是没有意义的。
- en: Other interface improvements
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他接口改进
- en: 'Interfaces generally have had some new features added, they include:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接口通常有一些新的特性，它们包括：
- en: Default methods (virtual extension methods)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认方法（虚拟扩展方法）
- en: Static interface methods
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态接口方法
- en: And a bunch of new functional interfaces in the `java.util.function` package;
    things like `Function` and `Predicate`
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及`java.util.function`包中一堆新的函数接口；像`Function`和`Predicate`这样的东西
- en: Summary
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this section we've talked about how any interface with a single method is
    now a "functional interface" and that the single method is often called a "functional
    method" or SAM (for single abstract method).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们谈到了任何具有单一方法的接口现在都是"函数接口"，而且这个单一方法通常被称为"函数方法"或SAM（单一抽象方法）。
- en: We looked at the new annotation and saw a couple of examples of how existing
    JDK interfaces like `Runnable` and `Callable` have been retrofitted with the annotation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了一下新的注解，并看了一些现有JDK接口如`Runnable`和`Callable`是如何使用这个注解进行改造的。
- en: We also introduced the idea of *target typing* which is how the compiler can
    use the signature of a functional method to help work out what lambdas can be
    used where. We skimmed over this a little as we're going to talk about it later
    in the type inference section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了*目标类型*的概念，即编译器如何使用函数方法的签名来帮助确定可以在哪里使用lambda表达式。我们稍微提了一下这个概念，因为我们将在类型推断部分稍后讨论它。
- en: We discussed some examples of functional interfaces, how the compiler and IDE
    can help us out when we make mistakes and got a feel for the kinds of errors we
    might encounter. Things like adding more than one method to a functional interface.
    We also saw the exceptions to this rule, namely when we override methods from
    `Object` or implement default methods.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了一些函数接口的示例，编译器和IDE在我们犯错时如何帮助我们，并对我们可能遇到的错误有了一些了解。例如，向函数接口添加多个方法。我们还看到了这个规则的例外情况，即当我们重写`Object`的方法或实现默认方法时。
- en: We had a quick look at interface inheritance and how that affects things and
    mentioned some of the other interface improvements that we'll be covering later.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快速查看了接口继承以及它对事物的影响，并提到了我们稍后将要涵盖的其他接口改进。
- en: An important point to take away here is the idea that any place a functional
    interface is used, you can now use a lambda. Lambdas can be used in-lieu of anonymous
    implementations of the functional interface. Using a lambda instead of the anonymous
    class may seem like syntactic sugar, but they're actually quiet different. See
    the *Functions vs. classes* section for more details.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要记住的一个重要观点是，任何地方都可以使用函数接口，现在都可以使用lambda。Lambda可以用来代替函数接口的匿名实现。使用lambda而不是匿名类可能看起来像语法糖，但它们实际上是有很大不同的。有关更多详细信息，请参阅*函数
    vs. 类*部分。
- en: Type inference improvements
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断改进
- en: There have been several type inference improvements in modern Java. To be able
    to support lambdas, the way the compiler infers things has been improved to use
    *target typing* extensively. This and other improvements over Java 7's inference
    were managed under the Open **JDK Enhancement Proposal** (**JEP**) 101.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Java中有几个类型推断改进。为了支持lambda，编译器推断的方式已经得到改进，广泛使用*目标类型*。这些改进和Java 7的推断改进都是在开放**JDK增强提案**（**JEP**）101下进行管理的。
- en: Before we get into those, lets recap on the basics.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论这些之前，让我们回顾一下基础知识。
- en: Type inference refers to the ability for a programming language to automatically
    deduce the type of an expression.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断是指编程语言自动推断表达式类型的能力。
- en: Statically typed languages know the types of things at *compile* time. Dynamically
    typed languages know the types at *runtime*. A statically typed language can use
    type inference and drop type information in source code and use the compiler to
    figure out what's missing.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型语言在*编译*时知道事物的类型。动态类型语言在*运行时*知道类型。静态类型语言可以使用类型推断，在源代码中删除类型信息，并使用编译器来找出缺失的部分。
- en: '![Type inference improvements](img/static_vs_dynamic.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: 类型推断改进
- en: So this means that type inference can be used by statically typed languages
    (like Scala) to "look" like dynamic languages (like JavaScript). At least at the
    source code level.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着静态类型语言（如Scala）可以使用类型推断来“看起来”像动态语言（如JavaScript）。至少在源代码级别上是这样。
- en: 'Here''s an example of a line of code in Scala:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Scala中的一行代码示例：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You don't need to tell the compiler explicitly that the value is a string. It
    figures it out. You could write it out explicitly like this,
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要明确告诉编译器该值是一个字符串。它会自己推断出来。你可以像这样明确地写出来，
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: but there's no need.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但没有必要。
- en: As an aside, Scala also tries to figure out when you've finished a statement
    or expression based on it's **abstract syntax tree** (**AST**). So often, you
    don't even need to add a terminating semi-colon.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，Scala还尝试根据其**抽象语法树**（**AST**）来确定何时完成语句或表达式。因此，通常情况下，你甚至不需要添加终止分号。
- en: Java type inference
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java类型推断
- en: 'Type inference is a fairly broad topic, Java doesn''t support the type of inference.
    I''ve just been talking about, at least for things like dropping the type annotations
    for variables. We have to keep that in:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断是一个相当广泛的主题，Java不支持我刚刚谈到的类型推断类型。至少对于像删除变量的类型注释这样的事情。我们必须记住：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So Java doesn't support type inference in the wider sense. It can't guess *everything*
    like some languages. Type inference for Java then typically refers to the way
    the compiler can work out types for generics. Java 7 improved this when it introduced
    the diamond operator (`<>`) but there are still lots of limitations in what Java
    *can* figure out.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Java在更广义上不支持类型推断。它不能像某些语言那样猜测*一切*。因此，Java中的类型推断通常指的是编译器如何为泛型推断类型。Java 7在引入了菱形操作符（`<>`）时改进了这一点，但在Java
    *可以*推断出的内容上仍然有很多限制。
- en: The Java compiler was built with type erasure; it actively removes the type
    information during compilation. Because of type erasure, `List<String>` becomes
    `List<Object>` after compilation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Java编译器是基于类型擦除构建的；它在编译过程中主动删除类型信息。由于类型擦除，`List<String>`在编译后变成了`List<Object>`。
- en: For historical reasons, when generics were introduced in Java 5, the developers
    couldn't easily reverse the decision to use erasure. Java was left with the need
    to understand what types to substitute for a given generic type but no information
    how to do it because it had all been erased. Type inference was the solution.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 出于历史原因，在Java 5中引入泛型时，开发人员无法轻易地逆转使用擦除的决定。Java需要理解要替换给定泛型类型的类型，但没有信息如何做到这一点，因为所有信息都已被擦除。类型推断是解决方案。
- en: All generic values are really of type `Object` behind the scenes but by using
    type inference, the compiler can check that all the source code usages are consistent
    with what it thinks the generic should be. At runtime, everything is going to
    get passed around as instances of `Object` with appropriate casting behind the
    scenes. Type inference just allows the compiler to check that the casts would
    be valid ahead of time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有泛型值在后台实际上都是`Object`类型，但通过使用类型推断，编译器可以检查所有源代码用法是否与它认为的泛型一致。在运行时，一切都将作为`Object`的实例传递，并在后台进行适当的转换。类型推断只是允许编译器提前检查转换是否有效。
- en: 'So type inference is about guessing the types, Java''s support for type inferences
    was due to be improved in a couple of ways with Java 8:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，类型推断是关于猜测类型的，Java对类型推断的支持在Java 8中将以几种方式得到改进：
- en: Target-typing for lambdas.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: lambda的目标类型推断。
- en: 'and using generalized target-typing to:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 并使用泛化的目标类型推断：
- en: Add support for parameter type inference in method calls.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法调用中添加对参数类型推断的支持。
- en: Add support for parameter type inference in chained calls.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链式调用中添加对参数类型推断的支持。
- en: Lets have a look at the current problems and how modern Java addresses them.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当前的问题以及现代Java如何解决它们。
- en: Target-typing for lambdas
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于lambda的目标类型推断
- en: 'The general improvements to type inference in modern Java mean that lambdas
    can infer their type parameters; so rather than use:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Java对类型推断的一般改进意味着lambda可以推断它们的类型参数；所以不再需要使用：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'you can drop the `Integer` type annotation and use the following instead:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以去掉`Integer`类型注释，使用以下代替：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is because the functional interface describes the types, it gives the compiler
    all the information it needs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为函数接口描述了类型，它给编译器提供了所有需要的信息。
- en: For example, if we take an example functional interface.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们拿一个例子函数接口。
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When a lambda is used in-lieu of the interface, the first thing the compiler
    does is work out the *target* type of the lambda. So if we create a method `calculate`
    that takes the interface and two integers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当lambda被用来代替接口时，编译器首先要做的是确定lambda的*目标*类型。所以如果我们创建一个接受接口和两个整数的方法`calculate`。
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: and then create two lambdas; an addition and subtraction function
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建两个lambda；一个加法和减法函数
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'and use them like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 并且像这样使用它们：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The compiler understands that the lambdas addition and subtraction have a target
    type of Calculation (it's the only "shape" that will fit the method signature
    of calculate). It can then use the method signature to infer the types of the
    lambda's parameters. There's only one method on the interface, so there's no ambiguity,
    the argument types are obviously `Integer`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器理解lambda的加法和减法具有Calculation的目标类型（它是唯一符合calculate方法签名的“形状”）。然后它可以使用方法签名来推断lambda参数的类型。接口上只有一个方法，所以没有歧义，参数类型显然是`Integer`。
- en: We're going to look at lots of examples of target typing so for now, just be
    aware that the mechanism Java uses to achieve lots of the lambda goodness relies
    on improvements to type inference and this idea of a *target* type.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看很多目标类型推断的例子，所以现在，只需知道Java用来实现很多lambda功能的机制依赖于类型推断的改进和*目标*类型的概念。
- en: Type parameters in method calls
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法调用中的类型参数
- en: The were some situations prior to Java 8 where the compiler couldn't infer types.
    One of these was when calling methods with generic type parameters as arguments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8之前，有一些情况下编译器无法推断类型。其中之一是在调用带有泛型类型参数的方法时。
- en: 'For example, the `Collections` class has a generified method for producing
    an empty list. It looks like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Collections`类有一个用于生成空列表的泛型方法。它看起来像这样：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In Java 7 this compiles:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中，这个编译：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: as the Java 7 compiler can work out that the generic needed for the `emptyList`
    method is of type `String`. What it struggles with though is if the result of
    a generic method is passed as a parameter to another method call.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Java 7编译器可以推断出`emptyList`方法所需的泛型类型是`String`类型。然而，它在泛型方法的结果作为参数传递给另一个方法调用时会有困难。
- en: 'So if we had a method to process a list that looks like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们有一个处理列表的方法看起来像这样：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: and then call it with the empty list method.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用空列表方法调用它。
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: it won't compile because the generic type of the parameter has been erased to
    `Object`. It really looks like this.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会编译，因为参数的泛型类型已被擦除为`Object`。它实际上看起来像这样。
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This doesn't match the `processList` method.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`processList`方法不匹配。
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So it won't compile until we give it an extra hint using an explicit "type witness".
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在我们使用显式的“类型见证”给它一个额外的提示之前，它不会编译。
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now the compiler knows enough about what generic type is being passed into the
    method.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译器已经足够了解传递到方法中的泛型类型。
- en: The improvements in Java 8 include better support for this, so generally speaking
    where you would have needed a type witness, you no longer do.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8中的改进包括更好地支持这一点，因此一般来说，你不再需要类型见证。
- en: Our example of calling the `processNames` now compiles!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在调用`processNames`的例子编译通过了！
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Type parameters in chained method calls
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链式方法调用中的类型参数
- en: 'Another common problem with type inference is when methods are chained together.
    Lets suppose we have a `List` class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断的另一个常见问题是方法链。假设我们有一个`List`类：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: and we want to chain a call to add an element to the method creating an empty
    list. Type erasure rears it's head again; the type is erased and so can't be known
    by the next method in the chain. It doesn't compile.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 并且我们想要链式调用添加一个元素到创建空列表的方法。类型擦除再次出现；类型被擦除，所以下一个方法无法知道它。它不会编译。
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This was due to be fixed in Java 8, but unfortunately it was dropped. So, at
    least for now, you'll still need to explicitly offer up a type to the compiler;
    you'll still need a type witness.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这本来应该在Java 8中修复，但不幸的是它被放弃了。所以，至少目前，你仍然需要明确地向编译器提供一个类型；你仍然需要一个类型见证。
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Method references
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法引用
- en: I mentioned earlier that method references are kind of like shortcuts to lambdas.
    They're a compact and convenient way to point to a method and allow that method
    to be used anywhere a lambda would be used.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到方法引用有点像是lambda的快捷方式。它们是指向方法的一种简洁方便的方式，并允许该方法在任何lambda可以使用的地方使用。
- en: When you create a lambda, you create an anonymous function and supply the method
    body. When you use a method reference as a lambda, it's actually pointing to a
    *named* method that already exists; it already has a body.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个lambda时，你创建了一个匿名函数并提供方法体。当你将方法引用作为lambda使用时，它实际上指向一个*已存在*的*命名*方法；它已经有了一个方法体。
- en: You can think of them as *transforming* a regular method into a functional interface.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把它们想象成*将*一个常规方法转换为一个函数接口。
- en: 'The basic syntax looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 基本语法看起来像这样：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'or, a more concrete example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，一个更具体的例子：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The part preceding the double colon is the target reference and after, the method
    name. So, in this case, we're targeting the `String` class and looking for a method
    called `valueOf`; we're referring to the `static` method on `String`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 双冒号之前的部分是目标引用，之后是方法名。所以，在这种情况下，我们的目标是`String`类，并且正在寻找一个叫做`valueOf`的方法；我们正在引用`String`上的`static`方法。
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The double colon is called the *delimiter*. When we use it, we're not invoking
    the method, just *referencing* it. So remember not to add brackets on the end.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 双冒号被称为*分隔符*。当我们使用它时，我们不是在调用方法，只是*引用*它。所以记住不要在末尾加括号。
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can't invoke method references directly, they can only be used in-lieu of
    a lambda. So anywhere a lambda is used, you can use a method reference.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接调用方法引用，它们只能用作lambda的替代。所以任何地方可以使用lambda，你都可以使用方法引用。
- en: Example
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: This statement on it's own won't compile.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句本身不会编译。
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That's because the method reference can't be transformed into a lambda as there's
    no context for the compiler to infer what type of lambda to create.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为方法引用不能转换为lambda，因为编译器无法推断出要创建什么类型的lambda。
- en: '*We* happen to know that this reference is equivalent to'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们*碰巧知道这个引用等同于'
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: but the compiler doesn't know that yet. It can tell some things though. It knows,
    that as a lambda, the return value should be of type `String` because all methods
    called `valueOf` in `String` return a string. But it has no idea what to supply
    as a argument. We need to give it a little help and give it some more context.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 但是编译器还不知道。它可以知道一些事情。它知道，作为lambda，返回值应该是`String`类型，因为`String`中所有名为`valueOf`的方法都返回一个字符串。但它不知道要提供什么样的参数。我们需要给它一点帮助，给它一些更多的上下文。
- en: We'll create a functional interface called `Conversion` that takes an integer
    and returns a string. This is going to be the target type of our lambda.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`Conversion`的函数接口，它接受一个整数并返回一个字符串。这将是我们lambda的目标类型。
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Next, we need to create a scenario where we use this as a lambda. So we create
    a little method to take in a functional interface and apply an integer to it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个场景，在这个场景中我们将使用它作为lambda。所以我们创建一个小方法，接受一个函数接口并将一个整数应用到它上面。
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, here's the thing. We've just given the compiler enough information to transform
    a method reference into the equivalent lambda.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题来了。我们刚刚给编译器足够的信息，以将方法引用转换为等效的lambda。
- en: When we call `convert` method, we can do so passing in a lambda.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`convert`方法时，我们可以传入一个lambda。
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And we can replace the lambda with a reference to the `valueOf` method. The
    compiler now knows we need a lambda that returns a string and takes an integer.
    It now knows that the `valueOf` method "fits" and can substitute the integer argument.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`valueOf`方法的引用替换lambda。编译器现在知道我们需要一个返回字符串并接受一个整数的lambda。它现在知道`valueOf`方法“适合”，并且可以替换整数参数。
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Another way to give the compiler the information it needs is just to assign
    the reference to a type.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 给编译器提供所需的信息的另一种方法就是将引用分配给一个类型。
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: and as a method reference
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以及作为方法引用
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: the "shapes" fit, so it can be assigned.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: “形状”匹配，所以可以分配。
- en: Interestingly, we can assign the same lambda to any interface that requires
    the same "shape". For example, if we have another functional interface with the
    same "shape",
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们可以将相同的lambda分配给任何需要相同“形状”的接口。例如，如果我们有另一个具有相同“形状”的函数接口，
- en: Here, `Example` returns a `String` and takes an `Object` so it has the same
    signature shape as `valueOf`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Example`返回一个`String`并接受一个`Object`，所以它的签名形状与`valueOf`相同。
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: we can still assign the method reference (or lambda) to it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以将方法引用（或lambda）分配给它。
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Method reference types
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法引用类型
- en: 'There are four types of method reference:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种方法引用类型：
- en: Constructor references
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数引用
- en: Static method references
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法引用
- en: And two types of instance method references
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和两种实例方法引用
- en: The last two are a little confusing. The first is a method reference of a particular
    object and the second is a method reference of an *arbitrary* object *but* of
    a particular type. The difference is in how you want to use the method and if
    you have the instance ahead of time or not.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个有点混淆。第一个是特定对象的方法引用，第二个是*任意*对象的方法引用，但是是特定类型的。区别在于你想如何使用这个方法，以及是否提前有实例。
- en: Firstly then, lets have a look at constructor references.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看构造函数引用。
- en: Constructor reference
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数引用
- en: 'The basic syntax looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 基本语法看起来像这样：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: A *target* type followed by the double colon then the `new` keyword. It's going
    to create a lambda that will call the zero argument constructor of the `String`
    class.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*目标*类型后跟双冒号，然后是`new`关键字。它将创建一个lambda，将调用`String`类的零参数构造函数。'
- en: It's equivalent to this lambda
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它等同于这个lambda
- en: '[PRE42]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Remember that method references never have the parentheses; they're not invoking
    methods, just referencing one. This example is referring to the constructor of
    the `String` class but *not* instantiating a string.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，方法引用永远不带括号；它们不是在调用方法，只是引用一个方法。这个例子是指`String`类的构造函数，但*不*实例化一个字符串。
- en: Lets have a look at how we might actually use a constructor reference.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可能如何实际使用构造函数引用。
- en: If we create a list of objects we might want to populate that list say ten items.
    So we could create a loop and add a new object ten times.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个对象列表，我们可能想要填充该列表，比如十个项目。因此，我们可以创建一个循环，并添加一个新对象十次。
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: but if we want to be able to reuse that initializing function, we could extract
    the code to a new method called `initialise` and then use a factory to create
    the object.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想要能够重用该初始化函数，我们可以将代码提取到一个名为`initialise`的新方法中，然后使用工厂来创建对象。
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `Factory` class is just a functional interface with a method called `create`
    that returns some object. We can then add the object it created to the list. Because
    it''s a functional interface, we can use a lambda to implement the factory to
    initialize the list:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Factory`类只是一个带有名为`create`的方法的功能接口，该方法返回一些对象。然后我们可以将它创建的对象添加到列表中。因为它是一个功能接口，我们可以使用lambda来实现初始化列表的工厂：'
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Or we could swap in a constructor reference.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以换成构造函数引用。
- en: '[PRE46]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There's a couple of other things we could do here. If we add some generics to
    the `initialise` method we can reuse it when initializing lists of any type. For
    example, we can go back and change the type of the list to be `String` and use
    a constructor reference to initialize it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一些其他事情我们可以做。如果我们给`initialise`方法添加一些泛型，我们可以在初始化任何类型的列表时重用它。例如，我们可以回过头将列表的类型更改为`String`，并使用构造函数引用进行初始化。
- en: '[PRE47]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We've seen how it works for zero argument constructors, but what about the case
    when classes have multiple argument constructors?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到它如何适用于零参数构造函数，但是当类有多个参数构造函数时呢？
- en: When there are multiple constructors, you use the same syntax but the compiler
    figures out which constructor would be the best match. It does this based on the
    *target* type and inferring functional interfaces that it can use to create that
    type.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在多个构造函数时，您可以使用相同的语法，但编译器会找出哪个构造函数最匹配。它是基于*目标*类型和推断出的功能接口来完成这一点，它可以用来创建该类型。
- en: Let's take the example of a `Person` class, it looks like this and you can see
    the constructor takes a bunch of arguments.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`Person`类为例，它看起来像这样，您可以看到构造函数接受一堆参数。
- en: '[PRE48]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Going back to our example from earlier and looking at the general purpose `initialise`
    method, we could use a lambda like this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前的例子，看看通用的`initialise`方法，我们可以使用这样的lambda：
- en: '[PRE49]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'but to be able to use a constructor reference, we''d need a lambda *with variable
    arguments* and that would look like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要能够使用构造函数引用，我们需要一个带有可变参数的lambda，看起来像这样：
- en: '[PRE50]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: but this doesn't translate to a constructor reference directly. If we were to
    try and use
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不直接转换为构造函数引用。如果我们尝试使用
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: it won't compile as it doesn't know anything about the parameters. If you try
    and compile it, the error says you've created an invalid constructor reference
    that cannot be applied to the given types; it found no arguments.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 它不会编译，因为它不知道任何关于参数的信息。如果您尝试编译它，错误会说您创建了一个无效的构造函数引用，不能应用于给定的类型；它找不到参数。
- en: Instead, we have to introduce some indirection to give the compiler enough information
    to find an appropriate constructor. We can create something that can be used as
    a functional interface *and* has the right types to slot into the appropriate
    constructor.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们必须引入一些间接性，以便为编译器提供足够的信息来找到合适的构造函数。我们可以创建一些可以用作功能接口*并且*具有正确类型以适应适当构造函数的东西。
- en: Let's create a new functional interface called `PersonFactory`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`PersonFactory`的新功能接口。
- en: '[PRE52]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, the arguments from `PersonFactory` match the available constructor on
    `Person`. Magically, this means we can go back and use it with a constructor reference
    of `Person`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，来自`PersonFactory`的参数与`Person`上可用的构造函数匹配。神奇的是，这意味着我们可以回过头使用`Person`的构造函数引用。
- en: '[PRE53]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice I'm using the constructor reference from `Person`. The thing to note
    here is that a constructor reference can be assigned to a target functional interface
    even though we don't yet know the arguments.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我正在使用`Person`的构造函数引用。这里需要注意的是，构造函数引用可以分配给目标功能接口，即使我们还不知道参数。
- en: It may seem a bit strange that the type of the method reference is `PersonFactory`
    and not `Person`. This extra target type information helps the compiler to know
    it has to go via `PersonFactory` to create a `Person`. With this extra hint, the
    compiler is able to create a lambda based on the factory interface that will *later*
    create a `Person`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用的类型是`PersonFactory`而不是`Person`可能看起来有点奇怪。这种额外的目标类型信息帮助编译器知道它必须通过`PersonFactory`来创建`Person`。有了这个额外的提示，编译器就能够创建一个基于工厂接口的lambda，*稍后*创建一个`Person`。
- en: Writing it out long hand, the compiler would generate this.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 写出来的话，编译器会生成这个。
- en: '[PRE54]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'which could be used later like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 之后可以像这样使用：
- en: '[PRE55]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Fortunately, the compiler can do this for us once we've introduced the indirection.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一旦我们引入了间接性，编译器就可以为我们做到这一点。
- en: It understands the target type to use is `PersonFactory` and it understands
    that it's single `abstract` method can be used in-lieu of a constructor. It's
    kind of like a two step process, firstly, to work out that the `abstract` method
    has the same argument list as a constructor and that it returns the right type,
    then apply it with colon colon new syntax.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它了解要使用的目标类型是`PersonFactory`，并且了解它的单个`abstract`方法可以用来代替构造函数。这有点像一个两步过程，首先，找出`abstract`方法与构造函数具有相同的参数列表，并且返回正确的类型，然后使用双冒号新语法应用它。
- en: To finish off the example, we need to tweak our `initialise` method to add the
    type information (replace the generics), add parameters to represent the person's
    details and actually invoke the factory.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成示例，我们需要调整我们的`initialise`方法以添加类型信息（替换泛型），添加参数来表示人的详细信息，并实际调用工厂。
- en: '[PRE56]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'and then we can use it like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以像这样使用它：
- en: '[PRE57]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'or inline, like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 或者内联，像这样：
- en: '[PRE58]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Static method reference
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态方法引用
- en: A method reference can point directly to a static method. For example,
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用可以直接指向静态方法。例如，
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This time, the left hand side refers to the type where a static method, in this
    case `valueOf`, can be found. It's equivalent to this lambda
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，左侧指的是可以找到静态方法（在这种情况下是`valueOf`）的类型。它相当于这个lambda
- en: '[PRE60]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: A more extended example would be where we sort a collection using a reference
    to a static method on the class `Comparators`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的例子是我们使用对`Comparators`类的静态方法的引用对集合进行排序。
- en: '[PRE61]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'where, the static method `ascending` might be defined like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，静态方法`ascending`可能是这样定义的：
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Instance method reference of particular object (in this case, a closure)
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定对象的实例方法引用（在这种情况下是闭包）
- en: 'Here''s an example of an instance method reference of a specific instance:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是特定实例的实例方法引用的一个示例：
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `x` is a specific instance that we want to get at. It''s lambda equivalent
    looks like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`是我们想要获取的特定实例。它的lambda等效如下：'
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The ability to reference the method of a specific instance also gives us a
    convenient way to convert between different functional interface types. For example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 引用特定实例的方法的能力还为我们提供了一种方便的方法，可以在不同的功能接口类型之间进行转换。例如：
- en: '[PRE65]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Callable's functional method is call. When it's invoked the lambda will return
    `"Hello"`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Callable`的功能方法是调用。当调用时，lambda将返回`"Hello"`。'
- en: If we have another functional interface, `Factory`, we can convert the `Callable`
    using a method reference.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有另一个功能接口`Factory`，我们可以使用方法引用将`Callable`转换。
- en: '[PRE66]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We could have just re-created the lambda but this trick is a useful way to get
    reuse out of predefined lambdas. Assign them to variables and reuse them to avoid
    duplication.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重新创建lambda，但这个技巧是一种有用的方法，可以重复使用预定义的lambda。将它们分配给变量并重复使用，以避免重复。
- en: 'Here''s an example of it in use:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用它的示例：
- en: '[PRE67]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This is an example where the method reference is using a closure. It creates
    a lambda that will call the `toString` method on the instance `x`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用闭包的方法引用的示例。它创建一个lambda，将在实例`x`上调用`toString`方法。
- en: 'The signature and implementation of function above looks like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的函数的签名和实现如下：
- en: '[PRE68]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `Supplier` interface is a functional interface that looks like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`Supplier`接口是一个看起来像这样的功能接口：'
- en: '[PRE69]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'When used in our function, it provides a string value (via the call to `get`)
    and the only way it can do that is if the value has been supplied to it on construction.
    It''s equivalent to:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当在我们的函数中使用时，它提供一个字符串值（通过调用`get`），它唯一能做到这一点的方式是如果值在构造时已经被提供。它相当于：
- en: '[PRE70]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Notice here that the lambda has no arguments (it uses the "hamburger" symbol).
    This shows that the value of `x` isn't available in the lambda's local scope and
    so can only be available from outside it's scope. It's a closure because must
    close over `x` (it will *capture* `x`).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的lambda没有参数（它使用“汉堡包”符号）。这表明`x`的值在lambda的局部范围内不可用，因此只能从其范围外部获得。它是一个闭包，因为必须关闭`x`（它将*捕获*`x`）。
- en: 'If you''re interested in seeing the long hand, anonymous class equivalent,
    it''ll look like this. Notice again how `x` must be passed in:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣看到长手，匿名类等效，它将如下所示。再次注意`x`必须传入：
- en: '[PRE71]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: All three of these are equivalent. Compare this to the lambda variation of an
    instance method reference where it doesn't have it's argument explicitly passed
    in from an outside scope.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种都是等效的。将其与实例方法引用的lambda变体进行比较，其中它的参数不是显式从外部范围传入的。
- en: Instance method reference of a arbitrary object whose instance is supplied later
    (lambda)
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 稍后提供实例的任意对象的实例方法引用（lambda）
- en: 'The last case is for a method reference that points to an arbitrary object
    referred to by its type:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况是指向由其类型引用的任意对象的方法引用：
- en: '[PRE72]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: So in this case, although it looks like the left hand side is pointing to a
    class (like the `static` method reference), it's actually pointing to an instance.
    The `toString` method is an instance method on `Object`, not a `static` method.
    The reason why you might not use the regular instance method syntax is because
    you may not yet have an instance to refer to.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，尽管看起来左侧指向一个类（就像`static`方法引用一样），但实际上指向一个实例。`toString`方法是`Object`上的实例方法，而不是`static`方法。之所以可能不使用常规实例方法语法，是因为您可能尚未有实例可供参考。
- en: So before, when we call `x` colon colon `toString`, we know the value of `x`.
    There are some situations where you don't have a value of `x` and in these cases,
    you can still pass around a reference to the method but supply a value later using
    this syntax.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在以前，当我们调用`x`冒号冒号`toString`时，我们知道`x`的值。有些情况下，您没有`x`的值，在这些情况下，您仍然可以传递方法的引用，但稍后使用此语法提供值。
- en: For example, the lambda equivalent doesn't have a bound value for `x`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，lambda等效没有`x`的绑定值。
- en: '[PRE73]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: There difference between the two types of instance method reference is basically
    academic. Sometimes, you'll need to pass something in, other times, the usage
    of the lambda will supply it for you.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 两种类型的实例方法引用之间的区别基本上是学术性的。有时，您需要传递一些内容，其他时候，lambda的使用将为您提供它。
- en: The example is similar to the regular method reference; it calls the `toString`
    method of a string only this time, the string is supplied to the function that's
    making use of the lambda and not passed in from an outside scope.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例类似于常规方法引用；它调用字符串的`toString`方法，只是这一次，字符串是由使用lambda的函数提供的，而不是从外部范围传入的。
- en: '[PRE74]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `String` part looks like it's referring to a class but it's actually referencing
    an instance. It's confusing, I know but to see things more clearly, we need to
    see the function that's making use of the lambda. It looks like this.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`部分看起来像是在引用一个类，但实际上是在引用一个实例。我知道这很令人困惑，但为了更清楚地看到事情，我们需要看到使用lambda的函数。它看起来像这样。'
- en: '[PRE75]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: So, the string value is passed directly to the function, it would look like
    this as a fully qualified lambda.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，字符串值直接传递给函数，它看起来像这样作为完全限定的lambda。
- en: '[PRE76]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: which Java can shortcut to look like `String::toString`; it's saying "supply
    the object instance" at runtime.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Java可以快捷方式查看`String::toString`；它表示在运行时“提供对象实例”。
- en: If you expand it fully to an anonymous interface, it looks like this. The `x`
    parameter is made available and not closed over. Hence it being a lambda rather
    than a closure.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将其完全扩展为匿名接口，它看起来像这样。`x`参数可用且未关闭。因此它是一个lambda而不是闭包。
- en: '[PRE77]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'Oracle describe the four kinds of method reference([http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html](http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html))
    as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle描述了四种方法引用（[http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html](http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html)）如下：
- en: '| **Kind** | **Example** |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| **种类** | **示例** |'
- en: '| Reference to a static method | `ContainingClass::staticMethodName` |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: 对静态方法的引用 | `ContainingClass::staticMethodName` |
- en: '| Reference to an instance method of a particular object | `ContainingObject::instanceMethodName`
    |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: 对特定对象的实例方法的引用 | `ContainingObject::instanceMethodName` |
- en: '| Reference to an instance method of an arbitrary object of a particular type
    | `ContainingType::methodName` |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: 对特定类型的任意对象的实例方法的引用 | `ContainingType::methodName` |
- en: '| Reference to a constructor | `ClassName::new` |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: 对构造函数的引用 | `ClassName::new` |
- en: But the instance method descriptions are just plain confusing. What on earth
    is an instance method of an arbitrary object of a particular type? Aren't all
    objects *of a* particular type? Why is it important that the object is *arbitrary*?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但是实例方法的描述只是纯粹令人困惑。到底是什么意思呢？特定类型的任意对象的实例方法？难道不是所有对象都是*特定类型的*吗？为什么重要的是对象是*任意的*？
- en: I prefer to think of the first as an instance method of a *specific* object
    known ahead of time and the second as an instance method of an arbitrary object
    that will be *supplied* later. Interestingly, this means the first is a *closure*
    and the second is a *lambda*. One is *bound* and the other *unbound*. The distinction
    between a method reference that closes over something (a closure) and one that
    doesn't (a lambda) may be a bit academic but at least it's a more formal definition
    than Oracle's unhelpful description.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢将第一个视为*特定*对象的实例方法，而将第二个视为稍后将*提供*的任意对象的实例方法。有趣的是，这意味着第一个是*闭包*，第二个是*lambda*。一个是*绑定*的，另一个是*未绑定*的。方法引用的区别是闭包（闭包）和不闭包（lambda）可能有点学术，但至少这是一个比Oracle无用的描述更正式的定义。
- en: '| **Kind** | **Syntax** | **Example** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **种类** | **语法** | **示例** |'
- en: '| Reference to a static method | `Class::staticMethodName` | `String::valueOf`
    |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: 对静态方法的引用 | `Class::staticMethodName` | `String::valueOf` |
- en: '| Reference to an instance method of a specific object | `object::instanceMethodName`
    | `x::toString` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: 对特定对象的实例方法的引用 | `object::instanceMethodName` | `x::toString` |
- en: '| Reference to an instance method of a arbitrary object supplied later | `Class::instanceMethodName`
    | `String::toString` |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: 参考任意对象后提供的实例方法的引用 | `Class::instanceMethodName` | `String::toString` |
- en: '| Reference to a constructor | `ClassName::new` | `String::new` |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: 对构造函数的引用 | `ClassName::new` | `String::new` |
- en: 'or as equivalent lambdas:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 或等效的lambda：
- en: '| **Kind** | **Syntax** | **As Lambda** |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| **种类** | **语法** | **作为Lambda** |'
- en: '| Reference to a static method | `Class::staticMethodName` | `(s) -> String.valueOf(s)`
    |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: 对静态方法的引用 | `Class::staticMethodName` | `(s) -> String.valueOf(s)` |
- en: '| Reference to an instance method of a specific object | `object::instanceMethodName`
    | `() -> "hello".toString()` |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: 对特定对象的实例方法的引用 | `object::instanceMethodName` | `() -> "hello".toString()` |
- en: '| Reference to an instance method of a arbitrary object supplied later | `Class::instanceMethodName`
    | `(s) -> s.toString()` |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: 对任意对象后提供的实例方法的引用 | `Class::instanceMethodName` | `(s) -> s.toString()` |
- en: '| Reference to a constructor | `ClassName::new` | `() -> new String()` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: 对构造函数的引用 | `ClassName::new` | `() -> new String()` |
- en: Note that the syntax for a `static` method reference looks very similar to a
    reference to an instance method of a class. The compiler determines which to use
    by going through each applicable static method and each applicable instance method.
    If it were to find a match for both, the result would be a compiler error.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`static`方法引用的语法看起来非常类似于对类的实例方法的引用。编译器通过遍历每个适用的静态方法和每个适用的实例方法来确定使用哪一个。如果它找到两者都匹配，结果将是编译器错误。
- en: You can think of the whole thing as a transformation from a method reference
    to a lambda. The compiler provides the *transformation* function that takes a
    method reference and target typing and can derive a lambda.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将整个过程视为从方法引用到lambda的转换。编译器提供了一个*转换*函数，它接受一个方法引用和目标类型，并可以推导出一个lambda。
- en: Scoping
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: The good news with lambdas is that they don't introduce any new scoping. Using
    variables within a lambda will refer to variables residing in the enclosing environment.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 关于lambda的好消息是它们不会引入任何新的作用域。在lambda中使用变量将引用封闭环境中的变量。
- en: This is what's called **lexical scoping**. It means that lambdas don't introduce
    a new level of scoping at all; you can directly access fields, methods and variables
    from the enclosing scope. It's also the case for the **this** and **super** keywords.
    So we don't have to worry about the crazy nested class syntax for resolving scope.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的**词法作用域**。这意味着lambda根本不会引入新的作用域级别；您可以直接访问封闭范围中的字段、方法和变量。这也适用于**this**和**super**关键字。因此，我们不必担心解析作用域的疯狂嵌套类语法。
- en: Let's take a look at an example. We have an example class here, with a member
    variable `i` set to the value of `5`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。我们在这里有一个示例类，其中一个成员变量`i`设置为`5`的值。
- en: '[PRE78]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the `example` method, a lambda uses a variable called `i` and multiplies
    it by two.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在`example`方法中，lambda使用一个名为`i`的变量，并将其乘以2。
- en: Because lambdas are lexically scoped, `i` simply refers to the enclosing classes'
    variable. It's value at run-time will be 5\. Using this drives home the point;
    this within a lambda is the same as without.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因为lambda是词法作用域的，`i`简单地指的是封闭类的变量。它在运行时的值将是5。使用`this`来强调这一点；在lambda中，`this`与外部相同。
- en: '[PRE79]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the `anotherExample` method below, a method parameter is used which is also
    called `i`. The usual shadowing rules kick in here and `i` will refer to the method
    parameter and not the class member variable. The method variable *shadows* the
    class variable. It's value will be whatever is passed into the method.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的`anotherExample`方法中，使用了一个方法参数，也叫做`i`。通常的遮蔽规则在这里生效，`i`将指代方法参数而不是类成员变量。方法变量*遮蔽*了类变量。它的值将是传入方法的任何值。
- en: '[PRE80]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: If you wanted to refer to the class variable `i` and not the parameter `i` from
    within the body, you could make the variable explicit with this. For example,
    `Supplier<Integer> function = () -> i * 2;`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想引用类变量`i`而不是参数`i`，你可以使用这个方法使变量明确。例如，`Supplier<Integer> function = () -> i
    * 2;`。
- en: The following example has a locally scoped variable defined within the `yetAnotherExample`
    method. Remember that lambdas use their enclosing scope as their own, so in this
    case, `i` within the lambda refers to the method's variable; `i` will be `15`
    and not `5`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在`yetAnotherExample`方法中定义了一个局部作用域变量。记住，lambda使用其封闭作用域作为自己的作用域，所以在这种情况下，lambda中的`i`指的是方法的变量；`i`将是`15`而不是`5`。
- en: '[PRE81]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'If you want to see this for yourself, you could use a method like the following
    to print out the values:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想亲自看看，你可以使用以下方法打印出数值：
- en: '[PRE82]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The output would look like this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE83]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: So, the first method prints `10`; 5 from the class variable multiplied by two.
    The second method prints `20` as the parameter value was 10 and was multiplied
    by two and the final method prints `30` as the local method variable was set to
    15 and again multiplied by two.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一个方法打印`10`；类变量乘以2得到5。第二个方法打印`20`，因为参数值为10，乘以2得到20，最后一个方法打印`30`，因为本地方法变量设置为15，再次乘以2得到30。
- en: Lexical scoping means deferring to the enclosing environment. Each example had
    a different enclosing environment or scope. You saw a variable defined as a class
    member, a method parameter and locally from within a method. In all cases, the
    lambda behaved consistently and referenced the variable from these enclosing scopes.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 词法作用域意味着推迟到封闭环境。每个例子都有一个不同的封闭环境或作用域。你看到一个变量定义为类成员、方法参数和方法内部的局部变量。在所有情况下，lambda的行为都是一致的，并引用了这些封闭作用域中的变量。
- en: Lambda scoping should be intuitive if you're already familiar with basic Java
    scoping, there's really nothing new here.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉基本的Java作用域，Lambda作用域应该是直观的，这里真的没有什么新东西。
- en: Effectively final
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际上final
- en: In Java 7, any variable passed into an anonymous class instance would need to
    be made final.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中，传递给匿名类实例的任何变量都需要被设为final。
- en: This is because the compiler actually copies all the context or *environment*
    it needs into the instance of the anonymous class. If those values were to change
    under it, unexpected side effects could happen. So Java insists that the variable
    be final to ensure it doesn't change and the inner class can operate on them safely.
    By safely, I mean without race conditions or visibility problems between threads.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为编译器实际上将它所需的所有上下文或*环境*复制到匿名类的实例中。如果这些值在其下发生变化，可能会发生意外的副作用。因此Java要求变量是final，以确保它不会改变，内部类可以安全地对其进行操作。安全地，我是指没有线程之间的竞争条件或可见性问题。
- en: Let's have a look at an example. To start with, we'll use Java 7 and create
    a method called `filter` that takes a list of people and a predicate. We'll create
    a temporary list to contain any matches we find then enumerate each element testing
    to see if the predicate holds true for each person. If the test is positive, we'll
    add them to the temporary list before returning all matches.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。首先，我们将使用Java 7创建一个名为`filter`的方法，该方法接受一个人员列表和一个谓词。我们将创建一个临时列表来包含我们找到的任何匹配项，然后枚举每个元素，测试谓词对每个人是否成立。如果测试是积极的，我们将把他们添加到临时列表中，然后返回所有匹配项。
- en: '[PRE84]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Then we'll create a method that uses this to find all the people in a list that
    are eligible for retirement. We set a retirement age variable and then call the
    `filter` method with an arbitrary list of people and a new anonymous instance
    of a `Predicate` interface.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将创建一个方法，使用这个方法来找到列表中所有符合退休条件的人。我们设置一个退休年龄变量，然后调用`filter`方法，传入一个任意的人员列表和一个`Predicate`接口的新匿名实例。
- en: We'll implement this to return true if a person's age is greater than or equal
    to the retirement age variable.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现这个方法，如果一个人的年龄大于或等于退休年龄变量，就返回true。
- en: '[PRE85]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: If you try and compile this, you'll get a compiler failure when accessing the
    variable. This is because the variable isn't final. We'd need to add `final` to
    make it compile.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试编译这个，当访问变量时会得到编译器失败。这是因为变量不是final。我们需要添加`final`使其编译。
- en: '[PRE86]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Passing the environment into an anonymous inner class like this is an example
    of a closure. The environment is what a closure "closes" over; it has to capture
    the variables it needs to do its job. The Java compiler achieves this using the
    copy trick rather than try and manage multiple changes to the same variable. In
    the context of closures, this is called *variable capture*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样将环境传递给匿名内部类是闭包的一个例子。环境是闭包"封闭"的内容；它必须捕获它需要执行任务的变量。Java编译器使用复制技巧来实现这一点，而不是尝试管理对同一变量的多次更改。在闭包的上下文中，这被称为*变量捕获*。
- en: Java 8 introduced the idea of "effectively final" which means that if the compiler
    can work out that a particular variable is *never* changed, it can be used where
    ever a final variable would have be used. It interprets it as "effectively" final.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8引入了"实际上final"的概念，这意味着如果编译器可以确定特定变量*永远*不会改变，它可以在任何需要final变量的地方使用。它将其解释为"实际上"final。
- en: In our example, if we switch to Java 8 and drop the `final` keyword. Things
    still compile. No need to make the variable final. Java knows that the variable
    doesn't change so it makes it effectively final.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，如果我们切换到Java 8并删除`final`关键字。事情仍然可以编译。不需要使变量为final。Java知道变量不会改变，因此它实际上是final。
- en: '[PRE87]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Of course, it still compiles if you were to make it `final`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你把它设为`final`，它仍然可以编译。
- en: But how about if we try and modify the variable after we've initialized it?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们在初始化后尝试修改变量呢？
- en: '[PRE88]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The compiler spots the change and can no longer treat the variable as effectively
    final. We get the original compilation error asking us to make it final. Conversely,
    if adding the `final` keyword to a variable declaration doesn't cause a compiler
    error, then the variable is effectively final.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器发现了变化，不能再将变量视为有效的最终值。我们得到了原始的编译错误，要求我们将其声明为最终值。相反，如果在变量声明中添加`final`关键字不会导致编译错误，那么该变量就是有效的最终值。
- en: I've been demonstrating the point here with an anonymous class examples because
    the idea of effectively final isn't something specific to lambdas. It is of course
    applicable to lambdas though. You can convert this anonymous class above into
    a lambda and nothing changes. There's still no need to make the variable final.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直在用匿名类示例来演示这一点，因为有效最终值的概念并不是特定于lambda的。当然，它也适用于lambda。您可以将上面的匿名类转换为lambda，而不会发生任何变化。仍然不需要将变量声明为最终值。
- en: Circumventing final
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规避最终值
- en: You can still get round the safety net by passing in final objects or arrays
    and then change their internals in your lambda.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以通过传递最终对象或数组来绕过安全网，然后在lambda中更改它们的内部。
- en: 'For example, taking our list of people, lets say we want to sum all their ages.
    We could create a method to loop and sum like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们拿着我们的人员名单，假设我们想要计算他们所有的年龄总和。我们可以创建一个循环和求和的方法，就像这样：
- en: '[PRE89]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'where the sum count is maintained as the list is enumerated. As an alternative,
    we could try and abstract the looping behavior and pass in a function to be applied
    to each element. Like this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，当列表被枚举时，保持总和计数。作为一种替代，我们可以尝试抽象出循环行为，并传入一个要应用于每个元素的函数。就像这样：
- en: '[PRE90]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'and to achieve the summing behavior, all we''d need to do is create a function
    that can sum. You could do this using an anonymous class like this:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现求和行为，我们只需要创建一个可以求和的函数。您可以使用匿名类来做到这一点：
- en: '[PRE91]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Where the functions method takes an integer and returns an integer. In the implementation,
    the sum variable is a class member variable and is mutated each time the function
    is applied. This kind of mutation is generally bad form when it comes to functional
    programming.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的方法接受一个整数并返回一个整数。在实现中，总和变量是一个类成员变量，并且每次应用函数时都会发生变化。这种变化通常在函数式编程中是不好的形式。
- en: 'Nether the less, we can pass this into our `forEach` method like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们可以像这样将其传递给我们的`forEach`方法：
- en: '[PRE92]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: and we'd get the sum of all peoples ages. This works because we're using the
    same instance of the function so the `sum` variable is reused and mutated during
    each iteration.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到所有人年龄的总和。这是因为我们使用了相同的函数实例，所以`sum`变量在每次迭代期间被重用和改变。
- en: The bad news is that we can't convert this into a lambda directly; there's no
    equivalent to a member variable with lambdas, so there's nowhere to put the `sum`
    variable other than outside of the lambda.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 坏消息是我们不能直接将这个转换成lambda；在lambda中没有成员变量的等价物，所以除了在lambda之外没有地方可以放置`sum`变量。
- en: '[PRE93]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: but this highlights that the variable isn't effectively final (it's changed
    in the lambda's body) and so it must be made final.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 但这突显了变量并不是有效的最终值（它在lambda的函数体中被改变），所以它必须被声明为最终值。
- en: But if we make it final
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们将它声明为最终值
- en: '[PRE94]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: we can no longer modify it in the body! It's a chicken and egg situation.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能再在函数体内修改它了！这是一个鸡生蛋蛋生鸡的情况。
- en: The trick around this is to use a object or an array; it's reference can remain
    final but it's internals can be modified
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过最终值
- en: '[PRE95]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The array reference is indeed final here, but we can modify the array contents
    without reassigning the reference. However, this is generally bad form as it opens
    up to all the safety issues we talked about earlier. I mention it for illustration
    purposes but don't recommend you do this kind of thing often. It's generally better
    not to create functions with side effects and you can avoid the issues completely,
    if you use a more functional approach. A more idiomatic way to do this kind of
    summing is to use what's called a *fold* or in the Java vernacular *reduce*.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 数组引用在这里确实是最终的，但我们可以修改数组内容而不重新分配引用。然而，这通常是不好的形式，因为它会引发我们之前讨论的所有安全问题。我提到这个只是为了举例说明，但不建议您经常这样做。通常最好不要创建具有副作用的函数，如果您使用更多的函数式方法，完全可以避免这些问题。这种求和的更符合惯例的方法是使用所谓的*fold*或在Java术语中称为*reduce*。
- en: Exception handling
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: There's no new syntax for exception handling in lambdas. Exceptions thrown in
    a lambda are propagated to the caller, just as you'd expect with a regular method
    call. There's nothing special about calling lambdas or handling their exceptions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda中没有新的异常处理语法。lambda中抛出的异常会传播到调用者，就像您对常规方法调用的预期一样。调用lambda或处理它们的异常没有任何特殊之处。
- en: However, there are some subtleties that you need to be aware of. Firstly, as
    a caller of a lambda, you are potentially unaware of what exceptions might be
    thrown, if any and secondly, as the author of a lambda, you're potentially unaware
    what context your lambda will be run in.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些微妙之处需要您注意。首先，作为lambda的调用者，您可能不知道可能抛出什么异常，如果有的话，其次，作为lambda的作者，您可能不知道您的lambda将在什么上下文中运行。
- en: When you create a lambda, you typically give up responsibility of how that lambda
    will be executed to the method that you pass it to. For all you know, your lambda
    may be run in parallel or at some point in the future and so any exception you
    throw may not get handled as you might expect. You can't rely on exception handling
    as a way to control your program's flow.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个lambda时，通常会将如何执行该lambda的责任交给您传递给它的方法。就你所知，您的lambda可能会并行运行，或者在将来的某个时刻运行，因此您抛出的任何异常可能不会得到您的预期处理。您不能依赖异常处理来控制程序的流程。
- en: To demonstrate this, lets write some code to call two things, one after the
    other. We'll use `Runnable` as a convenient lambda type.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，让我们编写一些代码来依次调用两个东西。我们将使用`Runnable`作为一个方便的lambda类型。
- en: '[PRE96]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: If the first call to run were to throw an exception, the method would terminate
    and the second method would never be called. The caller is left to deal the exception.
    If we use this method to transfer money between two bank accounts, we might write
    two lambdas. One for the debit action and one for the credit.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一次调用run抛出异常，方法将终止，第二个方法将不会被调用。调用者需要处理异常。如果我们使用这种方法在两个银行账户之间转账，我们可能会编写两个lambda。一个用于借方操作，一个用于贷方。
- en: '[PRE97]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'we could then call our `runInSequence` method like this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样调用我们的`runInSequence`方法：
- en: '[PRE98]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'any exceptions could be caught and dealt with by using a `try`/`catch` like
    this:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 任何异常都可以通过使用`try`/`catch`来捕获和处理，就像这样：
- en: '[PRE99]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Here''s the thing. As an author of the lambdas, I potentially have no idea
    how `runInSequence` is implemented. It may well be implemented to run asynchronously
    like this:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是问题所在。作为lambda的作者，我可能根本不知道`runInSequence`是如何实现的。它很可能是异步运行的，就像这样：
- en: '[PRE100]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: In which case any exception in the first call would terminate the thread, the
    exception would disappear to the default exception handler and our original client
    code wouldn't get the chance to deal with the exception.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第一个调用中的任何异常都将终止线程，异常将消失到默认的异常处理程序，我们原始的客户端代码将没有机会处理异常。
- en: Using a callback
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用回调
- en: 'Incidentally, one way round the specific problem with raising an exception
    on a different thread than the caller can be addressed with a callback function.
    Firstly, you''d defend against exceptions in the `runInSequence` method:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，解决在不同线程上引发异常的特定问题的一种方法是使用回调函数。首先，您可以防御`runInSequence`方法中的异常：
- en: '[PRE101]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Then introduce an exception handler which can be called in the event of an
    exception:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 然后引入一个异常处理程序，可以在发生异常时调用：
- en: '[PRE102]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Consumer is a functional interface (new in Java 8) that in this case takes the
    exception as an argument to it's `accept` method.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer是一个函数接口（Java 8中的新功能），在这种情况下，它将异常作为参数传递给它的`accept`方法。
- en: When we wire this up to the client, we can pass in a callback lambda to handle
    any exception.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将其连接到客户端时，我们可以传递一个回调lambda来处理任何异常。
- en: '[PRE103]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This is a good example of deferred execution and so has it's own foibles. The
    exception handler method may (or may not) get executed at some later point in
    time. The `nonBlockingTransfer` method will have finished and the bank accounts
    themselves may be in some other state by the time it fires. You can't rely on
    the exception handler being called when it's convenient for you; we've opened
    up a whole can of concurrency worms.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这是延迟执行的一个很好的例子，因此它有自己的缺点。异常处理程序方法可能（或可能不会）在以后的某个时间点执行。`nonBlockingTransfer`方法将已经完成，银行账户本身可能在它触发时处于其他状态。您不能指望在方便的时候调用异常处理程序；我们已经打开了一个并发问题的大潘头。
- en: Dealing with exceptions when writing lambdas
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理编写lambda时的异常
- en: Let's look at dealing with exceptions from the perspective of a lambda author,
    someone writing lambdas. After this, we'll look at dealing with exceptions when
    calling lambdas.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从lambda作者的角度来看待处理异常。之后，我们将看看在调用lambda时如何处理异常。
- en: Lets look at it as if we wanted to implement the `transfer` method using lambdas
    but this time wanted to reuse an existing library that supplies the `runInSequence`
    method.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们想使用lambda来实现`transfer`方法，但这次想要重用一个提供`runInSequence`方法的现有库。
- en: Before we start, let's take a look at the `BankAccount` class. You'll notice
    that this time, the `debit` and `credit` methods both throw a checked exception;
    `InsufficientFundsException`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们看一下`BankAccount`类。您会注意到这次，`debit`和`credit`方法都会抛出一个已检查的异常；`InsufficientFundsException`。
- en: '[PRE104]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Let's recreate the `transfer` method. We'll try to create the debit and credit
    lambdas and pass these into the `runInSequence` method. Remember that the `runInSequence`
    method was written by some library author and we can't see or modify it's implementation.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新创建`transfer`方法。我们将尝试创建借方和贷方lambda，并将其传递给`runInSequence`方法。请记住，`runInSequence`方法是由某个库的作者编写的，我们无法看到或修改它的实现。
- en: '[PRE105]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The debit and credit both throw a checked exception, so this time, you can see
    a compiler error. It makes no difference if we add this to the method signature;
    the exception would happen inside the lambda. Remember I said exceptions in lambdas
    are propagated to the caller? In our case, this will be the `runInSequence` method
    and not the point we define the lambda. The two aren't communicating between themselves
    that there could be an exception raised.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 借方和贷方都会抛出一个已检查的异常，所以这次你会看到一个编译错误。如果我们将其添加到方法签名中也没有任何区别；异常会发生在lambda内部。记住我说过lambda中的异常会传播给调用者吗？在我们的情况下，这将是`runInSequence`方法，而不是我们定义lambda的地方。它们之间没有相互通信，可能会引发异常。
- en: '[PRE106]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'So if we can''t force a checked exception to be *transparent* between the lambda
    and the caller, one option is to wrap the checked exception as a runtime exception
    like this:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们无法强制要求已检查的异常在lambda和调用者之间是*透明*的，一种选择是将已检查的异常包装为运行时异常，就像这样：
- en: '[PRE107]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: That gets us out of the compilation error but it's not the full story yet. It's
    very verbose and we still have to catch and deal with, what's now a runtime exception,
    around the call to `runInSequence`.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以解决编译错误，但这还不是全部。这非常冗长，我们仍然需要捕获和处理现在是运行时异常的调用`runInSequence`。
- en: '[PRE108]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: There's still one or two niggles though; we're throwing and catching a `RuntimeException`
    which is perhaps a little loose. We don't really know what other exceptions, if
    any, might be thrown in the `runInSequence` method. Perhaps it's better to be
    more explicit. Let's create a new sub-type of `RuntimeException` and use that
    instead.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管还有一两个小问题；我们抛出并捕获了一个`RuntimeException`，这可能有点松散。我们真的不知道在`runInSequence`方法中可能会抛出什么其他异常。也许更明确一些会更好。让我们创建`RuntimeException`的一个新子类型，然后使用它。
- en: '[PRE109]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: After we've modified the original lambda to throw the new exception, we can
    restrict the catch to deal with only exceptions we know about; namely the `InsufficientFundsRuntimeException`.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修改原始lambda以抛出新异常之后，我们可以限制catch处理只处理我们知道的异常；即`InsufficientFundsRuntimeException`。
- en: We can now implement some kind of balance check and rollback functionality,
    confident that we understand all the scenarios that can cause it.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现某种余额检查和回滚功能，并确信我们理解了可能导致它的所有情况。
- en: '[PRE110]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The trouble with all this, is that the code has more exception handling boilerplate
    than actual business logic. Lambdas are supposed to make things less verbose but
    this is just full of noise. We can make things better if we generalize the wrapping
    of checked exceptions to runtime equivalents. We could create a functional interface
    that captures an exception type on the signature using generics.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些麻烦之处在于，代码中的异常处理样板比实际业务逻辑更多。Lambda应该使事情变得不那么冗长，但这里充满了噪音。如果我们将受检异常的包装泛化为运行时等价物，我们可以做得更好。我们可以创建一个捕获异常类型的泛型签名的函数接口。
- en: Let's name it `Callable` and its single method; `call`. Don't confuse this with
    the class of the same name in the JDK; we're creating a new class to illustrate
    dealing with exceptions.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称它为`Callable`，它的单个方法是`call`。不要将其与JDK中同名的类混淆；我们正在创建一个新类来说明如何处理异常。
- en: '[PRE111]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: We'll change the old implementation of transfer and create lambdas to match
    the "shape" of the new functional interface. I've left off the type for a moment.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改transfer的旧实现，并创建lambda以匹配新函数接口的“形状”。我暂时省略了类型。
- en: '[PRE112]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Remember from the type inference section that Java would be able to see this
    as a type of `Callable` as it has no parameters as does `Callable`, it has the
    same return type (none) and throws an exception of the same type as the interface.
    We just need to give the compiler a hint, so we can assign this to an instance
    of a `Callable`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 从类型推断部分可以看出，Java可以将其视为`Callable`类型，因为它没有参数，`Callable`也没有参数，它具有相同的返回类型（无）并且抛出与接口相同类型的异常。我们只需要给编译器一个提示，这样我们就可以将其分配给`Callable`的实例。
- en: '[PRE113]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Creating the lambdas like this doesn't cause a compilation error as the functional
    interface declares that it could be thrown. It doesn't need to warn us at the
    point we create the lambda, as the signature of the functional method will cause
    the compiler to error if required when we actually try and call it. Just like
    a regular method.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样创建lambda不会导致编译错误，因为函数接口声明可能会抛出异常。它不需要在我们创建lambda的时候警告我们，因为函数方法的签名会在我们尝试调用它时引发编译器错误，如果需要的话。就像普通方法一样。
- en: If we try and pass them into the `runInSequence` method, we'll get a compiler
    error though.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将它们传递给`runInSequence`方法，我们将会得到一个编译错误。
- en: '[PRE114]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The lambdas are of the wrong type. We still need a lambda of type `Runnable`.
    We''ll have to write a method that can convert from a `Callable` to a `Runnable`.
    At the same time, we''ll wrap the checked exception to a run time one. Something
    like this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: lambda的类型是错误的。我们仍然需要一个`Runnable`类型的lambda。我们将不得不编写一个方法，可以将`Callable`转换为`Runnable`。与此同时，我们将受检异常包装为运行时异常。就像这样：
- en: '[PRE115]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'All that''s left to do is wire it in for our lambdas:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要做的就是将其连接到我们的lambda中：
- en: '[PRE116]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Once we put the exception handling back in we're back to a more concise method
    body and have dealt with the potential exceptions in the same way as before.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们把异常处理放回去，我们就回到了更简洁的方法体，并且以与以前相同的方式处理了潜在的异常。
- en: '[PRE117]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The downside is this isn't a totally generalized solution; we'd still have to
    create variations of the unchecked method for different functions. We've also
    just hidden the verbose syntax away. The verbosity is still there its just been
    moved. Yes, we've got some reuse out of it but if exception handling were transparent
    or we didn't have checked exceptions, we wouldn't need to brush the issue under
    the carpet quite so much.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这个缺点是这不是一个完全通用的解决方案；我们仍然需要为不同的函数创建unchecked方法的变体。我们只是把冗长的语法隐藏起来了。冗长仍然存在，只是被移动了。是的，我们已经从中获得了一些重复利用，但是如果异常处理是透明的，或者我们没有检查异常，我们就不需要掩盖问题了。
- en: It's worth pointing out that we'd probably end up doing something similar if
    we were in Java 7 and using anonymous classes instead of lambdas. A lot of this
    stuff can still be done pre-Java 8 and you'll end up creating helper methods to
    push the verbosity to one side.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，如果我们在Java 7中使用匿名类而不是lambda，我们可能最终会做类似的事情。在Java 8之前仍然可以做很多这样的事情，你最终会创建辅助方法来推迟冗长。
- en: It's certainly the case that lambdas offer more concise representations for
    small anonymous pieces of functionality but because of Java's checked exception
    model, dealing with exceptions in lambdas will often cause all the same verbosity
    problems we had before.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，lambda为小型匿名功能提供了更简洁的表示，但由于Java的受检异常模型，处理lambda中的异常通常会导致我们之前遇到的所有冗长问题。
- en: As a caller (dealing with exceptions when calling lambdas)
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为调用者（在调用lambda时处理异常）
- en: We've seen things from the perspective of writing lambdas, now lets have a look
    at things when calling lambdas.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从编写lambda的角度看到了一些事情，现在让我们看看在调用lambda时的情况。
- en: Let's imagine that now we're writing the library that offers the `runInSequence`
    method. We have more control this time and aren't limited to using `Runnable`
    as a lambda type. Because we don't want to force our clients to jump through hoops
    dealing with exceptions in their lambdas (or wrap them as runtime exceptions),
    we'll provide a functional interface that declares that a checked exception might
    be thrown.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们正在编写一个提供`runInSequence`方法的库。这次我们有更多的控制权，不再局限于使用`Runnable`作为lambda类型。因为我们不想强迫客户在他们的lambda中处理异常（或将它们包装为运行时异常），我们将提供一个函数接口，声明可能会抛出受检异常。
- en: 'We''ll call it `FinancialTransfer` with a `transfer` method:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称它为`FinancialTransfer`，有一个`transfer`方法：
- en: '[PRE118]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: We're saying that whenever a banking transaction occurs, there's the possibility
    that insufficient funds are available. Then when we implement our `runInSequence`
    method, we accept lambdas of this type.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在说，每当发生银行交易时，都有可能出现资金不足的情况。然后当我们实现我们的`runInSequence`方法时，我们接受这种类型的lambda。
- en: '[PRE119]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This means that when clients use the method, they're not forced to deal with
    exceptions within their lambdas. For example, writing a method like this.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当客户端使用该方法时，他们不必强制在他们的lambda内部处理异常。例如，编写这样的方法。
- en: '[PRE120]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This time there is no compiler error when creating the lambdas. There's no need
    to wrap the exceptions from `BankAccount` methods as runtime exceptions; the functional
    interface has already declared the exception. However, `runInSequence` would now
    throw a checked exception, so it's explicit that the client has to deal with the
    possibility and you'll see a compiler error.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这次在创建lambda时不会有编译器错误。无需将`BankAccount`方法的异常包装为运行时异常；函数接口已经声明了异常。但是，`runInSequence`现在会抛出一个已检查的异常，因此明确表示客户端必须处理可能性，您将看到一个编译器错误。
- en: '[PRE121]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'So we need to wrap the call in a `try`/`catch` to make the compiler happy:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要用`try`/`catch`来包装调用，以使编译器满意：
- en: '[PRE122]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The end result is something like we saw previously but without the need for
    the unchecked method. As a library developer, we've made it easier for clients
    to integrate with our code.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结果类似于我们之前看到的，但不需要未经检查的方法。作为库开发人员，我们使客户更容易与我们的代码集成。
- en: But what about if we try something more exotic? Let's make the `runInSequence`
    method asynchronous again. There's no need to throw the exception from the method
    signature as it wouldn't propagate to the caller if it were thrown from a different
    thread. So this version of the `runInSequence` method doesn't include the throws
    clause and the `transfer` method is no longer forced to deal with it. However,
    the calls to `.transfer` will still throw an exception.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们尝试一些更奇特的东西呢？让我们再次将`runInSequence`方法异步化。无需从方法签名中抛出异常，因为如果从不同的线程中抛出异常，它不会传播到调用者。因此，这个版本的`runInSequence`方法不包括throws子句，`transfer`方法也不再被强制处理异常。然而，对`.transfer`的调用仍然会抛出异常。
- en: '[PRE123]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: With the compiler errors still in the `runInSequence` method, we need another
    way to handle the exception. One technique is to pass in a function that will
    be called in the event of an exception. We can use this lambda to bridge the code
    running asynchronously back to the caller.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`runInSequence`方法中仍然存在编译器错误，我们需要另一种处理异常的方法。一种技术是传入一个在发生异常时将被调用的函数。我们可以使用这个lambda将异步运行的代码与调用者连接起来。
- en: To start with, we'll add the `catch` block back in and pass in a functional
    interface to use as the exception handler. I'll use the `Consumer` interface here,
    it's new in Java 8 and part of the `java.util.function` package. We then call
    the interface method in the catch block, passing in the cause.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将重新添加`catch`块，并传入一个函数接口作为异常处理程序。我将在这里使用`Consumer`接口，它是Java 8中的新功能，并且是`java.util.function`包的一部分。然后在catch块中调用接口方法，传入原因。
- en: '[PRE124]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: To call it, we need to update the `transfer` method to pass in a lambda for
    the callback. The parameter, exception below, will be whatever is passed into
    the `accept` method in `runInSequence`. It will be an instance of `InsufficientFundsException`
    and the client can deal with it however they chose.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用它，我们需要更新`transfer`方法，以传入一个回调的lambda。下面的参数exception将是传递给`runInSequence`中的`accept`方法的任何内容。它将是`InsufficientFundsException`的一个实例，客户端可以自行处理。
- en: '[PRE125]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: There we are. We've provided the client to our library with an alternative exception
    handling mechanism rather than forcing them to catch exceptions.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为我们的库提供了一种替代的异常处理机制，而不是强制它们捕获异常。
- en: We've internalized the exception handling into the library code. It's a good
    example of deferred execution; should there be an exception, the client doesn't
    necessarily know when his exception handler would get invoked. For example, as
    we're running in another thread, the bank accounts themselves may have be altered
    by the time it executes. Again it highlights that using exceptions to control
    your program's flow is a flawed approach. You can't rely on the exception handler
    being called when it's convenient for you.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将异常处理内部化到库代码中。这是延迟执行的一个很好的例子；如果有异常，客户端不一定知道何时会调用他的异常处理程序。例如，由于我们在另一个线程中运行，银行账户本身可能在执行时已经被更改。再次强调，使用异常来控制程序流是一种有缺陷的方法。您不能指望在方便时调用异常处理程序。
- en: Lambdas vs closures
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda vs 闭包
- en: The terms *closure* and *lambda* are often used interchangeably but they are
    actually distinct. In this section we'll take a look at the differences so you
    can be clear about which is which.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*闭包*和*lambda*经常可以互换使用，但它们实际上是不同的。在本节中，我们将看一下它们之间的区别，以便您清楚地知道哪个是哪个。
- en: 'Below is a table showing the release dates for each major version of Java.
    Java 5.0 came along in 2004 and included the first major language changes including
    things like generics support:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是显示每个Java主要版本的发布日期的表格。Java 5.0于2004年推出，包括了第一个重大的语言更改，包括泛型支持等内容：
- en: '![Lambdas vs closures](img/timeline.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![Lambdas vs closures](img/timeline.jpg)'
- en: Around 2008 to 2010 there was a lot of work going on to introduce closures to
    Java. It was due to go in to Java 7 but didn't quite make it in time. Instead
    it evolved into lambda support in Java 8\. Unfortunately, around that time, people
    used the term "closures" and "lambdas" interchangeably and so it's been a little
    confusing for the Java community since. In fact, there's still a project page
    on the OpenJDK site for [closures](http://openjdk.java.net/projects/closures/) and
    one for [lambdas](http://openjdk.java.net/projects/lambda/).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在2008年至2010年期间，有很多工作正在进行，以引入闭包到Java中。原本计划在Java 7中引入，但最终没有及时实现。相反，它演变为了Java
    8中的lambda支持。不幸的是，在那个时候，人们经常互换使用术语“闭包”和“lambda”，因此对于Java社区来说有点混淆。事实上，OpenJDK网站上仍然有一个[closures](http://openjdk.java.net/projects/closures/)的项目页面，还有一个[lambdas](http://openjdk.java.net/projects/lambda/)的项目页面。
- en: From the OpenJDK project's perspective, they really should have been using "lambda"
    consistently from the start. In fact, the OpenJDK got it so wrong, they ignored
    the fact that Java *has had* closure support since version 1.1!
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 从OpenJDK项目的角度来看，他们真的应该从一开始就一直使用“lambda”。事实上，OpenJDK搞错了，他们忽略了Java自1.1版本以来就已经支持闭包。
- en: I'm being slightly pedantic here as although there are technical differences
    between closures and lambdas, the goals of the two projects were to achieve the
    same thing, even if they used the terminology inconsistently.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里有点追究，因为尽管闭包和lambda之间存在技术上的差异，但两个项目的目标都是实现相同的事情，即使它们在术语上使用不一致。
- en: So what is the difference between lambdas and closures? Basically, a closure
    *is a* type of lambda but a lambda isn't necessarily a closure.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 那么lambda和闭包之间的区别是什么？基本上，闭包*是*lambda的一种类型，但lambda不一定是闭包。
- en: Basic differences
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本区别
- en: Just like a lambda, a closure is effectively an anonymous block of functionality,
    but there are some important distinctions. A closure depends on external values
    (not just it's arguments) whereas a lambda depends only on it's arguments. A closure
    is said to "close over" the environment it requires.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 就像lambda一样，闭包实际上是一个匿名的功能块，但有一些重要的区别。闭包依赖于外部值（不仅仅是它的参数），而lambda只依赖于它的参数。闭包被认为是“关闭”它所需的环境。
- en: 'For example, the following:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下内容：
- en: '[PRE126]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: is a lambda, but this
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个lambda，但这
- en: '[PRE127]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: is a closure.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个闭包。
- en: They both return a boolean indicating if some server is up but one uses it's
    argument and the other must get the variable from somewhere else. Both are lambdas;
    in the general sense, they are both anonymous blocks of functionality and in the
    Java language sense, they both use the new lambda syntax.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都返回一个布尔值，指示某个服务器是否正在运行，但一个使用它的参数，另一个必须从其他地方获取变量。它们都是lambda；从一般意义上讲，它们都是匿名的功能块，在Java语言意义上，它们都使用新的lambda语法。
- en: The first example refers to a server variable passed into the lambda as an argument
    whereas the second example (the closure) gets the server variable from somewhere
    else; that is the environment. To get the instance of the variable, the lambda
    has to "close over" the environment or capture the value of server. We've seen
    this in action when we talked about `effectively final` before.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子是指传递给lambda的服务器变量作为参数，而第二个例子（闭包）从其他地方获取服务器变量；也就是环境。为了获取变量的实例，lambda必须“关闭”环境或捕获server的值。我们在之前谈到“有效最终”时已经看到了这一点。
- en: Let's expand the example to see things more clearly. Firstly, we'll create a
    method in a static class to perform a naive poll and wait. It'll check a functional
    interface on each poll to see if some condition has been met.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展这个例子，以便更清楚地看到事情。首先，我们将在一个静态类中创建一个方法来执行一个简单的轮询和等待。它将在每次轮询时检查一个函数接口，以查看是否满足某个条件。
- en: '[PRE128]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: We use `Predicate` (another new `java.util` interface) as our functional interface
    and test it, pausing for a short while if the condition is not satisfied. We can
    call this method with a simple lambda that checks if some HTTP server is running.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Predicate`（另一个新的`java.util`接口）作为我们的函数接口，并测试它，如果条件不满足，就暂停一小段时间。我们可以用一个简单的lambda调用这个方法，检查某个HTTP服务器是否正在运行。
- en: '[PRE129]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The server parameter is supplied by our `waitFor` method and will be the instance
    of `HttpServer` we've just defined. It's a lambda as the compiler doesn't need
    to capture the server variable as we supply it manually at runtime.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器参数由我们的`waitFor`方法提供，并且将是我们刚刚定义的`HttpServer`的实例。它是一个lambda，因为编译器不需要捕获服务器变量，因为我们在运行时手动提供它。
- en: Note
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Incidentally, we might have been able to use a method reference...  `waitFor(new
    HttpServer(), HttpServer::isRunning);`
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们可能可以使用方法引用... `waitFor(new HttpServer(), HttpServer::isRunning);`
- en: Now, if we re-implement this as a closure, it would look like this. Firstly,
    we have to add another `waitFor` method.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们将其重新实现为一个闭包，它将看起来像这样。首先，我们必须添加另一个`waitFor`方法。
- en: '[PRE130]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: This time, with a simpler signature. We pass in a functional interface that
    requires no parameters. The `Condition` interface has a simple `isSatisfied` method
    with no argument which implies that we have to supply any values an implementation
    might need. It's already hinting that usages of it may result in closures.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，使用一个更简单的签名。我们传递一个不需要参数的函数接口。`Condition`接口有一个简单的`isSatisfied`方法，没有参数，这意味着我们必须提供实现可能需要的任何值。它已经暗示了它的用法可能会导致闭包。
- en: 'Using it, we''d write something like this:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它，我们会写成这样：
- en: '[PRE131]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The server instance is not passed as a parameter to the lambda here but accessed
    from the enclosing scope. We've defined the variable and the lambda uses it directly.
    This variable has to be captured, or copied by the compiler. The lambda "closes
    over" the server variable.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这里服务器实例没有作为参数传递给lambda，而是从封闭的作用域中访问。我们已经定义了变量，lambda直接使用它。这个变量必须被编译器捕获或复制。lambda“关闭”了服务器变量。
- en: This expression to "close over" comes from the idea that a lambda expression
    with open bindings (or free variables) have been closed by (or bound in) the lexical
    environment or scope. The result is a *closed expression*. There are no unbound
    variables. To be more precise, closures close over *values* not *variables*.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“关闭”表达式来自这样一个想法，即具有开放绑定（或自由变量）的lambda表达式已经被词法环境或作用域关闭（或绑定）。结果是一个*封闭的表达式*。没有未绑定的变量。更准确地说，闭包关闭的是*值*而不是*变量*。
- en: We've seen a closure being used to provide an anonymous block of functionality
    and the difference between an equivalent lambda but, there are still more useful
    distinctions we can make.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到闭包被用来提供一个匿名的功能块，以及等效的lambda之间的区别，但是我们仍然可以做出更有用的区分。
- en: Other differences
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他区别
- en: An anonymous function, is a function literal without a name, whilst a closure
    is an instance of a function. By definition, a lambda has no instance variables;
    it's not an instance. It's variables are supplied as arguments. A closure however,
    has instance's variables which are provided when the instance is created.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数是一个没有名称的函数文字，而闭包是函数的一个实例。根据定义，lambda没有实例变量；它不是一个实例。它的变量是作为参数提供的。然而，闭包有实例变量，这些变量在实例创建时提供。
- en: With this in mind, a lambda will generally be more efficient than a closure
    as it only needs to evaluated once. Once you have the function, you can re-use
    it. As a closure closes over something not in it's local environment, it has to
    be evaluated every time it's called. An instance has to be newed up each time
    it's used.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理解，lambda通常比闭包更有效，因为它只需要评估一次。一旦有了函数，就可以重复使用它。由于闭包封闭了其本地环境之外的东西，因此每次调用它都必须进行评估。每次使用时都必须新建一个实例。
- en: All the issues we looked at in the functions vs classes section are relevant
    here too. There may be memory considerations to using closures over lambdas.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在函数与类部分看到的所有问题在这里也是相关的。使用闭包而不是lambda可能会考虑到内存问题。
- en: Summary
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We've talked about a lot here so let's summarize the differences briefly.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里谈论了很多，让我们简要总结一下区别。
- en: Lambdas are just anonymous functions, similar to static methods in Java. Just
    like static methods, they can't reference variables outside their scope except
    for their arguments. A special type of lambda, called a closure, can capture variables
    outside their scope (or close over them) so they can use external variables or
    their arguments. So the simple rule is if a lambda uses a variable from outside
    it's scope, it's also a closure.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda只是匿名函数，类似于Java中的静态方法。就像静态方法一样，它们不能引用其范围之外的变量，除了它们的参数。一种特殊类型的lambda，称为闭包，可以捕获其范围之外的变量（或者封闭它们），以便可以使用外部变量或它们的参数。因此，简单的规则是，如果lambda使用了其范围之外的变量，它也是一个闭包。
- en: Closures can be seen as instances of functions. Which is kind of an odd concept
    for Java developers.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包可以被视为函数的实例。这对于Java开发人员来说有点奇怪的概念。
- en: A great example is the conventional anonymous class that we would pass around
    if we didn't have the new lambda syntax. These can "close over" variables and
    so are themselves closures. So we've had closure support in Java since 1.1.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是传统的匿名类，如果没有新的lambda语法，我们将传递它们。这些可以“封闭”变量，因此它们本身也是闭包。因此，自Java 1.1以来，我们一直在Java中支持闭包。
- en: Take a look at this example. The server variable has to be closed over by the
    compiler to be used in the anonymous instance of the `Condition` interface. This
    is both an anonymous class instance and a closure.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个例子。服务器变量必须由编译器封闭，以便在`Condition`接口的匿名实例中使用。这既是匿名类实例，也是闭包。
- en: '[PRE132]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Lambda's aren't always closures, but closures are always lambdas.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda并不总是闭包，但闭包总是lambda。
- en: In this section we'll explore how the compiler output differs when you compile
    anonymous classes to when you compile lambdas. First we'll remind ourselves about
    java bytecode and how to read it. Then we'll look at both anonymous classes and
    lambdas when they capture variables and when they don't. We'll compare pre-Java
    8 closures with lambdas and explore how lambdas are *not* just syntactic sugar
    but produce very different bytecode from the traditional approaches.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨当您将匿名类编译为lambda时，编译器输出的差异。首先，我们会提醒自己关于java字节码以及如何阅读它。然后，我们将研究匿名类和lambda在捕获变量和不捕获变量时的情况。我们将比较Java
    8之前的闭包与lambda，并探讨lambda并不仅仅是语法糖，而是与传统方法产生非常不同的字节码。
- en: Bytecode recap
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节码回顾
- en: To start with, let's recap on what we know about bytecode.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们回顾一下我们对字节码的了解。
- en: To get from source code to machine runnable code. The Java compiler produces
    bytecode. This is either interpreted by the JVM or re-compiled by the Just-in-time
    compiler.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 从源代码到可执行的机器代码。Java编译器生成字节码。这要么由JVM解释，要么由即时编译器重新编译。
- en: When it's interpreted, the bytecode is turned into machine code on the fly and
    executed. This happens each time the bytecode is encountered but he JVM.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 当它被解释时，字节码会即时转换为机器码并执行。这每次遇到字节码时都会发生，但是JVM。
- en: When it's Just-in-time compiled, the JVM compiles it directly into machine code
    the first time it's encountered and then goes on to execute it.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 当它被即时编译时，JVM会直接将其编译成机器码，然后继续执行。
- en: Both happen at run-time but Just-in-time compilation offer lots of optimizations.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都发生在运行时，但即时编译提供了许多优化。
- en: So, Java bytecode is the intermediate representation between source code and
    machine code.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Java字节码是源代码和机器代码之间的中间表示。
- en: Note
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As a quick side bar: Java''s JIT compiler has enjoyed a great reputation over
    the years. But going back full circle to our introduction, it was John McCarthy
    that first wrote about JIT compilation way back in 1960\. So it''s interesting
    to think that it''s not just lambda support that was influenced by LISP. ([Aycock
    2003, 2\. JIT Compilation Techniques, 2.1 Genesis, p. 98](http://user.it.uu.se/~kostis/Teaching/KT2-04/jit_survey.pdf)).'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速的旁注：Java的JIT编译器多年来一直享有很好的声誉。但回到我们的介绍，是约翰·麦卡锡在1960年首次写了关于JIT编译的。因此，有趣的是，不仅lambda支持受到LISP的影响。
    ([Aycock 2003, 2. JIT Compilation Techniques, 2.1 Genesis, p. 98](http://user.it.uu.se/~kostis/Teaching/KT2-04/jit_survey.pdf))。
- en: The bytecode is the instruction set of the JVM. As it's name suggests, bytecode
    consists of single-byte instructions (called *opcodes*) along with associated
    bytes for parameters. There are therefore a possible 256 opcodes available although
    only about 200 are actually used.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码是JVM的指令集。顾名思义，字节码由单字节指令（称为*操作码*）以及与参数相关的字节组成。因此，可能有256个操作码可用，尽管实际使用的只有大约200个。
- en: The JVM uses a [stack based computation model](http://en.wikipedia.org/wiki/Model_of_computation),
    if we want to increment a number, we have to do it using the stack. All instructions
    or opcodes work against the stack.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 使用基于栈的计算模型，如果我们想要增加一个数字，必须使用栈来实现。所有指令或操作码都针对栈进行操作。
- en: So for example, 5 + 1 becomes 5 1 + where 5 is pushed to the stack,
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 所以例如，5 + 1 变成了 5 1 +，其中 5 被推入栈中，
- en: '![Bytecode recap](img/Push5.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![字节码概述](img/Push5.jpg)'
- en: 1 is pushed then...
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 1 被推入栈，然后...
- en: '![Bytecode recap](img/Push1.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![字节码概述](img/Push1.jpg)'
- en: the `+` operator is applied. Plus would pop the top two frames, add the numbers
    together and push the result back onto the stack. The result would look like this.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 应用了 `+` 运算符。加号会弹出栈顶的两个帧，将数字相加，然后将结果推回栈上。结果如下。
- en: '![Bytecode recap](img/iadd6.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
  zh: '![字节码概述](img/iadd6.jpg)'
- en: 'Each opcode works against the stack like this so we can translate our example
    into a sequence of Java bytecodes:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作码都像这样针对栈进行操作，所以我们可以将我们的示例转换为一系列 Java 字节码：
- en: '![Bytecode recap](img/Push5.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![字节码概述](img/Push5.jpg)'
- en: The `push 5` opcode becomes `iconst_5`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`push 5` 操作码变成了 `iconst_5`。'
- en: '![Bytecode recap](img/iconst1.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![字节码概述](img/iconst1.jpg)'
- en: 'The `push 1` opcode becomes `iconst_1`:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`push 1` 操作码变成了 `iconst_1`：'
- en: '![Bytecode recap](img/iconst_1_5.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![字节码概述](img/iconst_1_5.jpg)'
- en: and `add` becomes `iadd`.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 变成了 `iadd`。'
- en: '![Bytecode recap](img/iadd6.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![字节码概述](img/iadd6.jpg)'
- en: The `iconst_x` opcode and `iadd` opcode are examples of opcodes. Opcodes often
    have prefixes and/or suffices to indicate the types they work on, `i` in these
    examples refers to integer, `x` is an opcode specific suffix.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`iconst_x` 操作码和 `iadd` 操作码是操作码的示例。操作码通常具有前缀和/或后缀来指示它们作用的类型，在这些示例中，`i` 指的是整数，`x`
    是特定于操作码的后缀。'
- en: 'We can group the opcodes into the following categories:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将操作码分为以下几类：
- en: '| **Group** | **Examples** |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| **组** | **示例** |'
- en: '| Stack manipulation | `aload_n`, `istore`, `swap`, `dup2` |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| 栈操作 | `aload_n`, `istore`, `swap`, `dup2` |'
- en: '| Control flow instructions | `goto`, `ifeq`, `iflt` |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| 控制流指令 | `goto`, `ifeq`, `iflt` |'
- en: '| Object interactions | `new`, `invokespecial`, `areturn` |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| 对象交互 | `new`, `invokespecial`, `areturn` |'
- en: '| Arithmetic, logic and type conversion | `iadd`, `fcmpl`, `i2b` |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| 算术、逻辑和类型转换 | `iadd`, `fcmpl`, `i2b` |'
- en: Instructions concerned with stack manipulation, like `aload` and `istore`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 与栈操作有关的指令，如 `aload` 和 `istore`。
- en: To control program flow with things like if and while, we use opcodes like `goto`
    and if equal.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像 `goto` 和 if equal 这样的操作码来控制程序流程。
- en: Creating objects and accessing methods use codes like `new` and `invokespecial`.
    We'll be particularly interested in this group when we look at the different opcodes
    used to invoke lambdas.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象和访问方法使用像 `new` 和 `invokespecial` 这样的代码。当我们查看用于调用 lambda 表达式的不同操作码时，我们将特别关注这个组。
- en: The last group is about arithmetic, logic and type conversion and includes codes
    like `iadd`, float compare long (`fcmpl`) and integer to byte (`i2b`).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一组是关于算术、逻辑和类型转换的，包括像 `iadd`、float compare long (`fcmpl`) 和 integer to byte
    (`i2b`) 这样的代码。
- en: Descriptors
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符
- en: Opcodes will often use parameters, these look a little cryptic in the bytecode
    as they're usually referenced via lookup tables. Internally, Java uses what's
    called *descriptors* to describe these parameters.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 操作码通常会使用参数，它们在字节码中看起来有点晦涩，因为它们通常是通过查找表引用的。在内部，Java 使用所谓的 *描述符* 来描述这些参数。
- en: They describe types and signatures using a specific grammar you'll see throughout
    the bytecode. You'll often see the same grammar used in compiler or debug output,
    so it's useful to recap it here.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 它们使用特定的语法描述类型和签名，你将在整个字节码中看到这种语法。你经常会在编译器或调试输出中看到相同的语法，所以在这里回顾一下是有用的。
- en: Here's an example of a method signature descriptor.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个方法签名描述符的示例。
- en: '[PRE133]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: It's describing the constructor of a class called `$1`, which we happen to know
    is the JVM's name for the first anonymous class instance within another class.
    In this case `Example`. So we've got a constructor of an anonymous class that
    takes two parameters, an instance of the outer class `com.foo.Example` and an
    instance of `com.foo.Server`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 它描述了一个名为 `$1` 的类的构造函数，我们碰巧知道这是 JVM 对另一个类内第一个匿名类实例的命名。在这种情况下是 `Example`。所以我们有一个匿名类的构造函数，它接受两个参数，一个是外部类
    `com.foo.Example` 的实例，另一个是 `com.foo.Server` 的实例。
- en: Being a constructor, the method doesn't return anything. The `V` symbol represents
    void.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 作为构造函数，该方法不返回任何东西。`V` 符号表示 void。
- en: Have a look at breakdown of the descriptor syntax below. If you see an uppercase
    `Z` in a descriptor, it's referring to a boolean, an uppercase `B` a byte and
    so on.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的描述符语法的分解。如果在描述符中看到大写的 `Z`，它指的是布尔值，大写的 `B` 指的是字节，依此类推。
- en: '![Descriptors](img/descriptors.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![描述符](img/descriptors.jpg)'
- en: 'A couple of ones to mention:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些需要提到的：
- en: Classes are described with an uppercase `L` followed by the fully qualified
    class name, followed by a semi-colon. The class name is separated with slashes
    rather than the dots.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类使用大写的 `L` 描述，后面跟着完全限定的类名，然后是一个分号。类名使用斜杠而不是点来分隔。
- en: And arrays are described using an opening square bracket followed by a type
    from the list. No closing bracket.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组使用一个开放的方括号后跟列表中的类型来描述。没有闭合方括号。
- en: Converting a method signature
  id: totrans-518
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换方法签名
- en: 'Let''s take the following method signature and turn it into a method descriptor:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下方法签名转换为方法描述符：
- en: '[PRE134]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The method returns a `long`, so we describe the fact that it is a method with
    brackets and that it returns a `long` with a uppercase `J`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个 `long`，所以我们用括号描述它是一个方法，返回一个大写的 `J`。
- en: '[PRE135]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The first argument is of type `int`, so we use an uppercase `I`.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是 `int` 类型，所以我们使用大写的 `I`。
- en: '[PRE136]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The next argument is an object, so we use `L` to describe it's an object, fully
    qualify the name and close it with a semi-colon.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个参数是一个对象，所以我们使用 `L` 来描述它是一个对象，完全限定名称并用分号关闭。
- en: '[PRE137]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The last argument is an integer array so we drop in the array syntax followed
    by `int` type:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个参数是整数数组，所以我们插入数组语法，然后是 `int` 类型：
- en: '[PRE138]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: and we're done. A JVM method descriptor.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们完成了。一个 JVM 方法描述符。
- en: Code examples
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码示例
- en: Lets have a look at the bytecode produced for some examples.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下一些示例生成的字节码。
- en: We're going to look at the bytecode for four distinct blocks of functionality
    based on the example we looked at in `lambdas vs closures` section.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据我们在“lambda vs闭包”部分中看到的示例，查看四个不同功能块的字节码。
- en: 'We''ll explore:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨：
- en: A simple anonymous class.
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简单的匿名类。
- en: An anonymous class closing over some variable (an old style closure).
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个匿名类关闭某些变量（旧样式闭包）。
- en: A lambda with no arguments.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有参数的lambda。
- en: A lambda with arguments.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 带参数的lambda。
- en: A lambda closing over some variable (a new style closure).
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 闭包覆盖某些变量的lambda（新样式闭包）。
- en: The example bytecode was generated using the `javap` command line tool. Only
    partial bytecode listings are shown in this section, for full source and bytecode
    listings, see `Appendix A`. Also, fully qualified class names have been shortened
    to better fit on the page.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 示例字节码是使用`javap`命令行工具生成的。本节仅显示了部分字节码列表，完整的源代码和字节码列表请参见`附录A`。此外，完全限定的类名已经被缩短以更好地适应页面。
- en: Example 1
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例1
- en: The first example is a simple anonymous class instance passed into our `waitFor`
    method.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例是一个简单的匿名类实例，传递给我们的`waitFor`方法。
- en: '[PRE139]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: If we look at the bytecode below, the thing to notice is that an instance of
    the anonymous class is newed up at line 6\. The `#2` refers to a lookup, the result
    of which is shown in the comment. So it uses the `new` opcode with whatever is
    at `#2` in the constant pool, this happens to be the anonymous class `Example$1`.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下下面的字节码，要注意的是匿名类的一个实例在第6行被新建。`#2`是一个查找，其结果显示在注释中。因此，它使用`new`操作码与常量池中的`#2`进行操作，这恰好是匿名类`Example$1`。
- en: '[PRE140]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Once created, the constructor is called using `invokespecial` on line 9\. This
    opcode is used to call constructor methods, private methods and accessible methods
    of a super class. You might notice the method descriptor includes a reference
    to `Example1`. All anonymous class instances have this implicit reference to the
    parent class.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，使用`invokespecial`在第9行调用构造函数。这个操作码用于调用构造方法、私有方法和超类的可访问方法。您可能会注意到方法描述符包括对`Example1`的引用。所有匿名类实例都有对父类的这个隐式引用。
- en: The next step uses `invokestatic` to call our `waitFor` method passing in the
    anonymous class on line 10\. The  `invokestatic` opcode is used to call static
    methods and is very fast as it can direct dial a method rather than figure out
    which to call as would be the case in an object hierarchy.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步使用`invokestatic`调用我们的`waitFor`方法，传递匿名类在第10行。`invokestatic`操作码用于调用静态方法，非常快速，因为它可以直接拨号方法，而不是像在对象层次结构中那样找出要调用的方法。
- en: Example 2
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例2
- en: 'The `Example 2` class is another anonymous class but this time it closes over
    the server variable. It''s an old style closure:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '`Example 2`类是另一个匿名类，但这次它关闭了`server`变量。这是一种旧式的闭包：'
- en: '[PRE141]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The bytecode is similar to the previous except that an instance of the `Server`
    class is newed up (at line 3.) and it's constructor called at line 5\. The instance
    of the anonymous class `$1` is still constructed with `invokespecial` (at line
    11.) but this time it takes the instance of `Server` as an argument as well as
    the instance of the calling class.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 字节码与之前类似，只是`Server`类的一个实例被新建（在第3行），并且在第5行调用了它的构造函数。匿名类`$1`的实例仍然是用`invokespecial`构造的（在第11行），但这次它除了调用类的实例外，还将`Server`的实例作为参数。
- en: 'To close over the server variable, it''s passed directly into the anonymous
    class:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 为了关闭`server`变量，它直接传递给匿名类：
- en: '[PRE142]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Example 3
  id: totrans-553
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例3
- en: The `Example 3` class uses a Java lambda with our `waitFor` method. The lambda
    doesn't do anything other than return true. It's equivalent to example 1.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`Example 3`类使用了一个Java lambda与我们的`waitFor`方法。这个lambda除了返回true之外什么也不做。它相当于示例1。'
- en: '[PRE143]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The bytecode is super simple this time. It uses the `invokedynamic` opcode to
    create the lambda at line 3 which is then passed to the `invokestatic` opcode
    on the next line.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这次字节码非常简单。它使用`invokedynamic`操作码在第3行创建lambda，然后将其传递给下一行的`invokestatic`操作码。
- en: '[PRE144]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The descriptor for the `invokedynamic` call is targeting the `isSatisfied` method
    on the `Condition` interface (line 3.).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokedynamic`调用的描述符针对`Condition`接口的`isSatisfied`方法（第3行）。'
- en: What we're not seeing here is the mechanics of `invokedynamic`. The `invokedynamic`
    opcode is a new opcode to Java 7, it was intended to provide better support for
    dynamic languages on the JVM. It does this by not linking the types to methods
    until run-time. The other "invoke" opcodes all resolve types at compile time.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看不到`invokedynamic`的机制。`invokedynamic`操作码是Java 7的新操作码，旨在为JVM上的动态语言提供更好的支持。它通过直到运行时才将类型链接到方法来实现这一点。其他“invoke”操作码都在编译时解析类型。
- en: For lambdas, this means that placeholder method invocations can be put into
    the bytecode like we've just seen and working out the implementation can be done
    on the JVM at runtime.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 对于lambda来说，这意味着占位符方法调用可以像我们刚刚看到的那样放入字节码中，并且实现可以在JVM上在运行时完成。
- en: If we look at a more verbose bytecode that includes the constant pool we can
    dereference the lookups. For example, if we look up number 2, we can see it references
    `#0` and `#26`.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看包含常量池的更详细的字节码，我们可以解除查找。例如，如果我们查找编号2，我们可以看到它引用了`#0`和`#26`。
- en: '[PRE145]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The constant `0` is in a special lookup table for bootstrapping methods (line
    6). It refers to a static method call to the JDK `LambdaMetafactory` to create
    the lambda. This is where the heavy lifting goes on. All the target type inference
    to adapt types and any partial argument evaluation goes on here.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 常量`0`在一个特殊的查找表中用于引导方法（第6行）。它引用了对JDK `LambdaMetafactory`的静态方法调用，以创建lambda。这就是繁重的工作所在。所有目标类型推断以适应类型和任何部分参数评估都在这里进行。
- en: The actual lambda is shown as a method handle called `lambda$example$25` (line
    12) with no arguments, returning a boolean. It's invoked using `invokestatic`
    which shows that it's accessed as a genuine function; there's no object associated
    with it. There's also no implicit reference to a containing class unlike the anonymous
    examples before.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的lambda显示为一个名为`lambda$example$25`的方法句柄（第12行），没有参数，返回一个布尔值。它使用`invokestatic`调用，这表明它被视为一个真正的函数；它没有与之关联的对象。与之前的匿名示例不同，它也没有对包含类的隐式引用。
- en: It's passed into the `LambdaMetafactory` and we know it's a method handle by
    looking it up in the constant pool. The number of the lambda is compiler assigned
    and just increments from zero for each lambda required.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 它被传递到`LambdaMetafactory`，我们知道它是一个方法句柄，通过在常量池中查找它。lambda的编号由编译器分配，并且对于每个需要的lambda，它只是从零递增。
- en: '[PRE146]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Example 4
  id: totrans-567
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例4
- en: The `Example 4` class is another lambda but this time it takes an instance of
    `Server` as an argument. It's equivalent in functionality to example 2 but it
    doesn't close over the variable; it's not a closure.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '`Example 4`类是另一个lambda，但这次它以`Server`的实例作为参数。它在功能上等同于示例2，但它不会闭包变量；它不是一个闭包。'
- en: '[PRE147]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Just like example 2, the bytecode has to create the instance of server but this
    time, the `invokedynamic` opcode references the `test` method of type `Predicate`.
    If we were to follow the reference (`#4`) to the boostrap methods table, we would
    see the actual lambda requires an argument of type `HttpServer` and returns a
    `Z` which is a primitive boolean.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 就像示例2一样，字节码必须创建服务器的实例，但这次，`invokedynamic`操作码引用了`Predicate`类型的`test`方法。如果我们按照引用（`＃4`）到引导方法表，我们会看到实际的lambda需要一个`HttpServer`类型的参数，并返回一个`Z`，这是一个原始布尔值。
- en: '[PRE148]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: So the call to the lambda is still a static method call like before but this
    time takes the variable as a parameter when it's invoked.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对lambda的调用仍然是静态方法调用，但这次在调用时将变量作为参数传递。
- en: Example 4 (with method reference)
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例4（使用方法引用）
- en: Interestingly, if we use a method reference instead, the functionality is exactly
    the same but we get different bytecode.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果我们使用方法引用，功能完全相同，但得到的字节码不同。
- en: '[PRE149]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Via the call to `LambdaMetafactory` when the final execution occurs, `method_reference`
    results in a call to `invokevirtual` rather than `invokestatic`. The `invokevirtual`
    opcode is used to call public, protected an package protected methods so it implies
    an instance is required. The instance is supplied to the `metafactory` method
    and no lambda (or static function) is needed at all; there are no `lambda$` in
    this bytecode.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对`LambdaMetafactory`的调用，当最终执行发生时，`method_reference`会导致调用`invokevirtual`而不是`invokestatic`。`invokevirtual`操作码用于调用公共、受保护和包保护方法，因此需要一个实例。实例由`metafactory`方法提供，根本不需要lambda（或静态函数）；在这个字节码中没有`lambda$`。
- en: '[PRE150]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Example 5
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例5
- en: Lastly, example 5 uses a lambda but closes over the server instance. It's equivalent
    to example 2 and is a new style closure.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，示例5使用lambda，但是闭包了服务器实例。它等同于示例2，是一种新的样式闭包。
- en: '[PRE151]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: It goes through the basics in the same way as the other lambdas but if we lookup
    the `metafactory` method in the bootstrap methods table, you'll notice that this
    time, the lambda's method handle has an argument of type `Server`. It's invoked
    using `invokestatic` (line 9) and the variable is passed directly into the lambda
    at invocation time.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 它以与其他lambda相同的方式介绍了基础知识，但是如果在引导方法表中查找`metafactory`方法，您会注意到这次lambda的方法句柄具有`Server`类型的参数。它使用`invokestatic`（第9行）调用，并且变量在调用时直接传递到lambda中。
- en: '[PRE152]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: So like the anonymous class in example 2, an argument is added by the compiler
    to capture the term although this time, it's a method argument rather than a constructor
    argument.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就像示例2中的匿名类一样，编译器添加了一个参数来捕获该术语，但这次是方法参数而不是构造函数参数。
- en: Summary
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We saw how using an anonymous class will create a new instance and call it's
    constructor with `invokespecial`.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到使用匿名类将创建一个新实例，并使用`invokespecial`调用它的构造函数。
- en: We saw anonymous classes that close over variables have an extra argument on
    their constructor to capture that variable.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到闭包变量的匿名类在其构造函数上有一个额外的参数，用于捕获该变量。
- en: And we saw how Java lambdas use the `invokedynamic` instruction to defer binding
    of the types and that a special `lambda$` method handle is used to actually represent
    the lambda. This method handle has no arguments in this case and is invoked using
    `invokestatic` making it a genuine function.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到Java lambda使用`invokedynamic`指令来推迟类型的绑定，并且特殊的`lambda$`方法句柄用于实际表示lambda。在这种情况下，该方法句柄没有参数，并且使用`invokestatic`调用它，使其成为真正的函数。
- en: The lambda was created by the `LambdaMetafactory` class which itself was the
    target of the `invokedynamic` call.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: lambda是由`LambdaMetafactory`类创建的，它本身是`invokedynamic`调用的目标。
- en: When a lambda has arguments, we saw how the `LambdaMetafactory` describes the
    argument to be passed into the lambda. The `invokestatic` opcode is used to execute
    the lambda like before. But we also had a look at a method reference used in-lieu
    of a lambda. In this case, no `lambda$` method handle was created and `invokevirtual`
    was used to call the method directly.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 当lambda有参数时，我们看到`LambdaMetafactory`描述要传递到lambda中的参数。`invokestatic`操作码用于执行lambda，就像以前一样。但我们还看了一个方法引用，代替lambda。在这种情况下，没有创建`lambda$`方法句柄，而是使用`invokevirtual`直接调用方法。
- en: Lastly, we looked at a lambda that closes over a variable. This one creates
    an argument on the `lambda$` method handle and again is called with `invokestatic`.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了一个闭包变量的lambda。这个创建了一个`lambda$`方法句柄上的参数，并且再次使用`invokestatic`调用。
