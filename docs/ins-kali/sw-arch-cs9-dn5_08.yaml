- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Interacting with Data in C# – Entity Framework Core
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中与数据交互-Entity Framework Core
- en: 'As we mentioned in *Chapter 5*, *Applying a Microservice Architecture to Your
    Enterprise Application*, software systems are organized into layers, and each
    layer communicates with the previous and next layers through interfaces that don''t
    depend on how the layer is implemented. When the software is a business/enterprise
    system, it usually contains at least three layers: the data layer, the business
    layer, and the presentation layer. In general, the interface that''s offered by
    each layer and the way the layer is implemented depends on the application.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第5章*中提到的，*将微服务架构应用于企业应用程序*，软件系统被组织成层，每一层通过接口与前后层通信，这些接口不依赖于层的实现方式。当软件是一个商业/企业系统时，通常至少包含三层：数据层、业务层和表示层。一般来说，每一层提供的接口以及层的实现方式取决于应用程序。
- en: However, it turns out that the functionalities offered by data layers are quite
    standard, since they just map data from a data storage subsystem into objects
    and vice versa. This led to the conception of general-purpose frameworks for implementing
    data layers in a substantially declarative way. These tools are called **Object-Relational
    Mapping** (**ORM**) tools since they are data storage subsystems based on relational
    databases. However, they also work well with the modern non-relational storage
    classified as NoSQL databases (such as MongoDB and Azure Cosmos DB) since their
    data model is closer to the target object model than a purely relational model.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，事实证明，数据层提供的功能非常标准，因为它们只是将数据从数据存储子系统映射到对象，反之亦然。这导致了以一种实质性的声明方式实现数据层的通用框架的构想。这些工具被称为**对象关系映射**（**ORM**）工具，因为它们是基于关系数据库的数据存储子系统。然而，它们也可以很好地与现代的非关系存储（如MongoDB和Azure
    Cosmos DB）一起使用，因为它们的数据模型更接近目标对象模型，而不是纯粹的关系模型。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding ORM basics
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解ORM基础知识
- en: Configuring Entity Framework Core
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Entity Framework Core
- en: Entity Framework Core migrations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entity Framework Core迁移
- en: Querying and updating data with Entity Framework Core
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Entity Framework Core查询和更新数据
- en: Deploying your data layer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署您的数据层
- en: Understanding Entity Framework Core advanced features – global filters
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Entity Framework Core高级功能-全局过滤器
- en: This chapter describes ORMs and how to configure them, and then focuses on Entity
    Framework Core, the ORM included in .NET 5.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了ORM以及如何配置它们，然后重点介绍了Entity Framework Core，这是.NET 5中包含的ORM。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the free Visual Studio 2019 Community edition or better
    with all the database tools installed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要免费的Visual Studio 2019社区版或更高版本，并安装了所有数据库工具。
- en: All the concepts in this chapter will be clarified with practical examples based
    on the WWTravelClub book use case. You will find the code for this chapter at
    [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有概念都将通过基于WWTravelClub书籍用例的实际示例进行澄清。您可以在[https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5)找到本章的代码。
- en: Understanding ORM basics
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解ORM基础知识
- en: ORMs map relational DB tables into in-memory collections of objects where object
    properties correspond to DB table fields. Types from C#, such as Booleans, numeric
    types, and strings, have corresponding DB types. If GUIDs are not available in
    the mapped database, then types such as GUIDs are mapped to their equivalent string
    representations. All date and time types are mapped either to C# `DateTime` when
    date/time contains no time zone information or to `DateTimeOffset` when date/time
    also contains explicit time zone information. Any DB time duration is mapped to
    a `TimeSpan`. Finally, single characters should not be mapped at all to DB fields.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ORM将关系数据库表映射为内存中的对象集合，其中对象属性对应于数据库表字段。来自C#的类型，如布尔值、数字类型和字符串，都有对应的数据库类型。如果映射的数据库中没有GUID，则诸如GUID之类的类型将映射到它们的等效字符串表示。所有日期和时间类型都映射到C#的`DateTime`，当日期/时间不包含时区信息时，或者映射到`DateTimeOffset`，当日期/时间还包含显式时区信息时。任何数据库时间持续时间都映射到`TimeSpan`。最后，单个字符根本不应该映射到数据库字段。
- en: Since the string properties of most object-oriented languages have no length
    limits associated with them (while DB string fields usually have length limits),
    the DB limits are taken into account in the DB mapping configuration. In general,
    when the mapping between DB types and object-oriented language types needs options
    to be specified, these options are declared in the mapping configuration.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数面向对象语言的字符串属性没有与之关联的长度限制（而数据库字符串字段通常有长度限制），因此在数据库映射配置中考虑了数据库限制。一般来说，当需要指定数据库类型和面向对象语言类型之间的映射时，这些选项都在映射配置中声明。
- en: 'The way the whole configuration is defined depends on the specific ORM. Entity
    Framework Core offers three options:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 整个配置的定义方式取决于具体的ORM。Entity Framework Core提供了三种选项：
- en: Data annotations (property attributes)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据注释（属性注释）
- en: Name conventions
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称约定
- en: A fluent configuration interface based on configuration objects and methods
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于配置对象和方法的流畅配置接口
- en: While the fluent interface can be used to specify any configuration option,
    the data annotations and name conventions can be used for a smaller subset of
    them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然流畅接口可以用于指定任何配置选项，但数据注释和名称约定只能用于其中的一小部分。
- en: Personally, I prefer using the fluent interface for most settings. I use name
    conventions only for specifying the principal key with an ID property name, since
    I find that relying on name conventions also for more complex settings is very
    dangerous. In fact, there are no compilation-time checks on name conventions so
    a reengineering operation might erroneously change or destroy some ORM settings.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我更喜欢对大多数设置使用流畅的接口。我仅在指定具有ID属性名称的主键时使用名称约定，因为我发现仅依赖名称约定进行更复杂的设置也是非常危险的。实际上，名称约定上没有编译时检查，因此重新工程操作可能会错误地更改或破坏一些ORM设置。
- en: I use data annotations mainly for specifying constraints on the possible values
    of properties, such as the maximum length of a value, or the fact that a property
    is obligatory and can't be null. In fact, these constraints restrict the type
    specified in each property, so placing them next to the properties they are applied
    to increases the code's readability.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我主要使用数据注释来指定属性可能值的约束，例如值的最大长度，或者属性是必填的且不能为空。实际上，这些约束限制了每个属性中指定的类型，因此将它们放在应用的属性旁边可以增加代码的可读性。
- en: All other settings are better grouped and organized by using the fluent interface
    in order to increase code readability and maintainability.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加代码的可读性和可维护性，所有其他设置最好通过使用流畅的接口进行分组和组织。
- en: Each ORM adapts to a specific DB type (Oracle, MySQL, SQL Server, and so on)
    with DB-specific adapters called **providers** or **connectors**. Entity Framework
    Core has providers for most of the available DB engines.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ORM都适应于特定的DB类型（Oracle、MySQL、SQL Server等），具有称为**提供程序**或**连接器**的特定于DB的适配器。Entity
    Framework Core具有大多数可用DB引擎的提供程序。
- en: A complete list of providers can be found at [https://docs.microsoft.com/en-US/ef/core/providers/](https://docs.microsoft.com/en-US/ef/core/providers/).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://docs.microsoft.com/en-US/ef/core/providers/](https://docs.microsoft.com/en-US/ef/core/providers/)找到完整的提供程序列表。
- en: Adapters are necessary for the differences in DB types, for the way transactions
    are handled, and for all the other features that are not standardized by the SQL
    language.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器对于DB类型的差异、事务处理方式以及SQL语言未标准化的所有其他特性都是必需的。
- en: Relations among tables are represented with object pointers. For instance, in
    a one-to-many relationship, the class that's mapped to the *one* side of the relationship
    contains a collection that is populated with the related objects on the *many*
    side of the relationship. On the other hand, the class mapped to the *many* side
    of the relationship has a simple property that is populated with a uniquely related
    object on the *one* side of the relationship.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表之间的关系用对象指针表示。例如，在一对多关系中，映射到关系*一*方的类包含一个集合，该集合由关系*多*方上的相关对象填充。另一方面，映射到关系*多*方的类具有一个简单的属性，该属性由关系*一*方上的唯一相关对象填充。
- en: The whole database (or just a part of it) is represented by an in-memory cache
    class that contains a property for each collection that's mapped to a DB table.
    First, the query and update operations are performed on an instance of an in-memory
    cache class, and then this instance is synchronized with the database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 整个数据库（或其中的一部分）由一个内存缓存类表示，该类包含映射到DB表的每个集合的属性。首先，在内存缓存类的实例上执行查询和更新操作，然后将此实例与数据库同步。
- en: The in-memory cache class that's used by Entity Framework Core is called `DbContext`
    and it also contains the mapping configuration. More specifically, the application-specific
    in-memory cache class is obtained by inheriting `DbContext` and adding it to all
    the mapped collections and all the necessary configuration information.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core使用的内存缓存类称为`DbContext`，它还包含映射配置。更具体地说，通过继承`DbContext`并将其添加到所有映射集合和所有必要的配置信息中，可以获得特定于应用程序的内存缓存类。
- en: Summing up, `DbContext` subclass instances contain partial snapshots of the
    DB that are synchronized with the database to get/update the actual data.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，`DbContext`子类实例包含与数据库同步以获取/更新实际数据的DB的部分快照。
- en: DB queries are performed with a query language made of method calls on the collections
    of the in-memory cache class. The actual SQL is created and executed during the
    synchronization stage. For instance, Entity Framework Core performs **Language
    Integrated Queries** (**LINQ**) on the collections mapped to the DB tables.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在内存缓存类的集合上进行方法调用的查询语言执行DB查询。实际的SQL是在同步阶段创建和执行的。例如，Entity Framework Core在映射到DB表的集合上执行**语言集成查询**（**LINQ**）。
- en: 'In general, LINQ queries produce `IEnumerable` instances, that is, collections
    whose elements are not computed when `IEnumerable` is created at the end of the
    query, but when you actually attempt to retrieve the collection elements from
    `IEnumerable`. This is called lazy evaluation or deferred execution. It works
    as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，LINQ查询会产生`IEnumerable`实例，也就是说，在查询结束时创建`IEnumerable`时，集合的元素并不会被计算，而是当您尝试从`IEnumerable`中实际检索集合元素时才会计算。这称为延迟评估或延迟执行。它的工作方式如下：
- en: LINQ queries that start from a mapped collection of a `DbContext` create a specific
    subtype of `IEnumerable` called `IQueryable`.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`DbContext`的映射集合开始的LINQ查询会创建`IQueryable`的特定子类型。
- en: An `IQueryable` contains all the information that's needed to issue a query
    to the database, but the actual SQL is produced and executed when the first element
    of the `IQueryable` is retrieved.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IQueryable`包含发出对数据库查询所需的所有信息，但是当检索到`IQueryable`的第一个元素时，实际的SQL才会被生成和执行。'
- en: Typically, each Entity Framework query ends with a `ToList` or `ToArray` operation
    that transforms the `IQueryable` into a list or array, thereby causing the actual
    execution of the query on the database.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，每个Entity Framework查询都以`ToList`或`ToArray`操作结束，将`IQueryable`转换为列表或数组，从而导致在数据库上实际执行查询。
- en: If the query is expected to return just a single element or no element at all,
    we typically execute a `SingleOrDefault` operation that returns a single element,
    if any, or `null`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果查询预计只返回单个元素或根本没有元素，通常我们会执行一个`SingleOrDefault`操作，该操作返回一个元素（如果有的话）或`null`。
- en: Also, updates, deletions, and the addition of new entities to a DB table are
    performed by mimicking these operations on a `DbContext` collection property that
    represents the database table. However, entities may only be updated or deleted
    this way after they have been loaded in that memory collection by means of a query.
    An update query requires the in-memory representation of the entity to be modified
    as needed, while a delete query requires the in-memory representation of the entity
    to be removed from its in-memory mapped collection. In Entity Framework Core,
    the removal operation is performed by calling the `Remove(entity)` method of the
    collection.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过在表示数据库表的`DbContext`集合属性上模拟这些操作，也可以对DB表执行更新、删除和添加新实体。但是，只有在通过查询加载到内存集合中后，才能以这种方式更新或删除实体。更新查询需要根据需要修改实体的内存表示，而删除查询需要从其内存映射集合中删除实体的内存表示。在Entity
    Framework Core中，通过调用集合的`Remove(entity)`方法执行删除操作。
- en: The addition of a new entity has no further requirements. It is enough to add
    the new entity to the in-memory collection. Updates, deletions, and additions
    that are performed on various in-memory collections are actually passed to the
    database with an explicit call to a DB synchronization method.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新实体没有进一步的要求。只需将新实体添加到内存集合中即可。对各种内存集合进行的更新、删除和添加实际上是通过显式调用DB同步方法传递到数据库的。
- en: For instance, Entity Framework Core passes all the changes that are performed
    on a `DbContext` instance to the database when you call the `DbContext.SaveChanges()`
    method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当您调用`DbContext.SaveChanges()`方法时，Entity Framework Core会将在`DbContext`实例上执行的所有更改传递到数据库。
- en: Changes that are passed to the database during a synchronization operation are
    executed in a single transaction. Moreover, for ORMs, such as Entity Framework
    Core, that have an explicit representation of transactions, a synchronization
    operation is executed in the scope of a transaction, since it uses that transaction
    instead of creating a new one.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在同步操作期间传递到数据库的更改是在单个事务中执行的。此外，对于具有事务的显式表示的ORM（如Entity Framework Core），同步操作是在事务范围内执行的，因为它使用该事务而不是创建新事务。
- en: The remaining sections in this chapter explain how to use Entity Framework Core,
    along with some example code based on this book's WWTravelClub use case.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将解释如何使用Entity Framework Core，以及基于本书的WWTravelClub用例的一些示例代码。
- en: Configuring Entity Framework Core
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Entity Framework Core
- en: 'Since database handling is confined within a dedicated application layer, it
    is good practice to define your Entity Framework Core (`DbContext`) in a separate
    library. Accordingly, we need to define a .NET Core class library project. As
    we discussed in the *Book use case – understanding the main types of .NET Core
    projects* sections of *Chapter 2*, *Non-Functional Requirements*, we have two
    different kinds of library projects: **.NET Standard** and **.NET (Core)**.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库处理被限制在专用应用程序层中，因此最好的做法是在一个单独的库中定义您的Entity Framework Core（`DbContext`）。因此，我们需要定义一个.NET
    Core类库项目。正如我们在*第2章*的*书籍用例-理解.NET Core项目的主要类型*部分中讨论的那样，我们有两种不同类型的库项目：**.NET Standard**和**.NET
    (Core)**。
- en: While .NET Core libraries are tied to a specific .NET Core version, .NET Standard
    2.0 libraries have a wide range of applications since they work with any .NET
    version greater than 2.0 and also with the classical .NET Framework 4.7.2 and
    above.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然.NET Core库与特定的.NET Core版本相关联，但.NET Standard 2.0库具有广泛的应用范围，因为它们可以与大于2.0的任何.NET版本以及经典的.NET
    Framework 4.7.2及以上版本一起使用。
- en: However, version 5 of the `Microsoft.EntityFrameworkCore` package, which is
    the version that comes with .NET 5, depends just on .NET Standard 2.1\. This means
    that it is not designed to work with a specific .NET (Core) version but that it
    just requires a .NET Core version that supports .NET Standard 2.1\. Therefore,
    Entity Framework 5 works properly with .NET 5 and with any .NET Core version higher
    than or equal to 2.1.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Microsoft.EntityFrameworkCore`包的第5版，也就是随.NET 5一起发布的版本，仅依赖于.NET Standard
    2.1。这意味着它不是设计用于特定的.NET（Core）版本，而是只需要支持.NET Standard 2.1的.NET Core版本。因此，Entity
    Framework 5可以与.NET 5以及高于或等于2.1的任何.NET Core版本正常工作。
- en: 'Since our library is not a general-purpose library (it''s just a component
    of a specific .NET 5 application), instead of choosing a .NET Standard library
    project, we can simply choose a .NET 5 library. Our .NET 5 library project can
    be created and prepared as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的库不是通用库（它只是特定.NET 5应用程序的一个组件），所以我们可以选择.NET 5库而不是选择.NET Standard库项目。我们的.NET
    5库项目可以按以下方式创建和准备：
- en: Open Visual Studio and define a new solution named `WWTravelClubDB` and then
    select **Class Library (.NET Core)** for the latest .NET Core version available.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio并定义一个名为`WWTravelClubDB`的新解决方案，然后选择可用的最新.NET Core版本的**类库（.NET
    Core）**。
- en: We must install all Entity Framework Core-related dependencies. The simplest
    way to have all the necessary dependencies installed is to add the NuGet package
    for the provider of the database engine we are going to use – in our case, SQL
    Server – as we mentioned in *Chapter 4*, *Deciding the Best Cloud-Based Solution*.
    In fact, any provider will install all the required packages since it has all
    of them as dependencies. So, let's add the latest stable version of `Microsoft.EntityFrameworkCore.SqlServer`.
    If you plan to use several database engines, you can also add other providers
    since they can work side by side. Later in this chapter, we will install other
    NuGet packages that contain tools that we need to process our Entity Framework
    Core. Then, we will explain how to install further tools that are needed to process
    Entity Framework Core's configuration.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须安装所有与Entity Framework Core相关的依赖项。安装所有必要的依赖项的最简单方法是添加我们将要使用的数据库引擎提供程序的NuGet包
    - 在我们的情况下是SQL Server - 正如我们在*第4章*，*决定最佳基于云的解决方案*中提到的。实际上，任何提供程序都将安装所有所需的包，因为它们都作为依赖项。因此，让我们添加最新稳定版本的`Microsoft.EntityFrameworkCore.SqlServer`。如果您计划使用多个数据库引擎，还可以添加其他提供程序，因为它们可以并存。在本章的后面，我们将安装其他包含我们需要处理Entity
    Framework Core的工具的NuGet包。然后，我们将解释如何安装进一步需要处理Entity Framework Core配置的工具。
- en: Let's rename the default `Class1` class to `MainDbContext`. This was automatically
    added to the class library.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将默认的`Class1`类重命名为`MainDbContext`。这是自动添加到类库中的。
- en: 'Now, let''s replace its content with the following code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用以下代码替换其内容：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We inherit from `DbContext` and we are required to pass `DbContextOptions` to
    the `DbContext` constructor. `DbContextOptions` contains creation options such
    as the database connection string, which depends on the target DB engine.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继承自`DbContext`，并且需要将`DbContextOptions`传递给`DbContext`构造函数。`DbContextOptions`包含创建选项，如数据库连接字符串，这取决于目标数据库引擎。
- en: All the collections that have been mapped to database tables will be added as
    properties of `MainDbContext`. The mapping configuration will be defined inside
    of the overridden `OnModelCreating` method with the help of the `ModelBuilder`
    object passed as a parameter.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有映射到数据库表的集合将作为`MainDbContext`的属性添加。映射配置将在重写的`OnModelCreating`方法中使用传递的`ModelBuilder`对象来定义。
- en: The next step is the creation of all the classes that represent all the DB table
    rows. These are called **entities**. We need an entity class for each DB table
    we want to map. Let's create a `Models` folder in the project root for all of
    them. The next subsection explains how to define all the required entities.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建表示所有数据库表行的所有类。这些称为**实体**。我们需要为要映射的每个数据库表创建一个实体类。让我们在项目根目录下创建一个`Models`文件夹。下一小节将解释如何定义所有所需的实体。
- en: Defining DB entities
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义数据库实体
- en: 'DB design, like the whole application design, is organized in iterations. Let''s
    suppose that, in the first iteration, we need a prototype with two database tables:
    one for all the travel packages and another one for all the locations referenced
    by the packages. Each package covers just one location, while a single location
    may be covered by several packages, so the two tables are connected by a one-to-many
    relationship.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设计，就像整个应用程序设计一样，是按迭代进行的。假设在第一次迭代中，我们需要一个包含两个数据库表的原型：一个用于所有旅行套餐，另一个用于所有套餐引用的位置。每个套餐只涵盖一个位置，而单个位置可能被多个套餐涵盖，因此这两个表通过一对多的关系相连。
- en: 'So, let''s start with the location database table. As we mentioned at the end
    of the previous section, we need an entity class to represent the rows of this
    table. Let''s call `Destination` the entity class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从位置数据库表开始。正如我们在上一节末尾提到的，我们需要一个实体类来表示这个表的行。让我们称实体类为`Destination`：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All the DB fields must be represented by read/write C# properties. Suppose that
    each destination is something like a town or a region that can be defined by just
    its name and the country it is in, and that all the relevant information is contained
    in its `Description`. In future iterations, we will probably add several more
    fields. `Id` is an auto-generated key.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据库字段必须由可读/写的C#属性表示。假设每个目的地都类似于一个城镇或地区，可以通过其名称和所在国家来定义，并且所有相关信息都包含在其`Description`中。在将来的迭代中，我们可能会添加几个字段。`Id`是自动生成的键。
- en: However, now, we need to add information about how all the fields are mapped
    to DB fields. In Entity Framework Core, all the primitive types are mapped automatically
    to DB types by the DB engine-specific provider that's used (in our case, the SQL
    Server provider).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在，我们需要添加关于如何将所有字段映射到数据库字段的信息。在Entity Framework Core中，所有基本类型都会自动映射到数据库类型，由所使用的数据库引擎特定提供程序（在我们的情况下是SQL
    Server提供程序）。
- en: 'Our only preoccupations are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一的担忧是：
- en: '**Length limits on the string**: They can be taken into account by applying
    adequate `MaxLength` and `MinLength` attributes to each string property. All the
    attributes that are useful for the entity''s configuration are contained in the
    `System.ComponentModel.DataAnnotations` and `System.ComponentModel.DataAnnotations.Schema`
    namespaces. Therefore, it''s good practice to add both of them to all the entity
    definitions.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的长度限制：可以通过为每个字符串属性应用适当的`MaxLength`和`MinLength`属性来考虑。所有对实体配置有用的属性都包含在`System.ComponentModel.DataAnnotations`和`System.ComponentModel.DataAnnotations.Schema`命名空间中。因此，最好将它们都添加到所有实体定义中。
- en: '**Specifying which fields are obligatory and which ones are optional**: If
    the project is not using the new Nullable Reference Type feature, by default,
    all the reference types (such as all the strings) are assumed to be optional,
    while all the value types (numbers and GUIDs, for instance) are assumed to be
    obligatory. If we want a reference type to be obligatory, then we must decorate
    it with the `Required` attribute. On the other side, if we want a `T` type property
    to be optional, and `T` is a value type or the Nullable Reference Type feature
    is on, then we must replace `T` with `T?`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定哪些字段是必填的，哪些是可选的**：如果项目没有使用新的可空引用类型功能，默认情况下，所有引用类型（例如所有字符串）都被假定为可选的，而所有值类型（例如数字和GUID）都被假定为必填的。如果我们希望引用类型是必填的，那么我们必须用`Required`属性进行修饰。另一方面，如果我们希望`T`类型的属性是可选的，并且`T`是值类型或者可空引用类型功能已经开启，那么我们必须用`T?`替换`T`。'
- en: '**Specifying which property represents the primary key**: The key may be specified
    by decorating a property with the `Key` attribute. However, if no `Key` attribute
    is found, a property named `Id` (if there is one) is taken as the primary key.
    In our case, there is no need for the `Key` attribute.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指定哪个属性代表主键**：可以通过用`Key`属性修饰属性来指定主键。然而，如果没有找到`Key`属性，那么名为`Id`的属性（如果有的话）将被视为主键。在我们的情况下，不需要`Key`属性。'
- en: Since each destination is on the *one* side of a one-to-many relationship, it
    must contain a collection for the related package entities; otherwise, we will
    not be able to refer to the related entities in the clauses of our LINQ queries.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个目的地都在一对多关系的*一*侧，它必须包含一个与相关包实体相关的集合；否则，我们将无法在LINQ查询的子句中引用相关实体。
- en: 'Putting everything together, the final version of the `Destination` class is
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一起，`Destination`类的最终版本如下：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since the `Description` property has no length limits, it will be implemented
    with a SQL Server `nvarchar(MAX)` field of indefinite length. We can write the
    code for the `Package` class in a similar way:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Description`属性没有长度限制，它将以SQL Server `nvarchar(MAX)`字段的无限长度实现。我们可以以类似的方式编写`Package`类的代码：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each package has a duration in days, as well as optional start and stop dates
    in which the package offer is valid. `MyDestination` connects packages with their
    destinations in the many-to-one relationship that they have with the `Destination`
    entity, while `DestinationId` is the external key of the same relation.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包都有一个持续时间（以天为单位），以及可选的开始和结束日期，其中包的优惠有效。`MyDestination`将包与它们与`Destination`实体的多对一关系连接起来，而`DestinationId`是同一关系的外键。
- en: While it is not obligatory to specify the external key, it is good practice
    to do so since this is the only way to specify some properties of the relationship.
    For instance, in our case, since `DestinationId` is an `int` (value type), it
    is obligatory. Therefore, the relationship here is one-to-many and not (0, 1)-to-many.
    Defining `DestinationId` as `int?`, instead of `int`, would turn the one-to-many
    relationship into a (0, 1)-to-many relationship. Moreover, as we will see later
    on in this chapter, having an explicit representation of the foreign key simplifies
    the update operations a lot, and some queries.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是必须指定外键，但这是一个好习惯，因为这是唯一指定关系的一些属性的方法。例如，在我们的情况下，由于`DestinationId`是一个`int`（值类型），它是必填的。因此，这里的关系是一对多，而不是（0,1）-对多。将`DestinationId`定义为`int?`，而不是`int`，会将一对多关系转变为（0,1）-对多关系。此外，正如我们将在本章后面看到的那样，有一个外键的显式表示大大简化了更新操作和一些查询。
- en: In the next section, we will explain how to define the in-memory collection
    that represents the database tables.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释如何定义表示数据库表的内存集合。
- en: Defining the mapped collections
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义映射集合
- en: 'Once we have defined all the entities that are object-oriented representations
    of the database rows, we need to define the in-memory collections that represent
    the database tables themselves. As we mentioned in the *Understanding ORM basics*
    section, all the database operations are mapped to the operations on these collections
    (the *Querying and updating data with Entity Framework Core* section of this chapter
    explains how). It is enough to add a `DbSet<T>` collection property to our `DbContext`
    for each entity, `T`. Usually, the name of each of these properties is obtained
    by pluralizing the entity name. Thus, we need to add the following two properties
    to our `MainDbContext`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了所有的实体，它们就是数据库行的面向对象表示，我们需要定义表示数据库表本身的内存集合。正如我们在*理解ORM基础*部分中提到的，所有数据库操作都映射到这些集合上的操作（本章的*使用Entity
    Framework Core查询和更新数据*部分将解释如何）。对于每个实体`T`，只需在我们的`DbContext`中添加一个`DbSet<T>`集合属性即可。通常，每个属性的名称是通过将实体名称变为复数形式得到的。因此，我们需要将以下两个属性添加到我们的`MainDbContext`中：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Up until now, we've translated database stuff into properties, classes, and
    data annotations. However, Entity Framework needs further information to interact
    with a database. The next subsection explains how to provide it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将数据库内容翻译成属性、类和数据注释。然而，Entity Framework需要更多信息来与数据库交互。下一小节将解释如何提供这些信息。
- en: Completing the mapping configuration
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成映射配置
- en: 'The mapping configuration information that we couldn''t specify in the entity
    definitions must be added in the `OnModelCreating DbContext` method. Each configuration
    information relative to an entity, `T`, starts with `builder.Entity<T>()` and
    continues with a call to a method that specifies that kind of constraint. Further
    nested calls specify further properties of the constraint. For instance, our one-to-many
    relationship may be configured as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法在实体定义中指定的映射配置信息必须在`OnModelCreating DbContext`方法中添加。每个与实体`T`相关的配置信息都以`builder.Entity<T>()`开头，并继续调用指定该约束类型的方法。进一步嵌套调用指定约束的更多属性。例如，我们的一对多关系可以配置如下：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The two sides of the relationship are specified through the navigation properties
    that we added to our entities. `HasForeignKey` specifies the external key. Finally,
    `OnDelete` specifies what to do with packages when a destination is deleted. In
    our case, it performs a cascade delete of all the packages related to that destination.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 关系的两侧是通过我们添加到实体的导航属性来指定的。`HasForeignKey`指定外部键。最后，`OnDelete`指定了在删除目标时要执行的操作。在我们的情况下，它执行了与该目的地相关的所有包的级联删除。
- en: 'The same configuration can be defined by starting from the other side of the
    relationship, that is, starting with `builder.Entity<Package>()`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过从关系的另一侧开始定义相同的配置，也就是从`builder.Entity<Package>()`开始：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The only difference is that the previous statement''s `HasMany-WithOne` methods
    are replaced by the `HasOne-WithMany` methods since we started from the other
    side of the relationship. Here we can also choose the precision with which each
    decimal property is represented in its mapped database field. As a default, decimals
    are represented by 18 digits and 2 decimals. You can change this setting for each
    property with something like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是前面语句的`HasMany-WithOne`方法被`HasOne-WithMany`方法替换，因为我们是从关系的另一侧开始的。在这里，我们还可以选择每个小数属性在其映射的数据库字段中表示的精度。默认情况下，小数由18位和2位小数表示。您可以使用类似以下内容为每个属性更改此设置：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `ModelBuilder builder` object allows us to specify database indexes with
    something such as the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ModelBuilder builder`对象允许我们使用以下内容指定数据库索引：'
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Multi-property indexes are defined as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 多属性索引定义如下：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Starting from version 5 indexes can also be defined with attributes applied
    to the class. Following is the case of a single property index:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本5开始，索引也可以通过应用于类的属性来定义。以下是单属性索引的情况：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Following is the case of a multi-property index:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是多属性索引的情况：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we add all the necessary configuration information, then our `OnModelCreating`
    method will look as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加了所有必要的配置信息，那么我们的`OnModelCreating`方法将如下所示：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The previous example show a one-to-many relation, but Entity Framework Core
    5 also supports many-to-many relations:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例展示了一对多关系，但Entity Framework Core 5也支持多对多关系：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding case, the join entity and the database join table are created
    automatically, but you can also specify an existing entity as the join entity.
    In the previous example, the join entity might be the course that the teacher
    teaches in each classroom:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，联接实体和数据库联接表是自动创建的，但您也可以指定现有实体作为联接实体。在前面的示例中，联接实体可能是老师在每个教室教授的课程：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once you've configured Entity Framework Core, we can use all the configuration
    information we have to create the actual database and put all the tools we need
    in place in order to update the database's structure as the application evolves.
    The next section explains how.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦配置了Entity Framework Core，我们可以使用所有配置信息来创建实际的数据库，并在应用程序发展过程中放置所有需要的工具，以便更新数据库的结构。下一节将解释如何进行。
- en: Entity Framework Core migrations
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Entity Framework Core迁移
- en: Now that we've configured Entity Framework and defined our application-specific
    `DbContext` subclass, we can use the Entity Framework Core design tools to generate
    the physical database and create the database structure snapshot that's needed
    by Entity Framework Core to interact with the database.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了Entity Framework并定义了特定于应用程序的`DbContext`子类，我们可以使用Entity Framework Core设计工具来生成物理数据库，并创建Entity
    Framework Core与数据库交互所需的数据库结构快照。
- en: 'Entity Framework Core design tools must be installed in each project that needs
    them as NuGet packages. There are two equivalent options:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个需要它们的项目中必须安装Entity Framework Core设计工具作为NuGet包。有两个等效的选项：
- en: '**Tools that work in any Windows console**: These are available through the
    `Microsoft.EntityFrameworkCore.Design` NuGet package. All Entity Framework Core
    commands are in `dotnet ef .....` format since they are contained in the `ef`
    command line''s .NET Core application.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适用于任何Windows控制台的工具**：这些工具通过`Microsoft.EntityFrameworkCore.Design` NuGet包提供。所有Entity
    Framework Core命令都以`dotnet ef .....`格式，因为它们包含在`ef`命令行的.NET Core应用程序中。'
- en: '**Tools that are specific to the Visual Studio Package Manager Console**: These
    are contained in the `Microsoft.EntityFrameworkCore.Tools` NuGet package. They
    don''t need the `dotnet ef` prefix since they can only be launched from the **Package
    Manager Console** inside of Visual Studio.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**专门用于Visual Studio Package Manager控制台的工具**：这些工具包含在`Microsoft.EntityFrameworkCore.Tools`
    NuGet包中。它们不需要`dotnet ef`前缀，因为它们只能从Visual Studio内的**Package Manager Console**中启动。'
- en: 'Entity Framework Core''s design tools are used within the design/update procedure.
    This procedure is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core的设计工具在设计/更新过程中使用。该过程如下：
- en: We modify `DbContext` and entities' definitions as needed.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要修改`DbContext`和实体的定义。
- en: We launch the design tools to ask Entity Framework Core to detect and process
    all the changes we made.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们启动设计工具，要求Entity Framework Core检测和处理我们所做的所有更改。
- en: Once launched, the design tools update the database structure snapshot and generate
    a new *migration*, that is, a file containing all the instructions we need in
    order to modify the physical database to reflect all the changes we made.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦启动，设计工具将更新数据库结构快照并生成一个新的*迁移*，即一个包含我们需要的所有指令的文件，以便修改物理数据库以反映我们所做的所有更改。
- en: We launch another tool to update the database with the newly created migration.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们启动另一个工具来使用新创建的迁移更新数据库。
- en: We test the newly configured DB layer and, if new changes are necessary, we
    go back to *step 1*.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们测试新配置的DB层，如果需要新的更改，我们回到*步骤1*。
- en: When the data layer is ready, it is deployed in staging or production, where
    all the migrations are applied once more to the actual staging/production database.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当数据层准备就绪时，它被部署到暂存或生产环境中，所有迁移再次应用到实际的暂存/生产数据库。
- en: This is repeated several times in the various software project iterations and
    during the lifetime of the application.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这在各种软件项目迭代和应用程序的生命周期中会重复多次。
- en: If we operate on an already existing database, we need to configure `DbContext`
    and its models to reflect the existing structure of all the tables we want to
    map. Then, if we want to start using migration instead of continuing with direct
    database changes, we can call the design tools with the `IgnoreChanges` option
    so that they generate an empty migration. Also, this empty migration must be passed
    to the physical database so that it can synchronize a database structure version
    associated with the physical database with the version that's been recorded in
    the database snapshot. This version is important because it determines which migrations
    must be applied to a database and which ones have already been applied.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们操作的是已经存在的数据库，我们需要配置`DbContext`及其模型，以反映我们想要映射的所有表的现有结构。然后，如果我们想要开始使用迁移而不是继续进行直接的数据库更改，我们可以调用设计工具，并使用`IgnoreChanges`选项，以便它们生成一个空迁移。此外，这个空迁移必须传递给物理数据库，以便它可以将与物理数据库关联的数据库结构版本与数据库快照中记录的版本进行同步。这个版本很重要，因为它决定了哪些迁移必须应用到数据库，哪些已经应用了。
- en: 'The whole design process needs a test/design database and, if we operate on
    an existing database, the structure of this test/design database must reflect
    the actual database – at least in terms of the tables we want to map. To enable
    design tools so that we can interact with the database, we must define the `DbContextOptions`
    options that they pass to the `DbContext` constructor. These options are important
    at design time since they contain the connection string of the test/design database.
    The design tools can be informed about our `DbContextOptions` options if we create
    a class that implements the `IDesignTimeDbContextFactory<T>` interface, where
    `T` is our `DbContext` subclass:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 整个设计过程需要一个测试/设计数据库，如果我们操作的是已经存在的数据库，那么这个测试/设计数据库的结构必须反映实际数据库的结构 - 至少在我们想要映射的表方面。为了使设计工具能够与数据库交互，我们必须定义它们传递给`DbContext`构造函数的`DbContextOptions`选项。这些选项在设计时很重要，因为它们包含测试/设计数据库的连接字符串。如果我们创建一个实现`IDesignTimeDbContextFactory<T>`接口的类，其中`T`是我们的`DbContext`子类，设计工具可以了解我们的`DbContextOptions`选项：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`connectionString` will be used by Entity Framework to create a new database
    in the local SQL Server instance that''s been installed in the development machine
    and connects with Windows credentials. You are free to change it to reflect your
    needs.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectionString`将被Entity Framework用于在开发机器上安装的本地SQL Server实例中创建一个新数据库，并使用Windows凭据进行连接。您可以自由更改它以反映您的需求。'
- en: 'Now, we are ready to create our first migration! Let''s get started:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备创建我们的第一个迁移！让我们开始吧：
- en: Let's go to the **Package Manager Console** and ensure that **WWTravelClubDB**
    is selected as our default project.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们转到**程序包管理器控制台**，确保**WWTravelClubDB**被选为我们的默认项目。
- en: Now, type `Add-Migration initial` and press Enter to issue this command. Verify
    that you added the `Microsoft.EntityFrameworkCore.Tools` NuGet package before
    issuing this command, otherwise you might get an "unrecognized command" error:![](img/B16756_08_01.png)
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入`Add-Migration initial`并按Enter键发出此命令。在发出此命令之前，请验证是否已添加了`Microsoft.EntityFrameworkCore.Tools`
    NuGet包，否则可能会出现“未识别的命令”错误！[](img/B16756_08_01.png)
- en: 'Figure 8.1: Adding the first migration'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：添加第一个迁移
- en: '`initial` is the name we gave our first migration. So, in general, the command
    is `Add-Migration <migration name>`. When we operate on an existing database,
    we must add the `-IgnoreChanges` option to the first migration (and just to that)
    so that an empty migration is created. References to the whole set of commands
    can be found in the *Further reading* section.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`initial`是我们给第一个迁移的名称。因此，一般来说，命令是`Add-Migration <迁移名称>`。当我们操作现有数据库时，必须在第一个迁移（仅在第一个迁移）中添加`-IgnoreChanges`选项，以便创建一个空迁移。有关整套命令的参考可以在*进一步阅读*部分找到。'
- en: If, after having created the migration, but before having applied the migration
    to the database, we realize we made some errors, we can undo our action with the
    `Remove-Migration` command. If the migration has already been applied to the database,
    the simplest way to correct our error is to make all the necessary changes to
    the code and then apply another migration.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在创建迁移之后，但在将迁移应用到数据库之前，我们意识到我们犯了一些错误，我们可以使用`Remove-Migration`命令撤消我们的操作。如果迁移已经应用到数据库，纠正错误的最简单方法是对代码进行所有必要的更改，然后应用另一个迁移。
- en: As soon as the `Add-Migration` command is executed, a new folder appears in our
    project:![](img/B16756_08_02.png)
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦执行`Add-Migration`命令，我们的项目中会出现一个新文件夹！[](img/B16756_08_02.png)
- en: 'Figure 8.2: Files created by the Add-Migration command'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：Add-Migration命令创建的文件
- en: '`20201008150827_initial.cs` is our migration expressed in an easy to understand
    language.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`20201008150827_initial.cs`是我们用易于理解的语言表达的迁移。'
- en: You may review the code to verify that everything is okay, and you may also
    modify the migration content (only if you are enough of an expert to do it reliably).
    Each migration contains an `Up` method and a `Down` method. The `Up` method implies
    the migration, while the `Down` method undoes its changes. Accordingly, the `Down`
    method contains the reverse actions of all the actions included in the `Up` method
    in reverse order.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看代码以验证一切是否正常，您也可以修改迁移内容（只有当您足够专业时才能可靠地这样做）。每个迁移都包含一个`Up`方法和一个`Down`方法。`Up`方法表示迁移，而`Down`方法撤消其更改。因此，`Down`方法包含与`Up`方法中包含的所有操作的相反操作，按照相反的顺序。
- en: '`20201008150827_initial.Designer.cs` is the Visual Studio designer code you
    *must not* modify, while `MainDBContextModelSnapshot.cs` is the overall database
    structure snapshot. If you add further migrations, new migration files and their
    designer counterparts will appear and the unique `MainDBContextModelSnapshot.cs`
    database structure snapshot will be updated to reflect the database''s overall
    structure.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`20201008150827_initial.Designer.cs`是Visual Studio的设计器代码，*不得*修改，而`MainDBContextModelSnapshot.cs`是整体数据库结构快照。如果添加了进一步的迁移，新的迁移文件及其设计器对应文件将出现，并且唯一的`MainDBContextModelSnapshot.cs`数据库结构快照将被更新以反映数据库的整体结构。'
- en: The same command can be issued in a Windows console by typing `dotnet ef migrations
    add initial`. However, this command must be issued from within the project's root
    folder (not from within the solution's root folder).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows控制台中输入`dotnet ef migrations add initial`可以发出相同的命令。但是，此命令必须在项目的根文件夹中发出（而不是在解决方案的根文件夹中）。
- en: Migrations can be applied to the database by typing `Update-Database` in the
    Package Manager Console. The equivalent Windows console command is `dotnet ef database
    update`. Let's try using this command to create the physical database!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在包管理器控制台中键入`Update-Database`来将迁移应用到数据库。相应的Windows控制台命令是`dotnet ef database
    update`。让我们尝试使用这个命令来创建物理数据库！
- en: The next subsection explains how to create database stuff that Entity Framework
    is unable to create automatically. After that, in the next section, we will use
    Entity Framework's configuration and the database we generated with `dotnet ef
    database update` to create, query, and update data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将解释如何创建Entity Framework无法自动创建的数据库内容。之后，在下一节中，我们将使用Entity Framework的配置和我们使用`dotnet
    ef database update`生成的数据库来创建、查询和更新数据。
- en: Understanding stored procedures and direct SQL commands
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解存储过程和直接SQL命令
- en: Some database structures, like, for instance, stored procedures, can't be generated
    automatically by the Entity Framework Core commands and declarations we described
    previously. Stored procedures such as generic SQL strings can be included manually
    in the `Up` and `Down` methods through the `migrationBuilder.Sql("<sql scommand>")`
    method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库结构，例如存储过程，无法通过我们之前描述的Entity Framework Core命令和声明自动生成。例如，可以通过`migrationBuilder.Sql("<sql
    scommand>")`方法在`Up`和`Down`方法中手动包含存储过程和通用SQL字符串。
- en: The safest way to do this is by adding a migration without performing any configuration
    changes so that the migration is empty when it's created. Then, we can add the
    necessary SQL commands to the empty `Up` method of this migration and their converse
    commands in the empty `Down` method. It is good practice to put all the SQL strings
    in the properties of resource files (`.resx` files).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的方法是添加一个迁移而不进行任何配置更改，以便在创建时迁移为空。然后，我们可以将必要的SQL命令添加到此迁移的空`Up`方法中，以及在空的`Down`方法中添加它们的相反命令。将所有SQL字符串放在资源文件（`.resx`文件）的属性中是一个好的做法。
- en: Now, you are ready to interact with the database through Entity Framework Core.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经准备好通过Entity Framework Core与数据库进行交互了。
- en: Querying and updating data with Entity Framework Core
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Entity Framework Core查询和更新数据
- en: 'To test our DB layer, we need to add a console project based on the same .NET
    Core version as our library to the solution. Let''s get started:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的DB层，我们需要根据与我们的库相同的.NET Core版本向解决方案中添加一个基于控制台的项目。让我们开始吧：
- en: Let's call the new console project `WWTravelClubDBTest`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将新的控制台项目命名为`WWTravelClubDBTest`。
- en: Now, we need to add our data layer as a dependency of the console project by
    right-clicking on the **References** node of the console project and selecting
    **Add reference**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将数据层作为控制台项目的依赖项添加到**References**节点中，然后选择**Add reference**。
- en: 'Remove the content of the `Main` static method in the `program.cs` file and
    start by writing the following:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`program.cs`文件中`Main`静态方法的内容，并开始编写以下内容：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, add the following namespaces at the top of the file:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在文件顶部添加以下命名空间：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we have finished preparing our test project, we can experiment with
    queries and data updates. Let''s start by creating some database objects, that
    is, some destinations and packages. Follow these steps to do so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了准备测试项目的工作，可以尝试查询和更新数据。让我们开始创建一些数据库对象，即一些目的地和包。按照以下步骤进行：
- en: 'First, we must create an instance of our `DbContext` subclass with an appropriate
    connection string. We can use the same `LibraryDesignTimeDbContextFactory` class
    that''s used by the design tools to get it:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个适当的连接字符串的`DbContext`子类的实例。我们可以使用相同的`LibraryDesignTimeDbContextFactory`类，该类被设计工具用于获取它：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'New rows can be created by simply adding class instances to the mapped collections
    of our `DbContext` subclass. If a `Destination` instance has packages associated
    with it, we can simply add them to its `Packages` property:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过简单地将类实例添加到我们`DbContext`子类的映射集合中来创建新行。如果`Destination`实例与其关联的包相关联，我们可以简单地将它们添加到其`Packages`属性中：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is no need to specify primary keys since they are auto-generated and will
    be filled in by the database. In fact, after the `SaveChanges()` operation synchronizes
    our context with the actual DB, the `firstDestination.Id` property has a non-zero
    value. The same is true for the primary keys of `Package`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 无需指定主键，因为它们是自动生成的，并将由数据库填充。事实上，在`SaveChanges()`操作后，我们的上下文与实际数据库同步后，`firstDestination.Id`属性具有非零值。对于`Package`的主键也是如此。
- en: 'When we declare that an entity (in our case, `Package`) is a child of another
    entity (in our case, `Destination`) by inserting it in a parent entity collection
    (in our case, the `Packages` collection), there is no need to explicitly set its
    external key (in our case, `DestinationId`) since it is inferred automatically
    by Entity Framework Core. Once created and synchronized with the `firstDestination`
    database, we can add further packages in two different ways:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明一个实体（在我们的情况下是`Package`）是另一个实体（在我们的情况下是`Destination`）的子实体，通过将其插入到父实体集合（在我们的情况下是`Packages`集合）中时，由于Entity
    Framework Core会自动推断外键（在我们的情况下是`DestinationId`），因此无需显式设置外键。创建并与`firstDestination`数据库同步后，我们可以以两种不同的方式添加更多的套餐：
- en: Create a `Package` class instance, set its `DestinationId` external key to `firstDestinatination.Id`
    and add it to `context.Packages`
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`Package`类实例，将其`DestinationId`外键设置为`firstDestinatination.Id`，并将其添加到`context.Packages`
- en: Create a `Package` class instance, with no need to set its external key, and
    then add it to the `Packages` collection of its parent `Destination` instance.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`Package`类实例，无需设置其外键，然后将其添加到其父`Destination`实例的`Packages`集合中。
- en: The latter option is the only possibility when a child entity (`Package`) is
    added with its parent entity (`Destination`) and the parent entity has an auto-generated
    principal key since, in this case, the external key isn't available at the time
    we perform the additions. In most of the other circumstances, the former option
    is simpler since the second option requires the parent `Destination` entity to
    be loaded in memory, along with its `Packages` collection, that is, together with
    all the packages associated with the `Destination` object (by default, connected
    entities aren't loaded by queries).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种选项是唯一的可能性，当子实体（`Package`）与其父实体（`Destination`）一起添加，并且父实体具有自动生成的主键时，因为在这种情况下，外键在执行添加时不可用。在大多数其他情况下，前一种选项更简单，因为第二种选项要求在内存中加载父`Destination`实体，以及其`Packages`集合，即与`Destination`对象相关联的所有套餐（默认情况下，连接的实体不会通过查询加载）。
- en: 'Now, let''s say we want to modify the *Florence* destination and give a 10%
    increment to all `Florence` package prices. How do we proceed? Follow these steps
    to find out how:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想修改*佛罗伦萨*目的地，并为所有`佛罗伦萨`套餐价格增加10%。我们该如何操作？按照以下步骤找出答案：
- en: First, comment out all previous instructions for populating the database while
    keeping the `DbContext` creation instruction.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，注释掉所有以前用于填充数据库的指令，但保留`DbContext`创建指令。
- en: Then, we need to load the entity into memory with a query, modify it, and call
    `SaveChanges()` to synchronize our changes with the database.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要使用查询将实体加载到内存中，修改它，并调用`SaveChanges()`将我们的更改与数据库同步。
- en: 'If we want to modify, say, just its description, a query such as the following
    is enough:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想修改其描述，那么以下查询就足够了：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We need to load all the related destination packages that are not loaded by
    default. This can be done with the `Include` clause, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要加载所有相关的目的地套餐，这些套餐默认情况下未加载。可以使用`Include`子句来完成，如下所示：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After that, we can modify the description and package prices, as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以修改描述和套餐价格，如下所示：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If entities included with the `Include` method themselves contain a nested
    collection we would like to include, we can use `ThenInclude` as shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`Include`方法包含的实体本身包含我们想要包含的嵌套集合，我们可以使用`ThenInclude`，如下所示：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Since Entity Framework always tries to translate each LINQ in a single SQL
    query, sometimes the resulting query might be too complex and slow. In such cases,
    starting from version 5, we can give Entity Framework the permission to split
    the LinQ query into several SQL queries, as shown here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Entity Framework始终尝试将每个LINQ翻译为单个SQL查询，有时生成的查询可能过于复杂和缓慢。在这种情况下，从第5版开始，我们可以允许Entity
    Framework将LinQ查询拆分为多个SQL查询，如下所示：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Performance issues can be addressed by inspecting the SQL generated by a LinQ
    query with the help of the `ToQueryString` method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查`ToQueryString`方法生成的LinQ查询的SQL，可以解决性能问题：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Starting from version 5, included nested collection can also be filtered with
    `Where` as shown here:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从第5版开始，包含的嵌套集合也可以使用`Where`进行过滤，如下所示：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So far, we've performed queries whose unique purpose is to update the retrieved
    entities. Next, we will explain how to retrieve information that will be shown
    to the user and/or be used by complex business operations.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们执行的查询的唯一目的是更新检索到的实体。接下来，我们将解释如何检索将向用户显示和/或由复杂业务操作使用的信息。
- en: Returning data to the presentation layer
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据返回到表示层
- en: 'To keep the layers separated and to adapt queries to the data that''s actually
    needed by each *use case*, DB entities aren''t sent as they are to the presentation
    layer. Instead, the data is projected into smaller classes that contain the information
    that''s needed by the *use case*. These are implemented by the presentation layer''s
    caller method. Objects that move data from one layer to another are called **Data
    Transfer Objects** (**DTOs**). As an example, let''s create a DTO containing the
    summary information that is worth showing when returning a list of packages to
    the user (we suppose that, if needed, the user can get more details by clicking
    the package they are interested in):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持层之间的分离，并根据每个*用例*实际需要的数据调整查询，DB实体不会按原样发送到表示层。相反，数据将投影到包含*用例*所需信息的较小类中，这些类由表示层的调用方法实现。将数据从一层移动到另一层的对象称为**数据传输对象**（**DTOs**）。例如，让我们创建一个DTO，其中包含在向用户返回套餐列表时值得显示的摘要信息（我们假设如果需要，用户可以通过单击他们感兴趣的套餐来获取更多详细信息）：
- en: 'Let''s add a DTO to our WWTravelClubDBTest project that contains all the information
    that needs to be shown in a list of packages:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在WWTravelClubDBTest项目中添加一个DTO，其中包含需要在套餐列表中显示的所有信息：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We don't need to load entities in memory and then copy their data into the DTO,
    but database data can be projected directly into the DTO, thanks to the LINQ `Select`
    clause. This minimizes how much data is exchanged with the database.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要将实体加载到内存中，然后将其数据复制到DTO中，而是可以直接将数据库数据投影到DTO中，这要归功于LINQ的`Select`子句。这样可以最大程度地减少与数据库交换的数据量。
- en: 'As an example, we can populate our DTOs with a query that checks all the packages
    that are available around August 10:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，我们可以使用查询填充我们的DTO，该查询检查所有在8月10日左右可用的包裹：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the `Select` clause, we can also navigate to any related entities to get
    the data we need. For instance, the preceding query navigates to the related `Destination`
    entity to get the `Package` destination name.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Select`子句中，我们还可以导航到任何相关实体以获取所需的数据。例如，前面的查询导航到相关的`Destination`实体以获取`Package`目的地名称。
- en: The programs stop at each `Console.ReadKey()` method, waiting for you to hit
    any key. This way, you have time to analyze the output that's produced by all
    the code snippets that we added to the `Main` method.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序在每个`Console.ReadKey()`方法处停止，等待您按任意键。这样，您就有时间分析由我们添加到`Main`方法的所有代码片段产生的输出。
- en: Now, right-click on the WWTravelClubDBTest project in Solution Explorer and
    set it as the start project. Then, run the solution.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在解决方案资源管理器中右键单击WWTravelClubDBTest项目，并将其设置为启动项目。然后，运行解决方案。
- en: Now, we will learn how to handle operations that can't be efficaciously mapped
    to the immediate operations in the in-memory collections that represent the database
    tables.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将学习如何处理不能有效映射到表示数据库表的内存集合中的即时操作的操作。
- en: Issuing direct SQL commands
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发出直接的SQL命令
- en: 'Not all database operations can be executed efficiently by querying the database
    with LINQ and updating in-memory entities. For instance, counter increments can
    be performed more efficiently with a single SQL instruction. Moreover, some operations
    can be executed with acceptable performance if we define adequate stored procedures/SQL
    commands. In these cases, we are forced to either issue direct SQL commands to
    the database or call database stored procedures from our Entity Framework code.
    There are two possibilities: SQL statements that perform database operations but
    do not return entities, and SQL statements that do return entities.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的数据库操作都可以通过使用LINQ查询数据库并更新内存实体来高效执行。例如，计数器增量可以通过单个SQL指令更有效地执行。此外，如果我们定义了适当的存储过程/SQL命令，一些操作可以以可接受的性能执行。在这些情况下，我们不得不直接向数据库发出SQL命令或从Entity
    Framework代码中调用数据库存储过程。有两种可能性：执行数据库操作但不返回实体的SQL语句，以及返回实体的SQL语句。
- en: 'SQL commands that don''t return entities can be executed with the `DbContext`
    method, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不返回实体的SQL命令可以通过`DbContext`方法执行，如下所示：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Parameters can be referenced in the string as `{0}, {1}, ..., {n}`. Each `{m}`
    is filled with the object contained at the `m` index of the `parameters` array,
    which is converted from a .NET type into the corresponding SQL type. The method
    returns the number of affected rows.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以在字符串中作为`{0}，{1}，...，{n}`进行引用。每个`{m}`都填充了`parameters`数组中`m`索引处包含的对象，该对象从.NET类型转换为相应的SQL类型。该方法返回受影响的行数。
- en: 'SQL commands that return collections of entities must be issued through the
    `FromSqlRaw` method of the mapped collection associated with those entities:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 必须通过与这些实体相关联的映射集合的`FromSqlRaw`方法发出返回实体集合的SQL命令：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Thus, for instance, a command that returns `Package` instances would look something
    like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，返回`Package`实例的命令看起来像这样：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'SQL strings and parameters work like this in the `ExecuteSqlRaw` method. The
    following is a simple example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: SQL字符串和参数在`ExecuteSqlRaw`方法中的工作方式如下。以下是一个简单的例子：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is good practice to put all the SQL strings in resource files and encapsulate
    all the `ExecuteSqlRaw` and `FromSqlRaw` calls inside the public methods that
    you defined in your `DbContext` subclasses, in order to keep the dependence from
    a specific database inside of your Entity Framework Core-based data layer.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有SQL字符串放入资源文件中，并将所有`ExecuteSqlRaw`和`FromSqlRaw`调用封装在您在基于Entity Framework Core的数据层中定义的公共方法中，以便将特定数据库的依赖性保持在内部。
- en: Handling transactions
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理事务
- en: 'All the changes that are made to a `DbContext` instance are passed in a single
    transaction at the first `SaveChanges` call. However, sometimes, it is necessary
    to include queries and updates in the same transaction. In these cases, we must
    handle the transaction explicitly. Several Entity Framework Core commands can
    be included in a transaction if we put them inside a `using` block associated
    with a transaction object:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对`DbContext`实例所做的所有更改都在第一次`SaveChanges`调用时作为单个事务传递。然而，有时需要在同一个事务中包含查询和更新。在这些情况下，我们必须显式处理事务。如果我们将它们放在与事务对象关联的`using`块中，那么几个Entity
    Framework Core命令可以包含在事务中：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, `context` is an instance of our `DbContext` subclass.
    Inside of the `using` block, the transaction can be aborted and committed by calling
    its `Rollback` and `Commit` methods. Any `SaveChanges` calls that are included
    in the transaction block use the transaction they are already in, instead of creating
    new ones.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`context`是我们`DbContext`子类的一个实例。在`using`块内，可以通过调用其`Rollback`和`Commit`方法来中止和提交事务。包含在事务块中的任何`SaveChanges`调用都使用它们已经存在的事务，而不是创建新的事务。
- en: Deploying your data layer
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署数据层
- en: When your database layer is deployed in production or in staging, usually, an
    empty database already exists, so you must apply all the migrations in order to
    create all the database objects. This can be done by calling `context.Database.Migrate()`.
    The `Migrate` method applies the migrations that haven't been applied to the databases
    yet, so it may be called safely several times during the application's lifetime.
    `context` is an instance of our `DbContext` class that must be passed through
    a connection string with enough privileges to create tables and to perform all
    the operations included in our migrations. Thus, typically, this connection string
    is different from the string we will use during normal application operations.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库层部署到生产环境或暂存环境时，通常已经存在一个空数据库，因此必须应用所有迁移以创建所有数据库对象。这可以通过调用`context.Database.Migrate()`来完成。`Migrate`方法应用尚未应用到数据库的迁移，因此在应用程序的生命周期中可以安全地多次调用。`context`是我们的`DbContext`类的一个实例，必须通过具有足够权限来创建表和执行迁移中包含的所有操作的连接字符串进行传递。因此，通常，此连接字符串与我们在正常应用程序操作期间使用的字符串不同。
- en: During the deployment of a web application on Azure, we are given the opportunity
    to check migrations with a connection string we provide. We can also check migrations
    manually by calling the `context.Database.Migrate()` method when the application
    starts. This will be discussed in detail in *Chapter 15*, *Presenting ASP.NET
    Core MVC*, which is dedicated to ASP.NET MVC web applications.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure上部署Web应用程序时，我们有机会使用我们提供的连接字符串来检查迁移。我们还可以在应用程序启动时通过调用`context.Database.Migrate()`方法来手动检查迁移。这将在*第15章*“介绍ASP.NET
    Core MVC”中详细讨论，该章节专门讨论ASP.NET MVC Web应用程序。
- en: For desktop applications, we can apply migrations during the installation of
    the application and of its subsequent updates.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于桌面应用程序，我们可以在应用程序安装和后续更新期间应用迁移。
- en: At the first application installation and/or in subsequent application updates,
    we may need to populate some tables with initial data. For web applications, this
    operation can be performed at application start, while for desktop applications,
    this operation can be included in the installation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次安装应用程序和/或后续应用程序更新时，我们可能需要使用初始数据填充一些表。对于Web应用程序，此操作可以在应用程序启动时执行，而对于桌面应用程序，此操作可以包含在安装中。
- en: 'Database tables can be populated with Entity Framework Core commands. First,
    though, we need to verify whether the table is empty in order to avoid adding
    the same table rows several times. This can be done with the `Any()` LINQ method,
    as shown in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库表可以使用Entity Framework Core命令进行填充。但首先，我们需要验证表是否为空，以避免多次添加相同的表行。这可以使用`Any()`
    LINQ方法来完成，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let's take a look at a few advanced features that Entity Framework Core has
    to share.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Entity Framework Core有哪些高级特性可以分享。
- en: Understanding Entity Framework Core advanced features
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Entity Framework Core的高级特性
- en: An interesting Entity Framework advanced feature that is worth mentioning is
    global filters, which were introduced at the end of 2017\. They enable techniques
    such as soft delete and multi-tenant tables that are shared by several users,
    where each user just *sees* its records.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的一个有趣的Entity Framework高级特性是全局过滤器，这是在2017年底引入的。它们可以实现软删除和多租户表等技术，这些表由多个用户共享，每个用户只能*看到*自己的记录。
- en: 'Global filters are defined with the `modelBuilder` object, which is available
    in the `DbContext` `OnModelCreating` method. The syntax for this method is as
    follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 全局过滤器是使用`modelBuilder`对象定义的，该对象在`DbContext`的`OnModelCreating`方法中可用。此方法的语法如下：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'For instance, if we add an `IsDeleted` property to our `Package` class, we
    may soft delete a `Package` without removing it from the database by defining
    the following filter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们向我们的`Package`类添加一个`IsDeleted`属性，我们可以通过定义以下过滤器软删除`Package`而不从数据库中删除它：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, filters contain `DbContext` properties. Thus, for instance, if we
    add a `CurrentUserID` property to our `DbContext` subclass (whose value is set
    as soon as a `DbContext` instance is created), then we can add a filter like the
    following one to all the entities that refer to a user ID:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，过滤器包含`DbContext`属性。因此，例如，如果我们向我们的`DbContext`子类添加一个`CurrentUserID`属性（其值在创建`DbContext`实例时设置），那么我们可以向所有引用用户ID的实体添加以下过滤器：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With the preceding filter in place, the currently logged-in user can only access
    the documents they own (the ones that have their `UserId`). Similar techniques
    are very useful in the implementation of multi-tenant applications.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述过滤器，当前登录的用户只能访问他们拥有的文档（具有他们的`UserId`的文档）。类似的技术在多租户应用程序的实现中非常有用。
- en: Another interesting feature that is worth mentioning is mapping entities to
    un-updatable database queries, which was introduced in version 5.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得一提的有趣特性是将实体映射到不可更新的数据库查询，这是在版本5中引入的。
- en: 'When you define an entity, you can define explicitly either the name of the
    mapped database table or the name of a mapped updatable view:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义一个实体时，您可以明确定义映射的数据库表的名称或映射的可更新视图的名称：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When an entity is mapped to a view, no table is generated by database migration,
    so the database view must be defined manually by the developer.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当实体映射到视图时，数据库迁移不会生成表，因此必须由开发人员手动定义数据库视图。
- en: 'If the view we would like to map out entity is not updatable, LinQ cannot use
    it to pass updates to the database. In this case, we can map the same entity simultaneously
    to a view and a table:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要映射实体的视图不可更新，LinQ无法使用它将更新传递给数据库。在这种情况下，我们可以同时将相同实体映射到视图和表：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Entity Framework will use the view for the queries and the table for the updates.
    This is useful when we create a newer version of a database table but we want
    to also take data from the old version of the table in all queries. In this case,
    we may define a view that takes data from both the old and the new tables, but
    pass all updates only on the new table.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework将使用视图进行查询和表进行更新。当我们创建数据库表的新版本，但又希望在所有查询中同时从旧版本的表中获取数据时，这是非常有用的。在这种情况下，我们可以定义一个视图，该视图从旧表和新表中获取数据，但只在新表上传递所有更新。
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the essentials of ORM basics and why they are
    so useful. Then, we described Entity Framework Core. In particular, we discussed
    how to configure database mappings with class annotations and other declarations
    and commands that are included in `DbContext` subclasses.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了ORM基础知识的基本要点以及它们为何如此有用。然后，我们描述了Entity Framework Core。特别是，我们讨论了如何使用类注释和其他声明以及包含在`DbContext`子类中的命令来配置数据库映射。
- en: Then, we discussed how to automatically create and update the physical database
    structure with the help of migrations, as well as how to query and pass updates
    to the database through Entity Framework Core. Finally, we learned how to pass
    direct SQL commands and transactions through Entity Framework Core, as well as
    how to deploy a data layer based on Entity Framework Core.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了如何通过迁移自动创建和更新物理数据库结构，以及如何通过Entity Framework Core查询和传递更新到数据库。最后，我们学习了如何通过Entity
    Framework Core传递直接的SQL命令和事务，以及如何基于Entity Framework Core部署数据层。
- en: This chapter also reviewed a couple of advanced features that were introduced
    in the latest Entity Framework Core releases.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还回顾了最新的Entity Framework Core版本中引入的一些高级功能。
- en: In the next chapter, we will discuss how Entity Framework Core can be used with
    NoSQL data models and the various types of storage options that are available
    in the cloud and, in particular, in Azure.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Entity Framework Core如何与NoSQL数据模型一起使用，以及云中和特别是Azure中可用的各种存储选项。
- en: Questions
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How does Entity Framework Core adapt to several different database engines?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Entity Framework Core如何适应多种不同的数据库引擎？
- en: How are primary keys declared in Entity Framework Core?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Entity Framework Core中如何声明主键？
- en: How is a string field's length declared in Entity Framework Core?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Entity Framework Core中如何声明字符串字段的长度？
- en: How are indexes declared in Entity Framework Core?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Entity Framework Core中如何声明索引？
- en: How are relations declared in Entity Framework Core?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Entity Framework Core中如何声明关系？
- en: What are the two important migration commands?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是两个重要的迁移命令？
- en: By default, are related entities loaded by LINQ queries?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，LINQ查询是否加载相关实体？
- en: Is it possible to return database data in a class instance that isn't a database
    entity? If yes, how?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可能在不是数据库实体的类实例中返回数据库数据？如果是，如何？
- en: How are migrations applied in production and staging?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产和分段中如何应用迁移？
- en: Further reading
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: More details about migration commands can be found at [https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index](https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index)
    and at the other links contained there.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关迁移命令的更多详细信息，请参阅[https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index](https://docs.microsoft.com/en-US/ef/core/miscellaneous/cli/index)以及其中包含的其他链接。
- en: 'More details about Entity Framework Core can be found in the official Microsoft
    documentation: [https://docs.microsoft.com/en-us/ef/core/](https://docs.microsoft.com/en-us/ef/core/).'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Entity Framework Core的更多详细信息，请参阅官方Microsoft文档：[https://docs.microsoft.com/en-us/ef/core/](https://docs.microsoft.com/en-us/ef/core/)。
- en: 'An exhaustive set of examples of complex LINQ queries can be found here: [https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b).'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里可以找到一组复杂LINQ查询的详尽示例：[https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)。
