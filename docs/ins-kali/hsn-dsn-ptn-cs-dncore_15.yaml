- en: Coding for the Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为云端编码
- en: The previous chapters explored patterns, from lower-level concepts such as the
    Singleton and Factory patterns, to patterns for specific technologies such as
    databases and web applications. These patterns are essential for ensuring the
    good design of a solution to ensure maintainability and efficient implementation.
    These patterns provide a solid foundation that allows applications to be enhanced
    and modified as requirements change and new functionality is added.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节探讨了模式，从较低级别的概念，如单例和工厂模式，到特定技术的模式，如数据库和Web应用程序的模式。这些模式对于确保解决方案的良好设计以确保可维护性和高效实施至关重要。这些模式提供了一个坚实的基础，使应用程序能够在需求变化和添加新功能时得到增强和修改。
- en: This chapter takes a higher-level view of a solution to address concerns involving
    designing implementing solutions that are reliable, scalable, and secure. The
    patterns in this chapter often involve environments that contain multiple applications,
    a repository, and a range of possible infrastructure configurations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从更高层次的视角来看待解决方案，以解决设计实施可靠、可扩展和安全的问题。本章中的模式通常涉及包含多个应用程序、存储库和各种可能的基础设施配置的环境。
- en: The software industry is continually evolving and with the change comes new
    opportunity as well as new challenges. In this chapter, we will look at different
    software patterns for the cloud. Many of these patterns are not new, and existed
    in on-premises environments. As cloud-first solutions are becoming the norm, these
    patterns are even more commonplace due to the ease of implementing solutions that
    do not rely on on-premises infrastructure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 软件行业不断发展，随之而来的是新的机遇和新的挑战。在本章中，我们将探讨云端的不同软件模式。这些模式中许多并非新鲜事物，在本地环境中已经存在。随着云优先解决方案变得普遍，这些模式由于实施不依赖本地基础设施的便利性而变得更加普遍。
- en: Cloud-first or cloud-native solutions have been designed to target cloud computing
    resources, while hybrid solutions have been designed to use both cloud computing
    resources as well as resources from a private data center.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 云优先或云原生解决方案旨在针对云计算资源，而混合解决方案则旨在同时使用云计算资源和私人数据中心的资源。
- en: 'This chapter defines five key concerns when building solutions in the cloud:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章定义了在构建云端解决方案时的五个关键考虑因素：
- en: Scalability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Availability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Security
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Application design
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用设计
- en: DevOps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevOps
- en: We will discuss the key concerns and why they are significant to building cloud
    solutions. As the concerns are discussed, different patterns will be described
    that can be applied to address these concerns.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论这些关键考虑因素以及它们对构建云解决方案的重要性。随着讨论这些问题，将描述不同的模式，以应对这些问题。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not require any special technical requirements or source code
    as it is primarily theoretical.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不需要任何特殊的技术要求或源代码，因为它主要是理论性的。
- en: Key considerations when building solutions in the cloud
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构建云端解决方案时的关键考虑因素
- en: Making the decision to move to the cloud comes with its own set of problems
    and challenges. In this section, we will cover five key areas of consideration
    for building cloud-based solutions. While these are not unique to the cloud, they
    require special attention when switching to the cloud due to the wide range of
    technologies and solutions that are available.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 决定转移到云端会带来一系列问题和挑战。在本节中，我们将涵盖构建基于云的解决方案的五个关键考虑领域。虽然这些问题并非云端独有，但在转向云端时需要特别关注，因为有各种技术和解决方案可供选择。
- en: 'The five primary considerations are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 五个主要考虑因素如下：
- en: '**Scalability**: This allows for accommodation of increased load or traffic
    for a growing business.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：这允许适应不断增长的业务的负载或流量。'
- en: '**Resilience/availability**: This ensures the handling of failures in a system
    gracefully with as little impact on the user as possible.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性/可用性**：这确保系统在发生故障时能够优雅地处理，对用户的影响尽可能小。'
- en: '**Security**: This ensures that private and proprietary data stays that way
    and is safe from hacks and attacks.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：这确保私人和专有数据保持原样，并且免受黑客和攻击的威胁。'
- en: '**Application design**: This refers to the design of applications with special
    consideration for cloud-based solutions.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用设计**：这指的是专门考虑云端解决方案的应用设计。'
- en: '**DevOps**: This is a collection of tools and practices that supports the development
    and running of cloud-based solutions.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DevOps**：这是一套支持云端解决方案开发和运行的工具和实践集合。'
- en: Depending on your business requirements, you may need to look for solutions
    for some or all of these considerations. It is also in your business's best interest
    to adopt providers with solutions to problems that you don't anticipate but would
    make for good contingency planning.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的业务需求，您可能需要寻找一些或所有这些考虑因素的解决方案。对于您的业务来说，采用能够解决您未预料到但会成为良好备用计划的问题的解决方案提供商也是最为有利的。
- en: In the following sections, we will discuss these considerations in further detail
    along with the available solution patterns for them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将详细讨论这些考虑因素以及针对它们的可用解决方案模式。
- en: These patterns range from a type of technology to architectural to business
    processes and a single pattern could address more than one concern.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式涵盖了从技术类型到架构和业务流程的各种问题，一个单一模式可能涉及多个问题。
- en: Scalability
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性
- en: Scalability refers to the ability to allocate and manage resources used by an
    application in order for the application to maintain an acceptable level of quality
    under a given workload. Most cloud offerings provide mechanisms for increasing
    the quality and quantity of resources used by an application. For example, the
    Azure App Service allows scaling of both the size of the App Service and the number
    of instances of the App Service.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性指的是为了应用程序在给定的工作负载下保持可接受的质量水平而分配和管理资源的能力。大多数云服务提供机制来增加应用程序使用的资源的质量和数量。例如，Azure应用服务允许扩展应用服务的大小和应用服务的实例数量。
- en: Scalability can be viewed as demand on a limited number of resources. A resource
    could be disk space, RAM, bandwidth, or another aspect of software that can be
    quantified. The demand can range from the number of users, concurrent connections,
    or another demand that would produce a constraint on a resource. As the demand
    increases, a strain is placed on the application in order to provide the resource.
    When the strain affects the performance of the application, this is referred to
    as a resource bottleneck.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性可以被视为对有限资源的需求。资源可以是磁盘空间、RAM、带宽或软件的另一个可以量化的方面。需求可以涵盖用户数量、并发连接数量或会对资源产生约束的其他需求。随着需求的增加，应用程序需要提供资源。当需求影响应用程序的性能时，这被称为资源瓶颈。
- en: For example, a measure might be the number of users that can access an application
    before the performance of the application begins to deteriorate. The performance
    could be set as an average latency on requests being less than 2 seconds. As the
    number of users increases, the load on the system could then be viewed, and specific
    resource bottlenecks affecting the performance could be identified.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个度量标准可能是在应用程序性能开始恶化之前可以访问应用程序的用户数量。性能可以设置为请求的平均延迟小于2秒。随着用户数量的增加，可以查看系统的负载，并识别影响性能的特定资源瓶颈。
- en: Workload
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作负载
- en: 'In order to determine how to effectively address scaling issues, it is important
    to understand the workload that the system will be under. There are four main
    types of workload: static, periodic, once-in-a-lifetime and unpredictable.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定如何有效地解决扩展性问题，了解系统将承受的工作负载是很重要的。有四种主要类型的工作负载：静态、周期性、一次性和不可预测的。
- en: A static workload represents a constant level of activity on a system. Because
    the workload does not fluctuate, this type of system does not require a very elastic
    infrastructure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 静态工作负载表示系统上的持续活动水平。由于工作负载不波动，这种类型的系统不需要非常弹性的基础设施。
- en: Systems that have a predictable change in workload have a periodic workload.
    An example would be a system that experiences a surge of activity around the weekends
    or around the months when income tax is due. These systems can be scaled up to
    maintain a desired level of quality when the load increases and scaled down to
    save cost when the load decreases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 具有可预测工作负载变化的系统具有周期性工作负载。例如，系统在周末或应交所得税的月份周围经历活动激增。这些系统可以进行扩展以在负载增加时保持所需的质量水平，并在负载减少时进行缩减以节省成本。
- en: Once-in-a-lifetime workloads indicate systems designed around a specific event.
    These systems are provisioned to handle the workload around the event and deprovisioned
    once they are no longer needed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性工作负载表示围绕特定事件设计的系统。这些系统被配置为处理事件周围的工作负载，并在不再需要时取消配置。
- en: Unpredictable workloads often benefit from the auto-scale functionality mentioned
    earlier. These systems have large fluctuations in activity that are either not
    understood by the business yet or are influenced by other factors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不可预测的工作负载通常受益于前面提到的自动扩展功能。这些系统的活动波动很大，要么业务尚未理解，要么受其他因素影响。
- en: Understanding and designing a cloud-based application for its type of workload
    is essential for both maintaining a high level of performance as well as lowering
    costs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和设计基于云的应用程序以适应其工作负载类型对于保持高性能水平和降低成本都至关重要。
- en: Solution patterns
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案模式
- en: 'We have available three design patterns and one architecture pattern to choose
    from to enable us to add scalability to our systems:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种设计模式和一种架构模式可供选择，以使我们的系统具有可扩展性：
- en: Vertical scaling
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直扩展
- en: Horizontal scaling
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水平扩展
- en: Auto-scaling
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动扩展
- en: Microservices
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务
- en: Let's review each in more detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地审查每一种。
- en: Vertical scaling
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垂直扩展
- en: Though it is possible to add physical RAM or an additional disk drive to an
    on-premises server, most cloud providers support the ability to easily increase
    or decrease the computing power of a system. This is often with little or no downtime
    as the system scales. This type of scaling is called vertical scaling and refers
    to when a resource such as the type of CPU, size and quality of RAM, or size and
    quality of the disk is altered.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以向本地服务器添加物理RAM或额外的磁盘驱动器，但大多数云提供商支持轻松增加或减少系统的计算能力。这通常是在系统扩展时几乎没有或没有停机时间。这种类型的扩展称为垂直扩展，指的是改变资源，如CPU类型、RAM的大小和质量，或磁盘的大小和质量。
- en: Vertical scaling is often referred to as *scaling up* while horizontal scaling
    is often referred to as *scaling out*. In this context, the term *up* refers to
    the size of the resource while *out* refers to the number of instances.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直扩展通常被称为“扩展”，而水平扩展通常被称为“扩展”。在这种情况下，“扩展”指的是资源的大小，“扩展”指的是实例的数量。
- en: Horizontal scaling
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平扩展
- en: Horizontal scaling differs from vertical scaling because, instead of altering
    the size of a system, horizontal scaling changes the number of systems involved.
    For example, a web application might run on a single server having 4 GB RAM and
    2 CPUs. If the server was increased in size to 8 GB RAM and 4 CPUs, then this
    would be vertical scaling. However, if two more servers were added with the same
    configuration of 4 GB RAM and 2 CPUs, then this would be horizontal scaling.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展与垂直扩展不同，因为水平扩展改变的是系统的数量，而不是系统的大小。例如，Web应用程序可能在一台具有4GB RAM和2个CPU的单个服务器上运行。如果将服务器的大小增加到8GB
    RAM和4个CPU，那么这将是垂直扩展。但是，如果增加了两台具有相同配置的4GB RAM和2个CPU的服务器，那么这将是水平扩展。
- en: 'Horizontal scaling can be achieved by using some form of load balancing that
    redirects the requests across a collection of systems as illustrated in the following
    diagram:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展可以通过使用某种形式的负载平衡来实现，该负载平衡将请求重定向到一组系统，如下图所示：
- en: '![](img/1248ceaf-6ac8-4e3c-b613-ad243ecee78e.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1248ceaf-6ac8-4e3c-b613-ad243ecee78e.png)'
- en: Horizontal scaling is usually preferred in cloud solutions over vertical scaling.
    This is because, in general, it is more cost effective to use several smaller
    virtual machines to a single large server to provide the same measure of performance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展通常比垂直扩展更受云解决方案的青睐。这是因为一般来说，使用多个较小的虚拟机来提供相同性能的服务比使用单个大型服务器更具成本效益。
- en: For horizontal scaling to be most effective, it does require a system design
    that supports this type of scaling. For example, web applications designed without
    sticky sessions and/or state stored on the server work better for horizontal scaling.
    This is because sticky sessions cause a user's requests to be routed to the same
    virtual machine for processing and, over time, the balance of the routing across
    the virtual machines could become uneven and therefore not as efficient as possible.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要使水平扩展最有效，确实需要支持这种类型扩展的系统设计。例如，设计时没有粘性会话和/或状态存储在服务器上的Web应用程序更适合水平扩展。这是因为粘性会话会导致用户的请求被路由到同一台虚拟机进行处理，随着时间的推移，虚拟机之间的路由平衡可能变得不均匀，因此效率可能不尽如人意。
- en: Stateful applications
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态应用程序
- en: A *stateful *application maintains information about an active session on the
    server or repository.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*有状态*应用程序在服务器或存储库上维护有关活动会话的信息。'
- en: Stateless applications
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态应用程序
- en: '*Stateless* applications are designed to not require information about an active
    session to be stored on the server or repository. This allows for subsequent requests
    in a single session to be sent to any server to be handled and not just to the
    same server for the entire session.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*无状态*应用程序设计为不需要在服务器或存储库上存储有关活动会话的信息。这允许将单个会话中的后续请求发送到任何服务器进行处理，而不仅仅是发送到整个会话的同一服务器。'
- en: Web applications designed that are stateful require sessions or information
    to be maintained in a shared repository. Stateless web applications support a
    more resilient pattern as any server in a web garden or web farm. This allows
    for a single node in the web application to fail without losing session information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态的Web应用程序需要在共享存储库中维护会话或信息。无状态的Web应用程序支持更具弹性的模式，因为Web garden或Web farm中的任何服务器都可以失败而不会丢失会话信息。
- en: A web *garden* is a pattern where multiple copies of the same web application
    are hosted on the same server, whereas a web *farm* is a pattern where multiple
    copies of the same web application are hosted on different servers. In both patterns,
    routing is used to expose the multiple copies as if they were a single application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Web *garden*是一种模式，其中同一Web应用程序的多个副本托管在同一台服务器上，而Web *farm*是一种模式，其中同一Web应用程序的多个副本托管在不同的服务器上。在这两种模式中，路由用于将多个副本公开为单个应用程序。
- en: Auto-scaling
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动扩展
- en: 'An advantage of using a cloud provider over on-premises solutions is the built-in
    support for auto-scaling. As an added benefit to horizontal scaling, the ability
    to auto-scale an application is often a configurable feature of a cloud service.
    For example, an Azure App Service provides the ability to set up auto-scale profiles
    that allow an application to react to conditions. For example, the following screenshot
    shows an auto-scale profile:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用云提供商而不是本地解决方案的优势是内置的自动扩展支持。作为水平扩展的附加好处，自动扩展应用程序的能力通常是云服务的可配置功能。例如，Azure应用服务提供了设置自动扩展配置文件的功能，允许应用程序对条件做出反应。例如，以下屏幕截图显示了一个自动扩展配置文件：
- en: '![](img/9d5b1f53-4831-473c-af9e-263e3667205e.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d5b1f53-4831-473c-af9e-263e3667205e.png)'
- en: The profile designed for weekdays will increase or decrease the number of app
    service instances depending on the load on the servers. The load is being measured
    in CPU percentage. If the CPU percentage is averages above 60%, then the number
    of instances is increased up to a maximum of 10\. Similarly, if the CPU percentage
    falls below 30%, the number of instances is reduced to a minimum of 2.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为工作日设计的配置文件将根据服务器负载增加或减少应用服务实例的数量。负载以CPU百分比来衡量。如果CPU百分比平均超过60％，则实例数量增加到最多10个。同样，如果CPU百分比低于30％，实例数量将减少到最少2个。
- en: An elastic infrastructure allows for resources to be scaled vertically or horizontally
    without requiring a re-deploy or downtime. The term is actually more of a degree
    of elasticity instead of referring to whether a system is *elastic* or *not elastic*. For
    example, an elastic service could allow for scaling both vertically and horizontally
    without requiring a restart of the service instances. A less elastic service would
    allow for scaling horizontally without a restart but would require a restart of
    the service when the size of the server is altered.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性基础设施允许资源在不需要重新部署或停机的情况下进行垂直或水平扩展。该术语实际上更多地是弹性程度，而不是指系统是否具有*弹性*或*非弹性*。例如，弹性服务可以允许在不需要重新启动服务实例的情况下进行垂直和水平扩展。较不具弹性的服务可以允许在不重新启动的情况下进行水平扩展，但在更改服务器大小时需要重新启动服务。
- en: Microservices
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: 'There are different interpretations of what microservices means and how it
    relates to **service-oriented architecture** (**SOA**). In this section, we are
    going to view microservices as a refinement of SOA and not a new architectural
    pattern. The microservice architecture extends SOA by adding some additional key
    principles which require that services must:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微服务的含义以及它与面向服务的架构（SOA）的关系有不同的解释。在本节中，我们将微服务视为SOA的一种完善，而不是一种新的架构模式。微服务架构通过添加一些额外的关键原则来扩展SOA，要求服务必须：
- en: be small - hence the term *micro*
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规模小 - 因此称为*微*
- en: be built around a business capability
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 围绕业务能力构建
- en: be loosely coupled with other services
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他服务松散耦合
- en: be independently maintainable
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以独立维护
- en: have an isolated state
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有隔离状态
- en: Small
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规模小
- en: Microservices takes the services in SOA farther by reducing them to their smallest
    possible size. This fits well with some other patterns that we have seen, such
    as **Keep It Simple Stupid** (**KISS**) and **You Aren't Gonna Need It** (**YAGNI**)
    from [Chapter 2](e8666bee-88b0-4d5d-a62f-ee8aa27f3e29.xhtml), *Modern Software
    Design Patterns and Principles*. The microservice should only fulfill its requirements
    and nothing more.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务将SOA中的服务缩小到最小可能的规模。这与我们之前看到的一些其他模式非常契合，比如《保持简单愚蠢》（KISS）和《你不会需要它》（YAGNI）来自[第2章]，*现代软件设计模式和原则*。微服务应该只满足其要求，而不多做其他事情。
- en: Business capability
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务能力
- en: By building a service around a business capability, we align our implementation
    in such a way that, as the business requirements change, our services will be
    changed in a similar manner. Because of this, it is less likely that change in
    one area of the business will impact other areas.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过围绕业务能力构建服务，我们以一种使得当业务需求发生变化时，我们的服务也会以类似的方式进行变更的方式来实现我们的实现。因此，较少可能会导致业务的一个领域的变化影响其他领域。
- en: Loosely coupled
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 松散耦合
- en: A microservice should interact with other services across a service boundary
    using a technology-agnostic protocol such as HTTP. This allows for the microservices
    to be integrated more easily and, more importantly, not require the rebuild of
    a microservice when another service changes. This does require a known *service
    contract* to exist.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该使用技术无关的协议（如HTTP）跨服务边界与其他服务进行交互。这使得微服务更容易集成，更重要的是，当另一个服务发生变化时，不需要重建微服务。这确实需要存在一个已知的*服务合同*。
- en: Service contract
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 服务合同
- en: A *service contract* is the definition of a service that is distributed to other
    development teams. **Web Services Description Language** (**WSDL**) is a widely
    known XML-based language for describing services, but other languages, such as
    Swagger, are also very popular.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务合同*是分发给其他开发团队的服务定义。Web服务描述语言（WSDL）是一种广为人知的基于XML的描述服务的语言，但其他语言，如Swagger，也非常流行。'
- en: When implementing a microservice, it is important to have a strategy for how
    the change will be managed. By having a versioned service contract, it is then
    possible to communicate the change clearly to a client of the service.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施微服务时，重要的是要有一个管理变更的策略。通过具有版本化的服务合同，可以清晰地向服务的客户传达变更。
- en: 'For example, the strategy of a microservice used to store an inventory of books
    could have the following strategy:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，用于存储图书库存的微服务的策略可能如下：
- en: Each service will be versioned and include a Swagger definition.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务将被版本化并包括Swagger定义。
- en: Each service will start with version 1.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务将从版本1开始。
- en: When a change is made that requires the service contract to change, the version
    will be increased by 1.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当进行需要更改服务合同的更改时，版本将增加1。
- en: The service will maintain up to three versions.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务将维护最多三个版本。
- en: Changes to a service must ensure that all current versions behave suitably.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对服务的更改必须确保所有当前版本的行为都合适。
- en: The preceding basic strategy does have interesting implications. First of all,
    the team maintaining a service must ensure that changes do not break existing
    services. This ensures a new deployment will not break other services while allowing
    for new functionality to be deployed. The contract does allow for up to three
    services to be active at a time, thus allowing for a dependable service to update
    independently.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的基本策略确实有一些有趣的含义。首先，维护服务的团队必须确保更改不会破坏现有服务。这确保了新部署不会破坏其他服务，同时允许部署新功能。合同允许最多同时有三个服务处于活动状态，因此可以独立更新可靠的服务。
- en: Independently maintainable
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可以独立维护
- en: This is one of the most distinguishing features of microservices. Having a microservice
    able to be maintained independent of other microservices empowers a business to
    be able to manage the service without impacting other services. By managing a
    service, we are including both the development as well as the deployment of a
    service. With this principle, microservices can be updated and deployed with a
    reduced chance of impacting other services, as well as at a different rate of
    change from other services.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是微服务最显著的特点之一。使得一个微服务能够独立于其他微服务进行维护，使得企业能够在不影响其他服务的情况下管理该服务。通过管理服务，我们既包括服务的开发，也包括服务的部署。根据这一原则，微服务可以更新和部署，减少对其他服务的影响，并且以不同的变化速率进行部署。
- en: Isolated state
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离状态
- en: Isolated state includes both data and other resources that could be shared including
    databases and files. This is also a distinguishing feature of microservice architecture.
    By having an independent state, we are reducing the chance that a change in the
    data model to support one service will impact other services.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离状态包括数据和其他可能共享的资源，包括数据库和文件。这也是微服务架构的一个显著特点。通过拥有独立的状态，我们减少了支持一个服务的数据模型的变化会影响其他服务的机会。
- en: 'The following diagram illustrates a more traditional SOA approach, where a
    single database is used by multiple services:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了更传统的SOA方法，多个服务使用单个数据库：
- en: '![](img/d160a26b-1edb-470c-91ef-e87a93b40e64.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d160a26b-1edb-470c-91ef-e87a93b40e64.png)'
- en: 'By requiring a microservice to have an isolated state, we would then require
    a database per service as shown in the following diagram:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过要求微服务具有隔离状态，我们将要求每个服务都有一个数据库，如下图所示：
- en: '![](img/6b3b7c88-5528-4c3a-8215-2f707c7365f4.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b3b7c88-5528-4c3a-8215-2f707c7365f4.png)'
- en: This has an advantage in that each service can choose the technology that best
    fits the requirements of the services.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处在于每个服务可以选择最适合服务要求的技术。
- en: Advantages
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优势
- en: The microservice architecture does represent a shift from traditional service
    design and it does fit well in a cloud-based solution. The advantages of microservices
    and why they are gaining in popularity might not be immediately obvious. We have
    touched on how the design of microservices provides advantages for handling change
    gracefully. From a technical point of view, microservices can be scaled independently
    both at the service level and at the database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构确实代表了传统服务设计的转变，并且它在基于云的解决方案中表现良好。微服务的优势以及它们为什么越来越受欢迎可能并不立即明显。我们已经提到了微服务设计如何提供处理变化的优势。从技术角度来看，微服务可以在服务级别和数据库级别独立扩展。
- en: What might not be clear is the benefit a microservice architecture has to a
    business. By having small independent services, the business can then look at
    different ways to maintain and develop microservices. The business now has options
    to host the services in different ways, including different cloud providers, as
    best fits the independent services. Likewise, the isolated nature of the services
    allows for a greater degree of agility in developing the services. As change happens,
    resources (that is, development team members) can be allocated to different services
    as required, and, as the scope of service is smaller, the amount of business knowledge
    required is also reduced.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 也许不清楚的是微服务架构对业务的好处。通过拥有小型独立服务，业务可以以不同的方式来维护和开发微服务。业务现在可以选择以不同的方式托管服务，包括不同的云提供商，以最适合独立服务的方式。同样，服务的隔离性允许在开发服务时具有更大的灵活性。随着变化的发生，资源（即开发团队成员）可以根据需要分配到不同的服务，由于服务范围较小，所需的业务知识量也减少了。
- en: Resiliency/availability
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性/可用性
- en: Resiliency is the ability of an application to handle failure gracefully while
    availability is a measure of the amount of time the application is working. An
    application may have a collection of resources and still remain available if one
    of the resources becomes inoperable or unavailable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性是应用程序处理失败的能力，而可用性是应用程序工作的时间的度量。如果一个应用程序拥有一组资源，并且即使其中一个资源变得无法操作或不可用，它仍然保持可用。
- en: If an application is designed to handle one or more resources failing without
    the entire system becoming inoperable, this is referred to as **graceful degradation**.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序被设计成可以处理一个或多个资源失败而不会导致整个系统无法操作，这被称为**优雅降级**。
- en: Patterns apply to both isolate the elements of an application as well as handle
    the interaction between the elements so that when a failure occurs, the impact
    is limited. Many of the resiliency-related patterns focus on the messaging between
    the components within the application or to other applications. The Bulkhead pattern,
    for example, isolates the traffic into pools so that when one pool becomes overwhelmed
    or fails, the other pools are not adversely affected. Other patterns apply specific
    techniques to handle messaging, such as retry policies or compensating transactions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 模式既适用于隔离应用程序的元素，也适用于处理元素之间的交互，以便在发生故障时限制影响。许多与弹性相关的模式侧重于应用程序内部或与其他应用程序之间的消息传递。例如，Bulkhead模式将流量隔离成池，以便当一个池被压倒或失败时，其他池不会受到不利影响。其他模式应用特定技术来处理消息传递，如重试策略或补偿事务。
- en: Availability is an important factor to many cloud-based applications and, typically,
    availability is measured against a **service level agreement** (**SLA**). In most
    cases, the SLA stipulates the percentage of time the application must remain operable.
    Patterns involve both allowing for redundancy of components as well as using techniques
    to limit the effect of an increase in activity. For example, the Queue-Based Load
    Leveling pattern uses a queue to limit the effect a spike in activity might have
    on an application by acting as a buffer between the caller, or client, and the
    application or service.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性对许多基于云的应用程序来说是一个重要因素，通常可用性是根据**服务级别协议**（**SLA**）来衡量的。在大多数情况下，SLA规定了应用程序必须保持可操作的时间百分比。模式既涉及允许组件冗余，又使用技术来限制活动增加的影响。例如，基于队列的负载平衡模式使用队列来限制活动增加可能对应用程序的影响，充当调用者或客户端与应用程序或服务之间的缓冲。
- en: Resiliency and availability are identified here as related cloud solution factors
    as often a resilient application allows for a strict SLA on availability to be
    achieved.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性和可用性被确定为相关的云解决方案因素，因为通常一个具有弹性的应用程序可以实现严格的可用性SLA。
- en: Solution pattern
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案模式
- en: To ensure we have a system that has resilience and availability, our best bet
    is to look for a provider with a specific architecture. Enter **event-driven architecture**
    (**EDA**).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们拥有一个具有弹性和可用性的系统，我们最好寻找一个具有特定架构的提供商。进入**事件驱动架构**（**EDA**）。
- en: EDA is an architectural pattern that uses *events* to drive the behavior and
    activity of a system. The solution patterns available under it will help us achieve
    the intended resolutions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: EDA是一种使用*事件*来驱动系统行为和活动的架构模式。它下面提供的解决方案模式将帮助我们实现预期的解决方案。
- en: EDA
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EDA
- en: EDA promotes the concept of having loosely connected producers and consumers
    where the producers do not have direct knowledge of the consumers. An event in
    this context is any change ranging from a user logging onto a system, to an order
    being placed, to a process failing to complete successfully. EDA fits well in
    distributed systems and allows for highly scalable solutions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: EDA推广了松散连接的生产者和消费者的概念，其中生产者不直接了解消费者。在这种情况下，事件是指任何变化，从用户登录系统，到下订单，到进程无法成功完成。EDA非常适合分布式系统，并允许高度可扩展的解决方案。
- en: 'There are many related patterns and approaches to EDA and the following patterns
    are presented in this section as being directly relevant to EDA:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与EDA相关的模式和方法有很多，本节介绍的以下模式与EDA直接相关：
- en: Queue-Based Load Leveling
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于队列的负载平衡
- en: Publisher Subscriber
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布者-订阅者
- en: Priority Queue
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先队列
- en: Compensating Transaction
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补偿事务
- en: Queue-Based Load Leveling
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于队列的负载平衡
- en: 'Queue-Based Load Leveling is an effective way of minimizing the impact of occurrences
    of high demand on availability. By introducing a queue between a client and service,
    we are able to throttle or restrict the number of requests that are being handled
    by the service at a time. This allows for smoother user experience. Take the following
    diagram as an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 基于队列的负载平衡是一种有效的方式，可以最小化高需求对可用性的影响。通过在客户端和服务之间引入队列，我们能够限制或限制服务一次处理的请求数量。这可以实现更流畅的用户体验。以以下图表为例：
- en: '![](img/80878957-90a5-47bd-a052-acb18a6d198c.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80878957-90a5-47bd-a052-acb18a6d198c.png)'
- en: The preceding diagram shows a client submitting a request to a queue to be processed
    and the result saved to a table. The queue acts to prevent the function from being
    overwhelmed by a sudden spike in activity.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了客户端向队列提交请求进行处理，并将结果保存到表中。队列可以防止函数被突然的活动激增所压倒。
- en: Publisher Subscriber
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布者-订阅者
- en: 'The Publisher Subscriber pattern states that there are event publishers and
    event consumers. Essentially, this is the heart of EDA, as the publishers are
    decoupled from the consumers and are not concerned about the delivery of events
    to the consumers, but only with publishing events. The event will contain information
    that will be used to route the event to interested consumers. A consumer would
    then register or subscribe to being interested in specific events:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者-订阅者模式指出有事件发布者和事件消费者。基本上，这是EDA的核心，因为发布者与消费者解耦，不关心将事件传递给消费者，只关心发布事件。事件将包含信息，用于将事件路由到感兴趣的消费者。然后消费者将注册或订阅对特定事件感兴趣：
- en: '![](img/93444369-0f06-4847-b5ec-f974300ac2cd.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/93444369-0f06-4847-b5ec-f974300ac2cd.png)'
- en: The preceding diagram illustrates a Customer Service and an Order Service. The
    Customer Service acts as a publisher and submits an event when a customer is added.
    The Order Service has subscribed to new customer events. When a new customer event
    is received, the Order Service inserts the customer information into its local
    store.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了一个客户服务和一个订单服务。客户服务充当发布者，并在添加客户时提交事件。订单服务已订阅了新客户事件。当接收到新客户事件时，订单服务将客户信息插入其本地存储。
- en: By introducing the Publisher Subscriber pattern into the architecture, the Order
    Service is then decoupled from the Customer Service. An advantage of this is it
    provides a more flexible architecture for change. For example, a new service could
    be introduced to add new customers to the solutions that do not require being
    added to the same repository used by the Customer Service. Also, more than one
    service could subscribe to the new customer event. Adding a welcome email could
    more easily be added as a new subscriber, rather than having to build this functionality
    into a single monolithic solution.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将发布者-订阅者模式引入架构中，订单服务与客户服务解耦。这样做的一个优点是它为变更提供了更灵活的架构。例如，可以引入一个新服务来向不需要添加到客户服务使用的相同存储库的解决方案添加新客户。此外，可以有多个服务订阅新客户事件。添加欢迎电子邮件可以更容易地作为新的订阅者添加，而不必将此功能构建到单个的单片解决方案中。
- en: Priority Queue
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列
- en: Another related pattern is Priority Queue, which provides a mechanism for treating
    similar events differently. Using the new customer example from the previous section,
    it would be possible to have two subscribers for a new customer event. One subscriber
    would be interested in the majority of the new customers, while one subscriber
    would identify a subset of the customers that should be handled differently. For
    example, new subscribers from rural areas might receive an email with additional
    information about specialized shipping providers.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个相关的模式是优先队列，它提供了一种处理类似事件的不同机制。使用上一节中的新客户示例，可能会有两个订阅者对新客户事件感兴趣。一个订阅者可能对大多数新客户感兴趣，而另一个订阅者可能会识别应该以不同方式处理的客户子集。例如，来自农村地区的新订阅者可能会收到一封电子邮件，其中包含有关专门的运输提供商的额外信息。
- en: Compensating transaction
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 补偿事务
- en: 'With distributed systems, it is not always practical or desirable to issue
    a command as a transaction. A transaction in this context refers to a lower-level
    programming construct that manages one or more commands as a single action that
    either all succeeds or all fails. In some situations, a distributed transaction
    is not supported, or the overhead of using a distributed transaction outweighs
    the benefits. The Compensating Transaction pattern was developed to handle this
    situation. Let''s use the following as an example based on a BizTalk orchestration:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中，将命令作为事务发出并不总是切实可行或可取的。在这种情况下，事务是指管理一个或多个命令的较低级别的编程构造，将它们作为单个操作来处理，要么全部成功，要么全部失败。在某些情况下，不支持分布式事务，或者使用分布式事务的开销超过了好处。补偿事务模式是为处理这种情况而开发的。让我们以BizTalk协调为例：
- en: '![](img/e76b66c8-dbb6-4406-abf7-ff38d425fd48.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e76b66c8-dbb6-4406-abf7-ff38d425fd48.png)'
- en: 'The diagram shows two steps in a process: creating order in an Order Service
    and debiting funds from a Customer Service. The diagram shows how, first the order
    is created and then the funds are removed. If the debit of funds does not succeed
    then the order is removed from the Order Service.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 该图显示了一个过程中的两个步骤：在订单服务中创建订单和从客户服务中扣款。该图显示了首先创建订单，然后扣除资金。如果资金扣除不成功，则订单将从订单服务中移除。
- en: Security
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: Security ensures an application does not disclose information incorrectly or
    provide functionality outside of intended use. Security includes both malicious
    and accidental actions. With cloud applications and increasing use of a wide range
    of identity providers, restricting access to only approved users is often challenging.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 安全确保应用程序不会错误地披露信息或提供超出预期使用范围的功能。安全包括恶意和意外行为。随着云应用程序的增加以及广泛使用各种身份提供者，通常很难将访问权限限制为仅批准的用户。
- en: End-user authentication and authorization requires design and planning as fewer
    applications run in isolation, and it is common for multiple identity providers,
    such as Facebook, Google, and Microsoft, to be used. In some instances, patterns
    are used to provide access directly to resources for improved performance and
    scalability. Furthermore, other patterns are concerned with creating a virtual
    wall between clients and applications.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最终用户身份验证和授权需要设计和规划，因为较少的应用程序是独立运行的，通常会使用多个身份提供者，如Facebook、Google和Microsoft。在某些情况下，模式用于直接为改进性能和可伸缩性而提供对资源的访问。此外，其他模式涉及在客户端和应用程序之间创建虚拟墙壁。
- en: Solution patterns
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案模式
- en: As the industry has become more interconnected, the pattern of using an external
    party to authenticate users has become more common. The Federated Security pattern
    has been chosen for discussion here as it is one of the best ways to ensure security
    in our systems, and most **software-as-a-service (SaaS)** platforms offer this
    feature.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 随着行业的日益互联，使用外部方来对用户进行身份验证的模式变得更加普遍。联合安全模式被选择用于讨论，因为它是确保系统安全的最佳方式之一，大多数**软件即服务（SaaS）**平台都提供此功能。
- en: Federated security
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合安全
- en: Federated security delegates the authentication of user or service (consumer)
    to an external party known as an **identity provider** (**IdP**). An application
    using federated security will trust the IdP to properly authenticate the consumer
    and provide details about the consumer or claims accurately. This information
    about the consumer is presented as a token. A common scenario for this would be
    a web application using a social IdP such as Google, Facebook, or Microsoft.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 联合安全将用户或服务（消费者）的身份验证委托给称为**身份提供者**（**IdP**）的外部方。使用联合安全的应用程序将信任IdP正确地对消费者进行身份验证并准确提供有关消费者或声明的详细信息。有关消费者的这些信息被呈现为令牌。这种情况的常见场景是使用Google、Facebook或Microsoft等社交IdP的Web应用程序。
- en: 'Federated security can handle a variety of scenarios, from interactive sessions
    to authentication backend services or non-interactive sessions. Another common
    scenario is the ability to provide a single authentication experience or **single
    sign-on** (**SSO**) across a suite of separately hosted applications. This scenario
    allows for a single token to be acquired from a **security token service** (**STS**)
    and the same token used to present to the multiple applications without requiring
    the login procedure to be repeated:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 联合安全可以处理各种场景，从交互式会话到身份验证后端服务或非交互式会话。另一个常见的场景是能够在一套分别托管的应用程序中提供单一的身份验证体验或**单点登录**（**SSO**）。这种情况允许从**安全令牌服务**（**STS**）获取单个令牌，并且在不需要重复登录过程的情况下将相同的令牌用于多个应用程序：
- en: '![](img/8b8e558d-26c7-47d9-b3b8-1bdc16566e6f.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b8e558d-26c7-47d9-b3b8-1bdc16566e6f.png)'
- en: Federated security has two main purposes. First, it simplifies the management
    of identities by having a single identity store. This allows for identities to
    be managed in a central and unified manner, making it easier to perform management
    tasks such as providing the login experience, forgotten password management, as
    well as revoking passwords in a consistent manner. Secondly, it provides a better
    user experience by offering users a similar experience across multiple applications
    as well as requiring only a single form of authentication, instead of needing
    to remember multiple passwords.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 联合安全有两个主要目的。首先，通过拥有单一身份存储库，简化身份管理。这允许以集中和统一的方式管理身份，使得执行管理任务（如提供登录体验、忘记密码管理以及一致地撤销密码）更容易。其次，通过为用户提供类似的体验跨多个应用程序，以及只需要记住单个密码而不是多个密码，提供更好的用户体验。
- en: There are several standards for federated security and two widely used ones
    are **Security Assertion Markup Language** (**SAML**) and **OpenId Connect** (**OIDC**).
    SAML is older than OIDC and allows for the exchange of messages using an XML SAML
    format. OIDC is built upon OAuth 2.0 and commonly uses **JSON Web Token** (**JWT**)
    for describing the security token. Both formats support federated security, SSO,
    and many public IdPs such as Facebook, Google, and Microsoft support both standards.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种联合安全标准，其中两种广泛使用的是**安全断言标记语言**（**SAML**）和**OpenId Connect**（**OIDC**）。SAML比OIDC更早，允许使用XML
    SAML格式交换消息。OIDC建立在OAuth 2.0之上，通常使用**JSON Web Token**（**JWT**）来描述安全令牌。这两种格式都支持联合安全、单点登录（SSO），许多公共IdP（如Facebook、Google和Microsoft）都支持这两种标准。
- en: Application design
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序设计
- en: The design of an application can vary significantly and be influenced by many
    factors. These factors are not only technical but are influenced by the teams
    involved in building, managing, and maintaining the applications. Some patterns,
    for example, work best with small dedicated teams as opposed to a larger number
    of geographically dispersed teams. Other design-related patterns handle different
    types of workload better and are used in specific scenarios. Other patterns have
    been designed around the frequency of change and how to limit the disruption of
    changes to an application once it has been released to users.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的设计可以有很大的变化，并受到许多因素的影响。这些因素不仅仅是技术上的，而且受到参与构建、管理和维护应用程序的团队的影响。例如，一些模式最适合小型专门团队，而不适合较大数量的地理分散的团队。其他与设计相关的模式更好地处理不同类型的工作负载，并在特定场景中使用。其他模式是围绕变更的频率设计的，以及如何限制应用程序发布后的变更中断。
- en: Solution patterns
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案模式
- en: As almost all on-premises patterns are applicable to cloud-based solutions,
    the scope of patterns that could be covered is staggering. The Cache and CQRS
    patterns have been chosen because the former is a very common pattern employed
    by most web applications and the latter shifts how designers think of building
    solutions and lends itself well to other architectural patterns such as SOA and
    microservices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的本地模式都适用于基于云的解决方案，可以涵盖的模式范围令人震惊。缓存和CQRS模式之所以被选择，是因为前者是大多数Web应用程序采用的非常常见的模式，而后者改变了设计者构建解决方案的方式，并且非常适合其他架构模式，如SOA和微服务。
- en: Cache
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: 'Storing information retrieved from slower forms of storage into faster forms
    of storage, or caching, has been a technique that has been used in programming
    for decades and can be seen in software such as a browser cache and hardware such
    as RAM. In this chapter, we will look at three examples: Cache-aside, Write-through
    Cache, and Static Content Hosting.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将从较慢的存储中检索的信息存储到更快的存储中，或者进行缓存，是几十年来编程中使用的一种技术，可以在浏览器缓存等软件和RAM等硬件中看到。在本章中，我们将看到三个例子：缓存旁路、写入穿透缓存和静态内容托管。
- en: Cache-aside
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存旁路
- en: 'The Cache-aside pattern can be used to improve performance by loading frequently
    referenced data in a local or faster form of storage. With this pattern, it is
    the responsibility of the application to maintain the state of the cache. This
    is illustrated in the following diagram:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存旁路模式可以通过在本地或更快的存储中加载频繁引用的数据来提高性能。使用此模式，应用程序负责维护缓存的状态。如下图所示：
- en: '![](img/0fd306bb-6874-4916-83c7-54ffcdd30e3f.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fd306bb-6874-4916-83c7-54ffcdd30e3f.png)'
- en: First, the application requests information from the cache. If the information
    is missing, then it is requested from the data store. The application then updates
    the cache with the information. Once the information is stored, it will then be
    retrieved from the cache and used without referencing the slower data store. With
    this pattern, it is the application's responsibility to maintain the cache, both
    when there is a cache miss, and when the data is updated.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，应用程序从缓存中请求信息。如果信息丢失，则从数据存储中请求。然后，应用程序使用信息更新缓存。一旦信息存储，它将从缓存中检索并在不引用较慢的数据存储的情况下使用。使用此模式，应用程序负责维护缓存，无论是在缓存未命中时，还是在数据更新时。
- en: The term *cache miss* refers to when data is not found in the cache. In other
    words, it is missing from the cache.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*缓存未命中*指的是在缓存中找不到数据。换句话说，它在缓存中丢失了。
- en: Write-through cache
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入穿透缓存
- en: 'The Write-through Cache pattern can also be used to improve performance in
    a similar manner as the Cache-aside pattern. Its approach differs by moving the
    management of the cache''s content from the application to the cache itself, as
    shown in the following diagram:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 写入穿透缓存模式也可以像缓存旁路模式一样用于提高性能。其方法不同之处在于将缓存内容的管理从应用程序移动到缓存本身，如下图所示：
- en: '![](img/2b8f50a0-1ebe-44cd-943e-2011381bb41e.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b8f50a0-1ebe-44cd-943e-2011381bb41e.png)'
- en: A request is made for a piece of information in the cache. If the data is not
    already loaded, then the information is retrieved from the data store, placed
    in the cache, and then returned. If the data was already held, then it is immediately
    returned. This pattern supports updating the cache by passing the write of the
    information through the cache service. The cache service then updates the information
    held, both in the cache and in the data store.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在缓存中请求一条信息。如果数据尚未加载，则从数据存储中检索信息，将其放入缓存，然后返回。如果数据已经存在，则立即返回。这种模式支持通过缓存服务传递信息的写入来更新缓存。然后，缓存服务更新保存的信息，无论是在缓存中还是在数据存储中。
- en: Static Content Hosting
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态内容托管
- en: 'The Static Content Hosting pattern moves static content such as media images,
    movies, and other non-dynamic files to a system dedicated for fast retrieval.
    A specialized service for this is called a **content delivery network** (**CDN**),
    which manages to distribute content across multiple data centers and directs requests
    to the data center closest to the caller, as shown in the following diagram:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 静态内容托管模式将媒体图像、电影和其他非动态文件等静态内容移动到专门用于快速检索的系统中。这样的专门服务称为**内容传递网络**（**CDN**），它可以管理跨多个数据中心的内容分发，并将请求定向到最接近调用者的数据中心，如下图所示：
- en: '![](img/d72bd427-be1a-4e5b-b152-8c8bc6e0ec2d.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d72bd427-be1a-4e5b-b152-8c8bc6e0ec2d.png)'
- en: Static Content Hosting is a common pattern for web applications where a dynamic
    page is requested from the web application and the page contains a collection
    of static content, such as JavaScript and images, which the browser then retrieves
    directly from the CDN. This is an effective way to reduce the traffic on the web
    application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 静态内容托管是Web应用程序的常见模式，其中从Web应用程序请求动态页面，页面包含静态内容的集合，例如JavaScript和图像，然后浏览器直接从CDN中检索。这是减少Web应用程序流量的有效方法。
- en: Command and Query Responsibility Segregation
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令和查询责任分离
- en: '**Command and Query Responsibility Segregation** (**CQRS**) is a great software
    pattern to discuss in more detail as it is conceptually simple and relatively
    easy to implement but has dramatic implications to both the application and the
    developers involved. The pattern clearly separates the commands that affect the
    state of the application from queries that only retrieve data. Simply put, commands
    such as updates, adds, and deletes are provided in different services from the
    queries that do not change any data.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令和查询职责分离**（CQRS）是一个很好的软件模式，我们将在更多细节上讨论它，因为它在概念上很简单，相对容易实现，但对应用程序和涉及的开发人员有着巨大的影响。该模式清晰地将影响应用程序状态的命令与仅检索数据的查询分开。简而言之，更新、添加和删除等命令在不同的服务中提供，而不会改变任何数据的查询则在不同的服务中提供。'
- en: You might say *CQRS again!* and we recognize that we have used an example of
    CQRS in OOP and database design. The same principle does apply to many areas of
    software development. We are presenting CQRS in this section as a pattern for
    service design as it leads to some interesting benefits and fits well in modern
    patterns such as microservices and reactive application design.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会说*又是CQRS*！我们意识到我们在面向对象编程和数据库设计中使用了CQRS的示例。同样的原则也适用于软件开发的许多领域。我们在本节中提出CQRS作为服务设计的一种模式，因为它带来了一些有趣的好处，并且与微服务和反应式应用程序设计等现代模式非常契合。
- en: CQRS is based on the object-oriented design presented in the late 1980s by Bertrand
    Meyer's book, *Object-Oriented Software Construction*: [http://se.ethz.ch/~meyer/publications/](http://se.ethz.ch/~meyer/publications/).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS基于贝尔特兰·梅耶（Bertrand Meyer）在上世纪80年代末出版的《面向对象的软件构造》一书中提出的面向对象设计：[http://se.ethz.ch/~meyer/publications/](http://se.ethz.ch/~meyer/publications/)。
- en: 'If we revisit [Chapter 5](fd71001a-4673-4391-a10b-2490e07f135e.xhtml): *Implementing
    Design Patterns - .NET Core*, we illustrated this pattern by splitting our inventory
    context into two interfaces: `IInventoryReadContext` and `IInventoryWriteContext`.
    As a reminder, here are the interfaces:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新访问[第5章](fd71001a-4673-4391-a10b-2490e07f135e.xhtml)：*实现设计模式-.NET Core*，我们通过将库存上下文拆分为两个接口：`IInventoryReadContext`和`IInventoryWriteContext`来说明这种模式。作为提醒，这些是接口：
- en: '[PRE0]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we can see, the `GetBooks` method is separated from the two methods, `AddBook`
    and `UpdateQuantity`, that modify the state of the inventory. This illustrated
    CQRS within the code solution.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`GetBooks`方法与修改库存状态的`AddBook`和`UpdateQuantity`方法分开。这在代码解决方案中展示了CQRS。
- en: 'The same approach can be applied at a service level. If we use a service for
    maintaining inventory as an example, we would break the service between a service
    for updating the inventory and another service for retrieving the inventory. This
    is illustrates in the following diagram:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的方法也可以应用在服务层。举例来说，如果我们使用一个用于维护库存的服务，我们会将服务分为一个用于更新库存的服务和另一个用于检索库存的服务。下图展示了这一点：
- en: '![](img/54d55117-1d9a-43ec-85f4-67b74384663e.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54d55117-1d9a-43ec-85f4-67b74384663e.png)'
- en: Let's explore CQRS first by looking at the challenges of when it is applied
    in cloud-based solutions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过探讨CQRS来看看在基于云的解决方案中应用时所面临的挑战。
- en: Challenges of CQRS
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS的挑战
- en: 'There are significant challenges to using the CQRS pattern with services:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CQRS模式的挑战很大：
- en: Consistency
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一致性
- en: Adoption
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用
- en: Staleness is a measure of how closely data reflects the committed version of
    the data. Data, in most circumstances, has the potential to change, so, as soon
    as a piece of data is read, there is a chance that the data could be updated,
    making the read data become inconsistent with the source data. This is a challenge
    with all distributed systems where it is not practical to guarantee the value
    shown to a user reflects the source value. When the data directly reflects what
    is stored, we can call the data consistent; when the data does not, it is viewed
    as inconsistent.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 陈旧性是数据反映已提交数据版本的程度。在大多数情况下，数据可能会发生变化，因此，一旦读取了一部分数据，就有可能更新数据，使读取的数据与源数据不一致。这是所有分布式系统都面临的挑战，因为不可能保证向用户显示的值反映源值。当数据直接反映存储的内容时，我们可以称数据是一致的；当数据不是这样时，就被视为不一致。
- en: A common term used in distributed systems is *eventual consistency*. Eventual
    consistency is used to say a system will over time become consistent. In other
    words, it will eventually become consistent.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式系统中常用的一个术语是*最终一致性*。最终一致性用于表示系统最终会变得一致。换句话说，它最终会变得一致。
- en: The other more subtle challenge is adoption. Implementing CQRS into an established
    development team can be met with resistance both from developers and designers
    who are unfamiliar with the pattern and may lack support from the business for
    deviating from current design patterns.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更微妙的挑战是采用。将CQRS引入已建立的开发团队可能会遇到抵制，无论是来自不熟悉该模式的开发人员和设计师，还是来自业务方面对偏离当前设计模式的支持不足。
- en: So what are the benefits?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 那么有什么好处呢？
- en: Why CQRS?
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择CQRS？
- en: 'The following are three compelling factors for using CQRS:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用CQRS的三个引人注目的因素：
- en: '**Collaboration**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**'
- en: '**Model separation**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型分离**'
- en: '**Independent scalability**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立扩展性**'
- en: With separate services, we can then maintain, deploy, and scale these services
    independently. This increases the level of collaboration we can achieve between
    the development teams.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分开的服务，我们可以独立地维护、部署和扩展这些服务。这增加了开发团队之间可以实现的协作水平。
- en: By having separate services, we can use a model that best fits our service.
    The command service might use simple SQL statements directly against a database,
    as that is the most familiar technology to the team responsible, while the team
    building the query service might use a framework for handling complex statements
    against the database.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有独立的服务，我们可以使用最适合我们服务的模型。命令服务可能直接使用简单的SQL语句针对数据库，因为这是负责团队最熟悉的技术，而构建查询服务的团队可能会使用一个处理复杂语句针对数据库的框架。
- en: Most solutions tend to have a higher level of reads than writes (or vice versa)
    so splitting the services along this criterion makes sense in many scenarios.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数解决方案往往具有更高的读取量而不是写入量（或反之），因此根据这一标准将服务进行拆分在许多情况下是有意义的。
- en: DevOps
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevOps
- en: With cloud-based solutions, the data center is remotely hosted and you often
    do not have full control or access to all aspects of an application. In some cases,
    such as serverless services, the infrastructure is abstracted away. An application
    must still expose information about a running application that can be used to
    manage and monitor an application. Patterns used to manage and monitor are essential
    for the success of an application by providing both the ability to keep an application
    running healthily as well as providing strategic information to the business.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过基于云的解决方案，数据中心是远程托管的，通常您无法完全控制或访问应用程序的所有方面。在某些情况下，例如无服务器服务，基础架构被抽象化了。应用程序仍然必须公开有关运行应用程序的信息，以便用于管理和监视应用程序。用于管理和监视的模式对于应用程序的成功至关重要，因为它们既能够保持应用程序的健康运行，又能够为业务提供战略信息。
- en: Solution patterns
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案模式
- en: With the availability of commercial packages relating to monitoring and managing
    solutions, many businesses have gained better control and understanding of their
    distributed systems. Telemetry and continuous delivery/continuous integration
    have been chosen to cover in more detail as they have particular value in cloud-based
    solutions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 随着与监控和管理解决方案相关的商业软件包的可用性，许多企业已经更好地控制和了解了他们的分布式系统。遥测和持续交付/持续集成已被选择进行更详细的覆盖，因为它们在基于云的解决方案中具有特殊价值。
- en: Telemetry
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遥测
- en: 'As the software industry has evolved and distributed systems involve more services
    and applications, being able to have a collective and consistent view of a system
    has become a huge asset. Popularized by services such as New Relic and Microsoft
    Application Insights, **application performance management** (**APM**) systems
    use information recorded about applications and infrastructure, known as telemetry,
    to monitor, manage performance, and view the availability of a system. In cloud-based
    solutions, where it is often not possible or practical to gain direct access to
    the infrastructure of a system, an APM allows for telemetry to be sent to a central
    service, digested, and then presented to operations and the business, as shown
    in the following diagram:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件行业的发展和分布式系统涉及更多的服务和应用程序，能够对系统进行集体和一致的视图已经成为一项巨大的资产。由New Relic和Microsoft
    Application Insights等服务推广，应用程序性能管理（APM）系统使用记录的有关应用程序和基础设施的信息，即遥测，来监视、管理性能和查看系统的可用性。在基于云的解决方案中，通常无法或不实际直接访问系统的基础设施，APM允许将遥测发送到中央服务，然后呈现给运营和业务，如下图所示：
- en: '![](img/3799f3e4-3f09-45ba-b16e-43093c14d35c.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3799f3e4-3f09-45ba-b16e-43093c14d35c.png)'
- en: The preceding diagram is taken from Microsoft Application Insights and provides
    a high-level snapshot of a running web application. At a glance, operations can
    identify changes in the behavior of the system and react accordingly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上图摘自Microsoft Application Insights，提供了一个正在运行的Web应用程序的高层快照。一眼就可以看出，运营人员可以识别系统行为的变化并做出相应反应。
- en: Continuous integration/continuous deployment
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成/持续部署
- en: '**Continuous integration/continuous deployment** (**CI/CD**) is a modern development
    process designed to streamline the **software delivery product life cycle** (**SDLC**)
    by merging changes frequently and deploying those changes often. CI addresses
    the issues that arise in enterprise software development where multiple programmers
    are working on the same code base or when a single product is managed with multiple
    code branches.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成/持续部署（CI/CD）是一种现代开发流程，旨在通过频繁合并更改并经常部署这些更改来简化软件交付产品生命周期。CI解决了企业软件开发中出现的问题，即多个程序员正在同一代码库上工作，或者单个产品由多个代码分支管理。
- en: 'Take a look at the following diagram:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图表：
- en: '![](img/242a34d7-263b-49fd-bcbd-c06e5fe5d85c.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/242a34d7-263b-49fd-bcbd-c06e5fe5d85c.png)'
- en: 'In the preceding example, there are three target environments: Development,
    **User Acceptance Testing** (**UAT**), and Production. The Development environment
    is the initial environment where all the changes made to an application are tested
    together. The UAT environment is used by the **Quality Assurance** (**QA**) team
    to verify the system is working as intended before the changes are moved to a
    customer-facing environment, referred to in the diagram as Production. The code
    base has been broken into three matching branches: the trunk which all changes
    by the development team are merged into, UAT, which is used to deploy to the UAT
    environment, and the Production code base, which is used to deploy into the Production
    environment.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，有三个目标环境：开发、用户验收测试（UAT）和生产。开发环境是最初的环境，所有对应用程序的更改都在此进行测试。UAT环境由质量保证（QA）团队用于在将更改移至面向客户的环境之前验证系统是否按预期工作，如图中所示的生产环境。代码库已分为三个匹配的分支：主干，开发团队将所有更改合并到其中，UAT用于部署到UAT环境，生产代码库用于部署到生产环境。
- en: The CI pattern is applied by creating a new build when the code base changes.
    After a successful build, a suite of unit tests is run against the build to ensure
    existing functionality has not been broken. If a build is not successful, the
    development team investigates and either fixes the code base or the unit test
    so the build then passes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: CI模式是通过在代码库更改时创建新构建来应用的。成功构建后，会对构建运行一系列单元测试，以确保现有功能未被破坏。如果构建不成功，开发团队会进行调查，然后修复代码库或单元测试，使构建通过。
- en: Successful builds are then pushed to a target environment. The Trunk might be
    set to push a new build automatically once a day to the Integration environment,
    while the QA team has requested less disturbance in the environment, so a new
    build is only pushed once a week after office hours. Production might require
    a manual trigger to coordinate new releases as to announce the new features and
    bug fixes in a formal release.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的构建然后被推送到目标环境。主干可能被设置为每天自动将新构建推送到集成环境，而QA团队要求环境中的干扰更少，因此新构建仅在办公时间结束后每周推送一次。生产可能需要手动触发以协调新版本的发布，以宣布新功能和错误修复的正式发布。
- en: There is confusion over the terms *continuous deployment* and *continuous delivery*.
    Many sources differentiate the two terms as to whether the process of deploying
    is automated or manual. In other words, continuous deployment requires automated
    continuous delivery.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“持续部署”和“持续交付”这两个术语存在混淆。许多来源区分这两个术语，即部署过程是自动化的还是手动的。换句话说，持续部署需要自动化的持续交付。
- en: The trigger to cause a merge between environments and therefore a build to be
    pushed to an environment, or released, might differ. In our illustration for the
    Development environment, we have a set of automated tests that are run against
    new builds automatically. If the tests are successful, then the merge is automatically
    performed from the Trunk to the UAT code base. The merge between UAT and Production
    code bases is only performed once the QA team has signed off or accepted the changes
    in the UAT environment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 导致环境之间合并的触发器，从而推送到环境中进行构建，或者发布，可能会有所不同。在我们对开发环境的示例中，有一组自动化测试会自动运行对新构建进行测试。如果测试成功，那么就会自动从主干合并到UAT代码库。只有在QA团队在UAT环境中签署或接受更改后，才会在UAT和生产代码库之间执行合并。
- en: Each enterprise will tailor the CI/CD process to fit their particular SDLC and
    business requirements. A public-facing website, for example, might require a rapid
    SDLC to stay competitive in the market, whereas an internal application might
    require a more conservative approach to limit the disruption caused by changing
    functionality without staff training.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每个企业都会根据其特定的SDLC和业务需求来定制CI/CD流程。例如，一个面向公众的网站可能需要快速的SDLC以保持市场竞争力，而内部应用可能需要更保守的方法，以限制由于功能变更而导致的员工培训。
- en: Regardless, suites of tools have been developed to manage the CI/CD process
    within an organization. Azure DevOps, for example, helps to manage this process
    by allowing for a pipeline to be built to handle when builds are created and when
    they are released to environments, including both manual and automated triggers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，已经开发了一套工具套件来管理组织内的CI/CD流程。例如，Azure DevOps可以通过允许构建管道来处理构建何时创建以及何时发布到环境中，包括手动和自动触发器。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Cloud development requires careful planning, maintenance, and monitoring, and
    patterns can help achieve highly scalable, reliable, and secure solutions. Many
    of the patterns discussed in this chapter are applicable to on-premises applications
    and are essential in cloud solutions. The design of a cloud-first application
    should consider many factors, including scalability, availability, maintenance,
    monitoring, and security.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 云开发需要仔细的规划、维护和监控，模式可以帮助实现高度可扩展、可靠和安全的解决方案。本章讨论的许多模式适用于本地应用程序，并且在云解决方案中至关重要。云优先应用程序的设计应考虑许多因素，包括可扩展性、可用性、维护、监控和安全性。
- en: A scalable application allows for fluctuations in system load while maintaining
    an acceptable level of performance. The load can be measured in the number of
    users, concurrent processes, amount of data, and other factors in software. The
    ability to scale a solution horizontally requires a particular type of application
    development and is a paradigm that is especially significant to cloud computing.
    Patterns such as Queue-Based Load Leveling are a great technique to ensure solutions
    remain responsive under an increased load.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展的应用程序允许在系统负载波动时保持可接受的性能水平。负载可以通过用户数量、并发进程、数据量和软件中的其他因素来衡量。横向扩展解决方案的能力需要特定类型的应用程序开发，并且是云计算中特别重要的范例。诸如基于队列的负载平衡之类的模式是确保解决方案在负载增加时保持响应的重要技术。
- en: Many of the patterns covered in this chapter are complementary. For example,
    an application following the Command and Query Responsibility Segregation might
    leverage federated security for providing a single sign-on experience and use
    an event-driven architecture to handle consistency across the different components
    of an application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的许多模式是互补的。例如，遵循命令和查询责任分离的应用程序可能利用联合安全来提供单一登录体验，并使用事件驱动架构来处理应用程序不同组件之间的一致性。
- en: In cloud-based solutions, there is a near-endless collection of applicable patterns
    that address different challenges in distributed systems. The patterns presented
    in this chapter represent a selection chosen for their breadth, as well as how
    they complement one another. Please see the references to explore other patterns
    suitable in cloud-based solutions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于云的解决方案中，有一个几乎无穷无尽的适用模式集合，用于解决分布式系统中的不同挑战。本章介绍的模式代表了因其广度以及它们如何相互补充而被选择的一部分。请参阅参考资料，以探索适用于基于云的解决方案的其他模式。
- en: What a journey! We have covered patterns from software design patterns used
    in object-oriented programming and architectural patterns used in cloud-based
    solutions, to business patterns for more efficient teams and patterns for building
    successful applications. Though we tried to cover a wide range of patterns, there
    are bound to be ones that could have, and should have, been added.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 多么不容易啊！我们已经涵盖了从面向对象编程中使用的软件设计模式到基于云的解决方案中使用的架构模式，再到用于构建成功应用程序的更高效团队和模式。尽管我们尽力涵盖了各种模式，但肯定还有一些模式可能本该被添加进来。
- en: With that, thank you from Gaurav and Jeffrey and we hope you enjoyed and gained
    something from reading *Hands-On Design Patterns with C# and .NET Core*. Please
    let us know what you think and share with us your favorite patterns.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 谢谢，Gaurav和Jeffrey，希望您喜欢并从阅读*使用C#和.NET Core进行设计模式实践*中获得了一些收获。请告诉我们您的想法，并与我们分享您最喜欢的模式。
- en: Questions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将让您巩固本章中包含的信息：
- en: Most patterns have been developed recently and only apply to cloud-based applications.
    True or false?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数模式是最近开发的，只适用于基于云的应用程序。真还是假？
- en: 'An ESB stands for what, and can be used in what type of architecture: EDA,
    SOA or monolithic?'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ESB代表什么，并且可以在哪种类型的架构中使用：EDA、SOA还是单片？
- en: Is Queue-Based Load Leveling primarily used for DevOps, scalability, or availability?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 队列负载平衡主要用于DevOps、可伸缩性还是可用性？
- en: What are the benefits of CI/CD? Would it be more beneficial in a large number
    of globally dispersed teams or a single small team of collocated developers?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CI/CD的好处是什么？在全球分散的大量团队还是一个小型的本地开发团队中，它会更有益？
- en: In a website following Static Content Hosting, does a browser retrieve images
    and static content directly through a CDN, or does the web application retrieve
    the information on behalf of the browser?
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在遵循静态内容托管的网站中，浏览器是直接通过CDN检索图像和静态内容，还是Web应用程序代表浏览器检索信息？
- en: Further reading
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics covered in this chapter, refer to the following
    books. These books will provide you with various in-depth and hands-on exercises
    on the topics that have been covered in this chapter:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解本章涵盖的主题，请参考以下书籍。这些书籍将为您提供有关本章涵盖的各种主题的深入和实践性练习：
- en: '*Azure Serverless Computing Cookbook,* by *Praveen Kumar Sreeram,* published
    by *Packt Publishing*: [https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook](https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Azure无服务器计算食谱*，作者*Praveen Kumar Sreeram*，由*Packt Publishing*出版：[https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook](https://www.packtpub.com/in/virtualization-and-cloud/azure-serverless-computing-cookbook)'
- en: '*Microservices with Azure,* by *Namit Tanasseri* *and Rahul Rai*, published
    by *Packt Publishing*: [https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure](https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Azure的微服务*，作者*Namit Tanasseri*和*Rahul Rai*，由*Packt Publishing*出版：[https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure](https://www.packtpub.com/in/virtualization-and-cloud/microservices-azure)'
- en: '*Hands-On Azure for Developers,* by *Kamil Mrzygłód,* published by *Packt Publishing*: [https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*面向开发人员的Azure实践*，作者*Kamil Mrzygłód*，由*Packt Publishing*出版：[https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers](https://www.packtpub.com/virtualization-and-cloud/hands-azure-developers)'
- en: '*Building Microservices with .NET Core 2.0 - Second Edition* by *Gaurav Aroraa*,
    published by *Packt Publishing*: [https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition](https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition).'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用.NET Core 2.0构建微服务-第二版*，作者*Gaurav Aroraa*，由*Packt Publishing*出版：[https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition](https://www.packtpub.com/application-development/building-microservices-net-core-20-second-edition)。'
