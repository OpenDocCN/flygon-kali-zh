- en: '*Chapter 4*: Scaling and Deploying Your Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：扩展和部署您的应用程序'
- en: In this chapter, we will learn about the higher-level Kubernetes resources that
    are used to run applications and control Pods. First, we'll cover the drawbacks
    of the Pod, before moving on to the simplest Pod controller, ReplicaSets. From
    there we will move on to Deployments, the most popular method for deploying applications
    to Kubernetes. Then we'll cover special resources to help you deploy specific
    types of applications – Horizontal Pod Autoscalers, DaemonSets, StatefulSets,
    and Jobs. Finally, we'll put it all together with a full example of how to run
    a complex application on Kubernetes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习用于运行应用程序和控制Pod的高级Kubernetes资源。首先，我们将介绍Pod的缺点，然后转向最简单的Pod控制器ReplicaSets。然后我们将转向部署，这是将应用程序部署到Kubernetes的最流行方法。然后，我们将介绍特殊资源，以帮助您部署特定类型的应用程序–水平Pod自动缩放器、DaemonSets、StatefulSets和Jobs。最后，我们将通过一个完整的示例将所有内容整合起来，演示如何在Kubernetes上运行复杂的应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding Pod drawbacks and their solutions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Pod的缺点及其解决方案
- en: Using ReplicaSets
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ReplicaSets
- en: Controlling Deployments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制部署
- en: Harnessing the Horizontal Pod Autoscaler
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用水平Pod自动缩放
- en: Implementing DaemonSets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施DaemonSets
- en: Reviewing StatefulSets and Jobs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审查StatefulSets和Jobs
- en: Putting it all together
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to run the commands detailed in this chapter, you will need a computer
    that supports the `kubectl` command-line tool along with a working Kubernetes
    cluster. See [*Chapter 1*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016), *Communicating
    with Kubernetes*, for several methods to get up and running with Kubernetes quickly,
    and for instructions on how to install the `kubectl` tool.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本章中详细介绍的命令，您需要一台支持`kubectl`命令行工具的计算机，以及一个可用的Kubernetes集群。请参阅[*第1章*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016)，*与Kubernetes通信*，了解快速启动和运行Kubernetes的几种方法，以及如何安装`kubectl`工具的说明。
- en: The code used in this chapter can be found in the book's GitHub repository at
    [https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter4](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter4).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在书籍的GitHub存储库中找到[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter4](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter4)。
- en: Understanding Pod drawbacks and their solutions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Pod的缺点及其解决方案
- en: As we reviewed in the previous chapter, [*Chapter 3*](B14790_03_Final_PG_ePub.xhtml#_idTextAnchor091),
    *Running Application Containers on Kubernetes*, a Pod in Kubernetes is an instance
    of one or more application containers that run on a node. Creating just one Pod
    is enough to run an application the same way you would in any other container.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章[*第3章*](B14790_03_Final_PG_ePub.xhtml#_idTextAnchor091)中所回顾的，*在Kubernetes上运行应用程序容器*，在Kubernetes中，Pod是在节点上运行一个或多个应用程序容器的实例。创建一个Pod就足以像在任何其他容器中一样运行应用程序。
- en: That being said, using a single Pod to run an application ignores many of the
    benefits of running containers in the first place. Containers allow us to treat
    each instance of our application as a stateless item that can be scaled up or
    down to meet demand by spinning up new instances of the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，使用单个Pod来运行应用程序忽略了在容器中运行应用程序的许多好处。容器允许我们将应用程序的每个实例视为一个可以根据需求进行扩展或缩减的无状态项目，通过启动应用程序的新实例来满足需求。
- en: This has the benefits of both allowing us to scale our application easily and
    making our application more available by providing multiple instances of our application
    at a given time. If one of our instances crashes, the application will still continue
    to function, and will automatically scale to pre-crash levels. The way we do this
    on Kubernetes is by using a Pod controller resource.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这既可以让我们轻松扩展应用程序，又可以通过在给定时间提供多个应用程序实例来提高应用程序的可用性。如果我们的一个实例崩溃，应用程序仍将继续运行，并将自动扩展到崩溃前的水平。在Kubernetes上，我们通过使用Pod控制器资源来实现这一点。
- en: Pod controllers
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod控制器
- en: Kubernetes provides several choices for Pod controllers out of the box. The
    simplest option is to use a ReplicaSet, which maintains a given number of Pod
    instances for a particular Pod. If one instance fails, the ReplicaSet will spin
    up a new instance to replace it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了几种Pod控制器的选择。最简单的选择是使用ReplicaSet，它维护特定Pod的给定数量的实例。如果一个实例失败，ReplicaSet将启动一个新实例来替换它。
- en: Secondly, there are Deployments, which themselves control a ReplicaSet. Deployments
    are the most popular controller when it comes to running an application on Kubernetes,
    and they make it easy to upgrade applications using a rolling update across a
    ReplicaSet.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，有部署，它们自己控制一个ReplicaSet。在Kubernetes上运行应用程序时，部署是最受欢迎的控制器，它们使得通过ReplicaSet进行滚动更新来升级应用程序变得容易。
- en: Horizontal Pod Autoscalers take Deployments to the next level by allowing applications
    to autoscale to different numbers of instances based on performance metrics.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 水平Pod自动缩放器将部署带到下一个级别，允许应用根据性能指标自动缩放到不同数量的实例。
- en: 'Finally, there are a few specialty controllers that may be valuable in certain
    situations:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在某些特定情况下可能有一些特殊的控制器可能是有价值的：
- en: DaemonSets, which run an instance of the application on each node and maintain
    them
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DaemonSets，每个节点上运行一个应用程序实例并维护它们
- en: StatefulSets, where the Pod identity is kept static to assist in running stateful
    workloads
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: StatefulSets，其中Pod身份保持静态以帮助运行有状态的工作负载
- en: Jobs, which start, run to completion, and then shut down on a specified number
    of Pods
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业，它在指定数量的Pod上启动，运行完成，然后关闭。
- en: 'The actual behavior of a controller, be it a default Kubernetes controller
    like a ReplicaSet or a custom controller (for instance, the PostgreSQL Operator),
    should be easy to predict. A simplified view of the standard control loop looks
    something like the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的实际行为，无论是默认的Kubernetes控制器，如ReplicaSet，还是自定义控制器（例如PostgreSQL Operator），都应该很容易预测。标准控制循环的简化视图看起来像下面的图表：
- en: '![Figure 4.1 – A basic control loop for a Kubernetes controller](image/B14790_04_001.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1- Kubernetes控制器的基本控制循环](image/B14790_04_001.jpg)'
- en: Figure 4.1 – A basic control loop for a Kubernetes controller
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1- Kubernetes控制器的基本控制循环
- en: As you can see, the controller constantly checks the **Intended cluster state**
    (we want seven Pods of this app) against the **Current cluster state** (we have
    five Pods of this app running). When the intended state does not match the current
    state, the controller will take action via the API to correct the current state
    to match the intended state.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，控制器不断地检查**预期的集群状态**（我们希望有七个此应用程序的Pod）与**当前的集群状态**（我们有五个此应用程序的Pod正在运行）是否匹配。当预期状态与当前状态不匹配时，控制器将通过API采取行动来纠正当前状态以匹配预期状态。
- en: 'By now, you should understand why controllers are necessary on Kubernetes:
    the Pod itself is not a powerful enough primitive when it comes to delivering
    highly available applications. Let''s move on to the simplest such controller:
    the ReplicaSet.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该明白为什么在Kubernetes上需要控制器：Pod本身在提供高可用性应用程序方面不够强大。让我们继续讨论最简单的控制器：ReplicaSet。
- en: Using ReplicaSets
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ReplicaSets
- en: ReplicaSets are the simplest Kubernetes Pod controller resource. They replace
    the older ReplicationController resource.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet是最简单的Kubernetes Pod控制器资源。它取代了较旧的ReplicationController资源。
- en: The major difference between a ReplicaSet and a ReplicationController is that
    a ReplicationController uses a more basic type of *selector* – the filter that
    determines which Pods should be controlled.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet和ReplicationController之间的主要区别在于ReplicationController使用更基本类型的*选择器*
    - 确定应该受控制的Pod的过滤器。
- en: While ReplicationControllers use simple equity-based (*key=value*) selectors,
    ReplicaSets use a selector with multiple possible formats, such as `matchLabels`
    and `matchExpressions`, which will be reviewed in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ReplicationControllers使用简单的基于等式（*key=value*）的选择器，但ReplicaSets使用具有多种可能格式的选择器，例如`matchLabels`和`matchExpressions`，这将在本章中进行审查。
- en: Important note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: There shouldn't be any reason to use a ReplicationController over a ReplicaSet
    – just stick with ReplicaSets unless you have a really good reason not to.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您有一个非常好的理由，否则不应该使用ReplicationController而应该使用ReplicaSet-坚持使用ReplicaSets。
- en: ReplicaSets allow us to inform Kubernetes to maintain a certain number of Pods
    for a particular Pod spec. The YAML for a ReplicaSet is very similar to that for
    a Pod. In fact, the entire Pod spec is nested in the ReplicaSet YAML, under the
    `template` key.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSets允许我们通知Kubernetes维护特定Pod规范的一定数量的Pod。ReplicaSet的YAML与Pod的YAML非常相似。实际上，整个Pod规范都嵌套在ReplicaSet的YAML中，位于`template`键下。
- en: 'There are also a few other key differences, which can be observed in the following
    code block:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他关键区别，可以在以下代码块中观察到：
- en: replica-set.yaml
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: replica-set.yaml
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, in addition to the `template` section, which is essentially
    a Pod definition, we have a `selector` key and a `replicas` key in our ReplicaSet
    spec. Let's start with `replicas`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，除了`template`部分（本质上是一个Pod定义），在我们的ReplicaSet规范中还有一个`selector`键和一个`replicas`键。让我们从`replicas`开始。
- en: Replicas
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 副本
- en: The `replicas` key specifies a replica count, which our ReplicaSet will ensure
    is always running at a given time. If a Pod dies or stops working, our ReplicaSet
    will create a new Pod to take its place. This makes the ReplicaSet a self-healing
    resource.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`replicas`键指定了副本数量，我们的ReplicaSet将确保在任何给定时间始终运行指定数量的副本。如果一个Pod死掉或停止工作，我们的ReplicaSet将创建一个新的Pod来替代它。这使得ReplicaSet成为一个自愈资源。'
- en: How does a ReplicaSet controller decide when a Pod stops working? It looks at
    the Pod's status. If the Pod's current status isn't "*Running*" or "*ContainerCreating*",
    the ReplicaSet will attempt to start a new Pod.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet控制器如何决定一个Pod何时停止工作？它查看Pod的状态。如果Pod的当前状态不是“*Running*”或“*ContainerCreating*”，ReplicaSet将尝试启动一个新的Pod。
- en: As we discussed in [*Chapter 3*](B14790_03_Final_PG_ePub.xhtml#_idTextAnchor091),
    *Running Application Containers on Kubernetes*, the Pod's status after container
    creation is driven by the liveness, readiness, and startup probes, which can be
    configured specifically for a Pod. This means that you can set up application-specific
    ways to know whether a Pod is broken in some way, and your ReplicaSet can jump
    in and start a new one in its place.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第3章*](B14790_03_Final_PG_ePub.xhtml#_idTextAnchor091)中讨论的那样，*在Kubernetes上运行应用容器*，容器创建后Pod的状态由存活探针、就绪探针和启动探针驱动，这些探针可以针对Pod进行特定配置。这意味着您可以设置特定于应用程序的方式来判断Pod是否以某种方式损坏，并且您的ReplicaSet可以介入并启动一个新的Pod来替代它。
- en: Selector
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择器
- en: The `selector` key is important because of the way a ReplicaSet works – it is
    a controller that is implemented with the selector at its core. The ReplicaSet's
    job is to ensure that the number of running Pods that match its selector is correct.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`selector`键很重要，因为ReplicaSet的工作方式是以选择器为核心实现的控制器。ReplicaSet的工作是确保与其选择器匹配的运行中的Pod数量是正确的。'
- en: Let's say, for instance, that you have an existing Pod running your application,
    `MyApp`. This Pod is labeled with a `selector` key as `App=MyApp`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，你有一个现有的 Pod 运行你的应用程序 `MyApp`。这个 Pod 被标记为 `selector` 键为 `App=MyApp`。
- en: Now let's say you want to create a ReplicaSet with the same app, which will
    add an additional three instances of your application. You create a ReplicaSet
    with the same selector, and specify three replicas, with the intent of running
    four instances in total, since you already have one running.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你想创建一个具有相同应用程序的 ReplicaSet，这将增加你的应用程序的三个额外实例。你使用相同的选择器创建一个 ReplicaSet，并指定三个副本，目的是总共运行四个实例，因为你已经有一个在运行。
- en: What will happen once you start the ReplicaSet? You'll find that the total number
    of Pods running that application will be three, not four. This is because a ReplicaSet
    has the ability to adopt orphaned Pods and bring them under its reign.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你启动 ReplicaSet，会发生什么？你会发现运行该应用程序的总 pod 数将是三个，而不是四个。这是因为 ReplicaSet 有能力接管孤立的
    pods 并将它们纳入其管理范围。
- en: When the ReplicaSet starts up, it sees that there is already an existing Pod
    matching its `selector` key. Depending on the number of replicas required, a ReplicaSet
    will shut down existing Pods or start new Pods that match the `selector` in order
    to create the correct number.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当 ReplicaSet 启动时，它会看到已经存在一个与其 `selector` 键匹配的现有 Pod。根据所需的副本数，ReplicaSet 将关闭现有的
    Pods 或启动新的 Pods，以匹配 `selector` 以创建正确的数量。
- en: Template
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: The `template` section contains the Pod and supports all the same fields as
    Pod YAMLs do, including the metadata section and the spec itself. Most other controllers
    follow this pattern – they allow you to define the Pod spec within the larger
    overall controller YAML.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`template` 部分包含 Pod，并支持与 Pod YAML 相同的所有字段，包括元数据部分和规范本身。大多数其他控制器都遵循这种模式 - 它们允许你在更大的控制器
    YAML 中定义 Pod 规范。'
- en: You should now understand the various parts of the ReplicaSet spec and what
    they do. Let's move on to actually running applications using our ReplicaSet.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该了解 ReplicaSet 规范的各个部分以及它们的作用。让我们继续使用我们的 ReplicaSet 来运行应用程序。
- en: Testing a ReplicaSet
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试 ReplicaSet
- en: Now, let's deploy our ReplicaSet.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们部署我们的 ReplicaSet。
- en: 'Copy the `replica-set.yaml` file listed previously and run it on your cluster
    using the following command in the same folder as your YAML file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 复制先前列出的 `replica-set.yaml` 文件，并在与你的 YAML 文件相同的文件夹中使用以下命令在你的集群上运行它：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To check that the ReplicaSet has been created properly, run `kubectl get pods`
    to fetch the Pods in the default namespace.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查 ReplicaSet 是否已正确创建，请运行 `kubectl get pods` 来获取默认命名空间中的 Pods。
- en: 'Since we haven''t specified a namespace for our ReplicaSet, it will be created
    by default. The `kubectl get pods` command should give you the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有为 ReplicaSet 指定命名空间，它将默认创建。`kubectl get pods` 命令应该给你以下结果：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, try deleting one of the ReplicaSet Pods by using the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试使用以下命令删除一个 ReplicaSet Pod：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A ReplicaSet will always try to keep the specified number of replicas online.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ReplicaSet 将始终尝试保持指定数量的副本在线。
- en: 'Let''s use our `kubectl get` command to see our running pods again:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `kubectl get` 命令再次查看我们正在运行的 pods：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, our ReplicaSet controller is starting a new pod to keep our
    number of replicas at three.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的 ReplicaSet 控制器正在启动一个新的 pod，以保持我们的副本数为三。
- en: 'Finally, let''s delete our ReplicaSet using the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用以下命令删除我们的 ReplicaSet：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With our cluster a bit cleaner, let's move on to a more complex controller –
    Deployments.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 清理了一下我们的集群，让我们继续学习一个更复杂的控制器 - 部署。
- en: Controlling Deployments
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制部署
- en: Though ReplicaSets contain much of the functionality you would want to run a
    high availability application, most of the time you will want to use Deployments
    to run applications on Kubernetes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然ReplicaSets包含了您想要运行高可用性应用程序的大部分功能，但大多数时候您会想要使用部署来在Kubernetes上运行应用程序。
- en: Deployments have a few advantages over ReplicaSets, and they actually work by
    owning and controlling a ReplicaSet.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 部署比ReplicaSets有一些优势，实际上它们通过拥有和控制一个ReplicaSet来工作。
- en: The main advantage of a Deployment is that it allows you to specify a `rollout`
    procedure – that is, how an application upgrade is deployed to the various pods
    in the Deployment. This lets you easily configure controls to stop bad upgrades
    in their tracks.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的主要优势在于它允许您指定`rollout`过程 - 也就是说，应用程序升级如何部署到部署中的各个Pod。这让您可以轻松配置控件以阻止糟糕的升级。
- en: 'Before we review how to do this, let''s look at the entire spec for a Deployment:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们回顾如何做到这一点之前，让我们看一下部署的整个规范：
- en: deployment.yaml
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: deployment.yaml
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see, this is very similar to the spec for a ReplicaSet. The difference
    we see here is a new key in the spec: `strategy`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这与ReplicaSet的规范非常相似。我们在这里看到的区别是规范中的一个新键：`strategy`。
- en: Using the `strategy` setting, we can tell our Deployment which way to upgrade
    our application, either via a `RollingUpdate`, or `Recreate`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`strategy`设置，我们可以告诉部署方式升级我们的应用程序，可以通过`RollingUpdate`或`Recreate`。
- en: '`Recreate` is a very basic deployment method: all Pods in the Deployment will
    be deleted at the same time, and new Pods will be created with the new version.
    `Recreate` doesn''t give us much control against a bad Deployment – if the new
    Pods don''t start for some reason, we''re stuck with a completely non-functioning
    application.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Recreate`是一种非常基本的部署方法：部署中的所有Pod将同时被删除，并将使用新版本创建新的Pod。`Recreate`不能给我们太多控制权来防止糟糕的部署
    - 如果由于某种原因新的Pod无法启动，我们将被困在一个完全无法运行的应用程序中。'
- en: With `RollingUpdate` on the other hand, Deployments are slower but far more
    controlled. Firstly, the new application will be rolled out bit by bit, Pod by
    Pod. We can specify values for `maxSurge` and `maxUnavailable` to tune the strategy.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用`RollingUpdate`，部署速度较慢，但控制更加严格。首先，新应用程序将逐步推出，逐个Pod。我们可以指定`maxSurge`和`maxUnavailable`的值来调整策略。
- en: A rolling update works like this – when the Deployment spec is updated with
    a new version of the Pod container, the Deployment will take down one Pod at a
    time, create a new Pod with the new application version, wait for the new Pod
    to register `Ready` as determined by the readiness check, and then move on to
    the next Pod.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动更新的工作方式是这样的 - 当部署规范使用Pod容器的新版本进行更新时，部署将逐个关闭一个Pod，创建一个新的带有新应用程序版本的Pod，等待新的Pod根据就绪检查注册为`Ready`，然后继续下一个Pod。
- en: The `maxSurge` and `maxUnavailable` parameters allow you to speed up or slow
    down this process. `maxUnavailable` allows you to tune the maximum number of unavailable
    Pods during the rollout process. This can be either a percentage or a fixed number.
    `maxSurge` allows you to tune the maximum number of Pods over the Deployment replica
    number that can be created at any given time. Like with `maxUnavailable`, this
    can be a percentage or a fixed number.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxSurge`和`maxUnavailable`参数允许您加快或减慢此过程。`maxUnavailable`允许您调整在部署过程中不可用的最大Pod数量。这可以是百分比或固定数量。`maxSurge`允许您调整在任何给定时间内可以创建的超出部署副本数量的最大Pod数量。与`maxUnavailable`一样，这可以是百分比或固定数量。'
- en: 'The following diagram shows the `RollingUpdate` procedure:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了`RollingUpdate`过程：
- en: '![Figure 4.2 – RollingUpdate process for a Deployment](image/B14790_04_002.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 - 部署的RollingUpdate过程](image/B14790_04_002.jpg)'
- en: Figure 4.2 – RollingUpdate process for a Deployment
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - 部署的RollingUpdate过程
- en: As you can see, the `RollingUpdate` procedure follows several key steps. The
    Deployment attempts to update Pods, one by one. Only after a Pod is successfully
    updated does the update proceed to the next Pod.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，“滚动更新”过程遵循了几个关键步骤。部署尝试逐个更新Pod。只有在成功更新一个Pod之后，更新才会继续到下一个Pod。
- en: Controlling Deployments with imperative commands
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令控制部署。
- en: As we've discussed, we can change our Deployment by simply updating its YAML
    using declarative methods. However, Kubernetes also gives us some special commands
    in `kubectl` for controlling several aspects of Deployments.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，我们可以通过简单地更新其YAML文件来更改我们的部署，使用声明性方法。然而，Kubernetes还为我们提供了一些在`kubectl`中控制部署的特殊命令。
- en: First off, Kubernetes lets us manually scale a Deployment – that is, we can
    edit the amount of replicas that should be running.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Kubernetes允许我们手动扩展部署-也就是说，我们可以编辑应该运行的副本数量。
- en: 'To scale our `myapp-deployment` up to five replicas, we can run the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的`myapp-deployment`扩展到五个副本，我们可以运行以下命令：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, we can roll back our `myapp-deployment` to an older version if required.
    To demonstrate this, first let''s manually edit our Deployment to use a new version
    of our container:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果需要，我们可以将我们的`myapp-deployment`回滚到旧版本。为了演示这一点，首先让我们手动编辑我们的部署，以使用容器的新版本：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This command tells Kubernetes to change the version of our container in our
    Deployment to 1.2\. Then, our Deployment will go through the steps in the preceding
    figure to roll out our change.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令告诉Kubernetes将我们部署中容器的版本更改为1.2。然后，我们的部署将按照前面的图表中的步骤来推出我们的更改。
- en: 'Now, let''s say that we want to go back to our previous version before we updated
    the container image version. We can easily do this using the `rollout undo` command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想回到之前更新容器图像版本之前的版本。我们可以使用`rollout undo`命令轻松实现这一点：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In our previous case, we only had two versions, the initial one and our version
    with the updated container, but if we had others, we could specify them in the
    `undo` command like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的情况下，我们只有两个版本，初始版本和我们更新容器的版本，但如果有其他版本，我们可以在`undo`命令中指定它们，就像这样：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This should give you a glimpse into why Deployments are so valuable – they give
    us fine-tuned control over rollout for new versions of our application. Next,
    we'll discuss a smart scaler for Kubernetes that works in concert with Deployments
    and ReplicaSets.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该让您对为什么部署如此有价值有所了解-它们为我们提供了对应用程序新版本的推出的精细控制。接下来，我们将讨论一个与部署和副本集协同工作的Kubernetes智能缩放器。
- en: Harnessing the Horizontal Pod Autoscaler
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用水平Pod自动缩放器
- en: As we've seen, Deployments and ReplicaSets allow you to specify a total number
    of replicas that should be available at a certain time. However, neither of these
    structures allow automatic scaling – they must be scaled manually.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，部署和副本集允许您指定应在某个时间可用的副本的总数。然而，这些结构都不允许自动缩放-它们必须手动缩放。
- en: '**Horizontal Pod Autoscalers** (**HPA**) provide this functionality by existing
    as a higher-level controller that can change the replica count of a Deployment
    or ReplicaSet based on metrics such as CPU and memory usage.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 水平Pod自动缩放器（HPA）通过作为更高级别的控制器存在，可以根据CPU和内存使用等指标改变部署或副本集的副本数量来提供这种功能。
- en: By default, an HPA can autoscale based on CPU utilization, but by using custom
    metrics this functionality can be extended.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，HPA可以根据CPU利用率进行自动缩放，但通过使用自定义指标，可以扩展此功能。
- en: 'The YAML file for an HPA looks like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: HPA的YAML文件如下所示：
- en: hpa.yaml
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: hpa.yaml
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding spec, we have the `scaleTargetRef`, which specifies what should
    be autoscaled by the HPA, and the tuning parameters.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述规范中，我们有`scaleTargetRef`，它指定了HPA应该自动缩放的内容，以及调整参数。
- en: The definition of `scaleTargetRef` can be a Deployment, ReplicaSet, or ReplicationController.
    In this case, we've defined the HPA to scale our previously created Deployment,
    `myapp-deployment`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`scaleTargetRef`的定义可以是部署（Deployment）、副本集（ReplicaSet）或复制控制器（ReplicationController）。在这种情况下，我们已经定义了HPA来扩展我们之前创建的部署`myapp-deployment`。'
- en: For tuning parameters, we're using the default CPU utilization-based scaling,
    so we can use `targetCPUUtilizationPercentage` to define the intended CPU utilization
    of each Pod running our application. If the average CPU usage of our Pods increases
    past 70%, our HPA will scale the Deployment spec up, and if it drops below for
    long enough, it will scale the Deployment down.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于调整参数，我们使用默认的基于CPU利用率的扩展，因此我们可以使用`targetCPUUtilizationPercentage`来定义运行我们应用程序的每个Pod的预期CPU利用率。如果我们的Pod的平均CPU使用率超过70%，我们的HPA将扩展部署规范，如果它长时间下降到以下水平，它将缩小部署。
- en: 'A typical scaling event looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的扩展事件看起来像这样：
- en: The average CPU usage of a Deployment exceeds 70% on three replicas.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署的平均CPU使用率超过了三个副本的70%。
- en: The HPA control loop notices this increase in CPU utilization.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HPA控制循环注意到CPU利用率的增加。
- en: The HPA edits the Deployment spec with a new replica count. This count is calculated
    based on CPU utilization, with the intent of a steady state per-node CPU usage
    under 70%.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HPA使用新的副本计数编辑部署规范。这个计数是基于CPU利用率计算的，目的是使每个节点的CPU使用率保持在70%以下的稳定状态。
- en: The Deployment controller spins up a new replica.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署控制器启动一个新的副本。
- en: This process repeats itself to scale the Deployment up or down.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个过程会重复自身来扩展或缩小部署。
- en: In summary, the HPA keeps track of CPU and memory utilization and initiates
    a scaling event when boundaries are exceeded. Next, we will review DaemonSets,
    which provide a very specific type of Pod controller.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，HPA跟踪CPU和内存利用率，并在超出边界时启动扩展事件。接下来，我们将审查DaemonSets，它们提供了一种非常特定类型的Pod控制器。
- en: Implementing DaemonSets
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施DaemonSets
- en: From now until the end of the chapter, we will be reviewing more niche options
    when it comes to running applications with specific requirements.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在到本章结束，我们将审查更多关于具有特定要求的应用程序运行的小众选项。
- en: We'll start with DaemonSets, which are similar to ReplicaSets except that the
    number of replicas is fixed at one replica per node. This means that each node
    in the cluster will keep one replica of the application active at any time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从DaemonSets开始，它们类似于ReplicaSets，只是副本的数量固定为每个节点一个副本。这意味着集群中的每个节点将始终保持应用程序的一个副本处于活动状态。
- en: Important note
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: It's important to keep in mind that this functionality will only create one
    replica per node in the absence of additional Pod placement controls, such as
    Taints or Node Selectors, which we will cover in greater detail in [*Chapter 8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186),
    *Pod Placement Controls*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在没有额外的Pod放置控制（如污点或节点选择器）的情况下，这个功能只会在每个节点上创建一个副本，我们将在[*第8章*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186)中更详细地介绍*Pod放置控制*。
- en: 'This ends up looking like the following diagram for a typical DaemonSet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终看起来像典型DaemonSet的下图所示：
- en: '![Figure 4.3 – DaemonSet spread across three nodes](image/B14790_04_003.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 - DaemonSet分布在三个节点上](image/B14790_04_003.jpg)'
- en: Figure 4.3 – DaemonSet spread across three nodes
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - DaemonSet分布在三个节点上
- en: As you can see in the preceding figure, each node (represented by a box) contains
    one Pod of the application, as controlled by the DaemonSet.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上图中所看到的，每个节点（由方框表示）包含一个由DaemonSet控制的应用程序的Pod。
- en: 'This makes DaemonSets great for running applications that collect metrics at
    the node level or provide networking processes on a per-node basis. A DaemonSet
    spec looks like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得DaemonSets非常适合在节点级别收集指标或在每个节点上提供网络处理。DaemonSet规范看起来像这样：
- en: daemonset-1.yaml
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: daemonset-1.yaml
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, this is very similar to your typical ReplicaSet spec, except
    that we do not specify the number of replicas. This is because a DaemonSet will
    try to run a Pod on each node in your cluster.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这与您典型的ReplicaSet规范非常相似，只是我们没有指定副本的数量。这是因为DaemonSet会尝试在集群中的每个节点上运行一个Pod。
- en: 'If you want to specify a subset of nodes to run your application, you can do
    this using a node selector as shown in the following file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想指定要运行应用程序的节点子集，可以使用节点选择器，如下面的文件所示：
- en: daemonset-2.yaml
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: daemonset-2.yaml
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This YAML will restrict our DaemonSet to nodes that match the `type=bigger-node`
    selector in their labels. We will learn much more about Node Selectors in [*Chapter
    8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186), *Pod Placement Controls*.
    For now, let's discuss a type of controller well suited to running stateful applications
    such as databases – the StatefulSet.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个YAML将限制我们的DaemonSet只能在其标签中匹配`type=bigger-node`的节点上运行。我们将在[*第8章*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186)中更多地了解有关节点选择器的信息，*Pod放置控制*。现在，让我们讨论一种非常适合运行有状态应用程序（如数据库）的控制器类型
    - StatefulSet。
- en: Understanding StatefulSets
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解StatefulSets
- en: StatefulSets are very similar to ReplicaSets and Deployments, but with one key
    difference that makes them better for stateful workloads. StatefulSets maintain
    the order and identity of each Pod, even if the Pods are rescheduled onto new
    nodes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSets与ReplicaSets和Deployments非常相似，但有一个关键的区别，使它们更适合有状态的工作负载。StatefulSets保持每个Pod的顺序和标识，即使Pod被重新调度到新节点上。
- en: For instance, in a StatefulSet of 3 replicas, there will always be Pod 1, Pod
    2, and Pod 3, and those Pods will maintain their identity in Kubernetes and storage
    (which we'll get to in [*Chapter 7*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166),
    *Storage on Kubernetes*), regardless of any rescheduling that happens.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个有3个副本的StatefulSet中，将始终存在Pod 1、Pod 2和Pod 3，并且这些Pod将在Kubernetes和存储中保持它们的标识（我们将在[*第7章*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166)中介绍，*Kubernetes上的存储*），无论发生任何重新调度。
- en: 'Let''s take a look at a simple StatefulSet configuration:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的StatefulSet配置：
- en: statefulset.yaml
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: statefulset.yaml
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This YAML will create a StatefulSet with five replicas of our app.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个YAML将创建一个具有五个应用程序副本的StatefulSet。
- en: 'Let''s see how the StatefulSet maintains Pod identity differently than a typical
    Deployment or ReplicaSet. Let''s fetch all Pods using the command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看StatefulSet如何与典型的Deployment或ReplicaSet不同地维护Pod标识。让我们使用以下命令获取所有Pods：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output should look like the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, in this example, we have our five StatefulSet Pods, each with
    a numeric indicator of their identity. This property is extremely useful for stateful
    applications such as a database cluster. In the case of running a database cluster
    on Kubernetes, the identity of the master versus replica Pods is important, and
    we can use StatefulSet identities to easily manage that.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这个例子中，我们有五个StatefulSet Pods，每个都有一个数字指示其标识。这个属性对于有状态的应用程序非常有用，比如数据库集群。在Kubernetes上运行数据库集群时，主Pod与副本Pod的标识很重要，我们可以使用StatefulSet标识来轻松管理它。
- en: Another point of interest is that you can see the final Pod is still starting
    up, and that the Pod ages increase as numeric identity increases. This is because
    StatefulSet Pods are created one at a time, in order.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的地方是，您可以看到最终的Pod仍在启动，并且随着数字标识的增加，Pod的年龄也在增加。这是因为StatefulSet Pods是按顺序逐个创建的。
- en: 'StatefulSets are valuable in concert with persistent Kubernetes storage in
    order to run stateful applications. We''ll learn more about this in [*Chapter
    7*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166), *Storage On Kubernetes*,
    but for now, let''s discuss another controller with a very specific use: Jobs.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSets 在持久的 Kubernetes 存储中非常有价值，以便运行有状态的应用程序。我们将在第7章《Kubernetes 上的存储》中了解更多相关内容，但现在让我们讨论另一个具有非常特定用途的控制器：Jobs。
- en: Using Jobs
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jobs
- en: The purpose of the Job resource in Kubernetes is to run tasks that can complete,
    which makes them not ideal for long-running applications, but great for batch
    jobs or similar tasks that can benefit from parallelism.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中 Job 资源的目的是运行可以完成的任务，这使它们不太适合长时间运行的应用程序，但非常适合批处理作业或类似任务，可以从并行性中受益。
- en: 'Here''s what a Job spec YAML looks like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Job 规范 YAML 的样子：
- en: job-1.yaml
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: job-1.yaml
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This Job will start a single Pod, and run a command, `node job.js`, until it
    completes, at which point the Pod will shut down. In this and the future examples,
    we assume that the container image used has a file, `job.js`, that runs the job
    logic. The `node:lts-jessie` container image will not have this by default. This
    is an example of a Job that runs without parallelism. As you are likely aware
    from Docker usage, multiple command arguments must be passed as an array of strings.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Job 将启动一个单独的 Pod，并运行一个命令 `node job.js`，直到完成，然后 Pod 将关闭。在这个和未来的示例中，我们假设使用的容器镜像有一个名为
    `job.js` 的文件，其中包含了作业逻辑。`node:lts-jessie` 容器镜像默认情况下不会有这个文件。这是一个不使用并行性运行的 Job 的示例。正如您可能从
    Docker 的使用中知道的那样，多个命令参数必须作为字符串数组传递。
- en: In order to create a Job that can run with parallelism (that is to say, multiple
    replicas running the Job at the same time), you need to develop your application
    code in a way that it can tell that the Job is completed before ending the process.
    In order to do this, each instance of the Job needs to contain code that ensures
    it does the right part of the greater batch task and prevents duplicate work from
    occurring.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个可以并行运行的 Job（也就是说，多个副本同时运行 Job），您需要以一种可以在结束进程之前告诉它 Job 已完成的方式来开发应用程序代码。为了做到这一点，每个
    Job 实例都需要包含代码，以确保它执行更大批处理任务的正确部分，并防止发生重复工作。
- en: There are several application patterns that can enable this, including a mutex
    lock and a Work Queue. In addition, the code needs to check the status of the
    entire batch task, which could again be handled by updating a value in a database.
    Once the Job code sees that the greater task is complete, it should exit.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种应用程序模式可以实现这一点，包括互斥锁和工作队列。此外，代码需要检查整个批处理任务的状态，这可能需要通过更新数据库中的值来处理。一旦 Job 代码看到更大的任务已经完成，它就应该退出。
- en: 'Once you''ve done that, you can add parallelism to your job code using the
    `parallelism` key. The following code block shows this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您可以使用 `parallelism` 键向作业代码添加并行性。以下代码块显示了这一点：
- en: job-2.yaml
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: job-2.yaml
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we add the `parallelism` key with three replicas. Further, you
    can swap pure job parallelism for a specified number of completions, in which
    case Kubernetes can keep track of how many times the Job has been completed. You
    can still set parallelism for this case, but if you don't set it, it will default
    to 1.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用 `parallelism` 键添加了三个副本。此外，您可以将纯作业并行性替换为指定数量的完成次数，在这种情况下，Kubernetes
    可以跟踪 Job 已完成的次数。您仍然可以为此设置并行性，但如果不设置，它将默认为 1。
- en: 'This next spec will run a Job `4` times to completion, with `2` iterations
    running at any given time:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个规范将运行一个 Job 完成 4 次，每次运行 2 次迭代：
- en: job-3.yaml
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: job-3.yaml
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Jobs on Kubernetes provide a great way to abstract one-time processes, and many
    third-party applications link them into workflows. As you can see, they are very
    easy to use.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes上的作业提供了一种很好的方式来抽象一次性进程，并且许多第三方应用程序将它们链接到工作流中。正如你所看到的，它们非常容易使用。
- en: Next, let's look at a very similar resource, the CronJob.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一个非常相似的资源，CronJob。
- en: CronJobs
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CronJobs
- en: CronJobs are a Kubernetes resource for scheduled job execution. This works very
    similarly to CronJob implementations you may find in your favorite programming
    language or application framework, with one key difference. Kubernetes CronJobs
    trigger Kubernetes Jobs, which provide an additional layer of abstraction that
    can be used, for instance, to trigger batch Jobs at night, every night.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: CronJobs是用于定时作业执行的Kubernetes资源。这与你可能在你喜欢的编程语言或应用程序框架中找到的CronJob实现非常相似，但有一个关键的区别。Kubernetes
    CronJobs触发Kubernetes Jobs，这提供了一个额外的抽象层，可以用来触发每天晚上的批处理作业。
- en: 'CronJobs in Kubernetes are configured using a very typical cron notation. Let''s
    take a look at the full spec:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的CronJobs使用非常典型的cron表示法进行配置。让我们来看一下完整的规范：
- en: cronjob-1.yaml
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: cronjob-1.yaml
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This CronJob will, at 1 a.m. every day, create a Job that is identical to our
    previous Job spec. For a quick review of cron time notation, which will explain
    the syntax of our 1 a.m. job, read on. For a comprehensive review of cron notation,
    check [http://man7.org/linux/man-pages/man5/crontab.5.html](http://man7.org/linux/man-pages/man5/crontab.5.html).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个CronJob将在每天凌晨1点创建一个与我们之前的Job规范相同的Job。要快速查看cron时间表示法，以解释我们凌晨1点工作的语法，请继续阅读。要全面了解cron表示法，请查看[http://man7.org/linux/man-pages/man5/crontab.5.html](http://man7.org/linux/man-pages/man5/crontab.5.html)。
- en: 'Cron notation consists of five values, separated by spaces. Each value can
    be a numeric integer, character, or combination. Each of the five values represents
    a time value with the following format, from left to right:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Cron表示法由五个值组成，用空格分隔。每个值可以是数字整数、字符或组合。这五个值中的每一个代表一个时间值，格式如下，从左到右：
- en: Minute
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分钟
- en: Hour
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小时
- en: Day of the month (such as `25`)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个月中的某一天（比如`25`）
- en: Month
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月
- en: Day of the week (where, for example, `3` = Wednesday)
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星期几（例如，`3` = 星期三）
- en: 'The previous YAML assumes a non-parallel CronJob. If we wanted to increase
    the batch capacity of our CronJob, we could add parallelism as we did with our
    previous Job specs. The following code block shows this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的YAML假设了一个非并行的CronJob。如果我们想增加CronJob的批处理能力，我们可以像之前的作业规范一样添加并行性。以下代码块显示了这一点：
- en: cronjob-2.yaml
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: cronjob-2.yaml
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that for this to work, the code in your CronJob container needs to gracefully
    handle parallelism, which could be implemented using a work queue or other such
    pattern.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了使其工作，你的CronJob容器中的代码需要优雅地处理并行性，这可以使用工作队列或其他类似的模式来实现。
- en: We've now reviewed all the basic controllers that Kubernetes provides by default.
    Let's use our knowledge to run a more complex application example on Kubernetes
    in the next section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经审查了Kubernetes默认提供的所有基本控制器。让我们利用我们的知识，在下一节中运行一个更复杂的应用程序示例在Kubernetes上。
- en: Putting it all together
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有这些放在一起
- en: 'We now have a toolset for running applications on Kubernetes. Let''s look at
    a real-world example to see how this could all be combined to run an application
    with multiple tiers and functionality spread across Kubernetes resources:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了在Kubernetes上运行应用程序的工具集。让我们看一个真实的例子，看看如何将所有这些组合起来运行一个具有多个层和功能分布在Kubernetes资源上的应用程序：
- en: '![Figure 4.4 – Multi-tier application diagram](image/B14790_04_004.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4 - 多层应用程序图表](image/B14790_04_004.jpg)'
- en: Figure 4.4 – Multi-tier application diagram
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 - 多层应用程序图表
- en: As you can see, our diagrammed application contains a web tier running a .NET
    Framework application, a mid-tier or service tier running Java, a database tier
    running Postgres, and finally a logging/monitoring tier.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，我们的示例应用程序包含一个运行.NET Framework应用程序的Web层，一个运行Java的中间层或服务层，一个运行Postgres的数据库层，最后是一个日志/监控层。
- en: Our controller choices for each of these tiers are dependent on the applications
    we plan to run on each tier. For both the web tier and the mid-tier, we're running
    stateless applications and services, so we can effectively use Deployments to
    handle rolling out updates, blue/green deploys, and more.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对每个层级的控制器选择取决于我们计划在每个层级上运行的应用程序。对于Web层和中间层，我们运行无状态应用程序和服务，因此我们可以有效地使用Deployments来处理更新、蓝/绿部署等。
- en: For the database tier, we need our database cluster to know which Pod is a replica
    and which is a master – so we use a StatefulSet. And finally, our log collector
    needs to run on every node, so we use a DaemonSet to run it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据库层，我们需要我们的数据库集群知道哪个Pod是副本，哪个是主节点 - 因此我们使用StatefulSet。最后，我们的日志收集器需要在每个节点上运行，因此我们使用DaemonSet来运行它。
- en: Now, let's go through example YAML specs for each of our tiers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐个查看每个层级的示例YAML规范。
- en: Let's start with our JavaScript-based web app. By hosting this application on
    Kubernetes, we can do canary tests and blue/green Deployments. As a note, some
    of the examples in this section use container image names that aren't publicly
    available in DockerHub. To use this pattern, adapt the examples to your own application
    containers, or just use busybox if you want to run it without actual application
    logic.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基于JavaScript的Web应用程序开始。通过在Kubernetes上托管此应用程序，我们可以进行金丝雀测试和蓝/绿部署。需要注意的是，本节中的一些示例使用在DockerHub上不公开可用的容器映像名称。要使用此模式，请将示例调整为您自己的应用程序容器，或者如果您想在没有实际应用程序逻辑的情况下运行它，只需使用busybox。
- en: 'The YAML file for the web tier could look like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Web层的YAML文件可能如下所示：
- en: example-deployment-web.yaml
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: example-deployment-web.yaml
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding YAML, we're labeling our applications using the `tier` label
    and using that as our `matchLabels` selector.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的YAML中，我们使用`tier`标签对我们的应用程序进行标记，并将其用作我们的`matchLabels`选择器。
- en: 'Next up is the mid-tier service layer. Let''s take a look at the relevant YAML:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是中间层服务层。让我们看看相关的YAML：
- en: example-deployment-mid.yaml
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: example-deployment-mid.yaml
- en: '[PRE23]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see in the preceding code, our mid-tier application is pretty similar
    to the web tier setup, and we're using another Deployment.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码中所看到的，我们的中间层应用程序与Web层设置非常相似，并且我们使用了另一个Deployment。
- en: 'Now comes the interesting part – let''s look at the spec for our Postgres StatefulSet.
    We have truncated this code block somewhat in order to fit on the page, but you
    should be able to see the most important parts:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是有趣的部分 - 让我们来看看我们的Postgres StatefulSet的规范。我们已经在这个代码块中进行了一些截断，以便适应页面，但您应该能够看到最重要的部分：
- en: example-statefulset.yaml
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: example-statefulset.yaml
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding YAML file, we can see some new concepts that we haven't reviewed
    yet – ConfigMaps and volumes. We'll get a much closer look at how these work in
    *Chapters 6*, *Kubernetes Application Configuration*, and [*Chapter 7*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166),
    *Storage on Kubernetes*, respectively, but for now let's focus on the rest of
    the spec. We have our `postgres` container as well as a port set up on the default
    Postgres port of `5432`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的YAML文件中，我们可以看到一些我们尚未审查的新概念 - ConfigMaps和卷。我们将在*第6章*，*Kubernetes应用程序配置*和[*第7章*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166)，*Kubernetes上的存储*中更仔细地了解它们的工作原理，但现在让我们专注于规范的其余部分。我们有我们的`postgres`容器以及在默认的Postgres端口`5432`上设置的端口。
- en: 'Finally, let''s take a look at our DaemonSet for our logging app. Here''s a
    portion of the YAML file, which we''ve again truncated for length:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看看我们的日志应用程序的DaemonSet。这是YAML文件的一部分，我们为了长度又进行了截断：
- en: example-daemonset.yaml
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: example-daemonset.yaml
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this DaemonSet, we're setting up FluentD (a popular open source log collector)
    to forward logs to Papertrail, a cloud-based log collector and search tool. Again,
    in this YAML file, we have some things we haven't reviewed before. For instance,
    the `tolerations` section for `node-role.kubernetes.io/master` will actually allow
    our DaemonSet to place Pods on master nodes, not just worker nodes. We'll review
    how this works in [*Chapter 8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186),
    *Pod Placement Controls*.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个DaemonSet中，我们正在设置FluentD（一个流行的开源日志收集器）将日志转发到Papertrail，一个基于云的日志收集器和搜索工具。同样，在这个YAML文件中，有一些我们以前没有审查过的内容。例如，`tolerations`部分用于`node-role.kubernetes.io/master`，实际上允许我们的DaemonSet将Pod放置在主节点上，而不仅仅是工作节点上。我们将在[*第8章*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186)
    *Pod放置控制*中审查这是如何工作的。
- en: We're also specifying environment variables directly in the Pod spec, which
    is fine for relatively basic configurations, but could be improved by using Secrets
    or ConfigMaps (which we'll review in [*Chapter 6*](B14790_06_Final_PG_ePub.xhtml#_idTextAnchor143),
    *Kubernetes Application Configuration*) to keep it out of our YAML code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在Pod规范中直接指定环境变量，这对于相对基本的配置来说是可以的，但是可以通过使用Secrets或ConfigMaps（我们将在[*第6章*](B14790_06_Final_PG_ePub.xhtml#_idTextAnchor143)
    *Kubernetes应用配置*中进行审查）来改进，以避免将其放入我们的YAML代码中。
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed some methods of running applications on Kubernetes.
    To start, we reviewed why Pods themselves are not enough to guarantee application
    availability and introduced controllers. We then reviewed some simple controllers,
    including ReplicaSets and Deployments, before moving on to controllers with more
    specific uses such as HPAs, Jobs, CronJobs, StatefulSets, and DaemonSets. Finally,
    we took all our learning and used it to implement a complex application running
    on Kubernetes.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了在Kubernetes上运行应用程序的一些方法。首先，我们回顾了为什么Pod本身不足以保证应用程序的可用性，并介绍了控制器。然后，我们回顾了一些简单的控制器，包括ReplicaSets和Deployments，然后转向具有更具体用途的控制器，如HPAs、Jobs、CronJobs、StatefulSets和DaemonSets。最后，我们将所有学到的知识应用到了在Kubernetes上运行复杂应用程序的实现中。
- en: In the next chapter, we'll learn how to expose our applications (which are now
    running properly with high availability) to the world using Services and Ingress.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用Services和Ingress将我们的应用程序（现在具有高可用性）暴露给世界。
- en: Questions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a ReplicaSet and a ReplicationController?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ReplicaSet和ReplicationController之间有什么区别？
- en: What's the advantage of a Deployment over a ReplicaSet?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Deployment相对于ReplicaSet的优势是什么？
- en: What is a good use case for a Job?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Job的一个很好的用例？
- en: Why are StatefulSets better for stateful workloads?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么StatefulSets对有状态的工作负载更好？
- en: How might we support a canary release flow using Deployments?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用Deployments支持金丝雀发布流程？
- en: Further reading
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The official Kubernetes documentation: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Kubernetes文档：[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)
- en: 'Documentation on the Kubernetes Job resource: [https://kubernetes.io/docs/concepts/workloads/controllers/job/](https://kubernetes.io/docs/concepts/workloads/controllers/job/)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes Job资源的文档：[https://kubernetes.io/docs/concepts/workloads/controllers/job/](https://kubernetes.io/docs/concepts/workloads/controllers/job/)
- en: 'Docs for FluentD DaemonSet installation: [https://github.com/fluent/fluentd-kubernetes-daemonset](https://github.com/fluent/fluentd-kubernetes-daemonset)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FluentD DaemonSet安装文档：[https://github.com/fluent/fluentd-kubernetes-daemonset](https://github.com/fluent/fluentd-kubernetes-daemonset)
- en: '*Kubernetes The Hard Way*: [https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kubernetes The Hard Way*: [https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way)'
