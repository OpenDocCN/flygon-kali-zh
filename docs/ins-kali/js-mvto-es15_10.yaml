- en: Chapter 9. Server-Side JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。服务器端JavaScript
- en: We have been focusing so far on the versatility of JavaScript as the language
    of the browser. It speaks volumes about the brilliance of the language given that
    JavaScript has gained significant popularity as a language to program scalable
    server systems. In this chapter, we will look at Node.js. Node.js is one of the
    most popular JavaScript frameworks used for server-side programming. Node.js is
    also one of the most watched project on GitHub and has superb community support.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我们一直在关注JavaScript作为浏览器语言的多功能性。鉴于JavaScript作为一种编写可扩展服务器系统的语言已经获得了显著的流行度，这充分说明了这种语言的卓越性。在本章中，我们将介绍Node.js。Node.js是用于服务器端编程的最流行的JavaScript框架之一。Node.js也是GitHub上最受关注的项目之一，并且拥有出色的社区支持。
- en: Node uses V8, the virtual machine that powers Google Chrome, for server-side
    programming. V8 gives a huge performance benefit to Node because it directly compiles
    the JavaScript into native machine code over executing bytecode or using an interpreter
    as a middleware.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Node使用V8，这是Google Chrome的虚拟机，用于服务器端编程。V8为Node带来了巨大的性能优势，因为它直接将JavaScript编译成本机机器代码，而不是执行字节码或使用解释器作为中间件。
- en: 'The versatility of V8 and JavaScript is a wonderful combination—the performance,
    reach, and overall popularity of JavaScript made Node an overnight success. In
    this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: V8和JavaScript的多功能性是一个美妙的组合——JavaScript的性能、覆盖范围和整体流行度使Node一夜之间取得了成功。在本章中，我们将涵盖以下主题：
- en: An asynchronous evented-model in a browser and Node.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器和Node.js中的异步事件模型
- en: Callbacks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调
- en: Timers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器
- en: EventEmitters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件发射器
- en: Modules and npm
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和npm
- en: An asynchronous evented-model in a browser
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器中的异步事件模型
- en: Before we try to understand Node, let's try to understand JavaScript in a browser.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们试图理解Node之前，让我们先试着理解浏览器中的JavaScript。
- en: Node relies on event-driven and asynchronous platforms for server-side JavaScript.
    This is very similar to how browsers handle JavaScript. Both the browser and Node
    are event-driven and non-blocking when they use I/O.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Node依赖于事件驱动和异步平台来进行服务器端JavaScript编程。这与浏览器处理JavaScript的方式非常相似。当浏览器和Node使用I/O时，它们都是事件驱动的，且是非阻塞的。
- en: 'To dive deeper into the event-driven and asynchronous nature of Node.js, let''s
    first do a comparison of the various kinds of operations and costs associated
    with them:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地了解Node.js的事件驱动和异步特性，让我们首先比较一下各种操作及其相关成本：
- en: '| L1 cache read | 0.5 nanoseconds |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| L1缓存读取 | 0.5纳秒 |'
- en: '| L2 cache read | 7 nanoseconds |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| L2缓存读取 | 7纳秒 |'
- en: '| RAM | 100 nanoseconds |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| RAM | 100纳秒 |'
- en: '| Read 4 KB randomly from SSD | 150,000 ns |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 从SSD随机读取4KB | 150,000纳秒 |'
- en: '| Read 1 MB sequentially from SSD | 1,000,000 ns |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 从SSD顺序读取1MB | 1,000,000纳秒 |'
- en: '| Read 1 MB sequentially from disk | 20,000,000 ns |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 从磁盘顺序读取1MB | 20,000,000纳秒 |'
- en: 'These numbers are from [https://gist.github.com/jboner/2841832](https://gist.github.com/jboner/2841832)
    and show how costly **Input/Output** (**I/O**) can get. The longest operations
    taken by a computer program are the I/O operations and these operations slow down
    the overall program execution if the program keeps waiting on these I/O operations
    to finish. Let''s see an example of such an operation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字来自[https://gist.github.com/jboner/2841832](https://gist.github.com/jboner/2841832)，显示了**输入/输出**（I/O）可能变得多么昂贵。计算机程序所花费的最长时间是I/O操作，如果程序一直在等待这些I/O操作完成，将会减慢整体程序的执行速度。让我们看一个这样的操作的例子：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you call `fileSystemReader.read()`, you are reading a file from the filesystem.
    As we just saw, I/O is the bottleneck here and can take quite a while before the
    read operation is completed. Depending on the kind of hardware, filesystem, OS,
    and so on, this operation will block the overall program execution quite a bit.
    The preceding code does some I/O that will be a blocking operation—the process
    will be blocked till I/O finishes and the data comes back. This is the traditional
    I/O model and most of us are familiar with this. However, this is costly and can
    cause terribly latency. Every process has associated memory and state—both these
    will be blocked till I/O is complete.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用`fileSystemReader.read()`时，您正在从文件系统中读取文件。正如我们刚才看到的，I/O在这里是瓶颈，可能需要相当长的时间才能完成读取操作。根据硬件、文件系统、操作系统等的不同，此操作将阻塞整个程序的执行。前面的代码执行了一些I/O操作，这将是一个阻塞操作——进程将被阻塞，直到I/O完成并数据返回。这是传统的I/O模型，我们大多数人都很熟悉。然而，这是昂贵的，并且可能导致严重的延迟。每个进程都有关联的内存和状态，这两者都将被阻塞，直到I/O完成。
- en: If a program blocks I/O, the Node server will refuse new requests. There are
    several ways of solving this problem. The most popular traditional approach is
    to use several threads to process requests—this technique is known as multithreading.
    If are you familiar with languages such as Java, chances are that you have written
    multithreaded code. Several languages support threads in various forms—a thread
    essentially holds its own memory and state. Writing multithreaded applications
    on a large scale is tough. When multiple threads are accessing a common shared
    memory or values, maintaining the correct state across these threads is a very
    difficult task. Threads are also costly when it comes to memory and CPU utilization.
    Threads that are used on synchronized resources may eventually get blocked.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序阻塞I/O，Node服务器将拒绝新的请求。解决这个问题有几种方法。最流行的传统方法是使用多个线程来处理请求——这种技术称为多线程。如果您熟悉Java等语言，您很可能已经编写过多线程代码。多种语言以各种形式支持线程——线程基本上持有自己的内存和状态。在大规模上编写多线程应用程序是困难的。当多个线程访问共享内存或值时，跨这些线程维护正确的状态是一项非常困难的任务。当涉及到内存和CPU利用率时，线程也是昂贵的。在同步资源上使用的线程最终可能会被阻塞。
- en: The browser handles this differently. I/O in the browser happens outside the
    main execution thread and an event is emitted when I/O finishes. This event is
    handled by the callback function associated with that event. This type of I/O
    is non-blocking and asynchronous. As I/O is not blocking the main execution thread,
    the browser can continue to process other events as they come without waiting
    on any I/O. This is a powerful idea. Asynchronous I/O allows browsers to respond
    to several events and allows a high level of interactivity.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器处理方式不同。浏览器中的I/O发生在主执行线程之外，并且在I/O完成时会发出事件。此事件由与该事件关联的回调函数处理。这种类型的I/O是非阻塞和异步的。由于I/O不会阻塞主执行线程，因此浏览器可以在不等待任何I/O的情况下继续处理其他事件。这是一个强大的想法。异步I/O允许浏览器响应多个事件，并允许高度的交互性。
- en: Node uses a similar idea for asynchronous processing. Node's event loop runs
    as a single thread. This means that the application that you write is essentially
    single-threaded. This does not mean that Node itself is single-threaded. Node
    uses **libuv** and is multithreaded—fortunately, these details are hidden within
    Node and you don't need to know them while developing your application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Node使用类似的思想进行异步处理。Node的事件循环作为一个单线程运行。这意味着您编写的应用程序本质上是单线程的。这并不意味着Node本身是单线程的。Node使用**libuv**并且是多线程的——幸运的是，这些细节在Node内部是隐藏的，您在开发应用程序时不需要了解它们。
- en: Every call that involves an I/O call requires you to register a callback. Registering
    a callback is also asynchronous and returns immediately. As soon as an I/O operation
    is completed, its callback is pushed on the event loop. It is executed as soon
    as all the other callbacks that were pushed on the event loop before are executed.
    All operations are essentially thread-safe, primarily because there is no parallel
    execution path in the event loop that will require synchronization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每次涉及I/O调用的调用都需要您注册一个回调。注册回调也是异步的，并立即返回。一旦I/O操作完成，它的回调就会被推送到事件循环中。它会在事件循环中之前推送的所有其他回调都执行完毕后立即执行。所有操作本质上都是线程安全的，主要是因为在事件循环中没有需要同步的并行执行路径。
- en: Essentially, there is only one thread running your code and there is no parallel
    execution; however, everything else except for your code runs in parallel.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，只有一个线程在运行您的代码，没有并行执行；然而，除了您的代码之外的所有其他东西都是并行执行的。
- en: Node.js relies on **libev** ([http://software.schmorp.de/pkg/libev.html](http://software.schmorp.de/pkg/libev.html))
    to provide the event loop, which is supplemented by **libeio** ([http://software.schmorp.de/pkg/libeio.html](http://software.schmorp.de/pkg/libeio.html))
    that uses pooled threads to provide asynchronous I/O. To learn even more, take
    a look at the libev documentation at [http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js依赖于**libev** ([http://software.schmorp.de/pkg/libev.html](http://software.schmorp.de/pkg/libev.html))
    来提供事件循环，它由**libeio** ([http://software.schmorp.de/pkg/libeio.html](http://software.schmorp.de/pkg/libeio.html))
    补充，后者使用池化线程提供异步I/O。要了解更多信息，请查看[http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod](http://pod.tst.eu/http://cvs.schmorp.de/libev/ev.pod)上的libev文档。
- en: 'Consider the following example of asynchronous code execution in Node.js:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Node.js中异步代码执行的示例：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this program, we read the `response.json` file from the disk. When the disk
    I/O is finished, the callback is executed with parameters containing the argument''s
    error, if any error occurred, and data, which is the file data. What you will
    see in the console is the output of `console.log(''1'')` and `console.log(''2'')`
    one immediately after another:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在此程序中，我们从磁盘中读取`response.json`文件。当磁盘I/O完成时，回调将被执行，参数包含参数的错误，如果发生任何错误，以及数据，即文件数据。您在控制台中看到的是`console.log('1')`和`console.log('2')`的输出，一个紧接着一个：
- en: '![An asynchronous evented-model in a browser](img/00028.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器中的异步事件模型](img/00028.jpeg)'
- en: Node.js does not need any additional server component as it creates its own
    server process. A Node application is essentially a server running on a designated
    port. In Node, the server and application are the same.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js不需要任何额外的服务器组件，因为它创建了自己的服务器进程。Node应用程序本质上是在指定端口上运行的服务器。在Node中，服务器和应用程序是相同的。
- en: 'Here is an example of a Node.js server responding with the **Hello Node** string
    when the `http://localhost:3000/` URL is run from a browser:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个Node.js服务器的示例，当从浏览器中运行`http://localhost:3000/`URL时，它会响应**Hello Node**字符串：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we are using an `http` module. If you recall our earlier discussions
    on the JavaScript module, you will realize that this is the CommonJS module implementation.
    Node has several modules compiled into the binary. The core modules are defined
    within Node's source. They can be located in the `lib/` folder.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用了一个`http`模块。如果您回忆一下我们之前关于JavaScript模块的讨论，您会意识到这是CommonJS模块实现。Node有几个模块编译到二进制文件中。核心模块在Node的源代码中定义。它们可以在`lib/`文件夹中找到。
- en: They are loaded first if their identifier is passed to `require()`. For instance,
    `require('http')` will always return the built-in HTTP module, even if there is
    a file by this name.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它们的标识符被传递给`require()`，它们将首先被加载。例如，`require('http')`将始终返回内置的HTTP模块，即使有一个同名的文件。
- en: 'After loading the module to handle HTTP requests, we create a `server` object
    and use a listener for a `request` event using the `server.on()` function. The
    callback is called whenever there is a request to this server on port `3000`.
    The callback receives `request` and `response` parameters. We are also setting
    the `Content-Type` header and HTTP response code before we send the response back.
    You can copy the preceding code, save it in a plain text file, and name it `app.js`.
    You can run the server from the command line using Node.js as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 加载处理HTTP请求的模块后，我们创建一个`server`对象，并使用`server.on()`函数为`request`事件使用监听器。每当有一个请求到达端口`3000`的服务器时，就会调用回调函数。回调函数接收`request`和`response`参数。在发送响应之前，我们还设置了`Content-Type`头和HTTP响应代码。您可以复制上述代码，将其保存在一个纯文本文件中，并命名为`app.js`。您可以使用Node.js从命令行运行服务器，方法如下：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the server is started, you can open the `http://localhost:3000` URL in
    a browser and you will be greeted with unexciting text:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器启动，您可以在浏览器中打开`http://localhost:3000` URL，然后会看到一些不那么令人兴奋的文本：
- en: '![An asynchronous evented-model in a browser](img/00029.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器中的异步事件模型](img/00029.jpeg)'
- en: 'If you want to inspect what''s happening internally, you can issue a `curl`
    command as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查内部发生了什么，可以发出以下`curl`命令：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Curl shows a nice request (`>`) and response (`<`) dialog including the request
    and response headers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Curl显示了一个漂亮的请求（`>`）和响应（`<`）对话框，包括请求和响应头。
- en: Callbacks
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调
- en: Callbacks in JavaScript usually take some time getting used to. If you are coming
    from some other non-asynchronous programming background, you will need to understand
    carefully how callbacks work; you may feel like you're learning programming for
    the first time. As everything is asynchronous in Node, you will be using callbacks
    for everything without trying to carefully structure them. The most important
    part of the Node.js project is sometimes the code organization and module management.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，回调通常需要一些时间来适应。如果您来自其他非异步编程背景，您需要仔细理解回调的工作原理；您可能会感觉自己像是第一次学习编程。由于Node中的一切都是异步的，您将会在所有事情上使用回调，而不是试图仔细地构造它们。有时，Node.js项目中最重要的部分是代码组织和模块管理。
- en: Callbacks are functions that are executed asynchronously at a later time. Instead
    of the code reading top to bottom procedurally, asynchronous programs may execute
    different functions at different times based on the order and speed that earlier
    functions such as HTTP requests or filesystem reads happen.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是在以后异步执行的函数。异步程序可能根据较早的函数（如HTTP请求或文件系统读取）发生的顺序和速度，在不同的时间执行不同的函数，而不是按顺序逐行执行代码。
- en: 'Whether a function execution is sequential or asynchronous depends on the context
    in which it is executed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数执行是顺序还是异步取决于它执行的上下文：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you run this program using Node, you will see the following output (assuming
    that your file is named `app.js`):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Node运行此程序，您将看到以下输出（假设您的文件名为`app.js`）：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is what we are all used to. This is traditional synchronous code execution
    where each line is executed in a sequence. The code here defines a function and
    then on the next line calls this function, without waiting for anything. This
    is sequential control flow.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们都习惯的。这是传统的同步代码执行，其中每一行按顺序执行。这段代码定义了一个函数，然后在下一行调用这个函数，而不等待任何东西。这是顺序控制流。
- en: 'Things will be different if we introduced I/O to this sequence. If we try to
    read something from the file or call a remote endpoint, Node will execute these
    operations in an asynchronous fashion. For the next example, we are going to use
    a Node.js module called `request`. We will use this module to make HTTP calls.
    You can install the module as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这个顺序中引入I/O，情况将会有所不同。如果我们尝试从文件中读取内容或调用远程端点，Node将以异步方式执行这些操作。在下一个示例中，我们将使用一个名为`request`的Node.js模块。我们将使用这个模块进行HTTP调用。您可以按照以下方式安装模块：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will discuss the use of npm later in this chapter. Consider the following
    example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论npm的使用。考虑以下示例：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When you execute this code, you will see that the value of the `status` variable
    is still `undefined`. In this example, we are making an HTTP call—this is an I/O
    operation. When we do an I/O operation, the execution becomes asynchronous. In
    the earlier example, we are doing everything within the memory and there was no
    I/O involved, hence, the execution was synchronous. When we run this program,
    all of the functions are immediately defined, but they don't all execute immediately.
    The `request()` function is called and the execution continues to the next line.
    If there is nothing to execute, Node will either wait for I/O to finish or it
    will exit. When the `request()` function finishes its work, it will execute the
    callback function (an anonymous function as the second parameter to the `request()`
    function). The reason that we got `undefined` in the preceding example is that
    nowhere in our code exists the logic that tells the `console.log()` statement
    to wait until the `request()` function has finished fetching the response from
    the HTTP call.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行此代码时，您会发现`status`变量的值仍然是`undefined`。在这个例子中，我们正在进行HTTP调用——这是一个I/O操作。当我们进行I/O操作时，执行变得异步。在之前的例子中，我们在内存中做了一切，没有涉及I/O，因此执行是同步的。当我们运行此程序时，所有函数都会立即定义，但它们并不会立即执行。`request()`函数被调用，执行继续到下一行。如果没有要执行的内容，Node将等待I/O完成，或者它将退出。当`request()`函数完成其工作时，它将执行回调函数（作为`request()`函数的第二个参数的匿名函数）。在前面的例子中得到`undefined`的原因是，我们的代码中没有逻辑告诉`console.log()`语句要等到`request()`函数完成从HTTP调用中获取响应。
- en: 'Callbacks are functions that get executed at some later time. This changes
    things in the way you organize your code. The idea around reorganizing the code
    is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是在以后某个时间执行的函数。这改变了您组织代码的方式。重新组织代码的想法如下：
- en: Wrapping the asynchronous code in a function
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将异步代码封装在函数中
- en: Passing a callback function to the wrapper function
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将回调函数传递给包装函数
- en: 'We will organize our previous example with these two ideas in mind. Consider
    this modified example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据这两个想法重新组织我们之前的示例。考虑这个修改后的例子：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you run this, you will get the following (correct) output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后，您将得到以下（正确的）输出：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'What we changed was to wrap the asynchronous code in a `getSiteStatus()` function,
    pass a function named `callback()` as a parameter to this function, and execute
    this function on the last line of `getSiteStatus()`. The `showStatusCode()` callback
    function simply wraps around `console.log()` that we called earlier. The difference,
    however, is in the way the asynchronous execution works. The most important idea
    to understand while learning how to program with callbacks is that functions are
    first-class objects that can be stored in variables and passed around with different
    names. Giving simple and descriptive names to your variables is important in making
    your code readable by others. Now that the callback function is called once the
    HTTP call is completed, the value of the `status_code` variable will have a correct
    value. There are genuine circumstances where you want an asynchronous task executed
    only after another asynchronous task is completed. Consider this scenario:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的改变是将异步代码包装在`getSiteStatus()`函数中，将名为`callback()`的函数作为参数传递给这个函数，并在`getSiteStatus()`的最后一行执行这个函数。`showStatusCode()`回调函数简单地包装了我们之前调用的`console.log()`。然而，不同之处在于异步执行的方式。在学习如何使用回调函数编程时理解的最重要的想法是，函数是一等对象，可以存储在变量中，并以不同的名称传递。给你的变量起简单和描述性的名称对于使你的代码可读性更强是很重要的。现在，一旦HTTP调用完成，回调函数就会被调用，`status_code`变量的值将会是正确的。确实存在一些情况，你希望一个异步任务在另一个异步任务完成后才执行。考虑这种情况：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, we are nesting one asynchronous function in another. This kind
    of nesting can result in code that is difficult to read and manage. This style
    of callback is sometimes known as **callback hell**. To avoid such a scenario,
    if you have code that has to wait for some other asynchronous code to finish,
    then you express that dependency by putting your code in functions that get passed
    around as callbacks. Another important idea is to name your functions instead
    of relying on anonymous functions as callbacks. We can restructure the preceding
    example into a more readable one as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在一个异步函数中嵌套了另一个异步函数。这种嵌套可能导致代码难以阅读和管理。这种回调风格有时被称为**回调地狱**。为了避免这种情况，如果你的代码必须等待其他异步代码完成，那么你可以通过将代码放在作为回调传递的函数中来表达这种依赖关系。另一个重要的想法是给你的函数命名，而不是依赖于匿名函数作为回调。我们可以将前面的例子重构为更可读的形式，如下所示：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This fragment uses two important concepts. First, we are using named functions
    and using them as callbacks. Second, we are not nesting these asynchronous functions.
    If you are accessing closure variables within the inner functions, the preceding
    would be a bit different implementation. In such cases, using inline anonymous
    functions is even more preferable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段使用了两个重要的概念。首先，我们使用了命名函数并将它们用作回调。其次，我们没有嵌套这些异步函数。如果你在内部函数中访问闭包变量，前面的实现会有所不同。在这种情况下，使用内联匿名函数更可取。
- en: Callbacks are most frequently used in Node. They are usually preferred to define
    logic for one-off responses. When you need to respond to repeating events, Node
    provides another mechanism for this. Before going further, we need to understand
    the function of timers and events in Node.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回调在Node中最常用。它们通常用于定义一次性响应的逻辑。当你需要响应重复事件时，Node提供了另一种机制。在继续之前，我们需要了解Node中计时器和事件的功能。
- en: Timers
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计时器
- en: 'Timers are used to schedule the execution of a particular callback after a
    specific delay. There are two primary methods to set up such delayed execution:
    `setTimeout` and `setInterval`. The `setTimeout()` function is used to schedule
    the execution of a specific callback after a delay, while `setInterval` is used
    to schedule the repeated execution of a callback. The `setTimeout` function is
    useful to perform tasks that need to be scheduled such as housekeeping. Consider
    the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 计时器用于在特定延迟后安排特定回调的执行。有两种主要方法来设置这样的延迟执行：`setTimeout`和`setInterval`。`setTimeout()`函数用于在延迟后安排特定回调的执行，而`setInterval`用于安排回调的重复执行。`setTimeout`函数用于执行需要安排的任务，例如日常工作。考虑以下例子：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, we are using `setTimeout()` to execute a callback (the anonymous function)
    after a delay of 1,000 ms. This is just a one-time schedule for this callback.
    We scheduled the repeated execution of the callback using `setInterval()`. Note
    that we are assigning the value returned by `setInterval()` in a variable `t`—we
    can use this reference in `clearInterval()` to clear this schedule.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`setTimeout()`在延迟1,000毫秒后执行一个回调（匿名函数）。这只是对这个回调的一次性调度。我们使用`setInterval()`来安排回调的重复执行。请注意，我们将`setInterval()`返回的值赋给变量`t`——我们可以在`clearInterval()`中使用这个引用来清除这个调度。
- en: EventEmitters
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件发射器
- en: We discussed earlier that callbacks are great for the execution of one-off logic.
    **EventEmitters** are useful in responding to repeating events. EventEmitters
    fire events and include the ability to handle these events when triggered. Several
    important Node APIs are built on EventEmitters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过，回调函数非常适合执行一次性逻辑。**事件发射器**在响应重复事件方面非常有用。事件发射器会触发事件，并包括处理这些事件的能力。几个重要的Node
    API都是基于事件发射器构建的。
- en: Events raised by EventEmitters are handled through listeners. A listener is
    a callback function associated with an event—when the event fires, its associated
    listener is triggered as well. The `event.EventEmitter` is a class that is used
    to provide a consistent interface to emit (trigger) and bind callbacks to events.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由事件发射器引发的事件通过监听器进行处理。监听器是与事件关联的回调函数——当事件触发时，它的关联监听器也会被触发。`event.EventEmitter`是一个用于发出（触发）和绑定事件回调的类，用于提供一致的接口。
- en: As a common style convention, event names are represented by a camel-cased string;
    however, any valid string can be used as an event name.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种常见的风格约定，事件名称由驼峰式字符串表示；然而，任何有效的字符串都可以用作事件名称。
- en: 'Use `require(''events'')` to access the `EventEmitter` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`require('events')`来访问`EventEmitter`类：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When an EventEmitter instance encounters an error, it emits an `error` event.
    Error events are treated as a special case in Node.js. If you don't handle these,
    the program exits with an exception stack.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个EventEmitter实例遇到错误时，它会发出一个`error`事件。错误事件在Node.js中被视为特殊情况。如果您不处理这些事件，程序将以异常堆栈退出。
- en: All EventEmitters emit the `newListener` event when new listeners are added
    and `removeListener` when a listener is removed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的EventEmitters在添加新的监听器时都会发出`newListener`事件，当监听器被移除时会发出`removeListener`事件。
- en: 'To understand the usage of EventEmitters, we will build a simplistic telnet
    server where different clients can log in and enter certain commands. Based on
    these commands, our server will respond accordingly:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解EventEmitters的用法，我们将构建一个简单的telnet服务器，不同的客户端可以登录并输入特定的命令。根据这些命令，我们的服务器将做出相应的响应：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When a client connects, we are emitting a `join` event, and when the client
    disconnects, we are emitting a `quit` event. We have listeners for both these
    events and they log appropriate messages on the server.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端连接时，我们发出一个`join`事件，当客户端断开连接时，我们发出一个`quit`事件。我们对这两个事件都有监听器，并且它们在服务器上记录适当的消息。
- en: 'You start this program and connect to our server using telnet as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以启动此程序并使用telnet连接到我们的服务器，如下所示：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On the server console, you will see the server logging which client joined
    the server:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器控制台上，您将看到服务器记录哪个客户端加入了服务器：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If any client quits the session, an appropriate message will appear as well.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何客户端退出会话，将出现适当的消息。
- en: Modules
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: When you are writing a lot of code, you soon reach a point where you have to
    start thinking about how you want to organize the code. Node modules are CommonJS
    modules that we discussed earlier when we discussed module patterns. Node modules
    can be published to the **Node Package Manager** (**npm**) repository. The npm
    repository is an online collection of Node modules.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写大量代码时，很快就会达到一个需要开始考虑如何组织代码的地步。Node模块是我们在讨论模块模式时早些时候讨论过的CommonJS模块。Node模块可以发布到**Node
    Package Manager**（**npm**）存储库。npm存储库是Node模块的在线集合。
- en: Creating modules
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模块
- en: 'Node modules can be either single files or directories containing one or more
    files. It''s usually a good idea to create a separate module directory. The file
    in the module directory that will be evaluated is normally named `index.js`. A
    module directory can look as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Node模块可以是单个文件，也可以是包含一个或多个文件的目录。通常最好创建一个单独的模块目录。模块目录中将被评估的文件通常命名为`index.js`。模块目录可以如下所示：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In your project directory, the `nav` module directory contains the module code.
    Conventionally, your module code needs to reside in the `index.js` file—you can
    change this to another file if you want. Consider this trivial module called `geo.js`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的项目目录中，`nav`模块目录包含模块代码。按照惯例，您的模块代码需要驻留在`index.js`文件中——如果您愿意，可以将其更改为其他文件。考虑一个名为`geo.js`的微不足道的模块：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You are exporting two functions via `exports`. You can use the module using
    the `require` function. This function takes the name of the module or system path
    to the module''s code. You can use the module that we created as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过`exports`导出了两个函数。您可以使用`require`函数来使用模块。此函数接受模块的名称或系统路径到模块代码。您可以按如下方式使用我们创建的模块：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we are exporting only two functions to the outside world, everything else
    remains private. If you recollect, we discussed the module pattern in detail—Node
    uses CommonJS modules. There is an alternative syntax to create modules as well.
    You can use `modules.exports` to export your modules. Indeed, `exports` is a helper
    created for `modules.exports`. When you use `exports`, it attaches the exported
    properties of a module to `modules.exports`. However, if `modules.exports` already
    has some properties attached to it, properties attached by `exports` are ignored.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只向外部导出了两个函数，其他所有内容都保持私有。如果您回忆起来，我们在详细讨论模块模式时讨论过——Node使用CommonJS模块。还有一种替代语法来创建模块。您可以使用`modules.exports`来导出您的模块。实际上，`exports`是为`modules.exports`创建的一个辅助程序。当您使用`exports`时，它会将模块的导出属性附加到`modules.exports`。但是，如果`modules.exports`已经附加了一些属性，那么`exports`附加的属性将被忽略。
- en: 'The `geo` module created earlier in this section can be rewritten in order
    to return a single `Geo` constructor function rather than an object containing
    functions. We can rewrite the `geo` module and its usage as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中早些时候创建的`geo`模块可以重写，以返回一个单一的`Geo`构造函数，而不是包含函数的对象。我们可以重写`geo`模块及其用法如下：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Consider a `config.js` module:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个`config.js`模块：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you want to access `db_config` from outside this module, you can use `require()`
    to include the module and refer the object as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从此模块外部访问`db_config`，可以使用`require()`来包含模块，并按如下方式引用对象：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There are three ways to organize modules:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种组织模块的方法：
- en: Using a relative path, for example, `config = require('./lib/config.js')`
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，使用相对路径，`config = require('./lib/config.js')`
- en: Using an absolute path, for example, `config = require('/nodeproject/lib/config.js')`
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，使用绝对路径，`config = require('/nodeproject/lib/config.js')`
- en: Using a module search, for example, `config = require('config')`
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，使用模块搜索，`config = require('config')`
- en: The first two are self-explanatory—they allow Node to look for a module in a
    particular location in the filesystem.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种方法很容易理解——它们允许Node在文件系统中的特定位置查找模块。
- en: When you use the third option, you are asking Node to locate the module using
    the standard look method. To locate the module, Node starts at the current directory
    and appends `./node_modules/` to it. Node then attempts to load the module from
    this location. If the module is not found, then the search starts from the parent
    directory until the root of the filesystem is reached.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用第三个选项时，您正在要求Node使用标准查找方法来定位模块。为了定位模块，Node从当前目录开始，并在其后附加`./node_modules/`。然后Node尝试从此位置加载模块。如果未找到模块，则搜索将从父目录开始，直到达到文件系统的根目录。
- en: 'For example, if `require(''config'')` is called in `/projects/node/`, the following
    locations will be searched until a match a found:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果在`/projects/node/`中调用`require('config')`，将搜索以下位置直到找到匹配项：
- en: '`/projects/node /node_modules/config.js`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/projects/node /node_modules/config.js`'
- en: '`/projects/node_modules/config.js`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/projects/node_modules/config.js`'
- en: '`/node_modules/config.js`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/node_modules/config.js`'
- en: For modules downloaded from npm, using this method is relatively simple. As
    we discussed earlier, you can organize your modules in directories as long as
    you provide a point of entry for Node.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从npm下载的模块，使用此方法相对简单。正如我们之前讨论的，只要为Node提供入口点，您可以将模块组织在目录中。
- en: 'The easiest way to do this is to create the `./node_modules/supermodule/` directory,
    and insert an `index.js` file in this directory. The `index.js` file will be loaded
    by default. Alternatively, you can put a `package.json` file in the `mymodulename`
    folder, specifying the name and main file of the module:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是创建`./node_modules/supermodule/`目录，并在此目录中插入一个`index.js`文件。`index.js`文件将被默认加载。或者，您可以将`package.json`文件放在`mymodulename`文件夹中，指定模块的名称和主文件：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You have to understand that Node caches modules as objects. If you have two
    (or more) files requiring a specific module, the first `require` will cache the
    module in memory so that the second `require` will not have to reload the module
    source code. However, the second `require` can alter the module functionality
    if it wishes to. This is commonly called **monkey patching** and is used to modify
    a module behavior without really modifying or versioning the original module.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须了解Node将模块缓存为对象。如果有两个（或更多）文件需要特定模块，第一个`require`将在内存中缓存模块，因此第二个`require`将不必重新加载模块源代码。但是，第二个`require`可以改变模块的功能。这通常被称为**monkey
    patching**，用于修改模块的行为而不真正修改或版本化原始模块。
- en: npm
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: npm
- en: The npm is the package manager used by Node to distribute modules. The npm can
    be used to install, update, and manage modules. Package managers are popular in
    other languages such as Python. The npm automatically resolves and updates dependencies
    for a package and hence makes your life easy.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: npm是Node使用的包管理器，用于分发模块。npm可用于安装、更新和管理模块。包管理器在其他语言中也很受欢迎，例如Python。npm会自动解析和更新包的依赖关系，因此使您的生活变得更加轻松。
- en: Installing packages
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装包
- en: 'There are two ways to install npm packages: locally or globally. If you want
    to use the module''s functionality only for a specific Node project, you can install
    it locally relative to the project, which is default behavior of `npm install`.
    Alternatively, there are several modules that you can use as a command-line tool;
    in this case, you can install them globally:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安装npm包有两种方式：本地安装和全局安装。如果您只想为特定的Node项目使用模块功能，可以相对于项目本地安装它，这是`npm install`的默认行为。另外，有一些模块可以用作命令行工具；在这种情况下，您可以全局安装它们：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `install` directive with `npm` will install a particular module—`request`
    in this case. To confirm that `npm install` worked correctly, check to see whether
    a `node_modules` directory exists and verify that it contains a directory for
    the package(s) that you installed.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`npm`的`install`指令将安装特定模块——在这种情况下是`request`。要确认`npm install`是否正确工作，请检查是否存在`node_modules`目录，并验证它是否包含您安装的包的目录。
- en: As you start adding modules to your project, it becomes difficult to manage
    the version/dependency of each module. The best way to manage locally installed
    packages is to create a `package.json` file in your project.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始向项目添加模块时，管理每个模块的版本/依赖关系变得困难。管理本地安装的包的最佳方法是在项目中创建一个`package.json`文件。
- en: 'A `package.json` file can help you in the following ways:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`package.json`文件可以帮助您以下几种方式：'
- en: Defining versions of each module that you want to install. There are times when
    your project depends on a specific version of a module. In this case, your `package.json`
    helps you download and maintain the correct version dependency.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义您想要安装的每个模块的版本。有时您的项目依赖于模块的特定版本。在这种情况下，您的`package.json`将帮助您下载和维护正确的版本依赖关系。
- en: Serving as a documentation of all the modules that your project needs.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为您的项目需要的所有模块的文档。
- en: Deploying and packaging your application without worrying about managing dependencies
    every time you deploy the code.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不必每次部署代码时担心管理依赖关系的情况下，部署和打包应用程序。
- en: 'You can create `package.json` by issuing the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过发出以下命令创建`package.json`：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After answering basic questions about your project, a blank `package.json`
    is created with content similar to the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 回答关于您的项目的基本问题后，将创建一个空白的`package.json`，内容类似于以下内容：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can manually edit this file in a text editor. An important part of this
    file is the `dependencies` tag. To specify the packages that your project depends
    on, you need to list the packages you''d like to use in your `package.json` file.
    There are two types of packages that you can list:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文本编辑器中手动编辑此文件。此文件的重要部分是`dependencies`标签。要指定项目所依赖的包，您需要在`package.json`文件中列出您想要在其中使用的包。您可以列出两种类型的包：
- en: '`dependencies`: These packages are required by your application in production'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dependencies`：这些包在生产中由您的应用程序需要'
- en: '`devDependencies`: These packages are needed only for development and testing
    (for example, using the **Jasmine node package**)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devDependencies`：这些包仅在开发和测试时需要（例如，使用**Jasmine node package**）'
- en: 'In the preceding example, you can see the following dependency:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，您可以看到以下依赖关系：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This means that the project is dependent on the `request` module.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着项目依赖于`request`模块。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The version of the module is dependent on the semantic versioning rules—[https://docs.npmjs.com/getting-started/semantic-versioning](https://docs.npmjs.com/getting-started/semantic-versioning).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的版本取决于语义化版本规则—[https://docs.npmjs.com/getting-started/semantic-versioning](https://docs.npmjs.com/getting-started/semantic-versioning)。
- en: Once your `package.json` file is ready, you can simply use the `npm install`
    command to install all the modules for your projects automatically.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的`package.json`文件准备好，您可以简单地使用`npm install`命令自动为您的项目安装所有模块。
- en: 'There is a cool trick that I love to use. While installing modules from the
    command line, we can add the `--save` flag to add that module''s dependency to
    the `package.json` file automatically:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个我喜欢使用的很酷的技巧。在命令行安装模块时，我们可以添加`--save`标志，自动将该模块的依赖项添加到`package.json`文件中：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding command, we installed the `async` module with the normal `npm`
    command with a `--save` flag. There is a corresponding entry automatically created
    in `package.json`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用了普通的`npm`命令安装了`async`模块，并带有`--save`标志。`package.json`中自动创建了相应的条目：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: JavaScript performance
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript性能
- en: Like any other language, writing correct JavaScript code at scale is an involved
    task. As the language matures, several of the inherent problems are being taken
    care of. There are several exceptional libraries that aid in writing good quality
    code. For most serious systems, *good code = correct code + high performance code*.
    The demands of new-generation software systems are high on performance. In this
    section, we will discuss a few tools that you can use to analyze your JavaScript
    code and understand its performance metrics.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何其他语言一样，在规模上编写正确的JavaScript代码是一项复杂的任务。随着语言的成熟，一些固有问题正在得到解决。有几个出色的库可以帮助编写高质量的代码。对于大多数严肃的系统，*好的代码=正确的代码+高性能代码*。新一代软件系统对性能要求很高。在本节中，我们将讨论一些工具，您可以使用这些工具来分析您的JavaScript代码并了解其性能指标。
- en: 'We will discuss the following two ideas in this section:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下两个想法：
- en: 'Profiling: Timing various functions and operations during script-profiling
    helps in identifying areas where you can optimize your code'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析：在脚本分析期间计时各种函数和操作有助于识别可以优化代码的地方
- en: 'Network performance: Examining the loading of network resources such as images,
    stylesheets, and scripts'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络性能：检查网络资源（如图像、样式表和脚本）的加载
- en: JavaScript profiling
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript分析
- en: JavaScript profiling is critical to understand performance aspects of various
    parts of your code. You can observe timings of the functions and operations to
    understand which operation is taking more time. With this information, you can
    optimize the performance of time-consuming functions and tune the overall performance
    of your code. We will be focusing on the profiling options provided by Chrome's
    Developer Tools. There are comprehensive analysis tools that you can use to understand
    the performance metrics of your code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript分析对于了解代码各个部分的性能方面至关重要。您可以观察函数和操作的时间，以了解哪个操作花费了更多的时间。有了这些信息，您可以优化耗时函数的性能，并调整代码的整体性能。我们将专注于Chrome开发者工具提供的分析选项。有全面的分析工具可供您使用，以了解代码的性能指标。
- en: The CPU profile
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CPU配置文件
- en: The CPU profile shows the execution time spent by various parts of your code.
    We have to inform DevTools to record the CPU profile data. Let's take the profiler
    for a spin.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: CPU配置文件显示了代码各个部分的执行时间。我们必须通知DevTools记录CPU配置文件数据。让我们来试试分析器。
- en: 'You can enable the CPU profiler in DevTools as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下步骤在DevTools中启用CPU分析器：
- en: Open the Chrome DevTools **Profiles** panel.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Chrome DevTools **Profiles**面板。
- en: Verify that **Collect JavaScript CPU Profile** is selected:![The CPU profile](img/00030.jpeg)
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证是否选择了**收集JavaScript CPU配置文件**：![CPU配置文件](img/00030.jpeg)
- en: For this chapter, we will be using Google's own benchmark page, [http://octane-benchmark.googlecode.com/svn/latest/index.html](http://octane-benchmark.googlecode.com/svn/latest/index.html).
    We will use this because it contains sample functions where we can see various
    performance bottlenecks and benchmarks. To start recording the CPU profile, open
    DevTools in Chrome, and in the **Profiles** tab, click on the **Start** button
    or press *Cmd*/*Ctrl* + *E*. Refresh the **V8 Benchmark Suite** page. When the
    page has completed reloading, a score for the benchmark tests is shown. Return
    to the **Profiles** panel and stop the recording by clicking on the **Stop** button
    or pressing *Cmd*/*Ctrl* + *E* again.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Google自己的基准页面[http://octane-benchmark.googlecode.com/svn/latest/index.html](http://octane-benchmark.googlecode.com/svn/latest/index.html)。我们将使用这个页面，因为它包含了我们可以看到各种性能瓶颈和基准测试的示例函数。要开始记录CPU配置文件，请在Chrome中打开DevTools，在**Profiles**选项卡中，单击**开始**按钮或按下*Cmd*/*Ctrl*
    + *E*。刷新**V8基准套件**页面。页面完成重新加载后，将显示基准测试的得分。返回**Profiles**面板，并通过单击**停止**按钮或再次按下*Cmd*/*Ctrl*
    + *E*来停止录制。
- en: 'The recorded CPU profile shows you a detailed view of the functions and the
    execution time taken by them in the bottom-up fashion, as shown in the following
    image:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的CPU配置文件以自下而上的方式详细显示了函数和它们所花费的执行时间，如下图所示：
- en: '![The CPU profile](img/00031.jpeg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![CPU配置文件](img/00031.jpeg)'
- en: The Timeline view
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间轴视图
- en: The Chrome DevTools **Timeline** tool is the first place you can start looking
    at the overall performance of your code. It lets you record and analyze all the
    activity in your application as it runs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome DevTools **时间轴**工具是您可以开始查看代码整体性能的第一个地方。它允许您记录和分析应用程序运行时的所有活动。
- en: 'The **Timeline** provides you with a complete overview of where time is spent
    when loading and using your site. A timeline recording includes a record for each
    event that occurred and is displayed in a **waterfall** graph:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间轴**为您提供了加载和使用您的站点时花费时间的完整概述。时间轴记录包括每个事件的记录，并以**瀑布**图显示：'
- en: '![The Timeline view](img/00032.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴视图](img/00032.jpeg)'
- en: 'The preceding screen shows you the timeline view when we try to render [https://twitter.com/](https://twitter.com/)
    in the browser. The timeline view gives you an overall view of which operation
    took how much time in execution:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕显示了我们在浏览器中尝试渲染[https://twitter.com/](https://twitter.com/)时的时间轴视图。时间轴视图为您提供了执行中的每个操作花费了多少时间的整体视图：
- en: '![The Timeline view](img/00033.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴视图](img/00033.jpeg)'
- en: 'In the preceding screenshot, we can see the progressive execution of various
    JavaScript functions, network calls, resource downloads, and other operations
    involved in rendering the Twitter home page. This view gives us a very good idea
    about which operations may be taking longer. Once we identify such operations,
    we can optimize them for performance. The **Memory** view is a great tool to understand
    how the memory is used during the lifetime of your application in the browser.
    The **Memory** view shows you a graph of the memory used by your application over
    time and maintains a counter of the number of documents, DOM nodes, and event
    listeners that are held in the memory. The **Memory** view can help detect memory
    leaks and give you good enough hints to understand what optimizations are required:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到渲染Twitter首页涉及的各种JavaScript函数、网络调用、资源下载和其他操作的渐进执行。这个视图让我们对哪些操作可能花费更长时间有了很好的了解。一旦我们确定了这样的操作，我们就可以优化它们以提高性能。**内存**视图是一个很好的工具，可以帮助我们了解应用在浏览器中的生命周期中如何使用内存。**内存**视图向您显示了应用程序随时间使用的内存的图表，并维护了一些文档、DOM节点和事件监听器的数量计数。**内存**视图可以帮助检测内存泄漏，并给出足够的提示，以了解需要进行哪些优化：
- en: '![The Timeline view](img/00034.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![时间轴视图](img/00034.jpeg)'
- en: JavaScript performance is a fascinating subject and deserves its own dedicated
    text. I would urge you to explore Chrome's DevTools and understand how best to
    use the tools to detect and diagnose performance problems in your code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript性能是一个迷人的课题，值得有专门的文本来讨论。我建议你探索Chrome的DevTools，并了解如何最好地使用这些工具来检测和诊断代码中的性能问题。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at a different avatar of JavaScript—that of a server-side
    framework in the form of Node.js.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了JavaScript的另一个形象——作为Node.js的服务器端框架。
- en: Node offers an asynchronous evented-model to program scalable and high-performance
    server applications in JavaScript. We dived deep into some core concepts on Node,
    such as an event loop, callbacks, modules, and timers. Understanding them is critical
    to write good Node code. We also discussed several techniques to structure Node
    code and callbacks in a better way.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Node提供了一个异步事件模型，用于在JavaScript中编写可扩展和高性能的服务器应用程序。我们深入研究了Node的一些核心概念，比如事件循环、回调、模块和定时器。理解它们对于编写良好的Node代码至关重要。我们还讨论了几种结构化Node代码和回调的更好方式的技术。
- en: With this, we reach the conclusion of our exploration of a brilliant programming
    language. JavaScript has been instrumental in the evolution of the World Wide
    Web because of its sheer versatility. The language continues to expand its horizons
    and improves with each new iteration.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一切，我们结束了对一个杰出的编程语言的探索。由于其极大的多功能性，JavaScript对万维网的演变起到了重要作用。这种语言不断拓展自己的视野，并在每一次新的迭代中得到改进。
- en: We started our journey with understanding the building blocks of the grammar
    and syntax of the language. We grasped the fundamental ideas of closures and the
    functional behavior of JavaScript. These concepts are so essential that most of
    the JavaScript patterns are based on them. We looked at how we can utilize these
    patterns to write better code with JavaScript. We studied how JavaScript can operate
    on a DOM and how to use jQuery to manipulate the DOM effectively. Finally, we
    looked at the server-side avatar of JavaScript in Node.js.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从理解语言的语法和语法的构建模块开始了我们的旅程。我们掌握了闭包的基本概念和JavaScript的函数行为。这些概念是如此重要，以至于大多数JavaScript模式都是基于它们的。我们看了一下如何利用这些模式来用JavaScript编写更好的代码。我们研究了JavaScript如何在DOM上操作，以及如何使用jQuery有效地操作DOM。最后，我们看了JavaScript在Node.js中的服务器端形象。
- en: This module should have enabled you to think differently when you start programming
    in JavaScript. Not only will you think about common patterns when you code, but
    also appreciate and use newer language features by ES6.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块应该让你在开始用JavaScript编程时有不同的思考方式。你不仅会在编码时考虑常见的模式，还会欣赏并使用ES6的新语言特性。
