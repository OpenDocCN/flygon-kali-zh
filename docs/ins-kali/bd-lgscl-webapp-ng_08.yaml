- en: RxJS Advanced
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJS高级
- en: We finished the last chapter that taught us more about what operators exist
    and how to utilize them effectively. Armed with this knowledge, we will now go
    into this subject in more depth. We will go from learning about what parts exist,
    to actually understanding the nature of RxJS. Knowing the nature of RxJS involves
    understanding more about what makes it tick. To uncover this, we need to cover
    topics such as what the differences are between hot, warm, and cold Observables;
    knowing about Subjects and what they are good for; and the sometimes ignored topic
    of Schedulers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了上一章，它教会了我们更多关于存在哪些操作符以及如何有效利用它们。凭借这些知识，我们现在将更深入地研究这个主题。我们将从了解存在哪些部分开始，真正理解RxJS的本质。了解RxJS的本质涉及更多了解它的运作方式。为了揭示这一点，我们需要涵盖诸如热、温和、冷Observables之间的区别是什么；了解主题以及它们的用途；以及有时被忽视的调度器等主题。
- en: There are also other aspects of working with Observables that we want to cover,
    namely, how to deal with errors and how to test your Observables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想涵盖与Observables一起工作的其他方面，即如何处理错误以及如何测试您的Observables。
- en: 'In this chapter, you will learn about:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下内容：
- en: Hot, cold, and warm Observables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热、冷和温和Observables
- en: 'Subjects: how they differ from Observables, and when to use them'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题：它们与Observables的区别，以及何时使用它们
- en: Pipeable operators, a recent addition to the RxJS library, and how they affect
    how you compose Observables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道操作符，这是RxJS库的最新添加，以及它们如何影响您组合Observables的方式
- en: Marble testing, the testing machinery in place that helps you with testing your
    Observables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹珠测试，这是一个测试机制，可以帮助您测试您的Observables
- en: Hot, cold, and warm Observables
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热、冷和温和Observables
- en: 'There are hot, cold, and warm Observables. What do we actually mean by that?
    For starters, let''s say that most things you will deal with are cold Observables.
    Not helping? If we say that cold Observables are lazy, does that help? No? OK,
    let''s talk about Promises for a second. Promises are hot. They are hot because
    when we execute their code, it happens straight away. Let''s see an example of
    that:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有热、冷和温和的Observables。我们实际上是什么意思呢？首先，让我们说你将处理的大多数事物都是冷Observables。没有帮助？如果我们说冷Observables是懒惰的，那有帮助吗？不？好吧，让我们谈谈Promise。Promise是热的。它们是热的，因为当我们执行它们的代码时，它会立即发生。让我们看一个例子：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you come from a non-RxJS background, you will most likely, at this point,
    think: OK, yes, that''s what I expected. This is the point we are trying to make,
    though: Calling `getData()` makes your code run straight away. This differs from
    RxJS in the sense that similar RxJS code will actually not run until there is
    a listener/subscriber that cares about the result. RxJS answers the old philosophical
    question: Does a tree make a sound when it falls in the forest if no one is there
    to listen? In the case of Promises, it does. In the case of an Observable, it
    doesn''t. Let''s clarify what we just said with a similar code example using RxJS
    and Observables:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自一个非RxJS背景，那么在这一点上，你很可能会认为：好的，是的，这正是我所期望的。然而，我们试图表达的是：调用`getData()`会让你的代码立即运行。这与RxJS不同，因为类似的RxJS代码实际上不会运行，直到有一个关心结果的监听器/订阅者。RxJS回答了一个古老的哲学问题：如果没有人在森林里听到树倒下时会发出声音吗？在Promise的情况下，会。在Observable的情况下，不会。让我们通过使用RxJS和Observables的类似代码示例来澄清刚才说的话：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In RxJS, code like this is considered cold, or lazy. We need a subscriber for
    something to actually happen. We can add a subscriber like so:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJS中，像这样的代码被认为是冷的，或者懒惰的。我们需要一个订阅者才能真正发生一些事情。我们可以这样添加一个订阅者：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This is a major difference in how Observables behave versus Promises, and it''s
    important to know. This is a cold Observable; so, what is a hot Observable? It
    would be easy to think, at this point, that a hot Observable is something that
    executes straight away; there is more to it than that, however. One of the official
    explanations of what a hot Observable is, is that anything that subscribes to
    it will share the Producer with other Subscribers. The Producer is what spouts
    out values internally inside the Observable. This means that the data is shared.
    Let''s look at a cold Observable subscription scenario and contrast that with
    a hot Observable subscription scenario. We will start with the cold scenario:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Observable 行为与 Promise 的主要区别，这一点很重要。这是一个冷 Observable；那么，什么是热 Observable？在这一点上很容易认为热
    Observable 是立即执行的东西；然而，事实并非如此。官方解释热 Observable 的一个解释是，任何订阅它的东西都将与其他订阅者共享生产者。生产者是在
    Observable 内部产生值的东西。这意味着数据是共享的。让我们看看冷 Observable 订阅场景，并将其与热 Observable 订阅场景进行对比。我们将从冷场景开始：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, we have three different subscribers that receive their
    own copy of emitted values. The values start from the beginning, every time we
    add a new subscriber. That might be expected when looking at the two first subscribers.
    As for the third one, it is added as a subscriber after two seconds. Yes, even
    that subscriber receives its own set of values. The explanation is that each subscriber
    receives its own Producer upon subscription.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们有三个不同的订阅者，它们分别接收发出的值。每次添加新的订阅者时，值都从头开始。当看两个第一订阅者时，这可能是预期的。至于第三个订阅者，它是在两秒后添加的。是的，即使该订阅者也会收到自己的一组值。解释是每个订阅者在订阅时都会收到自己的生产者。
- en: 'With hot Observables, there is just one producer, which means the scenario
    above will play out differently. Let''s write down the code for a hot Observable
    scenario:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于热 Observable，只有一个生产者，这意味着上面的场景将有所不同。让我们写下热 Observable 场景的代码：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reason the third subscriber is outputting only the value `2` is that the
    other values have been emitted already. The third subscriber wasn't around to
    see that happen. On the third value emit, it is around, and that is the reason
    it receives the value `2`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个订阅者只输出值`2`的原因是其他值已经被发出。第三个订阅者没有看到这种情况发生。在第三个值发出时，它出现了，这就是它接收值`2`的原因。
- en: Making a stream hot
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将流变热
- en: 'This `hotStream$`, how can it be created? You did say that most of the streams
    being created are cold? We have an operator for doing just that, or two operators,
    in reality. We can make a stream go from cold to hot by using the operators `publish()` and `connect()`.
    Let''s start with a cold Observable and add the mentioned operators, like so:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`hotStream$`，它是如何创建的？你说大多数创建的流都是冷的？我们有一个操作符可以做到这一点，或者说实际上有两个操作符。我们可以使用`publish()`和`connect()`操作符将流从冷转为热。让我们从一个冷
    Observable 开始，并添加上述操作符，就像这样：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see from the preceding code that we create our Observable and instruct
    it to emit values, one value per second. Furthermore, it should stop after five
    emitted values. We then call the operator `publish()`. This puts us in ready mode.
    We then set up a few subscriptions to happen after two seconds and three seconds,
    respectively. This is followed by us calling `connect()` on the stream. This will
    make the stream go from hot to cold. Thereby, our stream starts emitting values,
    and any subscriber, whenever it starts subscribing, will share a producer with
    any future subscriber. Lastly, we add a subscriber to happen straight after the
    call to `connect()`. Let''s show what the output becomes with the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到我们创建了我们的 Observable，并指示它每秒发出一个值。此外，它应该在发出五个值后停止。然后我们调用操作符`publish()`。这将使我们处于就绪模式。然后我们设置了一些订阅，分别在两秒后和三秒后发生。然后我们在流上调用`connect()`。这将使流从热变冷。因此，我们的流开始发出值，任何订阅者，无论何时开始订阅，都将与任何未来的订阅者共享一个生产者。最后，我们在调用`connect()`后立即添加一个订阅者。让我们通过以下截图展示输出结果：
- en: '![](Images/a082e1cf-166a-438d-b3ee-2e08ec543b11.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a082e1cf-166a-438d-b3ee-2e08ec543b11.png)'
- en: Our first subscriber is emitting values after one second. Our second subscriber
    kicks in after yet another second. This time its value is `1`; it has missed out
    on the first value. After yet another second, the third subscriber has been attached.
    The first value that subscriber emits is `2`; it missed out on the two first values.
    We clearly see how the operators `publish()` and `connect()` help to create our
    hot Observable, but also how it matters when you start subscribing to a hot Observable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个订阅者在一秒后开始发出值。我们的第二个订阅者在另一秒后开始。这次它的值是`1`；它错过了第一个值。再过一秒，第三个订阅者被附加上。该订阅者发出的第一个值是`2`；它错过了前两个值。我们清楚地看到了操作符`publish()`和`connect()`如何帮助创建我们的热
    Observable，以及当您开始订阅热 Observable时会发生什么。
- en: Why on earth would I want a hot Observable? What's the area for application?
    Well, imagine you have a live stream, a football game that you stream to many
    subscribers/viewers. They wouldn't want to see what happens from the first minute
    of the game when they arrive late, but, rather, where the match is right now,
    at the time of subscription (when they park themselves in front of the television).
    So, there definitely exist cases where hot Observables are the way to go.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我为什么要使用热 Observable？应用领域是什么？嗯，想象一下你有一个直播流，一个足球比赛，你要将其流式传输给许多订阅者/观众。他们不想看到比赛的第一分钟发生了什么，因为他们来晚了，而是想看到比赛现在的情况，即订阅时的情况（当他们坐在电视机前）。因此，肯定存在热
    Observable 是合适的情况。
- en: Warm streams
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 温流
- en: 'So far, we have been describing and discussing cold Observables and hot Observables,
    but there is a third kind: the warm Observable. A warm Observable can be thought
    of as being created as a cold Observable, but turning into a hot Observable under
    certain conditions. Let''s look at such a case by introducing the `refCount()` operator:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在描述和讨论冷 Observable 和热 Observable，但还有第三种：温 Observable。温 Observable
    可以被认为是作为冷 Observable 创建的，但在某些条件下变成了热 Observable。让我们通过引入`refCount()`操作符来看一个这样的情况：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'OK, so we started to use the operator `publish()`, and it looks like we are
    about to use our `connect()` operator and that we have a hot Observable, right?
    Well, yes, but instead of calling `connect()`, we call `refCount()`. This operator
    will warm our Observable up so that when the first subscriber arrives, it will
    act like a cold Observable. OK? That just sounds like a cold Observable, right?
    Let''s have a look at the output first:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们开始使用`publish()`运算符，看起来我们即将使用`connect()`运算符，我们有一个热Observable，对吧？是的，但是我们不是调用`connect()`，而是调用`refCount()`。这个运算符会使我们的Observable变热，这样当第一个订阅者到达时，它会表现得像一个冷Observable。明白了吗？这听起来就像一个冷Observable，对吧？让我们先看一下输出：
- en: '![](Images/36b34610-a52e-40ab-af36-aa2922f4d198.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/36b34610-a52e-40ab-af36-aa2922f4d198.png)'
- en: 'To answer the preceding question, yes, it''s correct that it just behaves like
    a cold Observable; we aren''t missing out on any emitted values. The interesting
    thing happens when we get a second subscriber. Let''s add that second subscriber
    and see what the effects are:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 回答前面的问题，是的，它的行为就像一个冷Observable；我们不会错过任何发出的值。有趣的事情发生在我们得到第二个订阅者时。让我们添加第二个订阅者，看看效果如何：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our second subscriber is added; now, let''s have a look at what the result
    is:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了第二个订阅者；现在，让我们看看结果是什么：
- en: '![](Images/ba5c64f7-982a-4e83-9d58-f52164b99678.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ba5c64f7-982a-4e83-9d58-f52164b99678.png)'
- en: What we can see from the results above is that the first subscriber is alone
    in receiving the number `0`. When the second subscriber arrives, its first value
    is `1`, which proves the stream has gone from acting like a cold Observable to
    a hot Observable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的结果中我们可以看到，第一个订阅者独自接收到数字`0`。当第二个订阅者到达时，它的第一个值是`1`，这证明了流已经从冷Observable变成了热Observable。
- en: 'There is another way we can do warm Observables, and that is through using
    the `share()` operator. The `share()` operator can be seen as more of a smart
    operator that allows our Observable to go from cold to hot, depending on the situation.
    That can be a really great idea sometimes. So, there are the following situations
    for Observables:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一种方法可以使用`share()`运算符来创建热的Observable。`share()`运算符可以被视为更智能的运算符，它允许我们的Observable根据情况从冷态变为热态。这有时可能是一个非常好的主意。因此，对于Observables，存在以下情况：
- en: Created as a hot Observable; the stream hasn't completed, and none of the subscribers
    are more than one
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为热Observable创建；流尚未完成，订阅者不超过一个
- en: Falls back into being a cold Observable; any previous subscription has had time
    to end before a new subscription arrives
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回到了冷Observable状态；任何先前的订阅都有时间结束，然后新的订阅才会到来
- en: Created as a cold Observable; the Observable itself has had time to complete
    before the subscription happens
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为冷Observable创建；Observable本身在订阅发生之前已经完成
- en: 'Let''s try to show in code how the first bullet can happen:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着用代码展示第一个情况是如何发生的：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code describes a situation where we defined a stream with a subscription
    that happens straight away. The second subscription happens after one second.
    Now, according to the definition of the `share()` operator, this means that the
    stream will be created as a cold Observable, but will, at the time of the second
    subscriber, be turned into a hot Observable, as there is a pre-existing subscriber
    and the stream has yet to complete. Let''s inspect our output to verify that this
    is the case:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码描述了这样一种情况：我们定义了一个带有立即发生的订阅的流。第二个订阅将在一秒后发生。现在，根据`share()`运算符的定义，这意味着流将被创建为一个冷Observable，但在第二个订阅者到来时，它将变成热Observable，因为已经有一个现有的订阅者，而流尚未完成。让我们检查输出来验证这一点。
- en: '![](Images/0c775f85-2d7d-4277-baee-b245cf676176.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0c775f85-2d7d-4277-baee-b245cf676176.png)'
- en: The first subscriber seems to be clearly alone in the values it gets. When the
    second subscriber arrives, it seems to share the producer, as it doesn't start
    from zero, but, rather, it starts listening where the first subscriber is.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个订阅者似乎显然是独自获得值的。当第二个订阅者到来时，它似乎共享了生产者，因为它不是从零开始，而是从第一个订阅者开始监听。
- en: Subjects
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题
- en: 'We are used to using Observables in a certain way. We construct them from something
    and we start listening to values that they emit. There is usually very little
    we can do to affect what is being emitted after the point of creation. Sure, we
    can change it and filter it, but it is next to impossible to add more to our `Observable`
    unless we merge it with another stream. Let''s have a look at when we are really
    in control of what is being emitted when it comes to Observables, using the `create()` operator:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们习惯以某种方式使用Observables。我们从某些东西构造它们，并开始监听它们发出的值。通常情况下，除了更改和过滤之外，我们几乎无法影响创建后发出的内容。除非我们将其与另一个流合并，否则几乎不可能为我们的`Observable`添加更多内容。让我们看看何时我们真正控制发出的内容时，使用`create()`操作符来处理Observables：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We see the Observable acting as a wrapper around the thing that really emits
    our values, the Observer. In our Observer instance, the Observer is calling `next()`,
    with a parameter to emit values – values that we listen to in our `subscribe()` method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到Observable充当了围绕真正发出值的东西的包装器，即Observer。在我们的Observer实例中，观察者正在调用`next()`，并带有一个参数来发出值-我们在`subscribe()`方法中监听到的值。
- en: 'This section is about the Subject. The Subject differs from the Observable
    in that it can affect the content of the stream after its creation. Let''s have
    a look at just that with the following piece of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是关于主题的。主题与Observable不同，它可以在创建后影响流的内容。让我们用下面的代码片段来看看：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first thing we notice is how we just call the constructor instead of using
    a factory method like `create()` or `from()` or similar, as we do on an Observable.
    The second thing we notice is how we subscribe to it on the second line, and only
    on the last line do we emit values by calling `next()`. Why is the code written
    in this order? Well, if we didn''t write it this way and have the `next()` call
    happen as the second thing, our subscription wouldn''t be there, and the value
    would have been emitted straight away. We know two things for sure, though: we
    are calling `next()`, and we are calling `subscribe()`, which makes `Subject`
    a double nature. We did mention another thing the `Subject` was capable of: changing
    the stream after creation. Our call to `next()` is literally doing that. Let''s
    add a few more calls so we ensure we really get the idea:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到的第一件事是，我们只是调用构造函数，而不是像在Observable上那样使用工厂方法`create()`或`from()`或类似的方法。我们注意到的第二件事是，我们在第二行订阅它，只有在最后一行才通过调用`next()`来发出值。为什么代码是按这种顺序编写的呢？如果我们不是这样编写代码，并且`next()`调用发生在第二件事之后，我们的订阅就不会存在，值将立即被发出。但有两件事我们是确定的：我们正在调用`next()`，我们正在调用`subscribe()`，这使`Subject`具有双重性质。我们确实提到了`Subject`的另一种能力：在创建后更改流。我们对`next()`的调用就是在做这件事。让我们再添加一些调用，以确保我们真正理解这个概念：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we stated before, all the calls we make to the `next()` method enable us
    to affect the stream; we see in our `subscribe()` method that every call to `next()` leads
    to the `subscribe()` being hit, or, technically, the first function we pass into
    it.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所述，我们对`next()`方法的所有调用都使我们能够影响流；我们在我们的`subscribe()`方法中看到，对`next()`的每次调用都会导致`subscribe()`被触发，或者从技术上讲，我们传递给它的第一个函数被触发。
- en: Using Subject for cascading lists
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Subject进行级联列表
- en: 'So, what''s the point? Why should we use Subjects over Observables? That''s
    actually a quite deep question. There are many ways of solving most streaming-related
    problems; problems where it is tempting to use a Subject can often be solved through
    some other way. Let''s have a look at what you could be using it for, though.
    Let''s talk about cascading drop-down lists. What we mean by that is that we want
    to know what restaurants exist in a city. Imagine, therefore, that we have a drop-down
    list that allows us to select what country we are interested in. Once we select
    a country, we should select the city we are interested in from a drop-down list
    of cities. Thereafter, we get to select from a list of restaurants, and, finally,
    pick the restaurant that interests us. In the markup, it most likely looks like
    this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，重点是什么？为什么我们应该使用Subjects而不是Observables？这实际上是一个非常深刻的问题。解决大多数与流相关的问题有许多方法；通常情况下诱人使用Subject的问题往往可以通过其他方式解决。不过，让我们来看看你可以用它来做什么。让我们谈谈级联下拉列表。我们所说的是，我们想知道一个城市中存在哪些餐馆。因此，想象一下，我们有一个下拉列表，允许我们选择我们感兴趣的国家。一旦我们选择了一个国家，我们应该从城市的下拉列表中选择我们感兴趣的城市。之后，我们可以从餐馆列表中进行选择，最后选择我们感兴趣的餐馆。在标记中，它很可能是这样的：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the start of the application, we haven''t selected anything, and the only
    drop-down list that is selected is the first one, and it is filled with countries.
    Imagine that we therefore set up the following code in JavaScript:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开始时，我们什么都没有选择，唯一被选择的下拉列表是第一个，它填满了国家。因此，想象一下，我们在JavaScript中设置了以下代码：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point, we have established that we want to listen to the selected events
    of each drop-down list, and we want, in the cases of countries or cities droplist,
    filter the upcoming droplist. Say we select a specific country then we want to
    repopulate/filter the cities droplist so that it only shows cities for the selected
    country. For the restaurant drop-down list, we want to perform a booking based
    on our restaurant selection. Sounds pretty simple, right? We need some subscribers.
    The cities drop-down list needs to listen to changes in the countries drop-down
    list. So we add that to our code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经确定我们想要监听每个下拉列表的选择事件，并且在国家或城市下拉列表的情况下，我们想要过滤即将到来的下拉列表。比如我们选择了一个特定的国家，然后我们想要重新填充/过滤城市下拉列表，以便它只显示所选国家的城市。对于餐馆下拉列表，我们想要根据我们的餐馆选择进行预订。听起来很简单，对吧？我们需要一些订阅者。城市下拉列表需要监听国家下拉列表的变化。所以我们把它加到我们的代码中：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, here, we have a behavior of performing an AJAX request when we select a
    country; we get a filtered list of cities, and we introduce the new subject instance `cities$`. 
    We call the `next()` method on it with our filtered cities as a parameter. Finally,
    we listen to changes to the `cities$` stream by calling the `subscribe()` method
    on the stream. As you can see, when data arrives, we rebuild our cities drop-down
    list there.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，我们有一个行为，当我们选择一个国家时执行一个AJAX请求；我们得到一个经过筛选的城市列表，并引入新的subject实例`cities$`。我们调用它的`next()`方法，并将我们筛选后的城市作为参数传递进去。最后，我们通过在流上调用`subscribe()`方法来监听`cities$`流的变化。正如你所看到的，当数据到达时，我们在那里重建我们的城市下拉列表。
- en: 'We realize that our next step is to react to changes from us doing a selection
    in the cities drop-down list. So, let''s set that up:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到，我们下一步是要对我们在城市下拉列表中进行选择的变化做出反应。所以，让我们来设置一下：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code, we added some code to react to a selection being made
    in our cities drop-down list. We also added some code to listen to changes in
    the `restaurants$` stream, which finally led to our restaurants drop-down list
    being repopulated. The last step is to listen to changes on us selecting a restaurant
    in the restaurants drop-down list. What should happen here is up to you, dear
    reader. A suggestion is that we query some API for the selected restaurant''s
    opening hours, or its menu. Use your creativity. We will leave you with some final
    subscription code, though:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了一些代码来对我们的城市下拉列表中的选择做出反应。我们还添加了一些代码来监听`restaurants$`流的变化，最终导致我们的餐馆下拉列表被重新填充。最后一步是监听我们在餐馆下拉列表中选择餐馆时的变化。这里应该发生的事情取决于你，亲爱的读者。一个建议是，我们查询一些API以获取所选餐馆的营业时间或菜单。发挥你的创造力。尽管如此，我们会留下一些最终的订阅代码：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This became a quite long code example, and it should be said that this is not
    the best way of solving a problem like this, but it does demonstrate how a Subject
    works: it can add value to the stream when it wants, and it can be subscribed
    to.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这变成了一个相当长的代码示例，应该说这不是解决这个问题的最佳方式，但它确实演示了主题的工作原理：它可以在想要时向流中添加值，并且可以被订阅。
- en: BehaviorSubject
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行为主题
- en: 'So far, we have been looking at the default type of Subject, and we have uncovered
    a little of its secrets. However, there are many more types of Subjects. One such
    interesting type of Subject is the `BehaviorSubject`. So, why do we need a `BehaviorSubject`,
    and for what? Well, when dealing with a default Subject, we are able to add values
    to the stream, as well as subscribe to the stream. The `BehaviorSubject` gives
    us some added capabilities, in the form of:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在看默认类型的主题，并揭示了一些它的秘密。然而，还有许多其他类型的主题。其中一个有趣的主题类型是`BehaviorSubject`。那么，为什么我们需要`BehaviorSubject`，以及为什么？嗯，当处理默认主题时，我们能够向流中添加值，并订阅流。`BehaviorSubject`给了我们一些额外的能力，形式如下：
- en: A starter value, which is great if we are able to show something to the UI while
    waiting for an AJAX call to finish
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个起始值，如果我们能够在等待AJAX调用完成时向UI显示一些内容，那就太好了
- en: We can query on the latest value; in some situations, it is interesting to know
    what the last emitted value was
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以查询最新的值；在某些情况下，知道最后发出的值是什么很有趣
- en: 'To address the first bullet, let''s write some code and showcase this capability:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第一个问题，让我们编写一些代码并展示这种能力：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ReplaySubject
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重放主题
- en: 'With a normal Subject, it matters when we start subscribing. If we start emitting
    values before our subscription is set up, those values are simply lost. If we
    have a `BehaviorSubject`, we have a somewhat better scenario. Even if we are late
    in subscribing, so a value has already been emitted, the very last emitted value
    is still possible to gain access to. Then the following question arises: What
    if two or more values are emitted before a subscription happens and we care about
    those values – what then?'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用普通主题，订阅的开始很重要。如果我们在设置订阅之前开始发出值，那些值就会被简单地丢失。如果我们有一个`BehaviorSubject`，情况会好一些。即使我们在订阅时已经晚了，所以值已经被发出，仍然有可能获得最后发出的值。然后出现了以下问题：如果在订阅发生之前发出了两个或更多个值，并且我们关心这些值
    - 那么呢？
- en: 'Let''s illustrate this scenario and see what happens with a Subject and `BehaviorSubject`,
    respectively:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子，看看主题和`BehaviorSubject`分别会发生什么。
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'What we can see from the preceding code is that Subject is not a good candidate
    if we care about values prior to us subscribing. The `BehaviorSubject` constructors
    are slightly better for that scenario, but if we really care about prior values,
    and a lot of them, then we should have a look at the `ReplaySubject`.  The `ReplaySubject`
    has the ability to specify two things: a buffer size and a window size. A buffer
    size is simply the amount of values it should remember from the past, and the
    window size specifies for how long it should remember them for. Let us demonstrate
    this in code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中我们可以看到，如果我们在订阅之前关心之前的值，Subject并不是一个好的选择。`BehaviorSubject`的构造函数对于这种情况稍微好一些，但如果我们真的关心之前的值，而且有很多值，那么我们应该看看`ReplaySubject`。`ReplaySubject`有能力指定两件事：缓冲区大小和窗口大小。缓冲区大小只是它应该记住的过去值的数量，窗口大小指定它应该记住这些值的时间。让我们在代码中演示这一点：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we can see how we emit `2` and `3`, that is, the two
    latest emitted values. This is due to the fact that we specify the buffer size
    in the `ReplaySubject` constructor to be 2\. The only value we loose out on is
    1\. Had we, on the other hand, specified a 3 in our constructor, all three values
    would have reached the subscriber. So much for the buffer size and how that works;
    what about the window size property? Let''s illustrate how that works with the
    following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们发出了`2`和`3`，也就是最近发出的两个值。这是因为我们在`ReplaySubject`构造函数中指定了缓冲区大小为2。我们失去的唯一值是1。另一方面，如果我们在构造函数中指定了3，所有三个值都会到达订阅者。这就是缓冲区大小的作用；那么窗口大小属性呢？让我们用下面的代码来说明它是如何工作的：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we specify the window size as 2,000 milliseconds; that is how long the
    values should be held in the buffer. We can see below that we delay the creation
    of our subscription to occur after 2,010 milliseconds. The end result of this
    is that no values will be emitted, as the buffer will have been emptied before
    the subscription has time to occur. A higher value of the window size would have
    fixed this issue.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将窗口大小指定为2,000毫秒；这是值应该在缓冲区中保持的时间。我们可以看到下面，我们延迟了订阅的创建，使其在2,010毫秒后发生。这样做的最终结果是没有值会被发出，因为在订阅发生之前缓冲区已经被清空。窗口大小的值更高将解决这个问题。
- en: AsyncSubject
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AsyncSubject
- en: 'The `AsyncSubject` has a capacity of one, which means we can emit a ton of
    values, but only the latest one is something that is stored. It isn''t really
    lost, either, but you won''t see it unless you complete the stream. Let''s look
    at a piece of code that illustrates just this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncSubject`的容量为1，这意味着我们可以发出大量的值，但只有最新的一个被存储。它也不是真的丢失了，但除非你完成流，否则你看不到它。让我们看一个代码片段，说明了这一点：'
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Earlier, we had fours values being emitted, but nothing seems to reach the
    subscriber. At this point, we don''t know whether this is because it just acts
    like a subject and throws away all emitted values that happen before a subscription
    or not. Let''s therefore call the `complete()` method and see how that plays out:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们发出了四个值，但似乎没有任何东西到达订阅者。在这一点上，我们不知道这是因为它只是像一个主题一样，丢弃在订阅之前发生的所有发出的值，还是其他原因。因此，让我们调用`complete()`方法，看看情况如何发展：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will emit a `4` due to the fact that `AsyncSubject` only remembers the
    last value and we are calling the `complete()` method, thereby signaling the completion
    of the stream.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发出一个`4`，因为`AsyncSubject`只记住最后一个值，我们调用了`complete()`方法，从而表示流的完成。
- en: Error handling
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: Error handling is a very big topic. It is an area that is easy to underestimate.
    Normally, when coding, we could be led to believe we just need to do certain things,
    such as ensure we don't have syntax errors or runtime errors. With streams, we
    mostly think of runtime errors. The question is, how should we act when an error
    occurs? Should we pretend like it rains and just throw the error away? Should
    we hope for a different outcome if we try the same code some time in the future,
    or should we maybe just give up when a certain type of error exists? Let's try
    to collect our thoughts and look at the different error approaches that exist
    within RxJS.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理是一个非常重要的话题。这是一个很容易被低估的领域。通常，在编码时，我们可能会被误导认为我们只需要做一些特定的事情，比如确保我们没有语法错误或运行时错误。对于流，我们大多数时候会考虑运行时错误。问题是，当发生错误时，我们应该如何行动？我们应该像下雨一样假装并丢弃错误吗？如果我们在将来尝试相同的代码，我们应该希望有不同的结果，或者当某种类型的错误存在时，我们应该放弃吗？让我们试着整理一下思绪，看看RxJS中存在的不同错误处理方法。
- en: Catch and continue
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获并继续
- en: 'Sooner or later, we will have a stream that will throw an error. Let''s see
    what that can look like:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 迟早会有一个流会抛出一个错误。让我们看看那是什么样子：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, we set up a scenario where we first emit a value, followed
    by emitting an error. The first value is captured in our first callback in our
    subscribe method. The second emitted thing, the error, is captured by our error
    callback. The third emitted value does not get emitted to our subscriber because
    our stream has been interrupted by the error. There is something we can do here,
    and that is to use the `catch()` operator. Let''s apply that to our stream and
    see what happens:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们设置了一个场景，首先发出一个值，然后发出一个错误。第一个值被我们subscribe方法中的第一个回调捕获。第二个发出的东西，错误，被我们的错误回调捕获。第三个发出的值并没有被发出给我们的订阅者，因为我们的流被错误中断了。在这里我们可以做一些事情，那就是使用`catch()`操作符。让我们将其应用到我们的流中，看看会发生什么：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we capture our error with the `catch()` operator. In the `catch()` operator,
    we take our error and emit it as a normal Observable using the `of()` operator.
    What happens to the `2` we emit, though? Still no luck with that one. The `catch()` operator
    is able to take our error and turn it into a normal emitted value; instead of
    an error, we don't get all the values from the stream.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`catch()`操作符捕获我们的错误。在`catch()`操作符中，我们将错误作为普通的Observable使用`of()`操作符发出。然而，我们发出的`2`会发生什么呢？对于这个值，依然没有运气。`catch()`操作符能够将我们的错误转换为正常的发出值；而不是一个错误，我们不会从流中得到所有的值。
- en: 'Let''s have a look at a scenario when we are dealing with multiple streams:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看处理多个流的情况：
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the scenario above, we merge three streams. The first stream emits the number
    `1` and nothing else gets emitted. This is due to our second stream tearing everything
    down, as it emits an error. Let''s try to apply our newfound `catch()` operator
    and see what happens:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的场景中，我们合并了三个流。第一个流发出数字`1`，然后没有其他值被发出。这是由于我们的第二个流将一切都拆除，因为它发出了一个错误。让我们尝试应用我们新发现的`catch()`操作符，看看会发生什么：
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We run the above code and we notice that the `1` is emitted, the error is emitted
    as a normal value, and, finally, even the `2` is emitted. Our conclusion here
    is that it is a good idea to apply a `catch()` operator to a stream before it
    is being merged with our streams.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行上面的代码，我们注意到`1`被发出，错误被作为正常值发出，最后甚至`2`也被发出。我们的结论是，在将流与我们的流合并之前，应用`catch()`操作符是一个好主意。
- en: As before, we can also conclude that the `catch()` operator is able to stop
    the stream from just erroring out, but that other values that would have been
    emitted after the error are effectively lost.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们也可以得出结论，`catch()`操作符能够阻止流仅仅出现错误，但在错误之后本来会被发出的其他值实际上是丢失了。
- en: Ignoring the error
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略错误
- en: 'As we saw in the former section, the `catch()` operator does a good job of
    ensuring that a stream that errors out doesn''t cause any problems when being
    merged with another stream. The `catch()` operator enables us to take the error,
    investigate it, and create a new Observable that will emit a value as though nothing
    happened. Sometimes, however, you don''t want to even deal with streams that error
    out. For such a scenario, there is a different operator, called `onErrorResumeNext()`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中看到的，`catch()`操作符很好地确保了出现错误的流在与另一个流合并时不会造成任何问题。`catch()`操作符使我们能够获取错误，调查它，并创建一个新的Observable，它将发出一个值，就好像什么都没有发生过一样。然而，有时候，你甚至不想处理出现错误的流。对于这种情况，有一个不同的操作符，叫做`onErrorResumeNext()`：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The implication of using the `onErrorResumeNext()` operator is that the second
    stream, the one that emits an error, gets completely ignored, and the values `1`
    and `2` get emitted. This is a very nice operator to use if your scenario is only
    about caring for the streams that do not error out.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`onErrorResumeNext()`操作符的含义是，第二个流，即发出错误的流，被完全忽略，而值`1`和`2`被发出。如果你的情况只涉及关心不出错的流，那么这是一个非常好的操作符。
- en: Retry
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重试
- en: 'There are different reasons why you would want to retry a stream. It''s easier
    to imagine why you would want to if your stream is dealing with AJAX calls. Network
    connections may be unreliable at times with the local network you are on, or the
    service you are trying to hit may be temporarily down for some reason. Regardless
    of the reason, you have a situation where hitting that endpoint will some of the
    time reply with an answer, and some of the time return a 401 error. What we are
    describing here is the business case for adding retry logic to your streams. Let''s
    have a look at a stream designed to fail:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的原因会导致你想要重试一个流。如果你的流正在处理AJAX调用，想要重试的原因就更容易想象了。网络连接有时可能不可靠，可能是你所在的本地网络，或者你尝试访问的服务可能因某种原因暂时不可用。无论原因是什么，你都会遇到这样一种情况，即命中该端点有时会回复一个答案，有时会返回401错误。我们在这里描述的是为流添加重试逻辑的业务案例。让我们来看一个设计失败的流：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of the code above is the value `1` being emitted four times, followed
    by our error. What happens is that our streams'' values are retried three times
    before the error callback is hit in the subscribe. Using the `retry()` operator
    delays when the error is actually treated as an error. The preceding example doesn''t
    make sense to retry, though, as the error will always occur. Therefore, let''s
    take a better example – an AJAX call where the network connection may come and
    go:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上面代码的输出是值`1`被发出四次，然后是我们的错误。发生的情况是我们的流的值在错误回调被触发之前重试了三次。使用`retry()`操作符会延迟错误被实际视为错误的时间。然而，前面的例子不适合重试，因为错误总是会发生。因此，让我们来看一个更好的例子
    - 一个可能会断断续续的网络连接的AJAX调用：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, we are attempting an AJAX request towards a file that doesn''t seem to
    exist. Having a look at the console, we are faced with the following result:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在尝试向一个似乎不存在的文件发出AJAX请求。查看控制台后，我们面对以下结果：
- en: '![](Images/e4df4109-8dd2-41ee-bbf7-5a7a99832bd4.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e4df4109-8dd2-41ee-bbf7-5a7a99832bd4.png)'
- en: 'What we see in the above logging are four failed AJAX requests that lead to
    an error. We have essentially just switched our simple stream to a more credible
    AJAX request stream, with the same behavior. Should the file suddenly start to
    exist, we may have a scenario with two failed attempts and one successful attempt.
    Our approach has a flaw, though: we retry our AJAX attempts far too often. If
    we are actually dealing with an intermittent network connection, we need to have
    some kind of delay between attempts. It is reasonable to set a delay between attempts
    of at least 30 seconds or more. We can accomplish that by using a slightly different
    retry operator that takes milliseconds rather than a number of attempts as an
    argument. It looks like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的日志中，我们看到了四次失败的AJAX请求导致了错误。我们基本上只是将我们简单的流切换到了一个更可信的AJAX请求流，行为相同。如果文件突然开始存在，我们可能会遇到两次失败尝试和一次成功尝试的情况。然而，我们的方法有一个缺陷：我们重试AJAX尝试的次数太多了。如果我们实际上正在处理间歇性的网络连接，我们需要在尝试之间设置一些延迟。合理地设置尝试之间的延迟至少为30秒或更长的时间。我们可以通过使用一个稍微不同的重试操作符来实现这一点，该操作符需要毫秒而不是尝试次数作为参数。它看起来像下面这样：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What we do here is use the operator `retryWhen()`. The `retryWhen()` operator's
    mission in life is to return a stream. At this point, you can manipulate the stream
    it returns by appending a `.delay()` operator that takes a number of milliseconds.
    The result from doing so is that it will retry the AJAX call for all eternity,
    which may not be what you want.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`retryWhen()`操作符。`retryWhen()`操作符的使命是返回一个流。在这一点上，您可以通过附加一个`.delay()`操作符来操作它返回的流，该操作符需要一个毫秒数。这样做的结果是它将永远重试AJAX调用，这可能不是您想要的。
- en: Advanced Retry
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级重试
- en: 'What we most likely want is to combine the delay between retry attempts with
    being able to specify how many times we want to retry the stream. Let''s have
    a look at how we can accomplish that:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最希望的是将重试尝试之间的延迟与能够指定重试流的次数相结合。让我们看看我们如何可以实现这一点：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The interesting part here is that we use the operator `.take()`. We specify
    the number of emitted values we want from this inner Observable. We have now accomplished
    a nice approach in which we are able to control the number of retries and the
    delay between retries. There is an aspect to this that we haven''t tried, namely,
    how we want all the retries to end when it finally gives up. In the preceding
    code, the stream just completes after the stream is retried after *x* number of
    times with no successful result. However, we may want the stream to error out
    instead. We can accomplish this by just adding an operator to the code, like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的部分是我们使用了操作符`.take()`。我们指定了我们希望从这个内部Observable中发出的值的数量。我们现在已经实现了一种不错的方法，可以控制重试次数和重试之间的延迟。关于这一点还有一个方面我们还没有尝试过，那就是当最终放弃时我们希望所有的重试都结束。在前面的代码中，流在*x*次重试后没有成功结果时就会静默完成。然而，我们可能希望流出现错误。我们可以通过向代码添加一个操作符来实现这一点，就像这样：
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we are adding a `concat()` operator that adds a stream that just fails.
    So we are guaranteed, after three failed attempts, to have an error happen. This
    is usually a better approach than having the stream silently complete after *x*
    number of failed attempts.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个`concat()`操作符，它添加了一个只会失败的流。因此，在三次失败尝试之后，我们保证会发生错误。这通常比在*x*次失败尝试后静默完成流更好。
- en: This isn't a perfect approach, though; imagine that you want to investigate
    what type of error you get back. In the case of AJAX requests being made, it matters
    whether we get a 400-something error or a 500-something error back as HTTP status
    code. They mean different things.  With 500 errors, something is very wrong on
    the backend, and we probably want to give up straight away. With a 404 error,
    however, this implies the resource isn't there, but in the case with an intermittent
    network connection, this means the resource can't be reached due to our connection
    being offline. For that reason, a 404 error might be worth retrying. To solve
    that in code, we need to inspect the value being emitted to determine what to
    do. We can inspect values using the `do()` operator.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是一个完美的方法；想象一下，你想调查你收到的错误类型。在进行AJAX请求时，我们收到400多个错误或500多个错误作为HTTP状态码是很重要的。它们意味着不同的事情。500错误意味着后端出现了严重的问题，我们可能想立即放弃。然而，404错误意味着资源不存在，但在网络连接不稳定的情况下，这意味着由于我们的连接处于离线状态，无法访问资源。因此，404错误可能值得重试。为了解决这个问题，我们需要检查发出的值以确定该做什么。我们可以使用`do()`运算符来检查值。
- en: 'In the following code, we investigate the type of HTTP status of the response
    and determine how to handle it:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们调查响应的HTTP状态类型，并确定如何处理它：
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Marble testing
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大理石测试
- en: Testing asynchronous code can be challenging. For one, we have the time factor.
    The way we specify what operators to use for our crafted algorithm leads to the
    algorithm taking anywhere from 2 seconds to 30 minutes to execute. Therefore,
    it will at first feel like there is no point in testing it, because it can't be
    done within a reasonable time. We have a way to test RxJS, though; it is called
    Marble testing and it allows us to control how fast time passes so we have a test
    that can execute it in milliseconds.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 测试异步代码可能具有挑战性。首先，我们有时间因素。我们指定我们的精心设计的算法要使用哪些运算符的方式导致算法执行的时间从2秒到30分钟不等。因此，起初会感觉没有测试的意义，因为它无法在合理的时间内完成。然而，我们有一种测试RxJS的方法；它被称为大理石测试，它允许我们控制时间的流逝速度，这样我们就可以在毫秒内执行测试。
- en: The idea of a Marble is known to us. We can represent one or many streams and
    the effect an operator has one two or more streams. We do this by drawing the
    streams as a line and values as circles on the lines. The operator is shown as
    verb below the input streams. Following operator is a third stream, the result
    of taking the input streams and applying the operator, a so - called marble diagram.
    The line represents a continuous timeline. We take this concept and bring it to
    testing. What this means is that we can express our incoming values as a graphical
    representation and apply our algorithm to it and assert on the result.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 大理石的概念对我们来说是众所周知的。我们可以表示一个或多个流，以及运算符对一个、两个或多个流的影响。我们通过将流绘制成一条线，将值绘制成线上的圆圈来实现这一点。运算符显示为输入流下方的动词。接下来是运算符，是第三个流，是将输入流应用于运算符的结果，所谓的大理石图。线代表连续的时间线。我们将这个概念引入到测试中。这意味着我们可以将我们的传入值表示为图形，并将我们的算法应用于它，并对结果进行断言。
- en: Set up
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: 'Let''s set up our environment correctly so we can write marble tests. We need
    the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们正确设置我们的环境，这样我们就可以编写大理石测试了。我们需要以下内容：
- en: The NPM library jasmine-marbles
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NPM库jasmine-marbles
- en: A scaffolded Angular application
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个脚手架化的Angular应用程序
- en: 'With that we scaffold our Angular project, like so:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就可以像这样脚手架我们的Angular项目了：
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After the project has been scaffolded, it''s time to add our NPM library, like
    so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 项目脚手架完成后，是时候添加我们的NPM库了，就像这样：
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now we have finished the setup, so the time has come to write tests.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了设置，是时候编写测试了。
- en: Writing your first marble test
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你的第一个大理石测试
- en: 'Let''s create a new file `marble-testing.spec.ts`. It should look like the
    following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新文件`marble-testing.spec.ts`。它应该看起来像下面这样：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A lot of interesting things are happening here. We import the function `cold()` from
    the NPM library marble-testing. Thereafter we set up a test suite by calling `describe()`,
    followed by a test specification, by calling `it()`. Then we call our `cold()` function
    and provide it a string. Let''s have a close look at that function call:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多有趣的事情。我们从NPM库marble-testing中导入了`cold()`函数。然后我们通过调用`describe()`来设置一个测试套件，然后通过调用`it()`来设置一个测试规范。然后我们调用我们的`cold()`函数并提供一个字符串。让我们仔细看看这个函数调用：
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The above code set up a stream that expects to values to be emitted followed
    by the stream ending. How do we know that? It's time to explain what `x-x|` means.
    `x` is just any value, the hyphen `-` means time has passed. The pipe `|` means
    our stream has ended. The second argument in the cold function is a mapping object
    that tells us what the x means. In this case, it has come to mean the value 1.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码设置了一个流，期望发射两个值，然后结束流。我们怎么知道呢？现在是时候解释`x-x|`的意思了。`x`只是任何值，破折号`-`表示时间已经过去。管道`|`表示我们的流已经结束。`cold`函数中的第二个参数是一个映射对象，告诉我们x的含义。在这种情况下，它表示值1。
- en: 'Moving on, let''s have a look at the next line:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看下一行：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code applies the operator `.map()` and increased the value with
    one for each value emitted in the stream. Thereafter, we call the `.toBeObservable()` helper
    method and verify it against an expected condition,
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码应用了操作符`.map()`并且对流中发射的每个值增加了一个。然后，我们调用了`.toBeObservable()`辅助方法并根据预期条件进行验证，
- en: '[PRE40]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The previous condition states that we expect the stream to should emit two values,
    but that the values should now have the number 2\. This makes sense, as our `map()` function
    performs just that.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的条件说明我们期望流应该发射两个值，但是这些值现在应该是数字2。这是有道理的，因为我们的`map()`函数就是做这个的。
- en: Fleshing out with more tests
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 充实更多的测试
- en: 'Let''s write one more test. This time we will be testing the `filter()` operator.
    This one is interesting, as it filters away values that does not fulfill a certain
    condition. Our test file should now look like the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再写一个测试。这次我们将测试`filter()`操作符。这个操作符很有趣，因为它过滤掉不满足特定条件的值。我们的测试文件现在应该看起来像下面这样：
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This test is set up in pretty much the same way as our first test. This time
    we use the `filter()` operator but what stands out is our expected stream:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的设置方式基本上和我们的第一个测试一样。这次我们使用了`filter()`操作符，但是显著的是我们期望的流：
- en: '[PRE42]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`--y`, means that our first values is removed. Based on how the filter condition
    is defined, we are not surprised. The reason for the double hyphen, `-`, though,
    is that time still passes, but instead of an emitted value a hyphen takes its
    place.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`--y`，意味着我们的第一个值被移除了。根据过滤条件的定义，我们并不感到意外。然而，双破折号`-`的原因是时间仍在流逝，但是代替发射值的是一个破折号。'
- en: To learn more about Marble testing, have a look at the following link from the
    official documentation, [https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md](https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Marble测试的更多信息，请查看官方文档中的以下链接，[https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md](https://github.com/ReactiveX/rxjs/blob/master/doc/writing-marble-tests.md)
- en: Pipeable operators
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可管道的操作符
- en: 'We haven''t mentioned it much so far, but the RxJS library weighs in quite
    heavily when used in an app. In today''s world of mobile first, every kilobyte
    counts when it comes to libraries that you include in your app. They count because
    the user may be on a 3G connection, and if it takes too long to load, your user
    may leave, or just may end up not liking your app, as it feels slow to load, and
    this may cause you to have bad reviews or lose users. So far, we have used two
    different ways of importing RxJS:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有提到它太多，但是在应用程序中使用RxJS库会非常沉重。在今天的移动优先世界中，每个字节在你的应用程序中包含的库都很重要。这很重要，因为用户可能在3G连接上，如果加载时间太长，用户可能会离开，或者可能最终不喜欢你的应用程序，因为它加载起来感觉很慢，这可能导致你得到不好的评价或失去用户。到目前为止，我们已经使用了两种不同的导入RxJS的方式：
- en: Importing the whole library; this one is quite costly in terms of size
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入整个库；这在大小方面是非常昂贵的
- en: Importing only the operators we need; this ensures that the bundle decreases
    significantly
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只导入我们需要的操作符；这可以显著减少捆绑包的大小
- en: 'The different options have looked like this, for importing the whole library
    and all its operators:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的选项看起来像这样，用于导入整个库和所有其操作符：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Or like this, to only import what we need:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像这样，只导入我们需要的：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'That looks good, right? Well, yes, but it is a flawed approach. Let''s explain
    what happens when you type:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错，对吧？是的，但这是一个有缺陷的方法。让我们解释一下当你输入时会发生什么：
- en: '[PRE45]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'By typing the preceding, we add to the prototype of the `Observable`. Looking
    in the source code for RxJS, it looks like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入前面的内容，我们向`Observable`的原型添加了内容。查看RxJS的源代码，它看起来是这样的：
- en: '[PRE46]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see from the preceding code, we import the `Observable` as well
    as the operator in question and we add the operator to the prototype by assigning
    it to a `map` property on the prototype. What''s flawed with that, you might wonder?
    The problem is tree shaking, a process we use to get rid of unused code. Tree
    shaking has a hard time determining what you use and don''t use, respectively.
    You may actually import a `map()` operator and it gets added to the Observable.
    As the code changes over time, you may end up not using it anymore. You may argue
    that you should remove the import at that point, but you might have a lot of code,
    and it is easy to overlook. It would be better if only used operators were included
    in the final bundle. It is, as we mentioned before, hard for the tree-shaking
    process to know what is used and what is not, with the current approach. For that
    reason, a big rewrite has happened in RxJS, adding something called pipeable operators,
    which help us with the above problem. There is also another downside to patching
    the prototype, and that is the fact that it creates a dependency. If the library
    changes and the operator is no longer added when we patch it (calling the import),
    then we have a problem. We won''t detect the problem until runtime. We would rather
    be told that the operator has gone through us importing and explicitly using it,
    like so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，我们导入了`Observable`以及相关的操作符，并通过将其分配给原型上的`map`属性来将操作符添加到原型中。你可能会想，这有什么问题？问题在于摇树，这是我们用来摆脱未使用代码的过程。摇树在确定你使用和不使用的代码方面有困难。你可能实际上导入了一个`map()`操作符，并且它被添加到了Observable中。随着时间的推移，你可能不再使用它。你可能会争辩说在那时应该删除导入，但你可能有很多代码，很容易忽视。最好的方法是只包含在最终捆绑包中使用的操作符。正如我们之前提到的，目前的方法对于摇树过程来说很难知道什么被使用了，什么没有被使用。因此，RxJS进行了一次大的重写，添加了一种称为管道操作符的东西，它可以帮助我们解决上述问题。在修改原型的同时还有另一个缺点，那就是它创建了一个依赖。如果库发生了变化，并且在我们修补它时（调用导入）不再添加操作符，那么我们就有了问题。我们直到运行时才能检测到问题。我们宁愿被告知操作符已经通过我们导入并明确使用了，就像这样：
- en: '[PRE47]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Creating reusable operators with let()
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用let()创建可重用的操作符
- en: 'The `let()` operator lets you have the whole operator and operate on it, rather
    than just manipulating the values as you would do with the `map()` operator, for
    example. Using the `let()` operator could look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`let()`操作符让您拥有整个操作符并对其进行操作，而不仅仅像您使用`map()`操作符那样操作值。使用`let()`操作符可能会像这样：'
- en: '[PRE48]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding example, we were able to define a group of operators such as `addAndFilter` and `sub3` and
    use them on the stream with the `let()` operator. This enables us to create composable
    and reusable operators. It is with this very knowledge that we now move on to
    the concept of pipeable operators.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们能够定义一组操作符，比如`addAndFilter`和`sub3`，并在流上使用它们与`let()`操作符。这使我们能够创建可组合和可重用的操作符。正是基于这种知识，我们现在转向管道操作符的概念。
- en: Shifting to pipeable operators
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向可管道化的操作符
- en: 'As we mentioned already, pipeable operators are here, and you can find them
    by importing the respective operators from the `rxjs/operators` directory, like
    so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，可管道化的操作符已经出现了，您可以通过从`rxjs/operators`目录导入相应的操作符来找到它们，就像这样：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To use it, we are now relying on the `pipe()` operator that we use as the parent
    operator, if you will. Using the preceding operators will, therefore, look like
    this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用它，我们现在依赖于`pipe()`操作符，我们将其用作父操作符。因此，使用前面的操作符将如下所示：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has taken us deep into RxJS by covering topics such as hot, cold,
    and warm Observables, and what that generally means in terms of when to subscribe
    to a stream and how they share their Producer under certain conditions. Next up,
    we covered Subjects, and the fact that Observable isn't the only thing you can
    subscribe to. Subjects also allow as to append values to the stream whenever we
    want, and we also learned that there exist different types of Subjects, depending
    on the situation at hand.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了RxJS，涵盖了诸如热、冷和温暖的Observables等主题，以及这在何时订阅流以及它们在特定条件下如何共享其生产者的一般含义。接下来，我们介绍了Subjects，并且Observable并不是您唯一可以订阅的东西。Subjects还允许我们在需要时向流中追加值，我们还了解到根据手头的情况存在不同类型的Subjects。
- en: We ventured deeper into an important topic, testing, and tried to explain the
    difficulty in testing asynchronous code. We talked about the current state of
    the testing situation and what libraries to use here and now for your testing
    scenarios. Lastly, we covered pipeable operators, and our new preferred way of
    importing and composing operators to ensure we end up with the smallest possible
    bundle size.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们深入探讨了一个重要的主题，测试，并试图解释测试异步代码的困难。我们谈到了测试情况的现状，以及在测试场景中现在应该使用哪些库。最后，我们介绍了可管道化的操作符，以及我们新的首选方式，即导入和组合操作符，以确保最小可能的捆绑大小。
- en: In the next chapter, you will leverage Kanban using Waffle, build a simple web
    app with a full-stack architecture in mind, and get introduced to reactive programming
    with RxJS.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将利用Waffle使用看板，构建一个以全栈架构为目标的简单Web应用，并介绍使用RxJS进行响应式编程。
