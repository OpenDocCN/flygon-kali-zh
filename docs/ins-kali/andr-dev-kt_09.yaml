- en: Making Your Marvel Gallery Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作您的Marvel画廊应用程序
- en: We've already seen the most important Kotlin features that allow us to make
    Android development easier and more productive, but it is hard to understand the
    whole picture just by looking at the pieces. This is why, in this chapter, we
    will build a whole Android application written in Kotlin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了最重要的Kotlin功能，它们使得Android开发更加简单和高效，但仅仅通过查看这些部分很难理解整个画面。因此，在本章中，我们将构建一个完整的用Kotlin编写的Android应用程序。
- en: It was a tough decision to choose what application should be implemented in
    this chapter. It has to be short and simple, but at the same time it should utilize
    as many Kotlin features as possible. At the same time, we wanted to minimize the
    number of used libraries, because it is a book about Android development in Kotlin,
    not about Android libraries. We wanted to make it look as good as possible, but
    we also wanted to avoid implementation of custom graphic elements, because they
    are usually complex and do not really provide benefits from a Kotlin perspective.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，选择要实现的应用程序是一个艰难的决定。它必须简短而简单，但同时应尽可能多地利用Kotlin功能。同时，我们希望最小化使用的库的数量，因为这是一本关于Kotlin的Android开发书籍，而不是关于Android库的书籍。我们希望它看起来尽可能好，但同时我们也希望避免实现自定义图形元素，因为它们通常复杂且实际上并不从Kotlin的角度提供好处。
- en: We have finally decided to make a Marvel Gallery application--a small app which
    we can use to find our favorite Marvel characters and display their details. All
    data is provided from the Marvel website by their API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终决定制作一个Marvel画廊应用程序--一个小型应用程序，我们可以用来查找我们最喜欢的Marvel角色并显示他们的详细信息。所有数据都是通过Marvel网站的API提供的。
- en: Marvel Gallery
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Marvel画廊
- en: 'Let''s implement our Marvel Gallery application. This application should allow
    the following use cases:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现我们的Marvel画廊应用程序。该应用程序应允许以下用例：
- en: After starting the application, the user can see a gallery of characters.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动应用程序后，用户可以看到一个角色画廊。
- en: After starting the application, the user can search for a character by its name.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动应用程序后，用户可以通过角色名称搜索角色。
- en: When the user clicks on a character picture, there is a profile displayed. The
    character profile contains character name, photo, description, and its occurrences.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击角色图片时，会显示一个简介。角色简介包括角色名称、照片、描述和出现次数。
- en: These are three use-cases that describe the main functionalities of the application.
    In the next sections, we are going to implement them one after another. If you
    are lost during this chapter, remember that you can always take a look at the
    complete application on GitHub ( [https://github.com/MarcinMoskala/MarvelGallery](https://github.com/MarcinMoskala/MarvelGallery)
    ).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是描述应用程序主要功能的三种用例。在接下来的章节中，我们将逐一实现它们。如果在本章中迷失了方向，记住您可以随时在GitHub上查看完整的应用程序（[https://github.com/MarcinMoskala/MarvelGallery](https://github.com/MarcinMoskala/MarvelGallery)）。
- en: 'To understand better what we want to build, let''s look at some screenshots
    from the final version of our application:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解我们想要构建的内容，让我们看一些来自我们应用程序最终版本的截图：
- en: '![](img/Image00053.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00053.jpg)'
- en: How to use this chapter
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用本章
- en: This chapter shows all steps and code necessary to build an application. Its
    purpose is to show the step-by-step process of this application development. When
    you are reading this chapter, concentrate on the development process and try to
    understand what the purpose of presented code is. You don't need to fully understand
    layouts and you don't have to understand unit test definitions as long as you
    understand what they are doing. Concentrate on application structure and Kotlin
    solutions that are making the final code simpler. Most solutions were already
    described in previous chapters, so they have only a brief description. The value
    in this chapter is that their usage is presented in the context of a concrete
    application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了构建应用程序所需的所有步骤和代码。其目的是展示应用程序开发的逐步过程。在阅读本章时，专注于开发过程，并尝试理解所呈现的代码的目的。您不需要完全理解布局，也不必理解单元测试的定义，只要理解它们在做什么即可。专注于应用程序结构和使最终代码更简单的Kotlin解决方案。大多数解决方案已在前几章中进行了描述，因此只有简要描述。本章的价值在于它们的使用是在具体应用程序的上下文中呈现的。
- en: You can download the application code from GitHub ( [https://github.com/MarcinMoskala/MarvelGallery](https://github.com/MarcinMoskala/MarvelGallery)
    ).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从GitHub（[https://github.com/MarcinMoskala/MarvelGallery](https://github.com/MarcinMoskala/MarvelGallery)）下载应用程序代码。
- en: 'On GitHub, you can see the final code, download it, or you can clone it to
    your computer using Git:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub上，您可以查看最终代码，下载它，或者使用Git将其克隆到您的计算机上：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The application also includes UI tests written in **Espresso** , but they are
    not presented on this chapter to make it simpler for readers who are not proficient
    in Espresso usage.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序还包括使用**Espresso**编写的UI测试，但本章未展示它们，以使对Espresso使用不熟练的读者更容易理解。
- en: 'Each section of this chapter has a corresponding Git branch on this project,
    so if you want to see how the code looks at the end of the section then you can
    just switch to the corresponding branch:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的每个部分在此项目上都有一个对应的Git分支，因此如果您想看到每个部分结束时的代码是什么样子，只需切换到相应的分支即可：
- en: '![](img/Image00054.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00054.jpg)'
- en: 'Also, locally, after you clone the repository, you can check out the corresponding
    branch using the following Git command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本地，当您克隆存储库后，可以使用以下Git命令检出相应的分支：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you have an electronic version of this book and you want to make the whole
    application by copy and pasting parts of the code then you can do it, but remember
    to place files in the folders corresponding to the package. This way, you will
    keep a clean structure in the project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有本书的电子版本，并且想通过复制和粘贴代码的方式制作整个应用程序，那么您可以这样做，但请记住将文件放在对应包的文件夹中。这样，您将保持项目的清晰结构。
- en: 'Note that if you place code from the book in another folder, there will be
    a warning displayed:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您将书中的代码放在其他文件夹中，将会显示警告：
- en: '![](img/Image00055.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00055.jpg)'
- en: 'You can intentionally place a file in any folder, because the second fix proposition
    is to move the file into the path corresponding to the defined package:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以故意将文件放在任何文件夹中，因为第二个修复建议是将文件移动到与定义的包对应的路径中：
- en: '![](img/Image00056.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00056.jpg)'
- en: You can use it to move your file into the correct location.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用它将文件移动到正确的位置。
- en: Make an empty project
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个空项目
- en: 'Before we can start implementing functionalities, we need to create an empty
    Kotlin Android project with a single activity, `MainActivty` . This process was
    described in [Chapter 1](text00021.html) *,* *Beginning your Kotlin Adventure*
    . Therefore, we don''t need to describe it deeply, but we will show what the steps
    are in Android Studio 3.0:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现功能之前，我们需要创建一个空的Kotlin Android项目，其中只有一个活动，`MainActivty`。这个过程在[第1章](text00021.html)中已经描述过了，*开始你的Kotlin冒险*。因此，我们不需要深入描述它，但我们会展示在Android
    Studio 3.0中的步骤是什么：
- en: Set name, package, and location for the new project. Remember to tick Include
    Kotlin support option:*.*
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新项目设置名称、包和位置。记得勾选包括Kotlin支持选项：*.*
- en: '![](img/Image00057.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00057.jpg)'
- en: 'We can choose other minimal Android version, but in this example, we are going
    to set API 16:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以选择其他最小的Android版本，但在这个例子中，我们将设置API 16：
- en: '![](img/Image00058.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00058.jpg)'
- en: Choose a template. We don't need any of these templates so we should start from
    Empty Activity *:*
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个模板。我们不需要这些模板中的任何一个，所以我们应该从空活动开始*：*
- en: '![](img/Image00059.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00059.jpg)'
- en: Name newly created activity. We can keep the first view named `MainActivity`
    *:*
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名新创建的活动。我们可以保留第一个视图命名为`MainActivity` *:*
- en: '![](img/Image00060.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00060.jpg)'
- en: 'For Android Studio prior to 3.x, we need to follow slightly different steps:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android Studio 3.x之前的版本，我们需要遵循稍微不同的步骤：
- en: Create a project from template with empty *Activity* .
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空的*Activity*从模板创建项目。
- en: 1\. Configure Kotlin in the project (for example, *Ctrl* /*Cmd* + *Shift* +
    *A* and Configure Kotlin in project ).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 配置项目中的Kotlin（例如，*Ctrl*/*Cmd* + *Shift* + *A*和配置项目中的Kotlin）。
- en: 2\. Convert all Java classes to Kotlin (for example, in `MainActivity` *Ctrl/Cmd+Shift+A*
    and Convert Java file to Kotlin file ).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 将所有Java类转换为Kotlin（例如，在`MainActivity`中*Ctrl/Cmd+Shift+A*和将Java文件转换为Kotlin文件）。
- en: 'After these steps, we will have a Kotlin Android application with an empty
    Activity created:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些步骤，我们将拥有一个使用空Activity创建的Kotlin Android应用：
- en: '![](img/Image00061.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00061.jpg)'
- en: Character gallery
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色画廊
- en: In this section, we will implement a single use case--after starting the application,
    the user can see a gallery of characters.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将实现一个单一用例——启动应用后，用户可以看到一个角色画廊。
- en: 'This is a pretty complex use case because it requires view to be presented,
    network connection with API and business rules implementation. Therefore, we will
    split it into the following tasks:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当复杂的用例，因为它需要呈现视图、与API进行网络连接和实现业务规则。因此，我们将把它分成以下任务：
- en: View implementation
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图实现
- en: Communication with API
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与API通信
- en: Business logic implementation of character display
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色显示的业务逻辑实现
- en: Putting it all together
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: Such tasks are much easier to implement. Let's implement them one after another.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的任务要容易实现得多。让我们依次实现它们。
- en: View implementation
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图实现
- en: Let's start with View implementation. Here, we are going to define what the
    list of characters will look like. For testing purposes, we are also going to
    define a few characters and display them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从视图实现开始。在这里，我们将定义角色列表的外观。为了测试目的，我们还将定义一些角色并显示它们。
- en: 'Let''s start with `MainActivity` layout implementation. We will use `RecyclerView`
    to show a list of elements. The `RecyclerView` layout is distributed in a separate
    dependency, which we have to add to the `app` module `build.gradle` file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`MainActivity`布局实现开始。我们将使用`RecyclerView`来显示一个元素列表。`RecyclerView`布局分布在一个单独的依赖项中，我们需要将其添加到`app`模块的`build.gradle`文件中：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `android_support_version` instance is a variable which is not yet defined.
    The reason behind it is that the version should be the same for all Android support
    libraries and when we extract this version number as a separator variable then
    it is easier to manage. This is why we should replace the hard coded version for
    each of the Android support libraries with a reference to `android_support_version`
    :'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`android_support_version`实例是一个尚未定义的变量。其背后的原因是所有Android支持库的版本应该是相同的，当我们将这个版本号提取为一个分隔变量时，就更容易管理了。这就是为什么我们应该用对`android_support_version`的引用来替换每个Android支持库的硬编码版本：'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And we have to set support library version value. Good practice is to define
    it in the project `build*.* gradle` file inside `buildscript` , after the `kotlin*_*
    version` definition:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 并且我们需要设置支持库版本值。良好的做法是在项目的`build*.*gradle`文件中的`buildscript`部分定义它，在`kotlin*_*version`定义之后：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can start implementation of `MainActivity` layout. This is the effect
    that we want to achieve:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始实现`MainActivity`布局。这是我们想要实现的效果：
- en: '![](img/Image00062.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00062.jpg)'
- en: 'We will keep character elements on `RecyclerView` packed into `SwipeRefreshLayout`
    to allow swipe-refresh. Also, to fulfill Marvel copyright, there needs to be a
    presented label that is informing that data is provided by Marvel. The layout
    `activity_main` (`res/layout/activity_main.xml` ) should be replaced with following
    definition:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把角色元素放入`RecyclerView`中，打包到`SwipeRefreshLayout`中以允许滑动刷新。此外，为了满足Marvel的版权要求，需要有一个呈现的标签，告知数据是由Marvel提供的。布局`activity_main`（`res/layout/activity_main.xml`）应该被替换为以下定义：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We need to add a copyright notice to strings (`res/values/strings.xml` ):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在字符串（`res/values/strings.xml`）中添加版权声明：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is a preview:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个预览：
- en: '![](img/Image00063.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00063.jpg)'
- en: 'The next step is to define the item view. We would like each element to be
    always square. To do this, we need to define a view which will preserve the square
    shape (place it in `view/views` ):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义项目视图。我们希望每个元素都是正方形的。为了做到这一点，我们需要定义一个可以保持正方形形状的视图（将其放在`view/views`中）：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using `JvmOverloads` annotation, we've avoided telescoping constructors that
    are normally used to define a custom view in Android. This was described in [Chapter
    4](text00088.html) , *Classes and Objects* .
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`JvmOverloads`注解，我们避免了通常用于在Android中定义自定义视图的望远镜构造函数。这在[第4章](text00088.html)中有描述，*类和对象*。
- en: We are forcing the element to have always the same height as width.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们强制元素始终具有与宽度相同的高度。
- en: 'With `SquareFrameLayout` , we can define the layout of gallery items. This
    is what we want it to look like:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SquareFrameLayout`，我们可以定义画廊项目的布局。这就是我们想要的样子：
- en: '![](img/Image00064.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00064.jpg)'
- en: 'We need to define `ImageView` to display the character image, and `TextView`
    to display its name. While `SquareFrameLayout` is actually `FrameLayout` that
    has fixed height, its children elements (image and text) are by default placed
    one above another. Let''s add layout into `item_character.xml` file in `res/layout`
    :'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义`ImageView`来显示角色图像，以及`TextView`来显示其名称。虽然`SquareFrameLayout`实际上是具有固定高度的`FrameLayout`，但它的子元素（图像和文本）默认情况下是一个在另一个上面。让我们将布局添加到`res/layout`文件夹中的`item_character.xml`文件中：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that we are also using values such as `element_padding` defined in `dimens`
    . Let''s add them to the `dimen.xml` file in `res/values` :'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还在`dimens`中定义的`element_padding`等值。让我们将它们添加到`res/values`文件夹中的`dimen.xml`文件中：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we can see, each element needs to display the name of the character and
    its image. Therefore, the model of a character needs to contain these two properties.
    Let''s define a simple model for a character:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，每个元素都需要显示角色的名称和图像。因此，角色的模型需要包含这两个属性。让我们为角色定义一个简单的模型：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To display a list of elements using `RecyclerView` , we need to implement both
    a `RecyclerView` list and an item adapter. A list adapter is used to manage all
    elements in a list, while an item adapter is an adapter for a single item type.
    Here, we need only one item adapter, because we display a single type of items.
    It is, however, good practice to assume that in future there might be other kind
    of elements on this list, for example, comics or ads. The same with the list adapter--we
    need only one in this example, but in most projects there is more than a single
    list and it is better to extract common behavior into a single abstract class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`RecyclerView`显示元素列表，我们需要实现`RecyclerView`列表和一个项目适配器。列表适配器用于管理列表中的所有元素，而项目适配器是单个项目类型的适配器。在这里，我们只需要一个项目适配器，因为我们显示单一类型的项目。然而，最好假设在将来可能会有其他类型的元素在这个列表上，例如漫画或广告。列表适配器也是一样--在这个例子中我们只需要一个，但在大多数项目中不止一个列表，最好将通用行为提取到一个单独的抽象类中。
- en: 'While this example is designed to present how Kotlin can be used in larger
    projects, we will define an abstract list adapter, which we will name `RecyclerListAdapter`
    , and an abstract item adapter, which we will name `ItemAdapter` . Here is the
    `ItemAdapter` definition:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子旨在展示Kotlin如何在更大的项目中使用，我们将定义一个抽象列表适配器，我们将其命名为`RecyclerListAdapter`，以及一个抽象项目适配器，我们将其命名为`ItemAdapter`。这是`ItemAdapter`的定义：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We need to pass a holder as a type parameter to allow direct operations on its
    fields. The holder is created in `onCreateViewHolder` so we know that its type
    will be always type parameter `T` . Therefore, we can cast the holder to `T` on
    `bindViewHolder` and use it as a receiver object for `onBindViewHolder` . Suppression
    `@Suppress("UNCHECKED_CAST")` is here just to hide the warning while we know that
    we can securely cast in this situation.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将持有者作为类型参数传递，以允许直接对其字段进行操作。持有者是在`onCreateViewHolder`中创建的，因此我们知道它的类型将始终是类型参数`T`。因此，我们可以在`bindViewHolder`上将持有者转换为`T`并将其用作`onBindViewHolder`的接收器对象。`@Suppress("UNCHECKED_CAST")`的抑制只是为了在我们知道可以在这种情况下安全转换时隐藏警告。
- en: Function used to create view holder. In most cases, it will be a single expression
    function that is just calling a constructor.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于创建视图持有者的函数。在大多数情况下，它将是一个只调用构造函数的单表达式函数。
- en: In the `onBin+dViewHolder` function, we will set all values on item view.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onBindViewHolder`函数中，我们将设置item视图上的所有值。
- en: 'Here is the definition of `RecyclerListAdapter` :'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`RecyclerListAdapter`的定义：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Class is `open` instead of `abstract` because it can be initialized and used
    without any children. We define children to allow us to define custom methods
    for different lists.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类是`open`而不是`abstract`，因为它可以被初始化和使用而不需要任何子类。我们定义子类是为了允许我们为不同的列表定义自定义方法。
- en: We keep items in list.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将项目保存在列表中。
- en: We will use layout to distinguish item type. Because of it, we cannot use two
    item adapters with the same layout on the same list, but this solution is simplifying
    a lot.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用布局来区分项目类型。因此，我们不能在同一个列表上使用具有相同布局的两个项目适配器，但这个解决方案简化了很多事情。
- en: Methods are overriding methods of `RecyclerView.Adapter` , but they also use
    `final` modifier to restrict their override in children. All list adapters that
    are extending `RecyclerListAdapter` should operate on items.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法是`RecyclerView.Adapter`的重写方法，但它们还使用`final`修饰符来限制它们在子类中的重写。所有扩展`RecyclerListAdapter`的列表适配器都应该操作项目。
- en: We define type alias to simplify the definition of any `ItemAdapter` .
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义类型别名来简化任何`ItemAdapter`的定义。
- en: 'Using the preceding definitions, we can define `MainListAdapter` (adapter for
    character list) and `CharacterItemAdapter` (adapter for item on list). Here is
    the definition of `MainListAdapter` :'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述定义，我们可以定义`MainListAdapter`（角色列表的适配器）和`CharacterItemAdapter`（列表上项目的适配器）。这是`MainListAdapter`的定义：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this project, we do not need any special methods defined in `MainListAdapter`
    , but to show how easy it is to define them, here is presented `MainListAdapter`
    with additional methods to add and delete:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们不需要在`MainListAdapter`中定义任何特殊方法，但是为了展示定义它们有多容易，这里呈现了具有额外添加和删除方法的`MainListAdapter`：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the definition of `CharacterItemAdapter` :'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`CharacterItemAdapter`的定义：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`MarvelCharacter` is passed by constructor.'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MarvelCharacter`通过构造函数传递。'
- en: '`onBindViewHolder` method is used set up views. It was defined as an abstract
    member extension function in `ItemAdapter` and, thanks to that, now we can use
    `textView` and `imageView` explicitly inside its body.'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onBindViewHolder`方法用于设置视图。它被定义为`ItemAdapter`中的抽象成员扩展函数，由于这样，现在我们可以在其主体内明确使用`textView`和`imageView`。'
- en: Function `loadImage` is not defined yet. We will define it as an extension function
    a bit later.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loadImage`函数尚未定义。我们稍后将其定义为扩展函数。'
- en: In view holder, we are binding properties to view elements using the `bindView`
    function that will soon be defined.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图持有者中，我们使用`bindView`函数将属性绑定到视图元素，该函数很快将被定义。
- en: 'Inside, we use the functions `loadImage` and `bindView` which are not yet defined.
    `bindView` is a top-level extension function to `RecyclerView.ViewHolder` , which
    is providing a lazy delegate that is providing a view found by its ID:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，我们使用尚未定义的函数`loadImage`和`bindView`。`bindView`是一个顶级扩展函数，用于`RecyclerView.ViewHolder`，它提供了一个懒惰的委托，该委托通过其ID找到视图：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also need to define the `loadImage` extension function that will help us
    to download an image from the URL and place it into `ImageView` . Two typical
    libraries used to such purpose are **Picasso** and **Glide** . We will use Glide,
    and to do it, we need to add a dependency in `build.gradle` :'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义`loadImage`扩展函数，它将帮助我们从URL下载图像并将其放入`ImageView`中。用于此目的的两个典型库是**Picasso**和**Glide**。我们将使用Glide，并且为此，我们需要在`build.gradle`中添加依赖项：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Specify the version in project `build.gradle` :'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目`build.gradle`中指定版本：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add permission to use the internet in `AndroidManifest` :'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AndroidManifest`中添加使用互联网的权限：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And we can finally define the `loadImage` extension function for the `ImaveView`
    class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以为`ImaveView`类定义`loadImage`扩展函数：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is time to define the activity that will display this list. We will use
    one more element, the **Kotlin Android extensions** plugin. It is used to simplify
    access to view elements from code. Its usage is simple--we add the `kotlin-android-extensions`
    plugin in module `build.gradle` :'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候定义将显示此列表的活动了。我们将使用另一个元素，**Kotlin Android扩展**插件。它用于简化从代码访问视图元素。它的使用很简单 - 我们在模块`build.gradle`中添加`kotlin-android-extensions`插件：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we can import a reference to this view inside `Activity` :'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在`Activity`中导入对此视图的引用：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And we can access `View` elements directly using its name without using the
    `findViewById` method or define annotations:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接使用其名称访问`View`元素，而无需使用`findViewById`方法或定义注释：
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will use Kotlin Android extensions in all activities in the project. Now
    let''s define `MainActivity` to display a list of characters with images:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在项目中的所有活动中使用Kotlin Android扩展。现在让我们定义`MainActivity`以显示带有图像的角色列表：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here we define a temporary list of characters to display.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个临时的角色列表以显示。
- en: We use this window feature because we don't want to display a title.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用此窗口功能，因为我们不想显示标题。
- en: We use `GridLayoutManager` as `RecyclerView` layout manager to achieve a grid
    effect.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`GridLayoutManager`作为`RecyclerView`布局管理器以实现网格效果。
- en: We are creating item adapters from characters using the `CharacterItemAdapter`
    constructor reference.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用`CharacterItemAdapter`构造函数引用从字符创建项目适配器。
- en: 'Now we can compile the project and we will see the following screen:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编译项目，然后我们会看到以下屏幕：
- en: '![](img/Image00065.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00065.jpg)'
- en: Network definition
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络定义
- en: 'Until now, the presented data was hard coded inside the application, but we
    want to use data from the Marvel API instead. To do it, we need to define some
    network mechanisms that will retrieve the data from the server. We are going to
    use **Retrofit** , a popular Android library used to simplify network operations,
    together with RxJava, a popular library used for reactive programming. For both
    libraries, we will use only basic functionalities to make their usage as simple
    as possible. To use them, we need to add following dependencies in the module
    `build.gradle` :'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所呈现的数据是在应用程序内部硬编码的，但我们希望改为使用Marvel API的数据。为此，我们需要定义一些网络机制，以从服务器检索数据。我们将使用**Retrofit**，这是一个流行的Android库，用于简化网络操作，以及RxJava，这是一个用于响应式编程的流行库。对于这两个库，我们将仅使用基本功能，以使其使用尽可能简单。要使用它们，我们需要在模块`build.gradle`中添加以下依赖项：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And version definitions in project `build.gradle` :'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目`build.gradle`中定义版本定义：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We already have internet permission defined on `AndroidManifest` , so we don''t
    need to add it. A simple `Retrofit` definition might look like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`AndroidManifest`中定义了互联网权限，因此不需要添加它。简单的`Retrofit`定义可能如下所示：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can keep `retrofit` instance as lazy top-level property.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将`retrofit`实例保留为惰性顶级属性。
- en: Here we define the `baseUrl`
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里我们定义`baseUrl`
- en: 'But there are some additional requirements on Retrofit that need to be matched.
    We need to add converters to use Retrofit together with RxJava, and to send objects
    serialized as JSON. We also need interceptors that will be used to provide headers
    and extra queries needed by Marvel API. This is a small application, so we can
    define all required elements as top-level functions. The full Retrofit definition
    will be the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 但是Retrofit还有一些额外的要求需要满足。我们需要添加转换器以将Retrofit与RxJava一起使用，并将对象序列化为JSON进行发送。我们还需要拦截器，这些拦截器将用于提供Marvel
    API所需的标头和额外查询。这是一个小应用程序，因此我们可以将所有所需的元素定义为顶级函数。完整的Retrofit定义将如下所示：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Add a converter that allows object JSON serialization and deserialization using
    GSON library.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个允许使用GSON库对对象JSON进行序列化和反序列化的转换器。
- en: Add a converter that will allow RxJava2 types (Observable, Single) as observables
    for returned values from network requests.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个转换器，它将允许RxJava2类型（Observable，Single）作为网络请求返回值的可观察对象。
- en: We add custom interceptors. We need to define all of them.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加自定义拦截器。我们需要定义它们所有。
- en: 'Let''s define the needed interceptors. `makeHeadersInterceptor` is used to
    add standard headers for each request:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义所需的拦截器。`makeHeadersInterceptor`用于为每个请求添加标准标头：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Interceptor is SAM, so we can define it using a SAM constructor.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拦截器是SAM，因此我们可以使用SAM构造函数来定义它。
- en: 'The `makeLoggingInterceptor` function is used to display logs on console when
    we are running the application in debug mode:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeLoggingInterceptor`函数用于在调试模式下运行应用程序时在控制台上显示日志：'
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `makeAddRequiredQueryInterceptor` function is more complex, because it
    is used to provide query parameters used by Marvel API to verify the user. These
    parameters need a hash calculated using the MD5 algorithm. It also needs a public
    and private key from the Marvel API. Everyone can generate their own keys at [https://developer.marvel.com/](https://developer.marvel.com/)
    . Once you have generated keys, we need to place them in the `gradle.properties`
    file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeAddRequiredQueryInterceptor`函数更复杂，因为它用于提供Marvel API用于验证用户的查询参数。这些参数需要使用MD5算法计算的哈希。它还需要来自Marvel
    API的公钥和私钥。每个人都可以在[https://developer.marvel.com/](https://developer.marvel.com/)生成自己的密钥。生成密钥后，我们需要将它们放在`gradle.properties`文件中：'
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Also add the following definitions in the module `build.gradle` in Android
    in the `defaultConfig` section:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 还在Android的`defaultConfig`部分的模块`build.gradle`中添加以下定义：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After project rebuild, you will be able to access these values by `BuildConfig.PUBLIC_KEY`
    and `BuildConfig.PRIVATE_KEY` . Using these keys, we can generate query parameters
    that are required by Marvel API:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 项目重建后，您将能够通过`BuildConfig.PUBLIC_KEY`和`BuildConfig.PRIVATE_KEY`访问这些值。使用这些密钥，我们可以生成Marvel
    API所需的查询参数：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We need to provide three additional queries:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要提供三个额外的查询：
- en: '`apikey` : Which is just including our public key.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apikey`：只包括我们的公钥。'
- en: '`ts` : Which is just containing device time in milliseconds. It is used to
    improve the security of the hash provided in the next query.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ts`：只包含设备时间的毫秒数。它用于提高下一个查询中提供的哈希的安全性。'
- en: '`hash` : Which is calculated as MD5 hash from time stamp, private, and public
    key, one after another in a single `String` .'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hash`：这是从时间戳、私钥和公钥依次计算MD5哈希的`String`。'
- en: 'Here is the definition of the function used to calculate the MD5 hash:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于计算MD5哈希的函数的定义：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are using the times extension operator to fill the hash with zeros if it
    is shorter than 32.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在使用times扩展运算符来填充哈希，如果它比32短。
- en: 'We have interceptors defined, so we can define actual API methods. The Marvel
    API contains a lot of data models that are representing characters, lists, and
    so on. We need to define them as separate classes. Such classes are called **data
    transfer objects** (**DTOs** ). We will define objects we will need:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了拦截器，因此我们可以定义实际的API方法。Marvel API包含许多表示字符、列表等的数据模型。我们需要将它们定义为单独的类。这样的类称为**数据传输对象**（**DTOs**）。我们将定义我们需要的对象：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For values that might not be provided, we should set a default value. Values
    that are mandatory might be prefixed with `lateinit` instead.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于可能未提供的值，我们应该设置默认值。必须提供的值可能会用`lateinit`前缀。
- en: 'Retrofit is using reflection to create an HTTP request basing of interface
    definition. This is how we can implement an interface that is defining an HTTP
    request:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Retrofit使用反射来创建基于接口定义的HTTP请求。这是我们如何实现定义HTTP请求的接口：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With such definitions, we can finally get a list of characters:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样的定义，我们最终可以得到一个字符列表：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We use a `retrofit` instance to create an object that will make HTTP requests
    according to the `MarvelApi` interface definition.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`retrofit`实例来创建一个对象，根据`MarvelApi`接口定义进行HTTP请求。
- en: We create observable ready to send call to API.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个准备发送到API的可观察对象。
- en: By `subscribe` , we send an HTTP request and we start listening for a response.
    The first argument is the callback that is invoked when we successfully receive
    a response.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`subscribe`，我们发送一个HTTP请求并开始监听响应。第一个参数是在成功接收响应时调用的回调函数。
- en: 'Such a network definition could be sufficient, but we might implement it better.
    The biggest problem is that we now need to operate on DTO objects instead of on
    our own data model objects. For mapping, we should define an additional layer.
    The repository pattern is used for this purpose. This pattern is also really helpful
    when we are implementing unit tests, because we can mock the repository instead
    of the whole API definition. This is the definition of repository that we would
    like to have:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的网络定义可能已经足够了，但我们可能会实现得更好。最大的问题是我们现在需要操作DTO对象，而不是我们自己的数据模型对象。对于映射，我们应该定义一个额外的层。存储库模式用于此目的。当我们实现单元测试时，这种模式也非常有帮助，因为我们可以模拟存储库而不是整个API定义。这是我们想要的存储库定义：
- en: '[PRE38]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We are getting a list of DTO elements and mapping it into `MarvelCharacter`
    using a constructor reference.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在获取DTO元素的列表，并使用构造函数引用将其映射到`MarvelCharacter`。
- en: 'To make it work, we need to define an additional constructor in `MarvelCharacter`
    , that takes `CharacterMarvelDto` as an argument:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为使其工作，我们需要在`MarvelCharacter`中定义一个额外的构造函数，以`CharacterMarvelDto`作为参数：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There are different ways to provide an instance of `MarvelRepository` . In
    most common implementation, a concrete instance of `MarvelRepository` is passed
    to `Presenter` as constructor argument. But what about UI testing (such as Espresso
    tests)? We don''t want to test the Marvel API and we don''t want to make a UI
    test depending on it. The solution is to make a mechanism that will generate standard
    implementation during normal runtime, but it will also allow us to set a different
    implementation for testing purposes. We will make the following generic implementation
    of such mechanism (place it in data):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 提供`MarvelRepository`实例的不同方法。在最常见的实现中，具体的`MarvelRepository`实例作为构造函数参数传递给`Presenter`。但是对于UI测试（如Espresso测试）呢？我们不想测试Marvel
    API，也不想使UI测试依赖于它。解决方案是制作一个机制，在正常运行时生成标准实现，但也允许我们为测试目的设置不同的实现。我们将制作以下通用机制的实现（将其放在数据中）：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Instead of defining our own `Provider` , we might use some of Dependency Injection
    libraries, such as **Dagger** or **Kodein** . Dagger usage for such purposes is
    really common in Android development, but we've decided that we won't include
    it in this example to avoid additional complexity for developers who are not experienced
    with this library.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些依赖注入库，如**Dagger**或**Kodein**，而不是定义自己的`Provider`。在Android开发中，Dagger用于此类目的非常普遍，但我们决定不在此示例中包含它，以避免给不熟悉该库的开发人员增加额外的复杂性。
- en: 'We can make the `MarvelRepository` companion object provider extend above class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使`MarvelRepository`的伴生对象提供者扩展上述类：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Thanks to the preceding definition, we can use the `MarvelRepository` companion
    object to get an instance of `MarvelRepository` :'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的定义，我们可以使用`MarvelRepository`的伴生对象来获取`MarvelRepository`的实例：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It will be a lazy instance of MarvelRepositoryImpl, until somebody sets some
    not-null value of the `testingInstance` property:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 它将是MarvelRepositoryImpl的延迟实例，直到有人设置`testingInstance`属性的非空值为止：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Such a construction is useful to allow UI tests using espresso. Its usage for
    element override is present in the project and can be found in GitHub. It is not
    presented in this section to keep it simpler to understand for developers who
    are not proficient in testing. If you are willing to see it, then you can find
    it at [https://github.com/MarcinMoskala/MarvelGallery/blob/master/app/src/androidTest/java/com/sample/marvelgallery/MainActivityTest.kt](https://github.com/MarcinMoskala/MarvelGallery/blob/master/app/src/androidTest/java/com/sample/marvelgallery/MainActivityTest.kt)
    .
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的构造对使用Espresso进行UI测试非常有用。它在项目中用于元素覆盖，并且可以在GitHub上找到。为了让不熟悉测试的开发人员更容易理解，本节中没有介绍它。如果你想看到它，可以在[https://github.com/MarcinMoskala/MarvelGallery/blob/master/app/src/androidTest/java/com/sample/marvelgallery/MainActivityTest.kt](https://github.com/MarcinMoskala/MarvelGallery/blob/master/app/src/androidTest/java/com/sample/marvelgallery/MainActivityTest.kt)找到。
- en: Let's finally connect this repository with view by implementation of the business
    logic of the character gallery display.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后让我们通过实现角色画廊显示的业务逻辑来将这个存储库与视图连接起来。
- en: Business logic implementation
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务逻辑实现
- en: 'We have both view and repository parts implemented and it is time to finally
    implement the business logic. On this point, we need only to get the character
    list and display it on the list when the user enters the screen or when they refresh
    it. We will extract these business logic rules from view implementation by using
    an architectural pattern known as **Model-View-Presenter** (**MVP** ). Here are
    the simplified rules:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了视图和存储库部分，现在是时候最终实现业务逻辑了。在这一点上，我们只需要获取角色列表并在用户进入屏幕或刷新时显示它。我们将使用一种称为**Model-View-Presenter**（**MVP**）的架构模式从视图实现中提取这些业务逻辑规则。以下是简化的规则：
- en: '**Model** : This is the layer responsible for managing data. Model''s responsibilities
    include using APIs, caching data, managing databases, and so on.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Model**：这是负责管理数据的层。模型的责任包括使用API、缓存数据、管理数据库等。'
- en: '**Presenter** : The presenter is the middle-man between Model and View, and
    it should include all your presentation logic. The presenter is responsible for
    reacting to user interactions, using and updating the Model and the View.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Presenter**：Presenter是模型和视图之间的中间人，它应该包含所有的演示逻辑。Presenter负责对用户交互做出反应，使用和更新模型和视图。'
- en: '**View** : This is responsible for presenting data and forwarding user interaction
    events to the Presenter.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**View**：这负责呈现数据并将用户交互事件转发给Presenter。'
- en: In our implementation of this pattern, we will treat Activity as a View, and
    for each view we need to create a presenter. It is good practice to write unit
    tests to check whether business logic rules are implemented correctly. To make
    it simple, we need to hide Activity behind an easy-to-mock interface that is representing
    all possible Presenter interaction with view (Activity). Also, we are going to
    create all the dependencies (such as `MarvelRepository` ) in Activity and deliver
    them to the Presenter via the constructor as objects hidden behind interfaces
    (for example, pass `MarvelRepositoryImpl` as `MarvelRepository` ).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现这种模式时，我们将Activity视为视图，并且对于每个视图，我们需要创建一个Presenter。编写单元测试来检查业务逻辑规则是否正确实现是一个好的实践。为了简化，我们需要将Activity隐藏在一个易于模拟的接口后面，该接口代表了Presenter与视图（Activity）的所有可能的交互。此外，我们将在Activity中创建所有依赖项（例如`MarvelRepository`），并通过构造函数将它们作为隐藏在接口后面的对象（例如，将`MarvelRepositoryImpl`作为`MarvelRepository`）传递给Presenter。
- en: 'In Presenter, we need to implement the following behaviors:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Presenter中，我们需要实现以下行为：
- en: When the Presenter is waiting for a response, loading animation is displayed
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Presenter等待响应时，显示加载动画
- en: After the View has been created, a list of characters is loaded and displayed
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图创建后，加载并显示角色列表
- en: After the refresh method is called, a list of characters is loaded
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用刷新方法后，加载角色列表
- en: When the API returns a list of characters, it is displayed on the view
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当API返回角色列表时，它会显示在视图上
- en: When the API returns an error, it is displayed on the view
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当API返回错误时，它会显示在视图上
- en: 'As we can see, the Presenter needs to get by constructor both View and `MarvelRepository`
    , and it should specify the methods that will be called when the view is created
    or the user request list is refreshed:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Presenter需要通过构造函数获取View和`MarvelRepository`，并且应该指定在视图创建或用户请求列表刷新时将调用的方法：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The View needs to specify the methods used to show the list of characters,
    show error and show progress bar when View is refreshing (define it in `view/main`
    and move `MainActivity` to `view/main` ):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 视图需要指定用于显示角色列表、显示错误和在视图刷新时显示进度条的方法（在`view/main`中定义，并将`MainActivity`移动到`view/main`）：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Before adding logic to a presenter, let''s define first two unit tests:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在向Presenter添加逻辑之前，让我们先定义两个单元测试：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Descriptive names are allowed in Kotlin unit tests, but there will be a warning
    displayed. This suppression is needed to hide this warning.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin单元测试允许使用描述性名称，但会显示警告。需要抑制此警告。
- en: Define a list of example characters to display.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个要显示的示例角色列表。
- en: Define a view and repository and create a presenter using them.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个视图和存储库，并使用它们创建一个Presenter。
- en: When a list of elements is shown, then we should set it as a displayed list.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当显示元素列表时，我们应该将其设置为显示的列表。
- en: The test is failing when `showError` is called.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用`showError`时，测试失败。
- en: The `getAllCharacters` method is just returning an example list.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getAllCharacters` 方法只是返回一个示例列表。'
- en: We call a defined action on the presenter.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Presenter上调用一个定义好的动作。
- en: We check whether the list returned by the repository is the same as the displayed
    list.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查存储库返回的列表是否与显示的列表相同。
- en: 'To simplify the preceding definitions, we could extract `BaseMarvelRepository`
    and `BaseMainView` , and keep example data in a separate class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化前面的定义，我们可以提取`BaseMarvelRepository`和`BaseMainView`，并将示例数据保存在一个单独的类中：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now we can simplify the definition of `PresenterActionAssertion` :'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以简化`PresenterActionAssertion`的定义：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We start the tests:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始测试：
- en: '![](img/Image00066.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00066.jpg)'
- en: 'We will see that they are not passing:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会发现它们没有通过：
- en: '![](img/Image00067.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00067.jpg)'
- en: 'The reason is that functionalities are not implemented yet in `MainPresenter`
    . The simplest code that is satisfactory to pass this unit test is the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`MainPresenter`中的功能尚未实现。满足这个单元测试的最简单的代码如下：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now our tests are passing:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试通过了：
- en: '![](img/Image00068.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00068.jpg)'
- en: 'But there are two issues with following implementation:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 但是以下实现存在两个问题：
- en: It won't work in Android, because `getAllCharacters` is using a network operation
    and it cannot run on the main thread as in this example
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android中不起作用，因为`getAllCharacters`正在使用网络操作，而不能像这个例子中一样在主线程上运行
- en: We will have a memory leak if the user left the application before loading had
    been finished
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户在加载完成之前离开应用程序，我们将会有内存泄漏
- en: 'To resolve the first issue, we need to specify on which threads what operations
    should run. The network request should be running on the I/O thread, and we should
    observe on the Android main thread (because we are changing the view in callback):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第一个问题，我们需要指定哪些操作应该在哪些线程上运行。网络请求应该在I/O线程上运行，我们应该在Android主线程上观察（因为我们在回调中改变了视图）：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We specify that the network request should be running in IO thread.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指定网络请求应该在IO线程中运行。
- en: We specify that callbacks should be started on the main thread.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指定回调应该在主线程上启动。
- en: 'While these are common schedulers to show, we can extract them in a top-level
    extension function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是常见的调度程序，但我们可以将它们提取到顶层扩展函数中：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Tests are not allowed to access the Android main thread. Therefore, our tests
    will not pass. Also, operations running on a new thread are not what we want in
    unit tests, because we would have problem assertions synchronization. To resolve
    these problems, we need override schedulers before unit tests to make everything
    run on the same thread (add it in `MainPresenterTest` class):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 测试不允许访问Android主线程。因此，我们的测试将无法通过。此外，在单元测试中运行在新线程上的操作并不是我们想要的，因为我们会有问题断言同步。为了解决这些问题，我们需要在单元测试之前覆盖调度程序，使一切都在同一个线程上运行（将其添加到`MainPresenterTest`类中）：
- en: '[PRE52]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now unit tests are passing again:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在单元测试再次通过了：
- en: '![](img/Image00069.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00069.jpg)'
- en: 'Another problem is memory leak if the user leaves the application before we
    get a server response. A common solution is to keep all subscriptions in composite,
    and dispose them all when the user is leaving the application:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，如果用户在我们收到服务器响应之前离开应用程序，会出现内存泄漏。一个常见的解决方案是将所有订阅保留在composite中，并在用户离开应用程序时将它们全部处理掉：
- en: '[PRE53]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In bigger applications, most presenters have some subscriptions. So the functionality
    of collecting subscriptions and disposing them when the user destroys the view
    can be treated as common behavior and extracted in `BasePresenter` . Also, to
    simplify the process, we can make a `BaseActivityWithPresenter` class that will
    hold the presenter behind the `Presenter` interface and call the `onViewDestroyed`
    method when the view is destroyed. Let''s define this mechanism in our application.
    Here is the definition of `Presenter` :'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大的应用程序中，大多数Presenter都有一些订阅。因此，收集订阅并在用户销毁视图时处理它们的功能可以被视为常见行为，并在`BasePresenter`中提取。此外，为了简化流程，我们可以创建一个`BaseActivityWithPresenter`类，它将在`Presenter`接口后面保存Presenter，并在视图被销毁时调用`onViewDestroyed`方法。让我们在我们的应用程序中定义这个机制。以下是`Presenter`的定义：
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here is the definition of `BasePresenter` :'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`BasePresenter`的定义：
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here is the definition of `BaseActivityWithPresenter` :'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`BaseActivityWithPresenter`的定义：
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To simplify how a new subscription is added to subscriptions, we can define
    a plus assign operator:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化将新订阅添加到订阅中的定义，我们可以定义一个加法分配运算符：
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And we can use both solutions to make `MainPresenter` secure:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这两种解决方案来使`MainPresenter`更安全：
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The first two `MainPresenter` behaviors have been implemented. It is time to
    move on to the next one--when the API returns an error, it is displayed on the
    view. We can add this requirement as a test in `MainPresenterTest` :'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个`MainPresenter`行为已经实现。现在是时候转向下一个--当API返回错误时，它会显示在视图上。我们可以将这个要求作为`MainPresenterTest`中的一个测试添加：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'A simple change that will make this test pass is error handler specification
    in the subscribe method in `MainPresenter` :'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个测试通过的一个简单的改变是在`MainPresenter`的订阅方法中指定错误处理程序：
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'While `subscribe` is Java method, we cannot use named argument convention.
    Such invocation is not really descriptive. This is why we are going to define
    in the `RxExt.kt` custom subscribe method named `subscribeBy` :'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`subscribe`是Java方法，我们不能使用命名参数约定。这种调用并不真正描述性。这就是为什么我们将在`RxExt.kt`中定义一个名为`subscribeBy`的自定义订阅方法：
- en: '[PRE61]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And we will use it instead of subscribe:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用它而不是订阅：
- en: '[PRE62]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`subscribeBy` in full version defined for different RxJava typed (such as Observable,
    Flowable, and so on) together with lots of other useful Kotlin extensions to RxJava
    can be found in **RxKotlin** library ([https://github.com/ReactiveX/RxKotlin](https://github.com/ReactiveX/RxKotlin)
    ).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeBy`的完整版本定义了不同的RxJava类型（如Observable、Flowable等），以及许多其他有用的Kotlin扩展到RxJava，可以在**RxKotlin**库中找到（[https://github.com/ReactiveX/RxKotlin](https://github.com/ReactiveX/RxKotlin)）。'
- en: 'To show and hide list loading, we will define additional listeners to events
    that are always occurring before and after processing:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示和隐藏列表加载，我们将定义额外的监听器来监听在处理之前和之后总是发生的事件：
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And tests are passing again:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 测试又通过了：
- en: '![](img/Image00070.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00070.jpg)'
- en: 'The `subscribe` method is becoming less and less readable, but we will resolve
    this problem together with another business rule, whose definition is the following--when
    the presenter is waiting for a response, refresh is displayed. Define its unit
    test in `MainPresenterTest` :'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe`方法变得越来越难以阅读，但我们将解决这个问题，还有另一个业务规则，其定义如下--当Presenter等待响应时，会显示刷新。在`MainPresenterTest`中定义其单元测试：'
- en: '[PRE64]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We expect refresh displayed during network request and when elements are shown,
    but not after processing finishes.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们期望在网络请求期间和显示元素时刷新显示，但在处理完成后不刷新。
- en: We expect refresh to be displayed during a network request and when elements
    are shown, but not after processing finishes.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望在网络请求期间和显示元素时刷新显示，但在处理完成后不刷新。
- en: 'In the presented version on RxJava2, assertions inside callbacks are not breaking
    the test but displaying an error on the execution report instead:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在RxJava2的这个版本中，回调内的断言不会破坏测试，而是在执行报告中显示错误：
- en: '![](img/Image00071.jpg)![](img/Image00072.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00071.jpg)![](img/Image00072.jpg)'
- en: Probably, in future versions, it will be possible to add a handler that is allowing
    to fail a test from inside a callback.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 可能在未来的版本中，将可以添加一个处理程序，允许从回调内部使测试失败。
- en: 'To show and hide list loading, we will define additional listeners to events
    that are always occurring before and after processing:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示和隐藏列表加载，我们将定义额外的监听器来监听在处理之前和之后总是发生的事件：
- en: '[PRE65]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'After these changes, all tests are passing again:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改之后，所有测试又通过了：
- en: '![](img/Image00073.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00073.jpg)'
- en: Now we have a fully functional presenter, network, and view. Time to connect
    it all and finish implementation of the first use case.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全功能的Presenter、网络和视图。是时候把它们全部连接起来，完成第一个用例的实现了。
- en: Putting it all together
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把它们放在一起
- en: 'We have `MainPresenter` ready to be used in the project. Now we need to use
    it in `MainActivity` :'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好在项目中使用`MainPresenter`。现在我们需要在`MainActivity`中使用它：
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Activity should extend `BaseActivityWithPresenter` and implement `MainView`
    .
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Activity应该扩展`BaseActivityWithPresenter`并实现`MainView`。
- en: '`bindToSwipeRefresh` and `toast` are not yet implemented.'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bindToSwipeRefresh`和`toast`还没有实现。'
- en: We make presenter lazily. The first argument is a reference to activity behind
    the `MainView` interface.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使Presenter懒惰。第一个参数是指向`MainView`接口后面的活动的引用。
- en: We need to pass events to the presenter using its methods.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用它的方法将事件传递给Presenter。
- en: 'In the preceding code, we used two functions that were already described in
    the book, `toast` , used to display toast on the screen, and `bindToSwipeRefresh`
    , used to bind property with visibility of swipe refresh:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了两个已在书中描述的函数，`toast`用于在屏幕上显示提示，`bindToSwipeRefresh`用于绑定滑动刷新的可见性属性：
- en: '[PRE67]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now our application should correctly show a list of characters:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序应该正确显示角色列表：
- en: '![](img/Image00074.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00074.jpg)'
- en: Our first use case has been implemented. We can move on to the next one.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个用例已经实现。我们可以继续下一个。
- en: Character search
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色搜索
- en: Another behavior we need to implement is character search. Here is the use case
    definition, after starting the application, the user can search for a character
    by its name.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的另一个行为是角色搜索。以下是用例定义，启动应用程序后，用户可以通过角色名称搜索角色。
- en: 'To add it, we are going to add `EditText` to the `activity_main` layout:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加它，我们将在`activity_main`布局中添加`EditText`：
- en: '[PRE68]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We need to add **Android Support Design** library dependency to allow `TextInputLayout`
    usage:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加**Android Support Design**库依赖，以允许使用`TextInputLayout`：
- en: '[PRE69]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'And string `search_hint` definition in `strings.xml` :'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在`strings.xml`中定义了`search_hint`字符串：
- en: '[PRE70]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Also, to keep the label that is informing about Marvel copyright when the keyboard
    is opened, we also need to `adjustResize` to `windowSoftInputMode` in `activity`
    definition in `AndroidManifest` :'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了在键盘打开时保持通知有关Marvel版权的标签，我们还需要在`AndroidManifest`中的`activity`定义中将`adjustResize`设置为`windowSoftInputMode`：
- en: '[PRE71]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We should see the following preview:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下预览：
- en: '![](img/Image00075.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00075.jpg)'
- en: 'Now we have a search field added in `MainActivity` :'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`MainActivity`中添加了一个搜索字段：
- en: '![](img/Image00076.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00076.jpg)'
- en: 'The behavior we are expecting is that whenever the user changes the text in
    the search field, a new list will be loaded. We need a new method in `MainPresenter`
    , that will be used to inform the presenter that the text was changed. We will
    call it `onSearchChanged` :'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望的行为是，每当用户更改搜索字段中的文本时，将加载新列表。我们需要在`MainPresenter`中添加一个新方法，用于通知Presenter文本已更改。我们将称之为`onSearchChanged`：
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We need to change the `MarvelRepository` definition to accept a search query
    as `getAllCharacters` parameter (remember to update also `BaseMarvelRepository`
    ):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改`MarvelRepository`的定义，以接受搜索查询作为`getAllCharacters`参数（记得也更新`BaseMarvelRepository`）：
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'As a result, we have to update the implementation:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须更新实现：
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We also update the network request definition:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新网络请求的定义：
- en: '[PRE75]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'And to allow code compilation, we need to provide `null` as a `getAllCharacters`
    argument in `MainPresenter` :'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许代码编译，我们需要在`MainPresenter`中提供`null`作为`getAllCharacters`参数：
- en: '[PRE76]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'And we need to update `BaseMarvelRepository` :'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新`BaseMarvelRepository`：
- en: '[PRE77]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now our network implementation is returning a list of characters that starts
    from a query, or a fill list if we don''t specify any query. Time to implement
    the presenter. Let''s define the following tests:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的网络实现返回一个从查询开始的角色列表，或者如果我们没有指定任何查询，则返回一个填充列表。是时候实现Presenter了。让我们定义以下测试：
- en: '[PRE78]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To make following test pass, we need to add search query as a parameter with
    default argument to the `loadCharacters` method of `MainPresenter` :'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使以下测试通过，我们需要将搜索查询作为`MainPresenter`的`loadCharacters`方法的参数添加默认参数：
- en: '[PRE79]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'But the tricky part is that the Marvel API does not allow only white spaces
    as an search query. There should be a `null` send instead. Therefore, if the user
    deletes the last character or if they try to search place only space in search
    field, then the application would crash. We should prevent such situations. Here
    is a test that is checking whether the presenter is changing a query with only
    white spaces into `null` :'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 但棘手的部分是Marvel API不允许将空格作为搜索查询。应该发送一个`null`。因此，如果用户删除最后一个字符，或者尝试在搜索字段中只放置空格，那么应用程序将崩溃。我们应该防止这种情况发生。这是一个测试，检查Presenter是否将只有空格的查询更改为`null`：
- en: '[PRE80]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now all tests are passing again:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的测试都通过了：
- en: '![](img/Image00077.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00077.jpg)'
- en: 'We still need to implement an `Activity` functionality that will call the presenter
    when text has changed. We will do it using the optional callback class defined
    in [Chapter 7](text00171.html) , *Extension Functions and Properties* :'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要实现一个`Activity`功能，当文本发生变化时将调用Presenter。我们将使用[第7章](text00171.html)中定义的可选回调类来实现：
- en: '[PRE81]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'And use it in the `onCreate` method of `MainActivity` :'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 并在`MainActivity`的`onCreate`方法中使用它：
- en: '[PRE82]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'That is all we need to define the functionality of the character search. Now
    we can build the application and use it to find our favorite character:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要定义角色搜索功能的全部内容。现在我们可以构建应用程序并使用它来查找我们喜欢的角色：
- en: '![](img/Image00078.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00078.jpg)'
- en: With a correctly working application, we can move on to the next use case.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 有了一个正确工作的应用程序，我们可以继续下一个用例。
- en: Character profile display
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色概要显示
- en: Searching through characters is not enough. To make the app functional, we should
    add a character description display. Here is the use case we've defined--when
    the user clicks on some character picture, there is a profile displayed. The character
    profile contains character name, photo, description, and its occurrences.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过角色搜索是不够的。为了使应用程序功能正常，我们应该添加角色描述显示。这是我们定义的用例--当用户点击某个角色图片时，会显示一个概要。角色概要包含角色名称、照片、描述和出现次数。
- en: 'To implement this use case, we need to create a new activity and layout that
    will define what this `Activity` looks like. To do it, create a new Activity called
    `CharacterProfileActivity` in the package `com.sample.marvelgallery.view.character`
    :'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个用例，我们需要创建一个新的活动和布局，来定义这个`Activity`的外观。为此，在`com.sample.marvelgallery.view.character`包中创建一个名为`CharacterProfileActivity`的新Activity：
- en: '![](img/Image00079.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00079.jpg)'
- en: 'We will start its implementation from changes in layout (in `activity_character_profile.xml`
    ). Here is the final result we would like to achieve:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从布局更改（在`activity_character_profile.xml`中）开始实现它。这是我们想要实现的最终结果：
- en: '![](img/Image00080.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00080.jpg)'
- en: 'The base element is `CoordinatorLayout` with `AppBar` and `CollapsingToolbarLayout`
    both used to achieve a collapsing effect known from material design:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 基本元素是`CoordinatorLayout`，其中`AppBar`和`CollapsingToolbarLayout`都用于实现材料设计中的折叠效果：
- en: '![](img/Image00081.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00081.jpg)'
- en: Collapsing effect step by step.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步实现折叠效果。
- en: 'We also need `TextView` for description and occurrences that will be filled
    with data in the next use case. Here is the full `activity_character_profile`
    layout definition:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要用于描述和出现次数的`TextView`，这些将在下一个用例中填充数据。这是完整的`activity_character_profile`布局定义：
- en: '[PRE83]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We also need to add following styles in `styles.xml` :'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`styles.xml`中添加以下样式：
- en: '[PRE84]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And we need to define `AppFullScreenTheme` as the theme for `CharacterProfileActivity`
    in `AndroidManifest` :'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`AndroidManifest`中将`AppFullScreenTheme`定义为`CharacterProfileActivity`的主题：
- en: '[PRE85]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Here is a preview of the defined layout:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是定义的布局的预览：
- en: '![](img/Image00082.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00082.jpg)'
- en: 'This view will be used to display data about the character, but first we need
    to open it from `MainActivity` . We need to set `onClickListener` in `CharacterItemAdapter`
    *,* that is calling `clicked` callback provided by constructor:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图将用于显示有关角色的数据，但首先我们需要从`MainActivity`中打开它。我们需要在`CharacterItemAdapter`中设置`onClickListener`，它调用构造函数提供的`clicked`回调：
- en: '[PRE86]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'And we need to update `MainActivity` :'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新`MainActivity`：
- en: '[PRE87]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In the preceding implementation, we are using a method from the `CharacterProfileActivity`
    companion object to start `CharacterProfileActivity` . We need to pass the `MarvelCharacter`
    object to this method. The most efficient way to pass a `MarvelCharacter` object
    is pass it as *parcelable* . To allow it, `MarvelCharacter` must implement the
    `Parcelable` interface. This is why a useful solution is to use some annotation
    processing library such as **Parceler** , **PaperParcel** , or **Smuggler** ,
    that generates the necessary elements. We will use solution from Kotlin Android
    extensions we already have in the project. During book publication, it was still
    experimental, so there needs to be added following definition in the `build.gradle`
    module:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的实现中，我们使用了`CharacterProfileActivity`伴生对象中的一个方法来启动`CharacterProfileActivity`。我们需要将`MarvelCharacter`对象传递给这个方法。传递`MarvelCharacter`对象的最有效方式是将其作为*parcelable*传递。为了允许这样做，`MarvelCharacter`必须实现`Parcelable`接口。这就是为什么一个有用的解决方案是使用一些注解处理库，如**Parceler**，**PaperParcel**或**Smuggler**，来生成必要的元素。我们将使用项目中已经存在的Kotlin
    Android扩展解决方案。在书籍出版时，它仍然是实验性的，因此需要在`build.gradle`模块中添加以下定义：
- en: '[PRE88]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'All we need to do it to add `Parcelize` annotation before class, and we need
    to make this class implement `Parcelable` . We will also add error suppression
    because to hide default Android warning:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在类之前添加`Parcelize`注解，并且需要使这个类实现`Parcelable`。我们还需要添加错误抑制，以隐藏默认的Android警告：
- en: '[PRE89]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now we can implement the `start` function and field `character` , that will
    get the argument value from Intent using the property delegate:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现`start`函数和`character`字段，它将使用属性委托从Intent中获取参数值：
- en: '[PRE90]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `extra` and `getIntent` extension functions were already presented in the
    book, but they are not implemented yet in the project. Also, `loadImage` will
    display an error because it needs to be changed.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`extra`和`getIntent`扩展函数已经在书中介绍过，但在项目中尚未实现。此外，`loadImage`将显示错误，因为它需要更改。'
- en: 'We need to update `loadImage` , and define `extra` and `getIntent` as top-level
    functions:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新`loadImage`，并将`extra`和`getIntent`定义为顶级函数：
- en: '[PRE91]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Instead of defining functions to start the Activity, we might use some library
    that is generating these methods. For example, we might use the `ActivityStarter`
    library. This is what `CharacterProfileActivity` would look like:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些库来生成这些方法，而不是定义启动Activity的函数。例如，我们可以使用`ActivityStarter`库。这就是`CharacterProfileActivity`将会是什么样子：
- en: '[PRE92]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We should start it of get its intent using static methods of the generated
    class `CharacterProfileActivityStarter` :'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该启动它或使用生成的类`CharacterProfileActivityStarter`的静态方法获取其Intent：
- en: '[PRE93]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'To allow it, we need the **kapt** plugin in the module `build.gradle` (used
    to support annotation processing in Kotlin):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许它，我们需要在模块`build.gradle`中使用**kapt**插件（用于支持Kotlin中的注解处理）：
- en: '[PRE94]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'And `ActivityStarter` dependencies in module `build.gradle` :'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在`build.gradle`模块中的`ActivityStarter`依赖项：
- en: '[PRE95]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'After these changes, when we click into character in `MainActivity` , then
    `CharacterProfileActivity` will be started:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些更改，当我们点击`MainActivity`中的角色时，`CharacterProfileActivity`将会启动：
- en: '![](img/Image00083.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00083.jpg)'
- en: 'We are displaying the name and showing the character photo. The next step is
    to display the description and list of occurrences. The necessary data can be
    found in the Marvel API and we only need to extend DTO models to get them. We
    need to add `ListWrapper` that is used to hold a list:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在显示名称并展示角色照片。下一步是显示描述和事件列表。所需的数据可以在Marvel API中找到，我们只需要扩展DTO模型来获取它们。我们需要添加`ListWrapper`来保存列表：
- en: '[PRE96]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We need to define `ComicDto` , which holds the data we need about occurrence:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义`ComicDto`，其中包含有关事件发生的数据：
- en: '[PRE97]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'And we need to update `CharacterMarvelDto` :'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更新`CharacterMarvelDto`：
- en: '[PRE98]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Data is now read from the API and kept in DTO objects, but to use them in the
    project, we also need to change the `MarvelCharacter` class definition, and add
    a new constructor:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从API中读取数据并保存在DTO对象中，但为了在项目中使用它们，我们还需要更改`MarvelCharacter`类的定义，并添加一个新的构造函数：
- en: '[PRE99]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now we can update `CharacterProfileActivity` to display the description and
    list of occurrences:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更新`CharacterProfileActivity`来显示描述和事件列表：
- en: '[PRE100]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The composition of the list of occurrences is quite a complex task, so we extract
    it to the function `makeOccurrencesText` . There, for each occurrence type (comic,
    series, and so on), we want to show introduction text and list only if there are
    some occurrences of this type. We also want to prefix each item with a bullet.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出现列表的组合是一个相当复杂的任务，因此我们将其提取到函数`makeOccurrencesText`中。在那里，对于每种出现类型（漫画、系列等），我们希望在有这种类型的出现时显示介绍文本和列表。我们还希望在每个项目前加上一个项目符号。
- en: '`makeOccurrencesText` is a single expression function that is using `addList`
    to append an initially empty string with the next lists that we want to display.'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`makeOccurrencesText`是一个单表达式函数，它使用`addList`来将初始空字符串附加上我们想要显示的下一个列表。'
- en: '`addList` is a member extension function. It is returning a string unchanged
    if the provided list is empty, or it is returning a string appended with introduction
    text and list of elements with bullets.'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addList`是一个成员扩展函数。如果提供的列表为空，则返回一个未更改的字符串，或者返回一个附加了介绍文本和带有项目列表的字符串。'
- en: This is the character that is used as a list bullet.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是用作列表项目符号的角色。
- en: 'We also need to define strings in `strings.xml` :'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`strings.xml`中定义字符串：
- en: '[PRE101]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Now we can see the whole character profile--character name, image, description,
    and lists of its occurrences in comics, series, events, and stories:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到整个角色资料--角色名称、图片、描述以及在漫画、系列、事件和故事中的出现列表：
- en: '![](img/Image00084.jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00084.jpg)'
- en: Summary
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The application is complete, but there are still lots of functionalities that
    can be added. In this application, we've seen some examples of how Kotlin can
    be used to simplify Android development. But there are still a lot of solutions
    to discover. Kotlin simplifies Android development at any level--from common operations
    such as listener set or view element reference, to high-level functionalities
    such as functional programming or collection processing.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已经完成，但仍然可以添加许多功能。在这个应用程序中，我们看到了Kotlin如何简化Android开发的一些示例。但仍然有很多解决方案等待发现。Kotlin简化了Android开发的任何层次--从常见操作，如监听器设置或视图元素引用，到高级功能，如函数式编程或集合处理。
- en: This book cannot say everything about Android development with Kotlin. It was
    designed to show enough to allow everyone to start their own adventure with baggage
    full of ideas and feature understanding. The next step is to open Android Studio,
    create your own project, and start having fun with Kotlin. The big adventure is
    in front of you.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书无法涵盖关于Kotlin的Android开发的所有内容。它旨在展示足够的内容，以便每个人都可以开始自己的冒险，拥有充满想法和功能理解的行囊。下一步是打开Android
    Studio，创建自己的项目，并开始享受Kotlin带来的乐趣。大冒险就在你面前。
