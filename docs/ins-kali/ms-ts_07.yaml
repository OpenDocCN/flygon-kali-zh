- en: Chapter 7. Modularization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 模块化
- en: Modularization is a popular technique used in modern programming languages that
    allows programs to be built from a series of smaller programs, or modules. Writing
    programs that use modules encourages programmers to write code that conforms to
    the design principle called "Separation of Concerns". In other words, each module
    focuses on doing one thing, and has a clearly defined interface. If we then consume
    this module by focusing on the interface, we can easily replace this interface
    with something else, without breaking our code. We will focus more on "Separation
    of Concerns" and other object-oriented design patterns in the next chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化是现代编程语言中常用的一种技术，它允许程序由一系列较小的程序或模块构建而成。编写使用模块的程序鼓励程序员编写符合称为“关注点分离”的设计原则的代码。换句话说，每个模块专注于做一件事，并且有一个明确定义的接口。如果我们通过关注接口来使用这个模块，我们可以很容易地用其他东西替换这个接口，而不会破坏我们的代码。我们将在下一章更多地关注“关注点分离”和其他面向对象的设计模式。
- en: JavaScript, in itself, does not have a concept of modules, but it is proposed
    for the upcoming ECMAScript 6 standard. Popular frameworks and libraries such
    as Node and Require have built module-loading capabilities into their frameworks.
    These frameworks, however, use slightly different syntax. Node uses the CommonJS
    syntax for module loading, whereas Require uses the **Asynchronous Module Loading**
    (**AMD**) syntax. The TypeScript compiler has an option to turn on module compilation,
    and then switch between these two syntax styles.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript本身并没有模块的概念，但它被提议用于即将到来的ECMAScript 6标准。流行的框架和库，如Node和Require，已经在它们的框架中构建了模块加载功能。然而，这些框架使用略有不同的语法。Node使用CommonJS语法进行模块加载，而Require使用**异步模块加载**（**AMD**）语法。TypeScript编译器有一个选项可以打开模块编译，然后在这两种语法风格之间切换。
- en: In this chapter, we will look at the syntax of both module styles, and how the
    TypeScript compiler implements them. We will take a look at how to use modules
    when writing code for both Node and Require. We will also have a cursory look
    at Backbone, and how to write an application using a Model, View and Controller.
    Each of these Backbone components will be built as loadable modules.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下两种模块风格的语法，以及TypeScript编译器如何实现它们。我们将看一下在编写Node和Require的代码时如何使用模块。我们还将简要介绍Backbone，以及如何使用Model、View和Controller编写应用程序。这些Backbone组件将被构建为可加载的模块。
- en: CommonJs
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CommonJs
- en: The most prevalent usage of the CommonJs syntax for writing modules is when
    writing server-side code. It has been argued that browser-based CommonJs syntax
    simply cannot be done without a lot of overhead, but there are some libraries
    out there such as Curl ([https://github.com/cujojs/curl](https://github.com/cujojs/curl))
    that allow this syntax. In this section, we will, however, focus on Node application
    development.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CommonJs语法编写模块的最普遍用法是编写服务器端代码。有人认为基于浏览器的CommonJs语法简直无法做到，但也有一些库，比如Curl（[https://github.com/cujojs/curl](https://github.com/cujojs/curl)）可以实现这种语法。然而，在本节中，我们将专注于Node应用程序开发。
- en: Setting up Node in Visual Studio
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Visual Studio中设置Node
- en: 'Using Node within Visual Studio has been made a breeze by the Node tools for
    Visual Studio plugin ([https://nodejstools.codeplex.com](https://nodejstools.codeplex.com)).
    This toolset has also been updated to use TypeScript as a default editor, bringing
    the full TypeScript development experience to Node. Once the extension has been
    installed, we can create a new blank Node application, as shown in the following
    screenshot:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中使用Node已经变得非常简单，这得益于Node工具的Visual Studio插件（[https://nodejstools.codeplex.com](https://nodejstools.codeplex.com)）。这个工具集也已经更新，使用TypeScript作为默认编辑器，为Node带来了完整的TypeScript开发体验。安装了扩展后，我们可以创建一个新的空白Node应用程序，如下面的截图所示：
- en: '![Setting up Node in Visual Studio](img/image_9665OS_07_01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![在Visual Studio中设置Node](img/image_9665OS_07_01.jpg)'
- en: Creating a blank Node application with the Node toolset
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node工具集创建空白Node应用程序
- en: This project template will create a `server.ts` TypeScript file, and include
    the `node.d.ts` declaration file automatically for us. If we compile and run this
    default implementation by simply hitting *F5*, the project template will automatically
    start up a new console to run our Node server, start the server instance, and
    open a browser to connect to this instance. If all goes well at this stage, your
    browser will simply say **Hello World**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目模板将自动为我们创建一个`server.ts` TypeScript文件，并自动包含`node.d.ts`声明文件。如果我们编译并运行这个默认实现，只需按下*F5*，项目模板将自动启动一个新的控制台来运行我们的Node服务器，启动服务器实例，并打开一个浏览器连接到这个实例。如果一切顺利，你的浏览器将简单地显示**Hello
    World**。
- en: 'Let''s take a look at the `server.ts` TypeScript file that is creating an instance
    of our Node server:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看创建我们的Node服务器实例的`server.ts` TypeScript文件：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line of this code snippet uses the CommonJs module syntax to tell
    our Node server that it must `import` the library named `'http'`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段的第一行使用CommonJs模块语法告诉我们的Node服务器必须`import`名为`'http'`的库。
- en: This line has two key parts. To explain these key parts, let's start at the
    right-hand side of the `=` sign and work our way towards the left. The `require`
    function takes a single parameter, and is used to tell the application that there
    is a library named `'http'` out there. The `require` function also tells the application
    that it needs this library to be made available to it, in order to continue functioning.
    As `require` is a key part of the syntax of modules in TypeScript, it has been
    given the keyword status and will be highlighted in blue, just like other keywords
    such as `var`, `string`, and `function`. If the application cannot find this `'http'`
    library, then Node will immediately throw an exception.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行有两个关键部分。为了解释这些关键部分，让我们从`=`号的右侧开始，然后向左工作。`require`函数接受一个参数，并用于告诉应用程序有一个名为`'http'`的库。`require`函数还告诉应用程序需要这个库才能继续正常运行。由于`require`是TypeScript模块语法的关键部分，它被赋予了关键字状态，并且将会像`var`、`string`和`function`等其他关键字一样以蓝色高亮显示。如果应用程序找不到`'http'`库，那么Node将立即抛出异常。
- en: The left-hand side of the `=` sign uses the `import` keyword, which is also
    a fundamental concept in module syntax. The `import` statement tells the application
    to attach the library that has been loaded via the `require` function, `require('http')`,
    into a namespace called `_http`. Whatever functions or objects that the `'http'`
    library has made public will be available to the program via the `_http` namespace.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`=`号的左侧使用了`import`关键字，这也是模块语法中的一个基本概念。`import`语句告诉应用程序将通过`require`函数加载的库`require(''http'')`附加到名为`_http`的命名空间中。`''http''`库公开的任何函数或对象都将通过`_http`命名空间对程序可用。'
- en: If we jump to the third line very quickly, we can see that we invoke a function
    called `createServer` that is defined in the `'http'` module, and call it via
    the `_http` namespace. hence `_http.createServer()`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们快速跳到第三行，我们会看到我们调用了`'http'`模块中定义的`createServer`函数，并通过`_http`命名空间调用它，因此是`_http.createServer()`。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The default `server.ts` file that is generated by the blank Node project template
    is very slightly different than our preceding code sample. It names the import
    `http`, which matches the library name `''http'',` as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由空白Node项目模板生成的默认`server.ts`文件与我们前面的代码示例略有不同。它将导入命名为`http`，与库名`'http'`匹配，如下所示：
- en: '`import http = require(''http'');`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`import http = require(''http'');`'
- en: This is a common naming standard for Node. You can, of course, name your import
    namespaces whatever you like, but it does help to have the namespace match the
    imported library's name, to help with the readability of the code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Node的一个常见命名标准。当然，您可以将导入的命名空间命名为任何您喜欢的名称，但是将命名空间与导入的库的名称匹配会有助于提高代码的可读性。
- en: The second line of our code snippet simply sets up the variable named `port`
    to either be the value of the global variable `process.env.port`, or a default
    value of `1337`. This port number is used on the very last line, and uses fluent
    syntax to call the `listen` function on the returned value of the `http.createServer`
    function.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码片段的第二行只是将名为`port`的变量设置为全局变量`process.env.port`的值，或者默认值`1337`。这个端口号在最后一行使用，使用流畅的语法在`http.createServer`函数的返回值上调用`listen`函数。
- en: Our `createServer` function has two variables named `req` and `res`. If we use
    our mouse to hover over the `req` variable, we can see that it is of type `_http.ServerRequest`.
    Similarly, the `res` variable is of type `_http.ServerResponse`. These two variables
    are our HTTP request and response streams. In the body of the code, we are invoking
    the `writeHead` function on the HTTP response to set the content-type, and then
    we are invoking the `end` function on the HTTP response to write the text `'Hello
    World\n'` to the browser.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`createServer`函数有两个名为`req`和`res`的变量。如果我们将鼠标悬停在`req`变量上，我们会看到它的类型是`_http.ServerRequest`。同样，`res`变量的类型是`_http.ServerResponse`。这两个变量是我们的HTTP请求和响应流。在代码体中，我们在HTTP响应上调用`writeHead`函数来设置内容类型，然后在HTTP响应上调用`end`函数来向浏览器写入文本`'Hello
    World\n'`。
- en: With these couple of lines of code, we have created a running node HTTP server
    that serves up a simple web page with the text **"Hello World"**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这几行代码，我们创建了一个运行中的Node HTTP服务器，提供一个简单的网页，其中包含文本**"Hello World"**。
- en: 'Note that if you have a keen eye for TypeScript syntax, you will notice that
    this file uses JavaScript syntax and not TypeScript syntax for our `createServer`
    function. This is most probably due to the recent upgrade of the Node toolset
    from JavaScript to TypeScript. The call to `createServer` can also be written
    using TypeScript fat arrow syntax as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您对TypeScript语法有敏锐的眼光，您会注意到这个文件使用JavaScript语法而不是TypeScript语法来调用我们的`createServer`函数。这很可能是由于最近将Node工具集从JavaScript升级到TypeScript。调用`createServer`也可以使用TypeScript的箭头函数语法来编写，如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating a Node module
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Node模块
- en: 'To create a Node module, we simply need to create another TypeScript file to
    house our module code. Let''s create a file named `ServerMain.ts`, and move the
    code that writes to the HTTP response into this module as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Node模块，我们只需要创建另一个TypeScript文件来存放我们的模块代码。让我们创建一个名为`ServerMain.ts`的文件，并将写入HTTP响应的代码移入此模块，如下所示：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our `ServerMain` module starts with the `import` of the `'http'` module into
    the `http` namespace. This is necessary to allow us to use the `ServerRequest`
    and `ServerResponse` types that are part of this library.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ServerMain`模块以将`'http'`模块导入到`http`命名空间开始。这是必要的，以便我们可以使用此库的`ServerRequest`和`ServerResponse`类型。
- en: The keyword `export` is now used to indicate what functions will be made available
    to users of this module. As we can see, we have exported a function named `processRequest`
    that takes two parameters, `req` and `res`. This function will be used as a replacement
    for the anonymous function `(req, res) => { … }` that we were using in the `server.ts`
    file previously.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用关键字`export`来指示哪些函数将对该模块的用户可用。正如我们所看到的，我们导出了一个名为`processRequest`的函数，它接受两个参数，`req`和`res`。这个函数将用作替代我们之前在`server.ts`文件中使用的匿名函数`(req,
    res) => { ... }`。
- en: Note that as good TypeScript coders, we have also strongly typed the `req` and
    `res` variables to be of type `http.ServerRequest`, and of type `http.ServerResponse`
    respectively. This will enable Intellisense within our IDE, and also adheres to
    two principles of strong typing (S.F.I.A.T and self-describing functions).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，作为优秀的TypeScript编码者，我们还强类型化了`req`和`res`变量，分别为`http.ServerRequest`类型和`http.ServerResponse`类型。这将使我们的IDE内置智能提示，并且也符合强类型的两个原则（S.F.I.A.T和自描述函数）。
- en: 'Before we modify the `server.ts` file to use our new module, let''s crack open
    the generated JavaScript file and take a closer look at the CommonJs syntax in
    a little more detail:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改`server.ts`文件以使用我们的新模块之前，让我们打开生成的JavaScript文件，更仔细地查看一下CommonJs语法：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first part of this JavaScript is simple enough—we have a function named
    `processRequest`. The last line, however, attaches this function to a property
    on the `exports` global variable. This `exports` global variable is how CommonJs
    publishes modules to the outside world. Any function, class, or property that
    needs to be exposed to the outside world must be attached to the `exports` global
    variable. The TypeScript compiler will generate this line of code for us whenever
    we use the `exports` keyword in a TypeScript file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个JavaScript的前半部分足够简单——我们有一个名为`processRequest`的函数。然而，最后一行将这个函数附加到`exports`全局变量的一个属性上。这个`exports`全局变量是CommonJs将模块发布到外部世界的方式。任何需要暴露给外部世界的函数、类或属性都必须附加到`exports`全局变量上。每当我们在TypeScript文件中使用`exports`关键字时，TypeScript编译器将为我们生成这行代码。
- en: Using a Node module
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Node模块
- en: 'Now that we have our module in place, we can modify our `server.ts` file to
    use this module as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的模块，我们可以修改我们的`server.ts`文件来使用这个模块，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first line stays the same, but the second line uses the same `import` and
    `require` syntax to now import our `'./ServerMain'` module into the `ServerMain`
    namespace.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行保持不变，但第二行使用相同的`import`和`require`语法来将我们的`'./ServerMain'`模块导入到`ServerMain`命名空间中。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The syntax that we use to name this module points to a local file module, and
    therefore uses a relative file path to the module file. This relative path will
    resolve to the `ServerMain.js` file that TypeScript has generated. Creating a
    global Node module with the name `'ServerMain'`, which would be globally available—similar
    to the `'http'` module—is outside the scope of this discussion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来命名这个模块的语法指向一个本地文件模块，因此使用相对文件路径到模块文件。这个相对路径将解析为TypeScript生成的`ServerMain.js`文件。创建一个名为`'ServerMain'`的全局Node模块，它将全局可用——类似于`'http'`模块——超出了本讨论的范围。
- en: Our call to the `http.createServer` function now passes in our `processRequest`
    function as an argument. We have changed from an anonymous function using the
    fat arrow syntax, to a named function from the `ServerMain` module. We have also
    started to adhere to our "Separation of Concerns" design pattern. The `server.ts`
    file starts the server on a specific port, and the `ServerMain.ts` file now houses
    the code used to process a single request.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`http.createServer`函数的调用现在将我们的`processRequest`函数作为参数传入。我们已经从使用箭头函数的匿名函数改为了来自`ServerMain`模块的命名函数。我们还开始遵循我们的“关注点分离”设计模式。`server.ts`文件在特定端口上启动服务器，而`ServerMain.ts`文件现在包含用于处理单个请求的代码。
- en: Chaining asynchronous functions
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接异步函数
- en: 'When writing Node code, it is necessary to take a careful note of the asynchronous
    nature of all Node programming, as well as JavaScript''s lexical scoping rules.
    Luckily, the TypeScript compiler will generate errors if we break any of these
    rules. As an example of this, let''s update our `ServerMain` module to read in
    a file from disk, and serve up the contents of this file, instead of our `Hello
    world` text, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写Node代码时，有必要仔细注意所有Node编程的异步性质，以及JavaScript的词法作用域规则。幸运的是，TypeScript编译器会在我们违反这些规则时生成错误。举个例子，让我们更新我们的`ServerMain`模块，从磁盘中读取文件，并提供该文件的内容，而不是我们的`Hello
    world`文本，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To read files from disk, we will need to use the Node global module named `"fs"`,
    or filesystem, which is imported on the first line of the code. We then expose
    a new function named `processRequestReadFromFileAnonymous` that again uses the
    `req` and `res` parameters. Within this function, we then use the `fs.readFile`
    function to read a file from disk using three arguments. The first argument is
    the name of the file to be read in, the second argument is the file type, and
    the third argument is a callback function that Node will call, once the file has
    been read from disk.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要从磁盘中读取文件，我们需要使用名为`"fs"`的Node全局模块，或者文件系统，它在代码的第一行被导入。然后我们暴露一个名为`processRequestReadFromFileAnonymous`的新函数，再次使用`req`和`res`参数。在这个函数内部，我们使用`fs.readFile`函数来使用三个参数从磁盘中读取文件。第一个参数是要读取的文件名，第二个参数是文件类型，第三个参数是一个回调函数，Node在从磁盘中读取文件后将调用它。
- en: The body of this anonymous function is similar to what we have seen previously,
    but it also checks the `err` argument to see whether there was an error while
    loading the file. If there was no error, the function simply writes the file to
    the response stream.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个匿名函数的主体与我们之前看到的类似，但它还检查`err`参数，以查看在加载文件时是否出现错误。如果没有错误，函数就简单地将文件写入响应流中。
- en: 'In real-world applications, the logic inside of the main `processRequestReadFromFileAnonymous`
    function could become quite complex (besides the name), and may involve more than
    a single step to read a hardcoded filename from disk. Let''s move this anonymous
    function into a private function, and see what happens. Our first pass at refactoring
    this code may be something similar to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的应用程序中，主`processRequestReadFromFileAnonymous`函数内部的逻辑可能会变得非常复杂（除了名称之外），并且可能涉及从磁盘读取硬编码文件名的多个步骤。让我们将这个匿名函数移到一个私有函数中，看看会发生什么。我们对重构这段代码的第一次尝试可能类似于以下内容：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we have modified the `fs.readFile` function call, and replaced the anonymous
    callback function with a named function—`writeFileToStreamError`. This change,
    however, will immediately generate a compilation error:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们修改了`fs.readFile`函数调用，并用命名函数`writeFileToStreamError`替换了匿名回调函数。然而，这个改变会立即生成一个编译错误：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This compilation error is caused by the lexical scoping rules of JavaScript.
    The function `writeFileToStreamError` is trying to use the `res` parameter of
    the parent function. However, as soon as we moved this function outside the lexical
    scope of the parent, the variable `res` is no longer in scope – and will therefore
    be `undefined`. To fix this error, we need to ensure that the lexical scope of
    the `res` argument is maintained within our code structure, and we need to pass
    the value of the `res` argument down to our `writeFileToStream` function, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编译错误是由JavaScript的词法作用域规则引起的。函数`writeFileToStreamError`试图使用父函数的`res`参数。然而，一旦我们将这个函数移出父函数的词法作用域，变量`res`就不再在作用域内
    - 因此将是`undefined`。为了解决这个错误，我们需要确保`res`参数的词法作用域在我们的代码结构中得到维持，并且我们需要将`res`参数的值传递给我们的`writeFileToStream`函数，如下所示：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that in the call to `fs.readFile` on the third line in the preceding code,
    we have reverted back to our anonymous syntax, and passed on the value of the
    parent `res` argument down to our new function `writeFileToStream`. This modification
    of our code now correctly adheres to the lexical scoping rules of JavaScript.
    Another side-effect is that we have clearly defined what variables the `writeFileToStream`
    function needs, in order to work. It needs the `err` and `data` variables from
    the `fs.readFile` callback, but it also needs the `res` variable from the original
    HTTP request.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面代码的第三行调用`fs.readFile`时，我们已经恢复到了匿名语法，并将父级`res`参数的值传递给我们的新函数`writeFileToStream`。我们对代码的这种修改现在正确地遵守了JavaScript的词法作用域规则。另一个副作用是，我们已经清楚地定义了`writeFileToStream`函数需要哪些变量才能工作。它需要`fs.readFile`回调中的`err`和`data`变量，但它还需要原始HTTP请求中的`res`变量。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have not exported the `writeFileToStream` function; it is purely an internal
    function for use within our module.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有导出`writeFileToStream`函数；它纯粹是我们模块内部使用的函数。
- en: 'We can now modify our `server.ts` file to use our new chained function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以修改我们的`server.ts`文件来使用我们的新的链式函数：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running the application now will show the world what our `server.js` file contains:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序将展示`server.js`文件的内容：
- en: '![Chaining asynchronous functions](img/image_9665OS_07_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![链接异步函数](img/image_9665OS_07_02.jpg)'
- en: The Node application serving the contents of a file on disk
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Node应用程序提供磁盘上文件的内容
- en: Note that because we are using modules, we have been able to write three different
    versions of the `processRequest` function, each with a slight twist. However,
    our modifications to the `server.ts` file that launches the server have been very
    simple. We have just replaced the function that the server calls, in order to
    effectively run three different versions of our application. Again, this complies
    with the "Separation of Concerns" design principle. The `server.ts` code is simply
    used to start the Node server on a specific port, and should not be concerned
    with how each request is processed. Our code within `ServerMain.ts` is responsible
    simply for processing a request.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于我们使用了模块，我们已经能够编写`processRequest`函数的三个不同版本，每个版本都有一点不同。然而，我们对启动服务器的`server.ts`文件的修改非常简单。我们只是替换了服务器调用的函数，以有效地运行我们应用程序的三个不同版本。再次，这符合“关注点分离”设计原则。`server.ts`代码只是用于在特定端口上启动Node服务器，并不应该关心每个请求是如何处理的。我们`ServerMain.ts`中的代码只负责处理请求。
- en: 'This concludes our section on writing Node applications within TypeScript.
    As we have seen, the TypeScript developer experience brings with it a compilation
    step, which will quickly trap lexical scoping rules and many other issues within
    our code. Final score, TypeScript: 1, buggy code: 0!'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们在TypeScript中编写Node应用程序的部分。正如我们所见，TypeScript开发者体验带来了一个编译步骤，它将快速捕捉到我们代码中的词法作用域规则和许多其他问题。最终得分，TypeScript：1，有错误的代码：0！
- en: Using AMD
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AMD
- en: AMD stands for Asynchronous Module Definition, and as the name suggests, loads
    modules asynchronously. This means that when an HTML page is loaded, requests
    to fetch the JavaScript module files happen at the same time. This allows our
    page to load faster, as we are requesting smaller amounts of JavaScript simultaneously.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: AMD代表异步模块定义，正如其名称所示，它异步加载模块。这意味着当加载HTML页面时，获取JavaScript模块文件的请求同时发生。这使得我们的页面加载更快，因为我们同时请求了更小量的JavaScript。
- en: AMD module loading is typically used in browser applications, and works together
    with third-party libraries that provide a script-loading capability. One of the
    most popular script and module loaders currently available is Require. In this
    section, we will look at how to use the AMD module-loading syntax, and how to
    implement Require in a browser-based application.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: AMD模块加载通常用于浏览器应用程序，并与提供脚本加载功能的第三方库一起工作。目前最流行的脚本和模块加载器之一是Require。在本节中，我们将看看如何使用AMD模块加载语法，以及如何在基于浏览器的应用程序中实现Require。
- en: To begin with, let's create a simple TypeScript-based solution, using the "**Html
    application with TypeScript"** Visual Studio template. If you are not using Visual
    Studio, then simply create a new project or base source directory, and set up
    your environment for TypeScript compilation. To use AMD compilation, we will need
    to set our TypeScript project properties in order to compile to the AMD module
    syntax.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用“**带有TypeScript的HTML应用程序”**Visual Studio模板创建一个简单的基于TypeScript的解决方案。如果您不使用Visual
    Studio，那么只需创建一个新项目或基本源目录，并设置TypeScript编译环境。为了使用AMD编译，我们需要设置TypeScript项目属性，以便编译为AMD模块语法。
- en: 'Using NuGet, we will then install the following packages:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NuGet，我们将安装以下包：
- en: '`RequireJS`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RequireJS
- en: '`Requirejs.TypeScript.DefinitelyTyped`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Requirejs.TypeScript.DefinitelyTyped`'
- en: '`jQuery`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jQuery
- en: '`jquery.TypeScript.DefinitelyTyped`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jquery.TypeScript.DefinitelyTyped
- en: '`JasmineTest`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JasmineTest
- en: '`Jasmine.TypeScript.DefinitelyTyped`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine.TypeScript.DefinitelyTyped
- en: 'We will also base our application on Backbone, so we will therefore need the
    following NuGet packages:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还将基于Backbone构建我们的应用程序，因此我们需要以下NuGet包：
- en: '`Backbone.js`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Backbone.js
- en: '`Backbone.TypeScript.DefinitelyTyped`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Backbone.TypeScript.DefinitelyTyped`'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Backbone installation will also install Underscore, and the `Backbone.TypeScript.DefinitelyTyped`
    package will also install `underscore.TypeScript.DefinitelyTyped`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone安装还将安装Underscore，而`Backbone.TypeScript.DefinitelyTyped`包还将安装`underscore.TypeScript.DefinitelyTyped`。
- en: Backbone
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Backbone
- en: Backbone provides a very minimalistic framework for writing rich client-side
    JavaScript applications. It uses the MVC pattern to abstract our logic away from
    direct DOM manipulation. Backbone provides a core set of functionality that is
    broken up into models, collections, and views, as well as some utility classes
    to help with events and routing. The library itself is incredibly small, with
    the minimized `.js` file under 20 KB in size. Its only dependency is Underscore,
    which is a utility library, again under 16 KB in size. Backbone is a very popular
    library, has a huge number of extensions, and is relatively easy to learn and
    implement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone提供了一个非常简约的框架，用于编写丰富的客户端JavaScript应用程序。它使用MVC模式将我们的逻辑抽象出来，远离直接的DOM操作。Backbone提供了一组核心功能，分为模型、集合和视图，以及一些辅助类来帮助处理事件和路由。库本身非常小，最小化的`.js`文件大小不到20
    KB。它的唯一依赖是Underscore，这是一个实用库，大小不到16 KB。Backbone是一个非常受欢迎的库，有大量的扩展，并且相对容易学习和实现。
- en: Models, collections and views
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型、集合和视图
- en: At the core of Backbone lies the model. A model is a class that has a set of
    properties, and represents an item of information that will be treated as a unit.
    You could think of a model as a single row of data in a database table, or as
    an object to hold a particular type of information. Model objects are typically
    very simple, with a few getters and setters for each of their properties, and
    possibly a `url:` property for use with RESTful services. Arrays of models are
    held within a collection. A collection could be thought of as all the rows of
    data in a database table, or a logical group of models, each of the same type.
    Models can contain other models, and can also contain collections, so we are free
    to mix and match and combine collections and models at will.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Backbone的核心是模型。模型是一个具有一组属性的类，代表将被视为一个单元的信息项。您可以将模型视为数据库表中的单行数据，或者作为保存特定类型信息的对象。模型对象通常非常简单，每个属性都有一些getter和setter，可能还有一个用于RESTful服务的`url:`属性。模型的数组存储在集合中。集合可以被视为数据库表中的所有数据行，或者是相同类型的逻辑模型组。模型可以包含其他模型，也可以包含集合，因此我们可以自由地混合和匹配和组合集合和模型。
- en: Models, therefore, are used to define the structure of the data that our application
    uses. Backbone provides a simple `url:` property for both models and collections,
    which is used to synchronize Backbone models with RESTful services. Backbone will
    take care of generating create, read, update, and delete AJAX calls to our services
    via this `url:` property.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模型用于定义我们的应用程序使用的数据结构。Backbone为模型和集合都提供了一个简单的`url:`属性，用于将Backbone模型与RESTful服务同步。Backbone将通过这个`url:`属性来生成对我们服务的创建、读取、更新和删除的AJAX调用。
- en: Once a model or collection has been created, it is then passed to a view. A
    Backbone view is responsible for combining the properties of a model with an HTML
    template. Templates are made up of normal HTML, but have a special syntax to allow
    the properties of a model to be injected into this HTML. Once this HTML template
    has been combined with a model, the view can render the resultant HTML to the
    page.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦模型或集合被创建，它就会被传递给视图。Backbone视图负责将模型的属性与HTML模板结合在一起。模板由普通HTML组成，但具有特殊的语法，允许将模型的属性注入到此HTML中。一旦将此HTML模板与模型结合，视图就可以将生成的HTML呈现到页面上。
- en: Backbone does not really have the concept of a controller, as found in the classic
    MVC definition, but we can use normal TypeScript classes to accomplish the same
    functionality.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone实际上并没有控制器的概念，就像经典的MVC定义中那样，但我们可以使用普通的TypeScript类来实现相同的功能。
- en: Creating a model
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型
- en: Let's dive right into Backbone, and start with the definition of a model. In
    this sample, we will work with the concept of a contact—that simply has a `Name`
    and `EmailAddress` property—as shown in the following code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即深入Backbone，并从定义模型开始。在此示例中，我们将使用联系人的概念——只有`Name`和`EmailAddress`属性——如下所示。
- en: 'Note that this `ContactModel.ts` file is located under the `/tscode/app/models`
    directory:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ContactModel.ts`文件位于`/tscode/app/models`目录下：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We start with the definition of an interface named `IContactModel`, which has
    our `Name` and `EmailAddress` properties, both of which are strings.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从定义一个名为`IContactModel`的接口开始，其中包含我们的`Name`和`EmailAddress`属性，都是字符串。
- en: Next, we create a class named `ContactModel` that derives from, or `extends`,
    the base `Backbone.Model` class. Note that we are using the `export` keyword before
    our class definition, to indicate to the TypeScript compiler that we are creating
    a module that can be imported elsewhere. The `export` keyword and usage is exactly
    the same as what we have seen previously when we used the CommonJS syntax. Our
    `ContactModel` class implements the `IContactModel` interface, and also uses ES5
    `get` and `set` syntax to define the `Name` and `EmailAddress` properties.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个名为`ContactModel`的类，它派生自基类`Backbone.Model`。请注意，我们在类定义之前使用了`export`关键字，以指示给TypeScript编译器我们正在创建一个可以在其他地方导入的模块。`export`关键字和用法与我们之前使用CommonJS语法时完全相同。我们的`ContactModel`类实现了`IContactModel`接口，并且还使用了ES5的`get`和`set`语法来定义`Name`和`EmailAddress`属性。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The implementation of each of these properties calls the Backbone `this.get('<propertyname>')`
    or `this.set('<propertyname>', value)` functions. Backbone stores model properties
    as object attributes, and uses these `get` and `set` functions internally to interact
    with model properties – hence the syntax used previously.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性的实现都调用了Backbone的`this.get('<propertyname>')`或`this.set('<propertyname>',
    value)`函数。Backbone将模型属性存储为对象属性，并在内部使用这些`get`和`set`函数与模型属性交互，因此之前使用的语法。
- en: 'Let''s follow TDD practices, and write a set of unit tests to make sure that
    we can create an instance of our `ContactModel` correctly. For this test, we will
    create a `ContactModelTests.ts` file under the `/tscode/tests/models` directory,
    as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循TDD实践，并编写一组单元测试，以确保我们可以正确地创建`ContactModel`的实例。对于这个测试，我们将在`/tscode/tests/models`目录下创建一个`ContactModelTests.ts`文件，如下所示：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line of this test uses the `import <namespace> = require('<filename>')`
    syntax that we have seen previously, to import the `ContactModel` module that
    we exported earlier. You will notice that the file name uses a relative path,
    which drops down two directories (`"../../"`) before specifying the `"app/models/ContactModel"`
    path. This is because AMD module compilation uses paths that are relative to the
    current file. As our test code is in the `/tscode/tests/models` directory, this
    relative path must point to the correct directory that contains the `ContactModel.ts`
    TypeScript file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的第一行使用了我们之前见过的`import <namespace> = require('<filename>')`语法，导入了我们之前导出的`ContactModel`模块。您会注意到文件名使用了相对路径，它在指定`"app/models/ContactModel"`路径之前向下跨越了两个目录(`"../../"`)。这是因为AMD模块编译使用相对于当前文件的路径。由于我们的测试代码在`/tscode/tests/models`目录中，这个相对路径必须指向包含`ContactModel.ts`
    TypeScript文件的正确目录。
- en: Our test defines a variable named `contactModel` that is strongly typed to be
    of type `cm.ContactModel`. Again, we are using the prefix from the `import` statement
    as a namespace in order to reference the exported `ContactModel` class. Our `beforeEach`
    function then creates an instance of the `ContactModel` class, passing a JavaScript
    object with the `Name` and `EmailAddress` properties into the constructor.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试定义了一个名为`contactModel`的变量，它被强类型为`cm.ContactModel`类型。同样，我们使用了`import`语句中的前缀作为命名空间，以便引用导出的`ContactModel`类。我们的`beforeEach`函数然后创建了`ContactModel`类的一个实例，将一个具有`Name`和`EmailAddress`属性的JavaScript对象传递给构造函数。
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are using JSON syntax in the constructor of our `ContactModel` class. This
    syntax closely matches the data that a RESTful service would return, and is, therefore,
    a handy way of constructing classes and assigning properties in a single constructor
    call.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`ContactModel`类的构造函数中使用了JSON语法。这个语法与RESTful服务返回的数据非常接近，因此是一种方便的方式来构造类并在单个构造函数调用中分配属性。
- en: Our first test is checking whether the `contactModel.Name` ES5 syntax works
    correctly, and will return the text `'testName'`. The second test is almost the
    same but uses the `.get('Name')` internal Backbone attribute syntax in order to
    ensure that our TypeScript class and the Backbone class are working as expected.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个测试检查`contactModel.Name` ES5语法是否正确工作，并且将返回文本`'testName'`。第二个测试几乎相同，但是使用了`.get('Name')`内部Backbone属性语法，以确保我们的TypeScript类和Backbone类按预期工作。
- en: The require.config file
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: require.config文件
- en: Now that we have defined a `Backbone.Model`, and have a written a Jasmine test
    for it, we will need to run this test in a browser to verify our results. Generally,
    we would create an HTML page, and then include the `<script>` tags for each of
    our JavaScript files in the header section. This is where AMD steps in. We no
    longer need to specify every JavaScript file in our HTML. All we need to do is
    include a single `<script>` tag for Require ( which is our module loader ), which
    will then co-ordinate the loading of all the files that we need automatically.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个`Backbone.Model`，并且为它编写了一个Jasmine测试，我们需要在浏览器中运行这个测试来验证我们的结果。通常，我们会创建一个HTML页面，然后在头部部分包含每个JavaScript文件的`<script>`标签。这就是AMD发挥作用的地方。我们不再需要在HTML中指定每个JavaScript文件。我们只需要包含一个Require的`<script>`标签（这是我们的模块加载器），它将自动协调加载我们需要的所有文件。
- en: 'To do this, let''s create a `SpecRunner.html` file in the `/tests` directory
    as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，让我们在`/tests`目录中创建一个`SpecRunner.html`文件，如下所示：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a very simple HTML file. The line to note here, though, is the `<script>`
    tag that loads `/Scripts/require.js`. This script tag has a `data-main` attribute,
    which is set to `"/tscode/tests/TestConfig"`. The `data-main` attribute is passed
    to Require, and it tells Require where to start looking for our JavaScript files.
    In the preceding code, Require will look for a file named `/tscode/tests/TestConfig.js`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的HTML文件。这里需要注意的是`<script>`标签加载了`/Scripts/require.js`。这个脚本标签有一个`data-main`属性，它设置为`"/tscode/tests/TestConfig"`。`data-main`属性被传递给Require，它告诉Require从哪里开始寻找我们的JavaScript文件。在前面的代码中，Require将寻找一个名为`/tscode/tests/TestConfig.js`的文件。
- en: 'We will build this `/tscode/tests/TestConfig.ts` file as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下方式构建`/tscode/tests/TestConfig.ts`文件：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We start with a call to the `require.config` function, and pass it a JavaScript
    object which has three properties: `baseUrl`, `paths`, and `shim`. The `baseUrl`
    property tells Require what base directory to use when it is looking for JavaScript
    files. In the sample application, our `TestConfig.ts` file is in the `/tscode/tests`
    directory, so our base directory would be `/`.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从调用`require.config`函数开始，并传递一个具有三个属性的JavaScript对象：`baseUrl`，`paths`和`shim`。`baseUrl`属性告诉Require在查找JavaScript文件时要使用的基本目录。在示例应用程序中，我们的`TestConfig.ts`文件位于`/tscode/tests`目录中，因此我们的基本目录将是`/`。
- en: The `paths` property specifies the full path to our JavaScript files, and each
    entry is given a name. In the previous example, the script `/Scripts/jasmine/jasmine.js`
    is named `'jasmine'`, and can be referred to as `'jasmine'` throughout the rest
    of the script.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`paths`属性指定了我们JavaScript文件的完整路径，每个条目都有一个名称。在前面的示例中，脚本`/Scripts/jasmine/jasmine.js`被命名为`''jasmine''`，并且可以在脚本的其余部分中被称为`''jasmine''`。'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Require will automatically append `.js` to each of these entries, so any entry
    in the `paths` property should NOT include `.js` in the file's entry.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Require会自动将`.js`附加到这些条目中，因此`paths`属性中的任何条目都不应包含文件条目中的`.js`。
- en: The `shim` property tells Require a few more details about each entry in the
    `paths` property. Take a look at the `shim` entry for `backbone`. It has a `deps`
    property that specifies what the dependencies for Backbone are. Backbone has a
    dependency on Underscore, so Underscore must be loaded before Backbone.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`shim`属性告诉Require关于`paths`属性中每个条目的更多细节。看一下`backbone`的`shim`条目。它有一个`deps`属性，指定了Backbone的依赖关系。Backbone依赖于Underscore，因此必须在Backbone之前加载Underscore。'
- en: The `exports` property tells Require to append the library to the namespace
    that is specified as the exports' value. In our preceding sample, therefore, any
    call to Underscore must prepend an `_` to any function call in the Underscore
    library. As an example, `_.bindAll` calls the `bindAll` function of Underscore.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`exports`属性告诉Require将库附加到指定为exports值的命名空间。因此，在我们之前的示例中，对Underscore的任何调用都必须在Underscore库中的任何函数调用之前加上`_`。例如，`_.bindAll`调用Underscore的`bindAll`函数。'
- en: Dependencies specified in the `shim` section of `require.config` are recursive.
    If we take a look at the shim for `'jasmine-boot'`, we can see that it is dependent
    on `'jasmine-html'`, which in turn is dependent on `'jasmine'`. Require will ensure
    that all these scripts are loaded in the correct order, before running code that
    needs `'jasmine-boot'`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在`require.config`的`shim`部分指定的依赖关系是递归的。如果我们看一下`jasmine-boot`的shim，我们可以看到它依赖于`jasmine-html`，而`jasmine-html`又依赖于`jasmine`。Require将确保在运行需要`jasmine-boot`的代码之前，按正确的顺序加载所有这些脚本。
- en: 'Let''s next take a look at the bottom of the file where we call the `require`
    function. This call takes two parameters: an array of files that need to be loaded,
    and a callback function to call once the load step has been completed. This callback
    function has a corresponding parameter for each of the file entries in our array.
    So, in the previous example, `''jasmine-boot''` will be made available to our
    function via the corresponding parameter `jb`. We will see more examples of this
    a bit later.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们看一下文件底部的`require`函数调用。这个调用有两个参数：需要加载的文件数组和一旦加载步骤完成后要调用的回调函数。这个回调函数对应于数组中每个文件条目的参数。因此，在前面的示例中，`'jasmine-boot'`将通过相应的参数`jb`提供给我们的函数。稍后我们将看到更多这方面的例子。
- en: Calls to the `require` function, each with its array of files that need to be
    loaded, and the corresponding callback parameters, can be nested. In our sample,
    we have nested a second call to the require function inside our initial call,
    but this time we have passed in the `specs` array and omitted the callback parameters.
    This `specs` array currently contains just our `ContactModelTests` file. Our nested
    anonymous function just calls the `window.onload` function, which will trigger
    Jasmine to run all of our tests.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 对`require`函数的调用，每个调用都有其需要加载的文件数组和相应的回调参数，可以嵌套。在我们的示例中，我们在初始调用内嵌套了对require函数的第二次调用，但这次我们传入了`specs`数组并省略了回调参数。这个`specs`数组目前只包含我们的`ContactModelTests`文件。我们嵌套的匿名函数只是调用`window.onload`函数，这将触发Jasmine运行我们所有的测试。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The call to `window.onload()` has a slightly strange syntax. We are using an
    explicit cast to cast the `window` variable to a type of `<any>` before calling
    the `onload()` function. This is because the TypeScript compiler is expecting
    an `Event` parameter to be passed to the `onload()` function. We do not have an
    event parameter, and need to ensure that the generated JavaScript is in the correct
    syntax – hence the cast to `<any>`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对`window.onload()`的调用具有稍微奇怪的语法。在调用`onload()`函数之前，我们使用显式转换将`window`变量转换为`<any>`类型。这是因为TypeScript编译器期望将`Event`参数传递给`onload()`函数。我们没有事件参数，需要确保生成的JavaScript语法正确
    - 因此转换为`<any>`。
- en: If all goes well, we can now fire up our browser and call the `SpecRunner.html`
    page at `/tscode/tests/SpecRunner.html`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们现在可以启动浏览器，并在`/tscode/tests/SpecRunner.html`页面上调用`SpecRunner.html`。
- en: Fixing Require config errors
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复Require配置错误
- en: Quite often, when developing AMD applications with Require, we can start to
    get unexpected behaviour, strange error messages, or simply blank pages. These
    strange results are generally caused by the configuration for Require, either
    in the `paths`, `shim`, or `deps` properties. Fixing these AMD errors can be quite
    frustrating at first, but generally, they are caused by one of two things—incorrect
    dependencies or `file-not-found` errors.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Require开发AMD应用程序时，经常会出现意外行为、奇怪的错误消息或者空白页面。这些奇怪的结果通常是由Require的配置引起的，要么是在`paths`，`shim`或`deps`属性中。修复这些AMD错误一开始可能会令人沮丧，但通常是由两种情况引起的
    - 不正确的依赖关系或`file-not-found`错误。
- en: To fix these errors, we will need to open the debugging tools within the browser
    that we are using—which for most browsers, is achieved by simply hitting *F12*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复这些错误，我们需要打开浏览器中的调试工具，大多数浏览器可以通过简单地按下*F12*来实现。
- en: Incorrect dependencies
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不正确的依赖关系
- en: 'Some AMD errors are caused by incorrect dependencies in our `require.config`.
    These errors can be found by checking the console output in the browser. Dependency
    errors would generate browser errors similar to the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一些AMD错误是由`require.config`中的不正确依赖关系引起的。可以通过检查浏览器中的控制台输出来找到这些错误。依赖错误会生成类似以下的浏览器错误：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This type of error might mean that the AMD loader has loaded Backbone, for example,
    before loading Underscore. So, whenever Backbone tries to use an underscore function,
    we get a `not defined` error, as shown in the preceding output. The fix for this
    type of error is to update the `deps` property of the library that is causing
    the error. Make sure that all prerequisite libraries have been named in the `deps`
    property, and the errors should go away. If they do not, then the error may be
    caused by the next type of AMD error, a `file-not-found` error.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的错误可能意味着AMD加载器在加载Underscore之前加载了Backbone，例如。因此，每当Backbone尝试使用下划线函数时，我们会得到一个`未定义`错误，如前面的输出所示。修复这种类型的错误的方法是更新导致错误的库的`deps`属性。确保所有先决条件库都已在`deps`属性中命名，错误应该会消失。如果没有，那么错误可能是由下一种类型的AMD错误引起的，即`文件未找到`错误。
- en: 404 errors
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 404错误
- en: 'File-not-found, or 404 errors are generally indicated by console output similar
    to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 文件未找到，或404错误通常由类似以下的控制台输出指示：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To find out which file is causing the preceding error, switch to the network
    tab in your debugger tools and refresh the page. Look for 404 (`file-not-found`)
    errors, as shown in the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出哪个文件导致了前面的错误，请切换到调试工具中的网络选项卡并刷新页面。查找404（`文件未找到`）错误，如下面的截图所示：
- en: '![404 errors](img/image_9665OS_07_03.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![404错误](img/image_9665OS_07_03.jpg)'
- en: Firefox network tab with 404 errors
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox网络选项卡显示404错误
- en: In this screenshot, we can see that the call to `jquery.js` is generating a
    404 error, as our file is actually named `/Scripts/jquery-2.1.1.js`. These sorts
    of errors can be fixed by adding an entry to the `paths` parameter in `require.config`
    so that any call to `jquery.js` is replaced by a call to `jquery-2.1.1.js`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个截图中，我们可以看到对`jquery.js`的调用生成了一个404错误，因为我们的文件实际上被命名为`/Scripts/jquery-2.1.1.js`。这种错误可以通过在`require.config`的`paths`参数中添加一个条目来修复，这样任何对`jquery.js`的调用都会被替换为对`jquery-2.1.1.js`的调用。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Require has a good set of documentation for common AMD errors ([http://requirejs.org/docs/errors.html](http://requirejs.org/docs/errors.html))
    as well as advanced API usages, including circular references ([http://requirejs.org/docs/api.html#circular](http://requirejs.org/docs/api.html#circular)),
    so be sure to check the site for more information on possible AMD errors.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Require有一套很好的常见AMD错误文档（[http://requirejs.org/docs/errors.html](http://requirejs.org/docs/errors.html)），以及包括循环引用在内的高级API用法，因此请务必查看该网站，了解可能的AMD错误的更多信息。
- en: Using Backbone.Collections
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Backbone.Collections
- en: 'Now that we have a `ContactModel` working and tested, we can build a `Backbone.Collection`
    to house a group of `ContactModel` instances. Since we are using AMD, we can create
    a new `ContactCollection.ts` file and add the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个工作并经过测试的`ContactModel`，我们可以构建一个`Backbone.Collection`来容纳一组`ContactModel`实例。由于我们使用了AMD，我们可以创建一个新的`ContactCollection.ts`文件，并添加以下代码：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Creating a `Backbone.Collection` is relatively straightforward. Firstly, we
    `import` the `ContactModel`, as we have seen previously, and assign it to the
    `cm` namespace. We then create a class named `ContactCollection` that `extends`
    from `Backbone.Collection`, and uses the generic type `cm.ContactModel`. This
    `ContactCollection` has two properties: `model` and `url`. The `model` property
    tells Backbone what model class to use internally, and the `url` property points
    to a server-side RESTful URL. Backbone will generate the correct POST, GET, DELETE,
    and UPDATE HTTP protocols for server-side RESTful calls when we synchronize our
    data with the server. In the preceding sample, we are simply returning a hardcoded
    JSON file, as we will only be using HTTP GETs.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Backbone.Collection`相对简单。首先，我们像之前看到的那样`import`了`ContactModel`，并将其赋值给`cm`命名空间。然后我们创建了一个名为`ContactCollection`的类，它`extends`自`Backbone.Collection`，并使用了泛型类型`cm.ContactModel`。这个`ContactCollection`有两个属性：`model`和`url`。`model`属性告诉Backbone内部使用哪个模型类，`url`属性指向服务器端的RESTful
    URL。当我们将数据与服务器同步时，Backbone将为服务器端的RESTful调用生成正确的POST、GET、DELETE和UPDATE HTTP协议。在前面的示例中，我们只是返回一个硬编码的JSON文件，因为我们只会使用HTTP
    GET。
- en: 'If we open the resultant JavaScript file that TypeScript generates, we will
    see that the compiler has modified our file quite a bit:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开TypeScript生成的结果JavaScript文件，我们会看到编译器已经对我们的文件进行了相当多的修改：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first six lines of the file starting with `var __extends`, are simply TypeScript's
    implementation of inheritance in JavaScript, and we will not concern ourselves
    too much with it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的前六行以`var __extends`开头，只是TypeScript在JavaScript中实现继承的方式，我们不需要过多关注它。
- en: 'The lines to note start with the `define` function. TypeScript has wrapped
    our class definition within an outer call to `define`. This `define` function
    call now has three parameters: `require`, `exports`, and `./ContactModel`. The
    syntax and usage of this function are exactly the same as the call to the `require`
    function that we wrote ourselves in the `TestConfig.ts` file.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的行以`define`函数开头。TypeScript已经将我们的类定义包裹在一个外部的`define`调用中。这个`define`函数现在有三个参数：`require`，`exports`和`./ContactModel`。这个函数的语法和用法与我们在`TestConfig.ts`文件中自己编写的`require`函数调用完全相同。
- en: The first parameter is an array of files to import, and the second parameter
    is a callback function to call once these files have been loaded. Again, each
    element in our first array has a corresponding argument in our callback parameters.
    TypeScript will automatically add the `"require"` and `"exports"` parameters for
    us, and then include any file that we specified using the `import` keyword. When
    TypeScript compiles our files using the AMD syntax, it will automatically generate
    this style of JavaScript to be compatible with AMD loaders such as Require.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要导入的文件数组，第二个参数是在这些文件加载完成后要调用的回调函数。同样，我们第一个数组中的每个元素在回调参数中都有对应的参数。TypeScript会自动为我们添加`"require"`和`"exports"`参数，然后包含我们使用`import`关键字指定的任何文件。当TypeScript使用AMD语法编译我们的文件时，它会自动生成与AMD加载器（如Require）兼容的JavaScript样式。
- en: 'Let''s now write a couple of unit tests for our `ContactCollection`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为我们的`ContactCollection`编写一些单元测试：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This test starts with an `import` statement for both the `ContactCollection`,
    as well as the `ContactModel`, as we will be using both within this test. It then
    simply creates a new `ContactCollection` and passes in an array of two new `ContactModels`.
    This test highlights how to create a new `ContactCollection`, and populate it
    programmatically.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试以`import`语句开始，导入了`ContactCollection`和`ContactModel`，因为我们将在这个测试中使用这两者。然后简单地创建一个新的`ContactCollection`，并传入一个包含两个新的`ContactModels`的数组。这个测试突出了如何通过编程方式创建一个新的`ContactCollection`并填充它。
- en: 'Let ''s now write a test to load the collection via the `url` property:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编写一个测试，通过`url`属性加载集合：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This test creates a new `ContactCollection` and then calls the `fetch` function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试创建了一个新的`ContactCollection`，然后调用了`fetch`函数。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have passed an `async` flag set to `false` to force Backbone to use a synchronous
    call to the server. In other words, the JavaScript will pause until the fetch
    is complete before moving onto the next line. We could have written this test
    using the asynchronous `done` syntax of Jasmine, but for smaller tests, passing
    this `async` flag makes the code a little easier to read.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递了一个设置为`false`的`async`标志，以强制Backbone使用同步调用服务器。换句话说，JavaScript将在获取完成之前暂停，然后再继续执行下一行。我们本可以使用Jasmine的异步`done`语法来编写这个测试，但对于较小的测试，传递这个`async`标志使代码更容易阅读。
- en: 'As mentioned previously, the `fetch` function will use the `url` parameter
    to issue a GET HTTP request to the provided URL, which in this case is simply
    loading the `contacts.json` file. The contents of this file are as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`fetch`函数将使用`url`参数向提供的URL发出GET HTTP请求，在这种情况下，它只是加载`contacts.json`文件。该文件的内容如下：
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This file uses simple JSON syntax to define four contacts, each with a `Name`
    and `EmailAddress` property. Let''s write a few integration tests to ensure that
    the `fetch` function, using this JSON, actually creates a `ContactCollection`
    correctly:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件使用简单的JSON语法定义了四个联系人，每个联系人都有一个`Name`和`EmailAddress`属性。让我们编写一些集成测试，以确保使用这个JSON的`fetch`函数实际上正确地创建了一个`ContactCollection`：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this test code, we are using the `beforeEach` function to populate our collection
    variable with an instance of the `ContactCollection` class, and are then calling
    the `fetch` function, again with the `{async: false}` flag. Our first test then
    uses the Backbone `at` function to retrieve the first model held within the collection
    at index `0`. We then check the `''Name''` attribute of the returned model, using
    Backbone''s internal `get` function. The second test is using the ES5 syntax of
    our `ContactModel` class, just to test whether Backbone is in fact storing an
    instance of our `ContactModel` class in its collection.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个测试代码中，我们使用`beforeEach`函数用`ContactCollection`类的一个实例填充我们的集合变量，然后再次调用`fetch`函数，使用`{async:
    false}`标志。我们的第一个测试然后使用Backbone的`at`函数从索引`0`处的集合中检索第一个模型。然后我们使用Backbone的内部`get`函数检查返回的模型的`''Name''`属性。第二个测试使用我们`ContactModel`类的ES5语法，只是为了测试Backbone是否确实在其集合中存储了我们的`ContactModel`类的实例。'
- en: 'To include these tests in our test suite, we now simply need to modify the
    `TestConfig.ts` file and add an entry to our specs array as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些测试包含在我们的测试套件中，现在我们只需要修改`TestConfig.ts`文件，并在我们的specs数组中添加一个条目，如下所示：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Backbone views
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Backbone视图
- en: 'Now that we have a `ContactCollection` to house our `ContactModels`, let''s
    create a `Backbone.View` that will render this collection to the DOM. In order
    to do this, we will actually create two views: one view for each item in the collection,
    and one view for the collection itself. Remember that Backbone views combine a
    `Backbone.Model` with a template in order to render the model''s properties into
    the DOM.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个用于存放我们的`ContactModels`的`ContactCollection`，让我们创建一个`Backbone.View`，将这个集合渲染到DOM中。为了做到这一点，我们实际上会创建两个视图：一个视图用于集合中的每个项目，另一个视图用于集合本身。请记住，Backbone视图将`Backbone.Model`与模板结合起来，以便将模型的属性呈现到DOM中。
- en: 'We will start with the view to render a single collection item (in this case
    a single `ContactModel`), called `ContactItemView`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从视图开始，以渲染单个集合项（在本例中是单个`ContactModel`），称为`ContactItemView`：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code snippet starts with an `import` of the `ContactModel` class that we
    have attached to the `cm` namespace. We then create a class named `ContactItemView`
    that `extends` from `Backbone.View`. Similar to the generic syntax that we used
    for our collection, this view class also uses the `ContactModel` as the type for
    its generic instance. Finally, we export this class to make it available to our
    code as an AMD module.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段以我们附加到`cm`命名空间的`ContactModel`类的`import`开始。然后我们创建了一个名为`ContactItemView`的类，它`extends`自`Backbone.View`。与我们用于集合的通用语法类似，这个视图类也使用`ContactModel`作为其通用实例的类型。最后，我们导出这个类，使其作为AMD模块对我们的代码可用。
- en: The `ContactItemView` class has a public property named `template` that is a
    function that returns a string. This function takes the model's properties as
    an input argument. The `template` function is assigned in the second line of the
    constructor, to be the result of the call to Underscore's `_.template( … )` function.
    If we take a closer look at the string used in this template function, we will
    see that it is an HTML string that uses the `<%= propertyName %>` syntax, to inject
    the Backbone model's properties into the HTML. We have also specified that the
    DOM `className` should be set to `"contact-item-view"`. Finally, we call the base
    class constructor with the `options` argument that was passed into the constructor.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactItemView`类有一个名为`template`的公共属性，它是一个返回字符串的函数。这个函数将模型的属性作为输入参数。`template`函数在构造函数的第二行被赋值为调用Underscore的`_.template(
    … )`函数的结果。如果我们仔细看一下这个模板函数中使用的字符串，我们会发现它是一个HTML字符串，它使用`<%= propertyName %>`语法将Backbone模型的属性注入到HTML中。我们还指定了DOM的`className`应该设置为`"contact-item-view"`。最后，我们使用传递给构造函数的`options`参数调用基类构造函数。'
- en: So, what have we done here? We have created a `Backbone.View` class, specified
    its `className`, and set the `template` that the view should use to render its
    model to the DOM. The last piece of code that we need is the `render` function
    itself. This `render` function does a couple of things in just one line. Firstly,
    each Backbone view has a `$el` property that holds the DOM element. We then call
    the `html` function on this element in order to set it's HTML, and pass in the
    result of a call to the `template` function. By convention, the `render` function
    always returns `this`, to enable a calling class to use fluent syntax after calling
    the `render` function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在这里做了什么？我们创建了一个`Backbone.View`类，指定了它的`className`，并设置了视图应该用来将其模型呈现到DOM的`template`。我们需要的最后一段代码是`render`函数本身。这个`render`函数在一行中做了几件事情。首先，每个Backbone视图都有一个`$el`属性，它保存着DOM元素。然后我们在这个元素上调用`html`函数来设置它的HTML，并传入`template`函数的调用结果。按照惯例，`render`函数总是返回`this`，以便调用类在调用`render`函数后使用流畅的语法。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are a number of template engines that can be used with Backbone—such as
    Handlebars ([http://handlebarsjs.com/](http://handlebarsjs.com/)) and Moustache
    ([https://github.com/janl/mustache.js/](https://github.com/janl/mustache.js/))
    to name a few. In this sample, we will just stick to the Underscore template engine.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone可以与许多模板引擎一起使用，例如Handlebars（[http://handlebarsjs.com/](http://handlebarsjs.com/)）和Moustache（[https://github.com/janl/mustache.js/](https://github.com/janl/mustache.js/)）。在这个示例中，我们将坚持使用Underscore模板引擎。
- en: 'Now that we have a `Backbone.View` defined, we can write a simple test for
    it:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了`Backbone.View`，我们可以为其编写一个简单的测试：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This code snippet starts with the imports for both `ContactModel` and `ContactItemView`.
    There is only one test in this suite, and it is fairly simple. Firstly, we create
    an instance of a `ContactModel`, setting the `Name` and `EmailAddress` properties
    in the constructor. We then create an instance of the `ContactItemView` class,
    and pass the model we just created as a constructor argument. Note the syntax
    that we are using in the constructor: `{ model: contactModel }`. Backbone views
    can be constructed in a few different ways, and the properties that we set on
    construction – in this case the `model` property – are passed down to the base
    Backbone classes, via the `super()` function call in our constructor.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码片段以`ContactModel`和`ContactItemView`的导入开始。这个套件中只有一个测试，而且非常简单。首先，我们创建一个`ContactModel`的实例，在构造函数中设置`Name`和`EmailAddress`属性。然后我们创建`ContactItemView`类的一个实例，并将我们刚刚创建的模型作为构造函数的参数传递。请注意我们在构造函数中使用的语法：`{
    model: contactModel }`。Backbone视图可以以几种不同的方式构造，我们在构造时设置的属性-在这种情况下是`model`属性-通过我们的构造函数中的`super()`函数调用传递给基本的Backbone类。'
- en: Our test then calls the `render` function on the `contactItemView` instance.
    Note here that we are then referencing the `$el` property of the view directly,
    and calling the `html` function – as if it were a jQuery DOM element. This is
    the reason why all `render` functions should return `this`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试然后在`contactItemView`实例上调用`render`函数。请注意，我们直接引用了视图的`$el`属性，并调用了`html`函数-就好像它是一个jQuery
    DOM元素一样。这就是为什么所有`render`函数都应该返回`this`的原因。
- en: Our test then checks that the result of the `render` function generates the
    HTML that we expect, based on the template, and our model properties.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试然后检查`render`函数的结果是否生成了我们根据模板和我们的模型属性所期望的HTML。
- en: Using the Text plugin
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Text插件
- en: 'Having hardcoded HTML within our view, however, will make our code difficult
    to maintain. To help with this conundrum, we will use a Require plugin called
    Text. Text uses normal require syntax, just with a `''text!"` prefix to load files
    from the site for use in our code. To install this plugin via NuGet, simply type:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的视图中硬编码HTML将使我们的代码难以维护。为了解决这个难题，我们将使用一个名为Text的Require插件。Text使用正常的require语法，只是使用`'text!"`前缀从站点加载文件以在我们的代码中使用。要通过NuGet安装此插件，只需键入：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To use Text, we will first need to list `text` in our `require.config paths`
    property as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Text，我们首先需要在`require.config paths`属性中列出`text`，如下所示：
- en: '[PRE26]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then modify our call to `require` in our `TestConfig.ts` as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以修改我们在`TestConfig.ts`中对`require`的调用如下：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this code snippet, we create a global variable named `CONTACT_ITEM_SNIPPET`
    to hold our snippet, and then we include the HTML file that we need to load using
    the `'text!<path to html>'` syntax in our call to `require`. Again, each item
    in the array we use for the `require` function call has a corresponding variable
    in our anonymous function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，我们创建了一个名为`CONTACT_ITEM_SNIPPET`的全局变量来保存我们的片段，然后我们在调用`require`时使用`'text!<path
    to html>'`语法来包含我们需要加载的HTML文件。同样，我们在`require`函数调用的数组中的每个项目都在我们的匿名函数中有一个对应的变量。
- en: 'In this way, Require will load the text found at `/tscode/app/views/ContactItemView.html`,
    and pass it to our function via the `contactItemSnippet` argument as a string.
    We can then set the global variable `CONTACT_ITEM_SNIPPET` to this value. Before
    we can run this code, however, we will need to modify our `ContactItemView` to
    use this variable:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，Require将加载在`/tscode/app/views/ContactItemView.html`找到的文本，并通过字符串作为`contactItemSnippet`参数传递给我们的函数。然后我们可以将全局变量`CONTACT_ITEM_SNIPPET`设置为这个值。然而，在运行这段代码之前，我们需要修改我们的`ContactItemView`来使用这个变量。
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The changed line in the preceding code is the call invoke the `_.template` function
    using the value of the global variable `CONTACT_ITEM_SNIPPET`, instead of a hard
    coded HTML string.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中改变的行是使用全局变量`CONTACT_ITEM_SNIPPET`的值调用`_.template`函数，而不是使用硬编码的HTML字符串。
- en: 'The last thing we need is to create the `ContactItemView.html` file itself,
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是创建`ContactItemView.html`文件本身，如下所示：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This HTML file uses the same `<%= propertyName %>` syntax that we have seen
    before, but we are now able to easily expand our HTML to include outer `divs`,
    and give each property its own CSS classes for some styling later on.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML文件使用了与之前相同的`<%= propertyName %>`语法，但是现在我们可以很容易地扩展我们的HTML，包括外部的`divs`，并为每个属性分配自己的CSS类，以便稍后进行一些样式设置。
- en: 'Running our tests now, however, will break our `ContactItemViewTests` – because
    the HTML we are using has been changed. Let''s fix this broken test now:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在运行我们的测试将会破坏我们的`ContactItemViewTests`，因为我们使用的HTML已经被更改了。让我们现在修复这个破损的测试：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have commented the offending line, and are using the `.toContain` matcher
    to ensure that our HTML has been injected correctly with the model properties,
    instead of looking for an exact match for the `html` string value.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经注释了有问题的行，并使用`.toContain`匹配器来确保我们的HTML已经正确地注入了模型属性，而不是寻找`html`字符串值的精确匹配。
- en: Rendering a collection
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染一个集合
- en: 'Now that we have a view to render individual Contact items, we need another
    view to render the entire `ContactCollection`. To do this, we simply create a
    new `Backbone.View` for our collection, and then create a new `ContactItemView`
    instance for each item in the collection as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个用于渲染单个联系人项目的视图，我们需要另一个视图来渲染整个`ContactCollection`。为此，我们简单地为我们的集合创建一个新的`Backbone.View`，然后为集合中的每个项目创建一个新的`ContactItemView`实例，如下所示：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We start this code snippet with our imports for the `ContactModel` and `ContactItemView`
    modules. We then create a `ContactCollectionView` that extends `Backbone.View`,
    this time using a base `Backbone.Model` for the generic syntax. Our `constructor`
    simply passes any `options` that it receives down to the base view class through
    the `super` function call. We then call an Underscore function named `bindAll`.
    The Underscore `bindAll` function is a utility function that binds the scope of
    `this` to the correct context, when used in a class function. Let's explore the
    code a little to make this clearer.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`ContactModel`和`ContactItemView`模块导入开始这个代码片段。然后我们创建了一个扩展了`Backbone.View`的`ContactCollectionView`，这次使用了一个基本的`Backbone.Model`来进行通用的语法。我们的`constructor`简单地通过`super`函数调用将它接收到的任何`options`传递给基本视图类。然后我们调用了一个Underscore函数命名为`bindAll`。Underscore的`bindAll`函数是一个实用函数，用于在类函数中绑定`this`的作用域到正确的上下文。让我们稍微探索一下代码，以使这一点更清楚。
- en: 'The `render` function will be called by the user of the `ContactCollectionView`,
    and simply calls the `renderChildItem` function for each model that it has in
    its collection. `this.collection.each` takes a single parameter, which is a callback
    function to be called for each model in the collection. We could have written
    this code as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`函数将被`ContactCollectionView`的用户调用，并简单地为它的集合中的每个模型调用`renderChildItem`函数。`this.collection.each`接受一个参数，这个参数是一个回调函数，用于对集合中的每个模型进行调用。我们可以将这段代码写成如下形式：'
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This version of the same code uses an anonymous function within the `each` function.
    In our previous code snippet, however, we have written the `renderChildItem` as
    a class function, instead of using an anonymous function. Because of JavaScript's
    lexical scoping rules, this slight change means that the `this` property would
    now refer to the function itself, and not the class instance. By using `_.bindAll(this,'renderChildItem')`,
    we have bound the variable `this` to be the class instance for all calls to `renderChildItem`.
    We can then use the `this` variable within the `renderChildItem` function, and
    `this.$el` will be correctly scoped to the instance of the class `ContactCollectionView`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的相同代码在`each`函数内部使用了一个匿名函数。然而，在我们之前的代码片段中，我们已经将`renderChildItem`写成了一个类函数，而不是使用匿名函数。由于JavaScript的词法作用域规则，这种细微的变化意味着`this`属性现在将指向函数本身，而不是类实例。通过使用`_.bindAll(this,'renderChildItem')`，我们已经将变量`this`绑定为所有对`renderChildItem`的调用的类实例。然后我们可以在`renderChildItem`函数内部使用`this`变量，`this.$el`将正确地作用于`ContactCollectionView`类的实例。
- en: 'Now for a couple of tests on this `ContactCollectionView` class:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在对这个`ContactCollectionView`类进行一些测试：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this code snippet, the `import` and `beforeAll` functions should be pretty
    easy to decipher, so let''s focus on the body of the actual test. Firstly, we
    are creating a `ContactCollectionView` instance, and passing in this `contactCollection`
    instance via the `{ collection: contactCollection}` property in the constructor.
    Backbone views that work with a single item use the `{ model: <modelName> }` property,
    and views that work with collections use the `{ collection: <collectionInstance>
    }` property. Our first test simply checks to see that the internal `collection`
    property does actually contain a collection whose `length` should be `2`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个代码片段中，`import`和`beforeAll`函数应该很容易理解，所以让我们专注于实际测试的主体。首先，我们创建了一个`ContactCollectionView`实例，并通过构造函数中的`{
    collection: contactCollection}`属性将这个`contactCollection`实例传递给它。使用单个项目的Backbone视图使用`{
    model: <modelName> }`属性，而使用集合的视图使用`{ collection: <collectionInstance> }`属性。我们的第一个测试简单地检查内部的`collection`属性是否确实包含一个`length`为`2`的集合。'
- en: 'We can now write a test to check that the `renderChildItem` function is called
    when we call the `render` function on our `ContactCollectionView` as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以写一个测试，检查当我们在`ContactCollectionView`上调用`render`函数时，`renderChildItem`函数是否被调用：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This test creates a view as we have seen previously, and then creates a spy
    on the `renderChildItem` function. To trigger this function to be called, we call
    the `render` function on our view instance. Finally, we just check that our spy
    has been called.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试创建了一个视图，就像我们之前看到的那样，然后在`renderChildItem`函数上创建了一个间谍。为了触发调用这个函数，我们在视图实例上调用`render`函数。最后，我们只是检查我们的间谍是否被调用了。
- en: 'Next, we can write a quick test to see if the HTML generated by the `render`
    function contains properties from our collection''s models:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以写一个快速测试，看看`render`函数生成的HTML是否包含我们集合模型的属性：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This test is very similar to our `ContactItemView` rendering tests, but instead
    uses the `ContactCollectionView` `render` function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试与我们的`ContactItemView`渲染测试非常相似，但是使用了`ContactCollectionView`的`render`函数。
- en: Creating an application
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个应用程序
- en: 'With the two Backbone views in place, we can now build a simple class to coordinate
    the loading of our collection, and the rendering of the full collection to the
    DOM:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个Backbone视图，我们现在可以构建一个简单的类来协调我们集合的加载和完整集合的渲染到DOM中：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Our code starts with imports for each of our various modules. We then create
    a class definition named `ContactViewApp`, and within this class, a method named
    `run`. This `run` method simply creates a new `ContactCollection`, and calls `fetch`
    to trigger Backbone to load the collection. This call to `fetch` then defines
    a `success` and `error` callback, each set to their relevant functions within
    the class.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码从各种模块的导入开始。然后我们创建了一个名为`ContactViewApp`的类定义，在这个类中，有一个名为`run`的方法。这个`run`方法简单地创建了一个新的`ContactCollection`，并调用`fetch`来触发Backbone加载集合。这次调用`fetch`然后定义了一个`success`和一个`error`回调，每个都设置为类内部的相关函数。
- en: When the `ContactCollection` fetch returns successfully, Backbone will invoke
    the `contactCollectionLoaded` function. Within this function, we simply create
    a `ContactCollectionView`, and then use jQuery to append the HTML returned via
    the `render` function to the DOM element `"#mainContent"`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ContactCollection`成功返回时，Backbone将调用`contactCollectionLoaded`函数。在这个函数中，我们简单地创建一个`ContactCollectionView`，然后使用jQuery将通过`render`函数返回的HTML附加到DOM元素`"#mainContent"`上。
- en: 'We can now create a web page to put everything together. The contents of our
    HTML page would now read as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个网页来把所有东西放在一起。我们的HTML页面的内容现在应该如下所示：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This page is very similar to the page we were using previously for running
    our tests. We have included an `app.css` link to allow for some styling, and we
    then call Require with a new config file, named `/tscode/app/AppConfig`. We also
    have a `div` within the body tag, with an id of `mainContent`, which will house
    the rendered HTML from our `ContactViewApp`. Now we need to create our `AppConfig.ts`
    file for Require to use, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面与我们之前用于运行测试的页面非常相似。我们包含了一个`app.css`链接以允许一些样式，然后调用Require并使用一个新的配置文件，名为`/tscode/app/AppConfig`。我们还在body标签内有一个id为`mainContent`的`div`，用来容纳我们的`ContactViewApp`返回的渲染HTML。现在我们需要创建我们的`AppConfig.ts`文件供Require使用，如下所示：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first thing to note in this code snippet, is that we have now included a
    `paths` reference to our `ContactViewApp`. The corresponding `shim` entry for
    `ContactViewApp` specifies that it has a dependency on `backbone`. Again, we have
    a global variable named `CONTACT_ITEM_SNIPPET`, and we then call the `require`
    function to load our `ContactViewApp` class, as well as the HTML snippet. Note
    too, that we are able to reference our `ContactViewApp` via the `app` argument
    in our anonymous function, and the HTML via the `contactItemSnippet` argument.
    To run the app, we simply create an instance of the `ContactViewApp` class, and
    call the `run` method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中要注意的第一件事是，我们现在已经在我们的`ContactViewApp`中包含了一个`paths`引用。`ContactViewApp`的相应`shim`条目指定它依赖于`backbone`。同样，我们有一个名为`CONTACT_ITEM_SNIPPET`的全局变量，然后我们调用`require`函数来加载我们的`ContactViewApp`类，以及HTML片段。还要注意，我们能够通过匿名函数中的`app`参数引用我们的`ContactViewApp`，并且通过`contactItemSnippet`参数引用HTML。要运行应用程序，我们只需创建`ContactViewApp`类的一个实例，并调用`run`方法。
- en: 'We should now be able to see the results of all of our hard work:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够看到我们所有辛苦工作的结果了：
- en: '![Creating an application](img/image_9665OS_07_04.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![创建一个应用程序](img/image_9665OS_07_04.jpg)'
- en: The Backbone app running with Require.js
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Require.js运行的Backbone应用程序
- en: Using jQuery plugins
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用jQuery插件
- en: 'To finish off our app, let''s use a jQuery plugin called **flip** ([http://lab.smashup.it/flip/](http://lab.smashup.it/flip/))
    that triggers an animation to rotate, or flip, the outer `div` of an item when
    it is clicked. Flip is typical of a range of jQuery plugins that can be applied
    to elements of our application. Before we can trigger a Flip animation, however,
    we will need to respond to a click event from the user within the `ContactItemView`
    as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 完成我们的应用程序，让我们使用一个名为**flip**的jQuery插件（[http://lab.smashup.it/flip/](http://lab.smashup.it/flip/)），触发一个动画来旋转或翻转项目的外部`div`。Flip是一系列可以应用于我们应用程序元素的jQuery插件的典型代表。然而，在触发Flip动画之前，我们需要在`ContactItemView`中响应用户的点击事件，如下所示：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this code snippet, we have now added an `onClicked` function to our `ContactItemView`
    class that simply pops up an `alert`. Note how we are able to reference the `model`
    property of the view class, in order to read properties from the underlying `Backbone.Model`
    that this class instance was created with. Within the `constructor`, we have also
    set `this.events` to a JavaScript object that has a single property: `''click''`.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，我们现在在我们的`ContactItemView`类中添加了一个`onClicked`函数，简单地弹出一个`alert`。请注意，我们能够引用视图类的`model`属性，以便从该类实例创建时使用的底层`Backbone.Model`中读取属性。在`constructor`中，我们还将`this.events`设置为一个具有一个属性`'click'`的JavaScript对象。
- en: 'The `''click''` property is set to our `onClicked` function, and will be invoked
    when the `ContactItemView` DOM element receives a user''s click event. With this
    in place, whenever we click on a rendered element in our page, we will receive
    an alert popup:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`''click''`属性设置为我们的`onClicked`函数，并在`ContactItemView` DOM元素接收到用户点击事件时调用。有了这个设置，每当我们在页面上点击渲染的元素时，我们将收到一个警报弹窗：'
- en: '![Using jQuery plugins](img/image_9665OS_07_05.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![使用jQuery插件](img/image_9665OS_07_05.jpg)'
- en: Alert popup on click event showing Model properties
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 点击事件显示模型属性的警报弹窗
- en: 'We can now turn our attention to using the Flip jQuery plugin. Flip relies
    on jQuery as well as jQueryUI, so we will need to install jQueryUI from NuGet
    as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以转向使用Flip jQuery插件。Flip依赖于jQuery和jQueryUI，因此我们需要从NuGet安装jQueryUI，如下所示：
- en: '[PRE40]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Flip itself does not have a NuGet package, so will need to download it, and
    included it in our project the old-fashioned way. There is also no DefinitelyTyped
    definition for Flip, so we will need to include one in our project as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Flip本身没有NuGet包，因此需要下载并以传统的方式将其包含在我们的项目中。Flip也没有DefinitelyTyped定义，因此我们需要在项目中包含一个如下所示的定义：
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This declaration file for the Flip plugin is very simply generated from the
    documentation on the website. As Flip is a jQuery plugin, it is available on any
    jQuery object that is reference by the `$( )` notation. Because of this, we must
    `extend` the JQuery type definition with our own – hence we create the jQuery
    interface with our two new functions: `flip` and `revertFlip`. The input to Flip
    has been defined as the `IFlipOptions` interface, as built from the website documentation.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Flip插件的声明文件非常简单，是从网站上的文档生成的。由于Flip是一个jQuery插件，它可以在通过`$( )`符号引用的任何jQuery对象上使用。因此，我们必须使用我们自己的`extend`
    JQuery类型定义 - 因此我们创建了带有我们两个新函数`flip`和`revertFlip`的jQuery接口。Flip的输入已被定义为`IFlipOptions`接口，根据网站文档构建。
- en: 'To load this library within Require, we modify our call to `require.config`
    as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Require中加载此库，我们修改对`require.config`的调用如下：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here, we have added two entries to our paths object: `jqueryui`, and `jqueryflip`.
    We have then added corresponding `shim` entries and specified the relevant dependencies.
    The line to note here, is the `exports` property on `jqueryflip`. We have specified
    that it must export to the `$` symbol. This is the default jQuery selector symbol,
    and all jQuery plugins must export to the `$` symbol, in order to be defined correctly
    when using Require. Our final change to the code is to use the `flip` function
    on the click event of `ContactItemView` as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经向我们的路径对象添加了两个条目：`jqueryui`和`jqueryflip`。然后，我们添加了相应的`shim`条目并指定了相关的依赖关系。这里需要注意的一行是`jqueryflip`上的`exports`属性。我们指定它必须导出到`$`符号。这是默认的jQuery选择器符号，所有jQuery插件必须导出到`$`符号，以便在使用Require时正确定义。我们对代码的最终更改是在`ContactItemView`的点击事件上使用`flip`函数，如下所示：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here we are referencing the `$el` element within the `Backbone.View`, which
    is a shorthand syntax for the jQuery selector. We are then calling the `flip`
    function, and specifying a top-to-bottom flip, to last 200 milliseconds. Running
    our page now, and clicking on a contact element will now trigger a flip animation:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引用了`Backbone.View`中的`$el`元素，这是jQuery选择器的简写语法。然后我们调用`flip`函数，并指定从上到下翻转，持续200毫秒。现在运行我们的页面，点击联系人元素将触发翻转动画：
- en: '![Using jQuery plugins](img/image_9665OS_07_06.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![使用jQuery插件](img/image_9665OS_07_06.jpg)'
- en: Flip.js in action flipping a div element
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Flip.js在操作中翻转div元素
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他用途均需版权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止并违反适用法律。保留所有权利。
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we have had a look at using modules – both CommonJs and AMD.
    We explored CommonJS modules as used within Node applications, and discussed the
    creation and usage of these modules with TypeScript. We then moved on to browser-based
    modules, and explored the use of AMD compilation in regards to Require. We built
    a very simple Backbone based application, complete with Jasmine unit tests, and
    then had a look at using the Text plugin with Require. We also incorporated a
    third-party jQuery plugin called Flip to provide some animation on our user interface.
    In our next chapter, we will tackle some object-oriented programming principles,
    and have a look at dependency injection and domain events.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经研究了使用模块 - 包括CommonJs和AMD。我们探讨了在Node应用程序中使用的CommonJS模块，并讨论了在TypeScript中创建和使用这些模块。然后，我们转向基于浏览器的模块，并探讨了与Require相关的AMD编译的使用。我们构建了一个非常简单的基于Backbone的应用程序，包括Jasmine单元测试，然后研究了在Require中使用Text插件。我们还整合了一个名为Flip的第三方jQuery插件，以在用户界面上提供一些动画。在下一章中，我们将探讨一些面向对象的编程原则，并研究依赖注入和领域事件。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他用途均需版权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止并违反适用法律。保留所有权利。
