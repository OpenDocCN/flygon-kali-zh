- en: Introducing Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Docker
- en: We will discuss how the modern Continuous Delivery process should look by introducing
    Docker, the technology that changed the IT industry and the way the servers are
    used.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论现代持续交付过程应该如何看待，引入Docker，这种改变了IT行业和服务器使用方式的技术。
- en: 'This chapter covers the following points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下内容：
- en: Introducing the idea of virtualization and containerization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍虚拟化和容器化的概念
- en: Installing Docker for different local and server environments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的本地和服务器环境中安装Docker
- en: Explaining the architecture of the Docker toolkit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Docker工具包的架构
- en: Building Docker images with Dockerfile and by committing changes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建Docker镜像并提交更改
- en: Running applications as Docker containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序作为Docker容器运行
- en: Configuring Docker networks and port forwarding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Docker网络和端口转发
- en: Introducing Docker volumes as a shared storage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Docker卷作为共享存储
- en: What is Docker?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Docker？
- en: 'Docker is an open source project designed to help with application deployment
    using software containers. This quote is from the official Docker page:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个旨在通过软件容器帮助应用程序部署的开源项目。这句话来自官方Docker页面：
- en: '"Docker containers wrap a piece of software in a complete filesystem that contains
    everything needed to run: code, runtime, system tools, system libraries - anything
    that can be installed on a server. This guarantees that the software will always
    run the same, regardless of its environment."'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “Docker容器将软件包装在一个完整的文件系统中，其中包含运行所需的一切：代码、运行时、系统工具、系统库 - 任何可以安装在服务器上的东西。这保证软件无论在什么环境下都能始终运行相同。”
- en: Docker, therefore, in a similar way as virtualization, allows packaging an application
    into an image that can be run everywhere.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Docker与虚拟化类似，允许将应用程序打包成可以在任何地方运行的镜像。
- en: Containerization versus virtualization
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器化与虚拟化
- en: 'Without Docker, isolation and other benefits can be achieved with the use of
    hardware virtualization, often called virtual machines. The most popular solutions
    are VirtualBox, VMware, and Parallels. A virtual machine emulates a computer architecture
    and provides the functionality of a physical computer. We can achieve complete
    isolation of applications if each of them is delivered and run as a separate virtual
    machine image. The following figure presents the concept of virtualization:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 没有Docker，可以使用硬件虚拟化来实现隔离和其他好处，通常称为虚拟机。最流行的解决方案是VirtualBox、VMware和Parallels。虚拟机模拟计算机架构，并提供物理计算机的功能。如果每个应用程序都作为单独的虚拟机镜像交付和运行，我们可以实现应用程序的完全隔离。以下图展示了虚拟化的概念：
- en: '![](assets/020d670e-74d0-41e8-af9d-8598b12046c2.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/020d670e-74d0-41e8-af9d-8598b12046c2.png)'
- en: 'Each application is launched as a separate image with all dependencies and
    a guest operating system. Images are run by the hypervisor, which emulates the
    physical computer architecture. This method of deployment is widely supported
    by many tools (such as Vagrant) and dedicated to development and testing environments.
    Virtualization, however, has three significant drawbacks:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都作为一个单独的镜像启动，具有所有依赖项和一个客户操作系统。镜像由模拟物理计算机架构的hypervisor运行。这种部署方法得到许多工具（如Vagrant）的广泛支持，并专门用于开发和测试环境。然而，虚拟化有三个重大缺点：
- en: '**Low performance**: The virtual machine emulates the whole computer architecture
    to run the guest operating system, so there is a significant overhead associated
    with each operation.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能低下**：虚拟机模拟整个计算机架构来运行客户操作系统，因此每个操作都会带来显着的开销。'
- en: '**High resource consumption**: Emulation requires a lot of resources and has
    to be done separately for each application. This is why, on a standard desktop
    machine, only a few applications can be run simultaneously.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高资源消耗**：模拟需要大量资源，并且必须针对每个应用程序单独进行。这就是为什么在标准桌面机器上只能同时运行几个应用程序。'
- en: '**Large image size**: Each application is delivered with a full operating system,
    so the deployment on a server implies sending and storing a large amount of data.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大的镜像大小**：每个应用程序都随着完整的操作系统交付，因此在服务器上部署意味着发送和存储大量数据。'
- en: 'The concept of containerization presents a different solution:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化的概念提出了一个不同的解决方案：
- en: '![](assets/41c0db73-c10e-42f2-8fec-f45e28ef52f4.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/41c0db73-c10e-42f2-8fec-f45e28ef52f4.png)'
- en: Each application is delivered together with its dependencies, but, without the
    operating system. Applications interface directly with the host operating system,
    so there is no additional layer of the guest operating system. It results in better
    performance and no waste of resources. Moreover, shipped Docker images are significantly
    smaller.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都与其依赖项一起交付，但没有操作系统。应用程序直接与主机操作系统接口，因此没有额外的客户操作系统层。这导致更好的性能和没有资源浪费。此外，交付的Docker镜像大小明显更小。
- en: Notice that in the case of containerization, the isolation happens at the level
    of the host operating system's processes. It doesn't mean, however, that the containers
    share their dependencies. Each of them has their own libraries in the right version,
    and if any of them is updated, it has no impact on the others. To achieve this,
    Docker Engine creates a set of Linux namespaces and control groups for the container.
    This is why the Docker security is based on the Linux kernel process isolation.
    This solution, although mature enough, could be considered slightly less secure
    than the complete operating system-based isolation offered by virtual machines.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在容器化的情况下，隔离发生在主机操作系统进程的级别。然而，这并不意味着容器共享它们的依赖关系。它们每个都有自己的正确版本的库，如果其中任何一个被更新，它对其他容器没有影响。为了实现这一点，Docker引擎为容器创建了一组Linux命名空间和控制组。这就是为什么Docker安全性基于Linux内核进程隔离。尽管这个解决方案已经足够成熟，但与虚拟机提供的完整操作系统级隔离相比，它可能被认为略微不够安全。
- en: The need for Docker
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker的需求
- en: Docker containerization solves a number of problems seen in traditional software
    delivery. Let's take a closer look.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器化解决了传统软件交付中出现的许多问题。让我们仔细看看。
- en: Environment
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境
- en: Installing and running software is complex. You need to decide about the operating
    system, resources, libraries, services, permissions, other software, and everything
    your application depends on. Then, you need to know how to install it. What's
    more, there may be some conflicting dependencies. What do you do then? What if
    your software needs an upgrade of a library but the other does not? In some companies,
    such issues are solved by having **classes of applications**, and each class is
    served by a dedicated server, for example, a server for web services with Java
    7, another one for batch jobs with Java 8, and so on. This solution, however,
    is not balanced in terms of resources and requires an army of IT operations teams
    to take care of all production and test servers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和运行软件是复杂的。您需要决定操作系统、资源、库、服务、权限、其他软件以及您的应用程序所依赖的一切。然后，您需要知道如何安装它。而且，可能会有一些冲突的依赖关系。那么你该怎么办？如果您的软件需要升级一个库，但其他软件不需要呢？在一些公司中，这些问题是通过拥有**应用程序类别**来解决的，每个类别由专用服务器提供服务，例如，一个用于具有Java
    7的Web服务的服务器，另一个用于具有Java 8的批处理作业，依此类推。然而，这种解决方案在资源方面不够平衡，并且需要一支IT运维团队来照顾所有的生产和测试服务器。
- en: Another problem with the environment complexity is that it often requires a
    specialist to run an application. A less technical person may have a hard time
    setting up MySQL, ODBC, or any other slightly more sophisticated tool. This is
    particularly true for applications not delivered as an operating system-specific
    binary but which require source code compilation or any other environment-specific
    configuration.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 环境复杂性的另一个问题是，通常需要专家来运行应用程序。一个不太懂技术的人可能会很难设置MySQL、ODBC或任何其他稍微复杂的工具。对于不作为特定操作系统二进制文件交付但需要源代码编译或任何其他特定环境配置的应用程序来说，这一点尤为真实。
- en: Isolation
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离
- en: Keep the workspace tidy. One application can change the behavior of the other
    one. Imagine what can happen. Applications share one filesystem, so if application
    A writes something to the wrong directory, application B reads the incorrect data.
    They share resources, so if there is a memory leak in application A, it can freeze
    not only itself but also application B. They share network interfaces, so if applications
    A and B both use port `8080`, one of them will crash. Isolation concerns the security
    aspects too. Running a buggy application or malicious software can cause damage
    to other applications. This is why it is a much safer approach to keep each application
    inside a separate sandbox, which limits the scope of damage impact to the application
    itself.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 保持工作区整洁。一个应用程序可能会改变另一个应用程序的行为。想象一下会发生什么。应用程序共享一个文件系统，因此如果应用程序A将某些内容写入错误的目录，应用程序B将读取不正确的数据。它们共享资源，因此如果应用程序A存在内存泄漏，它不仅会冻结自身，还会冻结应用程序B。它们共享网络接口，因此如果应用程序A和B都使用端口`8080`，其中一个将崩溃。隔离也涉及安全方面。运行有错误的应用程序或恶意软件可能会对其他应用程序造成损害。这就是为什么将每个应用程序保持在单独的沙盒中是一种更安全的方法，它限制了损害范围仅限于应用程序本身。
- en: Organizing applications
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织应用程序
- en: Servers often end up looking messy with a ton of running applications nobody
    knows anything about. How will you check what applications are running on the
    server and what dependencies each of them is using? They could depend on libraries,
    other applications, or tools. Without the exhaustive documentation, all we can
    do is look at the running processes and start guessing. Docker keeps things organized
    by having each application as a separate container that can be listed, searched,
    and monitored.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器通常会因为有大量运行的应用程序而变得混乱，而没有人知道这些应用程序是什么。你将如何检查服务器上运行的应用程序以及它们各自使用的依赖关系？它们可能依赖于库、其他应用程序或工具。如果没有详尽的文档，我们所能做的就是查看运行的进程并开始猜测。Docker通过将每个应用程序作为一个单独的容器来保持组织，这些容器可以列出、搜索和监视。
- en: Portability
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可移植性
- en: <q>Write once, run anywhere,</q> said the slogan while advertising the earliest
    versions of Java. Indeed, Java addresses the portability issue quite well; however,
    I can still think of a few cases where it fails, for example, the incompatible
    native dependencies or the older version of the Java runtime. Moreover, not all
    software is written in Java.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: “一次编写，到处运行”，这是Java最早版本的广告口号。的确，Java解决了可移植性问题；然而，我仍然可以想到一些它失败的情况，例如不兼容的本地依赖项或较旧版本的Java运行时。此外，并非所有软件都是用Java编写的。
- en: Docker moves the concept of portability one level higher; if the Docker version
    is compatible, then the shipped software works correctly regardless of the programming
    language, operating system, or environment configuration. Docker, then, can be
    expressed by the slogan <q>Ship the entire environment instead of just code.</q>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将可移植性的概念提升了一个层次；如果Docker版本兼容，那么所提供的软件将在编程语言、操作系统或环境配置方面都能正确运行。因此，Docker可以用“不仅仅是代码，而是整个环境”来表达。
- en: Kittens and cattle
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小猫和牛
- en: The difference between traditional software deployment and Docker-based deployment
    is often expressed with an analogy of kittens and cattle. Everybody likes kittens.
    Kittens are unique. Each has its own name and needs special treatment. Kittens
    are treated with emotion. We cry when they die. On the contrary, cattle exist
    only to satisfy our needs. Even the form cattle is singular since it's just a
    pack of animals treated together. No naming, no uniqueness. Surely, they are unique
    (the same as each server is unique), but it is irrelevant.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 传统软件部署和基于Docker的部署之间的区别通常用小猫和牛的类比来表达。每个人都喜欢小猫。小猫是独一无二的。每只小猫都有自己的名字，需要特殊对待。小猫是用情感对待的。它们死了我们会哭。相反，牛只存在来满足我们的需求。即使牛的形式是单数，因为它只是一群一起对待的动物。没有命名，没有独特性。当然，它们是独一无二的（就像每个服务器都是独一无二的），但这是无关紧要的。
- en: This is why the most straightforward explanation of the idea behind Docker is
    <q>Treat your servers like cattle, not pets.</q>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么对Docker背后的理念最直接的解释是<q>把你的服务器当作牛，而不是宠物。</q>
- en: Alternative containerization technologies
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代的容器化技术
- en: Docker is not the only containerization system available on the market. Actually,
    the first versions of Docker were based on the open source **LXC** (**Linux Containers**)
    system, which is an alternative platform for containers. Other known solutions
    are FreeBSD Jails, OpenVZ, and Solaris Containers. Docker, however, overtook all
    other systems because of its simplicity, good marketing, and startup approach.
    It works under most operating systems, allows you to do something useful in less
    than 15 minutes, has a lot of simple-to-use features, good tutorials, a great
    community, and probably the best logo in the IT industry.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Docker并不是市场上唯一的容器化系统。实际上，Docker的最初版本是基于开源的**LXC**（**Linux Containers**）系统的，这是一个容器的替代平台。其他已知的解决方案包括FreeBSD
    Jails、OpenVZ和Solaris Containers。然而，Docker因其简单性、良好的营销和创业方法而超越了所有其他系统。它适用于大多数操作系统，允许您在不到15分钟内做一些有用的事情，具有许多易于使用的功能，良好的教程，一个伟大的社区，可能是IT行业中最好的标志。
- en: Docker installation
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker安装
- en: Docker's installation process is quick and simple. Currently, it's supported
    on most Linux operating systems and a wide range of them have dedicated binaries
    provided. Mac and Windows are also well supported with native applications. However,
    it's important to understand that Docker is internally based on the Linux kernel
    and its specifics, and this is why, in the case of Mac and Windows, it uses virtual
    machines (xhyve for Mac and Hyper-V for Windows) to run the Docker Engine environment.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的安装过程快速简单。目前，它在大多数Linux操作系统上得到支持，并提供了专门的二进制文件。Mac和Windows也有很好的本地应用支持。然而，重要的是要理解，Docker在内部基于Linux内核及其特定性，这就是为什么在Mac和Windows的情况下，它使用虚拟机（Mac的xhyve和Windows的Hyper-V）来运行Docker引擎环境。
- en: Prerequisites for Docker
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker的先决条件
- en: Docker requirements are specific for each operating system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的要求针对每个操作系统都是特定的。
- en: '**Mac**:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mac**：'
- en: 2010 or newer model, with Intel’s hardware support for **memory management unit**
    (**MMU**) virtualization
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2010年或更新型号，具有英特尔对**内存管理单元**（**MMU**）虚拟化的硬件支持
- en: macOS 10.10.3 Yosemite or newer
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS 10.10.3 Yosemite或更新版本
- en: At least 4GB of RAM
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少4GB的RAM
- en: No VirtualBox prior to version 4.3.30 installed
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未安装早于4.3.30版本的VirtualBox
- en: '**Windows**:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows**：'
- en: 64-bit Windows 10 Pro
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64位Windows 10专业版
- en: The Hyper-V package enabled
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用了Hyper-V包
- en: '**Linux**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux**：'
- en: 64-bit architecture
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64位架构
- en: Linux kernel 3.10 or later
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux内核3.10或更高版本
- en: If your machine does not meet the requirements, then the solution is to use
    VirtualBox with the Ubuntu operating system installed. This workaround, even though
    it sounds complicated, is not necessarily the worst method, especially taking
    into consideration that the Docker Engine environment is virtualized anyway in
    the case of Mac and Windows. Furthermore, Ubuntu is one of the best-supported
    systems for using Docker.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的机器不符合要求，那么解决方案是使用安装了Ubuntu操作系统的VirtualBox。尽管这种解决方法听起来有些复杂，但并不一定是最糟糕的方法，特别是考虑到在Mac和Windows的情况下Docker引擎环境本身就是虚拟化的。此外，Ubuntu是使用Docker的最受支持的系统之一。
- en: All examples in this book have been tested on the Ubuntu 16.04 operating system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例都在Ubuntu 16.04操作系统上进行了测试。
- en: Installing on a local machine
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地机器上安装
- en: Dockers installation process is straightforward and very well described on its
    official pages.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Dockers的安装过程非常简单，并且在其官方页面上有很好的描述。
- en: Docker for Ubuntu
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ubuntu的Docker
- en: '[https://docs.docker.com/engine/installation/linux/ubuntulinux/](https://docs.docker.com/engine/installation/linux/ubuntulinux/)
    contains a guide on how to install Docker on an Ubuntu machine.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/engine/installation/linux/ubuntulinux/](https://docs.docker.com/engine/installation/linux/ubuntulinux/)
    包含了在Ubuntu机器上安装Docker的指南。'
- en: 'In the case of Ubuntu 16.04, I''ve executed the following commands:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu 16.04的情况下，我执行了以下命令：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After all operations are completed, Docker should be installed. However, at
    the moment, the only user allowed to use Docker commands is `root`. This means
    that the `sudo` keyword must precede every Docker command.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有操作完成后，Docker应该已安装。然而，目前唯一被允许使用Docker命令的用户是`root`。这意味着每个Docker命令前都必须加上`sudo`关键字。
- en: 'We can enable other users to use Docker by adding them to the `docker` group:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将他们添加到`docker`组来使其他用户使用Docker：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After a successful logout, everything is set up. With the latest command, however,
    we need to take some precautions not to give the Docker permissions to an unwanted
    user, and therefore create a vulnerability in the Docker Engine. This is particularly
    important in the case of installation on the server machine.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 成功注销后，一切都设置好了。然而，通过最新的命令，我们需要采取一些预防措施，以免将Docker权限赋予不需要的用户，从而在Docker引擎中创建漏洞。这在服务器机器上安装时尤为重要。
- en: Docker for Linux
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux的Docker
- en: '[https://docs.docker.com/engine/installation/linux/](https://docs.docker.com/engine/installation/linux/)
    contains installation guides for most Linux distributions.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/engine/installation/linux/](https://docs.docker.com/engine/installation/linux/)
    包含了大多数Linux发行版的安装指南。'
- en: Docker for Mac
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Mac的Docker
- en: '[https://docs.docker.com/docker-for-mac/](https://docs.docker.com/docker-for-mac/)
    contains a step-by-step guide on how to install Docker on a Mac machine. It is
    delivered together with a collection of Docker components:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/docker-for-mac/](https://docs.docker.com/docker-for-mac/)
    包含了在Mac机器上安装Docker的逐步指南。它与一系列Docker组件一起提供：'
- en: Virtual machine with Docker Engine
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有Docker引擎的虚拟机
- en: Docker Machine (a tool used to create Docker hosts on the virtual machine)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Machine（用于在虚拟机上创建Docker主机的工具）
- en: Docker Compose
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Docker client and server
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker客户端和服务器
- en: 'Kitematic: a GUI application'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kitematic：一个GUI应用程序
- en: The Docker Machine tool helps in installing and managing Docker Engine on Mac,
    Windows, on company networks, in data centers, and on cloud providers such as
    AWS or Digital Ocean.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Machine工具有助于在Mac、Windows、公司网络、数据中心以及AWS或Digital Ocean等云提供商上安装和管理Docker引擎。
- en: Docker for Windows
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows的Docker
- en: '[https://docs.docker.com/docker-for-windows/](https://docs.docker.com/docker-for-windows/)
    contains a step-by-step guide on how to install Docker on a Windows machine. It
    is delivered together with a collection of Docker components similar to Mac.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/docker-for-windows/](https://docs.docker.com/docker-for-windows/)
    包含了如何在Windows机器上安装Docker的逐步指南。它与一组类似于Mac的Docker组件一起提供。'
- en: The installation guides for all supported operating systems and cloud platforms
    can be found on the official Docker page, [https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有支持的操作系统和云平台的安装指南都可以在官方Docker页面上找到，[https://docs.docker.com/engine/installation/](https://docs.docker.com/engine/installation/)。
- en: Testing Docker installation
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Docker安装
- en: 'No matter which installation you''ve chosen (Mac, Windows, Ubuntu, Linux, or
    other), Docker should be set up and ready. The best way to test it is to run the
    `docker info` command. The output message should be similar to the following one:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择了哪种安装方式（Mac、Windows、Ubuntu、Linux或其他），Docker都应该已经设置好并准备就绪。测试的最佳方法是运行`docker
    info`命令。输出消息应该类似于以下内容：
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installing on a server
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在服务器上安装
- en: In order to use Docker over the network, it is possible to either take advantage
    of cloud platform providers or to manually install Docker on a dedicated server.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在网络上使用Docker，可以利用云平台提供商或在专用服务器上手动安装Docker。
- en: In the first case, the Docker configuration differs from one platform to another,
    but it is always very well described in dedicated tutorials. Most cloud platforms
    enable creating Docker hosts via user-friendly web interfaces or describe exact
    commands to execute on their servers.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，Docker配置因平台而异，但在专门的教程中都有很好的描述。大多数云平台都可以通过用户友好的网络界面创建Docker主机，或者描述在其服务器上执行的确切命令。
- en: The second case (installing Docker manually) requires, however, a few words
    of comment.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二种情况（手动安装Docker）需要一些评论。
- en: Dedicated server
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专用服务器
- en: Installing Docker manually on a server does not differ much from the local installation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上手动安装Docker与本地安装并没有太大区别。
- en: Two additional steps are required that include setting the Docker daemon to
    listen on the network socket and setting security certificates.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要两个额外的步骤，包括设置Docker守护程序以侦听网络套接字和设置安全证书。
- en: Let's start from the first step. By default, due to security reasons, Docker
    runs via a non-networked Unix socket that only allows local communication. It's
    necessary to add listening on the chosen network interface socket so that the
    external clients can connect. [https://docs.docker.com/engine/admin/](https://docs.docker.com/engine/admin/)
    describes in detail all the configuration steps needed for each Linux distribution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一步开始。出于安全原因，默认情况下，Docker通过非网络化的Unix套接字运行，只允许本地通信。必须添加监听所选网络接口套接字，以便外部客户端可以连接。[https://docs.docker.com/engine/admin/](https://docs.docker.com/engine/admin/)详细描述了每个Linux发行版所需的所有配置步骤。
- en: 'In the case of Ubuntu, the Docker daemon is configured by the systemd, so in
    order to change the configuration of how it''s started, we need to modify one
    line in the `/lib/systemd/system/docker.service` file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu的情况下，Docker守护程序由systemd配置，因此为了更改它的启动配置，我们需要修改`/lib/systemd/system/docker.service`文件中的一行：
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By changing this line, we enabled the access to the Docker daemon via the specified
    IP address. All the details on the systemd configuration can be found at [https://docs.docker.com/engine/admin/systemd/](https://docs.docker.com/engine/admin/systemd/).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更改这一行，我们启用了通过指定的IP地址访问Docker守护程序。有关systemd配置的所有细节可以在[https://docs.docker.com/engine/admin/systemd/](https://docs.docker.com/engine/admin/systemd/)找到。
- en: The second step of server configuration concerns the Docker security certificates.
    This enables only clients authenticated by a certificate to access the server.
    The comprehensive description of the Docker certificates configuration can be
    found at [https://docs.docker.com/engine/security/https/](https://docs.docker.com/engine/security/https/).
    This step isn't strictly required; however, unless your Docker daemon server is
    inside the firewalled network, it is essential.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器配置的第二步涉及Docker安全证书。这使得只有通过证书认证的客户端才能访问服务器。Docker证书配置的详细描述可以在[https://docs.docker.com/engine/security/https/](https://docs.docker.com/engine/security/https/)找到。这一步并不是严格要求的；然而，除非您的Docker守护程序服务器位于防火墙网络内，否则是必不可少的。
- en: If your Docker daemon is run inside the corporate network, you have to configure
    the HTTP proxy. The detailed description can be found at [https://docs.docker.com/engine/admin/systemd/](https://docs.docker.com/engine/admin/systemd/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的Docker守护程序在公司网络内运行，您必须配置HTTP代理。详细描述可以在[https://docs.docker.com/engine/admin/systemd/](https://docs.docker.com/engine/admin/systemd/)找到。
- en: Running Docker hello world>
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Docker hello world>
- en: The Docker environment is set up and ready, so we can start the first example.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Docker环境已经设置好，所以我们可以开始第一个示例。
- en: 'Enter the following command in your console:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中输入以下命令：
- en: '[PRE4]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Congratulations, you''ve just run your first Docker container. I hope you already
    feel how simple Docker is. Let''s examine step-by-step what happened under the
    hood:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您刚刚运行了您的第一个Docker容器。我希望您已经感受到Docker是多么简单。让我们逐步检查发生了什么：
- en: You ran the Docker client with the `run` command.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用`run`命令运行了Docker客户端。
- en: The Docker client contacted the Docker daemon asking to create a container from
    the image called `hello-world`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker客户端联系Docker守护程序，要求从名为`hello-world`的镜像创建一个容器。
- en: The Docker daemon checked if it contained the `hello-world` image locally and,
    since it didn't, requested the `hello-world` image from the remote Docker Hub
    registry.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker守护程序检查是否在本地包含`hello-world`镜像，由于没有，它从远程Docker Hub注册表请求了`hello-world`镜像。
- en: The Docker Hub registry contained the `hello-world` image, so it was pulled
    into the Docker daemon.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Hub注册表包含了`hello-world`镜像，因此它被拉入了Docker守护程序。
- en: The Docker daemon created a new container from the `hello-world` image that
    started the executable producing the output.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker守护程序从`hello-world`镜像创建了一个新的容器，启动了产生输出的可执行文件。
- en: The Docker daemon streamed this output to the Docker client.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker守护程序将此输出流式传输到Docker客户端。
- en: The Docker client sent it to your terminal.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker客户端将其发送到您的终端。
- en: 'The projected flow can be presented in the following diagram:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的流程可以用以下图表表示：
- en: '![](assets/991a6408-e39f-4455-80eb-b42d883c3a49.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/991a6408-e39f-4455-80eb-b42d883c3a49.png)'
- en: Let's look at each Docker component that was illustrated in this section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下在本节中所示的每个Docker组件。
- en: Docker components
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker组件
- en: 'The official Docker page says this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 官方Docker页面上说：
- en: '"Docker Engine is a client-server application that creates and manages Docker
    objects, such as images and containers."'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “Docker Engine是一个创建和管理Docker对象（如镜像和容器）的客户端-服务器应用程序。”
- en: Let's sort out what this means.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们搞清楚这意味着什么。
- en: Docker client and server
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker客户端和服务器
- en: 'Let''s look at a diagram that presents the Docker Engine architecture:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下展示Docker Engine架构的图表：
- en: '![](assets/22168b81-9283-421d-8295-d0af9d675db3.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/22168b81-9283-421d-8295-d0af9d675db3.png)'
- en: 'Docker Engine consists of three components:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Engine由三个组件组成：
- en: '**Docker Daemon** (server) running in the background'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker守护程序**（服务器）在后台运行'
- en: '**Docker Client** running as a command tool'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker客户端**作为命令工具运行'
- en: '**REST API**'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST API**'
- en: Installing Docker Engine means installing all the components so that the Docker
    daemon runs on our computer all the time as a service. In the case of the `hello-world`
    example, we used the Docker client to interact with the Docker daemon; however,
    we could do exactly the same using REST API. Also, in the case of the hello-world
    example, we connected to the local Docker daemon; however, we could use the same
    client to interact with the Docker daemon running on a remote machine.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker Engine意味着安装所有组件，以便Docker守护程序作为服务在我们的计算机上运行。在`hello-world`示例中，我们使用Docker客户端与Docker守护程序交互；但是，我们也可以使用REST
    API来做完全相同的事情。同样，在hello-world示例中，我们连接到本地Docker守护程序；但是，我们也可以使用相同的客户端与远程机器上运行的Docker守护程序交互。
- en: 'To run the Docker container on a remote machine, you can use the `-H` option:
     `docker -H <server_ip>:2375 run hello-world`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要在远程机器上运行Docker容器，可以使用`-H`选项：`docker -H <server_ip>:2375 run hello-world`
- en: Docker images and containers
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker镜像和容器
- en: An image is a stateless building block in the Docker world. You can imagine
    an image as a collection of all files necessary to run your application together
    with the recipe on how to run it. The image is stateless, so you can send it over
    the network, store it in the registry, name it, version it, and save it as a file.
    Images are layered, which means that you can build an image on top of another
    image.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker世界中，镜像是一个无状态的构建块。您可以将镜像想象为运行应用程序所需的所有文件的集合，以及运行它的方法。镜像是无状态的，因此可以通过网络发送它，将其存储在注册表中，命名它，对其进行版本控制，并将其保存为文件。镜像是分层的，这意味着可以在另一个镜像的基础上构建镜像。
- en: A container is a running instance of an image. We can create many containers
    from the same image if we want to have many instances of the same application.
    Since containers are stateful, we can interact with them and make changes to their
    states.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是镜像的运行实例。如果我们想要多个相同应用的实例，我们可以从同一个镜像创建多个容器。由于容器是有状态的，我们可以与它们交互并更改它们的状态。
- en: 'Let''s look at the example of a container and the image layers structure:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个容器和镜像层结构的例子：
- en: '![](assets/0099e866-f813-47d3-a4b7-b34fb88f722b.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0099e866-f813-47d3-a4b7-b34fb88f722b.png)'
- en: At the bottom, there is always the base image. In most cases, it represents
    an operating system, and we build our images on top of the existing base images.
    It's technically possible to create own base images however, this is rarely needed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 底部始终是基础镜像。在大多数情况下，它代表一个操作系统，我们在现有的基础镜像上构建我们的镜像。从技术上讲，可以创建自己的基础镜像，但这很少需要。
- en: In our example, the `ubuntu` base image provides all the capabilities of the
    Ubuntu operating system. The `add git` image adds the Git toolkit. Then, there
    is an image adding the JDK environment. Finally, on the top, there is a container
    created from the `add JDK` image. Such container is able, for example, to download
    a Java project from the GitHub repository and compile it to a JAR file. As a result,
    we can use this container to compile and run Java projects without installing
    any tools on our operating system.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`ubuntu`基础镜像提供了Ubuntu操作系统的所有功能。`add git`镜像添加了Git工具包。然后，有一个添加了JDK环境的镜像。最后，在顶部，有一个从`add
    JDK`镜像创建的容器。这样的容器能够从GitHub仓库下载Java项目并将其编译为JAR文件。因此，我们可以使用这个容器来编译和运行Java项目，而无需在我们的操作系统上安装任何工具。
- en: 'It is important to notice that layering is a very smart mechanism to save bandwidth
    and storage. Imagine that we have an application that is also based on `ubuntu`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，分层是一种非常聪明的机制，可以节省带宽和存储空间。想象一下，我们的应用程序也是基于`ubuntu`：
- en: '![](assets/26c3a1aa-7f15-49e9-9c27-e5a2ed80fbdb.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/26c3a1aa-7f15-49e9-9c27-e5a2ed80fbdb.png)'
- en: This time we will use the Python interpreter. While installing the `add python`
    image, the Docker daemon will note that the `ubuntu` image is already installed,
    and what it needs to do is only to add the `python` layer, which is very small.
    So, the `ubuntu` image is a dependency that is reused. The same if we would like
    to deploy our image in the network. When we deploy the Git and JDK application,
    we need to send the whole `ubuntu` image. However, while subsequently deploying
    the `python` application, we need to send just the small `add python` layer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将使用Python解释器。在安装`add python`镜像时，Docker守护程序将注意到`ubuntu`镜像已经安装，并且它需要做的只是添加一个非常小的`python`层。因此，`ubuntu`镜像是一个被重复使用的依赖项。如果我们想要在网络中部署我们的镜像，情况也是一样的。当我们部署Git和JDK应用程序时，我们需要发送整个`ubuntu`镜像。然而，随后部署`python`应用程序时，我们只需要发送一个小的`add
    python`层。
- en: Docker applications
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker应用程序
- en: A lot of applications are provided in the form of Docker images that can be
    downloaded from the internet. If we knew the image name, then it would be enough
    to run it in the same way we did with the hello world example. How can we find
    the desired application image on the Docker Hub?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序以Docker镜像的形式提供，可以从互联网上下载。如果我们知道镜像名称，那么只需以与hello world示例相同的方式运行它就足够了。我们如何在Docker
    Hub上找到所需的应用程序镜像呢？
- en: 'Let''s take MongoDB as an example.  If we like to find it on the Docker Hub,
    we have two options:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以MongoDB为例。如果我们想在Docker Hub上找到它，我们有两个选项：
- en: Search on the Docker Hub Explore page ([https://hub.docker.com/explore/](https://hub.docker.com/explore/))
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker Hub探索页面上搜索（[https://hub.docker.com/explore/](https://hub.docker.com/explore/)）
- en: Use the `docker search` command
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker search`命令
- en: 'In the second case, we can perform the following operation:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们可以执行以下操作：
- en: '[PRE5]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are many interesting options. How do we choose the best image? Usually,
    the most appealing one is the one without any prefix, since it means that it''s
    an official Docker Hub image and should be therefore stable and maintained. The
    images with prefixes are unofficial, usually maintained as open source projects.
    In our case, the best choice seems to be `mongo`, so in order to run the MongoDB
    server, we can run the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多有趣的选项。我们如何选择最佳镜像？通常，最吸引人的是没有任何前缀的镜像，因为这意味着它是一个官方的Docker Hub镜像，因此应该是稳定和维护的。带有前缀的镜像是非官方的，通常作为开源项目进行维护。在我们的情况下，最好的选择似乎是`mongo`，因此为了运行MongoDB服务器，我们可以运行以下命令：
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's all, MongoDB has started. Running applications as Docker containers is
    that simple because we don't need to think of any dependencies; they are all delivered
    together with the image.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，MongoDB已经启动了。作为Docker容器运行应用程序是如此简单，因为我们不需要考虑任何依赖项；它们都与镜像一起提供。
- en: On the Docker Hub service, you can find a lot of applications; they store more
    than 100,000 different images.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Hub服务上，你可以找到很多应用程序；它们存储了超过100,000个不同的镜像。
- en: Building images
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建镜像
- en: Docker can be treated as a useful tool to run applications; however, the real
    power lies in building own Docker images that wrap the programs together with
    the environment. In this section, we will see how to do this using two different
    methods, the Docker `commit` command and the Dockerfile automated build.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Docker可以被视为一个有用的工具来运行应用程序；然而，真正的力量在于构建自己的Docker镜像，将程序与环境一起打包。在本节中，我们将看到如何使用两种不同的方法来做到这一点，即Docker
    `commit`命令和Dockerfile自动构建。
- en: Docker commit
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker commit
- en: 'Let''s start with an example and prepare an image with the Git and JDK toolkits.
    We will use Ubuntu 16.04 as a base image. There is no need to create it; most
    base images are available in the Docker Hub registry:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个例子开始，使用Git和JDK工具包准备一个镜像。我们将使用Ubuntu 16.04作为基础镜像。无需创建它；大多数基础镜像都可以在Docker
    Hub注册表中找到：
- en: 'Run a container from the `ubuntu:16.04` and connect it to its command line:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ubuntu:16.04`运行一个容器，并连接到其命令行：
- en: '[PRE7]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We've pulled the `ubuntu:16.04` image and run it as a container and then called
    the `/bin/bash` command in an interactive way (`-i` flag). You should see the
    terminal of the container. Since containers are stateful and writable, we can
    do anything we want in its terminal.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拉取了`ubuntu:16.04`镜像，并将其作为容器运行，然后以交互方式（-i标志）调用了`/bin/bash`命令。您应该看到容器的终端。由于容器是有状态的和可写的，我们可以在其终端中做任何我们想做的事情。
- en: 'Install the Git toolkit:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Git工具包：
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Check if the Git toolkit is installed:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Git工具包是否已安装：
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Exit the container:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出容器：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Check what has changed in the container comparing it to the `ubuntu` image:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查容器中的更改，将其与`ubuntu`镜像进行比较：
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The command should print a list of all files changed in the container.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应打印出容器中所有更改的文件列表。
- en: 'Commit the container to the image:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将容器提交到镜像：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ve just created our first Docker image. Let''s list all the images of our
    Docker host to see if the image is present:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了我们的第一个Docker镜像。让我们列出Docker主机上的所有镜像，看看镜像是否存在：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As expected, we see `hello-world`, `mongo` (installed before), `ubuntu` (base
    image pulled from Docker Hub), and freshly built `ubuntu_with_git`. By the way,
    we can observe the size of each image that corresponds to what we've installed
    on the image.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们看到了`hello-world`，`mongo`（之前安装的），`ubuntu`（从Docker Hub拉取的基础镜像）和新构建的`ubuntu_with_git`。顺便说一句，我们可以观察到每个镜像的大小，它对应于我们在镜像上安装的内容。
- en: 'Now, if we create a container from the image, it will have the Git tool installed:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们从镜像创建一个容器，它将安装Git工具：
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Using the exact same method, we can build `ubuntu_with_git_and_jdk` on top
    of the `ubuntu_with_git` image:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完全相同的方法，我们可以在`ubuntu_with_git`镜像的基础上构建`ubuntu_with_git_and_jdk`：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Dockerfile
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile
- en: Creating each Docker image manually with the commit command could be laborious,
    especially in the case of build automation and the Continuous Delivery process.
    Luckily, there is a built-in language to specify all the instructions that should
    be executed to build the Docker image.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建每个Docker镜像并使用commit命令可能会很费力，特别是在构建自动化和持续交付过程中。幸运的是，有一种内置语言可以指定构建Docker镜像时应执行的所有指令。
- en: Let's start with an example similar to the one with Git and JDK. This time,
    we will prepare the `ubuntu_with_python` image.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个类似于Git和JDK的例子开始。这次，我们将准备`ubuntu_with_python`镜像。
- en: 'Create a new directory and a file called `Dockerfile` with the following content:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新目录和一个名为`Dockerfile`的文件，内容如下：
- en: '[PRE16]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the command to create the `ubuntu_with_python` image:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行命令以创建`ubuntu_with_python`镜像：
- en: '[PRE17]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check that the image was created:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查镜像是否已创建：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can now create a container from the image and check that the Python interpreter
    exists in exactly the same way we did after executing the `docker commit` command.
    Note that the `ubuntu` image is listed only once even though it's the base image
    for both `ubuntu_with_git` and `ubuntu_with_python`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从镜像创建一个容器，并检查Python解释器是否存在，方式与执行`docker commit`命令后的方式完全相同。请注意，即使`ubuntu`镜像是`ubuntu_with_git`和`ubuntu_with_python`的基础镜像，它也只列出一次。
- en: 'In this example, we used the first two Dockerfile instructions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了前两个Dockerfile指令：
- en: '`FROM` defines the image on top of which the new image will be built'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`定义了新镜像将基于的镜像'
- en: '`RUN` specifies the commands to run inside the container'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`指定在容器内部运行的命令'
- en: 'All Dockerfile instructions can be found on the official Docker page at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
    The most widely-used instructions are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Dockerfile指令都可以在官方Docker页面[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)上找到。最常用的指令如下：
- en: '`MAINTAINER` defines the metainformation about the author'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAINTAINER`定义了关于作者的元信息'
- en: '`COPY` copies a file or a directory into the filesystem of the image'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY`将文件或目录复制到镜像的文件系统中'
- en: '`ENTRYPOINT` defines which application should be run in the executable container'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`定义了可执行容器中应该运行哪个应用程序'
- en: A complete guide of all Dockerfile instructions can be found on the official
    Docker page at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方Docker页面[https://docs.docker.com/engine/reference/builder/]上找到所有Dockerfile指令的完整指南。
- en: Complete Docker application
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整的Docker应用程序
- en: We already have all the information necessary to build a fully working application
    as a Docker image. As an example, we will prepare, step by step, a simple Python
    hello world program. The same steps exist always, no matter what environment or
    programming language we use.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有构建完全可工作的应用程序作为Docker镜像所需的所有信息。例如，我们将逐步准备一个简单的Python hello world程序。无论我们使用什么环境或编程语言，这些步骤都是相同的。
- en: Write the application
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写应用程序
- en: 'Create a new directory and inside this directory, a `hello.py` file with the
    following content:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新目录，在这个目录中，创建一个名为`hello.py`的文件，内容如下：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Close the file. This is the source code of our application.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭文件。这是我们应用程序的源代码。
- en: Prepare the environment
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备环境
- en: 'Our environment will be expressed in the Dockerfile. We need the instructions
    to define:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的环境将在Dockerfile中表示。我们需要定义以下指令：
- en: what base image should be used
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该使用哪个基础镜像
- en: (optionally) who the maintainer is
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）维护者是谁
- en: how to install the Python interpreter
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安装Python解释器
- en: how to include  `hello.py` in the image
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将`hello.py`包含在镜像中
- en: how to start the application
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何启动应用程序
- en: 'In the same directory, create the Dockerfile:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录中，创建Dockerfile：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Build the image
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建镜像
- en: 'Now, we can build the image exactly the same way we did before:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以以与之前完全相同的方式构建镜像：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run the application
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'We run the application by running the container:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过运行容器来运行应用程序：
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You should see the friendly Hello World from Python! message. The most interesting
    thing in this example is that we are able to run the application written in Python
    without having the Python interpreter installed in our host system. This is possible
    because the application packed as an image has all the environment needed inside.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到友好的Hello World from Python!消息。这个例子中最有趣的是，我们能够在没有在主机系统中安装Python解释器的情况下运行Python编写的应用程序。这是因为作为镜像打包的应用程序在内部具有所需的所有环境。
- en: An image with the Python interpreter already exists in the Docker Hub service,
    so in the real-life scenario, it would be enough to use it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器的镜像已经存在于Docker Hub服务中，因此在实际情况下，使用它就足够了。
- en: Environment variables
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境变量
- en: We've run our first home-made Docker application. However, what if the execution
    of the application should depend on some conditions?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经运行了我们的第一个自制Docker应用程序。但是，如果应用程序的执行应该取决于一些条件呢？
- en: For example, in the case of the production server, we would like to print `Hello`
    to the logs, not to the console, or we may want to have different dependent services
    during the testing phase and the production phase. One solution would be to prepare
    a separate Dockerfile for each case; however, there is a better way, environment
    variables.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在生产服务器的情况下，我们希望将`Hello`打印到日志中，而不是控制台，或者我们可能希望在测试阶段和生产阶段有不同的依赖服务。一个解决方案是为每种情况准备一个单独的Dockerfile；然而，还有一个更好的方法，即环境变量。
- en: 'Let''s change our hello world application to print `Hello World from` `<name_passed_as_environment_variable>
    !`. In order to do this, we need to proceed with the following steps:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的hello world应用程序更改为打印`Hello World from` `<name_passed_as_environment_variable>
    !`。为了做到这一点，我们需要按照以下步骤进行：
- en: 'Change the Python script to use the environment variable:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改Python脚本以使用环境变量：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Build the image:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建镜像：
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the container passing environment variable:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行传递环境变量的容器：
- en: '[PRE25]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternatively, we can define the environment variable value in Dockerfile,
    for example:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，我们可以在Dockerfile中定义环境变量的值，例如：
- en: '[PRE26]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then, we can run the container without specifying the `-e` option.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以运行容器而不指定`-e`选项。
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Environment variables are especially useful when we need to have different versions
    of the Docker container depending on its purpose, for example, to have separate
    profiles for production and testing servers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要根据其用途拥有Docker容器的不同版本时，例如，为生产和测试服务器拥有单独的配置文件时，环境变量尤其有用。
- en: If the environment variable is defined both in Dockerfile and as a flag, then
    the command flag takes precedence.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果环境变量在Dockerfile和标志中都有定义，那么命令标志优先。
- en: Docker container states
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker容器状态
- en: 'Every application we''ve run so far was supposed to do some work and stop.
    For example, we''ve printed `Hello from Docker!` and exited. There are, however,
    applications that should run continuously such as services. To run a container
    in the background, we can use the `-d` (`--detach`) option. Let''s try it with
    the `ubuntu` image:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们运行的每个应用程序都应该做一些工作然后停止。例如，我们打印了`Hello from Docker!`然后退出。但是，有些应用程序应该持续运行，比如服务。要在后台运行容器，我们可以使用`-d`（`--detach`）选项。让我们尝试一下`ubuntu`镜像：
- en: '[PRE28]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This command started the Ubuntu container but did not attach the console to
    it. We can see that it''s running using the following command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令启动了Ubuntu容器，但没有将控制台附加到它上面。我们可以使用以下命令看到它正在运行：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This command prints all containers that are in the running state. What about
    our old, already-exited containers? We can find them by printing all containers:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令打印出所有处于运行状态的容器。那么我们的旧容器呢，已经退出了？我们可以通过打印所有容器来找到它们：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that all the old containers are in the exited state. There are two more
    states we haven''t observed yet: paused and restarting.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有旧容器都处于退出状态。我们还没有观察到的状态有两种：暂停和重新启动。
- en: 'All of the states and the transitions between them are presented in the following
    diagram:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 所有状态及其之间的转换都在以下图表中显示：
- en: '![](assets/9b56cc40-6571-4e7b-98f0-7617455661b3.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9b56cc40-6571-4e7b-98f0-7617455661b3.png)'
- en: Pausing Docker containers is very rare, and technically, it's realized by freezing
    the processes using the SIGSTOP signal. Restarting is a temporary state when the
    container is run with the `--restart` option to define the restarting strategy
    (the Docker daemon is able to automatically restart the container in case of failure).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停Docker容器非常罕见，从技术上讲，它是通过使用SIGSTOP信号冻结进程来实现的。重新启动是一个临时状态，当容器使用`--restart`选项运行以定义重新启动策略时（Docker守护程序能够在发生故障时自动重新启动容器）。
- en: The diagram also shows the Docker commands used to change the Docker container
    state from one to another.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表还显示了用于将Docker容器状态从一个状态更改为另一个状态的Docker命令。
- en: 'For example, we can stop the running Ubuntu container:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以停止正在运行的Ubuntu容器：
- en: '[PRE31]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We always used the `docker run` command to create and start the container; however,
    it's possible to just create the container without starting it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用`docker run`命令来创建和启动容器；但是，也可以只创建容器而不启动它。
- en: Docker networking
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker网络
- en: Most applications these days do not run in isolation but need to communicate
    with other systems over the network. If we want to run a website, web service,
    database, or a cache server inside a Docker container, then we need to understand
    at least the basics of Docker networking.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数应用程序不是独立运行的，而是需要通过网络与其他系统进行通信。如果我们想在Docker容器内运行网站、网络服务、数据库或缓存服务器，那么我们需要至少了解Docker网络的基础知识。
- en: Running services
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行服务
- en: 'Let''s start with a simple example, and run a Tomcat server directly from Docker
    Hub:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始，直接从Docker Hub运行Tomcat服务器：
- en: '[PRE32]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tomcat is a web application server whose user interface can be accessed by the
    port `8080`. Therefore, if we installed Tomcat on our machine, we could browse
    it at `http://localhost:8080`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Tomcat是一个Web应用程序服务器，其用户界面可以通过端口`8080`访问。因此，如果我们在本机安装了Tomcat，我们可以在`http://localhost:8080`上浏览它。
- en: 'In our case, however, Tomcat is running inside the Docker container. We started
    it the same way we did with the first `Hello World` example. We can see it''s
    running:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下，Tomcat是在Docker容器内运行的。我们以与第一个“Hello World”示例相同的方式启动了它。我们可以看到它正在运行：
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since it''s run as a daemon (with the `-d` option), we don''t see the logs
    in the console right away. We can, however, access it by executing the following
    code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是作为守护进程运行的（使用`-d`选项），我们无法立即在控制台中看到日志。然而，我们可以通过执行以下代码来访问它：
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If there are no errors, we should see a lot of logs that concludes Tomcat has
    been started and is accessible via port `8080`. We can try going to `http://localhost:8080`, but
    we won't be able to connect. The reason for this is that Tomcat has been started
    inside the container and we're trying to reach it from the outside. In other words,
    we can reach it only if we connect with the command to the console in the container
    and check it there. How to make the running Tomcat accessible from outside?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，我们应该会看到很多日志，说明Tomcat已经启动，并且可以通过端口`8080`访问。我们可以尝试访问`http://localhost:8080`，但是我们无法连接。原因是Tomcat已经在容器内启动，我们试图从外部访问它。换句话说，我们只能在连接到容器中的控制台并在那里检查时才能访问它。如何使正在运行的Tomcat可以从外部访问呢？
- en: 'We need to start the container specifying the port mapping with the  `-p` (`--publish`)
    flag:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要启动容器并指定端口映射，使用`-p`（`--publish`）标志：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So, let''s first stop the running container and start a new one:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先停止正在运行的容器并启动一个新的容器：
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: After waiting a few seconds, Tomcat must have started and we should be able
    to open its page, `http://localhost:8080`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 等待几秒钟后，Tomcat必须已经启动，我们应该能够打开它的页面，`http://localhost:8080`。
- en: '![](assets/5a754575-bd73-41d5-9f7c-01590ca4ecb7.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5a754575-bd73-41d5-9f7c-01590ca4ecb7.png)'
- en: Such a simple port mapping command is sufficient in most common Docker use cases.
    We are able to deploy (micro) services as Docker containers and expose their ports
    to enable communication. However, let's dive a little deeper into what happened
    under the hood.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数常见的Docker使用情况下，这样简单的端口映射命令就足够了。我们能够将（微）服务部署为Docker容器，并公开它们的端口以启用通信。然而，让我们深入了解一下发生在幕后的情况。
- en: Docker allows publishing to the specified host network interface with `-p <ip>:<host_port>:<container_port>`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Docker允许使用`-p <ip>:<host_port>:<container_port>`将指定的主机网络接口发布出去。
- en: Container networks
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器网络
- en: We have connected to the application running inside the container. In fact,
    the connection is two-way, because if you remember our previous examples, we executed
    the `apt-get install` commands from inside and the packages were downloaded from
    the internet. How is this possible?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经连接到容器内运行的应用程序。事实上，这种连接是双向的，因为如果你还记得我们之前的例子，我们是从内部执行`apt-get install`命令，并且包是从互联网下载的。这是如何可能的呢？
- en: 'If you check the network interfaces on your machine, you can see that one of
    the interfaces is called `docker0`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查您的机器上的网络接口，您会看到其中一个接口被称为`docker0`：
- en: '[PRE37]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `docker0` interface is created by the Docker daemon in order to connect
    with the Docker container. Now, we can see what interfaces are created inside
    the Docker container with the `docker inspect` command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker0`接口是由Docker守护程序创建的，以便与Docker容器连接。现在，我们可以使用`docker inspect`命令查看Docker容器内创建的接口：'
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It prints all the information about the container configuration in the JSON
    format. Among others, we can find the part related to the network settings:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 它以JSON格式打印有关容器配置的所有信息。其中，我们可以找到与网络设置相关的部分。
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In order to filter the `docker inspect` response, we can use the `--format` option,
    for example, `docker inspect --format '{{ .NetworkSettings.IPAddress }}' <container_id>`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了过滤`docker inspect`的响应，我们可以使用`--format`选项，例如，`docker inspect --format '{{ .NetworkSettings.IPAddress
    }}' <container_id>`。
- en: We can observe that the Docker container has the IP address `172.17.0.2` and
    it communicates with the Docker host with the IP address `172.17.0.1`. This means
    that in our previous example, we could access the Tomcat server even without the
    port forwarding, using the address `http://172.17.0.2:8080`. Nevertheless, in
    most cases, we run the Docker container on a server machine and want to expose
    it outside, so we need to use the `-p` option.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到Docker容器的IP地址为`172.17.0.2`，并且它与具有IP地址`172.17.0.1`的Docker主机进行通信。这意味着在我们之前的示例中，即使没有端口转发，我们也可以访问Tomcat服务器，使用地址`http://172.17.0.2:8080`。然而，在大多数情况下，我们在服务器机器上运行Docker容器并希望将其暴露到外部，因此我们需要使用`-p`选项。
- en: 'Note that by default, the containers are protected by the host''s firewall
    system and don''t open any routes from external systems. We can change this default
    behavior by playing with the `--network` flag and setting it as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，容器受主机防火墙系统保护，并且不会从外部系统打开任何路由。我们可以通过使用`--network`标志并将其设置为以下内容来更改此默认行为：
- en: '`bridge` (default): network via the default Docker bridge'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bridge`（默认）：通过默认Docker桥接网络'
- en: '`none`: no network'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`：无网络'
- en: '`container`: network joined with the other (specified) container'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container`：与其他（指定的）容器连接的网络'
- en: '`host`: host network (no firewall)'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`：主机网络（无防火墙）'
- en: 'The different networks can be listed and managed by the `docker network` command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的网络可以通过`docker network`命令列出和管理：
- en: '[PRE40]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If we specify `none` as the network, then we will not be able to connect to
    the container, and vice versa; the container has no network access to the external
    world. The `host` option makes the container network interfaces identical to the
    host. They share the same IP addresses, so everything started on the container
    is visible outside. The most often used option is the default one (`bridge`) because
    it lets us define explicitly which ports should be published. It is both secure
    and accessible.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`none`指定为网络，则将无法连接到容器，反之亦然；容器无法访问外部世界。`host`选项使容器网络接口与主机相同。它们共享相同的IP地址，因此容器上启动的所有内容在外部可见。最常用的选项是默认选项（`bridge`），因为它允许我们明确定义应发布哪些端口。它既安全又可访问。
- en: Exposing container ports
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露容器端口
- en: 'We mentioned a few times that the container exposes the port. In fact, if we
    dug deeper into the Tomcat image on GitHub ([https://github.com/docker-library/tomcat](https://github.com/docker-library/tomcat)),
    we can notice the following line in the Dockerfile:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们多次提到容器暴露端口。实际上，如果我们深入研究GitHub上的Tomcat镜像（[https://github.com/docker-library/tomcat](https://github.com/docker-library/tomcat)），我们可以注意到Dockerfile中的以下行：
- en: '[PRE41]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This Dockerfile instruction expresses that the port 8080 should be exposed from
    the container. However, as we have already seen, this doesn't mean that the port
    is automatically published. The EXPOSE instruction only informs the users which
    ports they should publish.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Dockerfile指令表示应该从容器中公开端口8080。然而，正如我们已经看到的，这并不意味着端口会自动发布。EXPOSE指令只是通知用户应该发布哪些端口。
- en: Automatic port assignment
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动端口分配
- en: 'Let''s try to run the second Tomcat container without stopping the first one:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在不停止第一个Tomcat容器的情况下运行第二个Tomcat容器：
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This error may be common. In such cases, we have to either take care of the
    uniqueness of the ports on our own or let Docker assign the ports automatically
    using one of the following versions of the `publish` command:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误可能很常见。在这种情况下，我们要么自己负责端口的唯一性，要么让Docker使用`publish`命令的以下版本自动分配端口：
- en: '`-p <container_port>`: publish the container port to the unused host port'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -p <container_port>：将容器端口发布到未使用的主机端口
- en: '`-P` (`--publish-all`): publish all ports exposed by the container to the unused
    host ports:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-P`（`--publish-all`）：将容器公开的所有端口发布到未使用的主机端口：'
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can see that the second Tomcat has been published to port `32772`, so it
    can be browsed at `http://localhost:32772`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到第二个Tomcat已发布到端口`32772`，因此可以在`http://localhost:32772`上浏览。
- en: Using Docker volumes
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker卷
- en: Imagine that you would like to run the database as a container. You can start
    such a container and enter the data. Where is it stored? What happens when you
    stop the container or remove it? You can start the new one, but the database will
    be empty again. Unless it's your testing environment, you don't expect such a
    scenario.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想将数据库作为容器运行。您可以启动这样一个容器并输入数据。它存储在哪里？当您停止容器或删除它时会发生什么？您可以启动新的容器，但数据库将再次为空。除非这是您的测试环境，您不会期望这样的情况发生。
- en: 'Docker volume is the Docker host''s directory mounted inside the container.
    It allows the container to write to the host''s filesystem as it was writing to
    its own. The mechanism is presented in the following diagram:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Docker卷是Docker主机的目录，挂载在容器内部。它允许容器像写入自己的文件系统一样写入主机的文件系统。该机制如下图所示：
- en: '![](assets/b175c0eb-1e9a-4d07-8f40-8ec867942345.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b175c0eb-1e9a-4d07-8f40-8ec867942345.png)'
- en: Docker volume enables the persistence and sharing of the container's data. Volumes
    also clearly separate the processing from the data.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Docker卷使容器的数据持久化和共享。卷还清楚地将处理与数据分开。
- en: 'Let''s start with an example and specify the volume with the `-v <host_path>:<container_path>` option
    and connect to the container:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个示例开始，并使用`-v <host_path>:<container_path>`选项指定卷并连接到容器：
- en: '[PRE44]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we can create an empty file in `host_directory` in the container:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在容器中的`host_directory`中创建一个空文件：
- en: '[PRE45]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s check if the file was created in the Docker host''s filesystem:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下文件是否在Docker主机的文件系统中创建：
- en: '[PRE46]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can see that the filesystem was shared and the data was therefore persisted
    permanently. We can now stop the container and run a new one to see that our file
    will still be there:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到文件系统被共享，数据因此得以永久保存。现在我们可以停止容器并运行一个新的容器，看到我们的文件仍然在那里：
- en: '[PRE47]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Instead of specifying the volume with the `-v` flag, it''s possible to specify
    the volume as an instruction in the Dockerfile, for example:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要使用`-v`标志来指定卷，可以在Dockerfile中将卷指定为指令，例如：
- en: '[PRE48]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this case, if we run the docker container without the `-v` flag, then the
    container's `/host_directory` will be mapped into the host's default directory
    for volumes, `/var/lib/docker/vfs/`. This is a good solution if you deliver an
    application as an image and you know it needs the permanent storage for some reason
    (for example, storing application logs).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果我们运行docker容器而没有`-v`标志，那么容器的`/host_directory`将被映射到主机的默认卷目录`/var/lib/docker/vfs/`。如果您将应用程序作为镜像交付，并且知道它因某种原因需要永久存储（例如存储应用程序日志），这是一个很好的解决方案。
- en: If the volume is defined both in Dockerfile and as a flag, then the command
    flag takes precedence.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果卷在Dockerfile中和作为标志定义，那么命令标志优先。
- en: Docker volumes can be much more complicated, especially in the case of databases.
    More complex use cases of the Docker volume are, however, out of the scope of
    this book.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Docker卷可能会更加复杂，特别是在数据库的情况下。然而，Docker卷的更复杂的用例超出了本书的范围。
- en: A very common approach to data management with Docker is to introduce an additional
    layer in the form of data volume containers. A data volume container is a Docker
    container whose only purpose is to declare the volume. Then, other containers
    can use it (with the `--volumes-from <container>` option) instead of declaring
    the volume directly. Read more at [https://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container](https://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker进行数据管理的一个非常常见的方法是引入一个额外的层，即数据卷容器。数据卷容器是一个唯一目的是声明卷的Docker容器。然后，其他容器可以使用它（使用`--volumes-from
    <container>`选项）而不是直接声明卷。在[https://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container](https://docs.docker.com/engine/tutorials/dockervolumes/#creating-and-mounting-a-data-volume-container)中了解更多。
- en: Using names in Docker
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中使用名称
- en: So far, when we operated on the containers, we always used autogenerated names.
    This approach has some advantages, such as the names being unique (no naming conflicts)
    and automatic (no need to do anything). In many cases, however, it's better to
    give a real user-friendly name for the container or the image.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们操作容器时，我们总是使用自动生成的名称。这种方法有一些优势，比如名称是唯一的（没有命名冲突）和自动的（不需要做任何事情）。然而，在许多情况下，最好为容器或镜像提供一个真正用户友好的名称。
- en: Naming containers
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名容器
- en: 'There are two good reasons to name the container: convenience and the possibility
    of automation:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 命名容器有两个很好的理由：方便和自动化：
- en: Convenience, because it's simpler to make any operations on the container addressing
    it by name than checking the hashes or the autogenerated name
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方便，因为通过名称对容器进行任何操作比检查哈希或自动生成的名称更简单
- en: Automation, because sometimes we would like to depend on the specific naming
    of the container
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化，因为有时我们希望依赖于容器的特定命名
- en: For example, we would like to have containers that depend on each other and
    to have one linked to another. Therefore, we need to know their names.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们希望有一些相互依赖的容器，并且有一个链接到另一个。因此，我们需要知道它们的名称。
- en: 'To name a container, we use the `--name` parameter:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要命名容器，我们使用`--name`参数：
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can check (by `docker ps`) that the container has a meaningful name. Also,
    as a result, any operation can be performed using the container''s name, for example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`docker ps`检查容器是否有有意义的名称。此外，作为结果，任何操作都可以使用容器的名称执行，例如：
- en: '[PRE50]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Please note that when the container is named, it does not lose its identity.
    We can still address the container by its autogenerated hash ID like we did before.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当容器被命名时，它不会失去其身份。我们仍然可以像以前一样通过自动生成的哈希ID来寻址容器。
- en: The container always has both ID and name. It can be addressed by any of them
    and both of them are unique.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 容器始终具有ID和名称。可以通过任何一个来寻址，它们两个都是唯一的。
- en: Tagging images
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给图像打标签
- en: 'Images can be tagged. We''ve already done this while creating our own images,
    for example, in the case of building the `hello-world_python` image:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图像可以被标记。我们在创建自己的图像时已经做过这个，例如，在构建`hello-world_python`图像的情况下：
- en: '[PRE51]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `-t` flag describes the tag of the image. If we didn't use it, then the
    image would be built without any tags and, as a result, we would have to address
    it by its ID (hash) in order to run the container.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`-t`标志描述了图像的标签。如果我们没有使用它，那么图像将被构建而没有任何标签，结果我们将不得不通过其ID（哈希）来寻址它以运行容器。'
- en: 'The image can have multiple tags, and they should follow the naming convention:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图像可以有多个标签，并且它们应该遵循命名约定：
- en: '[PRE52]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The tag consists of the following parts:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 标签由以下部分组成：
- en: '`registry_address`: IP and port of the registry or the alias name'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry_address`：注册表的IP和端口或别名'
- en: '`image_name`: name of the image that is built, for example, `ubuntu`'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_name`：构建的图像的名称，例如，`ubuntu`'
- en: '`version`: a version of the image in any form, for example, 16.04, 20170310'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：图像的版本，可以是任何形式，例如，16.04，20170310'
- en: We will cover Docker registries in [Chapter 5](881f1493-1456-4c5b-bdc0-b87595433366.xhtml),
    *Automated Acceptance Testing*. If the image is kept on the official Docker Hub
    registry, then we can skip the registry address. This is why we've run the `tomcat`
    image without any prefix. The last version is always tagged as the latest and
    it can also be skipped, so we've run the `tomcat` image without any suffix.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](881f1493-1456-4c5b-bdc0-b87595433366.xhtml)中介绍Docker注册表，*自动验收测试*。如果图像保存在官方Docker
    Hub注册表上，那么我们可以跳过注册表地址。这就是为什么我们在没有任何前缀的情况下运行了`tomcat`图像。最后一个版本总是被标记为最新的，也可以被跳过，所以我们在没有任何后缀的情况下运行了`tomcat`图像。
- en: Images usually have multiple tags, for example, all four tags are the same image: `ubuntu:16.04`,
    `ubuntu:xenial-20170119`, `ubuntu:xenial`, and `ubuntu:latest.`
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图像通常有多个标签，例如，所有四个标签都是相同的图像：`ubuntu:16.04`，`ubuntu:xenial-20170119`，`ubuntu:xenial`和`ubuntu:latest`。
- en: Docker cleanup
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker清理
- en: Throughout this chapter, we have created a number of containers and images.
    This is, however, only a small part of what you will see in real-life scenarios.
    Even when the containers are not running at the moment, they need to be stored
    on the Docker host. This can quickly result in exceeding the storage space and
    stopping the machine. How can we approach this concern?
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了许多容器和图像。然而，这只是现实场景中的一小部分。即使容器此刻没有运行，它们也需要存储在Docker主机上。这很快就会导致存储空间超出并停止机器。我们如何解决这个问题呢？
- en: Cleaning up containers
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理容器
- en: 'First, let''s look at the containers that are stored on our machine. To print
    all the containers (no matter of their state), we can use the `docker ps -a` command:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看存储在我们的机器上的容器。要打印所有容器（无论它们的状态如何），我们可以使用`docker ps -a`命令：
- en: '[PRE53]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In order to delete a stopped container, we can use the `docker rm` command
    (if the container is running, we need to stop it first):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除已停止的容器，我们可以使用`docker rm`命令（如果容器正在运行，我们需要先停止它）：
- en: '[PRE54]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we want to remove all stopped containers, we can use the following command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要删除所有已停止的容器，我们可以使用以下命令：
- en: '[PRE55]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `-aq` option specifies to pass only IDs (no additional data) for all containers.
    Additionally, `--no-trunc` asks Docker not to truncate the output.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`-aq`选项指定仅传递所有容器的ID（没有额外数据）。另外，`--no-trunc`要求Docker不要截断输出。'
- en: 'We can also adopt a different approach and ask the container to remove itself,
    when it''s stopped using the `--rm` flag, for example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以采用不同的方法，并要求容器在停止时使用`--rm`标志自行删除，例如：
- en: '[PRE56]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In most real-life scenarios, we don't use the stopped containers, and they are
    left only for the debugging purpose.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数实际场景中，我们不使用已停止的容器，它们只用于调试目的。
- en: Cleaning up images
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理图像
- en: 'Images are just as important as containers. They can occupy a lot of space,
    especially in the case of the Continuous Delivery process, when each build ends
    up in a new Docker image. This can quickly result in the no space left on device error.
    To check all the images in the Docker container, we can use the `docker images` command:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图像和容器一样重要。它们可能占用大量空间，特别是在持续交付过程中，每次构建都会产生一个新的Docker图像。这很快就会导致设备上没有空间的错误。要检查Docker容器中的所有图像，我们可以使用`docker
    images`命令：
- en: '[PRE57]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To remove an image, we can call the following command:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除图像，我们可以调用以下命令：
- en: '[PRE58]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the case of images, the automatic cleanup process is slightly more complex.
    Images don''t have states, so we cannot ask them to remove themselves when not
    used. The common strategy would be to set up the Cron cleanup job, which removes
    all old and unused images. We could do this using the following command:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像的情况下，自动清理过程稍微复杂一些。图像没有状态，所以我们不能要求它们在不使用时自行删除。常见的策略是设置Cron清理作业，删除所有旧的和未使用的图像。我们可以使用以下命令来做到这一点：
- en: '[PRE59]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In order to prevent removing the images with tags (for example, to not remove
    all the latest images), it''s very common to use the `dangling` parameter:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止删除带有标签的图像（例如，不删除所有最新的图像），非常常见的是使用`dangling`参数：
- en: '[PRE60]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If we have containers that use volumes, then, in addition to images and containers,
    it's worth to think about cleaning up volumes. The easiest way to do this is to
    use the `docker volume ls -qf dangling=true | xargs -r docker volume rm` command.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有使用卷的容器，那么除了图像和容器之外，还值得考虑清理卷。最简单的方法是使用`docker volume ls -qf dangling=true
    | xargs -r docker volume rm`命令。
- en: Docker commands overview
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker命令概述
- en: 'All Docker commands can be found by executing the following `help` command:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下`help`命令可以找到所有Docker命令：
- en: '[PRE61]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To see all the options of any particular Docker command, we can use `docker
    help <command>`, for example:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看任何特定Docker命令的所有选项，我们可以使用`docker help <command>`，例如：
- en: '[PRE62]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: There is also a very good explanation of all Docker commands on the official
    Docker page [https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/).
    It's really worth reading or at least skimming through.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方Docker页面[https://docs.docker.com/engine/reference/commandline/docker/](https://docs.docker.com/engine/reference/commandline/docker/)上也有对所有Docker命令的很好的解释。真的值得阅读，或者至少浏览一下。
- en: 'In this chapter, we''ve covered the most useful commands and their options.
    As a quick reminder, let''s walk through them:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了最有用的命令及其选项。作为一个快速提醒，让我们回顾一下：
- en: '| **Command** | **Explanation** |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **解释** |'
- en: '| `docker build` | Build an image from a Dockerfile |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `docker build` | 从Dockerfile构建图像 |'
- en: '| `docker commit` | Create an image from the container |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `docker commit` | 从容器创建图像 |'
- en: '| `docker diff` | Show changes in the container |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `docker diff` | 显示容器中的更改 |'
- en: '| `docker images` | List images |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `docker images` | 列出图像 |'
- en: '| `docker info` | Display Docker information |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `docker info` | 显示Docker信息 |'
- en: '| `docker inspect` | Show the configuration of the Docker image/container |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '`docker inspect` | 显示Docker镜像/容器的配置'
- en: '| `docker logs` | Show logs of the container |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| `docker logs` | 显示容器的日志 |'
- en: '| `docker network` | Manage networks |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| `docker network` | 管理网络 |'
- en: '| `docker port` | Show all exposed ports by the container |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| `docker port` | 显示容器暴露的所有端口 |'
- en: '| `docker ps` | List containers |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `docker ps` | 列出容器 |'
- en: '| `docker rm` | Remove container |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `docker rm` | 删除容器 |'
- en: '| `docker rmi` | Remove image |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `docker rmi` | 删除图像 |'
- en: '| `docker run` | Run a container from the image |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `docker run` | 从图像运行容器 |'
- en: '| `docker search` | Search for the Docker image in Docker Hub |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `docker search` | 在Docker Hub中搜索Docker镜像 |'
- en: '| `docker start/stop/pause/unpause` | Manage the container''s state |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `docker start/stop/pause/unpause` | 管理容器的状态 |'
- en: Exercises
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: We've covered a lot of material in this chapter. To make well-remembered, we
    recommend two exercises.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的材料。为了记忆深刻，我们建议进行两个练习。
- en: 'Run `CouchDB` as a Docker container and publish its port:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`CouchDB`作为一个Docker容器并发布它的端口：
- en: You can use the `docker search` command to find the `CouchDB` image.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker search`命令来查找`CouchDB`镜像。
- en: Run the container
  id: totrans-387
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行容器
- en: Publish the `CouchDB` port
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布`CouchDB`端口
- en: Open the browser and check that `CouchDB` is available
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开浏览器并检查`CouchDB`是否可用
- en: 'Create a Docker image with the REST service replying `Hello World!` to `localhost:8080/hello`.
    Use any language and framework you prefer:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Docker镜像，其中REST服务回复`Hello World!`到`localhost:8080/hello`。使用您喜欢的任何语言和框架：
- en: The easiest way to create a REST service is to use Python with the Flask framework,
    [http://flask.pocoo.org/](http://flask.pocoo.org/). Note that a lot of web frameworks
    start the application on the localhost interface only by default. In order to
    publish a port, it's necessary to start it on all interfaces (`app.run(host='0.0.0.0')`
    in the case of a Flask framework).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 创建REST服务的最简单方法是使用Python和Flask框架，[http://flask.pocoo.org/](http://flask.pocoo.org/)。请注意，许多Web框架默认只在localhost接口上启动应用程序。为了发布端口，有必要在所有接口上启动它（在Flask框架的情况下，使用`app.run(host='0.0.0.0')`）。
- en: Create a web service application
  id: totrans-392
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Web服务应用程序
- en: Create a Dockerfile to install dependencies and libraries
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Dockerfile来安装依赖和库
- en: Build the image
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建镜像
- en: Run the container publishing the port
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行容器并发布端口
- en: Check if it's running correctly using the browser
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用浏览器检查它是否正常运行
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we have covered the Docker basics that are enough to build
    images and run applications as containers. The key takeaway, from the chapter
    are the following points:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经涵盖了足够构建镜像和运行应用程序作为容器的Docker基础知识。本章的关键要点如下：
- en: The containerization technology addresses the issues of isolation and environment
    dependencies using the Linux kernel features. This is based on the process separation
    mechanism, therefore no real performance drop is observed.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化技术利用Linux内核特性解决了隔离和环境依赖的问题。这是基于进程分离机制的，因此没有观察到真正的性能下降。
- en: Docker can be installed on most of the systems but is supported natively only
    on Linux.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker可以安装在大多数系统上，但只有在Linux上才能得到原生支持。
- en: Docker allows running applications from the images available on the internet
    and to build own images.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker允许从互联网上可用的镜像中运行应用程序，并构建自己的镜像。
- en: An image is an application packed together with all dependencies.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像是一个打包了所有依赖关系的应用程序。
- en: 'Docker provides two methods for building the images: Dockerfile or committing
    the container. In most cases, the first option is used.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker提供了两种构建镜像的方法：Dockerfile或提交容器。在大多数情况下，第一种选项被使用。
- en: Docker containers can communicate over the network by publishing the ports they
    expose.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker容器可以通过发布它们暴露的端口进行网络通信。
- en: Docker containers can share the persistent storage using volumes.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker容器可以使用卷共享持久存储。
- en: For the purpose of convenience, Docker containers should be named, and Docker
    images should be tagged. In the Docker world, there is a specific convention of
    how to tag images.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了方便起见，Docker容器应该被命名，Docker镜像应该被标记。在Docker世界中，有一个特定的约定来标记镜像。
- en: Docker images and containers should be cleaned from time to time in order to
    save the server space and avoid the *no space left on device* error.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker镜像和容器应该定期清理，以节省服务器空间并避免*设备上没有空间*的错误。
- en: In the next chapter, we will cover Jenkins configuration and the way Jenkins
    can be used together with Docker.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Jenkins的配置以及Jenkins与Docker一起使用的方式。
