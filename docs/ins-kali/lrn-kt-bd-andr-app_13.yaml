- en: Testing and Continuous Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和持续集成
- en: In this chapter, you will be introduced to the concept of **Continuous Integration **(**CI**)
    and the importance of testing. Never heard of CI? Well, what about testing?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解**持续集成**（**CI**）的概念和测试的重要性。从未听说过CI？那测试呢？
- en: 'In this chapter, we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn about writing tests
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解编写测试
- en: Learn about the Android Testing Support Library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Android测试支持库
- en: Learn how to use Crashlytics to track crash reports
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用Crashlytics来跟踪崩溃报告
- en: Learn about beta testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解beta测试
- en: Be introduced to the concept of CI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍CI的概念
- en: Learn about tools such as Jenkins, Bamboo, and Fastlane and how to use them
    for build automation and deployment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Jenkins、Bamboo和Fastlane等工具以及如何将它们用于构建自动化和部署
- en: Testing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Software testing is the process of evaluating software, or a piece of it, to
    ensure it works as expected. The product has to satisfy the given requirements
    for which it was built. Therefore, the report from a test gives an indication
    of the quality of the software. Another main reason for testing is to find bugs
    and fix them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试是评估软件或其部分以确保其按预期工作的过程。产品必须满足其构建的给定要求。因此，测试报告给出了软件质量的指示。测试的另一个主要原因是找到错误并修复它们。
- en: At times, there is the temptation to treat testing as an afterthought. This
    is mostly as a result of issues such as time constraints, but considering the
    importance of testing, it should form a part of the development process. Writing
    tests much later in the life of the software can be a very terrible experience.
    You may have to commit huge amounts of time refactoring it to make it testable
    before you even get to write the tests. The frustration involved in all of these
    factors makes it difficult for most software to have proper tests.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '有时，有诱惑将测试视为事后思考。这主要是由于时间限制等问题，但考虑到测试的重要性，它应该成为开发过程的一部分。在软件生命周期的后期编写测试可能是非常糟糕的经历。您可能不得不花费大量时间重构它，使其可测试，然后才能编写测试。所有这些因素涉及的挫折使大多数软件难以进行适当的测试。 '
- en: Importance of testing
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的重要性
- en: 'Testing is a very broad topic, and you could easily write a book about it.
    The importance of testing cannot be emphasized enough. Here are some reasons why
    all software needs testing:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个非常广泛的话题，你可以很容易地写一本书。测试的重要性无法过分强调。以下是一些软件需要测试的原因：
- en: It allows the business to appreciate and understand the risks of software implementation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使企业能够欣赏和理解软件实施的风险
- en: It ensures that quality programs are written
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确保编写了质量程序
- en: It helps produce bug-free products
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于生产无bug的产品
- en: It reduces maintenance costs
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它降低了维护成本
- en: It is a sure way of validating and verifying software
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是验证和验证软件的一种可靠方式
- en: It improves performance
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提高了性能
- en: It confirms that all the declared functional requirements have been implemented
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确认了所有声明的功能要求都已经实施
- en: It instils confidence in clients
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它给客户带来信心
- en: It exposes bugs quicker
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更快地暴露错误
- en: It's required to stay in business
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是为了保持业务的需要
- en: It ensures that the product can be installed and run in its intended environment
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确保产品可以在其预期环境中安装和运行
- en: Android Testing Support Library
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android测试支持库
- en: The **Android Testing Support Library** (**ATSL**) is a set of libraries purposely
    built for testing Android apps. It's just like the usual support libraries you
    use in Android app development, only this one is specifically for testing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**Android测试支持库**（**ATSL**）是一组专门为测试Android应用程序而构建的库。它就像您在Android应用程序开发中使用的通常支持库一样，只是这个库是专门用于测试的。'
- en: Model-View-Presenter architecture
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Model-View-Presenter架构
- en: As mentioned earlier, the software needs to be testable. Only then can we write
    efficient tests for them. For this reason, you will architect your app using the **Model-View-Presenter **(**MVP**)
    architecture. This architecture employs some design best practices such as inversion
    of control and dependency injection, thus making it suitable for testing. For
    an app to be testable, it has to have its parts decoupled as much as possible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，软件需要可测试。只有这样，我们才能为其编写有效的测试。因此，您将使用**Model-View-Presenter**（**MVP**）架构设计您的应用程序。这种架构采用了一些设计最佳实践，如控制反转和依赖注入，因此非常适合测试。为了使应用程序可测试，其各个部分必须尽可能解耦。
- en: 'Check out the high-level diagrammatic view of an MVP architecture in the following
    diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下图表中MVP架构的高级图解：
- en: '![](img/4744851a-ccfd-4477-aec1-471e8558a85e.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4744851a-ccfd-4477-aec1-471e8558a85e.png)'
- en: 'Very briefly, this is what the various parts mean:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 非常简单地说，这些各部分的含义是：
- en: 'Model: It provides and stores the app''s data'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Model：它提供并存储应用程序的数据
- en: 'View: It handles the display of the model''s data'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: View：它处理模型数据的显示
- en: 'Presenter: It coordinates the UI with the data'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Presenter：它协调UI和数据
- en: You could also easily swap out other parts and mock them during testing. In
    software testing, mocks are objects which mimic real objects. You will provide
    its behavior instead of relying on the actual implementation of the code. This
    way, you get to focus on the class under test, which is doing exactly as expected.
    You will see them in action in the following sections.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以轻松地替换其他部分并在测试期间模拟它们。在软件测试中，模拟是模仿真实对象的对象。您将提供其行为，而不是依赖于代码的实际实现。这样，您就可以专注于正在进行预期操作的测试类。您将在以下部分中看到它们的实际应用。
- en: Test-Driven Development
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: 'You will be building a Notes app using a type of software development known
    as **Test-Driven Development **(**TDD**). Take a look at the following diagram,
    and the following explanation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用一种称为**测试驱动开发**（**TDD**）的软件开发类型构建一个Notes应用程序。看一下下面的图表和下面的解释：
- en: '![](img/14fc8340-e928-4d1b-874f-ddb4f70c3e3b.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14fc8340-e928-4d1b-874f-ddb4f70c3e3b.png)'
- en: '**TDD** is a software development method where tests are written before the
    actual program code.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**TDD**是一种软件开发方法，其中测试是在实际程序代码之前编写的。'
- en: 'RED: Red is the first stage of the TDD process. Here, you write tests. Since
    this is the first test, it means you basically have nothing to test. Therefore,
    you must write the minimum piece of code that you can test. Now, since it''s the
    least amount of code required to be able to write a test, it will most likely
    fail when you write the code. But that''s totally fine. In TDD, your tests must
    fail before anything else happens! When your tests fail, that''s the first stage
    of the TDD cycle—the red stage.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 红：红是TDD过程的第一阶段。在这里，您编写测试。由于这是第一个测试，这意味着您基本上没有什么可以测试的。因此，您必须编写最少量的代码来进行测试。现在，由于这是编写测试所需的最少量代码，当您编写代码时它很可能会失败。但这完全没关系。在TDD中，您的测试必须在发生任何其他事情之前失败！当您的测试失败时，这是TDD周期的第一阶段-红色阶段。
- en: 'GREEN: Now, you have to write the minimum piece of code required to pass the
    test. When the test passes, that''s great, you have completed the second phase
    of the TDD cycle. Passing the test means that you have a part of your program
    working just as you expect it to. And as you keep building your app this way,
    at any point in time you will have every part of your code tested. Can you see
    how this works? By the time you have completed a feature, you have sufficient
    tests for testing various parts of that feature.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色：现在，您必须编写通过测试所需的最少量代码。当测试通过时，那很好，您已经完成了TDD周期的第二阶段。通过测试意味着您的程序的一部分正如您期望的那样工作。随着您以这种方式构建应用程序，任何时候您都将测试代码的每个部分。您能看到这是如何运作的吗？当您完成一个功能时，您将有足够的测试来测试该功能的各个部分。
- en: 'REFACTOR: The final stage of the TDD process is to refactor the code you wrote
    earlier to pass the test. Here, you remove redundant code, clean up, and write
    the full implementation for mocks. Afterwards, run the tests again. They may likely
    fail. In TDD, failing tests is a good thing. When you write tests and they pass,
    you can be certain a particular requirement or expectation has been met.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重构：TDD过程的最后阶段是重构您早期编写的代码以通过测试。在这里，您删除冗余代码，清理代码，并为模拟编写完整的实现。之后再次运行测试。它们可能会失败。在TDD中，测试失败是件好事。当您编写测试并且它们通过时，您可以确信特定的需求或期望已经得到满足。
- en: There are other forms of development models built around testing, such as Behavior-Driven
    Testing, black-box testing, and smoke testing. However, they can basically be
    categorized under functional testing and non-functional testing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他围绕测试构建的开发模型，例如行为驱动测试、黑盒测试和冒烟测试。但是，它们基本上可以归类为功能测试和非功能测试。
- en: Functional versus non-functional testing
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能与非功能测试
- en: 'With functional tests, you test the application against the given business
    requirements. They don''t require the application to be in full operation. These
    include:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过功能测试，您将根据给定的业务需求测试应用程序。它们不需要应用程序完全运行。这些包括：
- en: Unit testing
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Integration testing
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试
- en: Acceptance testing
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试
- en: 'And with non-functional tests, you test the application against its operational
    environment. For instance, the app will connect to a real data source and use
    an HTTP connection. These include:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非功能测试，您将测试应用程序与其操作环境的交互。例如，应用程序将连接到真实数据源并使用HTTP连接。这些包括：
- en: Security testing
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全测试
- en: Usability testing
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性测试
- en: Compatibility testing
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 兼容性测试
- en: Notes app
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 笔记应用程序
- en: 'To start building our Notes app, create a new application and call it notes-app.
    Switch to the Project view using the tab at the top left corner of Android Studio.
    This view allows you to see the full project structure as it exists on your file
    system. It should look like the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建我们的笔记应用程序，请创建一个新应用程序并将其命名为notes-app。使用Android Studio左上角的选项卡切换到项目视图。此视图允许您查看项目结构，就像它在文件系统上存在的那样。它应该看起来像以下截图：
- en: '![](img/2040b167-15e5-4220-975c-59cbb23f4ad1.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2040b167-15e5-4220-975c-59cbb23f4ad1.png)'
- en: Unit tests test small pieces of code, without any other parts of the product.
    In this case, it means your unit tests will not need a physical device, nor the
    Android jar, database, or network; just the source code you have written. These
    are the kind of tests that are to be written in the `test` directory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试测试代码的小部分，而不涉及产品的其他部分。在这种情况下，这意味着您的单元测试不需要物理设备，也不需要Android jar、数据库或网络；只需要您编写的源代码。这些是应该在`test`目录中编写的测试。
- en: On the other hand, integration tests include all of the components required
    to run the app, and these tests will go into the `androidTest` directory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，集成测试包括运行应用程序所需的所有组件，这些测试将进入`androidTest`目录。
- en: Test dependencies
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试依赖项
- en: Currently, there is only one testing library, `Junit`, which you will use for
    unit testing. But, since your code will interact with other components, even though
    they may not be the ones under test, you will have to mock them. `Junit` is still
    not enough for writing the test cases. Therefore, you will also need to add `Hamcrest` to
    help with creating assertion matches and more. Let's go ahead and add the libraries
    we will need.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，只有一个测试库`Junit`，您将用它进行单元测试。但是，由于您的代码将与其他组件交互，即使它们不是被测试的组件，您也必须对它们进行模拟。`Junit`仍然不足以编写测试用例。因此，您还需要添加`Hamcrest`来帮助创建断言匹配等。让我们继续添加我们需要的库。
- en: 'Open your module''s build file, update the dependencies to match the following
    code, and sync the project:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 打开模块的构建文件，更新依赖项以匹配以下代码，并同步项目：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For now, use the exact library versions as shown in the preceding code. This
    means you will have to ignore suggestions from the IDE to upgrade your library
    versions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，请使用与前面代码中显示的确切库版本相同的库版本。这意味着您将不得不忽略IDE提升库版本的建议。
- en: Later, you can update to newer, stable versions which are compatible with each
    other.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，您可以更新为彼此兼容的较新稳定版本。
- en: Your first test
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个测试
- en: You will first work on displaying the notes to the user. The notes presenter
    will provide the logic showing a progress indicator, which displays the notes
    and other note-related views.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先开始向用户显示笔记。笔记演示者将提供显示进度指示器的逻辑，显示笔记和其他与笔记相关的视图。
- en: Since the **Presenter** coordinates between the **Model** and **View**, you
    will have to mock them so you can focus on the class under test.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**Presenter**在**Model**和**View**之间协调，因此您必须对它们进行模拟，以便您可以专注于正在测试的类。
- en: In this test, you will verify that asking the `NotesPresenter` to Add a new
    note will trigger a call to the `View` to show the add-note screen. Let's implement
    the ``should display note when button is clicked`()` test method.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，您将验证要求`NotesPresenter`添加新笔记将触发调用`View`来显示添加笔记屏幕。让我们实现`should display
    note when button is clicked`测试方法。
- en: You will first add a call to the presenter's `addNewNote()` method. Then, you
    will verify that the View's `showAddNote()` is called. Therefore, you call on
    one method and verify that it, in turn, calls another method (recall how the MVP
    pattern works; the presenter coordinates with the views).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您将添加对presenter的`addNewNote()`方法的调用。然后，您将验证View的`showAddNote()`被调用。因此，您调用一个方法并验证它反过来调用另一个方法（回想一下MVP模式的工作原理；presenter与视图协调）。
- en: 'For now, we will not worry about what the second call method does; this is
    unit testing, and you test one small thing (unit) at a time. So, you will have
    to mock out the View, and you don''t need to implement it now. A few interfaces
    can achieve this; that is, an API or contract without necessarily implementing
    them. See the following final pieces of code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们不需要担心第二个调用方法做什么；这是单元测试，您一次测试一个小东西（单元）。因此，您必须模拟出View，并且现在不需要实现它。一些接口可以实现这一点；也就是说，一个API或契约而不一定要实现它们。请参阅以下代码的最终部分：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, create `NotesContract`, which is the **View** part of the MVP architecture.
    It will be an interface where only the methods are required to make the test pass:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建`NotesContract`，它是MVP架构中的**View**部分。它将是一个只需要方法以使测试通过的接口：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, create the `Note` class. It represents the **Model** in the MVP architecture.
    It defines the structure of the notes for the notes-app you''re building:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建`Note`类。它代表MVP架构中的**Model**。它定义了您正在构建的笔记应用程序的笔记结构：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create the `NotesPresenter`, which represents the **Presenter** in the MVP
    architecture. Let it implement the `UserActionsListener` in the `NotesContract`
    class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`NotesPresenter`，它代表MVP架构中的**Presenter**。让它实现`NotesContract`类中的`UserActionsListener`：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That''s enough for the first test. Are you ready? Okay, now click the right
    arrowhead beside the number on which the test method is defined. Or, you could
    equally right-click in or on the `NotesPresenterTest` file and select Run:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于第一个测试来说已经足够了。您准备好了吗？好的，现在点击测试方法所在数字旁边的右箭头。或者，您也可以右键单击`NotesPresenterTest`文件中的位置或文件并选择运行：
- en: '![](img/39c8e93b-906f-4bab-9b3e-dde09872b839.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/39c8e93b-906f-4bab-9b3e-dde09872b839.jpg)'
- en: 'Your test should fail:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您的测试应该失败：
- en: '![](img/c50e97d4-36ff-422d-b102-784fb5e1562f.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c50e97d4-36ff-422d-b102-784fb5e1562f.png)'
- en: It failed because we expected the `showAddNote()` method of the `NotesView`
    class to be called, but it wasn't. This happened because you only implemented
    the interface in the `Presenter` class, but you never called the expected method
    in the `NotesView` class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它失败了，因为我们期望调用`NotesView`类的`showAddNote()`方法，但实际上没有。这是因为您只在`Presenter`类中实现了接口，但从未在`NotesView`类中调用预期的方法。
- en: Let's go ahead and fix that now.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续并修复它。
- en: First, update `NotesPresenter` to accept a `NotesContract.View` object in its
    primary constructor. Then, call the expected method, `showAddNote()`, within the
    `addNewNote()` method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，更新`NotesPresenter`以在其主要构造函数中接受`NotesContract.View`对象。然后，在`addNewNote()`方法中调用预期的方法`showAddNote()`。
- en: You should always prefer constructor injection to field injection. It is much
    easier to handle, and easier to read and maintain too.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终更喜欢构造函数注入而不是字段注入。这样更容易处理，也更容易阅读和维护。
- en: 'Your `NotesPresenter` class should now look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`NotesPresenter`类现在应该如下所示：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`checkNotNull` is a built-in `Kotlin` utility function for verifying whether
    an object is null or not. Its second parameter takes a lambda function which should
    return a default message if the object is null.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkNotNull`是一个内置的`Kotlin`实用程序函数，用于验证对象是否为null。它的第二个参数接受一个lambda函数，如果对象为null，则应返回默认消息。'
- en: 'Since the `NotesPresenter` now requires a `NotesContract.View` in its primary
    constructor, you''ll have to update the test to cater for that:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`NotesPresenter`现在在其主要构造函数中需要`NotesContract.View`，因此您必须更新测试以适应这一点：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code has been refactored. Now, rerun the test:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已经重构。现在重新运行测试：
- en: '![](img/6795a76f-089d-47d4-8190-e1fe3e286a61.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6795a76f-089d-47d4-8190-e1fe3e286a61.png)'
- en: Hooray! The test passes now; that's awesome. Excellent work.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！测试现在通过了；太棒了。干得好。
- en: That's one complete cycle using **TDD**. Now, you need to keep going, and there
    are a few more tests to complete before the feature will be fully implemented.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用**TDD**的一个完整循环。现在，您需要继续前进，在功能完全实现之前还有一些测试要完成。
- en: Your next test is to validate that the presenter displays the notes as expected.
    In this process, the notes will have to be retrieved from the repository first
    before you update the view.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您的下一个测试是验证presenter是否按预期显示笔记。在此过程中，您将首先从存储库中检索笔记，然后更新视图。
- en: 'You will use similar test APIs from the previous test. There is a new one you''ll
    learn here, however, which is called `ArgumentCaptor`. As you may have guessed,
    it captures the arguments passed to a method. You will use these to call another
    method and pass them in as parameters. Let''s have a look:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用先前测试的类似测试API。但是，这里有一个新的测试API，称为`ArgumentCaptor`。正如您可能已经猜到的那样，它捕获传递给方法的参数。您将使用这些参数调用另一个方法，并将它们作为参数传递。让我们看一下：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's go over this again very briefly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再简要地回顾一下。
- en: You first called the method you are testing, which is `loadNotes()`. Then, you
    verified that that action, in turn, gets the notes (`getNotes()`) using the `NotesRepository`
    instance, just like the previous test. You then verified that the instance passed
    to the `getNotes()` method, which is again used to load the notes (`onNotesLoaded()`).
    Afterwards, you verify that `notesView` hides the progress indicator (`setProgressIndicator(false)`)
    and displays the notes (`showNotes()`).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您首先调用了要测试的方法，即`loadNotes()`。然后，您验证了该操作反过来使用`NotesRepository`实例获取笔记（`getNotes()`），就像之前的测试一样。然后，您验证了传递给`getNotes()`方法的实例，该实例再次用于加载笔记（`onNotesLoaded()`）。之后，您验证了`notesView`隐藏了进度指示器（`setProgressIndicator(false)`）并显示了笔记（`showNotes()`）。
- en: Leverage the Null Safety feature in Kotlin as much as possible. Instead of having
    nullable types for the mocks, use Kotlin's `lateinit` modifier instead.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能利用Kotlin中的空安全功能。不要为模拟使用可空类型，而是使用Kotlin的`lateinit`修饰符。
- en: This results in much cleaner code because then you don't have to have nullability
    checks everywhere, nor do you have to use the `elvis` operator, either.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致代码更加清晰，因为您不必在任何地方进行空值检查，也不必使用`elvis`运算符。
- en: 'Now, create the `NotesRepository` as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下方式创建`NotesRepository`：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, update the `NotesContract`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新`NotesContract`：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You are all set to test your second test case now. Go ahead and run it:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已准备好测试第二个测试用例。继续并运行它：
- en: '![](img/7408b728-8d67-4d75-9de4-e29d76a12448.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7408b728-8d67-4d75-9de4-e29d76a12448.png)'
- en: Okay, it fails. And again, with TDD, that's perfect! You realize that this tells
    us exactly what is missing, and thus what needs to be done. You only have the
    contract (interface) implemented, but no further action goes on there.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它失败了。再次，使用TDD，这很完美！您意识到这确切地告诉我们缺少什么，因此需要做什么。您只实现了合同（接口），但没有进一步的操作。
- en: 'Open up your `NotesPresenter` and refactor the code to make this test pass.
    You will first add the `NotesRepository` as part of the constructor parameters,
    and then you will make the call within the appropriate method. See the following
    code for the full implementation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`NotesPresenter`并重构代码以使此测试通过。您将首先将`NotesRepository`添加为构造函数参数的一部分，然后在适当的方法中进行调用。请参阅以下代码以获取完整实现：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You used constructor injection to inject a `NotesRepository` instance into `NotesPresenter`.
    You checked it for nullability just like you did for `NotesContract.View`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用构造函数注入将`NotesRepository`实例注入`NotesPresenter`。您检查了它的可空性，就像您对`NotesContract.View`所做的那样。
- en: In the `loadNotes()` method, you displayed the progress indicator and refreshed
    the data depending on the `forceUpdate` field.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在`loadNotes()`方法中，您显示了进度指示器，并根据`forceUpdate`字段刷新了数据。
- en: You then used a utility class, `EspressoIdlingResource`, basically to alert
    Espresso of a possible asynchronous request. On getting the notes, you hide the
    progress indicator and showed the notes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您使用了一个实用类`EspressoIdlingResource`，基本上是为了提醒Espresso可能存在异步请求。在获取笔记时，您隐藏了进度指示器并显示了笔记。
- en: 'Create a util package to contain `EspressoIdlingResource` and `SimpleCountingIdlingResource`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个util包，其中包含`EspressoIdlingResource`和`SimpleCountingIdlingResource`：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And for `SimpleCountingIdlingResource` :'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以及`SimpleCountingIdlingResource`：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Make sure to update your app''s build dependencies with the `EspressoIdlingResource`
    library:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 确保使用`EspressoIdlingResource`库更新应用程序的构建依赖项：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, update the `setUp` method to initialize correctly the `NotesPresenter`
    class:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新`setUp`方法以正确初始化`NotesPresenter`类：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that everything''s set, run the test:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都准备好了，运行测试：
- en: '![](img/840cf956-4c61-45d0-bae7-ab5347e41120.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/840cf956-4c61-45d0-bae7-ab5347e41120.png)'
- en: Great! Really awesome stuff. You have successfully written the business logic
    for the NotesApp using a TDD approach.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！真是太棒了。您已成功使用TDD方法编写了NotesApp的业务逻辑。
- en: Crashlytics
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Crashlytics
- en: 'From the official website:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从官方网站：
- en: '*Firebase Crashlytics is a lightweight, real-time crash reporter that helps
    you track, prioritize, and fix stability issues that erode your app quality. Crashlytics
    saves you troubleshooting time by intelligently grouping crashes and highlighting
    the circumstances that lead up to them.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*Firebase Crashlytics是一个轻量级的实时崩溃报告工具，可帮助您跟踪、优先处理和修复侵蚀应用程序质量的稳定性问题。 Crashlytics通过智能分组崩溃并突出导致崩溃的情况，节省了故障排除时间。*'
- en: 'There you have it, that''s basically what Crashlytics is about. It works on
    iOS and Android. Here are some of its primary capabilities:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，这基本上就是Crashlytics的全部内容。它适用于iOS和Android。以下是其主要功能：
- en: '**Crash reporting:** Its main purpose is to report crashes, and it does it
    really well. It can be customized to suit your needs. For example, you may not
    want it to report certain kinds of crashes, among other customization options.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**崩溃报告：**其主要目的是报告崩溃，并且它确实做得很好。它可以定制以满足您的需求。例如，您可能不希望它报告某些类型的崩溃，还有其他定制选项。'
- en: '**Analytics:** It gives reports on crashes including data on the users affected,
    their devices, the time the crash occurred, including clean stack traces and logs
    to aid in debugging and fixing.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析：**它提供有关崩溃的报告，包括受影响的用户、其设备、崩溃发生的时间，包括干净的堆栈跟踪和日志，以帮助调试和修复。'
- en: '**Real-time alerts:** You are automatically alerted about new and recurring
    issues. The real-time alerts are necessary as they help you mitigate issues very
    quickly.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时警报：**您将自动收到有关新问题和重复问题的警报。实时警报是必要的，因为它们可以帮助您非常快速地解决问题。'
- en: Crashlytics is used to find out if a particular crash is impacting a lot of
    users. You also get alerts when an issue suddenly increases in severity, and it
    allows you to figure out which lines of code are causing crashes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Crashlytics用于查找特定崩溃是否影响了大量用户。当问题突然严重性增加时，您还会收到警报，并且它允许您找出哪些代码行导致崩溃。
- en: 'The steps for implementation are:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 实施步骤如下：
- en: Connect
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接
- en: Integrate
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合
- en: Check console
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查控制台
- en: Connect
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接
- en: You will start by adding Firebase to your app. Firebase is a platform for development
    for both mobile and web applications. It has a lot of tools, of which one is Crashlytics.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先向您的应用程序添加Firebase。Firebase是一个为移动和Web应用程序开发的平台。它有很多工具，其中之一就是Crashlytics。
- en: 'The minimum requirements are:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最低要求是：
- en: A device running Android 4.0 (Ice Cream Sandwich) or newer, and Google Play
    Services 12.0.1 or higher
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Android 4.0（冰淇淋三明治）或更新版本的设备，并且Google Play服务12.0.1或更高版本
- en: Android Studio 2.2 or later
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio 2.2或更高版本
- en: 'You will use the Firebase Assistant tool within Android Studio 2.2+ to connect
    your app to Firebase. The Assistant tool will update your existing project or
    create a new one with all the necessary Gradle dependencies. It provides a very
    nice intuitive UI guide which you can follow:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用Android Studio 2.2+中的Firebase助手工具将您的应用连接到Firebase。助手工具将更新您现有的项目或创建一个带有所有必要的Gradle依赖项的新项目。它提供了一个非常好的直观的UI指南，您可以按照它进行操作：
- en: '![](img/257940e6-ea7b-428d-996b-895332131468.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/257940e6-ea7b-428d-996b-895332131468.jpg)'
- en: 'Check out the full guide for adding your project to Firebase in [Chapter 12](4204e9e4-6c78-4bb4-b581-bb3c8b1cb266.xhtml),
    *Setting Reminders for Tasks*. When you are done, log into the Firebase console
    from your browser. On the side menu, select **Crashlytics** from the **STABILITY**
    section:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 查看完整指南，了解如何将您的项目添加到Firebase中的[第12章](4204e9e4-6c78-4bb4-b581-bb3c8b1cb266.xhtml)，*为任务设置提醒*。完成后，从浏览器登录到Firebase控制台。在侧边菜单中，从**STABILITY**部分选择**Crashlytics**：
- en: '![](img/e18fef4d-54eb-4579-9d8d-7a200210c3ea.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e18fef4d-54eb-4579-9d8d-7a200210c3ea.jpg)'
- en: 'When the Crashlytics page opens up, you will be asked if the app is new to
    Crashlytics. Select Yes, this app is new to Crashlytics (it doesn''t have any
    version of the SDK):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当Crashlytics页面打开时，您将被问及应用程序是否是Crashlytics的新应用程序。选择是，这个应用程序是Crashlytics的新应用程序（它没有任何版本的SDK）：
- en: '![](img/e2ebfd80-78a0-453b-bb24-981692d48a3e.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2ebfd80-78a0-453b-bb24-981692d48a3e.png)'
- en: 'The second step then gives you a link to the documentation page to set up Crashlytics
    for your app. To add Crashlytics to the app, update your project-level `build.gradle`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后第二步会给您一个链接到文档页面，以设置您的应用的Crashlytics。要将Crashlytics添加到应用中，请更新项目级别的`build.gradle`：
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, update your app module''s `build.gradle` file with the Crashlytics plugin
    and dependency:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用Crashlytics插件和依赖项更新您的应用程序模块的`build.gradle`文件：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That''s it, Crashlytics is ready to listen for crashes in your app. This is
    its default behavior, but if you want to control the initialization yourself,
    you will have to disable it in your manifest file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，Crashlytics已经准备好监听您的应用程序中的崩溃。这是它的默认行为，但是如果您想自己控制初始化，您将不得不在清单文件中禁用它：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, in your Activity class, you can enable it, even with a debugger like
    so:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在您的Activity类中，您可以启用它，即使使用调试器也可以：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Make sure your Gradle Wrapper version is at least 4.4:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的Gradle Wrapper版本至少为4.4：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Since your app will need to send reports to your console, add the internet
    permissions in your manifest file as well:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的应用程序需要向控制台发送报告，请在清单文件中添加互联网权限：
- en: '[PRE20]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As usual, sync Gradle to update your project with the dependency updates you
    just made.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，同步Gradle以使用您刚刚进行的依赖项更新您的项目。
- en: 'After this, you should see the Fabric plugin integrated with Android Studio.
    Sign up with your email and password:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您应该看到Fabric插件已集成到Android Studio中。使用您的电子邮件和密码注册：
- en: '![](img/a706d43a-a7b2-4047-8200-6465f9d94290.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a706d43a-a7b2-4047-8200-6465f9d94290.png)'
- en: 'After confirming your account, the Fabric API key will be generated for you.
    It should look something like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 确认您的帐户后，Fabric API密钥将为您生成。它应该看起来像这样：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will now force a crash in your app in order to test it. Create a new blank
    activity and add only one button. Then, set its `clicklistener` to force the crash.
    The Crashlytics SDK has a simple API for doing just this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将强制在您的应用程序中崩溃以进行测试。创建一个新的空白活动，并只添加一个按钮。然后，将其`clicklistener`设置为强制崩溃。Crashlytics
    SDK有一个简单的API可以做到这一点：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since you're testing, reopen the app after it crashes so the report can be sent
    to your console.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您正在测试，崩溃后重新打开应用程序，以便报告可以发送到您的控制台。
- en: 'Go ahead and run the app. Your test activity should look like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 继续运行应用程序。您的测试活动应该是这样的：
- en: '![](img/4e9636e6-0f3f-430c-b472-c232cdbbdb8b.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e9636e6-0f3f-430c-b472-c232cdbbdb8b.png)'
- en: 'Click on the CRASH! button to force the crash. Your app will crash. Click OK
    and reopen the app:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 点击CRASH！按钮来强制崩溃。您的应用程序将崩溃。点击确定，然后重新打开应用程序：
- en: '![](img/9ec06018-156b-4433-9d6a-b51f642381d5.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ec06018-156b-4433-9d6a-b51f642381d5.png)'
- en: 'Check your inbox, that is, the one you signed up with on Crashlytics:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 检查您的收件箱，也就是您在Crashlytics上注册的那个：
- en: '![](img/c07f5283-dfce-4fc5-8af9-7f00b6bbe270.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c07f5283-dfce-4fc5-8af9-7f00b6bbe270.png)'
- en: Click the Learn more button. It will open up the Crashlytics console. From there,
    you can find more details about the crash. From there, you can resolve it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“了解更多”按钮。它将打开Crashlytics控制台。从那里，您可以找到有关崩溃的更多详细信息。从那里，您可以解决它。
- en: Stages of testing
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试阶段
- en: 'There are two main stages in testing: alpha and beta testing. The main idea
    is to get a set of people to test the app at a stage in the development of the
    app. It usually begins just after the app is beginning to take shape, so that
    the feedback can be harnessed to make the app more stable. Stability is the key
    here. One key thing that distinguishes the various testing stages is the number
    of people involved in the testing.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 测试有两个主要阶段：alpha测试和beta测试。主要思想是在应用程序开发的阶段让一组人测试应用程序。通常是在应用程序开始成形之后，以便可以利用反馈使应用程序更加稳定。稳定性在这里是关键。区分各种测试阶段的一个关键因素是参与测试的人数。
- en: Alpha testing
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Alpha测试
- en: Alpha testing is considered to be the first phase of testing software. This
    test usually involves very few numbers of testers. At this stage, the app is highly
    unstable, so a few people close to the developers will be involved at this stage
    to test and provide constructive feedback. After the app becomes stabilized, it
    is ready to move into beta testing.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Alpha测试被认为是测试软件的第一阶段。这个测试通常涉及很少数量的测试人员。在这个阶段，应用程序非常不稳定，因此只有与开发人员密切相关的少数人参与测试并提供建设性反馈。应用程序稳定后，就可以进入beta测试阶段。
- en: Beta testing
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Beta测试
- en: Beta testing is a phase of software testing where a larger group of people test
    out the application. It could involve 10, 100, or 1,000 people or more, depending
    on the nature of the app and the size of the team working on the app. If an app
    has lots of users worldwide, it'll most likely have a large team working on it
    and thus can afford to have lots of people engaged in beta testing the app.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Beta测试是软件测试的一个阶段，其中有一个更大的人群测试应用程序。这可能涉及10、100或1000人或更多，这取决于应用程序的性质和团队的规模。如果一个应用程序在全球拥有大量用户，那么它很可能有一个庞大的团队在开发，并且因此可以承担许多人参与测试该应用程序的beta测试。
- en: Setting up for beta testing
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为beta测试设置
- en: You can set up and manage beta testing from the **Google Pay Console.** You
    can choose to make your app available to a specific Google group or you can send
    them invitations via email.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从**Google Pay控制台**设置和管理beta测试。您可以选择将您的应用程序提供给特定的Google组，或者您可以通过电子邮件发送邀请。
- en: Users must have a Google (`@gmail.com`) or a G Suite account to join. After
    publishing, it may take a while for your link to become available to testers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 用户必须拥有Google（@gmail.com）或G Suite帐户才能加入。发布后，您的链接可能需要一段时间才能对测试人员可用。
- en: Creating the beta test track
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建beta测试轨道
- en: Now, you will have to create what is called a **track** inside your Google Play
    console. This is basically a setup to manage your testing processes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将需要在Google Play控制台内创建所谓的**轨道**。这基本上是一个用于管理测试流程的设置。
- en: Here, you will be able to upload your APK, distribute it to a selected group
    of people, and track feedback as they test. You can manage both alpha and beta
    testing stages, too.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以上传您的APK，将其分发给选定的一组人，并在他们测试时跟踪反馈。您还可以管理alpha和beta测试阶段。
- en: 'Follow the following steps to set up a beta track:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤设置beta测试：
- en: Login to your Play Console and select your application.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到您的Play控制台并选择您的应用程序。
- en: Locate **App releases** under **Release management**and select **Manage** under
    the **Beta track**.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**发布管理**下找到**应用发布**，并在**Beta轨道**下选择**管理**。
- en: Upload your APK in the **Artifacts** section, then expand the **Manage testers** section.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Artifacts**部分上传您的APK，然后展开**管理测试人员**部分。
- en: Under **Choose a testing method**, select **Open Beta Testing**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**选择测试方法**下，选择**公开Beta测试**。
- en: Copy the **Opt-in URL** and share it with your testers.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**Opt-in URL**并与您的测试人员分享。
- en: Provide an email address or URL next to the **Feedback channel** in order to
    collect feedback from testers. Then, click **Save** to, well, save it.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**反馈渠道**旁边提供电子邮件地址或URL，以便从测试人员收集反馈。然后，点击**保存**来保存它。
- en: The opt-in URL
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Opt-in URL
- en: When you are done creating the test, publish it. Then, you will be given the
    test link. Its format is as follows: [https://play.google.com/apps/testing/com.yourpackage.name](https://play.google.com/apps/testing/com.yourpackage.name.).
    Now, you have to share this link with your testers. With that, they can opt-in
    to test your app.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 创建测试后，发布它。然后，您将获得测试链接。其格式如下：[https://play.google.com/apps/testing/com.yourpackage.name](https://play.google.com/apps/testing/com.yourpackage.name.)。现在，您必须与您的测试人员分享此链接。有了这个链接，他们可以选择测试您的应用程序。
- en: Continuous integration
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: 'Usually, more than one person (team) works on an app. For instance, person
    A may work on the UI, while person B works on feature 1 and person C works on
    feature 2 in the business logic. Such a project will still have one code base
    along with its tests and everything else. All committers will likely run tests
    locally against what each has worked on before pushing the code. The code in a
    shared repository with different committers has to be unified and built as one
    complete app (integration). The tests have to be run for the whole app as well.
    This has to be done regularly, and in the case of CI, per every commit. So in
    a day, the code in the shared repository will have been built and tested many
    times. This is the concept of Continuous Integration. The following is a very
    simple diagram showing the flow of the CI process. It begins from the left (Development):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个应用可能有多个人（团队）在进行工作。例如，A可能负责UI，B负责功能1，C负责业务逻辑中的功能2。这样的项目仍然会有一个代码库以及其测试和其他一切。所有提交者可能会在推送代码之前在本地运行测试以确保自己的工作正常。具有不同提交者的共享存储库中的代码必须统一并构建为一个完整的应用程序（集成）。还必须对整个应用程序运行测试。这必须定期进行，在CI的情况下，每次提交都要进行。因此，在一天内，共享存储库中的代码将被构建和测试多次。这就是持续集成的概念。以下是一个非常简单的图表，显示了CI过程的流程。它从左边（开发）开始：
- en: '![](img/cdf09475-ece3-4615-9315-760d518fcfea.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdf09475-ece3-4615-9315-760d518fcfea.png)'
- en: Definition
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义
- en: CI is a software development practice where an automated system is set up to build,
    test, and report on a piece of software after it has been checked into version
    control. **Integration** occurs because the various branches are merged into the
    main branch. This means whatever is in the main branch effectively represents
    the current state of the entire app, and since this happens every time code enters
    the main repository, it's **continuous;** hence, **Continuous Integration**.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: CI是一种软件开发实践，其中设置了一个自动化系统，用于在代码检入版本控制后构建、测试和报告软件的情况。**集成**发生是因为各种分支合并到主分支中。这意味着主分支中的任何内容都有效地代表了整个应用程序的当前状态，而且由于这每次代码进入主存储库时都会发生，所以它是**持续的**；因此，**持续集成**。
- en: In CI, whenever code is committed, an automated build system automatically grabs
    the latest code from the shared repository (main branch) and builds, tests, and
    validates the whole branch. By doing this regularly, errors are quickly detected
    and thus can be fixed quickly. Knowing that your commit could cause an unstable
    build, you are forced to commit small changes only. This also makes it easy to
    identify and fix bugs.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI中，每当提交代码时，自动构建系统会自动从共享存储库（主分支）中获取最新代码并构建、测试和验证整个分支。通过定期执行此操作，可以快速检测到错误，从而可以快速修复。知道您的提交可能会导致不稳定的构建，因此只能提交小的更改。这也使得易于识别和修复错误。
- en: This is very important because, though the different parts of the app are tested
    and built individually, it may not be necessary after they have been merged into
    a shared repository. Each check-in is then verified by an automated build, allowing
    teams to detect problems early.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要，因为尽管应用程序的不同部分经过了单独测试和构建，但在它们合并到共享存储库后可能并不是必要的。然后，每次检入都会由自动构建进行验证，允许团队及早发现问题。
- en: In the same light, there is also Continuous Deployment as well as Continuous
    Delivery.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，还有持续部署以及持续交付。
- en: Tools
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具
- en: There is a wide array of tools available for CI. Some are open source, some
    are self-hosted, some are more suitable for web frontend, some for web backend,
    and some are more suitable for mobile development.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用于CI的工具。有些是开源的，有些是自托管的，有些更适合于Web前端，有些更适合于Web后端，有些更适合于移动开发。
- en: Examples include Jenkins, Bamboo, and Fastlane. You will use Fastlane to integrate
    your app and run your tests. Fastlane is self-hosted, which means that you run
    it on your development machine. Ideally, you should install it on a CI server,
    a dedicated server for CI tasks.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 示例包括Jenkins、Bamboo和Fastlane。您将使用Fastlane来集成您的应用程序并运行测试。Fastlane是自托管的，这意味着您在开发机器上运行它。理想情况下，您应该将其安装在CI服务器上，即专用于CI任务的服务器。
- en: First, let's install it locally and use it to run tests for the Notes app.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在本地安装它，并使用它来运行Notes应用程序的测试。
- en: Fastlane, at the time of writing this book, runs on MacOS only. There is work
    in progress to get it to work on Linux and Windows as well. Some CI services include
    Jenkins, Bamboo, GitLab CI, Circle CI, and Travis.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Fastlane仅在MacOS上运行。目前正在进行工作，以使其在Linux和Windows上运行。一些CI服务包括Jenkins、Bamboo、GitLab
    CI、Circle CI和Travis。
- en: Installing fastlane
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装fastlane
- en: 'To install fastlane, follow these steps:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装fastlane，请按照以下步骤进行操作：
- en: 'You should already have **`gem`** on your path in your Terminal since x-code
    uses Ruby and comes bundled with Mac OS X. Run the following command to install
    it:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该已经在终端中的路径上有**`gem`**，因为x-code使用Ruby并且捆绑在Mac OS X中。运行以下命令进行安装：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You may need to use `sudo` depending on your user account's privileges.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的用户帐户权限，您可能需要使用`sudo`。
- en: 'After a successful install, export the path to the `bin` directory to your
    `PATH` environment variable:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功安装后，将`bin`目录的路径导出到您的`PATH`环境变量中：
- en: '[PRE24]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'While you''re at it, add the following locales as well:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此期间，还添加以下区域设置：
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open a new session within your Terminal. This new session will load the changes
    you just made to your environment variables. First, ensure that you have `bundler`
    installed. Use the following command if you don''t have it already:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中打开一个新会话。这个新会话将加载您刚刚对环境变量所做的更改。首先，确保您已安装`bundler`。如果尚未安装，请使用以下命令：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, switch to the root of your working directory. There, initialize `fastlane`
    with the following command:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，切换到您的工作目录的根目录。然后，使用以下命令初始化`fastlane`：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will be asked a few questions as part of the process. The first is for
    your package name. A default one will be provided when you leave it blank, so
    enter your package name:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作为过程的一部分，您将被问及一些问题。首先是您的包名称。当您留空时，将提供默认值，因此请输入您的包名称：
- en: '![](img/d4101973-7c49-4029-a07a-891247a1ac5b.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4101973-7c49-4029-a07a-891247a1ac5b.png)'
- en: 'Next, you will be asked to supply the path to a certain service action JSON
    secret file. Just press *Enter*, as we will not be needing it just yet; it can
    be supplied later. Finally, you will be asked whether you want to upload some
    metadata among other things. Humbly decline; you can set it up later with:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将被要求提供某个服务操作JSON秘密文件的路径。只需按*Enter*，因为我们暂时不需要它；稍后可以提供。最后，您将被问及是否要上传一些元数据等内容。请谦逊地拒绝；您可以稍后使用以下命令进行设置：
- en: '[PRE28]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There will be a few other prompts, for which you will just have to hit the *Enter*
    key.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 还会有一些其他提示，您只需按*Enter*键即可。
- en: 'When you are done, use the following command to run your test:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，使用以下命令运行您的测试：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When all goes well, you should see the results as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一切顺利时，您应该会看到以下结果：
- en: '![](img/6fe3d173-e43b-471f-b080-44b955de79ad.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fe3d173-e43b-471f-b080-44b955de79ad.png)'
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have been introduced to the concept of CI and testing.
    You have learned how to use the ATSL to write tests.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经了解了CI和测试的概念。您已经学会了如何使用ATSL编写测试。
- en: You learned about the two most popular stages in testing and how to set them
    up in the Google Play console. You tried out Crashlytics and experienced its crash
    reporting feature among others. Then you learned about CI, and as an example,
    you used one of the CI tools called Fastlane.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您了解了测试中最流行的两个阶段以及如何在Google Play控制台中设置它们。您尝试了Crashlytics，并体验了其崩溃报告功能等。然后您了解了CI，并且作为示例，您使用了名为Fastlane的CI工具之一。
- en: Wow, this chapter was really packed and here you are—you have made it to the
    end. In the next chapter, you will learn how to "make your app available to the
    world". Interesting, right? Well, let's move on; we'll meet again in the next
    chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这一章真的很充实，您已经到达了结尾。在下一章中，您将学习如何“让您的应用程序面向全球”。有趣，对吧？好吧，让我们继续吧；我们下一章再见。
