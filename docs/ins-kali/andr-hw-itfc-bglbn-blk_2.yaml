- en: Chapter 2. Interfacing with Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。与Android进行接口
- en: In the last chapter, you installed Android on your BBB. You also gathered all
    of the hardware and components that you will need to try out the exercises in
    this book. Now that you have a working Android system and the hardware needed
    to explore it, it is time to dive into Android and find out how to prepare it
    to interface with custom hardware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您在BBB上安装了Android。您还收集了所有在本书中尝试练习所需的硬件和组件。现在您已经有了一个可用的Android系统和探索它所需的硬件，是时候深入了解Android，并找出如何准备它与自定义硬件进行接口。
- en: Most people would not consider Android and Linux to be very similar, but the
    two have more in common than you might realize. Underneath the polished UIs and
    a wide variety of apps, Android is secretly Linux. Android's filesystem layout
    and services are quite different from those of a typical Linux system, so there
    are certainly many differences between the two in terms of user space (where apps
    and other processes execute). In terms of kernel space (where device drivers execute
    and resources are allocated to each running process), they are almost identical
    in functionality. Understanding how the BBB interacts with Linux kernel drivers
    is the key to creating Android apps that can do the same.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数人可能不会认为Android和Linux非常相似，但它们之间的共同点可能比您想象的要多。在经过精心设计的用户界面和各种各样的应用程序之下，Android其实是Linux。Android的文件系统布局和服务与典型的Linux系统有很大的不同，因此在用户空间（应用程序和其他进程执行的地方）两者之间肯定有很多不同之处。但在内核空间（设备驱动程序执行和为每个运行的进程分配资源的地方）功能上它们几乎是相同的。了解BBB如何与Linux内核驱动程序交互是创建可以执行相同操作的Android应用程序的关键。
- en: In this chapter, we will tell you about Android's hardware abstraction layer,
    or HAL. We will also introduce you to PacktHAL, a special library that you can
    include within your apps to interface with hardware on the BBB. We assume that
    you already have Eclipse **Android Developer Tools** (**ADT**) with the Android
    SDK, the Android **Native Development Kit** (**NDK**), and the **Android Debug
    Bridge** (**ADB**) tools installed and working on your system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将告诉您关于Android的硬件抽象层（HAL）。我们还将向您介绍PacktHAL，这是一个特殊的库，您可以在您的应用程序中包含它，以便与BBB上的硬件进行接口。我们假设您已经在系统上安装并且正常运行了Eclipse
    **Android Developer Tools** (**ADT**)与Android SDK、Android **Native Development
    Kit** (**NDK**)和**Android Debug Bridge** (**ADB**)工具。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the Android HAL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Android HAL
- en: Installing PacktHAL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装PacktHAL
- en: Setting up the Android NDK for PacktHAL
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为PacktHAL设置Android NDK
- en: Multiplexing the BBB pins
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复用BBB引脚
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Are you missing a few tools?**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**您是否缺少一些工具？**'
- en: 'If you do not yet have the Eclipse ADT or Android NDK tools installed on your
    system, you can find installation instructions and download links at these locations:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统上尚未安装Eclipse ADT或Android NDK工具，您可以在这些位置找到安装说明和下载链接：
- en: '**Eclipse ADT**: [http://developer.android.com/sdk](http://developer.android.com/sdk)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Eclipse ADT**: [http://developer.android.com/sdk](http://developer.android.com/sdk)'
- en: '**Android NDK**: [http://developer.android.com/tools/sdk/ndk](http://developer.android.com/tools/sdk/ndk)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android NDK**: [http://developer.android.com/tools/sdk/ndk](http://developer.android.com/tools/sdk/ndk)'
- en: How to install ADB is discussed later in this chapter. This chapter assumes
    that you have installed the Eclipse ADT to the `c:\adt-bundle` directory if you
    are using Windows (we make no assumptions for Linux) and that you have installed
    the Android NDK to the `c:\android-ndk` directory (Windows) or `android-ndk` in
    your home directory (Linux). If you have installed these tools to a different
    location, you will have to make a few simple adjustments to a few instructions
    later in this chapter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面将讨论如何安装ADB。本章假设您已经在Windows上安装了Eclipse ADT到`c:\adt-bundle`目录（我们不对Linux做任何假设），并且已经将Android
    NDK安装到了`c:\android-ndk`目录（Windows）或者您的家目录中的`android-ndk`（Linux）。如果您将这些工具安装到了其他位置，您将需要稍微调整本章后面的一些指令。
- en: Understanding the Android HAL
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Android HAL
- en: An Android kernel contains a few additional features that aren't found in a
    typical Linux kernel, such as **Binder IPC** and the low-memory killer, but otherwise
    it is still Linux. This provides you with one very big advantage when interfacing
    hardware with Android, that is, if a Linux driver already exists in the kernel
    used for an Android system, then you already have an Android driver for that device.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Android内核包含一些在典型的Linux内核中找不到的附加功能，比如**Binder IPC**和低内存杀手，但除此之外它仍然是Linux。这为您在与Android接口硬件时提供了一个非常大的优势，也就是，如果Linux驱动程序已经存在于用于Android系统的内核中，那么您已经拥有了该设备的Android驱动程序。
- en: Android apps must interact with the hardware of an Android device by generating
    video and audio data, receiving button and touchscreen input events, and receiving
    sensor events from cameras, accelerometers, and other devices that gather information
    from the outside world. Leveraging existing Linux drivers for these devices makes
    Android support much easier. Unlike a traditional Linux distribution, which grants
    applications permission to directly access many different device files (by directly
    opening files in the `/dev` filesystem), Android dramatically limits the ability
    of processes to directly access hardware.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序必须通过生成视频和音频数据、接收按钮和触摸屏输入事件以及从摄像头、加速度计和其他收集外部信息的设备接收传感器事件来与Android设备的硬件进行交互。利用这些设备的现有Linux驱动程序可以使Android支持变得更加容易。与传统的Linux发行版不同，传统的Linux发行版允许应用程序直接访问许多不同的设备文件（通过直接在`/dev`文件系统中打开文件），而Android大大限制了进程直接访问硬件的能力。
- en: Consider the number of different Android apps that use the audio functionality
    of the device to play sounds or record audio data. Underneath Android, the Linux
    kernel provides this audio functionality via an **Advanced Linux Sound Architecture**
    (**ALSA**) audio driver. In most cases, only one process at a time can open and
    control the ALSA driver resource. If individual apps were in charge of taking,
    using, and releasing the ALSA driver, it would become a huge mess to coordinate
    audio resource usage among all of the various apps. One misbehaving app can easily
    take control of audio resources and block all other apps from using them! But
    how can the allocation and control of these resources be handled? To solve this
    problem, Android uses *managers*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到使用设备音频功能播放声音或记录音频数据的不同Android应用程序数量。在Android下，Linux内核通过高级Linux声音架构（ALSA）音频驱动程序提供此音频功能。在大多数情况下，一次只能有一个进程打开和控制ALSA驱动程序资源。如果各个应用程序负责获取、使用和释放ALSA驱动程序，将会在所有各种应用程序之间协调音频资源使用方面变得非常混乱。一个行为不端的应用程序很容易控制音频资源并阻止其他所有应用程序使用它们！但是如何处理这些资源的分配和控制呢？为了解决这个问题，Android使用了管理者。
- en: Android managers
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android管理者
- en: Managers are the components of the system that control hardware devices on behalf
    of all apps. Every app requires some set of resources (such as audio, GPS, and
    network access) to perform its job. Managers are in charge of allocating and interfacing
    with each of these resources and determining whether an app has permission to
    use that resource.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 管理者是系统的组成部分，代表所有应用程序控制硬件设备。每个应用程序都需要一些资源（如音频、GPS和网络访问）来执行其工作。管理者负责分配和与每个资源进行接口，并确定应用程序是否有权限使用该资源。
- en: Having managers deal with these low-level details makes life much easier. Android
    can be installed on a wide variety of hardware platforms that vary wildly in terms
    of physical size and input/output capabilities, and app developers can't be expected
    to have intimate knowledge of each and every platform that their app can be installed
    on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让管理者处理这些低级细节使生活变得更加轻松。Android可以安装在各种各样的硬件平台上，这些平台在物理尺寸和输入/输出能力方面差异巨大，应用程序开发人员无法期望对其安装的每个平台都有深入了解。
- en: 'To use a resource, an app must create a reference to the proper manager via
    the `getSystemService()` method of the `android.content.Context` class:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用资源，应用程序必须通过android.content.Context类的`getSystemService()`方法创建对适当管理者的引用：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, make information and control requests via this manager reference:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过此管理者引用进行信息和控制请求：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Apps interact with managers through the Java Android API. While managers respond
    to these Java methods, they must eventually use the **Java native interface**
    (**JNI**) to call the native code that directly interacts with the hardware. This
    is where the true control of the hardware takes place. The bridge between the
    Android API and calls to the native code that control the hardware is known as
    the **hardware abstraction layer** (**HAL**).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通过Java Android API与管理者进行交互。管理者响应这些Java方法，但最终必须使用Java本机接口（JNI）调用直接与硬件交互的本机代码。这就是真正控制硬件的地方。Android
    API和控制硬件的本机代码之间的桥梁称为硬件抽象层（HAL）。
- en: The various pieces of the HAL are typically written in C/C++, and each device's
    vendor is responsible for implementing them. If some pieces of the HAL are missing,
    services and apps won't be able to fully utilize all aspects of the hardware platform.
    Various Android services use the HAL to communicate with the hardware, and apps
    use IPC to communicate with these services and gain access to the hardware. The
    services interact with the hardware on an app's behalf (assuming that the app
    has the proper Android permissions to access that particular hardware resource).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: HAL的各个部分通常是用C/C++编写的，每个设备的供应商负责实现它们。如果HAL的某些部分丢失，服务和应用程序将无法充分利用硬件平台的所有方面。各种Android服务使用HAL与硬件通信，应用程序使用IPC与这些服务通信并访问硬件。服务代表应用程序与硬件交互（假设应用程序具有适当的Android权限以访问特定的硬件资源）。
- en: The HAL development workflow
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HAL开发工作流程
- en: 'Typically, creating a complete HAL follows these steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，创建完整的HAL遵循以下步骤：
- en: Identify or develop a Linux kernel device driver to control the hardware.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别或开发Linux内核设备驱动程序以控制硬件。
- en: Create a kernel Device Tree overlay that instantiates and configures the driver.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个内核设备树叠加，实例化和配置驱动程序。
- en: Develop a user space library to interface with the kernel device driver.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发用户空间库以与内核设备驱动程序进行接口。
- en: Develop JNI bindings to the userspace library.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发JNI绑定到用户空间库。
- en: Develop an Android manager using the JNI bindings to interface with the hardware.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JNI绑定开发Android管理器，与硬件进行接口。
- en: Sometimes, it isn't a clear decision as to where a particular piece of custom
    hardware should be properly integrated into the HAL and which manager should be
    in charge of accessing the hardware. What Android permissions control access to
    the hardware? Will the API have to be extended to offer new types of permissions?
    Will a custom service have to be created?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，对于一块特定的自定义硬件应该被适当整合到HAL的位置以及哪个管理者应该负责访问硬件并不是一个明确的决定。Android权限控制对硬件的访问？API是否必须扩展以提供新类型的权限？是否必须创建自定义服务？
- en: Implementing every aspect of a proper HAL for a piece of custom hardware is
    a bit of an overkill for hobbyists, students, and other developers interested
    in simple experimentation with hardware interfacing. While a commercial Android
    system must address all of these steps to develop a proper HAL, we take a far
    more direct approach to hardware access in this book.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为一块自定义硬件的每个方面实现一个适当的HAL对于业余爱好者、学生和其他对硬件接口进行简单实验感兴趣的开发人员来说有点过度。虽然商业Android系统必须解决所有这些步骤来开发一个适当的HAL，但我们在本书中对硬件访问采取了更为直接的方法。
- en: As our focus is on showing how you can interface Android apps with hardware,
    we skip steps 1 through 4 by providing you with **PacktHAL**, a native library
    that implements a very simple HAL. PacktHAL will ease you into the daunting task
    of interfacing with hardware on the BBB, and it provides a set of functions that
    are capable of interfacing with the hardware used in the examples throughout this
    book. Strictly speaking, your apps will act as the manager in charge of each hardware
    resource.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的重点是展示如何将Android应用程序与硬件进行接口，我们通过提供**PacktHAL**来跳过步骤1到4，这是一个实现非常简单的HAL的本地库。PacktHAL将帮助您轻松地进行与BBB上的硬件进行接口的艰巨任务，并提供一组能够与本书中示例中使用的硬件进行接口的函数。严格来说，您的应用程序将作为负责每个硬件资源的管理器。
- en: Working with PacktHAL
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PacktHAL
- en: 'Apps communicate with the native calls of PacktHAL using JNI. PacktHAL demonstrates
    how to perform user space interfacing with hardware via three different interfacing
    methods: `GPIO`, `SPI`, and `I2C`. Using PacktHAL, you have direct access to hardware
    devices. [Chapters 3](part0024_split_000.html#page "Chapter 3. Handling Inputs
    and Outputs with GPIOs") through [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating
    a Complete Interfacing Solution") provide examples of how this interfacing works
    and how you can use it within your own Android app code. Each chapter will examine
    the various pieces of PacktHAL used in the app examples of that chapter.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通过JNI与PacktHAL的本地调用进行通信。PacktHAL演示了如何通过三种不同的接口方法：`GPIO`、`SPI`和`I2C`，执行用户空间与硬件的接口。使用PacktHAL，您可以直接访问硬件设备。[第3章](part0024_split_000.html#page
    "第3章。使用GPIO处理输入和输出")到[第6章](part0041_split_000.html#page "第6章。创建完整的接口解决方案")提供了这种接口工作的示例，以及您如何在自己的Android应用程序代码中使用它。每一章都将检查在该章节的应用程序示例中使用的PacktHAL的各个部分。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**How does PacktHAL actually talk to hardware?**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**PacktHAL实际上是如何与硬件通信的？**'
- en: Generally, any method that allows you to interface with hardware under Linux
    can also be used by the HAL for interfacing. Reading, writing, and making `ioctl()`
    calls to files in the `/dev` filesystem will work, as does using `mmap()` to provide
    access to memory-mapped control registers. PacktHAL uses all of these techniques
    to interface with the hardware that you connect to your BBB.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，任何允许您在Linux下与硬件进行接口的方法也可以被HAL用于接口。读取、写入和对`/dev`文件系统中的文件进行`ioctl()`调用都可以，使用`mmap()`提供对内存映射控制寄存器的访问也可以。PacktHAL使用所有这些技术来与连接到BBB的硬件进行接口。
- en: Using PacktHAL is nowhere near as secure as a proper HAL implementation because
    we must change the permissions on the hardware's user space interfaces such that
    *any* app can access the hardware directly. This can potentially make your system
    vulnerable to malicious apps, so such an approach should never be used in a production
    device. Users that root (gain superuser access to) commercial Android phones and
    tablets often do so to lessen the strict permissions on these devices by default.
    This allows them to install and enable custom features, and it provides more flexibility
    and customization for their devices.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PacktHAL远不及一个适当的HAL实现安全，因为我们必须更改硬件的用户空间接口的权限，以便*任何*应用程序可以直接访问硬件。这可能会使您的系统容易受到恶意应用程序的攻击，因此在生产设备中永远不应该使用这种方法。经常有用户root（获得超级用户访问权限）商用Android手机和平板电脑，以减少这些设备的默认严格权限。这使他们能够安装和启用自定义功能，并为其设备提供更多的灵活性和定制性。
- en: As you are using the BBB as an Android-prototyping device, such an approach
    is the easiest way for you to interact with the hardware. This is a stepping stone
    towards developing your own custom managers and services that speak to your hardware
    on behalf of apps. Ideally, on a commercial device, only an Android manager will
    have the necessary permissions to directly interface with the hardware.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您正在使用BBB作为Android原型设备，这种方法是您与硬件交互的最简单方式。这是向开发自己的自定义管理器和服务迈出的一步，这些管理器和服务代表应用程序与硬件进行通信。理想情况下，在商用设备上，只有一个Android管理器才有必要的权限直接与硬件进行接口。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Once you become comfortable with using PacktHAL in your apps, you can then examine
    PacktHAL's source code to better understand how native code interfaces with the
    Linux kernel. Eventually, you might find yourself integrating PacktHAL into your
    own custom managers. You might even find yourself developing custom code for the
    actual kernel!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在应用程序中使用PacktHAL变得舒适，您可以检查PacktHAL的源代码，以更好地理解本地代码如何与Linux内核进行接口。最终，您可能会发现自己将PacktHAL集成到自己的自定义管理器中。您甚至可能会发现自己为实际内核开发自定义代码！
- en: Installing PacktHAL
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装PacktHAL
- en: All of the various pieces of PacktHAL are located in the `PacktHAL.tgz` file,
    which is available for download from Packt's website ([http://www.packtpub.com/support](http://www.packtpub.com/support)).
    This is a compressed tar file that contains all of the source code and configuration
    files required to modify BBBAndroid to use PacktHAL and include PacktHAL support
    in your apps.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PacktHAL的各种部分都位于`PacktHAL.tgz`文件中，可以从Packt的网站（[http://www.packtpub.com/support](http://www.packtpub.com/support)）下载。这是一个压缩的tar文件，包含了修改BBBAndroid以使用PacktHAL和在您的应用程序中包含PacktHAL支持所需的所有源代码和配置文件。
- en: Preparing PacktHAL under Linux
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linux下准备PacktHAL
- en: Once you have downloaded the `PacktHAL.tgz` file, you must decompress and untar
    it. We will assume that you have copied `PacktHAL.tgz` to your home directory
    after downloading it and will decompress it from there. We will refer to your
    home directory as `$HOME`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您下载了`PacktHAL.tgz`文件，您必须解压缩和解压它。我们假设您已经在下载后将`PacktHAL.tgz`复制到您的主目录，并将从那里解压缩它。我们将把您的主目录称为`$HOME`。
- en: 'Use the Linux `tar` command to decompress and untar the file:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Linux的`tar`命令来解压缩和解压文件：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A directory named `PacktHAL` now exists in your `$HOME` directory. All of the
    PacktHAL files are located in this directory.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的`$HOME`目录中存在一个名为`PacktHAL`的目录。所有的PacktHAL文件都位于这个目录中。
- en: Preparing PacktHAL under Windows
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows下准备PacktHAL
- en: Once you have downloaded the `PacktHAL.tgz` file, decompress and untar it. We
    will assume that you have copied `PacktHAL.tgz` to the root directory of the `C:`
    drive after downloading it and will use WinRAR to decompress it from there.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您下载了`PacktHAL.tgz`文件，解压并解包它。我们假设您在下载后将`PacktHAL.tgz`复制到`C:`驱动器的根目录，并将使用WinRAR从那里解压它。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Where should I unpack PacktHAL.tgz?**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**我应该在哪里解压PacktHAL.tgz？**'
- en: You can decompress and untar `PacktHAL.tgz` on the desktop or wherever else
    you wish, but you will be performing some command-line commands to copy files
    around later. It is much simpler to perform these operations if `PacktHAL.tgz`
    is decompressed and untarred in the root directory of the `C:` drive, so we will
    assume that you are performing these operations from there.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在桌面或其他任何地方解压和解包`PacktHAL.tgz`，但是稍后将执行一些命令行命令来复制文件。如果`PacktHAL.tgz`在`C:`驱动器的根目录中解压和解包，执行这些操作会更简单，因此我们假设您是从那里执行这些操作的。
- en: 'Perform the following steps to extract the `PacktHAL.tgz` file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来提取`PacktHAL.tgz`文件：
- en: Open a file explorer window and navigate to the root of the `C:` drive.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件资源管理器窗口，导航到`C:`驱动器的根目录。
- en: Right-click on the `PacktHAL.tgz` file in file explorer and select **Extract
    Here**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件资源管理器中右键单击`PacktHAL.tgz`文件，然后选择**在此处提取**。
- en: A directory named `C:\PacktHAL` now exists. All of the PacktHAL files are located
    in this directory.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在存在一个名为`C:\PacktHAL`的目录。所有的PacktHAL文件都位于这个目录中。
- en: The PacktHAL directory structure
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PacktHAL目录结构
- en: 'The `PacktHAL` directory has the following structure:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`PacktHAL`目录具有以下结构：'
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `cape` subdirectory contains the source code and build script for building
    a Device Tree overlay that enables all of the hardware features that PacktHAL
    needs. You will learn more about Device Tree overlays later in this chapter. The
    `jni` subdirectory contains the source code files that implement PacktHAL. These
    source files will be added to your projects in later chapters to build PacktHAL
    support into your apps. The `prebuilt` directory contains a few premade files
    that must be added to your BBBAndroid image and Android NDK to build and use PacktHAL.
    You will install the files in the `prebuilt` directory to their required locations
    in the next few sections.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`cape`子目录包含用于构建设备树叠加的源代码和构建脚本，该叠加可以启用PacktHAL需要的所有硬件功能。您将在本章后面了解有关设备树叠加的更多信息。`jni`子目录包含实现PacktHAL的源代码文件。这些源文件将在后面的章节中添加到您的项目中，以将PacktHAL支持构建到您的应用程序中。`prebuilt`目录包含一些必须添加到BBBAndroid映像和Android
    NDK中以构建和使用PacktHAL的预制文件。您将在接下来的几节中将`prebuilt`目录中的文件安装到它们所需的位置。'
- en: Preparing Android for PacktHAL
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为PacktHAL准备Android
- en: Before using PacktHAL with any apps, you have to prepare your BBBAndroid installation.
    By default, Android is very restrictive on the permissions that it assigns to
    hardware devices. To use PacktHAL, you must lessen the permission restrictions
    and configure Android for the hardware that you will interface with. These actions
    require copying some prebuilt files into your Android system to make a few configuration
    changes that relax various Android permissions and configure the hardware properly
    for PacktHAL's use.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用PacktHAL与任何应用程序之前，您必须准备好您的BBBAndroid安装。默认情况下，Android对其分配给硬件设备的权限非常严格。要使用PacktHAL，您必须减少权限限制，并为您将与之交互的硬件配置Android。这些操作需要将一些预制文件复制到您的Android系统中，以进行一些配置更改，以放宽各种Android权限，并为PacktHAL的使用正确配置硬件。
- en: You will use the ADB tool to push (`push`) the necessary files over to your
    running BBB system. Prior to pushing the files, boot Android on the BBB and connect
    the BBB to your PC using the USB cable that came with your BBB. Once you have
    reached this point, continue with the instructions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用ADB工具将必要的文件推送到正在运行的BBB系统上。在推送文件之前，将BBB上的Android启动，并使用随BBB提供的USB电缆将BBB连接到您的PC。一旦达到这一点，继续执行说明。
- en: Pushing PacktHAL files under Linux
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linux下推送PacktHAL文件
- en: 'The following steps are used in order to publish PacktHAL files under Linux:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤用于在Linux下发布PacktHAL文件：
- en: 'Before you get started, make sure that ADB can see your BBB by using the `adb
    devices` command. The BBB will report as having a serial number of `BBBAndroid`.
    Execute the following command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始之前，请确保ADB可以通过`adb devices`命令看到您的BBB。BBB将报告具有`BBBAndroid`序列号。执行以下命令：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you are missing the `adb` command, install the `android-tools-adb` package
    via `apt-get`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您缺少`adb`命令，请通过`apt-get`安装`android-tools-adb`软件包：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Why can''t Linux find my BBB?**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么Linux找不到我的BBB？**'
- en: If `adb` is installed on your system and you are unable to see the BBB, you
    might need to add a `udev` rule to your system and perform some additional troubleshooting.
    Google provides directions for adding this rule and some troubleshooting steps
    if you run into any difficulty, and this can be found at [http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统上已安装`adb`，但无法看到BBB，可能需要向系统添加`udev`规则并执行一些额外的故障排除。Google提供了添加此规则和一些故障排除步骤的说明，如果遇到任何困难，可以在[http://developer.android.com/tools/device.html](http://developer.android.com/tools/device.html)找到。
- en: BBBAndroid reports the USB device ID of its ADB interface as `18D1:4E23`, which
    is the device ID of a Google Nexus S, so the USB vendor ID for the BBB is 18D1
    (the device ID for Google devices).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: BBBAndroid将其ADB接口的USB设备ID报告为`18D1:4E23`，这是Google Nexus S的设备ID，因此BBB的USB供应商ID为18D1（Google设备的设备ID）。
- en: 'Once you have verified that `adb` can see the BBB, change into the `PacktHAL`
    directory, shell into Android via `adb`, and remount the read-only `rootfs` filesystem
    as read-write:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您验证了`adb`可以看到BBB，就切换到`PacktHAL`目录，通过`adb`进入Android，并将只读的`rootfs`文件系统重新挂载为读写：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, push the necessary files into Android''s `rootfs` filesystem:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将必要的文件推送到Android的`rootfs`文件系统中：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, shell into Android''s `rootfs` filesystem to sync it and remount it
    as read-only:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过`adb`进入Android的`rootfs`文件系统进行同步，并将其重新挂载为只读：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You have now prepared your BBBAndroid image for PacktHAL under Linux. Remove
    the power supply cable and USB cable from your BBB to shut it down.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在已经为Linux下的PacktHAL准备好了BBBAndroid镜像。拔掉BBB的电源线和USB线以关闭它。
- en: Then, power up the BBB to verify that Android boots properly with the modifications
    that you have just made.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，启动BBB以验证Android是否能够正确引导并应用您刚刚进行的修改。
- en: Pushing PacktHAL files under Windows
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows下推送PacktHAL文件
- en: You must locate where your `adb.exe` file is located. It is part of the platform
    tools in the Android SDK. In the following instructions, we are assuming that
    you installed the Eclipse ADT in the `c:\adt-bundle` directory, making the full
    path to `adb` to be `c:\adt-bundle\sdk\platform-tools\adb.exe`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须找到`adb.exe`文件的位置。它是Android SDK中的平台工具的一部分。在以下说明中，我们假设您将Eclipse ADT安装在`c:\adt-bundle`目录中，使得`adb`的完整路径为`c:\adt-bundle\sdk\platform-tools\adb.exe`。
- en: 'The following steps are used in order to publish PacktHAL files under Windows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤用于在Windows下发布PacktHAL文件：
- en: 'Before you get started, make sure that `adb` can see your BBB by using the
    `adb devices` command. The BBB will report as having a serial number of `BBBAndroid`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始之前，请确保`adb`可以通过使用`adb devices`命令看到您的BBB。BBB将报告具有`BBBAndroid`的序列号：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Why can''t Windows find my BBB?**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么Windows找不到我的BBB？
- en: It can be notoriously difficult to get `adb` to see Android devices under Windows.
    This is because each hardware manufacturer that creates an Android device provides
    its own Windows ADB device driver that Windows uses to talk to that device. BBBAndroid
    reports the USB device ID of its ADB interface as `18D1:4E23`, which is the device
    ID of a Google Nexus S. This device is one of the (many) USB devices that are
    supported by Koushik Dutta's excellent Universal ADB driver for Windows. If `adb`
    can't find your BBB, install the Universal ADB driver and then try again. You
    can download the driver from [http://www.koushikdutta.com/post/universal-adb-driver](http://www.koushikdutta.com/post/universal-adb-driver).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows下让`adb`看到Android设备可能非常困难。这是因为每个创建Android设备的硬件制造商都提供自己的Windows ADB设备驱动程序，Windows使用该驱动程序与该设备通信。BBBAndroid报告其ADB接口的USB设备ID为`18D1:4E23`，这是Google
    Nexus S的设备ID。这个设备是Koushik Dutta出色的Universal ADB驱动程序支持的（众多）USB设备之一。如果`adb`找不到您的BBB，请安装Universal
    ADB驱动程序，然后重试。您可以从[http://www.koushikdutta.com/post/universal-adb-driver](http://www.koushikdutta.com/post/universal-adb-driver)下载驱动程序。
- en: 'Once you have verified this, `adb` can see the BBB, shell into Android via
    `adb`, and remount the read-only `rootfs` filesystem as read-write:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您验证了这一点，`adb`可以看到BBB，通过`adb`进入Android，并将只读的`rootfs`文件系统重新挂载为读写：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, push the necessary files into Android''s `rootfs` filesystem:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将必要的文件推送到Android的`rootfs`文件系统中：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, shell into Android''s `rootfs` filesystem to sync it and remount it
    as read-only:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过Android的`rootfs`文件系统进入shell以同步它并重新挂载为只读：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You have now prepared your BBBAndroid image for PacktHAL under Windows. Remove
    the power supply cable and USB cable from your BBB to shut it down. Then, power
    up the BBB to verify that Android boots properly with the modifications that you
    have just made.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在已经为Windows下的PacktHAL准备好了BBBAndroid镜像。拔掉BBB的电源线和USB线以关闭它。然后，启动BBB以验证Android是否能够正确引导并应用您刚刚进行的修改。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Why is it that the init.genericam33xx(flatteneddevicetr.rc file is named
    so oddly?**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么init.genericam33xx(flatteneddevicetr.rc文件的命名如此奇怪？
- en: Android devices have a set of read-only properties that describe the hardware
    and software of the system to apps and managers. One of these properties is `ro.hardware`,
    which describes the hardware that the kernel is configured for. Device-specific
    `.rc` files in Android have the `init.{ro.hardware}.*rc` form.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备具有一组只读属性，用于向应用程序和管理器描述系统的硬件和软件。其中一个属性是`ro.hardware`，它描述了内核配置的硬件。Android中的特定设备`.rc`文件采用`init.{ro.hardware}.*rc`的形式。
- en: In the Linux kernel source, the `arch/arm/mach-omap2/board-generic.c` file uses
    a `DT_MACHINE_START()` macro to specify the name of the BBB platform as `Generic
    AM33XX (Flattened Device Tree)`. This text string is converted to lowercase, spaces
    are removed, and the string is truncated to produce the final string that is stored
    in the `ro.hardware` property.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux内核源代码中，`arch/arm/mach-omap2/board-generic.c`文件使用`DT_MACHINE_START()`宏来指定BBB平台的名称为`Generic
    AM33XX (Flattened Device Tree)`。此文本字符串转换为小写，去除空格，并截断字符串以生成存储在`ro.hardware`属性中的最终字符串。
- en: Setting up the Android NDK for PacktHAL
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为PacktHAL设置Android NDK
- en: Unfortunately, the Android **Native Development Kit** (**NDK**) is missing a
    kernel header file that is needed to build PacktHAL. The missing header describes
    the interface between user space apps and the generic SPI driver (`spidev`, which
    you will use in [Chapter 5](part0035_split_000.html#page "Chapter 5. Interfacing
    with High-speed Sensors Using SPI"), *Interfacing with High-speed Sensors Using
    SPI*). It is not the fault of the NDK that this header file is missing, as usually
    apps will never need direct access to the `spidev` driver.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Android **Native Development Kit** (**NDK**)缺少构建PacktHAL所需的内核头文件。缺少的头文件描述了用户空间应用程序与通用SPI驱动（`spidev`，您将在[第5章](part0035_split_000.html#page
    "第5章. 使用SPI接口与高速传感器进行交互")中使用的*使用SPI接口与高速传感器进行交互*）之间的接口。NDK缺少这个头文件并不是它的错，因为通常应用程序永远不需要直接访问`spidev`驱动程序。
- en: As you are using an app to talk directly talk to the hardware, you will need
    to copy this missing header into your NDK installation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您正在使用应用程序直接与硬件通信，因此您需要将此缺失的头文件复制到您的NDK安装中。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For your convenience, we have included a copy of this header file in the PacktHAL
    source tarball. You only need to copy the file into your NDK installation prior
    to building PacktHAL.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的方便，我们在PacktHAL源代码tarball中包含了此头文件的副本。在构建PacktHAL之前，您只需要将文件复制到您的NDK安装中。
- en: BBBAndroid is 4.4.4 KitKat, and API level 19 is the highest level supported
    by this version. You will be building all of the examples in this book for API
    level 19\. Each API level has a different set of headers in the NDK, so you must
    add the missing headers to the `include/linux` directory for API level 19\. If
    you decide to build apps at lower API levels, you can repeat the following steps
    to add the additional header file to any of the other API levels that you wish
    to.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: BBBAndroid是4.4.4 KitKat，API级别19是该版本支持的最高级别。您将为API级别19构建本书中的所有示例。每个API级别在NDK中都有不同的头文件集，因此您必须将缺少的头文件添加到API级别19的`include/linux`目录中。如果决定在较低的API级别构建应用程序，可以重复以下步骤，将额外的头文件添加到希望的任何其他API级别。
- en: Adding the header to the NDK under Linux
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linux下将头文件添加到NDK
- en: 'If you are going to be building apps using Eclipse ADT under Linux, you will
    need to have the Android NDK installed on your Linux system. For these instructions,
    we will assume that you have already installed the NDK to the `android-ndk` folder
    in your `$HOME` directory. As you have already downloaded, decompressed, and untarred
    the `PacktHAL.tgz` file to your `$HOME` directory earlier in this chapter, we
    will assume that the `PacktHAL` directory that you created is still there:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在Linux下使用Eclipse ADT构建应用程序，需要在Linux系统上安装Android NDK。对于这些说明，我们将假设您已经将NDK安装到`$HOME`目录中的`android-ndk`文件夹中。由于在本章的前面部分已经下载、解压缩和解压了`PacktHAL.tgz`文件到您的`$HOME`目录，我们将假设您创建的`PacktHAL`目录仍然存在：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will copy the contents of the `spi` header file directory into your NDK
    header files. Your Linux NDK installation now has the extra header file that it
    needs to build PacktHAL.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`spi`头文件目录的内容复制到您的NDK头文件中。您的Linux NDK安装现在已经有了构建PacktHAL所需的额外头文件。
- en: Adding the header to the NDK under Windows
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows下将头文件添加到NDK
- en: 'If you are going to be building apps using Eclipse ADT under Windows, you will
    need to have the Android NDK installed on your Windows system. For these instructions,
    we will assume that you have installed the NDK to the `c:\android-ndk` folder.
    As you have already downloaded, decompressed, and untarred the `PacktHAL.tgz`
    file to your `c:\` directory earlier in this chapter, we will assume that the
    `PacktHAL` directory that you created is still there:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要在Windows下使用Eclipse ADT构建应用程序，需要在Windows系统上安装Android NDK。对于这些说明，我们将假设您已经将NDK安装到`c:\android-ndk`文件夹中。由于在本章的前面部分已经下载、解压缩和解压了`PacktHAL.tgz`文件到您的`c:\`目录，我们将假设您创建的`PacktHAL`目录仍然存在：
- en: Open a file explorer window and navigate to the `c:\android-ndk\platforms\android-19\arch-arm\usr\include\linux`
    path.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件资源管理器窗口，导航到`c:\android-ndk\platforms\android-19\arch-arm\usr\include\linux`路径。
- en: Open a second file explorer window and navigate to the `c:\PacktHAL\prebuilt`
    path. Right-click on the `spi` directory and select **Copy** from the context
    menu.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个文件资源管理器窗口，导航到`c:\PacktHAL\prebuilt`路径。右键单击`spi`目录，然后从上下文菜单中选择**复制**。
- en: Change to the Android NDK window, right-click anywhere within the white space
    of the file list in the window, and select **Paste** from the context menu.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到Android NDK窗口，在窗口的文件列表的空白处右键单击，然后从上下文菜单中选择**粘贴**。
- en: This will copy the contents of the `spi` header file directory into your NDK
    header files. Your Windows NDK installation now has the extra header file that
    it needs to build PacktHAL.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`spi`头文件目录的内容复制到您的NDK头文件中。您的Windows NDK安装现在已经有了构建PacktHAL所需的额外头文件。
- en: Multiplexing the BBB pins
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多路复用BBB引脚
- en: As accessing hardware resources follows the same process under Android as it
    does under Linux, it is important to understand how the Linux kernel configures
    device drivers and allocates them to particular pieces of hardware. It is also
    necessary to understand how these kernel drivers provide user space interfaces
    that PacktHAL can interact with.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在Android下访问硬件资源与在Linux下的过程相同，因此了解Linux内核如何配置设备驱动程序并将它们分配给特定的硬件部件非常重要。还需要了解这些内核驱动程序如何提供用户空间接口，PacktHAL可以与之交互。
- en: The BBB's AM3359 processor offers a wide variety of signals on its hundreds
    of pins. These signals include many different, specialized interface buses and
    sensor inputs. There are far too many potential signals for the number of pins
    available to supply these signals to the outside world. To select which signals
    are available on the pins, the pins are multiplexed, or *muxed*, to specific signals.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: BBB的AM3359处理器在其数百个引脚上提供了各种信号。这些信号包括许多不同的、专门的接口总线和传感器输入。可用的信号远远超过了可用于将这些信号提供给外部世界的引脚数量。为了选择在引脚上可用的信号，引脚被多路复用到特定的信号上。
- en: Several of the processor's pins are wired to the connections of the BBB's P8
    and P9 headers. The muxing of these particular pins is of great interest to BBB
    users, as the muxing determines which processor signals and features are easily
    accessible to the user for hardware interfacing. There are 46 pins on each of
    the BBB's two headers, giving you a total of 92 pins to interface with. Unfortunately,
    61 of these pins are in use by default, meaning that only 31 pins can be changed
    around for your projects without you having to disable one or more standard features
    of the BBB to make more pins available.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器的几个引脚连接到BBB的P8和P9引脚的连接。这些特定引脚的复用对BBB用户非常重要，因为复用确定了哪些处理器信号和功能对用户来说易于访问，用于硬件接口。BBB的两个引脚头上各有46个引脚，总共有92个引脚可供接口使用。不幸的是，默认情况下有61个引脚正在使用中，这意味着只有31个引脚可以在您不必禁用BBB的一个或多个标准功能的情况下用于项目。
- en: '![Multiplexing the BBB pins](img/00008.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![多路复用BBB引脚](img/00008.jpeg)'
- en: The P8 and P9 expansion headers of the BeagleBone Black
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: BeagleBone Black的P8和P9扩展头
- en: Some pins on the headers are permanently assigned, such as the pins that provide
    access to voltage (1.8, 3.3, and 5 VDC are available) and ground signals. The
    other pins though, can be muxed to meet the needs of your project. Proper muxing
    all of the P8/P9 pins to provide all of the resources that you require can sometimes
    be tricky, particularly if you are only beginning to learn about the hardware
    interfacing aspects of the BBB. Luckily, we have already determined a pinmux configuration
    for you that will provide PacktHAL with all of the hardware resources that it
    needs to run all of the exercises in this book.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 标头上的一些引脚是永久分配的，例如提供电压（1.8、3.3和5 VDC可用）和地信号的引脚。但其他引脚可以进行复用，以满足项目的需求。正确地复用所有P8/P9引脚以提供您所需的所有资源有时可能会有些棘手，特别是如果您刚开始学习BBB的硬件接口方面。幸运的是，我们已经为您确定了一个引脚复用配置，可以为PacktHAL提供本书中所有练习所需的所有硬件资源。
- en: '![Multiplexing the BBB pins](img/00009.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![复用BBB引脚](img/00009.jpeg)'
- en: Default pins in use on the BeagleBone Black
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: BeagleBone Black上使用的默认引脚
- en: The kernel Device Tree and capemgr
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核设备树和capemgr
- en: The pins of the BBB must be muxed in a specific way to speak with custom hardware,
    but where and how is this actually done? The answer is "the kernel's **Device
    Tree**." The Device Tree is a hierarchical data structure inside the kernel that
    describes what hardware is present, which resources are used by that hardware,
    and which kernel drivers should be used to talk to each hardware device. It describes
    different facets of the hardware, such as pin muxing settings, clock speeds, and
    parameters that are passed to kernel device drivers.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: BBB的引脚必须以特定方式进行复用，以便与自定义硬件通信，但这实际上是在哪里和如何完成的呢？答案是“内核的**设备树**”。设备树是内核内部的分层数据结构，描述了哪些硬件存在，该硬件使用哪些资源，以及应该使用哪些内核驱动程序与每个硬件设备通信。它描述了硬件的不同方面，例如引脚复用设置、时钟速度和传递给内核设备驱动程序的参数。
- en: It would be an annoying hassle if the user was required to install a new kernel
    every time the hardware changed. For a hardware platform like the BBB, the user
    can change the hardware connected to the BBB between power cycles! It would be
    very useful to be able to dynamically change the Device Tree to add or remove
    hardware on the fly. The BBB's Linux 3.8 kernel has a special subsystem, called
    the **cape manager** (**capemgr**) that allows you to do just that.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户需要在硬件更改时安装新内核，那将是一个令人讨厌的麻烦。对于像BBB这样的硬件平台，用户可以在两次电源循环之间更改连接到BBB的硬件！能够动态更改设备树以在运行时添加或删除硬件将非常有用。BBB的Linux
    3.8内核有一个特殊的子系统，称为**cape管理器**（**capemgr**），可以做到这一点。
- en: 'The capemgr dynamically adds and removes pieces or *overlays* of the Device
    Tree. It provides three important services:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: capemgr动态添加和删除设备树的部分或*叠加*。它提供了三项重要服务：
- en: It recognizes any cape hardware that is connected to the BBB
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它识别连接到BBB的任何cape硬件
- en: It loads the appropriate Device Tree overlay to enable and configure each recognized
    cape
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它加载适当的设备树叠加以启用和配置每个识别的cape
- en: It allows arbitrary Device Tree overlays to be loaded dynamically from user
    space to configure any hardware that is not automatically discovered
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许从用户空间动态加载任意设备树叠加，以配置任何未自动发现的硬件
- en: Defining a cape
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义cape
- en: A cape is any hardware add-on that connects to the BBB's P8/P9 connectors (similar
    to how shield boards connect to an Arduino) and contains an **electrically erasable
    programmable read-only memory** (**EEPROM**) chip that reports the cape's identity
    to the kernel's capebus. The capemgr in the kernel can then dynamically enable
    the appropriate Device Tree overlay for that particular cape. This is what allows
    you to connect a variety of different, commercially available cape boards to the
    BBB, and they all just automatically work without you having to change a single
    configuration file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: cape是连接到BBB的P8/P9连接器的任何硬件附加件（类似于Arduino连接到盾板），并包含一个**电可擦可编程只读存储器**（**EEPROM**）芯片，该芯片向内核的capebus报告cape的身份。内核中的capemgr然后可以动态启用该特定cape的适当设备树叠加。这就允许您连接各种不同的商用cape板到BBB，它们都可以自动工作，而无需您更改任何配置文件。
- en: A much looser definition of a cape is any external circuitry that interfaces
    via the P8/P9 connectors. Without including an EEPROM that tells the capemgr "I
    am a cape and my name is XYZ", the capemgr won't automatically locate and load
    the proper Device Tree overlay for the cape. This is the case for all of the examples
    in this book. You can still consider the hardware that you connect to the BBB
    to be a cape that Android is interfacing with, but the Device Tree overlay must
    be loaded manually from user space.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: cape的更宽松定义是通过P8/P9连接器进行接口的任何外部电路。如果不包括一个EEPROM，告诉capemgr“我是一个cape，我的名字是XYZ”，capemgr就不会自动定位和加载cape的适当设备树叠加。这是本书中所有示例的情况。您仍然可以将连接到BBB的硬件视为Android正在接口的cape，但是设备树叠加必须从用户空间手动加载。
- en: Earlier in this chapter, you used `adb` to push a file named `BB-PACKTPUB-00A0.dtbo`
    to your Android image. This file is the Device Tree overlay that configures the
    BBB for the hardware that you will use in the exercises throughout this book.
    The custom `init.genericam33xx(flatteneddevicetr.rc` file that you also pushed
    over to the Android image manually loads this overlay for you during Android's
    boot process.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，您使用`adb`将名为`BB-PACKTPUB-00A0.dtbo`的文件推送到了您的Android镜像中。这个文件是设备树叠加，用于配置BBB以便您在本书中的练习中使用的硬件。您还手动将自定义的`init.genericam33xx(flatteneddevicetr.rc`文件推送到Android镜像中，这个文件在Android的引导过程中会为您加载这个叠加。
- en: In the Linux filesystem, custom overlays are placed into the `/lib/firmware`
    directory. Under Android, however, there is no `/lib` directory in `rootfs`, so
    overlays are instead placed into the `/system/vendor/firmware` directory. This
    is also the location where firmware (`.fw` files) built during kernel compilation
    is installed. When using your own Device Tree overlays for your future projects,
    remember to place them into the `/system/vendor/firmware` directory so that the
    capemgr can find them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux文件系统中，自定义覆盖层被放置在`/lib/firmware`目录中。然而，在Android中，`rootfs`中没有`/lib`目录，因此覆盖层被放置在`/system/vendor/firmware`目录中。这也是内核编译过程中安装固件（`.fw`文件）的位置。在将来的项目中使用自己的设备树覆盖层时，请记得将它们放置在`/system/vendor/firmware`目录中，以便capemgr可以找到它们。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Where can I learn more about multiplexing the BBB''s pins, the Device Tree,
    and creating custom overlays?**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**我在哪里可以了解更多关于BBB引脚复用、设备树和创建自定义覆盖层的知识？**'
- en: 'Learning how to select the best pin muxing for custom projects and creating
    the appropriate Device Tree overlays are outside the scope of this book, but there
    are many excellent resources available that can introduce you to the process.
    Here are a few great resources we recommend that you read to learn more:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何为自定义项目选择最佳引脚复用和创建适当的设备树覆盖层超出了本书的范围，但有许多优秀的资源可供学习这个过程。以下是一些我们推荐您阅读以了解更多的优秀资源：
- en: 'The BeagleBone Black System reference manual: [http://www.adafruit.com/datasheets/BBB_SRM.pdf](http://www.adafruit.com/datasheets/BBB_SRM.pdf)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BeagleBone Black系统参考手册：[http://www.adafruit.com/datasheets/BBB_SRM.pdf](http://www.adafruit.com/datasheets/BBB_SRM.pdf)
- en: 'Derek Molloy''s website: [http://derekmolloy.ie/category/embedded-systems/beaglebone/](http://derekmolloy.ie/category/embedded-systems/beaglebone/)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Derek Molloy的网站：[http://derekmolloy.ie/category/embedded-systems/beaglebone/](http://derekmolloy.ie/category/embedded-systems/beaglebone/)
- en: 'AdaFruit''s Device Tree Overlay tutorial: [https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree](https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AdaFruit的设备树覆盖层教程：[https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree](https://learn.adafruit.com/introduction-to-the-beaglebone-black-device-tree)
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explained how Android uses a HAL to allow Android managers
    to provide hardware access to apps. We introduced you to PacktHAL that can be
    used to interface with all of the examples throughout this book. You configured
    your BBBAndroid image to use PacktHAL, and you modified your NDK installation
    to build PacktHAL into your apps.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们解释了Android如何使用HAL允许Android管理器为应用程序提供硬件访问。我们向您介绍了PacktHAL，它可以用于与本书中的所有示例进行接口。您配置了BBBAndroid镜像以使用PacktHAL，并修改了NDK安装以将PacktHAL构建到您的应用程序中。
- en: We also showed which pins of the BBB's P8/P9 headers can be multiplexed, what
    the Device Tree is and how it is used to multiplex pins, and how the capemgr loads
    Device Tree overlays to dynamically mux the BBB's pins.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还展示了BBB的P8/P9引脚头可以进行复用，设备树是什么以及如何用它来进行引脚复用，以及capemgr如何加载设备树覆盖层来动态复用BBB的引脚。
- en: In the next chapter, you'll put PacktHAL to work and build your first hardware-interfacing
    app using GPIOs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将使用PacktHAL并使用GPIO构建您的第一个硬件接口应用程序。
