- en: '*Chapter 5*: Object-Oriented Programming in C#'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：C#中的面向对象编程'
- en: In the previous chapter, we covered user-defined types and learned about classes,
    structures, and enumerations. In this chapter, we will learn about **object-oriented
    programming** (or **OOP** for short). A good understanding of OOP concepts is
    essential to write better programs using C#. OOP reduces code complexity, increases
    code reusability, and makes software easy to maintain and scale.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了用户定义类型，并学习了类、结构和枚举。在本章中，我们将学习**面向对象编程**（简称**OOP**）。对OOP概念的深入理解对使用C#编写更好的程序至关重要。面向对象编程可以减少代码复杂性，增加代码可重用性，并使软件易于维护和扩展。
- en: 'We will cover the following concepts in detail:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细介绍以下概念：
- en: Understanding OOP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解面向对象编程
- en: Abstraction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: Encapsulation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Inheritance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Polymorphism
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: SOLID principles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID原则
- en: By the end of this chapter, you will learn how to create classes and methods
    using OOP. Let's begin with an overview of OOP.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将学会如何使用面向对象编程创建类和方法。让我们从面向对象编程的概述开始。
- en: Understanding OOP
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解面向对象编程
- en: Object-oriented programming is a paradigm that allows us to write a program
    around objects. As discussed in the previous chapter, objects contain data and
    methods to act on that data. Each object has its own set of data and methods.
    If an object wants to access the data of another object, it has to access it via
    the methods defined in that object. An object can inherit the properties of another
    object using the concept of **inheritance**. Hence, we can say that object-oriented
    programming is organized around data and the operations that are permitted on
    the data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是一种允许我们围绕对象编写程序的范式。正如前一章中讨论的，对象包含数据和用于操作该数据的方法。每个对象都有自己的一组数据和方法。如果一个对象想要访问另一个对象的数据，它必须通过该对象中定义的方法进行访问。一个对象可以使用**继承**的概念继承另一个对象的属性。因此，我们可以说面向对象编程是围绕数据和允许对数据进行的操作组织起来的。
- en: C# is a general-purpose multi-paradigm programming language. OOP is only one
    of these paradigms. Other supported paradigms, such as generic and functional
    programming, will be discussed in later chapters.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: C#是一种通用多范式编程语言。面向对象编程只是其中的一种范式。其他支持的范式，如泛型和函数式编程，将在后续章节中讨论。
- en: When discussing object-oriented programming, it is important to understand the
    differences between classes and objects. As mentioned already, in the previous
    chapter, a class is a blueprint that defines data and how it is represented in
    memory as well as functionalities that operate on this data. On the other hand,
    an object is an instance of a class built and functioning according to the blueprint.
    It has a physical representation in memory, unlike a class that only exists in
    source code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论面向对象编程时，了解类和对象之间的区别是很重要的。如前所述，在上一章中，类是定义数据及其在内存中的表示以及操作这些数据的功能的蓝图。另一方面，对象是根据蓝图构建和运行的类的实例。它在内存中有一个物理表示，而类只存在于源代码中。
- en: When you do object-oriented programming, you start with identifying the entities
    you need to operate on, how they relate to each other, and how they interact.
    This is a process called **data modeling**. The result of this is a set of classes
    that generalize the identified entities. These can vary from physical entities
    (people, objects, machines, and so on) to abstractions (an order, a to-do list,
    a connection string, and so on).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行面向对象编程时，您首先要确定需要操作的实体，它们之间的关系以及它们如何相互作用。这个过程称为**数据建模**。其结果是一组概括了确定实体的类。这些实体可以是从物理实体（人、物体、机器等）到抽象实体（订单、待办事项列表、连接字符串等）的各种形式。
- en: Abstraction, encapsulation, polymorphism, and inheritance are the core principles
    of object-oriented programming. We will explore them in detail in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象、封装、多态和继承是面向对象编程的核心原则。我们将在本章中详细探讨它们。
- en: Abstraction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象
- en: Abstraction is the process of describing entities and processes in simple terms
    by removing non-essential characteristics. A physical or abstract entity may have
    many characteristics but for the purpose of some application or domain, not all
    of them are important. By abstracting entities into simple models (that make sense
    for the application domain), we can build simpler and more efficient programs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是通过去除非必要的特征来以简单的方式描述实体和过程的过程。一个物理或抽象实体可能有许多特征，但是对于某些应用程序或领域的目的，并不是所有特征都是重要的。通过将实体抽象为简单模型（对应应用程序领域有意义的模型），我们可以构建更简单、更高效的程序。
- en: Let's consider the example of an employee. An employee is a person. A person
    has a name; a birthday; body characteristics, such as height, weight, hair color,
    and eye color; relatives and friends; likes and hobbies (such as food, books,
    movies, and sports); an address; properties (such as a house or apartment and
    cars or bikes); one or more phone numbers and email addresses; and many other
    things that we could fill pages listing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以员工为例。员工是一个人。一个人有姓名、生日、身体特征（如身高、体重、头发颜色、眼睛颜色）、亲戚和朋友、喜欢的爱好（如食物、书籍、电影、运动）、地址、财产（如房屋或公寓、汽车或自行车）、一个或多个电话号码和电子邮件地址，以及我们可以列出的许多其他事物。
- en: Depending on the kind of application we are building, some of these are relevant
    and some are not. For instance, if we build a payroll system, we are interested
    in an employee's name, birthday, address, phone, and email, as well as hiring
    date, department, role, salary, and so on. If we build a social media application,
    we are interested in a user's name, birthday, address, relatives, friends, interests,
    activities, and more.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们构建的应用程序的类型，其中一些特征是相关的，而另一些则不是。例如，如果我们构建一个工资系统，我们对员工的姓名、生日、地址、电话和电子邮件感兴趣，以及入职日期、部门、职位、工资等。如果我们构建一个社交媒体应用程序，我们对用户的姓名、生日、地址、亲戚、朋友、兴趣、活动等感兴趣。
- en: Sometimes, different levels of abstraction are required—some more general, others
    more particular. For instance, if we build a graphical system that can draw shapes,
    we might need to model a generic shape with little functionalities, such as the
    ability to draw itself or transform (translate and rotate) itself. We can then
    have two-dimensional shapes and three-dimensional shapes, each with more specific
    properties and functionalities based on the characteristics of these shapes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要不同级别的抽象 - 一些更一般的，另一些更具体的。例如，如果我们构建一个可以绘制形状的图形系统，我们可能需要用少量功能模拟一个通用形状，比如能够自己绘制或变换（平移和旋转）的能力。然后我们可以有二维形状和三维形状，每个都有更具体的属性和功能，基于这些形状的特征。
- en: We can build lines, ellipses, and polygons as two-dimensional shapes. A line
    has properties such as a start point and an end point, but an ellipse has two
    foci, as well as an area and a perimeter. Three-dimensional objects, such as a
    cube, can drop shadows. Although we are still abstracting concepts, we have moved
    from more general to more particular abstractions. When these abstractions are
    based on each other, the typical way to implement them is through inheritance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将线条、椭圆和多边形构建为二维形状。一条线有诸如起点和终点之类的属性，但一个椭圆有两个焦点，以及一个面积和周长。三维对象，如立方体，可以投下阴影。虽然我们仍在抽象概念，但我们已经从更一般的抽象转向更具体的抽象。当这些抽象是基于彼此的时，实现它们的典型方式是通过继承。
- en: Encapsulation
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation is defined as binding data and code that manipulates it together
    in a single unit. Data is privately bound within a class without direct access
    from the outside of the class. All objects that need to read or modify the data
    of an object should do it through the public methods that a class provides. This
    characteristic is called **data hiding** and makes code less error-prone by defining
    a limited number of entry points to an object's data.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 封装被定义为将数据和操作数据的代码绑定在一个单元中。数据被私下绑定在一个类中，外部无法直接访问。所有需要读取或修改对象数据的对象都应该通过类提供的公共方法来进行。这种特性被称为**数据隐藏**，通过定义有限数量的对象数据入口点，使代码更不容易出错。
- en: 'Let''s take a look at the `Employee` class here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这里的`Employee`类：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An employee has two properties modeled here: `name` and `salary`. These are
    implemented as `private` class fields, which makes them accessible only from within
    the `Employee` class. Both of these values are set in the constructor. The name
    is exposed for reading and writing using the property called `Name`. The `salary`
    variable is, however, only exposed for reading, with the read-only property called
    `Salary`. To change the salary, we must call the `GiveRaise()` method. Of course,
    this is just a possible implementation. We could have used auto-implemented properties
    instead of fields, or maybe different other methods to modify the salary. This
    class can be used as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里模拟了员工有两个属性：`name`和`salary`。这些被实现为`private`类字段，这使它们只能从`Employee`类内部访问。这两个值在构造函数中设置。名字通过名为`Name`的属性暴露出来以供读取和写入。然而，`salary`变量只暴露出来供读取，使用名为`Salary`的只读属性。要更改工资，我们必须调用`GiveRaise()`方法。当然，这只是一种可能的实现。我们可以使用自动实现的属性而不是字段，或者可能使用不同的其他方法来修改工资。这个类可以如下使用：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have created an object of the `Employee` class and set the values to the
    private fields using the constructor. The `Employee` class does not allow direct
    access to its fields. To read their values, we use the public `get` accessor of
    the public properties. To change the salary, we use the `GiveRaise()` method.
    The output of this program is as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`Employee`类的对象，并使用构造函数将值设置为私有字段。`Employee`类不允许直接访问其字段。要读取它们的值，我们使用公共属性的`get`访问器。要更改工资，我们使用`GiveRaise()`方法。该程序的输出如下所示：
- en: '![Figure 5.1 – The console output from the execution of the preceding snippet'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 - 从前面片段的执行中得到的控制台输出'
- en: '](img/Figure_5.1_B12346.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.1_B12346.jpg)'
- en: Figure 5.1 – The console output from the execution of the preceding snippet
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 - 从前面片段的执行中得到的控制台输出
- en: Encapsulation allows us to hide the data inside a class from the outside world,
    which is why it is also known as data-hiding.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 封装允许我们将类内部的数据隐藏起来，这就是为什么它也被称为数据隐藏。
- en: Encapsulation is important because it reduces the dependencies between different
    components by defining minimal public interfaces for them. It also increases code
    reusability and security and makes code easier to unit test.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 封装很重要，因为它通过为不同组件定义最小的公共接口来减少它们之间的依赖关系。它还增加了代码的可重用性和安全性，并使代码更容易进行单元测试。
- en: Inheritance
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is a mechanism through which a class can inherit the properties
    and functionalities of another class. If we have a set of common functionalities
    and data shared among multiple classes, we can put them in one class known as
    a **parent** or **base** class. Other classes can inherit these functionalities
    and data of the parent class as well as extending or modifying them and adding
    additional functionalities and properties. A class that inherits from another
    class is known as a **child** or **derived** class. Inheritance, therefore, facilitates
    *code reusability*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一种机制，通过它一个类可以继承另一个类的属性和功能。如果我们有一组多个类共享的常见功能和数据，我们可以将它们放在一个称为**父**或**基**类的类中。其他类可以继承父类的这些功能和数据，同时扩展或修改它们并添加额外的功能和属性。从另一个类继承的类称为**子**或**派生**类。因此，继承有助于*代码重用*。
- en: In C#, inheritance is only supported for reference types. Only types defined
    as classes can be derived from other types. Types that are defined as structures
    are value types and cannot be derived from other types. However, all types in
    C# are either value or reference types and are indirectly derived from the `System.Object`
    type. This relationship is implicit and does not require developers to do anything
    special.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，继承仅支持引用类型。只有定义为类的类型才能从其他类型派生。定义为结构的类型是值类型，不能从其他类型派生。但是，在C#中，所有类型都是值类型或引用类型，并且间接从`System.Object`类型派生。这种关系是隐式的，不需要开发人员做任何特殊处理。
- en: 'There are three types of inheritance supported in C#:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: C#支持三种类型的继承：
- en: '**Single inheritance**: When a class inherits from one parent class. The child
    class should not act as the parent class to any other class. Refer to the following
    diagram, where class B is inheriting for class A:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一继承：当一个类从一个父类继承时。子类不应该作为任何其他类的父类。参考下图，类B从类A继承：
- en: '![Figure 5.2 – A class diagram showing class B inheriting from class A'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 - 类图显示类B从类A继承'
- en: '](img/Figure_5.2_B12346.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.2_B12346.jpg)'
- en: Figure 5.2 – A class diagram showing class B inheriting from class A
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 - 类图显示类B从类A继承
- en: '**Multilevel inheritance**: This is actually an extension to the previous case,
    because the child is, on the other hand, a parent to another class. In the following
    diagram, class B is a child class to class A as well as the parent to class C:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多级继承：这实际上是对前一种情况的扩展，因为子类又是另一个类的父类。在下图中，类B既是类A的子类，也是类C的父类：
- en: '![Figure 5.3 – A class diagram showing class A being the base class for class
    B, which in turn is the base for class C'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 - 类图显示类A作为类B的基类，而类B又是类C的基类'
- en: '](img/Figure_5.3_B12346.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.3_B12346.jpg)'
- en: Figure 5.3 – A class diagram showing class A being the base class for class
    B, which in turn is the base for class C
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - 类图显示类A作为类B的基类，而类B又是类C的基类
- en: '**Hierarchical inheritance**: A class serves as the parent class to more than
    one class. Refer to the following diagram. Here, the classes B and C inherit from
    the same parent class, A:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分层继承：一个类作为多个类的父类。参考下图。这里，类B和类C都继承自同一个父类A：
- en: '![Figure 5.4 – A class diagram showing classes B and C inheriting from the
    base class A'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.4 - 类图显示类B和类C从基类A继承'
- en: '](img/Figure_5.4_B12346.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.4_B12346.jpg)'
- en: Figure 5.4 – A class diagram showing classes B and C inheriting from the base
    class A
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 - 类图显示类B和类C从基类A继承
- en: Unlike other programming languages (such as C++), C# does not support multiple
    inheritance. This means that a class cannot be derived from more than one class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他编程语言（如C++）不同，C#不支持多重继承。这意味着一个类不能从多个类派生。
- en: 'To understand inheritance, let''s consider the following example: we are building
    a game that must represent objects such as terrain, obstacles, people, machinery,
    and so on. These are various types of objects with different properties. For instance,
    people and machines can move and battle, obstacles can be destroyed, terrain can
    be crossable or not, and so on. However, all of these game objects have some common
    properties: they all have a position in the game and they all can be drawn on
    a surface (which could be a screen, memory, and so on). We can represent a base
    class that provides these functionalities as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解继承，让我们考虑以下示例：我们正在构建一个必须表示地形、障碍、人物、机械等对象的游戏。这些是具有不同属性的各种类型的对象。例如，人和机器可以移动和战斗，障碍可以被摧毁，地形可以是可穿越的或不可穿越的，等等。然而，所有这些游戏对象都有一些共同的属性：它们都在游戏中有一个位置，并且它们都可以在表面上绘制（可以是屏幕、内存等）。我们可以表示一个提供这些功能的基类如下：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`GameUnit` is a class with a property called `Position`; the accessor `get`
    is public, but the accessor `set` is protected, which means it is only accessible
    from this class or its derived classes. The `Draw()` public method draws the unit
    on a surface at the current unit position. `GetImage()` is a virtual method that
    returns the representation on a unit (which, in our example, is a single character).
    In the base class, this simply returns a space, but in the derived classes, this
    will be implemented to return an actual character.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameUnit`是一个具有名为`Position`的属性的类；访问器`get`是公共的，但访问器`set`是受保护的，这意味着它只能从这个类或它的派生类中访问。`Draw()`公共方法在当前单位位置在表面上绘制单位。`GetImage()`是一个虚方法，返回单位的表示（在我们的例子中是一个单一字符）。在基类中，这只返回一个空格，但在派生类中，这将被实现为返回一个实际字符。'
- en: 'The `Position` and `Surface` classes seen here are implemented as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里看到的`Position`和`Surface`类的实现如下：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From the base class, we will now derive several other classes. To keep it simple,
    we will focus on terrain objects for the time being:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从基类派生出几个其他类。为了简单起见，我们将暂时专注于地形对象：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have defined here a `Terrain` class, derived from `GameUnit`, which is itself
    a base class for all types of terrain. We don''t have many things in this class,
    but in a real application, there would be various functionalities. `Water` and
    `Hill` are two classes derived from `Terrain` that override the `GetImage()` class
    returning a different character to represent the terrain. We can use these as
    follows to build a game:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义了一个从`GameUnit`派生的`Terrain`类，它本身是所有类型地形的基类。在这个类中我们没有太多东西，但在一个真实的应用程序中，会有各种功能。`Water`和`Hill`是从`Terrain`派生的两个类，它们覆盖了`GetImage()`类，返回一个不同的字符来表示地形。我们可以使用这些来构建一个游戏：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of this program is as shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出如下截图所示：
- en: '![Figure 5.5 – The console output from the execution of the previous program'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5 - 前一个程序执行的控制台输出'
- en: '](img/Figure_5.5_B12346.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.5_B12346.jpg)'
- en: Figure 5.5 – The console output from the execution of the previous program
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 - 前一个程序执行的控制台输出
- en: Virtual members
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚成员
- en: In the preceding example, we have seen a virtual method. This is a method that
    has an implementation in a base class but can be overridden in derived classes,
    which is helpful for changing implementation details. Methods are non-virtual
    by default. A virtual method in a base class is declared with the `virtual` keyword.
    An overridden implementation of a virtual method in a derived class is defined
    with the `override` keyword, instead of the `virtual` keyword. The method signature
    of the virtual and overridden methods must match.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们已经看到了一个虚方法。这是一个在基类中有实现但可以在派生类中被重写的方法，这对于改变实现细节很有帮助。方法默认情况下是非虚的。基类中的虚方法使用`virtual`关键字声明。派生类中虚方法的重写实现使用`override`关键字定义，而不是`virtual`关键字。虚方法和重写方法的方法签名必须匹配。
- en: Methods are not the only class members that can be virtual. The `virtual` keyword
    can be applied to properties, indexers, and events. However, the `virtual` modifier
    cannot be used together with `static`, `abstract`, `private`, or `override` modifiers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 方法不是唯一可以是虚的类成员。`virtual`关键字可以应用于属性、索引器和事件。但是`virtual`修饰符不能与`static`、`abstract`、`private`或`override`修饰符一起使用。
- en: A virtual member that is overridden in a derived class can be further overridden
    in a class derived from the derived class. This chain of virtual inheritance continues
    indefinitely unless explicitly stopped with the use of the `sealed` keyword, as
    described in a subsequent section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在派生类中重写的虚成员可以在派生类的派生类中进一步重写。这种虚继承链会无限继续，除非使用`sealed`关键字明确停止，如后续章节所述。
- en: 'The classes shown earlier can be modified to use a virtual property, called
    `Image` in the following code, instead of the virtual method, `GetImage()`. In
    this case, they would look as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的类可以修改为在以下代码中使用虚属性`Image`，而不是虚方法`GetImage()`。在这种情况下，它们将如下所示：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are cases when you want a method to be overridden in derived classes without
    providing an implementation in the base class. Such virtual methods are called
    *abstract* and will be discussed in the next section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你希望一个方法在派生类中被重写，但在基类中不提供实现。这样的虚方法称为*抽象*，将在下一节中讨论。
- en: Abstract classes and members
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类和成员
- en: The examples we have seen so far have an inconvenience because, although the
    `GameUnit` and `Terrain` classes are just some base classes without an actual
    representation in the game, we can still instantiate them. This is unfortunate
    because we would want to be able to only create objects of `Water` and `Hill`.
    Also, the `GetImage()` virtual method or the `Image` virtual property must have
    an implementation in the base class, which does not make much sense. We would
    actually only want to have an implementation in classes representing physical
    objects. This can be achieved using abstract classes and members.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们看到的例子有一个不便之处，因为`GameUnit`和`Terrain`类只是一些在游戏中没有实际表示的基类，我们仍然可以实例化它们。这是不幸的，因为我们只希望能够创建`Water`和`Hill`的对象。此外，`GetImage()`虚方法或`Image`虚属性必须在基类中有一个实现，这并没有太多意义。实际上，我们只希望在表示物理对象的类中有一个实现。这可以通过使用抽象类和成员来实现。
- en: An abstract class is declared using the `abstract` keyword. An abstract class
    cannot be instantiated, which means we cannot create the object of an abstract
    class. If we try to create an instance of an abstract class, it will result in
    a compile-time error. An abstract class is supposed to be the base class for other
    classes that will implement the abstractions that a class defines.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`abstract`关键字声明抽象类。抽象类不能被实例化，这意味着我们不能创建抽象类的对象。如果我们尝试创建抽象类的实例，将导致编译时错误。抽象类应该是其他类的基类，这些类将实现类定义的抽象。
- en: An abstract class must include at least one abstract member, which can be a
    method, property, indexer, or event. Abstract members are also declared using
    the `abstract` keyword. A non-abstract class that derives from an abstract class
    must implement all of the inherited abstract members and property accessors.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类必须包含至少一个抽象成员，可以是方法、属性、索引器或事件。抽象成员也使用`abstract`关键字声明。从抽象类派生的非抽象类必须实现所有继承的抽象成员和属性访问器。
- en: 'We can rewrite the game unit examples using abstract classes and members. This
    is shown in the following listing:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用抽象类和成员重写游戏单位示例。如下所示：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, the `GameUnit` class is declared `abstract`. It has an abstract
    property, `Image`, which no longer has an implementation. `Terrain` is derived
    from `GameUnit` but because it does not override the abstract property, it is
    itself an abstract class and must be declared using the `abstract` modifier. The
    `Water` and `Hill` classes are both overriding the `Image` property, and do so
    using the `override` keyword.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`GameUnit`类被声明为`abstract`。它有一个抽象属性`Image`，不再有实现。`Terrain`是从`GameUnit`派生的，但因为它没有重写抽象属性，它本身是一个抽象类，必须使用`abstract`修饰符声明。`Water`和`Hill`类都重写了`Image`属性，并使用`override`关键字进行了重写。
- en: 'The following are a few features of an abstract class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类的一些特点如下：
- en: An abstract class can have both abstract and non-abstract members.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类可以有抽象和非抽象成员。
- en: If a class contains an abstract member, then the class must be marked `abstract`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类包含抽象成员，则该类必须标记为`abstract`。
- en: An abstract member cannot be private.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象成员不能是私有的。
- en: An abstract member cannot have an implementation.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象成员不能有实现。
- en: An abstract class must provide an implementation for all of the members of all
    of the interfaces it implements (if any).
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类必须为其实现的所有接口的所有成员提供实现（如果有的话）。
- en: 'Similarly, an abstract method or property has the following characteristics:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，抽象方法或属性具有以下特点：
- en: An abstract method is implicitly a virtual method.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象方法隐式地是虚方法。
- en: Members declared abstract cannot be `static` or `virtual`.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明为抽象的成员不能是`static`或`virtual`。
- en: The implementation in a derived class must specify the `override` keyword in
    the declaration of the member.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生类中的实现必须在成员的声明中指定`override`关键字。
- en: So far, we have seen how classes and members can be derived and overridden.
    However, it is possible to prevent this from happening. We will learn how to do
    so in the next section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何派生和重写类和成员。然而，可以阻止这种情况发生。我们将在下一节中学习如何做到这一点。
- en: Sealed classes and members
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封闭类和成员
- en: 'If we want to restrict a class from being inherited by another class, then
    we declare the class as `sealed`. If we try to inherit a sealed class, it will
    result in a compile-time error. We use the `sealed` keyword to create a sealed
    class. Refer to the following example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要限制一个类不被另一个类继承，那么我们将该类声明为`sealed`。如果我们尝试继承一个被封闭的类，将导致编译时错误。我们使用`sealed`关键字来创建一个封闭的类。参考以下示例：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Water` class here is declared `sealed`. An attempt to use it as a base
    class for another class will result in a compile-type error.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`Water`类被声明为`sealed`。尝试将其用作另一个类的基类将导致编译时错误。
- en: Not only can classes be declared as `sealed`, but overridden members can too.
    A class can stop the virtual inheritance of a member by using the `sealed` keyword
    in front of `override`. An attempt to override it again in a further derived class
    will result in a compiler error.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以将类声明为`sealed`，还可以将重写的成员声明为`sealed`。类可以通过在`override`前面使用`sealed`关键字来阻止成员的虚继承。在进一步派生类中再次尝试重写它将导致编译器错误。
- en: 'In the following example, the `Water` class is not sealed, but its `Image`
    property is. Attempting to override it in the `Lake` derived class will produce
    a compiler error:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`Water`类没有被封闭，但其`Image`属性被封闭。尝试在`Lake`派生类中重写它将产生编译器错误：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now that we have seen how to use sealed classes and members, let's see how to
    hide base class members.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用封闭类和成员，让我们看看如何隐藏基类成员。
- en: Hiding base class members
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏基类成员
- en: 'In certain situations, you might want to hide an existing member of a base
    class with a member with the same name in the derived class, without *virtual
    invocation* (which is the invocation of virtual methods within the class hierarchy).
    This is possible by using the `new` keyword in front of the return type of the
    member in the derived class, as shown in the following example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望在派生类中使用`new`关键字在成员的返回类型前面隐藏基类的现有成员，而不是*虚调用*（即在类层次结构中调用虚方法）。可以通过在派生类中成员的返回类型前面使用`new`关键字来实现这一点，如以下示例所示：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A new member defined this way will be invoked when called through a reference
    to the derived type. However, if the member is invoked through a reference to
    the base type, the hidden base member will be called as shown here:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式定义的新成员在通过对派生类型的引用调用时将被调用。然而，如果通过对基类型的引用调用成员，则将调用隐藏的基成员，如下所示：
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Unlike virtual methods, which are invoked at runtime based on the runtime type
    of the object used to invoke them, hidden methods are resolved at compile-time
    based on the compile-time type of the object used to invoke them.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与虚方法不同，虚方法是根据用于调用它们的对象的运行时类型在运行时调用的，隐藏方法是根据用于调用它们的对象的编译时类型在编译时解析的。
- en: 'A possible use for hiding members is shown in the following example, where
    we have a hierarchy of classes that need to support a cloning method. However,
    each class should return a new copy of itself and not a reference to the base
    class:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏成员的一个可能用途在以下示例中显示，我们有一个需要支持克隆方法的类层次结构。然而，每个类应该返回自己的新副本，而不是基类的引用：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With these defined, we can write the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些定义，我们可以编写以下代码：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Notice that this works only when we invoke the `Clone()` method from an object
    of that class, and not through a reference to the base class. Because the invocation
    is resolved at compile time, if you have a reference to `Pet`, even if the runtime
    type of the object is `Dog`, only `Pet` will be cloned. This is exemplified in
    the following sample:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这仅在我们从该类的对象调用`Clone()`方法时才起作用，而不是通过对基类的引用。因为调用在编译时解析，如果你有一个对`Pet`的引用，即使对象的运行时类型是`Dog`，也只会克隆`Pet`。这在以下示例中得到了说明：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Member hiding is, in general, considered a code smell (that is, an indication
    of a deeper problem within the design and the code base) and should be avoided.
    The goals achieved through member hiding can usually be reached by better means.
    For instance, the cloning example shown here can be implemented by using a creational
    design pattern, typically the **Prototype** pattern, but possibly others such
    as the **Factory Method**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，成员隐藏被认为是代码异味（即设计和代码库中存在更深层次问题的指示）并且应该避免。通过成员隐藏实现的目标通常可以通过更好的方式实现。例如，这里显示的克隆示例可以通过使用创建型设计模式，通常是**原型**模式，但可能还有其他模式，如**工厂方法**来实现。
- en: So far in this chapter, we have seen how to create classes and hierarchies of
    classes. Another important concept in object-oriented programming is interfaces,
    which is the topic we will discuss next.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经看到了如何创建类和类的层次结构。面向对象编程中的另一个重要概念是接口，这是我们接下来要讨论的主题。
- en: Interfaces
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: An interface contains a set of members that must be implemented by any class
    or struct that implements the interface. An interface defines a contract that
    is supported by all of the types that implement the interface. This also means
    that the clients using interfaces do not need to know anything about the actual
    implementation details, which promotes loose coupling, which helps with maintenance
    and testability.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接口包含一组必须由实现接口的任何类或结构实现的成员。接口定义了一个由实现接口的所有类型支持的合同。这也意味着使用接口的客户端不需要了解任何关于实际实现细节的信息，这有助于松耦合，有助于维护和可测试性。
- en: Because neither multiple class inheritance nor inheritance for structures is
    supported in the language, interfaces provide a means to simulate them. A type,
    regardless of whether it is a reference type or a value type, can implement any
    number of interfaces.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因为语言不支持多重类继承或结构的继承，接口提供了一种模拟它们的方法。无论是引用类型还是值类型，类型都可以实现任意数量的接口。
- en: Typically, an interface *contains only declarations* of members but *not implementations*.
    Beginning with C# 8, interfaces can contain default methods; this is a subject
    that will be covered in detail in [*Chapter 15*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271),
    *New Features of C# 8*. In C#, interfaces are declared using the `interface` keyword.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，接口*只包含成员的声明*，而*不包含实现*。从C# 8开始，接口可以包含默认方法；这是一个将在[*第15章*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271)中详细介绍的主题，*C#
    8的新特性*。在C#中，接口使用`interface`关键字声明。
- en: 'The following list contains important points to consider when using interfaces:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含在使用接口时需要考虑的重要要点：
- en: An interface can contain only methods, properties, indexers, and events. They
    cannot contain fields.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口只能包含方法、属性、索引器和事件。它们不能包含字段。
- en: If a type implements an interface, then it must provide an implementation for
    all of the members of the interface. The method signature and return type of the
    method of an interface cannot be altered by the type that is implementing the
    interface.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类型实现了一个接口，那么它必须为接口的所有成员提供实现。接口的方法签名和返回类型不能被实现接口的类型改变。
- en: When an interface defines properties or indexers, an implementation can provide
    extra accessors for them. For instance, if a property in an interface has only
    the `get` accessor, the implementation can also provide a `set` accessor.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个接口定义属性或索引器时，实现可以为它们提供额外的访问器。例如，如果接口中的属性只有`get`访问器，实现也可以提供`set`访问器。
- en: An interface cannot have constructors or operators.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口不能有构造函数或运算符。
- en: An interface cannot have static members.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口不能有静态成员。
- en: The interface members are implicitly defined as `public`. If you try to use
    an access modifier with a member of an interface, it will result in a compile-time
    error.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口成员隐式定义为`public`。如果尝试在接口的成员上使用访问修饰符，将导致编译时错误。
- en: An interface can be implemented by multiple types. A type can implement multiple
    interfaces.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接口可以被多种类型实现。一个类型可以实现多个接口。
- en: If a class is inheriting from another class and simultaneously implementing
    an interface, then the base class name must come before the name of the interface
    separated by a comma.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类从另一个类继承并同时实现一个接口，那么基类名称必须在接口名称之前，用逗号分隔。
- en: Typically, an interface name starts with the letter `I`, such as `IEnumerable`,
    `IList<T>`, and so on.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，接口名称以字母`I`开头，比如`IEnumerable`、`IList<T>`等等。
- en: To understand how interfaces work, we will consider the example with game units.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解接口的工作原理，我们将考虑游戏单位的示例。
- en: 'In the previous implementations, we had a class called `Surface`, which was
    responsible for drawing the game objects. Our implementation was printing to the
    console but this could be anything—the game window, memory, a bitmap, and so on.
    To make it possible to easily change between these and not tie the `GameUnit`
    class to a particular implementation of surfaces, we can define an interface that
    will specify the functionalities that any implementation must provide. This interface
    will then be used by the game unit for rendering. Such an interface can be defined
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的实现中，我们有一个名为`Surface`的类，负责绘制游戏对象。我们的实现是打印到控制台，但这可以是任何东西——游戏窗口、内存、位图等等。为了能够轻松地在这些之间进行切换，并且不将`GameUnit`类与特定的表面实现绑定，我们可以定义一个接口，指定任何实现必须提供的功能。然后游戏单位将使用这个接口进行渲染。这样的接口可以定义如下：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It contains three member functions, all implicitly `public`. This interface
    will then be implemented by the `Surface` class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含三个成员函数，都是隐式的`public`。然后`Surface`类将实现这个接口：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The class must implement all of the members of the interface. However, it is
    possible to skip that. In that case, the class must be abstract and must declare
    abstract members to match the interface members that it does not implement.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该类必须实现接口的所有成员。但是也可以跳过。在这种情况下，类必须是抽象的，并且必须声明抽象成员以匹配它没有实现的接口成员。
- en: 'In the preceding example, the `Surface` class implements all three methods
    of the `ISurface` interface. The methods are explicitly declared as `public`.
    Using any other access modifier would result in a compiler error because the members
    are implicitly public in the interface and the class cannot lower their visibility.
    The `GameUnit` class will change, so that the `Draw()` method will have an `ISurface`
    parameter:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`Surface`类实现了`ISurface`接口的所有三个方法。这些方法被明确声明为`public`。使用其他访问修饰符会导致编译错误，因为接口中的成员在类中是隐式公共的，类不能降低它们的可见性。`GameUnit`类将发生变化，使得`Draw()`方法将有一个`ISurface`参数：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s further extend the example and consider another interface called `IMoveable`
    that defines a `MoveTo()` method that moves a game object to another position:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步扩展这个例子，考虑另一个名为`IMoveable`的接口，它定义了一个`MoveTo()`方法，将游戏对象移动到另一个位置：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This interface will be implemented by all of the game objects that can be moved,
    such as people, machines, and so on. A class called `ActionUnit` acts as a base
    class for all such objects and implements `IMoveable`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口将被所有可以移动的游戏对象实现，比如人、机器等等。一个名为`ActionUnit`的类作为所有这些对象的基类，并实现了`IMoveable`：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`ActionUnit` is also derived from `GameUnit`, so the base class comes before
    the list of interfaces. However, since this class only acts as a base class for
    other classes, it does not implement the `Image` property and must, therefore,
    be abstract. A `Meeple` class, shown in the following listing, derives from `ActionUnit`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionUnit`也是从`GameUnit`派生的，因此基类出现在接口列表之前。然而，由于这个类只作为其他类的基类，它不实现`Image`属性，因此必须是抽象的。下面的代码显示了一个从`ActionUnit`派生的`Meeple`类：'
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can use instances of the `Meeple` class to extend the game we built in a
    previous example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Meeple`类的实例来扩展我们在之前示例中构建的游戏：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of this program is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出如下：
- en: '![Figure 5.6 – The console output from the execution of the modified game'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6 - 修改后的游戏执行的控制台输出'
- en: '](img/Figure_5.6_B12346.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_5.6_B12346.jpg)'
- en: Figure 5.6 – The console output from the execution of the modified game
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6 - 修改后的游戏执行的控制台输出
- en: Now that we have learned about inheritance, it is time to look at the last pillar
    of OOP, which is polymorphism.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了继承，是时候看看面向对象编程的最后一个支柱，即多态性了。
- en: Polymorphism
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: 'The last core pillar of object-oriented programming is polymorphism. Polymorphism
    is a Greek word that stands for *multiple forms*. This is the ability to use one
    entity in multiple forms. There are two types of polymorphism:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的最后一个核心支柱是多态性。多态性是一个希腊词，代表着*多种形式*。这是使用一个实体的多种形式的能力。有两种类型的多态性：
- en: '*Compile-time polymorphism*: When we have methods with the same name but different
    numbers or types of parameters, which is called method overloading.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译时多态性*：当我们有相同名称但参数数量或类型不同的方法时，这被称为方法重载。'
- en: '*Run-time polymorphism*: This has two different aspects:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*运行时多态性*：这有两个不同的方面：'
- en: On one hand, Objects of derived classes can be seamlessly used as objects of
    base classes in arrays or other types of collections, method parameters, and other
    places.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，派生类的对象可以无缝地用作数组或其他类型的集合、方法参数和其他位置中的基类对象。
- en: On the other hand, Classes can define virtual methods that can be overridden
    in derived classes. At runtime, the **Common Language Runtime** (**CLR**) will
    invoke the implementation of the virtual member corresponding to the runtime type
    of the object. An object's declared type and its runtime type differ when objects
    of derived classes are used in place of objects of base classes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，类可以定义虚拟方法，可以在派生类中重写。在运行时，**公共语言运行时**（**CLR**）将调用与对象的运行时类型相对应的虚拟成员的实现。当派生类的对象被用于替代基类的对象时，对象的声明类型和运行时类型不同时。
- en: Polymorphism promotes code reuse, which can make it easier to read, test, and
    maintain the code. It also promotes separation of concerns, which is an important
    principle in object-oriented programming. Another benefit is that it helps to
    hide implementation details because it allows interacting with different classes
    through a common interface.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性促进了代码重用，这可以使代码更容易阅读、测试和维护。它还促进了关注点的分离，这是面向对象编程中的一个重要原则。另一个好处是它有助于隐藏实现细节，因为它允许通过一个公共接口与不同的类进行交互。
- en: 'In the previous sections, we have seen examples of both these aspects. We have
    seen how to declare virtual members and how to override them, as well as how to
    stop the virtual inheritance with the `sealed` keyword. We have also seen examples
    of objects of derived classes used in arrays of base classes. Here is, again,
    such an example:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经看到了这两个方面的例子。我们已经看到了如何声明虚拟成员以及如何重写它们，以及如何使用`sealed`关键字停止虚拟继承。我们还看到了派生类的对象在基类数组中的使用的例子。这里再次是这样一个例子：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Compile-time polymorphism is represented by *method and operator overloading*.
    We will explore these in the following sections.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时多态性由*方法和运算符重载*表示。我们将在接下来的章节中探讨这些。
- en: Method overloading
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法重载
- en: Method overloading allows us to declare two or more methods within the same
    class with the same name but different parameters. This can be either a different
    number of parameters or parameters of different types. The return type is not
    considered for overload resolution. If two methods differ only in the return type,
    then the compiler will issue an error. Also, the `ref`, `in`, and `out` parameter
    modifiers do not participate in overload resolution. That means that two methods
    cannot differ only in a parameter modifier, such as one method has a `ref` parameter
    and another one has the same parameter specified with `in` or `out` modifiers.
    On the other hand, a method with a parameter with no modifier can be overloaded
    by a method that has the same parameter specified as `ref`, `in`, or `out`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载允许我们在同一个类中声明两个或多个具有相同名称但不同参数的方法。这可以是不同数量的参数或不同类型的参数。返回类型不考虑重载解析。如果两个方法只在返回类型上有所不同，那么编译器将发出错误。此外，`ref`、`in`和`out`参数修饰符不参与重载解析。这意味着两个方法不能仅在参数修饰符上有所不同，比如一个方法有一个`ref`参数，另一个方法有相同的参数指定为`in`或`out`修饰符。另一方面，一个没有修饰符的参数的方法可以被一个具有相同参数指定为`ref`、`in`或`out`的方法重载。
- en: 'Let''s look at the following example to understand method overloading. Considering
    the `IMoveable` interface shown earlier, we can modify it so that it contains
    two methods called `MoveTo()` with different parameters:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看下面的例子来理解方法重载。考虑之前显示的`IMoveable`接口，我们可以修改它，使其包含两个名为`MoveTo()`的方法，参数不同：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `ActionUnit` class provides implementations for both of these overloads.
    When the overloaded method is called, the compiler finds the best match based
    on the type and number of supplied arguments and invokes the appropriate overload.
    An example is shown here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionUnit`类提供了这两种重载的实现。当调用重载的方法时，编译器会根据提供的参数的类型和数量找到最佳匹配，并调用适当的重载。示例如下：'
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The process to identify the best match for a method call is called *overload
    resolution*. There are many rules that define how the best match is found and
    listing them all is beyond the scope of this book. In very simple terms, overload
    resolution is performed as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 识别方法调用的最佳匹配的过程称为*重载解析*。有许多规则定义了如何找到最佳匹配，列出它们都超出了本书的范围。简单来说，重载解析的执行如下：
- en: Create a set of members with the specified name.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有指定名称的成员集合。
- en: Eliminate all of the members that are not accessible from the calling scope.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消除从调用范围不可访问的所有成员。
- en: Eliminate all of the inapplicable members. An applicable member is one that
    has a parameter for every argument and the argument is implicitly convertible
    to the parameter's type.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消除所有不适用的成员。适用的成员是指每个参数都有一个参数，并且参数可以隐式转换为参数的类型。
- en: If a member has a form with a variable number of arguments, then evaluate them
    and eliminate non-applicable forms.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个成员有一个带有可变数量参数的形式，那么评估它们并消除不适用的形式。
- en: On the remaining set, apply the rules for finding the best match. A more specific
    parameter is better than less specific. This means, for instance, that a derived
    class, which is more specific, is better than a base class. Also, a non-generic
    parameter is more specific than a generic parameter.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于剩下的集合，应用找到最佳匹配的规则。更具体的参数比不太具体的更好。这意味着，例如，更具体的派生类比基类更好。此外，非泛型参数比泛型参数更具体。
- en: Similar to method overloading but with slightly different syntax and semantics
    is operator overloading, which we will look at next.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与方法重载类似，但语法和语义略有不同的是运算符重载，我们将在下面看到。
- en: Operator overloading
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符重载
- en: Operator overloading allows us to provide user-defined functionality to an operator
    with respect to a particular type. A type can provide a custom implementation
    for an overloadable operator when one or both of the operands are of that type.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符重载允许我们针对特定类型提供用户定义的功能。当一个或两个操作数是该类型时，类型可以为可重载的运算符提供自定义实现。
- en: 'The following are a few important points to consider while implementing operator
    overloading:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现运算符重载时需要考虑的一些重要点如下：
- en: The `operator` keyword is used to declare an operator. Such methods must be
    `public` and `static`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`operator`关键字用于声明运算符。这样的方法必须是`public`和`static`。'
- en: The assignment operators cannot be overloaded.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值运算符不能被重载。
- en: The parameters of an overloaded operator method should not use the `ref`, `in`,
    or `out` modifiers.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载运算符方法的参数不应该使用`ref`、`in`或`out`修饰符。
- en: We cannot change the operator precedence via operator overloading.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能通过运算符重载改变运算符的优先级。
- en: We cannot change the number of operands required by an operator. However, an
    overloaded operator can ignore an operand.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能改变运算符所需的操作数数量。但是，重载的运算符可以忽略一个操作数。
- en: The C# language has unary, binary, and ternary operators. However, only operators
    of the first two categories can be overloaded. Let's begin by learning how binary
    operators can be overloaded.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言有一元、二元和三元运算符。然而，只有前两类运算符可以被重载。让我们从学习如何重载二元运算符开始。
- en: Overloading a binary operator
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重载二元运算符
- en: At least one of the arguments of a binary operator must be of type `T` or `T?`,
    where `T` is the type that defines the operator.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 二元运算符的至少一个参数必须是`T`或`T?`类型，其中`T`是定义运算符的类型。
- en: 'Let''s consider the following type for which we want to overload operators:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们想要重载运算符的类型：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is a very simple implementation for complex numbers, with just two properties
    for the real and imaginary parts. We want to be able to do arithmetic operations
    such as addition and subtraction, as shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的复数实现，只有实部和虚部两个属性。我们希望能够进行加法和减法等算术运算，如下所示：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To do so, we must overload the `+` and `-` binary operators as follows (the
    parts of the `Complex` structure shown previously are omitted for simplicity):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，我们必须按照以下方式重载`+`和`-`二元运算符（前面显示的`Complex`结构的部分为简单起见而省略）：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We might also want to be able to do object comparison. In this case, we need
    to overload the `==`, `!=`, `<`, `>`, `<=`, or `>=` operators or a combination
    of them:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还想要能够进行对象比较。在这种情况下，我们需要重载`==`、`!=`、`<`、`>`、`<=`或`>=`运算符或它们的组合：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the following listing, you can see the implementation of the `==` and `!=`
    operators for the `Complex` type:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的清单中，您可以看到`Complex`类型的`==`和`!=`运算符的实现：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When overloading the comparison operators, you must implement them in pairs,
    as mentioned:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在重载比较运算符时，你必须按照成对实现它们，如前所述：
- en: If you overload `==` or `!=`, you must overload them both.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你重载`==`或`!=`，你必须同时重载它们。
- en: If you overload `<` or `>`, you must overload them both.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你重载`<`或`>`，你必须同时重载它们。
- en: If you overload `=<` or `>=`, you must overload them both.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你重载`=<`或`>=`，你必须同时重载它们。
- en: Moreover, when you overload `==` and `!=`, you also need to override the `System.Object`
    virtual methods, `Equals()` and `GetHashCode()`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当你重载`==`和`!=`时，你还需要重写`System.Object`的虚拟方法，`Equals()`和`GetHashCode()`。
- en: Overloading a unary operator
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重载一元运算符
- en: The single argument of a unary operator must be either `T` or `T?` where `T`
    is the type that defines the operator.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一元运算符的单个参数必须是`T`或`T?`，其中`T`是定义运算符的类型。
- en: 'We will exemplify again using the `Complex` type and the increment and decrement
    operators. These can be implemented as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用`Complex`类型和增量和减量运算符进行举例。可以实现如下：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In this implementation, the increment (`++`) operator and the decrement (`--`)
    operator alter only the real part of a complex number and return a new complex
    number. We can then write the following code to show how these operators can be
    used:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，增量(`++`)运算符和减量(`--`)运算符只改变复数的实部，并返回一个新的复数。然后我们可以编写以下代码来展示这些运算符如何被使用：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It is important to note that when calling the increment or decrement operators,
    the operated object is assigned a new value. For reference types, that means a
    reference to a new object is assigned. As a result, the increment and decrement
    operators should not modify the original object and return a reference to it.
    Let''s understand the reason by implementing the `Complex` type as a class:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，当调用增量或减量运算符时，操作的对象被赋予一个新值。对于引用类型来说，这意味着被赋予一个新对象的引用。因此，增量和减量运算符不应该修改原始对象并返回对其的引用。通过将`Complex`类型实现为一个类来理解原因：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This implementation is wrong because it will affect all of the references to
    the modified object. Consider the following example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现是错误的，因为它会影响对修改后对象的所有引用。考虑以下例子：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Initially, `c1` and `c2` are equal. We then increment the value of `c1` and
    because of the implementation of the `++` operator in the `Complex` class, both
    `c1` and `c2` will have the same value. The correct implementation is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`c1`和`c2`是相等的。然后我们增加了`c1`的值，由于`Complex`类中`++`运算符的实现，`c1`和`c2`将具有相同的值。正确的实现如下：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Although this is not a problem with value types, you should get into the habit
    of returning a new object from unary operators.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对值类型不是问题，但你应该养成从一元运算符返回一个新对象的习惯。
- en: SOLID principles
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: 'The principles we discussed in this chapter—abstraction, encapsulation, inheritance,
    and polymorphism– are the pillars of object-oriented programming. However, these
    are not the only principles that developers employ when doing object-oriented
    programming. There are many other principles but some that are worth mentioning
    at this point are the five known by the acronym **SOLID**. These were initially
    introduced by Robert C. Martin in 2000, in a paper called *Design Principles and
    Design Patterns*. The term SOLID was later coined by Michael Feathers:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章讨论的原则——抽象、封装、继承和多态——是面向对象编程的支柱。然而，这些并不是开发人员在进行面向对象编程时所采用的唯一原则。还有许多其他原则，但在这一点上值得一提的是由缩写**SOLID**所知的五个原则。这些最初是由Robert
    C. Martin在2000年在一篇名为*设计原则和设计模式*的论文中首次提出的。后来，Michael Feathers创造了SOLID这个术语：
- en: '**S** stands for the **Single responsibility principle** that states that a
    module or a class should have a single responsibility, where responsibility is
    defined as a reason to change. When a class provides functionalities that may
    change at different times and for different reasons, it means those functionalities
    do not belong together and should be separated into different classes.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S**代表**单一职责原则**，它规定一个模块或类应该只有一个职责，其中职责被定义为变化的原因。当一个类提供的功能可能在不同时间和出于不同原因而发生变化时，这意味着这些功能不应该放在一起，应该分开成不同的类。'
- en: '**O** stands for the **Open-close principle** that states that a module, class,
    or function should be opened for extensions but closed for modifications. That
    is, when functionalities need to change, those changes should not affect the existing
    implementation. Inheritance is the typical way to achieve this, as derived classes
    can either add more functionalities or specialize existing ones. Extension methods
    is another technique available in C#.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**O**代表**开闭原则**，它规定一个模块、类或函数应该对扩展开放，但对修改关闭。也就是说，当功能需要改变时，这些改变不应该影响现有的实现。继承是实现这一点的典型方式，因为派生类可以添加更多功能或专门化现有功能。扩展方法是C#中的另一种可用技术。'
- en: '**L** stands for the **Liskov substitution principle** that states that if
    S is a sub-type of T, then objects of T may be substituted with objects of S without
    disrupting the functionality of the program. This principle is named after Barbara
    Liskov, who first introduced it. To understand the principle, let''s consider
    a system that handles shapes. We may have an ellipse class with methods to change
    its two foci. When implementing a circle, we might be tempted to specialize the
    ellipse class because, mathematically, the circle is a special ellipse with the
    two foci being equal. In this case, the circle has to set the two foci to the
    same value in both these two methods. That is something a client of these classes
    does not expect and therefore an ellipse may not be substituted for a circle.
    To avoid violating the principle, we would have to implement the circle without
    deriving from the ellipse. To make sure you follow this principle, you should
    define preconditions and post-conditions for all methods. The preconditions must
    hold true before the method is executed and post-conditions must hold true after
    its execution. When specializing a method, you can only replace its preconditions
    with weaker ones and post-conditions with stronger ones.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**代表**里氏替换原则**，它规定如果S是T的子类型，那么T的对象可以被S的对象替换而不会破坏程序的功能。这个原则是以首次提出它的Barbara
    Liskov的名字命名的。为了理解这个原则，让我们考虑一个处理形状的系统。我们可能有一个椭圆类，其中有方法来改变它的两个焦点。当实现一个圆时，我们可能会倾向于专门化椭圆类，因为在数学上，圆是具有两个相等焦点的特殊椭圆。在这种情况下，圆必须在这两个方法中将两个焦点设置为相同的值。这是客户端不期望的，因此椭圆不能替换圆。为了避免违反这个原则，我们必须实现圆而不是从椭圆派生。为了确保遵循这个原则，你应该为所有方法定义前置条件和后置条件。前置条件在方法执行之前必须为真，后置条件在方法执行后必须为真。当专门化一个方法时，你只能用更弱的前置条件和更强的后置条件替换它的前置条件和后置条件。'
- en: '**I** stands for the **Interface segregation principle** and says that smaller,
    specific interfaces are to be preferred to larger and more general ones. The reason
    for this is that a client may only need to implement those functionalities that
    it needs and nothing more. By separating responsibilities, this principle facilitates
    composition and decoupling.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**I**代表**接口隔离原则**，它规定更小、更具体的接口比更大、更一般的接口更可取。原因是客户端可能只需要实现它需要的功能，而不需要其他的。通过分离职责，这个原则促进了组合和解耦。'
- en: '**D** stands for the **Dependency inversion principle** and is the last in
    the list. This principle states that software entities should depend on abstractions
    and not on implementations. High-level modules should not depend on low-level
    modules; instead, they should both depend on abstractions. Moreover, abstractions
    should not depend on concrete implementations but the other way around. Dependency
    on implementations introduces tight coupling, making it hard to replace components.
    However, dependency on high-level abstractions decouples modules and facilitates
    flexibility and reusability.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**D**代表**依赖反转原则**，是列表中的最后一个。该原则规定软件实体应依赖于抽象而不是实现。高级模块不应依赖低级模块；相反，它们都应该依赖于抽象。此外，抽象不应依赖具体实现，而是相反。对实现的依赖引入了紧耦合，使得难以替换组件。然而，对高级抽象的依赖解耦了模块，并促进了灵活性和可重用性。'
- en: These five principles enable us to write code that is simpler and more understandable,
    which also makes it easier to maintain. At the same time, they make code more
    reusable and also easier to test.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个原则使我们能够编写更简单、更易理解的代码，这也使得它更容易维护。同时，它们使代码更具可重用性，也更容易测试。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned about the core concepts of object-oriented programming:
    abstraction, encapsulation, inheritance, and polymorphism. We learned about the
    language functionalities that enable them, such as inheritance, virtual members,
    abstract types and members, sealed types and members, interfaces, and method and
    operator overloading. At the end of this chapter, we briefly discussed other object-oriented
    principles known as SOLID.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了面向对象编程的核心概念：抽象、封装、继承和多态。我们了解了使它们成为可能的语言功能，比如继承、虚成员、抽象类型和成员、密封类型和成员、接口，以及方法和运算符重载。在本章末尾，我们简要讨论了其他被称为SOLID的面向对象原则。
- en: In the next chapter, we will learn about another programming paradigm in C#—generic
    programming.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习C#中的另一种编程范式——泛型编程。
- en: Test what you learned
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你学到的东西
- en: What is object-oriented programming and what are its core principles?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是面向对象编程，其核心原则是什么？
- en: What are the benefits of encapsulation?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 封装有哪些好处？
- en: What is inheritance and what types of inheritance are supported in C#?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是继承，C#支持哪些类型的继承？
- en: What are virtual methods? What about overridden methods?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是虚方法？重写方法呢？
- en: How do you prevent a virtual member from being overridden in a derived class?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何防止派生类中的虚成员被重写？
- en: What are abstract classes and what are their features?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是抽象类，它们有哪些特点？
- en: What is an interface and what kinds of members can it contain?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是接口，它可以包含哪些成员？
- en: What types of polymorphism exist?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在哪些多态类型？
- en: What is an overloaded method? How do you overload operators?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是重载方法？如何重载运算符？
- en: What are the SOLID principles?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是SOLID原则？
- en: Further Reading
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Design Principles and Design Patterns by Robert C. Martin*: [https://web.archive.org/web/20150906155800/http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf](https://web.archive.org/web/20150906155800/http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*由Robert C. Martin编写的《设计原则和设计模式》*：[https://web.archive.org/web/20150906155800/http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf](https://web.archive.org/web/20150906155800/http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf)'
