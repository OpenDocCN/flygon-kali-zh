- en: Elastic Beanstalk
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性 Beanstalk
- en: So far in this book, we have focused on the use of Elastic Container Service
    (ECS) and its variant, AWS Fargate, to manage and deploy Docker applications. 
    The remainder of this book will focus on alternative technologies that you can
    use to run your Docker applications in AWS, and the first of these that we will
    cover is Elastic Beanstalk.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经专注于使用弹性容器服务（ECS）及其变体 AWS Fargate 来管理和部署 Docker 应用程序。本书的其余部分将专注于您可以使用的替代技术，以在
    AWS 中运行 Docker 应用程序，我们将首先介绍的是弹性 Beanstalk。
- en: Elastic Beanstalk falls into a category that is commonly referred to by the
    industry as **Platform as a service** (**PaaS**), and is a service that is intended
    to provide a managed runtime environment for your applications that lets you focus
    on developing, deploying, and operating your application, rather than worry about
    the surrounding infrastructure.  To reinforce this paradigm, Elastic Beanstalk
    is focused around supporting various popular programming languages and today includes
    support for Node.js, PHP, Python, Ruby, Java, .NET, and Go applications.  When
    you create an Elastic Beanstalk application, you specify the target programming
    language, and Elastic Beanstalk will deploy an environment that supports your
    programming language and associated runtimes and application frameworks.  Elastic
    Beanstalk will also deploy supporting infrastructure such as load balancers and
    databases, and more importantly will configure your environment so that you have
    easy access to logs, monitoring information, and alerts, ensuring you can not
    only deploy your applications, but also monitor them and ensure, they are up and
    running in an optimal state.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性 Beanstalk 属于行业通常称为**平台即服务**（**PaaS**）的类别，旨在为您的应用程序提供受管的运行时环境，让您专注于开发、部署和操作应用程序，而不必担心周围的基础设施。为了强调这一范式，弹性
    Beanstalk 专注于支持各种流行的编程语言，如 Node.js、PHP、Python、Ruby、Java、.NET 和 Go 应用程序。创建弹性 Beanstalk
    应用程序时，您会指定目标编程语言，弹性 Beanstalk 将部署一个支持您的编程语言和相关运行时和应用程序框架的环境。弹性 Beanstalk 还将部署支持基础设施，如负载均衡器和数据库，更重要的是，它将配置您的环境，以便您可以轻松访问日志、监控信息和警报，确保您不仅可以部署应用程序，还可以监视它们，并确保它们处于最佳状态下运行。
- en: In addition to the aforementioned programming languages, Elastic Beanstalk also
    supports Docker environments, meaning it can support any application that can
    be run in a Docker container, regardless of programming language or application
    runtime, and in this chapter you will learn how you can use Elastic Beanstalk
    to manage and deploy your Docker applications.  You will learn how to create an
    Elastic Beanstalk application using the AWS console and create an environment,
    which includes an application load balancer and RDS database instance that's required
    for our application. You will encounter some issues with the initial setup, and
    learn how to diagnose and troubleshoot these issues using the AWS console and
    Elastic Beanstalk command-line tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的编程语言外，弹性 Beanstalk 还支持 Docker 环境，这意味着它可以支持在 Docker 容器中运行的任何应用程序，无论编程语言或应用程序运行时如何。在本章中，您将学习如何使用弹性
    Beanstalk 来管理和部署 Docker 应用程序。您将学习如何使用 AWS 控制台创建弹性 Beanstalk 应用程序并创建一个环境，其中包括应用程序负载均衡器和我们应用程序所需的
    RDS 数据库实例。您将遇到一些初始设置问题，并学习如何使用 AWS 控制台和弹性 Beanstalk 命令行工具来诊断和解决这些问题。
- en: To resolve these issues, you will configure a feature known as **ebextensions**,
    which is an advanced configuration feature of Elastic Beanstalk that can be used
    to apply a number of custom configuration scenarios to your application.  You
    will leverage ebextensions to address permissions issues with Docker volumes,
    transform default environment variables generated by Elastic Beanstalk to the
    format expected by your application, and finally ensure single shot deployment
    tasks such as executing database migrations are only run on a single instance
    for each application deployment.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，您将配置一个名为**ebextensions**的功能，这是Elastic Beanstalk的高级配置功能，可用于将许多自定义配置方案应用于您的应用程序。您将利用ebextensions来解决Docker卷的权限问题，将Elastic
    Beanstalk生成的默认环境变量转换为应用程序期望的格式，并最终确保诸如执行数据库迁移之类的一次性部署任务仅在每个应用程序部署的单个实例上运行。
- en: This chapter is not intended to provide exhaustive coverage of Elastic Beanstalk
    and will only focus on core scenarios related to deploying and managing Docker
    applications.  For coverage of support for other programming languages and more
    advanced scenarios, refer to the [AWS Elastic Beanstalk Developer Guide](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/Welcome.html).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不旨在详尽介绍Elastic Beanstalk，并且只关注与部署和管理Docker应用程序相关的核心场景。有关对其他编程语言的支持和更高级场景的覆盖，请参考[AWS
    Elastic Beanstalk开发人员指南](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/Welcome.html)。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to Elastic Beanstalk
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elastic Beanstalk简介
- en: Creating Elastic Beanstalk applications using the AWS console
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS控制台创建Elastic Beanstalk应用程序
- en: Managing Elastic Beanstalk applications using the Elastic Beanstalk CLI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Elastic Beanstalk CLI管理Elastic Beanstalk应用程序
- en: Customizing Elastic Beanstalk applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义Elastic Beanstalk应用程序
- en: Deploying and testing Elastic Beanstalk applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和测试Elastic Beanstalk应用程序
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the technical requirements for this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: Administrator access to an AWS account
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS帐户的管理员访问权限
- en: Local environment configured as per the instructions in Chapter 1
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地环境按照第1章的说明进行配置
- en: A local AWS profile, configured as per the instructions in Chapter 3
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地AWS配置文件，按照第3章的说明进行配置
- en: Python 2.7 or 3.x
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 2.7或3.x
- en: PIP package manager
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PIP软件包管理器
- en: AWS CLI version 1.15.71 or higher
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI版本1.15.71或更高版本
- en: Docker 18.06 CE or higher
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 18.06 CE或更高版本
- en: Docker Compose 1.22 or higher
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose 1.22或更高版本
- en: GNU Make 3.82 or higher
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Make 3.82或更高版本
- en: This chapter assumes you have successfully completed all of the configuration
    tasks covered so far in this book
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已成功完成本书迄今为止涵盖的所有配置任务
- en: The following GitHub URL contains the code samples that are used in this chapter: [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch14](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch14).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下GitHub URL包含本章中使用的代码示例：[https://github.com/docker-in-aws/docker-in-aws/tree/master/ch14](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch14)。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[http://bit.ly/2MDhtj2](http://bit.ly/2MDhtj2)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2MDhtj2](http://bit.ly/2MDhtj2)'
- en: Introduction to Elastic Beanstalk
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elastic Beanstalk简介
- en: As discussed in the introduction to this chapter, Elastic Beanstalk is a PaaS
    offering from AWS that allows you to focus on application code and features rather
    than worry about the surrounding infrastructure required to support your application.
    To this end, Elastic Beanstalk is somewhat opinionated in its approach and generally
    works in a specific way.  Elastic Beanstalk does leverage other AWS services as
    much as possible, and tries to take the effort and complexity out of integrating
    with these services, which works well if you follow the way Elastic Beanstalk
    expects you to use these services.  If you are running a small team in a small
    to medium sized organization, Elastic Beanstalk can bring a lot of value to the
    table, providing lots of functionality out of the box. However, as soon as your
    organization grows and you look to optimize and standardize the way you deploy,
    monitor, and operate your applications, you may find that you outgrow the individual
    application-focused approach of Elastic Beanstalk.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章介绍中所讨论的，Elastic Beanstalk是AWS提供的PaaS服务，允许您专注于应用程序代码和功能，而不必担心支持应用程序所需的周围基础设施。为此，Elastic
    Beanstalk在其方法上有一定的偏见，并且通常以特定的方式工作。Elastic Beanstalk尽可能地利用其他AWS服务，并试图消除与这些服务集成的工作量和复杂性，如果您按照Elastic
    Beanstalk期望您使用这些服务的方式，这将非常有效。如果您在一个中小型组织中运行一个小团队，Elastic Beanstalk可以为您提供很多价值，提供了大量的开箱即用功能。然而，一旦您的组织发展壮大，并且希望优化和标准化部署、监控和操作应用程序的方式，您可能会发现您已经超出了Elastic
    Beanstalk的个体应用程序重点的范围。
- en: For example, it is important to understand that Elastic Beanstalk operates on
    the concept of a single ECS task definition per EC2 instance, so if you are wanting
    to run multiple container workloads on a shared infrastructure, Elastic Beanstalk
    is not the right choice for you.  The same applies for logging and operational
    tools—in general, Elastic Beanstalk provides its own toolchain that is very focused
    on individual applications, whereas your organization may want to adopt standard
    toolsets that operate across multiple applications. Personally, I prefer the more
    flexible and extensible approach that using ECS offers, but I must admit some
    of the out of the box operational and monitoring tools that you essentially get
    for free with Elastic Beanstalk are very attractive for getting an application
    up and running, and fully integrated with other AWS services.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，重要的是要了解Elastic Beanstalk基于每个EC2实例的单个ECS任务定义的概念运行，因此，如果您希望在共享基础设施上运行多个容器工作负载，Elastic
    Beanstalk不是您的正确选择。相同的情况也适用于日志记录和操作工具 - 一般来说，Elastic Beanstalk提供了其专注于个体应用程序的工具链，而您的组织可能希望采用跨多个应用程序运行的标准工具集。就个人而言，我更喜欢使用ECS提供的更灵活和可扩展的方法，但我必须承认，Elastic
    Beanstalk免费提供的一些开箱即用的操作和监控工具对于快速启动应用程序并与其他AWS服务完全集成非常有吸引力。
- en: Elastic Beanstalk concepts
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elastic Beanstalk概念
- en: This chapter is solely focused on running Docker applications using Elastic
    Beanstalk, so don't expect exhaustive coverage of Elastic Beanstalk and all of
    its supported programming languages. It is important to understand the basic concepts
    however, which I will cover off briefly now before we get started with creating
    an Elastic Beanstalk application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要关注使用Elastic Beanstalk运行Docker应用程序，因此不要期望对Elastic Beanstalk及其支持的所有编程语言进行详尽的覆盖。然而，在我们开始创建Elastic
    Beanstalk应用程序之前，了解基本概念是很重要的，我将在这里简要介绍一下。
- en: When using Elastic Beanstalk, you create *applications* which can define one
    or more *environments*.  Using the todobackend application as an example, you
    would define the todobackend application as an Elastic Beanstalk application,
    and create an environment called Dev and an environment called Prod to mirror
    the development and production environments we have deployed to date. Each environment
    references a specific version of your application, which contains the deployable
    code for your application. In the case of Docker applications, the source code
    includes a specification called `Dockerrun.aws.json` that defines the container
    environment for your application, which may reference an external Docker image
    or reference a local Dockerfile that is used to build your application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Elastic Beanstalk时，您创建*应用程序*，可以定义一个或多个*环境*。以todobackend应用程序为例，您将把todobackend应用程序定义为Elastic
    Beanstalk应用程序，并创建一个名为Dev的环境和一个名为Prod的环境，以反映我们迄今部署的开发和生产环境。每个环境引用应用程序的特定版本，其中包含应用程序的可部署代码。对于Docker应用程序，源代码包括一个名为`Dockerrun.aws.json`的规范，该规范定义了应用程序的容器环境，可以引用外部Docker镜像或引用用于构建应用程序的本地Dockerfile。
- en: Another important concept to understand is that behind the scenes, Elastic Beanstalk
    runs your application on regular EC2 instances, and follows a very strict paradigm
    of one instance of your application per EC2 instance. Each Elastic Beanstalk EC2
    instance runs a specially curated environment based upon your target application—for
    example, in the case of a multi container Docker application, the EC2 instance
    includes the Docker Engine and ECS agent.  Elastic Beanstalk also allows you to
    access and manage these EC2 instances via SSH in the case of Linux servers (which
    we will be using in this chapter), although you should generally reserve this
    access for troubleshooting purposes and never attempt to modify the configuration
    of these instances directly yourself.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的概念要了解的是，在幕后，Elastic Beanstalk在常规EC2实例上运行您的应用程序，并遵循一个非常严格的范例，即每个EC2实例运行一个应用程序实例。每个Elastic
    Beanstalk EC2实例都运行一个根据目标应用程序特别策划的环境，例如，在多容器Docker应用程序的情况下，EC2实例包括Docker引擎和ECS代理。Elastic
    Beanstalk还允许您通过SSH访问和管理这些EC2实例（在本章中我们将使用Linux服务器），尽管您通常应该将此访问保留用于故障排除目的，并且永远不要尝试直接修改这些实例的配置。
- en: Creating an Elastic Beanstalk application
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Elastic Beanstalk应用程序
- en: 'Now that you understand the basic concepts of Elastic Beanstalk, let''s turn
    our attention to creating a new Elastic Beanstalk application. You can create
    and configure Elastic Beanstalk applications using a variety of methods:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了Elastic Beanstalk的基本概念，让我们把注意力转向创建一个新的Elastic Beanstalk应用程序。您可以使用各种方法创建和配置Elastic
    Beanstalk应用程序：
- en: AWS console
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS控制台
- en: AWS CLI and SDKs
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI和SDK
- en: AWS CloudFormation
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CloudFormation
- en: Elastic Beanstalk CLI
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elastic Beanstalk CLI
- en: In this chapter, we will first create an Elastic Beanstalk application in the
    AWS console, and then use the Elastic Beanstalk CLI to manage, update, and refine
    the application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先在AWS控制台中创建一个Elastic Beanstalk应用程序，然后使用Elastic Beanstalk CLI来管理、更新和完善应用程序。
- en: 'When you are creating a Docker application, it is important to understand that
    Elastic Beanstalk supports two kinds of Docker applications:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Docker应用程序时，重要的是要了解Elastic Beanstalk支持两种类型的Docker应用程序：
- en: Single-container applications: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/docker-singlecontainer-deploy.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/docker-singlecontainer-deploy.html)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单容器应用程序：[https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/docker-singlecontainer-deploy.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/docker-singlecontainer-deploy.html)
- en: Multi-container applications: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker_ecs.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker_ecs.html)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多容器应用程序：[https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker_ecs.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker_ecs.html)
- en: For our use case, we will be following a very similar approach to how we configured
    the todobackend application for the ECS in previous chapters, hence we will require
    a multi container application, given we previously defined a main application
    container definition called **todobackend** and a **collectstatic** container
    definition in our ECS task definition (see the *Defining an ECS task definition
    using CloudFormation* section from the chapter *Deploying Applications using ECS*). 
    In general, I recommend the multi container approach, regardless of whether or
    not your application is a single container application, as the original single
    container application model goes against Docker best practices and forces you
    to run everything from a single container should your application requirements
    ever change or grow.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用例，我们将采用与之前章节中为ECS配置todobackend应用程序的非常相似的方法，因此我们将需要一个多容器应用程序，因为我们之前在ECS任务定义中定义了一个名为**todobackend**的主应用程序容器定义和一个**collectstatic**容器定义（请参阅章节*使用CloudFormation定义ECS任务定义*中的*部署使用ECS的应用程序*）。总的来说，我建议采用多容器方法，无论您的应用程序是否是单容器应用程序，因为原始的单容器应用程序模型违反了Docker最佳实践，并且在应用程序要求发生变化或增长时，强制您从单个容器中运行所有内容。
- en: Creating a Dockerrun.aws.json file
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Dockerrun.aws.json文件
- en: Regardless of the type of Docker application you are creating, you must first
    create a file called `Dockerrun.aws.json`, which defines the various containers
    that comprise your application. This file is defined in a JSON format and is based
    upon the ECS task definition format that you configured in earlier chapters, which
    we will use as a basis for the settings in the `Dockerrun.aws.json` file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您创建的是什么类型的Docker应用程序，您都必须首先创建一个名为`Dockerrun.aws.json`的文件，该文件定义了组成您的应用程序的各种容器。该文件以JSON格式定义，并基于您在之前章节中配置的ECS任务定义格式，我们将以此为`Dockerrun.aws.json`文件中的设置基础。
- en: 'Let''s create a folder called `eb` in the `todobackend-aws` repository, and
    define a new file called `Dockerrun.aws.json` as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`todobackend-aws`存储库中创建一个名为`eb`的文件夹，并定义一个名为`Dockerrun.aws.json`的新文件，如下所示：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When defining a multi container Docker application, you must specify and use
    version 2 of the specification format, which is configured via the `AWSEBDockerrunVersion`
    property.  If you refer back to the *Defining an ECS task definition using CloudFormation*
    in the chapter *Deploying applications using ECS*, you can see that the version
    2 specification of the `Dockerrun.aws.json` file is very similar, although the
    format is JSON as opposed to the YAML format we have been using in our CloudFormation
    templates. We use camel case naming to define each parameter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义多容器Docker应用程序时，您必须指定并使用规范格式的第2版本，该版本通过`AWSEBDockerrunVersion`属性进行配置。如果您回顾一下章节*使用ECS部署应用程序*中的*使用CloudFormation定义ECS任务定义*，您会发现`Dockerrun.aws.json`文件的第2版本规范非常相似，尽管格式是JSON，而不是我们在CloudFormation模板中使用的YAML格式。我们使用驼峰命名来定义每个参数。
- en: The file includes two container definitions—one for the main todobackend application
    and one that generates static content—and we define a volume called `public` that
    is used to store static content.  We also configure a static port mapping from
    the container port 8000 to port 80 on the host, as port 80 is where Elastic Beanstalk
    expects your web applications to be listening by default.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 文件包括两个容器定义——一个用于主要的todobackend应用程序，另一个用于生成静态内容——我们定义了一个名为`public`的卷，用于存储静态内容。我们还配置了一个静态端口映射，将容器端口8000映射到主机的端口80，因为Elastic
    Beanstalk默认期望您的Web应用程序在端口80上监听。
- en: 'Note that there are some important differences from the approach we used for
    ECS:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与我们用于ECS的方法相比，有一些重要的区别。
- en: '**Image**: We reference the same ECR image, however we do not specify an image
    tag, meaning the latest version of the Docker image will always be deployed. 
    The `Dockerrun.aws.json` file does not support parameter or variable references,
    so if you wanted to reference an explicit image, you would need a continuous delivery
    workflow that automatically generates this file as part of the build process.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像**：我们引用相同的ECR镜像，但是我们没有指定镜像标签，这意味着最新版本的Docker镜像将始终被部署。`Dockerrun.aws.json`文件不支持参数或变量引用，因此如果您想引用一个明确的镜像，您需要一个自动生成此文件的持续交付工作流作为构建过程的一部分。'
- en: '**Environment**: Notice that we do not specify any environment variables related
    to database configuration, such as `MYSQL_HOST` or `MYSQL_USER`. We will discuss
    the reasons for this later on in this chapter, however for now understand that
    when you use the integrated support for RDS in Elastic Beanstalk, the environment
    variables that are automatically available to your applications follow a different
    format that we need to transform to meet the expectations of our application.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**：请注意，我们没有指定与数据库配置相关的任何环境变量，比如`MYSQL_HOST`或`MYSQL_USER`。我们将在本章后面讨论这样做的原因，但现在要明白的是，当您在Elastic
    Beanstalk中使用RDS的集成支持时，自动可用于应用程序的环境变量遵循不同的格式，我们需要转换以满足我们应用程序的期望。'
- en: '**Logs**: I have removed the CloudWatch logging configuration to simplify this
    chapter, however there is no reason why you cannot include a CloudWatch logs configuration
    with your containers. Note that if you did use CloudWatch logs, you would need
    to modify the Elastic Beanstalk  EC2 service role to include permissions for writing
    your logs to CloudWatch logs. We will see an example of this later in this chapter.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志**：我已经删除了CloudWatch日志配置，以简化本章，但您完全可以在您的容器中包含CloudWatch日志配置。请注意，如果您使用了CloudWatch日志，您需要修改Elastic
    Beanstalk EC2服务角色，以包括将您的日志写入CloudWatch日志的权限。我们将在本章后面看到一个例子。'
- en: I have also removed the `XRAY_DAEMON_ADDRESS` environment variable to keep things
    simple, as you may no longer have the X-Ray daemon running in your environment. 
    Note that if you did want to support X-Ray, you would need to ensure the instance
    security group attached to your Elastic Beanstalk instances included security
    rules permitting network communications to the X-Ray daemon.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我还删除了`XRAY_DAEMON_ADDRESS`环境变量，以保持简单，因为您可能不再在您的环境中运行X-Ray守护程序。请注意，如果您确实想支持X-Ray，您需要确保附加到Elastic
    Beanstalk实例的实例安全组包含允许与X-Ray守护程序进行网络通信的安全规则。
- en: 'Now that we have defined a `Dockerrun.aws.json` file, we need to create a ZIP
    archive that includes this file.  Elastic Beanstalk requires your application
    source to be uploaded in a ZIP or WAR archive format, hence this requirement.
    You can do this from the command line by using the `zip` utility as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个`Dockerrun.aws.json`文件，我们需要创建一个ZIP存档，其中包括这个文件。Elastic Beanstalk要求您的应用程序源代码以ZIP或WAR存档格式上传，因此有这个要求。您可以通过使用`zip`实用程序从命令行执行此操作：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will create an archive called `app.zip` in the `todobackend-aws/eb` folder,
    with the `-r` flag specifying that zip should recursively add all files in any
    folders that may exist (this will be the case later on in this chapter). After
    specifying an archive name of `app.zip`, we reference the current working directory
    by specifying `.` rather than `*`, as using the `.` syntax will include any hidden
    directories or files (again, this will be the case later on in this chapter).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`todobackend-aws/eb`文件夹中创建一个名为`app.zip`的存档，使用`-r`标志指定zip应该递归添加所有可能存在的文件夹中的所有文件（这将在本章后面的情况下发生）。在指定`app.zip`的存档名称后，我们通过指定`.`而不是`*`来引用当前工作目录，因为使用`.`语法将包括任何隐藏的目录或文件（同样，这将在本章后面的情况下发生）。
- en: Also note that in a macOS environment, you can use the `-x` flag to exclude
    `.DS_Store` directory metadata files from being included in your archive.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在macOS环境中，您可以使用`-x`标志来排除`.DS_Store`目录元数据文件，以防止其被包含在存档中。
- en: Creating an Elastic Beanstalk application using the AWS console
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS控制台创建一个弹性Beanstalk应用程序
- en: 'We are now ready to create an Elastic Beanstalk application using the AWS console.
    To get started, select **Services** | **Elastic Beanstalk** and then click on
    the **Get started** button to create a new application.  In the **Create a web
    app** screen, specify an application name of todobackend, configure a platform
    of **multicontainer Docker**, and finally upload the `app.zip` file you created
    previously using the **Upload your code** option for the **Application code**
    setting:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用AWS控制台创建一个弹性Beanstalk应用程序。要开始，请选择**服务** | **弹性Beanstalk**，然后单击**开始**按钮创建一个新应用程序。在**创建Web应用程序**屏幕上，指定一个名为todobackend的应用程序名称，配置一个**多容器Docker**的平台，最后使用**上传您的代码**选项为**应用程序代码**设置上传之前创建的`app.zip`文件：
- en: '![](assets/d841d257-68b2-4f59-8ea4-50c2ff17d47f.png)Creating an Elastic Beanstalk
    web application'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d841d257-68b2-4f59-8ea4-50c2ff17d47f.png)创建一个弹性Beanstalk Web应用程序'
- en: Next, click on the **Configure more options** button, which will present a screen
    called **Configure Todobackend-Env** that allows you to customize your application.
    Note that by default, Elastic Beanstalk names your first application environment
    `<application-name>-Env`, hence the name **Todobackend-Env**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，点击**配置更多选项**按钮，这将呈现一个名为**配置Todobackend-Env**的屏幕，允许您自定义应用程序。请注意，默认情况下，弹性Beanstalk将您的第一个应用程序环境命名为`<application-name>-Env`，因此名称为**Todobackend-Env**。
- en: 'In the Configuration presets section, select the **High availability** option,
    which will add a load balancer to your configuration:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置预设部分，选择**高可用性**选项，这将向您的配置添加一个负载均衡器：
- en: '![](assets/5e471f97-8e8c-4707-9949-f22419a59c26.png)Configuring an Elastic
    Beanstalk web application'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5e471f97-8e8c-4707-9949-f22419a59c26.png)配置弹性Beanstalk Web应用程序'
- en: 'If you review the current settings, you will notice that the **EC2 instance
    type** is **t1.micro** in the **Instances** section, the **Load balancer type**
    is **classic** in the **Load balancer** section, and that the **Database** section
    currently is not configured. Let''s first modify the **EC2 instance type** to
    be the free tier **t2.micro** instance type by clicking the **Modify** link in
    the **Instances** section, changing the **Instance type** and then clicking **Save**:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看当前设置，您会注意到**EC2实例类型**在**实例**部分是**t1.micro**，**负载均衡器类型**在**负载均衡器**部分是**经典**，而**数据库**部分目前未配置。让我们首先通过单击**实例**部分的**修改**链接，更改**实例类型**，然后单击**保存**来修改**EC2实例类型**为免费层**t2.micro**实例类型：
- en: '![](assets/6955ffa0-6782-47dd-aed1-eca0baed8119.png)Modifying EC2 instance
    type'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6955ffa0-6782-47dd-aed1-eca0baed8119.png)修改EC2实例类型'
- en: 'Next, change the **Load balancer type** to **Application Load Balancer** by
    clicking the **Modify** link in the **Load Balancer**s section and then slicking
    **Save**.  Note that the default settings expect to expose your application on
    Port - `80` to the outside world, as defined in the **Application Load Balancer**
    and **Rules** sections, and that your containers are exposed on Port 80 on your
    EC2 instances, as defined in the **Processes** section:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过单击**负载均衡器**部分中的**修改**链接，然后单击**保存**，将**负载均衡器类型**更改为**应用程序负载均衡器**。请注意，默认设置期望在**应用程序负载均衡器**和**规则**部分中将您的应用程序暴露在端口`80`上，以及您的容器在EC2实例上的端口80上，如**进程**部分中定义的那样：
- en: '![](assets/cb26c7fb-cf9e-4789-bf21-df41b88b4254.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cb26c7fb-cf9e-4789-bf21-df41b88b4254.png)'
- en: Modifying load balancer type
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 修改负载均衡器类型
- en: 'Finally, we need to define a database configuration for the application by
    clicking the **Modify** link in the **Database** section.  Select **mysql** as
    the **Engine**, specify an appropriate **Username** and **Password**, and finally
    set the **Retention** to **Delete**, given that we are only using this environment
    for test purposes.  The defaults for the other settings are sufficient, so you
    can click on the **Save** button after completing your configuration:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要通过单击**数据库**部分中的**修改**链接为应用程序定义数据库配置。选择**mysql**作为**引擎**，指定适当的**用户名**和**密码**，最后将**保留**设置为**删除**，因为我们只是为了测试目的而使用这个环境。其他设置的默认值足够，因此在完成配置后，可以单击**保存**按钮：
- en: '![](assets/2a591e2a-6b48-4839-bcc2-e776bfeb2e48.png)Configuring database settings'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2a591e2a-6b48-4839-bcc2-e776bfeb2e48.png)配置数据库设置'
- en: At this point, you have completed the configuration of your application and
    can click on the **Create app** button at the bottom of the **Configure Todobackend-env**
    screen. Elastic Beanstalk will now start creating you application and show you
    the progress of this in the console.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您已经完成了应用程序的配置，并且可以单击**配置Todobackend-env**屏幕底部的**创建应用程序**按钮。弹性Beanstalk现在将开始创建您的应用程序，并在控制台中显示此过程的进度。
- en: The Elastic Beanstalk application wizard creates a CloudFormation stack behind
    the scenes that includes all of the resources and configuration you specified. 
    It is also possible to create your own Elastic Beanstalk environments using CloudFormation
    without using the wizard.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性Beanstalk应用程序向导在幕后创建了一个包括您指定的所有资源和配置的CloudFormation堆栈。也可以使用CloudFormation创建自己的弹性Beanstalk环境，而不使用向导。
- en: 'After some time, the application''s creation will complete, although you can
    see that there are problems with the application:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，应用程序的创建将完成，尽管您可以看到应用程序存在问题：
- en: '![](assets/a97cdb26-7e8f-412b-b2d9-570cd14d3b30.png)Initial application state'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a97cdb26-7e8f-412b-b2d9-570cd14d3b30.png)初始应用程序状态'
- en: Configuring the EC2 instance profile
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置EC2实例配置文件
- en: We have created a new Elastic Beanstalk application, however the current health
    of the application is logged as Severe due to several errors.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个新的弹性Beanstalk应用程序，但由于几个错误，当前应用程序的健康状态记录为严重。
- en: 'If you select the **Logs** option on the left hand menu and then select **Request
    Logs** | **Last 100 Lines**, you should be presented with a **Download** link
    that allows you to review the most recent log activity:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在左侧菜单中选择**日志**选项，然后选择**请求日志** | **最后100行**，您应该会看到一个**下载**链接，可以让您查看最近的日志活动：
- en: '![](assets/d8b79e73-f968-41de-8d12-f59c8321ea8b.png)Initial application state'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d8b79e73-f968-41de-8d12-f59c8321ea8b.png)初始应用程序状态'
- en: 'A separate tab should open in your browser, displaying various Elastic Beanstalk
    logs. At the top, you should see the ECS agent logs, and the most recent error
    should indicate that the ECS agent cannot pull the image into your `Dockerrun.aws.json`
    specification from ECR:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中应该打开一个新的标签页，显示各种Elastic Beanstalk日志。在顶部，您应该看到ECS代理日志，最近的错误应该指示ECS代理无法从ECR将图像拉入您的`Dockerrun.aws.json`规范中：
- en: '![](assets/a7babaa2-adec-436b-a371-eb476c40aa2e.png)Elastic Beanstalk ECS agent
    error'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a7babaa2-adec-436b-a371-eb476c40aa2e.png)Elastic Beanstalk ECS代理错误'
- en: 'To resolve this, we need to configure the IAM role associated with the EC2
    instance profile that is attached to our Elastic Beanstalk instances to include
    permissions to pull images from ECR.  We can see which role Elastic Beanstalk
    is using by selecting **Configuration** from the left hand menu and reviewing
    the **Virtual machine instance profile** setting in the **Security** section:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要配置与附加到我们的Elastic Beanstalk实例的EC2实例配置文件相关联的IAM角色，以包括从ECR拉取图像的权限。我们可以通过从左侧菜单中选择**配置**并在**安全**部分中查看**虚拟机实例配置文件**设置来查看Elastic
    Beanstalk正在使用的角色：
- en: '![](assets/2d1d05a4-22bd-4106-b6d2-d9ec1c92ef5e.png)Viewing security configuration'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/2d1d05a4-22bd-4106-b6d2-d9ec1c92ef5e.png)查看安全配置'
- en: 'You can see that an IAM role called **aws-elasticbeanstalk-ec2-role** is being
    used, so if you select **Services** | **IAM** from the navigation bar, select
    **Roles**, and then locate the IAM role, you need to attach the `AmazonEC2ContainerRegistryReadOnly`
    policy to the role as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到正在使用名为**aws-elasticbeanstalk-ec2-role**的IAM角色，因此，如果您从导航栏中选择**服务** | **IAM**，选择**角色**，然后找到IAM角色，您需要按照以下方式将`AmazonEC2ContainerRegistryReadOnly`策略附加到角色：
- en: '![](assets/4c1d7e88-a2ae-4e62-8813-813fe2d2bc81.png)Attaching the AmazonEC2ContainerRegistryReadOnly
    policy to the Elastic Beanstack EC2 instance role'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4c1d7e88-a2ae-4e62-8813-813fe2d2bc81.png)将AmazonEC2ContainerRegistryReadOnly策略附加到Elastic
    Beanstack EC2实例角色'
- en: 'At this point, we should have resolved the permissions issue that caused our
    application to fail to start previously.  You now need to configure Elastic Beanstalk
    to attempt to restart the application, which you can do using any one of the following
    techniques:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该已经解决了之前导致应用程序启动失败的权限问题。您现在需要配置Elastic Beanstalk尝试重新启动应用程序，可以使用以下任一技术来执行：
- en: Upload a new application source file—this will trigger a new application deployment.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上传新的应用程序源文件-这将触发新的应用程序部署。
- en: Restart app servers
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新启动应用程序服务器
- en: Rebuild the environment
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重建环境
- en: Given our application source (which in the case of a Docker application is the
    `Dockerrun.aws.json` file) has not changed, the least destructive and fastest
    option is to restart the app servers, which you can do by selecting **Actions** |
    **Restart App Server(s)** in the top right hand corner of the **All Applications**
    | **todobackend** | **Todobackend-env** configuration screen.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们的应用程序源（在Docker应用程序的情况下是`Dockerrun.aws.json`文件）没有更改，最不破坏性和最快的选项是重新启动应用程序服务器，您可以通过在**所有应用程序**
    | **todobackend** | **Todobackend-env**配置屏幕的右上角选择**操作** | **重新启动应用程序服务器(s)**来执行。
- en: 'After a few minutes, you will notice that your application still has problems,
    and if you repeat the process of obtaining the most recent logs, scanning these
    logs will show you that the **collectstatic** container is failing due to a permissions
    error:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，您会注意到您的应用程序仍然存在问题，如果您重复获取最新日志的过程，并扫描这些日志，您会发现**collectstatic**容器由于权限错误而失败：
- en: '![](assets/d000d79b-4c00-425c-9d45-95325d27e079.png)collectstatic permissions
    error'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d000d79b-4c00-425c-9d45-95325d27e079.png)collectstatic权限错误'
- en: Recall, earlier in this book, how we configured a folder with the correct permissions
    on our ECS container instances to host the public volume that the **collectstatic**
    container writes to? With Elastic Beanstalk, the default EC2 instance that is
    created for a Docker application is obviously not configured in such a fashion.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在本书的早些时候，我们如何在我们的ECS容器实例上配置了一个具有正确权限的文件夹，以托管**collectstatic**容器写入的公共卷？对于Elastic
    Beanstalk，为Docker应用程序创建的默认EC2实例显然没有以这种方式进行配置。
- en: 'We will resolve this issue shortly, but for now it is important to understand
    there are also other problems. To understand these problems, you need to actually
    attempt to access the application, which you can do so by clicking the URL link
    at the top of the All Applications | todobackend | Todobackend-env configuration
    screen:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快解决这个问题，但现在重要的是要了解还有其他问题。要了解这些问题，您需要尝试访问应用程序，您可以通过单击All Applications | todobackend
    | Todobackend-env配置屏幕顶部的URL链接来实现：
- en: '![](assets/44aeed70-ba34-4753-b83c-b25340f5d855.png)Obtaining the Elastic Beanstalk
    application URL'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 获取Elastic Beanstalk应用程序URL
- en: 'Browsing to this link should show you immediately that static content files
    are not being generated:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到此链接应立即显示静态内容文件未生成：
- en: '![](assets/def30500-bb83-4fd9-a5d0-0a8b0d026721.png)Missing static content'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少静态内容
- en: 'And if you click on the **todos** link to view the current list of Todo items,
    you will receive an error indicating that the application cannot connect to the
    MySQL database:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您单击**todos**链接以查看当前的Todo项目列表，您将收到一个错误，指示应用程序无法连接到MySQL数据库：
- en: '![](assets/232faa9e-1890-4f51-8bdb-3b829aaad7fc.png)Database connectivity error'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接错误
- en: The problem is that we haven't added any database configuration to our `Dockerrun.aws.json`
    file, hence our application is defaulting to using localhost in an attempt to
    locate the database.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们尚未向`Dockerrun.aws.json`文件添加任何数据库配置，因此我们的应用程序默认使用本地主机来定位数据库。
- en: Configuring Elastic Beanstalk applications using the CLI
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CLI配置Elastic Beanstalk应用程序
- en: We will resolve the issues that still exist with our application shortly, but
    in order do so we are going to use the Elastic Beanstalk CLI to continue configuring
    our application and address these issues.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快解决我们应用程序中仍然存在的问题，但为了解决这些问题，我们将继续使用Elastic Beanstalk CLI来继续配置我们的应用程序并解决这些问题。
- en: Before we start using the Elastic Beanstalk CLI, it is important to understand
    that the current version of this application does have some challenges when interacting
    with the multi-factor authentication (MFA) requirements we introduced for all
    console and API access in earlier chapters. If you continue to use MFA, you will
    notice that you are prompted each and every time you execute an Elastic Beanstalk
    CLI command.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用Elastic Beanstalk CLI之前，重要的是要了解，当前版本的该应用程序在与我们在早期章节中引入的多因素身份验证（MFA）要求进行交互时存在一些挑战。如果您继续使用MFA，您会注意到每次执行Elastic
    Beanstalk CLI命令时都会提示您。
- en: 'To work around this, we can temporarily remove the MFA requirement by first
    removing your user from the `Users` group:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以通过首先将用户从“Users”组中删除来临时删除MFA要求：
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, comment out the `mfa_serial` line within the `docker-in-aws` profile
    inside your local `~/.aws/config` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在本地的`~/.aws/config`文件中的`docker-in-aws`配置文件中注释掉`mfa_serial`行：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note, this is not ideal, and in a real world scenario you probably would not
    have the ability to, nor want to, temporarily disable MFA for a given user.  Bear
    this in mind when considering Elastic Beanstalk, as you will generally rely on
    the Elastic Beanstalk CLI for a number of operations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这并不理想，在实际情况下，您可能无法或不想临时禁用特定用户的MFA。在考虑Elastic Beanstalk时，请记住这一点，因为您通常会依赖Elastic
    Beanstalk CLI执行许多操作。
- en: 'With MFA now temporarily disabled, you can install the Elastic Beanstalk CLI,
    which you can do by using the Python `pip` package manager. Once it''s been installed,
    it will be accessible via the `eb` command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在MFA已被临时禁用，您可以安装Elastic Beanstalk CLI，您可以使用Python的`pip`软件包管理器来安装它。安装完成后，可以通过`eb`命令访问它：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next step is to initialize the CLI in the `todobackend/eb` folder that
    you created earlier:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在您之前创建的`todobackend/eb`文件夹中初始化CLI：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `eb init` command uses the `--profile` flag to specify a local AWS profile,
    and then prompts for the region that you will be interacting with. The CLI then
    checks to see if there are any existing Elastic Beanstalk applications, and prompts
    you as to whether you want to manage an existing application or create a new application. 
    Once you have made your selections, the CLI will add project information to the
    current folder under the a folder called `.elasticbeanstalk`, and will also create
    or append to a `.gitignore` file. Given our `eb` folder is a a subdirectory of
    the **todobackend** repository, it is a good idea to append the contents of the `.gitignore`
    file to the root of the **todobackend** repository:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`eb init`命令使用`--profile`标志来指定本地AWS配置文件，然后提示您将要交互的区域。然后CLI会检查是否存在任何现有的Elastic
    Beanstalk应用程序，并询问您是否要管理现有应用程序或创建新应用程序。一旦您做出选择，CLI将在名为`.elasticbeanstalk`的文件夹下将项目信息添加到当前文件夹中，并创建或追加到`.gitignore`文件。鉴于我们的`eb`文件夹是**todobackend**存储库的子目录，将`.gitignore`文件的内容追加到**todobackend**存储库的根目录是一个好主意：'
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can now use the CLI to view the current status of your application, list
    your application environments, and perform many other administrative tasks:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用CLI查看应用程序的当前状态，列出应用程序环境，并执行许多其他管理任务：
- en: '[PRE7]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that the `eb status` command lists the URL of your application in the
    `CNAME` property—take note of this URL as you will need it to test your application
    throughout this chapter.  You can also use the `eb open` command to access your
    application, which will open the application URL in your default browser.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`eb status`命令会列出应用程序的URL在`CNAME`属性中，请记下这个URL，因为您需要在本章中测试您的应用程序。您还可以使用`eb
    open`命令访问您的应用程序，这将在您的默认浏览器中打开应用程序的URL。
- en: Managing Elastic Beanstalk EC2 instances
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Elastic Beanstalk EC2实例
- en: When using Elastic Beanstalk, it is useful to be able to have access to the
    Elastic Beanstalk EC2 instances, especially if you need to do some troubleshooting.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Elastic Beanstalk时，能够访问Elastic Beanstalk EC2实例是很有用的，特别是如果您需要进行一些故障排除。
- en: 'The CLI includes the ability to establish SSH connections to your Elastic Beanstalk
    EC2 instances, which you can set up by running the `eb ssh --setup` command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CLI包括建立与Elastic Beanstalk EC2实例的SSH连接的功能，您可以通过运行`eb ssh --setup`命令来设置它：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that setting up SSH access requires you to terminate existing instances
    and create new instances, given you can only associate an SSH key pair with an
    EC2 instance upon creation. After selecting the existing `admin` key pair that
    you created earlier in this book, the CLI terminates the existing instances, creates
    a new auto scaling launch configuration that enables SSH access, and then launches
    new instances.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，设置 SSH 访问需要您终止现有实例并创建新实例，因为您只能在创建 EC2 实例时将 SSH 密钥对与实例关联。在选择您在本书中早期创建的现有
    `admin` 密钥对后，CLI 终止现有实例，创建一个新的自动缩放启动配置以启用 SSH 访问，然后启动新实例。
- en: You can avoid this step by configuring an EC2 key pair in the Security section
    of the configuration wizard when creating the Elastic Beanstalk application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建弹性 Beanstalk 应用程序时，您可以通过在配置向导的安全部分中配置 EC2 密钥对来避免此步骤。
- en: 'You can now SSH into your Elastic Beanstalk EC2 instance as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以按照以下步骤 SSH 进入您的弹性 Beanstalk EC2 实例：
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By default, the `eb ssh` command will attempt to use an SSH private key called
    `~/.ssh/<ec2-keypair-name>.pem`, which in this case is `~/.ssh/admin.pem`.  If
    your SSH private key is in a different location, you can use the `-e` flag to
    override the file that is used, as demonstrated in the preceding example.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`eb ssh` 命令将尝试使用名为 `~/.ssh/<ec2-keypair-name>.pem` 的 SSH 私钥，本例中为 `~/.ssh/admin.pem`。如果您的
    SSH 私钥位于不同位置，您可以使用 `-e` 标志来覆盖使用的文件，就像上面的示例中演示的那样。
- en: 'You can now take a look around at your Elastic Beanstalk EC2 instance. Given
    we are running a Docker application, you might be first inclined to run the `docker
    ps` command to see what containers are currently running:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以查看一下您的弹性 Beanstalk EC2 实例。鉴于我们正在运行一个 Docker 应用程序，您可能首先倾向于运行 `docker ps`
    命令以查看当前正在运行的容器：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Somewhat surprisingly, the standard `ec2-user` does not have access to Docker—to
    resolve this, we need to add more advanced configuration referred to as **ebextensions**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，标准的 `ec2-user` 没有访问 Docker 的权限 - 为了解决这个问题，我们需要添加更高级的配置，称为 **ebextensions**。
- en: Customizing Elastic Beanstalk applications
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义弹性 Beanstalk 应用程序
- en: As discussed in the previous section, we need to add an ebextension, which is
    simply a configuration file that can be used to customize your Elastic Beanstalk
    environment to our existing Elastic Beanstalk application.  This is an important
    concept to understand, as we will ultimately use this same approach to resolve
    all of the issues that our application currently has.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所讨论的，我们需要添加一个 ebextension，它只是一个配置文件，可用于自定义您的弹性 Beanstalk 环境以适应我们现有的弹性 Beanstalk
    应用程序。这是一个重要的概念需要理解，因为我们最终将使用相同的方法来解决我们应用程序当前存在的所有问题。
- en: 'To configure `ebextensions`, you first need to create a folder called `.ebextensions`
    in the `eb` folder where you are currently storing your `Dockerrun.aws.json` file
    (note that you will need to disconnect from the SSH session, go to your Elastic
    Beanstalk EC2 instance, and perform this in your local environment):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 `ebextensions`，首先需要在存储 `Dockerrun.aws.json` 文件的 `eb` 文件夹中创建一个名为 `.ebextensions`
    的文件夹（请注意，您需要断开 SSH 会话，转到您的弹性 Beanstalk EC2 实例，并在本地环境中执行此操作）：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Each file with a `.config` extension in the `.ebextensions` folder will be
    treated as an ebextension and processed by Elastic Beanstalk during an application
    deployment. In the preceding example, we create a file called `init.config`, which
    we can now configure to allow the `ec2-user` access to the Docker Engine:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ebextensions` 文件夹中具有 `.config` 扩展名的每个文件都将被视为 ebextension，并在应用程序部署期间由弹性 Beanstalk
    处理。在上面的示例中，我们创建了一个名为 `init.config` 的文件，现在我们可以配置它以允许 `ec2-user` 访问 Docker 引擎：'
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We add a command directive called `01_add_ec2_user_to_docker_group` to the `commands`
    key, which is a top-level property that defines commands that should be run *before*
    the latest version of your application is set up and deployed to your instances. 
    This command runs the `usermod` command to ensure that the `ec2-user` is a member
    of the `docker` group, which will grant `ec2-user` access to the Docker Engine.
    Notice that you can use the `ignoreErrors` property to ensure any command failures
    are ignored.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`commands`键中添加了一个名为`01_add_ec2_user_to_docker_group`的命令指令，这是一个顶级属性，定义了在设置和部署最新版本应用程序到实例之前应该运行的命令。该命令运行`usermod`命令，以确保`ec2-user`是`docker`组的成员，这将授予`ec2-user`访问Docker引擎的权限。请注意，您可以使用`ignoreErrors`属性来确保忽略任何命令失败。
- en: 'With this configuration in place, we can deploy a new version of our application
    by running the `eb deploy` command in the `eb` folder, which will automatically
    create a ZIP archive of our existing `Dockerrun.aws.json` and the new `.ebextensions/init.config`
    file:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，我们可以通过在`eb`文件夹中运行`eb deploy`命令来部署我们应用程序的新版本，这将自动创建我们现有的`Dockerrun.aws.json`和新的`.ebextensions/init.config`文件的ZIP存档。
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We first remove the initial `app.zip` archive you created when you first created
    the Elastic Beanstalk application, as the `eb deploy` command automatically takes
    care of this. You can see that once the new configuration is uploaded, the deployment
    process involves stopping and starting the ECS task that is running our application.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先删除您第一次创建Elastic Beanstalk应用程序时创建的初始`app.zip`存档，因为`eb deploy`命令会自动处理这个问题。您可以看到一旦新配置上传，部署过程涉及停止和启动运行我们应用程序的ECS任务。
- en: 'Once the deployment is complete, if you establish a new SSH session to the
    Elastic Beanstalk EC2 instance, you should see that you are now able to run `docker`
    commands:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 部署完成后，如果您建立一个新的SSH会话到Elastic Beanstalk EC2实例，您应该能够运行`docker`命令：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see that the instance is currently running the todobackend container,
    and also runs the ECS agent. This demonstrates that the Docker support in Elastic
    Beanstalk uses ECS in the background to manage and deploy container-based applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到实例当前正在运行todobackend容器，并且还运行ECS代理。这表明Elastic Beanstalk中的Docker支持在后台使用ECS来管理和部署基于容器的应用程序。
- en: Resolving Docker volume permissions issues
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决Docker卷权限问题
- en: Earlier in this chapter, we ran into a problem where the collectstatic container
    was unable to write to the public volume.  The issue here is that the ECS agent
    running on the Elastic Beanstalk EC2 instance creates a *bind* mount, which are
    always created with root permissions. This prevents the app user that our collectstatic
    container runs as from writing to the public volume, so we need some way to resolve
    this.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们遇到了一个问题，即collectstatic容器无法写入公共卷。问题在于Elastic Beanstalk EC2实例上运行的ECS代理创建了一个*绑定*挂载，这些挂载始终以root权限创建。这会阻止我们的collectstatic容器以app用户的身份写入公共卷，因此我们需要一些方法来解决这个问题。
- en: 'As we have already seen, the `ebextensions` feature can run commands on Elastic
    Beanstalk EC2 instances, and we will once again leverage this functionality to
    ensure that the public volume is configured to allow the `app` user in our containers
    to read and write in the `.ebextensions/init.config` file:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，`ebextensions`功能可以在Elastic Beanstalk EC2实例上运行命令，我们将再次利用这个功能来确保公共卷被配置为允许我们容器中的`app`用户读写`.ebextensions/init.config`文件：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We add a new command directive called `02_docker_volumes`, which will be executed
    after the `01_add_ec2_user_to_docker_group` command.  Notice that you can use
    the YAML pipe operator (`|`) to specify a multi-line command string, allowing
    you to specify multiple commands to run.  We first create the `/tmp/public` folder
    that the public volume host `sourcePath` property refers to in the `Dockerrun.aws.json`
    file, and then ensure that the user ID/group ID values of `1000:1000` own this
    folder.  Because the app user has a user ID of 1000 and a group ID of 1000, this
    will enable any process running as that user to write to and read from the public
    volume.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`02_docker_volumes`的新命令指令，它将在`01_add_ec2_user_to_docker_group`命令之后执行。请注意，您可以使用YAML管道运算符（`|`）来指定多行命令字符串，从而允许您指定要运行的多个命令。我们首先创建`/tmp/public`文件夹，该文件夹是`Dockerrun.aws.json`文件中公共卷主机`sourcePath`属性所指的位置，然后确保用户ID/组ID值为`1000:1000`拥有此文件夹。因为应用程序用户的用户ID为1000，组ID为1000，这将使任何以该用户身份运行的进程能够写入和读取公共卷。
- en: At this point, you can use the `eb deploy` command to upload a new application
    configuration to Elastic Beanstalk (see earlier examples). Once the deployment
    is complete, you can browse to the URL of your application by running the `eb
    open` command, and you should now see that the static content and formatting of
    the todobackend application is correct.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可以使用`eb deploy`命令将新的应用程序配置上传到Elastic Beanstalk（请参阅前面的示例）。部署完成后，您可以通过运行`eb
    open`命令浏览到应用程序的URL，并且现在应该看到todobackend应用程序的静态内容和格式正确。
- en: Configuring database settings
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置数据库设置
- en: 'We have resolved the issue with accessing the public volume, however the application
    is still not working because we are not passing in any environment variables to
    configure database settings.  The reason for this is that when you configure a
    database in Elastic Beanstalk, all database settings are made available via the
    following environment variables:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已解决了访问公共卷的问题，但是应用程序仍然无法工作，因为我们没有传递任何环境变量来配置数据库设置。造成这种情况的原因是，当您在Elastic Beanstalk中配置数据库时，所有数据库设置都可以通过以下环境变量获得：
- en: '`RDS_HOSTNAME`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RDS_HOSTNAME`'
- en: '`RDS_USERNAME`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RDS_USERNAME`'
- en: '`RDS_PASSWORD`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RDS_PASSWORD`'
- en: '`RDS_DB_NAME`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RDS_DB_NAME`'
- en: '`RDS_PORT`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RDS_PORT`'
- en: The problem for the todobackend application is that it expects database-related
    settings that are prefixed with MYSQL—for example, `MYSQL_HOST` is used to configure
    the database hostname. Although we could update our application to use the RDS
    prefixed environment variables, we might want to deploy our application to other
    cloud providers, and RDS is an AWS specific technology.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: todobackend应用程序的问题在于它期望以MYSQL为前缀的与数据库相关的设置，例如，`MYSQL_HOST`用于配置数据库主机名。虽然我们可以更新我们的应用程序以使用RDS前缀的环境变量，但我们可能希望将我们的应用程序部署到其他云提供商，而RDS是AWS特定的技术。
- en: 'An alternative, albeit more complicated approach, is to write the environment
    variable mappings to a file on the Elastic Beanstalk instance, configure this
    as a volume that the todobackend application containers can access, and then modify
    our Docker image to inject these mappings at container startup.  This requires
    us to modify the entrypoint script for the todobackend application that is located
    in the `entrypoint.sh` file at the root of the `todobackend` repository:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择，尽管更复杂的方法是将环境变量映射写入Elastic Beanstalk实例上的文件，将其配置为todobackend应用程序容器可以访问的卷，然后修改我们的Docker镜像以在容器启动时注入这些映射。这要求我们修改位于`todobackend`存储库根目录中的`entrypoint.sh`文件中的todobackend应用程序的入口脚本：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding example, we added a new test expression that checks for the
    existence of a file called `/init/environment` using the syntax `[ -f /init/environment
    ]`. If this file is found, we assume that the file includes one or more environment
    variable settings in the format `<environment variable>=<value>`—for example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们添加了一个新的测试表达式，用于检查是否存在一个名为`/init/environment`的文件，使用语法`[ -f /init/environment
    ]`。如果找到了这个文件，我们假设该文件包含一个或多个环境变量设置，格式为`<环境变量>=<值>` - 例如：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With the preceding format, we then use the `export $(cat /init/environment |
    xargs)` command, which expands to `export MYSQL_HOST=abc.xyz.com MYSQL_USERNAME=todobackend
    ... ...` using the preceding example, ensuring that each environment variable
    defined in the `/init/environment` file is exported into the environment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有了前面的格式，我们接着使用`export $(cat /init/environment | xargs)`命令，该命令会扩展为`export MYSQL_HOST=abc.xyz.com
    MYSQL_USERNAME=todobackend ... ...`，使用前面的例子，确保在`/init/environment`文件中定义的每个环境变量都被导出到环境中。
- en: 'If you now commit your changes to the `todobackend` repository and run the `make
    login`, `make test`, `make release`, and `make publish` commands, the latest `todobackend`
    Docker image will now include the updated entrypoint script. Now, we need to modify
    the `Dockerrun.aws.json` file in the `todobackend-aws/eb` folder to define a new
    volume and mount called `init`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在提交您对`todobackend`存储库的更改，并运行`make login`，`make test`，`make release`和`make
    publish`命令，最新的`todobackend` Docker镜像现在将包括更新后的入口脚本。现在，我们需要修改`todobackend-aws/eb`文件夹中的`Dockerrun.aws.json`文件，以定义一个名为`init`的新卷和挂载：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With this volume mapped to `/tmp/init` on the Elastic Beanstalk EC2 instance
    and `/init` in the `todobackend` container, all we need to do now is write environment
    variable settings to `/tmp/init/environment` on the EC2 instance, which will appear
    as `/init/environment` in the `todobackend` container, and trigger processing
    of the file using the modifications we made to the entrypoint script. The idea
    here is that we will write the Elastic Beanstalk RDS instance settings to the
    appropriate environment variable settings that the todobackend application expects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个卷映射到弹性Beanstalk EC2实例上的`/tmp/init`和`todobackend`容器中的`/init`，现在我们所需要做的就是将环境变量设置写入到EC2实例上的`/tmp/init/environment`，这将显示为`todobackend`容器中的`/init/environment`，并使用我们对入口脚本所做的修改来触发文件的处理。这里的想法是，我们将弹性Beanstalk
    RDS实例设置写入到todobackend应用程序所期望的适当环境变量设置中。
- en: Before we can do this, we need a mechanism to be able to obtain the RDS settings—fortunately,
    there is a file called `/opt/elasticbeanstalk/deploy/configuration/containerconfiguration`
    on each Elastic Beanstalk instance that includes the entire environment and application
    configuration in a JSON file format.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够做到这一点之前，我们需要一个机制来获取RDS设置 - 幸运的是，每个弹性Beanstalk实例上都有一个名为`/opt/elasticbeanstalk/deploy/configuration/containerconfiguration`的文件，其中包含整个环境和应用程序配置的JSON文件格式。
- en: 'If you SSH into an instance, you can use the `jq` utility (which is already
    pre-installed on Elastic Beanstalk instances) to extract the RDS instance settings
    for your Elastic Beanstalk application:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您SSH到一个实例，您可以使用`jq`实用程序（它已经预先安装在弹性Beanstalk实例上）来提取您的弹性Beanstalk应用程序的RDS实例设置：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With this mechanism to extract RDS settings, we can now modify the `.ebextensions/init.config`
    file to write each of these settings to the `/tmp/init/environment` file that
    will be exposed to the `todobackend` container via the `init` volume at `/init/environment`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个提取RDS设置的机制，我们现在可以修改`.ebextensions/init.config`文件，将这些设置中的每一个写入到`/tmp/init/environment`文件中，该文件将通过`init`卷暴露给`todobackend`容器，位于`/init/environment`：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We first modify the `02_docker_volumes` directive to create the `/tmp/init`
    path that the init volume is mapped to, and ensure that the app user running in
    the todobackend application has read/write access to this folder. Next, we add
    the `container_commands` key, which specifies commands that should be executed
    *after* the application configuration has been applied but *before* the application
    is started. Note that is different from the `commands` key, which executes commands
    *before* the application configuration is applied.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先修改`02_docker_volumes`指令，创建init卷映射到的`/tmp/init`路径，并确保在todobackend应用程序中运行的app用户对此文件夹具有读/写访问权限。接下来，我们添加`container_commands`键，该键指定应在应用程序配置应用后但在应用程序启动之前执行的命令。请注意，这与`commands`键不同，后者在应用程序配置应用之前执行命令。
- en: The naming of the `container_commands` key is somewhat confusing in that it
    implies commands will be run inside a Docker container. This is actually not the
    case and the `container_commands` key is completely unrelated to containers in
    the Docker sense.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`container_commands`键的命名有些令人困惑，因为它暗示命令将在Docker容器内运行。实际上并非如此，`container_commands`键与Docker中的容器完全无关。'
- en: The `01_rds_settings` command writes the various MYSQL prefixed environment
    variable settings the application requires, obtaining the appropriate value for
    each by executing the `jq` command, as we demonstrated earlier. Because this file
    is created by the root user, we finally ensure that the `app` user has read/write
    access to the `/tmp/init/environment` file, which will be present as `/init/environment`
    in the container via the init volume.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`01_rds_settings`命令编写了应用程序所需的各种MYSQL前缀环境变量设置，通过执行`jq`命令获取每个变量的适当值，就像我们之前演示的那样。因为这个文件是由root用户创建的，所以我们最终确保`app`用户对`/tmp/init/environment`文件具有读/写访问权限，该文件将通过init卷作为`/init/environment`存在于容器中。'
- en: 'If you now deploy your changes using the `eb deploy` command, once deployment
    is complete and you navigate to the todobackend application URL, if you attempt
    to list Todos items (by accessing `/todos`), notice that a new error is now displayed:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在使用`eb deploy`命令部署更改，一旦部署完成并导航到todobackend应用程序URL，如果尝试列出Todos项目（通过访问`/todos`），请注意现在显示了一个新错误：
- en: '![](assets/0463b13c-678a-412c-a600-059010e23449.png)Accessing todobackend Todos
    items error'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 访问todobackend Todos项目错误
- en: Recall that when you previously accessed the same URL, the todobackend application
    was attempting to access MySQL using localhost, however now we get an error indicating
    that the `todo_todoitem` table cannot be found in the `ebdb` database.  This confirms
    that the application is now communicating with the RDS instance, however because
    we have not run database migrations, the schema and tables to support the application
    are not in place.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当您之前访问相同的URL时，todobackend应用程序尝试使用localhost访问MySQL，但现在我们收到一个错误，指示在`ebdb`数据库中找不到`todo_todoitem`表。这证实了应用程序现在正在与RDS实例通信，但由于我们尚未运行数据库迁移，因此不支持应用程序的架构和表。
- en: Running database migrations
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行数据库迁移
- en: To fix the current issue with our application, we need to have a mechanism that
    allows us to run database migrations to create the required database schema and
    tables.  This must also happen on each application update, however this should
    only occur *once* per application update. For example, if you had multiple Elastic
    Beanstalk instances, you do not want migrations to run on each instance. Instead,
    you want migrations to run only once for each deployment.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决我们应用程序的当前问题，我们需要一个机制，允许我们运行数据库迁移以创建所需的数据库架构和表。这也必须发生在每次应用程序更新时，但这应该只发生一次*每次*应用程序更新。例如，如果您有多个Elastic
    Beanstalk实例，您不希望在每个实例上运行迁移。相反，您希望迁移仅在每次部署时运行一次。
- en: 'The `container_commands` key that you were introduced to in the previous section
    includes a useful property called `leader_only`, which configures Elastic Beanstalk
    to only run the specified command on the leader instance. This is the first instance
    that becomes available to deploy to. We can therefore add a new directive to the
    `.ebextensions/init.config` file in the `todobackend-aws/eb` folder that will
    run migrations only once per application deployment:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中介绍的`container_commands`键中包含一个有用的属性叫做`leader_only`，它配置Elastic Beanstalk只在领导者实例上运行指定的命令。这是第一个可用于部署的实例。因此，我们可以在`todobackend-aws/eb`文件夹中的`.ebextensions/init.config`文件中添加一个新的指令，每次应用程序部署时只运行一次迁移：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we write the `python3 manage.py migrate --no-input` command to the `/tmp/init/commands` file,
    which will be exposed to the application container at the location `/init/commands`. 
    This, of course, requires us to now modify the entrypoint script in the `todobackend`
    repository to look for such a file and execute the commands contained within it,
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`python3 manage.py migrate --no-input`命令写入`/tmp/init/commands`文件，该文件将暴露给应用程序容器，位置在`/init/commands`。当然，这要求我们现在修改`todobackend`存储库中的入口脚本，以查找这样一个文件并执行其中包含的命令，如下所示：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we add a new test expression that checks for the existence of the `/init/commands` file,
    and if this file exists we use the `source` command to execute each command contained
    within the file.  Because this file will only be written on the leader Elastic
    Beanstalk instance, the entrypoint script will only invoke these commands once
    per deployment.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个新的测试表达式，检查`/init/commands`文件是否存在，如果存在，我们使用`source`命令来执行文件中包含的每个命令。因为这个文件只会在领导者弹性Beanstalk实例上写入，入口脚本将在每次部署时只调用这些命令一次。
- en: 'At this point, you need to rebuild the todobackend Docker image by running
    the  `make login`, `make test`, `make release`, and `make publish` commands, after
    which you can deploy your Elastic Beanstalk changes by running the `eb deploy`
    command from the `todobackend-aws/eb` directory.  Once this has completed successfully,
    if you SSH to your Elastic Beanstalk instance and review the logs of the current
    active todobackend application container, you should see that the database migrations
    were executed when the container was started:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您需要通过运行`make login`，`make test`，`make release`和`make publish`命令来重新构建todobackend
    Docker镜像，之后您可以通过从`todobackend-aws/eb`目录运行`eb deploy`命令来部署Elastic Beanstalk更改。一旦这个成功完成，如果您SSH到您的Elastic
    Beanstalk实例并审查当前活动的todobackend应用程序容器的日志，您应该会看到数据库迁移是在容器启动时执行的：
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you now browse to the application URL, you should find that the application
    is fully functional, and you have successfully deployed a Docker application to
    Elastic Beanstalk.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在浏览应用程序URL，您应该会发现应用程序是完全可用的，并且您已成功将Docker应用程序部署到Elastic Beanstalk。
- en: 'Before we wrap up this chapter, you should restore the MFA configuration you
    temporarily disabled earlier in this chapter by adding your user account back
    to the `Users` group:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，您应该通过将您的用户帐户重新添加到`Users`组来恢复您在本章前面暂时禁用的MFA配置：
- en: '[PRE25]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'And then re-enable the `mfa_serial` line within the `docker-in-aws` profile
    inside your local `~/.aws/config` file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在本地的`~/.aws/config`文件中重新启用`docker-in-aws`配置文件中的`mfa_serial`行：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can also delete your Elastic Beanstalk environment by browsing to the main
    Elastic Beanstalk dashboard and clicking the **Actions | Delete** application
    button next to the **todobackend** application.  This will delete the CloudFormation
    stack that was created by the Elastic Beanstalk environment, which includes the
    application load balancer, RDS database instance, and EC2 instances.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过浏览主Elastic Beanstalk仪表板并单击**操作|删除**按钮旁边的**todobackend**应用程序来删除Elastic
    Beanstalk环境。这将删除Elastic Beanstalk环境创建的CloudFormation堆栈，其中包括应用程序负载均衡器、RDS数据库实例和EC2实例。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to deploy multi-container Docker applications
    using Elastic Beanstalk.  You learned why and when you would choose Elastic Beanstalk
    over other alternative container management services such as ECS, and the general
    conclusion here is that Elastic Beanstalk is great for smaller organizations with
    a small number of applications, but becomes less useful as your organization starts
    to grow and needs to start focusing on offering shared container platforms to
    reduce cost, complexity, and management overheads.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何使用Elastic Beanstalk部署多容器Docker应用程序。您了解了为什么以及何时会选择Elastic Beanstalk而不是其他替代容器管理服务，如ECS，总的结论是Elastic
    Beanstalk非常适合规模较小的组织和少量应用程序，但随着组织的增长，需要开始专注于提供共享容器平台以降低成本、复杂性和管理开销时，它变得不那么有用。
- en: You created an Elastic Beanstalk application using the AWS console, which required
    you to define a single file called `Dockerrun.aws.json` that included the container
    definitions and volumes required to run your application, and then automatically
    deployed an application load balancer and RDS database instance with minimal configuration. 
    Getting your application up and running into a fully function state was a bit
    more challenging, and required you to define advanced configuration files called
    `ebextensions` that allowed you to adapt Elastic Beanstalk to meet the specific
    needs of your application.  You learned how to install and set up the Elastic
    Beanstalk CLI, connect to your Elastic Beanstalk instances using SSH, and deploy
    configuration changes to your `Dockerrun.aws.json` file and `ebextensions` files.
    This allowed you to set up volumes on the Elastic Beanstalk instances with correct
    permissions for container applications running as non-root users, and introduced
    a special init volume where you can inject environment variable settings and commands
    that should be executed as your container starts.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用AWS控制台创建了一个Elastic Beanstalk应用程序，这需要您定义一个名为`Dockerrun.aws.json`的单个文件，其中包括运行应用程序所需的容器定义和卷，然后自动部署应用程序负载均衡器和最小配置的RDS数据库实例。将应用程序快速运行到完全功能状态是有些具有挑战性的，需要您定义名为`ebextensions`的高级配置文件，这些文件允许您调整Elastic
    Beanstalk以满足应用程序的特定需求。您学会了如何安装和设置Elastic Beanstalk CLI，使用SSH连接到Elastic Beanstalk实例，并部署对`Dockerrun.aws.json`文件和`ebextensions`文件的配置更改。这使您能够为以非根用户身份运行的容器应用程序在Elastic
    Beanstalk实例上设置正确权限的卷，并引入了一个特殊的init卷，您可以在其中注入环境变量设置和应作为容器启动时执行的命令。
- en: In the next chapter, we will take a look at Docker Swarm and how you can deploy
    Docker Swarm clusters on AWS to deploy and run your Docker applications.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下Docker Swarm以及如何在AWS上部署和运行Docker Swarm集群来部署和运行Docker应用程序。
- en: Questions
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'True/false: Elastic Beanstalk only supports single container Docker applications.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：Elastic Beanstalk只支持单容器Docker应用程序。
- en: What is the minimum required artifact to create a Docker application using Elastic
    Beanstalk?
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Elastic Beanstalk创建Docker应用程序所需的最低要求是什么？
- en: 'True/false: The `.ebextensions` folder stores YAML files that allow you to
    customise your Elastic Beanstalk instances.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：`.ebextensions` 文件夹存储允许您自定义 Elastic Beanstalk 实例的 YAML 文件。
- en: You create a new Elastic Beanstalk service that deploys a Docker application
    whose Docker image is stored in ECR.  On initial creation. the application fails,
    with the Elastic Beanstalk logs showing an error including the words "CannotPullECRContainerError". 
    How would you resolve this issue?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您创建了一个部署存储在 ECR 中的 Docker 应用程序的新 Elastic Beanstalk 服务。在初始创建时，应用程序失败，Elastic
    Beanstalk 日志显示错误，包括“CannotPullECRContainerError”一词。您将如何解决此问题？
- en: 'True/false: Out of the box without any additional configuration, Docker containers
    running as non-root users in an Elastic Beanstalk environment can read and write
    to Docker volumes.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：在不进行任何额外配置的情况下，以非根用户身份运行的 Docker 容器在 Elastic Beanstalk 环境中可以读取和写入 Docker
    卷。
- en: 'True/false: You can set the `leader_only` property to true in the `commands`
    key to run a command on only one Elastic Beanstalk instance.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：您可以将 `leader_only` 属性设置为 true，在 `commands` 键中仅在一个 Elastic Beanstalk 实例上运行命令。
- en: 'True/false: The `eb connect` command is used to establish SSH access to an
    Elastic Beanstalk instance.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：`eb connect` 命令用于建立对 Elastic Beanstalk 实例的 SSH 访问。
- en: 'True/false: Elastic Beanstalk supports application load balancer integration
    with your application.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：Elastic Beanstalk 支持将应用程序负载均衡器集成到您的应用程序中。
- en: Further reading
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看以下链接，了解本章涵盖的主题的更多信息：
- en: Elastic Beanstalk Developer Guide: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/Welcome.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/Welcome.html)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性 Beanstalk 开发人员指南：[https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/Welcome.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/Welcome.html)
- en: Multicontainer Docker Environments: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker_ecs.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker_ecs.html)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多容器 Docker 环境：[https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker_ecs.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_docker_ecs.html)
- en: Using Elastic Beanstalk with Other AWS Services: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/AWSHowTo.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/AWSHowTo.html)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Elastic Beanstalk 与其他 AWS 服务一起使用：[https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/AWSHowTo.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/AWSHowTo.html)
- en: Advanced Environment Configuration with Configuration Files: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/ebextensions.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/ebextensions.html)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用配置文件进行高级环境配置：[https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/ebextensions.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/ebextensions.html)
- en: The Elastic Beanstalk Command Line Interface: [https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3.html)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elastic Beanstalk 命令行界面：[https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3.html](https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3.html)
