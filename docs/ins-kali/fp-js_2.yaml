- en: Chapter 2. Fundamentals of Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。函数式编程基础
- en: By now, you've seen a small glimpse of what functional programming can do. But
    what exactly is functional programming? What makes one language functional and
    not another? What makes one programming style functional and not another?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了函数式编程可以做些什么的一小部分。但函数式编程到底是什么？什么使一种语言是函数式的而另一种不是？什么使一种编程风格是函数式的而另一种不是？
- en: 'In this chapter, we will first answer these questions and then cover the core
    concepts of functional programming:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先回答这些问题，然后介绍函数式编程的核心概念：
- en: Using functions and arrays for control flow
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数和数组进行控制流
- en: Writing pure functions, anonymous functions, recursive functions, and more
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写纯函数、匿名函数、递归函数等
- en: Passing functions around like objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像对象一样传递函数
- en: Utilizing the `map()`, `filter()`, and `reduce()` functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 `map()`、`filter()` 和 `reduce()` 函数
- en: Functional programming languages
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程语言
- en: Functional programming languages are languages that facilitate the functional
    programming paradigm. At the risk of oversimplifying, we could say that, if a
    language includes the features required for functional programming, then it is
    a functional language—as simple as that. In most cases, it's the programming style
    that truly determines whether a program is functional or not.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程语言是促进函数式编程范式的语言。冒昧地说，我们可以说，如果一种语言包括函数式编程所需的特性，那么它就是一种函数式语言——就是这么简单。在大多数情况下，真正决定一个程序是否是函数式的是编程风格。
- en: What makes a language functional?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么使一种语言是函数式的？
- en: Functional programming cannot be performed in C. Functional programming cannot
    be performed in Java (without a lot of cumbersome workarounds for "almost" functional
    programming). Those and many more languages simply don't contain the constructs
    to support it. They are purely object-oriented and strictly non-functional languages.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: C语言无法进行函数式编程。Java语言也无法进行函数式编程（没有大量繁琐的“几乎”函数式编程的变通方法）。这些以及许多其他语言根本就不包含支持函数式编程的结构。它们纯粹是面向对象的，严格来说不是函数式语言。
- en: At the same time, object-oriented programming cannot be performed on purely
    functional languages, such as **Scheme**, **Haskell**, and **Lisp,** just to name
    a few.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，面向对象编程无法在纯函数式语言中进行，比如Scheme、Haskell和Lisp，仅举几例。
- en: 'However, there are certain languages that support both models. Python is a
    famous example, but there are others: Ruby, Julia, and—here''s the one we''re
    interested in—JavaScript. How can these languages support two design patterns
    that are very different from each other? They contain the features required for
    both programming paradigms. However, in the case of JavaScript, the functional
    features are somewhat hidden.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些语言支持两种模型。Python就是一个著名的例子，但还有其他的：Ruby、Julia，还有我们感兴趣的JavaScript。这些语言如何支持两种非常不同的设计模式？它们包含了两种编程范式所需的特性。然而，在JavaScript的情况下，函数式特性有些隐藏。
- en: But really, it's a little more involved than that. So what makes a language
    functional?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上，情况要复杂一些。那么什么使一种语言是函数式的呢？
- en: '| Characteristic | Imperative | Functional |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 特征 | 命令式 | 函数式 |'
- en: '| --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Programming Style | Perform step-by-step tasks and manage changes in state
    | Define what the problem is and what data transformations are needed to achieve
    the solution |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 编程风格 | 执行逐步任务和管理状态变化 | 定义问题是什么以及需要哪些数据转换来实现解决方案 |'
- en: '| State Changes | Important | Non-existent |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 状态变化 | 重要 | 不存在 |'
- en: '| Order of Execution | Important | Not as important |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 执行顺序 | 重要 | 不重要 |'
- en: '| Primary Flow Control | Loops, conditionals, and function calls | Function
    calls and recursion |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 主要流程控制 | 循环、条件和函数调用 | 函数调用和递归 |'
- en: '| Primary Manipulation Unit | Structures and class objects | Functions as first-class
    objects and data sets |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 主要操作单元 | 结构和类对象 | 函数作为一等对象和数据集 |'
- en: The syntax of the language must allow for certain design patterns, such as an
    inferred type system, and the ability to use anonymous functions. Essentially,
    the language must implement Lambda calculus. Also, the interpreter's evaluation
    strategy should be non-strict and call-by-need (also known as deferred execution),
    which allows for immutable data structures and non-strict, lazy evaluation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的语法必须允许某些设计模式，比如隐式类型系统和使用匿名函数的能力。基本上，语言必须实现Lambda演算。此外，解释器的评估策略应该是非严格的和按需调用（也称为延迟执行），这允许不可变的数据结构和非严格的惰性评估。
- en: Advantages
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优势
- en: You could say that the profound enlightenment you experience when you finally
    "get it" will make learning functional programming worth it. An experience such
    as this will make you a better programmer for the rest of your life, whether you
    actually become a full-time functional programmer or not.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说，当你最终“领悟”时所经历的深刻启示将使学习函数式编程变得值得。这样的经历将使你成为终身更好的程序员，无论你是否真的成为全职的函数式程序员。
- en: But we're not talking about learning to meditate; we're talking about learning
    an extremely useful tool that will make you a better programmer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们不是在谈论学习冥想；我们在谈论学习一种极其有用的工具，这将使你成为一个更好的程序员。
- en: Formally speaking, what exactly are the practical advantages of using functional
    programming?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从形式上讲，使用函数式编程的实际优势是什么？
- en: Cleaner code
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更清晰的代码
- en: Functional programs are cleaner, simpler, and smaller. This simplifies debugging,
    testing, and maintenance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式程序更清洁、更简单、更小。这简化了调试、测试和维护。
- en: 'For example, let''s say we need a function that converts a two-dimensional
    array into a one-dimensional array. Using only imperative techniques, we could
    write it the following way:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要一个将二维数组转换为一维数组的函数。只使用命令式技术，我们可以这样写：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And using functional techniques, it could be written as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 并且使用函数式技术，可以写成如下形式：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both of these functions take the same input and return the same output. However,
    the functional example is much more concise and clean.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都接受相同的输入并返回相同的输出。然而，函数示例要简洁清晰得多。
- en: Modularity
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块化
- en: Functional programming forces large problems to be broken down into smaller
    instances of the same problem to be solved. This means that the code is more modular.
    Programs that are modular are clearly specified, easier to debug, and simpler
    to maintain. Testing is easier because each piece of modular code can potentially
    be checked for correctness.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程迫使将大问题分解为要解决的相同问题的较小实例。这意味着代码更加模块化。模块化的程序具有明确定义，更容易调试，更简单维护。测试更容易，因为每个模块化代码片段都可以潜在地检查正确性。
- en: Reusability
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可重用性
- en: Functional programs share a variety of common helper functions, due to the modularity
    of functional programming. You'll find that many of these functions can be reused
    for a variety of different applications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数式编程的模块化，函数式程序共享各种常见的辅助函数。您会发现这些函数中的许多函数可以被重用于各种不同的应用程序。
- en: Many of the most common functions will be covered later in this chapter. However,
    as you work as a functional programmer, you will inevitably compile your own library
    of little functions that can be used over and over again. For example, a well-designed
    function that searches through the lines of a configuration file could also be
    used to search through a hash table.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面将介绍许多常见的函数。然而，作为函数式程序员，您将不可避免地编写自己的小函数库，这些函数可以反复使用。例如，一个设计良好的函数，用于搜索配置文件的行，也可以用于搜索哈希表。
- en: Reduced coupling
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少耦合
- en: Coupling is the amount of dependency between modules in a program. Because the
    functional programmer works to write first-class, higher-order, pure functions
    that are completely independent of each other with no side effects on global variables,
    coupling is greatly reduced. Certainly, functions will unavoidably rely on each
    other. But modifying one function will not change another, so long as the one-to-one
    mapping of inputs to outputs remains correct.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合是程序中模块之间的依赖程度。因为函数式程序员致力于编写独立于彼此的一流、高阶、纯函数，不对全局变量产生副作用，所以耦合大大减少。当然，函数将不可避免地相互依赖。但只要输入到输出的一对一映射保持正确，修改一个函数不会改变另一个函数。
- en: Mathematically correct
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学上的正确性
- en: This last one is on a more theoretical level. Thanks to its roots in Lambda
    calculus, functional programs can be mathematically proven to be correct. This
    is a big advantage for researchers who need to prove the growth rate, time complexity,
    and mathematical correctness of a program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个是在更理论的层面上。由于其源自Lambda演算，函数式程序可以在数学上被证明是正确的。这对需要证明程序的增长率、时间复杂度和数学正确性的研究人员来说是一个巨大优势。
- en: Let's look at Fibonacci's sequence. Although it's rarely used for anything other
    than a proof-of-concept, it illustrates this concept quite well. The standard
    way of evaluating a Fibonacci sequence is to create a recursive function that
    expresses `fibonnaci(n) = fibonnaci(n-2) + fibonnaci(n–1)` with a base case to
    `return 1 when n < 2`, which makes it possible to stop the recursion and begin
    adding up the values returned at each step in the recursive call stack.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看斐波那契数列。尽管它很少用于除了概念验证之外的任何其他用途，但它很好地说明了这个概念。评估斐波那契数列的标准方法是创建一个递归函数，表达式为`fibonnaci(n)
    = fibonnaci(n-2) + fibonnaci(n–1)`，并且有一个基本情况，即`当n < 2时返回1`，这样可以停止递归并开始在递归调用堆栈的每一步返回的值上进行求和。
- en: This describes the intermediary steps involved in calculating the sequence.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了计算序列所涉及的中间步骤。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: However, with the help of a library that implements a lazy execution strategy,
    an indefinite sequence can be generated that states the *mathematical equation*
    that defines the entire sequence of numbers. Only as many numbers as needed will
    be computed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，借助实现惰性执行策略的库，可以生成一个无限序列，该序列陈述了定义整个数字序列的*数学方程*。只有需要计算的数字才会被计算。
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The second example is clearly more mathematically sound. It relies on the `Lazy.js`
    library of JavaScript. There are other libraries that can help here as well, such
    as `Sloth.js` and `wu.js`. These will be covered in [Chapter 3](part0023_split_000.html#page
    "Chapter 3. Setting Up the Functional Programming Environment"), *Setting Up the
    Functional Programming Environment*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子显然更具数学上的合理性。它依赖于JavaScript的`Lazy.js`库。还有其他可以帮助的库，比如`Sloth.js`和`wu.js`。这些将在[第3章](part0023_split_000.html#page
    "第3章。设置函数式编程环境")中进行介绍，*设置函数式编程环境*。
- en: Functional programming in a nonfunctional world
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非函数式世界中的函数式编程
- en: Can functional and nonfunctional programming be mixed together? Although this
    is the subject of [Chapter 7](part0041_split_000.html#page "Chapter 7. Functional
    and Object-oriented Programming in JavaScript"), *Functional & Object-oriented
    Programming in JavaScript*, it is important to get a few things straight before
    we go any further.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式和非函数式编程可以混合在一起吗？尽管这是[第7章](part0041_split_000.html#page "第7章。JavaScript中的函数式和面向对象编程")的主题，*JavaScript中的函数式和面向对象编程*，但在我们继续之前，有几件事情需要搞清楚。
- en: This book is not intended to teach you how to implement an entire application
    that strictly adheres to the rigors of pure functional programming. Such applications
    are rarely appropriate outside Academia. Rather, this book will teach you how
    to use functional programming design strategies within your applications to complement
    the necessary imperative code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目的不是教您如何实现严格遵循纯函数式编程严格要求的整个应用程序。这样的应用程序在学术界之外很少合适。相反，本书将教您如何在应用程序中使用函数式编程设计策略，以补充必要的命令式代码。
- en: 'For example, if you need the first four words that only contain letters out
    of some text, they could naively be written like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您需要从某个文本中提取出的前四个只包含字母的单词，可以天真地写成这样：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In contrast, a functional programmer might write them as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，函数式程序员可能会这样写：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Or, with a library of functional programming utilities, they can be simplified
    even further:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通过一个函数式编程工具库，它们甚至可以更简化：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The key to identifying functions that can be written in a more functional way
    is to look for loops and temporary variables, such as `words` and `count` instances
    in the preceding example. We can usually do away with both temporary variables
    and loops by replacing them with higher-order functions, which we will explore
    later in this chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 识别可以以更函数式方式编写的函数的关键是查找循环和临时变量，例如前面示例中的`words`和`count`实例。通常我们可以通过用高阶函数替换它们来摆脱临时变量和循环，我们将在本章后面探讨这一点。
- en: Is JavaScript a functional programming language?
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript是一种函数式编程语言吗？
- en: There is one last question we must ask ourselves. Is JavaScript a functional
    language or a non-functional language?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须问自己最后一个问题。JavaScript是一种函数式语言还是非函数式语言？
- en: JavaScript is arguably the world's most popular and least understood functional
    programming language. JavaScript is a functional programming language in C-like
    clothing. Its syntax is undeniably C-like, meaning it uses C's block syntax and
    in-fix ordering. And it's one of the worst named languages in existence. It doesn't
    take a lot of imagination to see how so many people can confuse JavaScript as
    being related to Java; somehow, its name implies that it should be! But in reality
    it has very little in common with Java. And, to really cement the idea that JavaScript
    is an object-oriented language, libraries and frameworks such as Dojo and **ease.js**
    have been hard at work attempting to abstract it and make it suitable for object-oriented
    programming. JavaScript came of age in the 1990s when OOP was all the buzz, and
    we've been told that JavaScript is object-oriented because we want it to be so
    badly. But it is not.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript可以说是世界上最流行但最不被理解的函数式编程语言。JavaScript是一种穿着C样式衣服的函数式编程语言。它的语法无可否认地类似于C，意味着它使用C的块语法和中缀顺序。而且它是存在的最糟糕的命名语言之一。毫不费力地可以想象为什么这么多人会混淆JavaScript与Java有关；不知何故，它的名字暗示着它应该有关联！但实际上它与Java几乎没有共同之处。而且，为了真正巩固JavaScript是一种面向对象的语言的想法，诸如Dojo和**ease.js**等库和框架一直在努力将其抽象化，并使其适用于面向对象的编程。JavaScript在20世纪90年代成熟起来，当时面向对象编程是所有人都在谈论的话题，我们被告知JavaScript是面向对象的，因为我们非常希望它是这样。但它并不是。
- en: 'Its true identity is much more aligned with its ancestors: Scheme and Lisp,
    two classic functional languages. JavaScript is a functional language, all the
    way. Its functions are first-class and can be nested, it has closures and compositions,
    and it allows for currying and monads. All of these are key to functional programming.
    Here are a few more reasons why JavaScript is a functional language:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它的真正身份更与其祖先相一致：Scheme和Lisp，两种经典的函数式语言。JavaScript是一种纯函数式语言。它的函数是一等公民，可以嵌套，具有闭包和组合，并且允许柯里化和单子。所有这些都是函数式编程的关键。以下是JavaScript是函数式语言的几个原因：
- en: JavaScript's lexical grammar includes the ability to pass functions as arguments,
    has an inferred type system, and allows for anonymous functions, higher-order
    functions, closures and more. These facts are paramount to achieving the structure
    and behavior of functional programming.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的词法语法包括将函数作为参数传递的能力，具有推断类型系统，并允许匿名函数、高阶函数、闭包等。这些事实对于实现函数式编程的结构和行为至关重要。
- en: 'It is not a pure object-oriented language, with most object-oriented design
    patterns achieved by copying the Prototype object, a weak model for object-oriented
    programming. **European Computer Manufacturers Association Script** (**ECMAScript**),
    JavaScript''s formal and standardized specifications for implementation, states
    the following in specification 4.2.1:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是一种纯粹的面向对象语言，大多数面向对象的设计模式是通过复制原型对象来实现的，这是一种较弱的面向对象编程模型。**欧洲计算机制造商协会脚本**（**ECMAScript**），JavaScript的正式和标准化实现规范，在规范4.2.1中陈述了以下内容：
- en: '*"ECMAScript does not contain proper classes such as those in C++, Smalltalk,
    or Java, but rather, supports constructors which create objects. In a class-based
    object-oriented language, in general, state is carried by instances, methods are
    carried by classes, and inheritance is only of structure and behavior. In ECMAScript,
    the state and methods are carried by objects, and structure, behavior and state
    are all inherited."*'
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“ECMAScript不包含像C++、Smalltalk或Java中那样的适当类，而是支持创建对象的构造函数。在基于类的面向对象语言中，一般来说，状态由实例承载，方法由类承载，继承仅涉及结构和行为。在ECMAScript中，状态和方法由对象承载，结构、行为和状态都是继承的。”*'
- en: It is an interpreted language. Sometimes called "engines", JavaScript interpreters
    often closely resemble Scheme interpreters. Both are dynamic, both have flexible
    datatypes that easily combine and transform, both evaluate the code into blocks
    of expressions, and both treat functions similarly.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一种解释性语言。有时被称为“引擎”，JavaScript解释器通常与Scheme解释器非常相似。两者都是动态的，都具有灵活的数据类型，可以轻松组合和转换，都将代码评估为表达式块，并且都类似地处理函数。
- en: That being said, it is true that JavaScript is not a pure functional language.
    What's lacking is lazy evaluation and built-in immutable data. This is because
    most interpreters are call-by-name and not call-by-need. JavaScript also isn't
    very good with recursion due to the way it handles tail calls. However, all of
    these issues can be mitigated with a little bit of attention. Non-strict evaluation,
    required for infinite sequences and lazy evaluation, can be achieved with a library
    called `Lazy.js`. Immutable data can be achieved simply by programming technique,
    but this requires more programmer discipline rather than relying on the language
    to take care of it. And recursive tail call elimination can be achieved with a
    method called **Trampolining**. These issues will be addressed in [Chapter 6](part0037_split_000.html#page
    "Chapter 6. Advanced Topics and Pitfalls in JavaScript"), *Advanced Topics & Pitfalls
    in JavaScript*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，JavaScript并不是一种纯函数式语言。缺少的是惰性求值和内置的不可变数据。这是因为大多数解释器是按名称调用而不是按需调用。由于它处理尾调用的方式，JavaScript也不太擅长递归。然而，所有这些问题都可以通过一点注意来缓解。非严格求值，用于无限序列和惰性求值，可以通过一个名为`Lazy.js`的库来实现。不可变数据可以通过编程技术简单实现，但这需要更多的程序员纪律，而不是依赖语言来处理。递归尾调用消除可以通过一种称为**Trampolining**的方法来实现。这些问题将在[第6章](part0037_split_000.html#page
    "第6章. JavaScript中的高级主题和陷阱")中得到解决，*JavaScript中的高级主题和陷阱*。
- en: Many debates have been waged over whether or not JavaScript is a functional
    language, an object-oriented language, both, or neither. And this won't be the
    last debate.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JavaScript是一种函数式语言、面向对象语言、两者都是还是两者都不是，已经进行了许多争论。而且这不会是最后一次辩论。
- en: In the end, functional programming is way of writing cleaner code through clever
    ways of mutating, combining, and using functions. And JavaScript provides an excellent
    medium for this approach. If you really want to use JavaScript to its full potential,
    you must learn how to use it as a functional language.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，函数式编程是通过巧妙地改变、组合和使用函数的方式来编写更清晰的代码。JavaScript为这种方法提供了一个出色的媒介。如果您真的想要充分发挥JavaScript的潜力，您必须学会将其用作一种函数式语言。
- en: Working with functions
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数
- en: '|   | *Sometimes, the elegant implementation is a function. Not a method. Not
    a class. Not a framework. Just a function.* |   |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|   | *有时，优雅的实现是一个函数。不是一个方法。不是一个类。不是一个框架。只是一个函数。* |   |'
- en: '|   | --*John Carmack, lead programmer of the Doom video game* |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '|   | --*约翰·卡马克，末日游戏的首席程序员* |'
- en: Functional programming is all about decomposing a problem into a set of functions.
    Often, functions are chained together, nested within each other, passed around,
    and treated as first-class citizens. If you've used frameworks such as jQuery
    and Node.js, you've probably used some of these techniques, you just didn't realize
    it!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是将问题分解为一组函数的过程。通常，函数被链接在一起，嵌套在彼此内部，传递并被视为一等公民。如果您使用过jQuery和Node.js等框架，您可能已经使用了其中一些技术，只是您没有意识到！
- en: Let's start with a little JavaScript dilemma.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个小JavaScript困境开始。
- en: 'Say we need to compile a list of values that are assigned to generic objects.
    The objects could be anything: dates, HTML objects, and so on.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编译一个分配给通用对象的值列表。对象可以是任何东西：日期、HTML对象等等。
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It works but it's volatile. Any code can modify the `values` object without
    calling the `accumulate()` function. And if we forget to assign the empty set,
    `[]`, to the `values` instance then the code will not work at all.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它能工作，但它是不稳定的。任何代码都可以修改`values`对象，而不调用`accumulate()`函数。如果我们忘记将空集`[]`分配给`values`实例，那么代码将根本无法工作。
- en: But if the variable is declared inside the function, it can't be mutated by
    any rogue lines of code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果变量在函数内声明，它就不能被任何不受控制的代码改变。
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It does not work! Only the value of the object last passed in is returned.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 它不起作用！只返回最后传入的对象的值。
- en: We could possibly solve this with a nested function inside the first function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能可以通过在第一个函数内部嵌套一个函数来解决这个问题。
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: But it's the same issue, and now we cannot reach the `accumulate` function or
    the `values` variable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题是一样的，现在我们无法访问`accumulate`函数或`values`变量。
- en: What we need is a self-invoking function.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个自调用函数。
- en: Self-invoking functions and closures
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自调用函数和闭包
- en: What if we could return a function expression that in-turn returns the `values`
    array? Variables declared in a function are available to any code within the function,
    including self-invoking functions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能返回一个函数表达式，该表达式反过来返回`values`数组呢？在函数中声明的变量对函数内的任何代码都是可用的，包括自调用函数。
- en: By using a self-invoking function, our dilemma is solved.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用自调用函数，我们解决了我们的困境。
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It's all about variable scoping. The `values` variable is available to the inner
    `accumulate()` function, even when code outside the scope calls the functions.
    This is called a closure.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这都与变量作用域有关。`values`变量对内部的`accumulate()`函数是可用的，即使在作用域外部调用函数时也是如此。这就是闭包。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Closures in JavaScript are functions that have access to the parent scope, even
    when the parent function has closed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的闭包是指即使父函数已关闭，也可以访问父作用域的函数。
- en: Closures are a feature of all functional languages. Traditional imperative languages
    do not allow them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是所有函数式语言的特性。传统的命令式语言不允许它们。
- en: Higher-order functions
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Self-invoking functions are actually a form of higher-order functions. Higher-order
    functions are functions that either take another function as the input or return
    a function as the output.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 自调用函数实际上是一种高阶函数形式。高阶函数是要么将另一个函数作为输入，要么将一个函数作为输出的函数。
- en: Higher-order functions are not common in traditional programming. While an imperative
    programmer might use a loop to iterate an array, a functional programmer would
    take another approach entirely. By using a higher-order function, the array can
    be worked on by applying that function to each item in the array to create a new
    array.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数在传统编程中并不常见。在命令式编程中，程序员可能会使用循环来迭代数组，而函数式编程者则会采取完全不同的方法。通过使用高阶函数，可以通过将该函数应用于数组中的每个项来对数组进行操作，从而创建一个新数组。
- en: This is the central idea of the functional programming paradigm. What higher-order
    functions allow is the ability to pass logic to other functions, just like objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是函数式编程范式的核心思想。高阶函数允许将逻辑传递给其他函数，就像对象一样。
- en: Functions are treated as first-class citizens in JavaScript, a distinction JavaScript
    shares with Scheme, Haskell, and the other classic functional languages. This
    may sound bizarre, but all this really means is that functions are treated as
    primitives, just like numbers and objects. If numbers and objects can be passed
    around, so can functions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数被视为一等公民，这是JavaScript与Scheme、Haskell和其他经典函数式语言共享的特点。这听起来很奇怪，但这实际上意味着函数被视为原语，就像数字和对象一样。如果数字和对象可以被传递，那么函数也可以被传递。
- en: 'To see this in action, let''s use a higher-order function with our `ValueAccumulator()`
    function from the previous section:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这一点，让我们在前面部分的`ValueAccumulator()`函数中使用一个高阶函数：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Pure functions
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数
- en: Pure functions return a value computed using only the inputs passed to it. Outside
    variables and global states may not be used and there may be no side effects.
    In other words, it must not mutate the variables passed to it for input. Therefore,
    pure functions are only used for their returned value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数返回仅使用传递给它的输入计算的值。不能使用外部变量和全局状态，也不能产生副作用。换句话说，它不能改变传递给它的输入变量。因此，纯函数只能用于它们的返回值。
- en: A simple example of this is a math function. The `Math.sqrt(4)` function will
    always return `2`, does not use any hidden information such as settings or state,
    and will never inflict any side effects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子是数学函数。`Math.sqrt(4)`函数将始终返回`2`，不使用任何隐藏信息，如设置或状态，并且永远不会产生任何副作用。
- en: Pure functions are the true interpretation of the mathematical term for 'function',
    a relation between inputs and an output. They are simple to think about and are
    readily re-usable. Because they are totally independent, pure functions are more
    capable of being used again and again.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是对数学术语“函数”的真正解释，它是输入和输出之间的关系。它们很容易理解，并且可以被很容易地重复使用。因为它们是完全独立的，所以纯函数更有可能被反复使用。
- en: To illustrate this, compare the following non-pure function to the pure one.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，比较以下非纯函数和纯函数。
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While the non-pure function relies on the state of the window object to compute
    the height and width, the pure, self-sufficient function instead asks that those
    values be passed in. What this actually does is allow the message to be printed
    anywhere, and this makes the function much more versatile.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 非纯函数依赖于窗口对象的状态来计算高度和宽度，而纯自给自足的函数则要求传入这些值。实际上，这样做可以让消息在任何地方打印，这使得函数更加灵活。
- en: And while the non-pure function may seem like the easier option because it performs
    the appending itself instead of returning an element, the pure function `printSomewhere()`
    and its returned value play better with other functional programming design techniques.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然非纯函数可能看起来更容易，因为它自己执行附加而不是返回一个元素，但纯函数`printSomewhere()`及其返回值与其他函数式编程设计技术更配合。
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When the functions are pure and don't rely on state or environment, then we
    don't care about when or where they actually get computed. We'll see this later
    with lazy evaluation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数是纯的并且不依赖于状态或环境时，我们不关心它们实际上何时何地被计算。稍后我们将在惰性求值中看到这一点。
- en: Anonymous functions
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Another benefit of treating functions as first-class objects is the advent of
    anonymous functions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数视为一等公民的另一个好处是匿名函数的出现。
- en: As the name might imply, anonymous functions are functions without names. But
    they are more than that. What they allow is the ability to define ad-hoc logic,
    on-the-spot and as needed. Usually, it's for the benefit of convenience; if the
    function is only referred to once, then a variable name doesn't need to be wasted
    on it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，匿名函数是没有名称的函数。但它们不仅仅是这样。它们允许根据需要定义临时逻辑。通常是为了方便起见；如果函数只被引用一次，那么就不需要浪费一个变量名。
- en: 'Some examples of anonymous functions are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一些匿名函数的例子如下：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A more involved example of anonymous functions used within higher-order functions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在高阶函数中使用匿名函数的更复杂的例子：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The function that is returned doesn't need to be named; it can't be used anywhere
    outside the `powersOf()` function, and so it is an anonymous function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的函数不需要被命名；它不能在`powersOf()`函数之外的任何地方使用，因此它是一个匿名函数。
- en: Remember our accumulator function? It can be re-written using anonymous functions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们的累加器函数吗？可以使用匿名函数来重写它。
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Right on! A pure, high-order, anonymous function. How did we ever get so lucky?
    Actually, it's more than that. It's also *self-executing* as indicated by the
    structure, `(function(){...})();`. The pair of parentheses following the anonymous
    function causes the function to be called right away. In the above example, the
    `values` instance is assigned to the output of the self-executing function call.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！一个纯的、高阶的、匿名的函数。我们怎么会这么幸运呢？实际上，它不仅仅是这样。它还是*自执行*的，如结构`(function(){...})();`所示。匿名函数后面的一对括号会立即调用函数。在上面的例子中，`values`实例被赋值为自执行函数调用的输出。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Anonymous functions are more than just syntactical sugar. They are the embodiment
    of Lambda calculus. Stay with me on this… Lambda calculus was invented long before
    computers or computer languages. It was just a mathematical notion for reasoning
    about functions. Remarkably, it was discovered that—despite the fact that it only
    defines three kinds of expressions: variable references, function calls, and *anonymous
    functions*—it was Turing-complete. Today, Lambda calculus lies at the core of
    all functional languages if you know how to find it, including JavaScript.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数不仅仅是一种语法糖。它们是Lambda演算的体现。跟我一起来理解一下……Lambda演算是在计算机或计算机语言出现之前发明的。它只是用于推理函数的数学概念。令人惊讶的是，尽管它只定义了三种表达式：变量引用、函数调用和*匿名函数*，它却是图灵完备的。今天，如果你知道如何找到它，Lambda演算是所有函数式语言的核心，包括JavaScript。
- en: For this reason, anonymous functions are often called lambda expressions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，匿名函数通常被称为Lambda表达式。
- en: One drawback to anonymous functions remains. They're difficult to identify in
    call stacks, which makes debugging trickier. They should be used sparingly.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数的一个缺点是它们很难在调用堆栈中识别，这使得调试变得更加棘手。应该谨慎使用它们。
- en: Method chains
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法链
- en: Chaining methods together in JavaScript is quit common. If you've used jQuery,
    you've likely performed this technique. It's sometimes called the "Builder Pattern".
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中链接方法是相当常见的。如果你使用过jQuery，你可能已经使用过这种技术。有时被称为“构建器模式”。
- en: It's a technique that is used to simplify code where multiple functions are
    applied to an object one after another.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种用于简化代码的技术，其中多个函数依次应用于对象。
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This only works when the functions are methods of the object being worked on.
    If you created your own function that, for example, takes two arrays and returns
    an array with the two arrays zipped together, you must declare it as a member
    of the `Array.prototype` object. Take a look at the following code snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这只有在函数是对象的方法时才有效。如果你创建了自己的函数，例如，接受两个数组并返回一个将这两个数组合并在一起的数组，你必须将它声明为`Array.prototype`对象的成员。看一下以下代码片段：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This would allow us to the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够做到以下几点：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Recursion
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归
- en: Recursion is likely the most famous functional programming technique. If you
    don't know by now, a recursive function is a function that calls itself.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 递归很可能是最著名的函数式编程技术。如果你还不知道，递归函数是调用自身的函数。
- en: When a functions calls *itself*, something strange happens. It acts both as
    a loop, in that it executes the same code multiple times, and as a function stack.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数调用*它自己*时，会发生一些奇怪的事情。它既像一个循环，执行相同的代码多次，又像一个函数堆栈。
- en: Recursive functions must be very careful to avoid an infinite loop (rather,
    infinite recursion in this case). So just like loops, a condition must be used
    to know when to stop. This is called the base case.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数必须非常小心地避免无限循环（在这种情况下是无限递归）。因此，就像循环一样，必须使用条件来知道何时停止。这被称为基本情况。
- en: 'An example is as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子如下：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It's possible to convert any loop to a recursive algorithm and any recursive
    algorithm to a loop. But recursive algorithms are more appropriate, almost necessary,
    for situations that differ greatly from those where loops are appropriate.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将任何循环转换为递归算法，也可以将任何递归算法转换为循环。但是递归算法更适合，几乎是必要的，用于与适合使用循环的情况大不相同的情况。
- en: A good example is tree traversal. While it's not too hard to traverse a tree
    using a recursive function, a loop would be much more complex and would need to
    maintain a stack. And that would go against the spirit of functional programming.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是树的遍历。虽然使用递归函数遍历树并不太难，但使用循环会更加复杂，并且需要维护一个堆栈。这与函数式编程的精神相违背。
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Divide and conquer
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分而治之
- en: Recursion is more than an interesting way to iterate without `for` and `while`
    loops. An algorithm design, known as divide and conquer, recursively breaks problems
    down into smaller instances of the same problem until they're small enough to
    solve.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 递归不仅仅是一种在没有`for`和`while`循环的情况下进行迭代的有趣方式。一种算法设计，称为分而治之，将问题递归地分解为相同问题的较小实例，直到它们足够小以便解决。
- en: The historical example of this is the Euclidan algorithm for finding the greatest
    common denominator for two numbers.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这方面的历史例子是欧几里得算法，用于找到两个数的最大公约数。
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So in theory, divide and conquer works quite eloquently, but does it have any
    use in the real world? Yes! The JavaScript function for sorting arrays is not
    very good. Not only does it sort the array in place, which means that the data
    is not immutable, but it is unreliable and inflexible. With divide and conquer,
    we can do better.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所以从理论上讲，分而治之的工作方式非常优雅，但它在现实世界中有用吗？是的！JavaScript中用于对数组进行排序的函数并不是很好。它不仅会就地对数组进行排序，这意味着数据是不可变的，而且它也不可靠和灵活。通过分而治之，我们可以做得更好。
- en: The merge sort algorithm uses the divide and conquer recursive algorithm design
    to efficiently sort an array by recursively dividing the array into smaller sub-arrays
    and then merging them together.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序算法使用分而治之的递归算法设计，通过递归地将数组分成较小的子数组，然后将它们合并在一起来高效地对数组进行排序。
- en: 'The full implementation in JavaScript is about 40 lines of code. However, pseudo-code
    is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中的完整实现大约有40行代码。然而，伪代码如下：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Lazy evaluation
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惰性求值
- en: Lazy evaluation, also known as non-strict evaluation, call-by-need and deffered
    execution, is an evaluation strategy that waits until the value is needed to compute
    the result of a function and is particularly useful for functional programming.
    It's clear that a line of code that states `x = func()` is calling for `x` to
    be assigned to the returned value by `func()`. But what `x` actually equates to
    does not matter until it is needed. Waiting to call `func()` until `x` is needed
    is known as lazy evaluation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性评估，也称为非严格评估、按需调用和延迟执行，是一种等到需要值时才计算函数结果的评估策略，对函数式编程非常有用。很明显，一行代码 `x = func()`
    表示要将 `x` 赋值为 `func()` 返回的值。但是 `x` 实际上等于什么并不重要，直到需要它为止。等到需要 `x` 时再调用 `func()` 就是惰性评估。
- en: This strategy can result in a major increase in performance, especially when
    used with method chains and arrays, the favorite program flow techniques of the
    functional programmer.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略可以大大提高性能，特别是在方法链和数组中使用时，这是函数式编程者最喜欢的程序流技术。
- en: 'One exciting benefit of lazy evaluation is the existence of infinite series.
    Because nothing is actually computed until it can''t be delayed any further, it''s
    possible to do this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 惰性评估的一个令人兴奋的好处是存在无限序列。因为直到不能再延迟才实际计算任何东西，所以这是可能的：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This opens the door for many possibilities: asynchronous execution, parallelization,
    and composition, just to name a few.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这为许多可能性打开了大门：异步执行、并行化和组合，仅举几例。
- en: 'However, there''s one problem: JavaScript does not perform Lazy evaluation
    on its own. That being said, there exist libraries for JavaScript that simulate
    lazy evaluation very well. That is the subject of [Chapter 3](part0023_split_000.html#page
    "Chapter 3. Setting Up the Functional Programming Environment"), *Setting Up the
    Functional Programming Environment*.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题：JavaScript 本身不执行惰性评估。也就是说，存在着一些用于 JavaScript 的库，可以非常好地模拟惰性评估。这就是《第
    3 章》《设置函数式编程环境》的主题。
- en: The functional programmer's toolkit
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程者的工具包
- en: If you've looked closely at the few examples presented so far, you'll notice
    a few methods being used that you may not be familiar with. They are the `map()`,
    `filter()`, and `reduce()` functions, and they are crucial to every functional
    program of any language. They enable you to remove loops and statements, resulting
    in cleaner code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看了到目前为止呈现的几个例子，你会注意到使用了一些你可能不熟悉的方法。它们是 `map()`、`filter()` 和 `reduce()`
    函数，对任何语言的函数式程序都至关重要。它们使你能够消除循环和语句，从而使代码更加清晰。
- en: '`The map()`, `filter()`, and `reduce()` functions make up the core of the functional
    programmer''s toolkit, a collection of pure, higher-order functions that are the
    workhorses of the functional method. In fact, they''re the epitome of what a pure
    function and what a higher-order function should be like; they take a function
    as input and return an output with zero side effects.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`、`filter()` 和 `reduce()` 函数构成了函数式编程者工具包的核心，这是一组纯的高阶函数，是函数式方法的工作马。事实上，它们是纯函数和高阶函数应该具有的典范；它们接受一个函数作为输入，并返回一个没有副作用的输出。'
- en: While they're standard for browsers that implement ECMAScript 5.1, they only
    work on arrays. Each time it's called, a new array is created and returned. The
    existing array is not modified. But there's more, *they take functions as inputs*,
    often in the form of anonymous functions referred to as callback functions; they
    iterate over the array and apply the function to each item in the array!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们是 ECMAScript 5.1 实现的浏览器的标准，但它们只适用于数组。每次调用时，都会创建并返回一个新数组。现有数组不会被修改。但还有更多，*它们接受函数作为输入*，通常以匿名函数的形式作为回调函数；它们遍历数组并将函数应用于数组中的每个项目！
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: One more thing. Because they only work on arrays, they do not work on other
    iterable data structures, like certain objects. Fret not, libraries such as `underscore.js`,
    `Lazy.js`, `stream.js`, and many more all implement their own `map()`, `filter()`,
    and `reduce()` methods that are more versatile.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点。因为它们只适用于数组，所以不能用于其他可迭代的数据结构，比如某些对象。不用担心，诸如 `underscore.js`、`Lazy.js`、`stream.js`
    等库都实现了自己的 `map()`、`filter()` 和 `reduce()` 方法，更加灵活。
- en: Callbacks
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调
- en: If you've never worked with callbacks before, you might find the concept a little
    puzzling. This is especially true in JavaScript, given the several different ways
    that JavaScript allows you to declare functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前从未使用过回调函数，可能会觉得这个概念有点费解。特别是在 JavaScript 中，因为 JavaScript 允许以多种方式声明函数。
- en: 'A `callback()` function is used for passing to other functions for them to
    use. It''s a way to pass logic just as you would pass an object:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback()` 函数用于传递给其他函数以供其使用。这是一种传递逻辑的方式，就像传递对象一样：'
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To make it simpler for easy tasks, anonymous functions can be used:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化简单的任务，可以使用匿名函数：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'They are not only used in functional programming, they are used for many things
    in JavaScript. Purely for example, here''s a `callback()` function used in an
    AJAX call made with jQuery:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不仅用于函数式编程，还用于 JavaScript 中的许多其他事情。仅举一个例子，这是在使用 jQuery 进行 AJAX 调用时使用的 `callback()`
    函数：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Notice that only the name of the function was used. And because we''re not
    calling the callback and are only passing the name of it, it would be wrong to
    write this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意只使用了函数的名称。因为我们没有调用回调，只是传递了它的名称，所以写成这样是错误的：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: What would happen if we did call the callback? In that case, the `myCallback(xhr)`
    method would try to execute—'undefined' would be printed to the console and it
    would return `True`. When the `ajax()` call completes, it will have 'true' as
    the name of the callback function to use, and that will throw an error.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用回调会发生什么？在这种情况下，`myCallback(xhr)` 方法将尝试执行——控制台将打印“undefined”，并返回 `True`。当
    `ajax()` 调用完成时，它将以 'true' 作为要使用的回调函数的名称，这将引发错误。
- en: 'What this also means is that we cannot specify what arguments are passed to
    the callback functions. If we need different parameters from what the `ajax()`
    call will pass to it, we can wrap the callback function in an anonymous function:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们无法指定传递给回调函数的参数。如果我们需要与`ajax()`调用传递给它的参数不同的参数，我们可以将回调函数包装在匿名函数中：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Array.prototype.map()
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Array.prototype.map()
- en: The `map()` function is the ringleader of the bunch. It simply applies the callback
    function on each item in the array.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`函数是这一系列中的头目。它只是在数组中的每个项目上应用回调函数。'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Syntax: `arr.map(callback [, thisArg]);`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：`arr.map(callback [, thisArg]);`
- en: 'Parameters:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`callback()`: This function produces an element for the new array, receiving
    these arguments:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`回调()`: 此函数为新数组生成一个元素，接收以下参数：'
- en: '`currentValue`: This argument gives the current element being processed in
    the array'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentValue`：此参数给出正在处理的数组中的当前元素'
- en: '`index`: This argument gives the index of the current element in the array'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`索引`：此参数给出数组中当前元素的索引'
- en: '`array`: This argument gives the array being processed'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数组`：此参数给出正在处理的数组'
- en: '`thisArg()`: This function is optional. The value is used as `this` when executing
    `callback`.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thisArg()`: 此函数是可选的。在执行`回调`时，该值将被用作`this`。'
- en: 'Examples:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While the `Array.prototype.map` method is a standard method for the Array object
    in JavaScript, it can be easily extended to your custom objects as well.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Array.prototype.map`方法是JavaScript中数组对象的标准方法，但它也可以很容易地扩展到您的自定义对象。
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Array.prototype.filter()
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Array.prototype.filter()
- en: The `filter()` function is used to take elements out of an array. The callback
    must return `True` (to include the item in the new array) or `False` (to drop
    it). Something similar could be achieved by using the `map()` function and returning
    a `null` value for items you want dropped, but the `filter()` function will delete
    the item from the new array instead of inserting a `null` value in its place.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`函数用于从数组中取出元素。回调必须返回`True`（以在新数组中包含该项）或`False`（以删除该项）。使用`map()`函数并返回要删除的项目的`null`值也可以实现类似的效果，但`filter()`函数将从新数组中删除该项，而不是在其位置插入`null`值。'
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Syntax: `arr.filter(callback [, thisArg]);`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：`arr.filter(callback [, thisArg]);`
- en: 'Parameters:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`callback()`: This function is used to test each element in the array. Return
    `True` to keep the element, `False` otherwise. With these parameters:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`回调()`: 此函数用于测试数组中的每个元素。返回`True`以保留该元素，否则返回`False`。具有以下参数：'
- en: '`currentValue`: This parameter gives the current element being processed in
    the array'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentValue`：此参数给出正在处理的数组中的当前元素'
- en: '`index`: This parameter gives the index of the current element in the array'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`索引`：此参数给出数组中当前元素的索引'
- en: '`array`: This parameter gives the array being processed.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数组`：此参数给出正在处理的数组。'
- en: '`thisArg()`: This function is optional. Value is used as `this` when executing
    `callback`.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thisArg()`: 此函数是可选的。在执行`回调`时，该值将被用作`this`。'
- en: 'Examples:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Array.prototype.reduce()
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Array.prototype.reduce()
- en: Sometimes called fold, the `reduce()` function is used to accumulate all the
    values of the array into one. The callback needs to return the logic to be performed
    to combine the objects. In the case of numbers, they're usually added together
    to get a sum or multiplied together to get a product. In the case of strings,
    the strings are often appended together.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有时称为折叠，`reduce()`函数用于将数组的所有值累积为一个值。回调需要返回要执行的逻辑以组合对象。对于数字，它们通常相加以获得总和或相乘以获得乘积。对于字符串，通常将字符串追加在一起。
- en: Note
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Syntax: `arr.reduce(callback [, initialValue]);`'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：`arr.reduce(callback [, initialValue]);`
- en: 'Parameters:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`callback()`: This function combines two objects into one, which is returned.
    With these parameters:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`回调()`: 此函数将两个对象合并为一个，并返回。具有以下参数：'
- en: '`previousValue`: This parameter gives the value previously returned from the
    last invocation of the callback, or the `initialValue`, if supplied'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`previousValue`：此参数给出上一次调用回调时返回的值，或者如果提供了`initialValue`，则给出`initialValue`'
- en: '`currentValue`: This parameter gives the current element being processed in
    the array'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentValue`：此参数给出正在处理的数组中的当前元素'
- en: '`index`: This parameter gives the index of the current element in the array'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`索引`：此参数给出数组中当前元素的索引'
- en: '`array`: This parameter gives the array being processed'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数组`：此参数给出正在处理的数组'
- en: '`initialValue()`: This function is optional. Object to use as the first argument
    to the first call of the `callback`.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialValue()`: 此函数是可选的。用作`回调`的第一个参数的对象。'
- en: 'Examples:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Honorable mentions
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 荣誉提及
- en: The `map()`, `filter()`, and `reduce()` functions are not alone in our toolbox
    of helper functions. There exist many more functions that can be plugged into
    nearly any functional application.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()`、`filter()`和`reduce()`函数并不是我们辅助函数工具箱中的唯一函数。还有许多其他函数可以插入到几乎任何功能应用程序中。'
- en: Array.prototype.forEach
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Array.prototype.forEach
- en: Essentially the non-pure version of `map()`, `forEach()` iterates over an array
    and applies a `callback()` function over each item. However, it doesn't return
    anything. It's a cleaner way of performing a `for` loop.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上是`map()`的非纯版本，`forEach()`遍历数组并在每个项目上应用`回调()`函数。但它不返回任何东西。这是执行`for`循环的更干净的方式。
- en: Note
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Syntax: `arr.forEach(callback [, thisArg]);`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 语法：`arr.forEach(callback [, thisArg]);`
- en: 'Parameters:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`callback()`: This function is to be performed for each value of the array.
    With these parameters:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`回调()`: 此函数用于对数组的每个值执行。具有以下参数：'
- en: '`currentValue`: This parameter gives the current element being processed in
    the array'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currentValue`：此参数给出正在处理的数组中的当前元素'
- en: '`index`: This parameter gives the index of the current element in the array'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`索引`：此参数给出数组中当前元素的索引'
- en: '`array`: This parameter gives the array being processed'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数组`：此参数给出正在处理的数组'
- en: '`thisArg`: This function is optional. Value is used as `this` when executing
    `callback`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thisArg`：此函数是可选的。在执行`回调`时，该值将被用作`this`。'
- en: 'Examples:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Array.prototype.concat
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Array.prototype.concat
- en: When working with arrays instead of `for` and `while` loops, often you will
    need to join multiple arrays together. Another built-in JavaScript function, `concat()`,
    takes care of this for us. The `concat()` function returns a new array and leaves
    the old arrays untouched. It can join as many arrays as you pass to it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数组时，通常需要将多个数组连接在一起，而不是使用`for`和`while`循环。另一个内置的JavaScript函数`concat()`可以为我们处理这个问题。`concat()`函数返回一个新数组，不会改变旧数组。它可以连接你传递给它的任意多个数组。
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The original array is untouched. It returns a new array with both arrays concatenated
    together. This also means that the `concat()` function can be chained together.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数组不受影响。它返回一个新数组，其中包含两个数组连接在一起。这也意味着`concat()`函数可以链接在一起。
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Variables `x`, `y` and `z` all contain `[1,2,3,4,5,6,7,8,9]`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`x`、`y`和`z`都包含`[1,2,3,4,5,6,7,8,9]`。
- en: Array.prototype.reverse
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Array.prototype.reverse
- en: Another native JavaScript function helps with array transformations. The `reverse()`
    function inverts an array, such that the first element is now the last and the
    last is now the first.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原生JavaScript函数有助于数组转换。`reverse()`函数颠倒了一个数组，使得第一个元素现在是最后一个，最后一个是第一个。
- en: 'However, it does not return a new array; instead it mutates the array in place.
    We can do better. Here''s an implementation of a pure method for reversing an
    array:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它不会返回一个新数组；而是就地改变数组。我们可以做得更好。下面是一个纯方法的实现，用于颠倒一个数组：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Array.prototype.sort
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Array.prototype.sort
- en: Much like our `map()`, `filter()`, and `reduce()` methods, the `sort()` method
    takes a `callback()` function that defines how the objects within an array should
    be sorted. But, like the `reverse()` function, it mutates the array in place.
    And that's no bueno.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的`map()`、`filter()`和`reduce()`方法类似，`sort()`方法接受一个定义数组中对象应如何排序的`callback()`函数。但是，与`reverse()`函数一样，它会就地改变数组。这样做不好。
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We could write a pure `sort()` function that doesn''t mutate the array, but
    sorting algorithms is the source of much grief. Significantly large arrays that
    need to be sorted really should be organized in data structures that are designed
    just for that: quickStort, mergeSort, bubbleSort, and so on.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个不会改变数组的纯`sort()`函数，但是排序算法是让人头疼的源泉。需要排序的大型数组应该被组织在专门设计用于此目的的数据结构中：quickStort、mergeSort、bubbleSort等等。
- en: Array.prototype.every and Array.prototype.some
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Array.prototype.every和Array.prototype.some
- en: The `Array.prototype.every()` and `Array.prototype.some()` functions are both
    pure and high-order functions that are methods of the `Array` object and are used
    to test the elements of an array against a `callback()` function that must return
    a Boolean representing the respective input. The `every()` function returns `True`
    if the `callback()` function returns `True` for every element in the array, and
    the `some()` function returns `True` if some elements in the array are `True`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.every()`和`Array.prototype.some()`函数都是纯函数和高阶函数，是`Array`对象的方法，用于对数组的元素进行测试，以便返回一个表示相应输入的布尔值的`callback()`函数。如果`callback()`函数对数组中的每个元素都返回`True`，则`every()`函数返回`True`，而`some()`函数返回`True`，如果数组中的一些元素为`True`。'
- en: 'Example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE40]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Summary
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In order to develop an understanding of functional programming, this chapter
    covered a fairly broad range of topics. First we analyzed what it means for a
    programming language to be functional, then we evaluated JavaScript for its functional
    programming capabilities. Next, we applied the core concepts of functional programming
    using JavaScript and showcased some of JavaScript's built-in functions for functional
    programming.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解函数式编程，本章涵盖了一系列广泛的主题。首先，我们分析了编程语言为函数式编程意味着什么，然后评估了JavaScript的函数式编程能力。接下来，我们使用JavaScript应用了函数式编程的核心概念，并展示了一些JavaScript的内置函数用于函数式编程。
- en: Although JavaScript does have a few tools for functional programming, its functional
    core remains mostly hidden and much is to be desired. In the next chapter, we
    will explore several libraries for JavaScript that expose its functional underbelly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript确实有一些用于函数式编程的工具，但其函数式核心仍然大多隐藏，还有很多需要改进的地方。在下一章中，我们将探索几个用于JavaScript的库，这些库揭示了其函数式的本质。
