- en: Production, Integration, and Federated Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产、集成和联合模块
- en: In this chapter, we will cover production, integration, and federated modules. We
    will provide an overview of the correct deployment procedures, shortcuts, and
    alternatives. Even though some of this chapter will discuss subjects that have
    already been covered in more detail, it's good to go over them again so that you
    have a clearer understanding of what you've learned so far.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖生产、集成和联合模块。我们将概述正确的部署程序、快捷方式和替代方案。尽管本章的一些内容已经在更多细节上进行了讨论，但再次复习一下是很好的，这样您就可以更清楚地了解到目前为止学到的内容。
- en: So far, we have discussed and carried out development builds and alluded to
    going into production, but the procedure for appropriate publication-level production
    is a little different and involves cross-checking and following best practices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论并执行了开发构建，并暗示要进入生产，但适当的发布级生产过程有点不同，涉及交叉检查和遵循最佳实践。
- en: This section of the book will explore the various options we can use to deploy
    Webpack 5 with various web utilities. This will provide you with an overview of
    such web utilities and explain which are more appropriate for specific situations
    and platforms, including deploying with Babel.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的这一部分将探讨我们可以使用的各种选项，以部署Webpack 5与各种Web实用程序。这将为您提供这些Web实用程序的概述，并解释哪些对于特定情况和平台更为合适，包括使用Babel进行部署。
- en: All of these subjects are relevant to our opening section on production bundling,
    which also covers the topic of deployment for production and publication purposes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些主题都与我们在生产捆绑的开头部分相关，该部分还涵盖了生产和发布目的的部署主题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Production setup
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产设置
- en: Shimming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shimming
- en: Progressive web applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渐进式Web应用程序
- en: Integrating task runners
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成任务运行器
- en: GitHub
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub
- en: Extracting boilerplate
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取样板
- en: Module Federation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块联合
- en: Production setup
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产设置
- en: Now that we understand the basics, we can move on and learn about how to practically
    deploy production bundles. The objectives of building a project in development
    mode and production mode differ greatly. In production mode, goals shift to minifying
    builds using lightweight source mapping and optimizing assets to improve load
    time. In development mode, strong source mapping is crucial, as well as having
    a **localhost** server with live reloading or hot module replacement. Due to their
    different purposes, it is typically recommended to write separate Webpack configurations
    for each mode.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了基础知识，我们可以继续学习如何实际部署生产捆绑包。在开发模式和生产模式下构建项目的目标有很大的不同。在生产模式下，目标转向使用轻量级源映射对构建进行最小化，并优化资产以提高加载时间。在开发模式下，强大的源映射至关重要，以及具有**localhost**服务器和实时重新加载或热模块替换。由于它们的不同目的，通常建议为每种模式编写单独的Webpack配置。
- en: 'A common configuration should be maintained between modes, despite their differences.
    To merge these configurations, a utility called `webpack-merge` can be used. This
    common configuration process means code does not need to be duplicated with each
    mode. Let''s get started:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们之间存在差异，但通用配置应该在模式之间保持一致。为了合并这些配置，可以使用一个叫做`webpack-merge`的实用工具。这个通用配置过程意味着代码不需要在每个模式下重复。让我们开始吧：
- en: 'Begin by opening your command-line utility, installing `webpack-merge`, and
    saving it in development mode, as follows:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先打开命令行工具，安装`webpack-merge`，并以开发模式保存它，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s examine the **project directory**. Its contents should be structured
    similar to the following:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下**项目目录**。它的内容应该结构类似于以下内容：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that the preceding output shows that there are extra files present in this
    particular example. For instance, we are including the `webpack.common.js` file
    here.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的输出显示了在这个特定示例中存在额外的文件。例如，我们在这里包括了`webpack.common.js`文件。
- en: 'Let''s take a closer look at the `webpack.common.js` file:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们仔细看一下`webpack.common.js`文件：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `webpack.common.js` file deals with **CommonJS** requests. It does things
    similarly to ECMAScript but is formatted differently. Let's ensure that the `webpack.config.js`
    file, which works in the **ECMA** environment, does the same thing as the **CommonJS**
    configuration file. Take note of the entry points and bundle name, as well as
    the **`title`** option. This latter option is the mode's counterpart, so you must
    ensure there is parity between both files in your project.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack.common.js`文件处理**CommonJS**请求。它的做法与ECMAScript类似，但格式不同。让我们确保在**ECMA**环境中工作的`webpack.config.js`文件与**CommonJS**配置文件做同样的事情。注意入口点和捆绑名称，以及**`title`**选项。后者是模式的对应项，因此您必须确保项目中的两个文件之间存在对等性。'
- en: 'Here, we''re looking inside the `webpack.dev.js` file:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们来看一下`webpack.dev.js`文件：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the preceding code provides instructions on how `webpack.common.js`
    should be used in development mode. This is simply a case of cross-checking for
    final production to ensure the content of your work is formatted correctly and
    will map with an error during compilation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，前面的代码提供了关于如何在开发模式下使用`webpack.common.js`的说明。这只是一个交叉检查的情况，以确保您的工作内容在最终生产中格式正确，并且在编译过程中不会出现错误。
- en: 'If you''re working in production mode, the following file, `webpack.prod.js`, will
    be called into action:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在生产模式下工作，将调用以下文件`webpack.prod.js`：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using `webpack.common.js`, set up entry and output configurations and include
    any plugins that are required for both environment modes. When using `webpack.dev.js`,
    the mode should be set to development mode. Also, add the recommended **devtool**
    to that environment, as well as the simple `devServer` configuration. In `webpack.prod.js`,
    the mode is, of course, set to production, which loads `TerserPlugin`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`webpack.common.js`，设置入口和输出配置，并包括在两种环境模式下都需要的任何插件。在使用`webpack.dev.js`时，模式应设置为开发模式。还要在该环境中添加推荐的**devtool**，以及简单的`devServer`配置。在`webpack.prod.js`中，模式当然设置为生产模式，加载`TerserPlugin`。
- en: Note that `merge()` can be used in an environment-specific configuration so
    that you can easily include a common configuration in development and production
    modes. It is also worth noting that there are a variety of advanced features available
    when using the `**webpack-merge**` tool.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`merge()` 可以在特定环境配置中使用，以便您可以轻松地在开发和生产模式中包含通用配置。值得注意的是，在使用 `**webpack-merge**`
    工具时还有各种高级功能可用。
- en: 'Let''s make those development configurations inside of **`webpack.common.js`**:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 **`webpack.common.js`** 中进行这些开发配置：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding example simply shows the completed configuration for CommonJS.
    Note the list of plugin dependencies and their versions, which are loaded through
    the `devDependancies` option.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例只是展示了 CommonJS 的完成配置。请注意通过 `devDependancies` 选项加载的插件依赖项及其版本列表。
- en: Now, run those scripts and see how the output changes.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行这些脚本，看看输出如何变化。
- en: 'The following code shows how you can continue adding to the production configuration:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码显示了如何继续添加到生产配置：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that Webpack 5 will minify the project's code by default when in production
    mode.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当处于生产模式时，Webpack 5 将默认压缩项目的代码。
- en: '`TerserPlugin` is a good place to start minification and should be used as
    the default option. There are, however, a couple of choices, such as `BabelMinifyPlugin`
    and `closureWebpackPlugin`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`TerserPlugin` 是开始压缩的好地方，应该作为默认选项使用。然而，还有一些选择，比如 `BabelMinifyPlugin` 和 `closureWebpackPlugin`。'
- en: When trying a different minification plugin, ensure that the choice will also
    drop any dead code, similar to tree shaking, which we described earlier in this
    book. Something related to tree-shaking is shimming, which we'll discuss next.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试不同的压缩插件时，请确保选择也会删除任何死代码，类似于我们在本书中早些时候描述的摇树。与摇树相关的是 shimming，我们将在下面讨论。
- en: Shimming
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shimming
- en: Shimming, or more specifically, `shim-loaders`. Now is a good time to explore
    this concept in detail since you'll need a firm grasp of it before you can move
    on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Shimming，或者更具体地说，`shim-loaders`。现在是深入探讨这个概念的好时机，因为在您继续之前，您需要牢牢掌握它。
- en: The compiler that Webpack uses can understand modules written in **ECMAScript**
    **2015**, **CommonJS**, or **AMD**. It should be noted that some third-party libraries
    may need global dependencies, for example, when using jQuery. These libraries
    may, in this case, need globals to be exported. This almost broken nature of the
    module is where shimming comes into effect.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 使用的编译器可以理解用 **ECMAScript** **2015**，**CommonJS** 或 **AMD** 编写的模块。值得注意的是，一些第三方库可能需要全局依赖，例如使用
    jQuery 时。在这种情况下，这些库可能需要导出全局变量。模块的这种几乎破碎的特性是 Shimming 发挥作用的地方。
- en: Shimming can allow us to convert one language specification into another. In
    Webpack, this is usually done through dedicated loaders specific to your environment.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Shimming 可以让我们将一种语言规范转换为另一种。在 Webpack 中，这通常是通过专门针对您的环境的加载器来完成的。
- en: The principal concept behind Webpack is the use of modular development – isolated
    modules that are securely contained that don't rely on hidden or global dependencies –
    so it is important to note that the use of such dependencies should be sparse.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 的主要概念是模块化开发的使用 - 孤立的模块，安全地包含，不依赖于隐藏或全局依赖关系 - 因此重要的是要注意，使用这样的依赖关系应该是稀少的。
- en: Shimming can be useful when you wish to polyfill browsers so that you can support
    multiple users. In this case, the polyfill only needs to be patched where needed
    and loaded on demand.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望对浏览器进行 polyfill 以支持多个用户时，Shimming 可以派上用场。在这种情况下，polyfill 只需要在需要的地方进行修补并按需加载。
- en: Shimming is related to patching but tends to take place in the browser, which
    makes it highly relevant to progressive web applications.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Shimming 与修补有关，但往往发生在浏览器中，这使得它与渐进式网络应用程序高度相关。
- en: In the next section, we will look at progressive web applications in more detail
    – they are key to Webpack 5.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地了解渐进式网络应用程序 - 它们对于 Webpack 5 非常重要。
- en: Progressive web applications
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渐进式网络应用
- en: Sometimes called PWAs, progressive web applications deliver a native application
    experience online. They have many contributing factors, the most notable of which
    is the ability for the application to function when offline, as well as online.
    To do this, service workers are utilized.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时被称为 PWA，渐进式网络应用程序在线提供原生应用程序体验。它们有许多 contributing 因素，其中最显著的是应用程序在脱机和在线时都能正常运行的能力。为此，使用了服务工作者。
- en: Allowing your web app to work offline will mean you can provide functionality
    such as push notifications. These rich experiences will also be available to the
    web-based application through devices such as the service worker. This script
    will work in the background of a browser, regardless of whether the user is on
    the right page or not, and permit these same notifications or even background
    synchronization.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使您的网络应用程序能够脱机工作将意味着您可以提供诸如推送通知之类的功能。这些丰富的体验也将通过诸如服务工作者之类的设备提供给基于网络的应用程序。此脚本将在浏览器的后台运行，无论用户是否在正确的页面上，都会允许这些相同的通知甚至后台同步。
- en: PWAs offer the reach of the web but are fast and reliable, similar to desktop
    applications. They can also feel engaging, like mobile apps, and can offer the
    same immersive experience. This demonstrates a new level of quality for applications.
    They can also play a part in cross-platform compatibility.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: PWA 提供了网络的覆盖范围，但速度快、可靠，类似于桌面应用程序。它们也可以像移动应用一样引人入胜，并且可以提供相同的沉浸式体验。这展示了应用程序的新质量水平。它们也可以在跨平台兼容性中发挥作用。
- en: Responsive design was the web's first push in this direction, but the push to
    make the internet more universal has led us to PWA. To leverage your application's
    potential, you should use a progressive approach. For more information, see this
    Google resource on the subject: [https://developers.google.com/web/progressive-web-apps/](https://developers.google.com/web/progressive-web-apps/).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式设计是网络朝这个方向的第一次推动，但使互联网更普遍的推动使我们走向了PWA。为了发挥应用程序的潜力，您应该采用渐进式的方法。有关更多信息，请参阅Google关于此主题的资源：[https://developers.google.com/web/progressive-web-apps/](https://developers.google.com/web/progressive-web-apps/)。
- en: When using Webpack, the service workers need to be registered so that you can
    start integrating desktop functionality into your web-based PWA. PWAs are not
    designed to be installed locally by the user; they work natively through web browsers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Webpack时，需要注册服务工作者，以便您可以开始将桌面功能集成到基于Web的PWA中。PWA并不是为用户本地安装而设计的；它们通过Web浏览器本地工作。
- en: 'Service workers can be registered by adding the following to your code – in
    this example, this is an `index.js` file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将以下内容添加到您的代码中，可以注册服务工作者 - 在本例中，这是一个`index.js`文件：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this complete, run `npm build` – you should see the following output in
    the command-line window:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，运行`npm build` - 您应该在命令行窗口中看到以下输出：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, the application can be served with `npm start` in the command-line interface.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序可以在命令行界面中使用`npm start`来提供服务。
- en: 'A PWA should have a manifest, a service worker, and possibly a workbox to wrap
    and protect the service worker. For more information on the manifest, see [Chapter
    3](593298f3-f214-4726-9a04-28b4f89f2a31.xhtml), *Using Configurations and Options*.
    Workbox is a plugin that can be installed in the command line using the following
    command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: PWA应该有一个清单、一个服务工作者，可能还有一个workbox来包装和保护服务工作者。有关清单的更多信息，请参见[第3章](593298f3-f214-4726-9a04-28b4f89f2a31.xhtml)，*使用配置和选项*。Workbox是一个可以使用以下命令在命令行中安装的插件：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'An example configuration of the **Workbox** plugin can be seen here in a hypothetical
    `webpack.config.js` file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在假设的`webpack.config.js`文件中，可以在此处看到**Workbox**插件的示例配置：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The options inside the `{` braces will encourage the service workers to get
    to that point quickly and will not allow them to strangle previous service workers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号`{`内的选项将鼓励服务工作者迅速到达该点，并且不允许它们扼杀先前的服务工作者。
- en: As your project becomes more complicated, you may consider using related task
    runners. Let's take a look at this in more detail.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目变得更加复杂，您可能会考虑使用相关的任务运行器。让我们更详细地看一下这一点。
- en: Integrating task runners
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成任务运行器
- en: Task runners handle automation tasks such as code linting. Webpack is not designed
    for this purpose – no bundler is. However, using Webpack, we can benefit from
    the high level of focus that task runners offer while still having high-performance
    bundling.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 任务运行器处理自动化任务，如代码检查。Webpack并不是为此目的而设计的 - 没有捆绑器是。然而，使用Webpack，我们可以从任务运行器提供的高度关注度中受益，同时仍然具有高性能的捆绑。
- en: While there is some overlap between task runners and bundlers, they can integrate
    well if approached correctly. In this section, we will explore integration techniques
    we can use for some of the most popular task runners out there.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任务运行器和捆绑器之间存在一些重叠，但如果正确处理，它们可以很好地集成。在本节中，我们将探讨一些最流行的任务运行器的集成技术。
- en: Bundlers work by preparing JavaScript and other frontend code for deployment,
    transforming their format so that they're suitable for browser delivery. For example,
    it allows us to split JavaScript into chunks for lazy loading, which improves
    performance.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑器通过准备JavaScript和其他前端代码以进行部署，转换其格式，使其适合于浏览器交付。例如，它允许我们将JavaScript拆分成块以进行延迟加载，从而提高性能。
- en: Bundling may be challenging, but its results will remove a lot of the painstaking
    work of the process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑可能是具有挑战性的，但其结果将消除许多繁琐的工作过程。
- en: 'In this section, we will show you how to integrate the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何集成以下内容：
- en: Gulp
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gulp
- en: Mocha
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mocha
- en: Karma
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Karma
- en: 'Gulp is probably the most well-known task runner, so let''s start with that
    first. It is utilized through the use of a dedicated file, much like the other
    two task runners. Here, the `gulpfile.js` file will handle how Webpack interplays
    with Gulp. Let''s take a look at how to integrate all of these task runners:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp可能是最知名的任务运行器，因此让我们首先从那里开始。它通过使用专用文件来利用，就像其他两个任务运行器一样。在这里，`gulpfile.js`文件将处理Webpack与Gulp的相互作用。让我们看看如何集成所有这些任务运行器：
- en: 'First, let''s take a look at the `gulpfile.js` file:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们看一下`gulpfile.js`文件：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is all we have to do to use Gulp. Note the use of the `gulp.task` function,
    the `return` entry point, and the `.pipe(**gulp**.dest('dist/'));` output location.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们使用Gulp所需要做的。请注意`gulp.task`函数的使用，`return`入口点以及`.pipe(**gulp**.dest('dist/'));`输出位置。
- en: 'The following is the command-line code you can use to install Mocha:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是您可以使用的命令行代码来安装Mocha：
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: For more information, please visit the Webpack community repository.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请访问Webpack社区存储库。
- en: 'The following are the configuration file amendments you''ll need to make to
    the `karma.config.js` file to use Karma with Webpack:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是您需要对`karma.config.js`文件进行的配置文件修改，以便与Webpack一起使用Karma：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `webpack` and `webpackMiddleware` options have been left blank so that you
    can fill this content with your project's specific configuration. These options
    can be completely removed if you are not using them. For the sake of this example,
    we won't be.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`webpack`和`webpackMiddleware`选项已留空，以便您可以使用项目的特定配置填充此内容。如果您不使用它们，这些选项可以完全删除。出于本例的目的，我们不会这样做。'
- en: These installation procedures will be some use to you if you wish to use them
    in your development environment, but GitHub is an increasingly more essential
    tool. We'll take a look at how it can play a key role in terms of development
    in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在开发环境中使用它们，这些安装过程将对您有所帮助，但GitHub是一个越来越重要的工具。我们将在下一节中看一下它如何在开发中发挥关键作用。
- en: GitHub
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitHub
- en: GitHub, as you may already know, is a command-line code hosting platform that
    works well with Webpack. Much of the code and projects you will work with when
    using Webpack will be hosted through GitHub.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经知道的那样，GitHub是一个与Webpack配合良好的命令行代码托管平台。在使用Webpack时，您将与GitHub托管的大部分代码和项目一起工作。
- en: GitHub is based on the Git version control system. The use of GitHub with Webpack
    5 allows some command-line operations to be used online.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub基于Git版本控制系统。使用GitHub与Webpack 5允许在线使用一些命令行操作。
- en: A Git command-line instruction is typically made with the use of the `git` command
    before each new entry and before each command. Much of Webpack's content files
    are available through GitHub, and the GitHub Webpack page can be found here: [https://github.com/webpack/webpack](https://github.com/webpack/webpack).
    The development of Webpack 5 can be viewed here in terms of stages of progress,
    which can be interesting and allows you to anticipate its arrival better, should
    you need to upgrade your projects. The URL for this is [https://github.com/webpack/webpack/projects/5.](https://github.com/webpack/webpack/projects/5)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Git命令行指令通常在每个新条目和每个命令之前使用`git`命令。Webpack的大部分内容文件都可以通过GitHub获得，GitHub的Webpack页面可以在这里找到：[https://github.com/webpack/webpack](https://github.com/webpack/webpack)。Webpack
    5的开发可以在这里查看其进展阶段，这可能会很有趣，并且可以让您更好地预期其到来，如果您需要升级您的项目。其URL为[https://github.com/webpack/webpack/projects/5.](https://github.com/webpack/webpack/projects/5)
- en: As a developer, you may have used GitHub often, but if you're a dedicated JavaScript
    developer, you may have limited experience. When working on Webpack projects,
    the GitHub platform offers a great deal of live and collaborative opportunities.
    Since version control and command-line functionality is provided, there is less
    of a need to perform software development locally. This is the primary reason
    why GitHub is so popular among the developer community and why it is becoming
    so fundamental as proof of a developer's work.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您可能经常使用GitHub，但如果您是一名专注于JavaScript开发的开发人员，您可能经验有限。在处理Webpack项目时，GitHub平台提供了大量的实时和协作机会。由于提供了版本控制和命令行功能，因此在本地执行软件开发的需求较少。这是GitHub在开发人员社区中如此受欢迎并成为开发人员工作证明的主要原因。
- en: GitHub allows developers to work together on projects. When working with bundled
    projects, this is even more useful as some command-line operations can be run
    online. GitHub also allows Agile workflows or project management interfaces. Agile
    methodologies allow teams to collaborate while individuals self-organize through
    a dedicated digital platform.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub允许开发人员共同在项目上工作。在处理捆绑项目时，这更加有用，因为一些命令行操作可以在线运行。GitHub还允许敏捷工作流程或项目管理界面。敏捷方法允许团队通过专用数字平台进行协作，个人自组织。
- en: When using GitHub, you may be working with other people's code. This may include
    frameworks of code that have been developed by teams. This can become very difficult,
    even for the most seasoned developers, if they're unfamiliar with the logic being
    used. This brings us to the subject of boilerplate, which is usually standard
    or well-documented code, but nonetheless, you may want to extract this from the
    sections of a project you wish to utilize. This is where this extraction process
    starts to become very useful.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用GitHub时，您可能会使用其他人的代码。这可能包括由团队开发的代码框架。即使是经验丰富的开发人员，如果他们对使用的逻辑不熟悉，这也可能变得非常困难。这就引出了样板的主题，通常是标准或有良好文档记录的代码，但尽管如此，您可能希望从项目中提取出这部分。这就是提取过程开始变得非常有用的地方。
- en: Extracting boilerplate
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取样板
- en: Boilerplate code is sections of code that need to be included in various places,
    but with little or no alterations made to them. When using languages that are
    considered verbose, it is often necessary to write exhaustive amounts of code.
    This large section of code is called boilerplate. It has essentially the same
    purpose as a framework or library, and the terms are often conflated or mutually
    acceptable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 样板代码是需要包含在各个地方的代码部分，但几乎没有或没有进行修改。在使用被认为冗长的语言时，通常需要编写大量的代码。这一大段代码称为样板。它本质上与框架或库具有相同的目的，这些术语经常混淆或相互接受。
- en: The Webpack community offers boilerplate installations, such as the combined
    installation of multiple common dependencies such as prerequisites and loaders.
    There are multiple versions of these boilerplates, and the use of these can expedite
    a build. Please search the Webpack Community pages ([https://webpack.js.org/contribute/](https://webpack.js.org/contribute/))
    or Webpack's GitHub page ([https://github.com/webpack-contrib](https://github.com/webpack-contrib))
    for examples.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack社区提供了样板安装，例如安装多个常见依赖项的组合安装，如先决条件和加载程序。这些样板有多个版本，使用它们可以加快构建速度。请搜索Webpack社区页面（[https://webpack.js.org/contribute/](https://webpack.js.org/contribute/)）或Webpack的GitHub页面（[https://github.com/webpack-contrib](https://github.com/webpack-contrib)）以获取示例。
- en: This being said, there will be times when only part of the boilerplate is required.
    For this, extracting the boilerplate functionality of Webpack may be required.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，有时只需要部分样板。为此，可能需要提取Webpack的样板功能。
- en: Webpack, while using its minification method, allows boilerplate to be extracted;
    that is, only the elements of the boilerplate you need are included in the bundle.
    This is an automated process that's done during the compilation process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用其最小化方法时，Webpack允许提取样板；也就是说，只有您需要的样板元素包含在捆绑包中。这是在编译过程中自动完成的过程。
- en: Minification is the key way in which Webpack 5 offers this extraction process
    and it's one of the more salient ways in which a bundler of this type can be used.
    There is another key process that is highly useful and native to Webpack 5\. It
    takes us in a different direction regarding how bundles are built but is something
    that will no doubt follow on from a complex or custom build, such as a project
    that began by boilerplate being extracted. This process is known as Module Federation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 缩小是Webpack 5提供这种提取过程的关键方式，也是这种类型的捆绑器可以使用的更显著的方式之一。还有另一个关键过程，对于Webpack 5来说是非常有用的，也是本地的。它带我们走向了捆绑包的不同方向，但是这是一个毫无疑问会从一个复杂或自定义的构建中跟随的过程，比如一个从模板开始提取的项目。这个过程被称为模块联邦。
- en: Module Federation
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块联邦
- en: Module Federation has been described as a game-changer in the JavaScript architecture.
    It essentially allows applications to run code from remotely stored modules between
    servers while part of a bundled application.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 模块联邦已被描述为JavaScript架构的一个改变者。它基本上允许应用程序在服务器之间运行远程存储的模块代码，同时作为捆绑应用程序的一部分。
- en: Some developers may be aware of a technology called **GraphQL**. It is essentially
    a solution for sharing code between applications, developed by a company called
    Apollo. Federated Modules are a feature of Webpack 5 that allows this to happen
    between bundled applications.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员可能已经了解一种称为**GraphQL**的技术。它基本上是一个由Apollo公司开发的用于在应用程序之间共享代码的解决方案。联邦模块是Webpack
    5的一个功能，允许捆绑应用程序之间发生这种情况。
- en: For a long time, the best compromise was the use of externals of the `DllPlugin`,
    which relied on a centralized external dependency file, However, this isn't great
    for organic development, convenience, or large-scale projects.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，最好的折衷方案是使用`DllPlugin`的外部依赖，它依赖于集中的外部依赖文件，但是这对于有机开发、便利性或大型项目来说并不理想。
- en: With Module Federation, JavaScript applications can dynamically load code between
    applications and share dependencies. If an application is using a federated module
    as part of its build but requires a dependency to serve the federated code, Webpack
    can also download that dependency from the origin of the federated build. So,
    the federation will effectively provide a map of where Webpack 5 can find the
    required dependency code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模块联邦，JavaScript应用程序可以在应用程序之间动态加载代码并共享依赖关系。如果一个应用程序在其构建中使用了联邦模块，但需要一个依赖项来提供联邦代码，Webpack也可以从联邦构建的原始位置下载该依赖项。因此，联邦将有效地提供Webpack
    5可以找到所需依赖代码的地图。
- en: 'There is some terminology to consider when it comes to federation: remote and
    host. The term remote refers to the application or modules that are loaded into
    the user''s application, while the host refers to the application that the user
    is visiting through their browser at runtime.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑联邦时，有一些术语需要考虑：远程和主机。远程一词指的是加载到用户应用程序中的应用程序或模块，而主机指的是用户在运行时通过浏览器访问的应用程序。
- en: The federation method is designed for standalone builds and can be deployed
    independently or in your own repository. In this sense, they can be hosted bi-directionally,
    effectively serving as the host of remote content. This means that a single project
    could potentially switch between hosting orientations throughout the user's journey.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 联邦方法是为独立构建设计的，可以独立部署或在您自己的存储库中部署。在这种意义上，它们可以双向托管，有效地作为远程内容的主机。这意味着单个项目可能在用户的旅程中在托管方向之间切换。
- en: Building our first federated application
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个联邦应用
- en: Let's start by looking at three standalone applications, identified as the first,
    second, and third applications, respectively.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下三个独立的应用程序，分别标识为第一个、第二个和第三个应用程序。
- en: The first application in our system
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们系统中的第一个应用程序
- en: 'Let''s begin by configuring the first application:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从配置第一个应用程序开始：
- en: We are going to be using the `<app>` container in the HTML. This first app is
    a remote application in the federation system and is, therefore, to be consumed
    by other applications.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在HTML中使用`<app>`容器。这个第一个应用程序是联邦系统中的远程应用程序，因此将被其他应用程序消耗。
- en: 'To expose the application, we will use the `AppContainer` method:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了暴露应用程序，我们将使用`AppContainer`方法：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This first application will also consume a component from two other federated
    applications in the system.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个应用程序还将消耗系统中其他两个联邦应用程序的组件。
- en: To allow this application to consume components, the remote scope will need
    to be specified.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了允许这个应用程序消耗组件，需要指定远程范围。
- en: All these steps should be followed as specified in the preceding code block.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些步骤都应按照前面的代码块中指定的方式进行。
- en: 'Now, let''s take a look at the HTML segment of the build:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下构建的HTML部分：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code shows the `<head>` element of the HTML. `app_one_remote.js`
    connects the runtime and provisional orchestration layer at runtime. It is specifically
    designed for entry points. These are example URLs and you can use your own locations.
    It's important to note that this example is a very low-memory example and that
    your build may be much larger, but it is good enough to understand this principle.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了HTML的`<head>`元素。`app_one_remote.js`在运行时连接运行时和临时编排层。它专门设计用于入口点。这些是示例URL，您可以使用自己的位置。重要的是要注意，这个例子是一个非常低内存的例子，您的构建可能会大得多，但足够好理解这个原则。
- en: 'To consume code from a remote application, the first application has a web
    page that consumes a dialog component from the second application, as follows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了消耗远程应用程序的代码，第一个应用程序有一个网页，从第二个应用程序中消耗对话框组件，如下所示：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s start by exporting the default HTML page we are using and set up the
    router, which is done as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从导出我们正在使用的默认HTML页面开始，并设置路由，操作如下：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code block shows how the code works; it will export the default
    routes from each page in the system we are developing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块显示了代码如何工作；它将从我们正在开发的系统中的每个页面导出默认路由。
- en: This system is part of three applications, the second of which we will look
    at now.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统是由三个应用程序组成的，我们现在来看第二个应用程序。
- en: The second application
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个应用程序
- en: 'The system that we''re building is comprised of three applications. This application
    will expose the dialogue that enables the first application in this sequence to
    consume it. The second application, however, will consume the first application''s `<app>` element
    identifier. Let''s take a look:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的系统由三个应用程序组成。这个应用程序将暴露对话框，使得这个序列中的第一个应用程序可以消耗它。然而，第二个应用程序将消耗第一个应用程序的`<app>`元素标识符。让我们来看一下：
- en: 'We will start by configuring the second application. This means we need to
    specify `app-one` as a remote application and simultaneously demonstrate bi-directional
    hosting:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从配置第二个应用程序开始。这意味着我们需要指定`app-one`作为远程应用程序，并同时演示双向托管：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For the sake of consumption, the following is what the root application looks
    like:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了消耗，以下是根应用程序的样子：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to set up the code so that we can export the default application.
    The following is an example of what the default page should look like, when using
    the dialogue:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置代码，以便我们可以导出默认的应用程序。以下是使用对话框时默认页面应该看起来的示例：
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, we need to export the default `MainPage`. This is done using the third
    application in our system.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要导出默认的`MainPage`。这是通过我们系统中的第三个应用程序完成的。
- en: The third application
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三个应用程序
- en: 'Let''s take a look at our third and final application:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的第三个和最后一个应用程序：
- en: 'The third application in our system will be exporting a default `MainPage`.
    This is done through the following script:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们系统中的第三个应用程序将导出一个默认的`MainPage`。这是通过以下脚本完成的：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As expected, the third application looks similar to the previous ones, except
    it doesn't consume `<app>` from the first application. This application is standalone
    and has no navigation and as such, does not specify any remote federated components.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，第三个应用程序看起来与之前的应用程序类似，只是它不从第一个应用程序中消耗`<app>`。这个应用程序是独立的，没有导航，因此不指定任何远程联邦组件。
- en: When viewing the system in a browser, you should pay close attention to the
    network tab. The code can be federated across three different servers (potentially)
    and three different bundles (naturally).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看系统时，您应该密切关注网络选项卡。代码可以在三个不同的服务器（可能）和三个不同的捆绑包（自然）之间进行联邦。
- en: This component permits a great deal of dynamism in your builds, but you may
    want to avoid federating the whole application container unless you hope to utilize
    **server-side rendering (SSR)** or progressive loading as, otherwise, loading
    times could be severely harmed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件允许您的构建具有很大的动态性，但除非您希望利用**服务器端渲染（SSR）**或渐进式加载，否则您可能希望避免联邦整个应用程序容器，否则加载时间可能会受到严重影响。
- en: Loading issues are a natural concern, but one issue that would ordinarily cause
    larger project sizes is the potential duplication of repetitious code, which is
    the result of using multiple parallel bundles. Let's take a look at how Webpack
    5 handles that issue.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 加载问题是一个自然的关注点，但通常会导致项目规模变大的一个问题是潜在的重复的重复代码，这是使用多个并行捆绑的结果。让我们来看看Webpack 5是如何处理这个问题的。
- en: Duplication issues
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复问题
- en: One key feature of Webpack is removing duplicated code. In the federation environment,
    host applications serve the remote application with dependencies. In the absence
    of a sharable dependency, the remote application can download its own automatically.
    This is a kind of built-in redundancy fail-safe mechanism.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack的一个关键特性是去除重复的代码。在联邦环境中，宿主应用程序为远程应用程序提供依赖项。在没有可共享的依赖项的情况下，远程应用程序可以自动下载自己的依赖项。这是一种内置的冗余故障安全机制。
- en: Manually adding vendor code can be tedious at scale but the federation feature
    allows us to create automation scripts. This is the developer's choice, but it
    may be an excellent opportunity for you to be able to test your knowledge.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模情况下手动添加供应商代码可能会很繁琐，但联邦功能允许我们创建自动化脚本。这是开发者的选择，但这可能是一个很好的机会，让您能够测试自己的知识。
- en: 'We have already alluded to SSR. You should be aware that server builds require
    a `commonjs` library target so that they can be used with Webpack federation.
    This can be done with S3 streaming, ESI, or by automating npm publish so that
    you can consume server variants. The following code shows an example of including `commonjs`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了SSR。您应该知道服务器构建需要一个`commonjs`库目标，以便它们可以与Webpack联邦一起使用。这可以通过S3流式传输、ESI，或者通过自动化npm发布来完成，以便您可以消耗服务器变体。以下代码显示了包括`commonjs`的一个示例：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You may wish to use the `target: "node"` method to avoid URLs in favor of file
    paths. This will allow SSR with the same code base but different configurations
    when building for Node.js. This will also mean that separate builds will become
    separate deployments.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '您可能希望使用`target: "node"`方法，以避免URL而选择文件路径。这将允许在为Node.js构建时使用相同的代码库但不同的配置进行SSR。这也意味着单独的构建将成为单独的部署。'
- en: Webpack, as a company, is open to demonstrating SSR examples that you, as part
    of a community of developers, may have made. They will gladly accept pull requests
    through their GitHub pages since they have the bandwidth to and benefit from the
    exposure while the process is so new.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一家公司，Webpack愿意展示SSR示例，您作为开发者社区的一部分可能已经制作了。他们将很乐意通过他们的GitHub页面接受拉取请求，因为他们有带宽，并且在这个过程中受益于曝光。
- en: Summary
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you looked at the process you might use to deploy a project
    online. We went over the installation and setup process, as well as tree shaking.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了部署项目在线的过程。我们讨论了安装和设置过程，以及树摇。
- en: First, we looked at the production and development modes, the nature of each
    environment, and how they utilize Webpack. Then, we looked at shimming, the best
    way to use it, how it works so that we can patch code, its relationship with task
    runners, and their integration with bundlers such as Webpack.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看了一下生产和开发模式，每种环境的性质，以及它们如何利用Webpack。然后，我们看了shimming，最佳使用方法，它的工作原理，以便我们可以修补代码，它与任务运行器的关系，以及它们与Webpack等打包工具的集成。
- en: Now, you should be able to extract boilerplate, integrate various task runners, and
    know how to use GitHub.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够提取boilerplate，集成各种任务运行器，并知道如何使用GitHub。
- en: In the next chapter, we will discuss hot module replacement, and live coding,
    and get to grips with some serious tutorials.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论热模块替换和实时编码，并掌握一些严肃的教程。
- en: Questions
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is meant by boilerplate?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 术语boilerplate是什么意思？
- en: What does tree shaking do?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 摇树是做什么的？
- en: What is meant by the term shimming?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 术语shimming是什么意思？
- en: What is the purpose of progressive web applications?
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渐进式Web应用的目的是什么？
- en: What do task runners do?
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务运行器的作用是什么？
- en: What three task runners were mentioned in this chapter?
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一章提到了哪三个任务运行器？
- en: Webpack's compiler can understand modules written in which three specifications?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Webpack的编译器可以理解哪三种规范编写的模块？
- en: Further reading
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Webpack content files and the GitHub Webpack page can be found here: [https://github.com/webpack/webpack](https://github.com/webpack/webpack).
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack内容文件和GitHub的Webpack页面可以在这里找到：[https://github.com/webpack/webpack](https://github.com/webpack/webpack)。
- en: Webpack 5 can be viewed here in terms of its stages of progress: [https://github.com/webpack/webpack/projects/5.](https://github.com/webpack/webpack/projects/5)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack 5可以从这里按照其进展阶段进行查看：[https://github.com/webpack/webpack/projects/5.](https://github.com/webpack/webpack/projects/5)
- en: Webpack community pages: [https://webpack.js.org/contribute/](https://webpack.js.org/contribute/)
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack社区页面：[https://webpack.js.org/contribute/](https://webpack.js.org/contribute/)
- en: Webpack's GitHub pages: [https://github.com/webpack-contrib](https://github.com/webpack-contrib)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Webpack的GitHub页面：[https://github.com/webpack-contrib](https://github.com/webpack-contrib)
