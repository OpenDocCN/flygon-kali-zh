- en: '*Chapter 19*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第19章*：'
- en: System Scalability
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统可伸缩性
- en: Scalability is, for sure, one of the most critical demands for the success of
    a web application. An application's capacity to scale depends on the whole system
    architecture, and building a project while having scalability in mind is the best
    way to go. You'll be very thankful later when the success of the business may
    require the application to be highly scalable due to heavy loads of traffic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 可伸缩性无疑是Web应用程序成功的最关键需求之一。应用程序的可伸缩能力取决于整个系统架构，而在构建项目时考虑可伸缩性是最佳选择。当业务的成功可能需要应用程序因大量流量而需要高度可伸缩时，您以后会非常感激。
- en: So, as the web grows, designing and building scalable applications is also becoming
    more important. In this chapter, we cover all the scalability interview questions
    you may be asked during a junior/middle-level interview for a position such as
    a web application software architect, Java architect, or software engineer. If
    you are looking for a position that doesn't involve tasks related to software
    architecture and design, then most probably scalability will not be an interview
    topic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随着网络的发展，设计和构建可伸缩的应用程序也变得更加重要。在本章中，我们将涵盖您在初级/中级面试中可能会被问到的所有可伸缩性问题，比如Web应用程序软件架构师、Java架构师或软件工程师等职位。如果您正在寻找的职位不涉及与软件架构和设计相关的任务，那么可伸缩性很可能不会成为面试话题。
- en: 'Our agenda for this chapter includes the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的议程包括以下内容：
- en: Scalability in a nutshell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简而言之，可伸缩性
- en: Questions and coding challenges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题和编码挑战
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Scalability in a nutshell
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之，可伸缩性
- en: 'The most predictable yet important question your interviewer will ask you is:
    What is scalability? Scalability is the capability and ability of a process (system,
    network, application) to cope with an increase in workload (by workload, we understand
    anything that pushes the system to the limit, such as traffic, storage capacity,
    a maximum number of transactions, and so on) when adding resources (typically
    hardware). Scalability can be expressed as the ratio between the increase in system
    performance and the rise in resources used. Moreover, scalability also means the
    ability to add extra resources without affecting/modifying the structure of the
    main nodes.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 面试官最可预测但也最重要的问题是：什么是可伸缩性？可伸缩性是指一个过程（系统、网络、应用程序）应对工作负载增加的能力和能力（通过工作负载，我们理解任何推动系统极限的东西，如流量、存储容量、最大交易数量等），当添加资源（通常是硬件）时。可伸缩性可以表示系统性能提升与资源使用增加之间的比率。此外，可伸缩性还意味着能够在不影响/修改主节点结构的情况下添加额外的资源。
- en: If adding more resources results in a slight increase in performance, or even
    worse, boosting the resources has no effect on performance, then you are facing
    so-called *poor scalability*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果增加更多资源导致性能略微提高，甚至更糟的是，增加资源对性能没有影响，那么您面临所谓的*可伸缩性差*。
- en: 'How can you achieve scalability? During an interview that involves scalability
    questions, you will most probably be asked this question as well. Giving a general,
    comprehensive, and not too time-consuming answer is the best choice. The main
    points that should be touched upon are the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何实现可伸缩性？在涉及可伸缩性问题的面试中，您很可能也会被问到这个问题。给出一个一般、全面且不会花费太多时间的答案是最佳选择。应该触及的主要点包括以下内容：
- en: '**Leverage 12factor** (https://12factor.net/): This methodology is independent
    of the programming language and can be really helpful for delivering flexible
    and scalable applications.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**利用12要素**（https://12factor.net/）：这种方法与编程语言无关，对于交付灵活和可伸缩的应用程序非常有帮助。'
- en: '**Implement persistence wisely**: From choosing the proper database for your
    application and developing the most optimized schema, to mastering techniques
    for scaling the persistence layer (for example, clustering, replicas, sharding,
    and so on), this is one of the key aspects that deserve your entire attention.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**明智地实现持久性**：从为应用程序选择合适的数据库和开发最优化的模式，到掌握扩展持久层的技术（例如，集群、副本、分片等），这是值得您全部关注的关键方面之一。'
- en: '**Don''t underestimate queries**: Database queries are a key factor in acquiring
    short transactions. Tune your connection pool and queries for scalability. For
    example, pay attention to cross-node joins, which can quickly downgrade performance.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要低估查询**：数据库查询是获取短事务的关键因素。调整连接池和查询以实现可伸缩性。例如，注意跨节点连接，这可能会迅速降低性能。'
- en: '**Choose hosting and tools**: Scaling is not only about the code! The infrastructure
    counts a lot as well. Today, many cloud players (for example, Amazon) provide
    autoscaling and dedicated tools (Docker, Kubernetes, and so on).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择托管和工具**：扩展不仅仅是代码！基础设施也非常重要。今天，许多云服务提供商（例如亚马逊）提供自动扩展和专用工具（Docker、Kubernetes等）。'
- en: '**Consider load balancing and reverse proxying**: One day, you have to switch
    from a single server to a multi-server architecture. Running under a cloud infrastructure
    (for example, Amazon) will easily provide these facilities with just several configurations
    (for most cloud providers, load balancing and reverse proxying are part of the
    *ready-to-go* offer). Otherwise, you have to be prepared for this significant
    change.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**考虑负载均衡和反向代理**：有一天，您必须从单服务器切换到多服务器架构。在云基础设施下运行（例如亚马逊），只需进行几项配置即可轻松提供这些设施（对于大多数云服务提供商，负载均衡和反向代理是*即插即用*的一部分）。否则，您必须为这一重大变化做好准备。'
- en: '**Caching**: While scaling your application, consider new caching strategies,
    topologies, and tools.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**：在扩展应用程序时，考虑新的缓存策略、拓扑和工具。'
- en: '**Relieve the backend**: Move as many computations as possible from the backend
    to the frontend. This way, you take some work from your backend shoulders.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减轻后端负担**：尽可能将尽可能多的计算从后端移到前端。这样，您可以减轻后端的工作负担。'
- en: '**Test and monitor**: Testing and monitoring your code will help you to discover
    issues as soon as possible.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试和监控**：测试和监控代码将帮助您尽快发现问题。'
- en: There are many other aspects to discuss, but at this point, the interviewer
    should be ready to advance the interview to the next step.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他方面需要讨论，但在这一点上，面试官应该准备将面试推进到下一步。
- en: Questions and coding challenges
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题和编码挑战
- en: In this section, we cover 13 questions and coding challenges that represent
    *must-knows* in junior/middle-level scalability interviews. Let's begin!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们涵盖了13个问题和编码挑战，这些问题和挑战在初中级可扩展性面试中是必须了解的。让我们开始吧！
- en: Coding challenge 1 – Scaling types
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战1 - 扩展类型
- en: '**Problem**: What do scaling up and scaling out mean?'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：扩展和扩展意味着什么？'
- en: '**Solution**: Scaling up (or vertical scaling) is achieved by adding more resources
    to an existing system to achieve better performance and successfully face a greater
    workload. By resources, we can understand more storage, more memory, more network,
    more threads, more connections, more powerful hosts, more caching, and so on.
    Once the new resources are added, the application should be capable of respecting
    the SLAs. Today, scaling up in the cloud is very efficient and fast. Clouds such
    as AWS, Azure, Oracle, Heroku, Google Cloud, and so on can automatically allocate
    more resources based on the threshold plan in just a couple of minutes. When the
    traffic decreases, AWS can disable these extra resources. This way, you pay only
    for what you use.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：扩展（或纵向扩展）是通过向现有系统添加更多资源来实现更好的性能并成功应对更大的工作负载。通过资源，我们可以理解更多的存储、更多的内存、更多的网络、更多的线程、更多的连接、更强大的主机、更多的缓存等。添加新资源后，应用程序应能够遵守服务级别协议。今天，在云中扩展是非常高效和快速的。像AWS、Azure、Oracle、Heroku、Google
    Cloud等云可以根据阈值计划自动分配更多的资源，仅需几分钟。当流量减少时，AWS可以禁用这些额外的资源。这样，您只需支付您使用的部分。'
- en: 'Scaling out (or horizontal scaling) is typically related to distributed architectures.
    There are two basic forms of scaling out:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展（或横向扩展）通常与分布式架构相关。有两种基本形式的扩展：
- en: Add more infrastructure capacity in pre-packaged blocks of infrastructure/nodes
    (for example, hyper-converged).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在预打包的基础设施/节点块中增加更多的基础设施容量（例如，超融合）。
- en: Use an independent distributed service that can harvest information about customers.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用独立的分布式服务来收集有关客户的信息。
- en: Typically, scaling out is done by adding more servers or CPUs that are the same
    type as those that are currently used or any compatible kind. Scaling out makes
    it easy for service providers to offer customers a *pay-as-you-grow* infrastructure
    and services. Scaling out happens quite fast since nothing has to be imported
    or rebuilt. Nevertheless, scale-out speed is limited by the speed with which the
    servers can communicate.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，扩展是通过添加更多与当前使用的相同类型或任何兼容类型的服务器或CPU来完成的。扩展使服务提供商能够为客户提供“按需增长”的基础设施和服务。扩展速度相当快，因为不需要导入或重建任何东西。然而，扩展速度受服务器通信速度的限制。
- en: Clouds such as AWS can automatically allocate more infrastructure based on the
    threshold plan in just a couple of minutes. When the traffic is low, AWS can disable
    these extra infrastructures. This way, you pay only for what you use.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 像AWS这样的云可以根据阈值计划自动分配更多的基础设施，仅需几分钟。当流量较低时，AWS可以禁用这些额外的基础设施。这样，您只需支付您使用的部分。
- en: Typically, scaling up offers better performance than scaling out.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，扩展提供比扩展更好的性能。
- en: Coding challenge 2 – High availability
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战2 - 高可用性
- en: '**Problem**: What is high availability?'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是高可用性？'
- en: '**Solution**: High availability and low latency are mission-critical for tons
    of businesses.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：高可用性和低延迟对于许多企业来说至关重要。'
- en: Typically expressed as a percentage of uptime in a given year, high availability
    is achieved when an application is available to its users without interruption
    (99.9% of the time during a year).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常以一年中的正常运行时间的百分比来表示，当应用程序在没有中断的情况下对用户可用时，就实现了高可用性（在一年内99.9%的时间内）。
- en: Achieving high availability is commonly done via clustering.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过集群实现高可用性是常见的。
- en: Coding challenge 3 – Low latency
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战3 - 低延迟
- en: '**Problem**: What is low latency?'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是低延迟？'
- en: '**Solution**: Low latency is a term used in relation to computer networks that
    are optimized to handle and process an extremely high volume of data with minimal
    delay or latency. Such networks are designed and built to handle operations that
    attempt to achieve near real-time data processing capabilities.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：低延迟是与计算机网络相关的术语，它被优化为以最小的延迟或延迟处理极高数量的数据。这样的网络被设计和构建用于处理试图实现几乎实时数据处理能力的操作。'
- en: Coding challenge 4 – Clustering
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战4 - 集群
- en: '**Problem**: What is a cluster and why do we need clustering?'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是集群，为什么我们需要集群？'
- en: '**Solution**: A cluster is a group of machines that can individually run an
    application. We can have an application server cluster, a database server cluster,
    and so on.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：集群是一组可以单独运行应用程序的机器。我们可以有应用程序服务器集群、数据库服务器集群等。'
- en: Having a cluster significantly reduces the chances of our service becoming unavailable
    in the event that one of the machines from the cluster fails. In other words,
    clustering's main purpose consists of achieving 100% availability or zero downtime
    in service (high availability – see *Coding challenge 2*). Of course, there is
    still be a small chance of all the cluster machines failing at the same time,
    but that is typically mitigated by having the machines located at different locations
    or supported by their own resources.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有集群显著降低了我们的服务在集群中的一台机器失败时变得不可用的机会。换句话说，集群的主要目的是实现100%的可用性或服务的零停机时间（高可用性 - 见*编码挑战2*）。当然，所有集群机器同时失败的可能性仍然很小，但通常通过将机器放置在不同的位置或由它们自己的资源支持来减轻这种可能性。
- en: Coding challenge 5 – Latency, bandwidth, and throughput
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战5 - 延迟、带宽和吞吐量
- en: '**Problem**: What are latency, bandwidth, and throughput?'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是延迟、带宽和吞吐量？'
- en: '**Solution**: The best way to explain these notions during an interview relies
    on a simple analogy with a tube as in the following figure:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：在面试中解释这些概念的最佳方法是使用下图中的管道进行简单类比：'
- en: '![Figure 19.1 – Latency versus bandwidth versus throughput'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.1 – 延迟与带宽与吞吐量'
- en: '](img/Figure_19.1_B15403.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.1_B15403.jpg)'
- en: Figure 19.1 – Latency versus bandwidth versus throughput
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.1 – 延迟与带宽与吞吐量
- en: '**Latency** is the amount of time it takes to travel through the tube, not
    the tube length. It is, however, measured as a function of the tube length.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**延迟**是通过管道传输所需的时间，而不是管道长度。但是，它作为管道长度的函数来衡量。'
- en: '**Bandwidth** is how wide the tube is.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**带宽**是管道有多宽。'
- en: '**Throughput** is the amount of water flowing through the tube.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**吞吐量**是通过管道流动的水量。'
- en: Coding challenge 6 – Load balancing
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战6 – 负载均衡
- en: '**Problem**: What is load balancing?'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是负载均衡？'
- en: '**Solution**: Load balancing is a technique used for distributing workloads
    across multiple machines or clusters. Among the algorithms used by load balancing,
    we have Round Robin, sticky session (or session affinity), and IP address affinity.
    A common and simple algorithm is Round Robin, which divides the workload in a
    circular order, ensuring that all the available machines get an equal number of
    requests and none of them is overloaded or underloaded.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：负载均衡是一种用于在多台机器或集群之间分配工作负载的技术。在负载均衡使用的算法中，有循环轮询、粘性会话（或会话亲和性）和IP地址亲和性。常见且简单的算法是循环轮询，它按循环顺序分配工作负载，确保所有可用的机器获得相等数量的请求，没有一台机器过载或负载不足。'
- en: 'For example, the following figure marks the place of a load balancer in a typical
    master-slave architecture:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下图标记了典型主从架构中负载均衡器的位置：
- en: '![Figure 19.2 – Load balancer in a master-slave architecture'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.2 – 主从架构中的负载均衡器'
- en: '](img/Figure_19.2_B15403.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.2_B15403.jpg)'
- en: Figure 19.2 – Load balancer in a master-slave architecture
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.2 – 主从架构中的负载均衡器
- en: By dividing the work across the machines, load balancing strives to achieve
    maximum throughput and response time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在机器之间分配工作，负载均衡力求实现最大吞吐量和响应时间。
- en: Coding challenge 7 – Sticky session
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战7 – 粘性会话
- en: '**Problem**: What is sticky session (or session affinity)?'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是粘性会话（或会话亲和性）？'
- en: '**Solution**: Sticky session (or session affinity) is a notion encountered
    in a load balancer. Typically, the user information is stored in the session,
    and the session is replicated on all the machines from the cluster. But session
    replication (see *Coding challenge 11*) can be avoided by serving a particular
    user session requests from the same machine.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：粘性会话（或会话亲和性）是负载均衡器中遇到的一个概念。通常，用户信息存储在会话中，并且会话在集群中的所有机器上都有副本。但是会话复制（参见*编码挑战11*）可以通过从同一台机器为特定用户会话请求提供服务来避免。'
- en: For this, the session is associated with a machine. This happens when the sessions
    are created. All the incoming requests for this session are always redirected
    to the associated machine. The user data is only on that machine.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，会话与机器关联。这发生在会话创建时。对于此会话的所有传入请求始终重定向到关联的机器。用户数据仅在该机器上。
- en: In Java, sticky session is typically done via the `jsessionid` cookie. At the
    first request, the cookie is sent to the client. For each subsequent request,
    the client request contains the cookie as well. This way, the cookie identifies
    the session.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，粘性会话通常通过`jsessionid` cookie来实现。在第一次请求时，cookie被发送到客户端。对于每个后续请求，客户端请求也包含cookie。这样，cookie标识了会话。
- en: The main drawback of the sticky session approach consists of the fact that if
    the machine fails then the user information is lost, and that session is unrecoverable.
    If the client browser doesn't support cookies or cookies are disabled, then sticky
    session via cookies cannot be achieved.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 粘性会话方法的主要缺点在于，如果机器失败，则用户信息丢失，该会话无法恢复。如果客户端浏览器不支持cookie或禁用cookie，则无法通过cookie实现粘性会话。
- en: Coding challenge 8 – Sharding
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战8 – 分片
- en: '**Problem**: What is sharding?'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是分片？'
- en: '**Solution**: Sharding is an architectural technique for distributing a single
    logical database system across a cluster of machines. The following figure depicts
    this statement:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：分片是一种将单个逻辑数据库系统分布在一组机器上的架构技术。下图描述了这种说法：'
- en: '![Figure 19.3 – Sharding'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.3 – 分片'
- en: '](img/Figure_19.3_B15403.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.3_B15403.jpg)'
- en: Figure 19.3 – Sharding
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.3 – 分片
- en: As you can see in the preceding figure, sharding is about the horizontal partitioning
    of the database scheme. Mainly, the rows of a database table (for example, `teams`)
    are stored separately (West Data Center holds odd rows, while East Data Center
    holds even rows), instead of splitting the table into columns (splitting into
    columns is known as normalization and vertical partitioning).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图所示，分片是关于数据库方案的水平分区。主要是将数据库表（例如`teams`）的行分别存储（例如，西数据中心保存奇数行，而东数据中心保存偶数行），而不是将表分割为列（将表分割为列称为规范化和垂直分区）。
- en: Each partition is called a *shard.* As you can see from the preceding figure,
    each shard can be independently located on a physical location or on a separate
    database server.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个分区称为*分片*。从前面的图中可以看出，每个分片可以独立地位于物理位置或单独的数据库服务器上。
- en: The sharding goal is to make a database system highly scalable. The small number
    of rows in each shard reduces the index size and improves the read/search operations'
    performance.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 分片的目标是使数据库系统具有高度可伸缩性。每个分片中的行数较少，减少了索引大小，并提高了读取/搜索操作的性能。
- en: 'The drawbacks of sharding are the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 分片的缺点如下：
- en: The application must be aware of the data location.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序必须知道数据的位置。
- en: Adding/removing nodes from the system requires rebalancing the system.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向系统添加/删除节点需要重新平衡系统。
- en: The cross-node join queries come with performance penalties.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨节点连接查询会带来性能惩罚。
- en: Coding challenge 9 – Shared-nothing architecture
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战9 – 无共享架构
- en: '**Problem**: What is shared-nothing architecture?'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是无共享架构？'
- en: '**Solution**: Shared-nothing architecture (denoted as **SN**) is a distributed
    computing technique that holds that each node is independent and contains everything
    it needs to have autonomy. Moreover, there is no single point of contention required
    across the system. The main aspects of an SN architecture are the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：无共享架构（标记为**SN**）是一种分布式计算技术，它认为每个节点都是独立的，并包含其需要具有自治权的一切。此外，系统中不需要任何单一的争用点。SN架构的主要方面包括以下内容：'
- en: The nodes work independently.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点独立工作。
- en: No resources (memory, files, and so on) are shared between the nodes.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点之间没有共享资源（内存、文件等）。
- en: If a node fails, then it affects only its users (other nodes continue to work).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个节点失败，那么它只影响其用户（其他节点继续工作）。
- en: Having a linear and theoretically infinite scalability, the SN architecture
    is quite popular. Google is one of the major players that relies on SN.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 具有线性和理论上无限的可扩展性，SN架构非常受欢迎。谷歌是依赖SN的主要参与者之一。
- en: Coding challenge 10 – Failover
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战10 - 故障转移
- en: '**Problem**: What is failover?'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是故障转移？'
- en: '**Solution**: Failover is a technique used for achieving high availability
    by switching to another machine from the cluster when one of the machines fails.
    Commonly, failover is applied automatically by a load balancer via a heartbeat
    check mechanism. Mainly, the load balancer checks the machines'' availability
    by ensuring that they respond. If a heartbeat of a machine fails (the machine
    doesn''t respond), then the load balancer doesn''t send any requests to it and
    redirects the requests to another machine from the cluster.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：故障转移是一种通过在集群中的另一台机器上切换来实现高可用性的技术。通常，故障转移是通过负载均衡器自动应用的，通过心跳检查机制。主要是通过负载均衡器检查机器的可用性，确保它们响应。如果某台机器的心跳失败（机器没有响应），那么负载均衡器就不会向其发送任何请求，并将请求重定向到集群中的另一台机器。'
- en: Coding challenge 11 – Session replication
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战11 - 会话复制
- en: '**Problem**: What is session replication?'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：什么是会话复制？'
- en: '**Solution**: Session replication is commonly encountered in application server
    clusters with the main goal of achieving session failover.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：会话复制通常出现在应用服务器集群中，其主要目标是实现会话故障转移。'
- en: Session replication is applied every time a user changes their current session.
    Mainly, the user session is automatically replicated to other machines from the
    cluster. This way, if a machine fails, the load balancer sends the incoming requests
    to another machine from the cluster. Since every machine in the cluster has a
    copy of the user session, the load balancer can choose any of those machines.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 会话复制是每次用户更改其当前会话时应用的。主要是，用户会话会自动复制到集群中的其他机器。这样，如果一台机器失败，负载均衡器会将传入的请求发送到集群中的另一台机器。由于集群中的每台机器都有用户会话的副本，负载均衡器可以选择其中任何一台机器。
- en: While session replication sustains session failover, it may have extra cost
    in terms of memory and network bandwidth.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然会话复制可以维持会话故障转移，但在内存和网络带宽方面可能会有额外的成本。
- en: Coding challenge 12 – The CAP theorem
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战12 - CAP定理
- en: '**Problem**: What is the CAP theorem?'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：CAP定理是什么？'
- en: '**Solution**: The CAP theorem was published by Eric Brewer and is specific
    to distributed computing. Conforming to this theorem, a distributed computer system
    can simultaneously provide only two of the following three things:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：CAP定理由Eric Brewer发布，专门针对分布式计算。根据这个定理，分布式计算系统只能同时提供以下三个中的两个：'
- en: '**Consistency**: Concurrent updates are available to all nodes.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：并发更新对所有节点都是可用的。'
- en: '**Availability**: Every request receives a response of success or fail.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：每个请求都会收到成功或失败的响应。'
- en: '**Partition tolerance**: The system continues to operate despite a partial
    failure.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区容忍性**：系统在部分故障的情况下仍然可以运行。'
- en: 'The following figure depicts the CAP theorem:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图描述了CAP定理：
- en: '![Figure 19.4 – The CAP theorem'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.4 - CAP定理'
- en: '](img/Figure_19.4_B15403.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.4_B15403.jpg)'
- en: Figure 19.4 – The CAP theorem
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.4 - CAP定理
- en: Companies such as Google, Facebook, and Amazon use the CAP theorem to decide
    their application architecture.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌、Facebook和亚马逊等公司使用CAP定理来决定其应用架构。
- en: Coding challenge 13 – Social networks
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战13 - 社交网络
- en: '**Problem**: How would you design the data structures for a social network
    like Facebook? Describe the algorithm to show the shortest path between two people
    (for example, Tom → Alice → Mary → Kely).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：您将如何为像Facebook这样的社交网络设计数据结构？描述一种算法来显示两个人之间的最短路径（例如，Tom → Alice → Mary
    → Kely）。'
- en: '**Solution**: Commonly, social networks are designed using graphs. The result
    is a huge graph such as those in the next figure (this figure was gathered via
    Google Image via the *social network graph* keywords):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：通常，社交网络是使用图来设计的。结果是一个庞大的图，如下图所示（此图是通过Google图像通过*社交网络图*关键字收集的）：'
- en: '![Figure 19.5 – Social network graph'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.5 - 社交网络图'
- en: '](img/Figure_19.5_B15403.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_19.5_B15403.jpg)'
- en: Figure 19.5 – Social network graph
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图19.5 - 社交网络图
- en: So, finding a path between two people means finding a path in such a graph.
    In this case, the problem reduces to how to efficiently find a path between two
    nodes in such a huge graph.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，找到两个人之间的路径意味着在这样的图中找到一条路径。在这种情况下，问题就变成了如何在这样一个庞大的图中高效地找到两个节点之间的路径。
- en: We can start with one person and traverse the graph to find the other person.
    Traversing a graph can be done using **BFS** (**Breadth-first Search**) or **DFS**
    (**Depth-first Search**). For more details about these algorithms, check out [*Chapter
    13*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295), *Trees and Graphs*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一个人开始，遍历图来找到另一个人。遍历图可以使用**BFS**（**广度优先搜索**）或**DFS**（**深度优先搜索**）来完成。有关这些算法的更多细节，请查看[*第13章*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)，*树和图*。
- en: DFS will be very inefficient! Two persons might be only one degree of separation
    apart, but DFS may traverse millions of nodes (persons) before finding this relatively
    immediate connection.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: DFS将非常低效！两个人可能只相隔一度，但DFS可能在找到这种相对即时的连接之前遍历数百万个节点（人）。
- en: Hence, the winner is BFS. More precisely, we can employ bidirectional BFS. Like
    two trains that come from opposite directions and intersect at some moment in
    time, we use one BFS that starts from person *A* (the source) and one BFS that
    starts from person *B* (the destination). When the searches collide, we have found
    a path between *A* and *B*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，胜利者是BFS。更确切地说，我们可以采用双向BFS。就像两列火车从相反的方向开来，在某个时刻相交一样，我们使用一个从人*A*（源）开始的BFS，和一个从人*B*（目的地）开始的BFS。当搜索相撞时，我们找到了*A*和*B*之间的路径。
- en: 'Why not unidirectional BFS? Because going from *A* to *B* will traverse *p+p*p*
    people. Mainly, unidirectional BFS will traverse *A*''s *p* friends, and then
    each of their *p* friends. This means that for a path of length *q*, the unidirectional
    BFS will perform in O(pq) runtime. On the other hand, the bidirectional BFS traverses
    2*p* nodes: each of *A*''s *p* friends and each of *B*''s *p* friends. This means
    that for a path of length *q*, the bidirectional BFS performs in O(pq/2+ pq/2)
    = O(pq/2). Obviously, O(pq/2) is better than O(pq).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不使用单向BFS？因为从*A*到*B*会遍历*p+p*p*人。主要是，单向BFS将遍历*A*的*p*个朋友，然后是每个朋友的*p*个朋友。这意味着对于长度为*q*的路径，单向BFS将在O(pq)的运行时间内执行。另一方面，双向BFS遍历2*p*个节点：每个*A*的*p*个朋友和每个*B*的*p*个朋友。这意味着对于长度为*q*的路径，双向BFS执行O(pq/2+
    pq/2) = O(pq/2)。显然，O(pq/2)比O(pq)更好。
- en: Let's consider a path such as Ana -> Bob -> Carla -> Dan -> Elvira, where each
    person has 100 friends. A unidirectional BFS will traverse 100 million (1004)
    nodes. A bidirectional BFS will traverse only 20,000 nodes (2 x 1002).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个路径，比如Ana -> Bob -> Carla -> Dan -> Elvira，每个人都有100个朋友。单向BFS将遍历1亿（1004）个节点。双向BFS只会遍历2万个节点（2
    x 1002）。
- en: Finding an efficient way to connect *A* and *B* is just one of the problems.
    Another problem is caused by the high number of persons, when the amount of data
    is so huge it cannot be stored on a single machine. This means that our graph
    will use multiple machines (for example, a cluster). If we represent the list
    of users as a list of IDs, then we can use sharding and store ranges of IDs on
    each machine. This way, we go to the next person in the path by going first onto
    the machine that contains the person's ID.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 找到连接*A*和*B*的有效方法只是其中一个问题。另一个问题是由于人数众多，当数据量如此之大以至于无法存储在一台机器上时。这意味着我们的图将使用多台机器（例如，一个集群）。如果我们将用户列表表示为ID列表，那么我们可以使用分片并在每台机器上存储ID范围。这样，我们通过首先进入包含该人ID的机器来沿着路径前进到下一个人。
- en: In order to mitigate a lot of random jumps between machines, which will downgrade
    performance, we can distribute the users across machines by taking into account
    country, city, state, and so on. It is more likely that users from the same country
    will be friends.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少在机器之间的大量随机跳跃，这将降低性能，我们可以通过考虑国家、城市、州等来分布用户到机器上。同一个国家的用户更有可能成为朋友。
- en: Further questions that need an answer refer to caching usage, when to stop a
    search with no results, what to do if a machine fails, and so on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 需要回答的更多问题包括缓存使用、何时停止没有结果的搜索、如果机器出现故障该怎么办等等。
- en: It is clear that tackling problems such as the preceding one is not an easy
    task. It requires addressing a lot of questions and issues, therefore reading
    and practicing as much as possible is a must.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，解决前述问题等问题并不是一件容易的事。这需要解决很多问题和问题，因此阅读和尽可能多地实践是必须的。
- en: Practicing is the key to success
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践是成功的关键
- en: The topic of this short chapter deserves an entire book. But, challenging yourself
    to solve the following top 10 problems will boost your insights about scalability
    and your chances of becoming a software engineer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短章节的主题值得一本整书。但是，挑战自己解决以下前10个问题将增强您对可扩展性的见解，并增加成为软件工程师的机会。
- en: Designing bitly, TinyURL, and goo.gl (a service for shorting URLs)
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计bitly、TinyURL和goo.gl（用于缩短URL的服务）
- en: 'Questions to address:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的问题：
- en: How do you assign a unique identifier (ID) for each given URL?
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为每个给定的URL分配一个唯一的标识符（ID）？
- en: Having thousands of URLs per second, how do you generate unique identifiers
    (IDs) at scale?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每秒有数千个URL，如何在规模上生成唯一的标识符（ID）？
- en: How do you handle redirects?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理重定向？
- en: How do you deal with custom short URLs?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理自定义短URL？
- en: How do you deal with the expired URLs (delete them)?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理过期的URL（删除它们）？
- en: How do you track statistics (for example, click stats)?
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何跟踪统计数据（例如，点击统计）？
- en: Designing Netflix, Twitch, and YouTube (a global video streaming service)
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计Netflix、Twitch和YouTube（全球视频流服务）
- en: 'Questions to address:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的问题：
- en: How do you store and distribute data in a way that accommodates a large number
    of simultaneous users (the users can watch and share data)?
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何存储和分发数据以适应大量同时用户（用户可以观看和分享数据）？
- en: How do you track statistics (for example, the total number of views, voting,
    and so on)?
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何跟踪统计数据（例如，总浏览次数、投票等）？
- en: How do you allow users to add comments on videos (preferably, in real time)?
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何允许用户在视频上添加评论（最好是实时的）？
- en: Designing WhatsApp and Facebook Messenger (a global chat service)
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计WhatsApp和Facebook Messenger（全球聊天服务）
- en: 'Questions to address:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的问题：
- en: How do you design one-on-one conversations/meetings between users?
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计用户之间的一对一对话/会议？
- en: How do you design group chats/meetings?
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计群聊/会议？
- en: How do you deal with offline users (not connected to the internet)?
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理离线用户（未连接到互联网）？
- en: When should you send push notifications?
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时发送推送通知？
- en: How do you support end-to-end encryption?
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何支持端到端加密？
- en: Designing Reddit, HackerNews, Quora, and Voat (a message board service and social
    network)
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计Reddit、HackerNews、Quora和Voat（留言板服务和社交网络）
- en: 'Questions to address:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的问题：
- en: How do you track the stats of each answer (the total number of views, voting,
    and so on)?
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何跟踪每个答案的统计数据（总浏览次数、投票等）？
- en: How do you allow users to follow other users or topics?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何允许用户关注其他用户或主题？
- en: How do you design the timeline consisting of a user's top questions (similar
    to newsfeed generation)?
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计包含用户热门问题的时间线（类似于新闻源生成）？
- en: Designing Google Drive, Google Photos, and Dropbox (a global file storage and
    sharing service)
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计谷歌云盘、谷歌相册和Dropbox（全球文件存储和共享服务）
- en: 'Questions to address:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的问题：
- en: How do you design user features such as upload, search, view, and share files/photos?
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计用户功能，如上传、搜索、查看和共享文件/照片？
- en: How do you track permissions for file sharing?
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何跟踪文件共享的权限？
- en: How do you allow a group of users to edit the same document?
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何允许一组用户编辑同一文档？
- en: Designing Twitter, Facebook, and Instagram (an extremely large social media
    service)
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计Twitter、Facebook和Instagram（一个非常大的社交媒体服务）
- en: 'Questions to address:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的问题：
- en: How do you efficiently store and search for posts/tweets?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何高效存储和搜索帖子/推文？
- en: How do you implement newsfeed generation?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现新闻源生成？
- en: How do you tackle the social graph (see *Coding challenge 13*)?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何解决社交图（参见*编码挑战13*）？
- en: Designing Lyft, Uber, and RideAustin (a ride-sharing service)
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计Lyft、Uber和RideAustin（共乘服务）
- en: 'Questions to address:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的问题：
- en: How do you match a ride request with nearby drivers?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将乘车请求与附近的司机匹配？
- en: How do you store millions of locations (geographical coordinates) for riders
    and drivers that are continuously moving?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为不断移动的乘客和司机存储数百万个位置（地理坐标）？
- en: How do you update the driver/rider locations (updates every second)?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何更新驾驶员/乘客位置（每秒更新一次）？
- en: Designing a type-ahead and web crawler (a search engine related service)
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计类型提前和网络爬虫（与搜索引擎相关的服务）
- en: 'Questions to address:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的问题：
- en: How do you refresh data?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何刷新数据？
- en: How do you store the previous search queries?
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何存储先前的搜索查询？
- en: How do you detect the best matches for the already typed string?
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何检测已输入字符串的最佳匹配？
- en: How do you tackle a case when the user is typing too fast?
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户输入速度过快时，如何解决？
- en: How do you find new pages (web pages)?
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何找到新页面（网页）？
- en: How do you assign priorities to web pages that are changing dynamically?
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为动态变化的网页分配优先级？
- en: How do you guarantee that the crawler is not stuck on the same domain forever?
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保爬虫不会永远卡在同一个域上？
- en: Designing an API rate limiter (for example, GitHub or Firebase)
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计API速率限制器（例如GitHub或Firebase）
- en: 'Questions to address:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的问题：
- en: How do you limit the number of requests within a time window (for example, 30
    requests per second)?
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何限制在时间窗口内的请求数量（例如，每秒30个请求）？
- en: How do you implement rate-limiting to work in a cluster of servers?
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现在服务器集群中工作的速率限制？
- en: How do you tackle throttling (soft and hard)?
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何解决限流（软限流和硬限流）？
- en: Designing nearby places/friends and Yelp (a proximity server)
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计附近的地方/朋友和Yelp（一个临近服务器）
- en: 'Questions to address:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 需要解决的问题：
- en: How do you search for nearby friends or places?
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何搜索附近的朋友或地点？
- en: How do you rank places?
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何对地点进行排名？
- en: How do you store location data according to the population density?
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何根据人口密度存储位置数据？
- en: Answering these challenges is not an easy task and requires significant experience.
    However, if you are a junior/middle-level programmer and you have read this introductory
    chapter about scalability, then you should be able to decide whether your career
    path should go in this direction or not. However, keep in mind that designing
    large-scale distributed systems is a very demanding area in software engineering
    interviews.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 回答这些挑战并不是一件容易的事，需要丰富的经验。然而，如果你是一名初级/中级程序员，并且已经阅读了关于可扩展性的介绍性章节，那么你应该能够决定你的职业道路是否应该朝这个方向发展。然而，请记住，设计大规模分布式系统是软件工程面试中一个非常苛刻的领域。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This is the last chapter of this book. We've just covered a bunch of problems
    that fit into the scalability topic.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章。我们刚刚涵盖了一系列与可扩展性主题相关的问题。
- en: Congratulations on coming this far! Now, at the end of this book, remember to
    practice as much as possible, have confidence in your judgment, and never give
    up! I really hope that your next Java position will bring you the job of your
    dreams and that this book makes a contribution to your success.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你走到了这一步！现在，在本书的最后，记得尽可能多地练习，对自己的判断有信心，永不放弃！我真诚地希望你的下一个Java职位能给你带来梦想的工作，而这本书能为你的成功做出贡献。
