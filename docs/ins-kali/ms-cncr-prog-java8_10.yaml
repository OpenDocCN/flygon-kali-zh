- en: Chapter 9. Diving into Concurrent Data Structures and Synchronization Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。深入研究并发数据结构和同步实用程序
- en: Among of the most important elements in every computer program are **data structures**.
    Data structures allow us to store the data that our applications read, transform,
    and write in different ways according to our needs. The selection of an adequate
    data structure is a critical point to get good performance. A bad choice can degrade
    the performance of an algorithm considerably. Java concurrency API includes some
    data structures designed to be used in concurrent applications without provoking
    data inconsistencies or loss of information.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个计算机程序中最重要的元素之一是**数据结构**。数据结构允许我们根据需要以不同的方式存储我们的应用程序读取、转换和写入的数据。选择适当的数据结构是获得良好性能的关键点。糟糕的选择可能会显着降低算法的性能。Java并发API包括一些设计用于在并发应用程序中使用的数据结构，而不会引起数据不一致或信息丢失。
- en: Another critical point in concurrent applications are **synchronization mechanisms**.
    You use them to implement mutual exclusion by creating a critical section, that
    is to say, a piece of code that can only be executed by one thread at a time.
    But you can also use synchronization mechanisms to implement dependencies between
    threads when, for example, a concurrent task must wait for the finalization of
    another task. Java concurrency API includes basic synchronization mechanisms,
    like the `synchronized` keyword and very high-level utilities, such as the `CyclicBarrier`
    class or the `Phaser` class you used in [Chapter 5](part0037_split_000.html#1394Q1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 5. Running Tasks Divided into Phases – The Phaser Class"), *Running Tasks
    Divided into Phases – The Phaser Class*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 并发应用程序中另一个关键点是**同步机制**。您可以使用它们通过创建临界区来实现互斥，也就是说，只能由一个线程执行的代码段。但您还可以使用同步机制来实现线程之间的依赖关系，例如，并发任务必须等待另一个任务的完成。Java并发API包括基本的同步机制，如`synchronized`关键字和非常高级的实用程序，例如`CyclicBarrier`类或您在[第5章](part0037_split_000.html#1394Q1-2fff3d3b99304faa8fa9b27f1b5053ba
    "第5章。分阶段运行任务 - Phaser类")中使用的`Phaser`类，*分阶段运行任务 - Phaser类*。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Concurrent data structures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发数据结构
- en: Synchronization mechanisms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步机制
- en: Concurrent data structures
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发数据结构
- en: Every computer program works with data. They get the data from a database, a
    file, or another source, transform that data, and then write the transformed data
    into a database, a file, or another destination. The programs work with data stored
    in memory and use data structures to store the data in memory.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个计算机程序都使用数据。它们从数据库、文件或其他来源获取数据，转换数据，然后将转换后的数据写入数据库、文件或其他目的地。程序使用存储在内存中的数据，并使用数据结构将数据存储在内存中。
- en: When you implement a concurrent application, you must be very careful with the
    utilization of data structures. If different threads can modify the data stored
    in a unique data structure, you have to use a synchronization mechanism to protect
    the modifications over that data structure. If you don't do this, you can have
    a data race condition. Your application may sometimes work correctly, but next
    time may crash with a random exception, stuck in an infinite loop, or silently
    produce an incorrect result. The outcome will depend on the order of execution.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当您实现并发应用程序时，您必须非常小心地使用数据结构。如果不同的线程可以修改唯一数据结构中存储的数据，您必须使用同步机制来保护该数据结构上的修改。如果不这样做，可能会出现数据竞争条件。您的应用程序有时可能会正常工作，但下一次可能会因为随机异常而崩溃，在无限循环中卡住，或者悄悄地产生不正确的结果。结果将取决于执行的顺序。
- en: 'To avoid data race conditions you can:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免数据竞争条件，您可以：
- en: Use a non-synchronized data structure and add the synchronization mechanisms
    by yourself
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非同步数据结构，并自行添加同步机制
- en: Use a data structure provided by the Java concurrency API that implements the
    synchronization mechanism internally and is optimized to be used in concurrent
    applications
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java并发API提供的数据结构，它在内部实现了同步机制，并经过优化，可用于并发应用程序
- en: The second option is the most recommended. Through the pages of this section,
    you will review the most important concurrent data structures giving special importance
    to Java 8's new features.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是最推荐的。在本节的页面中，您将回顾最重要的并发数据结构，特别关注Java 8的新功能。
- en: Blocking and non-blocking data structures
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻塞和非阻塞数据结构
- en: 'Java concurrency API provides two kinds of concurrent data structures:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供了两种类型的并发数据结构：
- en: '**Blocking data structures**: This kind of data structure provides methods
    to insert and delete data on it where, when the operation cannot be done immediately
    (for example, if you want to take an element and the data structure is empty),
    the thread that made the call will be blocked until the operation can be done'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻塞数据结构**：这种数据结构提供了在其中插入和删除数据的方法，当操作无法立即完成时（例如，如果您想取出一个元素而数据结构为空），发出调用的线程将被阻塞，直到操作可以完成'
- en: '**Non-blocking data structures**: This kind of data structure provides methods
    to insert and delete data on it that, when the operation cannot be done immediately,
    return a special value or throw an exception'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非阻塞数据结构**：这种数据结构提供了在其中插入和删除数据的方法，当操作无法立即完成时，返回一个特殊值或抛出异常'
- en: Sometimes, we have a non-blocking equivalent for the blocking data structure.
    For example, the `ConcurrentLinkedDeque` class is a non-blocking data structure
    and the `LinkedBlockingDeque` is the blocking equivalent. Blocking data structures
    have methods that behave like non-blocking data structures. For example, the `Deque`
    interface defines the `pollFirst()` method that does not block returns `null`
    if the deque is empty. Every blocking queue implementation implements this method
    as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们对阻塞数据结构有非阻塞等价物。例如，`ConcurrentLinkedDeque`类是一个非阻塞数据结构，而`LinkedBlockingDeque`是阻塞等价物。阻塞数据结构具有类似非阻塞数据结构的方法。例如，`Deque`接口定义了`pollFirst()`方法，如果双端队列为空，则不会阻塞并返回`null`。每个阻塞队列实现也实现了这个方法。
- en: 'The **Java collections framework** (**JCF**) provides a set of different data
    structures that can be used in sequential programming. The Java concurrent API
    extends those structures, providing others that can be used in concurrent applications.
    This includes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java集合框架**（**JCF**）提供了一组可以在顺序编程中使用的不同数据结构。Java并发API扩展了这些结构，提供了可以在并发应用程序中使用的其他结构。这包括：'
- en: '**Interfaces**: This extends the interfaces provided by the JCF, adding some
    methods that can be used in concurrent applications'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：这扩展了JCF提供的接口，添加了一些可以在并发应用程序中使用的方法'
- en: '**Classes**: This implements the previous interfaces to provide implementations
    that can be used in the applications'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类**：这些类实现了前面的接口，提供了可以在应用程序中使用的实现'
- en: In the following sections, we make an introduction to the interfaces and classes
    you can use in concurrent applications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们介绍了并发应用程序中可以使用的接口和类。
- en: Interfaces
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接口
- en: First, let's describe the most important interfaces implemented by the concurrent
    data structures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们描述并发数据结构实现的最重要的接口。
- en: BlockingQueue
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BlockingQueue
- en: A **queue** is a linear data structure that allows you to insert elements at
    the end of the queue and get elements from the start. It's a **First-In-First-Out**
    (**FIFO**) data structure where the first elements introduced in the queue are
    the first ones that are processed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**是一种线性数据结构，允许您在队列末尾插入元素并从开头获取元素。它是一种**先进先出**（**FIFO**）的数据结构，队列中引入的第一个元素是被处理的第一个元素。'
- en: 'The JCF defines the `Queue` interface that defines the basic operations to
    be implemented in a queue. This interface provides methods to:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JCF定义了`Queue`接口，该接口定义了队列中要实现的基本操作。该接口提供了以下方法：
- en: Insert an element at the end of the queue
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在队列末尾插入元素
- en: Retrieve and remove an element from the head of the queue
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从队列头部检索并删除元素
- en: Retrieve without removing an element from the head of the queue
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从队列头部检索但不删除元素
- en: 'The interface defines two versions of these methods that have different behaviors
    when the method can be done (for example, if you want to retrieve an element of
    an empty queue):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口定义了这些方法的两个版本，当方法可以完成时具有不同的行为（例如，如果要从空队列中检索元素）：
- en: Methods that throw an exception
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常的方法
- en: Methods that return a special value, for example `false` or `null`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回特殊值的方法，例如`false`或`null`
- en: 'The next table includes the names of the methods for every operation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下表包括了每个操作的方法名称：
- en: '| Operation | Exception | Special value |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 异常 | 特殊值 |'
- en: '| --- | --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Insert | `add()` | `offer()` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 插入 | `add()` | `offer()` |'
- en: '| Retrieve and remove | `remove()` | `poll()` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 检索和删除 | `remove()` | `poll()` |'
- en: '| Retrieve but don''t remove | `element()` | `peek()` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 检索但不删除 | `element()` | `peek()` |'
- en: 'The `BlockingDeque` interface extends the `Queue` interface, adding methods
    that block the calling thread if the operation can be done. These methods are:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingDeque`接口扩展了`Queue`接口，添加了在操作可以完成时阻塞调用线程的方法。这些方法包括：'
- en: '| Operation | Blocks |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 阻塞 |'
- en: '| --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Insert | `put()` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 插入 | `put()` |'
- en: '| Retrieve and remove | `take()` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 检索和删除 | `take()` |'
- en: '| Retrieve without removing | N/A |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 检索但不删除 | N/A |'
- en: BlockingDeque
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BlockingDeque
- en: 'A **deque** is a linear data structure, like the queue, but allows you to insert
    and delete elements from both sides of the data structure. The JCF defines the
    `Deque` interface that extends the `Queue` interface. In addition to the methods
    provided by the `Queue` interface, it provides methods to insert, retrieve and
    remove, and retrieve without removing at both ends:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**双端队列**是一种线性数据结构，类似于队列，但允许您从数据结构的两侧插入和删除元素。JCF定义了扩展`Queue`接口的`Deque`接口。除了`Queue`接口提供的方法之外，它还提供了在两端插入、检索和删除以及在两端检索但不删除的方法：'
- en: '| Operation | Exception | Special value |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 异常 | 特殊值 |'
- en: '| --- | --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Insert | `addFirst()`, `addLast()` | `offerFirst()`, `offerLast()` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 插入 | `addFirst()`，`addLast()` | `offerFirst()`，`offerLast()` |'
- en: '| Retrieve and remove | `removeFirst()`, `removeLast()` | `pollFirst()`, `pollLast()`
    |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 检索和删除 | `removeFirst()`，`removeLast()` | `pollFirst()`，`pollLast()` |'
- en: '| Retrieve without removing | `getFirst()`, `getLast()` | `peekFirst()`, `peekLast()`
    |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 检索但不删除 | `getFirst()`，`getLast()` | `peekFirst()`，`peekLast()` |'
- en: 'The `BlockingDeque` interface extends the `Deque` interface, adding the methods
    that block the calling threads when the operation can''t be done:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockingDeque`接口扩展了`Deque`接口，添加了在操作无法完成时阻塞调用线程的方法：'
- en: '| Operation | Blocks |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 阻塞 |'
- en: '| --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Insert | `putFirst()`, `putLast()` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 插入 | `putFirst()`，`putLast()` |'
- en: '| Retrieve and remove | `takeFirst()`, `takeLast()` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 检索和删除 | `takeFirst()`，`takeLast()` |'
- en: '| Retrieve without removing | N/A |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 检索但不删除 | N/A |'
- en: ConcurrentMap
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ConcurrentMap
- en: 'A **map** (sometimes also called an **associative array**) is a data structure
    that allows you to store (key, value) pairs. The JCF provides the `Map` interface
    that defines the basic operations to work with the map. This includes methods
    to:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射**（有时也称为**关联数组**）是一种数据结构，允许您存储（键，值）对。JCF提供了`Map`接口，该接口定义了与映射一起使用的基本操作。这包括插入、检索和删除以及检索但不删除的方法：'
- en: '`put()`: Insert a (key, value) pair into the map'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put()`: 将（键，值）对插入到映射中'
- en: '`get()`: Return the value associated with a key'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 返回与键关联的值'
- en: '`remove()`: Remove the (key, value) pair associated with the specified key'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove()`: 移除与指定键关联的（键，值）对'
- en: '`containsKey()`and `containsValue()`: Return true if the map contains the specified
    key of the value'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containsKey()`和`containsValue()`: 如果映射包含指定的键或值，则返回true'
- en: 'This interface has been modified in Java 8 to include the following new methods.
    You will learn how to work with these methods later in this chapter:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口在Java 8中已经修改，包括以下新方法。您将在本章后面学习如何使用这些方法：
- en: '`forEach()`: This method executes the given function over all the elements
    of the map.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach()`: 这个方法对映射的所有元素执行给定的函数。'
- en: '`compute()`, `computeIfAbsent()`, and `computeIfPresent()`: These methods allows
    you to specify a function that calculates the new value associated with a key.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compute()`, `computeIfAbsent()`和`computeIfPresent()`: 这些方法允许您指定计算与键关联的新值的函数。'
- en: '`merge()`: This method allows you to specify merging a (key, value) pair into
    an existing map. If the key isn''t in the map, it''s inserted directly. If not,
    the function specified is executed.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merge()`: 这个方法允许你指定将（键，值）对合并到现有的映射中。如果键不在映射中，它会直接插入。如果不是，执行指定的函数。'
- en: '`ConcurrentMap` extends the `Map` interface to provide the same methods to
    concurrent applications. Notice that in Java 8 (unlike Java 7), the `ConcurrentMap`
    interface doesn''t add new methods to the `Map` interface.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentMap`扩展了`Map`接口，为并发应用程序提供相同的方法。请注意，在Java 8中（不像Java 7），`ConcurrentMap`接口没有向`Map`接口添加新方法。'
- en: TransferQueue
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TransferQueue
- en: 'This interface extends the `BlockingQueue` interface and adds methods to transfer
    elements from producers to consumers, where producers can wait until a consumer
    takes off its element. The new methods added by this interface are:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口扩展了`BlockingQueue`接口，并添加了从生产者传输元素到消费者的方法，其中生产者可以等待直到消费者取走它的元素。这个接口添加的新方法是：
- en: '`transfer()`: Transfer an element to a consumer and wait (blocking the calling
    thread) until the element is consumed.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transfer()`: 将一个元素传输给消费者，并等待（阻塞调用线程），直到元素被消费。'
- en: '`tryTransfer()`: Transfer an element if there is a consumer waiting. If not,
    this method returns the `false` value and doesn''t insert the element in the queue.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tryTransfer()`: 如果有消费者在等待，就传输一个元素。如果没有，这个方法返回`false`值，并且不会将元素插入队列。'
- en: Classes
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Classes
- en: The Java concurrency API provides different implementations of the interfaces
    described before. Some of them don't add any new characteristics but others add
    new interesting functionality.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供了之前描述的接口的不同实现。其中一些不添加任何新特性，但其他一些添加了新的有趣功能。
- en: LinkedBlockingQueue
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LinkedBlockingQueue
- en: This class implements the `BlockingQueue` interface to provide a queue with
    blocking methods that optionally can have a limited number of elements. It also
    implements the `Queue`, `Collection`, and `Iterable` interfaces.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了`BlockingQueue`接口，提供了一个具有阻塞方法的队列，可以选择具有有限数量的元素。它还实现了`Queue`、`Collection`和`Iterable`接口。
- en: ConcurrentLinkedQueue
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ConcurrentLinkedQueue
- en: This class implements the `Queue` interface to provide a thread-save unlimited
    queue. Internally, it uses a non-blocking algorithm to guarantee that there won't
    be a data race in your application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了`Queue`接口，提供了一个线程安全的无限队列。在内部，它使用非阻塞算法来保证在您的应用程序中不会出现数据竞争。
- en: LinkedBlockingDeque
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LinkedBlockingDeque
- en: This class implements the `BlockingDeque` interface to provide a deque with
    blocking methods that optionally can have a limited number of elements. It has
    more functionality than `LinkedBlockingQueue` but may have more overhead, thus
    `LinkedBlockingQueue` should be used when deque features are unnecessary.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了`BlockingDeque`接口，提供了一个具有阻塞方法的双端队列，可以选择具有有限数量的元素。它比`LinkedBlockingQueue`具有更多的功能，但可能有更多的开销，因此当不需要双端队列功能时应该使用`LinkedBlockingQueue`。
- en: ConcurrentLinkedDeque
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ConcurrentLinkedDeque
- en: This class implements the `Deque` interface to provide a thread-save unlimited
    deque that allows you to add and delete elements at both ends of the deque. It
    has more functionality than `ConcurrentLinkedQueue`, but may have more overhead
    as occurs with `LinkedBlockingDeque`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了`Deque`接口，提供了一个线程安全的无限双端队列，允许您在队列的两端添加和删除元素。它比`ConcurrentLinkedQueue`具有更多的功能，但可能有更多的开销，就像`LinkedBlockingDeque`一样。
- en: ArrayBlockingQueue
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ArrayBlockingQueue
- en: This class implements the `BlockingQueue` interface to provide an implementation
    of a blocking queue with a limited number of elements based on an array. It also
    implements the `Queue`, `Collection`, and `Iterable` interfaces. Unlike non-concurrent
    array-based data structures (`ArrayList` and `ArrayDeque`), `ArrayBlockingQueue`
    allocates an array of a fixed size specified in the constructor and never resizes
    it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了`BlockingQueue`接口，提供了一个基于数组的有限元素数量的阻塞队列实现。它还实现了`Queue`、`Collection`和`Iterable`接口。与非并发的基于数组的数据结构（`ArrayList`和`ArrayDeque`）不同，`ArrayBlockingQueue`在构造函数中分配一个固定大小的数组，并且不会调整大小。
- en: DelayQueue
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DelayQueue
- en: This class implements the `BlockingDeque` interface to provide an implementation
    of a queue with blocking methods and an unlimited number of elements. The elements
    of this queue must implement the `Delayed` interface, so they have to implement
    the `getDelay()` method. If that method returns a negative or zero value, the
    delay has expired and the element can be taken of the queue. The head of the queue
    is the element with the most negative value of delay.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了`BlockingDeque`接口，提供了一个具有阻塞方法和无限元素数量的队列实现。这个队列的元素必须实现`Delayed`接口，因此它们必须实现`getDelay()`方法。如果该方法返回负值或零值，延迟已经过期，元素可以从队列中取出。队列的头部是延迟值最负的元素。
- en: LinkedTransferQueue
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LinkedTransferQueue
- en: This class provide an implementation of the `TransferQueue` interface. It provides
    a blocking queue with an unlimited number of elements, and with the possibility
    of using them as a communication channel between producers and consumer where
    producers can wait for consumers to process their elements.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了`TransferQueue`接口的实现。它提供了一个具有无限元素数量的阻塞队列，并且可以将它们用作生产者和消费者之间的通信通道，其中生产者可以等待消费者处理他们的元素。
- en: PriorityBlockingQueue
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PriorityBlockingQueue
- en: This class provide an implementation of the `BlockingQueue` interface where
    the elements can be polled according to their natural order or by a comparator
    specified in the constructor of the class. The head of this queue is determined
    by the sorting order of the elements.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了`BlockingQueue`接口的实现，其中元素可以根据它们的自然顺序或在类的构造函数中指定的比较器进行轮询。这个队列的头部由元素的排序顺序确定。
- en: ConcurrentHashMap
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ConcurrentHashMap
- en: 'This class provides an implementation of the `ConcurrentMap` interface. It
    provides a thread-safe hash table. In addition to the methods added in the `Map`
    interface in the Java 8 version, this class has added other ones:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了`ConcurrentMap`接口的实现。它提供了一个线程安全的哈希表。除了Java 8版本中添加到`Map`接口的方法之外，这个类还添加了其他方法：
- en: '`search()`, `searchEntries()`, `searchKeys()`, and `searchValues()`: These
    methods allows you to apply a search function over the (key, value) pairs, over
    the keys, or over the values. The search function can be a lambda expression,
    and the method ends when the search function returns a not-null value. That is
    the result of the execution of the method.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search()`, `searchEntries()`, `searchKeys()`, and `searchValues()`: 这些方法允许您在（键，值）对、键或值上应用搜索函数。搜索函数可以是lambda表达式，当搜索函数返回非空值时，方法结束。这就是方法执行的结果。'
- en: '`reduce()`, `reduceEntries()`, `reduceKeys()`, and `reduceValues()`: These
    methods allows you to apply a `reduce()` operation to transform the (key, value)
    pairs, the keys, or the entries as occurs with streams (Refer to [Chapter 8](part0051_split_000.html#1GKCM1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 8. Processing Massive Datasets with Parallel Streams – The Map and Collect
    Model"), *Processing Massive Datasets with Parallel Streams – The Map and Collect
    Model* to get more details about the `reduce()` method).'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce()`, `reduceEntries()`, `reduceKeys()`, 和 `reduceValues()`: 这些方法允许您应用`reduce()`操作来转换（键，值）对、键或条目，就像流中发生的那样（参见[第8章](part0051_split_000.html#1GKCM1-2fff3d3b99304faa8fa9b27f1b5053ba
    "第8章。使用并行流处理大型数据集 - Map和Collect模型")，“使用并行流处理大型数据集 - Map和Collect模型”了解有关`reduce()`方法的更多细节）。'
- en: More methods have been added (`forEachValue`, `forEachKey`, and so on), but
    they are not covered here.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加更多方法（`forEachValue`，`forEachKey`等），但这里不涉及它们。
- en: Using the new features
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用新特性
- en: In this section, you will learn how to use the new features introduced in Java
    8 to the concurrent data structures.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用Java 8中引入的并发数据结构的新特性。
- en: First example with ConcurrentHashMap
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConcurrentHashMap的第一个示例
- en: In [Chapter 8](part0051_split_000.html#1GKCM1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 8. Processing Massive Datasets with Parallel Streams – The Map and Collect
    Model"), *Processing Massive Datasets with Parallel Streams – The Map and Collect
    Model*, you implemented an application to make a search in a dataset from 20,000
    Amazon products. We have taken that information from the Amazon product co-purchasing
    network metadata, which includes information about 548,552 products including
    title, salesrank, and similar products. You can download this dataset from [https://snap.stanford.edu/data/amazon-meta.html](https://snap.stanford.edu/data/amazon-meta.html).
    In that example, you used a `ConcurrentHashMap<String, List<ExtendedProduct>>`
    named `productsByBuyer` to store information about the products purchased by a
    user. The keys of this map are the identifier of the user, and the values a list
    of the products purchased by the user. You're going to use that map to learn how
    to work with the new methods of the `ConcurrentHashMap` class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](part0051_split_000.html#1GKCM1-2fff3d3b99304faa8fa9b27f1b5053ba "第8章。使用并行流处理大型数据集
    - Map和Collect模型")中，您实现了一个应用程序，从20,000个亚马逊产品的数据集中进行搜索。我们从亚马逊产品共购买网络元数据中获取了这些信息，其中包括548,552个产品的标题、销售排名和类似产品的信息。您可以从[https://snap.stanford.edu/data/amazon-meta.html](https://snap.stanford.edu/data/amazon-meta.html)下载这个数据集。在那个示例中，您使用了一个名为`productsByBuyer`的`ConcurrentHashMap<String,
    List<ExtendedProduct>>`来存储用户购买的产品的信息。这个映射的键是用户的标识符，值是用户购买的产品的列表。您将使用该映射来学习如何使用`ConcurrentHashMap`类的新方法。
- en: The forEach() method
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: forEach()方法
- en: 'This method allows you to specify a function that will be executed on every
    (key, value) pair of `ConcurrentHashMap`. There are many versions of this method,
    but the most basic version has only a `BiConsumer` function that can be expressed
    as a lambda expression. For example, you can use this method to print how many
    products every user has purchased, using the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法允许您指定一个函数，该函数将在每个`ConcurrentHashMap`的（键，值）对上执行。这个方法有很多版本，但最基本的版本只有一个`BiConsumer`函数，可以表示为lambda表达式。例如，您可以使用这个方法来打印每个用户购买了多少产品的代码：
- en: '[PRE0]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This basic version is a part of the usual `Map` interface and is always executed
    sequentially. In this code, we have used a lambda expression where `id` is the
    key of the element and `list` is the value of the element.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本版本是通常的`Map`接口的一部分，并且总是按顺序执行。在这段代码中，我们使用了lambda表达式，其中`id`是元素的键，`list`是元素的值。
- en: In this other example, we have used the `forEach()` method to calculate the
    average rating given per every user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个示例中，我们使用了`forEach()`方法来计算每个用户给出的平均评分。
- en: '[PRE1]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this code, we have also used a lambda expression where `id` is the key of
    the element and `list` is its value. We have used a stream applied to the list
    of products to calculate the average rating.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们还使用了lambda表达式，其中`id`是元素的键，`list`是其值。我们使用了应用于产品列表的流来计算平均评分。
- en: 'Other versions of this method are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的其他版本如下：
- en: '`forEach(parallelismThreshold, action)`: This is the version of the method
    you have to use in concurrent applications. If the map has more elements than
    the number specified in the first parameter, this method will be executed in parallel.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach(parallelismThreshold, action)`: 这是您在并发应用程序中必须使用的方法的版本。如果地图的元素多于第一个参数中指定的数量，则此方法将并行执行。'
- en: '`forEachEntry(parallelismThreshold, action)`: The same as the previous, but
    in this case the action is an implementation of the `Consumer` interface that
    receives a `Map.Entry` object with the key and the value of the element. You can
    also use a lambda expression in this case.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachEntry(parallelismThreshold, action)`: 与之前相同，但在这种情况下，操作是`Consumer`接口的实现，它接收一个带有元素的键和值的`Map.Entry`对象。在这种情况下，您也可以使用lambda表达式。'
- en: '`forEachKey(parallelismThreshold, action)`: The same as the previous, but in
    this case the action will be applied only over the keys of `ConcurrentHashMap`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachKey(parallelismThreshold, action)`: 与之前相同，但在这种情况下，操作仅应用于`ConcurrentHashMap`的键。'
- en: '`forEachValue(parallelismThreshold, action)`: The same as the previous, but
    in this case the action will be applied only over the values of `ConcurrentHashMap`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachValue(parallelismThreshold, action)`: 与之前相同，但在这种情况下，操作仅应用于`ConcurrentHashMap`的值。'
- en: Current implementation uses the common `ForkJoinPool` instance to execute the
    parallel tasks.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当前实现使用通用的`ForkJoinPool`实例来执行并行任务。
- en: The search() method
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: search()方法
- en: 'This method applies a search function to all the elements of `ConcurrentHashMap`.
    This search function can return a null value or a value different from null. The
    `search()` method will return the first non-null value returned by the search
    function. This method receives two parameters:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将搜索函数应用于`ConcurrentHashMap`的所有元素。此搜索函数可以返回空值或非空值。`search()`方法将返回搜索函数返回的第一个非空值。此方法接收两个参数：
- en: '`parallelismThreshold`: If the map has more elements than the number specified
    by this parameter, this method will be executed in parallel.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parallelismThreshold`: 如果地图的元素多于此参数指定的数量，则此方法将并行执行。'
- en: '`searchFunction`: This is an implementation of the `BiFunction` interface that
    can be expressed as a lambda expression. This function receives as parameters
    the key and the value of each element and, as we mentioned before, has to return
    a non-null value if you find what you are searching for and a null value if you
    don''t.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchFunction`: 这是`BiFunction`接口的实现，可以表示为lambda表达式。此函数接收每个元素的键和值作为参数，并且如前所述，如果找到您要搜索的内容，则必须返回非空值，如果找不到，则必须返回空值。'
- en: 'For example, you can use this function to find the first book that contains
    a word:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用此函数找到包含某个单词的第一本书：
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we use 100 as `parallelismThreshold` and a lambda expression to
    implement the search function. In this function, for every element, we process
    all the products of the list. If we find a product that contains the word `java`,
    we return that product. This is the value returned by the `search()` method. Finally,
    we write the buyer and the title of the product in the console.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用100作为`parallelismThreshold`，并使用lambda表达式来实现搜索函数。在此函数中，对于每个元素，我们处理列表的所有产品。如果我们找到包含单词`java`的产品，我们返回该产品。这是`search()`方法返回的值。最后，我们在控制台中写入产品的买家和标题。
- en: 'There are other versions of this method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法还有其他版本：
- en: '`searchEntries(parallelismThreshold, searchFunction)`: In this case, the search
    function is an implementation of the `Function` interface that receives as a parameter
    a `Map.Entry` object'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchEntries(parallelismThreshold, searchFunction)`: 在这种情况下，搜索函数是`Function`接口的实现，它接收一个`Map.Entry`对象作为参数'
- en: '`searchKeys(parallelismThreshold, searchFunction)`: In this case, the search
    function is applied only over the keys of `ConcurrentHashMap`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchKeys(parallelismThreshold, searchFunction)`: 在这种情况下，搜索函数仅应用于`ConcurrentHashMap`的键'
- en: '`searchValues(parallelismThreshold, searchFunction)`: In this case, the search
    function is applied only over the values of `ConcurrentHashMap`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchValues(parallelismThreshold, searchFunction)`: 在这种情况下，搜索函数仅应用于`ConcurrentHashMap`的值'
- en: The reduce() method
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: reduce()方法
- en: 'This method is similar to the `reduce()` method provided by the `Stream` framework,
    but in this case you work directly with the elements of `ConcurrentHashMap`. This
    method receive three parameters:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法类似于`Stream`框架提供的`reduce()`方法，但在这种情况下，您直接使用`ConcurrentHashMap`的元素。此方法接收三个参数：
- en: '`parallelismThreshold`: If `ConcurrentHashMap` has more elements than the number
    specified in this parameter, this method will be executed in parallel.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parallelismThreshold`: 如果`ConcurrentHashMap`的元素多于此参数中指定的数量，则此方法将并行执行。'
- en: '`transformer`: This parameter is an implementation of the `BiFunction` interface
    that can be expressed as a lambda function. It receives as a parameter a key and
    a value and returns a transformation of these elements.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transformer`: 此参数是`BiFunction`接口的实现，可以表示为lambda函数。它接收一个键和一个值作为参数，并返回这些元素的转换。'
- en: '`reducer`: This parameter is an implementation of the `BiFunction` interface
    that can be expressed as a lambda function too. It receives as parameters two
    objects returned by the transformer function. The objective of this function is
    to group those two objects into a single one.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reducer`: 此参数是`BiFunction`接口的实现，也可以表示为lambda函数。它接收transformer函数返回的两个对象作为参数。此函数的目标是将这两个对象分组为一个对象。'
- en: 'As an example of this method, we will obtain a list of products that have a
    review with a value of `1` (the worst value). We have used two auxiliary variables.
    The first one is `transformer`. It is a `BiFunction` interface that we will use
    as the `transformer` element of the `reduce()` method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这种方法的一个例子，我们将获得一个产品列表，其中包含值为`1`的评论（最差的值）。我们使用了两个辅助变量。第一个是`transformer`。它是一个`BiFunction`接口，我们将用作`reduce()`方法的`transformer`元素：
- en: '[PRE3]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This function will receive the key, which is the `id` of a user, and a list
    of `ExtendedProduct` objects with the products purchased by that user. We process
    all the products of the list and return the products that have a rating of one.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将接收键，即用户的`id`，以及用户购买的产品的`ExtendedProduct`对象列表。我们处理列表中的所有产品，并返回评分为一的产品。
- en: 'The second variable is the reducer `BinaryOperator`. We use it as the reducer
    function of the `reduce()` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个变量是reducer `BinaryOperator`。我们将其用作`reduce()`方法的reducer函数：
- en: '[PRE4]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The reduce receives two lists of `ExtendedProduct` and concatenates them into
    a single one using the `addAll()` method.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: reduce接收两个`ExtendedProduct`列表，并使用`addAll()`方法将它们连接成一个单一的列表。
- en: 'Now, we only have to implement the call to the `reduce()` method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需实现对`reduce()`方法的调用：
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are other versions of the `reduce()` method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`方法还有其他版本：'
- en: '`reduceEntries()`, `reduceEntriesToDouble()`, `reduceEntriesToInt()`, and `reduceEntriesToLong()`:
    In this case, the transformer and reducer functions work over `Map.Entry` objects.
    The last three versions return respectively a `double`, an `int`, and a `long`
    value.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduceEntries()`，`reduceEntriesToDouble()`，`reduceEntriesToInt()`和`reduceEntriesToLong()`：在这种情况下，转换器和reducer函数作用于`Map.Entry`对象。最后三个版本分别返回`double`，`int`和`long`值。'
- en: '`reduceKeys()`, `reduceKeysToDouble()`, and `reduceKeysToInt()`, `reduceKeysToLong()`:
    In this case, the transformer and reducer functions work over the keys of the
    map. The last three versions return respectively a `double`, an `int`. and a `long`
    value.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduceKeys()`，`reduceKeysToDouble()`和`reduceKeysToInt()`，`reduceKeysToLong()`：在这种情况下，转换器和reducer函数作用于映射的键。最后三个版本分别返回`double`，`int`和`long`值。'
- en: '`reduceToInt()`, `reduceToDouble()`, and `reduceToLong()`: In this case, the
    transformer function works over the keys and values and the reducer method works
    over `int`, `double`, or `long` number respectively. These methods return an `int`,
    `double`, and `long` values.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduceToInt()`，`reduceToDouble()`和`reduceToLong()`：在这种情况下，转换器函数作用于键和值，reducer方法分别作用于`int`，`double`或`long`数。这些方法返回`int`，`double`和`long`值。'
- en: '`reduceValues()`, `reduceValuesToDouble()`, `reduceValuesToInt()`, and `reduceValuesToLong()`:
    In this case, the transformer and reducer functions work over the values of the
    map. The last three versions return a `double`, an `int`, and a `long` value respectively.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduceValues()`，`reduceValuesToDouble()`，`reduceValuesToInt()`和`reduceValuesToLong()`：在这种情况下，转换器和reducer函数作用于映射的值。最后三个版本分别返回`double`，`int`和`long`值。'
- en: The compute() method
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: compute()方法
- en: This method (which is defined in the `Map` interface) receives as parameters
    the key of an element and an implementation of the `BiFunction` interface that
    can be expressed as a lambda expression. This function will receive the key and
    value of the element if the key exists in `ConcurrentHashMap` or null if the key
    doesn't exist in `ConcurrentHashMap`. The method will replace the value associated
    with the key with the value returned by the function, insert them in `ConcurrentHashMap`
    if it doesn't exist, or remove the item if `null` is returned for a previously
    existing item. Note that during the `BiFunction` execution, one or several map
    entries can be locked. Thus, your `BiFunction` should not work for very long and
    should not try to update any other entries in the same map. Otherwise a deadlock
    might occur.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法（在`Map`接口中定义）接收元素的键和可以表示为lambda表达式的`BiFunction`接口的实现作为参数。如果键存在于`ConcurrentHashMap`中，则此函数将接收元素的键和值，否则为`null`。该方法将用函数返回的值替换与键关联的值，如果不存在，则将它们插入`ConcurrentHashMap`，或者如果对于先前存在的项目返回`null`，则删除该项目。请注意，在`BiFunction`执行期间，一个或多个映射条目可能会被锁定。因此，您的`BiFunction`不应该工作太长时间，也不应该尝试更新同一映射中的任何其他条目。否则可能会发生死锁。
- en: For example, we can use this method with the new atomic variable introduced
    in Java 8 named `LongAdder` to calculate the number of bad reviews associated
    with every product. We create a new `ConcurrentHashMap` named counter. The keys
    will be the title of the products and the value an object of the `LongAdder` class
    to count how many bad reviews every product has.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用此方法与Java 8中引入的新原子变量`LongAdder`一起计算与每个产品关联的不良评论数量。我们创建一个名为counter的新`ConcurrentHashMap`。键将是产品的标题，值将是`LongAdder`类的对象，用于计算每个产品有多少不良评论。
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We process all the elements of `badReviews` `ConcurrentLinkedDeque` calculated
    in the previous section and use the `compute()` method to create and update the
    `LongAdder` associated with every product.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理在上一节中计算的`badReviews` `ConcurrentLinkedDeque`的所有元素，并使用`compute()`方法创建和更新与每个产品关联的`LongAdder`。
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, we write the results in the console.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将结果写入控制台。
- en: Another example with ConcurrentHashMap
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一个使用ConcurrentHashMap的例子
- en: 'There is another method added in the `ConcurrentHashMap` class and defined
    in the Map interface. It''s the `merge()` method that allows you to merge a (key,
    value) pair into the map. If the key doesn''t exist in `ConcurrentHashMap`, it
    is inserted directly. If the key exists, you have to define which will be the
    new value associated with that key from the old one and the new one. This method
    receives three parameters:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`类中添加的另一种方法并在Map接口中定义。这是`merge()`方法，允许您将（键，值）对合并到映射中。如果键不存在于`ConcurrentHashMap`中，则直接插入。如果键存在，则必须定义从旧值和新值中关联的键的新值。此方法接收三个参数：'
- en: The key we want to merge.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要合并的键。
- en: The value we want to merge.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们要合并的值。
- en: An implementation of `BiFunction` that can be expressed as a lambda expression.
    This function receives as parameters the old value and the new value associated
    with the key. The method will associate with the key the value returned by this
    function. `BiFunction` is executed under a partial lock of the map, so it's guaranteed
    that it's not concurrently executed for the same key.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以表示为lambda表达式的`BiFunction`的实现。此函数接收旧值和与键关联的新值作为参数。该方法将用此函数返回的值与键关联。`BiFunction`在映射的部分锁定下执行，因此可以保证它不会同时为相同的键并发执行。
- en: 'For example, we have split the 20,000 products of Amazon used in the previous
    section in files by the year of the review. For every year, we load `ConcurrentHashMap`
    where the products are the keys and a list of reviews are the values. So, we can
    load the reviews of 1995 and 1996 with the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们已经将上一节中使用的亚马逊的20,000个产品按评论年份分成文件。对于每一年，我们加载`ConcurrentHashMap`，其中产品是键，评论列表是值。因此，我们可以使用以下代码加载1995年和1996年的评论：
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we want to merge both versions of `ConcurrentHashMap` into one, we can use
    the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想将`ConcurrentHashMap`的两个版本合并成一个，可以使用以下代码：
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We process all the elements of the 1996 `ConcurrentHashMap` and for every (key,
    value) pair, we call the `merge()` method over the 1995 `ConcurrentHashMap`. The
    `merge` function will receive two lists of reviews, so we only have to concatenate
    them into one.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理了1996年的`ConcurrentHashMap`的所有元素，并且对于每个（键，值）对，我们在1995年的`ConcurrentHashMap`上调用`merge()`方法。`merge`函数将接收两个评论列表，因此我们只需将它们连接成一个。
- en: An example with the ConcurrentLinkedDeque class
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用ConcurrentLinkedDeque类的示例
- en: The `Collection` interface has also included new methods in Java 8\. Most of
    the concurrent data structures implement this interface, so we can use these new
    features with them. Two of them are the `stream()` and `parallelStream()` methods
    used in [Chapter 7](part0047_split_000.html#1CQAE2-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 7. Processing Massive Datasets with Parallel Streams – The Map and Reduce
    Model"), *Processing Massive Datasets with Parallel Streams – The Map and Reduce
    Model* and [Chapter 8](part0051_split_000.html#1GKCM1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 8. Processing Massive Datasets with Parallel Streams – The Map and Collect
    Model"), *Processing Massive Datasets with Parallel Streams – The Map and Collect
    Model*. Let's see how to use the other two using `ConcurrentLinkedDeque` with
    the 20,000 products we have used in the previous sections.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection`接口在Java 8中还包括了新的方法。大多数并发数据结构都实现了这个接口，因此我们可以在它们中使用这些新特性。其中两个是[第7章](part0047_split_000.html#1CQAE2-2fff3d3b99304faa8fa9b27f1b5053ba
    "第7章。使用并行流处理大型数据集 - 映射和归约模型")和[第8章](part0051_split_000.html#1GKCM1-2fff3d3b99304faa8fa9b27f1b5053ba
    "第8章。使用并行流处理大型数据集 - 映射和收集模型")中使用的`stream()`和`parallelStream()`方法。让我们看看如何使用`ConcurrentLinkedDeque`和我们在前面章节中使用的20,000个产品。'
- en: The removeIf() method
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: removeIf() 方法
- en: This method has a default implementation in the `Collection` interface that
    is not concurrent and is not overridden by the `ConcurrentLinkedDeque` class.
    This method receives an implementation of the `Predicate` interface as a parameter
    that will receive an element of the `Collection` as a parameter and should return
    a `true` or a `false` value. The method will process all the elements of the `Collection`
    and will delete those that obtain a `true` value with the predicate.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在`Collection`接口中有一个默认实现，不是并发的，并且没有被`ConcurrentLinkedDeque`类覆盖。此方法接收`Predicate`接口的实现作为参数，该接口将接收`Collection`的元素作为参数，并应返回`true`或`false`值。该方法将处理`Collection`的所有元素，并将删除那些使用谓词获得`true`值的元素。
- en: 'For example, if you want to delete all the products with a salesrank higher
    than 1,000, you can use the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想删除所有销售排名高于1,000的产品，可以使用以下代码：
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The spliterator() method
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: spliterator() 方法
- en: This method returns an implementation of the `Spliterator` interface. A **spliterator**
    defines the data source that can be used by the `Stream` API. You rarely need
    to use spliterator directly, but sometimes you may want to create your own spliterator
    to produce a custom source for the stream (for example, if you implement your
    own data structure). If you have your own spliterator implementation, you can
    create a stream on top of it using `StreamSupport.stream(mySpliterator, isParallel)`.
    Here, `isParallel` is a Boolean value that determines whether the created stream
    will be parallel or not. A spliterator is like an iterator in the sense that you
    can use it to traverse all the elements in the collection, but you can split them
    to make that traversal in a concurrent way.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回`Spliterator`接口的实现。**spliterator**定义了`Stream` API可以使用的数据源。您很少需要直接使用spliterator，但有时您可能希望创建自己的spliterator来为流生成自定义源（例如，如果您实现自己的数据结构）。如果您有自己的spliterator实现，可以使用`StreamSupport.stream(mySpliterator,
    isParallel)`在其上创建流。这里，`isParallel`是一个布尔值，确定创建的流是否是并行的。分割器类似于迭代器，您可以使用它来遍历集合中的所有元素，但可以将它们分割以以并发方式进行遍历。
- en: 'A spliterator has eight different characteristics that define its behavior:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 分割器有八种不同的特征来定义其行为：
- en: '`CONCURRENT`: The spliterator source may be safely concurrently modified'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONCURRENT`: 分割器源可以安全并发修改'
- en: '`DISTINCT`: All the elements returned by the spliterator are distinct'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DISTINCT`: 分割器返回的所有元素都是不同的'
- en: '`IMMUTABLE`: The spliterator source cannot be modified'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMMUTABLE`: 分割器源不可修改'
- en: '`NONNULL`: The spliterator never returns a `null` value'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NONNULL`: 分割器永远不会返回`null`值'
- en: '`ORDERED`: The elements returned by the spliterator are ordered (which means
    their order matters)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ORDERED`: 分割器返回的元素是有序的（这意味着它们的顺序很重要）'
- en: '`SIZED`: The spliterator is capable of returning an exact number of elements
    with the `estimateSize()` method'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIZED`: 分割器能够使用`estimateSize()`方法返回确切数量的元素'
- en: '`SORTED`: The spliterator source is sorted'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SORTED`: 分割器源已排序'
- en: '`SUBSIZED`: If you use the `trySplit()` method to divide this spliterator,
    the resulting spliterators will be `SIZED` and `SUBSIZED`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SUBSIZED`: 如果使用`trySplit()`方法来分割这个分割器，生成的分割器将是`SIZED`和`SUBSIZED`'
- en: 'The most useful methods of this interface are:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口最有用的方法是：
- en: '`estimatedSize()`: This method will give you an estimation of the number of
    elements in the spliterator.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`estimatedSize()`: 此方法将为您提供分割器中元素数量的估计。'
- en: '`forEachRemaining()`: This method allows you to apply an implementation of
    the `Consumer` interface, which can be represented with a lambda function, to
    the elements of the spliterator that haven''t yet been processed.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEachRemaining()`: 这个方法允许您对尚未被处理的spliterator的元素应用`Consumer`接口的实现，可以用lambda函数表示。'
- en: '`tryAdvance()`: This method allows you to apply an implementation of the `Consumer`
    interface, which can be represented with a lambda function, to the next element
    to process by the spliterator if there is one.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tryAdvance()`: 这个方法允许您对spliterator要处理的下一个元素应用`Consumer`接口的实现，可以用lambda函数表示，如果有的话。'
- en: '`trySplit()`: This method tries to split the spliterator in two parts. The
    caller spliterator will process some elements and the returned spliterator will
    process the others. If the spliterator is `ORDERED`, the returned spliterator
    must process a strict prefix of the elements and the call must process the strict
    suffix.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trySplit()`: 这个方法尝试将spliterator分成两部分。调用者spliterator将处理一些元素，返回的spliterator将处理其他元素。如果spliterator是`ORDERED`，返回的spliterator必须处理元素的严格前缀，调用必须处理严格后缀。'
- en: '`hasCharacteristics()`: This method allows you to check the properties of the
    spliterator.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasCharacteristics()`: 这个方法允许您检查spliterator的属性。'
- en: Let's see an example of this method with the `ArrayList` data structure, with
    20,000 products.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用`ArrayList`数据结构的例子，有20,000个产品。
- en: 'First, we need an auxiliary task that will process a set of products to convert
    their title to lowercase. This task will have a `Spliterator` as an attribute:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个辅助任务，它将处理一组产品，将它们的标题转换为小写。这个任务将有一个`Spliterator`作为属性：
- en: '[PRE11]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, this task writes the number of products processed when it finishes
    its execution.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个任务在执行完毕时会写入处理的产品数量。
- en: In the main method, once we have loaded `ConcurrentLinkedQueue` with the 20,000
    products, we can obtain the spliterator, check some of its properties, and look
    at its estimated size.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在主方法中，一旦我们用20,000个产品加载了`ConcurrentLinkedQueue`，我们就可以获得spliterator，检查它的一些属性，并查看它的估计大小。
- en: '[PRE12]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, we can divide the spliterator using the `trySplit()` method and look
    at the size of the two spliterators:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`trySplit()`方法分割spliterator，并查看两个spliterator的大小：
- en: '[PRE13]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, we can execute two tasks in an executor, one for the spliterator, to
    see that every spliterator has really processed the expected number of elements.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在执行器中执行两个任务，一个用于spliterator，以查看每个spliterator是否真的处理了预期数量的元素。
- en: '[PRE14]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the following screenshot, you can see the results of the execution of this
    example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，您可以看到这个例子的执行结果：
- en: '![The spliterator() method](img/00026.jpeg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![spliterator()方法](img/00026.jpeg)'
- en: You can see how before splitting the spliterator, the `estimatedSize()` method
    returns 20,000 elements. After the execution of the `trySplit()` method, both
    spliterators have 10,000 elements. These are the elements processed by each of
    the tasks.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，在分割spliterator之前，`estimatedSize()`方法返回20,000个元素。在`trySplit()`方法执行后，两个spliterator都有10,000个元素。这些是每个任务处理的元素。
- en: Atomic variables
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子变量
- en: Atomic variables were introduced in Java 1.5 to provide atomic operations over
    `integer`, `long`, `boolean`, `reference`, and `Array` objects. They provide some
    methods to increment, decrement, establish the value, return the value, or establish
    the value if its current value is equal to a predefined one.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Java 1.5引入了原子变量，以提供对`integer`、`long`、`boolean`、`reference`和`Array`对象的原子操作。它们提供了一些方法来增加、减少、建立值、返回值，或者在当前值等于预定义值时建立值。
- en: 'In Java 8, four new classes has been added. These are `DoubleAccumulator`,
    `DoubleAdder`, `LongAccumulator`, and `LongAdder`. In a previous section, we used
    the `LongAdder` class to count the number of bad reviews of the products. This
    class provides similar functionality to `AtomicLong`, but it has better performance
    when you frequently update the cumulative sum from different threads and request
    the result only at the end of the operation. The `DoubleAdder` function is equal
    to it but with double values. The main objective of both classes is to have a
    counter that can be updated by different threads in a consistent way. The most
    important methods of these classes are:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，新增了四个新类。它们是`DoubleAccumulator`、`DoubleAdder`、`LongAccumulator`和`LongAdder`。在前面的部分，我们使用了`LongAdder`类来计算产品的差评数量。这个类提供了类似于`AtomicLong`的功能，但是当您频繁地从不同线程更新累积和并且只在操作结束时请求结果时，它的性能更好。`DoubleAdder`函数与之相等，但是使用双精度值。这两个类的主要目标是拥有一个可以由不同线程一致更新的计数器。这些类的最重要的方法是：
- en: '`add()`: Increment the value of the counter with the value specified as a parameter'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add()`: 用指定的值增加计数器的值'
- en: '`increment()`: Equivalent to `add(1)`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`increment()`: 等同于`add(1)`'
- en: '`decrement()`: Equivalent to `add(-1)`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decrement()`: 等同于`add(-1)`'
- en: '`sum()`: This method returns the current value of the counter'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum()`: 这个方法返回计数器的当前值'
- en: Take into account that the `DoubleAdder` class doesn't have the `increment()`
    and `decrement()` methods.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`DoubleAdder`类没有`increment()`和`decrement()`方法。
- en: 'The `LongAccumulator` and `DoubleAccumulator` classes are similar but they
    have a very important difference. They have a constructor where you specify two
    parameters:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`LongAccumulator`和`DoubleAccumulator`类是类似的，但它们有一个非常重要的区别。它们有一个构造函数，您可以在其中指定两个参数：'
- en: The identity value of the internal counter
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部计数器的身份值
- en: A function to accumulate the new value into the accumulator
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将新值累积到累加器中的函数
- en: 'Note that the function must not depend on the order of accumulation. In this
    case, the most important methods are:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，函数不应依赖于累积的顺序。在这种情况下，最重要的方法是：
- en: '`accumulate()`: This method receives a `long` value as a parameter. It applies
    the function to increment or decrement the counter to the current value and the
    parameter.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accumulate()`: 这个方法接收一个`long`值作为参数。它将函数应用于当前值和参数来增加或减少计数器的值。'
- en: '`get()`: Returns the current value of the counter.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 返回计数器的当前值。'
- en: 'For example, the following code will write 362,880 in the console in all the
    executions:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将在所有执行中在控制台中写入362,880：
- en: '[PRE15]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We use a commutative operation inside the accumulator so the result is the same
    for any input order.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在累加器内部使用可交换操作，因此无论输入顺序如何，结果都是相同的。
- en: Synchronization mechanisms
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 同步机制
- en: 'Synchronization of tasks is the coordination between those tasks to get the
    desired results. In concurrent applications, we can have two kinds of synchronizations:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的同步是协调这些任务以获得期望的结果。在并发应用程序中，我们可以有两种同步方式：
- en: '**Process synchronization**: We use this kind of synchronization when we want
    to control the order of execution of the tasks. For example, a task must wait
    for the finalization of other tasks before it starts its execution.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程同步**：当我们想要控制任务的执行顺序时，我们使用这种同步。例如，一个任务必须在开始执行之前等待其他任务的完成。'
- en: '**Data synchronization**: We use this kind of synchronization when two or more
    tasks access the same memory object. In this case, you have to protect the access
    in the write operations to that object. If you don''t do this, you can have a
    data race condition where the final results of a program vary from one execution
    to another.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据同步**：当两个或多个任务访问相同的内存对象时，我们使用这种同步。在这种情况下，您必须保护对该对象的写操作的访问。如果不这样做，您可能会遇到数据竞争条件，程序的最终结果会因每次执行而异。'
- en: The Java concurrency API provides mechanisms that allow you to implement both
    types of synchronization. The most basic synchronization mechanism provided by
    the Java language is the `synchronized` keyword. This keyword can be applied to
    a method or to a block of code. In the first case, only one thread can execute
    the method at a time. In the second case, you have to specify a reference to an
    object. In this case, only one block of code protected by an object can be executed
    at the same time.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供了允许您实现这两种类型同步的机制。Java语言提供的最基本的同步机制是`synchronized`关键字。这个关键字可以应用于一个方法或一段代码。在第一种情况下，只有一个线程可以同时执行该方法。在第二种情况下，您必须指定一个对象的引用。在这种情况下，只有一个由对象保护的代码块可以同时执行。
- en: 'Java also provide other synchronization mechanisms:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Java还提供其他同步机制：
- en: 'The `Lock` interface and its implementation classes: This mechanism allows
    you to implement a critical section to guarantee that only one thread will execute
    that block of code.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lock` 接口及其实现类：这种机制允许您实现一个临界区，以确保只有一个线程将执行该代码块。'
- en: The `Semaphore` class that implements the well-known **semaphore** synchronization
    mechanism introduced by *Edsger Dijkstra*.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Semaphore` 类实现了由*Edsger Dijkstra*引入的著名的**信号量**同步机制。'
- en: '`CountDownLatch` allows you to implement a situation where one or more threads
    wait for the finalization of other threads.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountDownLatch` 允许您实现一个情况，其中一个或多个线程等待其他线程的完成。'
- en: '`CyclicBarrier` allows you to synchronize different tasks in a common point.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CyclicBarrier` 允许您在一个公共点同步不同的任务。'
- en: '`Phaser` allows you to implement concurrent tasks divided into phases. We made
    a detailed description of this mechanism in [Chapter 5](part0037_split_000.html#1394Q1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 5. Running Tasks Divided into Phases – The Phaser Class"), *Running Tasks
    Divided into Phases – The Phaser Class*.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Phaser` 允许您实现分阶段的并发任务。我们在[第5章](part0037_split_000.html#1394Q1-2fff3d3b99304faa8fa9b27f1b5053ba
    "第5章。分阶段运行任务 - Phaser 类")中对这种机制进行了详细描述，*分阶段运行任务 - Phaser 类*。'
- en: '`Exchanger` allows you to implement a point of data interchange between two
    tasks.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Exchanger` 允许您在两个任务之间实现数据交换点。'
- en: '`CompletableFuture`, a new feature of Java 8, extends the `Future` mechanism
    of the executor tasks to generate the result of a task in an asynchronous way.
    You can specify tasks to be executed after the result is generated, so you can
    control the order of the execution of the tasks.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletableFuture`，Java 8的一个新特性，扩展了执行器任务的`Future`机制，以异步方式生成任务的结果。您可以指定在生成结果后要执行的任务，因此可以控制任务的执行顺序。'
- en: In the following section, we will show you how to use these mechanisms, giving
    special attention to the `CompletableFuture` mechanism introduced in the Java
    8 version.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将向您展示如何使用这些机制，特别关注Java 8版本中引入的`CompletableFuture`机制。
- en: The CommonTask class
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CommonTask 类
- en: 'We have implemented a class named the `CommonTask` class. This class will sleep
    the calling thread during a random period of time between `0` and `10` seconds.
    This is its source code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个名为`CommonTask`类的类。这个类将使调用线程在`0`和`10`秒之间的随机时间内休眠。这是它的源代码：
- en: '[PRE16]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All the tasks we're going to implement in the following sections will use this
    class to simulate its execution time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将使用这个类来模拟其执行时间。
- en: The Lock interface
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lock接口
- en: One of the most basic synchronization mechanisms is the `Lock` interface and
    its implementation classes. The basic implementation class is the `ReentrantLock`
    class. You can use this class to implement a critical section in an easy way.
    For example, the following task gets a lock in the first line of its code using
    the `lock()` method and releases it in the last line using the `unlock()` method.
    Only one task can execute the code between these two sentences at the same time.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的同步机制之一是`Lock`接口及其实现类。基本实现类是`ReentrantLock`类。您可以使用这个类来轻松实现临界区。例如，以下任务在其代码的第一行使用`lock()`方法获取锁，并在最后一行使用`unlock()`方法释放锁。在同一时间只有一个任务可以执行这两个语句之间的代码。
- en: '[PRE17]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can check this if, for example, you execute ten tasks in an executor using
    the following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以通过以下代码在执行器中执行十个任务来检查这一点：
- en: '[PRE18]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the following image, you can see the result of an execution of this example.
    You can see how only one task is executed at a time.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图片中，您可以看到这个示例的执行结果。您可以看到每次只有一个任务被执行。
- en: '![The Lock interface](img/00027.jpeg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![Lock接口](img/00027.jpeg)'
- en: The Semaphore class
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Semaphore 类
- en: The semaphore mechanism was introduced by Edsger Dijkstra in 1962 and is used
    to control the access to one or more shared resources. This mechanism is based
    on an internal counter and two methods named `wait()` and `signal()`.When a thread
    calls the `wait()` method, if the internal counter has a value bigger than 0,
    then the semaphore decrements the internal counter and the thread gets access
    to the shared resource. If the internal counter has a value of 0, the thread is
    blocked until some thread calls the `signal()` method. When a thread calls the
    `signal()` method, the semaphore looks to see whether there are some threads waiting
    in the `waiting` state (they have called the `wait()` method). If there are no
    threads waiting, it increments the internal counter. If there are threads waiting
    for the semaphore, it gets one of those threads, which will return for the `wait()`
    method and access the shared resource. The other threads that were waiting continue
    waiting for their turn.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 信号量机制是由Edsger Dijkstra于1962年引入的，用于控制对一个或多个共享资源的访问。这个机制基于一个内部计数器和两个名为`wait()`和`signal()`的方法。当一个线程调用`wait()`方法时，如果内部计数器的值大于0，那么信号量会减少内部计数器，并且线程获得对共享资源的访问。如果内部计数器的值为0，线程将被阻塞，直到某个线程调用`signal()`方法。当一个线程调用`signal()`方法时，信号量会查看是否有一些线程处于`waiting`状态（它们已经调用了`wait()`方法）。如果没有线程在等待，它会增加内部计数器。如果有线程在等待信号量，它会选择其中一个线程，该线程将返回到`wait()`方法并访问共享资源。其他等待的线程将继续等待它们的轮到。
- en: 'In Java, semaphores are implemented in the `Semaphore` class. The `wait()`
    method is called `acquire()` and the `signal()` method is called `release()`.
    For example, in this example, we have used this task where a `Semaphore` class
    is protecting its code:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，信号量是在`Semaphore`类中实现的。`wait()`方法被称为`acquire()`，`signal()`方法被称为`release()`。例如，在这个例子中，我们使用了一个`Semaphore`类来保护它的代码：
- en: '[PRE19]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the main program, we execute ten tasks that share a `Semaphore` class initialized
    with two shared resources, so we will have two tasks running at the same time.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在主程序中，我们执行了共享一个`Semaphore`类的十个任务，该类初始化了两个共享资源，因此我们将同时运行两个任务。
- en: '[PRE20]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following screenshot shows the results of an execution of this example.
    You can see how two tasks are running at the same time:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这个例子执行的结果。你可以看到两个任务同时在运行：
- en: '![The Semaphore class](img/00028.jpeg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![信号量类](img/00028.jpeg)'
- en: The CountDownLatch class
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CountDownLatch类
- en: This class provides a mechanism to wait for the finalization of one or more
    concurrent tasks. It has an internal counter that must be initialized with the
    number of tasks we are going to wait for. Then, the `await()` method sleeps the
    calling thread until the internal counter arrives at zero and the `countDown()`
    method decrements that internal counter.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了一种等待一个或多个并发任务完成的机制。它有一个内部计数器，必须初始化为我们要等待的任务数量。然后，`await()`方法使调用线程休眠，直到内部计数器到达零，`countDown()`方法减少内部计数器。
- en: For example, in this task we use the `countDown()` method to decrement the internal
    counter of the `CountDownLatch` object it receives as a parameter in its constructor.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这个任务中，我们使用`countDown()`方法来减少`CountDownLatch`对象的内部计数器，它在构造函数中接收一个参数。
- en: '[PRE21]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then, in the `main()` method, we execute the tasks in an executor and wait for
    their finalization using the `await()` method of `CountDownLatch`. The object
    is initialized with the number of tasks we want to wait for.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`main()`方法中，我们在执行器中执行任务，并使用`CountDownLatch`的`await()`方法等待它们的完成。该对象被初始化为我们要等待的任务数量。
- en: '[PRE22]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following screenshot shows the results of an execution of this example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这个例子执行的结果：
- en: '![The CountDownLatch class](img/00029.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![CountDownLatch类](img/00029.jpeg)'
- en: The CyclicBarrier class
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CyclicBarrier类
- en: This class allows you to synchronize some tasks in a common point. All tasks
    will wait in that point until all have arrived. Internally, it also manages an
    internal counter with the tasks that haven't arrived at that point yet. When a
    task arrives at the determined point, it has to execute the `await()` method to
    wait for the rest of the tasks. When all the tasks have arrived, the `CyclicBarrier`
    object wakes them up so they continue with their execution.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类允许你在一个共同点同步一些任务。所有任务都将在那个点等待，直到所有任务都到达。在内部，它还管理一个内部计数器，记录还没有到达那个点的任务。当一个任务到达确定的点时，它必须执行`await()`方法等待其余的任务。当所有任务都到达时，`CyclicBarrier`对象唤醒它们，使它们继续执行。
- en: This class allows you to execute another task when all the parties have arrived.
    To configure this, you have to specify a runnable object in the constructor of
    the object.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类允许你在所有参与方到达时执行另一个任务。要配置这个，你必须在对象的构造函数中指定一个可运行的对象。
- en: 'For example, we have implemented the following Runnable that uses a `CyclicBarrier`
    object to wait for other tasks:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们实现了以下的Runnable，它使用了一个`CyclicBarrier`对象来等待其他任务：
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have also implemented another `Runnable` object that will be executed by
    `CyclicBarrier` when all the tasks have executed the `await()` method.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了另一个`Runnable`对象，当所有任务都执行了`await()`方法时，它将被`CyclicBarrier`执行。
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, in the `main()` method, we execute ten tasks in an executor. You can
    see how `CyclicBarrier` is initialized with the number of tasks we want to synchronize
    and with an object of the `FinishBarrierTask` object:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`main()`方法中，我们在执行器中执行了十个任务。你可以看到`CyclicBarrier`是如何初始化的，它与我们想要同步的任务数量以及`FinishBarrierTask`对象一起：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following screenshot shows the results of an execution of this example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这个例子执行的结果：
- en: '![The CyclicBarrier class](img/00030.jpeg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![CyclicBarrier类](img/00030.jpeg)'
- en: You can see how when all the tasks arrive at the point where the `await()` method
    is called, `FinishBarrierTask` is executed and then all the tasks continue with
    their execution.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到当所有任务都到达调用`await()`方法的点时，`FinishBarrierTask`被执行，然后所有任务继续执行。
- en: The CompletableFuture class
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CompletableFuture类
- en: This is a new synchronization mechanism introduced in the Java 8 concurrency
    API. It extends the `Future` mechanism, giving it more power and flexibility.
    It allows you to implement an event-driving model linking tasks that will only
    be executed when others have finished. As with the `Future` interface, `CompletableFuture`
    must be parameterized with the type of the result that will be returned by the
    operation. As with a `Future` object, the `CompletableFuture` class represents
    a result of an asynchronous computation, but the result of `CompletableFuture`
    can be established by any thread. It has the `complete()` method to establish
    the result when the computation ends normally, and the method `completeExceptionally()`
    when the computation ends with an exception. If two or more threads call the `complete()`
    or `completeExceptionally()` methods over the same `CompletableFuture`, only the
    first call will take effect.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Java 8并发API中引入的一种新的同步机制。它扩展了`Future`机制，赋予它更多的功能和灵活性。它允许您实现一个事件驱动模型，链接任务，只有在其他任务完成时才会执行。与`Future`接口一样，`CompletableFuture`必须使用操作返回的结果类型进行参数化。与`Future`对象一样，`CompletableFuture`类表示异步计算的结果，但`CompletableFuture`的结果可以由任何线程建立。它具有`complete()`方法，在计算正常结束时建立结果，以及`completeExceptionally()`方法，在计算异常结束时建立结果。如果两个或更多线程在同一个`CompletableFuture`上调用`complete()`或`completeExceptionally()`方法，只有第一次调用会生效。
- en: First, you can create `CompletableFuture` using its constructor. In this case,
    you have to establish the result of the task using the `complete()` method as
    we explained before. But you can also create one using the `runAsync()` or `supplyAsync()`
    methods. The `runAsync()` method executes a `Runnable` object and returns `CompletableFuture<Void>`
    so that computation can't return any result. The `supplyAsync()` method executes
    an implementation of the `Supplier` interface parametrized with the type that
    will be returned by this computation. The `Supplier` interface provides the `get()`
    method. In that method, we have to include the code of the task and return the
    result generated by it. In this case, the result of `CompletableFuture` will be
    the result of the `Supplier` interface.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以使用其构造函数创建`CompletableFuture`。在这种情况下，您必须使用`complete()`方法来建立任务的结果，就像我们之前解释的那样。但您也可以使用`runAsync()`或`supplyAsync()`方法来创建一个。`runAsync()`方法执行一个`Runnable`对象并返回`CompletableFuture<Void>`，因此计算不会返回任何结果。`supplyAsync()`方法执行一个`Supplier`接口的实现，该接口参数化了此计算将返回的类型。`Supplier`接口提供`get()`方法。在该方法中，我们必须包含任务的代码并返回其生成的结果。在这种情况下，`CompletableFuture`的结果将是`Supplier`接口的结果。
- en: 'This class provides a lot of methods that allow you to organize the order of
    execution of tasks implementing an event-driving model where one task doesn''t
    start its execution until a previous one has finished. These are some of those
    methods:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了许多方法，允许您组织任务的执行顺序，实现一个事件驱动模型，其中一个任务直到前一个任务完成后才开始执行。以下是其中一些方法：
- en: '`thenApplyAsync()`: This method receives as a parameter an implementation of
    the `Function` interface that can be represented as a lambda expression. This
    function will be executed when the calling `CompletableFuture` has been completed.
    This method will return `CompletableFuture` to get the result of the `Function`.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenApplyAsync()`: 这个方法接收`Function`接口的实现作为参数，可以表示为lambda表达式。当调用的`CompletableFuture`完成时，将执行此函数。此方法将返回`CompletableFuture`以获取`Function`的结果。'
- en: '`thenComposeAsync()`: This method is analogous to `thenApplyAsync`, but is
    useful when the supplied function returns `CompletableFuture` too.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenComposeAsync()`: 这个方法类似于`thenApplyAsync`，但在提供的函数也返回`CompletableFuture`时很有用。'
- en: '`thenAcceptAsync()`: This method is similar to the previous one but the parameter
    is an implementation of the `Consumer` interface that can be also specified as
    a lambda expression; in this case, the computation won''t return a result.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenAcceptAsync()`: 这个方法类似于前一个方法，但参数是`Consumer`接口的实现，也可以指定为lambda表达式；在这种情况下，计算不会返回结果。'
- en: '`thenRunAsync()`: This method is equivalent to the previous one but in this
    case receives a `Runnable` object as a parameter.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenRunAsync()`: 这个方法与前一个方法相同，但在这种情况下，它接收一个`Runnable`对象作为参数。'
- en: '`thenCombineAsync()`: This method receives two parameters. The first one is
    another `CompletableFuture` instance. The other is an implementation of the `BiFunction`
    interfaces that can be specified as a lambda function. This `BiFunction` will
    be executed when both `CompletableFuture` (the calling one and the parameter)
    have been completed. This method will return `CompletableFuture` to get the result
    of the `BiFunction`.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thenCombineAsync()`: 这个方法接收两个参数。第一个是另一个`CompletableFuture`实例。另一个是`BiFunction`接口的实现，可以指定为lambda函数。当两个`CompletableFuture`（调用方和参数）都完成时，将执行此`BiFunction`。此方法将返回`CompletableFuture`以获取`BiFunction`的结果。'
- en: '`runAfterBothAsync()`: This method receives two parameters. The first one is
    another `CompletableFuture`. The other is an implementation of the `Runnable`
    interface that will be executed when both `CompletableFuture` (the calling one
    and the parameter) have been completed.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runAfterBothAsync()`: 这个方法接收两个参数。第一个是另一个`CompletableFuture`。另一个是`Runnable`接口的实现，当两个`CompletableFuture`（调用方和参数）都完成时将执行。'
- en: '`runAfterEitherAsync()`: This method is equivalent to the previous one, but
    the Runnable task is executed when one of the `CompletableFuture` objects is completed.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runAfterEitherAsync()`: 这个方法等同于前一个方法，但当`CompletableFuture`对象之一完成时，将执行`Runnable`任务。'
- en: '`allOf()`: This method receives as a parameter a variable list of `CompletableFuture`
    objects. It will return a `CompletableFuture<Void>` object that will return its
    result when all the `CompletableFuture` objects have been completed.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allOf()`: 这个方法接收一个`CompletableFuture`对象的可变列表作为参数。它将返回一个`CompletableFuture<Void>`对象，当所有`CompletableFuture`对象都完成时，它将返回其结果。'
- en: '`anyOf()`: This method is equivalent to the previous one, but the returned
    `CompletableFuture` returns its result when one of the `CompletableFuture` is
    completed.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`anyOf()`: 这个方法等同于前一个方法，但是返回的`CompletableFuture`在其中一个`CompletableFuture`完成时返回其结果。'
- en: Finally, if you want to obtain the result returned by `CompletableFuture`, you
    can use the `get()` or `join()` methods. Both methods block the calling thread
    until `CompletableFuture` has been completed and then returns its result. The
    main difference between both methods is that `get()` throws `ExecutionException`,
    which is a checked exception, but `join()` throws `RuntimeException` (which is
    an unchecked exception). Thus, it's easier to use `join()` inside non-throwing
    lambdas (like `Supplier`, `Consumer`, or `Runnable`).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想要获取`CompletableFuture`返回的结果，你可以使用`get()`或`join()`方法。这两种方法都会阻塞调用线程，直到`CompletableFuture`完成并返回其结果。这两种方法之间的主要区别在于，`get()`会抛出`ExecutionException`，这是一个受检异常，而`join()`会抛出`RuntimeException`（这是一个未检查的异常）。因此，在不抛出异常的lambda表达式（如`Supplier`、`Consumer`或`Runnable`）中使用`join()`更容易。
- en: Most of the methods explained before have the `Async` suffix. This means that
    these methods will be executed in a concurrent way using the `ForkJoinPool.commonPool`
    instance. Those methods that have versions without the `Async` suffix will be
    executed in a serial way (that is to say, in the same thread where `CompletableFuture`
    is executed) and with the `Async` suffix and an executor instance as an additional
    parameter. In this case, `CompletableFuture` will be executed asynchronously in
    the executor passed as a parameter.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 前面解释的大部分方法都有`Async`后缀。这意味着这些方法将使用`ForkJoinPool.commonPool`实例以并发方式执行。那些没有`Async`后缀版本的方法将以串行方式执行（也就是说，在执行`CompletableFuture`的同一个线程中），而带有`Async`后缀和一个执行器实例作为额外参数。在这种情况下，`CompletableFuture`将在传递的执行器中异步执行。
- en: Using the CompletableFuture class
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用CompletableFuture类
- en: 'In this example, you will learn how to use the `CompletableFuture` class to
    implement the execution of some asynchronous tasks in a concurrent way. We will
    use our collection of 20,000 products of Amazon to implement the following tree
    of tasks:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您将学习如何使用`CompletableFuture`类以并发方式实现一些异步任务的执行。我们将使用亚马逊的2万个产品集合来实现以下任务树：
- en: '![Using the CompletableFuture class](img/00031.jpeg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![使用CompletableFuture类](img/00031.jpeg)'
- en: First, we're going to use the examples. Then, we will execute four concurrent
    tasks. The first one will make a search of products. When the search finishes,
    we will write the results to a file. The second one will obtain the best-rated
    product. The third one will obtain the best-selling product. When these both finish,
    we will concatenate their information using another task. Finally, the fourth
    task will get a list with the users who have purchased a product. The `main()`
    program will wait for the finalization of all the tasks and then will write the
    results.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用这些例子。然后，我们将执行四个并发任务。第一个任务将搜索产品。当搜索完成时，我们将把结果写入文件。第二个任务将获取评分最高的产品。第三个任务将获取销量最高的产品。当这两个任务都完成时，我们将使用另一个任务来连接它们的信息。最后，第四个任务将获取购买了产品的用户列表。`main()`程序将等待所有任务的完成，然后写入结果。
- en: Let's see the details of the implementation.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现的细节。
- en: Auxiliary tasks
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 辅助任务
- en: In this example, we will use some auxiliary tasks. The first one is `LoadTask`,
    which will load the product information from the disk and will return a list of
    `Product` objects.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用一些辅助任务。第一个是`LoadTask`，它将从磁盘加载产品信息，并返回一个`Product`对象的列表。
- en: '[PRE26]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: It implements the `Supplier` interface to be executed as `CompletableFuture`.
    Inside, it uses a stream to process and parse all the files obtaining a list of
    products.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 它实现了`Supplier`接口以作为`CompletableFuture`执行。在内部，它使用流来处理和解析所有文件，获取产品列表。
- en: The second task is `SearchTask`, which will implement the search in the list
    of `Product` objects, looking for the ones that contain a word in the title. This
    task is an implementation of the `Function` interface.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个任务是`SearchTask`，它将在`Product`对象列表中实现搜索，查找标题中包含某个词的产品。这个任务是`Function`接口的实现。
- en: '[PRE27]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It receives `List<Product>` with the information of all the products a return
    `List<Product>` with the products that meet the criteria. Internally, it creates
    the stream on the input list, filters it, and collects the result to another list.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收包含所有产品信息的`List<Product>`，并返回符合条件的产品的`List<Product>`。在内部，它在输入列表上创建流，对其进行过滤，并将结果收集到另一个列表中。
- en: 'Finally, the `WriteTask` is going to write the products obtained in the search
    task in a `File`. In our case, we generate an HTML file, but feel free to write
    this information in the format you want. This task implements the `Consumer` interface,
    so its code must be something like the follow:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`WriteTask`将把搜索任务中获取的产品写入一个`File`。在我们的例子中，我们生成了一个HTML文件，但是可以随意选择其他格式来写入这些信息。这个任务实现了`Consumer`接口，所以它的代码应该类似于下面这样：
- en: '[PRE28]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The main() method
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: main()方法
- en: We have organized the execution of the tasks in the `main()` method. First,
    we execute the `LoadTask` using the `supplyAsync()` method of the `CompletableFuture`
    class.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`main()`方法中组织了任务的执行。首先，我们使用`CompletableFuture`类的`supplyAsync()`方法执行`LoadTask`。
- en: '[PRE29]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Then, with the resultant `CompletableFuture`, we use `thenApplyAsync()` to execute
    the search task when the load task has been completed.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用结果的`CompletableFuture`，我们使用`thenApplyAsync()`在加载任务完成后执行搜索任务。
- en: '[PRE30]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Once the search task has been completed, we want to write the results of the
    execution in a file. As this task won''t return a result, we use the `thenAcceptAsync()`
    method:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦搜索任务完成，我们希望将执行结果写入文件。由于这个任务不会返回结果，我们使用了`thenAcceptAsync()`方法：
- en: '[PRE31]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have used the exceptionally() method to specify what we want to do if the
    write task throws an exception.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了exceptionally()方法来指定当写入任务抛出异常时我们想要做什么。
- en: Then, we use the `thenApplyAsync()` method over the `completableFuture` object
    to execute the task to get the list of users who purchased a product. We specify
    this task as a lambda expression. Take into account that this task will be executed
    in parallel with the search task.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`completableFuture`对象上使用`thenApplyAsync()`方法执行任务，以获取购买产品的用户列表。我们将此任务指定为lambda表达式。请注意，此任务将与搜索任务并行执行。
- en: '[PRE32]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In parallel with these tasks, we also executed the tasks using the `thenApplyAsync()`
    method to find the best-rated product and the best-selling product. We have defined
    these tasks using a lambda expression too.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些任务并行进行的是，我们还使用`thenApplyAsync()`方法执行任务，以找到最受欢迎的产品和最畅销的产品。我们也使用lambda表达式定义了这些任务。
- en: '[PRE33]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we mentioned before, we want to concatenate the results of the last two tasks.
    We can do this using the `thenCombineAsync()` method to specify a task that will
    be executed after both tasks have been completed.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们希望连接最后两个任务的结果。我们可以使用`thenCombineAsync()`方法来指定一个任务，在两个任务都完成后执行。
- en: '[PRE34]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, we wait for the end of the final tasks using the `allOf()` and `join()`
    methods and write the results using the `get()` method to obtain them.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`allOf()`和`join()`方法等待最终任务的结束，并使用`get()`方法编写结果以获取它们。
- en: '[PRE35]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the following screenshot, you can see the results of an execution of this
    example:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，您可以看到此示例的执行结果：
- en: '![The main() method](img/00032.jpeg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![main()方法](img/00032.jpeg)'
- en: First, the `main()` method executes all the configuration and waits for the
    finalization of the tasks. The execution of the tasks follows the order we have
    configured.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`main()`方法执行所有配置并等待任务的完成。任务的执行遵循我们配置的顺序。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have reviewed two components of all concurrent applications.
    The first one is data structures. Every program uses them to store in memory the
    information it has to process. We have quickly been introduced to the concurrent
    data structures to make a detailed description of the new features introduced
    in the Java 8 Concurrency API that affect the `ConcurrentHashMap` class and the
    classes that implement the `Collection` interface.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了并发应用程序的两个组件。第一个是数据结构。每个程序都使用它们来存储需要处理的信息。我们已经快速介绍了并发数据结构，以便详细描述Java
    8并发API中引入的新功能，这些功能影响了`ConcurrentHashMap`类和实现`Collection`接口的类。
- en: The second one is the synchronization mechanisms that allow you to protect your
    data when more than one concurrent task wants to modify them, and to control the
    order of execution of the tasks if necessary. In this case, we have also quickly
    been introduced to the synchronization mechanisms, giving a detailed description
    of `CompletableFuture`, a new feature of the Java 8 concurrency API.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是同步机制，允许您在多个并发任务想要修改数据时保护数据，并在必要时控制任务的执行顺序。在这种情况下，我们也快速介绍了同步机制，并详细描述了`CompletableFuture`，这是Java
    8并发API的一个新功能。
- en: In the next chapter, we will show you how you can implement complete concurrent
    systems integrating the different parts that can also be concurrent and using
    different classes to implement its concurrency.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向您展示如何实现完整的并发系统，集成也可以是并发的不同部分，并使用不同的类来实现其并发性。
