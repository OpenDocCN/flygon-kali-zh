- en: Working with Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用微服务
- en: After reading the previous two chapters, you should now have an understanding
    of the Docker architecture and its concepts. Before we go further on our Java,
    Docker, and Kubernetes journey, let's get to know the concept of microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读前两章之后，您现在应该对Docker架构及其概念有所了解。在我们继续Java、Docker和Kubernetes之旅之前，让我们先了解一下微服务的概念。
- en: By reading this chapter, you will find out why a transition to microservices
    and cloud development is necessary and why monolithic architecture is not an option
    anymore. The microservices architecture is also where Docker and Kubernetes will
    be especially useful.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本章，您将了解为什么转向微服务和云开发是必要的，以及为什么单片架构不再是一个选择。微服务架构也是Docker和Kubernetes特别有用的地方。
- en: 'This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to microservices and comparison to a monolithic architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务简介和与单片架构的比较
- en: How Docker and Kubernetes fits into the microservices world
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker和Kubernetes如何适应微服务世界
- en: When to use microservices architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用微服务架构
- en: Before we actually create the Java microservice and deploy it using Docker and
    Kubernetes, let's start with an explanation of the microservices idea and compare
    it to the monolithic architecture.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际创建Java微服务并使用Docker和Kubernetes部署之前，让我们先解释一下微服务的概念，并将其与单片架构进行比较。
- en: An introduction to microservices
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务简介
- en: By definition, microservices, also known as the **Microservice Architecture**
    (**MSA** ), is an architectural style and design pattern which says that an application
    should consist of a collection of loosely-coupled services. This architecture
    decomposes business domain models into smaller, consistent pieces implemented
    by services. In other words, each of the services will have its own responsibilities,
    independent of others, each one of them will provide a specific functionality.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，微服务，也称为**微服务架构**（**MSA**），是一种架构风格和设计模式，它认为一个应用程序应该由一组松散耦合的服务组成。这种架构将业务领域模型分解为由服务实现的较小、一致的部分。换句话说，每个服务都将有自己的责任，独立于其他服务，每个服务都将提供特定的功能。
- en: These services should be isolated and autonomous. Yet, they of course need to
    communicate to provide some piece of business functionality. They usually communicate
    using `REST` exposures or by publishing and subscribing events in the publish/subscribe
    way.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务应该是孤立的和自治的。然而，它们当然需要通信以提供一些业务功能。它们通常使用`REST`暴露或通过发布和订阅事件的方式进行通信。
- en: The best way of explaining the reasoning behind the idea of microservices is
    to compare them with an old, traditional approach for building large applications,
    the monolithic design.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 解释微服务背后理念的最好方式是将其与构建大型应用程序的旧传统方法——单片设计进行比较。
- en: 'Take a look at the following diagram presenting the monolithic application
    and distributed application consisting of microservices:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下下面的图表，展示了单片应用程序和由微服务组成的分布式应用程序。
- en: '![](Image00056.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00056.jpg)'
- en: As you can see on the previous diagram, the monolithic application differs totally
    from an application created using the microservices architecture. Let's compare
    the two approaches and point out their advantages and flaws.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一个图表中所看到的，单片应用程序与使用微服务架构创建的应用程序完全不同。让我们比较这两种方法，并指出它们的优点和缺点。
- en: Monolithic versus microservices
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单片与微服务
- en: We begin the comparison by starting with the description of the monolithic architecture
    to present its characteristics.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从描述单片架构开始比较，以展示其特点。
- en: The monolithic architecture
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单片架构
- en: 'In the past, we used to create applications as complete, massive, and uniform
    pieces of code. Let''s take a web MVC application for example. A simplified architecture
    of such an application is presented in the following diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，我们习惯于创建完整、庞大和统一的代码片段作为应用程序。以Web MVC应用程序为例。这种应用程序的简化架构如下图所示：
- en: '![](Image00057.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00057.jpg)'
- en: 'As you can see, the diagram presents the typical web application, a fragment
    of a banking system in this case. It''s the **Model** **View Controller** (**MVC**
    ) application, consisting of models, views, and controllers to serve up HTML content
    back to the client''s browser. It could probably also accept and send the JSON
    content via the REST endpoints. This kind of an application is built as a single
    unit. As you can see, we have a couple of layers here. Enterprise Applications
    are built in three parts usually: a client-side user interface (consisting of
    HTML pages and JavaScript running in a browser), a server-side part handling the
    `HTTP` requests (probably constructed using some spring-like controllers), then
    we have a service layer, which could probably be implemented using EJBs or Spring
    services. The service layer executes the domain specific business logic, and retrieves/updates
    data in the database, eventually. This is a very typical web application which
    every one of us has probably created once in a while. The whole application is
    a monolith, a single logical executable. To make any changes to the system, we
    must build and deploy an updated version of the whole server-side application;
    this kind of application is packaged into single WAR or EAR archive, altogether
    with all the static content such as HTML and JavaScript files. When deployed,
    all the application code runs in the same machine. Scaling this kind of application
    usually requires deploying multiple copies of the exact same application code
    to multiple machines in a cluster, behind some load balancer perhaps.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，该图表展示了典型的网络应用程序，这里是银行系统的一个片段。这是一个**模型** **视图** **控制器**（**MVC**）应用程序，由模型、视图和控制器组成，用于向客户端浏览器提供HTML内容。它可能还可以通过REST端点接受和发送JSON内容。这种应用程序是作为一个单一单元构建的。正如你所看到的，我们在这里有几个层。企业应用程序通常分为三个部分：客户端用户界面（包括在浏览器中运行的HTML页面和JavaScript）、处理`HTTP`请求的服务器端部分（可能使用类似spring的控制器构建），然后我们有一个服务层，可能使用EJB或Spring服务来实现。服务层执行特定领域的业务逻辑，并最终检索/更新数据库中的数据。这是一个非常典型的网络应用程序，我们每个人可能都曾经创建过。整个应用程序是一个单体，一个单一的逻辑可执行文件。要对系统进行任何更改，我们必须构建和部署整个服务器端应用程序的更新版本；这种应用程序通常打包成单个WAR或EAR存档，连同所有静态内容，如HTML和JavaScript文件一起。一旦部署，所有应用程序代码都在同一台机器上运行。通常情况下，要扩展这种应用程序，需要在集群中的多台机器上部署多个相同的应用程序代码副本，可能在某个负载均衡器后面。
- en: This design wasn't too bad, we had our applications up and running, after all.
    But the world, especially when using Agile methodologies, changes fast. Businesses
    have started asking to release software faster than ever. ASAP has become a very
    common word in the IT development language dictionary. The specification fluctuates,
    so the code changes often and grows over time. If the team working on the application
    is large (and it probably will be in case of complex, huge applications) everyone
    must be very careful not to destroy each other's work. With every added feature,
    our applications become more and more complex. The compile and build times become
    longer, sooner or later it will become tricky to test the whole thing using unit
    or integration tests. Also, the point of entry for new members coming to the team
    can be daunting, they will need to checkout the whole project from the source
    code repository. Then they need to build it in their IDE (which is not always
    that easy in case of huge applications), and analyze and understand the component
    structure to get their job done. Additionally, people working on the user interface
    part will need to communicate with developers working on the middle-tier, with
    people modelling the database, DBAs, and so on. The team structure will often
    begin to mimic the application architecture over time. There's a risk that a developer
    working on the specific layer will tend to put as much logic into the layer he
    controls as he can. As a result, the code can become unmaintainable over time.
    We all have been there and done that, haven't we?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计并不算太糟糕，毕竟我们的应用程序已经上线运行了。但是，世界变化很快，特别是在使用敏捷方法论的时候。企业已经开始要求比以往更快地发布软件。尽快成为IT开发语言词典中非常常见的词语。规格经常波动，所以代码经常变化并随着时间增长。如果团队规模庞大（在复杂的大型应用程序的情况下可能会是这样），每个人都必须非常小心，不要破坏彼此的工作。随着每个新增的功能，我们的应用程序变得越来越复杂。编译和构建时间变得更长，迟早会变得棘手，使用单元测试或集成测试来测试整个系统。此外，新成员加入团队的入口点可能令人望而生畏，他们需要从源代码存储库中检出整个项目。然后他们需要在他们的集成开发环境中构建它（在大型应用程序的情况下并不总是那么容易），并分析和理解组件结构以完成他们的工作。此外，负责用户界面部分的人需要与负责中间层的开发人员、数据库建模人员、数据库管理员等进行沟通。随着时间的推移，团队结构往往会开始模仿应用程序架构。有风险，即特定层上的开发人员倾向于尽可能多地将逻辑放入他所控制的层中。结果，随着时间的推移，代码可能变得难以维护。我们都曾经历过这种情况，对吧？
- en: 'Also, the scaling of monolithic systems is not as easy as putting a WAR or
    EAR in another application server and then booting it. Because all the application
    code runs in the same process on the server, it''s often almost impossible to
    scale individual portions of the application. Take this example: we have an application
    which integrates with the VOIP external service. We don''t have many users of
    our application, but then there is a lot of events coming from the VOIP service
    we need to process. To handle the increasing load, we need to scale our application
    and, in the case of a monolithic system, we need to scale the whole system. That''s
    because the application is a single, big, working unit. If just one of the application''s
    services is CPU or resource hungry, the whole server must be provisioned with
    enough memory and CPU to handle the load. This can be expensive. Every server
    needs a fast CPU and enough RAM to be able to run the most demanding component
    of our application.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，单片系统的扩展并不像将WAR或EAR放入另一个应用服务器然后启动那么容易。因为所有应用代码都在服务器上的同一个进程中运行，通常几乎不可能扩展应用程序的各个部分。举个例子：我们有一个集成了VOIP外部服务的应用程序。我们的应用程序用户不多，但是来自VOIP服务的事件却很多，我们需要处理。为了处理不断增加的负载，我们需要扩展我们的应用程序，在单片系统的情况下，我们需要扩展整个系统。这是因为应用程序是一个单一的、庞大的工作单元。如果应用程序的一个服务是CPU或资源密集型的，整个服务器必须配备足够的内存和CPU来处理负载。这可能很昂贵。每个服务器都需要一个快速的CPU和足够的RAM来运行我们应用程序中最苛刻的组件。
- en: 'All monolithic applications have these characteristics:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所有单片应用程序都具有以下特点：
- en: They are rather large, often involving a lot of people working on them. This
    can be a problem when loading your project into the IDE, despite having powerful
    machines and a great development environment, such as IntelliJ IDEA, for example.
    But it's not only about the hundreds, thousands, or millions of lines of code.
    It's about the complexity of the solution, such as communication problems between
    team members. Problems with communication could lead to multiple solutions for
    the same problem in different parts of the application. And this will make it
    even bigger, it can easily evolve into a big ball of mud where no one can understand
    the whole system any longer. Moreover, people can be afraid of introducing substantial
    changes to the system, because something at an opposite end could suddenly stop
    working. Too bad if this is reported by the users, on a production system.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常很大，经常涉及许多人参与其中。这可能是一个问题，当将项目加载到IDE中时，尽管拥有强大的机器和出色的开发环境，比如IntelliJ IDEA。但问题不仅仅在于数百、数千或数百万行代码。它还涉及解决方案的复杂性，比如团队成员之间的沟通问题。沟通问题可能导致在应用程序的不同部分针对同一个问题出现多种解决方案。这将使问题变得更加复杂，很容易演变成一个无人能够理解整个系统的大团团乱。此外，人们可能害怕对系统进行重大更改，因为在相反的一端可能会突然停止工作。如果这是由用户在生产系统上报告的，那就太糟糕了。
- en: They have a long release cycle, we all know the process of release management,
    permissions, regression testing, and so on. It's almost impossible to create a
    continuous delivery flow having a huge, monolith application.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们有一个长的发布周期，我们都知道发布管理、权限、回归测试等流程。几乎不可能在一个庞大的单片应用程序中创建持续交付流程。
- en: They are difficult to scale; it typically takes a considerable amount of work
    to put in a new application instance in the cluster by the operations team. Scaling
    the specific feature is impossible, the only option you have is to multiply the
    instances of the whole system in the cluster. This makes scaling up and down a
    big challenge.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们很难扩展；通常需要运维团队投入大量工作来在集群中增加一个新的应用实例。扩展特定功能是不可能的，你唯一的选择就是在集群中增加整个系统的实例。这使得扩展变得非常具有挑战性。
- en: In case of deployment failure, the whole system is unavailable.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在部署失败的情况下，整个系统将不可用。
- en: You are locked into the specific programming language or technology stack. Of
    course, with Java, parts of the system can be developed in one or more languages
    that run on JVM, such as Scala, Kotlin, or Groovy, but if you need to integrate
    with a `.net` library, here begins the trouble. This also means that you will
    not always be able to use the right tool for the job. Imagine a scenario in which
    you would like to store a lot of complex documents in the database. They often
    have different structures. MongoDB as a document database should be suitable,
    right? Yes, but our system is running on Oracle.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你被锁定在特定的编程语言或技术栈中。当然，使用Java，系统的部分可以用在JVM上运行的一个或多个语言开发，比如Scala、Kotlin或Groovy，但如果你需要与`.net`库集成，问题就开始了。这也意味着你不总是能够使用合适的工具来完成工作。想象一下，你想在数据库中存储大量复杂的文档。它们通常有不同的结构。作为文档数据库的MongoDB应该是合适的，对吧？是的，但我们的系统正在运行Oracle。
- en: It's not well suited well for agile development processes, where we need to
    implement changes all the time, release to production almost at once, and be ready
    for the next iteration.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不太适合敏捷开发过程，在这种过程中，我们需要不断实施变更，几乎立即发布到生产环境，并准备好进行下一次迭代。
- en: 'As you can see, monolithic applications are only good for small scale teams
    and small projects. If you need something that has a larger scale and involves
    many teams, it''s better to look at the alternative. But what to do with the existing
    monolithic system you may enjoy dealing with? You may realize that it can be handy
    to outsource some parts of the system outside, into small services. This will
    speed up the development process and increase testability. It will also make you
    application easier to scale. While the monolithic application still retains the
    core functionality, many pieces can be outsourced into small side services supporting
    the core module. This approach is presented in the following diagram:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，单体应用只适用于小规模团队和小型项目。如果你需要一个更大规模并涉及多个团队的系统，最好看看其他选择。但是对于现有的单体系统，你可能喜欢处理它，该怎么办呢？你可能会意识到，将系统的一些部分外包到小服务中可能会很方便。这将加快开发过程并增加可测试性。它还将使你的应用程序更容易扩展。虽然单体应用仍保留核心功能，但许多部分可以外包到支持核心模块的小边缘服务中。这种方法在下图中呈现：
- en: '![](Image00058.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00058.jpg)'
- en: In this, let's say intermediary solution, the main business logic will stay
    in your application monolith. Things such as integrations, background jobs, or
    other small subsystems that can be triggered by messages, for example, can be
    moved to their own services. You can even put those services into the cloud, to
    limit the necessity for managing infrastructure around them even further. This
    approach allows you to gradually move your existing monolith application into
    a fully service-oriented architecture. Let's look at the microservices approach.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种中间解决方案中，主要业务逻辑将保留在你的应用程序单体中。诸如集成、后台作业或其他可以通过消息触发的小子系统等事物可以移动到它们自己的服务中。你甚至可以将这些服务放入云中，以进一步减少管理基础设施的必要性。这种方法允许你逐渐将现有的单体应用程序转变为完全面向服务的架构。让我们来看看微服务的方法。
- en: The microservices architecture
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构
- en: 'The microservices architecture is designed to address the issues we''ve mentioned
    with monolithic applications. The main difference is that the services defined
    in the monolithic application are decomposed into individual services. Best of
    all, they are deployed separately from one another on separate hosts. Take a look
    at the following diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构旨在解决我们提到的单片应用程序的问题。主要区别在于单片应用程序中定义的服务被分解为单独的服务。最重要的是，它们是分别部署在不同的主机上的。看一下下面的图表：
- en: '![](Image00059.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00059.jpg)'
- en: When creating an application using the microservices architecture, each microservice
    is responsible for a single, specific business function and contains only the
    implementation that is required to perform exactly that specific business logic.
    It's same as a **divide** and **conquer** way of creating a system. This may seem
    similar to the SOA-oriented architecture. In fact, traditional SOA and microservices
    architecture share some common features. Both organize fragments of the application
    into services and both define clear boundaries at which a service can be decoupled
    from the other. SOA, however, has its roots in the need to integrate monolithic
    applications with another one. This has been done, usually, using an API that
    was usually SOAP-based, using heavy XML messaging. In SOA, this integration was
    relying heavily on some kind of middleware in between, usually **Enterprise Service
    Bus** (**ESB** ). Microservices architecture can also utilize the message bus,
    with significant differences. In microservices architecture there is no logic
    in the messaging layer at all, it is purely used as a transport for messages from
    one service to another. This is a total contrast to ESB, which needed a lot of
    logic for message routing, schema validation, message translation, and so on.
    As a result, microservices architecture is less cumbersome than traditional SOA.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构创建应用程序时，每个微服务负责单一的、特定的业务功能，并且只包含执行该特定业务逻辑所需的实现。这与创建系统的“分而治之”的方式相同。这似乎与面向SOA的架构相似。事实上，传统的SOA和微服务架构有一些共同的特点。两者都将应用程序的片段组织成服务，并且都定义了清晰的边界，服务可以在其中与其他服务解耦。然而，SOA起源于需要将单片应用程序与另一个应用程序集成起来。通常情况下，这是通过通常基于SOAP的API完成的，使用繁重的XML消息传递。在SOA中，这种集成在中间通常严重依赖某种中间件，通常是企业服务总线（ESB）。微服务架构也可以利用消息总线，但有显著的区别。在微服务架构中，消息层中根本没有逻辑，它纯粹用作从一个服务到另一个服务的消息传输。这与ESB形成了鲜明对比，ESB需要大量的逻辑来进行消息路由、模式验证、消息转换等。因此，微服务架构比传统的SOA更不繁琐。
- en: When it comes to scaling, there's a huge difference when comparing microservices
    to monolithic applications. The key advantage of microservices is that a single
    service can be scaled individually, depending on the resource requirements. That's
    because they are self-sufficient and independent. As a microservice is usually
    deployed on smaller (in terms of resources) host; the host needs to contain only
    resources that are required for a service to function properly. As the resource
    requirement grows, scaling is easy both ways, horizontally and vertically. To
    scale horizontally, you just deploy as many instances as you need to handle load
    on a specific component.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展方面，将微服务与单片应用程序进行比较时存在巨大的差异。微服务的关键优势在于单个服务可以根据资源需求进行独立扩展。这是因为它们是自给自足的和独立的。由于微服务通常部署在资源较小的主机上，主机只需要包含服务正常运行所需的资源。随着资源需求的增长，横向和纵向扩展都很容易。要进行横向扩展，只需部署所需数量的实例来处理特定组件的负载。
- en: We will get back to this concept in the coming chapters, when we will be getting
    to know Kubernetes. Scaling vertically is also a lot easier and cheaper in comparison
    to the monolithic systems, you upgrade only a host on which your microservice
    is being deployed. Also, introducing new versions of the service is easy, you
    don't need to stop the whole system just to upgrade a piece of functionality.
    In fact, you can do it on the fly. When deployed, microservices improve the fault
    tolerance for the entire application. For example, if there is a memory leak in
    one service or some other problem, only this service will be affected and can
    then be fixed and upgraded without interfering with the rest of the system. This
    is not the case with monolithic architecture, where one faulty component can bring
    down the entire application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，当我们开始了解Kubernetes时，我们将回到这个概念。与单片系统相比，垂直扩展也更容易和更便宜，您只需升级部署微服务的主机。此外，引入服务的新版本也很容易，您不需要停止整个系统只是为了升级某个功能。事实上，您可以在运行时进行。部署后，微服务提高了整个应用程序的容错能力。例如，如果一个服务出现内存泄漏或其他问题，只有这个服务会受到影响，然后可以修复和升级，而不会干扰其他部分系统。这在单片架构中并非如此，那里一个故障组件可能会导致整个应用程序崩溃。
- en: From a developer's perspective, having your application split into separate
    pieces deployed individually gives a huge advantage. A developer skilled in server-side
    JavaScript can develop its piece `node.js` , while the rest of the system will
    be developed in Java. It's all related to the API exposed by each microservice;
    apart from this API, each microservice doesn't need to know anything about the
    rest of the services. This makes the development process a lot easier. Separate
    microservices can be developed and tested independently. Basically, the microservices
    approach dictates that instead of having one giant code base that all developers
    are working on, which often becomes tricky to manage, there are several smaller
    code bases managed by small and agile teams. The only dependency services have
    on one another is their exposed APIs. There's a difference in storing data as
    well. As we have said before, each microservice should be responsible for storing
    its own data, because again, it should be independent. This leads to another feature
    of the microservices architecture, a possibility to have a polyglot persistence.
    Microservices should own their data.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从开发者的角度来看，将应用程序拆分为单独部署的独立组件具有巨大优势。精通服务器端JavaScript的开发者可以开发其`node.js`部分，而系统的其余部分将使用Java开发。这一切都与每个微服务暴露的API有关；除了这个API，每个微服务都不需要了解其他服务的任何信息。这使得开发过程变得更加容易。单独的微服务可以独立开发和测试。基本上，微服务的方法规定，不是所有开发者都在一个庞大的代码库上工作，而是由小而敏捷的团队管理的几个较小的代码库。服务之间唯一的依赖是它们暴露的API。存储数据也有所不同。正如我们之前所说，每个微服务应该负责存储自己的数据，因为它应该是独立的。这导致了微服务架构的另一个特性，即具有多语言持久性的可能性。微服务应该拥有自己的数据。
- en: While microservices communicate and exchange data with other microservices using
    REST endpoints or events, they can store their own data in the form that is best
    suitable for the job. If the data is relational, the service will be using a traditional,
    relational database such as MySQL or PostgreSQL. If a document database is better
    suited for the job, a microservice can use MongoDB for example, or Neo4j if it's
    graph as data. That leads to another conclusion, by implementing the microservices
    architecture we can now only choose the programming language or framework that
    will be best suited for the job, this applies to the data storage as well. Of
    course, having its own data can lead to a challenge in the microservices architecture,
    data consistency. We are going to cover this subject in a while in this chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务之间使用REST端点或事件进行通信和数据交换，它们可以以最适合工作的形式存储自己的数据。如果数据是关系型的，服务将使用传统的关系型数据库，如MySQL或PostgreSQL。如果文档数据库更适合工作，微服务可以使用例如MongoDB，或者如果是图形数据，可以使用Neo4j。这导致另一个结论，通过实施微服务架构，我们现在只能选择最适合工作的编程语言或框架，这也适用于数据存储。当然，拥有自己的数据可能会导致微服务架构中的一个挑战，即数据一致性。我们将在本章稍后讨论这个主题。
- en: 'Let''s summarize the benefits of using the microservices architecture from
    the development process perspective:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从开发过程的角度总结使用微服务架构的好处：
- en: Services can be written using a variety of languages, frameworks, and their
    versions
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可以使用各种语言、框架及其版本进行编写
- en: Each microservice is relatively small, easier to understand by the developer
    (which results in less bugs), easy to develop, and testable
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务相对较小，更容易被开发人员理解（从而减少错误），易于开发和可测试
- en: The deployment and start up time is fast, which makes developers more productive
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和启动时间快，这使开发人员更加高效
- en: Each service can consist of multiple service instances for increased throughput
    and availability
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每项服务可以由多个服务实例组成，以增加吞吐量和可用性
- en: Each service can be deployed independently of other services, easier to deploy
    new versions of services frequently
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务可以独立部署，更容易频繁部署新版本的服务
- en: It is easier to organize the development process; each team owns and is responsible
    for one or more service and can develop, release, or scale their service independently
    of all of the other teams
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易组织开发过程；每个团队拥有并负责一个或多个服务，可以独立开发、发布或扩展他们的服务，而不受其他团队的影响
- en: You can choose whatever programming language or framework you think is best
    for the job. There is no long-term commitment to a technology stack. If needed,
    the service can be rewritten in the new technology stack, and if there are no
    API changes, this will be transparent for the rest of the system
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以选择您认为最适合工作的编程语言或框架。对技术栈没有长期承诺。如果需要，服务可以在新的技术栈中重写，如果没有API更改，这对系统的其他部分是透明的
- en: It is better for continuous delivery as small units are easier to manage, test,
    and deploy. As long as each team maintains backwards and forward API compatibility,
    it can work in release cycles that are decoupled from other teams. There are some
    scenarios where these release cycles are coupled, but this is not the common case
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于持续交付来说更好，因为小单元更容易管理、测试和部署。只要每个团队保持向后和向前的API兼容性，就可以在与其他团队解耦的发布周期中工作。有一些情况下这些发布周期是耦合的，但这并不是常见情况
- en: Maintaining data consistency
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持数据一致性
- en: 'Services must be loosely coupled so that they can be developed, deployed, and
    scaled independently. They of course, need to communicate, but they are independent
    of each other. They, have well defined interfaces and encapsulate implementation
    details. But what about data? In the real world and in non-trivial applications
    (and microservice applications will probably be non-trivial), business transactions
    must often span multiple services. If you, for example, create a banking application,
    before you execute the customer''s money transfer order, you need to ensure that
    it will not exceed his account balance. The single database that comes with a
    monolith application gives us a lot of convenience: atomic transactions, a single
    place to look for data, and so on.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 服务必须松散耦合，以便它们可以独立开发、部署和扩展。它们当然需要进行通信，但它们是彼此独立的。它们有明确定义的接口并封装实现细节。但是数据呢？在现实世界和非平凡的应用程序中（微服务应用程序可能是非平凡的），业务交易经常必须跨多个服务。例如，如果你创建一个银行应用程序，在执行客户的转账订单之前，你需要确保它不会超过他的账户余额。单体应用程序附带的单个数据库给了我们很多便利：原子事务，一个查找数据的地方等等。
- en: On the other hand, in the microservices world, different services need to be
    independent. This also means that they can have different data storage requirements.
    For some services, it will be a relational database, others might need a document
    database such as MongoDB, which is good at storing complex, unstructured data.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在微服务世界中，不同的服务需要是独立的。这也意味着它们可以有不同的数据存储需求。对于一些服务，它可能是关系型数据库，而其他服务可能需要像MongoDB这样擅长存储复杂的非结构化数据的文档数据库。
- en: 'So, when building microservices and thus splitting up our database into multiple
    smaller databases, how do we manage these challenges? We have also said that services
    should own their data. That is, every microservice should depend only on its own
    database. The service''s database is effectively part of the implementation of
    that service. This leads to quite an interesting challenge when designing the
    microservices architecture. As Martin Fowler says in his `Microservice trade-offs`
    column: Maintaining strong consistency is extremely difficult for a distributed
    system, which means everyone has to manage eventual consistency. How do we deal
    with this? Well, it''s all about boundaries.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在构建微服务并将我们的数据库拆分成多个较小的数据库时，我们如何管理这些挑战呢？我们还说过服务应该拥有自己的数据。也就是说，每个微服务应该只依赖于自己的数据库。服务的数据库实际上是该服务实现的一部分。这在设计微服务架构时会带来相当有趣的挑战。正如马丁·福勒在他的“微服务权衡”专栏中所说的：在分布式系统中保持强一致性非常困难，这意味着每个人都必须管理最终一致性。我们如何处理这个问题？嗯，这一切都与边界有关。
- en: Microservices should have clearly defined responsibilities and boundaries.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该有明确定义的责任和边界。
- en: 'Microservices need to be grouped according to their business domain. Also,
    in practice, you will need to design your microservices in such a way that they
    cannot directly connect to a database owned by another service. The loose coupling
    means microservices should expose clear API interfaces that model the data and
    access patterns related to this data. They must stick to those interfaces, when
    changes are necessary, you will probably introduce a versioning mechanism and
    create another version of the microservice. You could use a publish/subscribe
    pattern to dispatch events from one microservice to be processed by others, as
    you can see in the following diagram:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务需要根据其业务领域进行分组。此外，在实践中，您需要以这样的方式设计您的微服务，使它们不能直接连接到另一个服务拥有的数据库。松散耦合意味着微服务应该公开清晰的API接口，模拟与数据相关的数据和访问模式。它们必须遵守这些接口，当需要进行更改时，您可能会引入版本控制机制，并创建另一个版本的微服务。您可以使用发布/订阅模式将一个微服务的事件分派给其他微服务进行处理，就像您在下面的图表中看到的那样。
- en: '![](Image00060.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00060.jpg)'
- en: The publish/subscribe mechanism you would want to use should provide retry and
    rollback features for the event processing. In a publish/subscribe scenario, the
    service that modifies or generates the data allows other services to subscribe
    to events. The subscribed services receive the event saying that the data has
    been modified. It's often the case that the event contains the data that has been
    modified. Of course, the event publish/subscribe pattern can be used not only
    in relation to data changes, it can be used as a generic communication mechanism
    between services. This is a simple and effective approach but it has a downside,
    there is a possibility to lose an event.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用的发布/订阅机制应该为事件处理提供重试和回滚功能。在发布/订阅场景中，修改或生成数据的服务允许其他服务订阅事件。订阅的服务接收到事件，表明数据已被修改。通常情况下，事件包含已经被修改的数据。当然，事件发布/订阅模式不仅可以用于数据更改，还可以作为服务之间的通用通信机制。这是一种简单而有效的方法，但它也有一个缺点，就是可能会丢失事件。
- en: When creating distributed applications, you may want to consider that there
    will be data inconsistency for some amount of time. When an application changes
    data items on one machine, that change needs to be propagated to the other replicas.
    Since the change propagation is not instant, there's a time interval during which
    some of the copies will have the most recent change, but others won't. However,
    the change will be propagated to all the copies, eventually. That's why this is
    called eventual consistency. Your services would need to assume that the data
    will be in an inconsistent state for a while and need to deal with the situation
    by using the data as is, postponing the operation, or even ignoring certain pieces
    of data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建分布式应用程序时，您可能需要考虑一段时间会出现数据不一致的情况。当应用程序在一台机器上更改数据项时，该更改需要传播到其他副本。由于更改传播不是即时的，因此在某个时间间隔内，一些副本将具有最新的更改，而其他副本则没有。然而，更改最终将传播到所有副本。这就是为什么这被称为最终一致性。您的服务需要假设数据在一段时间内处于不一致状态，并需要通过使用数据本身，推迟操作，甚至忽略某些数据来处理这种情况。
- en: 'As you can see, there are a lot of challenges, but also a lot of advantages
    behind using microservices architecture. You should be warned, though, there are
    more challenges we need to address. As services are independent of each other,
    they can be implemented in different programming languages. This means the deployment
    process of each may vary: it will be totally different for a Java web application
    and for a `node.js` application. This can make the deployment to a server complex.
    This is precisely the point where Docker comes to the rescue.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，微服务架构背后有很多挑战，但也有很多优势。不过，你应该注意，我们需要解决更多的挑战。由于服务彼此独立，它们可以用不同的编程语言实现。这意味着每个服务的部署过程可能会有所不同：对于Java
    Web应用程序和node.js应用程序来说，部署过程完全不同。这可能会使部署到服务器变得复杂。这正是Docker发挥作用的关键点。
- en: The Docker role
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker角色
- en: As you remember from the previous chapters, Docker utilizes the concept of containerization.
    You simply put your application (in this context, the application will be a microservice)
    no matter what language and technology it uses, into a single, deployable and
    runnable piece of software, called the image. We are going to cover the process
    of packaging a Java application into the image in detail in the [Chapter 4](text00063.html)
    , *Creating Java Microservices* . The Docker image will contain everything our
    service needs to work, it can be a Java Virtual Machine with all required libraries
    and an application server, or it can also be a `node.js` application packaged
    together with the `node.js` runtime with all the needed `node.js` modules, such
    as `express.js` or whatever the `node.js` service needs to run. A microservice
    might consist of two containers,   one running the service code and another running
    a database to keep the service's own data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前几章中所记得的，Docker利用了容器化的概念。无论应用程序使用什么语言和技术，你只需将其放入一个可部署和可运行的软件中，称为镜像（在这种情况下，应用程序将是一个微服务）。我们将在第4章《创建Java微服务》中详细介绍将Java应用程序打包到镜像的过程。Docker镜像将包含我们的服务所需的一切，可以是一个带有所有必需库和应用服务器的Java虚拟机，也可以是一个将node.js应用程序与所有所需的node.js模块（如express.js等）打包在一起的node.js运行时。一个微服务可能由两个容器组成，一个运行服务代码，另一个运行数据库以保存服务自己的数据。
- en: Docker isolates containers to one process or service. In effect, all the pieces
    of our application will just be a bunch of black boxes, packaged and ready to
    use Docker images. Containers operate as fully isolated sandboxes, with only the
    minimal kernel of the operating system present for each container. Docker uses
    the Linux kernel and makes use of kernel interfaces such as cnames and namespaces,
    which allow multiple containers to share the same kernel while running in complete
    isolation from one another.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将容器隔离到一个进程或服务。实际上，我们应用程序的所有部分只是一堆打包好的黑匣子，可以直接使用Docker镜像。容器作为完全隔离的沙盒运行，每个容器只有操作系统的最小内核。Docker使用Linux内核，并利用诸如cnames和命名空间之类的内核接口，允许多个容器共享同一个内核，同时完全隔离运行。
- en: Because the system resources of the underlying system are shared, you can run
    your services at optimal performance, the footprint is substantially smaller in
    comparison to traditional virtual machines. Because containers are portable, as
    we have said in [Chapter 2](text00037.html) , *Networking and Persistent Storage*
    , they can run everywhere the Docker engine can run. This makes the process of
    deployment of microservices easy. To deploy a new version of a service running
    on a given host, the running container can simply be stopped and a new container
    started that is based on a Docker image using the latest version of the service
    code. We are going to cover the process of creating new versions of the image
    later in this book. Of course, all the other containers running on the host will
    not be affected by this change.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于底层系统的系统资源是共享的，您可以以最佳性能运行您的服务，与传统虚拟机相比，占用空间大大减小。因为容器是可移植的，正如我们在[第2章](text00037.html)中所说的，*网络和持久存储*，它们可以在Docker引擎可以运行的任何地方运行。这使得微服务的部署过程变得简单。要在给定主机上部署服务的新版本，只需停止运行的容器，并启动一个基于使用服务代码最新版本的Docker镜像的新容器。我们将在本书的后面介绍创建镜像新版本的过程。当然，主机上运行的所有其他容器都不会受到此更改的影响。
- en: As microservices need to communicate using the `REST` protocol, our Docker containers
    (or, to be more precise, your Java microservices packaged and running from within
    the Docker container) also need to communicate using the network. As you remember
    from [Chapter 2](text00037.html) , *Networking and Persistent Storage* , about
    networking, it's very easy to expose and map a network port for the Docker container.
    It seems that Docker containerization is ideal for the purposes of microservice
    architecture. You can package the microservice into a portable box and expose
    the needed network ports, enabling it to communicate to the outside world. When
    needed, you can run as many of those boxes as you want.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务需要使用`REST`协议进行通信，我们的Docker容器（或者更准确地说，您的Java微服务打包并在Docker容器内运行）也需要使用网络进行通信。正如您在[第2章](text00037.html)中记得的，关于网络的*网络和持久存储*，很容易暴露和映射Docker容器的网络端口。Docker容器化似乎非常适合微服务架构的目的。您可以将微服务打包到一个便携式盒子中，并暴露所需的网络端口，使其能够与外部世界通信。在需要时，您可以运行任意数量的这些盒子。
- en: 'Let''s summarize the Docker features that are useful when dealing with microservices:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下在处理微服务时有用的Docker功能：
- en: It is easy to scale up and scale down a service, you just change the running
    container instances count
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易扩展和缩减服务，只需更改运行的容器实例数量
- en: The container hides the details of the technology behind each of the services.
    All containers with our services are started and stopped in exactly the same way,
    no matter what technology stack they use
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器隐藏了每个服务背后技术的细节。我们的所有服务容器都以完全相同的方式启动和停止，无论它们使用什么技术栈
- en: Each service instance is isolated
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务实例都是隔离的
- en: You can limit the runtime constraints on the CPU and memory consumed by a container
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以限制容器消耗的CPU和内存的运行时约束
- en: Containers are fast to build and start. As you remember from [Chapter 1](text00022.html)
    , *Introduction to Docker* , there's minimal overhead in comparison to traditional
    virtualization
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器构建和启动速度快。正如您在[第1章](text00022.html)中记得的，*Docker简介*，与传统虚拟化相比，开销很小
- en: Docker image layers are cached, this gives you another speed boost when creating
    a new version of the service
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker镜像层被缓存，这在创建服务的新版本时可以提供另一个速度提升
- en: 'Doesn''t it fit perfectly for the definition of the microservices architecture?
    Sure it does, but there''s one problem. Because our microservices are spread out
    across multiple hosts, it can be difficult to track which hosts are running certain
    services and also monitor which of them need more resources or, in the worst case,
    are dead and not functioning properly. Also, we need to group services that belong
    to the specific application or feature. This is the missing element in our puzzle:
    container management and orchestration. A lot of frameworks emerged for the sole
    purpose of handling more complex scenarios: managing single services in a cluster
    or multiple instances in a service across hosts, or how to coordinate between
    multiple services on a deployment and management level. One of these tools is
    Kubernetes.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构的定义完全符合吗？当然符合，但是有一个问题。因为我们的微服务分布在多个主机上，很难跟踪哪些主机正在运行某些服务，也很难监视哪些服务需要更多资源，或者在最坏的情况下，已经死掉并且无法正常运行。此外，我们需要对属于特定应用程序或功能的服务进行分组。这是我们拼图中缺少的元素：容器管理和编排。许多框架出现了，目的是处理更复杂的场景：在集群中管理单个服务或在多个主机上管理多个实例，或者如何在部署和管理级别协调多个服务之间。其中一个工具就是Kubernetes。
- en: Kubernetes' role
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes的作用
- en: While Docker provides the lifecycle management of containers, Kubernetes takes
    it to the next level by providing orchestration and managing clusters of containers.
    As you know, your application created using the microservice architecture will
    contain a couple of separated, independent services. How do we orchestrate and
    manage them? Kubernetes is an open-source tool that's perfect for this scenario.
    It defines a set of building blocks which provide mechanisms for deploying, maintaining,
    and scaling applications. The basic scheduling unit in Kubernetes is called a
    pod. Containers in a pod run on the same host, share the same IP address, and
    find each other via localhost. They can also communicate with each other using
    standard inter-process communications, such as shared memory or semaphores. A
    pod adds another level of abstraction to containerized components. A pod consists
    of one or more containers that are guaranteed to be co-located on the host machine
    and can share resources. It's same as a logical collection of containers that
    belong to an application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker提供了容器的生命周期管理，但Kubernetes将其提升到了下一个级别，提供了容器集群的编排和管理。正如你所知，使用微服务架构创建的应用程序将包含一些分离的、独立的服务。我们如何对它们进行编排和管理？Kubernetes是一个开源工具，非常适合这种情况。它定义了一组构建块，提供了部署、维护和扩展应用程序的机制。Kubernetes中的基本调度单元称为pod。Pod中的容器在同一主机上运行，共享相同的IP地址，并通过localhost找到彼此。它们还可以使用标准的进程间通信方式进行通信，比如共享内存或信号量。Pod为容器化组件增加了另一个抽象级别。一个pod由一个或多个容器组成，这些容器保证在主机上共同定位，并且可以共享资源。它与一个应用程序相关的容器的逻辑集合是相同的。
- en: For traditional services, such as a REST endpoint together with the corresponding
    database (our complete microservice, in fact), Kubernetes provides a concept of
    service. A service defines a logical group of pods and also enforces rules for
    accessing such logical groups from the outside world. Kubernetes uses the concept
    of Labels for pods and other resources (services, deployments, and so on). These
    are simple the key-value pairs that can be attached to resources at creation time
    and then added and modified at any time. We will be using labels later on, to
    organize and to select subsets of resources (pods, for example) to manage them
    as one entity.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于传统服务，例如与相应数据库一起的REST端点（实际上是我们完整的微服务），Kubernetes提供了服务的概念。服务定义了一组逻辑pod，并强制执行从外部世界访问这些逻辑组的规则。Kubernetes使用标签的概念来为pod和其他资源（服务、部署等）添加标签。这些标签是可以在创建时附加到资源上，然后随时添加和修改的简单键值对。我们稍后将使用标签来组织和选择资源的子集（例如pod）以将它们作为一个实体进行管理。
- en: Kubernetes can place your container or a group of containers in the specific
    host automatically. To find a suitable host (the one with the smallest workload),
    it will analyze the current workload of the hosts and different colocation and
    availability constraints. Of course, you will be able to specify the host manually,
    but having this automatic feature can make the best of the processing power and
    resources available. Kubernetes can monitor the resource usage (CPU and RAM) at
    the container, pod, and cluster level. The resource usage and performance analysis
    agent runs on each node, auto-discovers containers on the node, and collects CPU,
    memory, filesystem, and network usage statistics.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes可以自动将您的容器或一组容器放置在特定的主机上。为了找到合适的主机（具有最小工作负载的主机），它将分析主机的当前工作负载以及不同的共存和可用性约束。当然，您可以手动指定主机，但拥有这种自动功能可以充分利用可用的处理能力和资源。Kubernetes可以监视容器、pod和集群级别的资源使用情况（CPU和RAM）。资源使用和性能分析代理在每个节点上运行，自动发现节点上的容器，并收集CPU、内存、文件系统和网络使用统计信息。
- en: Kubernetes also manages the lifecycle of your container instances. If there
    are too many of them, some of them will be stopped. If the workload increases,
    new containers will be started automatically. This feature is called container
    auto-scaling. It will automatically change the number of running containers, based
    on memory, CPU utilization, or other metrics you define for your services, as
    the number of queries per second, for example.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes还管理您的容器实例的生命周期。如果实例过多，其中一些将被停止。如果工作负载增加，新的容器将自动启动。这个功能称为容器自动扩展。它将根据内存、CPU利用率或您为服务定义的其他指标（例如每秒查询次数）自动更改运行容器的数量。
- en: 'As you remember from [Chapter 2](text00037.html) , *Networking and Persistent
    Storage* , Docker operates volumes to persist your application data. Kubernetes
    also supports two kinds of volume: regular which has the same lifecycle as the
    pod, and persistent with a lifecycle independent of any pod. Volume types are
    implemented the same way as in Docker in the form of plugins. This extensible
    design enables you to have almost any type of volume you need. It currently contains
    storage plugins such as Google Cloud Platform volume, AWS elastic block storage
    volume, and others.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从[第2章](text00037.html)中记得的那样，*网络和持久存储*，Docker使用卷来持久保存您的应用数据。Kubernetes也支持两种卷：常规卷与pod具有相同的生命周期，持久卷则独立于任何pod的生命周期。卷类型以插件的形式与Docker实现方式相同。这种可扩展的设计使您可以拥有几乎任何类型的卷。它目前包含存储插件，如Google
    Cloud Platform卷、AWS弹性块存储卷等。
- en: Kubernetes can monitor the health of your services, it can do it by executing
    a specified `HTTP` method (the same as `GET` for example) for the specified URL
    and analyzing the `HTTP` status code given back in response. Also, a TCP probe
    can check if a specified port is open which can also be used to monitor the health
    of your service. Last, but not least, you can specify the command that can be
    executed in the container, and some actions that could be taken based on the command's
    response. If the specified probe method signals that something is wrong with the
    container, it can be automatically restarted. When you need to update your software,
    Kubernetes supports rolling updates. This feature allows you to update a deployed,
    containerized application with minimal downtime. The rolling update feature lets
    you specify the number of old replicas that may be down while they are being updated.
    Upgrading containerized software with Docker is especially easy, as you already
    know, it will just be a new image version for the container. I guess you are now
    getting the complete picture. Deployments can be updated, rolled out, or rolled
    back. Load balancing, service discovery, all the features you would probably need
    when orchestrating and managing your herd of microservices running from within
    Docker containers are available in Kubernetes. Initially made by Google for big
    scale, Kubernetes is nowadays widely used by organizations of various sizes to
    run containers in production.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes可以监视您的服务的健康状况，它可以通过执行指定的`HTTP`方法（例如与`GET`相同）来执行指定的URL并分析响应中给出的`HTTP`状态代码来实现。此外，TCP探测可以检查指定端口是否打开，也可以用于监视服务的健康状况。最后，但同样重要的是，您可以指定可以在容器中执行的命令，以及可以根据命令的响应采取的一些操作。如果指定的探测方法发出信号表明容器出现问题，它可以自动重新启动。当您需要更新软件时，Kubernetes支持滚动更新。此功能允许您以最小的停机时间更新部署的容器化应用程序。滚动更新功能允许您指定在更新时可能关闭的旧副本的数量。使用Docker升级容器化软件特别容易，因为您已经知道，它只是容器的新图像版本。我想现在您已经完全了解了。部署可以更新、部署或回滚。负载平衡、服务发现，所有您在编排和管理运行在Docker容器中的微服务群时可能需要的功能都可以在Kubernetes中使用。最初由谷歌为大规模而制作，Kubernetes现在被各种规模的组织广泛使用来在生产环境中运行容器。
- en: When to use the microservice architecture
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用微服务架构
- en: The microservice architecture is a new way to think about structuring applications
    At the beginning, when you begin creating a system and it's relatively small,
    there will probably be no need to use the microservices approach. Of course, it's
    nothing wrong with the basic web application. When doing basic web applications
    for the people in your office, going with the microservice architecture may be
    overkill. On the other hand, if you plan to develop a new, super internet service
    that will be used by millions of mobile clients, I would consider going with microservices
    from the start. Joking aside, you get the picture, always try to pick the best
    tool for the job. In the end, the goal is to provide business value.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是一种新的思考应用程序结构的方式。在开始时，当您开始创建一个相对较小的系统时，可能不需要使用微服务方法。当然，基本的Web应用程序没有问题。在为办公室的人们制作基本的Web应用程序时，采用微服务架构可能有些过度。另一方面，如果您计划开发一个新的、超级互联网服务，将被数百万移动客户端使用，我会考虑从一开始就采用微服务。开玩笑的时候，您明白了，始终要选择最适合工作的工具。最终目标是提供业务价值。
- en: However, you should keep in mind the whole picture of your system after some
    time. If your application is growing larger in features and functionality than
    you expected, or you know that from the beginning, you may want to start breaking
    features off into microservices. You should try to do the functional decomposition
    and point out the fragments of your systems that have clear boundaries and which
    would need scaling, and separate deployments in the future. If there's a lot of
    people working on a project, having them developing the separate, independent
    pieces of an application will give the development process a huge boost. There
    can be a mix of technology stacks used each service can be implemented in a different
    programming language or framework and store its own data in the most suitable
    data storage. It's all about API and the way services communicate with each other.
    Having this architecture will result in a faster time to market the build, test,
    and deployment time is highly reduced in comparison to a monolith architecture.
    If you need to scale only the service that needs to handle higher workload. Having
    Docker and Kubernetes available, there is no reason not to go into the microservice
    architecture; it will pay off in the future, for sure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你应该在一段时间后牢记你系统的整体情况。如果你的应用程序在功能和功能上比你预期的要大，或者你从一开始就知道这一点，你可能想要开始将功能拆分成微服务。你应该尝试进行功能分解，并指出系统的片段具有明确的边界，并且在将来需要扩展和单独部署。如果有很多人在一个项目上工作，让他们开发应用程序的独立部分将极大地推动开发过程。每个服务可以使用不同的技术栈，可以用不同的编程语言或框架实现，并且可以在最合适的数据存储中存储自己的数据。这一切都与API和服务之间的通信方式有关。拥有这样的架构将导致更快的上市时间，与单体架构相比，构建、测试和部署时间大大缩短。如果只需要扩展需要处理更高工作负载的服务。有了Docker和Kubernetes，没有理由不去使用微服务架构；这将在未来得到回报，毫无疑问。
- en: The microservice architecture is not just a new trendy buzzword, it's generally
    accepted as a better way to build applications today. The birth of the microservice
    idea has been driven by the need to make better use of compute resources and the
    need to maintain more and more complex web-based applications.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构不仅仅是一个新潮的时髦词汇，它通常被认为是今天构建应用程序的更好方式。微服务理念的诞生是由于需要更好地利用计算资源以及需要维护越来越复杂的基于Web的应用程序。
- en: Java is an excellent choice when building microservices. You can create a microservice
    as a single executable JAR, self-contained Spring Boot application, or fully featured
    web application deployed on an application server such as Wildfly or Tomcat. Depending
    on your use case and the responsibilities and features of your microservices,
    any of the previous will do. Docker Repository contains a lot of useful images
    you can use freely as a base for your microservice. Many images present in The
    Docker Hub are created by private individuals, some extending official images
    and customizing them to their needs, but others are entire platform configurations
    customized from base images. The base image can be as simple as pure JDK or it
    can be a fully configured Wildfly ready to run. This gives a serious development
    performance boost.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建微服务时，Java是一个很好的选择。你可以将微服务创建为一个单独的可执行JAR，自包含的Spring Boot应用程序，或者部署在诸如Wildfly或Tomcat之类的应用服务器上的功能齐全的Web应用程序。根据你的用例和微服务的职责和功能，任何一种方式都可以。Docker仓库包含许多有用的镜像，你可以自由地将其作为微服务的基础。Docker
    Hub中的许多镜像是由私人个人创建的，有些是扩展官方镜像并根据自己的需求进行定制，但其他一些是从基础镜像定制的整个平台配置。基础镜像可以简单到纯JDK，也可以是一个完全配置好的Wildfly准备运行。这将极大地提高开发性能。
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have compared monolithic and microservices architectures.
    I hope you see the advantages of using the latter. We have also learned how Docker
    and Kubernetes fits into the whole picture when deploying containerized applications,
    making this process a lot more easy and pleasant. Java is a proven ecosystem for
    implementing microservices. The software you are going to create will consist
    of small, highly testable, and efficient modules. In fact, in [Chapter 4](text00063.html)
    , *Creating Java Microservices* , we are going to get our hands dirty and create
    such a microservice.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们已经比较了单体架构和微服务架构。我希望你能看到使用后者的优势。我们还学习了Docker和Kubernetes在部署容器化应用程序时如何融入整个画面，使这个过程变得更加简单和愉快。Java是一个实践证明的生态系统，用于实现微服务。您将要创建的软件将由小型、高度可测试和高效的模块组成。实际上，在[第4章](text00063.html)
    *创建Java微服务*中，我们将亲自动手创建这样一个微服务。
