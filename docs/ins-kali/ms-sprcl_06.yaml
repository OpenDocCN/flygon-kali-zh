- en: Communication Between Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务之间的通信
- en: In the last two chapters, we discussed details related to very important elements
    in microservice architecture—service discovery and the configuration server. However,
    it is worth remembering that the main reason for their existence in the system
    is just to help in the management of the whole set of independent, standalone
    applications. One aspect of this management is communication between microservices.
    Here, a particularly important role is played by service discovery, which is responsible
    for storing and serving the network locations of all available applications. Of
    course, we may imagine our system architecture without a service discovery server.
    Such an example will also be presented in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两章中，我们讨论了与微服务架构中非常重要的元素相关的细节——服务发现和配置服务器。然而，值得记住的是，它们存在于系统中的主要原因只是为了帮助管理整套独立的独立应用程序。这种管理的一个方面是微服务之间的通信。在这里，服务发现扮演着特别重要的角色，负责存储和提供所有可用应用程序的网络位置。当然，我们可以想象我们的系统架构没有服务发现服务器。这样的例子也将在本章中呈现。
- en: However, the most important components taking part in an inter-service communication
    are HTTP clients and client-side load balancers. In this chapter, we are going
    to focus just on them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在参与服务间通信的最重要的组件是HTTP客户端和客户端负载均衡器。在本章中，我们将专注于它们。
- en: 'The topics we will cover in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将涵盖的主题包括：
- en: Using Spring `RestTemplate` for inter-service communication with and without
    service discovery
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring `RestTemplate`进行带有和不带有服务发现的微服务之间的通信
- en: Customizing the Ribbon client
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义Ribbon客户端
- en: Description of the main features provided by the Feign client, such as integration
    with the Ribbon client, service discovery, inheritance, and zoning support
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述Feign客户端提供的主要功能，如与Ribbon客户端的集成，服务发现，继承和区域支持
- en: Different styles of communication
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同的通信方式
- en: We can identify different styles of communication between microservices. It
    is possible to classify them into two dimensions. The first of them is a division
    into synchronous and asynchronous communication protocols. The key point of asynchronous
    communication is that the client should not have blocked a thread while waiting
    for a response. The most popular protocol for that type of communication is AMQP,
    and we already had the opportunity to run an example of that protocol usage at
    the end of the previous chapter. However, the main way of communication between
    services is still synchronous HTTP protocol. We will be only talking about it
    in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以识别微服务之间不同的通信方式。可以将它们分类为两个维度。其中之一是同步和异步通信协议的划分。异步通信的关键点是客户端在等待响应时不应该阻塞线程。这种通信的最流行协议是AMQP，我们已经有机会在上一章的最后运行该协议的示例。然而，服务之间的主要通信方式仍然是同步的HTTP协议。我们只会在本章中讨论它。
- en: The second division is into different communication types based on whether there
    is a single message receiver or multiple receivers. In one-to-one communication,
    each request is processed by exactly one service instance. In one-to-many communication,
    each request may be processed by many different services. This will be discussed
    in [Chapter 11](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml), *Message Driven Microservices*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个划分是基于是否有单个消息接收者或多个接收者的不同通信类型。在一对一通信中，每个请求都由一个服务实例处理。在一对多通信中，每个请求可能由许多不同的服务处理。这将在[第11章](554c4049-1dc9-430d-8fe7-19f3b9ac99a3.xhtml)中讨论，*消息驱动的微服务*。
- en: Synchronous communication with Spring Cloud
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud进行同步通信
- en: Spring Cloud provides a set of components to help you in implementing communication
    between microservices. The first of them is `RestTemplate`, which is always used
    for consuming RESTful web services by a client. It is included in a Spring Web
    project. To use it effectively in a microservices environment, it should be annotated
    with the `@LoadBalanced` qualifier. Thanks to that, it will be automatically configured
    to use Netflix Ribbon and it will be able to take an advantage of service discovery
    by using service names instead of IP addresses. Ribbon is a client-side load balancer,
    which provides a simple interface allowing control over the behavior of HTTP and
    TCP clients. It can be easily integrated with other Spring Cloud components, such
    as service discovery or circuit breaker, and, furthermore, it is fully transparent
    to a developer. The next available component is Feign, a declarative REST client
    also from the Netflix OSS stack. Feign already uses Ribbon for load balancing
    and fetching data from service discovery. It may be easily declared on the interface
    by annotating a method with `@FeignClient`. In this chapter, we will take a closer
    look at all the components listed here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud提供了一组组件，帮助您实现微服务之间的通信。其中之一是`RestTemplate`，它始终用于客户端消费RESTful web服务。它包含在Spring
    Web项目中。要在微服务环境中有效使用它，应该用`@LoadBalanced`限定符进行注释。由于这样，它将自动配置为使用Netflix Ribbon，并且能够利用服务发现，使用服务名称而不是IP地址。Ribbon是一个客户端负载均衡器，提供了一个简单的接口，允许控制HTTP和TCP客户端的行为。它可以轻松集成其他Spring
    Cloud组件，如服务发现或断路器，而且对开发人员完全透明。下一个可用的组件是Feign，也来自Netflix OSS堆栈的声明式REST客户端。Feign已经使用Ribbon进行负载平衡和从服务发现获取数据。可以通过用`@FeignClient`注释接口上的方法来轻松声明它。在本章中，我们将更详细地了解这里列出的所有组件。
- en: Load balancing with Ribbon
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ribbon进行负载均衡
- en: The main concept around Ribbon is a named **client**. That's why we may call
    other services using their names instead of the full address with hostname and
    port, without connecting to a service discovery. In that case, the list of addresses
    should be provided in the Ribbon configuration settings inside the `application.yml`
    file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Ribbon周围的主要概念是一个命名的**客户端**。这就是为什么我们可以使用它们的名称而不是完整的地址和主机名和端口来调用其他服务，而不连接到服务发现。在这种情况下，地址列表应该在`application.yml`文件的Ribbon配置设置中提供。
- en: Enabling communication between microservices using the Ribbon client
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ribbon客户端实现微服务之间的通信
- en: 'Let''s proceed with the example. It consists of four independent microservices.
    Some of them may call endpoints exposed by the others. The application source
    code is available here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行示例。它由四个独立的微服务组成。其中一些可能调用其他微服务公开的端点。应用源代码在此处可用：
- en: '[https://github.com/piomin/sample-spring-cloud-comm.git](https://github.com/piomin/sample-spring-cloud-comm.git).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/piomin/sample-spring-cloud-comm.git](https://github.com/piomin/sample-spring-cloud-comm.git)。'
- en: 'In this example, we will try to develop a simple order system where customers
    may buy products. If a customer decides to confirm a selected list of products
    to buy, the `POST` request is sent to the `order-service`. It is processed by
    the `Order prepare(@RequestBody Order order) {...}` method inside REST controller.
    This method is responsible for order preparation. First, it calculates the final
    price, considering the price of each product from the list, customer order history,
    and their category in the system by calling the proper API method from the `customer-service`.
    Then, it verifies the customer''s account balance is high enough to execute the
    order by calling the account service, and, finally, it returns the calculated
    price. If the customer confirms the action, the `PUT /{id}` method is called.
    The request is processed by the method `Order accept(@PathVariable Long id) {...}`
    inside REST controller. It changes the order status and withdraws money from the
    customer''s account. The system architecture is broken down into the individual
    microservices as shown here:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将尝试开发一个简单的订单系统，顾客可以在其中购买产品。如果顾客决定确认要购买的产品清单，将发送`POST`请求到`order-service`。这个请求会被REST控制器内的`Order
    prepare(@RequestBody Order order) {...}`方法处理。这个方法负责订单准备工作。首先，它通过调用`customer-service`中的适当API方法，考虑产品清单中每个产品的价格、顾客的订单历史和他们在系统中的类别来计算最终价格。然后，它通过调用账户服务验证顾客的账户余额是否足够执行订单，最后返回计算出的价格。如果顾客确认操作，将调用`PUT
    /{id}`方法。这个请求会被REST控制器内的`Order accept(@PathVariable Long id) {...}`方法处理。它会改变订单状态并从顾客的账户中扣除金额。系统架构被分解为各个微服务，如下所示：
- en: '![](img/5c7304e2-7612-4327-94a6-eaaaec6c0fd5.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c7304e2-7612-4327-94a6-eaaaec6c0fd5.png)'
- en: Static load balancing configuration
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态负载均衡配置
- en: 'Our `order-service` has to communicate with all other microservices from the
    example to perform the required operations. So, we need to define three different
    Ribbon clients with network addresses set using the `ribbon.listOfServers` property.
    The second important thing in the example is to disable discovery services in
    Eureka, which are enabled by default. Here are all the defined properties for
    `order-service` inside its `application.yml` file:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`order-service`必须与示例中的所有其他微服务进行通信以执行所需的操作。因此，我们需要使用`ribbon.listOfServers`属性设置网络地址来定义三个不同的Ribbon客户端。示例中的第二个重要事项是禁用Eureka中默认启用的发现服务。以下是`order-service`在其`application.yml`文件中定义的所有属性：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We should include the following dependencies in the project to use `RestTemplate`
    in conjunction with the Ribbon client:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在项目中包含以下依赖项，以便将`RestTemplate`与Ribbon客户端一起使用：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we should enable the Ribbon client by declaring a list of the names configured
    in `application.yml`. To achieve this, you may annotate the main class or any
    other Spring configuration class with `@RibbonClients`. You should also register
    the `RestTemplate` bean and annotate it with `@LoadBalanced` to enable interaction
    with Spring Cloud components:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该通过声明在`application.yml`中配置的名称列表来启用Ribbon客户端。为了实现这一点，您可以在主类或任何其他Spring配置类上使用`@RibbonClients`进行注释。您还应该注册`RestTemplate`
    bean，并使用`@LoadBalanced`进行注释，以启用与Spring Cloud组件的交互：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Calling other services
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用其他服务
- en: Finally, we may begin to implement the `OrderController` responsible for serving
    HTTP methods exposed outside a microservice. It has the `RestTemplate` bean injected
    to be able to call other HTTP endpoints. You may see in the following source code
    fragment that uses the Ribbon client name configured in `application.yml` instead
    of IP address or hostname. Using the same `RestTemplate` bean, we can communicate
    with three different microservices. Let's just take a second here to discuss the
    methods available inside the controller. In the first of the implemented methods,
    we call the `GET` endpoint from `product-service`, which returns a list with details
    of selected products. Then, we invoke the `GET /withAccounts/{id}` method exposed
    by `customer-service`. It returns the customer details with the list of their
    accounts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始实现`OrderController`，负责为微服务外部公开的HTTP方法提供服务。它注入了`RestTemplate` bean，以便调用其他HTTP端点。您可以在以下源代码片段中看到，它使用了`application.yml`中配置的Ribbon客户端名称，而不是IP地址或主机名。使用相同的`RestTemplate`
    bean，我们可以与三个不同的微服务进行通信。让我们在这里花一点时间讨论控制器内可用的方法。在实现的第一个方法中，我们调用`product-service`的`GET`端点，该端点返回所选产品的详细信息列表。然后，我们调用`customer-service`公开的`GET
    /withAccounts/{id}`方法。它返回顾客的详细信息和他们账户的列表。
- en: 'Now, we have all the information needed to calculate the final order price
    and validate the customer has sufficient funds in their main account. The `PUT`
    method calls the endpoint from `account-service` to withdraw money from the customer
    account. I have spent quite a bit of time discussing methods available in `OrderController`.
    However, I think that it was needed because the same example will be used to show
    the main features of Spring Cloud components that provide mechanisms for synchronous
    communication between microservices:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经获得了计算最终订单价格和验证顾客主账户是否有足够资金所需的所有信息。`PUT`方法调用`account-service`的端点从顾客账户中提取资金。我已经花了相当多的时间讨论`OrderController`中可用的方法。然而，我认为这是有必要的，因为相同的示例将用于展示Spring
    Cloud组件的主要特性，这些组件提供了微服务之间同步通信的机制：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It is interesting to note that the `GET /withAccounts/{id}` method from `customer-service`,
    which is called by `order-service`, also uses the Ribbon client to communicate
    with another microservice, `account-service`. Here''s the fragment from `CustomerController`
    with the implementation of the preceding method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`order-service`调用的`customer-service`中的`GET /withAccounts/{id}`方法也使用了Ribbon客户端与另一个微服务`account-service`进行通信。以下是`CustomerController`中实现上述方法的片段：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, build the whole project with the Maven command `mvn clean install`.
    Then, you may launch all the microservices in any order using the `java -jar`
    command without any additional parameters. Optionally, you can run the application
    from your IDE. The test data is prepared for every microservice on startup. There
    is no persistence storage, so all objects will be removed after a restart. We
    can test the whole system by calling the `POST` method exposed by `order-service`.
    The example request is shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用Maven命令`mvn clean install`构建整个项目。然后，您可以使用`java -jar`命令以任何顺序启动所有微服务，而无需任何额外的参数。也可以从IDE中运行应用程序。测试数据在启动时为每个微服务准备好。没有持久存储，因此所有对象在重新启动后将被删除。我们可以通过调用`order-service`公开的`POST`方法来测试整个系统。示例请求如下所示：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you try to send this request, you will able to see the following logs printed
    by the Ribbon client:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试发送此请求，您将能够看到Ribbon客户端打印的以下日志：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The approach described in this section has one big disadvantage, which makes
    it not very usable in a system composed of several microservices. The problem
    is more severe if you have auto-scaling. It is easy to see that all the network
    addresses of services have be managed manually. Of course, we may move the configuration
    settings from the `application.yml` file inside every fat JAR to the configuration
    server. However, it does not change the fact that management of a large number
    of interactions will still be troublesome. Such a problem would be easily solved
    by the ability for the client-side load balancer and service discovery to interact.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的方法有一个很大的缺点，在由多个微服务组成的系统中不太适用。如果有自动扩展，问题会更严重。很容易看出，所有服务的网络地址都必须手动管理。当然，我们可以将配置设置从`application.yml`文件移动到配置服务器中。但是，这并不改变大量交互的管理仍然会很麻烦的事实。客户端负载均衡器和服务发现进行交互将很容易解决这样的问题。
- en: Using RestTemplate together with service discovery
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RestTemplate与服务发现一起
- en: In fact, an integration with service discovery is the default behavior of the
    Ribbon client. As you probably remember, we disabled Eureka for the client-side
    balancer by setting the `ribbon.eureka.enabled` property to `false`. The existence
    of service discovery simplifies a configuration of Spring Cloud components during
    inter-service communication, examples in this section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，与服务发现集成是Ribbon客户端的默认行为。您可能还记得，我们通过将`ribbon.eureka.enabled`属性设置为`false`来禁用了客户端负载均衡器的Eureka。服务发现的存在简化了Spring
    Cloud组件在服务间通信期间的配置，本节中有示例。
- en: Building example application
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建示例应用程序
- en: The system architecture is the same as for the previous example. To view the
    source code for the current exercise, you have to switch to the `ribbon_with_discovery`
    branch ([https://github.com/piomin/shown here-spring-cloud-comm/tree/ribbon_with_discovery](https://github.com/piomin/sample-spring-cloud-comm/tree/ribbon_with_discovery)). The
    first thing you will see there is a new module, `discovery-service`. We have discussed
    in detail almost all aspects related to Eureka in [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml),
    *Service Discovery*, so you should not have any problems with launching it. We
    run a single standalone Eureka server with really basic settings. It is available
    on the default port, `8761`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 系统架构与先前的示例相同。要查看当前练习的源代码，您必须切换到`ribbon_with_discovery`分支（[https://github.com/piomin/sample-spring-cloud-comm/tree/ribbon_with_discovery](https://github.com/piomin/sample-spring-cloud-comm/tree/ribbon_with_discovery)）。您将在那里看到一个新模块`discovery-service`。我们已经在[第4章](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml)中详细讨论了与Eureka相关的几乎所有方面，*服务发现*，因此您在启动时不应该遇到任何问题。我们运行一个单独的独立Eureka服务器，设置非常基本。它在默认端口`8761`上可用。
- en: 'In comparison with the previous example, we should remove all the configuration
    and annotations strictly related to the Ribbon client. In their place, the Eureka
    discovery client has to be enabled with `@EnableDiscoveryClient` and the Eureka
    server address is provided in the `application.yml` file. Now, the main class
    of `order-service` looks like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前的示例相比，我们应该删除与Ribbon客户端严格相关的所有配置和注释。取而代之的是，必须使用`@EnableDiscoveryClient`启用Eureka发现客户端，并在`application.yml`文件中提供Eureka服务器地址。现在，`order-service`的主类如下所示：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here''s the current configuration file. I set the name of the service with
    the `spring.application.name` property:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当前的配置文件。我使用`spring.application.name`属性设置了服务的名称：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is the same as earlier; we also launch all microservices. But, this time
    `account-service` and `product-service` will be multiplied by two instances. When
    starting a second instance of each service, the default server port may be overridden
    with the `-DPORT` or `-Dserver.port` parameter, for example, `java -jar -DPORT=9093
    product-service-1.0-SNAPSHOT.jar`. All the instances have been registered in the
    Eureka server. This can be easily checked out using its UI dashboard:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前一样；我们也启动了所有微服务。但是，这次`account-service`和`product-service`将被两个实例化。启动每个服务的第二个实例时，可以使用`-DPORT`或`-Dserver.port`参数覆盖默认服务器端口，例如`java
    -jar -DPORT=9093 product-service-1.0-SNAPSHOT.jar`。所有实例都已在Eureka服务器中注册。这可以很容易地通过其UI仪表板进行检查：
- en: '![](img/deb2c9a7-afca-421d-993c-84c3189fed0c.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/deb2c9a7-afca-421d-993c-84c3189fed0c.png)'
- en: 'This is the first time in this book we have seen a practical example of load
    balancing. By default, the Ribbon client distributes traffic equally among all
    the registered instances of the microservice. That algorithm is called **round
    robin**. In practice, it means that the client remembers where it forwarded the
    last request and then sends the current request to the service next in the row.
    This approach may be overridden by the other rule I''m going to show you in detail
    in the next chapter. Load balancing may also be configured for the previous example
    without service discovery, by setting a comma-separated list of service addresses
    in `ribbon.listOfServers`, for example, `ribbon.listOfServers=localhost:8093,localhost:9093`.
    Getting back to the example application, the requests sent by `order-service`
    will be load balanced between two instances of `account-service` and `product-service`.
    This looks similar to `customer-service`, which distributes traffic between two
    instances of `account-service`. If you launch all the instances of the service
    visible on the Eureka dashboard in the previous screenshot and send some test
    requests to `order-service`, you will certainly see the following log which I
    have posted. I have highlighted the fragment where the Ribbon client displays
    a list of addresses found for the target service:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中第一次看到负载均衡的实际示例。默认情况下，Ribbon客户端将流量平均分配给微服务的所有注册实例。这个算法称为**轮询**。实际上，这意味着客户端记住了上次转发请求的位置，然后将当前请求发送到下一个服务。这种方法可以被下一章节中我将详细介绍的其他规则覆盖。负载均衡也可以在没有服务发现的情况下配置，通过在`ribbon.listOfServers`中设置一个逗号分隔的服务地址列表，例如`ribbon.listOfServers=localhost:8093,localhost:9093`。回到示例应用程序，`order-service`发送的请求将在`account-service`和`product-service`的两个实例之间进行负载均衡。这看起来类似于`customer-service`，它在两个`account-service`实例之间分配流量。如果您启动Eureka仪表板上可见的所有服务实例，并向`order-service`发送一些测试请求，您肯定会看到我发布的以下日志。我已经突出显示了Ribbon客户端显示的找到目标服务的地址列表的片段：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using Feign client
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Feign客户端
- en: '`RestTemplate` is a Spring component specially adapted to interact with Spring
    Cloud and microservices. However, Netflix has developed their own tool that acts
    as a web service client for providing out-of-the-box communication between independent
    REST services. Feign client, which is in it, generally does the same as `RestTemplate`
    with the `@LoadBalanced` annotation, but in a more elegant way. It is a Java to
    HTTP client binder that works by processing annotations into a templatized request.
    When using Open Feign client, you only have to create an interface and annotate
    it. It integrates with Ribbon and Eureka to provide a load balanced HTTP client,
    fetching all the necessary network addresses from service discovery. Spring Cloud
    adds support for Spring MVC annotations and for using the same HTTP message converters
    as in Spring Web.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestTemplate`是一个专门适用于与Spring Cloud和微服务交互的Spring组件。然而，Netflix已经开发了他们自己的工具，作为独立REST服务之间的开箱即用通信的Web服务客户端。其中的Feign客户端通常与`RestTemplate`和`@LoadBalanced`注解做相同的事情，但更加优雅。它是一个Java到HTTP客户端绑定器，通过处理注解来生成请求。当使用Open
    Feign客户端时，您只需要创建一个接口并对其进行注解。它集成了Ribbon和Eureka，提供了一个负载均衡的HTTP客户端，从服务发现中获取所有必要的网络地址。Spring
    Cloud添加了对Spring MVC注解的支持，以及使用与Spring Web中相同的HTTP消息转换器。'
- en: Support for different zones
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持不同区域
- en: 'Let me back up for a moment to the last example. I''m going to propose some
    changes to complicate our system architecture a little. The current architecture
    is visualized in the following diagram. The communication model between microservices
    is still the same, but now we launch two instances of every microservice and divide
    them into two different zones. A zoning mechanism has been already discussed in
    [Chapter 4](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml), *Service Discovery*,
    when talking about service discovery with Eureka, so I assume it is well known
    to you. The main purpose of this exercise is not only to show how to use Feign
    client, but also how a zoning mechanism works in communication between instances
    of microservices. Let''s start with the basics then:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我回顾一下上一个示例。我打算提出一些改变，稍微复杂化我们的系统架构。当前架构在下图中可视化。微服务之间的通信模型仍然相同，但现在我们启动了每个微服务的两个实例，并将它们分成两个不同的区域。在[第4章](b016b615-1eed-457a-9b9c-66ba07c9ce9e.xhtml)中已经讨论过分区机制，*服务发现*，当讨论Eureka的服务发现时，所以我假设您已经对此很熟悉。这个练习的主要目的不仅是展示如何使用Feign客户端，还有一个分区机制在微服务实例之间的通信中是如何工作的。让我们从基础开始：
- en: '![](img/0afef3be-1670-4898-98c6-3c8c6f421485.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0afef3be-1670-4898-98c6-3c8c6f421485.png)'
- en: Enabling Feign for an application
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序启用Feign
- en: 'To include Feign in the project, we have to add to the dependencies the `spring-cloud-starter-feign` artifact or
    `spring-cloud-starter-openfeign` for Spring Cloud Netflix in minimal version 1.4.0:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将Feign包含在项目中，我们必须在依赖项中添加`spring-cloud-starter-feign`或者`spring-cloud-starter-openfeign`这个Spring
    Cloud Netflix的最小版本1.4.0的artifact：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next step is to enable Feign for the application by annotating a main or
    a configuration class with `@EnableFeignClients`. This annotation will result
    in a search for all clients implemented in the application. We may also reduce
    the number of client used by setting the `clients` or `basePackages` annotation
    properties, for example, `@EnableFeignClients(clients = {AccountClient.class,
    Product.class})`. Here''s the main class of the `order-service` application:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是通过在主类或配置类上注释`@EnableFeignClients`来为应用程序启用Feign。这个注解将导致应用程序中所有客户端的搜索。我们还可以通过设置`clients`或`basePackages`注解属性来减少使用的客户端数量，例如`@EnableFeignClients(clients
    = {AccountClient.class, Product.class})`。这是`order-service`应用程序的主类：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Building Feign interfaces
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Feign接口
- en: 'An approach where only an interface with some annotations has to be created
    to provide a component is standard for Spring Framework. For Feign, an interface
    must be annotated with `@FeignClient(name = "...")`. It has one required property
    name, which corresponds to the invoked microservice name if service discovery
    is enabled. Otherwise, it is used together with the `url` property, where we can
    set a concrete network address. `@FeignClient` is not the only annotation that
    needs to be used here. Every method in our client interface is associated with
    a specific HTTP API endpoint by marking it with `@RequestMapping` or more concrete
    annotations, such as `@GetMapping`, `@PostMapping`, or `@PutMapping`, as in this
    example source code fragment:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 只需创建一个带有一些注解的接口来提供组件的方法是Spring Framework的标准方法。对于Feign，接口必须用`@FeignClient(name
    = "...")`进行注解。它有一个必需的属性名称，如果启用了服务发现，它对应于被调用的微服务名称。否则，它与`url`属性一起使用，我们可以设置一个具体的网络地址。`@FeignClient`不是唯一需要在这里使用的注解。我们的客户端接口中的每个方法都可以通过使用`@RequestMapping`或更具体的注解（如`@GetMapping`、`@PostMapping`或`@PutMapping`）与特定的HTTP
    API端点相关联，就像这个示例源代码片段中的那样：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Such components may be injected into the controller bean as they are also Spring
    Beans. Then, we just have to invoke their methods. Here''s the current implementation
    of the REST controller in `order-service`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件可以被注入到控制器bean中，因为它们也是Spring Bean。然后，我们只需调用它们的方法。以下是`order-service`中REST控制器的当前实现：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Launching microservices
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务启动
- en: 'I have changed a configuration for all the microservices in `application.yml`.
    Now, there are two different profiles, the first used for assigning an application
    to `zone1` and the second for `zone2`. You may check out the version from the
    `feign_with_discovery` branch ([https://github.com/piomin/shown here-spring-cloud-comm/tree/feign_with_discovery](https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_discovery)).
    Then, build the whole project using the `mvn clean install` command. The application
    should be launched with the `java -jar --spring.profiles.active=zone[n]` command,
    where `[n]` is the number of the zone. Because you have to start many instances
    to perform that test, it is worth considering a limit on heap size by setting
    the `-Xmx` parameter, for example, `-Xmx128m`. Here are the current configuration
    settings for one of the microservices:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在`application.yml`中为所有的微服务更改了配置。现在，有两个不同的配置文件，第一个用于将应用分配给`zone1`，第二个用于`zone2`。您可以从`feign_with_discovery`分支([https://github.com/piomin/shown
    here-spring-cloud-comm/tree/feign_with_discovery](https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_discovery))检出版本。然后，使用`mvn
    clean install`命令构建整个项目。应用程序应该使用`java -jar --spring.profiles.active=zone[n]`命令启动，其中`[n]`是区域的编号。因为您必须启动许多实例来执行该测试，所以值得考虑通过设置`-Xmx`参数来限制堆大小，例如`-Xmx128m`。以下是一个微服务的当前配置设置：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will launch one instance of every microservice per single zone. So, there
    are nine running Spring Boot applications, including the service discovery server,
    as shown in this screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为每个区域启动每个微服务的一个实例。因此，有九个正在运行的Spring Boot应用程序，包括服务发现服务器，如下图所示：
- en: '![](img/0333d3f0-6041-4b5e-98cc-a474b4c5a072.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0333d3f0-6041-4b5e-98cc-a474b4c5a072.png)'
- en: 'If you send the test request to the instance of `order-service` running in
    `zone1` (`http://localhost:8090`), all the traffic will be forwarded to the other
    services in that zone, and the same for `zone2` (`http://localhost:9090`). I have
    highlighted the fragment where the Ribbon client prints a list of found addresses
    of the target service registered in the current zone:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将测试请求发送到在`zone1`中运行的`order-service`实例（`http://localhost:8090`），所有流量将被转发到该区域中的其他服务，`zone2`（`http://localhost:9090`）也是如此。我已经突出显示了Ribbon客户端打印出在当前区域注册的目标服务的地址列表的片段：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Inheritance support
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承支持
- en: 'You have probably noticed that the annotations inside a controller implementation
    and the Feign client implementation for a REST service served by that controller
    are identical. We may create an interface that contains abstract REST method definitions.
    That interface can be implemented by a controller class or extended by a Feign
    client interface:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，控制器实现中的注解和由该控制器提供的REST服务的Feign客户端实现中的注解是相同的。我们可以创建一个包含抽象REST方法定义的接口。该接口可以由控制器类实现，或者由Feign客户端接口扩展：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, the controller class provides an implementation for all methods from the
    base interface, but does not contain any annotations for REST mappings instead
    of `@RestController`. Here''s a fragment of the `account-service` controller:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，控制器类为基础接口的所有方法提供了实现，但不包含任何REST映射的注解，而不是`@RestController`。以下是`account-service`控制器的片段：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The Feign client interface for calling `account-service` does not provide any
    methods. It just extends the base interface, `AccountService`. To see the full
    implementation based on interfaces and Feign inheritance, switch to the `feign_with_inheritance` branch:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 用于调用`account-service`的Feign客户端接口不提供任何方法。它只是扩展了基础接口`AccountService`。要查看基于接口和Feign继承的完整实现，请切换到`feign_with_inheritance`分支：
- en: '[https://github.com/piomin/shown here-spring-cloud-comm/tree/feign_with_inheritance](https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_inheritance)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/piomin/shown here-spring-cloud-comm/tree/feign_with_inheritance](https://github.com/piomin/sample-spring-cloud-comm/tree/feign_with_inheritance)'
- en: 'Here''s an example Feign client declaration with inheritance support. It extends
    the `AccountService` interface, and hence handles all the methods exposed by `@RestController`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个具有继承支持的Feign客户端声明示例。它扩展了`AccountService`接口，因此处理了所有由`@RestController`公开的方法：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating a client manually
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动创建客户端
- en: 'If you are not convinced by the annotation-like style, you may always create
    a Feign client manually using the Feign Builder API. Feign has several features
    that can be customized, such as encoders and decoders for messages or HTTP client
    implementation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对类似注解的风格不满意，您可以始终使用Feign Builder API手动创建Feign客户端。Feign有几个可以自定义的特性，比如消息的编码器和解码器，或者HTTP客户端的实现：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Client customization
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端定制
- en: 'Client customization can be performed not only with the Feign Builder API,
    but also by using the annotation-like style. We may provide a configuration class
    by setting it with the `configuration` property of `@FeignClient`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端定制不仅可以使用Feign Builder API，还可以使用类似注解的风格。我们可以通过在`@FeignClient`的`configuration`属性中设置配置类来提供配置：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An example configuration bean is shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个示例配置bean：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Spring Cloud supports the following properties to override by declaring Spring
    Beans:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Cloud支持通过声明Spring Beans来覆盖以下属性：
- en: '`Decoder`: By default, `ResponseEntityDecoder`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Decoder`：默认为`ResponseEntityDecoder`。'
- en: '`Encoder`: By default, `SpringEncoder`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Encoder`：默认为`SpringEncoder`。'
- en: '`Logger`: By default, `Slf4jLogger`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Logger`：默认为`Slf4jLogger`。'
- en: '`Contract`: By default, `SpringMvcContract`.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Contract`：默认为`SpringMvcContract`。'
- en: '`Feign.Builder`: By default, `HystrixFeign.Builder`.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Feign.Builder`：默认为`HystrixFeign.Builder`。'
- en: '`Client`: If Ribbon is enabled, it is `LoadBalancerFeignClient`; otherwise,
    the default Feign client is used.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`：如果启用了Ribbon，则为`LoadBalancerFeignClient`；否则，使用默认的Feign客户端。'
- en: '`Logger.Level`: It sets a default log level for Feign. You can choose between
    `NONE`, `BASIC`, `HEADERS` and `FULL`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Logger.Level`：它设置Feign的默认日志级别。您可以在`NONE`、`BASIC`、`HEADERS`和`FULL`之间进行选择。'
- en: '`Retryer`: It allows the implementing of the retry algorithm in case of communication
    failure.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Retryer`：它允许在通信失败的情况下实现重试算法。'
- en: '`ErrorDecoder`: It allows the mapping of the HTTP status code into application-specific
    exception.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ErrorDecoder`：它允许将HTTP状态代码映射到特定于应用程序的异常。'
- en: '`Request.Options`: It allows setting read and connects timeout for the request.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Request.Options`：它允许为请求设置读取和连接超时。'
- en: '`Collection<RequestInterceptor>`: Collection of registered `RequestInterceptor`
    implementations that perform some actions basing on data taken from request.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection<RequestInterceptor>`：注册的`RequestInterceptor`实现的集合，根据从请求中获取的数据执行某些操作。'
- en: 'Feign client can also be customized using configuration properties. It is possible
    to override settings for all available clients or only for a single selected client
    by providing its name after the `feign.client.config` property prefix. If we set
    the name `default` instead of a specific client name, it will apply it to all Feign
    clients. Default configurations can also be specified when using the `@EnableFeignClients` annotation and
    its `defaultConfiguration` attribute in a similar way to what was described previously.
    The settings provided in the `appplication.yml` file always have a higher priority
    than the `@Configuration` bean. To change that approach and prefer `@Configuration`
    instead of the YAML file, you should set the `feign.client.default-to-properties` property to
    `false`. Here''s an example Feign client configuration for `account-service` that
    sets connect timeout, read timeout of HTTP connection, and log level:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Feign客户端也可以使用配置属性进行定制。可以通过在`feign.client.config`属性前缀后提供其名称来覆盖所有可用客户端的设置，或者仅对单个选定的客户端进行设置。如果我们设置名称为`default`而不是特定的客户端名称，则将应用于所有Feign客户端。在使用`@EnableFeignClients`注解及其`defaultConfiguration`属性时，也可以以类似的方式指定默认配置，就像之前描述的那样。在`appplication.yml`文件中提供的设置始终比`@Configuration`
    bean具有更高的优先级。要更改这种方法，并更喜欢`@Configuration`而不是YAML文件，您应该将`feign.client.default-to-properties`属性设置为`false`。这里是一个为`account-service`设置连接超时、HTTP连接的读取超时和日志级别的Feign客户端配置示例：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have launched a couple of microservices that communicate
    with one another. We discussed such topics as different implementations of REST
    clients, load balancing between multiple instances, and integration with service
    discovery. In my opinion, these aspects are so important that I decided to describe
    them in two chapters. This chapter should be treated as an introduction to the subject
    of inter-service communication and a discussion of integration with other important
    components of microservice architecture. The next chapter will show more advanced
    use of load balancers and REST clients, with particular attention on network and
    communication problems. After reading this chapter, you should be able to use
    Ribbon, Feign, and even `RestTemplate` properly in your applications and connect
    them to other Spring Cloud components.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们启动了一对相互通信的微服务。我们讨论了诸如REST客户端的不同实现、多个实例之间的负载均衡以及与服务发现的集成等主题。在我看来，这些方面非常重要，所以我决定用两章来描述它们。本章应该被视为对内部服务通信主题的介绍，以及与微服务架构的其他重要组件集成的讨论。下一章将展示更高级的负载均衡器和REST客户端的使用，特别关注网络和通信问题。阅读完本章后，您应该能够在应用程序中正确使用Ribbon、Feign，甚至`RestTemplate`，并将它们连接到其他Spring
    Cloud组件。
- en: In most cases, this knowledge is enough. However, sometimes you will need to
    customize client-side load balancer configuration or enable more advanced communication
    mechanisms like a circuit breaker or fallback. It is important to understand these
    solutions and their impact on the inter-service communication in your system.
    We will discuss them in the next chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这些知识就足够了。然而，有时您需要定制客户端负载均衡器配置或启用更高级的通信机制，比如断路器或回退。了解这些解决方案及其对系统内部服务通信的影响非常重要。我们将在下一章中讨论它们。
