- en: Screens
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕
- en: One screen with a plain user interface is not exciting at all. However, before
    you go into eye candy styling and *wow* effects, you need to create more screens
    containing all the elements a professionally developed application must have.
    You see all this in modern applications you use in your everyday life. In the
    previous chapter, we built and ran our project. This skill is important so we
    can continue with our progress. Now you will add a UI in your application!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只有简单用户界面的屏幕一点也不令人兴奋。然而，在你进行眼睛糖样式和*哇*效果之前，你需要创建更多包含专业开发应用程序必须具有的所有元素的屏幕。你在日常生活中使用的现代应用程序中都可以看到这一点。在上一章中，我们构建并运行了我们的项目。这种技能很重要，这样我们才能继续我们的进展。现在你将在你的应用程序中添加一个UI！
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Analyzing mockup
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析模拟
- en: Defining application activities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序活动
- en: Android layouts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android布局
- en: Android Context
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android上下文
- en: Fragments, fragment manager, and stack
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 片段、片段管理器和堆栈
- en: View pager
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图翻页器
- en: Transaction, dialog fragments, and notifications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务、对话框片段和通知
- en: Other important UI components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他重要的UI组件
- en: Analyzing the mockup plan
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析模拟计划
- en: Things are getting hooked! We are ready to begin with some serious development!
    We will create all of the screens for our application. However, before we create
    them, we will create and analyze a mockup so we know what exactly we will create.
    The mockup will represent the basic application wireframe with no design. It will
    be just a layout for the screens and the relationship between them. To create
    a good mockup with wireframes, you will need a tool. Any tool capable of drawing
    lines will do the job. To draw our mockup, we used **Pencil**. Pencil is a free
    open source application providing GUI prototyping.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 事情正在变得有趣！我们准备开始一些严肃的开发！我们将为我们的应用程序创建所有的屏幕。然而，在我们创建它们之前，我们将创建并分析一个模拟，这样我们就知道我们将创建什么。模拟将代表基本的应用程序线框，没有设计。它只是屏幕和它们之间的关系的布局。要创建一个带有线框的好模拟，你需要一个工具。任何能够画线的工具都可以胜任。为了绘制我们的模拟，我们使用了**Pencil**。Pencil是一个提供GUI原型的免费开源应用程序。
- en: 'Let''s take a look at our mockup:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的模拟：
- en: '![](img/4a326c99-c11c-47a3-8633-6e16ed711c6b.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a326c99-c11c-47a3-8633-6e16ed711c6b.png)'
- en: As you can see, the mockup presents a relatively simple application with a few
    screens. There are different components that will be included in these screens,
    and we will explain these along with each screen. Let's go through the mockup.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，模拟呈现了一个相对简单的应用程序，具有一些屏幕。这些屏幕将包含不同的组件，我们将在每个屏幕中解释这些组件。让我们来看看模拟。
- en: The first screen, titled Landing screen, will be our main application screen.
    Every time we enter the application, this screen will appear. We already defined
    the `MainActivity` class. This activity will represent the screen. Soon, we will
    extend the code so the activity follows the mockup exactly as described.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个屏幕，标题为登陆界面，将是我们的主要应用程序屏幕。每次进入应用程序时，都会出现此屏幕。我们已经定义了`MainActivity`类。这个活动将代表这个屏幕。很快，我们将扩展代码，使活动完全按照模拟进行。
- en: The central part of the screen will be the list containing all the items we
    created. Each item will contain basic properties, such as title or date and time.
    We will be able to filter items by type. We will be able to filter only Notes
    or TODOs. The difference between Notes and TODOs is that TODOs will represent
    tasks with the *date* and *time* assigned. We will also support some functionalities
    such as the onLongPress events. The onLongPress event on each item will present
    a Popup menu with the Edit, Remove, or Complete options. Clicking on Edit will
    open the screen for updating.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕的中心部分将是包含我们创建的所有项目的列表。每个项目将包含基本属性，如标题或日期和时间。我们将能够按类型过滤项目。我们将只能过滤笔记或TODO。笔记和TODO之间的区别在于TODO将代表具有分配的*日期*和*时间*的任务。我们还将支持一些功能，如长按事件。在每个项目上的长按事件将呈现一个弹出菜单，其中包含编辑、删除或完成选项。点击编辑将打开更新屏幕。
- en: At the bottom-right corner, we will have a + button. The purpose of the button
    is to open the option Dialog on which a user can choose if they want to create
    a Note or TODO task. Depending on the option, a user can choose one of the screens
    that appear--Add note screen or Add TODO screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在右下角，我们将有一个+按钮。该按钮的目的是打开选项对话框，用户可以选择他们想要创建笔记还是TODO任务。根据选项，用户可以选择出现的屏幕之一--添加笔记屏幕或添加TODO屏幕。
- en: 'Landing screen also contains the Sliding menu button positioned at its top-left
    corner. Clicking on that button will open the Sliding menu with the following
    items in it:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 登陆界面还包含位于左上角的滑动菜单按钮。点击该按钮将打开滑动菜单，其中包含以下项目：
- en: An application icon with the application title and version
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有应用程序标题和版本的应用程序图标
- en: A Today button to filter only TODO items assigned for the current date
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个今天的按钮，用于仅过滤分配给当前日期的TODO项目
- en: A Next 7 Days button to filter TODO items assigned in the Next 7 Days including
    the current one
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个下一个7天的按钮，用于过滤分配给下一个7天的TODO项目，包括当前的日期
- en: A TODOs button filter only TODO items
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个TODO按钮仅过滤TODO项目
- en: The Notes button will filter only the Note items
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记按钮将仅过滤笔记项目
- en: Applying some of these filters will affect the checkboxes from the Popup menu
    we get by clicking on the top-right corner of the Landing screen. Also, checking
    and unchecking those will modify the currently applied filter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 应用一些过滤器将影响我们通过点击登陆界面右上角获得的弹出菜单中的复选框。此外，选中和取消选中这些复选框将修改当前应用的过滤器。
- en: The last item in the sliding menu is Synchronize now. This button will trigger
    synchronization and synchronize all unsynchronized items with backend if there
    are any.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 滑动菜单中的最后一项是立即同步。点击此按钮将触发同步，并将所有未同步的项目与后端进行同步。
- en: 'Now we will explain two screens responsible for the creation (or editing) of
    Notes and TODOs:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将解释两个负责创建（或编辑）笔记和TODO的屏幕：
- en: 'Add/Edit note screen: This is used to create a new note or to update the content
    of an existing one. Keyboard will be opened as edit text field is focused. There
    is no save or update button since we plan that all changes we make are applied
    immediately. The top-left and top-right buttons are disabled while we are on this
    screen.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加/编辑笔记屏幕：用于创建新的笔记或更新现有内容。当编辑文本字段聚焦时，键盘将打开。由于我们计划立即应用我们所做的所有更改，因此没有保存或更新按钮。在此屏幕上，左上角和右上角的按钮也被禁用。
- en: 'Add/Edit TODO screen: This is used to create a new TODO application or to update
    the content of an existing one. Keyboard will open as in the previous example.
    There is no save or update button as shown in the previous example, either. The
    top-left and top-right buttons are disabled too. Following are the title view,
    we have buttons to pick date and time. By default, they will be set to the current
    date and time. Opening keyboard will push these buttons up.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加/编辑TODO屏幕：用于创建新的TODO应用程序或更新现有内容。键盘将像前面的示例一样打开。也没有像前面的示例中显示的保存或更新按钮。左上角和右上角的按钮也被禁用。在标题视图之后，我们有按钮来选择日期和时间。默认情况下，它们将设置为当前日期和时间。打开键盘将推动这些按钮。
- en: We covered the basic UI and what we want to achieve by analyzing this mockup.
    The time has come to create some new screens.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了基本的UI和通过分析这个模型我们想要实现的内容。现在是时候创建一些新的屏幕了。
- en: Defining application activities
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义应用程序活动
- en: 'To sum up, we will have three activities:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们将有三个活动：
- en: Landing activity (`MainActivty.kt`)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登陆活动（`MainActivty.kt`）
- en: Add/Edit note screen
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加/编辑笔记屏幕
- en: Add/Edit TODO screen
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加/编辑TODO屏幕
- en: It's common practice in Android development to create an activity that will
    be a parent class to all other activities because, like this, we will reduce code
    base and share it at the same time with multiple activites. In most cases, Android
    developers call it `BaseActivity`. We will define our version of `BaseActivity`.
    Create a new class called `BaseActivity`; the `BaseActivity.kt` file is created.
    Make sure the newly created class is located under the `Activity` package of your
    project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android开发中，通常会创建一个活动，作为所有其他活动的父类，因为这样，我们将减少代码库，并同时与多个活动共享。在大多数情况下，Android开发人员称之为`BaseActivity`。我们将定义我们自己的`BaseActivity`版本。创建一个名为`BaseActivity`的新类；创建`BaseActivity.kt`文件。确保新创建的类位于项目的`Activity`包下。
- en: The `BaseActivity` class must extend the `FragmentActivity` class of Android
    SDK. We will extend `FragmentActivity` because we plan to use fragments inside
    our `MainActivity` class. Fragments will be used with ViewPager to navigate between
    different filters (Today, Next 7 Days, and so on). We plan that when the user
    clicks on one of those from our sliding menu, ViewPager automatically swipes to
    position with the fragment containing the data filtered by the chosen criteria.
    We will extend `FragmentActivity` from the package as follows--`android.support.v4.app.FragmentActivity`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseActivity`类必须扩展Android SDK的`FragmentActivity`类。我们将扩展`FragmentActivity`，因为我们计划在`MainActivity`类中使用片段。片段将与ViewPager一起使用，以在不同的过滤器之间导航（今天，接下来的7天等）。我们计划当用户从我们的侧滑菜单中点击其中一个时，ViewPager会自动切换到包含由所选条件过滤的数据的片段的位置。我们将从包`android.support.v4.app.FragmentActivity`扩展`FragmentActivity`。'
- en: 'Android provides a way to support multiple API versions. Since we plan to do
    so, we will use the `FragmentActivity` version from the support library. Like
    this, we maximize our compatibility! To add support for the Android support library,
    include the following directive in the `build`.`gradle` configuration:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了支持多个API版本的方法。因为我们计划这样做，我们将使用支持库中的`FragmentActivity`版本。这样，我们最大化了兼容性！要为Android支持库添加支持，请在`build.gradle`配置中包含以下指令：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you probably remember, we did so!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，我们已经这样做了！
- en: Let's continue! Since we are introducing a base class for all activities, we
    have to do some small refactoring to the only activity we have now. We will move
    the `tag` field from `MainActivity` to `BaseActivity`. Since it must be accessible
    to children of `BaseActivity`, we will update its visibility to `protected`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续！由于我们正在为所有活动引入一个基类，我们现在必须对我们现有的唯一活动进行一些小的重构。我们将`tag`字段从`MainActivity`移动到`BaseActivity`。由于它必须对`BaseActivity`的子类可访问，我们将更新其可见性为`protected`。
- en: 'We want each `Activity` class to have its unique tag. We will use activity
    concretization to choose the value for its tag. So, the `tag` field becomes `abstract`
    with no default value assigned:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望每个`Activity`类都有其独特的标签。我们将使用活动具体化来选择其标签的值。因此，`tag`字段变为`abstract`，没有分配默认值：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Beside this, we have some more common stuff in all activities. Each activity
    will have a layout. A layout is Android identified by the ID of the integer type.
    In the `BaseActivity` class, we will create an `abstract` method, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有活动中还有一些共同的东西。每个活动都将有一个布局。布局在Android中由整数类型的ID标识。在`BaseActivity`类中，我们将创建一个`abstract`方法，如下：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To optimize the code, we will move `onCreate` from `MainActivity` to `BaseActivity`.
    Instead of passing the ID of the layout from the Android generated resource directly,
    we will pass the result value of the `getLayout()` method. We will move all other
    lifecycle method overrides as well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化代码，我们将把`onCreate`从`MainActivity`移动到`BaseActivity`。我们将不再直接传递Android生成的资源中布局的ID，而是传递`getLayout()`方法的结果值。我们也会移动所有其他生命周期方法的覆盖。
- en: 'Update your classes according to these changes and build and run the application
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些更改更新您的类，并按以下方式构建和运行应用程序：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we are ready to define the rest of the screens. We have to create a screen
    for adding and editing Notes and a screen that does the same for TODOs. There
    is a lot of common between these screens. The only difference for now is that
    the TODOs screen has buttons for date and time. We will create a common class
    for everything that these screens share. Each concretization will extend it. Create
    a class called `ItemActivity`. Make sure it's located in the `Activity` package.
    Create two more classes--`NoteActivity` and `TodoActivity`. `ItemActivity` extends
    our `BaseActivity` class and `NoteActivity` and `TodoActivity` activity classes
    extend `ItemActivity` class. You will be asked to override members. Please do
    so. Give some meaningful value for the tag we will use in logging. To assign a
    proper layout ID first we must create it!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备定义其余的屏幕。我们必须创建一个用于添加和编辑笔记的屏幕，以及一个用于TODO的相同功能的屏幕。这些屏幕之间有很多共同之处。目前唯一的区别是TODO屏幕有日期和时间的按钮。我们将为这些屏幕共享的所有内容创建一个通用类。每个具体化都将扩展它。创建一个名为`ItemActivity`的类。确保它位于`Activity`包中。再创建两个类--`NoteActivity`和`TodoActivity`。`ItemActivity`扩展我们的`BaseActivity`类，`NoteActivity`和`TodoActivity`活动类扩展`ItemActivity`类。您将被要求覆盖成员。请这样做。为我们在日志中使用的标签赋予一些有意义的值。要分配适当的布局ID，首先我们必须创建它！
- en: 'Locate the layout we created for the main screen. Now, using the same principle,
    create two more layouts:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 找到我们为主屏幕创建的布局。现在，使用相同的原则，创建另外两个布局：
- en: '`activity_note.xml`, let it be the `LinearLayout` class if asked'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activity_note.xml`，如果被问到，让它成为`LinearLayout`类。'
- en: '`activity_todo.xml`, let it be the `LinearLayout` class if asked'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`activity_todo.xml`，如果被问到，让它成为`LinearLayout`类'
- en: 'Any layout or layout member in Android gets a unique ID as `integer` representation
    in the `R` class that Android generates during the build. The `R` class for our
    application is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，任何布局或布局成员都会在构建过程中由Android生成的`R`类中获得唯一的ID作为`integer`表示。我们应用程序的`R`类如下：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To access the layout, use the following line of code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问布局，请使用以下代码行：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We use static access. So, let''s update our class concretizations to access
    layout IDs. Classes now look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用静态访问。因此，让我们更新我们的类具体化以访问布局ID。类现在看起来像这样：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Last step is to register our screens (activities) in `view groups`. Open the
    `manifest` file and add the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在`view groups`中注册我们的屏幕（活动）。打开`manifest`文件并添加以下内容：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Both activities are locked to `portrait` orientation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 两个活动都锁定为“竖屏”方向。
- en: We made progress! We defined our application screens. In the next section, we
    will populate the screens it with UI components.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们取得了进展！我们定义了我们的应用程序屏幕。在下一节中，我们将用UI组件填充屏幕。
- en: Android layouts
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android布局
- en: We will continue our work by defining layouts for each screen. Layouts in Android
    are defined in XML. We will mention the most commonly used layout types and populate
    them with commonly used layout components.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续通过定义每个屏幕的布局来继续我们的工作。在Android中，布局是用XML定义的。我们将提到最常用的布局类型，并用常用的布局组件填充它们。
- en: 'Each layout file has one of the layout types as its top-level container. Layouts
    can contain other layouts with UI components and so on. We can nest it. Let''s
    mention the most commonly used layout types:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 每个布局文件都有一个布局类型作为其顶级容器。布局可以包含其他具有UI组件等的布局。我们可以嵌套它。让我们提到最常用的布局类型：
- en: '**Linear layout**: This aligns UI components in a linear order, vertically
    or horizontally'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性布局**：这将以线性顺序垂直或水平对齐UI组件'
- en: '**Relative layout**: These UI components are aligned relatively to each other'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相对布局**：这些UI组件相对地对齐'
- en: '**List view layout**: All items are organized in the form of a list'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表视图布局**：所有项目都以列表形式组织'
- en: '**Grid view layout**: All items are organized in the form of a grid'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格视图布局**：所有项目都以网格形式组织'
- en: '**Scroll view layout**: This is used to enable scrolling when its content becomes
    higher than the actual height of the screen'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动视图布局**：当其内容变得高于屏幕的实际高度时，用于启用滚动'
- en: Layout elements that we just mentioned are `view groups`. Each view group contains
    other views. `View groups` extend the `ViewGroup` class. At the top, everything
    is a `View` class. Classes (views) that are extending the `View` class, but do
    not extend `ViewGroup`, can't contain other elements (children). Such examples
    are `Button`, `ImageButton`, `ImageView`, and similar classes. Therefore, it's
    possible, for example, to define a `RelativeLayout` that contains a `LinearLayout`,
    which contains other multiple views aligned vertically or horizontally and so
    on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚提到的布局元素是`view groups`。每个视图组包含其他视图。`View groups`扩展了`ViewGroup`类。在顶部，一切都是`View`类。扩展`View`类但不扩展`ViewGroup`的类（视图）不能包含其他元素（子元素）。这样的例子是`Button`，`ImageButton`，`ImageView`和类似的类。因此，例如，可以定义一个包含`LinearLayout`的`RelativeLayout`，该`LinearLayout`包含垂直或水平对齐的其他多个视图等。
- en: 'We will now highlight some commonly used views:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将突出显示一些常用的视图：
- en: '`Button`: This is a `Base` class that represents a button linked to the `onClick`
    action we define'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button`：这是一个与我们定义的`onClick`操作相关联的`Base`类按钮'
- en: '`ImageButton`: This is a button with an image used as its visual representation'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageButton`：这是一个带有图像作为其视觉表示的按钮'
- en: '`ImageView`: This is a view that displays an image loaded from different sources'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageView`：这是一个显示从不同来源加载的图像的视图'
- en: '`TextView`: This is a view that contains single or multiline non-editable text'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextView`：这是一个包含单行或多行不可编辑文本的视图'
- en: '`EditText`: This is a view that contains single or multiline editable text'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditText`：这是一个包含单行或多行可编辑文本的视图'
- en: '`WebView`: This is a view that presents rendered HTML pages loaded from different
    sources'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WebView`：这是一个呈现从不同来源加载的渲染HTML页面的视图'
- en: '`CheckBox`: This is a main two-states choice view'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CheckBox`：这是一个主要的两状态选择视图'
- en: Every `View` and `ViewGroup` supports misc XML attributes. Some attributes are
    specific to only certain view types. There are also attributes that are the same
    for all views. We will highlight the most commonly used view attributes through
    the examples of our screens later in this chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`View`和`ViewGroup`都支持杂项XML属性。一些属性仅适用于特定的视图类型。还有一些属性对所有视图都是相同的。我们将在本章后面的屏幕示例中突出显示最常用的视图属性。
- en: 'To assign a unique identifier by which you can access a view through the code
    or other layout members, you must define an ID. To assign an ID to a view, use
    the syntax like in this example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过代码或其他布局成员访问视图，必须定义一个唯一标识符。要为视图分配ID，请使用以下示例中的语法：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, we assigned the `my_button` ID to a view. To access it from
    code, we will use the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为一个视图分配了`my_button` ID。要从代码中访问它，我们将使用以下方法：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`R` is a generated class providing us access to resources. To create an instance
    of the button, we will use the `findViewById()` method defined in the Android
    `Activity` class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`R`是一个生成的类，为我们提供对资源的访问。要创建按钮的实例，我们将使用Android `Activity`类中定义的`findViewById()`方法：'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we used Kotlin, we can access it directly, as shown in this example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了Kotlin，我们可以直接访问它，如本例所示：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The IDE will ask you about a proper import. Keep in mind that other layout resource
    files can have an ID with the same name defined. In that case, it can happen that
    you have a wrong import! If that happens, your application will crash.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: IDE会询问您有关适当的导入。请记住，其他布局资源文件可能具有相同名称的ID定义。在这种情况下，可能会发生错误的导入！如果发生这种情况，您的应用程序将崩溃。
- en: 'The `@` symbol at the beginning of the string indicates that the XML parser
    should parse and expand the rest of the ID string and identify it as an ID resource.
    The `+` symbol means that this is a new resource name. When referencing an Android
    resource ID, you do not need the `+` symbol, as shown in this example:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串开头的`@`符号表示XML解析器应解析并扩展ID字符串的其余部分，并将其标识为ID资源。`+`符号表示这是一个新的资源名称。当引用Android资源ID时，不需要`+`符号，如本例所示：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s build our UI for the main application screen! We will start with some
    prerequisites. In the values resource directory, create `dimens.xml` to define
    some dimensions we will use:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为主应用程序屏幕构建我们的UI！我们将从一些先决条件开始。在值资源目录中，创建`dimens.xml`来定义我们将使用的一些尺寸：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Android defines dimensions in the following units:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Android以以下单位定义尺寸：
- en: '**px (pixels)**: This corresponds to actual pixels on the screen'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**像素（pixels）**：这对应于屏幕上的实际像素'
- en: '**in (inches)**: This is based on the physical size of the screen, that is,
    1 inch = 2.54 centimeters'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**英寸（inches）**：这是基于屏幕的物理尺寸，即1英寸=2.54厘米'
- en: '**mm (millimeters)**: This is based on the physical size of the screen'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**毫米（millimeters）**：这是基于屏幕的物理尺寸'
- en: '**pt (points)**: This is the 1/72 of an inch based on the physical size of
    the screen'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点（points）**：这是基于屏幕的物理尺寸的1/72'
- en: 'And the most important for us is the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说最重要的是以下内容：
- en: '**dp (Density-independent Pixels)**: This represents an abstract unit that
    is based on the physical density of the screen. They are relative to a 160 DPI
    screen. One dp is one pixel on a 160 DPI screen. The ratio of dp-to-pixel will
    change with the screen density, but not necessarily in direct proportion.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**dp（密度无关像素）**：这代表一个基于屏幕物理密度的抽象单位。它们相对于160 DPI的屏幕。一个dp在160 DPI屏幕上等于一个像素。dp到像素的比率会随着屏幕密度的变化而改变，但不一定成正比。'
- en: '**sp (Scale-independent Pixels)**: These are like the dp unit and generally
    used for font size.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sp（可伸缩像素）**：这类似于dp单位，通常用于字体大小。'
- en: 'We have to define a header layout that will be included on all screens. Create
    the `activity_header.xml` file and define it like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须定义一个将包含在所有屏幕上的页眉布局。创建`activity_header.xml`文件并像这样定义它：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's explain the most important parts of it. First of all, we have defined
    `RelativeLayout` as our main container. Since all elements are positioned relatively
    to the parent and to each other, we will use some special attributes to express
    these relationships.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释其中最重要的部分。首先，我们将`RelativeLayout`定义为我们的主容器。由于所有元素都相对于父元素和彼此定位，我们将使用一些特殊属性来表达这些关系。
- en: 'For every view, we must have width and height attributes. Values for it can
    be as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个视图，我们必须有宽度和高度属性。其值可以如下：
- en: 'Dimension defined in the dimension resource file, for example:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在尺寸资源文件中定义的尺寸，例如：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Directly defined dimension value, for example:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接定义的尺寸值，例如：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Match the size of the parent (`match_parent`)
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配父级的大小（`match_parent`）
- en: Or wrap the content of the view (`wrap_content`)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者包装视图的内容（`wrap_content`）
- en: 'Then, we will populate the layout with children views. We have three children
    views. We will define two buttons and one text view. Text view is aligned to the
    center of the layout. Buttons are aligned with edges of the layout--one to the
    left and the other to the right. To achieve central alignment of the text view,
    we used the `layout_centerInParent` attribute. The value passed to it is the Boolean
    true. To align a button at the layout''s left edge, we used the `layout_alignParentStart`
    attribute. For the right edge, we used the `layout_alignParentEnd` attribute.
    Each child has a proper ID assigned. We will include this in `MainActivity`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用子视图填充布局。我们有三个子视图。我们将定义两个按钮和一个文本视图。文本视图对齐到布局的中心。按钮对齐到布局的边缘——一个在左边，另一个在右边。为了实现文本视图的中心对齐，我们使用了`layout_centerInParent`属性。传递给它的值是布尔值true。为了将按钮对齐到布局的左边缘，我们使用了`layout_alignParentStart`属性。对于右边缘，我们使用了`layout_alignParentEnd`属性。每个子视图都有一个适当的ID分配。我们将在`MainActivity`中包含这个：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The main container for `Main activity` is `LinearLayout`. An orientation attribute
    for `LinearLayout` is mandatory:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main activity`的主容器是`LinearLayout`。`LinearLayout`的方向属性是强制性的：'
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Values that can be assigned to it are vertical and horizontal. As the first
    child of the `Main activity`, we included the `activity_header` layout. Then we
    defined `RelativeLayout`, which fills the rest of screen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可以分配给它的值是垂直和水平。作为`Main activity`的第一个子元素，我们包含了`activity_header`布局。然后我们定义了`RelativeLayout`，它填充了屏幕的其余部分。
- en: '`RelativeLayout` has two members, `ListView` that will present all our items.
    We assigned a background to it. We did not define our own color in the colors
    resource file, but the one predefined in Android. Last view we have here is `FloatingActionButton`,
    the same one you can see in the Gmail Android application. The button will be
    positioned over the list with items at the bottom of the screen aligned to the
    right. We also set a margin that will surround the button from all sides. Take
    a look at the attributes we used.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`RelativeLayout`有两个成员，`ListView`将呈现所有的项目。我们为它分配了一个背景。我们没有在颜色资源文件中定义自己的颜色，而是使用了Android中预定义的颜色。我们在这里的最后一个视图是`FloatingActionButton`，和你在Gmail
    Android应用程序中看到的一样。按钮将被定位在屏幕底部对齐右侧的项目列表上。我们还设置了一个边距，将从四面包围按钮。看一下我们使用的属性。'
- en: 'Before we run our application again, we will make a few more changes. Open
    `BaseActivity` and update its code as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们再次运行应用程序之前，我们将做一些更改。打开`BaseActivity`并更新其代码如下：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We introduced the `abstract` method that will provide a proper title for each
    activity. We will `access` the `activity_title` view defined in `activity_header.xml`,
    which is included in our activity, and assign the value we get by executing the
    method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个`abstract`方法，它将为每个活动提供一个适当的标题。我们将`access`在`activity_header.xml`中定义的`activity_title`视图，它包含在我们的活动中，并赋予我们执行该方法得到的值。
- en: 'Open `MainActivity` and override the following method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`MainActivity`并重写以下方法：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the same line to `ItemActivity`. Finally, run the application. Your main
    screen should look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ItemActivity`中添加相同的行。最后，运行应用程序。你的主屏幕应该是这样的：
- en: '![](img/5ff9331e-6609-466a-9375-7fbeb062a8af.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ff9331e-6609-466a-9375-7fbeb062a8af.png)'
- en: 'Let''s define layouts for the rest of the screens. For the Notes, Add/Edit
    note screen, we will define the following layout:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为其余的屏幕定义布局。对于笔记、添加/编辑笔记屏幕，我们将定义以下布局：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are a few important things that we must highlight. We will explain them
    one by one. We introduced `ScrollView` as our top container for the layout. Since
    we will populate multiline notes, it will happen that its content goes below the
    physical limit of the screen. If that happens, we will be able to scroll the content.
    We used one very important attribute--`fillViewport`. This attribute tells the
    container to stretch to the whole screen. All children use that space.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些重要的事情我们必须强调。我们会逐一解释它们。我们将`ScrollView`作为我们布局的顶级容器。由于我们将填充多行注释，它的内容可能会超出屏幕的物理限制。如果发生这种情况，我们将能够滚动内容。我们使用了一个非常重要的属性--`fillViewport`。这个属性告诉容器要拉伸到整个屏幕。所有子元素都使用这个空间。
- en: Using EditText views
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EditText视图
- en: 'We introduced the `EditText` views to enter editable text content. You can
    see some new attributes here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了`EditText`视图来输入可编辑的文本内容。你可以在这里看到一些新的属性：
- en: '**hint**: This defines the default string value that will be presented to the
    user'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hint**：这定义了将呈现给用户的默认字符串值'
- en: '**padding**: This is the space between the view itself and its content'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**padding**：这是视图本身和其内容之间的空间'
- en: '**gravity**: This defines direction for the content; in our case, all text
    will stick to the top of the parent view'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gravity**：这定义了内容的方向；在我们的例子中，所有的文本都将粘在父视图的顶部'
- en: Note that, for all strings and dimensions, we defined proper entries in the
    `strings.xml` file and the `dimens.xml` file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于所有的字符串和尺寸，我们在`strings.xml`文件和`dimens.xml`文件中定义了适当的条目。
- en: 'The strings resource file now looks like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在字符串资源文件看起来是这样的：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Again, the top container is `ScrollView`. Compared to the previous screen,
    we have introduced some differences. We added the container to hold buttons for
    date and time picking. The orientation is horizontal. We set the parent container
    attribute, `weightSum`, to define the weight value that can be divided by children
    views so each child takes the amount of space defined by its own weight. So, `weightSum`
    is one. First button has a `layout_weight` of `0.5`. It will consume 50% of the
    horizontal space. The second button has the same value. We achieved view splitting
    in two halves. Locate the bottom of your XML and click on Design to switch to
    Design view. Your buttons should look like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，顶级容器是`ScrollView`。与之前的屏幕相比，我们引入了一些不同之处。我们添加了一个容器来容纳日期和时间选择的按钮。方向是水平的。我们设置了父容器属性`weightSum`，以定义可以被子视图分割的权重值，这样每个子视图都可以占据其自己权重定义的空间量。所以，`weightSum`是1。第一个按钮的`layout_weight`是`0.5`。它将占据水平空间的50%。第二个按钮也是相同的值。我们实现了视图分割成两半。定位到XML的底部，点击Design切换到Design视图。你的按钮应该是这样的：
- en: '![](img/f065d15d-1b8e-4818-a721-f6a7c5532f48.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f065d15d-1b8e-4818-a721-f6a7c5532f48.png)'
- en: We defined layouts for our screens. To express how these screens should look,
    we relied on many different attributes. This is just a small portion of the available
    attributes we can use. To make this section complete, we will present you with
    some other important attributes that you will use in everyday development.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的屏幕定义了布局。为了表达这些屏幕应该是什么样子，我们依赖于许多不同的属性。这只是我们可以使用的可用属性的一小部分。为了使这一部分完整，我们将向您介绍一些其他重要的属性，这些属性在日常开发中会用到。
- en: The margins attribute
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边距属性
- en: 'Margins accept dimension resources or direct dimension values in one of the
    following supported units:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 边距接受维度资源或直接维度值，支持以下支持的单位之一：
- en: '`layout_margin`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_margin`'
- en: '`layout_marginTop`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_marginTop`'
- en: '`layout_marginBottom`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_marginBottom`'
- en: '`layout_marginStart`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_marginStart`'
- en: '`layout_marginEnd`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`layout_marginEnd`'
- en: The padding attribute
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充属性
- en: 'Padding accepts dimension resources or direct dimension values in one of the
    following supported units:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 填充接受维度资源或直接维度值，支持以下支持的单位之一：
- en: '`padding`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`padding`'
- en: '`paddingTop`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paddingTop`'
- en: '`paddingBottom`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paddingBottom`'
- en: '`paddingStart`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paddingStart`'
- en: '`paddingEnd`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paddingEnd`'
- en: Checking out the gravity attribute
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查重力属性
- en: 'View Gravity:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 视图重力：
- en: '**gravity (direction of the content inside the view)**: This accepts the following--`top`,
    `left`, `right`, `start`, `end`, `center`, `center_horizontal`, `center_vertical`,
    and many other'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重力（视图内内容的方向）**：这接受以下内容--`top`，`left`，`right`，`start`，`end`，`center`，`center_horizontal`，`center_vertical`，以及许多其他'
- en: '**layout_gravity (direction of the content inside the view parent)**: This
    accepts the following--`top`, `left`, `right`, `left`, `start`, `end`, `center`,
    `center_horizontal`, `center_vertical`, and many others'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`layout_gravity`（视图父级内内容的方向）**：这接受以下内容--`top`，`left`，`right`，`left`，`start`，`end`，`center`，`center_horizontal`，`center_vertical`，以及许多其他'
- en: 'It''s possible to combine values for gravity as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将重力的值组合如下：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Looking at other attributes
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看其他属性
- en: 'We just saw the most important attributes we will use. It is time to see other
    attributes you may find handy. Other attributes are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了我们将使用的最重要的属性。现在是时候看看其他你可能会发现方便的属性了。其他属性如下：
- en: '`src`: This is the resource to use:'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`src`：这是要使用的资源：'
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`background`: Background for the view, hex color, or color resource is as follows:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background`：视图的背景，十六进制颜色或颜色资源如下：'
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`onClick`: This is the method to be invoked when a user clicks on the view
    (usually a button)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onClick`：这是当用户点击视图（通常是按钮）时要调用的方法'
- en: '`visibility`: This is the visibility of the view, which accepts the following
    parameters--gone (invisible and does not consume any layout space), invisible
    (invisible but consumes layout space), and visible'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visibility`：这是视图的可见性，接受以下参数--gone（不可见且不占用任何布局空间），invisible（不可见但占用布局空间），visible'
- en: '`hint`: This is the hint text for the view, and it accepts a string value or
    a string resource'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hint`：这是视图的提示文本，它接受一个字符串值或字符串资源'
- en: '`text`: This is the text for the view, and it accepts a string value or a string
    resource'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text`：这是视图的文本，它接受一个字符串值或字符串资源'
- en: '`textColor`: This is the color for the text, hex color, or color resource'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textColor`：这是文本的颜色，十六进制颜色或颜色资源'
- en: '`textSize`: This is the size for the text in supported units--direct unit value
    or dimension resource'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textSize`：这是支持单位的文本大小--直接单位值或尺寸资源'
- en: '`textStyle`: This is the style resource that defines attributes to assign to
    view, as follows:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`textStyle`：这是定义要分配给视图的属性的样式资源，如下：'
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this section, we covered working with attributes. Without them, we can't
    develop our UI. In the rest of this chapter, we will introduce you to Android
    Context.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们介绍了使用属性。没有它们，我们无法开发我们的UI。在本章的其余部分，我们将向您介绍安卓上下文。
- en: Understanding Android Context
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解安卓上下文
- en: All our main screens now have their layouts defined. We will now explain Android
    Context since each screen we just created represents one `Context` instance. If
    you go through the class definition and follow class extension, you will realize
    that each activity we create extends the `Context` class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的主屏幕现在都有了它们的布局定义。现在我们将解释安卓上下文，因为我们刚刚创建的每个屏幕都代表一个`Context`实例。如果您查看类定义并遵循类扩展，您将意识到我们创建的每个活动都扩展了`Context`类。
- en: '`Context` represents the current state of the application or object. It is
    used to access specific classes and resources of the application. For example,
    consider the following lines of code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`代表应用程序或对象的当前状态。它用于访问应用程序的特定类和资源。例如，考虑以下代码行：'
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Access we showed is provided by the `Context` class, which shows our activities
    are extending. `Context` is needed when we have to launch another activity, start
    a service, or send broadcast messages. We will show use of these methods when
    the time is proper. We already mentioned that each screen (`Activity`) of an Android
    application represents a `Context` instance. Activities are not the only classes
    that represent context. Except activities, we have the service context type too.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示的访问是由`Context`类提供的，它显示了我们的活动是如何扩展的。当我们需要启动另一个活动、启动服务或发送广播消息时，需要`Context`。当时机合适时，我们将展示这些方法的使用。我们已经提到，安卓应用的每个屏幕（`Activity`）都代表一个`Context`实例。活动并不是唯一代表上下文的类。除了活动，我们还有服务上下文类型。
- en: 'Android Context has the following purposes:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓上下文有以下目的：
- en: Showing a dialog
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示对话框
- en: Starting an activity
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动活动
- en: Inflating layout
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 充气布局
- en: Starting a service
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动服务
- en: Binding to a service
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定到服务
- en: Sending a broadcast message
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送广播消息
- en: Registering for broadcast messages
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册广播消息
- en: And, like we already showed in the preceding example, loading resources
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而且，就像我们在前面的例子中已经展示的那样，加载资源
- en: '`Context` is an important part of Android and one of the most frequently used
    classes of the framework. Later in this book, you will meet other `Context` classes.
    However, before that, we will be focused on fragments and their explanation.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`是安卓的重要组成部分，也是框架中最常用的类之一。在本书的后面，您将遇到其他`Context`类。然而，在那之前，我们将专注于片段及其解释。'
- en: Understanding fragments
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解片段
- en: 'We have mentioned that the central part of our main screen will contain a list
    of filtered items. We want to have several pages with a different set of filters
    applied. A user will be able to swipe left or right to change the filtered content
    and navigate through the following pages:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到，我们的主屏幕的中心部分将包含一个经过筛选的项目列表。我们希望有几个页面应用不同的筛选集。用户将能够向左或向右滑动以更改筛选内容并浏览以下页面：
- en: All displayed
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有显示的
- en: Items for Today
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 今天的事项
- en: Items for Next 7 Days
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来7天的事项
- en: Only Notes
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有笔记
- en: Only TODOs
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有待办事项
- en: To achieve this functionality, we will need to define fragments. What are fragments
    and what is their purpose?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个功能，我们需要定义片段。片段是什么，它们的目的是什么？
- en: A fragment is a portion of the interface of an `Activity` instance. You can
    use fragments to create multiplane screens or screens with view paging, like in
    our case.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 片段是`Activity`实例界面的一部分。您可以使用片段创建多平面屏幕或具有视图分页的屏幕，就像我们的情况一样。
- en: 'Just like activities, fragments have their own lifecycle. Fragment lifecycle
    is presented in the following diagram:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就像活动一样，片段也有自己的生命周期。片段生命周期在以下图表中呈现：
- en: '![](img/d658d3db-bfe9-469b-a79a-d1736ce31949.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d658d3db-bfe9-469b-a79a-d1736ce31949.png)'
- en: 'There are some additional methods that activities do not have:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些活动没有的额外方法：
- en: '`onAttach()`: This is executed when a fragment is associated to an activity.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAttach()`: 当片段与活动关联时执行。'
- en: '`onCreateView()`: This instantiates and returns a fragment''s view instance.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateView()`: 这实例化并返回片段的视图实例。'
- en: '`onActivityCreated()`: This executes when an activity''s `onCreate()` is executed.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onActivityCreated()`: 当活动的`onCreate()`被执行时执行。'
- en: '`onDestroyView()`: This executes when a view is destroyed; it is convenient
    when some cleanup is needed.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDestroyView()`: 当视图被销毁时执行；当需要进行一些清理时很方便。'
- en: '`onDetach()`: This is executed when a fragment is unassociated from an activity.
    To demonstrate the use of fragments, we will put the central part of our `MainActivity`
    into one single fragment. Later, we will move it to `ViewPager` and add more pages
    to it.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDetach()`: 当片段与活动解除关联时执行。为了演示片段的使用，我们将`MainActivity`的中心部分放入一个单独的片段中。稍后，我们将把它移到`ViewPager`并添加更多页面。'
- en: 'Create a new package called `fragment`. Then, create a new class called `BaseFragment`.
    Update your `BaseFragment` class according to this example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`fragment`的新包。然后，创建一个名为`BaseFragment`的新类。根据此示例更新您的`BaseFragment`类：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Pay attention to imports:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意导入：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We want maximal compatibility, so we are importing fragments from the Android
    support library.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望最大限度地提高兼容性，因此我们正在从Android支持库中导入片段。
- en: 'As you can see, we did something similar to what we did with `BaseActivity`.
    Create a new fragment, a class named `ItemsFragment`. Update its code according
    to this example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们做了与`BaseActivity`相似的事情。创建一个新的片段，一个名为`ItemsFragment`的类。根据此示例更新其代码：
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We introduced a new layout that actually contains the list view we had in `activity_main`.
    Create a new layout resource called `fragment_items`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个实际包含我们在`activity_main`中的列表视图的新布局。创建一个名为`fragment_items`的新布局资源：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You already saw this. It is just a part we extracted from the `activity_main`
    layout. Instead of this, we put the following in the `activity_main` layout:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了这个。这只是我们从`activity_main`布局中提取出来的一部分。除此之外，我们将以下内容放入`activity_main`布局中：
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`FrameLayout` will be our `fragment` container. To show the new fragment in
    `fragment_container``FrameLayout`, update the code of `MainActivity` as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameLayout`将是我们的`fragment`容器。要在`fragment_container``FrameLayout`中显示新片段，请按照以下方式更新`MainActivity`的代码：'
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We accessed `supportFragmentManager`. If we did not choose to use the Android
    support library, we would use `fragmentManager`. Then, we start fragment transaction,
    to which, we add a new fragment instance that will be associated to `fragment_container`
    `FrameLayout`. The `commit` method executes this transaction. If we run our application
    now, we will not notice anything different, but, if we take a look at the logs,
    we may notice that the fragment lifecycle has been executed:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们访问了`supportFragmentManager`。如果我们选择不使用Android支持库，我们将使用`fragmentManager`。然后，我们开始片段事务，我们添加一个新的片段实例，该实例将与`fragment_container`
    `FrameLayout`相关联。`commit`方法执行此事务。如果我们现在运行我们的应用程序，我们不会注意到任何不同，但是，如果我们查看日志，我们可能会注意到片段生命周期已被执行：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We added a simple fragment to our interface. In the next section, you will learn
    more about fragment manager and its purpose. Then, we will do something very interesting--we
    will create a `ViewPager`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在界面中添加了一个简单的片段。在下一节中，您将了解有关片段管理器及其目的的更多信息。然后，我们将做一些非常有趣的事情--我们将创建一个`ViewPager`。
- en: Fragment manager
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段管理器
- en: 'The component that is responsible for interacting with fragments from your
    current activity is **fragment manager**. We can use the `FragmentManager` form
    in two different imports:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 负责与当前活动中的片段进行交互的组件是**片段管理器**。我们可以使用两种不同导入形式的`FragmentManager`：
- en: '`android.app.FragmentManager`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.app.FragmentManager`'
- en: '`android.support.v4.app.Fragment`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.support.v4.app.Fragment`'
- en: Import from the Android support library is recommended.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 建议从Android支持库导入。
- en: To perform a series of edit operations, start the fragment transaction using
    the `beginTransaction()` method. It will return an instance of transaction. To
    add a fragment (usually the first), use the `add` method, like in our example.
    The method takes the same arguments, but replaces the current fragment if already
    added. If we are planning to navigate backwards through fragments, it is needed
    to add the transaction to back stack by using the `addToBackStack` method. It
    takes a name parameter or null if we do not want to assign a name.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`beginTransaction()`方法开始片段事务以执行一系列编辑操作。它将返回一个事务实例。要添加一个片段（通常是第一个），请使用`add`方法，就像我们的示例中一样。该方法接受相同的参数，但如果已经添加，则替换当前片段。如果我们计划通过片段向后导航，需要使用`addToBackStack`方法将事务添加到返回堆栈。它接受一个名称参数，如果我们不想分配名称，则为null。
- en: Finally, we schedule a transaction by executing `commit()`. This is a not momental
    operation. It schedules operations on the application's main thread. When the
    main thread is ready, the transaction will be executed. Think about it when planning
    and implementing your code!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过执行`commit()`来安排事务。这不是瞬时操作。它安排在应用程序的主线程上执行操作。当主线程准备好时，事务将被执行。在规划和实施代码时，请考虑这一点！
- en: Fragments stack
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碎片堆栈
- en: 'To illustrate examples of fragments and the back stack, we will extend our
    application further. We will create a fragment to display a user manual containing
    the text, `Lorem ipsum`. First we need to create a new fragment. Create a new
    layout named `fragment_manual`. Update the layout as shown in this example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明片段和返回堆栈的示例，我们将进一步扩展我们的应用程序。我们将创建一个片段来显示包含文本`Lorem ipsum`的用户手册。首先，我们需要创建一个新的片段。创建一个名为`fragment_manual`的新布局。根据此示例更新布局：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is a simple layout containing the text view stretched across the whole
    parent view. The fragment that will use this layout will be called `ManualFragment`.
    Create a class for the fragment and make sure it has the following content:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的布局，包含了跨越整个父视图的文本视图。将使用这个布局的片段将被称为`ManualFragment`。为片段创建一个类，并确保它具有以下内容：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, let''s add it to the fragment back stack. Update the `onCreate()`
    method of `MainActivity` as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将其添加到片段返回堆栈。更新`MainActivity`的`onCreate()`方法如下：
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Build and run the application. The top-right header button will have label `H`;
    click on it. The fragment containing the `Lorem ipsum` text fills the view. Tap
    on the back button and the fragment disappears. This means that you successfully
    added and removed the fragment from the back stack.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序。右上角的标题按钮将标签为`H`；点击它。包含`Lorem ipsum`文本的片段填充视图。点击返回按钮，片段消失。这意味着你成功地将片段添加到返回堆栈并移除了它。
- en: We have to try one more thing--click on the same button two to three times in
    the row. Click on the back button. Then again. And again. You will go through
    the back stack until you reach the first fragment. If you tap on the back button
    once more, you will leave the application. Observe your Logcat.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要尝试一件事--连续两到三次点击同一个按钮。点击返回按钮。然后再次。再次。你将通过返回堆栈直到达到第一个片段。如果你再次点击返回按钮，你将离开应用程序。观察你的Logcat。
- en: Do you remember the order in which lifecycle methods are executed? You can recognize
    that each time a new fragment is added to the top, the one below pauses. When
    we start going back by pressing the back button, the fragment on the top pauses
    and the one below resumes. Fragments that are removed from the back stack enter
    the `onDestroy()` method at the end.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得生命周期方法执行的顺序吗？你可以认识到每次一个新的片段被添加到顶部时，下面的片段会暂停。当我们按下返回按钮开始后退时，顶部的片段暂停，下面的片段恢复。从返回堆栈中移除的片段最终进入`onDestroy()`方法。
- en: Creating View Pager
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建View Pager
- en: 'As we mentioned, we want our items to display on several pages that can be
    swiped. To do so, we need `ViewPager`. `ViewPager` makes it possible to swipe
    between different fragments as a part of the fragment collection. We will make
    some changes to our code. Open the `activity_main` layout and update it like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，我们希望我们的项目显示在可以滑动的几个页面上。为此，我们需要`ViewPager`。`ViewPager`使得在片段集合的一部分之间进行滑动成为可能。我们将对我们的代码进行一些更改。打开`activity_main`布局并像这样更新它：
- en: '[PRE38]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Instead of `FrameLayout`, we put the `ViewPager` view. Then, open the `MainActivity`
    class and update it like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`FrameLayout`替换为`ViewPager`视图。然后，打开`MainActivity`类，并像这样更新它：
- en: '[PRE39]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The main part of our work is to define the `adapter` class for the pager. We
    must extend the `FragmentStatePagerAdapter` class; its constructor accepts the
    fragment manager that will deal with fragment transactions. To complete work properly,
    override the `getItem()` methods that returns an instance of the fragment and
    `getCount()` that returns the total number of expected fragments. The rest of
    the code is very clear--we access to pager (the ID of `ViewPager` we assigned)
    and assign to it a new instance of the adapter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们工作的主要部分是为分页器定义`adapter`类。我们必须扩展`FragmentStatePagerAdapter`类；它的构造函数接受将处理片段事务的片段管理器。为了正确完成工作，重写`getItem()`方法，返回片段的实例和`getCount()`返回预期片段的总数。其余的代码非常清晰--我们访问分页器（我们分配的`ViewPager`的ID）并将其分配给适配器的新实例。
- en: Run your application and try swiping left and right. While you're swiping, observe
    Logcat and the lifecycle logs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的应用程序，尝试左右滑动。在你滑动时，观察Logcat和生命周期日志。
- en: Making animations with transitions
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用过渡制作动画
- en: 'To animate transactions between fragments, it''s needed to assign some animation
    resources to the transaction instance. As you remember, after we begin the fragment
    transaction, we get one transaction instance. We can then access this instance
    and execute the method as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在片段之间制作动画过渡，需要为事务实例分配一些动画资源。正如你记得的，当我们开始片段事务后，我们得到一个事务实例。然后我们可以访问这个实例并执行以下方法：
- en: '`setCustomAnimations (int enter, int exit, int popEnter, int popExit)`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setCustomAnimations (int enter, int exit, int popEnter, int popExit)`'
- en: 'Or, we can use this method:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用这个方法：
- en: '`setCustomAnimations (int enter, int exit)`'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setCustomAnimations (int enter, int exit)`'
- en: 'Here, each parameter represents the animation used in this transaction. We
    can define our own animation resources or use one of the predefined ones:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，每个参数代表此事务中使用的动画。我们可以定义自己的动画资源，或者使用预定义的动画之一：
- en: '![](img/26f2bac6-99df-4c27-9afa-f482bdfd75d1.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26f2bac6-99df-4c27-9afa-f482bdfd75d1.png)'
- en: Dialog fragments
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对话框片段
- en: 'If you need to display any of your fragments floating above the rest of application''s
    UI, then `DialogFragment` is perfect for you. All you need to do is define the
    fragment very similarly to what we did so far. Define the class that is extending
    `DialogFragment`. Override the `onCreateView()` method so you can define the layout.
    You can override `onCreate()` as well. The last thing you have to do is to display
    it as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要显示任何浮动在应用程序UI上方的片段，那么`DialogFragment`就非常适合你。你所需要做的就是定义片段，非常类似于我们到目前为止所做的。定义一个扩展`DialogFragment`的类。重写`onCreateView()`方法，这样你就可以定义布局。你也可以重写`onCreate()`。你所需要做的最后一件事就是按照以下方式显示它：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this example, we passed the instance and the name for the transaction to
    the fragment manager.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们向片段管理器传递了实例和事务的名称。
- en: Notifications
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知
- en: If the content you are planning to present to the end user is short, then, instead
    of dialogs, you should try notifications. We can customize notifications in many
    different ways. Here, we will present some basic customizations. Creating and
    displaying notifications is easy. It requires more knowledge of Android than we
    have learned so far. Don't worry; we will do our best to explain it. You will
    face many of these classes in the later chapters.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划呈现给最终用户的内容很短，那么，您应该尝试通知而不是对话框。我们可以以许多不同的方式自定义通知。在这里，我们将介绍一些基本的自定义。创建和显示通知很容易。这需要比我们迄今为止学到的更多关于Android的知识。不要担心；我们会尽力解释。您将在以后的章节中遇到许多这些类。
- en: 'We will demonstrate how to use notifications as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示如何使用通知如下：
- en: 'Define a `notificationBuilder` and pass a small icon, content title, and content
    text as follows:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个“notificationBuilder”，并传递一个小图标、内容标题和内容文本如下：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Define `Intent` for activity of your application. (More about intents, will
    be discussed in the next chapter):'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为应用程序的活动定义“Intent”。（关于意图的更多内容将在下一章中讨论）：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now define the stack builder object that will contain the back stack for the
    activity as follows:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在定义包含活动后退堆栈的堆栈构建器对象如下：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Add back stack for the intent:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为意图添加后退堆栈：
- en: '[PRE44]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add intent at the top of the stack:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在堆栈顶部添加意图：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Other important UI components
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他重要的UI组件
- en: 'Android Framework is large and powerful. So far, we have covered `View` classes,
    which are most frequently used. However, there are a lot of `View` classes that
    we did not cover. Some of them will be covered later, but some that are not so
    frequently used will be just mentioned. Anyway, it''s good to know that these
    views exist and it is a good starting point for your further learning. Let''s
    give some examples to give you an idea:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Android框架庞大而强大。到目前为止，我们已经涵盖了最常用的“View”类。然而，还有很多“View”类我们没有涵盖。其中一些将在以后涵盖，但一些不太常用的将只是提及。无论如何，知道这些视图存在并且是进一步学习的好起点是很好的。让我们举一些例子来给你一个概念：
- en: '**ConstraintLayout**: This views and positions child elements in a flexible
    way'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ConstraintLayout：这种视图以灵活的方式放置和定位子元素
- en: '**CoordinatorLayout**: This is a very advanced version of FrameLayout'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoordinatorLayout：这是FrameLayout的一个非常高级的版本
- en: '**SurfaceView**: This is a view used for drawing (especially when high performance
    is needed)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SurfaceView：这是一个用于绘图的视图（特别是在需要高性能时）
- en: '**VideoView**: This is set to play video content'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VideoView：这是设置播放视频内容的
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to create screens divided into sections, and
    now you are able to create basic and complex layouts containing buttons and images.
    You also learned how to create dialogs and notifications. In the following chapter,
    you will connect all your screens and navigation actions.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何创建分成部分的屏幕，现在您可以创建包含按钮和图像的基本和复杂布局。您还学会了如何创建对话框和通知。在接下来的章节中，您将连接所有屏幕和导航操作。
