- en: '*Chapter 1*: An Overview of Modern JavaScript'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：现代JavaScript概述'
- en: 'In this chapter, we will talk about some core JavaScript concepts. If you are
    new to JavaScript and need an introduction, check out [*Chapter 13*](B17076_13_ePub_RK.xhtml#_idTextAnchor222),
    *Appendix*: *Essential JavaScript Concepts*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将讨论一些核心的JavaScript概念。如果你是JavaScript的新手，需要介绍的话，请查看[*第13章*](B17076_13_ePub_RK.xhtml#_idTextAnchor222)，*附录*：*基本JavaScript概念*。
- en: Understanding some of the modern concepts of JavaScript is not a prerequisite
    to using Danfo.js, but we recommend going through this chapter if you're new to
    JavaScript or coming from a Python background, the reason being that we'll be
    using most of the concepts introduced here when building applications with Danfo.js.
    Also, it is worth mentioning that many of the concepts introduced here will, in
    general, help you to write better JavaScript.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 理解一些现代JavaScript概念并不是使用Danfo.js的先决条件，但是如果您是JavaScript的新手或者来自Python背景，我们建议您阅读本章，原因是在使用Danfo.js构建应用程序时，我们将使用这里介绍的大部分概念。另外，值得一提的是，这里介绍的许多概念通常会帮助您编写更好的JavaScript。
- en: 'This chapter introduces you to some modern JavaScript concepts, and by the
    end, you will have learned and understand the following concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍一些现代JavaScript概念，到最后，您将学习并理解以下概念：
- en: Understanding the difference between let and var
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`let`和`var`之间的区别
- en: Destructuring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解构
- en: Spread syntax
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开语法
- en: Overview of scopes and closures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域和闭包概述
- en: Understanding Array and Object methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数组和对象方法
- en: Understanding the this property
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解this属性
- en: Arrow functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Promises and async/await
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Promises和async/await
- en: Object-oriented programming and JavaScript classes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程和JavaScript类
- en: Setting up a modern JavaScript environment with transpilers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用转译器设置现代JavaScript环境
- en: Unit testing with Mocha and Chai
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mocha和Chai进行单元测试
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The major requirement is to have Node.js and NPM installed. You can follow
    the official installation guide available at [https://nodejs.org/en/download/](https://nodejs.org/en/download/)
    to install Node for your operating system. The code for this chapter can be found
    in the GitHub repo here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter01](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter01).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 主要要求是已安装Node.js和NPM。您可以按照官方安装指南在[https://nodejs.org/en/download/](https://nodejs.org/en/download/)上安装适用于您操作系统的Node。本章的代码可以在GitHub仓库中找到：[https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter01](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter01)。
- en: We will start this section by understanding the difference between `let` and
    `var`, and why you should use `let` more often.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从理解`let`和`var`之间的区别开始，以及为什么您应该更频繁地使用`let`。
- en: Understanding the difference between let and var
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`let`和`var`之间的区别
- en: Before ECMA 6, the common way of creating a variable was with the use of `var`.
    However, using `var` sometimes introduces bugs that mostly show up at runtime
    and others that are not revealed at runtime but may affect the way your code works.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMA 6之前，创建变量的常见方式是使用`var`。然而，使用`var`有时会引入在运行时出现的错误，以及在运行时未显现但可能影响代码运行方式的错误。
- en: 'Some of the properties of `var` that introduce bugs as mentioned in the previous
    paragraph are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如前段提到的，`var`的一些属性会引入错误，如下所示：
- en: '`var` allows the redeclaration of variables.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`允许变量的重新声明。'
- en: '`var` is not blocked scope; hence, it is either attached to the global scope
    or to a function scope.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`不是块级作用域；因此，它要么附加到全局作用域，要么附加到函数作用域。'
- en: Let's discuss the two properties listed above in detail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论上面列出的两个属性。
- en: var allows the redeclaration of variables
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: var允许变量的重新声明
- en: '`var` gives users access to redeclare variables along the line, hence overriding
    the previous variable of the same name. This feature might not show an error if
    not caught, but will certainly affect the behavior of the code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`允许用户在代码中重新声明变量，因此覆盖了之前同名的变量。如果没有被捕获，这个特性可能不会显示错误，但肯定会影响代码的行为：'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippet, there won't be any error, but the main objective
    of the code is altered just because `var` did not alert us that such a variable
    has been declared already.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，不会出现任何错误，但是代码的主要目标会因为`var`没有警告我们已经声明了这样一个变量而被改变。
- en: 'Let''s say we replace `var` with `let`, as shown in the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们用`let`替换`var`，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see from the preceding error output that `let`, unlike `var`, will not
    allow you to declare a variable in the same namespace twice.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的错误输出中可以看出，`let`与`var`不同，不允许在同一命名空间中声明变量两次。
- en: Next, let's look at the scope property of variables declared with `var`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看使用`var`声明的变量的作用域属性。
- en: var is not a blocked scope
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: var不是块级作用域
- en: 'Variables declared with `var` have the following properties:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`声明的变量具有以下属性：
- en: They are readily available in the scope to which they are defined.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在定义的作用域内是立即可用的。
- en: They are available to scope within the range they are being declared.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在被声明的作用域内是可用的。
- en: 'In the following code, we will check how the `estimate` variable declared with
    `var` is accessible across all the scope within the variable declaration scope:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将检查使用`var`声明的`estimate`变量在变量声明作用域内的所有作用域中都是可访问的：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, for a blocked scope such as `if`, `while` loop, and `for` loop, the code
    within the blocked scope is meant to be run when the scope is available. Likewise,
    the variable is meant to exist only when the scope is available, and once the
    scope is not available again, the variable should not be accessible.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于像`if`、`while`循环和`for`循环这样的块级作用域，块级作用域内的代码应该在作用域可用时运行。同样，变量应该只在作用域可用时存在，一旦作用域再次不可用，变量就不应该被访问。
- en: 'Declaring variables with `var` makes the preceding statement not possible.
    In the following code, we declare a variable using `var` and investigate its availability
    across all possible scopes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`声明变量会使前面的语句不可能。在下面的代码中，我们使用`var`声明一个变量，并调查其在所有可能的作用域中的可用性：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will output the estimate as `6000`. The variable is not meant to exist
    outside the `if` block. Using `let` helps to solve this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出估计值为`6000`。该变量不应存在于`if`块之外。使用`let`有助于解决这个问题：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This shows that using `let` to declare variables helps reduce unprecedented
    bugs in your code. In the next section, we'll discuss another important concept
    called destructuring.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明使用`let`声明变量有助于减少代码中的意外错误。在下一节中，我们将讨论另一个重要概念，称为解构。
- en: Destructuring
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构
- en: '`20`, `John`, `Doe`, and `2019` into specified variables:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`20`，`John`，`Doe`和`2019`分配到指定的变量中：'
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Destructuring makes it possible to assign the element of an array to a variable,
    unlike the old conventional method of accessing an array element as shown in the
    following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 解构使得可以将数组的元素分配给一个变量，而不是像在下面的代码中所示的旧的常规方法访问数组元素：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Destructuring also works on objects, as shown in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 解构也适用于对象，就像在下面的代码中所示的那样：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In object destructuring, notice that we use `{}` instead of `[]`, as used for
    arrays. This is because the type on the left-hand side must be the same as the
    type on the right-hand side.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象解构中，请注意我们使用`{}`而不是`[]`，就像用于数组的一样。这是因为左侧的类型必须与右侧的类型相同。
- en: Important note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If we are to use `[]` while destructuring for an object, we receive an error,
    showing `{}` for array destructuring, you might not obtain any error, but the
    variables will be undefined.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在解构对象时使用`[]`，我们会收到一个错误，显示`{}`。对于数组解构，你可能不会得到任何错误，但变量将是未定义的。
- en: In the next section, we take a look at spread syntax.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将看一下展开语法。
- en: Spread syntax
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开语法
- en: '**Spread syntax** is another form of destructuring for iterable elements such
    as strings and arrays. The spread syntax can be used in many situations involving
    arrays and objects. In this section, we''ll quickly look at some of the use cases
    of spread syntax.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**展开语法**是可迭代元素的另一种解构形式，例如字符串和数组。展开语法可以在涉及数组和对象的许多情况下使用。在本节中，我们将快速查看展开语法的一些用例。'
- en: Spreading or unpacking an iterable into an array
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将可展开的可迭代对象展开或解包到数组中。
- en: 'An iterable can be expanded/unpacked into an array. In the following example,
    we will show how to use the spread operator to unpack a string variable:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象可以展开/解包成数组。在下面的示例中，我们将展示如何使用展开运算符来解包字符串变量：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code expands the `name` string into `name_array`, hence, `name_array` will
    have the following values: [`''s'', ''t'', ''e'',''p'', ''h'', ''e'',''n''`].'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将`name`字符串展开为`name_array`，因此，`name_array`将具有以下值：[`'s'，'t'，'e'，'p'，'h'，'e'，'n'`]。
- en: 'While expanding the string element into the array, we can add other values
    alongside, as shown in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在将字符串元素展开为数组的同时，我们可以添加其他值，就像在下面的代码中所示的那样：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Remember that any iterable can be spread into an array. This shows that we
    can also spread one array into another, as demonstrated in the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，任何可迭代对象都可以展开成数组。这表明我们也可以展开一个数组到另一个数组中，就像在下面的代码中演示的那样：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, we'll apply the spread operator to objects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把展开运算符应用到对象上。
- en: Creating new objects from existing ones
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从现有对象创建新对象
- en: 'Creating new objects from existing ones follows the same pattern as the **Spread**
    operator:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从现有对象创建新对象遵循与**展开**运算符相同的模式：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This creates a new object having the same property as the former object. While
    expanding the former object into the new one, new properties can be added alongside:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个具有与前一个对象相同属性的新对象。在将前一个对象展开为新对象时，可以同时添加新属性：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Function arguments
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数
- en: For functions requiring a lot of arguments, the spread syntax can help pass
    in a lot of arguments at once into the function, thereby reducing the stress of
    filling in the function's arguments one after the other.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要许多参数的函数，展开语法可以帮助一次性传递许多参数到函数中，从而减少逐个填充函数参数的压力。
- en: 'In the following code, we will see how an array of arguments can be passed
    into a function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将看到如何将参数数组传递给函数：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, first, we created a function called `data_func` and defined
    a set of arguments to be passed in. We then created an array containing a list
    of parameters to pass to `data_func`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，首先，我们创建了一个名为`data_func`的函数，并定义了要传递的一组参数。然后我们创建了一个包含要传递给`data_func`的参数列表的数组。
- en: By using spread syntax, we were able to pass the data array and assign each
    of the values in the array as an argument value – `data_func(...data)`. This becomes
    handy whenever a function takes many arguments.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用展开语法，我们能够传递数据数组并将数组中的每个值分配为参数值–`data_func(...data)`。每当一个函数需要许多参数时，这将变得非常方便。
- en: In the next section, we will look at scope and closures, and how to use them
    to understand your JavaScript code better.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下作用域和闭包，以及如何使用它们更好地理解您的JavaScript代码。
- en: Overview of scopes and closures
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域和闭包概述
- en: In the *Understanding the difference between let and var* section, we discussed
    scope and talked about how `var` is available in the global scope, as well as
    in the function scope. In this section, we will be moving into scope and closures
    in a little more depth.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在*理解let和var之间的区别*部分，我们讨论了作用域，并谈到了`var`在全局作用域和函数作用域中都可用。在本节中，我们将更深入地了解作用域和闭包。
- en: Scope
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域
- en: 'To understand scope, let''s start with the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解作用域，让我们从下面的代码开始：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `food` variables and `data` function are both assigned to the global scope;
    hence, they are termed **a global variable** and **global function**. These global
    variables and functions are always accessible to every other scope and program
    in the JavaScript file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`food`变量和`data`函数都分配给了全局作用域；因此，它们被称为**全局变量**和**全局函数**。这些全局变量和函数始终对JavaScript文件中的每个其他作用域和程序都是可访问的。'
- en: 'The **local** scope can further be grouped as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本地范围可以进一步分为以下几类：
- en: '**Function scope**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数范围**'
- en: '**Block scope**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块范围**'
- en: 'Function scope is only available within a function. That is, all variables
    and functions created within a function scope are not accessible outside the function,
    and only exist when the function scope is available, for example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 函数范围仅在函数内部可用。也就是说，在函数范围内创建的所有变量和函数在函数外部是不可访问的，并且只有在函数范围可用时才存在，例如：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The block scope exists in specific contexts only. For instance, it can exist
    within a curly brace, `{ }`, along with the `if` statement, `for` loop, and `while`
    loop. Two more examples are presented in the following code snippets:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 块范围仅存在于特定上下文中。例如，它可以存在于花括号`{ }`内，以及`if`语句、`for`循环和`while`循环中。下面的代码片段中还提供了另外两个例子：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding `if` statement, you can see that the block scope only exists
    inside the curly braces, and all variables declared inside the `if` statement
    are local to it. Another example is a `for` loop, as shown in the following code
    snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`if`语句中，您可以看到块范围仅存在于花括号内部，并且在`if`语句内声明的所有变量都是局部变量。另一个例子是`for`循环，如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The block scope also exists inside the curly braces of a `for...`loop. Here,
    you have access to the `i` counter, and any variables declared inside cannot be
    accessed outside the block.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 块范围还存在于`for...`循环的花括号内。在这里，您可以访问`i`计数器，并且无法在块外部访问内部声明的任何变量。
- en: Next, let's understand the concept of closures.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解闭包的概念。
- en: Closure
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包
- en: '**Closure** makes use of the idea of scope within functions. Remember we agreed
    that the variables declared within a function scope are not accessible outside
    the function scope. Closure gives us the ability to make use of these private
    properties (or variables).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**闭包**利用了函数内部作用域的概念。请记住，我们同意在函数范围内声明的变量在函数范围外部是不可访问的。闭包使我们能够利用这些私有属性（或变量）。'
- en: 'Let''s say we want to create a program that will always add the values `2`
    and `1` to an `estimate` variable representing a population estimate. One way
    to do this is shown in the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想创建一个程序，该程序将始终将值`2`和`1`添加到表示人口估计的`estimate`变量中。可以使用以下代码的一种方法：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There's nothing wrong with the preceding code, but as the code base becomes
    very big, we might lose track of the `estimate` value, perhaps a function along
    the line to update the value, and we may also want to make the global scope clean
    by making the global `estimate` variable a local variable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码没有问题，但是随着代码库变得非常庞大，我们可能会迷失`estimate`值，也许在某个时候需要一个函数来更新该值，并且我们可能还希望通过将全局`estimate`变量设置为局部变量来清理全局范围。
- en: 'Hence, we can create a function scope to do this for us and ultimately, clean
    the global scope. Here is an example in the following code snippet:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以创建一个函数范围来为我们执行此操作，并最终清理全局范围。以下是下面代码片段中的一个示例：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code snippet is similar to the first one we defined, with just
    a tiny difference, that is, the function accepts the `estimate` value and then
    creates the `add_2` and `add_1` functions inside the `calc_estimate` function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段与我们定义的第一个代码片段类似，只是有一个小差异，即函数接受`estimate`值，然后在`calc_estimate`函数内部创建`add_2`和`add_1`函数。
- en: 'A better way to showcase closure using the preceding code is to have the ability
    to update the estimate value whenever we want and not at the instance where the
    function is called. Let''s see an example of this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码更好地展示闭包的一种方法是能够在任何时候更新估计值，而不是在调用函数的实例中。让我们看一个例子：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding code snippet, the inner function, `add_2`, will add the value
    `2` to the `estimate` variable, thereby changing the value. `calc_estimate` is
    called and assigned to a variable, `add_2`. With this, whenever we call `add_2`,
    we update the estimated value by `2`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，内部函数`add_2`将值`2`添加到`estimate`变量中，从而改变了值。调用`calc_estimate`并将其分配给变量`add_2`。因此，每当我们调用`add_2`时，我们都会将估计值更新为`2`。
- en: 'We update the `add_2` function inside `calc_estimate` to accept a value that
    can be used to update the `estimate` value:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新`calc_estimate`内部的`add_2`函数，以接受一个值，该值可用于更新`estimate`值：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that you've learned about scopes and closures, we will move to arrays, objects,
    and string methods in the following section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了作用域和闭包，我们将在下一节中讨论数组、对象和字符串方法。
- en: Further reading
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To go into closures in greater detail, check out the book *Mastering JavaScript*,
    by *Ved Antani*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要更详细地了解闭包，请查看*Ved Antani*的书《精通JavaScript》。
- en: Understanding Array and Object methods
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数组和对象方法
- en: '**Arrays** and **Objects** are the two most important data types in JavaScript.
    As such, we have dedicated a section to talking about some of their methods. We
    will start with the Array methods.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**和**对象**是JavaScript中最重要的两种数据类型。因此，我们专门设置了一个部分来讨论它们的一些方法。我们将从数组方法开始。'
- en: Array methods
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组方法
- en: We can't discuss how to build a data-driven product without discussing Array
    methods. Knowing different Array methods gives us the privilege of accessing our
    data and creating tools to manipulate/handle our data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法讨论如何构建数据驱动的产品而不讨论数组方法。了解不同的数组方法使我们能够访问我们的数据并创建工具来操作/处理我们的数据。
- en: 'An array can be created in two different forms:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以以两种不同的形式创建：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `[ ]` method is mostly used for initializing arrays, while the `new Array()`
    method is used mostly to create an empty array of an *n* size, as shown in the
    following code snippet:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ ]`方法主要用于初始化数组，而`new Array()`方法主要用于创建大小为*n*的空数组，如下面的代码片段所示：'
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The empty array created can later be filled with values as shown in the following
    code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的空数组可以稍后用值填充，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Creating such an empty array is not limited to using the `new Array()` method.
    It can also be created with the `[ ]` method, as shown in the following code snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这样一个空数组不仅限于使用`new Array()`方法。它也可以使用`[ ]`方法创建，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can see that we explicitly set the length after creation, and as such, the
    `new Array()` method is more convenient.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们在创建后明确设置了长度，因此`new Array()`方法更方便。
- en: Let's now look at some of the common array methods that will be used in building
    some of our data-driven tools.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一些常见的数组方法，这些方法将用于构建一些数据驱动的工具。
- en: Array.splice
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Array.splice
- en: 'Deleting and updating array values will always be one of the essential things
    in a data-driven product. JavaScript has a `delete` keyword to delete a value
    at a particular index in an array. This method does not actually delete the value,
    but replaces it with an empty or undefined value, as shown in the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 删除和更新数组值始终是数据驱动产品中的基本操作之一。JavaScript有一个`delete`关键字，用于删除数组中特定索引处的值。该方法实际上并不删除值，而是用空值或undefined值替换它，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `data` variable, if we try to access the value at index `4`, we will
    see that it returns `undefined`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data`变量中，如果我们尝试访问索引`4`处的值，我们会发现它返回`undefined`：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But whenever we use `splice` to delete a value in an array, the index of the
    array is re-arranged, as demonstrated in the following code snippet:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，每当我们使用`splice`删除数组中的一个值时，数组的索引会重新排列，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`Array.splice` takes in the following argument, `start,[deleteCount, value-1,......N-values]`.
    In the preceding code snippet, since we are only deleting, we make use of `start`
    and `deleteCount`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.splice`接受以下参数，`start,[deleteCount, value-1,......N-values]`。在前面的代码片段中，由于我们只是删除，所以我们使用了`start`和`deleteCount`。'
- en: The `data.splice(4,1)` command deletes the value starting at index `4`, with
    only one count, hence it deletes the value at index `5`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.splice(4,1)`命令删除从索引`4`开始的值，只有一个计数，因此它删除了索引`5`处的值。'
- en: 'If we replace the value `1` in `data.splice(4,1)` with `2`, resulting in `data.splice(4,2)`,
    two values (`5` and `6`) from the `data` array will be deleted, starting from
    index `4`, as shown in the following code block:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`data.splice(4,1)`中的值`1`替换为`2`，结果为`data.splice(4,2)`，将从索引`4`开始删除`data`数组中的两个值（`5`和`6`），如下面的代码块所示：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`data.splice(4,0,10, 20);` specifies starting at index `4`, and `0` specifies
    that no values should be deleted, while adding the new values (`10` and `20`)
    between `5` and `6`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.splice(4,0,10, 20);`指定从索引`4`开始，`0`指定不删除任何值，同时在`5`和`6`之间添加新值（`10`和`20`）。'
- en: Array.includes
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Array.includes
- en: 'This method is used for checking whether an array contains a particular value.
    We show an example in the following code snippet:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法用于检查数组是否包含特定值。我们在下面的代码片段中展示了一个例子：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Array.slice
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Array.slice
- en: '`Array.slice` is used to obtain an array element by specifying the range; `Array.slice(start-index,
    end-index)`. Let''s see an example of using this method in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.slice`用于通过指定范围获取数组元素；`Array.slice(start-index, end-index)`。让我们在下面的代码中看一个使用这种方法的例子：'
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code extracts elements, starting from index `2` (having element
    `3`) to index `5`. Note that the array did not output `[3,4,5]`, but [`3,4]`.
    `Array.splice` always excludes the end index value, and so it uses a close end
    range.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码从索引`2`（具有元素`3`）开始提取元素，直到索引`5`。请注意，数组没有输出`[3,4,5]`，而是[`3,4]`。`Array.splice`总是排除结束索引值，因此它使用一个闭区间。
- en: Array.map
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Array.map
- en: 'The `Array.map` method iterates through all the elements of an array, applies
    some operations to each iteration, and then returns the result as an array. The
    following code snippet is an example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.map`方法遍历数组的所有元素，对每次迭代应用一些操作，然后将结果作为数组返回。下面的代码片段是一个例子：'
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `data2` variable is created by iterating over each data element by using
    a `map` method. In the `map` method, we are adding each element (value) of the
    array to its index.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`data2`变量是通过使用`map`方法迭代每个数据元素创建的。在`map`方法中，我们将数组的每个元素（值）添加到其索引中。'
- en: Array.filter
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Array.filter
- en: 'The `Array.filter` method is used to filter out some elements in an array.
    Let''s see this in action:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.filter`方法用于过滤数组中的一些元素。让我们看看它的运行方式：'
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code snippet, the array element of data at every even index
    is filtered out using the modulus (%) of `2`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，使用`2`的模数（%）过滤掉了数据中每个偶数索引的数组元素。
- en: There are lots of Array methods, but we covered these few methods because they
    are always handy during data handling, and we will not be able to cover all of
    them.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多数组方法，但我们只涵盖了这些方法，因为它们在数据处理过程中总是很方便，我们无法覆盖所有方法。
- en: However, if any new method is used in later chapters of this book, we will certainly
    provide an explanation. In the next section, we'll discuss Object methods.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果在本书的后续章节中使用了任何新方法，我们肯定会提供解释。在下一节中，我们将讨论对象方法。
- en: Objects
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: '**Objects** are the most powerful and important data type in JavaScript, and
    in this section, we''ll introduce some important properties and methods of objects
    that make working with them easier.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象**是JavaScript中最强大和重要的数据类型，在本节中，我们将介绍一些重要的对象属性和方法，使得与它们一起工作更容易。'
- en: Accessing object elements
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问对象元素
- en: 'Accessing keys/values in an object is important, so there exists a special
    `for...in` loop for doing that:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 访问对象中的键/值很重要，因此存在一个特殊的`for...in`循环来执行这个操作：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `for...in` loop returns all the keys in an object, and this can be used
    to access Object values, as demonstrated in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`for...in`循环返回对象中的所有键，这可以用于访问对象值，如下面的代码所示：'
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the next section, we will show how to test the existence of properties.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示如何测试属性的存在。
- en: Testing for the existence of property
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试属性是否存在
- en: 'To check whether a property exists, you can use the `"key"` `in` object syntax,
    as demonstrated in the following code snippet:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查属性是否存在，可以使用`"key"` `in`对象语法，如下面的代码片段所示：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Deleting properties
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除属性
- en: 'The `delete` keyword used before an object property will remove a specified
    property from an object. Look at the following example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象属性之前使用`delete`关键字将从对象中删除指定的属性。看看下面的例子：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can see that the `age` property has been successfully removed from the `user_profile`
    object. Next, let's look at how to copy and clone objects.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`age`属性已经成功地从`user_profile`对象中删除。接下来，让我们看看如何复制和克隆对象。
- en: Copying and cloning objects
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制和克隆对象
- en: 'Assigning an old object to a new one simply creates a reference to the old
    object. That is, any modification made to the new object also affects the old
    one. For instance, in the following example, we assign the `user_profile` object
    to a new variable, `new_user_profile`, and then proceed to delete the `age` property:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将旧对象分配给新对象只是创建对旧对象的引用。也就是说，对新对象的任何修改也会影响旧对象。例如，在下面的例子中，我们将`user_profile`对象分配给一个新变量`new_user_profile`，然后删除`age`属性：
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You will notice that deleting the `age` property from the `user_profile` object
    also deletes it from `new_user_profile`. This is because the copy is simply a
    reference to the old object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到从`user_profile`对象中删除`age`属性也会从`new_user_profile`中删除。这是因为复制只是对旧对象的引用。
- en: 'In order to copy/clone objects as new and independent ones, you can use the
    `Object.assign` method, as shown in the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将对象复制/克隆为新的独立对象，您可以使用`Object.assign`方法，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `Object.assign` method can also be used to copy properties from more than
    one object at the same time. We present an example in the following code snippet:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign`方法也可以用于一次从多个对象中复制属性。我们在下面的代码片段中提供了一个示例：'
- en: '[PRE40]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can see that we were able to copy properties from two objects (`education`
    and `permissions`) into our original object, `user_profile`. In this way, we can
    copy any number of objects into another one by simply listing all the objects
    when you call the `Object.assign` method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们能够从两个对象（`education`和`permissions`）中复制属性到我们的原始对象`user_profile`中。通过这种方式，我们可以通过简单列出所有对象来调用`Object.assign`方法，将任意数量的对象复制到另一个对象中。
- en: Tip
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'You can also perform a deep copy with a **spread** operator. This is actually
    quicker and easier to write, as demonstrated in the following example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用**spread**运算符执行深拷贝。这实际上更快，更容易编写，如下面的示例所示：
- en: '`let user_profile = {`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`let user_profile = {`'
- en: '`name: ''Mary'',`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`name: ''Mary'',`'
- en: '`sex: ''Female''`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`sex: ''Female''`'
- en: '`}`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: '`let education = { graduated: true, degree: ''BSc'' }`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`let education = { graduated: true, degree: ''BSc'' }`'
- en: '`let permissions = { isAdmin: true }`'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`let permissions = { isAdmin: true }`'
- en: '`const allObjects = {...user_profile, ...education, ...permissions}`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`const allObjects = {...user_profile, ...education, ...permissions}`'
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the next section, we will talk about another important concept relating to
    JavaScript objects called the **this** property.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论与JavaScript对象相关的另一个重要概念，称为**this**属性。
- en: Understanding the this property
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解this属性
- en: The **this** keyword is an object property. When used within a function, it
    takes the form of the object to which the function is bound at invocation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**this**关键字是一个对象属性。当在函数内部使用时，它以函数在调用时绑定的对象的形式出现。'
- en: In every JavaScript environment, we have a global object. In Node.js, the global
    object is named **global** and, in the browser, the global object is named **window**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个JavaScript环境中，我们都有一个全局对象。在Node.js中，全局对象被命名为**global**，在浏览器中，全局对象被命名为**window**。
- en: 'By global object, we mean that all the variable declarations and functions
    are represented as a property and method of this global object. For example, in
    a browser script file, we can access the global objects, as shown in the following
    code snippet:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的全局对象是指所有变量声明和函数都表示为这个全局对象的属性和方法。例如，在浏览器脚本文件中，我们可以访问全局对象，如下面的代码片段所示：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding code block, the `name` variable and `print` function are declared
    at the global scope, hence they can be accessed as an attribute (`window.name`)
    and method (`window.print()`) of the **window** global object.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，`name`变量和`print`函数是在全局范围声明的，因此它们可以作为**window**全局对象的属性（`window.name`）和方法（`window.print()`）来访问。
- en: The statement made in the previous sentence can be summarized as the global
    name and function are binded (or assigned) by default to the global object window.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 前面一句话中的陈述可以总结为全局名称和函数默认绑定（或分配）到全局对象window。
- en: This also means that we can always bind this variable to any object having the
    same `name` variable and the same function, called `print`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们可以将这个变量绑定到任何具有相同`name`变量和相同函数`print`的对象上。
- en: To get this concept, first, let's re-write `window.print()` as `print.call(window)`.
    This new method is called de-sugaring in JavaScript; it is like seeing an implementation
    of a method in its real form.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个概念，首先让我们将`window.print()`重写为`print.call(window)`。这种新的方法在JavaScript中被称为de-sugaring；它就像看到一个方法的实现形式一样。
- en: The `.call` method simply takes in the object we want to bind a function call
    to.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`.call`方法只是简单地接受我们想要绑定函数调用的对象。'
- en: 'Let''s see how `print.call()` and how this property works. We''ll rewrite the
    `print` function to access the `name` variable, as shown in the following code
    snippet:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`print.call()`和这个属性是如何工作的。我们将重写`print`函数以访问`name`变量，如下面的代码片段所示：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s create a custom object and also give it the same property as the
    `window` object, as shown in the following code snippet:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个自定义对象，并且给它与`window`对象相同的属性，如下面的代码片段所示：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This concept can be applied to all Object methods, as shown in the following
    code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念可以应用于所有的对象方法，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With this, we can also bind the `print()` method from `data` to another object,
    as shown in the following code snippet:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们也可以将`data`中的`print()`方法绑定到另一个对象，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This method shows how this property depends on the function invocation runtime.
    This concept also affects how some event operations work in JavaScript.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法展示了this属性如何依赖于函数调用时的运行时。这个概念也影响了JavaScript中一些事件操作的工作方式。
- en: Further reading
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To get a deeper understanding of this concept, Yehuda Katz, one of the creators
    of *Emberjs and Members of TC39*, sheds more light on this in his article, *Understanding
    JavaScript Function Invocation and "this"*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更深入地理解这个概念，*Emberjs 和 TC39 成员*之一 Yehuda Katz 在他的文章*理解 JavaScript 函数调用和 "this"*中对此进行了更详细的阐述。
- en: Arrow functions
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'Arrow functions are just unnamed or anonymous functions. The general syntax
    of **arrow** functions is shown in the following expression:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数只是未命名或匿名函数。**箭头**函数的一般语法如下所示：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Arrow functions provide a means of creating concise callable functions. By this,
    we mean arrow functions are not constructible, that is, they can't be instantiated
    with the new keyword.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数提供了一种创建简洁可调用函数的方法。这意味着箭头函数不可构造，也就是说，它们不能用 `new` 关键字实例化。
- en: 'The following are different ways of how and when to use arrow functions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何以及何时使用箭头函数的不同方式：
- en: 'The arrow function can be assigned to a variable:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数可以赋值给一个变量：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Arrow functions can be used as an **IIFE** (**Immediately Invoked Function
    Expression**). IIFEs are functions that once encountered by the JavaScript compiler
    are called immediately:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数可以用作**IIFE**（**立即调用函数表达式**）。IIFE 是一旦被 JavaScript 编译器遇到就立即调用的函数：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Arrow functions can be used as callbacks:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数可以用作回调：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: While arrow functions are great in some situations, there is a downside to using
    them. For example, arrow functions do not have their own `this` scope, hence its
    scope is always bound to the general scope, thereby changing our whole idea of
    function invocation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然箭头函数在某些情况下很棒，但使用它们也有缺点。例如，箭头函数没有自己的 `this` 作用域，因此它的作用域始终绑定到一般作用域，从而改变了我们对函数调用的整体理念。
- en: 'In the *Understanding the this property* section, we talked about how functions
    are bounded to their invocation scope and using this ability to support **closure**,
    but using the arrow function denies us this feature by default:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在*理解 this 属性*部分，我们谈到了函数如何绑定到它们的调用范围，并使用这种能力来支持**闭包**，但使用箭头函数默认情况下会剥夺我们这个特性：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Even though in the object, as shown in the code snippet, we make use of the
    anonymous function (but not the arrow function), we have access to the object''s
    `Obj` properties:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在对象中，如代码片段所示，我们使用了匿名函数（但不是箭头函数），我们仍然可以访问对象的 `Obj` 属性：
- en: '[PRE52]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The arrow function used makes the `Obj.func` output `undefined`. Let''s see
    how it works if we have a variable called `name` in the global scope:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的箭头函数使 `Obj.func` 的输出为 `undefined`。让我们看看如果全局作用域中有一个名为 `name` 的变量时它是如何工作的：
- en: '[PRE53]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As we can see, `Obj.func` makes a call to the variable in the global scope.
    Hence, we must know when and where to use the arrow functions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`Obj.func` 调用了全局作用域中的变量。因此，我们必须知道何时何地使用箭头函数。
- en: In the next section, we will talk about Promises and async/await concepts. This
    will give us the power to easily manage long-running tasks and avoid callback
    hell (callbacks having callbacks).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论 Promise 和 async/await 概念。这将使我们能够轻松管理长时间运行的任务，并避免回调地狱（回调中有回调）。
- en: Promises and async/await
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promise 和 async/await
- en: Let's dive a bit into the world of Asynchronous functions, functions that we
    call now but finish later. In this section, we will see why we need **Promise**
    and **async/await**.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入一下异步函数的世界，现在调用但稍后完成的函数。在本节中，我们将看到为什么我们需要**Promise**和**async/await**。
- en: 'Let''s start with a simple problem as shown in the following code snippet.
    We are given a task to update an array with a function, after `1` second of calling
    the function:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从下面的代码片段中显示的一个简单问题开始。我们需要使用一个函数在调用函数后的 `1` 秒后更新一个数组：
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`console.log(syncarray)` is executed before the `addB()` function, hence we
    see the `syncarray` output before it is being updated. This is an Asynchronous
    behavior. One of the ways to solve this is to use a callback:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(syncarray)` 在 `addB()` 函数之前执行，因此我们在更新之前看到了 `syncarray` 的输出。这是一种异步行为。解决这个问题的一种方法是使用回调：'
- en: '[PRE55]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Using the preceding callback approach means that we always pass in callbacks
    in order to perform other operations on the updated `syncarray` function. Let''s
    update the code a little, and this time we''ll also add the string `"A"` to `syncarray`
    and then print out the updated array:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的回调方法意味着我们总是传递回调以执行对更新后的 `syncarray` 函数的其他操作。让我们稍微更新一下代码，这次我们还将字符串 `"A"`
    添加到 `syncarray` 中，然后打印出更新后的数组：
- en: '[PRE56]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The preceding code block shows a quick way of passing `callback`. Based on the
    arrow function we discussed, it can be more organized by creating a named function.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块显示了传递 `callback` 的快速方法。根据我们讨论的箭头函数，通过创建一个命名函数可以使代码更有组织性。
- en: Cleaning callbacks with promises
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Promise 清理回调
- en: 'Using callbacks quickly becomes unwieldy and can quickly descend into callback
    hell. One method of freeing ourselves from this is to make use of Promises. Promises
    makes our callbacks more organized. It gives a chainable mechanism to unify and
    orchestrate code that is dependent on previous functions, as you''ll see in the
    following code block:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调很快变得难以控制，并且很快就会陷入回调地狱。摆脱这种情况的一种方法是使用 Promise。Promise 使我们的回调更有组织性。它提供了一种可链接的机制，用于统一和编排依赖于先前函数的代码，正如你将在下面的代码块中看到的：
- en: '[PRE57]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding code snippet, `setTimeout` is wrapped inside the `Promise`
    function. A `Promise` is always instantiated using the following expression:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`setTimeout` 被包裹在 `Promise` 函数中。使用以下表达式始终实例化 `Promise`：
- en: '[PRE58]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: A `Promise` is either resolved or rejected. When it is resolved, then we are
    free to do other things, and when it is rejected, we need to handle the error.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise` 要么被解决，要么被拒绝。当它被解决时，我们可以做其他事情，当它被拒绝时，我们需要处理错误。'
- en: 'For example, let''s ensure that the following `Promise` is rejected:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们确保以下的 `Promise` 被拒绝：
- en: '[PRE59]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And whenever we have multiple promises, we can use the `.then()` method to
    handle each one:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们有多个 Promise 时，我们可以使用 `.then()` 方法来处理每一个：
- en: '[PRE60]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The use of multiple `.then()` methods to handle numerous promises can quickly
    become unwieldy. To prevent this, we can use methods such as `Promise.all()`,
    `Promise.any()`, and `Promise.race()`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个`.then()`方法来处理多个promise可能会很快变得难以控制。为了防止这种情况，我们可以使用`Promise.all()`、`Promise.any()`和`Promise.race()`等方法。
- en: 'The `Promise.all()` method takes in an array of promises to be executed, and
    will only resolve when all promises are fulfilled. In the following code snippet,
    we add another Asynchronous function to our previous example and use `Promise.all()`
    to handle them:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`Promise.all()`方法接受一个要执行的promise数组，并且只有当所有promise都被实现时才会解析。在下面的代码片段中，我们向我们之前的示例中添加了另一个异步函数，并使用`Promise.all()`来处理它们：'
- en: '[PRE61]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: From the output in the preceding section, you can see that each Asynchronous
    function gets executed in the order it was added, and the final result is the
    effect of both functions on the `syncarray` variable.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分输出中，您可以看到每个异步函数按添加顺序执行，并且最终结果是这两个函数对`syncarray`变量的影响。
- en: 'The `promise.race` method, on the other hand, will return as soon as any promise
    in the array is resolved or rejected. You can think of this as a race where each
    promise tries to resolve or reject first, and as soon as this happens, the race
    is over. To see an in-depth explanation as well as code examples, you can visit
    the MDN docs here: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any).'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`promise.race`方法将在数组中的任何promise被解析或拒绝时立即返回。您可以将其视为一场比赛，其中每个promise都试图首先解析或拒绝，一旦发生这种情况，比赛就结束了。要查看深入的解释以及代码示例，您可以访问MDN文档：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/any)。
- en: 'And finally, the `promise.any` method will return on the first fulfilled promise
    irrespective of any other rejected `promise` function. If all promises are rejected,
    then `Promise.any` rejects promises by providing errors for all of them. To see
    an in-depth explanation as well as code examples, you can visit the MDN docs here:
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`promise.any`方法将返回第一个实现的promise，而不管其他被拒绝的`promise`函数。如果所有promise都被拒绝，那么`Promise.any`通过为所有promise提供错误来拒绝promise。要查看深入的解释以及代码示例，您可以访问MDN文档：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)。
- en: While using promises to work with callback solves a lot of issues, there is
    an even better way of implementing or using them. These are called **async/await**
    functions. We'll introduce these functions and show you how to use them in the
    following section.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用promise来处理回调解决了很多问题，但实现或使用它们的更好方法是**async/await**函数。我们将在下一节介绍这些函数，并向您展示如何使用它们。
- en: async/await
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: async/await
- en: As said earlier, async/await provides a more elegant way of working with promises.
    It gives us the power to control how and when each promise function gets called
    inside a function, instead of using `.then()` and `Promise.all()`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所说，async/await提供了一种更优雅的处理promise的方式。它赋予我们控制在函数内部如何以及何时调用每个promise函数的能力，而不是使用`.then()`和`Promise.all()`。
- en: 'The following code snippet shows how you can use async/await in your code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何在代码中使用async/await：
- en: '[PRE62]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The preceding `async` function can contain as many promise functions as possible,
    each waiting for the other to execute before being executed. Also, note that an
    `a``sync` function is resolved as a `Promise`. that is, you can only obtain the
    return variable of the preceding `anyName` function (or resolve the function)
    using `.then()` or by calling it in another `async`/`await` function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`async`函数可以包含尽可能多的promise函数，每个函数在执行之前都在等待其他函数执行。此外，注意`async`函数被解析为`Promise`。也就是说，您只能使用`.then()`或在另一个`async`/`await`函数中调用它来获取前面`anyName`函数的返回变量（或解析函数）：
- en: '[PRE63]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'With this knowledge, here is how we can rewrite the promise execution from
    the previous section instead of using `Promise.all([addA(), addB()])`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个知识，我们可以重新编写前一节中的promise执行，而不是使用`Promise.all([addA(), addB()])`：
- en: '[PRE64]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You can see from the preceding output that we have the same output as when using
    the `Promise.all` syntax, but are adopting a minimal and cleaner approach.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从前面的输出中看到，我们与使用`Promise.all`语法时得到了相同的输出，但采用了更简洁和清晰的方法。
- en: Note
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: One drawback of using multiple awaits as opposed to `promise.all` is efficiency.
    Though minor, `promise.all` is the preferred and recommended way to handle multiple
    independent promises.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个await而不是`promise.all`的一个缺点是效率。尽管很小，但`promise.all`是处理多个独立promise的首选和推荐方式。
- en: This thread ([https://stackoverflow.com/questions/45285129/any-difference-between-await-promise-all-and-multiple-await](https://stackoverflow.com/questions/45285129/any-difference-between-await-promise-all-and-multiple-await))
    on Stack Overflow clearly explains why this is the recommended way to handle multiple
    promises.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Stack Overflow上的这个主题（[https://stackoverflow.com/questions/45285129/any-difference-between-await-promise-all-and-multiple-await](https://stackoverflow.com/questions/45285129/any-difference-between-await-promise-all-and-multiple-await)）清楚地解释了为什么这是处理多个promise的推荐方式。
- en: In the next section, we'll discuss **object-oriented programming** (**OOP**)
    in JavaScript, and how to use ES6 classes.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论JavaScript中的**面向对象编程**（**OOP**）以及如何使用ES6类。
- en: Object-oriented programming and JavaScript classes
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程和JavaScript类
- en: OOP is a common programming paradigm supported by most high-level languages.
    In OOP, you typically program an application using the concept of objects, which
    can be a combination of data and code.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: OOP是大多数高级语言支持的常见编程范式。在OOP中，您通常使用对象的概念来编写应用程序，这些对象可以是数据和代码的组合。
- en: Data represents information about the object, while code represents attributes,
    properties, and behaviors that can be carried out on objects.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表示对象的信息，而代码表示可以在对象上执行的属性、属性和行为。
- en: OOP opens up a whole new world of possibilities as many problems can be simulated
    or designed as the interaction between different objects, thereby making it easier
    to design complex programs, as well as maintain and scale them.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程打开了一个全新的可能性世界，因为许多问题可以被模拟或设计为不同对象之间的交互，从而更容易设计复杂的程序，并且更易于维护和扩展它们。
- en: JavaScript, like other high-level languages, provides support for OOP concepts,
    although not fully ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)),
    but in essence, most of the important concepts of OOP, such as **objects**, **classes**,
    and **inheritance**, are supported, and these are mostly enough to solve many
    problems you wish to model using OOP. In the following section, we will briefly
    look at classes and how these are related to OOP in JavaScript.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript，像其他高级语言一样，提供了对面向对象编程概念的支持，尽管不是完全的（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)），但实质上，大多数重要的面向对象编程概念，如**对象**、**类**和**继承**都得到了支持，这些概念大多足以解决使用面向对象编程建模的许多问题。在接下来的部分，我们将简要介绍类以及它们与JavaScript中的面向对象编程的关系。
- en: Classes
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: Classes in OOP act like a blueprint for an object. That is, they define a template
    of an abstract object in such a way that multiple copies can be made by following
    that blueprint. Copies here are officially called **instances**. So, in essence,
    if we define a class, then we can easily create multiple instances of that class.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中的类就像对象的蓝图。也就是说，它们以一种抽象对象的模板定义，使得可以通过遵循该蓝图创建多个副本。这里的副本官方称为**实例**。因此，实质上，如果我们定义了一个类，那么我们可以轻松地创建该类的多个实例。
- en: 'In ECMA 2015, the `User` object using the ES16 `class` keyword:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMA 2015中，使用ES16的`class`关键字的`User`对象：
- en: '[PRE65]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: By using the `class` keyword, you can wrap both data (names and email) with
    functionality (functions/methods) in a cleaner way that aids easy maintenance
    as well as understanding.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`class`关键字，您可以以更清晰的方式将数据（名称和电子邮件）与功能（函数/方法）结合在一起，从而有助于易于维护和理解。
- en: Before we move on, let's break down the class template in more detail for a
    better understanding.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们更详细地分解类模板，以便更好地理解。
- en: The first line starts with the `class` keyword and is usually followed by a
    class name. A class name, by convention, is written in camel case, for instance,
    `UserModel` or `DatabaseModel`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行以`class`关键字开头，通常后面跟着一个类名。按照惯例，类名采用驼峰命名法，例如`UserModel`或`DatabaseModel`。
- en: 'An optional constructor can be added inside a `class` definition. A `constructor`
    class is an initialization function that runs every time a new instance is created
    from a class. Here, you''ll normally add code that initializes each instance with
    specific properties. For instance, in the following code snippet, we create two
    instances from the `User` class, and initialize them with specific properties:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义中可以添加一个可选的构造函数。`constructor` 类是一个初始化函数，每次从类创建新实例时都会运行。在这里，通常会添加代码，用特定属性初始化每个实例。例如，在以下代码片段中，我们从`User`类创建两个实例，并使用特定属性进行初始化：
- en: '[PRE66]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The next important part of a class is the addition of functions. Functions
    act as `class` methods and generally add a specific behavior to the class. Functions
    are also available to every instance created from the class. In our `User` class,
    methods such as `getFirstName`, `getLastName`, `getEmail`, and `setEmail` are
    added to perform different functions based on their implementation. To call functions
    on class instances, you typically use a dot notation, as you would when accessing
    an object''s property. For example, in the following code, we return the full
    name of the `Person1` instance:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 类的下一个重要部分是添加函数。函数充当`class`方法，并通常为类添加特定行为。函数也对从类创建的每个实例都可用。在我们的`User`类中，添加了诸如`getFirstName`、`getLastName`、`getEmail`和`setEmail`等方法，以根据它们的实现执行不同的功能。要在类实例上调用函数，通常使用点表示法，就像访问对象的属性时一样。例如，在以下代码中，我们返回`Person1`实例的全名：
- en: '[PRE67]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: With classes out of the way, we now move to the next concept in OOP, called
    *inheritance*.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 有了类之后，我们现在转向面向对象编程中的下一个概念，称为*继承*。
- en: Inheritance
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: '**Inheritance** in OOP is the ability of one class to use properties/methods
    of another class. It is an easy way of extending the characteristics of one class
    (subclass/child class) using another class (superclass/parent class). In that
    way, the child class inherits all the characteristics of the parent class and
    can either extend or change these properties. Let''s use an example to better
    understand this concept.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，**继承**是一个类使用另一个类的属性/方法的能力。这是一种通过使用另一个类（超类/父类）来扩展一个类（子类/子类）特征的简单方法。这样，子类继承了父类的所有特征，并且可以扩展或更改这些特性。让我们使用一个示例来更好地理解这个概念。
- en: 'In our application, let''s assume we already have the `User` class defined
    in the previous section, but we want to create a new set of users called `Teachers`.
    Teachers are also a class of users, and they will also require basic properties,
    such as the name and email that the `User` class already has. So, instead of creating
    a new class with these existing properties and methods, we can simply extend it,
    as shown in the following code snippet:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，假设我们已经在上一节中定义了`User`类，但我们想创建一个名为`Teachers`的新用户组。教师也是用户类，他们也将需要基本属性，例如`User`类已经具有的名称和电子邮件。因此，我们可以简单地扩展它，而不是创建一个具有这些现有属性和方法的新类，如下面的代码片段所示：
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Note that we use the `extends` keyword. This keyword simply makes all the properties
    in the parent class (`User`) available to the child class (`Teacher`). With just
    the basic setup, the `Teacher` class automatically has access to all the properties
    and methods of the `User` class. For instance, we can instantiate and create a
    new `Teacher` in the same way we created a `User` value:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们使用了`extends`关键字。这个关键字简单地使得父类（`User`）中的所有属性都可以在子类（`Teacher`）中使用。只需基本的设置，`Teacher`类就自动可以访问`User`类的所有属性和方法。例如，我们可以像创建`User`值一样实例化和创建一个新的`Teacher`：
- en: '[PRE69]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'After extending a class, we basically want to add new features. We can do this
    by simply adding new functions or properties inside the child class template,
    as shown in the following code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展一个类之后，我们基本上想要添加新的特性。我们可以通过简单地在子类模板中添加新的函数或属性来实现这一点，就像下面的代码所示：
- en: '[PRE70]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the preceding code snippet, we added a new method, `getUserType`, which returns
    a string of the `user` type. In this way, we can add more features that were not
    originally in the `parent` class.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们添加了一个新的方法`getUserType`，它返回`user`类型的字符串。通过这种方式，我们可以添加更多原本不在`parent`类中的特性。
- en: 'It is worth mentioning that you can replace parent functions in the `child`
    class by creating a new function in the `child` class with the same name. This
    process is called `getFullName` function in the `Teacher` class, we can do the
    following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，你可以通过在`child`类中创建一个同名的新函数来替换`parent`函数。这个过程在`Teacher`类中称为`getFullName`函数，我们可以这样做：
- en: '[PRE71]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A question may arise here: What if we want to initialize the `Teacher` class
    with additional instances besides `firstname`, `lastname`, and `email`? This is
    achievable, and we can easily extend the constructor function by using a new keyword,
    `super`. We demonstrate how to do this in the following code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能会有一个问题：如果我们想要在初始化`Teacher`类时除了`firstname`、`lastname`和`email`之外添加额外的实例，该怎么办？这是可以实现的，我们可以通过使用一个新的关键字`super`轻松扩展构造函数。我们在下面的代码中演示了如何做到这一点：
- en: '[PRE72]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding code, we are performing two new things. First, we add two new
    instance properties (`userType` and `subject`) to the `Teacher` class, and then
    we are calling the `super` function. The `super` function simply calls the parent
    class (`User`), and performs the instantiation, and immediately after, we initialize
    the new properties of the `Teacher` class.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们进行了两件新的事情。首先，我们向`Teacher`类添加了两个新的实例属性（`userType`和`subject`），然后我们调用了`super`函数。`super`函数简单地调用父类（`User`），执行实例化，然后立即初始化`Teacher`类的新属性。
- en: In this way, we are able to first initialize the parent properties before initializing
    the class properties.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们能够在初始化类属性之前先初始化父类属性。
- en: 'Classes are very useful in OOP and the `class` keyword provided in JavaScript
    makes working with OOP easy. It is worth mentioning that under the hood, JavaScript
    converts the classes template to an object, as it does not have first-class support
    for classes. This is because JavaScript, by default, is a prototype-based, object-oriented
    language. Hence, the class interface provided is called **syntactic sugar** over
    the underlying prototype-based model, which JavaScript calls under the hood. You
    can read more about this at the following link: [http://es6-features.org/#ClassDefinition](http://es6-features.org/#ClassDefinition).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 类在面向对象编程中非常有用，JavaScript中提供的`class`关键字使得使用面向对象编程变得容易。值得一提的是，在幕后，JavaScript将类模板转换为对象，因为它没有对类的一流支持。这是因为JavaScript默认是基于原型的面向对象语言。因此，JavaScript在幕后调用的类接口被称为底层原型模型上的**语法糖**。你可以在以下链接中阅读更多关于这个问题：[http://es6-features.org/#ClassDefinition](http://es6-features.org/#ClassDefinition)。
- en: Now that we have a basic understanding of OOP in JavaScript, we are ready to
    create complex applications that can be easily maintained. In the next section,
    we will discuss another important aspect of JavaScript development, which is setting
    up a development environment with modern JavaScript support.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对JavaScript中的面向对象编程有了基本的了解，我们可以开始创建易于维护的复杂应用程序。在接下来的部分中，我们将讨论JavaScript开发的另一个重要方面，即使用现代JavaScript支持设置开发环境。
- en: Setting up a modern JavaScript environment with transpilers
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个支持转译器的现代JavaScript环境
- en: One of the unique features of JavaScript, and the reason why it is very popular,
    is its cross-platform support. JavaScript runs almost everywhere, from browsers
    and desktops to even on the server side. While this is a unique feature, getting
    JavaScript to run optimally in these environments requires some setup and configuration
    using third-party tools/libraries. Another reason why you need to set up tooling
    is that you can write JavaScript in different flavors, and because these modern/newer
    flavors may not be supported by older browsers. This means that the code you write
    in newer syntax, typically post-ES15, will need to be transpiled into pre-ES16
    format for it to run properly in most browsers.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的一个独特特性，也是它非常受欢迎的原因之一，就是它的跨平台支持。JavaScript几乎可以在任何地方运行，从浏览器和桌面到甚至服务器端。虽然这是一个独特的特性，但要让JavaScript在这些环境中运行得最佳，需要一些设置和配置，使用第三方工具/库。设置工具的另一个原因是，你可以用不同的风格来编写JavaScript，因为这些现代/新的风格可能不被旧版浏览器支持。这意味着你在新语法中编写的代码，通常是ES15之后的语法，需要被转译成ES16之前的格式，才能在大多数浏览器中正确运行。
- en: In this section, you will learn how to set up and configure a JavaScript project
    to support cross-platform and modern JavaScript code. You will use two popular
    tools – **Babel** and **webpack** – to achieve this.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何设置和配置一个JavaScript项目，以支持跨平台和现代JavaScript代码。你将使用两个流行的工具——**Babel**和**webpack**来实现这一点。
- en: Babel
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Babel
- en: 'Babel is a tool for converting JavaScript code written in ES15 code into a
    backward-compatible version of JavaScript in modern or older browsers. Babel can
    help you to do the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Babel是一个工具，用于将用ES15编写的JavaScript代码转换为现代或旧版浏览器中向后兼容的JavaScript版本。Babel可以帮助你做到以下几点：
- en: Transform/transpile syntax.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换/转译语法。
- en: Polyfill features that are missing in your target environment. Some modern features
    that are not available in older environments are automatically added by Babel.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充在目标环境中缺失的功能。Babel会自动添加一些在旧环境中不可用的现代功能。
- en: Transform source code.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换源代码。
- en: 'In the following code, we show an example of a Babel-transformed code snippet:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们展示了一个经过Babel转换的代码片段的示例：
- en: '[PRE73]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You will notice that in the preceding code snippet, the modern arrow function
    is automatically transpiled to the function keyword that is supported by all browsers.
    This is what Babel does under the hood to your source code.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到在前面的代码片段中，现代箭头函数会自动转译为所有浏览器都支持的`function`关键字。这就是Babel在幕后对您的源代码所做的事情。
- en: Next, let's understand where webpack comes in.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解webpack的作用。
- en: Webpack
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webpack
- en: webpack is also a transpiler, and can perform the same function as Babel, and
    even more. webpack can package and bundle just about anything, including *images*,
    *HTML*, *CSS*, and *JavaScript*, into a single optimized script that can easily
    be used in the browser.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: webpack也是一个转译器，可以执行与Babel相同的功能，甚至更多。webpack可以将几乎任何东西，包括*图像*、*HTML*、*CSS*和*JavaScript*打包和捆绑成一个优化的脚本，可以轻松在浏览器中使用。
- en: In this section, we'll leverage both Babel and webpack to show you how to set
    up a cross-platform JavaScript project. Let's dive right in.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将利用Babel和webpack来展示如何设置一个跨平台的JavaScript项目。让我们马上开始吧。
- en: Example project using Babel and webpack
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Babel和webpack的示例项目
- en: 'In this section, we''re going to create a simple JavaScript project using `npm`.
    As such, you should have Node.js installed locally in order to follow along. Perform
    the following steps to achieve this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用`npm`创建一个简单的JavaScript项目。因此，您应该在本地安装Node.js以便跟随操作。执行以下步骤来实现这一点：
- en: 'Open a terminal in your preferred directory and create a folder with the following
    commands:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的目录中打开终端，并使用以下命令创建一个文件夹：
- en: '[PRE74]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Create a `package.json` file. While you can do this manually, it is easier
    to create one using `npm`. Run the following command in your terminal:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`package.json`文件。虽然您可以手动创建，但使用`npm`创建会更容易。在终端中运行以下命令：
- en: '[PRE75]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, install all the relevant packages that will help us to perform bundling
    and transpilation:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，安装所有相关的软件包，以帮助我们进行捆绑和转译：
- en: '[PRE76]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '{'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"name": "cross-env-js",'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "cross-env-js",'
- en: '"version": "1.0.0",'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '"version": "1.0.0",'
- en: '"description": "",'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '"description": "",'
- en: '"main": "index.js",'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '"main": "index.js",'
- en: '"scripts": {'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '"scripts": {'
- en: '"test": "echo \"Error: no test specified\" && exit 1"'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '"test": "echo \"Error: no test specified\" && exit 1"'
- en: '},'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"keywords": [],'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '"keywords": [],'
- en: '"author": "",'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '"author": "",'
- en: '"license": "ISC",'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '"license": "ISC",'
- en: '"devDependencies": {'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '"devDependencies": {'
- en: '"@babel/cli": "^7.12.8",'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '"@babel/cli": "^7.12.8",'
- en: '"@babel/core": "^7.12.9",'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '"@babel/core": "^7.12.9",'
- en: '"@babel/preset-env": "^7.12.7",'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '"@babel/preset-env": "^7.12.7"'
- en: '"babel-loader": "^8.2.2",'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '"babel-loader": "^8.2.2",'
- en: '"webpack": "^5.9.0",'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '"webpack": "^5.9.0",'
- en: '"webpack-cli": "^4.2.0"'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '"webpack-cli": "^4.2.0"'
- en: '},'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"dependencies": {'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '"dependencies": {'
- en: '"@babel/polyfill": "^7.12.1"'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '"@babel/polyfill": "^7.12.1"'
- en: '}'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE77]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Add some code, which we'll transpile and test. For this section, you can either
    create files and folders from the terminal or use a code editor. I'll use the
    Visual Studio Code editor here.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些代码，我们将对其进行转译和测试。对于这一部分，您可以从终端创建文件和文件夹，也可以使用代码编辑器。我将在这里使用Visual Studio Code编辑器。
- en: 'In your code editor, open the `cross-env-js` project folder and then create
    the files and folders as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中，打开`cross-env-js`项目文件夹，然后创建以下文件和文件夹：
- en: '[PRE78]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: That is, you will create two folders called `dist` and `src`. `dist` will contain
    an HTML file (`index.html`), which will be used to test our bundled application,
    and `src` will contain our modern JavaScript code that we want to transpile.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，您将创建两个名为`dist`和`src`的文件夹。`dist`将包含一个HTML文件（`index.html`），用于测试我们的捆绑应用程序，`src`将包含我们想要转译的现代JavaScript代码。
- en: 'After creating these files and folders, your entire directory structure should
    look like this:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些文件和文件夹后，整个目录结构应如下所示：
- en: '[PRE79]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you're using version control such as Git, you will typically add a `.gitignore`
    file to specify that `node_modules` can be ignored.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Git等版本控制工具，通常会添加一个`.gitignore`文件，指定`node_modules`可以被忽略。
- en: 'Create a `dist` folder, and in that folder, create an `index.html` file with
    the following code:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`dist`文件夹，在该文件夹中创建一个带有以下代码的`index.html`文件：
- en: '[PRE80]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The HTML file should be familiar to you, but notice that we added a `script`
    tag pointing to a `bundle.js` file. This file does not yet exist and will be generated
    by webpack using Babel under the hood.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: HTML文件对您来说应该很熟悉，但请注意我们添加了一个指向`bundle.js`文件的`script`标签。这个文件目前还不存在，将由webpack在幕后使用Babel生成。
- en: Write some modern JavaScript in the `src` folder. Starting with `utils.js`,
    we'll create and export some functions, and then import them to be used in `index.js`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中编写一些现代JavaScript。从`utils.js`开始，我们将创建并导出一些函数，然后导入它们以在`index.js`中使用。
- en: 'Starting with `utils.js`, add the following code:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 从`utils.js`开始，添加以下代码：
- en: '[PRE81]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `utils.js` script uses some modern JS syntax, such as `export` and arrow
    functions, and these will only be compatible with older browsers after transpilation.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`utils.js`脚本使用一些现代的JS语法，比如`export`和箭头函数，这些在转译后只能兼容旧浏览器。'
- en: 'Next, in the `index.js` script, you''ll import these functions and use them.
    Add the following code to your `index.js` script:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`index.js`脚本中，您将导入这些函数并使用它们。将以下代码添加到您的`index.js`脚本中：
- en: '[PRE82]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: You'll notice that we are also using arrow functions and the destructuring import
    in the `index.js` file. Here, we're importing the exported array (names) and the
    `getSubject` function from the `utils.js` script. We are also using a combination
    of the arrow function and template literals (`` ``) to retrieve and log the details
    of each `Teacher`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们还在`index.js`文件中使用箭头函数和解构导入。在这里，我们从`utils.js`脚本中导入了导出的数组（names）和`getSubject`函数。我们还使用箭头函数和模板文字（``
    ``）的组合来检索和记录每个`Teacher`的详细信息。
- en: Now that our modern JS files are ready, we'll create a configuration file that
    tells webpack where to find our source code to bundle as well as which transpiler
    to use, in our case, Babel.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的现代JS文件已经准备好，我们将创建一个配置文件，告诉webpack在哪里找到我们的源代码来捆绑，以及使用哪个转译器，就我们的情况而言，是Babel。
- en: 'In your root directory, create a `webpack.config.js` file and add the following
    code:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的根目录中，创建一个`webpack.config.js`文件，并添加以下代码：
- en: '[PRE83]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Let''s understand what is going on in this file:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一下这个文件中发生了什么：
- en: a) The first part of the config file requires the `path` module, which will
    help resolve all path-related functions.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: a) 配置文件的第一部分需要`path`模块，这将有助于解决所有与路径相关的函数。
- en: b) Next, you will notice the `entry` field. This field simply tells webpack
    where to find the starting/main script. webpack will use this file as a starting
    point, and then recursively walk through each import dependency to link all files
    relating to the entry file.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: b) 接下来，您会注意到`entry`字段。这个字段简单地告诉webpack在哪里找到起始/主要脚本。webpack将使用这个文件作为起点，然后递归地遍历每个导入依赖项，以链接与入口文件相关的所有文件。
- en: c) The next field is `output`, and this tells webpack where to save the bundled
    file. In our example, we are saving bundled files to the `dist` folder under the
    name `bundle.js` (remember we referenced `bundle.js` in our HTML file).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: c) 接下来是`output`字段，它告诉webpack在哪里保存捆绑文件。在我们的示例中，我们将捆绑文件保存到`dist`文件夹下的`bundle.js`文件中（请记住我们在HTML文件中引用了`bundle.js`）。
- en: d) Finally, in the `module` field, we specify that we want to transpile each
    script using Babel, and we also exclude transpiling `node_modules`. With this
    webpack configuration file, you're ready to transpile and bundle your source code.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: d) 最后，在`module`字段中，我们指定要使用Babel转译每个脚本，并且排除转译`node_modules`。有了这个webpack配置文件，您就可以准备转译和捆绑您的源代码了。
- en: 'In your `package.json` file, you''ll add a script command that will call `webpack`,
    as shown in the following code block:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`package.json`文件中，您将添加一个脚本命令，该命令将调用`webpack`，如下面的代码块所示：
- en: '[PRE84]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In your terminal, run the following command:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中，运行以下命令：
- en: '[PRE85]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '![Figure 1.2 – webpack bundling successful output'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2 – webpack捆绑成功的输出'
- en: '](img/B17076_01_02.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_01_02.jpg)'
- en: Figure 1.2 – webpack bundling successful output
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – webpack捆绑成功的输出
- en: Upon successful completion of the preceding steps, you can navigate to the `dist`
    folder where you will find an extra file – `bundle.js`. This file has already
    been referenced by the `index.html` file, and as such will be executed anytime
    we load the `index.html` file in the browser.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成上述步骤后，您可以导航到`dist`文件夹，在那里您将找到一个额外的文件–`bundle.js`。这个文件已经被`index.html`文件引用，因此每当我们在浏览器中加载`index.html`文件时，它将被执行。
- en: To test this, open the `index.html` file in your default browser. This can be
    done by navigating to the directory and double-clicking on the `index.html` file.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这一点，打开默认浏览器中的`index.html`文件。可以通过导航到目录并双击`index.html`文件来完成。
- en: 'Once you have the `index.html` file opened in your browser, you should open
    the developer console, where you can find your code output, as in the following
    screenshot:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在浏览器中打开了`index.html`文件，您应该打开开发者控制台，在那里您可以找到您的代码输出，就像下面的截图中一样：
- en: '![Figure 1.3 – index.js output in the browser console'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 – 浏览器控制台中的index.js输出'
- en: '](img/B17076_01_03.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_01_03.jpg)'
- en: Figure 1.3 – index.js output in the browser console
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 浏览器控制台中的index.js输出
- en: This shows that you have successfully transpiled and bundled your modern JS
    code into a format that can be executed in any browser, be it old or new.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明您已成功将现代JS代码转译和捆绑成可以在任何浏览器中执行的格式，无论是旧的还是新的。
- en: Further reading
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Bundling files can quickly become difficult and confusing, especially as the
    project gets bigger. If you require further understanding of how to bundle files,
    you can reference the following resources:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 捆绑文件可能会很快变得困难和混乱，特别是在项目变得更大时。如果您需要进一步了解如何捆绑文件，您可以参考以下资源：
- en: '* Getting Started ([https://webpack.js.org/guides/getting-started/](https://webpack.js.org/guides/getting-started/))
    with webpack'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '* 使用webpack([https://webpack.js.org/guides/getting-started/](https://webpack.js.org/guides/getting-started/))入门'
- en: '* Usage Guide ([https://babeljs.io/docs/en/usage](https://babeljs.io/docs/en/usage))
    for Babel'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '* 使用指南([https://babeljs.io/docs/en/usage](https://babeljs.io/docs/en/usage))
    for Babel'
- en: '* How to enable ES6 (and beyond) syntax with Node and Express ([https://www.freecodecamp.org/news/how-to-enable-es6-and-beyond-syntax-with-node-and-express-68d3e11fe1ab/](https://www.freecodecamp.org/news/how-to-enable-es6-and-beyond-syntax-with-node-and-express-68d3e11fe1ab/))'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '* 如何在Node和Express中启用ES6（及更高版本）语法([https://www.freecodecamp.org/news/how-to-enable-es6-and-beyond-syntax-with-node-and-express-68d3e11fe1ab/](https://www.freecodecamp.org/news/how-to-enable-es6-and-beyond-syntax-with-node-and-express-68d3e11fe1ab/))'
- en: In the next section, you'll learn how to set up testing and perform unit testing
    in your JavaScript application.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何设置测试并在您的JavaScript应用程序中进行单元测试。
- en: Unit testing with Mocha and Chai
  id: totrans-396
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mocha和Chai进行单元测试
- en: Writing tests for your application code is very important, but rarely talked
    about in most books. This is why we have decided to add this section on unit testing
    with Mocha. While you may not necessarily write verbose tests for every sample
    app you'll be building in this book, we will show you the basics you need to get
    by and you can even use them in your own project.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的应用程序代码编写测试非常重要，但在大多数书籍中很少谈到。这就是为什么我们决定添加这一部分关于使用Mocha进行单元测试。虽然您可能不会为本书中构建的每个示例应用程序编写冗长的测试，但我们将向您展示您需要了解的基础知识，并且您甚至可以在自己的项目中使用它们。
- en: Testing, or automated testing, is used during development to check that our
    code actually behaves as expected. That is, you, the writer of a function, will
    generally know beforehand how the function behaves and therefore can test the
    outcome with the expected outcome.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 测试，或自动化测试，用于在开发过程中检查我们的代码是否按预期运行。也就是说，函数的编写者通常会预先知道函数的行为，因此可以测试结果与预期结果是否一致。
- en: '`it` and `describe`, which can be used to write and run tests automatically.
    The beautiful thing about Mocha is that it can run in both node and browser environments.
    Mocha also supports integration with various assertion libraries such as *Chai*
    ([https://www.chaijs.com/](https://www.chaijs.com/)), *Expect.js* ([https://github.com/LearnBoost/expect.js](https://github.com/LearnBoost/expect.js)),
    *Should.js* ([https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js)),
    or even Node.js'' built-in *assert* ([https://nodejs.org/api/assert.html](https://nodejs.org/api/assert.html))
    module. In this book, we''ll use the Chai assertion library, as it is one of the
    most commonly used assertion libraries with Mocha.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`it`和`describe`，可用于自动编写和运行测试。Mocha的美妙之处在于它可以在node和浏览器环境中运行。Mocha还支持与各种断言库的集成，如*Chai*
    ([https://www.chaijs.com/](https://www.chaijs.com/))，*Expect.js* ([https://github.com/LearnBoost/expect.js](https://github.com/LearnBoost/expect.js))，*Should.js*
    ([https://github.com/shouldjs/should.js](https://github.com/shouldjs/should.js))，甚至是Node.js的内置*assert*
    ([https://nodejs.org/api/assert.html](https://nodejs.org/api/assert.html))模块。在本书中，我们将使用Chai断言库，因为它是Mocha中最常用的断言库之一。'
- en: Setting up a test environment
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置测试环境
- en: 'Before we begin writing tests, we''ll set up a basic Node.js project. Perform
    the following steps to achieve this:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写测试之前，我们将建立一个基本的Node.js项目。执行以下步骤来实现这一点：
- en: 'In your current working directory, create a new folder called `unit-testing`:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你当前的工作目录中，创建一个名为`unit-testing`的新文件夹：
- en: '[PRE86]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Initialize a new Node.js project using `npm`, as shown in the following command:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令使用`npm`初始化一个新的Node.js项目：
- en: '[PRE87]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Install Mocha and Chai as development dependencies:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Mocha和Chai作为开发依赖项：
- en: '[PRE88]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Following successful installation, open your `package.json` file and change
    the `test` command in `scripts` to the following:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装成功后，打开你的`package.json`文件，并将`scripts`中的`test`命令更改为以下内容：
- en: '[PRE89]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This means that we can run tests by running the `npm run test` command in the
    terminal.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以通过在终端中运行`npm run test`命令来运行测试。
- en: 'Create two folders, `src` and `test`. The `src` folder will contain our source
    code/scripts, while the `test` folder will contain corresponding tests for our
    code. Your project tree should look like the following after creating the folders:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个文件夹，`src`和`test`。`src`文件夹将包含我们的源代码/脚本，而`test`文件夹将包含我们代码的相应测试。创建完文件夹后，你的项目树应该如下所示：
- en: '[PRE90]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In the `src` folder, create a script called `utils.js`, and add the following
    functions:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src`文件夹中，创建一个名为`utils.js`的脚本，并添加以下函数：
- en: '[PRE91]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The preceding functions perform some basic computation. The first one adds two
    numbers and returns the result, while the second function computes the mean of
    numbers in an array.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数执行一些基本的计算。第一个函数将两个数字相加并返回结果，而第二个函数计算数组中数字的平均值。
- en: Note
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are writing pre-ES16 JavaScript here. This is because we do not plan to set
    up any transpiler for this sample project. In a project using modern JavaScript,
    you'll typically transpile source code before testing it.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里编写的是ES16之前的JavaScript。这是因为我们不打算为这个示例项目设置任何转译器。在使用现代JavaScript的项目中，你通常会在测试之前转译源代码。
- en: 'In your `test` folder, add a new file, also called `utils.js`. This naming
    convention is recommended, as different files should bear the same name as their
    corresponding source code. In the `utils.js` file in your `test` folder, add the
    following code:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`test`文件夹中，添加一个名为`utils.js`的新文件。建议使用这种命名约定，因为不同的文件应该与其对应的源代码同名。在`test`文件夹中的`utils.js`文件中，添加以下代码：
- en: '[PRE92]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In the first three lines of the preceding code snippet, we are importing `chai`
    and `expect`, as well as the `utils` scripts, which contain our source code.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段的前三行中，我们导入了`chai`和`expect`，以及包含我们源代码的`utils`脚本。
- en: Next, we use Mocha's `describe` and `it` functions to define our test cases.
    Note that we have two `describe` functions corresponding to the two functions
    we have in our source code. This means that each `describe` function will contain
    individual unit tests that test different aspects of our code.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用Mocha的`describe`和`it`函数来定义我们的测试用例。请注意，我们有两个`describe`函数对应于我们源代码中的两个函数。这意味着每个`describe`函数将包含测试我们代码不同方面的单元测试。
- en: The first `describe` function tests the `addTwoNumber` function and includes
    three unit tests, one of which tests whether the correct error is thrown on a
    passing string data type. The second `describe` function tests the `mean` function
    by providing different values.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`describe`函数测试`addTwoNumber`函数，并包含三个单元测试，其中一个测试了在传递字符串数据类型时是否抛出了正确的错误。第二个`describe`函数通过提供不同的值来测试`mean`函数。
- en: 'To run our test, go to your terminal and run the following command:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的测试，去你的终端并运行以下命令：
- en: '[PRE93]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '![Figure 1.4 – Mocha test output showing all tests passed'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4 - Mocha测试输出显示所有测试通过'
- en: '](img/B17076_01_04.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_01_04.jpg)'
- en: Figure 1.4 – Mocha test output showing all tests passed
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 - Mocha测试输出显示所有测试通过
- en: By following the preceding steps, we were able to write and run some tests that
    passed on the first run. This may not be the case most times, as your test will
    generally fail a lot before passing, especially when you have numerous unit tests
    for different edge cases.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循上述步骤，我们能够编写并运行一些在第一次运行时通过的测试。这在大多数情况下可能不是这样，因为你的测试通常会在通过之前失败很多次，特别是当你有许多不同边界情况的单元测试时。
- en: As an example, we'll add a new test case that expects an error when the array
    passed to the mean function contains no element.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将添加一个新的测试用例，当传递给平均函数的数组不包含任何元素时，期望出现错误。
- en: 'In the test script, under the second `describe` function, add the following
    unit test:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试脚本中，在第二个`describe`函数下，添加以下单元测试：
- en: '[PRE94]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'By running the test again, we''ll see the following error:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试，我们将看到以下错误：
- en: '![Figure 1.5 – Mocha test output showing one failed test'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5 - Mocha测试输出显示一个测试失败'
- en: '](img/B17076_01_05.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_01_05.jpg)'
- en: Figure 1.5 – Mocha test output showing one failed test
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 - Mocha测试输出显示一个测试失败
- en: 'The error message provided by Mocha tells us that our function is expected
    to throw an error when an empty array is passed, but it is currently not doing
    that. To fix this error, we''ll go to our source code and update the `mean` function,
    as shown in the following code block:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha提供的错误消息告诉我们，当传递一个空数组时，我们的函数应该抛出一个错误，但目前并没有这样做。为了修复这个错误，我们将转到我们的源代码并更新`mean`函数，如下面的代码块所示：
- en: '[PRE95]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now, if we run the test again, we should see it pass successfully:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次运行测试，我们应该看到它成功通过：
- en: '![Figure 1.6 – Mocha test output showing that all tests passed'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6 - Mocha测试输出显示所有测试都通过了'
- en: '](img/B17076_01_06.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_01_06.jpg)'
- en: Figure 1.6 – Mocha test output showing that all tests passed
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 - Mocha测试输出显示所有测试都通过了
- en: Further reading
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Mocha is versatile and provides support for almost all test cases and scenarios
    you''ll encounter. To learn more, you can visit the official documentation here:
    [https://mochajs.org/](https://mochajs.org/).'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha是多才多艺的，并为您可能遇到的几乎所有测试用例和场景提供支持。要了解更多信息，您可以访问官方文档：[https://mochajs.org/](https://mochajs.org/)。
- en: 'Chai, on the other hand, provides numerous assertion statements and functions
    that you can use to enrich your test. You can learn more about these assertions
    here: [https://www.chaijs.com/api/](https://www.chaijs.com/api/).'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: Chai, 另一方面，提供了许多断言语句和函数，您可以使用它们来丰富您的测试。您可以在这里了解更多关于这些断言：[https://www.chaijs.com/api/](https://www.chaijs.com/api/)。
- en: Congratulations on making it to the end of this chapter! It was a lengthy one,
    but the concepts covered are important, as they will help you build better data-driven
    products, as you'll see in future chapters.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜您完成了本章！这是一个冗长的章节，但所涵盖的概念很重要，因为它们将帮助您构建更好的数据驱动产品，正如您将在未来章节中看到的。
- en: Summary
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced and discussed some of the modern JavaScript syntax
    introduced in ECMA 6\. We first considered the difference between `let` and `var`
    and discussed why `let` is the preferred method for initializing variables. Following
    that, we discussed destructuring, the spread operator, scopes, and also closures.
    We then went on to introduce some important methods of arrays, objects, and strings.
    Following that, we talked about arrow functions, including their advantages over
    traditional functions, and then we moved on to discuss JavaScript promises and
    async/await.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍并讨论了ECMA 6中引入的一些现代JavaScript语法。我们首先考虑了`let`和`var`之间的区别，并讨论了为什么`let`是初始化变量的首选方法。在此之后，我们讨论了解构、展开运算符、作用域，以及闭包。然后，我们介绍了一些数组、对象和字符串的重要方法。在此之后，我们讨论了箭头函数，包括它们相对于传统函数的优势，然后我们继续讨论了JavaScript的promises和async/await。
- en: We then looked briefly at OOP concepts and support in JavaScript with examples
    showing how to write classes. We also learned how to set up a modern JavaScript
    environment with transpiling and bundling support using tools such as Babel and
    webpack. Finally, we introduced unit testing using Mocha and the Chai library.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们简要介绍了JavaScript中的面向对象编程概念和支持，并通过示例展示了如何编写类。我们还学习了如何使用诸如Babel和webpack之类的工具建立现代JavaScript环境，支持转译和捆绑。最后，我们介绍了使用Mocha和Chai库进行单元测试。
- en: In the next chapter, we will introduce Dnotebook, an interactive computing environment
    that enables quick and interactive experimentation in JavaScript.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Dnotebook，这是一个交互式计算环境，可以在JavaScript中进行快速和交互式的实验。
