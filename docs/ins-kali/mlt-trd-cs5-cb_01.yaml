- en: Chapter 1. Threading Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。线程基础知识
- en: 'In this chapter, we will cover the basic tasks for working with threads in
    C#. You will learn about:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍在C#中使用线程的基本任务。您将了解到：
- en: Creating a thread in C#
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#中创建线程
- en: Pausing a thread
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停线程
- en: Making a thread wait
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使线程等待
- en: Aborting a thread
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中止线程
- en: Determining thread state
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定线程状态
- en: Thread priority
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程优先级
- en: Foreground and background threads
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前台和后台线程
- en: Passing parameters to a thread
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向线程传递参数
- en: Locking with a C# lock keyword
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C#锁定关键字进行锁定
- en: Locking with a Monitor construct
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用监视器构造进行锁定
- en: Handling exceptions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异常
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: At some point of time in the past, the common computer had only one computing
    unit and could not execute several computing tasks simultaneously. However, operating
    systems could already work with multiple programs simultaneously, implementing
    the concept of multitasking. To prevent the possibility of one program taking
    control of the CPU, forever causing other applications and the operating system
    itself to hang, the operating systems had to split a physical computing unit across
    a few virtualized processors in some way and give a certain amount of computing
    power to each executing program. Moreover, an operating system must always have
    priority access to the CPU and should be able to prioritize CPU access to different
    programs. A thread is an implementation of this concept. It could be considered
    a virtual processor given to the one specific program that runs it independently.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的某个时刻，普通计算机只有一个计算单元，无法同时执行多个计算任务。然而，操作系统已经可以同时处理多个程序，实现了多任务的概念。为了防止一个程序永远控制CPU，导致其他应用程序和操作系统本身挂起，操作系统必须以某种方式将物理计算单元分割成几个虚拟处理器，并为每个执行程序分配一定量的计算能力。此外，操作系统必须始终具有对CPU的优先访问权，并且应该能够为不同的程序优先访问CPU。线程是这一概念的实现。它可以被认为是分配给独立运行的特定程序的虚拟处理器。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that a thread consumes a significant amount of operating system resources.
    Trying to share one physical processor across many threads will lead to a situation
    where an operating system is busy just managing threads instead of running programs.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，线程会消耗大量的操作系统资源。试图在许多线程之间共享一个物理处理器将导致操作系统忙于管理线程而无法运行程序的情况。
- en: Therefore, while it was possible to enhance computer processors, making them
    execute more and more commands per second, working with threads was usually an
    operating system task. There was no sense in trying to compute some tasks in parallel
    on a single-core CPU because it would take more time than running those computations
    sequentially. However, when processors started to have more computing cores, older
    programs could not take advantage of this because they just used one processor
    core.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然可以增强计算机处理器，使其每秒执行更多命令，但处理线程通常是操作系统的任务。在单核CPU上尝试并行计算某些任务是没有意义的，因为这比按顺序运行这些计算需要更多时间。然而，当处理器开始拥有更多的计算核心时，旧程序无法利用这一点，因为它们只使用一个处理器核心。
- en: To use a modern processor's computing power effectively, it is very important
    to be able to compose a program in a way that it can use more than one computing
    core, which leads to organizing it as several threads communicating and synchronizing
    with each other.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地利用现代处理器的计算能力，非常重要的是能够以多线程通信和同步的方式组织程序，从而使用多个计算核心。
- en: The recipes in this chapter will focus on performing some very basic operations
    with threads in the C# language. We will cover a thread's lifecycle, which includes
    creating, suspending, making a thread wait, and aborting a thread, and then we
    will go through basic synchronization techniques.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例将重点介绍在C#语言中使用线程执行一些非常基本的操作。我们将涵盖线程的生命周期，包括创建、挂起、使线程等待和中止线程，然后我们将介绍基本的同步技术。
- en: Creating a thread in C#
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中创建线程
- en: Throughout the following recipes, we will use Visual Studio 2012 as the main
    tool to write multithreaded programs in C#. This recipe will show you how to create
    a new C# program and use threads in it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将使用Visual Studio 2012作为编写C#多线程程序的主要工具。本示例将向您展示如何创建一个新的C#程序并在其中使用线程。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are free Visual Studio 2012 Express editions, which can be downloaded
    from the Microsoft website. We will need Visual Studio 2012 Express for Windows
    Desktop for most of the examples and Visual Studio 2012 Express for Windows 8
    for Windows 8-specific recipes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有免费的Visual Studio 2012 Express版本，可以从微软网站下载。我们将需要Visual Studio 2012 Express for
    Windows Desktop来进行大多数示例，以及Visual Studio 2012 Express for Windows 8来进行Windows 8特定的示例。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe1`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本示例，您将需要Visual Studio 2012。没有其他先决条件。本示例的源代码可以在`BookSamples\Chapter1\Recipe1`中找到。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    through your account at [http://www.packtpub.com](http://www.packtpub.com). If
    you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过您在[http://www.packtpub.com](http://www.packtpub.com)的帐户下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to create a new C# program and use threads in it, perform
    the following steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何创建一个新的C#程序并在其中使用线程，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: Make sure that the project uses .NET Framework 4.0 or higher version.![How to
    do it...](img/7644OT_01_01.jpg)
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保项目使用.NET Framework 4.0或更高版本。![如何做...](img/7644OT_01_01.jpg)
- en: 'In the `Program.cs` file add the following `using` directives:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中添加以下`using`指令：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program. The output will be something like:![How to do it...](img/7644OT_01_02.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。输出将会是这样的：![如何做...](img/7644OT_01_02.jpg)
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In steps 1 and 2 we created a simple console application in C# using .Net Framework
    version 4.0\. Then in step 3 we included the namespace `System.Threading`, which
    contains all the types needed for the program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1和2中，我们使用.Net Framework版本4.0创建了一个简单的C#控制台应用程序。然后在第3步中，我们包含了包含程序所需的所有类型的`System.Threading`命名空间。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An instance of a program is being executed can be referred to as a process.
    A process consists of one or more threads. This means that when we run a program,
    we always have one main thread that executes the program code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 正在执行程序的实例可以称为进程。一个进程由一个或多个线程组成。这意味着当我们运行一个程序时，我们总是有一个执行程序代码的主线程。
- en: In step 4 we defined the method `PrintNumbers`, which will be used in both the
    main and newly created threads. Then in step 5, we created a thread that runs
    `PrintNumbers`. When we construct a thread, an instance of the `ThreadStart` or
    `ParameterizedThreadStart` delegate is passed to the constructor. The C# compiler
    is creating this object behind the scenes when we just type the name of the method
    we want to run in a different thread. Then we start a thread and run `PrintNumbers`
    in the usual manner on the main thread.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们定义了`PrintNumbers`方法，该方法将在主线程和新创建的线程中使用。然后在第5步中，我们创建了一个运行`PrintNumbers`的线程。当我们构造一个线程时，`ThreadStart`或`ParameterizedThreadStart`委托的实例被传递给构造函数。当我们只需输入要在不同线程中运行的方法的名称时，C#编译器在幕后创建了这个对象。然后我们启动一个线程，并在主线程上以通常的方式运行`PrintNumbers`。
- en: As a result, there will be two ranges of numbers from 1 to 10 randomly crossing
    each other. This illustrates that the `PrintNumbers` method runs simultaneously
    on the main thread and on the other thread.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将会有两个范围从1到10的数字范围随机交叉。这说明`PrintNumbers`方法同时在主线程和另一个线程上运行。
- en: Pausing a thread
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停一个线程
- en: This recipe will show you how to make a thread wait for some time without wasting
    operating system resources.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将向您展示如何使一个线程在一段时间内等待，而不浪费操作系统资源。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe2`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本示例，您需要Visual Studio 2012。没有其他先决条件。本示例的源代码可以在`BookSamples\Chapter1\Recipe2`中找到。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to make a thread wait without wasting operating system resource,
    perform the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解如何使一个线程等待而不浪费操作系统资源，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file add the following `using` directives:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中添加以下`using`指令：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the program.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program is run, it creates a thread that will execute a code in the
    `PrintNumbersWithDelay` method. Immediately after that, it runs the `PrintNumbers`
    method. The key feature here is adding the `Thread.Sleep` method call to a `PrintNumbersWithDelay`
    method. It causes a thread executing this code to wait a specified amount of time
    (two seconds in our case) before printing each number. While a thread is sleeping,
    it uses as little CPU time as possible. As a result, we will see that the code
    in the `PrintNumbers` method that usually runs later will be executed before the
    code in the `PrintNumbersWithDelay` method in a separate thread.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它创建一个线程，该线程将在`PrintNumbersWithDelay`方法中执行代码。在那之后，它立即运行`PrintNumbers`方法。这里的关键特点是在`PrintNumbersWithDelay`方法中添加`Thread.Sleep`方法调用。它会导致执行此代码的线程在打印每个数字之前等待指定的时间（在我们的例子中为两秒）。当一个线程正在睡眠时，它尽可能少地使用CPU时间。因此，我们将看到通常稍后运行的`PrintNumbers`方法中的代码将在单独的线程中的`PrintNumbersWithDelay`方法中的代码之前执行。
- en: Making a thread wait
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使一个线程等待
- en: This recipe will show you how a program can wait for some computation in another
    thread to complete to use its result later in the code. It is not enough to use
    `Thread.Sleep` because we don't know the exact time the computation will take.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将向您展示程序如何等待另一个线程中的某些计算完成，以便稍后在代码中使用其结果。仅使用`Thread.Sleep`是不够的，因为我们不知道计算需要多长时间。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe3`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本示例，您需要Visual Studio 2012。没有其他先决条件。本示例的源代码可以在`BookSamples\Chapter1\Recipe3`中找到。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how a program can wait for some computation in another thread
    to complete to use its result later, perform the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解程序如何等待另一个线程中的某些计算完成，以便稍后使用其结果，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program is run, it runs a long-running thread that prints out numbers
    and waits two seconds before printing each number. But in the main program, we
    called the `t.Join` method, which allows us to wait for thread `t` to complete.
    When it is complete, the main program continues to run. With the help of this
    technique, it is possible to synchronize execution steps between two threads.
    The first one waits until another one is complete and then continues to work.
    While the first thread is waiting, it is in a blocked state (as it is in the previous
    recipe when you call `Thread.Sleep`).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，它运行一个长时间运行的线程，打印出数字，并在打印每个数字之前等待两秒。但在主程序中，我们调用了`t.Join`方法，这允许我们等待线程`t`完成。当它完成时，主程序继续运行。借助这种技术，可以在两个线程之间同步执行步骤。第一个线程等待另一个完成，然后继续工作。在第一个线程等待时，它处于阻塞状态（就像在之前的示例中调用`Thread.Sleep`时一样）。
- en: Aborting a thread
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中止一个线程
- en: In this recipe, we will describe how to abort another thread's execution.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将描述如何中止另一个线程的执行。
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe4`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本示例，您需要Visual Studio 2012。没有其他先决条件。本示例的源代码可以在`BookSamples\Chapter1\Recipe4`中找到。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to abort another thread''s execution, perform the following
    steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何中止另一个线程的执行，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the program.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program and a separate number-printing thread run, we wait for
    6 seconds and then call a `t.Abort` method on a thread. This injects a `ThreadAbortException`
    method into a thread causing it to terminate. It is very dangerous, generally
    because this exception can happen at any point and may totally destroy the application.
    In addition, it is not always possible to terminate a thread with this technique.
    The target thread may refuse to abort by handling this exception and calling the
    `Thread.ResetAbort` method. Thus, it is not recommended that you use the `Abort`
    method to close a thread. There are different methods that are preferred, such
    as providing a `CancellationToken` method to cancel a thread execution. This approach
    will be described in [Chapter 3](ch03.html "Chapter 3. Using a Thread Pool"),
    *Using a Thread Pool*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序和一个单独的打印数字的线程运行时，我们等待6秒，然后在一个线程上调用`t.Abort`方法。这会向线程注入一个`ThreadAbortException`方法，导致线程终止。这是非常危险的，通常因为这个异常可能在任何时候发生，可能会完全破坏应用程序。此外，并不总是可能使用这种技术终止线程。目标线程可能拒绝通过处理此异常并调用`Thread.ResetAbort`方法来中止。因此，不建议使用`Abort`方法来关闭线程。有不同的方法更受推荐，比如提供一个`CancellationToken`方法来取消线程执行。这种方法将在[第3章](ch03.html
    "第3章。使用线程池")*使用线程池*中描述。
- en: Determining a thread state
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定线程状态
- en: This recipe will describe possible states a thread could have. It is useful
    to get information about whether a thread is started yet or whether it is in a
    blocked state. Please note that because a thread runs independently, its state
    could be changed at any time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将描述线程可能具有的可能状态。了解线程是否已启动或是否处于阻塞状态非常有用。请注意，因为线程独立运行，其状态可能随时改变。
- en: Getting ready
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe5`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本示例，您需要Visual Studio 2012。没有其他先决条件。本示例的源代码可以在`BookSamples\Chapter1\Recipe5`中找到。
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to determine a thread state and acquire useful information
    about it, perform the following steps:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何确定线程状态并获取有用的信息，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the program.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts it defines two different threads; one of them will
    be aborted and the other runs successfully. The thread state is located in the
    `ThreadState` property of a `Thread` object, which is a C# enumeration. At first
    the thread has a `ThreadState.Unstarted` state. Then we run it and assume that,
    for the duration of 30 iterations of a cycle, the thread will change its state
    from `ThreadState.Running` to `ThreadState.WaitSleepJoin`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它定义了两个不同的线程；其中一个将被中止，另一个成功运行。线程状态位于`Thread`对象的`ThreadState`属性中，这是一个C#枚举。一开始，线程处于`ThreadState.Unstarted`状态。然后我们运行它，并假设在30次循环迭代的过程中，线程将从`ThreadState.Running`状态变为`ThreadState.WaitSleepJoin`状态。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Please note that the current `Thread` object is always accessible through the
    `Thread.CurrentThread` static property.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当前的`Thread`对象始终可以通过`Thread.CurrentThread`静态属性访问。
- en: If it does not happen, just increase the number of iterations. Then we abort
    the first thread and see that now it has a `ThreadState.Aborted` state. It is
    also possible that the program will print out the `ThreadState.AbortRequested`
    state. This illustrates very well the complexity of synchronizing two threads.
    Please keep in mind that you should not use thread abortion in your programs.
    I've covered it here only to show the corresponding thread state.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生，只需增加迭代次数。然后我们中止第一个线程，并看到现在它有一个`ThreadState.Aborted`状态。程序也可能打印出`ThreadState.AbortRequested`状态。这很好地说明了同步两个线程的复杂性。请记住，您不应该在程序中使用线程中止。我在这里只是为了展示相应的线程状态。
- en: Finally, we can see that our second thread `t2` completed successfully and now
    has a `ThreadState.Stopped` state. There are several other states, but they are
    partly deprecated and partly not as useful as those we examined.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到我们的第二个线程`t2`成功完成，现在有一个`ThreadState.Stopped`状态。还有其他几种状态，但它们部分已被弃用，部分不如我们检查的那些有用。
- en: Thread priority
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程优先级
- en: This recipe will describe the different possible options for thread priority.
    Setting a thread priority determines how much CPU time a thread will be given.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将描述线程优先级的不同可能选项。设置线程优先级确定线程将获得多少CPU时间。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe6`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个示例，您需要Visual Studio 2012。没有其他先决条件。此示例的源代码可以在`BookSamples\Chapter1\Recipe6`中找到。
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand the workings of thread priority, perform the following steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解线程优先级的工作原理，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始Visual Studio 2012。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the program.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, it defines two different threads. The first one,
    `ThreadPriority.Highest`, will have the highest thread priority, while the second
    one, that is `ThreadPriority.Lowest`, will have the lowest. We print out the main
    thread priority value and then start these two threads on all available cores.
    If we have more than one computing core, we should get an initial result within
    two seconds. The highest priority thread should calculate more iterations usually,
    but both values should be close. However, if there are any other programs running
    that load all the CPU cores, the situation could be quite different.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它定义了两个不同的线程。第一个是`ThreadPriority.Highest`，将具有最高的线程优先级，而第二个是`ThreadPriority.Lowest`，将具有最低的优先级。我们打印出主线程优先级值，然后在所有可用的核心上启动这两个线程。如果我们有多个计算核心，我们应该在两秒内得到一个初始结果。最高优先级线程通常应该计算更多迭代，但两个值应该接近。但是，如果有其他程序运行并加载所有CPU核心，情况可能会大不相同。
- en: To simulate this situation, we set up the `ProcessorAffinity` option, instructing
    the operating system to run all our threads on a single CPU core (number one).
    Now the results should be very different and the calculations will take more than
    2 seconds. This happens because the CPU core will run mostly the high-priority
    thread, giving the rest of the threads very little time.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟这种情况，我们设置了`ProcessorAffinity`选项，指示操作系统在单个CPU核心（编号为一）上运行所有线程。现在结果应该非常不同，计算将花费超过2秒。这是因为CPU核心将主要运行高优先级线程，给其他线程很少的时间。
- en: Please note that this is an illustration of how an operating system works with
    thread prioritization. Usually, you should not write programs relying on this
    behavior.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是操作系统如何处理线程优先级的示例。通常，您不应该编写依赖于此行为的程序。
- en: Foreground and background threads
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前台和后台线程
- en: This recipe will describe what foreground and background threads are and how
    setting this option affects the program's behavior.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将描述前台和后台线程是什么，以及设置此选项如何影响程序行为。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe7`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个示例，您需要Visual Studio 2012。没有其他先决条件。此示例的源代码可以在`BookSamples\Chapter1\Recipe7`中找到。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand the effect of foreground and background threads on a program,
    perform the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解前台和后台线程对程序的影响，请执行以下操作：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始Visual Studio 2012。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the program.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts it defines two different threads. By default, a
    thread we create explicitly is a foreground thread. To create a background thread,
    we manually set the `IsBackground` property of the `threadTwo` object to `true`.
    We configure these threads in a way that the first one will complete faster, and
    then we run the program.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它定义了两个不同的线程。默认情况下，我们显式创建的线程是前台线程。要创建后台线程，我们手动将`threadTwo`对象的`IsBackground`属性设置为`true`。我们以第一个线程将更快完成的方式配置这些线程，然后运行程序。
- en: 'After the first thread completes, the program shuts down and the background
    thread terminates. This is the main difference between the two: a process waits
    for all the foreground threads to complete before finishing the work, but if it
    has background threads, they just shut down.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个线程完成后，程序关闭，后台线程终止。这是两者之间的主要区别：进程在完成工作之前等待所有前台线程完成，但如果有后台线程，它们只是关闭。
- en: It is also important to mention that if a program defines a foreground thread
    that does not complete, the main program will not end properly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，如果程序定义了一个前台线程，而这个线程没有完成，主程序将无法正常结束。
- en: Passing parameters to a thread
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向线程传递参数
- en: This recipe will describe how to provide a code we run in another thread with
    the required data. We will go through the different ways to fulfill this task
    and review common mistakes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将描述如何向在另一个线程中运行的代码提供所需的数据。我们将介绍不同的方式来完成这个任务，并审查常见的错误。
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe8`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个示例，您需要Visual Studio 2012。没有其他先决条件。这个示例的源代码可以在`BookSamples\Chapter1\Recipe8`中找到。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to pass parameters to a thread, perform the following steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何向线程传递参数，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the program.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the main program starts, it first creates an object of class `ThreadSample`,
    providing it with a number of iterations. Then we start a thread with the object's
    method `CountNumbers`. This method runs in another thread, but it uses the number
    10, which is the value that we passed to the object's constructor. Therefore,
    we just passed this number of iterations to another thread in the same indirect
    way.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，首先创建一个`ThreadSample`类的对象，并为其提供一定数量的迭代次数。然后我们使用对象的方法`CountNumbers`启动一个线程。这个方法在另一个线程中运行，但它使用数字10，这是我们传递给对象构造函数的值。因此，我们只是以同样间接的方式将这个迭代次数传递给另一个线程。
- en: There's more…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another way to pass data is to use the `Thread.Start` method by accepting an
    object that can be passed to another thread. To work this way, a method that we
    started in another thread must accept one single parameter of type object. This
    option is illustrated by creating a `threadTwo` thread. We pass `8` as an object
    to the `Count` method, where it is cast to an `integer` type.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种传递数据的方式是使用`Thread.Start`方法，接受一个可以传递给另一个线程的对象。为了以这种方式工作，我们在另一个线程中启动的方法必须接受一个类型为object的单个参数。通过创建一个`threadTwo`线程来说明这个选项。我们将`8`作为一个对象传递给`Count`方法，在那里它被转换为`integer`类型。
- en: The next option involves using lambda expressions. A lambda expression defines
    a method that does not belong to any class. We create such a method that invokes
    another method with the arguments needed and start it in another thread. When
    we start the `threadThree` thread, it prints out 12 numbers, which are exactly
    the numbers we passed to it via the lambda expression.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项涉及使用lambda表达式。lambda表达式定义了一个不属于任何类的方法。我们创建这样一个方法，调用另一个方法所需的参数，并在另一个线程中启动它。当我们启动`threadThree`线程时，它打印出12个数字，这些数字正是我们通过lambda表达式传递给它的数字。
- en: Using the lambda expressions involves another C# construct named `closure`.
    When we use any local variable in a lambda expression, C# generates a class and
    makes this variable a property of this class. So actually, we do the same thing
    as in the `threadOne` thread, but we do not define the class ourselves; the C#
    compiler does this automatically.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lambda表达式涉及另一个名为`闭包`的C#构造。当我们在lambda表达式中使用任何局部变量时，C#会生成一个类，并将这个变量作为这个类的属性。因此，实际上，我们做的事情与`threadOne`线程中的一样，但我们不是自己定义这个类；C#编译器会自动完成这个工作。
- en: This could lead to several problems; for example, if we use the same variable
    from several lambdas, they will actually share this variable value. This is illustrated
    by the previous example; when we start `threadFour` and `threadFive`, they will
    both print `20` because the variable was changed to hold the value `20` before
    both threads were started.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致几个问题；例如，如果我们从几个lambda中使用相同的变量，它们实际上会共享这个变量的值。这可以通过前面的例子来说明；当我们启动`threadFour`和`threadFive`时，它们都会打印出`20`，因为在启动这两个线程之前，变量已经被更改为持有值`20`。
- en: Locking with a C# lock keyword
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用C#锁定关键字进行锁定
- en: This recipe will describe how to ensure that if one thread uses some resource,
    another does not simultaneously use it. We will see why this is needed and what
    the thread safety concept is all about.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将描述如何确保一个线程使用某个资源时，另一个线程不会同时使用它。我们将看到为什么需要这样做，以及线程安全概念是什么。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites The source code for this recipe can be found at `BookSamples\Chapter1\Recipe9`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个示例，您需要Visual Studio 2012。没有其他先决条件。这个示例的源代码可以在`BookSamples\Chapter1\Recipe9`中找到。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to use the C# lock keyword, perform the following steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用C#锁定关键字，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Run the program.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the main program starts, it first creates an object of the class `Counter`.
    This class defines a simple counter that can be incremented and decremented. Then
    we start three threads that share the same counter instance and perform an increment
    and decrement in a cycle. This leads to nondeterministic results. If we run the
    program several times, it will print out several different counter values. It
    could be zero, but mostly won't be.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，首先创建一个`Counter`类的对象。这个类定义了一个简单的计数器，可以进行增加和减少。然后我们启动三个线程，它们共享同一个计数器实例，并在一个循环中执行增加和减少操作。这会导致不确定的结果。如果我们多次运行程序，会打印出几个不同的计数器值。它可能是零，但大多数情况下不会是。
- en: This happens because the `Counter` class is not thread safe. When several threads
    access the counter at the same time, the first thread gets the counter value `10`
    and increments it to 11\. Then a second thread gets the value 11 and increments
    it to 12\. The first thread gets the counter value 12, but before a decrement
    happens, a second thread gets the counter value 12 as well. Then the first thread
    decrements 12 to 11 and saves it into the counter, and the second thread simultaneously
    does the same. As a result, we have two increments and only one decrement, which
    is obviously not right. This kind of a situation is called race condition and
    is a very common cause of errors in a multithreaded environment.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`Counter`类不是线程安全的。当多个线程同时访问计数器时，第一个线程获取计数器值为`10`并将其增加到11。然后第二个线程获取值11并将其增加到12。第一个线程获取计数器值12，但在减少之前，第二个线程也获取了计数器值12。然后第一个线程将12减少到11并保存到计数器中，而第二个线程同时也做同样的操作。结果是我们有两次增加和只有一次减少，这显然是不对的。这种情况被称为竞争条件，是多线程环境中错误的一个常见原因。
- en: To make sure that this does not happen, we must ensure that while one thread
    works with the counter, all other threads must wait until the first one finishes
    the work. We can use the `lock` keyword to achieve this kind of behavior. If we
    `lock` an object, all the other threads that require an access to this object
    will be waiting in a blocked state until it is unlocked. This could be a serious
    performance issue and later, in [Chapter 2](ch02.html "Chapter 2. Thread Synchronization"),
    *Thread Synchronization*, we will learn more about this.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这种情况不会发生，我们必须确保当一个线程使用计数器时，所有其他线程必须等待，直到第一个线程完成工作。我们可以使用`lock`关键字来实现这种行为。如果我们`lock`一个对象，所有需要访问这个对象的其他线程将会处于阻塞状态，直到它被解锁。这可能会导致严重的性能问题，稍后在[第2章](ch02.html
    "第2章. 线程同步")中，*线程同步*，我们将学到更多关于这个的知识。
- en: Locking with a Monitor construct
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Monitor构造锁定
- en: This recipe illustrates another common multithreaded error called a deadlock.
    Since a deadlock will cause a program to stop working, the first piece in this
    example is a new `Monitor` construct that allows us to avoid a deadlock. Then,
    the previously described `lock` keyword is used to get a deadlock.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例说明了另一个常见的多线程错误，称为死锁。由于死锁会导致程序停止工作，所以这个示例的第一部分是一个新的`Monitor`构造，它允许我们避免死锁。然后，之前描述的`lock`关键字被用来产生死锁。
- en: Getting ready
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe10`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个示例，你需要Visual Studio 2012。没有其他先决条件。这个示例的源代码可以在`BookSamples\Chapter1\Recipe10`中找到。
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand the multithreaded error deadlock, perform the following steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解多线程错误死锁，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C# **控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中添加以下代码片段：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Run the program.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's start with the `LockTooMuch` method. In this method, we just `lock` the
    first object, wait a second and then `lock` the second object. Then we start this
    method in another thread and try to `lock` the second object and then the first
    object from the main thread.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`LockTooMuch`方法开始。在这个方法中，我们只是锁定第一个对象，等待一秒，然后锁定第二个对象。然后我们在另一个线程中启动这个方法，并尝试从主线程锁定第二个对象，然后锁定第一个对象。
- en: If we use the `lock` keyword like in the second part of this demo, it would
    be a deadlock. The first thread holds a `lock` on the `lock1` object and waits
    while the `lock2` object gets free; the main thread holds a `lock` on the `lock2`
    object and waits for the `lock1` object to become free, which in this situation
    will never happen.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像示例的第二部分那样使用`lock`关键字，就会发生死锁。第一个线程持有`lock1`对象的`lock`并等待`lock2`对象释放；主线程持有`lock2`对象的`lock`并等待`lock1`对象释放，而在这种情况下永远不会发生。
- en: 'Actually, the `lock` keyword is a syntactic sugar for `Monitor` class usage.
    If we were to disassemble a code with `lock`, we would see that it turns into
    the following code snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`lock`关键字是对`Monitor`类使用的一种语法糖。如果我们反汇编带有`lock`的代码，我们会看到它转换成以下代码片段：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Therefore, we can use the `Monitor` class directly; it has the `TryEnter` method,
    which accepts a timeout parameter and returns `false` if this timeout parameter
    expires before we can acquire the resource protected by `lock`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以直接使用`Monitor`类；它有`TryEnter`方法，接受一个超时参数，并在我们无法获取由`lock`保护的资源之前超时返回`false`。
- en: Handling exceptions
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理异常
- en: This recipe will describe how to handle exceptions in other threads properly.
    It is very important to always place a `try/catch` block inside the thread because
    it is not possible to catch an exception outside a thread's code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将描述如何正确处理其他线程中的异常。在线程内部始终放置一个`try/catch`块非常重要，因为在线程代码外部无法捕获异常。
- en: Getting ready
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To work through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter1\Recipe11`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个示例，你需要Visual Studio 2012。没有其他先决条件。这个示例的源代码可以在`BookSamples\Chapter1\Recipe11`中找到。
- en: How to do it...
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到…
- en: 'To understand the handling of exceptions in other threads, perform the following
    steps:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解其他线程中异常的处理，执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C# **控制台应用程序**项目。
- en: 'In the `Program.cs` file add the following `using` directives:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中添加以下`using`指令：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE32]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE33]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Run the program.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When the main program starts, it defines two threads that will throw an exception.
    One of these threads handles exception, while the other does not. You can see
    that the second exception is not caught by a `try/catch` block around a code that
    starts the thread. So if you work with threads directly, the general rule is to
    not throw an exception from a thread, but to use a `try/catch` block inside a
    thread code instead.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，它定义了两个将抛出异常的线程。其中一个线程处理异常，而另一个不处理。你可以看到第二个异常没有被`try/catch`块捕获，而是在启动线程的代码周围。因此，如果直接使用线程，一般规则是不要从线程中抛出异常，而是在线程代码内部使用`try/catch`块。
- en: 'In the older versions of .NET Framework (1.0 and 1.1), this behavior was different
    and uncaught exceptions did not force an application shutdown. It is possible
    to use this policy by adding an application configuration file (such as `app.config`)
    containing the following code snippet:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧版本的.NET Framework（1.0和1.1）中，这种行为是不同的，未捕获的异常不会强制应用程序关闭。可以通过添加一个应用程序配置文件（如`app.config`）来使用此策略，其中包含以下代码片段：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
