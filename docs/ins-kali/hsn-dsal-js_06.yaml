- en: Exploring Types of Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索算法类型
- en: An algorithm in the computer science world is a set of instructions that takes
    finite space and time to execute. It starts at an initial state of the application
    and then performs a set of instructions step by step to achieve the end result.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学世界中，算法是一组指令，它需要有限的空间和时间来执行。它从应用程序的初始状态开始，然后逐步执行一系列指令以达到最终结果。
- en: Algorithms come in all shape and sizes, and all of them will fit the bill when
    you compare it with the overly generic definition of what an algorithm is. The
    big question is to decide which algorithm to use in which case and to make modifications
    to enhance its functionality based on the application's needs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 算法有各种各样的形状和大小，当您将其与算法的过于通用的定义进行比较时，所有这些算法都将符合要求。重要的问题是决定在哪种情况下使用哪种算法，并根据应用程序的需求进行修改以增强其功能。
- en: As I have shown in the use cases in previous chapters, most of the times, the
    algorithms that exist out there do not directly apply to the problems at hand.
    This is when a thorough understanding of the algorithm comes in handy. That is
    exactly what we will be doing in this chapter; we will take a look at a series
    of algorithms and then try to understand them better with the help of some examples.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在前几章的用例中所展示的，大多数时候，那些已经存在的算法并不直接适用于手头的问题。这就是在需要对算法进行深入理解时的用武之地。这正是我们将在本章中要做的；我们将看一系列算法，然后尝试通过一些示例更好地理解它们。
- en: 'In this chapter, we will discuss the following algorithms with some examples:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下算法，并陦有一些示例：
- en: Recursion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Dijkstra
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迪杰斯特拉
- en: Breadth First Search (BFS)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广度优先搜索（BFS）
- en: Dynamic Programming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态规划
- en: Greedy Algorithm
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 贪婪算法
- en: Branch And Bound
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支和界限
- en: Let's set up a bare-bones Node.js project before we start looking at the use
    cases.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始查看用例之前，让我们先建立一个简单的Node.js项目。
- en: Creating a Node.js application
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Node.js应用程序
- en: For this chapter, we will use a very simple and light Node.js application, which
    will be holding our example scripts. The main goal here is to be able to run each
    of the use cases individually and not have an entire web (client or server) application
    for each of them. This helps us to have a uniform base project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个非常简单和轻量的Node.js应用程序，它将保存我们的示例脚本。这里的主要目标是能够单独运行每个用例，而不是为每个用例都有一个完整的Web（客户端或服务器）应用程序。这有助于我们拥有一个统一的基础项目。
- en: 'The first step is to create your application''s project folder. From the Terminal,
    run the following command:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是创建应用程序的项目文件夹。从终端运行以下命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, to initialize a Node.js project, run the `init` command in the `root`
    folder of the project. This will prompt a series of questions to generate the `package.json`file.
    You can fill out the answers you wish or just click on returnto accept default
    values for the prompts:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，要初始化一个Node.js项目，请在项目的`root`文件夹中运行`init`命令。这将提示一系列问题以生成`package.json`文件。您可以填写您希望的答案，或者只需点击`return`接受提示的默认值：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s also install our beloved `lodash` to help us out with some of the trivial
    array and object manipulations and utilities:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也安装我们心爱的`lodash`，以帮助我们处理一些琐碎的数组和对象操作和实用程序：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Use cases
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: Once your project is ready to go, we can now add the necessary scripts in the
    project's root and then run them independently.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的项目准备就绪，我们现在可以在项目的根目录中添加必要的脚本，然后独立运行它们。
- en: Using recursion to serialize data
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用递归来序列化数据
- en: Recursion is a very popular **programming paradigm** in which a problem statement
    can be broken down into several smaller problems, which can be defined in terms
    of itself. Recursion is usually confused with **divide and concur**,in which the
    problem statement is broken into non-overlapping sub-problems which can be solved
    simultaneously.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种非常流行的**编程范式**，其中问题陈述可以被分解成几个较小的问题，这些问题可以用自身来定义。递归通常与**分而治之**混淆在一起，其中问题陈述被分解成不重叠的子问题，可以同时解决。
- en: In the following section, we will take a simple tree in which we have a root
    element followed by some child elements. We will be serializing this tree data,
    which can then be easily sent to the UI or persisted in the database.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将采用一个简单的树结构，其中有一个根元素，后面跟着一些子元素。我们将对这棵树的数据进行序列化，然后可以轻松地将其发送到UI或持久化在数据库中。
- en: Let's first create a folder called `recursion` within our project, which we
    created based on the preceding section. Then, we can create our `serializer.js`
    file within this folder, which will contain the class for serializing tree data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先在我们基于前一节创建的项目中创建一个名为`recursion`的文件夹。然后，我们可以在这个文件夹中创建我们的`serializer.js`文件，其中将包含用于序列化树数据的类。
- en: Pseudocode
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪代码
- en: 'Let''s formulate our algorithm in pseudo code before implementing the recursive
    serializer:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现递归序列化器之前，让我们用伪代码来制定我们的算法：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Serializing data
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化数据
- en: 'Now that we have the pseudo code in place, the code for serialization becomes
    quite simple, let us add the following to a file called `recursion.js` next to
    our serializer:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了伪代码，序列化的代码变得非常简单，让我们将以下内容添加到一个名为`recursion.js`的文件中，放在我们的序列化器旁边：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that in the preceding code we split the problem in terms of itself, that
    we determined what needs to be done for one level and then repeated the process
    for all the nodes **recursively. **Now, to consume this serialization method,
    create a `serialization.js` file and then add the following code to it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码中，我们按照自身的方式分解了问题，确定了一个级别需要做什么，然后递归地为所有节点重复了这个过程。现在，为了使用这种序列化方法，创建一个`serialization.js`文件，然后将以下代码添加到其中：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we run the preceding file with the `node recursion/serializer.js` command from
    the root of the project, we get the serialized response logged onto the console:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从项目的根目录运行上述文件时，使用`node recursion/serializer.js`命令，我们会在控制台上得到序列化的响应日志：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From the preceding response, you can note that the depth-first approach can
    be seen quite visibly based on our input dataset. `B` is a child of `A`, and `E`
    is a leaf child of `B` (indicated by the `^` symbol following `E`). Deserializing
    this serialized data using recursive is also a simple process, which you can try
    on your own.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的响应中，您可以注意到基于我们的输入数据集，深度优先方法可以很清楚地看到。`B`是`A`的子节点，`E`是`B`的叶子节点（在`E`后面的`^`符号表示）。使用递归来反序列化这个序列化的数据也是一个简单的过程，您可以自己尝试一下。
- en: Using Dijkstra to determine the shortest path
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Dijkstra确定最短路径
- en: Until the preceding chapter, we explored only the simple ways of graph traversal, **Breadth
    First Search** (**BFS**) and **Depth First Search** (**DFS**). We did discuss
    in brief in the preceding chapter about Dijkstra and how it can help us determine
    the path from node **A** to node **B** in a graph, provided the graph is directed
    with weighted edges.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们只探讨了图遍历的简单方法，**广度优先搜索**（**BFS**）和**深度优先搜索**（**DFS**）。在前一章中，我们简要讨论了Dijkstra以及它如何帮助我们确定图中从节点**A**到节点**B**的路径，前提是图是有向的，带有加权边。
- en: 'In this example, we have just that. We have a graph of nodes (cities) and edges
    (approximate distance in miles), and we need to determine the fastest path for
    a user to reach a destination node from a given start node, provided other factors,
    such as speed, traffic, and weather, remain constant:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们就是这样。我们有一个节点（城市）和边（大约的距离）的图，我们需要确定用户从给定的起始节点到达目的节点的最快路径，前提是其他因素，如速度、交通和天气保持不变：
- en: '![](assets/abe94949-c722-4241-8575-b60cdde8783b.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/abe94949-c722-4241-8575-b60cdde8783b.png)'
- en: 'Our trip starts from **San Francisco** (**SF**) and ends in **Phoenix** (**PX**).
    We have identified some intermediate cities in which the user can stop for rest
    or gas: **Monterey** (**MT**), **San Jose** (**SJ**), **Santa Barbara** (**SB**),
    **Los Angeles** (**LA**), **San Diego** (**SD**), **Fresno** (**FR**), **Bakersfield**
    (**BK**), and **Las Vegas** (**LV**). The distance to each of these cities is
    indicated by the weights that are associated with each of the edges between the
    cities.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的行程从**旧金山**（**SF**）开始，到**凤凰城**（**PX**）结束。我们已经确定了一些中间城市，用户可以在那里停下来休息或加油：**蒙特利**（**MT**）、**圣何塞**（**SJ**）、**圣巴巴拉**（**SB**）、**洛杉矶**（**LA**）、**圣迭戈**（**SD**）、**弗雷斯诺**（**FR**）、**贝克斯菲尔德**（**BK**）和**拉斯维加斯**（**LV**）。到达每个城市的距离由每个城市之间的边关联的权重表示。
- en: Pseudo code
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪代码
- en: 'Let''s take a look at the pseudo code for implementing Dijkstra''s algorithm:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下实现Dijkstra算法的伪代码：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Implementing Dijkstra's algorithm
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Dijkstra算法
- en: 'Let''s break down the implementation of Dijkstra''s algorithm based on the
    pseudo code described in the preceding section. The first step is to initialize
    all the variables. We will use one to track the costs of going through each node,
    one for tracking the path we are taking, and one more to track the already visited
    nodes to avoid recalculations:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们根据前一节描述的伪代码来分解Dijkstra算法的实现。第一步是初始化所有变量。我们将使用一个变量来跟踪通过每个节点的成本，一个用于跟踪我们所采取的路径，还有一个用于跟踪已经访问的节点，以避免重新计算：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Our `solve()` method here has initialized the `costs` with the `cost` of the
    start node, and then set the end nodes `cost` as `Infinity` as that is not calculated
    yet. This means that at the beginning, the `costs` `set` would contain exactly
    the same data as the nodes and edges, going out from the start node.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`solve()`方法在这里已经用起始节点的`成本`初始化了`costs`，然后将终点节点的`成本`设置为`Infinity`，因为还没有计算。这意味着在开始时，`costs`
    `set`将包含与从起始节点出发的节点和边完全相同的数据。
- en: 'We also calculated the paths accordingly, for example, since we are starting
    with `SF` in our example, the nodes—`SJ`, `MT`, and `SB`—were all reached from
    node `SF`. Following code explains how we can extract the lowest cost at each
    node:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还相应地计算了路径，例如，由于在我们的示例中从“SF”开始，节点“SJ”、“MT”和“SB”都是从节点“SF”到达的。以下代码解释了如何在每个节点提取最低成本：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is probably the most important part of the code; we are calculating the
    `currentCheapestNode` based on the `costs` and the `visitedNodes` array, whose
    value in the first iteration will be `SJ`, as we can see from our preceding diagram.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是代码中最重要的部分；我们根据`costs`和`visitedNodes`数组计算了`currentCheapestNode`，在第一次迭代中，它的值将是`SJ`，正如我们从前面的图中可以看到的。
- en: 'Once we have the first node, we can then access its neighbors and update the
    `costs` of reaching these neighbors only if its `costs` are less than the current
    `cost` of the node. Also, if the cost is lesser, it is only logical that we would
    like to pass through this node to get to the end node, so we update the path to
    this neighbor as well. We then recursively repeat this process after marking the
    visited nodes. At the end of all iterations, we will have the updated costs of
    all the nodes and thus get the final cost of traveling to a node:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了第一个节点，我们就可以访问它的邻居，并且只有在到达这些邻居的“成本”小于当前节点的“成本”时，我们才会更新到达这些邻居的“成本”。此外，如果成本更低，那么我们很可能会通过这个节点到达终点节点，因此我们也会更新到这个邻居的路径。然后在标记访问过的节点后，我们递归重复这个过程。在所有迭代结束时，我们将得到所有节点的更新成本，从而得到到达节点的最终成本：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once all the nodes' `costs` are generated, we will simply backtrack the steps
    which were taken to reach the end node, and we can return the cost of the end
    node and the path taken to reach the end node. The Utility method to get the lowest
    cost unvisited node is added at the end.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了所有节点的“成本”，我们将简单地回溯到达终点节点所采取的步骤，然后我们可以返回终点节点的成本和到达终点节点的路径。在最后添加了一个获取未访问节点最低成本的实用方法。
- en: 'Now, to consume this class, we can create a file called `shortest-path.js`
    under the `dijkstra` folder along with the `dijkstra.js` class that we just created:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要使用这个类，我们可以在“dijkstra”文件夹下创建一个名为“shortest-path.js”的文件，以及刚刚创建的“dijkstra.js”类：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, to run this file, simply run the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要运行这个文件，只需运行以下命令：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding command logs the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令记录了以下代码：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This, when visualized based on the original illustration, would be something
    like as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 基于原始插图的可视化如下：
- en: '![](assets/123c2c77-d526-47da-afb3-c71e80586f43.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/123c2c77-d526-47da-afb3-c71e80586f43.png)'
- en: Using BFS to determine relationships
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BFS确定关系
- en: Okay, it's not what it sounds like. We are not heading down a romantic path
    where we ask each other the difficult question. We are, however, talking about
    a simple graph, for example, a family tree (yes, trees are forms of the graph).
    In this example, we will use BFS to determine the shortest path between two nodes,
    which can then establish the relationship between those two nodes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这不是听起来的样子。我们不是在走一条浪漫的道路，彼此问难题。然而，我们正在谈论一个简单的图，例如，一个家谱（是的，树是图的形式）。在这个例子中，我们将使用BFS来确定两个节点之间的最短路径，然后可以建立这两个节点之间的关系。
- en: 'Let''s first set up our test data so that we have the input graph ready:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先设置我们的测试数据，以便我们有准备好的输入图：
- en: '![](assets/1112a6c8-816d-40ac-a461-0a3782262a2d.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1112a6c8-816d-40ac-a461-0a3782262a2d.png)'
- en: You can note from the preceding diagram that we have a small family in which
    nodes `A`, `E`, and `F` are siblings. `A` is married to `B` with nodes `C` and `D`
    as their children. Node `G` is a child of node `F`. Nothing complex or out of
    the ordinary here. We will use this data to determine the relationship between
    nodes `C` and `G`. You can surely look at the graph and tell it yourself, but
    that's not fun now, is it?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从前面的图中注意到，我们有一个小家庭，其中节点`A`，`E`和`F`是兄弟姐妹。 `A`与`B`结婚，节点`C`和`D`是他们的孩子。节点`G`是节点`F`的孩子。这里没有复杂或不寻常的地方。我们将使用这些数据来确定节点`C`和`G`之间的关系。您肯定可以看一下图表并自己判断，但现在这样做并不有趣，对吧？
- en: 'Let''s now convert this into a format that our program can understand:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将其转换为我们的程序可以理解的格式：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That got complex real quick, didn't it? This is a challenge with nodes where
    you want to establish a relationship (that is, labeled edges). Let's add this
    data to the `family.json` file and then take a look at the pseudo code for the
    BFS so that we can understand it better before implementing the same.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这很快变得复杂了，不是吗？这是节点的一个挑战，您想建立关系（即有标签的边）。让我们将这些数据添加到`family.json`文件中，然后再看一下BFS的伪代码，以便在实现之前更好地理解它。
- en: Pseudo code
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪代码
- en: 'The pseudo code for BFS is very similar to DFS, the main difference is that
    in BFS we iterate over all the connected nodes first before moving out to another
    level looking for our target node:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: BFS的伪代码与DFS非常相似，主要区别在于BFS在移动到另一个级别寻找目标节点之前，我们首先迭代所有连接的节点：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Sounds very similar to the other example we worked on with DFS, doesn't it?
    That is because DFS and BFS are very similar in terms of how we approach the problem.
    The minor difference between the two is that we evaluate all connected nodes before
    spreading out one more level in BFS, whereas we select one of the connected nodes in
    case of DFS and then traverse it till the entire depth.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来与我们之前使用DFS处理的另一个示例非常相似，不是吗？这是因为DFS和BFS在解决问题的方式上非常相似。两者之间的微小区别在于，在BFS中，我们在扩展到另一个级别之前首先评估所有连接的节点，而在DFS的情况下，我们选择一个连接的节点，然后遍历它直到整个深度。
- en: Implementing BFS
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施BFS
- en: 'To implement the previously discussed pseudo code, we will first simplify our
    data a little bit. There are two ways to do this, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现先前讨论的伪代码，我们将首先简化我们的数据。有两种方法可以做到这一点，如下所示：
- en: Create an adjacency matrix of the graph data that indicates the graph as a two-dimensional
    array of size *m x m*, which consists of 1s and 0s. *1s* indicates a connection
    between the *mrow* node with *mcolumn* and *0s* indicates no connection.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建图数据的邻接矩阵，指示图作为大小为*m x m*的二维数组，其中包含1和0。 *1*表示*mrow*节点与*mcolumn*之间的连接，*0*表示没有连接。
- en: We simplify the dataset and only extract the nodes as a map in which the key
    is the node and the value is the list of nodes that it is connected to.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们简化数据集，只提取节点作为一个映射，其中键是节点，值是它连接到的节点列表。
- en: Although both approaches are fine ways of approaching the problem, the first
    option is usually preferred and is popular because the second option is of a higher
    code complexity because of all the overhead of sets and lists which come with
    it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两种方法都是解决问题的好方法，但通常更喜欢第一种选项，因为第二种选项由于所有附带的集合和列表的开销而具有更高的代码复杂性。
- en: However, right now, we don't need to worry about code complexity as we want
    to get the simplest possible solution out there, so we will go with the second
    option.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们不需要担心代码复杂性，因为我们想要得到可能的最简单的解决方案，所以我们将选择第二个选项。
- en: 'First, we will simplify the input data so that we have the transformed input
    to pass into the BFS algorithm that we are going to create:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将简化输入数据，以便将转换后的输入传递到我们将创建的BFS算法中：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This basically sets the `transformedFamilyNodes` to the structure, which is
    described earlier, and in our case, it looks as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上将`transformedFamilyNodes`设置为前面描述的结构，在我们的情况下，它看起来如下：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we create the class for our BFS search and then add a method to implement
    the search functionality:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建我们的BFS搜索类，然后添加一个方法来实现搜索功能：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We accept the list of the original family nodes in the constructor and then
    the modified graph within our search method, which we will iterate upon. Then,
    why would we need the original family nodes? Because once we extract the path
    from one node to another, we will need to establish the relationship between them,
    which is recorded on the original unprocessed family nodes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构造函数中接受原始家庭节点的列表，然后在我们的搜索方法中接受修改后的图，我们将对其进行迭代。那么，为什么我们需要原始家庭节点？因为一旦我们从一个节点提取路径到另一个节点，我们将需要建立它们之间的关系，这是记录在原始未处理的家庭节点上的。
- en: 'We will move on to implement the `search()` method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续实现`search()`方法：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This was quick and painless. If you have noted, we are calling the `getRelationBetweenNodes`,
    which extracts the relations between the nodes based on the `familyNodes`, which
    are passed into the constructor once the path between two nodes is determined.
    This will extract the relationship of each node with the node that follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很快而且没有痛苦。如果您注意到，我们正在调用`getRelationBetweenNodes`，它会根据传入构造函数的`familyNodes`提取节点之间的关系，一旦确定了两个节点之间的路径。这将提取每个节点与其后继节点的关系：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now that we have the class ready, we are ready to invoke this by calling `node
    bfs/relations.js`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的类已经准备好了，我们可以通过调用`node bfs/relations.js`来调用它：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code logs the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码记录了以下内容：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This can be represented visually as follows, based on the initial illustration:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 根据初始示例，这可以用以下方式进行可视化表示：
- en: '![](assets/8b31bd8e-9e12-41f3-8f0a-7b702782be69.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8b31bd8e-9e12-41f3-8f0a-7b702782be69.png)'
- en: Using dynamic programming to build a financial planner
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态规划来构建财务规划师
- en: '**Dynamic programming** (**DP**) is a very common and powerful approach to
    solve a certain class of problems. These problems present themselves in ways in
    which the main problem can be divided into sub-problems and the sub-problems can
    be broken down further into smaller problems, with some overlap in between.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态规划**（**DP**）是解决某一类问题的一种非常常见和强大的方法。这些问题以主要问题可以分解为子问题，子问题可以进一步分解为更小的问题，并且它们之间存在一些重叠的方式呈现。'
- en: 'DP is often confused with recursion because of their similarities. A DP problem
    is only a type of problem, whereas recursion is part of the solution to such problems.
    There are two main ways in which we can approach solving such problems:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: DP经常因为与递归的相似性而被混淆。DP问题只是一种问题类型，而递归是解决这类问题的一部分。我们可以通过两种主要方式来解决这类问题：
- en: 'Break the problem down to sub-problems: If a sub-problem is solved already
    then return the saved solution, else solve and save the solution before returning
    it. This is also known as **memoization**. This is also known as a top-down approach.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将问题分解为子问题：如果子问题已经解决，则返回保存的解决方案，否则解决并保存解决方案，然后返回。这也被称为**记忆化**。这也被称为自顶向下的方法。
- en: 'Break the problem to sub-problems: Start solving the smallest sub-problem and
    work up. This approach is known as **bottom-up** approach.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将问题分解为子问题：开始解决最小的子问题，然后逐步解决更大的问题。这种方法被称为**自底向上**方法。
- en: 'In this example, we have a series of expenses that a user has; we will need
    to provide the user with all the possible outcomes based on a total, which is
    set by the user. We want the users to be able to pick and choose what option they
    like, thus we will go with the bottom-up approach. First, let''s break down the
    input data and then deduce the code from the pseudo code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一系列用户的开销；我们需要根据用户设定的总数为用户提供所有可能的结果。我们希望用户能够自由选择他们喜欢的选项，因此我们将采用自底向上的方法。首先，让我们分解输入数据，然后从伪代码中推导出代码：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can note from the preceding code that the sample input data has been normalized
    for simplicity and code efficiency. Once we have that setup, we can create our
    pseudo code to understand the algorithm.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从前面的代码中注意到，样本输入数据已经被规范化，以便简化和提高代码效率。一旦我们设置好了，我们就可以创建我们的伪代码来理解算法。
- en: Pseudo code
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪代码
- en: 'In this example, for this type of problem, we will be creating a two-dimensional
    array, where one dimension, (y), represents the values of the elements (that is,
    costs of each expense: 5, 3, 2, 2, and 5) and the other dimension, (x), represents
    the total cost incrementally (that is, 0 through 10). This is why we normalize
    our data in the first step—it helps us in terms of keeping our array small in
    terms of its dimensions.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，对于这种类型的问题，我们将创建一个二维数组，其中一个维度（y）表示元素的值（即每个开销的成本：5、3、2、2和5），另一个维度（x）表示总成本的增量（即0到10）。这就是为什么我们在第一步中规范化我们的数据——它有助于我们在维度方面保持数组的小型化。
- en: 'Once we have the array, we will assign each of the array positions—`arr[i][j]`—as
    true if any of the `0 to i` costs can create the `j` sum at any point, else it
    will be false:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了数组，我们将为数组的每个位置`arr[i][j]`分配一个true，如果`0到i`的任何费用可以在任何时候创建`j`的总和，否则为false：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note in the preceding code that the algorithm is quite straightforward; we just
    break down the problem into smaller sub-problems and try to answer the question
    for each sub-problem while working its way up to the bigger problem. Once we are
    done constructing the array, we start from the last cell of the array and then
    traverse up and add a cell to the path taken, based on whether the current cell
    is true or not. The recursive process is stopped once we reach the total of `0`,
    that is, the first column.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在前面的代码中，算法非常简单；我们只是将问题分解为更小的子问题，并尝试回答每个子问题的问题，同时向更大的问题迈进。一旦我们构建好数组，我们就从数组的最后一个单元格开始，然后向上遍历并根据当前单元格是否为true，将一个单元格添加到所采取的路径上。一旦我们达到总数为`0`，也就是第一列时，递归过程就停止了。
- en: Implementing the dynamic programming algorithm
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施动态规划算法
- en: Now that we understand the approach, let's first create the class for our algorithm
    and add the `analyze()` method, which will first create the 2D array before generating
    the algorithm.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了这种方法，让我们首先为我们的算法创建类，并添加`analyze()`方法，该方法将在生成算法之前首先创建2D数组。
- en: 'When the class is initialized, we will construct our 2D array with all the
    values in it set to `false`. We will then use this 2D array and update some of
    the values within it based on our conditions, which we will discuss shortly:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当类被初始化时，我们将构建一个2D数组，其中所有的值都设置为`false`。然后我们将使用这个2D数组，并根据我们的条件更新其中的一些值，我们将很快讨论这些条件：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we can implement the `analyze()` method, which will set the appropriate
    values in each of the cells of the 2D array.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现`analyze()`方法，该方法将在2D数组的每个单元格中设置适当的值。
- en: 'First, we will set the values of the first column, and then of the first row:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将设置第一列的值，然后是第一行的值：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Although the first column is all true, a cell of the first row, on the other
    hand, is only true when the cost associated with that row is less than the sum,
    that is, we can build the requested sum with only one element. Next, we take the
    row and column that has been filled out and use that to build the rest of the
    array:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然第一列都是true，但是第一行的一个单元格只有在与该行相关的成本小于总和时才为true，也就是说，我们可以只用一个元素构建所请求的总和。接下来，我们取出已填写的行和列，用它们来构建数组的其余部分：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we can implement the `generateOutcomes()` method, which will allow us
    to capture the possible paths recursively. When we list down our 2D array and
    take a look at what the generated array looks as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以实现`generateOutcomes()`方法，这将允许我们递归地捕获可能的路径。当我们列出我们的二维数组并查看生成的数组的外观时，如下所示：
- en: '![](assets/6e297533-3d83-4957-ae0c-38525e7b20c5.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6e297533-3d83-4957-ae0c-38525e7b20c5.png)'
- en: You can see in the preceding screenshot that the column `0` (i.e. sum `0`) is
    all `true`, and for row `0` (cost `5`), the only other column in which all the
    values are true is column 5 (i.e. sum `5`).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在上面的屏幕截图中看到，列`0`（即总和`0`）都是`true`，对于行`0`（成本`5`），唯一的其他所有值都为true的列是列5（即总和`5`）。
- en: Now, moving on to the next row, let's analyze the values one by one, for example,
    at that stage, the costs `5` and `3` (taken from the cost of the current row and
    the row above it) cannot add up to give a cost of `1` or `2` but it can give `3`,
    `5`, and `8`, so only they are `true` and the rest are `false`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续下一行，让我们逐个分析值，例如，在这个阶段，来自当前行和上面一行的成本`5`和`3`不能相加得到成本`1`或`2`，但可以得到`3`、`5`和`8`，所以只有它们是`true`，其余都是`false`。
- en: Now, moving on to each of the next rows, we can try to import the value from
    the row above if it is true, if it is not then subtract the current row's cost
    from the column sum and check whether that column for the above row is true. This
    lets us determine whether the sum was determined by an earlier subset.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续到下一行的每个值，我们可以尝试从上面的行导入值，如果为true，则从当前行的成本中减去该列总和，并检查上面一行的该列是否为true。这样我们就可以确定总和是由先前的子集确定的。
- en: For example, in row `3` column `1`, we just import from the parent row (remember
    that column `0` is always `true`). When we reach column `2`, we see that the parent
    rows' col `2` is `false`, so we offset this columns sum (`2`) with the current
    rows cost (`2`) so we end up with row `2` column `0` which is `true.` Hence we
    assign a value of `true` to row `2` column `2`, and then we continue this process
    for the next column till the end.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在第`3`行第`1`列，我们只是从父行导入（记住列`0`始终为`true`）。当我们到达第`2`列时，我们看到父行的列`2`为`false`，所以我们用当前行的成本（`2`）抵消这一列的总和（`2`），所以我们最终得到了第`2`行第`0`列为`true`。因此，我们将值为`true`分配给第`2`行第`2`列，然后我们继续这个过程，直到结束。
- en: 'Once the entire array is constructed, we will need to start at the very end,
    which in this case, is `array[4][10]`, and recursively traverse up until we reach
    the sum of `0` or reach the top with a nonzero sum:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 构建整个数组后，我们需要从最后开始，也就是`array[4][10]`，然后递归向上遍历，直到达到总和`0`或者到达非零总和的顶部：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, this can be consumed in our planner to generate the list of options for
    our users to choose from:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这可以在我们的计划中使用，以生成用户选择的选项列表：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Running the previous code logs the different combinations which fit our budget,
    resulting in:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上面的代码记录符合我们预算的不同组合，结果是：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using a greedy algorithm to build a travel itinerary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用贪婪算法构建旅行行程
- en: A greedy algorithm is one in which a problem is broken down into smaller sub-problems
    and a solution to each of these sub-problems is pieced together based on a locally
    optimized choice at each step. This means that, in case of weighted edge graphs,
    for example, the next node is picked on the basis of whatever provides the least
    cost to travel from the current node. This may not be the best path to take, but,
    in the case of greedy algorithms, getting a solution is the main goal rather than
    getting the perfect or the ideal solution.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪算法是一种将问题分解为较小子问题，并根据每一步的局部优化选择拼凑出每个子问题的解决方案的算法。这意味着，在加权边图的情况下，例如，下一个节点是根据从当前节点出发的最小成本来选择的。这可能不是最佳路径，但是在贪婪算法的情况下，获得解决方案是主要目标，而不是获得完美或理想的解决方案。
- en: In this use case, we have a set of cities along with the weight associated with
    traveling to each of these cities *(cost to travel/stay + enjoyment factor and
    so on)*. The objective is to figure out a way in which we want to travel and visit
    these cities so that the travel is complete and fun. Of course, for a given set
    of cities, you can travel to them in many possible ways, but that does not guarantee
    that the path is going to be optimized. To solve this problem, we will be using
    Kruskal's minimum spanning tree algorithm, which is a type of greedy algorithm
    that will generate the best possible solution for us. A spanning tree in a graph
    is one in which all the nodes are connected and there are no cycles between the
    nodes.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个用例中，我们有一组城市以及前往每个城市的权重（旅行/停留成本+享受因素等）。目标是找出我们想要旅行和访问这些城市的方式，以便旅行是完整和有趣的。当然，对于给定的一组城市，可以以许多可能的方式前往这些城市，但这并不保证路径将被优化。为了解决这个问题，我们将使用Kruskal的最小生成树算法，这是一种贪婪算法，将为我们生成最佳可能的解决方案。图中的生成树是指所有节点都连接在一起，并且节点之间没有循环的图。
- en: 'Let''s assume that our input data is of the following format, which is the
    same as what we have seen earlier in the Dijkstra example, except that we are
    not defining any direction between the nodes, allowing us to travel from either
    direction:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的输入数据格式如下，与我们之前在Dijkstra示例中看到的格式相同，只是我们没有定义节点之间的方向，允许我们从任一方向进行旅行：
- en: '![](assets/da5896ae-c1eb-4e81-9f3a-932850db3b74.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/da5896ae-c1eb-4e81-9f3a-932850db3b74.png)'
- en: 'This data can be programmatically written as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据可以以编程方式写成如下形式：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'From this information, we can extract the unique edges, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些信息中，我们可以提取唯一的边，如下所示：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Understanding spanning trees
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解生成树
- en: Before we go ahead and implement the pseudo code and the code, let's take some
    time to understand what spanning trees are and how we can employ them to simplify
    the problems as stated previously.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续实现伪代码和代码之前，让我们花一些时间了解生成树是什么，以及我们如何利用它们来简化前面提到的问题。
- en: A spanning tree within a graph is a series of edges that can connect all the
    nodes without any cycles within them. By saying that, it is obvious that there
    can be more than one spanning tree for any given graph. In terms of our example,
    it makes more sense now that we want to generate the **minimum spanning tree**
    (**MST**), that is, the spanning tree in which the combined edge weight is the
    minimum.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的生成树是一系列边，可以连接所有节点而不形成任何循环。因此，很明显对于任何给定的图，可能会有多个生成树。在我们的例子中，现在更有意义的是我们想要生成**最小生成树**（**MST**），也就是说，边的总权重最小的生成树。
- en: However, how do we generate the spanning tree and make sure that it has the
    minimum value? The solution, although not quite obvious, is quite simple. Let's
    explore the approach with the pseudo code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们如何生成生成树并确保它具有最小值呢？解决方案虽然不太明显，但相当简单。让我们用伪代码来探讨这个方法。
- en: Pseudo code
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伪代码
- en: 'The problem at hand now has boiled down to the following—connect all the nodes
    of our graph with least weight edges and no cycles. To achieve this, first, we
    will need to isolate all our edges and sort by weight in an increasing order.
    Then, we employ a technique called `union by rank` to get the final list of the
    edges, which can be used to create the MST:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在手头的问题已经归结为以下内容——用最小权重的边连接图的所有节点，且没有循环。为了实现这一点，首先，我们需要分离所有的边，并按权重递增的顺序进行排序。然后，我们使用一种称为`按秩合并`的技术来获得最终的边列表，这些边可以用来创建MST：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `find()` method, we will perform a small optimization called path compression.
    Sounds fancy, but it really isn''t. Let''s say that we are at a node `A` whose
    parent is node `B` and its parent is node `C`. When we are trying to determine
    that, we only parse this entire path once, and for next time, we remember that
    the parent of node `A` is ultimately node `C`. The way we do it is also relatively
    easy—every time we traverse up the tree for a node, we will be updating its `parent`
    property:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`find()`方法中，我们将执行一种称为路径压缩的小优化。听起来很花哨，但实际上并不是。假设我们在一个名为`A`的节点，其父节点是节点`B`，而其父节点是节点`C`。当我们试图确定这一点时，我们只需一次解析整个路径，然后下一次，我们就记住了节点`A`的父节点最终是节点`C`。我们做这件事的方式也相对简单——每次我们遍历树的上一个节点时，我们将更新它的`parent`属性：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Implementing a minimum spanning tree using a greedy algorithm
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用贪婪算法实现最小生成树
- en: 'So far, we have the dataset up as described earlier. Now, we will generate
    the edges from that data and then pass it on to our spanning tree class to generate
    the MST. So let us add the following code to `greeds/travel.js`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经按照前面描述的方式设置了数据集。现在，我们将从这些数据生成边，然后将其传递给我们的生成树类以生成MST。因此，让我们将以下代码添加到`greeds/travel.js`中：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our MST class can be added to `greedy/mst.js` which is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的MST类可以添加到`greedy/mst.js`中，如下所示：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Running the preceding code would log the edges, which will be as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述代码将记录边缘，如下所示：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once connected, these paths will look as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接，这些路径将如下所示：
- en: '![](assets/c9a3e0e6-cf76-4109-b6f3-e6c6b355af4c.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c9a3e0e6-cf76-4109-b6f3-e6c6b355af4c.png)'
- en: Using branch and bound algorithm to create a custom shopping list
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分支和界限算法创建自定义购物清单
- en: The branch and bound algorithm are applied to a set of problems, which involves
    combinational optimization. What that means is that we can have a problem at hand
    that does not necessarily have one correct solution, but with the information
    that we have, we will need to generate the best possible solution out of the finite
    yet very large number of available solutions.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 分支和界限算法适用于一组涉及组合优化的问题。这意味着我们手头可能有一个问题，并不一定有一个正确的解决方案，但根据我们拥有的信息，我们需要从可用解决方案的有限但非常大的数量中生成最佳解决方案。
- en: 'We will be using the branch and bound algorithm to optimize and solve a particular
    class of dynamic programming problems known as the 0/1 knapsack problem. In this
    case, consider that we have a shopping list in which we have a list of items,
    their cost in dollars, and their importance (value) to you on a scale of 0 to
    10\. For example, consider the following sample list:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用分支和界限算法来优化和解决一类称为0/1背包问题的动态规划问题。在这种情况下，考虑我们有一个购物清单，其中列出了物品、它们的成本（以美元计）以及它们对你的重要性（价值）在0到10的范围内。例如，考虑以下示例清单：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Given the list, we now need to find the best possible combination to maximize
    the value, given a fixed budget (for example, $10). The algorithm is called 0/1
    knapsack because the decision that you can take is only a binary, that is, either
    take an item or drop it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 给定清单，我们现在需要找到最佳组合以最大化价值，给定一个固定的预算（例如，10美元）。该算法称为0/1背包，因为你可以做出的决定只有二进制，即，要么拿起一个物品，要么放下它。
- en: 'Now, let''s try to understand what the problem statement is from a mathematical
    standpoint. We want to maximize the value while staying within our budget, so
    if we assume that we have `e[1], e[2], e[3]` and so on up to `e[n]` elements, and
    know that each of these elements can either be picked (which will assign it a
    value of 1) or not picked (which will assign it a value of 0), to determine the
    total value, we can formulate it as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试着从数学的角度理解问题陈述是什么。我们希望在预算范围内最大化价值，因此如果我们假设我们有`e[1], e[2], e[3]`等元素，我们知道每个元素都可以被选择（这将为其分配一个值1）或不选择（这将为其分配一个值0），为了确定总价值，我们可以将其公式化如下：
- en: '![](assets/226735ec-f528-40d7-95b2-bb927ad02550.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/226735ec-f528-40d7-95b2-bb927ad02550.jpg)'
- en: 'While we try to keep the value maximized, we also want to keep the total cost
    less than the budget:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们试图最大化价值，但我们也希望保持总成本低于预算：
- en: '![](assets/099d05c5-9ea6-4a49-90e7-4324ad5763e1.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/099d05c5-9ea6-4a49-90e7-4324ad5763e1.jpg)'
- en: Okay, great, now we know the problem, but what can be the solution for this?
    Since we know that the value is always going to be either 0 or 1, we can create
    a binary tree to represent the state space of our solution and then layout a branch
    for each possibility at every node; for example in our case, we will have *2*^(*n* )possibilities
    (n = 7), which is a total of 128\. Now, going through each of the 128 possibilities
    does not sound very optimal, and we can note that this number is going to increase
    exponentially.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，很好，现在我们知道问题在哪里了，但是对于这个问题有什么解决方案呢？由于我们知道值始终只能是0或1，我们可以创建一个二叉树来表示解的状态空间，然后在每个节点上为每种可能性布置一个分支；例如在我们的情况下，我们将有*2*^(*n*)种可能性（n
    = 7），总共128种。现在，遍历这128种可能性听起来并不是很理想，我们可以注意到这个数字会呈指数增长。
- en: Understanding branch and bound algorithm
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解分支和界限算法
- en: Before writing the pseudo code, let's break down the solution for a better understanding.
    What we want to do is to create a binary tree, and at each level of the tree we
    want to assign the cost to get to the node, the value of the node and the upper
    bound of the cost that it takes to reach to that node.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写伪代码之前，让我们分解解决方案以便更好地理解。我们要做的是创建一个二叉树，在树的每个级别上，我们要为到达该节点的成本、节点的价值和到达该节点的成本的上限分配值。
- en: 'However, how do we calculate the upper bound of the tree? To determine that,
    let''s first break our problem down into smaller parts:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们如何计算树的上限呢？为了确定这一点，让我们首先将我们的问题分解成更小的部分：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once we have that, we will rearrange our elements in the decreasing order of
    our value to cost ratio because we want to pick the elements with the highest
    value for the least cost:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这个，我们将按照价值与成本比的递减顺序重新排列我们的元素，因为我们希望以最小的成本选择价值最高的元素：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To determine the upper bound, we will now use a greedy algorithm (elements arranged
    in a decreasing order) in which we will allow fractional values to get the highest
    possible upper bound.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定上限，我们现在将使用贪婪算法（按递减顺序排列的元素），在其中我们将允许分数值以获得可能的最高上限。
- en: So, let's pick the obvious first element, which has a value of `12` and cost
    of `4`, so the total upper bound of value at this step is `12` and the total cost
    is `4`, which is less than the maximum, that is, `10`. Then, we move on to the
    next element, where the upper bound now becomes *12+6=18* and the cost is *4+2
    = 6* , which is still less than `10`. Then, we pick the next, which brings the
    upper bound of the value to *18+9=27* and the cost to *6+3=9*. If we take the
    next element with a cost of `3`, we will go over the maximum cost, so we will
    take it fractionally, that is, *(remaining cost/cost of the item) * value of the
    item which would be equal to (1/3)*6*, which is `2`. So, the upper bound of the
    root element is *27+2 = 29*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先选择显而易见的第一个元素，其价值为`12`，成本为`4`，因此此步骤的总上限价值为`12`，总成本为`4`，小于最大值，即`10`。然后，我们继续下一个元素，其中上限现在变为*12+6=18*，成本为*4+2=6*，仍然小于`10`。然后，我们选择下一个元素，将价值的上限提高到*18+9=27*，成本为*6+3=9*。如果我们选择成本为`3`的下一个元素，我们将超过最大成本，因此我们将按比例选择它，即*(剩余成本/项目成本)
    * 项目价值*，这将等于(1/3)*6*，即`2`。因此，根元素的上限为*27+2=29*。
- en: So, we can now say that under the given constraints, such as the cost and value,
    the upper bound value which we can get is `29`. Now that we have the upper bound
    on the value, we can create a root element for our binary tree with this upper
    bound value and a cost and value of 0 each.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以说在给定的约束条件下，例如成本和价值，我们可以获得的上限值是`29`。现在我们有了价值的上限，我们可以为我们的二叉树创建一个根元素，该根元素的上限值为此，成本和价值分别为0。
- en: 'Once the root nodes maximum upper bound is calculated, we can repeat this process
    recursively for the subsequent nodes starting from the first node. At each level,
    we will update the cost, value, and upper bound in such a way that it reflects
    what the values would be when a node is picked versus when it is not picked:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦计算出根节点的最大上限，我们可以从第一个节点开始递归地重复这个过程，为后续节点计算。在每个级别上，我们将以反映节点被选择与未被选择时的值的方式更新成本、值和上限：
- en: '![](assets/d8282701-a7f3-4e8e-bc5c-23064eb18a5d.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d8282701-a7f3-4e8e-bc5c-23064eb18a5d.png)'
- en: In the preceding image, you can note that we have built the state space tree
    for a few levels, which show what the state of each of the nodes would be when
    the branch is taken and also when it is not taken. As you can see, few of the
    branches are below the maximum upper bound of **27** (which we calculated earlier),
    whereas one of the branches goes over **27**, so we can remove that branch from
    further consideration. Now, at each of these steps, our main goal is to keep traversing
    the state space while increasing the value accumulated and staying below or equal
    to the upper bound. Any branch that deviates too far or exceeds from the upper
    bound can be safely removed from consideration.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，您可以注意到我们已经为几个级别构建了状态空间树，显示了当采取分支和不采取分支时每个节点的状态。正如您所看到的，其中一些分支低于我们之前计算的最大上限**27**，而其中一个分支超过了**27**，因此我们可以将该分支从进一步考虑中移除。现在，在每个步骤中，我们的主要目标是在增加累积值的同时保持在上限以下或等于上限。任何偏离太远或超过上限的分支都可以安全地从考虑中移除。
- en: Implementing branch and bound algorithm
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施分支和界限算法
- en: So far, we have discussed how we can construct the state space tree step by
    step for each of the elements that are available, but that is not necessary, we
    only need to add the nodes selectively based on our bounds and the maximum cost
    that has been set.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何逐步为每个可用元素构建状态空间树，但这并不是必要的，我们只需要根据我们的界限和已设置的最大成本有选择地添加节点。
- en: So, what does that mean for us in implementation? We will take nodes one by
    one, consider what would happen if we include it or if we do not, and then add
    it to the queue for further processing if it falls under the conditions (bounds)
    that are set by us (maximum overall cost and the maximum upper bound of each branch).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，对我们的实施意味着什么？我们将逐个节点地考虑，考虑如果包括它或者不包括它会发生什么，然后根据我们设置的条件（上限）将其添加到队列中以供进一步处理。
- en: 'Since we already have a list of items with us, we will first do some transformations
    to make the rest of the algorithm simpler:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一系列项目，我们将首先进行一些转换，以使算法的其余部分更简单：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Once we have the costs and the values sorted and extracted, we can then implement
    the algorithm to calculate the maximum value at each with, and without, the current
    node:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了成本和值排序并提取出来，我们就可以实现算法来计算每个节点的最大值，以及当前节点的最大上限值，和不包括当前节点的情况：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'On running the same algorithm, we get the results with the maximum value returned
    to us:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运行相同的算法，我们得到了返回给我们的最大值的结果：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This logs the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这记录如下：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When not to use brute-force algorithm
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时不使用蛮力算法
- en: Brute-force algorithm is a type of problem-solving technique in which every
    possible solution to a particular problem is explored before either selecting
    or rejecting one of the solutions as the final solution to the problem.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 蛮力算法是一种问题解决技术，它在选择或拒绝问题的最终解决方案之前，探索特定问题的每种可能的解决方案。
- en: When posed with a challenge, the most natural reaction is to brute-force the
    solution or try to brute-force it first and then optimize it later. However, is
    that really the best way to approach such problems? Are there better ways of doing
    things?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 面对挑战时，最自然的反应是蛮力解决方案，或者首先尝试蛮力解决方案，然后再进行优化。然而，这真的是解决这类问题的最佳方式吗？有更好的方法吗？
- en: The answer is most definitely yes, as we have seen very well in the entire chapter
    so far. brute-force is not the solution until it is the only solution. Sometimes,
    we may feel that we are creating a custom algorithm to find the solution to our
    given problem, but we need to ask ourselves if we are really going through all
    the possible solutions to the problem, if we are, then that's brute-force again.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 答案绝对是肯定的，因为到目前为止我们在整个章节中已经看到了。蛮力不是解决方案，直到它是唯一的解决方案。有时，我们可能会觉得我们正在创建一个自定义算法来解决我们所面临的问题，但我们需要问自己是否我们真的正在尝试找到问题的所有可能解决方案，如果是的话，那么这又是蛮力。
- en: Unfortunately, brute-force is not one fixed algorithm for us to detect it. The
    approach keeps changing with the problem statements, hence the need to see if
    we are trying to generate all solutions and avoid doing that.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，蛮力不是一个固定的算法供我们检测。方法随着问题陈述而改变，因此需要查看我们是否试图生成所有解决方案并避免这样做。
- en: However, you may ask, how do I know when to brute-force a problem and when should
    I try to find an optimal solution? How do I know a more optimal solution or algorithm
    exists for such a problem?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会问，我如何知道何时蛮力解决一个问题，何时应该尝试找到最优解？我如何知道更优解或算法是否存在？
- en: There is no quick and dirty way to tell if there are easier solutions than brute-force
    to calculate any solutions. For example, a problem can be solved in a brute-force
    manner, take any of the examples in this chapter, for instance. We can come up
    with a list of all possibilities (however hard it may be to generate this list,
    as a large number of them may exist) and then shortlist the ones that we deem
    as solutions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 没有快速简单的方法来判断是否有比蛮力更容易的解决方案来计算任何解决方案。例如，一个问题可以以蛮力方式解决，例如，本章中的任何一个例子。我们可以列出所有可能性（无论生成这个列表有多困难，因为可能存在大量的可能性），然后筛选出我们认为是解决方案的那些。
- en: In our example to generate the shortest path, we used Dijkstra's algorithm to
    use the cost associated with traveling to each city. A brute-force solution of
    this would be to calculate all the paths available in the graph from start to
    end nodes and then calculate the cost of each of the paths and then ultimately
    select the path with the lowest cost.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们生成最短路径的示例中，我们使用Dijkstra算法来使用与到达每个城市相关的成本。这个问题的蛮力解决方案是计算从起点到终点节点的图中所有可用路径，然后计算每条路径的成本，最终选择成本最低的路径。
- en: Knowing about the problem statement can greatly help with reducing the complexity
    of problems and also help us avoid brute-force solutions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 了解问题陈述可以极大地帮助减少问题的复杂性，也可以帮助我们避免蛮力解决方案。
- en: Brute-force Fibonacci generator
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蛮力斐波那契生成器
- en: 'Let''s take a Fibonacci generator, for example, and brute-force the generation
    of some numbers:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们以斐波那契生成器为例，蛮力生成一些数字：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we can see that we are not applying any domain knowledge; we simply take
    the two previous numbers from the series and add them. This is a fine way of doing
    it, but we can see that there are some improvements to be made here.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们没有应用任何领域知识；我们只是从系列中取出前两个数字并相加。这是一个很好的方法，但我们可以看到这里有一些改进的空间。
- en: Recursive Fibonacci generator
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归斐波那契生成器
- en: 'We can use recursion to generate Fibonacci series as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用递归生成斐波那契数列如下：
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can see that we apply the same concept as earlier, that the next number
    is a summation of the two previous numbers of the Fibonacci series numbers. However,
    we are relying on recursion to recalculate all the old values as and when a new
    value is demanded.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们应用了与之前相同的概念，即下一个数字是斐波那契数列数字的前两个数字的总和。然而，我们依赖递归来在需要新值时重新计算所有旧值。
- en: Memoized Fibonacci generator
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化斐波那契生成器
- en: 'We can further enhance the generator using memoization, which is a technique
    of calculating a value only once and remembering it for later:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步增强生成器，使用记忆化，这是一种只计算一次值并记住它以备后用的技术：
- en: '[PRE47]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here, we are relying on an in-memory variable called `memory` to store and retrieve
    the previously calculated value of the Fibonacci number within the series, hence
    avoiding a series of duplicate calculations.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们依赖于一个名为`memory`的内存变量来存储和检索系列中先前计算的斐波那契数的值，从而避免一系列重复计算。
- en: If you log the time taken for each of these methods, you can see that as the
    size of the input number increases, the performance does go down significantly
    for the recursive approach. Just because an algorithm is brute-force, that does
    not mean it is the worst/slowest/costliest. However, with a simple change to recursion(memoization),
    you can see that it is again faster than the brute-force technique.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果记录每种方法所花费的时间，您会发现随着输入数字的大小增加，递归方法的性能确实会显著下降。仅仅因为一个算法是蛮力算法，并不意味着它是最差/最慢/最昂贵的。然而，通过对递归进行简单的改变（记忆化），您会发现它再次比蛮力技术更快。
- en: When trying to code the solution for any problem, the biggest help is to reduce
    unnecessary space and time complexity.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试为任何问题编写解决方案时，最大的帮助是减少不必要的空间和时间复杂度。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered some of the important types of algorithms and implemented
    them for some example use cases. We also discussed various algorithmic optimization
    techniques, such as memoization and backtracking.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了一些重要类型的算法，并为一些示例用例实施了它们。我们还讨论了各种算法优化技术，如记忆化和回溯。
- en: In the next chapter, we will discuss some of the sorting techniques and apply
    them to solve some examples.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一些排序技术，并将它们应用于解决一些示例。
