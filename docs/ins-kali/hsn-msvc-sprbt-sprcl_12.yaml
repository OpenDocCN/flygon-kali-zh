- en: Using Spring Cloud Gateway to Hide Microservices Behind an Edge Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Cloud Gateway隐藏微服务在边缘服务器后面
- en: In this chapter, we will learn how to use Spring Cloud Gateway as an edge server,
    that is, to control what APIs are exposed from our microservices-based system
    landscape. We will see how microservices that have public APIs will be made accessible
    from the outside through the edge server, while microservices that have private
    APIs only will be accessible from the inside of the microservice landscape. In
    our system landscape, this means that the product composite service and the discovery
    service, Netflix Eureka, will be exposed through the edge server. The three core
    services—`product`, `recommendation`, and `review`—will be hidden from the outside.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用Spring Cloud Gateway作为边缘服务器，即控制从基于微服务的系统架构中公开哪些API。我们将看到具有公共API的微服务将通过边缘服务器从外部访问，而仅具有私有API的微服务将从微服务架构的内部访问。在我们的系统架构中，这意味着产品组合服务和发现服务Netflix
    Eureka将通过边缘服务器公开。三个核心服务—`product`、`recommendation`和`review`—将被隐藏在外部。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Adding an edge server to our system landscape
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的系统架构添加边缘服务器
- en: Setting up a Spring Cloud Gateway, including configuring routing rules
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Spring Cloud Gateway，包括配置路由规则
- en: Trying out the edge server
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试边缘服务器
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All commands described in this book are run on a MacBook Pro using macOS Mojave,
    but should be straightforward to modify in order to run on another platform such
    as Linux or Windows.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都是在使用macOS Mojave的MacBook Pro上运行的，但应该很容易修改以在其他平台（如Linux或Windows）上运行。
- en: No new tools need to be installed in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章无需安装新工具。
- en: The source code for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter10).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter10)。
- en: 'To be able to run the commands as described in this book, download the source
    code to a folder and set up an environment variable, `$BOOK_HOME`, that points
    to that folder. The following are sample commands:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够按照本书中描述的命令运行命令，请将源代码下载到一个文件夹并设置一个环境变量`$BOOK_HOME`，指向该文件夹。以下是示例命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1.0, SR1 (also known as the **Greenwich** release), Spring
    Boot 2.1.3, and Spring 5.1.5, which is the latest available version of the Spring
    components at the time of writing this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并在Java 12上进行了测试。本章使用Spring Cloud 2.1.0，SR1（也称为**Greenwich**发布），Spring
    Boot 2.1.3和Spring 5.1.5，这是撰写本章时可用的Spring组件的最新版本。
- en: 'The source code contains the following Gradle projects:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含以下Gradle项目：
- en: '`api`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api`'
- en: '`util`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`util`'
- en: '`microservices/product-service`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-service`'
- en: '`microservices/review-service`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/review-service`'
- en: '`microservices/recommendation-service`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/recommendation-service`'
- en: '`microservices/product-composite-service`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`microservices/product-composite-service`'
- en: '`spring-cloud/eureka-server`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/eureka-server`'
- en: '`spring-cloud/gateway`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/gateway`'
- en: The code examples in this chapter all come from source code in `$BOOK_HOME/Chapter10` but
    are, in several cases, edited to remove non-relevant parts of the source code,
    such as comments, and import and log statements.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例都来自`$BOOK_HOME/Chapter10`中的源代码，但在几种情况下进行了编辑，以删除源代码的非相关部分，如注释、导入和日志语句。
- en: If you want to see the changes applied to the source code in [Chapter 10](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml), *Using
    Spring Cloud Gateway to Hide Microservices Behind an Edge Server*, that is, see what
    it took to add Spring Cloud Gateway as an edge server to the microservices landscape, you
    can compare it with the source code for [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml),
    *Adding Service Discovery Using Netflix Eureka and Ribbon*. You can use your favorite `diff` tool
    and compare the two folders, `$BOOK_HOME/Chapter09` and `$BOOK_HOME/Chapter10`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看应用于[第10章](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml)源代码的更改，即查看将Spring
    Cloud Gateway添加为微服务架构的边缘服务器所需的内容，您可以将其与[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)的源代码进行比较，即*使用Netflix
    Eureka和Ribbon添加服务发现*。您可以使用您喜欢的`diff`工具比较两个文件夹`$BOOK_HOME/Chapter09`和`$BOOK_HOME/Chapter10`。
- en: Adding an edge server to our system landscape
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的系统架构添加边缘服务器
- en: 'In this section we will see how the edge server is added to the system landscape
    and how it affects the way external clients access the public APIs that the microservices
    expose. All incoming requests will now be routed through the edge server, as illustrated
    by the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到边缘服务器如何添加到系统架构中，以及它如何影响外部客户端访问微服务公开的公共API的方式。所有传入请求现在将通过边缘服务器路由，如下图所示：
- en: '![](img/3ec7ce9c-d8a1-48bd-a0af-932a2b44ed6b.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3ec7ce9c-d8a1-48bd-a0af-932a2b44ed6b.png)'
- en: As we can see from the preceding diagram, external clients send all their requests
    to the edge server. The edge server can route the incoming requests based on the
    URL path. For example, requests with a URL that starts with `/product-composite/`
    are routed to the **Product Composite** microservice, and a request with a URL
    that starts with `/eureka/` is routed to the **Discovery Server** based on Netflix
    Eureka.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 从上图可以看出，外部客户端将所有请求发送到边缘服务器。边缘服务器可以根据URL路径路由传入的请求。例如，以`/product-composite/`开头的URL请求将路由到**产品组合**微服务，以`/eureka/`开头的URL请求将基于Netflix
    Eureka路由到**发现服务器**。
- en: 'In the previous [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding
    Service Discovery Using Netflix Eureka and Ribbon*, we exposed both the `product-composite`
    service and the discovery service, Netflix Eureka, to the outside. When we introduce
    the edge server in this chapter, this will no longer be the case.  This is implemented
    by removing the following port declarations for the two services in the Docker
    Compose files:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章[第9章]（9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml）中，*使用Netflix Eureka和Ribbon添加服务发现*，我们将`product-composite`服务和发现服务Netflix
    Eureka都暴露给外部。当我们在本章引入边缘服务器时，情况将不再如此。这是通过在Docker Compose文件中删除两个服务的以下端口声明来实现的：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With the edge serve added to the system landscape, we will learn how to set
    up an edge server based on Spring Cloud Gateway in the next section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统架构中添加了边缘服务器后，我们将在下一节中学习如何基于Spring Cloud Gateway设置边缘服务器。
- en: Setting up a Spring Cloud Gateway
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Spring Cloud Gateway
- en: In this section, we will learn how to set up an edge server based on Spring
    Cloud Gateway.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何基于Spring Cloud Gateway设置边缘服务器。
- en: 'Setting up a Spring Cloud Gateway as an edge server is straightforward and
    can be done by means of the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Spring Cloud Gateway作为边缘服务器非常简单，可以通过以下步骤完成：
- en: Create a Spring Boot project using Spring Initializr as described in [Chapter
    3](d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml), *Creating a Set of Cooperating
    Microservices—*refer to the *Using Spring Initializr to generate skeleton code*
    section.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Spring Initializr创建一个Spring Boot项目，如[第3章]（d26f4e61-20bf-4f55-b96d-060c7dd6f20c.xhtml）中所述，*创建一组协作微服务*，请参阅*使用Spring
    Initializr生成骨架代码*部分。
- en: Add a dependency to `spring-cloud-starter-gateway`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加依赖项`spring-cloud-starter-gateway`。
- en: To be able to locate microservices instances though Netflix Eureka, also add
    the `spring-cloud-starter-netflix-eureka-client` dependency.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够通过Netflix Eureka定位微服务实例，还要添加`spring-cloud-starter-netflix-eureka-client`依赖项。
- en: 'Add the edge server to the common build file, `settings.gradle`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将边缘服务器添加到通用构建文件`settings.gradle`中：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Add a Dockerfile with the same content as for our microservices.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个具有与我们的微服务相同内容的Dockerfile。
- en: 'Add the edge server to our three Docker Compose files:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将边缘服务器添加到我们的三个Docker Compose文件中：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Port `8080` of the edge server is exposed outside the Docker engine. The memory
    limit of 350 MB is to ensure that all containers in this and the coming chapters
    will fit in the 6 GB of memory that we have allocated to the Docker engine
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 边缘服务器的端口`8080`暴露在Docker引擎之外。350 MB的内存限制是为了确保在本章和接下来的章节中的所有容器都适合我们分配给Docker引擎的6
    GB内存中。
- en: Add configuration for routing rules and more; refer to the *Configuring a Spring
    Cloud Gateway* section as we proceed in this chapter.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着我们在本章中的进行，为路由规则和更多内容添加配置，请参阅*配置Spring Cloud Gateway*部分。
- en: Since the edge server will handle all incoming traffic, we will move the composite health
    check from the product composite service to the edge server. This is described
    in *Adding a composite health check* section.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于边缘服务器将处理所有传入流量，我们将把复合健康检查从产品复合服务移动到边缘服务器。这在*添加复合健康检查*部分中有描述。
- en: You can find the source code for the Spring Cloud Gateway in `$BOOK_HOME/Chapter10/spring-cloud/gateway`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`$BOOK_HOME/Chapter10/spring-cloud/gateway`中找到Spring Cloud Gateway的源代码。
- en: Adding a composite health check
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加复合健康检查
- en: With an edge server in place, external health check requests also have to go through
    the edge server. Therefore, the composite health check that checks the status
    of all microservices been moved from the `product-composite` service to the edge
    server. See [Chapter 7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing
    Reactive Microservices—*refer to the *Adding a health API* section for implementation
    details of the composite health check.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有了边缘服务器，外部健康检查请求也必须通过边缘服务器。因此，检查所有微服务状态的复合健康检查已从`product-composite`服务移动到了边缘服务器。有关实施细节，请参阅[第7章]（436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml），*开发响应式微服务*，参考*添加健康API*部分。
- en: 'The following has been added to the edge server:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加以下内容到边缘服务器中：
- en: 'The `se.magnus.springcloud.gateway.HealthCheckConfiguration` class has been
    added, which declares the health indicator:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 已添加了`se.magnus.springcloud.gateway.HealthCheckConfiguration`类，声明了健康指示器：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have added the `product-composite` service to the composite health check!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`product-composite`服务添加到了复合健康检查！
- en: 'The main application class, `se.magnus.springcloud.gateway.GatewayApplication`, declares
    a `WebClient.builder` bean to be used by the implementation of the health indicator
    as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主应用程序类`se.magnus.springcloud.gateway.GatewayApplication`声明了一个`WebClient.builder`
    bean，用于实现健康指示器，如下所示：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From the preceding source code, we see that `WebClient.builder` is annotated
    with `@LoadBalanced`, which makes it aware of microservice instances registered
    in the discovery server, Netflix Eureka. Refer to the *Service discovery with
    Netflix Eureka in Spring Cloud* section in [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml),
    *Adding Service Discovery Using Netflix Eureka and Ribbon, *for details.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的源代码中，我们看到`WebClient.builder`带有`@LoadBalanced`注解，这使其能够识别在发现服务器Netflix Eureka中注册的微服务实例。有关详细信息，请参阅[第9章]（9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml）中的*使用Netflix
    Eureka在Spring Cloud中进行服务发现*部分。
- en: With a composite health check in place in the edge server, we are ready to look
    at the configuration that can be set up for a Spring Cloud Gateway.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在边缘服务器中放置了一个复合健康检查，我们准备查看可以为Spring Cloud Gateway设置的配置。
- en: Configuring a Spring Cloud Gateway
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Spring Cloud Gateway
- en: 'When it comes to configuring a Spring Cloud Gateway, the most important thing is setting
    up the routing rules. We also need to set up a few other things in the configuration:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置Spring Cloud Gateway时，最重要的是设置路由规则。我们还需要在配置中设置一些其他内容：
- en: Since Spring Cloud Gateway will use Netflix Eureka to find the microservices
    it will route traffic to, so it must be configured as a Eureka client in the same
    way as described in [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding
    Service Discovery Using Netflix Eureka and Ribbon*—refer to the *Configuration
    of clients to the Eureka server* section.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Spring Cloud Gateway将使用Netflix Eureka查找要将流量路由到的微服务，因此必须像[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)中描述的那样将其配置为Eureka客户端，*使用Netflix
    Eureka和Ribbon添加服务发现*—参考*配置客户端到Eureka服务器*部分。
- en: 'Configure Spring Boot Actuator for development usage as described in [Chapter
    7](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml), *Developing Reactive Microservices—*refer
    to the *Adding a health API* section:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为开发使用配置Spring Boot Actuator，如[第7章](436fb8c1-0c4d-410c-a3ec-da251aba4ca1.xhtml)中所述，*开发响应式微服务*—参考*添加健康API*部分：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Configure log levels so that we can see log messages from interesting parts
    of the internal processing in the Spring Cloud Gateway, for example, how it decides
    where to route incoming requests to:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置日志级别，以便我们可以看到Spring Cloud Gateway内部处理的有趣部分的日志消息，例如，它如何决定将传入请求路由到哪里：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the full source code, refer to the configuration file: `src/main/resources/application.yml`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参阅配置文件：`src/main/resources/application.yml`。
- en: Routing rules
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由规则
- en: Setting up routing rules can be done in two ways; programmatically, using a
    Java DSL, or by configuration. Using the Java DSL to set up the routing rules
    programmatically can be useful in cases where the rules are stored in external
    storage, such as a database, or are given at runtime, for example, via a RESTful
    API or a message sent to the gateway. In most cases, I find it convenient to declare
    the routes in the configuration file, `src/main/resources/application.yml`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设置路由规则可以通过两种方式完成；通过编程方式，使用Java DSL，或者通过配置。在规则存储在外部存储（如数据库）中，或者在运行时通过RESTful
    API或发送给网关的消息等情况下，使用Java DSL来编程设置路由规则可能是有用的。在大多数情况下，我发现在配置文件`src/main/resources/application.yml`中声明路由是方便的。
- en: 'A **route** is defined by the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由**由以下内容定义：'
- en: '**Predicates**, which select a route based on information in the incoming HTTP
    request'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**谓词**，根据传入的HTTP请求中的信息选择路由'
- en: '**Filters**, which can modify both the request and/or the response'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**过滤器**，可以修改请求和/或响应'
- en: A **destination URI**, which describes where to send a request
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**目标URI**，描述发送请求的位置'
- en: An **ID**, that is, the name of the route
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ID**，即路由的名称'
- en: For a full list of available predicates and filters, refer to the reference
    documentation: [https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html](https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可用谓词和过滤器的完整列表，请参阅参考文档：[https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html](https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html)。
- en: Routing requests to the product-composite API
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由请求到product-composite API
- en: 'If we, for example, want to route incoming requests where the URL path starts
    with `/product-composite/` to our `product-composite` service, we can specify
    a routing rule like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要将URL路径以`/product-composite/`开头的传入请求路由到我们的`product-composite`服务，我们可以指定如下的路由规则：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following are some points to take from the preceding code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面的代码中得出的一些要点：
- en: '`id: product-composite`: The name of the route is `product-composite`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id: product-composite`：路由的名称是`product-composite`。'
- en: '`uri: lb://product-composite`: If the route is selected by its predicates,
    the request will be routed to the service that is named `product-composite` in
    the discovery service, that is, Netflix Eureka. `lb://` is used to direct Spring
    Cloud Gateway to use the client-side load balancer to look up the destination
    in the discovery service.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uri: lb://product-composite`：如果路由由其谓词选择，请求将被路由到发现服务中名为`product-composite`的服务，即Netflix
    Eureka。`lb://`用于指示Spring Cloud Gateway使用客户端负载均衡器在发现服务中查找目标。'
- en: '`predicates:- Path=/product-composite/**` is used to specify what requests
    this route should match. `**` matches zero or more elements in the path.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`predicates:- Path=/product-composite/**`用于指定此路由应匹配的请求。`**`匹配路径中的零个或多个元素。'
- en: Routing requests to the Eureka server's API and web page
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由请求到Eureka服务器的API和网页
- en: 'Eureka exposes both an API and a web page for its clients. To provide a clean
    separation between the API and the web page in Eureka, we will set up routes as
    follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Eureka为其客户端公开了API和网页。为了在Eureka中为API和网页提供清晰的分离，我们将设置路由如下：
- en: Requests sent to the edge server with the path starting with `/eureka/api/`
    should be handled as a call to the Eureka API.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到以`/eureka/api/`开头的路径的请求应该被处理为对Eureka API的调用。
- en: Requests sent to the edge server with the path starting with `/eureka/web/`
    should be handled as a call to the Eureka web page.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送到以`/eureka/web/`开头的路径的请求应该被处理为对Eureka网页的调用。
- en: 'API requests will be routed to `http://${app.eureka-server}:8761/eureka`. The
    route rule for the Eureka API looks like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: API请求将被路由到`http://${app.eureka-server}:8761/eureka`。Eureka API的路由规则如下：
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `{segment}` part in the `Path` value matches zero or more elements in the
    path and will be used to replace the `{segment}` part in the `SetPath` value.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Path`值中的`{segment}`部分匹配路径中的零个或多个元素，并将用于替换`SetPath`值中的`{segment}`部分。'
- en: 'Web page requests will be routed to `http://${app.eureka-server}:8761`. The
    web page will load several web resources, such as `.js`, `.css`, and `.png` files.
    These requests will be routed to `http://${app.eureka-server}:8761/eureka`. The
    route rules for the Eureka web page look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 网页请求将被路由到`http://${app.eureka-server}:8761`。网页将加载几个网页资源，如`.js`、`.css`和`.png`文件。这些请求将被路由到`http://${app.eureka-server}:8761/eureka`。Eureka网页的路由规则如下：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From the preceding configuration, we can take the following notes: The `${app.eureka-server}`
    property is resolved by Spring''s property mechanism depending on what Spring
    profile is activated:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的配置中，我们可以得出以下注意事项：根据激活的Spring配置文件，`${app.eureka-server}`属性将由Spring的属性机制解析。
- en: When running the services on the same host without using Docker, for example,
    for debugging purposes, the property will be translated to `localhost` using the
    `default` profile.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不使用Docker在同一主机上运行服务时，例如用于调试目的，该属性将使用`default`配置文件转换为`localhost`。
- en: When running the services as Docker containers, the Netflix Eureka server will
    run in a container with the DNS name `eureka`. Therefore, the property will be
    translated into `eureka` using the `docker` profile.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将服务作为Docker容器运行时，Netflix Eureka服务器将在具有DNS名称`eureka`的容器中运行。因此，该属性将使用`docker`配置文件转换为`eureka`。
- en: 'The relevant parts in the `application.yml` file that defines this translation
    look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 定义此转换的`application.yml`文件中的相关部分如下：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Routing requests with predicates and filters
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用谓词和过滤器进行路由请求
- en: To learn a bit more about the routing capabilities in Spring Cloud Gateway,
    we will try out host-based routing; that is, where Spring Cloud Gateway uses the
    hostname of the incoming request to determine where to route the request. We will
    use one of my favorite websites for testing HTTP codes: [http://httpstat.us/](http://httpstat.us/).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更多地了解Spring Cloud Gateway中的路由能力，我们将尝试基于主机的路由；也就是说，Spring Cloud Gateway使用传入请求的主机名来确定将请求路由到何处。我们将使用我最喜欢的用于测试HTTP代码的网站之一：[http://httpstat.us/](http://httpstat.us/)。
- en: 'A call to `http://httpstat.us/${CODE}` simply returns a response with the `${CODE}`
    HTTP code and a response body containing the HTTP code and a corresponding descriptive
    text. For example, see the following `curl` command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对`http://httpstat.us/${CODE}`的调用只是返回一个带有`${CODE}`HTTP代码和包含HTTP代码及相应描述性文本的响应主体的响应。例如，查看以下`curl`命令：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will return the HTTP code 200, and a response body with the text, 200 OK.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回HTTP代码200，并带有文本“200 OK”的响应主体。
- en: 'Let''s assume that we want to route calls to `http://${hostname}:8080/headerrouting` as
    follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将对`http://${hostname}:8080/headerrouting`的调用路由如下：
- en: Calls to the `i.feel.lucky` host should return 200 OK.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`i.feel.lucky`主机的调用应返回200 OK。
- en: Calls to the `im.a.teapot` host should return `418 I'm a teapot`.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对`im.a.teapot`主机的调用应返回`418 I'm a teapot`。
- en: Calls to all other hostnames should return `501 Not Implemented`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对所有其他主机名的调用应返回`501 Not Implemented`。
- en: 'To implement these routing rules in Spring Cloud Gateway, we can use the `Host` route predicate
    to select requests with specific hostnames, and the `SetPath` filter to set the
    desired HTTP code in the request path. This can be done as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Spring Cloud Gateway中实现这些路由规则，我们可以使用`Host`路由谓词来选择具有特定主机名的请求，并使用`SetPath`过滤器在请求路径中设置所需的HTTP代码。可以按以下方式完成：
- en: 'To make calls to `http://i.feel.lucky:8080/headerrouting` return 200 OK, we
    can set up the following route:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`http://i.feel.lucky:8080/headerrouting`返回200 OK，我们可以设置以下路由：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To make calls to `http://im.a.teapot:8080/headerrouting` return `418 I''m a
    teapot`, we can set up the following route:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使对`http://im.a.teapot:8080/headerrouting`的调用返回`418 I'm a teapot`，我们可以设置以下路由：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, to make calls to all other hostnames return `501 Not Implemented`,
    we can set up the following route:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了使对所有其他主机名的调用返回`501 Not Implemented`，我们可以设置以下路由：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Okay, that was quite a bit of configuration, so now let's try it out!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是相当多的配置，现在让我们试一下！
- en: Trying out the edge server
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试边缘服务器
- en: 'To try out the edge server, we perform the following steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试边缘服务器，我们执行以下步骤：
- en: 'First, build the Docker images with the following commands:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令构建Docker镜像：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在Docker中启动系统景观，并使用以下命令运行常规测试：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Expect output similar to what we have seen in previous chapters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 期望的输出类似于我们在前几章中看到的：
- en: '![](img/fa1b108b-8607-4ced-a8b6-b24fc43ce34d.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa1b108b-8607-4ced-a8b6-b24fc43ce34d.png)'
- en: 'With the system landscape including the edge server, let''s explore the following
    topics:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在包括边缘服务器的系统景观中，让我们探索以下主题：
- en: Examine what is exposed by the edge server outside of the system landscape running
    in the Docker engine.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查边缘服务器在Docker引擎运行的系统景观之外公开了什么。
- en: 'Try out some of the most frequently used routing rules as follows:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试一些最常用的路由规则，如下所示：
- en: Use URL-based routing to call our APIs through the edge server.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于URL的路由通过边缘服务器调用我们的API。
- en: Use URL-based routing to call Netflix Eureka through the edge server, both using
    its API and web-based UI.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于URL的路由通过边缘服务器调用Netflix Eureka，同时使用其API和基于Web的UI。
- en: Use header-based routing to see how we can route requests based on the hostname
    in the request.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于标头的路由来查看如何根据请求中的主机名路由请求。
- en: Examining what is exposed outside the Docker engine
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查Docker引擎外部公开的内容
- en: 'To understand what the edge server exposes to the outside of the system landscape,
    perform the following steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解边缘服务器向系统景观外部公开了什么，执行以下步骤：
- en: 'Use the `docker-compose ps` command to see that what ports are exposed by our
    services:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker-compose ps`命令查看我们的服务公开了哪些端口：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As we can see in the following output, only the edge server (named `gateway`) exposes
    its port (`8080`) outside the Docker engine:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们在以下输出中所看到的，只有边缘服务器（名为`gateway`）将其端口（`8080`）暴露到Docker引擎之外：
- en: '![](img/635db56b-5896-497a-a15d-2ca63833a1e8.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/635db56b-5896-497a-a15d-2ca63833a1e8.png)'
- en: 'If we want to see what routes the edge server has set up, we can use the `/actuator/gateway/routes` API.
    The response from this API is rather verbose. To limit the response to information
    we are interested in, we can apply a `jq` filter. In the following example, I
    have selected the `id` of the route and the first predicate in the route:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要查看边缘服务器设置的路由，我们可以使用`/actuator/gateway/routes` API。此API的响应相当冗长。为了限制响应到我们感兴趣的信息，我们可以应用`jq`过滤器。在以下示例中，我已选择了路由的`id`和路由中的第一个谓词：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This command will respond with the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此命令将响应以下内容：
- en: '![](img/7e1c7cfb-3eb6-4299-9199-b4415b1b20b3.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e1c7cfb-3eb6-4299-9199-b4415b1b20b3.png)'
- en: This gives us a good overview of the actual routes configured in the edge server.
    Now, let's try out the routes!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了对边缘服务器中实际配置的路由的良好概述。现在，让我们尝试一下这些路由！
- en: Trying out the routing rules
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试路由规则
- en: In this section, we will try out the edge server and the routes it exposes to
    the outside of the system landscape. Let's start with calling the product composite
    API, then call the Eureka API and visit its web page, and conclude with testing
    the routes that are based on hostnames.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试边缘服务器和它向系统景观外部暴露的路由。让我们从调用产品组合API开始，然后调用Eureka API并访问其网页，最后测试基于主机名的路由。
- en: Calling the product composite API through the edge server
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过边缘服务器调用产品组合API
- en: 'Let''s perform the following steps to call the product composite API through
    the edge server as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤通过边缘服务器调用产品组合API来结束测试：
- en: 'To be able to see what is going on in the edge server, we can follow its log
    output:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了能够查看边缘服务器中发生了什么，我们可以跟踪其日志输出：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, make the call to the product composite API through the edge server:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过边缘服务器调用产品组合API：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Expect the normal type of response from the composite product API:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期望从产品组合API得到正常类型的响应：
- en: '![](img/20e4c6a4-4714-4990-b85f-964445d04b6a.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/20e4c6a4-4714-4990-b85f-964445d04b6a.png)'
- en: 'We should be able to find the following interesting information in the log
    output:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该能在日志输出中找到以下有趣的信息：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: From the log output, we can see the pattern matching based on the predicate
    we specified in the configuration, and we can see what microservice instance the
    edge server selected from the available instances in the discovery server—in this
    case, `http://b8013440aea0:8080/product-composite/2`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志输出中，我们可以看到基于我们在配置中指定的谓词的模式匹配，以及我们可以看到边缘服务器从发现服务器中的可用实例中选择了哪个微服务实例——在本例中是“http://b8013440aea0:8080/product-composite/2”。
- en: Calling Eureka through the edge server
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过边缘服务器调用Eureka
- en: 'To call Eureka through an edge server, perform the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过边缘服务器调用Eureka，执行以下步骤：
- en: 'First, call the Eureka API through the edge server to see what instances are
    currently registered in the discovery server:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过边缘服务器调用Eureka API，查看当前在发现服务器中注册的实例：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Expect a response along the lines of the following:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期望得到以下类型的响应：
- en: '![](img/d8b40a4a-a897-408e-9131-8dd8b7f52041.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d8b40a4a-a897-408e-9131-8dd8b7f52041.png)'
- en: Note that the edge server (named `gateway`) is also present in the response.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，响应中也包含了边缘服务器（名为“gateway”）。
- en: 'Next, open the Eureka web page in a web browser using the URL, `http://localhost:8080/eureka/web`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用URL“http://localhost:8080/eureka/web”在Web浏览器中打开Eureka网页：
- en: '![](img/c1f75e90-3c3a-42c1-aac1-432c7428230e.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1f75e90-3c3a-42c1-aac1-432c7428230e.png)'
- en: From the preceding screenshot, we can see the Eureka web page reporting the
    same available instances as the API response in the previous step.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们可以看到Eureka网页报告了与上一步API响应相同的可用实例。
- en: Routing based on the host header
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于主机头的路由
- en: Let's wrap up by testing the route setup based on the hostname used in the requests!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过测试基于请求中使用的主机名的路由设置来结束吧！
- en: 'Normally, the hostname in the request is set automatically in the `Host` header by
    the HTTP client. When testing the edge server locally, the hostname will be `localhost`—that
    is not so useful when testing hostname-based routing. But we can cheat by specifying
    another hostname in the `Host` header in the call to the API. Let''s see how this
    can be done:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，请求中的主机名会被HTTP客户端自动设置在“Host”头中。在本地测试边缘服务器时，主机名将是“localhost”，这在测试基于主机名的路由时并不那么有用。但我们可以通过在调用API时在“Host”头中指定另一个主机名来欺骗。让我们看看如何做到这一点：
- en: 'To call for the `i.feel.lucky` hostname, use this code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要调用“i.feel.lucky”主机名，请使用以下代码：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Expect the response 200 OK. For the hostname `im.a.teapot`, use the following
    command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 期望得到响应200 OK。对于主机名“im.a.teapot”，使用以下命令：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Expect the response `418 I'm a teapot`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 期望得到响应“418 I'm a teapot”。
- en: 'Finally, if not specifying any `Host` header, use `localhost` as the `Host`
    header:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果不指定任何“Host”头，请使用“localhost”作为“Host”头：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Expect the response `501 Not Implemented`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 期望得到响应“501 Not Implemented”。
- en: 'We can also use `i.feel.lucky` and `im.a.teapot` as real hostnames in the requests
    if we add them to the local `/etc/hosts` file and specify that they should be
    translated into the same IP address as `localhost`, that is `127.0.0.1`. Run the
    following command to add a row to the `/etc/hosts` file with the required information:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将它们添加到本地的`/etc/hosts`文件并指定它们应该被转换为与“localhost”相同的IP地址，即“127.0.0.1”，我们也可以在请求中使用“i.feel.lucky”和“im.a.teapot”作为真实的主机名。运行以下命令向`/etc/hosts`文件添加一行所需的信息：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now perform the same routing based on the hostname, but without specifying
    the `Host` header. Try it out by running the following commands:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以执行相同基于主机名的路由，但不指定“Host”头。通过运行以下命令来尝试：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Expect the same response as previously, that is, 200 OK and `418 I'm a teapot`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 期望得到与之前相同的响应，即200 OK和“418 I'm a teapot”。
- en: 'Wrap up the tests by shutting down the system landscape with the following
    command:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令关闭系统景观以结束测试：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Also, clean up the `/etc/hosts` file from the DNS name translation we added
    for the hostnames, `i.feel.lucky` and `im.a.teapot`. Edit the `/etc/hosts` file and
    remove the line we added: `127.0.0.1 i.feel.lucky im.a.teapot`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，从DNS名称转换中清理`/etc/hosts`文件，我们添加的主机名“i.feel.lucky”和“im.a.teapot”。编辑`/etc/hosts`文件并删除我们添加的行：“127.0.0.1
    i.feel.lucky im.a.teapot”。
- en: These tests of the routing capabilities in the system landscape's edge server
    end the chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试系统景观边缘服务器的路由能力结束了本章。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how Spring Cloud Gateway can be used as an edge
    server to control what services are allowed to be called from the outside of the
    system landscape. Based on predicates, filters, and destination URIs, we can define
    routing rules in a very flexible way. If we want to, we can configure Spring Cloud
    Gateway to use a discovery service such as Netflix Eureka to look up the target
    microservice instances.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了Spring Cloud Gateway如何作为边缘服务器来控制允许从系统景观外部调用哪些服务。基于谓词、过滤器和目标URI，我们可以以非常灵活的方式定义路由规则。如果需要，我们可以配置Spring
    Cloud Gateway使用诸如Netflix Eureka之类的发现服务来查找目标微服务实例。
- en: One important question still unanswered is how we prevent unauthorized access
    to the APIs exposed by the edge server and how we can prevent third parties from
    intercepting the traffic.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个尚未解答的重要问题是如何防止未经授权的访问边缘服务器暴露的API，并如何防止第三方拦截流量。
- en: In the next chapter, we will see how we can secure access to the edge server
    using standard security mechanisms such as HTTPS, OAuth, and OpenID Connect.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何使用标准安全机制（如HTTPS、OAuth和OpenID Connect）确保对边缘服务器的访问安全。
- en: Questions
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the elements used to build a routing rule in Spring Cloud Gateway called?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Spring Cloud Gateway中用于构建路由规则的元素是什么？
- en: What are they used for?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们用于什么？
- en: How can we instruct Spring Cloud Gateway to locate microservice instances through
    a discovery service such as Netflix Eureka?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何指示Spring Cloud Gateway通过Netflix Eureka等发现服务定位微服务实例？
- en: In a Docker environment, how can we ensure that external HTTP requests to the
    Docker engine can only reach the edge server?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Docker环境中，我们如何确保外部HTTP请求只能到达边缘服务器？
- en: How do we change the routing rules so that the edge server accepts calls to
    the `product-composite` service on the `http://$HOST:$PORT/api/product` URL instead
    of the currently used `http://$HOST:$PORT/product-composite`?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何更改路由规则，使边缘服务器接受对`http://$HOST:$PORT/api/product`URL的`product-composite`服务的调用，而不是当前使用的`http://$HOST:$PORT/product-composite`？
