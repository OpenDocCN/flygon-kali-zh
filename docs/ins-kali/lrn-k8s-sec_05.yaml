- en: '*Chapter 4*: Applying the Principle of Least Privilege in Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*：在Kubernetes中应用最小权限原则'
- en: The principle of least privilege states that each component of an ecosystem
    should have minimal access to data and resources for it to function. In a multitenant
    environment, multiple resources can be accessed by different users or objects.
    The principle of least privilege ensures that damage to the cluster is minimal
    if users or objects misbehave in such environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最小权限原则规定生态系统的每个组件在其功能运行所需的数据和资源上应具有最小的访问权限。在多租户环境中，不同用户或对象可以访问多个资源。最小权限原则确保在这种环境中，如果用户或对象行为不端，对集群造成的损害是最小的。
- en: In this chapter, we will first introduce the principle of least privilege. Given
    the complexity of Kubernetes, we will first look into the Kubernetes subjects,
    and then the privileges available for the subjects. Then, we will talk about the
    privileges of Kubernetes objects and possible ways to restrict them. The goal
    of this chapter is to help you understand a few critical concepts, such as the
    principle of least privilege and **Role-Based Access Control** (**RBAC**). In
    this chapter, we will talk about different Kubernetes objects, such as namespaces,
    service accounts, Roles, and RoleBindings, and Kubernetes security features, such
    as the security context, the PodSecurityPolicy, and the NetworkPolicy, which can
    be leveraged to implement the principle of least privilege for your Kubernetes
    cluster.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先介绍最小权限原则。鉴于Kubernetes的复杂性，我们将首先研究Kubernetes主题，然后是主题可用的权限。然后，我们将讨论Kubernetes对象的权限以及限制它们的可能方式。本章的目标是帮助您理解一些关键概念，如最小权限原则和基于角色的访问控制（RBAC）。在本章中，我们将讨论不同的Kubernetes对象，如命名空间、服务账户、角色和角色绑定，以及Kubernetes安全特性，如安全上下文、PodSecurityPolicy和NetworkPolicy，这些特性可以用来实现Kubernetes集群的最小权限原则。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The principle of least privilege
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小权限原则
- en: Least privilege of Kubernetes subjects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes主题的最小权限
- en: Least privilege of Kubernetes workloads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes工作负载的最小权限
- en: The principle of least privilege
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小权限原则
- en: Privilege is the authority to perform an action such as accessing a resource
    or processing some data. The principle of least privilege is the idea that any
    subject, user, program, process, and so on should only have the minimum required
    privileges to perform its function. For example, Alice, a regular Linux user,
    is able to create a file under her own home directory. In other words, Alice at
    least has the privilege or permission to create a file under her home directory.
    However, Alice may not be able to create a file under another user's directory
    because she doesn't have the privilege or permission to do so. If none of Alice's
    daily tasks actually exercises the privilege to create a file in the home directory,
    but she does have the privilege to do so, then the administrator for the machine
    is not complying with the principle of least privilege. In this section, we will
    first introduce the concept of the authorization model from which the concept
    of least privilege derived, and then, we will talk about the benefits of implementing
    the principle of least privilege.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 特权是执行操作的权限，例如访问资源或处理一些数据。最小特权原则是任何主体、用户、程序、进程等都应该只具有执行其功能所需的最低特权的想法。例如，Alice，一个普通的Linux用户，能够在自己的主目录下创建文件。换句话说，Alice至少具有在她的主目录下创建文件的特权或权限。然而，Alice可能无法在另一个用户的目录下创建文件，因为她没有这样做的特权或权限。如果Alice的日常任务中没有一个实际行使在主目录中创建文件的特权，但她确实有这样做的特权，那么机器的管理员就没有遵守最小特权原则。在本节中，我们将首先介绍授权模型的概念，然后我们将讨论实施最小特权原则的好处。
- en: Authorization model
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权模型
- en: 'When we talk about least privilege, most of the time we talk in the context
    of authorization, and in different environments, there will be different authorization
    models. For example, an **Access Control List** (**ACL**) is widely used in Linux
    and network firewalls, while RBAC is used in database systems. It is also up to
    the administrator of the environment to define authorization policies to ensure
    least privilege based on authorization models available in the system. The following
    list defines some popular authorization models:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论最小特权时，大多数时候我们是在授权的背景下谈论的，在不同的环境中，会有不同的授权模型。例如，**访问控制列表**（**ACL**）广泛用于Linux和网络防火墙，而RBAC用于数据库系统。环境的管理员也有责任定义授权策略，以确保基于系统中可用的授权模型的最小特权。以下列表定义了一些流行的授权模型：
- en: '**ACL**: An ACL defines a list of permissions associated with objects. It specifies
    which subjects are granted access to objects, as well as what operations are allowed
    on given objects. For example, the `-rw` file permission is read-write-only by
    the file owner.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ACL**：ACL定义了与对象关联的权限列表。它指定了哪些主体被授予对对象的访问权限，以及对给定对象允许的操作。例如，`-rw`文件权限是文件所有者的读写权限。'
- en: '**RBAC**: The authorization decision is based on a subject''s roles, which
    contain a group of permissions or privileges. For example, in Linux, a user is
    added to different groups (such as `staff`) to grant access to some folders instead
    of individually being granted access to folders on the filesystem.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RBAC：授权决策基于主体的角色，其中包含一组权限或特权。例如，在Linux中，用户被添加到不同的组（如`staff`）以授予对文件夹的访问权限，而不是单独被授予对文件系统上文件夹的访问权限。
- en: '**Attribute-Based Access Control (ABAC)**: The authorization decision is based
    on a subject''s attributes, such as labels or properties. An attribute-based rule
    checks user attributes such as `user.id="12345"`, `user.project="project"`, and
    `user.status="active"` to decide whether a user is able to perform a task.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于属性的访问控制（ABAC）**：授权决策基于主体的属性，例如标签或属性。基于属性的规则检查用户属性，如`user.id="12345"`，`user.project="project"`和`user.status="active"`，以决定用户是否能够执行任务。'
- en: Kubernetes supports both ABAC and RBAC. Though ABAC is powerful and flexible,
    the implementation in Kubernetes makes it difficult to manage and understand.
    Thus, it is recommended to enable RBAC instead of ABAC in Kubernetes. Besides
    RBAC, Kubernetes also provides multiple ways to restrict resource access. Before
    we look into RBAC and ABAC in Kubernetes in the next sections, let's discuss the
    benefits of ensuring least privilege.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持ABAC和RBAC。尽管ABAC功能强大且灵活，但在Kubernetes中的实施使其难以管理和理解。因此，建议在Kubernetes中启用RBAC而不是ABAC。除了RBAC，Kubernetes还提供了多种限制资源访问的方式。在接下来的部分中我们将探讨Kubernetes中的RBAC和ABAC之前，让我们讨论确保最小特权的好处。
- en: Rewards of the principle of least privilege
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小特权原则的奖励
- en: 'Though it might take quite some time to understand what the minimum privileges
    for subjects are in order to perform their functions, the rewards are also significant
    if the principle of least privilege has been implemented in your environment:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可能需要相当长的时间来理解主体的最低特权是为了执行其功能，但如果最小特权原则已经在您的环境中实施，奖励也是显著的：
- en: '**Better security**: Inside threats, malware propagation, lateral movement,
    and so on can be mitigated with the implementation of the principle of least privilege.
    The leak by Edward Snowden happened because of a lack of least privilege.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的安全性**：通过实施最小特权原则，可以减轻内部威胁、恶意软件传播、横向移动等问题。爱德华·斯诺登的泄密事件发生是因为缺乏最小特权。'
- en: '**Better stability**: Given the subjects are properly granted with necessary
    privileges only, subjects'' activities become more predictable. In return, system
    stability is bolstered.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的稳定性**：鉴于主体只被适当地授予必要的特权，主体的活动变得更加可预测。作为回报，系统的稳定性得到了加强。'
- en: '**Improved audit readiness**: Given the subjects are properly granted with
    necessary privileges only, the audit scope will be reduced dramatically. Additionally,
    many common regulations call for the implementation of the principle of least
    privilege as a compliance requirement.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的审计准备性**：鉴于主体只被适当地授予必要的特权，审计范围将大大减少。此外，许多常见的法规要求实施最小特权原则作为合规要求。'
- en: 'Now that you have seen the benefits for implementing the principle of least
    privilege, I want to introduce the challenge as well: the openness and configurability
    of Kubernetes makes implementing the principle of least privilege cumbersome.
    Let''s look at how to apply the principle of least privilege to Kubernetes subjects.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经看到了实施最小特权原则的好处，我也想介绍一下挑战：Kubernetes的开放性和可配置性使得实施最小特权原则变得繁琐。让我们看看如何将最小特权原则应用于Kubernetes主体。
- en: Least privilege of Kubernetes subjects
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes主体的最小特权
- en: Kubernetes service accounts, users, and groups communicate with `kube-apiserver`
    to manage Kubernetes objects. With RBAC enabled, different users or service accounts
    may have different privileges to operate Kubernetes objects. For example, users
    in the `system:master` group have the `cluster-admin` role granted, meaning they
    can manage the entire Kubernetes cluster, while users in the `system:kube-proxy`
    group can only access the resources required by the `kube-proxy` component. First,
    let's briefly talk about what RBAC is.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes服务账户、用户和组与`kube-apiserver`通信，以管理Kubernetes对象。启用RBAC后，不同的用户或服务账户可能具有操作Kubernetes对象的不同特权。例如，`system:master`组中的用户被授予`cluster-admin`角色，这意味着他们可以管理整个Kubernetes集群，而`system:kube-proxy`组中的用户只能访问`kube-proxy`组件所需的资源。首先，让我们简要介绍一下RBAC是什么。
- en: Introduction to RBAC
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RBAC简介
- en: As discussed earlier, RBAC is a model of regulating access to resources based
    on roles granted to users or groups. From version 1.6 onward, RBAC is enabled
    by default in Kubernetes. Before version 1.6, RBAC could be enabled by running
    the **Application Programming Interface** (**API**) server with the `--authorization-mode=RBAC`
    flag. RBAC eases the dynamic configuration of permission policies using the API
    server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面讨论的，RBAC是一种基于授予用户或组角色的资源访问控制模型。从1.6版本开始，Kubernetes默认启用了RBAC。在1.6版本之前，可以通过使用带有`--authorization-mode=RBAC`标志的**应用程序编程接口**（**API**）服务器来启用RBAC。RBAC通过API服务器简化了权限策略的动态配置。
- en: 'The core elements of RBAC include the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC的核心元素包括以下内容：
- en: '**Subject**: Service accounts, users, or groups requesting access to the Kubernetes
    API.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**主体**：请求访问Kubernetes API的服务账户、用户或组。'
- en: '**Resources**: Kubernetes objects that need to be accessed by the subject.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**资源**：需要被主体访问的Kubernetes对象。'
- en: '**Verbs**: Different types of access the subject needs on a resource—for example,
    create, update, list, delete.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**动词**：主体在资源上需要的不同类型访问，例如创建、更新、列出、删除。'
- en: Kubernetes RBAC defines the subjects and the type of access they have to different
    resources in the Kubernetes ecosystem.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes RBAC定义了主体和它们在Kubernetes生态系统中对不同资源的访问类型。
- en: Service accounts, users, and groups
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务账户、用户和组
- en: 'Kubernetes supports three types of subject, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes支持三种类型的主体，如下：
- en: '**Regular users**: These users are created by cluster administrators. They
    do not have a corresponding object in the Kubernetes ecosystem. Cluster administrators
    usually create users by using the **Lightweight Directory Access Protocol** (**LDAP**),
    **Active Directory** (**AD**), or private keys.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普通用户**：这些用户是由集群管理员创建的。它们在Kubernetes生态系统中没有对应的对象。集群管理员通常使用**轻量级目录访问协议**（**LDAP**）、**Active
    Directory**（**AD**）或私钥来创建用户。'
- en: '**Service accounts**: Pods authenticate to the `kube-apiserver` object using
    a service account. Service accounts are created using API calls. They are restricted
    to namespaces and have associated credentials stored as `secrets`. By default,
    pods authenticate as a `default` service account.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务账户**：Pod使用服务账户对`kube-apiserver`对象进行身份验证。服务账户是通过API调用创建的。它们受限于命名空间，并且有关联的凭据存储为`secrets`。默认情况下，pod使用`default`服务账户进行身份验证。'
- en: '**Anonymous users**: Any API request that is not associated with a regular
    or a service account is associated with an anonymous user.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匿名用户**：任何未与普通用户或服务账户关联的API请求都与匿名用户关联。'
- en: 'Cluster administrators can create new service accounts to be associated with
    pods by running the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 集群管理员可以通过运行以下命令创建与pod关联的新服务账户：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A `new_account` service account will be created in the default namespace. To
    ensure least privilege, cluster administrators should associate every Kubernetes
    resource with a service account with least privilege to operate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认命名空间中将创建一个“new_account”服务账户。为了确保最小权限，集群管理员应将每个Kubernetes资源与具有最小权限的服务账户关联起来。
- en: Role
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: A role is a collection of permissions—for example, a role in namespace A can
    allow users to create pods in namespace A and list secrets in namespace A. In
    Kubernetes, there are no deny permissions. Thus, a role is an addition of a set
    of permissions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 角色是权限的集合——例如，命名空间A中的角色可以允许用户在命名空间A中创建pods并列出命名空间A中的secrets。在Kubernetes中，没有拒绝权限。因此，角色是一组权限的添加。
- en: 'A role is restricted to a namespace. On the other hand, a ClusterRole works
    at the cluster level. Users can create a ClusterRole that spans across the complete
    cluster. A ClusterRole can be used to mediate access to resources that span across
    a cluster, such as nodes, health checks, and namespaced objects, such as pods
    across multiple namespaces. Here is a simple example of a role definition:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 角色受限于命名空间。另一方面，ClusterRole在集群级别工作。用户可以创建跨整个集群的ClusterRole。ClusterRole可用于调解对跨集群的资源的访问，例如节点、健康检查和跨多个命名空间的对象，例如pods。以下是一个角色定义的简单示例：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This simple rule allows the `get` operation to over-resource `pods` in the
    default namespace. This role can be created using `kubectl` by executing the following
    command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的规则允许“get”操作超越默认命名空间中的“pods”资源。可以通过执行以下命令使用kubectl创建此角色：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A user can only create or modify a role if either one of the following is true:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以下任一条件为真，则用户只能创建或修改角色：
- en: The user has all permissions contained in the role in the same scope (namespaced
    or cluster-wide).
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在相同范围（命名空间或整个集群）中拥有角色中包含的所有权限。
- en: The user is associated with an escalated role in the given scope.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户与给定范围内的升级角色相关联。
- en: This prevents users from performing privilege escalation attacks by modifying
    user roles and permissions.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以防止用户通过修改用户角色和权限来执行权限升级攻击。
- en: RoleBinding
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RoleBinding
- en: 'A RoleBinding object is used to associate a role with subjects. Similar to
    ClusterRole, ClusterRoleBinding can grant a set of permissions to subjects across
    namespaces. Let''s see a couple of examples:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: RoleBinding对象用于将角色与主体关联。与ClusterRole类似，ClusterRoleBinding可以向跨命名空间的主体授予一组权限。让我们看几个例子：
- en: 'Create a RoleBinding object to associate a `custom-clusterole` cluster role
    to the `demo-sa` service account in the default namespace, like this:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个RoleBinding对象，将“custom-clusterrole”集群角色与默认命名空间中的“demo-sa”服务账户关联起来，就像这样：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a RoleBinding object to associate a `custom-clusterrole` cluster role
    to the `group-1` group, like this:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个RoleBinding对象，将“custom-clusterrole”集群角色与“group-1”组关联起来，就像这样：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The RoleBinding object links roles to subjects and makes roles reusable and
    easy to manage.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: RoleBinding对象将角色链接到主体，并使角色可重用且易于管理。
- en: Kubernetes namespaces
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes命名空间
- en: A namespace is a common concept in computer science that provides a logical
    grouping for related resources. Namespaces are used to avoid name collisions;
    resources within the same namespace should have unique names, but resources across
    namespaces can share names. In the Linux ecosystem, namespaces allow the isolation
    of system resources.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是计算机科学中的一个常见概念，为相关资源提供了逻辑分组。命名空间用于避免名称冲突；同一命名空间内的资源应具有唯一名称，但跨命名空间的资源可以共享名称。在Linux生态系统中，命名空间允许隔离系统资源。
- en: 'In Kubernetes, namespaces allow a single cluster to be shared between teams
    and projects logically. With Kubernetes namespaces, the following applies:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，命名空间允许多个团队和项目在逻辑上共享单个集群。使用Kubernetes命名空间，以下内容适用：
- en: They allow different applications, teams, and users to work in the same cluster.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许不同的应用程序、团队和用户在同一个集群中工作。
- en: They allow cluster administrators to use namespace resource quotas for the applications.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许集群管理员为应用程序使用命名空间资源配额。
- en: They use RBAC policies to control access to specific resources within the namespaces.
    RoleBinding helps cluster administrators' control permissions granted to users
    within the namespace.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们使用RBAC策略来控制对命名空间内特定资源的访问。RoleBinding帮助集群管理员控制对命名空间内用户授予的权限。
- en: They allow network segmentation with the network policy defined in the namespace.
    By default, all pods can communicate with each other across different namespaces.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们允许在命名空间中使用网络策略进行网络分割。默认情况下，所有pod可以跨不同命名空间相互通信。
- en: 'By default, Kubernetes has three different namespaces. Run the following command
    to view them:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes有三个不同的命名空间。运行以下命令查看它们：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The three namespaces are described as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 三个命名空间的描述如下：
- en: '`default`: A namespace for resources that are not part of any other namespace.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：不属于任何其他命名空间的资源的命名空间。'
- en: '`kube-system`: A namespace for objects created by Kubernetes such as `kube-apiserver`,
    `kube-scheduler`, `controller-manager`, and `coredns`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-system`：Kubernetes创建的对象的命名空间，如`kube-apiserver`、`kube-scheduler`、`controller-manager`和`coredns`。'
- en: '`kube-public`: Resources within this namespace are accessible to all. By default,
    nothing will be created in this namespace.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-public`：此命名空间内的资源对所有人都是可访问的。默认情况下，此命名空间中不会创建任何内容。'
- en: Let's take a look at how to create a namespace.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一个命名空间。
- en: Creating a namespace
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建命名空间
- en: 'A new namespace in Kubernetes can be created by using the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令在Kubernetes中创建新的命名空间：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once a new namespace is created, objects can be assigned to a namespace by
    using the `namespace` property, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的命名空间后，可以使用`namespace`属性将对象分配给命名空间，如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Objects within the namespace can similarly be accessed by using the `namespace`
    property, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，可以使用`namespace`属性访问命名空间内的对象，如下所示：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In Kubernetes, not all objects are namespaced. Lower-level objects such as `Nodes`
    and `persistentVolumes` span across namespaces.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，并非所有对象都有命名空间。低级别对象如`Nodes`和`persistentVolumes`跨越多个命名空间。
- en: Wrapping up least privilege for Kubernetes subjects
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为Kubernetes主体实现最小特权
- en: 'By now, you should be familiar with the concepts of ClusterRole/Role, ClusterRoleBinding/RoleBinding,
    service accounts, and namespaces. In order to implement least privilege for Kubernetes
    subjects, you may ask yourself the following questions before you create a Role
    or RoleBinding object in Kubernetes:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该熟悉ClusterRole/Role、ClusterRoleBinding/RoleBinding、服务账户和命名空间的概念。为了为Kubernetes主体实现最小特权，您可以在创建Kubernetes中的Role或RoleBinding对象之前问自己以下问题：
- en: Does the subject need privileges for a namespace or across namespaces?
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体是否需要在命名空间内或跨命名空间拥有权限？
- en: This is important because once the subject has cluster-level privileges it may
    be able to exercise the privileges across all namespaces.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为一旦主体具有集群级别的权限，它可能能够在所有命名空间中行使权限。
- en: Should the privileges be granted to a user, group, or service account?
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限应该授予用户、组还是服务账户？
- en: When you grant a role to a group, it means all the users in the group will automatically
    get the privileges from the newly granted role. Be sure you understand the impact
    before you grant a role to a group. Next, a user in Kubernetes is for humans,
    while a service account is for microservices in pods. Be sure you know what the
    Kubernetes user's responsibility is and assign privileges accordingly. Also, note
    that some microservices do not need any privilege at all as they don't interact
    with `kube-apiserver` or any Kubernetes objects directly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向一个组授予一个角色时，这意味着组中的所有用户将自动获得新授予角色的特权。在向组授予角色之前，请确保您了解其影响。其次，Kubernetes中的用户是为人类而设，而服务账户是为pod中的微服务而设。请确保您了解Kubernetes用户的责任，并相应地分配特权。另外，请注意，一些微服务根本不需要任何特权，因为它们不直接与`kube-apiserver`或任何Kubernetes对象进行交互。
- en: What are the resources that the subjects need to access?
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体需要访问哪些资源？
- en: When creating a role, if you don't specify the resource name or do set `*` in
    the `resourceNames` field, it means access is granted to all the resources of
    the resource type. If you know which resource name the subject is going to access,
    do specify the resource name when creating a role.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建角色时，如果不指定资源名称或在`resourceNames`字段中设置`*`，则意味着已授予对该资源类型的所有资源的访问权限。如果您知道主体将要访问的资源名称，请在创建角色时指定资源名称。
- en: Kubernetes subjects interact with Kubernetes objects with the granted privileges.
    Understanding the actual tasks your Kubernetes subjects perform will help you
    grant privileges properly.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes主体使用授予的特权与Kubernetes对象进行交互。了解您的Kubernetes主体执行的实际任务将有助于您正确授予特权。
- en: Least privilege for Kubernetes workloads
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes工作负载的最小特权
- en: Usually, there will be a service account (default) associated with a Kubernetes
    workload. Thus, processes inside a pod can communicate with `kube-apiserver` using
    the service account token. DevOps should carefully grant necessary privileges
    to the service account for the purpose of least privilege. We've already covered
    this in the previous section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将会有一个（默认）服务账户与Kubernetes工作负载相关联。因此，pod内的进程可以使用服务账户令牌与`kube-apiserver`通信。DevOps应该仔细地为服务账户授予必要的特权，以实现最小特权的目的。我们在前一节已经介绍过这一点。
- en: Besides accessing `kube-apiserver` to operate Kubernetes objects, processes
    in a pod can also access resources on the worker nodes and other pods/microservices
    in the clusters (covered in [*Chapter 2*](B15566_02_Final_ASB_ePub.xhtml#_idTextAnchor049),
    *Kubernetes Networking*). In this section, we will talk about the possible least
    privilege implementation of access to system resources, network resources, and
    application resources.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了访问`kube-apiserver`来操作Kubernetes对象之外，pod中的进程还可以访问工作节点上的资源以及集群中的其他pod/微服务（在[*第2章*](B15566_02_Final_ASB_ePub.xhtml#_idTextAnchor049)，*Kubernetes网络*中有介绍）。在本节中，我们将讨论对系统资源、网络资源和应用程序资源进行最小特权访问的可能实现。
- en: Least privilege for accessing system resources
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问系统资源的最小特权
- en: Recall that a microservice running inside a container or pod is nothing but
    a process on a worker node isolated in its own namespace. A pod or container may
    access different types of resources on the worker node based on the configuration.
    This is controlled by the security context, which can be configured both at the
    pod level and the container level. Configuring the pod/container security context
    should be on the developers' task list (with the help of security design and review),
    while pod security policies—the other way to limit pod/container access to system
    resources at the cluster level—should be on DevOps's to-do list. Let's look into
    the concepts of security context, PodSecurityPolicy, and resource limit control.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，运行在容器或pod内的微服务只是工作节点上的一个进程，在其自己的命名空间中隔离。根据配置，pod或容器可以访问工作节点上的不同类型的资源。这由安全上下文控制，可以在pod级别和容器级别进行配置。配置pod/容器安全上下文应该是开发人员的任务清单（在安全设计和审查的帮助下），而限制pod/容器访问集群级别系统资源的另一种方式——pod安全策略，应该是DevOps的任务清单。让我们深入了解安全上下文、Pod安全策略和资源限制控制的概念。
- en: Security context
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全上下文
- en: 'A security context offers a way to define privileges and access control settings
    for pods and containers with regard to accessing system resources. In Kubernetes,
    the security context at the pod level is different from that at the container
    level, though there are some overlapping attributes that can be configured at
    both levels. In general, the security context provides the following features
    that allow you to apply the principle of least privilege for containers and pods:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 安全上下文提供了一种方式来定义与访问系统资源相关的pod和容器的特权和访问控制设置。在Kubernetes中，pod级别的安全上下文与容器级别的安全上下文不同，尽管它们有一些重叠的属性可以在两个级别进行配置。总的来说，安全上下文提供了以下功能，允许您为容器和pod应用最小特权原则：
- en: '**Discretionary Access Control (DAC)**: This is to configure which **user ID**
    (**UID**) or **group ID** (**GID**) to bind to the process in the container, whether
    the container''s root filesystem is read-only, and so on. It is highly recommended
    not to run your microservice as a root user (*UID = 0*) in containers. The security
    implication is that if there is an exploit and a container escapes to the host,
    the attacker gains the root user privileges on the host immediately.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自主访问控制（DAC）：这是用来配置将哪个用户ID（UID）或组ID（GID）绑定到容器中的进程，容器的根文件系统是否为只读等。强烈建议不要在容器中以root用户（UID
    = 0）身份运行您的微服务。安全影响是，如果存在漏洞并且容器逃逸到主机，攻击者立即获得主机上的root用户权限。
- en: '**Security Enhanced Linux (SELinux):** This is to configure the SELinux security
    context, which defines the level label, role label, type label, and user label
    for pods or containers. With the SELinux labels assigned, pods and containers
    may be restricted in terms of being able to access resources, especially volumes
    on the node.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全增强Linux（SELinux）：这是用来配置SELinux安全上下文的，它为pod或容器定义了级别标签、角色标签、类型标签和用户标签。通过分配SELinux标签，pod和容器可能会受到限制，特别是在能够访问节点上的卷方面。
- en: '**Privileged mode:** This is to configure whether a container is running in
    privileged mode. The power of the process running inside the privileged container
    is basically the same as a root user on a node.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权模式：这是用来配置容器是否在特权模式下运行。特权容器内运行的进程的权限基本上与节点上的root用户相同。
- en: '**Linux capabilities:** This is to configure Linux capabilities for containers.
    Different Linux capabilities allow the process inside the container to perform
    different activities or access different resources on the node. For example, `CAP_AUDIT_WRITE`
    allows the process to write to the kernel auditing log, while `CAP_SYS_ADMIN`
    allows the process to perform a range of administrative operations.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux功能：** 这是为容器配置Linux功能。不同的Linux功能允许容器内的进程执行不同的活动或在节点上访问不同的资源。例如，`CAP_AUDIT_WRITE`允许进程写入内核审计日志，而`CAP_SYS_ADMIN`允许进程执行一系列管理操作。'
- en: '**AppArmor:** This is to configure the AppArmor profile for pods or containers.
    An AppArmor profile usually defines which Linux capabilities the process owns,
    which network resources and files can be accessed by the container, and so on.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AppArmor：** 这是为Pod或容器配置AppArmor配置文件。AppArmor配置文件通常定义了进程拥有哪些Linux功能，容器可以访问哪些网络资源和文件等。'
- en: '**Secure Computing Mode (seccomp):** This is to configure the seccomp profile
    for pods or containers. A seccomp profile usually defines a whitelist of system
    calls that are allowed to execute and/or a blacklist of system calls that will
    be blocked to execute inside the pod or container.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全计算模式（seccomp）：** 这是为Pod或容器配置seccomp配置文件。seccomp配置文件通常定义了允许执行的系统调用白名单和将被阻止在Pod或容器内执行的系统调用黑名单。'
- en: '**AllowPrivilegeEscalation:** This is to configure whether a process can gain
    more privileges than its parent process. Note that `AllowPrivilegeEscalation`
    is always true when the container is either running as privileged or has a `CAP_SYS_ADMIN`
    capability.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AllowPrivilegeEscalation：** 这是用于配置进程是否可以获得比其父进程更多的权限。请注意，当容器以特权运行或具有`CAP_SYS_ADMIN`功能时，`AllowPrivilegeEscalation`始终为真。'
- en: We will talk more about security context in [*Chapter 8*](B15566_08_Final_ASB_ePub.xhtml#_idTextAnchor249),
    *Securing Pods*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第8章*](B15566_08_Final_ASB_ePub.xhtml#_idTextAnchor249)中更多地讨论安全上下文，*保护Pods*。
- en: PodSecurityPolicy
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PodSecurityPolicy
- en: 'The PodSecurityPolicy is a Kubernetes cluster-level resource that controls
    the attributes of pod specification relevant to security. It defines a set of
    rules. When pods are to be created in the Kubernetes cluster, the pods need to
    comply with the rules defined in the PodSecurityPolicy or they will fail to start.
    The PodSecurityPolicy controls or applies the following attributes:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: PodSecurityPolicy是Kubernetes集群级别的资源，用于控制与安全相关的Pod规范属性。它定义了一组规则。当要在Kubernetes集群中创建Pod时，Pod需要遵守PodSecurityPolicy中定义的规则，否则将无法启动。PodSecurityPolicy控制或应用以下属性：
- en: Allows a privileged container to be run
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许运行特权容器
- en: Allows host-level namespaces to be used
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许使用主机级别的命名空间
- en: Allows host ports to be used
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许使用主机端口
- en: Allows different types of volumes to be used
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许使用不同类型的卷
- en: Allows the host's filesystem to be accessed
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许访问主机文件系统
- en: Requires a read-only root filesystem to be run for containers
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要求容器运行只读根文件系统
- en: Restricts user IDs and group IDs for containers
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制容器的用户ID和组ID
- en: Restricts containers' privilege escalation
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制容器的特权升级
- en: Restricts containers' Linux capabilities
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制容器的Linux功能
- en: Requires an SELinux security context to be used
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要使用SELinux安全上下文
- en: Applies seccomp and AppArmor profiles to pods
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将seccomp和AppArmor配置文件应用于Pod
- en: Restricts sysctls that a pod can run
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制Pod可以运行的sysctl
- en: Allows a `proc` mount type to be used
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许使用`proc`挂载类型
- en: Restricts an FSGroup to volumes
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制FSGroup对卷的使用
- en: We will cover more about PodSecurityPolicy in [*Chapter 8*](B15566_08_Final_ASB_ePub.xhtml#_idTextAnchor249),
    *Securing Kubernetes Pods*. A PodSecurityPolicy control is basically implemented
    as an admission controller. You can also create your own admission controller
    to apply your own authorization policy for your workload. **Open Policy Agent**
    (**OPA**) is another good candidate to implement your own least privilege policy
    for a workload. We will look at OPA more in [*Chapter 7*](B15566_07_Final_ASB_ePub.xhtml#_idTextAnchor186),
    *Authentication, Authorization, and Admission Control*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《第8章》《Securing Kubernetes Pods》中更多地介绍PodSecurityPolicy。PodSecurityPolicy控制基本上是作为一个准入控制器实现的。您也可以创建自己的准入控制器，为您的工作负载应用自己的授权策略。**Open
    Policy Agent**（**OPA**）是另一个很好的选择，可以为工作负载实现自己的最小特权策略。我们将在《第7章》《Authentication,
    Authorization, and Admission Control》中更多地了解OPA。
- en: Now, let's look at the resource limit control mechanism in Kubernetes as you
    may not want your microservices to saturate all the resources, such as the **Central
    Processing Unit** (**CPU**) and memory, in the system.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下Kubernetes中的资源限制控制机制，因为您可能不希望您的微服务饱和系统中的所有资源，比如**Central Processing
    Unit**（**CPU**）和内存。
- en: Resource limit control
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源限制控制
- en: By default, a single container can use as much memory and CPU resources as a
    node has. A container with a crypto-mining binary running may easily consume the
    CPU resources on the node shared by other pods. It's always a good practice to
    set resource requests and limits for workload. The resource request impacts which
    node the pods will be assigned to by the scheduler, while the resource limit sets
    the condition under which the container will be terminated. It's always safe to
    assign more resource requests and limits to your workload to avoid eviction or
    termination. However, do keep in mind that if you set the resource request or
    limit too high, you've caused a resource waste on your cluster, and the resources
    allocated to your workload may not be fully utilized. We will cover this topic
    more in [*Chapter 10*](B15566_10_Final_ASB_ePub.xhtml#_idTextAnchor305), *Real-Time
    Monitoring and Resource Management of a Kubernetes Cluster*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，单个容器可以使用与节点相同的内存和CPU资源。运行加密挖矿二进制文件的容器可能会轻松消耗节点上其他Pod共享的CPU资源。为工作负载设置资源请求和限制始终是一个良好的实践。资源请求会影响调度器分配Pod的节点，而资源限制设置了容器终止的条件。为您的工作负载分配更多的资源请求和限制以避免驱逐或终止始终是安全的。但是，请记住，如果您将资源请求或限制设置得太高，您将在集群中造成资源浪费，并且分配给您的工作负载的资源可能无法充分利用。我们将在《第10章》《Real-Time
    Monitoring and Resource Management of a Kubernetes Cluster》中更多地介绍这个话题。
- en: Wrapping up least privilege for accessing system resources
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装访问系统资源的最小特权
- en: When pods or containers run in privileged mode, unlike the non-privileged pods
    or containers, they have the same privileges as admin users on the node. If your
    workload runs in privileged mode, why is this the case? When a pod is able to
    assess host-level namespaces, the pod can access resources such as the network
    stack, process, and **Interprocess Communication** (**IPC**) at the host level.
    But do you really need to grant host-level namespace access or set privileged
    mode to your pods or containers? Also, if you know which Linux capabilities are
    required for your processes in the container, you'd better drop those unnecessary
    ones. And how much memory and CPU is sufficient for your workload to be fully
    functional? Please do think through these questions for the purpose of implementing
    the principle of least privilege for your Kubernetes workload. Properly set resource
    requests and limits, use security context for your workload, and enforce a PodSecurityPolicy
    for your cluster. All of this will help ensure the least privilege for your workload
    to access system resources.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当pod或容器以特权模式运行时，与非特权pod或容器不同，它们具有与节点上的管理员用户相同的特权。如果您的工作负载以特权模式运行，为什么会这样？当一个pod能够访问主机级别的命名空间时，该pod可以访问主机级别的资源，如网络堆栈、进程和**进程间通信**（**IPC**）。但您真的需要授予主机级别的命名空间访问权限或设置特权模式给您的pod或容器吗？此外，如果您知道容器中的进程需要哪些Linux功能，最好放弃那些不必要的功能。您的工作负载需要多少内存和CPU才能完全正常运行？请考虑这些问题，以实现对您的Kubernetes工作负载的最小特权原则。正确设置资源请求和限制，为您的工作负载使用安全上下文，并为您的集群强制执行PodSecurityPolicy。所有这些都将有助于确保您的工作负载以最小特权访问系统资源。
- en: Least privilege for accessing network resources
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问网络资源的最小特权
- en: By default, any two pods inside the same Kubernetes cluster can communicate
    with other, and a pod may be able to communicate with the internet if there is
    no proxy rule or firewall rule configured outside the Kubernetes cluster. The
    openness of Kubernetes blurs the security boundary of microservices, and we mustn't
    overlook network resources such as API endpoints provided by other microservices
    that a container or pod can access.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，同一Kubernetes集群中的任何两个pod可以相互通信，如果在Kubernetes集群外没有配置代理规则或防火墙规则，一个pod可能能够与互联网通信。Kubernetes的开放性模糊了微服务的安全边界，我们不应忽视容器或pod可以访问的其他微服务提供的API端点等网络资源。
- en: 'Suppose one of your workloads (pod X) in namespace X only needs to access another
    microservice A in namespace NS1; meanwhile, there is microservice B in namespace
    NS2\. Both microservice A and microservice B expose their **Representational State
    Transfer** (**REST**ful) endpoints. By default, your workload can access both
    microservice A and B assuming there is neither authentication nor authorization
    at the microservice level, and also no network policies enforced in namespaces
    NS1 and NS2\. Take a look at the following diagram, which illustrates this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的工作负载（pod X）在名称空间X中只需要访问名称空间NS1中的另一个微服务A；同时，名称空间NS2中有微服务B。微服务A和微服务B都公开其**表述状态传输**（**REST**ful）端点。默认情况下，您的工作负载可以访问微服务A和B，假设微服务级别没有身份验证或授权，以及名称空间NS1和NS2中没有强制执行网络策略。请看下面的图表，说明了这一点：
- en: '![Figure 4.1 – Network access without network policy'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1-没有网络策略的网络访问'
- en: '](image/B15566_04_001.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15566_04_001.jpg)'
- en: Figure 4.1 – Network access without network policy
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1-没有网络策略的网络访问
- en: 'In the preceding diagram, **Pod X** is able to access both microservices, though
    they reside in different namespaces. Note also that **Pod X** only requires access
    to **Microservice A** in namespace **NS1**. So, is there anything we can do to
    restrict **Pod X''s** access to **Microservice A** only for the purpose of least
    privilege? Yes: a Kubernetes network policy can help. We will cover network policies
    in more detail [*Chapter 5*](B15566_05_Final_ASB_ePub.xhtml#_idTextAnchor144),
    *Configuring Kubernetes Security Boundaries*. In general, a Kubernetes network
    policy defines rules of how a group of pods are allowed to communicate with each
    other and other network endpoints. You can define both ingress rules and egress
    rules for your workload.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，**Pod X**能够访问这两个微服务，尽管它们位于不同的命名空间中。还要注意，**Pod X**只需要访问**NS1**命名空间中的**Microservice
    A**。那么，我们是否可以做一些事情，以限制**Pod X**仅出于最小特权的目的访问**Microservice A**？是的：Kubernetes网络策略可以帮助。我们将在[*第5章*](B15566_05_Final_ASB_ePub.xhtml#_idTextAnchor144)中更详细地介绍网络策略，*配置Kubernetes安全边界*。一般来说，Kubernetes网络策略定义了一组Pod允许如何相互通信以及与其他网络端点通信的规则。您可以为您的工作负载定义入口规则和出口规则。
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Ingress rules: Rules to define which sources are allowed to communicate with
    the pods under the protection of the network policy.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 入口规则：定义哪些来源被允许与受网络策略保护的Pod通信的规则。
- en: 'Egress rules: Rules to define which destinations are allowed to communicate
    with the pods under the protection of the network policy.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 出口规则：定义哪些目的地被允许与受网络策略保护的Pod通信的规则。
- en: 'In the following example, to implement the principle of least privilege in
    **Pod X**, you will need to define a network policy in **Namespace X** with an
    egress rule specifying that only **Microservice A** is allowed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，为了在**Pod X**中实现最小特权原则，您需要在**Namespace X**中定义一个网络策略，其中包含一个出口规则，指定只允许**Microservice
    A**：
- en: '![Figure 4.2 – Network policy blocks access to microservice B'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 - 网络策略阻止对微服务B的访问'
- en: '](image/B15566_04_002.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15566_04_002.jpg)'
- en: Figure 4.2 – Network policy blocks access to microservice B
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - 网络策略阻止对微服务B的访问
- en: In the preceding diagram, the network policy in **Namespace X** blocks any request
    from **Pod X** to **Microservice B**, and **Pod X** can still access **Microservice
    A**, as expected. Defining an egress rule in your network policy will help ensure
    least privilege for your workload to access network resources. Last but not least,
    we still need to bring your attention to the application resource level from a
    least-privilege standpoint.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，**Namespace X**中的网络策略阻止了来自**Pod X**对**Microservice B**的任何请求，而**Pod X**仍然可以访问**Microservice
    A**，这是预期的。在您的网络策略中定义出口规则将有助于确保您的工作负载访问网络资源的最小特权。最后但同样重要的是，我们仍然需要从最小特权的角度关注应用程序资源级别。
- en: Least privilege for accessing application resources
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问应用程序资源的最小特权
- en: Though this topic falls into the category of application security, it is worth
    bringing up here. If there are applications that your workload accesses that support
    multiple users with different levels of privileges, it's better to examine whether
    the privileges granted to the user on your workload's behalf are necessary or
    not. For example, a user who is responsible for auditing does not need any write
    privileges. Application developers should keep this in mind when designing the
    application. This helps to ensure the least privilege for your workload to access
    application resources.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个话题属于应用程序安全的范畴，但在这里提起也是值得的。如果有应用程序允许您的工作负载访问，并支持具有不同特权级别的多个用户，最好检查您的工作负载所代表的用户被授予的特权是否是必要的。例如，负责审计的用户不需要任何写入特权。应用程序开发人员在设计应用程序时应牢记这一点。这有助于确保您的工作负载访问应用程序资源的最小特权。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we went through the concept of least privilege. Then, we discussed
    the security control mechanism in Kubernetes that helps in implementing the principle
    of least privilege in two areas: Kubernetes subjects and Kubernetes workloads.
    It is worth emphasizing the importance of implementing the principle of the principle
    of least privilege holistically. If least privilege is missed in any area, this
    will potentially leave an attack surface wide open.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了最小特权的概念。然后，我们讨论了Kubernetes中的安全控制机制，帮助在两个领域实现最小特权原则：Kubernetes主体和Kubernetes工作负载。值得强调的是，全面实施最小特权原则的重要性。如果在任何领域中都忽略了最小特权，这可能会留下一个攻击面。
- en: 'Kubernetes offers built-in security controls to implement the principle of
    least privilege. Note that it is a process from development to deployment: application
    developers should work with security architects to design the minimum privileges
    for the service accounts associated with the application, as well as the minimum
    capabilities and proper resource allocation. During deployment, DevOps should
    consider using a PodSecurityPolicy and a network policy to enforce least privileges
    across the entire cluster.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了内置的安全控制，以实现最小特权原则。请注意，这是从开发到部署的一个过程：应用程序开发人员应与安全架构师合作，为与应用程序关联的服务账户设计最低特权，以及最低功能和适当的资源分配。在部署过程中，DevOps应考虑使用PodSecurityPolicy和网络策略来强制执行整个集群的最小特权。
- en: 'In the next chapter, we will look at the security of Kubernetes from a different
    angle: understanding the security boundaries of different types of resources and
    how to fortify them.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从不同的角度看待Kubernetes的安全性：了解不同类型资源的安全边界以及如何加固它们。
- en: Questions
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a Role object in Kubernetes?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kubernetes中，什么是Role对象？
- en: What is a RoleBinding object in Kubernetes?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kubernetes中，什么是RoleBinding对象？
- en: What is the difference between RoleBinding and ClusterRoleBinding objects?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RoleBinding和ClusterRoleBinding对象之间有什么区别？
- en: By default, a pod can't access host-level namespaces. Name a few settings that
    allow pods to access host-level namespaces.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Pod无法访问主机级命名空间。列举一些允许Pod访问主机级命名空间的设置。
- en: If you want to restrict pod access to external network resources (for example,
    the internal network or the internet), what you can do?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想限制Pod访问外部网络资源（例如内部网络或互联网），您可以做什么？
- en: Further reading
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You may have noticed that some of the security control mechanisms we talked
    about in this chapter have been around for a long time: SELinux **Multi-Category
    Security/Multi-Level Security** (**MCS/MLS**), AppArmor, seccomp, Linux capabilities,
    and so on. There are already many books or articles introducing these technologies.
    I would encourage you to take a look at the following materials for a better understanding
    of how to use them to achieve the least privilege goal in Kubernetes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们在本章中讨论的一些安全控制机制已经存在很长时间：SELinux多类别安全/多级安全（MCS/MLS），AppArmor，seccomp，Linux功能等。已经有许多书籍或文章介绍了这些技术。我鼓励您查看以下材料，以更好地了解如何使用它们来实现Kubernetes中的最小特权目标：
- en: 'SELinux MCS: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/deployment_guide/sec-mcs-getstarted](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/deployment_guide/sec-mcs-getstarted)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'SELinux MCS: [https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/deployment_guide/sec-mcs-getstarted](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/deployment_guide/sec-mcs-getstarted)'
- en: 'AppArmor: [https://ubuntu.com/server/docs/security-apparmor](https://ubuntu.com/server/docs/security-apparmor)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'AppArmor: [https://ubuntu.com/server/docs/security-apparmor](https://ubuntu.com/server/docs/security-apparmor)'
- en: 'Linux capabilities: [http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux能力：[http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)
- en: 'Help defining RBAC privilege grants: [https://github.com/liggitt/audit2rbac](https://github.com/liggitt/audit2rbac)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助定义RBAC权限授予：[https://github.com/liggitt/audit2rbac](https://github.com/liggitt/audit2rbac)
