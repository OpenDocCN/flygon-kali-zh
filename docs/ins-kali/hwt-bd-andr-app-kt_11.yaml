- en: 11\. Persisting Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11.持久化数据
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter goes in depth about data persistence in Android, as well as exploring
    the repository pattern. By the end of the chapter, you will be able to build a
    repository that can connect to multiple data sources, and then use this repository
    to download files from an API and save them on a device. You will know multiple
    ways to store (persist) data directly on a device and the frameworks accessible
    to do this. When dealing with a filesystem, you will learn how it's partitioned
    and how you can read and write files in different locations and using different
    frameworks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将深入探讨Android中的数据持久性，以及探索存储库模式。在本章结束时，您将能够构建一个可以连接到多个数据源的存储库，然后使用该存储库从API下载文件并将其保存在设备上。您将了解直接在设备上存储（持久化）数据的多种方法以及可用于执行此操作的框架。在处理文件系统时，您将学习其如何分区以及如何在不同位置和使用不同框架中读取和写入文件。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In the previous chapter, you learned how to structure your code and how to
    save data. In the activity, you also had the opportunity to build a repository
    and use it to access data and save data through Room. You probably asked the question:
    Why do you need this repository? This chapter will seek to answer that. With the
    repository pattern, you will be able to retrieve data from a server and store
    it locally in a centralized way. The pattern is useful in situations where the
    same data is required in multiple places, thereby avoiding code duplication while
    also keeping ViewModels clean of any unnecessary extra logic.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了如何构建代码结构以及如何保存数据。在活动中，您还有机会构建一个存储库，并使用它来访问数据并通过Room保存数据。您可能会问：为什么需要这个存储库？本章将试图回答这个问题。通过存储库模式，您将能够以集中的方式从服务器检索数据并将其存储在本地。该模式在需要在多个地方使用相同数据的情况下非常有用，从而避免代码重复，同时还保持ViewModel清除任何不必要的额外逻辑。
- en: If you look into the Settings app on your device, or the Settings feature of
    many apps, you will see some similarities. A list of items with toggles that can
    be on or off. This is achieved through `SharedPreferences` and `PreferenceFragments`.
    `SharedPreferences` is a way that allows you to store values in a file in key-value
    pairs. It has specialized mechanisms for reading and writing, thereby removing
    the concerns regarding threading. It's useful for small amounts of data and eliminates
    the need for something such as Room.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看设备上的设置应用程序或许多应用程序的设置功能，您将看到一些相似之处。一系列带有可以打开或关闭的切换的项目。这是通过`SharedPreferences`和`PreferenceFragments`实现的。`SharedPreferences`是一种允许您以键值对的方式将值存储在文件中的方法。它具有专门的读写机制，从而消除了关于线程的担忧。它对小量数据非常有用，并消除了对诸如Room之类的东西的需求。
- en: In this chapter, you will also learn about the Android filesystem and how it's
    structured into external and internal memory. You'll also develop your understanding
    of read and write permissions, how to create `FileProvider` class in order to
    offer other apps access to your files, and how you can save those files without
    requesting permissions on the external drives. You'll also see how to download
    files from the internet and save them on the filesystem.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您还将了解Android文件系统以及其如何结构化为外部和内部存储器。您还将加深对读取和写入权限的理解，以及如何创建`FileProvider`类以便其他应用程序访问您的文件，以及如何在外部驱动器上保存这些文件而无需请求权限。您还将了解如何从互联网下载文件并将其保存在文件系统中。
- en: Another concept that will be explored in this chapter is using the *Camera*
    application to take photos and videos on your application's behalf and save them
    to external storage using FileProviders.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将探讨的另一个概念是使用*相机*应用程序代表您的应用程序拍摄照片和视频，并使用FileProviders将它们保存到外部存储。
- en: Repository
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储库
- en: 'Repository is a pattern that helps developers keep code for data sources separate
    from activities and ViewModels. It offers centralized access to data that can
    then be unit tested:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库是一种模式，它帮助开发人员将数据源的代码与活动和ViewModel分开。它提供对数据的集中访问，然后可以进行单元测试：
- en: '![Figure 11.1: Diagram of repository architecture'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1：存储库架构图'
- en: '](img/B15216_11_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_11_01.jpg)'
- en: 'Figure 11.1: Diagram of repository architecture'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：存储库架构图
- en: 'In the preceding diagram, you can see the central role the repository plays
    in an application''s code. Its responsibilities include:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，您可以看到存储库在应用程序代码中的核心作用。其职责包括：
- en: Keeping all the data sources (SQLite, Network, File System) required by your
    activity or the application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留活动或应用程序所需的所有数据源（SQLite、网络、文件系统）
- en: Combining and transforming the data from multiple sources into a single output
    required at your activity level
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将来自多个源的数据组合和转换为活动级别所需的单一输出
- en: Transferring data from one data source to another (saving the result of a network
    call to Room)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据从一个数据源传输到另一个数据源（将网络调用的结果保存到Room中）
- en: Refreshing expired data (if necessary)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新过期数据（如果需要）
- en: Room, network layer, and `FileManager` represent the different types of data
    sources your repository can have. Room may be used to save large amounts of data
    from the network, while the filesystem can be used to store small amounts (`SharedPreferences`)
    or whole files.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Room、网络层和`FileManager`代表存储库可以拥有的不同类型的数据源。Room可用于保存来自网络的大量数据，而文件系统可用于存储小量（`SharedPreferences`）或整个文件。
- en: '`ViewModel` will have a reference to your repository and will deliver the results
    to the activity, which will display the result.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel`将引用您的存储库并将结果传递给活动，活动将显示结果。'
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Repositories should be organized based on domains, which means your app should
    have different repositories for different domains and not one giant repository.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库应该根据域进行组织，这意味着您的应用程序应该针对不同的域具有不同的存储库，而不是一个巨大的存储库。
- en: 'Exercise 11.01: Creating a Repository'
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.01：创建存储库
- en: In this exercise, we will create an app in Android Studio that connects to the
    API located at [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)
    using Retrofit and retrieves a list of posts that will then be saved using Room.
    The UI will display the title and the body of each post in `RecyclerView`. We
    will implement this using the repository pattern with `ViewModel`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在Android Studio中创建一个应用程序，该应用程序使用Retrofit连接到位于[https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)的API，并检索一系列帖子，然后使用Room保存。UI将在`RecyclerView`中显示每个帖子的标题和正文。我们将使用`ViewModel`实现存储库模式。
- en: 'In order to complete this exercise, we will need to build the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个练习，我们需要构建以下内容：
- en: A network component responsible for downloading and parsing the JSON file
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责下载和解析JSON文件的网络组件
- en: A Room database responsible for storing the data with one entity
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责使用一个实体存储数据的Room数据库
- en: A repository that manages the data between the components built previously
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理先前构建的组件之间的数据的存储库
- en: A `ViewModel` that accesses the repository
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问存储库的`ViewModel`
- en: An activity with `RecyclerView` model that displays the data
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示数据的带有`RecyclerView`模型的活动
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Let''s begin by adding the `app/build.gradle` folder:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`app/build.gradle`文件夹开始添加。
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will need to group the classes that will deal with the API communication.
    We will do this by creating an `api` package that will contain the classes required
    for networking.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要对处理API通信的类进行分组。我们将通过创建一个包含所需网络类的`api`包来实现这一点。
- en: 'Next, we define a `Post` class, which will map the data in the JSON file. Each
    field in the JSON file representing a post will be defined in our new model:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`Post`类，它将映射JSON文件中的数据。在我们的新模型中，将定义JSON文件中表示帖子的每个字段：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we create a `PostService` interface, which will be responsible for loading
    the data from the server through Retrofit. The class will have one method for
    retrieving the list of posts and will perform an `HTTP GET` call to retrieve the data:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`PostService`接口，负责通过Retrofit从服务器加载数据。该类将具有一个用于检索帖子列表的方法，并将执行`HTTP
    GET`调用以检索数据：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, let's set up our Room database, which will contain one entity and one
    data access object. Let's define a `db` package for this.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们设置我们的Room数据库，其中将包含一个实体和一个数据访问对象。让我们为此定义一个`db`包。
- en: 'The `PostEntity` class will have similar fields to the `Post` class:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PostEntity`类将与`Post`类具有类似的字段：'
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`PostDao` should contain methods for storing a list of posts and retrieving
    the list of posts:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PostDao`应包含用于存储帖子列表和检索帖子列表的方法：'
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And finally, in the case of the Room configuration, the `Post` database should
    look like this:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在Room配置的情况下，`Post`数据库应如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It's time to move into the `Repository` territory. So, let's create a repository package.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候进入`Repository`领域了。因此，让我们创建一个存储库包。
- en: 'Previously, we defined two types of `Post`, one modeled on the JSON and one
    entity. Let''s define a `PostMapper` class that converts from one to the other:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前，我们定义了两种类型的`Post`，一个是基于JSON的模型，一个是实体。让我们定义一个`PostMapper`类，将一个转换为另一个：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s now define a repository interface that will be responsible for loading
    the data. The repository will load the data from the API and store it using Room
    and will then provide `LiveData` with the `Room` entity that the UI layer will
    then consume:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个存储库接口，负责加载数据。存储库将从API加载数据并使用Room存储，然后提供带有UI层将消耗的`Room`实体的`LiveData`：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s provide the implementation for this:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为此提供实现：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you look at the preceding code, you can see that when the posts are loaded,
    we will make an asynchronous call to the network to load the posts. When the call
    finishes, we update Room with a new list of posts on a separate thread. The method
    will always return what Room returns. This is because when the data eventually
    changes in Room, it will be propagated to the observers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看上述代码，您会看到当加载帖子时，我们将异步调用网络以加载帖子。调用完成后，我们将在单独的线程上使用新的帖子列表更新Room。该方法将始终返回Room返回的内容。这是因为当Room中的数据最终发生变化时，它将传播到观察者。
- en: 'Let''s now set up our dependencies. Because we have no dependency injection
    framework, we will have to rely on the `Application` class, which means we will
    need a `RepositoryApplication` class in which we will initialize all the services
    that the repository will require and then create the repository:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们设置我们的依赖关系。因为我们没有依赖注入框架，所以我们将不得不依赖`Application`类，这意味着我们将需要一个`RepositoryApplication`类，在其中我们将初始化存储库所需的所有服务，然后创建存储库：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Add `RepositoryApplication` to `android:name` in the `<application>` tag in
    `AndroidManifest.xml`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RepositoryApplication`添加到`AndroidManifest.xml`中`<application>`标签中的`android:name`。
- en: 'Add internet permission to the `AndroidManifest.xml` file:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将互联网权限添加到`AndroidManifest.xml`文件中：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s now define our `ViewModel`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们定义我们的`ViewModel`：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `view_post_row.xml` layout file for each row will be as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每行的`view_post_row.xml`布局文件将如下所示：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `activity_main.xml` layout file for our activity will be as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们活动的`activity_main.xml`布局文件将如下所示：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `PostAdapter` class for the rows will be as follows:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于行的`PostAdapter`类将如下所示：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And finally, the `MainActivity` file will be as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`MainActivity`文件将如下所示：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you run the preceding code, you will see the following output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行上述代码，您将看到以下输出：
- en: '![Figure 11.2: Output of Exercise 11.01'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2：练习11.01的输出'
- en: '](img/B15216_11_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_11_02.jpg)'
- en: 'Figure 11.2: Output of Exercise 11.01'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：练习11.01的输出
- en: You can now turn the internet on and off and close and re-open the app to see
    that the data that was initially persisted will continue to be displayed. In the
    current implementation, the error handling is left empty for now. This means that
    in case something goes wrong when retrieving the list of posts, the user will
    not be informed of this. This may become a problem and make users frustrated.
    Most applications have some error message or other displayed on their user interface,
    with one of the most common error messages being `Something went wrong. Please
    try again`, which is used as a generic placeholder when the error is not properly identified.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以打开和关闭互联网，关闭和重新打开应用程序，以查看最初持久化的数据是否会继续显示。在当前实现中，错误处理目前为空。这意味着如果在检索帖子列表时出现问题，用户将不会得到通知。这可能会成为一个问题，并使用户感到沮丧。大多数应用程序在其用户界面上显示一些错误消息或其他内容，其中最常见的错误消息之一是“出现问题，请重试”，这是在错误没有被正确识别时用作通用占位符。
- en: 'Exercise 11.02: Adding Error Handling'
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.02：添加错误处理
- en: In this exercise, we will modify the previous exercise. In the case of an internet
    error, we will ensure that it will display a toast with the message *Something
    went wrong*. In the process of adding error handling, we will also need to remove
    the dependency between the UI and the entity classes by creating a new model class
    that will hold the relevant data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将修改之前的练习。在出现互联网错误的情况下，我们将确保它会显示一个带有消息“出现问题”的提示。在添加错误处理的过程中，我们还需要通过创建一个新的模型类来消除UI和实体类之间的依赖，该模型类将保存相关数据。
- en: 'In order to handle the error, we will need to build the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理错误，我们需要构建以下内容：
- en: A new model class containing just the body and text
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的模型类，只包含正文和文本
- en: A sealed class containing three inner classes for success, error, and loading
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含成功、错误和加载三个内部类的密封类
- en: A mapping function between our new model and the network post
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的新模型和网络帖子之间的映射函数
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Let''s start with our new model. This type of model is common when combined
    with the repository pattern and the reason for this is simple. The new models
    may contain data that is specific for this screen that requires some extra logic
    (let''s say you have a user that has `firstName` and `lastName`, but your UI requires
    you to display both in the same `TextView`. By creating a new model with a name
    field, you can solve this issue and also unit test the conversion and avoid moving
    that concatenation on your UI layer):'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从我们的新模型开始。当与存储库模式结合使用时，这种类型的模型很常见，原因很简单。新模型可能包含特定于此屏幕的数据，需要一些额外的逻辑（假设您有一个具有“firstName”和“lastName”的用户，但您的UI要求在同一个“TextView”中显示两者。通过创建一个具有名称字段的新模型，您可以解决此问题，并且还可以对转换进行单元测试，并避免将连接移动到UI层）：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And now to our new sealed class. The subclasses of this sealed class contain
    all the states of the data loading. The `Loading` state will be emitted when the
    repository starts loading the data, the `Success` state will be emitted when the
    repository has successfully loaded the data and contains the list of posts, and
    the `Error` state will be emitted when an error occurs:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来看看我们的新密封类。这个密封类的子类包含了数据加载的所有状态。当存储库开始加载数据时，将发出“加载”状态；当存储库成功加载数据并包含帖子列表时，将发出“成功”状态；当发生错误时，将发出“错误”状态：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The mapping method in `PostMapper` will look like this. It has an extra method
    that will convert the data extract from the API to the UI model, which will only
    have the fields necessary for the UI to be properly displayed:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PostMapper`中的映射方法将如下所示。它有一个额外的方法，将从API中提取的数据转换为UI模型，该模型只包含UI正确显示所需的字段：'
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s modify `PostRepository`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们修改`PostRepository`：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And now let''s modify `PostRepositoryImpl`. Our result will be `MutableLiveData`
    that will begin with the `Loading` value and, based on the status of the HTTP
    request, it will either send a `Success` message with a list of items or an `Error`
    message with the error `Retrofit encountered`. This approach will no longer rely
    on showing the stored values at all times. When the request is successful, the
    output from the HTTP call will be passed instead of the output from Room:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们修改`PostRepositoryImpl`。我们的结果将是`MutableLiveData`，它将以“加载”值开始，并根据HTTP请求的状态，它将发送一个带有项目列表的“成功”消息，或者带有错误“Retrofit遇到”的“错误”消息。这种方法将不再依赖于始终显示存储的值。当请求成功时，将传递HTTP调用的输出，而不是Room的输出：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the activity where you observe the live data, the following changes need
    to be implemented. Here, we will check each state and update the UI accordingly.
    If there is an error, we show an error message; if successful, we show the list
    of items; and when it is loading, we show a progress bar, indicating to the user
    that work is being done in the background:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您观察实时数据的活动中，需要实现以下更改。在这里，我们将检查每个状态并相应地更新UI。如果出现错误，我们显示错误消息；如果成功，我们显示项目列表；当正在加载时，我们显示一个进度条，向用户指示后台正在进行工作：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And finally, your adapter should be as follows:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您的适配器应该如下所示：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you run the preceding code, you should see the screen presented in *Figure 11.3*:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上述代码时，您应该看到*图11.3*中呈现的屏幕：
- en: '![Figure 11.3: Output of Exercise 11.02'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3：练习11.02的输出'
- en: '](img/B15216_11_03.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_11_03.jpg)'
- en: 'Figure 11.3: Output of Exercise 11.02'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：练习11.02的输出
- en: 'From this point on, the repository can be expanded in multiple ways:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，存储库可以以多种方式扩展：
- en: Adding algorithms that will request the data only after a certain time has passed
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加算法，只有在经过一定时间后才会请求数据
- en: Defining a more complex result class that will be able to store the cached data
    as well as an error message
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个更复杂的结果类，该类将能够存储缓存数据以及错误消息
- en: Adding in-memory caching
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加内存缓存
- en: Adding swipe-to-refresh functionality that will refresh the data when `RecyclerView`
    is swiped down and connecting the loading widget to the `Loading` state
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加滑动刷新功能，当“RecyclerView”向下滑动时刷新数据，并将加载小部件连接到“Loading”状态
- en: Preferences
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 偏好设置
- en: 'Imagine you are tasked with integrating a third-party API that uses something
    such as OAuth to implement logging in with Facebook, Google, and suchlike. The
    way these mechanisms work is as follows: they give you a token that you have to
    store locally and that can then be used to send other requests to access user
    data. The questions you''re faced with are: How can you store that token? Do you
    use Room just for one token? Do you save the token in a separate file and implement
    methods for writing the file? What if that file has to be accessed in multiple
    places at the same time? `SharedPreferences` is an answer to these questions.
    `SharedPreferences` is a functionality that allows you to save Booleans, integers,
    floats, longs, strings, and sets of strings into an XML file. When you want to
    save new values, you specify what values you want to save for the associated keys,
    and when you are done, you commit the change, which will trigger the save to the
    XML file in an asynchronous way. The `SharedPreferences` mappings are also kept
    in memory, so that when you want to read these values it''s instantaneous, thereby
    removing the need for an asynchronous call to read the XML file.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的任务是集成使用OAuth等内容的第三方API，以实现使用Facebook、Google等方式进行登录。这些机制的工作方式如下：它们会给您一个令牌，您必须将其存储在本地，然后可以使用它发送其他请求以访问用户数据。您面临的问题是：您如何存储该令牌？您是否只使用Room存储一个令牌？您是否将令牌保存在单独的文件中，并实现用于编写文件的方法？如果必须同时访问该文件的多个位置怎么办？“SharedPreferences”是这些问题的答案。“SharedPreferences”是一种功能，允许您将布尔值、整数、浮点数、长整型、字符串和字符串集保存到XML文件中。当您想要保存新值时，您指定要为关联键保存哪些值，完成后，您提交更改，这将以异步方式触发将更改保存到XML文件中。“SharedPreferences”映射也保存在内存中，因此当您想要读取这些值时，它是瞬时的，从而消除了读取XML文件的异步调用的需要。
- en: The standard way of accessing `SharedPreferences` data is through the `SharedPreferences`
    objects and the more recent `EncryptedSharedPreferences` option (if you wish to
    keep your data encrypted). There is also a specialized implementation through
    `PreferenceFragments`. These are useful in situations where you want to implement
    a settings-like screen where you want to store different configuration data that
    the user wishes to adjust.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 访问“SharedPreferences”数据的标准方式是通过“SharedPreferences”对象和更近期的“EncryptedSharedPreferences”选项（如果您希望保持数据加密）。还有一种通过“PreferenceFragments”的专门实现。在您想要实现类似设置的屏幕，并且希望存储用户希望调整的不同配置数据的情况下，这些是有用的。
- en: SharedPreferences
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SharedPreferences
- en: 'The way to access the `SharedPreference` object is through the `Context` object:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 访问“SharedPreference”对象的方式是通过“Context”对象：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first parameter is where you specify the name of your preferences, and the
    second is how you want to expose the file to other apps. Currently, the best mode
    is the private one. All of the others present potential security risks.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是您指定偏好名称的地方，第二个是您希望如何将文件暴露给其他应用程序。目前，最佳模式是私有模式。其他所有模式都存在潜在的安全风险。
- en: 'There is a specialized implementation for accessing the default `SharedPreferences`
    file, which is used by `PreferenceFragment`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种专门的实现用于访问默认的“SharedPreferences”文件，这是由“PreferenceFragment”使用的。
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you want to write data into your preferences file, you first need to get
    access to the Preferences editor. The editor will give you access to writing the
    data. You can then write your data in the editor. Once you finish writing, you
    will have to apply the changes that will trigger persistence to the XML file and
    will change the in-memory values as well. You have two choices for applying the
    changes on your preference file: `apply` or `commit`. `apply` will save your changes
    in memory instantly, but then the writing to the disk will be asynchronous, which
    is good if you want to call this from your app''s main thread. `commit` does everything
    synchronously and gives you a boolean result informing you if the operation was
    successful. In practice, `apply` tends to be favored over `commit`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将数据写入偏好文件，首先需要访问偏好编辑器。编辑器将允许您访问写入数据。然后可以在编辑器中写入数据。完成写入后，必须应用更改，这将触发将数据持久保存到XML文件，并同时更改内存中的值。对于应用偏好文件上的更改，您有两种选择：“apply”或“commit”。
    “apply”将立即保存更改到内存中，但然后写入磁盘将是异步的，这对于您想从应用程序的主线程调用此操作是有利的。 “commit”会同步执行所有操作，并给您一个布尔结果，通知您操作是否成功。在实践中，“apply”往往优于“commit”。
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, you want to clear your entire data. The same principle will apply; you''ll
    need the `editor`, `clear`, and `apply`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您想要清除所有数据。同样的原则将适用；您需要“editor”、“clear”和“apply”：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you want to read the values you previously saved, you can use the `SharedPreferences`
    object to read the stored values. In case there is no saved value, you can opt
    for a default value to be returned instead.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要读取先前保存的值，可以使用“SharedPreferences”对象读取存储的值。如果没有保存的值，可以选择返回默认值。
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Exercise 11.03: Wrapping SharedPreferences'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.03：包装SharedPreferences
- en: We're going to build an application that displays `TextView`, `EditText`, and
    a button. `TextView` will display the previous saved value in `SharedPreferences`.
    The user can type new text, and when the button is clicked, the text will be saved
    in `SharedPreferences` and `TextView` will display the updated text. We will need
    to use `ViewModel` and `LiveData` in order to make the code more testable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个应用程序，显示“TextView”、“EditText”和一个按钮。“TextView”将显示在“SharedPreferences”中保存的先前值。用户可以输入新文本，当单击按钮时，文本将保存在“SharedPreferences”中，“TextView”将显示更新后的文本。为了使代码更具可测试性，我们需要使用“ViewModel”和“LiveData”。
- en: 'In order to complete this exercise, we will need to create a `Wrapper` class,
    which will be responsible for saving the text. This class will return the value
    of the text as `LiveData`. This will be injected into our `ViewModel`, which will
    be bound to the activity:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个练习，我们需要创建一个`Wrapper`类，它将负责保存文本。这个类将以`LiveData`的形式返回文本的值。这将被注入到我们的`ViewModel`中，并绑定到活动中：
- en: 'Let''s begin by adding the appropriate libraries to `app/build.gradle`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先将适当的库添加到`app/build.gradle`中：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s make our `Wrapper` class, which will listen for changes in `SharedPreferences`
    and update the value of `LiveData` when the preferences change. The class will
    contain methods to save the new text and to retrieve `LiveData`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们制作我们的`Wrapper`类，它将监听`SharedPreferences`的更改，并在偏好更改时更新`LiveData`的值。该类将包含保存新文本和检索`LiveData`的方法：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice the top of the file. We've added a listener so that when our `SharedPreferences`
    values change, we can look up the new value and update our `LiveData` model. This
    will allow us to observe the `LiveData` for any changes and just update the UI.
    The `saveText` method will open the editor, set the new value, and apply the changes.
    The `getText` method will read the last saved value, set it in `LiveData`, and
    return the `LiveData` object. This is helpful in scenarios where the app is opened
    and we want to access the last value prior to the app closing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件顶部。我们添加了一个监听器，这样当我们的`SharedPreferences`值改变时，我们可以查找新值并更新我们的`LiveData`模型。这将允许我们观察`LiveData`的任何更改并只更新UI。`saveText`方法将打开编辑器，设置新值并应用更改。`getText`方法将读取上次保存的值，在`LiveData`中设置它，并返回`LiveData`对象。这在应用程序打开并且我们想要在应用程序关闭之前访问上次的值时非常有用。
- en: 'Now, let''s set up the `Application` class with the instance of the preferences:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用偏好设置的实例设置`Application`类：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s add the appropriate attributes in the `application` tag to `AndroidManifest.xml`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`AndroidManifest.xml`的`application`标签中添加适当的属性：
- en: '[PRE31]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And now, let''s build the `ViewModel` component:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们构建`ViewModel`组件：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, let''s define our `activity_main.xml` layout file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们定义我们的`activity_main.xml`布局文件：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And finally, in `MainActivity`, perform the following steps:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`MainActivity`中执行以下步骤：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding code will produce the output presented in *Figure 11.4*:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生*图11.4*中呈现的输出：
- en: '![Figure 11.4: Output of Exercise 11.03'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4：练习11.03的输出'
- en: '](img/B15216_11_04.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_11_04.jpg)'
- en: 'Figure 11.4: Output of Exercise 11.03'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：练习11.03的输出
- en: Once you insert a value, try closing the application and re-opening it. The
    app will display the last persisted value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 插入值后，尝试关闭应用程序并重新打开它。应用程序将显示上次持久化的值。
- en: PreferenceFragment
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PreferenceFragment
- en: As mentioned previously, `PreferenceFragment` is a specialized implementation
    of a fragment that relies on `SharedPreferences` in order to store user settings.
    Its features include storing Booleans based on on/off toggles, storing text based
    on dialogs displayed to the user, storing string sets based on single and multi-choice
    dialogs, storing integers based on `SeekBars`, and categorizing the sections and
    linking to other `PreferenceFragment` classes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`PreferenceFragment`是依赖于`SharedPreferences`来存储用户设置的片段的专门实现。其功能包括基于开/关切换存储布尔值，基于向用户显示的对话框存储文本，基于单选和多选对话框存储字符串集，基于`SeekBars`存储整数，并对部分进行分类并链接到其他`PreferenceFragment`类。
- en: While `PreferenceFragment` classes are part of the Android framework, they are
    marked as deprecated, which means that the recommended approach for fragments
    is to rely on the Jetpack Preference library, which introduces `PreferenceFragmentCompat`.
    `PreferenceFragmentCompat` is useful for ensuring backward compatibility between
    newer Android frameworks and older ones.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`PreferenceFragment`类是Android框架的一部分，但它们被标记为已弃用，这意味着片段的推荐方法是依赖于Jetpack Preference库，该库引入了`PreferenceFragmentCompat`。`PreferenceFragmentCompat`对确保新的Android框架和旧的Android框架之间的向后兼容性非常有用。
- en: 'In order to build a `PreferenceFragment` class, two things are required:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 构建`PreferenceFragment`类需要两个东西：
- en: A resource in the `res/xml` folder, where the structure of your preferences
    will be structured
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res/xml`文件夹中的资源，其中包含偏好设置的结构'
- en: A class extending `PreferenceFragment`, which will link the XML file with the fragment
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个扩展`PreferenceFragment`的类，它将XML文件与片段链接起来
- en: If you want to access the values that your `PreferenceFragment` stored from
    non-`PreferenceFragment` resources, you can access the `SharedPreference` object
    using the `PreferenceManager.getDefaultSharedPreferences(context)` method. The
    keys to accessing the values are the keys you defined in the XML file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从非`PreferenceFragment`资源访问您的`PreferenceFragment`存储的值，可以使用`PreferenceManager.getDefaultSharedPreferences(context)`方法访问`SharedPreference`对象。访问值的键是您在XML文件中定义的键。
- en: 'An example of a preference XML file named settings_preference.xml would look
    something like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 名为settings_preference.xml的偏好XML文件示例如下：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: For every preference, you have the ability to show icons, a title, a summary,
    a current value, and whether it's selectable. An important thing is the key and
    how to link it to your Kotlin code. You can use the `strings.xml` file to declare
    non-translatable strings, which you can then extract in your Kotlin code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个偏好设置，您可以显示图标、标题、摘要、当前值以及它是否可选择。一个重要的事情是键以及如何将其链接到您的Kotlin代码。您可以使用`strings.xml`文件声明不可翻译的字符串，然后在您的Kotlin代码中提取它们。
- en: 'Your `PreferenceFragment` will look similar to this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`PreferenceFragment`将类似于这样：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `onCreatePreferences` method is abstract, and you will need to implement
    it in order to specify the XML resource for your preferences through the `setPreferencesFromResource`
    method.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreatePreferences`方法是抽象的，您需要实现它以通过`setPreferencesFromResource`方法指定偏好设置的XML资源。'
- en: 'You can also access the preferences programmatically using the `findPreference` method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`findPreference`方法以编程方式访问偏好设置：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will return an object that will extend from `Preference`. The nature of
    the object should match the type declared in the XML for that particular key.
    You can modify the `Preference` object programmatically and change the desired
    fields.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个将从`Preference`扩展的对象。对象的性质应与在XML中为该特定键声明的类型匹配。您可以以编程方式修改`Preference`对象并更改所需的字段。
- en: 'You can also build a Settings screen programmatically using `createPreferenceScreen(Context)`
    on the `PreferenceManager` class that''s inherited in `PreferenceFragment`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`PreferenceFragment`中继承的`PreferenceManager`类上的`createPreferenceScreen(Context)`来以编程方式构建设置屏幕：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can use the `addPreference(Preference)` method on the `PreferenceScreen`
    container to add a new `Preference` object:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`PreferenceScreen`容器上使用`addPreference(Preference)`方法添加新的`Preference`对象：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's now move on to the next exercise to customize your settings.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续下一个练习，自定义您的设置。
- en: 'Exercise 11.04: Customized Settings'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.04：自定义设置
- en: 'In this exercise, we''re going to build the settings for a VPN app. The product
    requirements for the settings page are as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将构建VPN应用的设置。设置页面的产品要求如下：
- en: '`SeekBar`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SeekBar`'
- en: '**Configuration**: IP address – Text; Domain – Text'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：IP地址 - 文本；域 - 文本'
- en: '`Use mobile data`, with a toggle and a non-selectable option below containing
    the text `Manage your mobile data wisely`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`使用移动数据`，带有一个切换和一个下面包含文本`明智地管理您的移动数据`的不可选择选项。'
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Let''s start by adding the Jetpack Preference library:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先添加Jetpack Preference库：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In `res/values`, create a file named `preference_keys.xml` and let''s define
    the key for the `More preferences` screen:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/values`中，创建一个名为`preference_keys.xml`的文件，并定义`More preferences`屏幕的键：
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Create the `xml` folder in `res` if it's not available.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`res`中没有`xml`文件夹，请创建一个。
- en: Create the `preferences_more.xml` file in the `res/xml` folder.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/xml`文件夹中创建`preferences_more.xml`文件。
- en: 'In the `preferences_more.xml` file, add the following preferences:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`preferences_more.xml`文件中，添加以下首选项：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In `strings.xml`, add the following strings:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`strings.xml`中，添加以下字符串：
- en: '[PRE43]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a `PreferenceFragment` class called `MorePreferenceFragment`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MorePreferenceFragment`的`PreferenceFragment`类：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We are done with the `More` section. Let's now create the main section.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了`More`部分。现在让我们创建主要部分。
- en: 'Let''s create the keys for the main preference section. In `preference_keys.xml`,
    add the following:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为主要首选项部分创建键。在`preference_keys.xml`中，添加以下内容：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In `res/xml`, create the `preferences_settings.xml` file.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/xml`中，创建`preferences_settings.xml`文件。
- en: 'Now, define your preferences according to the specs:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，根据规格定义您的首选项：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In `strings.xml`, make sure you have the following values:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`strings.xml`中，确保您有以下值：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Create a fragment called `SettingsPreferenceFragment`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SettingsPreferenceFragment`的片段。
- en: 'Add the following setup:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下设置：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, let's add `Fragments` to our activity.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将`Fragments`添加到我们的活动中。
- en: 'In `activity_main.xml`, define a `FrameLayout` tag to contain the fragments:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`activity_main.xml`中，定义一个`FrameLayout`标签来包含片段：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And finally, in `MainActivity`, perform the following steps:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`MainActivity`中执行以下步骤：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Running the preceding code will produce the following output:![Figure 11.5:
    Output of Exercise 11.04'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上述代码将产生以下输出：![图11.5：练习11.04的输出
- en: '](img/B15216_11_05.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_11_05.jpg)'
- en: 'Figure 11.5: Output of Exercise 11.04'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：练习11.04的输出
- en: We can now monitor the changes to preferences and display them in the UI. We
    can apply this functionality to the IP address and domain sections to display
    what the user typed as a summary.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以监视首选项的更改并在UI中显示它们。我们可以将此功能应用于IP地址和域部分，以显示用户输入的摘要。
- en: 'Let''s now modify `SettingsPreferenceFragment` to programmatically set a listener
    for when values change, which will display the new value in the summary. We will
    also need to set the saved values when the screen is first opened. We will need
    to locate preferences we want to modify using `findPreference(key)`. This allows
    us to programmatically modify a preference. We can also register listeners on
    the preference, which will give us access to the new value. In our case, we can
    register a listener for when the IP address changes, so we can update the summary
    of the field based on what was introduced in `EditText` by the user:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们修改`SettingsPreferenceFragment`，以便在值更改时以编程方式设置监听器，这将在摘要中显示新值。当首次打开屏幕时，我们还需要设置保存的值。我们需要使用`findPreference(key)`来定位我们想要修改的首选项。这允许我们以编程方式修改首选项。我们还可以在首选项上注册监听器，这将使我们能够访问新值。在我们的情况下，我们可以注册一个监听器，以便在IP地址更改时更新字段的摘要，这样我们就可以根据用户在`EditText`中输入的内容更新字段的摘要：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`PreferenceFragment` is a good way of building settings-like functionality
    for any application. Its integration with `SharedPreferences` and built-in UI
    components allow developers to build elements quicker than usual and solve many
    issues with regard to handling the clicks and elements inserted for each setting
    element.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreferenceFragment`是为任何应用构建类似设置功能的好方法。它与`SharedPreferences`的集成和内置UI组件允许开发人员比通常更快地构建元素，并解决处理每个设置元素的点击和插入的许多问题。'
- en: Files
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件
- en: 'We''ve discussed Room and `SharedPreferences` and specified how the data they
    store is written to files. You may ask yourself, where are these files stored?
    These particular files are stored in internal storage. Internal storage is a dedicated
    space for every app that other apps are unable to access (unless the device is
    rooted). There is no limit to the amount of storage your app uses. However, users
    have the ability to delete your app''s files from the Settings menu. Internal
    storage occupies a smaller part of the total available space, which means that
    you should be careful when it comes to storing files in internal storage. There
    is also external storage. The files your app stores are accessible to other apps
    and the files from other apps are accessible to your app:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Room和`SharedPreferences`，并指定了它们存储的数据是如何写入文件的。您可能会问自己，这些文件存储在哪里？这些特定的文件存储在内部存储中。内部存储是每个应用程序的专用空间，其他应用程序无法访问（除非设备已root）。您的应用程序使用的存储空间没有限制。但是，用户可以从“设置”菜单中删除您的应用程序文件的能力。内部存储占用总可用空间的一小部分，这意味着在存储文件时应该小心。还有外部存储。您的应用程序存储的文件可供其他应用程序访问，其他应用程序存储的文件也可供您的应用程序访问：
- en: Note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In Android Studio, you can use the Device File Explorer tool to navigate through
    the files on the device or emulator. Internal storage is located in `/data/data/{packageName}`.
    If you have access to this folder, this means that the device is rooted. Using
    this, you can visualize the database files and the `SharedPreferences` files.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中，您可以使用设备文件浏览器工具浏览设备或模拟器上的文件。内部存储位于`/data/data/{packageName}`。如果您可以访问此文件夹，这意味着设备已经root。使用这个，您可以可视化数据库文件和`SharedPreferences`文件。
- en: '![Figure 11.6: Android Device File Explorer'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6：Android设备文件浏览器'
- en: '](img/B15216_11_06.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_11_06.jpg)'
- en: 'Figure 11.6: Android Device File Explorer'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：Android设备文件浏览器
- en: Internal Storage
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部存储
- en: 'Internal storage requires no permissions from the user. To access the internal
    storage directories, you can use one of the following methods from the `Context`
    object:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 内部存储不需要用户的权限。要访问内部存储目录，可以使用`Context`对象的以下方法之一：
- en: '`getDataDir()`: Returns the root folder of your application sandbox.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDataDir()`: 返回应用沙盒的根文件夹。'
- en: '`getFilesDir()`: A dedicated folder for application files; recommended for usage.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFilesDir()`: 一个专门用于应用文件的文件夹；推荐使用。'
- en: '`getCacheDir()`: A dedicated folder where files can be cached. Storing files
    here does not guarantee that you can retrieve them later because the system may
    decide to delete this directory to free memory. This folder is linked to the `Clear
    Cache` option in `Settings`.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCacheDir()`: 一个专门用于缓存文件的文件夹。在这里存储文件并不保证以后可以检索到它们，因为系统可能决定删除此目录以释放内存。这个文件夹与“设置”中的“清除缓存”选项相关联。'
- en: '`getDir(name, mode)`: Returns a folder that will be created if it does not
    exist based on the name specified.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDir(name, mode)`: 返回一个文件夹，如果不存在则根据指定的名称创建。'
- en: When users use the `Clear Data` option from `Settings`, most of these folders
    will be deleted, bringing the app to a similar state as a fresh install. When
    the app is uninstalled, then these files will be deleted as well.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户从“设置”中使用“清除数据”选项时，大多数这些文件夹将被删除，使应用程序回到类似于新安装的状态。当应用被卸载时，这些文件也将被删除。
- en: 'A typical example of reading a cache file is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 读取缓存文件的典型示例如下：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The preceding example will read from `my-file.txt`, located in the `Cache` directory,
    and will create `FileInputStream` for that file. Then, a buffer will be used that
    will collect the bytes from the file. The collected bytes will be placed in the
    `bytes` byte array, which will contain all of the data read from that file. Reading
    will stop when the entire length of the file has been read.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例将从“Cache”目录中的“my-file.txt”读取，并为该文件创建`FileInputStream`。然后，将使用一个缓冲区来收集文件中的字节。收集到的字节将被放入`bytes`字节数组中，其中包含从该文件中读取的所有数据。当文件的整个长度被读取时，读取将停止。
- en: 'Writing to the `my-file.txt` file will look something like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 写入`my-file.txt`文件将如下所示：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: What the preceding example does is take the byte array you want to write, create
    a new `File` object, create the file if it doesn't exist, and write the bytes
    into the file through `FileOutputStream`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例所做的是获取要写入的字节数组，创建一个新的`File`对象，如果不存在则创建文件，并通过`FileOutputStream`将字节写入文件。
- en: Note
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are many alternatives to dealing with files. The readers (`StreamReader`,
    `StreamWriter`, and so on) are better equipped for character-based data. There
    are also third-party libraries that help with disk I/O operations. One of the
    most common third parties that help with I/O operations is called Okio. It started
    life as part of the `OkHttp` library, which is used in combination with Retrofit
    to make API calls. The methods provided by Okio are the same methods it uses to
    write and read data in HTTP communications.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 处理文件有许多替代方法。读取器（`StreamReader`，`StreamWriter`等）更适合基于字符的数据。还有第三方库可以帮助进行磁盘I/O操作。其中一个最常见的帮助进行I/O操作的第三方是Okio。它起初是`OkHttp`库的一部分，用于与Retrofit一起进行API调用。Okio提供的方法与它用于在HTTP通信中写入和读取数据的方法相同。
- en: External Storage
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部存储
- en: Reading and writing in external storage requires user permissions for reading
    and writing. If write permission is granted, then your app has the ability to
    read the external storage. Once these permissions are granted, then your app can
    do whatever it pleases on the external storage. That may present a problem because
    users may not choose to grant these permissions. However, there are specialized
    methods that offer you the possibility to write on the external storage in folders
    dedicated to your application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在外部存储中读写需要用户的读写权限。如果授予写入权限，则您的应用程序可以读取外部存储。一旦这些权限被授予，您的应用程序就可以在外部存储上做任何它想做的事情。这可能会带来问题，因为用户可能不选择授予这些权限。然而，有专门的方法可以让您在专门为您的应用程序提供的外部存储中进行写入。
- en: 'Some of the most common ways of accessing external storage are from the `Context`
    and `Environment` objects:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Context`和`Environment`对象中访问外部存储的一些常见方式是：
- en: '`Context.getExternalFilesDir(mode)`: This method will return the path to the
    directory on the external storage dedicated to your application. Specifying different
    modes (pictures, movies, and so on) will create different subfolders depending
    on how you want your files saved. This method *does not require permissions*.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getExternalFilesDir(mode)`：这个方法将返回专门为你的应用程序在外部存储上的目录路径。指定不同的模式（图片、电影等）将创建不同的子文件夹，具体取决于你希望如何保存你的文件。这个方法*不需要权限*。'
- en: '`Context.getExternalCacheDir()`: This will point toward the application''s
    cache directory on the external storage. The same considerations should be applied
    to this `cache` folder as to the internal storage option. This method *does not
    require permissions*.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getExternalCacheDir()`：这将指向外部存储上应用程序的缓存目录。对这个`cache`文件夹应用相同的考虑。这个方法*不需要权限*。'
- en: The `Environment` class has access to paths of some of the most common folders
    on the device. However, on newer devices, apps may not have access to those files
    and folders.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Environment`类可以访问设备上一些最常见文件夹的路径。然而，在新设备上，应用可能无法访问这些文件和文件夹。'
- en: Note
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Avoid using hardcoded paths to files and folders. The Android operating system
    may shift the location of folders around depending on the device or operating
    system.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用硬编码的文件和文件夹路径。安卓操作系统可能会根据设备或操作系统的不同而改变文件夹的位置。
- en: FileProvider
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FileProvider
- en: This represents a specialized implementation of `ContentProviders` that is useful
    in organizing the file and folder structure of your application. It allows you
    to specify an XML file in which you define how your files should be split between
    internal and external storage if you choose to do so. It also gives you the ability
    to grant access to other apps to your files by hiding the path and generating
    a unique URI to identify and query your file.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了`ContentProviders`的一个专门实现，有助于组织应用程序的文件和文件夹结构。它允许你指定一个XML文件，在其中定义你的文件应该如何在内部和外部存储之间分割。它还让你有能力通过隐藏路径并生成一个唯一的URI来授予其他应用程序对你的文件的访问权限。
- en: '`FileProvider` gives you the choice to pick between six different folders where
    you can set up your folder hierarchies:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileProvider`让你可以在六个不同的文件夹中选择设置你的文件夹层次结构：'
- en: '`Context.getFilesDir()` (files-path)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getFilesDir()`（文件路径）'
- en: '`Context.getCacheDir()` (cache-path)'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getCacheDir()`（缓存路径）'
- en: '`Environment.getExternalStorageDirectory()` (external-path)'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Environment.getExternalStorageDirectory()`（外部路径）'
- en: '`Context.getExternalFilesDir(null)` (external-files-path)'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getExternalFilesDir(null)`（外部文件路径）'
- en: '`Context.getExternalCacheDir()` (external-cache-path)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getExternalCacheDir()`（外部缓存路径）'
- en: First result of `Context.getExternalMediaDirs()` (external-media-path)
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Context.getExternalMediaDirs()`的第一个结果（外部媒体路径）'
- en: The main benefits of `FileProvider` are the abstractions it provides in organizing
    your files since leaving the developer to define the paths in an XML file and,
    more importantly, if you chose to use it to store files on the external storage,
    you do not have to ask for permissions from the user. Another benefit is the fact
    that it makes sharing of internal files easier while giving the developer control
    of what files other apps can access without exposing their real location.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`FileProvider`的主要优点在于它提供了对文件的抽象，因为它让开发人员在XML文件中定义路径，并且更重要的是，如果你选择将文件存储在外部存储上，你不需要向用户请求权限。另一个好处是它使共享内部文件更容易，同时让开发人员控制其他应用程序可以访问哪些文件，而不会暴露它们的真实位置。'
- en: 'Let us understand better through the following example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下例子更好地理解：
- en: '[PRE54]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The preceding example will make `FileProvider` use the internal `files` directory
    and create a folder named `my-folder-name`. When the path is converted to a URI,
    then the URI will use `my-visible-name`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子将使`FileProvider`使用内部的`files`目录，并创建一个名为`my-folder-name`的文件夹。当路径转换为URI时，URI将使用`my-visible-name`。
- en: Storage Access Framework (SAF)
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储访问框架（SAF）
- en: 'The SAF is a file picker introduced in Android KitKat that apps can use for
    their users to pick files with a view to being processed or uploaded. You can
    use it in your app for the following scenarios:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: SAF是在Android KitKat中引入的文件选择器，应用程序可以使用它让用户选择要处理或上传的文件。你可以在你的应用程序中使用它来处理以下情况：
- en: Your app requires the user to process a file saved on the device by another
    app (photos and videos).
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的应用程序需要用户处理由其他应用程序保存在设备上的文件（照片和视频）。
- en: You want to save a file on the device and give the user the choice of where
    they want the file to be saved and the name of the file.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你希望在设备上保存一个文件，并让用户选择文件的保存位置和文件的名称。
- en: You want to offer the files your application uses to other apps for scenarios
    similar to scenario number 1.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你希望为你的应用程序使用的文件提供给其他应用程序，以满足类似于第1种情况的场景。
- en: This is again useful because your app will avoid read and write permissions
    and still write and access external storage. The way this works is based on intents.
    You can start an activity for a result with `Intent.ACTION_OPEN_DOCUMENT` or `Intent.ACTION_CREATE_DOCUMENT`.
    Then, in `onActivityResult`, the system will give you a URI that grants you temporary
    permissions to that file, allowing you to read and write.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这再次有用，因为你的应用程序将避免读写权限，但仍然可以写入和访问外部存储。这是基于意图的工作方式。你可以使用`Intent.ACTION_OPEN_DOCUMENT`或`Intent.ACTION_CREATE_DOCUMENT`启动一个活动以获取结果。然后，在`onActivityResult`中，系统将给你一个URI，授予你对该文件的临时权限，允许你读写。
- en: Another benefit of the SAF is the fact that the files don't have to be on a
    device. Apps such as Google Drive expose their content in the SAF and when a Google
    Drive file is selected, it will be downloaded to the device and the URI will be
    sent as a result. Another important thing to mention is the SAF's support for
    virtual files, meaning that it will expose Google docs, which have their own format,
    but when those docs are downloaded through the SAF, their formats will be converted
    to a common format such as PDF.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: SAF的另一个好处是文件不必在设备上。诸如谷歌云这样的应用程序在SAF中公开其内容，当选择谷歌云文件时，它将被下载到设备，并且URI将作为结果发送。另一个重要的事情是SAF对虚拟文件的支持，这意味着它将公开谷歌文档，这些文档有自己的格式，但是当这些文档通过SAF下载时，它们的格式将被转换为PDF等通用格式。
- en: Asset Files
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产文件
- en: Asset files are files you can package as part of your APK. If you've used apps
    that played certain videos or GIFs when the app is launched or as part of a tutorial,
    odds are that the videos were bundled with the APK. To add files to your assets,
    you need the `assets` folder inside your project. You can then group your files
    inside your assets using folders.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 资产文件是您可以打包为APK的文件。如果您使用过在应用程序启动时或作为教程的一部分播放某些视频或GIF的应用程序，那么这些视频很可能已经与APK捆绑在一起。要将文件添加到资产中，您需要项目中的`assets`文件夹。然后，您可以使用文件夹将文件分组到资产中。
- en: 'You can access these files at runtime through the `AssetManager` class, which
    itself can be accessed through the context object. `AssetManager` offers you the
    ability to look up the files and read them, but it does not permit any write operations:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`AssetManager`类在运行时访问这些文件，`AssetManager`本身可以通过上下文对象访问。`AssetManager`为您提供了查找文件和读取文件的能力，但不允许任何写操作：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding example lists all files inside the root of the `assets` folder.
    The `open` function returns `inputStream`, which can be used to read the file
    information if necessary.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例列出了`assets`文件夹根目录中的所有文件。`open`函数返回`inputStream`，如果需要，可以用它来读取文件信息。
- en: One common usage of the `assets` folder is for custom fonts. If your application
    uses custom fonts, then you can use the `assets` folder to store font files.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`assets`文件夹的一个常见用途是用于自定义字体。如果您的应用程序使用自定义字体，那么可以使用`assets`文件夹来存储字体文件。'
- en: 'Exercise 11.05: Copying Files'
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.05：复制文件
- en: Note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For this exercise, you will need an emulator. You can do so by selecting the
    `Tools` | `AVD Manager` in Android Studio. Then, you can create one with the `Create
    Virtual Device` option, selecting the type of emulator, clicking `Next`, and then
    selecting an x86 image. Any image larger than Lollipop should be acceptable for
    this exercise. Next, you can give your image a name and click `Finish`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，您将需要一个模拟器。您可以在Android Studio中选择`Tools` | `AVD Manager`来创建一个。然后，您可以使用`Create
    Virtual Device`选项创建一个，选择模拟器类型，单击`Next`，然后选择x86映像。大于棒棒糖的任何映像都应该适用于这个练习。接下来，您可以给您的映像命名并单击`Finish`。
- en: Let's create an app that will keep a file named `my-app-file.txt` in the `assets`
    directory. The app will display two buttons called `FileProvider` and `SAF`. When
    the `FileProvider` button is clicked, the file will be saved on the external storage
    inside the app's external storage dedicated area (`Context.getExternalFilesDir(null)`).
    The `SAF` button will open the SAF and allow the user to indicate where the file
    should be saved.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个应用程序，将在`assets`目录中保留一个名为`my-app-file.txt`的文件。该应用程序将显示两个名为`FileProvider`和`SAF`的按钮。单击`FileProvider`按钮时，文件将保存在应用程序的外部存储专用区域（`Context.getExternalFilesDir(null)`）。`SAF`按钮将打开SAF，并允许用户指示文件应保存在何处。
- en: 'In order to implement this exercise, the following approach will be adopted:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个练习，将采用以下方法：
- en: Define a file provider that will use the `Context.getExternalFilesDir(null)`
    location.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个文件提供程序，它将使用`Context.getExternalFilesDir(null)`位置。
- en: Copy `my-app-file.txt` to the preceding location when the `FileProvider` button
    is clicked.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击`FileProvider`按钮时，将`my-app-file.txt`复制到前面的位置。
- en: Use `Intent.ACTION_CREATE_DOCUMENT` when the `SAF` button is clicked and copy
    the file to the location provided.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击`SAF`按钮时使用`Intent.ACTION_CREATE_DOCUMENT`，并将文件复制到提供的位置。
- en: Use a separate thread for the file copy to comply with the Android guidelines.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为文件复制使用单独的线程，以符合Android指南。
- en: Use the Apache IO library to help with the file copy functionality, by providing
    methods that allow us to copy data from an InputStream to an OutputStream.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache IO库来帮助文件复制功能，提供允许我们从InputStream复制数据到OutputStream的方法。
- en: 'The steps for completion are as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的步骤如下：
- en: 'Let''s start with our Gradle configuration:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从Gradle配置开始：
- en: '[PRE56]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Create the `my-app-file.txt` file in the `main/assets` folder. Feel free to
    fill it up with the text you want to be read. If the `main/assets` folder doesn't
    exist, then you can create it. In order to create the `assets` folder, you can
    right-click on the `main` folder and select `New` and then select `Directory`
    and name it `assets`. This folder will now be recognized by the build system and
    any file inside it will also be installed on the device along with the app.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main/assets`文件夹中创建`my-app-file.txt`文件。随意填写您想要阅读的文本。如果`main/assets`文件夹不存在，则可以创建它。要创建`assets`文件夹，可以右键单击`main`文件夹，然后选择`New`，然后选择`Directory`并命名为`assets`。此文件夹现在将被构建系统识别，并且其中的任何文件也将与应用程序一起安装在设备上。
- en: 'We can also define a class that will wrap `AssetManager` and define a method
    to access this particular file:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以定义一个类，它将包装`AssetManager`并定义一个访问这个特定文件的方法：
- en: '[PRE57]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, let''s work on the `FileProvider` aspect. Create the `xml` folder in the
    `res` folder. Define `file_provider_paths.xml` inside the new folder. We will
    define `external-files-path`, name it `docs`, and place it in the `docs/` folder:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们来处理`FileProvider`方面。在`res`文件夹中创建`xml`文件夹。在新文件夹中定义`file_provider_paths.xml`。我们将定义`external-files-path`，命名为`docs`，并将其放在`docs/`文件夹中：
- en: '[PRE58]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we need to add `FileProvider` to the `AndroidManifest.xml` file and link
    it with the new path we defined:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将`FileProvider`添加到`AndroidManifest.xml`文件中，并将其与我们定义的新路径链接起来：
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The name will point to the `FileProvider` path that's part of the Android Support
    library. The authorities field represents the domain your application has (usually
    the package name of the application). The exported field indicates if we wish
    to share our provider with other apps, and `grantUriPermissions` indicates if
    we wish to grant other applications access to certain files through the URI. The
    meta-data links the XML file we defined previously with `FileProvider`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 名称将指向Android支持库的`FileProvider`路径。authorities字段表示应用程序的域（通常是应用程序的包名称）。exported字段指示我们是否希望与其他应用程序共享我们的提供程序，`grantUriPermissions`指示我们是否希望通过URI授予其他应用程序对某些文件的访问权限。meta-data将我们之前定义的XML文件与`FileProvider`链接起来。
- en: 'Define the `ProviderFileManager` class, which is responsible for accessing
    the `docs` folder and writing data into the file:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`ProviderFileManager`类，负责访问`docs`文件夹并将数据写入文件：
- en: '[PRE60]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `FileToUriMapper` class looks like this:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FileToUriMapper`类如下所示：'
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s now move on to defining our UI for the `activity_main.xml` file:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们继续定义`activity_main.xml`文件的UI：
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let''s define our `MainActivity` class:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们定义我们的`MainActivity`类：
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output will be as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 11.7: Output of copy through FileProvider'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7：通过FileProvider复制的输出'
- en: '](img/B15216_11_07.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_11_07.jpg)'
- en: 'Figure 11.7: Output of copy through FileProvider'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：通过FileProvider复制的输出
- en: 'Let''s add the logic for the `SAF` button. We will need to start an activity
    pointing toward the `SAF` with the `CREATE_DOCUMENT` intent in which we specify
    that we want to create a text file. We will then need the result of the `SAF`
    so we can copy the file to the location selected by the user. In `MainActivity`
    in `onCreateMethod`, we can add the following:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`SAF`按钮添加逻辑。我们需要启动一个指向`SAF`的活动，并使用`CREATE_DOCUMENT`意图，指定我们要创建一个文本文件。然后我们需要`SAF`的结果，这样我们就可以将文件复制到用户选择的位置。在`MainActivity`的`onCreateMethod`中，我们可以添加以下内容：
- en: '[PRE64]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: What the preceding code will do is to create an intent to create a document
    with the name of `Copied.txt` and the `text/plain` MIME (Multipurpose Internet
    Mail Extensions) type (which is suitable for text files). This code will only
    run in Android versions bigger than KitKat.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将创建一个意图，以创建一个名为`Copied.txt`的文档，并使用`text/plain` MIME（多用途互联网邮件扩展）类型（适用于文本文件）。此代码仅在大于KitKat的Android版本中运行。
- en: 'Let''s now tell the activity how to handle the result of the document creation.
    We will receive a URI object with an empty file selected by the user. We can now
    copy our file to that location. In `MainActivity`, we add `onActivityResult`,
    which will look like this:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们告诉活动如何处理文档创建的结果。我们将收到一个URI对象，其中用户选择了一个空文件。现在我们可以将我们的文件复制到该位置。在`MainActivity`中，我们添加`onActivityResult`，如下所示：
- en: '[PRE65]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We now have the URI. We can add a method to `ProviderFileManager` that will
    copy our file to a location given by `uri`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了URI。我们可以在`ProviderFileManager`中添加一个方法，将我们的文件复制到`uri`指定的位置：
- en: '[PRE66]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'And we can invoke this method from the `onActivityResult` method of `MainActivity`
    like this:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从`MainActivity`的`onActivityResult`方法中调用此方法，如下所示：
- en: '[PRE67]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If we run the preceding code and click on the `SAF` button, we will see the
    output presented in *Figure 11.8*:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码并单击`SAF`按钮，我们将看到*图11.8*中呈现的输出：
- en: '![Figure 11.8: Output of copy through the SAF'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.8：通过SAF复制的输出'
- en: '](img/B15216_11_08.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_11_08.jpg)'
- en: 'Figure 11.8: Output of copy through the SAF'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：通过SAF复制的输出
- en: If you choose to save the file, the SAF will be closed and our activity's `onActivityResult`
    method will be called, which will trigger the file copy. Afterward, you can navigate
    the Android Device File Manager tool to see whether the file was saved properly.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择保存文件，SAF将关闭，并且我们的活动的`onActivityResult`方法将被调用，这将触发文件复制。之后，您可以导航到Android设备文件管理器工具，查看文件是否已正确保存。
- en: Scoped Storage
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域存储
- en: Since Android 10 and with further updates in Android 11, the notion of Scoped
    Storage was introduced. The main idea behind this is to allow apps to gain more
    control of their files on the external storage and prevent other apps from accessing
    these files. The consequences of this mean that `READ_EXTERNAL_STORAGE` and `WRITE_EXTERNAL_STORAGE`
    will only apply for files the user interacts with (like media files). This discourages
    apps to create their own directories on the external storage and instead stick
    with the one already provided to them through the `Context.getExternalFilesDir`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 自Android 10以来，并在Android 11中进一步更新，引入了作用域存储的概念。其背后的主要思想是允许应用程序更多地控制外部存储上的文件，并防止其他应用程序访问这些文件。这意味着`READ_EXTERNAL_STORAGE`和`WRITE_EXTERNAL_STORAGE`仅适用于用户与之交互的文件（如媒体文件）。这会阻止应用程序在外部存储上创建自己的目录，而是坚持使用通过`Context.getExternalFilesDir`提供给它们的目录。
- en: FileProviders and Storage Access Framework are a good way of keeping your app's
    compliance with the scoped storage practices because one allows the app to use
    the `Context.getExternalFilesDir` and the other uses the built-in File Explorer
    app which will now avoid files from other applications in the `Android/data` and
    `Android/obb` folders on the external storage.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: FileProviders和存储访问框架是保持应用程序符合作用域存储实践的好方法，因为其中一个允许应用程序使用`Context.getExternalFilesDir`，另一个使用内置的文件浏览器应用程序，现在将避免在外部存储的`Android/data`和`Android/obb`文件夹中的其他应用程序文件。
- en: Camera and Media Storage
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相机和媒体存储
- en: Android offers a variety of ways to interact with media on an Android device,
    from building your own camera application and controlling how users take photos
    and videos to using the existing camera application and instructing it on how
    to take photos and videos. Android also comes with a `MediaStore` content provider,
    allowing applications to extract information about media files that are set on
    the device and shared between applications. This is useful in situations where
    you want a custom display for media files that exist on the device (such as a
    photo or music player application) and in situations where you use the `MediaStore.ACTION_PICK`
    intent to select a photo from the device and want to extract the information about
    the selected media image (this is usually the case for older applications where
    the SAF cannot be used).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Android提供了多种与Android设备上的媒体交互的方式，从构建自己的相机应用程序并控制用户如何拍照和录像，到使用现有的相机应用程序并指导其如何拍照和录像。Android还配备了`MediaStore`内容提供程序，允许应用程序提取有关设备上设置的媒体文件和应用程序之间共享的媒体文件的信息。这在您希望为设备上存在的媒体文件（如照片或音乐播放器应用程序）自定义显示的情况下非常有用，并且在使用`MediaStore.ACTION_PICK`意图从设备中选择照片并希望提取所选媒体图像的信息的情况下也非常有用（这通常是旧应用程序的情况，无法使用SAF）。
- en: 'In order to use an existing camera application, you will need to use the `MediaStore.ACTION_IMAGE_CAPTURE`
    intent to start a camera application for a result and pass the URI of the image
    you wish to save. The user will then go to the camera activity, take the photo,
    and then you handle the result of the operation:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用现有的相机应用程序，您需要使用`MediaStore.ACTION_IMAGE_CAPTURE`意图启动相机应用程序以获取结果，并传递您希望保存的图像的URI。然后用户将转到相机活动，拍照，然后您处理操作的结果：
- en: '[PRE68]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `photoUri` parameter will represent the location of where you want your
    photo to be saved. It should point to an empty file with a JPEG extension. You
    can build this file in two ways:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`photoUri`参数将表示您希望保存照片的位置。它应指向一个具有JPEG扩展名的空文件。您可以通过两种方式构建此文件：'
- en: Create a file on the external storage using the `File` object (this requires
    the `WRITE_EXTERNAL_STORAGE` permission) and then use the `Uri.fromFile()` method
    to convert it into a `URI` - no longer applicable on Android 10 and above
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在外部存储上使用`File`对象创建文件（这需要`WRITE_EXTERNAL_STORAGE`权限），然后使用`Uri.fromFile()`方法将其转换为`URI`
    - 在Android 10及以上版本不再适用
- en: Create a file in a `FileProvider` location using the `File` object and then
    use the `FileProvider.getUriForFile()` method to obtain the URI and grant it permissions
    if necessary. - the recommended approach for when your app targets Android 10
    and Android 11
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`File`对象在`FileProvider`位置创建文件，然后使用`FileProvider.getUriForFile()`方法获取URI并在必要时授予权限-适用于您的应用程序目标为Android
    10和Android 11的推荐方法
- en: Note
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The same mechanism can be applied to videos using `MediaStore.ACTION_VIDEO_CAPTURE`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的机制也可以应用于使用`MediaStore.ACTION_VIDEO_CAPTURE`的视频。
- en: If your application relies heavily on the camera features, then you can exclude
    the application from users whose devices don't have cameras by adding the `<uses-feature>`
    tag to the `AndroidManifest.xml` file. You can also specify the camera as non-required
    and query whether the camera is available using the `Context.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY)`
    method.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序严重依赖相机功能，则可以通过将`<uses-feature>`标签添加到`AndroidManifest.xml`文件中来排除没有相机的设备的用户。您还可以将相机指定为非必需，并使用`Context.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY)`方法查询相机是否可用。
- en: 'If you wish to have your file saved in `MediaStore`, there are multiple ways
    to achieve this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将文件保存在`MediaStore`中，有多种方法可以实现：
- en: 'Send an `ACTION_MEDIA_SCANNER_SCAN_FILE` broadcast with the URI of your media:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送带有媒体URI的`ACTION_MEDIA_SCANNER_SCAN_FILE`广播：
- en: '[PRE69]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Use the media scanner to scan files directly:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用媒体扫描程序直接扫描文件：
- en: '[PRE70]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Insert the media into `ContentProvider` directly using `ContentResolver`:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接将媒体插入`ContentProvider`使用`ContentResolver`：
- en: '[PRE71]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `MediaScanner` functionality no longer adds files from `Context.getExternalFilesDir`
    in Android 10 and above. Apps should rely on the `insert` method instead if they
    chose to share their media files with the rest of the apps.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android 10及以上版本中，`MediaScanner`功能不再添加来自`Context.getExternalFilesDir`的文件。如果应用程序选择与其他应用程序共享其媒体文件，则应依赖`insert`方法。
- en: 'Exercise 11.06: Taking Photos'
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.06：拍照
- en: 'We''re going to build an application that has two buttons: the first button
    will open the camera app to take a photo, and the second button will open the
    camera app to record a video. We will use `FileProvider` to save the photos to
    the external storage (external-path) in two folders: `pictures` and `movies`.
    The photos will be saved using `img_{timestamp}.jpg`, and the videos will be saved
    using `video_{timestamp}.mp4`. After a photo and video have been saved, you will
    copy the file from the `FileProvider` into the `MediaStore` so it will be visible
    for other apps:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个应用程序，其中有两个按钮：第一个按钮将打开相机应用程序以拍照，第二个按钮将打开相机应用程序以录制视频。我们将使用`FileProvider`将照片保存到外部存储（external-path）中的两个文件夹：`pictures`和`movies`。照片将使用`img_{timestamp}.jpg`保存，视频将使用`video_{timestamp}.mp4`保存。保存照片和视频后，您将从`FileProvider`复制文件到`MediaStore`中，以便其他应用程序可以看到。
- en: 'Let''s add the libraries in `app/build.gradle` :'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`app/build.gradle`中添加库：
- en: '[PRE72]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We will be targeting Android 11 which means that we need the following configuration
    in `app/build.gradle`
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将以Android 11为目标，这意味着我们需要在`app/build.gradle`中进行以下配置
- en: '[PRE73]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We will need to request the WRITE_EXTERNAL_STORAGE permission for devices that
    have less than Android 10, which means we need the following in `AndroidManifest.xml`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为低于Android 10的设备请求WRITE_EXTERNAL_STORAGE权限，这意味着我们需要在`AndroidManifest.xml`中添加以下内容：
- en: '[PRE74]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s define a `FileHelper` class, which will contain methods that are harder
    to test in the `test` package:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义一个`FileHelper`类，其中包含一些在`test`包中难以测试的方法：
- en: '[PRE75]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Let''s define our `FileProvider` paths in `res/xml/file_provider_paths.xml`.
    Make sure to include the appropriate package name for your application in `FileProvider`:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`res/xml/file_provider_paths.xml`中定义我们的`FileProvider`路径。确保在`FileProvider`中包含适当的应用程序包名称：
- en: '[PRE76]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s add the file provider paths to the `AndroidManifest.xml` file:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将文件提供程序路径添加到`AndroidManifest.xml`文件中：
- en: '[PRE77]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let''s now define a model that will hold both the `Uri` and the associated
    path for a file:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们定义一个模型，该模型将保存`Uri`和文件的关联路径：
- en: '[PRE78]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Let's create a `ContentHelper` class which will provide us with data required
    for the `ContentResolver`. We will define two methods for accessing the Photo
    and Video content Uri and two methods that will create the `ContentValues`. We
    do this because of the static methods required to obtain Uris and the `ContentValues`
    creation which makes this functionality hard to test. The code below is truncated
    for space. The full code you need to add can be found via the link below.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个`ContentHelper`类，它将为我们提供`ContentResolver`所需的数据。我们将定义两种方法来访问照片和视频内容Uri，以及两种方法来创建`ContentValues`。我们这样做是因为获取Uri和创建`ContentValues`所需的静态方法使得这个功能难以测试。由于篇幅限制，以下代码已被截断。您需要添加的完整代码可以通过下面的链接找到。
- en: '[PRE79]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Now, let''s create the `ProviderFileManager` class, where we will define methods
    to generate files for photos and videos that will then be used by the camera and
    the methods that will save to the media store. Again, the code has been truncated
    for brevity. Please see the link below for the full code that you need to use:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建`ProviderFileManager`类，在其中我们将定义生成照片和视频文件的方法，然后由相机使用，并保存到媒体存储的方法。同样，为简洁起见，代码已被截断。请查看下面的链接以获取您需要使用的完整代码：
- en: '[PRE80]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Notice how we defined the root folders as `context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)`
    and `context.getExternalFilesDir(Environment.DIRECTORY_MOVIES)`. This connects
    to `file_provider_paths.xml` and it will create a set of folders called `Movies`
    and `Pictures` in the application's dedicated folder on the external storage.
    The `insertToStore` method is where the files will be then copied to the `MediaStore`.
    First we will create an entry into that store which will give us a Uri for that
    entry. Next we copy the contents of our files from the Uri generated by the `FileProvider`
    into the `OutputStream` pointing to the `MediaStore` entry.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何将根文件夹定义为`context.getExternalFilesDir(Environment.DIRECTORY_PICTURES)`和`context.getExternalFilesDir(Environment.DIRECTORY_MOVIES)`。这与`file_provider_paths.xml`相关联，并将在外部存储器上的应用程序专用文件夹中创建一组名为`Movies`和`Pictures`的文件夹。`insertToStore`方法是文件将被复制到`MediaStore`的地方。首先，我们将在存储中创建一个条目，这将为我们提供该条目的Uri。接下来，我们将从`FileProvider`生成的Uri中将文件内容复制到指向`MediaStore`条目的`OutputStream`中。
- en: 'Let''s define the layout for our activity in `res/layout/activity_main.xml`:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`res/layout/activity_main.xml`中定义我们活动的布局：
- en: '[PRE81]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Let''s create the `MainActivity` class where we will check if we need to request
    the WRITE_STORAGE_PERMISSION, request it if we need to and after it was granted
    open the camera to take a photo or a video. As above, code has been truncated
    for brevity. You can access the full code using the link shown:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建`MainActivity`类，我们将在其中检查是否需要请求WRITE_STORAGE_PERMISSION，如果需要，则请求它，并在授予权限后打开相机拍摄照片或视频。与上文一样，为简洁起见，代码已被截断。您可以使用下面显示的链接访问完整的代码：
- en: '[PRE82]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'If we execute the preceding code, we will see the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行上述代码，我们将看到以下结果：
- en: '![Figure 11.9: Output of Exercise 11.06'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.9：练习11.06的输出'
- en: '](img/B15216_11_09.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_11_09.jpg)'
- en: 'Figure 11.9: Output of Exercise 11.06'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：练习11.06的输出
- en: 'By clicking on either of the buttons, you will be redirected to the camera
    application where you can take a photo or a video if you are running the example
    on Android 10 and above. If you''re running on lower Android versions then the
    permissions will be asked first. Once you have taken your photo and confirmed
    it, you will be taken back to the application. The photo will be saved in the
    location you defined in `FileProvider`:![Figure 11.10: The location of the captured
    files through the camera app'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击任一按钮，您将被重定向到相机应用程序，在那里您可以拍摄照片或视频（如果您在Android 10及以上版本上运行示例）。如果您在较低的Android版本上运行，则会首先要求权限。一旦您拍摄并确认了照片，您将被带回应用程序。照片将保存在您在`FileProvider`中定义的位置：![图11.10：通过相机应用程序捕获文件的位置
- en: '](img/B15216_11_10.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_11_10.jpg)'
- en: 'Figure 11.10: The location of the captured files through the camera app'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10：通过相机应用程序捕获文件的位置
- en: In the preceding screenshot, you can see where the files are located with the
    help of the Android Studio Device File Explorer.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述截图中，您可以看到借助Android Studio设备文件浏览器文件的位置。
- en: 'Modify `MainActivity` and add the `onActivityResult` method to trigger the
    save of the files to the MediaStore:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`MainActivity`并添加`onActivityResult`方法来触发文件保存到MediaStore的操作：
- en: '[PRE83]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: If you open any file exploring app like the "Files" app or the Gallery or Google
    Photos app, you will be able to see the videos and pictures taken.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打开任何文件浏览应用程序，如“文件”应用程序、画廊或Google照片应用程序，您将能够看到拍摄的视频和图片。
- en: '![Figure 11.11: The files from the app present in the File Explorer app'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.11：应用程序中的文件在文件浏览器应用程序中的位置'
- en: '](img/B15216_11_11.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_11_11.jpg)'
- en: 'Figure 11.11: The files from the app present in the File Explorer app'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11：应用程序中的文件在文件浏览器应用程序中的位置
- en: 'Activity 11.01: Dog Downloader'
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动11.01：狗下载器
- en: You are tasked with building an application that will target Android versions
    above API 21 that will display a list of URLs for dog photos. The URL you will
    connect to is `https://dog.ceo/api/breed/hound/images/random/{number}`, where
    `number` will be controlled through a Settings screen where the user can choose
    the number of URLs they want to be displayed. The Settings screen will be opened
    through an option presented on the home screen. When the user clicks on a URL,
    the image will be downloaded locally in the application's external cache path.
    While the image is being downloaded, the user will see an indeterminate progress
    bar. The list of URLs will be persisted locally using Room.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 您的任务是构建一个针对 Android 版本高于 API 21 的应用程序，该应用程序将显示狗照片的 URL 列表。您将连接到的 URL 是 `https://dog.ceo/api/breed/hound/images/random/{number}`，其中
    `number` 将通过设置屏幕控制，用户可以选择要显示的 URL 数量。设置屏幕将通过主屏幕上呈现的选项打开。当用户点击 URL 时，图像将在应用程序的外部缓存路径中本地下载。在下载图像时，用户将看到一个不确定的进度条。URL
    列表将使用 Room 在本地持久化。
- en: 'The technologies that will be used are the following:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用以下技术：
- en: Retrofit for retrieving the list of URLs and for downloading files
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Retrofit 用于检索 URL 列表和下载文件
- en: Room for persisting the list of URLs
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Room 用于持久化 URL 列表
- en: '`SharedPreferences` and `PreferencesFragment` for storing the number of URLs
    to retrieve'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SharedPreferences` 和 `PreferencesFragment` 用于存储要检索的 URL 数量'
- en: '`FileProvider` for storing the files in the cache'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileProvider` 用于将文件存储在缓存中'
- en: Apache IO for writing the files
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache IO 用于写文件
- en: Repository for combining all the data sources
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合所有数据源的存储库
- en: '`LiveData` and `ViewModel` for handling the logic from the user'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiveData` 和 `ViewModel` 用于处理用户的逻辑'
- en: '`RecyclerView` for the list of Items'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RecyclerView` 用于项目列表'
- en: 'The response JSON will look similar to this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 响应 JSON 将类似于这样：
- en: '[PRE84]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Perform the following steps to complete this activity:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Create an `api` package that will contain the network-related classes.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含与网络相关的类的 `api` 包。
- en: Create a data class that will model the response JSON.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数据类，用于建模响应 JSON。
- en: Create a Retrofit `Service` class that will contain two methods. The first method
    will represent the API call to return a list of breeds, and the second method
    will represent the API call to download the file.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Retrofit `Service` 类，其中包含两个方法。第一个方法将代表 API 调用以返回品种列表，第二个方法将代表 API 调用以下载文件。
- en: Create a `storage` package and, inside the `storage` package, create a `room` package.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `storage` 包，并在 `storage` 包内创建一个 `room` 包。
- en: Create the `Dog` entity, which will contain an autogenerated ID and a URL.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含自动生成的 ID 和 URL 的 `Dog` 实体。
- en: Create the `DogDao` class, which will contain methods to insert a list of `Dogs`,
    delete all the `Dogs`, and query all `Dogs`. The `delete` method is required because
    the API model does not have any unique identifiers.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `DogDao` 类，其中包含插入 `Dogs` 列表、删除所有 `Dogs` 和查询所有 `Dogs` 的方法。`delete` 方法是必需的，因为
    API 模型没有任何唯一标识符。
- en: Inside the `storage` package, create a `preference` package.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `storage` 包内，创建一个 `preference` 包。
- en: Inside the `preference` package, create a wrapper class around `SharedPreferences`
    that will return the number of URLs we need to use. The default will be `10`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `preference` 包内，创建一个围绕 `SharedPreferences` 的包装类，该类将返回我们需要使用的 URL 数量。默认值为 `10`。
- en: In `res/xml`, define your folder structure for `FileProvider`. The files should
    be saved in the root folder of the `external-cache-path` tag.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `res/xml` 中，为 `FileProvider` 定义文件夹结构。文件应保存在 `external-cache-path` 标签的根文件夹中。
- en: Inside the `storage` package, create a `filesystem` package.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `storage` 包内创建一个 `filesystem` 包。
- en: Inside the `filesystem` package, define a class that will be responsible for
    writing `InputStream` into a file in `FileProvider`, using `Context.externalCacheDir`.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `filesystem` 包内，定义一个类，负责将 `InputStream` 写入 `FileProvider` 中的文件，使用 `Context.externalCacheDir`。
- en: Create a `repository` package.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `repository` 包。
- en: Inside the `repository` package, create a sealed class that will hold the result
    of an API call. The subclasses of the sealed class will be `Success`, `Error`,
    and `Loading`.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `repository` 包内，创建一个密封类，该类将保存 API 调用的结果。密封类的子类将是 `Success`、`Error` 和 `Loading`。
- en: Define a `Repository` interface that will contain two methods, one to load the
    list of URLs, and the other to download a file.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含两个方法的 `Repository` 接口，一个用于加载 URL 列表，另一个用于下载文件。
- en: Define a `DogUi` model class that will be used in the UI layer of your application
    and that will be created in your repository.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `DogUi` 模型类，该类将用于应用程序的 UI 层，并将在存储库中创建。
- en: Define a mapper class that will convert your API models into entities and entities
    into UI models.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个映射器类，将您的 API 模型转换为实体，实体转换为 UI 模型。
- en: Define an implementation for `Repository` that will implement the preceding
    two methods. The repository will hold references to `DogDao`, the Retrofit `Service`
    class, the `Preferences` wrapper class, the class managing the files, the `Dog`
    mapping class, and an `Executor` class for multithreading. When downloading the
    files, we will be using the filename extracted from the URL.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个实现 `Repository` 的实现，该实现将实现前两个方法。存储库将持有对 `DogDao`、Retrofit `Service` 类、`Preferences`
    包装类、管理文件的类、`Dog` 映射类和用于多线程的 `Executor` 类的引用。在下载文件时，我们将使用从 URL 提取的文件名。
- en: Create a class that will extend `Application`, which will initialize the repository.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将初始化存储库的 `Application` 类。
- en: Define the `ViewModel` used by your UI, which will have a reference to `Repository`
    and will call `Repository` to load the URL list and download the images.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 UI 使用的 `ViewModel`，它将引用 `Repository` 并调用 `Repository` 加载 URL 列表和下载图片。
- en: 'Define your UI, which will be composed of two activities:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义您的 UI，它将由两个活动组成：
- en: The activity displays the list of URLs and will have the click action to start
    the downloads. This activity will have a progress bar, which will be displayed
    when the download takes place. The screen will also have a `Settings` option,
    which will open the Settings screen.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该活动显示URL列表，并将具有单击操作以开始下载。该活动将具有进度条，在下载发生时将显示。屏幕还将有一个“设置”选项，它将打开设置屏幕。
- en: The Settings activity, which will display one setting indicating the number
    of URLs to load.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置活动将显示一个设置，指示要加载的URL数量。
- en: Note
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在以下网址找到：http://packt.live/3sKj1cp
- en: Summary
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've analyzed the different ways of persisting data in Android
    and how to centralize them through the repository pattern. We've started with
    a look at the pattern itself to see how we can organize the data sources by combining
    Room and Retrofit.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了Android中持久化数据的不同方式，以及如何通过存储库模式将它们集中起来。我们首先看了一下模式本身，看看我们如何通过结合Room和Retrofit来组织数据源。
- en: Then, we moved on to analyze alternatives to Room when it comes to persisting
    data. We looked first at `SharedPreferences` and how they constitute a handy solution
    for data persistence when it's in a key-value format and the amount of data is
    small. We then looked at how you can use `SharedPreferences` to save data directly
    on the device, and then we examined `PreferenceFragments` and how they can be
    used to take in user input and store it locally.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们继续分析了在持久化数据方面替代Room的选择。我们首先看了`SharedPreferences`，以及当数据以键值格式且数据量较小时，它们构成了一个方便的数据持久化解决方案。然后我们看了如何使用`SharedPreferences`直接在设备上保存数据，然后我们研究了`PreferenceFragments`以及它们如何用于接收用户输入并在本地存储。
- en: 'Next, we looked over something that was in continuous change when it comes
    to the Android framework. That is the evolution of the abstractions regarding
    the filesystem. We started with an overview of the types of storage Android has
    and then took a more in-depth look at two of the abstractions: `FileProvider`,
    which your app can use to store files on the device and share them with others
    if there is a need to do so, and the SAF, which can be used to save files on the
    device in a location selected by the user.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当涉及到Android框架时，我们审视了一个持续变化的内容。那就是关于文件系统抽象的演变。我们首先概述了Android拥有的存储类型，然后更深入地研究了两种抽象：`FileProvider`，您的应用程序可以使用它在设备上存储文件，并在有需要时与他人共享；以及SAF，它可以用于在用户选择的位置在设备上保存文件。
- en: We also used the benefits of `FileProvider` to generate URIs for files in order
    to use the camera applications to take photos and record videos and save them
    in the application's files, while also adding them to `MediaStore`.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还利用了`FileProvider`的好处，为文件生成URI，以便使用相机应用程序拍照和录制视频，并将它们保存在应用程序文件中，同时将它们添加到`MediaStore`。
- en: The activity performed in this chapter combines all the elements discussed above
    to illustrate the point that even though you have to balance multiple sources
    inside an application, you can do it in a more readable way.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中进行的活动结合了上述所有元素，以说明即使您必须在应用程序内部平衡多个来源，也可以以更可读的方式进行。
- en: Note that for the activity and the exercises in this chapter and the previous
    one, we kept having to use the application class to instantiate the data sources.
    In the next chapter, you will learn how to overcome this through dependency injection
    and see how it can benefit an Android application.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在本章和上一章的活动和练习中，我们一直不得不使用应用程序类来实例化数据源。在下一章中，您将学习如何通过依赖注入来克服这一问题，并了解它如何有益于Android应用程序。
