- en: Starting Out with Functions - A Core Concept
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始学习函数 - 一个核心概念
- en: 'In [chapter 2](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml), *Thinking Functionally
    - A First Example*, we went over an example of FP thinking, but let''s now go
    to the basics, and review functions. In [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml),
    *Becoming Functional - Several Questions*, we mentioned that two important JS
    features were functions as first-class objects and closures. Now, in this chapter,
    let''s:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml)中，*函数式思维 - 第一个例子*，我们讨论了一个函数式思维的例子，但现在让我们回到基础，复习一下函数。在[第1章](395f5897-0ecc-4841-86ed-21521e148beb.xhtml)中，*成为函数式
    - 几个问题*，我们提到两个重要的JS特性是函数作为一等对象和闭包。现在，在这一章中，让我们：
- en: Examine some key ways of defining functions in JS
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查JS中定义函数的一些关键方式
- en: Go in detail regarding arrow functions, which are closest to the lambda calculus
    functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细讨论箭头函数，它们是最接近lambda演算函数的
- en: Introduce the concept of *currying*
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍*currying*的概念
- en: Revisit the concept of functions as first-class objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视函数作为一等对象的概念
- en: 'We''ll also consider several FP techniques, such as:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将考虑几种函数式编程技术，比如：
- en: Injection, as needed for sorting with different strategies and other uses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入，根据不同策略进行排序和其他用途
- en: Callbacks and promises, introducing the *continuation passing* style
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调和promises，引入*continuation passing* 风格
- en: '*Polyfilling* and *stubbing*'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Polyfilling* 和 *stubbing*'
- en: Immediate invocation schemes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即调用方案
- en: All about functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于函数的一切
- en: Let's get started with a short review of functions in JS and their relationship
    to FP concepts. We can start something we mentioned in previous chapters, about
    functions as first-class objects, and then go on to several considerations about
    their usage in JS.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从JS中函数的简要回顾和它们与函数式编程概念的关系开始。我们可以从我们在之前章节提到的东西开始，关于函数作为一等对象，然后继续讨论它们在JS中的使用。
- en: Of lambdas and functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于lambda和函数
- en: In lambda calculus terms, a function can look like *λx.2*x*. The understanding is
    that the variable after the *λ* character is the parameter for the function, and
    the expression after the dot is where you would replace whatever value is passed
    as an argument.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用lambda演算的术语来看，一个函数可以看起来像*λx.2*x*。理解的是，*λ* 字符后面的变量是函数的参数，点后面的表达式是你将要替换为传递的任何值的地方。
- en: 'If you sometimes wonder about the difference between arguments and parameters,
    a mnemonic with some alliteration may help: *Parameters are Potential, Arguments
    are Actual.* Parameters are placeholders for potential values that will be passed,
    and arguments are the actual values passed to the function.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有时想知道参数和实参之间的区别，一些头韵的助记词可能会有所帮助：*Parameters are Potential, Arguments are
    Actual.* 参数是潜在值的占位符，将要传递的值，而实参是传递给函数的实际值。
- en: Applying a function means that you provide an actual argument to it, and that
    is written in the usual way, by using parentheses. For example,  *(λx.2*x)(3)*
    would be calculated as 6\. What's the equivalent of these lambda functions in
    JS? That's an interesting question! There are several ways of defining functions,
    and not all have the same meaning.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 应用一个函数意味着你向它提供一个实际的参数，并且通常是用括号来表示。例如，*(λx.2*x)(3)* 将被计算为6。这些lambda函数在JS中的等价物是什么？这是一个有趣的问题！有几种定义函数的方式，并且并非所有的方式都有相同的含义。
- en: A good article showing the many ways of defining functions, methods, and more,
    is *The Many Faces of Functions in JavaScript*, by Leo Balter and Rick Waldron,
    at [https://bocoup.com/blog/the-many-faces-of-functions-in-javascript](https://bocoup.com/blog/the-many-faces-of-functions-in-javascript)--give
    it a look!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一篇很好的文章展示了定义函数、方法等的多种方式，是*JavaScript中函数的多种面孔*，由Leo Balter和Rick Waldron撰写，网址是[https://bocoup.com/blog/the-many-faces-of-functions-in-javascript](https://bocoup.com/blog/the-many-faces-of-functions-in-javascript)--去看看吧！
- en: 'In how many ways can you define a function in JS? The answer is, *probably
    in more ways than you thought!* At the very least, you could write:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在JS中你可以用多少种方式定义一个函数？答案是，*可能比你想象的要多！* 至少，你可以写：
- en: 'a named function declaration: `function first(...) {...};`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个命名的函数声明：`function first(...) {...};`
- en: 'an anonymous function expression: `var second = function(...) {...};`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个匿名函数表达式：`var second = function(...) {...};`
- en: 'a named function expression: `var third = function someName(...) {...};`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个命名的函数表达式：`var third = function someName(...) {...};`
- en: 'an immediately-invoked expression: `var fourth = (function() { ...; return
    function(...) {...}; })();`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个立即调用的表达式：`var fourth = (function() { ...; return function(...) {...}; })();`
- en: 'a function constructor: `var fifth = new Function(...);`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个函数构造器：`var fifth = new Function(...);`
- en: 'an arrow function: `var sixth = (...) => {...};`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个箭头函数：`var sixth = (...) => {...};`
- en: And, if you wanted, you could add object method declarations, since they actually
    imply functions as well, but that's enough.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意的话，你还可以添加对象方法声明，因为它们实际上也意味着函数，但这已经足够了。
- en: JS also allows defining generator functions as in `function*(...) {...}` that
    actually return a `Generator` object and `async` functions that really are a mix
    of generators and promises. We won't be using these kinds of functions, but read
    more about them at [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*) and [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)--they
    can be useful in other contexts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JS还允许定义生成器函数，如`function*(...) {...}`，实际上返回一个`Generator`对象，以及真正是生成器和promises混合的`async`函数。我们不会使用这些类型的函数，但是可以在[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*)和[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)了解更多--它们在其他情境中可能会有用。
- en: 'What''s the difference between all these ways of defining functions, and why
    should we care? Let''s go over them, one by one:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些定义函数的方式之间的区别是什么，为什么我们要在意？让我们一一讨论：
- en: The first definition, a standalone declaration starting with the `function`
    keyword, is probably the most used in JS and defines a function named `first`(that
    is, `first.name=="first"`). Due to *hoisting*, this function will be accessible
    everywhere in the scope where it's defined.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个定义，使用`function`关键字作为独立声明，可能是JS中最常用的方式，并定义了一个名为`first`的函数（即`first.name=="first"`）。由于*变量提升*，这个函数将在定义它的作用域中随处可访问。
- en: Read more about hoisting at [https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)
    and keep in mind that it applies only to declarations, but not to initializations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://developer.mozilla.org/en-US/docs/Glossary/Hoisting](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)上阅读更多关于变量提升的内容，并记住它只适用于声明，而不适用于初始化。
- en: 'The second definition, assigning a function to a variable, also produces a
    function, but an *anonymous*(that is, no name) one. However, many JS engines are
    capable of deducing what the name should be, and set `second.name=="second"`(check
    the following code, which shows a case where the anonymous function gets no name
    assigned). Since the assignment isn''t hoisted, the function will only be accessible
    after the assignment has been executed. Also, you''d probably prefer defining
    the variable with `const` rather than`var` because you wouldn''t (*shouldn''t*)
    be changing the function:'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个定义，将函数赋值给一个变量，也会产生一个函数，但是是一个*匿名*的函数（即没有名称）。然而，许多JS引擎能够推断名称应该是什么，并设置`second.name=="second"`（检查下面的代码，显示了匿名函数没有被分配名称的情况）。由于赋值不会被提升，函数只有在赋值执行后才能访问。此外，你可能更喜欢用`const`来定义变量，而不是`var`，因为你不应该改变这个函数：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The third definition is the same as the second, except that the function now
    has its own name: `third.name === "someName"`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个定义与第二个相同，只是函数现在有了自己的名称：`third.name === "someName"`。
- en: The name of a function is relevant when you want to call it, and also if you
    plan to do recursive calls; we'll come back to this in [Chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml),
    *Designing Functions - Recursion*. If you just want a function for, say, a callback,
    you can do without a name. However, note that named functions are more easily
    recognized in an error traceback.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的名称在你想要调用它时是相关的，如果你计划进行递归调用也是相关的；我们将在第九章*Designing Functions - Recursion*中回到这一点。如果你只是想要一个用于回调的函数，你可以不用名称。但是请注意，命名函数在错误回溯中更容易被识别。
- en: 'The fourth definition, with an immediately-invoked expression, lets you use
    a closure. An inner function can use variables or other functions, defined in
    its outer function, in a totally private, encapsulated, way. Going back to the
    counter making function that we saw in the *Closures section*of [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml),
    *Becoming Functional - Several Questions*, we could write something like the following:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个定义，使用立即调用的表达式，让你可以使用闭包。内部函数可以以完全私有、封装的方式使用外部函数中定义的变量或其他函数。回到我们在第一章的*Closures*部分看到的计数器制作函数，我们可以写出以下内容：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Study the code carefully: the outer function receives an argument (77, in this
    case) that is used as `count`''s initial value (if no initial value is provided,
    we start at zero). The inner function can access `count` (because of the closure),
    but the variable cannot be accessed anywhere else. In all aspects, the returned
    function is a common function; the only difference is its access to private elements.
    This is also the base of the *module* pattern.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究代码：外部函数接收一个参数（在这种情况下是77），这个参数被用作`count`的初始值（如果没有提供初始值，我们从零开始）。内部函数可以访问`count`（因为闭包的原因），但是这个变量在其他地方是无法访问的。在所有方面，返回的函数是一个普通的函数；唯一的区别是它可以访问私有元素。这也是*module*模式的基础。
- en: 'The fifth definition isn''t safe, and you shouldn''t use it! You pass the arguments
    names, and then the actual function body as a string in the last argument -- and
    the equivalent of `eval()` is used to create the function, which could allow for
    many dangerous hacks, so don''t do this! Just to whet your curiosity, let''s see
    an example, rewriting the very simple  `sum3()` function we saw back in the *Spread*
    section of [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming
    Functional - Several Questions*:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个定义是不安全的，你不应该使用它！你传递参数名称，然后将实际的函数体作为最后一个参数的字符串传递--并且使用了`eval()`的等价物来创建函数，这可能会导致许多危险的黑客攻击，所以不要这样做！只是为了激发你的好奇心，让我们看一个例子，重写我们在第一章的*Spread*部分中看到的非常简单的`sum3()`函数：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This sort of definition is not only unsafe, but has some other quirks, such
    as not creating closures with their creation contexts, and always being global
    instead. See [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    for more on this, but remember that using this way of creating functions isn't
    a good idea!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定义不仅不安全，而且还有一些其他怪癖，比如不会在创建上下文中创建闭包，而且总是全局的。查看[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)了解更多信息，但请记住，使用这种方式创建函数不是一个好主意！
- en: Finally, the last definition using an arrow `=>` definition is the most compact
    way to define a function and the one we'll try to use whenever possible. We'll
    get into more detail in the next section.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，使用箭头`=>`定义的最紧凑的方式来定义函数，我们将尽可能地尝试使用这种方式。我们将在下一节详细介绍。
- en: Arrow functions - the modern way
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数 - 现代的方式
- en: Even if arrow functions pretty much work as the other functions, there are some
    important differences with usual functions. These functions can implicitly return
    a value, the value of `this` is not bound, and there is no `arguments` object.
    Let's go over these three points.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 即使箭头函数基本上与其他函数一样工作，但是与普通函数有一些重要的区别。这些函数可以隐式返回一个值，`this`的值不会被绑定，也没有`arguments`对象。让我们来看看这三点。
- en: 'There are some extra differences: arrow functions cannot be used as constructors,
    they do not have a `prototype` property, and they cannot be used as generators
    because they don''t allow the `yield` keyword. For more details on these points,
    see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些额外的区别：箭头函数不能用作构造函数，它们没有`prototype`属性，也不能用作生成器，因为它们不允许使用`yield`关键字。有关这些点的更多细节，请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this)。
- en: Returning values
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值
- en: 'In lambda style, functions only consist of a result. For the sake of brevity,
    the new arrow functions provide a syntax for this. When you write something like
    `(x,y,z) =>` followed by an expression, a return is implied. For instance, the
    following two functions actually do the same as the `sum3()` function we showed
    previously:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda风格中，函数只包括一个结果。为了简洁起见，新的箭头函数提供了这种语法。当你写类似`(x,y,z) =>`的表达式时，会隐含一个返回。例如，以下两个函数实际上与我们之前展示的`sum3()`函数做的事情是一样的：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you want to return an object, then you must use parentheses, or otherwise,
    JS will assume code is meant.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想返回一个对象，那么你必须使用括号，否则JS会认为代码是有意义的。
- en: '"A matter of style: when you define an arrow function with only one parameter,
    you can omit the parentheses around it. For consistency, I prefer always including
    them. However, the formatting tool I use, prettier, doesn''t approve. Feel free
    to choose your style!"r!'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: “风格问题：当你用只有一个参数定义箭头函数时，你可以省略它周围的括号。为了一致性，我更喜欢总是包括它们。然而，我使用的格式化工具，prettier，不赞成。随意选择你的风格！”
- en: Handling the this value
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理this值
- en: 'A classic problem with JS is the handling of `this` -- whose value isn''t always
    what you expect it to be. ES2015 solved this with arrow functions, which inherit
    the proper `this` value, so problems are avoided. To see an example of the possible
    problems, in the following code, by the time the timeout function is called, `this`
    will point to the global (`window`) variable instead of the new object, so you''ll
    get an *undefined* in the console:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JS的一个经典问题是处理`this`的方式--它的值并不总是你期望的那样。ES2015通过箭头函数解决了这个问题，它们继承了正确的`this`值，因此避免了问题。要看一个可能出现问题的例子，在下面的代码中，当超时函数被调用时，`this`将指向全局（`window`）变量，而不是新对象，所以你会在控制台中得到一个*未定义*：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There are two classic ways of solving this with old-fashioned JS5, plus the
    arrow way of working:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种经典的解决方法，使用老式的JS5，以及箭头函数的工作方式：
- en: One solution uses a closure, and defines a local variable (usually  named `that`or
    sometimes `self`), which will get the original value of `this` so it won't be undefined
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种解决方案使用了闭包，并定义了一个本地变量（通常命名为`that`或者有时是`self`），它将获得`this`的原始值，这样它就不会是未定义的
- en: The second way uses `.bind()`, so the timeout function will be bound to the
    correct value of `this`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法使用`.bind()`，所以超时函数将绑定到正确的`this`值。
- en: And the third, more modern way, just uses an arrow function, so `this` gets the
    correct value (pointing to the object) without further ado
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种更现代的方式只是使用箭头函数，所以`this`会得到正确的值（指向对象）而无需其他操作
- en: We will also be using `.bind()`.  See the Of lambdas and etas section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`.bind()`。请参见lambda和eta部分。
- en: 'Let''s see the three solutions in actual code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际代码中的三种解决方案：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Working with arguments
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理参数
- en: 'In [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional
    - Several Questions*, and [Chapter 2](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml),
    *Thinking Functionally - A First Example*, we saw some uses of the spread ( `...`)
    operator. However, the most practical usage we''ll be making of it, has to do
    with working with arguments; we''ll see some cases of this in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*. Let''s review our `once()` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](395f5897-0ecc-4841-86ed-21521e148beb.xhtml)中，*成为功能性-几个问题*，和[第2章](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml)中，*思考功能性-第一个例子*，我们看到了一些使用扩展（`...`）运算符的用法。然而，我们将要做的最实际的用法，与处理参数有关；我们将在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中看到一些这方面的案例，*生成函数-高阶函数*。让我们回顾一下我们的`once()`函数：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Why are we writing `return (...args) =>` and afterwards `func(...args)`? The
    key has to do with the more modern way of handling a variable number (possibly
    zero) of arguments. How did you manage such kinds of code in older versions of
    JS? The answer has to do with the `arguments` object (*not* an array!) that lets
    you access the actual arguments passed to the function.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要写`return (...args) =>`，然后是`func(...args)`？关键在于处理可变数量（可能为零）的参数的更现代方式。在旧版本的JS中，你是如何处理这种代码的？答案与`arguments`对象有关（*不是*数组！），它允许你访问传递给函数的实际参数。
- en: For more on this, read  [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments.](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请阅读[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments.](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments)
- en: 'In JS5 and earlier, if we wanted a function to be able to process any number
    of arguments, we had to write code as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在JS5及更早版本中，如果我们希望函数能够处理任意数量的参数，我们必须编写以下代码：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first log shows that `arguments` is actually an object; the second log corresponds
    to a simple array. Also, note the complicated way needed to call `somethingElse()`,
    which requires using `.apply()`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个日志显示`arguments`实际上是一个对象；第二个日志对应一个简单的数组。另外，注意调用`somethingElse()`所需的复杂方式，需要使用`.apply()`。
- en: 'What would be the equivalent code in ES8? The answer is much shorter, and that''s
    why we''ll be seeing several examples of usage of the spread operator throughout
    the text:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES8中等价的代码是什么？答案要简短得多，这就是为什么我们将在整个文本中看到使用扩展运算符的几个例子：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The points to remember are:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的要点是：
- en: By writing `listArguments2(...args)` we immediately and clearly express that
    our new function receives several (possibly zero) arguments.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编写`listArguments2(...args)`，我们立即并清楚地表达了我们的新函数接收多个（可能为零）参数。
- en: You need not do anything to get an array. The console log shows that `args`
    is really an array without any further ado.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你无需做任何事情就可以得到一个数组。控制台日志显示`args`确实是一个数组，不需要进一步操作。
- en: Writing `somethingElse(...args)` is much more clear than the alternative way
    (using `.apply()`) that we had to use earlier.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写`somethingElse(...args)`比之前必须使用的替代方法（使用`.apply()`）更清晰。
- en: 'By the way, the `arguments` object is still available in ES8\. If you want
    to create an array from it, you have two alternative ways of doing so, without
    having to recur to the `Array.prototype.slice.call` trick:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，ES8中仍然可以使用`arguments`对象。如果你想从中创建一个数组，有两种替代方法可以做到，而不必使用`Array.prototype.slice.call`的技巧：
- en: use the `.from()` method, and write`var myArray=Array.from(arguments)`
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.from()`方法，并写`var myArray=Array.from(arguments)`
- en: or even more simply, say `var myArray=[...arguments]`, which shows yet another
    type of usage of the spread operator
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者更简单地说，比如`var myArray=[...arguments]`，这展示了扩展操作符的另一种用法。
- en: When we get to higher-order functions, writing functions that deal with other
    functions, with a possibly unknown number of parameters, will be commonplace.
    ES8 provides a much shorter way to do so, and that's why you'll have to get accustomed
    to this usage; it's worth it!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们涉及到高阶函数时，编写处理其他函数的函数，可能具有未知数量的参数，将会很普遍。ES8提供了一种更简洁的方法来做到这一点，这就是为什么你必须习惯这种用法；这是值得的！
- en: One argument or many?
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个参数还是多个参数？
- en: It's also possible to write functions that return functions, and in [Chapter
    6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing Functions - Higher-Order
    Functions*, we will be seeing more of this. For instance, in the lambda calculus,
    you don't write functions with several parameters, but only with one, by applying
    something called *currying*(why would you do this? Hold that thought; we'll come
    to that).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以编写返回函数的函数，在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中，我们将看到更多的这种情况。例如，在lambda演算中，你不会写带有多个参数的函数，而只会使用一个参数，通过应用一种叫做“柯里化”的东西（为什么要这样做？先留着这个想法；我们会讲到的）。
- en: Currying gets its name in memory of Haskell Curry, who developed the concept.
    Note that he is also remembered in the name of an FP language, *Haskell*; double
    recognition!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化得名于哈斯克尔·柯里，他发展了这个概念。请注意，他也因函数式编程语言*Haskell*的名字而被铭记；双重认可！
- en: 'For instance, the function we saw previously that sums three numbers, would
    be written as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们之前看到的对三个数字求和的函数，将被写成如下形式：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Why did I change the function''s name? Simply put, because this is *not* the
    same function as previously. As is, though it can be used to produce the very
    same results as our earlier function, it differs in an important way: how do you
    use it? Say, to sum the numbers 1, 2, and 3? You would have to write:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我改变了函数的名字？简单地说，因为这与之前的函数*不*相同。尽管它可以用来产生与我们之前函数完全相同的结果，但它在一个重要的方面有所不同：你如何使用它？比如，对数字1、2和3求和？你将不得不写成：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Test yourself before reading on, and mull on this: what would have been returned
    if you had written `altSum3(1,2,3)` instead?'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前先自我测试一下，并思考一下：如果你写成`altSum3(1,2,3)`会返回什么？
- en: 'Tip: It would not be a number! For the full answer, keep reading.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：它不会是一个数字！要获得完整答案，请继续阅读。
- en: 'How does this work? Separating it in many calls can help; this would be the
    way the previous expression is actually calculated by the JS interpreter:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？分开多次调用可能会有所帮助；这是JS解释器实际计算前面表达式的方式：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Think functionally! The result of calling `altSum3(1)` is, according to the
    definition, a function, which in virtue of a closure resolves to be equivalent
    to:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上来说！调用`altSum3(1)`的结果，根据定义，是一个函数，由于闭包的原因，等效于：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our `altSum3()`function is meant to receive a single argument, not three! The
    result of this call, `fn1`, is also a single argument function. When you do  `fn1(2)`,
    the result is again a function, also with a single parameter, equivalent to:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`altSum3()`函数旨在接收一个参数，而不是三个！这次调用的结果`fn1`也是一个单参数函数。当你执行`fn1(2)`时，结果再次是一个函数，同样只有一个参数，等效于：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And when you calculate `fn2(3)`, a value is finally returned; great! As we said,
    the function does the same kind of calculations as we had earlier seen, but in
    an intrinsically different way.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你计算`fn2(3)`时，最终返回一个值；太好了！正如我们所说，这个函数做的是我们之前看到的相同类型的计算，但是以一种内在不同的方式。
- en: 'You might think currying is just a peculiar trick: who would want to only use
    single-argument functions? You''ll see the reasons for this, when we consider
    how to join functions together in [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*, or [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml),
    *Building Better Containers - Functional Data Types*, where it won''t be feasible
    to pass more than one parameter from one step to the next.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为柯里化只是一个奇特的技巧：谁会只想使用单参数函数呢？当我们考虑如何在[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)中连接函数-流水线和组合，或者[第12章](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml)中构建更好的容器-函数数据类型时，你会明白这样做的原因，下一步传递多个参数将不可行。
- en: Functions as objects
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为对象
- en: 'The concept of *first-class objects*means that functions can be created, assigned,
    changed, passed as parameters, or returned as result of yet other functions, in
    the very same way that you can do with, say, numbers or strings. Let''s start
    with their definition. When you define a function in the usual way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: “头等对象”的概念意味着函数可以被创建、分配、更改、作为参数传递，或者作为其他函数的结果返回，就像你可以对待数字或字符串一样。让我们从它们的定义开始。当你以通常的方式定义一个函数时：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is (almost) equivalent to writing:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这（几乎）等同于写成：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Except for *hoisting*. JS moves all definitions to the top of the current scope,
    but not assignments; so, with the first definition you can invoke `xyzzy(...)`
    from any place in your code, but with the second you cannot invoke the function
    until the assignment has been executed.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*hoisting*。JS将所有定义移动到当前范围的顶部，但不包括赋值；因此，使用第一个定义，您可以从代码的任何位置调用`xyzzy(...)`，但使用第二个定义，直到执行赋值之后才能调用该函数。
- en: See the parallel with the Colossal Cave Adventure Game? Invoking `xyzzy(...)`anywhere
    won't always work! And, if you never played that famous interactive fiction game,
    try it online -- for example, at [http://www.web-adventures.org/cgi-bin/webfrotz?s=Adventure](http://www.web-adventures.org/cgi-bin/webfrotz?s=Adventure) or [http://www.amc.com/shows/halt-and-catch-fire/colossal-cave-adventure/landing](http://www.amc.com/shows/halt-and-catch-fire/colossal-cave-adventure/landing).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 看到与巨型洞穴冒险游戏的类似之处了吗？在任何地方调用`xyzzy(...)`并不总是有效！如果您从未玩过这个著名的互动小说游戏，请尝试在线游戏--例如，在[http://www.web-adventures.org/cgi-bin/webfrotz?s=Adventure](http://www.web-adventures.org/cgi-bin/webfrotz?s=Adventure)或[http://www.amc.com/shows/halt-and-catch-fire/colossal-cave-adventure/landing](http://www.amc.com/shows/halt-and-catch-fire/colossal-cave-adventure/landing)。
- en: 'The point we want to make, is that a function can be assigned to a variable
    -- and can also be reassigned, if desired. In a similar vein, we can define functions
    *on the spot*, when they are needed. We can even do this without naming them:
    as with common expressions, if used only once, then you don''t need to name it
    or store it in a variable.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要表达的观点是，函数可以分配给变量--并且如果需要，还可以重新分配。同样，我们可以在需要时*现场*定义函数。我们甚至可以在不命名它们的情况下执行此操作：与常见表达式一样，如果仅使用一次，则不需要命名它或将其存储在变量中。
- en: A React+Redux reducer
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个React+Redux减速器
- en: 'We can see another example that involves assigning functions. As we mentioned earlier
    in this chapter, React+Redux works by dispatching actions that are processed by
    a reducer. Usually, the reducer includes code with a switch:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到另一个涉及分配函数的例子。正如我们在本章前面提到的，React+Redux通过分派由减速器处理的操作来工作。通常，减速器包括带有开关的代码：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Providing `initialState` as a default value for `state` is a simple way of initializing
    the global state the first time around. Pay no attention to that default; it's
    not relevant for our example, and I included it just for completeness.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为`state`提供`initialState`作为默认值是初始化全局状态的简单方法。不要注意这个默认值；对于我们的示例来说并不重要，我只是为了完整性而包含它。
- en: 'By taking advantage of the possibility of storing functions, we can build a
    *dispatch table*and simplify the preceding code. First, we would initialize an
    object with the code for the functions for each action type. Basically, we are
    just taking the preceding code, and creating separate functions:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用存储函数的可能性，我们可以构建一个*调度表*并简化前面的代码。首先，我们将使用每种操作类型的函数代码初始化一个对象。基本上，我们只是采用前面的代码，并创建单独的函数：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have stored the different functions that process each type of action, as
    attributes in an object that will work as a dispatcher table. This object is created
    only once and is constant during the execution of the application. With it, we
    can now rewrite the action processing code in a single line of code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将处理每种类型的操作的不同函数存储为对象中的属性，该对象将作为调度表。该对象仅创建一次，并且在应用程序执行期间保持不变。有了它，我们现在可以用一行代码重写操作处理代码：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s analyze it: given the action, if `action.type` matches an attribute
    in the dispatching object, we execute the corresponding function, taken from the
    object where it was stored. If there isn''t a match, we just return the current
    state, as Redux requires. This kind of code wouldn''t be possible if we couldn''t
    handle functions (storing and recalling them) as first-class objects.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分析一下：给定操作，如果`action.type`与调度对象中的属性匹配，我们执行相应的函数，该函数取自存储它的对象。如果没有匹配，我们只需返回当前状态，就像Redux要求的那样。如果我们不能处理函数（存储和调用它们）作为一等对象，这种代码是不可能的。
- en: An unnecessary mistake
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个不必要的错误
- en: 'There is, however, a common (though in fact, harmless) mistake usually done.
    You often see code like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常会有一个常见的（尽管实际上是无害的）错误。您经常会看到这样的代码：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: What does this code do? The idea is that a remote URL is fetched, and when the
    data arrives, a function is called -- and this function itself calls `processResult`
    with `data` as an argument. That is to say, in the `then()` part, we want a function
    that, given `data`, calculates `processResult(data)`... don't we already have
    such a function?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是做什么的？这个想法是获取远程URL，并在数据到达时调用一个函数--这个函数本身调用`processResult`并将`data`作为参数。也就是说，在`then()`部分，我们希望一个函数，给定`data`，计算`processResult(data)`...我们已经有这样一个函数了吗？
- en: 'A small bit of theory: In lambda calculus terms, we are replacing λx.func x
    by simply a function -- this is called an eta conversion, more specifically an
    eta reduction. (If you were to do it the other way round, it would be an eta abstraction.)
    In our case, it could be considered a (very, very small!) optimization, but its
    main advantage is shorter, more compact code.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一点点理论：在λ演算术语中，我们将λx.func x替换为一个函数--这称为eta转换，更具体地说是eta缩减。（如果您要以另一种方式进行操作，那将是eta抽象。）在我们的情况下，这可以被认为是一种（非常非常小的！）优化，但它的主要优势是更短，更紧凑的代码。
- en: 'Basically, the rule we can apply is that whenever you see something like the
    following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '基本上，我们可以应用的规则是，每当您看到以下内容时： '
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You may replace it with just `someOtherFunction`. So, in our example, we can
    directly write what follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用`someOtherFunction`替换它。因此，在我们的示例中，我们可以直接写下面的内容：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code is exactly equivalent to the previous way (or, infinitesimally quicker,
    since you avoid one function call) but simpler to understand... or not?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与以前的方式完全相同（或者，由于避免了一个函数调用，可能稍微更快），但更容易理解...或者不是？
- en: 'This programming style is called pointfree style or *tacit* style, and its
    main characteristic is that you never specify the arguments for each function
    application. An advantage of this way of coding, is that it helps the writer (and
    the future readers of the code) think about the functions themselves and their
    meanings, instead of working at low level, passing data around and working with
    it. In the shorter version of the code, there are no extraneous or irrelevant
    details: if you understand what the called function does, then you understand
    the meaning of the complete piece of code. In our text, we''ll often (but not
    necessarily always) work in this way.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程风格称为pointfree风格或*暗示*风格，其主要特点是您从不为每个函数应用指定参数。这种编码方式的优势在于，它有助于编写者（以及代码的未来读者）思考函数本身及其含义，而不是在低级别上处理数据并与之一起工作。在较短的代码版本中，没有多余或无关的细节：如果您了解所调用的函数的作用，那么您就了解了完整代码的含义。在我们的文本中，我们通常（但不一定总是）以这种方式工作。
- en: Unix/Linux users may already be accustomed to this style, because they work
    in a similar way when they use pipes to pass the result of a command as an input
    to another. When you write something as ls | grep doc | sort the output of ls
    is the input to grep, and the latter's output is the input to sort -- but input arguments
    aren't written out anywhere; they are implied. We'll come back to this in the *PointFree
    Style* section of [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting
    Functions - Pipelining and Composition*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Unix/Linux用户可能已经习惯了这种风格，因为当他们使用管道将命令的结果作为输入传递给另一个命令时，他们就以类似的方式工作。当您编写类似ls |
    grep doc | sort的内容时，ls的输出是grep的输入，后者的输出是sort的输入--但是输入参数没有写在任何地方；它们是暗示的。我们将在[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)的*PointFree
    Style*部分中回到这一点，*连接函数 - 管道和组合*。
- en: Working with methods
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用方法
- en: 'There is, however, a case you should be aware of: what happens if you are calling
    an object''s method? If your original code had been something along the lines
    of:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种情况您应该注意：如果您正在调用对象的方法会发生什么？如果您的原始代码是这样的：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then the seemingly obvious transformed code would fail:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，看似明显的转换后的代码会失败：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Why? The reason is that in the original code, the called method is bound to
    an object (`myObject`) but in the modified code, it isn''t bound, and it is just
    a `free`function. We can then fix it in a simple way by using `bind()` as:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？原因是在原始代码中，调用的方法绑定到一个对象（`myObject`），但在修改后的代码中，它没有绑定，它只是一个`free`函数。然后我们可以通过使用`bind()`以简单的方式来修复它：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is a general solution. When dealing with a method, you cannot just assign
    it; you must use `.bind(`so the correct context will be available. Code like:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用解决方案。处理方法时，您不能只是分配它；您必须使用`.bind(`以便正确的上下文可用。像这样的代码：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Should be converted to:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 应该转换为：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Read more on `.bind()` at[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind)上阅读有关`.bind()`的更多信息。
- en: This looks rather awkward, and not too elegant, but it's required so the method
    will be associated to the correct object. We will see one application of this
    when we *promisify* functions in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing
    Functions - Higher-Order Functions*. Even if this code isn't so nice to look at,
    whenever you have to work with objects (and, remember, we didn't say that we would
    be trying to aim for fully FP code and that we would accept other constructs if
    they made things easier) you'll have to remember to bind methods before passing
    them as first-class objects, in pointfree style.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当笨拙，不太优雅，但是这是必需的，以便方法将与正确的对象关联。我们将在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中看到这种应用，*生成函数
    - 高阶函数*。即使这段代码看起来不太好看，但是每当您必须使用对象（记住，我们并没有说我们会尝试完全FP代码，并且如果其他构造使事情变得更容易，我们将接受其他构造）时，您必须记住在以pointfree风格传递它们之前绑定方法。
- en: Using functions in FP ways
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FP方式的函数
- en: There are several common coding patterns that actually take advantage of FP
    style, even if you weren't aware of it. Let's then get to examine them, and point
    out the functional aspects of the code, so you can get more accustomed to this coding
    style.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有几种常见的编码模式实际上利用了FP风格，即使您不知道。让我们来看看它们，并指出代码的功能方面，这样您就可以更加习惯这种编码风格。
- en: Injection - sorting it out
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注入 - 整理它
- en: 'A first example of passing functions as parameters is provided by the `Array.prototype.sort()`
    method. If you have an array of strings, and you want to sort it, you can just
    use something like the following code. For example, to alphabetically sort an
    array with the colors of the rainbow:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.prototype.sort()`方法提供了将函数作为参数传递的第一个示例。如果您有一个字符串数组，并且想对其进行排序，您可以使用以下代码。例如，要按字母顺序对彩虹颜色数组进行排序：'
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note that we didn't have to provide any parameters to the `.sort()` call, but
    the array got sorted perfectly well. By default, this method sorts strings according
    to their ASCII internal representation. So, if you use this method to sort an
    array of numbers, it will fail, since it will decide that 20 must be between 100
    and 3, because *100* precedes *20* --taken as strings!-- and the latter precedes
    *3*... this needs fixing! The code below shows the problem.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不必为`.sort()`调用提供任何参数，但数组被完美地排序了。默认情况下，此方法根据其ASCII内部表示对字符串进行排序。因此，如果您使用此方法对数字数组进行排序，它将失败，因为它将决定20必须介于100和3之间，因为*100*在*20*之前--被视为字符串！--而后者在*3*之前...这需要修复！下面的代码显示了问题。
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'But, let''s forget numbers for a while, and keep to sorting strings. We want
    to ask ourselves: what would happen if we wanted to sort some Spanish words (*palabras*)
    -- but following the appropriate locale rules? We would be sorting strings, but
    results wouldn''t be correct, anyhow:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，让我们暂时忘记数字，继续排序字符串。我们要问自己：如果我们想按适当的区域设置规则对一些西班牙单词（*palabras*）进行排序，会发生什么？我们将对字符串进行排序，但结果无论如何都不正确：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For language or biology buffs, `"ñandú"` in English is `"rhea"`, a running bird
    somewhat similar to ostriches. There aren't many Spanish words beginning with
    "ñ", and we happen to have these birds in my country, Uruguay, so that's the reason
    for the odd word!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于语言或生物学爱好者，英文中的`"ñandú"`是`"rhea"`，一种类似鸵鸟的奔跑鸟。以`"ñ"`开头的西班牙语单词并不多，我们碰巧在我的国家乌拉圭有这些鸟，所以这就是这个奇怪单词的原因！
- en: 'Oops! In Spanish, `"ñ"` comes between `"n"` and `"o"`, but `"ñandú"` got sorted
    at the end. Also, `"mítico"` (in English, `"mythical"`; note the accented `"i"`)
    should appear between `"mano"` and`"musical"`, because the tilde should be ignored.
    The appropriate way of solving this is by providing a comparison function to `sort()`.
    In this case, we can use the `localeCompare()` method:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！在西班牙语中，`"ñ"`位于`"n"`和`"o"`之间，但`"ñandú"`最终被排序。此外，`"mítico"`（英文中为`"mythical"`；请注意带重音的`"i"`）应该出现在`"mano"`和`"musical"`之间，因为应该忽略波浪号。解决这个问题的适当方法是为`sort()`提供一个比较函数。在这种情况下，我们可以使用`localeCompare()`方法：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `a.localeCompare(b,"es")` call compares strings `a` and `b`, and returns
    a negative value if `a` should precede `b`, a positive value if `a` should follow
    `b`, and 0 if `a` and `b` are the same -- but, according to Spanish (`"es"`) ordering
    rules. Now things are right! And the code could become clearer by introducing
    a new function, with an understandable name:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`a.localeCompare(b,"es")`调用比较字符串`a`和`b`，如果`a`应该在`b`之前，则返回负值，如果`a`应该在`b`之后，则返回正值，如果`a`和`b`相同，则返回0--但是，根据西班牙（`"es"`）排序规则。现在事情变得正确了！通过引入一个易懂的名称的新函数，代码可能会变得更清晰：'
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In upcoming chapters we will be discussing how FP lets you write code in a
    more declarative fashion, producing more understandable code, and this sort of
    small change helps: readers of the code, when they get to the sort, will immediately
    deduce what is being done, even if the comment wasn''t present.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论FP如何让您以更声明式的方式编写代码，生成更易理解的代码，这种小的改变有所帮助：代码的读者在到达排序时，即使没有注释，也会立即推断出正在做什么。
- en: This way of changing the way the `sort()` function works by injecting different
    comparison functions, is actually a case of the *Strategy*design pattern. We'll
    be seeing more about this in [Chapter 11](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml),
    *Implementing Design Patterns - The Functional Way*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注入不同的比较函数来改变`sort()`函数的工作方式，实际上是*策略*设计模式的一个案例。我们将在[第11章](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml)中看到更多关于这一点的内容，*实现设计模式-函数式方法*。
- en: 'Providing a sort function as a parameter (in a very FP way!) can also help
    with several other problems, such as:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以参数形式提供排序函数（以非常FP的方式！）还可以帮助解决其他一些问题，例如：
- en: '`sort()` only works with strings. If you want to sort numbers (as we tried
    to do earlier above) you have to provide a function that will compare numerically.
    For example, you would write something like `myNumbers.sort((a,b) => a-b)`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort()`只适用于字符串。如果要对数字进行排序（就像我们之前尝试的那样），您必须提供一个进行数字比较的函数。例如，您可以编写类似`myNumbers.sort((a,b)
    => a-b)`的东西'
- en: If you want to sort objects by a given attribute, you will use a function that
    compares to it. For example, you could sort people by age with something along
    the lines of ``myPeople.sort((a,b) => a.age - b.age)``
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要按给定属性对对象进行排序，您将使用一个与之进行比较的函数。例如，您可以按年龄对人进行排序，类似于`myPeople.sort((a,b) => a.age
    - b.age)`的方式
- en: For more on the `localeCompare()` possibilities, see[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
    You can specify which locale rules to apply, in which order to place upper/lower
    case letters, whether to ignore punctuation and much more -- but be careful; not
    all browsers may support the needed extra parameters.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`localeCompare()`的更多可能性，请参阅[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)。您可以指定要应用的区域设置规则，要放置大写/小写字母的顺序，是否忽略标点符号等等--但要小心；并非所有浏览器都支持所需的额外参数。
- en: This is a simple example, that you have probably used before -- but it's an
    FP pattern, after all. Let's move on to an even more common usage of functions
    as parameters, when you do Ajax calls.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，您可能以前使用过--但毕竟是FP模式。让我们继续讨论函数作为参数的更常见用法，当您进行Ajax调用时。
- en: Callbacks, promises, and continuations
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调，承诺和继续
- en: 'Probably the most used example of functions passed as first-class objects has
    to do with callbacks and promises. In Node.JS, reading a file is accomplished
    asynchronically with something like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 可能是将函数作为一等对象使用的最常见例子与回调和承诺有关。在Node.JS中，读取文件是通过类似以下方式异步完成的：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `readFile()` function requires a callback, which in this example is just
    an anonymous function, that gets called when the file reading operation is finished.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFile()`函数需要一个回调，在这个例子中只是一个匿名函数，当文件读取操作完成时调用。'
- en: 'With a more modern programming style, you would use promises or async/await..
    For instance, when doing an Ajax web service call, using the more modern `fetch()`
    function, you could write something along the lines of the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更现代的编程风格，您可以使用承诺或async/await。例如，在进行Ajax网络服务调用时，使用更现代的`fetch()`函数，您可以编写类似以下代码的内容：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that if you had defined appropriate `processData(data)` and `processError(error)`
    functions, the code could have been shortened to `fetch("some/remote/url").then(processData).catch(processError)`
    along the lines that we saw previously.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您定义了适当的`processData(data)`和`processError(error)`函数，代码可以缩短为`fetch("some/remote/url").then(processData).catch(processError)`，就像我们之前看到的那样。
- en: Continuation Passing Style
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Continuation Passing Style
- en: 'The preceding code, in which you call a function but also pass another function
    that is to be executed when the input/output operation is finished, can be considered
    a case of CPS - *Continuation Passing Style*. What is this way of coding? A way
    of putting it, is by thinking about this question: how would you program if using
    the `return` statement was forbidden?'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您调用一个函数，同时传递另一个函数，该函数在输入/输出操作完成时将被执行，可以被视为CPS - *Continuation Passing
    Style*的一种情况。这种编码方式是什么？一个解释方式是，如果使用`return`语句是被禁止的，您将如何编程？
- en: 'At first glance, this may appear to be an impossible situation. We can get
    out of our fix, however, if we grant this: you are allowed to pass a callback
    to the called function, so when that procedure is ready to return to the caller,
    instead of actually returning, it shall invoke the passed callback. In these terms,
    the callback provides the called function with the way to continue the process,
    and thus the name *Continuation*. We won''t get into this now, but in [Chapter
    9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml), *Designing Functions - Recursion*,
    we will study it in depth. In particular, CPS will help to avoid an important
    recursion restriction, as we''ll see.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这可能看起来是一个不可能的情况。然而，我们可以摆脱困境，只要我们同意这一点：允许您将回调传递给被调用的函数，因此当该过程准备返回给调用者时，它将调用传递的回调，而不是实际返回。在这些条件下，回调为被调用的函数提供了继续过程的方式，因此称为*Continuation*。我们现在不会深入讨论这个问题，但在[第9章](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml)中，*设计函数
    - 递归*，我们将深入研究它。特别是，CPS将有助于避免重要的递归限制，正如我们将看到的那样。
- en: Working out how to use continuations is sometimes challenging, but always possible.
    An interesting advantage of this way of coding, is that by specifying yourself
    how the process is going to continue, you can go beyond all the usual structures
    (`if`, `while`, `return`, and so on) and implement whatever mechanisms you may
    want. This can be very useful in some kinds of problems, where the process isn't
    necessarily linear. Of course, this can also lead to you inventing any kind of
    control structures, far worse than the possible usage of `GOTO` statements that
    you might imagine! Figure 3.1 shows the dangers of that practice!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 研究如何使用continuations有时是具有挑战性的，但总是可能的。这种编码方式的一个有趣优势是，通过自己指定过程如何继续，您可以超越所有通常的结构（`if`，`while`，`return`等）并实现您可能想要的任何机制。这在某些类型的问题中可能非常有用，其中过程不一定是线性的。当然，这也可能导致您发明任何一种控制结构，远比您可能想象的使用`GOTO`语句更糟糕！图3.1显示了这种做法的危险！
- en: '![](assets/577e359e-169d-429c-b927-d468d5aa63fd.png)Figure 3.1: What''s the
    worse that could happen if you start messing with the program flow?'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/577e359e-169d-429c-b927-d468d5aa63fd.png)图3.1：如果您开始干扰程序流程，最糟糕的情况会是什么？'
- en: '(Note: This XKCD comic is available online at https://xkcd.com/292/.)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: （注：这张XKCD漫画可以在https://xkcd.com/292/上在线获取。）
- en: 'You are not limited to passing a single continuation. As with promises, you
    can provide two or more alternate callbacks. And this, by the way, can provide
    a solution to another problem: how would you work with exceptions? If we simply
    allowed a function to throw an error, it would be an implied return to the caller
    -- and we don''t want this. The way out is to provide an alternative callback
    (that is, a different continuation) to be used whenever an exception would be
    thrown (in [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml), *Building
    Better Containers - Functional Data Types*, we''ll find another solution, with *Monads*):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您不仅限于传递单个continuation。与promises一样，您可以提供两个或更多的备用回调。顺便说一句，这也可以提供另一个问题的解决方案：您如何处理异常？如果我们简单地允许函数抛出错误，那将意味着隐含地返回给调用者
    - 而我们不希望这样。解决方法是提供一个备用回调（即不同的continuation），以便在抛出异常时使用（在[第12章](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml)中，*构建更好的容器
    - 函数数据类型*，我们将找到另一个解决方案，使用*Monads*）：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Polyfills
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Polyfills
- en: Being able to assign functions dynamically (in the same way you can assign different
    values to a variable) also allows you to work more efficiently when defining *polyfills*.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 能够动态分配函数（就像您可以为变量分配不同的值一样）还可以让您在定义*polyfills*时更有效地工作。
- en: Detecting Ajax
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测Ajax
- en: 'Let''s go back a bit to the times when Ajax started to appear. Given those
    different browsers implemented Ajax calls in distinct fashions, you would always
    have to code around those differences:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到Ajax开始出现的时候。鉴于不同的浏览器以不同的方式实现了Ajax调用，您总是需要围绕这些差异编码：
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This worked but implied that you would re-do the Ajax check for each and every
    call -- even though the results of the test wouldn''t ever change. There''s a
    more efficient way to do so, and it has to do with using functions as first-class
    objects. We could define *two* different functions, test for the condition only
    once, and then assign the correct function to be used later:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法有效，但意味着你需要为每次调用重新执行Ajax检查，即使测试的结果永远不会改变。有一种更有效的方法，它涉及使用函数作为一等对象。我们可以定义*两个*不同的函数，只测试一次条件，然后将正确的函数分配给以后使用：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This piece of code shows two important concepts. First, we can dynamically
    assign a function: when this code runs, `window.getAjax` (that is, the global
    `getAjax` variable) will get one of three possible values, according to the current
    browser. When you later call `getAjax()` in your code, the right function will
    execute, without needing to do any further browser detection tests.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了两个重要的概念。首先，我们可以动态分配一个函数：当这段代码运行时，`window.getAjax`（即全局`getAjax`变量）将根据当前浏览器获得三种可能的值之一。当您稍后在代码中调用`getAjax()`时，正确的函数将执行，而无需进行任何进一步的浏览器检测测试。
- en: The second interesting idea is that we define the `initializeGetAjax` function,
    and immediately run it -- this pattern is called IIFE, standing for *Immediately
    Invoked Function Expression*. The function runs, but *cleans after itself*, for
    all its variables are local, and won't even exist after the function runs. We'll
    see more about this later.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个有趣的想法是我们定义了`initializeGetAjax`函数，并立即运行它——这种模式称为IIFE，代表*Immediately Invoked
    Function Expression*。函数运行后，会*自我清理*，因为它的所有变量都是局部的，在函数运行后甚至都不存在了。我们以后会更多地了解这一点。
- en: Adding missing functions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加缺失的函数
- en: 'This idea of defining a function on the run, also allows us to write *polyfills*that
    provide otherwise missing functions. For example, let''s say that instead of writing
    code like:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在运行时定义函数的想法，也使我们能够编写*polyfills*，提供其他缺失的函数。例如，假设我们不是写代码像：
- en: '[PRE37]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You''d very much prefer using the newer, clearer way, and just write:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你会更喜欢使用更新、更清晰的方式，只需写：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: What happens if your browser doesn't provide `.includes()`? Once again, we can
    define the appropriate function *on the run*, but only if needed. If `.includes()` is
    available, you need do nothing, but if it is missing, you then define a polyfill
    that will provide the very same workings.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的浏览器不提供`.includes()`会发生什么？再一次，我们可以在运行时定义适当的函数，但只有在需要时才这样做。如果`.includes()`可用，你什么都不用做，但如果它缺失了，你就定义一个提供完全相同功能的polyfill。
- en: You can find polyfills for many modern JS features at Mozilla's developer site.
    For example, the polyfill we used for includes was taken directly from [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Mozilla的开发者网站上找到许多现代JS功能的polyfill。例如，我们用于includes的polyfill直接取自[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes)。
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When this code runs, it checks whether the `String` prototype already has the
    includes method. If not, it assigns a function to it that does the same job, so
    from that point onward, you'll be able to use `.includes()` without further worries.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当这段代码运行时，它会检查`String`原型是否已经有了includes方法。如果没有，它会给它分配一个执行相同工作的函数，所以从那时起，你就可以使用`.includes()`而不用再担心了。
- en: Directly modifying a standard type's prototype object is usually frowned upon,
    because in essence, it's equivalent to using a global variable, and thus prone
    to errors. However, in this case, writing a polyfill for a well established and
    known function, is quite unlikely to provoke any conflicts.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 直接修改标准类型的原型对象通常是不被赞同的，因为本质上它相当于使用全局变量，因此容易出错。然而，在这种情况下，为一个已经被广泛认可和已知的函数编写polyfill，几乎不太可能引起任何冲突。
- en: 'Finally, if you happened to think that the Ajax example shown previously was
    old hat, consider this: if you want to use the more modern `fetch()` way of calling
    services, you will also find that not all modern browsers support it (check[http://caniuse.com/#search=fetch](http://caniuse.com/#search=fetch)
    to verify that) and you''ll have to use a polyfill too, such as the one at[https://github.com/github/fetch](https://github.com/github/fetch).
    Study the code, and you''ll see it basically uses the same method as described
    previously, to see if a polyfill is needed, and to create it.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你认为之前展示的Ajax示例已经老掉牙了，考虑一下：如果你想使用更现代的`fetch()`方式来调用服务，你会发现并不是所有的现代浏览器都支持它（查看[http://caniuse.com/#search=fetch](http://caniuse.com/#search=fetch)来验证），你也需要使用一个polyfill，比如[https://github.com/github/fetch](https://github.com/github/fetch)上的polyfill。研究一下代码，你会发现它基本上使用了之前描述的相同方法，来检查是否需要一个polyfill，并创建它。
- en: Stubbing
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stubbing
- en: 'This is a use case similar in some aspects to polyfill: having a function do
    different work depending on the environment. The idea is to do *stubbing*, an
    idea from testing, which means replacing a function with another that does a simpler
    job, instead of doing the actual work.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在某些方面类似于polyfill的用例：根据环境的不同，让函数执行不同的工作。这个想法是做*stubbing*，这是测试中的一个概念，意思是用另一个函数替换一个函数，这个函数执行一个更简单的工作，而不是执行实际的工作。
- en: 'A common case is the usage of logging functions. You may want the application
    to do detailed logging when in development, but not to say a peep when in production. A
    common solution would be writing something along the lines of:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的情况是使用日志函数。你可能希望应用程序在开发时进行详细的日志记录，但在生产时不发出任何声音。一个常见的解决方案是写一些类似于以下的东西：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This works, but as in the example about Ajax detection, it does more work than
    it
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是有效的，但就像关于Ajax检测的示例一样，它做的工作比需要的要多。
- en: 'about Ajax detection, it does more work than it needs since it checks every
    time if the application is in development. We could simplify the code (and get
    a really, really tiny performance gain!) if we stub out the logging function,
    so it won''t actually log anything:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Ajax检测，它做的工作比需要的要多，因为它每次都要检查应用程序是否处于开发状态。如果我们将日志函数stub out，这样它就不会实际记录任何东西，我们可以简化代码（并获得一个非常非常小的性能提升！）：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can even do better with the ternary operator:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以用三元运算符做得更好：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is a bit more cryptic, but I prefer it, because it uses a `const`, which
    cannot be modified.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点晦涩，但我更喜欢它，因为它使用了`const`，它是不可修改的。
- en: Given that JS allows calling functions with more parameters than arguments,
    and that we aren't doing anything in `myLog()`when we are not in development,
    we could have also written `() => {}` and it would have worked fine. I do prefer,
    however, keeping the same signature, and that's why I specified the `someText`
    argument, even if it wouldn't be used; your call!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到JS允许调用函数时传递比参数更多的参数，并且当我们不处于开发状态时`myLog()`不做任何事情，我们也可以写`() => {}`，它也可以正常工作。然而，我更喜欢保持相同的签名，这就是为什么我指定了`someText`参数，即使它不会被使用；由你决定！
- en: Immediate invocation
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 立即调用
- en: 'There''s yet another common usage of functions, usually seen in popular libraries
    and frameworks, that lets you bring into JS (even the older versions!) some modularity
    advantages from other languages. The usual way of writing this is something like
    the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种常见的函数用法，通常在流行的库和框架中看到，它让你从其他语言中带入JS（甚至是旧版本！）一些模块化的优势。通常的写法是像下面这样：
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Another equivalent style is `(function(){ ... }())` -- note the different placement
    of the parentheses for the function call. Both styles have their fans; pick whichever
    suits you, but just follow it consistently.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种等效的样式是`(function(){ ... }())` - 注意函数调用的括号放置不同。两种样式都有他们的粉丝；选择适合你的那种，但要保持一致。
- en: 'You can also have the same style, but passing some arguments to the function,
    which will be used as the initial values for its parameters:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用相同的样式，但将一些参数传递给函数，这些参数将用作其参数的初始值：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, you could also return something from the function:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你也可以从函数中返回一些东西：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The pattern itself is called, as we mentioned, *Immediately Invoked Function
    Expression*-- usually simplified to IIFE, pronounced *iffy*. The name is easy
    to understand: you are defining a function and calling it right away, so it gets
    executed on the spot. Why would you do this, instead of simply writing the code
    inline? The reason has to do with scopes.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 模式本身被称为，正如我们提到的，*立即调用函数表达式* - 通常简化为IIFE，发音为*iffy*。这个名字很容易理解：你正在定义一个函数并立即调用它，所以它立即执行。为什么要这样做，而不是简单地内联编写代码呢？原因与作用域有关。
- en: Note the parentheses around the function. This helps the parser understand that
    we are writing an expression. If you were to omit the first set of parentheses,
    JS would think you were writing a function declaration instead of an invocation. 
    The parentheses also serve as a visual note, so readers of your code will immediately
    recognize the IIFE.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数周围的括号。这有助于解析器理解我们正在写一个表达式。如果你省略了第一组括号，JS会认为你正在写一个函数声明而不是调用。括号也作为一个视觉提示，所以你的代码读者会立即认出IIFE。
- en: 'If you define any variables or functions within the IIFE, because of JS''s
    function scope, those definitions will be internal, and no other part of your
    code will be able to access it. Imagine you wanted to write some complicated initialization,
    like the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在IIFE内定义了任何变量或函数，由于JS的函数作用域，这些定义将是内部的，你的代码的任何其他部分都无法访问它。想象一下，你想写一些复杂的初始化，比如下面的例子：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'What could go wrong? The problem hinges on the fact that you could (by accident)
    have some function with the same name of any of the three here, and hoisting would
    imply that the *latter* function would be called:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出什么问题？问题在于你可能（不小心）有一个与这三个函数中的任何一个同名的函数，提升会意味着*后面*的函数会被调用：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Oops! If you had used an IIFE, the problem wouldn''t have happened. Also, the
    three inner functions wouldn''t even be visible for the rest of the code, which
    helps keeping the global namescape less polluted:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！如果你使用了IIFE，问题就不会发生。此外，三个内部函数甚至不会对代码的其余部分可见，这有助于保持全局命名空间的污染较少：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To see an example involving returned values, we could revisit the example from
    [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional
    - Several Questions*, and write the following, which would create a single counter:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要看一个涉及返回值的例子，我们可以重新访问[第1章](395f5897-0ecc-4841-86ed-21521e148beb.xhtml)中的例子，*成为函数式
    - 几个问题*，并编写以下内容，这将创建一个单一的计数器：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Then, every call `myCounter()` would return an incremented count -- but there
    is no chance that any other part of your code will overwrite the inner `count`
    variable because it's only accessible within the returned function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每次调用`myCounter()`都会返回一个递增的计数 - 但没有任何其他部分的代码会覆盖内部的`count`变量，因为它只能在返回的函数内部访问。
- en: Questions
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 3.1 **Uninitialized object?**React+Redux programmers usually code *action creators*to
    simplify the creation of actions that will later be processed by a reducer. Actions
    are objects, which must include a `type` attribute that is used to determine what
    kind of action you are dispatching.  The following code supposedly does that,
    but can you explain the unexpected results?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 3.1 **未初始化的对象？**React+Redux程序员通常编写*action creators*来简化稍后由reducer处理的操作的创建。操作是对象，必须包括一个`type`属性，用于确定你正在分派的操作的类型。下面的代码应该做到这一点，但你能解释意外的结果吗？
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 3.2\. **Are arrows allowed?** Would everything be the same if you defined `listArguments()`and
    `listArguments2()` using arrow functions, instead of the *classic*way we used,
    with the `function` keyword?
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 3.2\. **箭头函数允许吗？**如果你使用箭头函数来定义`listArguments()`和`listArguments2()`，而不是我们使用的*经典*方式，使用`function`关键字，一切都会一样吗？
- en: '3.3\. **One liner.**Some line-of-codes-thrifty programmer suggested rewriting
    `doAction2()` as a one-liner... though formatting doesn''t let it look so! What
    do you think: is it correct or isn''t it?'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 3.3\. **一行代码。**一些节省代码行数的程序员建议将`doAction2()`重写为一行代码...尽管格式不让它看起来如此！你认为这样正确吗？
- en: '[PRE51]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we went over several ways of defining functions in JS, focusing
    mainly on arrow functions, which have several advantages over standard functions,
    including being more terse. We showed the concept of *currying* (which we'll be
    revisiting later), considered some aspects of functions as first class objects,
    and we finally considered several JS techniques that happen to be fully FP in
    concept.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了JS中定义函数的几种方式，主要关注箭头函数，它比标准函数有几个优点，包括更简洁。我们展示了*柯里化*的概念（我们稍后会重新讨论），考虑了函数作为一等对象的一些方面，最后考虑了几种JS技术，这些技术在概念上完全是FP。
- en: In [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml), *Behaving Properly
    - Pure Functions*, let's delve even more deeply into functions, and thus introduce
    the concept of *pure functions*, which will lead us to even better style programming.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml)中，*行为得当 - 纯函数*，让我们更深入地探讨函数，从而引入*纯函数*的概念，这将使我们的编程风格更好。
