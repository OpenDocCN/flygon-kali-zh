- en: Chapter 7. Retro Squash Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 复古壁球游戏
- en: This chapter is where the fun starts. Although a retro squash game is obviously
    a step or two down from the latest big-budget game, it is the point when we start
    to look at some fundamentals—drawing, detecting when objects we have drawn bump
    into each other, and having animation that is actually controlled by us.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是游戏开始的地方。尽管复古壁球游戏显然比最新的大型预算游戏要差一两步，但这是我们开始看一些基本原理的时候——绘图，检测我们绘制的对象何时相互碰撞，以及有我们实际控制的动画。
- en: Once you can draw a pixel and move it, it only needs a bit of imagination and
    work and you have the potential to draw anything. Then, when we combine this knowledge
    with some really simple math to simulate the physics of collision and gravity,
    we will be close to being able to implement our squash game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你能够绘制一个像素并移动它，只需要一点想象力和工作，你就有了绘制任何东西的潜力。然后，当我们将这些知识与一些非常简单的数学结合起来，来模拟碰撞和重力的物理过程时，我们就接近能够实现我们的壁球游戏了。
- en: Tip
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Sadly, this book does not have the time to go into the mathematics of turning
    a dot on the screen into realistic three-dimensional characters moving around
    in a three-dimensional world. Certainly, the technology and math behind big-budget
    titles is very advanced and complicated. However, the basics of turning pixels
    into lines and lines into triangles, texturing a triangle, building objects out
    of triangles, and positioning them in a three-dimensional world are within the
    grasp of anybody who has learned high-school-level math. Often, we hear that great
    graphics don''t make a great game, which is true, but great graphics (at least
    for me) are one of the most exciting aspects of video games, even when they are
    displayed on a game that could be more fun to play by itself. If you want to see
    how to turn pixels into magical worlds, and start to appreciate what goes on behind
    the scenes of the top game engines and graphics libraries, you could start with
    *Computer Graphics: Mathematical First Steps*, *P.A. Egerton and W.S Hall*, *Prentice
    Hall*.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这本书没有时间深入讲解如何将屏幕上的点变成在三维世界中移动的逼真三维角色的数学。当然，大型预算游戏背后的技术和数学非常先进和复杂。然而，将像素转化为线条，将线条转化为三角形，给三角形贴图，用三角形构建物体，并将它们定位在三维世界中的基础知识，都可以被学过高中数学的任何人掌握。我们经常听说优秀的图形并不一定能创造出优秀的游戏，这是真的，但对我来说，优秀的图形（至少对我来说）是视频游戏中最令人兴奋的方面之一，即使它们显示在一个本身可能更有趣的游戏上。如果你想看看如何将像素变成神奇的世界，并开始欣赏顶级游戏引擎和图形库背后的工作，你可以从《计算机图形学：数学初步》、P.A.
    Egerton和W.S Hall、Prentice Hall开始。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Explore the Android `Canvas` class, which makes drawing easy and fun
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Android的`Canvas`类，使绘图变得简单有趣
- en: Write a simple Canvas demo app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的Canvas演示应用程序
- en: Learn about detecting touches on the screen
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在屏幕上检测触摸
- en: Create the retro squash game
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建复古壁球游戏
- en: Implement the retro squash game
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现复古的壁球游戏
- en: Drawing with Android Canvas
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Android Canvas进行绘图
- en: So far, we have been using the Android UI designer to implement all our graphics.
    This is fine when all we need are objects such as buttons and text.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用Android UI设计师来实现所有的图形。当我们只需要按钮和文本等对象时，这是可以的。
- en: It is true that there is more to the Android UI elements than we have explored
    so far. For example, we know we can do a lot more with the `Animation` class,
    and we very briefly saw that we can assign any image we like to represent one
    of the UI elements.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Android UI元素确实比我们迄今所探索的更多。例如，我们知道我们可以用`Animation`类做更多的事情，我们也很简要地看到我们可以为UI元素中的一个分配任何我们喜欢的图像。
- en: As an example, we could assign game characters such as spaceships to UI elements
    and animate them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以将游戏角色（如太空飞船）分配给UI元素并对它们进行动画。
- en: However, if we want smoothly moving spaceships with accurate collision detection,
    cute characters, and gruesome baddies with multiframe, cartoon-like animation,
    then we are going to need to move away from predefined UI elements.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们想要平滑移动的太空飞船，准确的碰撞检测，可爱的角色，以及具有多帧、卡通般动画的可怕的坏家伙，那么我们需要摆脱预定义的UI元素。
- en: We are going to need to start looking at and designing with individual pixels,
    lines, bitmaps, and sprite sheets. Fortunately, as you might have guessed, Android
    has some classes to make this nice and easy for us. We will be learning how to
    get started with the `Canvas` and `Paint` classes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要开始查看和设计单个像素、线条、位图和精灵表。幸运的是，正如你可能已经猜到的那样，Android有一些类可以让我们轻松愉快地做到这一点。我们将学习如何开始使用`Canvas`和`Paint`类。
- en: Bitmaps and sprite sheets will be covered in the next chapter. In this chapter,
    we will learn how to draw pixels and lines to make a simple, smoothly moving pong-style
    game of squash.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 位图和精灵表将在下一章中介绍。在本章中，我们将学习如何绘制像素和线条，制作一个简单的、平滑移动的乒乓球风格的壁球游戏。
- en: To achieve this, we will learn about the coordinate system we use to draw our
    pixels and lines. Then we will look at the `Paint` and `Canvas` classes themselves.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将学习我们用来绘制像素和线条的坐标系。然后我们将看看`Paint`和`Canvas`类本身。
- en: The Android coordinate system
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android坐标系
- en: A pixel is the smallest graphical element we can manipulate using the `Paint`
    and `Canvas` classes. It is essentially a dot. If your device resolution is 1920
    x 1080, like some of the newer Google-branded tablets or high-end Samsung phones,
    then we have 1920 pixels across the longest length of the device and 1080 pixels
    across the width.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 像素是我们可以使用`Paint`和`Canvas`类来操作的最小图形元素。它本质上是一个点。如果你的设备分辨率是1920 x 1080，就像一些新的谷歌品牌平板电脑或高端三星手机一样，那么在设备的最长长度上有1920个像素，在宽度上有1080个像素。
- en: We can therefore think of our screen on which we will be drawing as a grid.
    We draw using the `Canvas` and `Paint` classes on a virtual canvas. We will do
    so by plotting points (pixels), lines, shapes, and text using coordinates on this
    grid.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将我们要绘制的屏幕看作一个网格。我们在虚拟画布上使用`Canvas`和`Paint`类进行绘制。我们将通过在这个网格上的坐标上绘制点（像素）、线条、形状和文本来实现这一点。
- en: The coordinate system starts in the top-left corner of the screen.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标系统从屏幕的左上角开始。
- en: 'As an example, take a look at this line of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，看看这行代码：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this, we would plot a single pixel in the top-left corner of the screen.
    Now look at the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将在屏幕的左上角绘制一个单个像素。现在看看以下代码：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we use it like this, we could draw a point in the bottom-right corner of
    one of these high-end devices (while in the landscape position).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们像这样使用它，我们可以在这些高端设备的右下角绘制一个点（在横向位置时）。
- en: 'We could also draw lines by specifying a start and end coordinate position,
    a bit like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过指定起始和结束坐标位置来绘制线条，就像这样：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This would draw a line from the top-left corner of the screen to the bottom
    right.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从屏幕的左上角画一条线到右下角。
- en: You might have noticed some potential problems. Firstly, not all Android devices
    have such a high resolution; in fact, most are significantly lower. Even devices
    with high resolution will have totally different coordinates when held in landscape
    or portrait positions. How will we write code that adapts to these devices regardless
    of the screen resolution? We will see the solution soon.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到一些潜在的问题。首先，并非所有的Android设备都具有如此高的分辨率；事实上，大多数设备的分辨率要低得多。即使是分辨率很高的设备在横向或纵向位置时，坐标也会完全不同。我们将很快看到如何编写适应这些设备的代码，而不管屏幕分辨率如何。
- en: Animating our pixels
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的像素动画
- en: 'Drawing shapes, lines, and pixels is all very well, but how do we make them
    appear to move? We will be using the same animation trick used in cartoons, movies,
    and other video games:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制形状、线条和像素都很好，但我们如何使它们看起来移动呢？我们将使用卡通、电影和其他视频游戏中使用的相同动画技巧：
- en: Draw an object.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个对象。
- en: Rub it out.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 擦掉它。
- en: Draw the object in its new position.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其新位置绘制对象。
- en: Repeat fast enough to trick the player's brain that the game objects are moving.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以足够快的速度重复，以欺骗玩家的大脑，使游戏对象移动。
- en: The theory makes all of this sound more complicated than it is. Let's take a
    quick look at the `Paint` and `Canvas` classes and a quick introductory demo app.
    Then we can implement our retro squash game for real.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 理论使所有这些听起来比实际复杂。让我们快速看一下“Paint”和“Canvas”类以及一个快速的入门演示应用程序。然后我们可以真正实现我们的复古壁球游戏。
- en: Getting started with Canvas and Paint
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用Canvas和Paint
- en: The aptly named `Canvas` class provides just what you would expect—a virtual
    canvas to draw our graphics on.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 贴切地命名的“Canvas”类提供了正是你所期望的——一个虚拟画布，用于绘制我们的图形。
- en: We can make a virtual canvas using the `Canvas` class from any Android UI element.
    In our demo app, we will draw on an ImageView, and when we make our game, we will
    draw straight on a special type of view, which will bring some extra advantages,
    as we will see.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用“Canvas”类从任何Android UI元素创建一个虚拟画布。在我们的演示应用程序中，我们将在一个ImageView上绘制，当我们制作我们的游戏时，我们将直接在一个特殊类型的视图上绘制，这将带来一些额外的优势，正如我们将看到的那样。
- en: 'To get started, we need a view to draw on. We already know how to get a view
    from our UI layout using Java code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要一个视图来绘制。我们已经知道如何使用Java代码从我们的UI布局中获取视图：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This line of code grabs a reference to an ImageView placed in the UI design
    and assigns it to our object in our Java code. As we have seen, the ImageView
    in the UI design has an assigned ID of `imageView`, and our controllable ImageView
    object in our Java code is called `ourView`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码获取了UI设计中放置的ImageView的引用，并将其分配给我们Java代码中的对象。正如我们所看到的，UI设计中的ImageView具有一个名为“imageView”的分配ID，而我们在Java代码中可控的ImageView对象称为“ourView”。
- en: 'Now we need a bitmap. A bitmap itself has a coordinate system like the screen.
    We are creating a bitmap to turn it into a canvas:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个位图。位图本身有一个像屏幕一样的坐标系统。我们正在创建一个位图将其转换为画布：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous line of code declares and creates an object of the `Bitmap` type.
    It will have a size of 300 by 600 pixels. We will keep this in mind when we draw
    on it shortly.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码声明并创建了一个“Bitmap”类型的对象。它将有300x600像素的大小。我们将在稍后绘制时记住这一点。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The last argument in the `createBitmap` method, `Bitmap.Config.ARGB_8888`, is
    simply a format, and we can create some great games without getting into the different
    options for bitmap formats.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: “createBitmap”方法中的最后一个参数“Bitmap.Config.ARGB_8888”只是一个格式，我们可以创建一些很棒的游戏，而不用涉及位图格式的不同选项。
- en: 'Now we can prepare our bitmap for drawing by creating a `Canvas` object from
    it:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过从中创建一个“Canvas”对象来准备我们的位图进行绘制：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we get ourselves an object of the `Paint` type. We can think of this
    object as the brush and the paint for our virtual canvas:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们得到一个“Paint”类型的对象。我们可以把这个对象看作是我们虚拟画布的刷子和颜料：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At this point, we are ready to use our `Paint` and `Canvas` objects to do some
    drawing. The actual code to draw a pixel in the top-left corner of the screen
    will look like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们准备使用我们的“Paint”和“Canvas”对象进行一些绘图。在屏幕左上角绘制一个像素的实际代码将如下所示：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let's now look at a working example.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个工作示例。
- en: Android Canvas demo app
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Canvas演示应用程序
- en: Let's make an app that uses the `Canvas` and `Paint` classes and do a bit of
    drawing. This example will be completely static (no animation), so we can clearly
    see how to use `Canvas` and `Paint` without cluttering the code with things we
    will learn later.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制作一个使用“Canvas”和“Paint”类并进行一些绘图的应用程序。这个例子将是完全静态的（没有动画），所以我们可以清楚地看到如何在不用后续学习的东西的情况下使用“Canvas”和“Paint”。
- en: 'In this demo app, we use some conceptually helpful variable names to help us
    grasp the role that each object is playing, but we will go through the whole thing
    at the end to make sure we know exactly what is going on at each stage. Of course,
    you don''t have to type all of this. You can open the completed code files from
    the `CanvasDemo` folder in the `Chapter7` folder of the download bundle:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个演示应用程序中，我们使用了一些概念上有帮助的变量名，以帮助我们理解每个对象所扮演的角色，但我们将在最后通过整个过程，以确保我们确切知道每个阶段发生了什么。当然，你不必输入所有这些。您可以在下载包的“Chapter7”文件夹中的“CanvasDemo”文件夹中打开已完成的代码文件：
- en: Start a new project and call it `CanvasDemo`. Tidy up the unnecessary imports
    and overrides if you want to.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新项目，称之为`CanvasDemo`。如果愿意，可以清理不必要的导入和覆盖。
- en: Open `activity_main.xml` in the editor. Drag an **ImageView** from the palette
    to the layout. The ImageView has an ID by default, which is `imageView`. Now we
    will use this ID in our code.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开`activity_main.xml`。从调色板中将**ImageView**拖动到布局中。ImageView默认具有一个ID，即`imageView`。现在我们将在我们的代码中使用这个ID。
- en: 'Switch to `MainActivity.java` in the editor. First, we will create our `Bitmap`,
    `Canvas`, and `Paint` objects as we discussed earlier. Here is the first part
    of the code. Enter it directly after the call to the `setContentView` method:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中切换到`MainActivity.java`。首先，我们将创建我们的`Bitmap`、`Canvas`和`Paint`对象，就像我们之前讨论的那样。这是代码的第一部分。在`setContentView`方法调用之后直接输入它：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we try out some of the cool things we can draw. Enter the code directly
    after the code in the previous step:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们尝试绘制一些很酷的东西。在上一步中的代码之后直接输入代码：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the demo on an emulator or a device.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或设备上运行演示。
- en: 'Your output will look like what is shown in the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您的输出将看起来像下面的截图所示：
- en: '![Android Canvas demo app](img/8859OS_07_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![Android Canvas demo app](img/8859OS_07_05.jpg)'
- en: Let's go through the code again. In steps 1 and 2, we created a new project
    and placed an ImageView object with an ID of `imageView` on our UI layout.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次浏览代码。在步骤1和2中，我们创建了一个新项目，并在UI布局上放置了一个ID为`imageView`的ImageView对象。
- en: 'In step 3, we started by getting a reference to the `ImageView` object in our
    layout. However, we have done this often, usually with TextViews and Buttons.
    We named our ImageView `ourFrame` because it will hold our canvas:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步中，我们首先获取了布局中`ImageView`对象的引用。然而，我们经常这样做，通常是使用TextView和Button。我们将我们的ImageView命名为`ourFrame`，因为它将容纳我们的画布：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we created a bitmap to be used to make a canvas:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个位图用于制作画布：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After that, we created our new `Paint` object:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们创建了新的`Paint`对象：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In step 4, we were ready to draw, and we did so in a few different ways. First,
    we painted the entire canvas black:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们准备好绘制，并以几种不同的方式绘制。首先，我们将整个画布涂成黑色：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we chose the color with which we will be painting. `(255, 255, 255, 255)`
    is a numerical representation of white with full opacity (no transparency):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们选择了要绘制的颜色。`(255, 255, 255, 255)`是白色的数字表示，完全不透明（没有透明度）：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now we see something new, but it is quite easy to understand. We can also draw
    strings of text to the screen and position that text at precise screen coordinates,
    just like we can with a pixel.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到了一些新东西，但很容易理解。我们还可以将文本字符串绘制到屏幕上，并将该文本定位到精确的屏幕坐标，就像我们可以使用像素一样。
- en: 'You will notice that with the `drawText` method and all other drawing methods
    of the `Canvas` class, we always pass our `Paint` object as an argument. Just
    to make what is going on in the next line of code absolutely clear, I am stating
    that `"Score: 42 Lives:3 Hi: 97`" is the string that will be drawn on the screen,
    `10, 10` are the screen coordinates, and `paint` is our `Paint` object:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '您会注意到，使用`Canvas`类的`drawText`方法和所有其他绘图方法时，我们总是将我们的`Paint`对象作为参数传递。为了让下一行代码中发生的事情绝对清晰，我声明`"Score:
    42 Lives:3 Hi: 97`"是将在屏幕上绘制的字符串，`10, 10`是屏幕坐标，`paint`是我们的`Paint`对象：'
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we draw a line. The argument list here can be described as follows: (start
    *x* coordinate, start *y* coordinate, end *x* coordinate, end *y* coordinate,
    our `Paint` object):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们画一条线。这里的参数列表可以描述如下：（起始*x*坐标，起始*y*坐标，结束*x*坐标，结束*y*坐标，我们的`Paint`对象）：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now we see that we can draw circles. We can also draw other shapes. The argument
    list here can be described as follows: (start *x* coordinate, start *y* coordinate,
    radius of circle, our `Paint` object):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到我们可以绘制圆。我们还可以绘制其他形状。这里的参数列表可以描述如下：（圆的起始*x*坐标，起始*y*坐标，圆的半径，我们的`Paint`对象）：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then we draw a humble, lonely pixel (point). The arguments we use are in this
    format: (*x* coordinate, *y* coordinate, `Paint` object):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们画了一个不起眼的孤独像素（点）。我们使用的参数格式如下：（*x*坐标，*y*坐标，`Paint`对象）：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, we place our bitmap canvas on our ImageView frame:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将我们的位图画布放在我们的ImageView框架上：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We still need to get smarter with managing screen resolution and orientation,
    and we will do so in our retro squash game. Also, we need to look for a system
    that will allow us to rub out and redraw our images at a set interval to create
    the illusion of movement. Actually, we already know one such system. Think about
    how we might use threads to achieve this illusion. First of all, let's take a
    look at how the player will control the game. After all, we are not going to have
    any handy UI buttons to press for this game.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要更加智能地管理屏幕分辨率和方向，我们将在我们的复古挤压游戏中这样做。此外，我们需要寻找一种系统，使我们能够在一定的时间间隔内擦除和重绘我们的图像，以创造运动的错觉。实际上，我们已经知道这样的系统。想想我们如何使用线程来实现这种错觉。首先，让我们看看玩家将如何控制游戏。毕竟，我们不会有任何方便的UI按钮来按下这个游戏。
- en: Detecting touches on the screen
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测屏幕上的触摸
- en: In our retro squash game, we will have no UI buttons, so we cannot use the `OnClickListener`
    interface and override the `onClick` method. This is not a problem, however. We
    will just use another interface to suit our situation. We will use `OnTouchListener`
    and override the `onTouchEvent` method. It works a bit differently, so let's take
    a look at implementing it before we dive into the game code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的复古挤压游戏中，我们将没有UI按钮，因此我们无法使用`OnClickListener`接口并重写`onClick`方法。但是这不是问题。我们将使用另一个接口来适应我们的情况。我们将使用`OnTouchListener`并重写`onTouchEvent`方法。它的工作方式有点不同，因此在我们深入游戏代码之前，让我们看看如何实现它。
- en: 'We must implement the `OnTouchListener` interface for the activity we want
    to listen to touches in, like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为我们想要监听触摸的活动实现`OnTouchListener`接口，就像这样：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then we can override the `onTouchEvent` method, perhaps a bit like this.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以重写`onTouchEvent`方法，也许有点像这样。
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `x` variable will hold the horizontal value of the position on the screen
    that was touched, and `y` will hold the vertical position. It is worth noting
    that the `motionEvent` object parameter contains lots of information as well as
    the *x* and *y* location, for example, whether the screen was touched or released.
    We can make some really useful switch statements with this information, as we
    will see later.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`x`变量将保存触摸屏幕的水平位置值，`y`将保存垂直位置。值得注意的是`motionEvent`对象参数包含大量信息，以及*x*和*y*的位置，例如屏幕是否被触摸或释放。我们可以利用这些信息制作一些非常有用的开关语句，稍后我们将看到。'
- en: Knowing exactly how we use this to achieve our goals in the squash game requires
    us to first consider the design of the game.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何利用这一点来实现我们在壁球游戏中的目标需要我们首先考虑游戏的设计。
- en: Preparing to make the retro squash game
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备制作复古壁球游戏
- en: Now we are ready to discuss the making of our next game. We actually know everything
    we need to. We just need to think about how to use the different techniques we
    have learned.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备讨论制作我们下一个游戏。我们实际上已经知道我们需要的一切。我们只需要考虑如何使用我们学到的不同技术。
- en: Let's first look at exactly what we want to achieve so that we have something
    to aim for.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先确切地了解我们想要实现的目标，这样我们就有了一个目标。
- en: The design of the game
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏的设计
- en: Let's look at a screenshot of the game as a good starting point. When you design
    your own games, drawing sketches of the in-game objects and mechanics of the game
    will be an invaluable part of the design process. Here, we can cheat a bit by
    taking a look at the end result.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下游戏的屏幕截图，作为一个很好的起点。当你设计自己的游戏时，绘制游戏对象和游戏机制的草图将是设计过程中非常宝贵的一部分。在这里，我们可以通过查看最终结果来稍微作弊一下。
- en: '![The design of the game](img/8859OS_07_15.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![游戏的设计](img/8859OS_07_15.jpg)'
- en: The UI
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户界面
- en: Starting from the top, we have **Score**. Every time the player successfully
    hits the ball, a point is added. Next, we have **Lives**. The player starts with
    three lives, and every time they let a ball go past their racket, they lose one
    life. When the player has zero lives, their score is set to zero, lives are set
    back to three, and the game begins again. Next to this, we have **FPS**. FPS stands
    for frames per second. It would be nice if we monitor on the screen the number
    of times our screen is being redrawn every second, as this is the first time we
    are animating our very own graphics.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，我们有**得分**。每当玩家成功击中球时，就会增加一个点。接下来是**生命**。玩家从三条生命开始，每次让球从球拍下通过，就会失去一条生命。当玩家生命值为零时，他们的得分将被设置为零，生命值将被重新设置为三，游戏将重新开始。在这之后，我们有**FPS**。FPS代表每秒帧数。如果我们能在屏幕上监视我们的屏幕每秒重绘的次数，那将是很好的，因为这是我们第一次在动画中使用我们自己的图形。
- en: Approximately in the middle of the previous screenshot is the ball. It is a
    square ball, in keeping with the traditional pong style. Squares are also easier
    when you have to perform realistic-looking collision detection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张屏幕截图的中间位置大约是球。它是一个方形的球，符合传统的乒乓球风格。当你需要执行看起来真实的碰撞检测时，方形也更容易。
- en: Physics
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理
- en: 'We will detect when the ball hits any of the four sides of the screen as well
    as when it hits the racket. Depending on what the ball hits and its current direction
    at the time of the collision, we will determine what happens to the ball. Here
    is a rough outline of what each type of collision will do:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检测当球击中屏幕的四个边缘以及击中球拍时。根据球击中的物体以及碰撞时的当前方向，我们将确定球的下一步动作。以下是每种类型碰撞的大致概述：
- en: '**Hit the top of the screen**: The ball will maintain the same horizontal (*x*)
    direction of travel but reverse the vertical (*y*) direction of travel.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**击中屏幕顶部**：球将保持相同的水平（*x*）行进方向，但会反转垂直（*y*）行进方向。'
- en: '**Hit either side of the screen**: The ball will maintain its *y* direction
    of travel but reverse its *x* direction.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**击中屏幕的任一侧**：球将保持其*y*行进方向，但会反转其*x*行进方向。'
- en: '**Hit the bottom of the screen**: The ball will disappear and restart at the
    top of the screen with a downward *y* direction of travel and a random *x* direction
    of travel.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**击中屏幕底部**：球将消失，并在屏幕顶部重新开始，向下的*y*行进方向和随机的*x*行进方向。'
- en: '**Hit the player''s racket**: We will check whether the ball has hit the left
    or the right of the racket and alter the *x* direction of travel to match. We
    will also reverse the *y* direction of travel to send the ball back to the top
    again.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**击中玩家的球拍**：我们将检查球是否击中球拍的左侧或右侧，并改变*x*行进方向以匹配。我们还将反转*y*行进方向，将球再次发送到顶部。'
- en: By enforcing these crude virtual rules of physics, we can simply create a ball
    that behaves almost as we would expect a real ball to do. We will add a few properties
    such as slightly increasing the ball speed after hitting the racket. These rules
    will work just as well in portrait or landscape orientations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过强制执行这些粗糙的虚拟物理规则，我们可以简单地创建一个表现几乎像真实球一样的球。我们将添加一些属性，例如在击中球拍后稍微增加球的速度。这些规则在纵向或横向方向上同样有效。
- en: The player's racket will be a simple rectangle that the player can slide left
    by holding anywhere on the left half of the screen, and right by holding anywhere
    on the right of the screen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家的球拍将是一个简单的矩形，玩家可以通过在屏幕左半部分任意位置按住左移，通过在屏幕右半部分任意位置按住右移。
- en: For brevity, we will not be making a main menu screen to implement high scores.
    In our final game, which we start in the next chapter, we will go ahead and have
    an animated menu screen, online high scores, and achievements. However, this squash
    game will simply restart when the player reaches zero lives.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们不会制作一个主菜单屏幕来实现高分。在我们下一章开始的最终游戏中，我们将继续制作一个动画菜单屏幕、在线高分和成就。然而，当玩家生命值为零时，这个壁球游戏将简单地重新开始。
- en: The structure of the code
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码的结构
- en: Here, we will take a quick theoretical look at some aspects of the implementation
    that might be raising questions. When we finally get down to the implementation,
    we should find most of the code quite straightforward, with only a few bits that
    might need extra explanation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将快速理论地看一下实现中可能引起问题的一些方面。当我们最终开始实现时，我们应该会发现大部分代码非常简单，只有少数几个部分可能需要额外的解释。
- en: We have discussed everything we need to know, and we will also discuss specifics
    in the code as we go through the implementation. We will go over the trickier
    parts of the code at the end of each phase of implementation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了我们需要知道的一切，我们也将在实现过程中讨论代码的具体内容。我们将在每个实现阶段结束时讨论代码中更棘手的部分。
- en: As usual, all the completed code files can be found in the download bundle.
    The files encompassing all the phases of this project are in the `Chapter7/RetroSquash`
    folder.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，所有已完成的代码文件都可以在下载包中找到。这个项目的所有阶段的文件都在`Chapter7/RetroSquash`文件夹中。
- en: We have learned that in an application using classes and their methods, different
    parts of the code will be dependent on other parts. Therefore, rather than jumping
    back and forth in the code, we will lay it out from the first line to the last
    in order. Of course, we will also refer to the related parts of code as we go
    along. I definitely recommend studying the code in its entirety to fully grasp
    what is going on and which parts of the code call which other parts.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，在使用类和它们的方法的应用程序中，代码的不同部分将依赖于其他部分。因此，我们不会在代码中来回跳跃，而是按顺序从第一行到最后一行进行布局。当然，我们在进行过程中也会参考相关的代码部分。我强烈建议全面研究代码，以充分理解正在发生的事情以及代码的哪些部分调用了其他部分。
- en: To prevent this implementation from spreading into an enormous to-do list, it
    has been broken into four phases. This should provide convenient places to stop
    and take a break.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这个实现变成一个庞大的待办事项列表，它已经被分成了四个阶段。这应该提供方便的停止和休息的地方。
- en: 'There is no layout file and only one `.java` file. This file is called `MainActivity.java`.
    The `MainActivity.java` file has a structure as indicated in the following overview
    of the code. I have indented some parts to show what parts are enclosed within
    others. This is a high-level view, and it omits quite a lot of detail:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 没有布局文件，只有一个`.java`文件。这个文件叫做`MainActivity.java`。`MainActivity.java`文件的结构如下概述所示。我缩进了一些部分，以显示哪些部分包含在其他部分中。这是一个高层次的视图，它省略了很多细节：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As previously stated, we can see that everything is in the `MainActivity.java`
    file. As usual, at the top of our file, we will have a package name and a load
    of imports for the different classes we will be using.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所述，我们可以看到一切都在`MainActivity.java`文件中。和往常一样，在文件的顶部，我们将有一个包名和一堆导入不同类的导入。
- en: Next, as per all our other projects, we have the `MainActivity` class. It encompasses
    everything else, even the `SquashCourtView` class. This makes the `SquashCourtView`
    class an inner class and will therefore be able to access the member variables
    of the `MainActivity` class, which will be essential in this implementation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，和我们其他项目一样，我们有`MainActivity`类。它包含了其他所有内容，甚至`SquashCourtView`类。这使得`SquashCourtView`类成为一个内部类，因此能够访问`MainActivity`类的成员变量，这在实现中将是必不可少的。
- en: Before the `SquashCourtView` class, however, comes the declaration of all the
    member variables in the `MainActivity` class, followed by a fairly in-depth `onCreate`
    method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`SquashCourtView`类之前，`MainActivity`类中声明了所有成员变量，然后是一个相当深入的`onCreate`方法。
- en: We could implement the other Android lifecycle methods next, and you are welcome
    to do so. However, the code within the other Android lifecycle methods will make
    more sense once we have seen the code in the `SquashCourtView` class methods.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以接下来实现其他Android生命周期方法，欢迎你这样做。然而，一旦我们看到`SquashCourtView`类方法中的代码，其他Android生命周期方法中的代码将更有意义。
- en: After `onCreate`, we will implement the `SquashCourtView` class. This has some
    fairly long methods in it, so we will break it into phases 2 and 3.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`之后，我们将实现`SquashCourtView`类。这个类中有一些相当长的方法，所以我们将把它分成阶段2和3。
- en: Finally, we will implement the remaining Android lifecycle methods. They are
    short but important.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现剩余的Android生命周期方法。它们很短，但很重要。
- en: The four implementation phases in detail
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细介绍的四个实现阶段
- en: 'Let''s take an even closer look at the implementation before we actually get
    to it. Here is how we will divide the implementation into the four phases, this
    time with a bit more detail as to what to expect in each:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们真正开始之前，让我们更仔细地看看实现。这是我们将如何将实现分成四个阶段，这次更详细地说明每个阶段可以期待的内容：
- en: '**Phase 1 – MainActivity and onCreate**: In this phase, we will create the
    project itself as well as implement the following steps:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段1 - MainActivity和onCreate**：在这个阶段，我们将创建项目本身，并实现以下步骤：'
- en: We will add our imports and create the body of our `MainActivity` class
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将添加我们的导入并创建我们的`MainActivity`类的主体
- en: Within this, we will declare the member variables that the game needs
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将声明游戏需要的成员变量
- en: We will implement our `onCreate` method, which does loads of setup work but
    nothing that is hard to understand
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将实现我们的`onCreate`方法，这个方法需要做大量的设置工作，但没有什么难以理解的东西。
- en: '**Phase 2 – SquashCourtView part 1**: In this phase, we will start work on
    our key class, `SquashCourtView`. Specifically, we will:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段2 - SquashCourtView第1部分**：在这个阶段，我们将开始处理我们的关键类`SquashCourtView`。具体来说，我们将：'
- en: Implement the declaration of the `SquashCourtView` class and its member variables.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`SquashCourtView`类及其成员变量的声明。
- en: Write a simple constructor.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的构造函数。
- en: Implement the `run` method to control the flow of the game.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现`run`方法来控制游戏的流程。
- en: Implement the lengthy but fairly easy-to-understand `updateCourt` method. This
    is the method that handles collision detection and keeps track of our ball and
    racket.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现冗长但相当容易理解的`updateCourt`方法。这个方法处理碰撞检测并跟踪我们的球和球拍。
- en: '**Phase 3 – SquashCourtView part 2**: In this phase, we will finish the `SquashCourtView`
    class by implementing the following:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第3阶段-SquashCourtView第2部分**：在这个阶段，我们将通过实现以下内容完成`SquashCourtView`类：'
- en: The `drawCourt` method, which unsurprisingly does all the drawing
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawCourt`方法，毫不奇怪地进行所有绘制'
- en: The `controlFPS` method, which makes the game run at similar speeds on devices
    that have different CPUs
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controlFPS`方法，使游戏在具有不同CPU的设备上以相似的速度运行'
- en: Next, we will quickly write a couple of methods that help the Android lifecycle
    methods with similar names—the `pause` and `resume` methods
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将快速编写一些帮助Android生命周期方法的方法，这些方法具有类似的名称——`pause`和`resume`方法
- en: Finally for this phase, we will easily handle the touch controls of the game
    by overriding the `onTouchEvent` method we looked at earlier
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，在这个阶段，我们将通过重写我们之前查看过的`onTouchEvent`方法轻松处理游戏的触摸控制
- en: '**Phase 4 – Remaining lifecycle methods**: In this short phase we will add
    the finishing touches:'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第4阶段-剩余的生命周期方法**：在这个简短的阶段，我们将添加最后的修饰：'
- en: Quickly implement what happens in the `onPause`, `onResume`, and `onStop` methods
    by overriding them
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重写`onPause`，`onResume`和`onStop`方法快速实现发生的情况
- en: We will also handle what happens when the player presses the back button on
    their phone or tablet
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将处理玩家在手机或平板上按返回按钮时发生的情况
- en: Phase 1 – MainActivity and onCreate
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1阶段-MainActivity和onCreate
- en: 'Now that we have seen what we will do in each of the phases, let''s actually
    get started with building our game by performing the following steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经看到了每个阶段我们将要做什么，让我们通过执行以下步骤来开始构建我们的游戏：
- en: 'Create a new project, just as we have before, but with one slight difference.
    This time, on the **New Project** dialog, change **Minimum required SDK** to **API
    13: Android 3.2 (Honeycomb)**. Call the project `RetroSquash`. Delete the unnecessary
    overridden methods if you like.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新项目，就像我们以前做的那样，但有一个小小的不同。这一次，在**新项目**对话框中，将**最低要求的SDK**更改为**API 13：Android
    3.2（蜂巢）**。将项目命名为`RetroSquash`。如果愿意，可以删除不必要的重写方法。
- en: 'Edit the `AndroidManifest.xml` file, just as we did at the end of [Chapter
    4](ch04.xhtml "Chapter 4. Discovering Loops and Methods"), *Discovering Loops
    and Methods*, to make the app use the full screen. Check back for full details
    if needed. Note that we are *not* locking orientation because this game is fun
    in both portrait and landscape. Here is the line of code to add:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`AndroidManifest.xml`文件，就像我们在[第4章](ch04.xhtml "第4章。发现循环和方法")结束时所做的那样，*发现循环和方法*，使应用程序使用全屏。如有需要，请查看完整的详细信息。请注意，我们*不*锁定方向，因为这个游戏在纵向和横向都很有趣。这是要添加的代码行：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Make some sound effects using Bfxr, as we did in [Chapter 5](ch05.xhtml "Chapter 5. Gaming
    and Java Essentials"), *Gaming and Java Essentials*. Four will be enough, but
    there is nothing stopping you from adding more sounds. For authentic 1970s-style
    sounds, try the **Blip/Select** button shown in the following screenshot. Name
    the samples `sample1.ogg`, `sample2.ogg`, `sample3.ogg`, and `sample4.ogg`. Or
    you can just use my samples. They are in the `assets` folder of the folder named
    `RetroSquash` in the code bundle.![Phase 1 – MainActivity and onCreate](img/8859OS_07_10.jpg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Bfxr制作一些音效，就像我们在[第5章](ch05.xhtml "第5章。游戏和Java基础")中所做的那样，*游戏和Java基础*。四个就足够了，但没有什么能阻止你添加更多的声音。要获得真正的1970年代风格的声音，请尝试下面截图中显示的**Blip/Select**按钮。将样本命名为`sample1.ogg`，`sample2.ogg`，`sample3.ogg`和`sample4.ogg`。或者你可以使用我的样本。它们在名为`RetroSquash`的文件夹的`assets`文件夹中。![第1阶段-MainActivity和onCreate](img/8859OS_07_10.jpg)
- en: In Project Explorer, create a directory called `assets` within the `main` directory.
    Copy the four sound files you created in the previous step to the newly created
    `assets` folder.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Project Explorer中，在`main`目录中创建一个名为`assets`的目录。将你在上一步中创建的四个声音文件复制到新创建的`assets`文件夹中。
- en: 'Type the following import statements at the top of the `MainActivity.java`
    file but just after your package name, as shown in the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity.java`文件的顶部但在包名之后输入以下导入语句，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now type your class declaration and declare the following member variables.
    We will discuss the member variables in detail at the end of this phase:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在输入你的类声明并声明以下成员变量。我们将在本阶段结束时详细讨论成员变量：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we will enter the `onCreate` method in its entirety. We are initializing
    many of the member variables that we declared in the previous step, as well as
    creating an object from our `SquashCourtView` class, which we will begin to implement
    in the next phase. Perhaps the most notable line in this block of code is the
    somewhat different call to `setContentView`. Look at the argument for `setContentView`.
    We will learn more about this argument at the end of this phase. This phase also
    sets up `SoundPool` and loads the sound samples. Type the first part of the `onCreate`
    code:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将完整进入`onCreate`方法。我们正在初始化许多在上一步中声明的成员变量，以及从我们的`SquashCourtView`类创建一个对象，我们将在下一阶段开始实现。在这段代码块中，可能最值得注意的一行是对`setContentView`的略有不同的调用。看一下`setContentView`的参数。我们将在本阶段结束时了解更多关于这个参数的信息。这个阶段还设置了`SoundPool`并加载了声音样本。输入`onCreate`代码的第一部分：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we initialize the variables we created earlier. Notice that there are some
    good potential candidates for a bit of encapsulation. However, to keep the code
    readable, we will not do so at this stage. Enter this code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在初始化我们之前创建的变量。请注意，有一些很好的潜在候选者可以进行一些封装。但是，为了保持代码的可读性，我们在这个阶段不会这样做。输入这段代码：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Phase 1 code explained
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释第1阶段的代码
- en: Let's look at what we did. From steps 1 to 4, we simply created a project and
    some sound files. Then we added the sound files to the `assets` folder as we have
    done before on other projects. In step 5, we added all the necessary imports for
    the classes we will be using.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们做了什么。从步骤1到4，我们只是创建了一个项目和一些声音文件。然后，我们像在其他项目中一样将声音文件添加到`assets`文件夹中。在第5步，我们为将要使用的类添加了所有必要的导入。
- en: In step 6, we created a whole load of member variables. Let's take a closer
    look at them. We declared an object of the `Canvas` type called `canvas`. We will
    use this object to set up our drawing system. We also declared an instance of
    `SquashCourtView` called `squashCourtView`. This will be underlined as an error
    because we haven't implemented the class yet.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步中，我们创建了一大堆成员变量。让我们仔细看看它们。我们声明了一个`Canvas`类型的对象`canvas`。我们将使用这个对象来设置我们的绘图系统。我们还声明了一个`SquashCourtView`的实例叫做`squashCourtView`。这将被划线为错误，因为我们还没有实现这个类。
- en: 'Here, we declared and initialized variables to be references to our sound files,
    just as we did in other projects. After this, we did something new:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明并初始化了变量，作为我们声音文件的引用，就像我们在其他项目中所做的那样。之后，我们做了一些新的事情：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We declared a `Display` object and a `Point` object. We see these in action
    in our `onCreate` method in a minute, alongside the two `int` variables, `screenWidth`
    and `screenHeight`. We use them to get the screen size in pixels so that we can
    make our game work on a screen with any resolution.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个`Display`对象和一个`Point`对象。我们将在`onCreate`方法中看到它们的作用，再加上两个`int`变量，`screenWidth`和`screenHeight`。我们使用它们来获取屏幕的像素大小，以便我们的游戏可以在任何分辨率的屏幕上运行。
- en: 'Here, we declared some variables whose purpose is plain from their names. Their
    actual usage becomes clearer when we initialize them in step 8 and use them throughout
    our `SquashCourtView` class:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一些变量，它们的目的从它们的名称中就很明显。当我们在第8步初始化它们并在整个`SquashCourtView`类中使用它们时，它们的实际用途会变得更清晰：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we have a bunch of Boolean variables to control the logic of the movement
    of both the racket and the ball. Notice that there is a variable for each possible
    direction for both the racket and the ball. Notice also that the racket can move
    in two directions—left and right—and the ball in four. Of course, the ball can
    travel in two directions at the same time. All will become clear when we write
    the `updateCourt` method in phase 2\. Here is that code again:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一堆布尔变量来控制球拍和球的移动逻辑。请注意，球拍和球的每个可能方向都有一个变量。还要注意球拍可以向两个方向移动——左和右——球可以向四个方向移动。当我们在第2阶段编写`updateCourt`方法时，所有这些都将变得清晰。以下是该代码：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the last part of step 6, we declared two fairly obvious variables, `lives`
    and `score`. But what about `lastFrameTime` and `fps`? These will be used in the
    `controlFPS` method, which we will write in phase 3\. They will be used along
    with some local variables to measure how fast our game loop runs. We can then
    lock it to run at a consistent rate so that players on devices with different
    CPU speeds get a similar experience.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6步的最后部分，我们声明了两个相当明显的变量，`lives`和`score`。但`lastFrameTime`和`fps`呢？这些将在我们在第3阶段编写的`controlFPS`方法中使用。它们将与一些局部变量一起用于测量我们的游戏循环运行的速度。然后我们可以将其锁定以以一致的速度运行，以便具有不同CPU速度的设备上的玩家获得类似的体验。
- en: In step 7, we entered the `onCreate` method, but this time, things are different.
    We initialize `squashCourtView` as a new `SquashCourtView` object. It's fine so
    far, but then we seem to be telling `setContentView` to make this the entire view
    that the player will see, instead of the usual view created in the Android Studio
    designer, which we have become used to. We are not using any Android UI components
    in this game, so the visual designer and all of its generated XML are of no use
    to us. As you will see right at the start of phase 2, our `SquashCourtView` class
    extends (inherits from) `SurfaceView`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7步中，我们进入了`onCreate`方法，但这一次情况有所不同。我们将`squashCourtView`初始化为一个新的`SquashCourtView`对象。到目前为止还好，但然后我们似乎在告诉`setContentView`将其作为玩家将看到的整个视图，而不是通常在Android
    Studio设计师中创建的视图，这是我们已经习惯的。在这个游戏中，我们没有使用任何Android UI组件，因此视觉设计师及其生成的XML对我们没有用处。正如您将在第2阶段开始时看到的，我们的`SquashCourtView`类扩展（继承自）`SurfaceView`。
- en: 'We created an object with all the facilities of a `SurfaceView`. We will just
    customize it to play our squash game. Neat! Therefore, it is perfectly acceptable
    and logical to set our `squashCourtView` object as the entire view that the player
    will see:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个具有所有`SurfaceView`功能的对象。我们将对其进行自定义以玩我们的壁球游戏。很好！因此，将我们的`squashCourtView`对象设置为玩家将看到的整个视图是完全可以接受和合乎逻辑的：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We then set up our sound effects as we have done before.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们设置了我们的音效，就像以前一样。
- en: In step 8, we initialized many of the variables that we declared in step 6\.
    Let's look at the values and the order in which we initialized them. You might
    have noticed that we don't initialize every variable here; some will be initialized
    later. Remember that we don't have to initialize member variables and that they
    also have default values.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8步中，我们初始化了在第6步中声明的许多变量。让我们看看初始化的值和顺序。您可能已经注意到，我们并没有在这里初始化每个变量；有些将稍后初始化。请记住，我们不必初始化成员变量，它们也有默认值。
- en: 'In the following code, we get the number of pixels (wide and high) for the
    device. The `display` object holds the details of the display after the first
    line has been executed. Then we create a new object called `size` of the `Point`
    type. We send `size` as an argument to the `display.getSize` method. The `Point`
    type has an `x` and `y` member variable, and so does the `size` object, which
    now holds the width and height (in pixels) of the display. These values are then
    assigned to `screenWidth` and `screenHeight` respectively. We will use `screenWidth`
    and `screenHeight` quite extensively in the `SquashCourtView` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码中，我们获取设备的像素数（宽和高）。`display`对象在第一行执行后保存了显示的详细信息。然后我们创建了一个名为`size`的`Point`类型的新对象。我们将`size`作为参数发送给`display.getSize`方法。`Point`类型有一个`x`和`y`成员变量，`size`对象也有，现在它保存了显示的宽度和高度（以像素为单位）。然后将这些值分别赋给`screenWidth`和`screenHeight`。我们将在`SquashCourtView`类中广泛使用`screenWidth`和`screenHeight`：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we initialize the variables that determine the size and position of the
    ball and racket. Here, we initialize our `racketPosition` object, which is of
    the `Point` type. Remember that it has an `x` and a `y` member variable:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化了决定球和球拍大小和位置的变量。在这里，我们初始化了我们的`racketPosition`对象，它是`Point`类型的。记住它有一个`x`和一个`y`成员变量：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We initialize `racketPosition.x` to be whatever the current screen width in
    pixels might be, but divided by two, so the racket will start in a horizontal
    and central position regardless of the resolution of the screen:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`racketPosition.x`初始化为当前屏幕宽度的一半，这样球拍将始终在水平和中央位置开始，而不受屏幕分辨率的影响：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the next line of code, `racketPosition.y` is put at the bottom of the screen
    with a small 20-pixel gap:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行代码中，`racketPosition.y`被放在屏幕底部，留有20像素的间隙：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We make the width of the racket to one-eighth the width of the screen. We will
    see when we get to run the game that this is a fairly effective size, but we could
    make it bigger by dividing it by a lower number, or smaller by dividing it by
    a larger number. The point is that it will be the same fraction of `screenWidth`
    regardless of the resolution of the device:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将球拍的宽度设置为屏幕宽度的八分之一。当我们运行游戏时，我们会看到这是一个相当有效的大小，但我们可以通过将其除以较小的数字来使其变大，或者通过将其除以较大的数字来使其变小。关键是，无论设备的分辨率如何，它都将是`screenWidth`的相同部分：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the following line of code, we choose an arbitrary height for our racket:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行代码中，我们为球拍选择了一个任意的高度：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then we make our ball as small as 1/35th of the screen. Again, we could make
    it larger or smaller:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将我们的球大小设置为屏幕的1/35。同样，我们可以将其放大或缩小：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the next line of code, we will create a new point object to hold the position
    of the ball:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行代码中，我们将创建一个新的点对象来保存球的位置：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As we did with the racket, we start the ball in the center of the screen, like
    this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与球拍一样，我们将球放在屏幕中央，如下所示：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, we set it to start at the top of the screen just far enough to see
    the top of the ball:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们将其设置为从屏幕顶部开始，刚好能看到球的顶部：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The player starts the game with three lives:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家从游戏开始就有三条命：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Phew! That was a fairly chunky section. Take a break if you like, and then we
    will move on to phase 2.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！那是一个相当庞大的部分。如果你愿意，可以休息一下，然后我们将继续进行第2阶段。
- en: Phase 2 – SquashCourtView part 1
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2阶段 - SquashCourtView 第1部分
- en: 'Finally, we get to the secret weapon of our game—the `SquashCourtView` class.
    The first three methods are presented here, and explained more fully once we have
    implemented them:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到了我们游戏的秘密武器 - `SquashCourtView`类。前三个方法在这里呈现，并在实现后进行更详细的解释：
- en: 'Here is a class declaration that extends `SurfaceView`, giving our class all
    the methods and properties of `SurfaceView`. It also implements `Runnable`, which
    allows it to run in a separate thread. As you will see, we will put the bulk of
    the functionality in the `run` method. After the declaration, we have a constructor.
    Remember that the constructor is a method that has the same name as the class
    and is called when we initialize a new object of its type. The code in the constructor
    initializes some objects and then sends the ball off in a random direction. We
    will look at that part in detail after we have implemented this phase. Enter the
    following code before the closing curly brace of the `MainActivity` class:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个扩展`SurfaceView`的类声明，使我们的类拥有`SurfaceView`的所有方法和属性。它还实现了`Runnable`，这使它可以在单独的线程中运行。正如你将看到的，我们将把大部分功能放在`run`方法中。在声明之后，我们有一个构造函数。记住构造函数是一个与类同名的方法，在我们初始化其类型的新对象时调用。构造函数中的代码初始化了一些对象，然后以随机方向发送球。在我们实现了这个阶段之后，我们将详细查看这部分。在`MainActivity`类的结束大括号之前输入以下代码：
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we have this short and sweet overriding of the `run` method. Remember that
    the `run` method contains the functionality of the thread. In this case, it has
    three calls, one to each of `updateCourt`, `drawCourt`, and `controlFPS`, the
    three key methods of our class. Enter this code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了这个简短而甜美的`run`方法的重写。记住`run`方法包含线程的功能。在这种情况下，它有三个调用，分别是`updateCourt`、`drawCourt`和`controlFPS`，这是我们类的三个关键方法。输入以下代码：
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will implement just one more method in this phase (`updateCourt`), but it
    is quite long. We will split it into chunks and briefly mention what is going
    on in each chunk before we type the code. We will perform a closer examination
    of how it works when the phase is implemented. In this next chunk of code, we
    handle the left and right movement of the racket as well as detecting and reacting
    when the ball hits either the left or the right of the screen. Enter the following
    code after the code from the previous step:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在这个阶段中实现一个额外的方法(`updateCourt`)，但它相当长。在我们输入代码之前，我们将把它分成几部分，并简要提到每部分的内容。在这部分代码中，我们处理球拍的左右移动，以及检测和反应当球击中屏幕的左侧或右侧。在上一步的代码之后输入以下代码：
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In this next chunk of code, we check whether the ball has hit the bottom of
    the screen, that is, the player has failed to return the ball. Enter this code
    directly after the code in the previous step:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一部分代码中，我们检查球是否击中了屏幕底部，也就是玩家未能返回球。在上一步的代码之后直接输入这段代码：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this chunk of code, we handle whether the ball has hit the top of the screen.
    We also calculate all the possible movements of the ball for this frame. Now type
    the following code:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这部分代码中，我们处理了球是否击中了屏幕顶部。我们还计算了本帧球的所有可能移动。现在输入以下代码：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we handle collision detection and the reaction of the racket and the
    ball. We also close the `updateCourt` method, and this is the last chunk of code
    for this phase. Enter the following after your code from the previous step:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们处理了球拍和球的碰撞检测和反应。我们还关闭了`updateCourt`方法，这是这个阶段的最后一部分代码。在上一步的代码之后输入以下内容：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Phase 2 code explained
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第2阶段代码解释
- en: The code in this phase was lengthy, but there is nothing too challenging when
    we break it down. Possibly, the only challenge is in unravelling some of those
    nested `if` statements. We will do this now.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段的代码很长，但当我们分解它时并没有太多挑战。可能唯一的挑战在于解开一些嵌套的`if`语句。我们现在将这样做。
- en: In step 1, we declare our `SquashCourView` class. This implements the `Runnable`
    interface. You might remember from [Chapter 5](ch05.xhtml "Chapter 5. Gaming and
    Java Essentials"), *Gaming and Java Essentials*, that `Runnable` provides us with
    a thread. All we need to do is override the `run` method, and whatever is within
    it will work in a new thread.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤1中，我们声明了`SquashCourView`类。这实现了`Runnable`接口。你可能还记得来自[第5章](ch05.xhtml "第5章。游戏和Java基础")，*游戏和Java基础*，`Runnable`为我们提供了一个线程。我们只需要重写`run`方法，里面的任何内容都将在一个新的线程中运行。
- en: Then we created a new `Thread` object called `ourThread`, and a `SurfaceHolder`
    object to hold our surface and enable us to control or lock our surface for use
    within our thread. Next, we have `playingSquash` of the `boolean` type. This wraps
    the inside of our overridden `run` method to control when the game is running.
    The odd-looking `volatile` modifier means that we will be able to change its value
    from the outside and inside of our thread.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个名为`ourThread`的新`Thread`对象，以及一个`SurfaceHolder`对象来保存我们的表面并使我们能够在线程内控制或锁定我们的表面。接下来，我们有`playingSquash`的`boolean`类型。这包裹了我们重写的`run`方法内部，以控制游戏何时运行。看起来奇怪的`volatile`修饰符意味着我们将能够从线程的内部和外部更改它的值。
- en: 'Lastly, for the currently discussed block of code, we declare an object of
    the `Paint` type, called `paint`, to do our painting:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于当前讨论的代码块，我们声明了一个`Paint`类型的对象，称为`paint`，来进行绘画：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we implemented the constructor of our class, so that when we initialized
    a new `SquashCourtView` object back in `onCreate`, this is the code that runs.
    First, we see that we run the constructor of the superclass. Then we initialize
    `ourHolder` using the `getHolder` method. Next, we initialize our `paint` object:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现了我们类的构造函数，这样当我们在`onCreate`中初始化一个新的`SquashCourtView`对象时，这就是运行的代码。首先，我们看到我们运行了超类的构造函数。然后我们使用`getHolder`方法初始化了`ourHolder`。接下来，我们初始化了我们的`paint`对象：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, still within the constructor, we get things moving. We set our `ballIsMovingDown`
    variable to `true`. At the start of each game, we always want the ball to be moving
    down. We will see soon that the `updateCourt` method will perform the ball movement.
    Next, we send the ball in a random horizontal direction. This is achieved by getting
    a random number between 0 and 2\. We then switch for each possible case: 0, 1,
    or 2\. In each case statement, we set the Boolean variables that control horizontal
    movement differently. In `case 0`, the ball moves left, and in `case 1` and `case
    3`, the ball will move right and straight down, respectively. Then we close our
    constructor:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在构造函数中，我们让事情开始动起来。我们将`ballIsMovingDown`变量设置为`true`。在每场比赛开始时，我们总是希望球朝下移动。很快我们将看到`updateCourt`方法将执行球的移动。接下来，我们以随机的水平方向发送球。这是通过获取0到2之间的随机数来实现的。然后我们为每种可能的情况进行切换：0、1或2。在每种情况下，我们以不同的方式设置控制水平移动的布尔变量。在`case
    0`中，球向左移动，在`case 1`和`case 3`中，球将向右移动和向下移动。然后我们关闭我们的构造函数：
- en: '[PRE51]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In step 2, we have some really simple code, but this is the code that runs
    everything else. The overridden `run` method is what `ourThread` calls at defined
    intervals. As you can see, the code is wrapped in a `while` block controlled by
    our `playingSquash` variable of the `boolean` type. Then the code simply calls
    `updateCourt`, which controls movement and collision detection; `drawCourt`, which
    will draw everything; and `controlFPS`, which will lock our game to a consistent
    frame rate. That''s it for `run`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们有一些非常简单的代码，但这些代码运行了其他所有内容。重写的`run`方法是`ourThread`在定义的时间间隔调用的。正如你所看到的，代码被包裹在一个由我们的`playingSquash`布尔类型变量控制的`while`块中。然后代码简单地调用`updateCourt`，控制移动和碰撞检测；`drawCourt`，将绘制一切；和`controlFPS`，将锁定我们的游戏到一个一致的帧速率。这就是`run`的全部内容。
- en: '[PRE52]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then in step 3, we begin the `updateCourt` method. It was quite long, so we
    broke it down into a few manageable chunks. The first two `if` blocks check to
    see whether either the `racketIsMovingRight` or the `racketIsMovingLeft` Boolean
    variables is true. If one of them is true, the blocks add `10` to or subtract
    `10` from `racketPosition.x`. The effect of this will be seen by the player when
    the racket is drawn in the `drawCourt` method. How the Boolean variables are manipulated
    in the `onTouchEvent` method will be discussed soon:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在第3步，我们开始`updateCourt`方法。它非常长，所以我们将它分解成几个可管理的部分。前两个`if`块检查`racketIsMovingRight`或`racketIsMovingLeft`布尔变量是否为true。如果其中一个为true，则块将从`racketPosition.x`中加上`10`或减去`10`。当球拍在`drawCourt`方法中绘制时，玩家将看到这种效果。布尔变量在`onTouchEvent`方法中如何操作将很快讨论：
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, still in the `updateCourt` method, we detect and handle collisions with
    the left and right side of the screen. Checking whether `ballPosition.x` is larger
    than `screenWidth` would be enough to see whether the ball bounces back the other
    way. However, by being a bit more precise and testing for `ballPosition.x + ballWidth
    > screenWidth`, we are testing whether the right edge of the ball hits the right
    side of the screen. This creates a much more pleasing effect as it looks more
    *real*. When a collision occurs with the right side, we simply reverse the direction
    of our ball and play a sound. The reason that the `if` code for the left-side
    detection is simpler is because we have drawn the ball using `drawRect`, so `ballPosition.x`
    is the precise left side of the ball. When the ball collides with the left side,
    we simply reverse its direction and play a beep sound:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仍然在`updateCourt`方法中，我们检测并处理与屏幕左侧和右侧的碰撞。检查`ballPosition.x`是否大于`screenWidth`就足以看到球是否会反弹。然而，通过更精确一些，测试`ballPosition.x
    + ballWidth > screenWidth`，我们测试了球的右边缘是否击中了屏幕的右侧。这会产生一个更加令人愉悦的效果，因为它看起来更“真实”。当发生与右侧的碰撞时，我们只需改变球的方向并播放声音。左侧检测的`if`代码更简单的原因是因为我们使用`drawRect`绘制了球，所以`ballPosition.x`是球的精确左侧。当球与左侧碰撞时，我们只需改变它的方向并播放一个哔哔声：
- en: '[PRE54]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In step 4, we implemented what happens when the ball hits the bottom of the
    screen. This occurs when the player fails to return the ball, so a fair few things
    need to happen here. However, there is nothing overly complicated in this section.
    First comes the collision test. We check whether the underside of the ball has
    hit the bottom of the screen:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们实现了当球击中屏幕底部时会发生什么。这发生在玩家未能将球击回时，因此这里需要发生一些事情。然而，在这一部分中并没有什么特别复杂的东西。首先是碰撞测试。我们检查球的底部是否击中了屏幕底部：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If it has hit, we deduct a life. Then we check whether the player has lost
    all their lives:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果击中了，我们扣除一条生命。然后我们检查玩家是否失去了所有的生命：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If all lives are lost, we start the game again by resetting lives to 3 and
    score to 0\. We also play a low beep sound:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有生命都丢失，我们通过将生命重置为3并将得分重置为0来重新开始游戏。我们还会播放一个低音响声：
- en: '[PRE57]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As of now, we are still within the `if` block because the ball hit the bottom
    of the screen, but outside the `if` block for the player who has zero lives. Whether
    the player has zero lives or still has some lives left, we need to put the ball
    back at the top of the screen and send it in a downward trajectory and a random
    horizontal direction. This code is similar to but not the same as the code we
    have seen in the constructor to start the ball moving at the beginning of the
    game:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仍然在`if`块内，因为球击中了屏幕底部，但是在玩家生命值为零的`if`块外。无论玩家是否生命值为零或者还有一些生命值，我们都需要将球放回屏幕顶部，并使其沿着向下的轨迹和随机的水平方向移动。这段代码与我们在构造函数中看到的代码类似，用于在游戏开始时使球移动：
- en: '[PRE58]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In step 5, we handle the event of the ball hitting the top of the screen. Reverse
    the values held by `ballIsMovingDown` and `ballIsMovingUp` to reverse the direction
    of the ball. Tweak the ball position with `ballPosition.y = 1`. This stops the
    ball from getting stuck and plays a nice beep:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5步中，我们处理了球击中屏幕顶部的事件。反转`ballIsMovingDown`和`ballIsMovingUp`所持有的值以改变球的方向。通过`tweak`
    `ballPosition.y = 1`来调整球的位置。这样可以防止球被卡住，并播放一个愉悦的哔哔声：
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, after all this collision detection and switching around of our Boolean
    variables, we actually move the ball. For each direction that is true, we add
    to or subtract from the `ballPosition.x` and `ballPosition.y` accordingly. Notice
    that the ball travels up faster than it travels down. This is done to shorten
    the time the player is waiting to get back into the action, and also crudely simulates
    the act of acceleration after the ball is hit by the racket:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在所有这些碰撞检测和布尔变量的切换之后，我们实际上移动了球。对于每个方向为真的情况，我们相应地向`ballPosition.x`和`ballPosition.y`添加或减去。请注意，球向上移动的速度比向下移动的速度快。这样做是为了缩短玩家等待重新参与游戏的时间，并且粗略地模拟球被球拍击中后的加速行为：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Tip
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might have noticed that by hardcoding the number of pixels the ball moves,
    we create an inconsistent speed for the ball between high-resolution and low-resolution
    screens. Take a look at the self-test questions at the end of the chapter to see
    how we can solve this.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，通过硬编码球移动的像素数，我们在高分辨率和低分辨率屏幕之间创建了不一致的球速度。查看本章末尾的自测问题，看看我们如何解决这个问题。
- en: 'We have one last bit of collision detection to do. Has the ball hit the racket?
    This detection is done in a couple of stages. First, we check whether the underside
    of the ball has reached or gone past the top side of the racket:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有最后一点碰撞检测要做。球是否击中了球拍？这个检测分为几个阶段进行。首先，我们检查球的底部是否到达或超过了球拍的顶部：
- en: '[PRE61]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If this condition is true, we perform some more tests. First, we declare and
    initialize an `int` variable called `halfRacket` to hold half the width of the
    racket. We will use this in the upcoming tests:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个条件成立，我们会进行一些额外的测试。首先，我们声明并初始化一个名为`halfRacket`的`int`变量，用于保存球拍宽度的一半。我们将在即将进行的测试中使用它：
- en: '[PRE62]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The next `if` block checks whether the right-hand side of the ball is greater
    than the far left corner of the racket, and whether it is touching it. Using the
    AND operator (`&&`), the block verifies that the ball''s left edge is not past
    the far right of the racket. If this condition is true, we definitely have a hit
    and can think about how to handle the rebound:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的`if`块检查球的右侧是否大于球拍的最左侧角，并且是否与之接触。使用AND运算符(`&&`)，该块验证球的左边缘是否没有超过球拍的最右边。如果这个条件成立，我们肯定击中了，可以考虑如何处理反弹：
- en: '[PRE63]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The first bit of code inside the `if` block, which determined a definite hit,
    is simple. Play a sound, increase the score, and set the ball on an upwards trajectory,
    like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`块内的第一部分代码，确定了一个明确的击中，很简单。播放声音，增加得分，并使球向上运动，就像这样：
- en: '[PRE64]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now we have an `if`-`else` condition, which simply checks whether the left-hand
    edge of the ball is past the center of the racket. If it is, we send the ball
    to the right. Otherwise, we send the ball to the left:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`if`-`else`条件，简单地检查球的左边缘是否超过了球拍的中心。如果是，我们将球发送到右侧。否则，我们将球发送到左侧：
- en: '[PRE65]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Phase 3 – SquashCourtView part 2
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3阶段 - SquashCourtView第2部分
- en: 'In this phase, we will complete our `SquashCourtView` class. There are two
    methods remaining that are called from the `run` method, `drawCourt` and `controlFPS`.
    Then there are a few short methods to interact with the Android lifecycle methods
    that we will implement in the fourth and final phase:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们将完成我们的`SquashCourtView`类。还有两个从`run`方法调用的方法，`drawCourt`和`controlFPS`。然后有一些与Android生命周期方法交互的短方法，我们将在第四和最后阶段实现：
- en: 'Here is the code that draws, in the following order, the text at the top of
    the screen, the ball, and the bat. All is contained within the `drawCourt` method,
    which is called from the `run` method, right after the call to `updateCourt`.
    Here is the code for `drawCourt`. Type the following code before the closing curly
    brace of the `SquashCourtView` class:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是按照以下顺序绘制的代码：屏幕顶部的文本，球和球拍。所有这些都包含在`drawCourt`方法中，该方法从`run`方法中调用，在调用`updateCourt`之后立即调用。以下是`drawCourt`的代码。在`SquashCourtView`类的结束大括号之前输入以下代码：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'And now the `controlFPS` method locks our frame rate to something smooth and
    consistent. We will soon go through its exact working. Type the following code
    after the code in the previous step:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`controlFPS`方法将我们的帧速率锁定到某个平稳一致的值。我们很快将详细了解其确切工作原理。在上一步的代码之后输入以下代码：
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we write the code for `pause` and `resume`. These are called by their
    related Android lifecycle methods (`onPause` and `onResume`). We ensure that our
    thread is ended or started safely when the player has finished or resumed our
    game, respectively. Now type this code after the code in the previous step:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们编写`pause`和`resume`的代码。这些代码由它们相关的Android生命周期方法（`onPause`和`onResume`）调用。我们确保在玩家完成或恢复游戏时，我们的线程能够安全地结束或启动。现在在上一步的代码之后输入以下代码：
- en: '[PRE68]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, we have the method that controls what happens when the player touches
    our customized `SurfaceView`. Remember that when we discussed the design of the
    game, we said that a press anywhere on the left of the screen would move the racket
    to the left, and a press anywhere on the right will move the racket to the right.
    Type the following code after the code in the preceding step:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们有一个控制玩家触摸我们自定义的`SurfaceView`时发生的情况的方法。请记住，当我们讨论游戏的设计时，我们说屏幕左侧的任何位置按下都会将球拍移动到左侧，而屏幕右侧的任何位置按下都会将球拍移动到右侧。在上一步的代码之后输入以下代码：
- en: '[PRE69]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Phase 3 code explained
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第3阶段代码解释
- en: 'In step 1, we do all the drawing. We have seen what all the different drawing
    methods of the `Canvas` class can do, and their names are self-explanatory as
    well. However, the manner in which we arrived at the coordinates needs some explanation.
    First, inside `drawCourt`, we use `ourHolder` to get a drawing surface, and we
    check its validity (usability). Then we initialize our `canvas` and `paint` objects:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们进行所有绘制。我们已经看到`Canvas`类的所有不同绘制方法可以做什么，它们的名称也是不言自明的。但是，我们需要解释如何得到这些坐标。首先，在`drawCourt`内部，我们使用`ourHolder`来获取绘图表面，并检查其有效性（可用性）。然后我们初始化我们的`canvas`和`paint`对象：
- en: '[PRE70]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we clear the screen from the previous frame of drawing:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们清除上一帧绘制的屏幕：
- en: '[PRE71]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now we set the paint color to white:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将画笔颜色设置为白色：
- en: '[PRE72]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This is new but simple to explain—we set a size for our text:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的，但很容易解释 - 我们为文本设置了一个大小：
- en: '[PRE73]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now we can draw a line of text at the top of the screen. It shows the `score`
    and `lives` variables. We have already seen how to control their values. It also
    shows the value of the `fps` variable. We will see how we can assign a value to
    that when we look at the next method, `controlFPS`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在屏幕顶部绘制一行文本。它显示`score`和`lives`变量。我们已经看到如何控制它们的值。它还显示`fps`变量的值。当我们查看下一个方法`controlFPS`时，我们将看到如何为其分配一个值：
- en: '[PRE74]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then we draw the racket. Notice that we calculate the `x` start position by
    subtracting half the racket width from `racketPosition.x`, and the `x` end position
    by adding the width to `x`. This makes our collision detection code simple because
    `racketPosition.x` refers to the center of the racket:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们绘制球拍。请注意，我们通过从`racketPosition.x`减去球拍宽度的一半来计算`x`起始位置，并通过将宽度添加到`x`来计算`x`结束位置。这使得我们的碰撞检测代码变得简单，因为`racketPosition.x`指的是球拍的中心：
- en: '[PRE75]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we draw the ball. Notice that the starting *x* and *y* coordinates are
    the same as the values held in `ballPosition.x` and `ballPosition.y`. Therefore,
    these coordinates correspond to the top-left corner of the ball. This is just
    what we need for our simple collision detection code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们绘制球。请注意，起始的*x*和*y*坐标与`ballPosition.x`和`ballPosition.y`中保存的值相同。因此，这些坐标对应于球的左上角。这正是我们简单碰撞检测代码所需要的：
- en: '[PRE76]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This final line draws what we have just done to the screen:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将我们刚刚完成的内容绘制到屏幕上：
- en: '[PRE77]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In step 2, we essentially pause the game. We want to decide the number of times
    we recalculate the position of our objects and redraw them. Here is how it works.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们基本上暂停了游戏。我们希望决定我们重新计算对象位置和重绘它们的次数。下面是它的工作原理。
- en: 'First, we enter the `controlFPS` method when it is called from the `run` method.
    We declare and initialize a `long` variable with the time in milliseconds, and
    then take away the time that the last frame took in milliseconds. The time is
    calculated in the previous run through this method, at the end, as we will see:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当从`run`方法调用`controlFPS`方法时，我们进入`controlFPS`方法。我们声明并初始化一个`long`变量，其值为毫秒，然后减去上一帧所花费的时间（以毫秒为单位）。时间是在上一次运行此方法时计算的，最后，我们将在此方法的最后看到：
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We then calculate how long we want to pause between frames, and initialize
    that value to `timeToSleep`, a new long variable. Here is how the calculation
    works: 15 milliseconds of pause gives us around 60 frames per second, which works
    well for our game and provides a very smooth animation. Therefore, `15 - timeThisFrame`
    equals the number of milliseconds we should pause for to make the frame last for
    15 milliseconds:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算我们希望在帧之间暂停多长时间，并将该值初始化为`timeToSleep`，一个新的长变量。计算的方法如下：15毫秒的暂停让我们大约每秒60帧，这对我们的游戏效果很好，提供了非常流畅的动画。因此，`15
    - timeThisFrame`等于我们应该暂停的毫秒数，以使帧持续15毫秒：
- en: '[PRE79]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Of course, some devices will not cope with this speed. Neither do we want to
    pause for a negative number, nor do we want to calculate the frames per second
    when `timeThisFrame` is equal to zero. Next, we wrap the calculation of frames
    per second within an `if` statement that prevents us from dividing by zero or
    a negative number:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一些设备无法应对这种速度。我们也不希望暂停负数，也不希望在`timeThisFrame`等于零时计算每秒帧数。接下来，我们将每秒帧数的计算包装在一个`if`语句中，以防止我们除以零或负数：
- en: '[PRE80]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Likewise, we wrap the instruction to our thread to pause within a similar cautionary
    `if` statement:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将暂停线程的指令包装在类似的谨慎的“if”语句中：
- en: '[PRE81]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we see how we initialize `lastFrameTime`, ready for the next time
    `controlFPS` is called:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看到我们如何初始化`lastFrameTime`，准备好下一次调用`controlFPS`：
- en: '[PRE82]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In step 3, we quickly implement two methods. They are `pause` and `resume`.
    These are not to be confused with the Android Activity lifecycle methods called
    `onPause` and `onResume`. However, the `pause` and `resume` methods are called
    from their near-namesakes. They handle stopping and starting `ourThread`, respectively.
    We should always clean up our threads. Otherwise, they can keep running even after
    the activity has finished:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3步，我们快速实现了两种方法。它们是`pause`和`resume`。这些不应与Android Activity生命周期方法`onPause`和`onResume`混淆。但是，`pause`和`resume`方法是从它们的近似名称中调用的。它们分别处理停止和启动`ourThread`。我们应该始终清理我们的线程。否则，它们可能会在活动结束后继续运行：
- en: '[PRE83]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In step 4, we handle touches on the screen. This is how we initialize our `racketIsMovingLeft`
    and `racketIsMovingRight` Boolean variables, which the `updateCourt` method uses
    to decide whether to slide the player's racket left or right, or to keep it still.
    We have talked about the `onTouchEvent` method before, but let's see how we set
    the values in those variables.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步，我们处理屏幕上的触摸。这是我们如何初始化我们的`racketIsMovingLeft`和`racketIsMovingRight`布尔变量的方式，`updateCourt`方法用于决定是向左还是向右滑动玩家的球拍，还是保持静止。我们之前已经讨论过`onTouchEvent`方法，但让我们看看如何在这些变量中设置值。
- en: 'First, we override the method and switch to get the type of event and the *x*,
    *y* coordinates of the event:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们重写该方法并切换以获取事件类型和事件的*x*，*y*坐标：
- en: '[PRE84]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If the event type is `ACTION_DOWN`, that is, the screen has been touched, we
    enter this case:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件类型是`ACTION_DOWN`，即屏幕已被触摸，我们进入此情况：
- en: '[PRE85]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Then we handle the coordinates. If the player has touched a position on the
    screen with an x coordinate greater than `screenWidth / 2`, then it means they
    have touched the right-hand side of the screen, so we set `isMovingRight` to `true`
    and `isMovingLeft` to `false`. The `updateCourt` method will handle changes in
    the necessary coordinates, and the `drawCourt` method will draw the racket in
    the appropriate place:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们处理坐标。如果玩家触摸屏幕上x坐标大于`screenWidth / 2`的位置，则意味着他们触摸了屏幕的右侧，因此我们将`isMovingRight`设置为`true`，将`isMovingLeft`设置为`false`。`updateCourt`方法将处理必要坐标的更改，而`drawCourt`方法将在适当的位置绘制球拍：
- en: '[PRE86]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `else` statement sets our two Boolean variables in the opposite manner
    because a touch must have occurred on the left of the screen:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`else`语句以相反的方式设置我们的两个布尔变量，因为触摸必须发生在屏幕的左侧：'
- en: '[PRE87]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Now we handle the case for the `ACTION_UP` event. But why do we care about
    two events? With the buttons, we just cared about a click and that was all, but
    by handling the `ACTION_UP` event, we can enable the functionality that allows
    our player to hold the screen to slide left or right, just as we discussed in
    the section *The design of the game* of this chapter. Thus, the `ACTION_DOWN`
    case sets the racket moving one way or the other, and the `ACTION_UP` case simply
    stops the slide completely:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处理`ACTION_UP`事件的情况。但是为什么我们关心两个事件？对于按钮，我们只关心点击，但通过处理`ACTION_UP`事件，我们可以启用允许玩家按住屏幕向左或向右滑动的功能，就像我们在本章的*游戏设计*部分讨论的那样。因此，`ACTION_DOWN`情况设置球拍向左或向右移动，而`ACTION_UP`情况只是完全停止滑动：
- en: '[PRE88]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Notice that we don't care about the *y* coordinate. Anywhere on the left we
    go left, anywhere on the right we go right.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们不关心*y*坐标。在左侧的任何地方我们向左走，在右侧的任何地方我们向右走。
- en: Note
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice also that all of the code will work whether a device is held in the portrait
    or landscape form, and will function the same regardless of the resolution of
    the device. However (and it is quite an important "however"), the game will be
    slightly harder on low-resolution screens. The solution to this problem is quite
    complicated and will not be discussed until the final chapter, but it might well
    help us make some decisions about the future path to learn Android, gaming, and
    Java.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，所有代码都将在设备以纵向或横向形式保持时运行，并且无论设备的分辨率如何，都将以相同的方式运行。但是（这是一个非常重要的“但是”），在低分辨率屏幕上，游戏会稍微困难一些。这个问题的解决方案非常复杂，直到最后一章才会讨论，但它可能会帮助我们对未来学习Android、游戏和Java的路径做出一些决定。
- en: Phase 4 – Remaining lifecycle methods
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4阶段-剩余的生命周期方法
- en: 'We are nearly there; just a few more steps and we will have a working retro
    squash game. I can almost smell the nostalgia! As these remaining methods are
    quite straightforward, we will explain them as we write them:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快要完成了；再过几步，我们就会有一个可用的复古壁球游戏。我几乎能闻到怀旧的味道！由于这些剩余的方法非常简单，我们将在编写它们时进行解释。
- en: 'As we previously learned, the `onStop` method is called by the Android system
    when the app is stopped. It is implemented for us already. The only reason we
    override it here is to ensure that our thread is stopped. We do so with the line
    highlighted. Enter the following code before the closing curly brace of the `MainActivity`
    class:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们之前学到的，当应用程序停止时，`onStop`方法会被Android系统调用。这个方法已经为我们实现了。我们在这里重写它的唯一原因是确保我们的线程被停止。我们可以通过下面的代码实现。在`MainActivity`类的结束大括号之前输入以下代码：
- en: '[PRE89]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `onPause` method is called by the Android system when the app is paused.
    This too is implemented for us already, and the only reason we override it here
    is to ensure that our thread is stopped. We do so with the line highlighted. Enter
    this code after the preceding code:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序暂停时，`onPause`方法会被Android系统调用。这也已经为我们实现了，我们在这里重写它的唯一原因是确保我们的线程被停止。我们可以通过下面的代码实现。在前面的代码之后输入这段代码：
- en: '[PRE90]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `onResume` method is called by the Android system when the app is resumed.
    Again, this method is implemented for us already. The only reason we override
    it here is to ensure that our thread is resumed, and we do so with the line highlighted.
    Enter the following code after the code in the previous step:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序恢复时，`onResume`方法会被Android系统调用。同样，这个方法已经为我们实现了。我们在这里重写它的唯一原因是确保我们的线程被恢复，我们可以通过下面的代码实现。在上一步的代码之后输入以下代码：
- en: '[PRE91]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Finally, we do something completely new. We handle what happens should the
    player press the back button on their device. As you might have guessed, there
    is a method we can override to achieve this— `onKeyDown`. We pause our thread,
    just as we did in the overridden lifecycle methods, and then call `finish()`,
    which ends the activity and our app. Enter this code after the code in the previous
    step:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们做一些全新的事情。我们处理玩家在设备上按下返回按钮时会发生什么。你可能已经猜到，我们可以重写一个方法来实现这一点——`onKeyDown`。我们暂停我们的线程，就像我们在重写的生命周期方法中所做的那样，然后调用`finish()`，这将结束活动和我们的应用程序。在上一步的代码之后输入这段代码：
- en: '[PRE92]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We covered the code in this phase as we went through it, and this was the shortest
    phase so far. So why didn't we encapsulate everything?
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在进行这个阶段时已经覆盖了代码，这是迄今为止最短的阶段。那么为什么我们没有封装一切呢？
- en: Good object-oriented design
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 良好的面向对象设计
- en: Perhaps simple games are not the best way to demonstrate good object-oriented
    design in action, but a simple code design with fewer private variables actually
    enhances the project. It certainly makes the teaching aspects of coding games
    simpler to explain.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 也许简单的游戏并不是展示良好面向对象设计的最佳方式，但是一个简单的代码设计，使用较少的私有变量实际上增强了项目。这无疑使教授编码游戏方面更简单易懂。
- en: However, when a game becomes more complex and more people work on the code,
    principles of object-oriented programming become more necessary.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当游戏变得更加复杂，更多的人参与到代码中时，面向对象编程原则变得更加必要。
- en: Self-test questions
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: Q1) Can you explain how to make ball speed relative between different screen
    resolutions?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 你能解释一下如何使不同屏幕分辨率下的球速度保持相对吗？
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: I hope you enjoyed animating your first game. You achieved a lot to get to this
    point. You learned not only all the Java topics but also the way the different
    classes of Android can be used to make games relatively simple.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你喜欢给你的第一个游戏添加动画。你已经取得了很大的成就。你不仅学会了所有的Java主题，还学会了Android的不同类如何相对简单地制作游戏。
- en: In the next chapter, we will move on to a new, more complex game. I hope you
    are ready.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续进行一个新的、更复杂的游戏。希望你已经准备好了。
