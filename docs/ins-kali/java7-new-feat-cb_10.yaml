- en: Chapter 10. Concurrent Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。并发处理
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Using join/fork framework in Java 7
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java 7中使用join/fork框架
- en: Using the reusable synchronization barrier Phaser
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可重用的同步障碍Phaser
- en: Using the ConcurrentLinkedDeque class safely with multiple threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多个线程中安全地使用ConcurrentLinkedDeque类
- en: Using the LinkedTransferQueue class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LinkedTransferQueue类
- en: Supporting multiple threads using the ThreadLocalRandom class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ThreadLocalRandom类支持多个线程
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Support for concurrent applications has been improved in Java 7\. Several new
    classes have been introduced that support the parallel execution of tasks. The
    `ForkJoinPool` class is used for applications, which use the divide-and-conquer
    technique to solve a problem. Each subproblem is forked (split) as a separate
    thread and later joined, if necessary to provide a solution. The threads used
    by this class are normally subclasses of the `java.util.concurrent.ForkJoinTask`
    class and are lightweight threads. The use of this approach is illustrated in
    the *Using join/fork framework in Java* recipe.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7中改进了并发应用程序的支持。引入了几个新类，支持任务的并行执行。`ForkJoinPool`类用于使用分而治之技术解决问题的应用程序。每个子问题都被分叉（分割）为一个单独的线程，然后在必要时合并以提供解决方案。该类使用的线程通常是`java.util.concurrent.ForkJoinTask`类的子类，是轻量级线程。*在Java中使用join/fork框架*示例中说明了这种方法的使用。
- en: In addition, the `java.util.concurrent.Phaser` class has been introduced to
    support the execution of a collection of threads in a series of phases. A group
    of threads are synchronized, so that they all execute and then wait for the completion
    of the others. Once they have all completed, they can be re-executed for a second
    phase or subsequent phase. The *Using the reusable synchronization barrier Phaser*
    recipe illustrates the use of this class in a game engine setting.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，引入了`java.util.concurrent.Phaser`类，以支持一系列阶段中线程集合的执行。一组线程被同步，以便它们都执行然后等待其他线程的完成。一旦它们都完成了，它们可以重新执行第二阶段或后续阶段。*使用可重用的同步障碍Phaser*示例说明了在游戏引擎设置中使用此类的情况。
- en: The *Using the java.util.concurrent.ConcurrentLinkedDeque class safely with
    multiple threads* and *Using the java.util.concurrent.LinkedTransferQueue class*
    recipes introduced two new classes designed to work safely with multiple threads.
    Examples of their use in support of the producer/consumer framework are illustrated.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用java.util.concurrent.ConcurrentLinkedDeque类安全地与多个线程一起使用*和*使用java.util.concurrent.LinkedTransferQueue类*示例介绍了两个设计用于安全地与多个线程一起工作的新类。展示了它们在支持生产者/消费者框架的使用示例。'
- en: The `java.util.concurrent.ThreadLocalRandom` class is new and provides better
    support for random number generation used between multiple threads. It is discussed
    in the *Supporting multiple threads using the ThreadLocalRandom class* recipe.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.ThreadLocalRandom`类是新的，并提供更好地支持在多个线程之间使用的随机数生成。在*使用ThreadLocalRandom类支持多个线程*示例中进行了讨论。'
- en: Two new constructors have been added to the `java.util.ConcurrentModificationException`
    class. They both accept a `Throwable` object used to specify the cause of the
    exception. One of the constructors also accepts a string that provides a detail
    message regarding the exception.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.ConcurrentModificationException`类中添加了两个新的构造函数。它们都接受一个`Throwable`对象，用于指定异常的原因。其中一个构造函数还接受一个提供有关异常的详细信息的字符串。'
- en: Java 7 has improved the use of class loaders by modifying the locking mechanism
    to avoid deadlocks. In multi-threaded custom class loaders prior to Java 7, certain
    custom class loaders were prone to deadlocks, when they used a cyclic delegation
    model.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Java 7通过修改锁定机制改进了类加载器的使用，以避免死锁。在Java 7之前的多线程自定义类加载器中，某些自定义类加载器在使用循环委托模型时容易发生死锁。
- en: Consider the following scenario. Thread1 tries to use a ClassLoader1 (locking
    ClassLoader1) to load class1\. It then delegates the loading of class2 to ClassLoader2\.
    At the same time, Thread2 uses ClassLoader2 (locking ClassLoader2) to load class3,
    and then delegates the loading of class4 to ClassLoader1\. Since both class loaders
    are locked and both the threads need both loaders, a deadlock situation occurs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情景。Thread1尝试使用ClassLoader1（锁定ClassLoader1）加载class1。然后将加载class2的委托给ClassLoader2。与此同时，Thread2使用ClassLoader2（锁定ClassLoader2）加载class3，然后将加载class4的委托给ClassLoader1。由于两个类加载器都被锁定，而两个线程都需要这两个加载器，因此发生死锁情况。
- en: The desired behavior of a concurrent class loader is to load different classes
    from the same instance of the class loader concurrently. This requires locking
    at a finer level of granularity, such as locking a class loader by the name of
    the class being loaded.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并发类加载器的期望行为是从同一实例的类加载器并发加载不同的类。这需要以更细粒度的级别进行锁定，例如通过正在加载的类的名称锁定类加载器。
- en: Synchronization should not be done at the class loader level. Instead, a lock
    should be made on a class level, where the class loader allows only a single instance
    of the class to be loaded at a time by that class loader.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 同步不应该在类加载器级别进行。相反，应该在类级别上进行锁定，其中类加载器只允许由该类加载器一次加载一个类的单个实例。
- en: Some class loaders are capable of loading classes concurrently. This type of
    class loader is called **parallel capable class loaders**. They are required to
    register themselves during their initialization process using the `registerAsParallelCapable`
    method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类加载器能够并发加载类。这种类型的类加载器称为**并行可用的类加载器**。它们在初始化过程中需要使用`registerAsParallelCapable`方法进行注册。
- en: If the custom class loader uses an acyclic hierarchal delegation model, no changes
    are needed in Java. In a hierarchal delegation model, delegation is first made
    to its parent class loader. Class loaders that do not use the hierarchical delegation
    model should be constructed as parallel capable class loaders in Java.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自定义类加载器使用无环层次委托模型，则在Java中不需要进行任何更改。在层次委托模型中，首先委托给其父类加载器。不使用层次委托模型的类加载器应该在Java中构造为并行可用的类加载器。
- en: 'To avoid deadlock for custom class loaders:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为自定义类加载器避免死锁：
- en: Use the `registerAsParallelCapable` method in the class initialization sequence.
    This indicates that all instances of the class loader are multi-thread safe.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类初始化序列中使用`registerAsParallelCapable`方法。这表示类加载器的所有实例都是多线程安全的。
- en: 'Make sure that the class loader code is multi-thread safe. This involves:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保类加载器代码是多线程安全的。这包括：
- en: Using an internal locking scheme, such as the class name locking scheme used
    by `java.lang.ClassLoader`
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内部锁定方案，例如`java.lang.ClassLoader`使用的类名锁定方案
- en: Removing any synchronization on the class loader lock
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除类加载器锁上的任何同步
- en: Ensuring that critical sections are multi-thread safe
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保关键部分是多线程安全的
- en: It is recommended that the class loader overrides the `findClass(String)` method
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议类加载器覆盖`findClass(String)`方法
- en: If the `defineClass` methods are overridden, then ensure that they are only
    called once per class name
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`defineClass`方法被覆盖，则确保每个类名只调用一次
- en: More detail about this problem can be found at [http://openjdk.java.net/groups/core-libs/ClassLoaderProposal.html](http://openjdk.java.net/groups/core-libs/ClassLoaderProposal.html).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此问题的更多详细信息，请访问[http://openjdk.java.net/groups/core-libs/ClassLoaderProposal.html](http://openjdk.java.net/groups/core-libs/ClassLoaderProposal.html)。
- en: Using join/fork framework in Java
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Java中使用join/fork框架
- en: The **join/fork** framework is an approach that supports breaking a problem
    into smaller and smaller pieces, solving them in parallel, and then combining
    the results. The new `java.util.concurrent.ForkJoinPool` class supports this approach.
    It is designed to work with multi-core systems, ideally with dozens or hundreds
    of processors. Currently, few desktop platforms support this type of concurrency,
    but future machines will. With fewer than four processors, there will be little
    performance improvement.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**join/fork**框架是一种支持将问题分解为更小的部分，以并行方式解决它们，然后将结果合并的方法。新的`java.util.concurrent.ForkJoinPool`类支持这种方法。它旨在与多核系统一起工作，理想情况下有数十个或数百个处理器。目前，很少有桌面平台支持这种并发性，但未来的机器将会支持。少于四个处理器时，性能改进将很小。'
- en: The `ForkJoinPool` class is derived from the `java.util.concurrent.AbstractExecutorService`
    making it an `ExecutorService`. It is designed to work with `ForkJoinTasks`, though
    it can be used with normal threads. The `ForkJoinPool` class differs from other
    executors, in that its threads attempt to find and execute subtasks created by
    other currently running tasks. This is called **work-stealing**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinPool`类源自`java.util.concurrent.AbstractExecutorService`，使其成为`ExecutorService`。它旨在与`ForkJoinTasks`一起工作，尽管它也可以与普通线程一起使用。`ForkJoinPool`类与其他执行程序不同，其线程尝试查找并执行其他当前运行任务创建的子任务。这称为**工作窃取**。'
- en: The `ForkJoinPool` class can be used for problems where the computation on the
    subproblems is either modified or returns a value. When a value is returned, a
    `java.util.concurrent.RecursiveTask` derived class is used. Otherwise, the `java.util.concurrent.RecursiveAction`
    class is used. In this recipe we will illustrate the use of the `RecursiveTask`
    derived class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinPool`类可用于计算子问题上的计算要么被修改，要么返回一个值。当返回一个值时，使用`java.util.concurrent.RecursiveTask`派生类。否则，使用`java.util.concurrent.RecursiveAction`类。在本教程中，我们将说明使用`RecursiveTask`派生类的用法。'
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use the fork/join framework for a task that returns a result for each subtask:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要为返回每个子任务结果的任务使用分支/合并框架：
- en: Create a subclass of `RecursiveTask` that implements the computation needed.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个实现所需计算的`RecursiveTask`的子类。
- en: Create an instance of the `ForkJoinPool` class.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ForkJoinPool`类的实例。
- en: Use the `ForkJoinPool` class' `invoke` method with the instance of the subclass
    of the `RecursiveTask` class.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ForkJoinPool`类的`invoke`方法与`RecursiveTask`类的子类的实例。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: This application is not intended to be implemented in the most efficient manner,
    but is used to illustrate the fork/join task. As a result, on systems with a small
    number of processors, there may be little or no performance improvement.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序并非旨在以最有效的方式实现，而是用于说明分支/合并任务。因此，在处理器数量较少的系统上，可能几乎没有性能改进。
- en: 'Create a new console application. We will use a static inner class that is
    derived from `RecursiveTask` to compute the sum of squares of the integers in
    the `numbers` array. First, declare the `numbers` array as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。我们将使用一个派生自`RecursiveTask`的静态内部类来计算`numbers`数组中整数的平方和。首先，声明`numbers`数组如下：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the `SumOfSquaresTask` class as follows. It creates a subrange of array
    elements and either uses an iterative loop to compute their sum of squares or
    breaks the array into smaller pieces based on a threshold size:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下添加`SumOfSquaresTask`类。它创建数组元素的子范围，并使用迭代循环计算它们的平方和，或者根据阈值大小将数组分成更小的部分：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following `main` method. For comparison purposes, the sum of squares
    is computed using a for loop and then using the `ForkJoinPool` class. The execution
    time is calculated and displayed as follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`main`方法。为了比较，使用for循环计算平方和，然后使用`ForkJoinPool`类。执行时间如下计算并显示：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Execute the application. Your output should be similar to the following. However,
    you should observe different execution times depending on your hardware configuration:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。您的输出应该类似于以下内容。但是，根据您的硬件配置，您应该观察到不同的执行时间：
- en: '**Sum of squares: 18103503627376**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**平方和：18103503627376**'
- en: '**Iterative solution time: 5**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**迭代解决方案时间：5**'
- en: '**Sum of squares: 18103503627376**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**平方和：18103503627376**'
- en: '**Fork/join solution time: 23**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**分支/合并解决方案时间：23**'
- en: Notice that the iterative solution is faster than the one using the fork/join
    strategy. As mentioned earlier, this approach is not always more efficient, unless
    there are a large number of processors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，迭代解决方案比使用分支/合并策略的解决方案更快。如前所述，除非有大量处理器，否则这种方法并不总是更有效。
- en: Running the application repeatedly will result in different results. A more
    aggressive testing approach would be to execute the solution repeatedly under
    possibly different processor loading conditions and then take the average of the
    result. The size of the threshold will also affect its performance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 重复运行应用程序将导致不同的结果。更积极的测试方法是在可能不同的处理器负载条件下重复执行解决方案，然后取结果的平均值。阈值的大小也会影响其性能。
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `numbers` array was declared as a 100,000 element integer array. The `SumOfSquaresTask`
    class was derived from the `RecursiveTask` class using the generic type `Long`.
    A threshold of 1000 was set. Any subarray smaller than this threshold was solved
    using iteration. Otherwise the segment was divided in half and two new tasks were
    created, one for each half.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`numbers`数组声明为一个包含100,000个元素的整数数组。`SumOfSquaresTask`类是从`RecursiveTask`类派生的，使用了泛型类型`Long`。设置了阈值为1000。任何小于此阈值的子数组都使用迭代解决。否则，该段被分成两半，并创建了两个新任务，每个任务处理一半。'
- en: The `ArrayList` was used to hold the two subtasks. This was strictly not needed
    and actually slows down the computation. However, it would be useful if we decided
    to partition the array into more than two segments. It provides a convenient way
    of recombining the elements when the subtasks are joined.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`用于保存两个子任务。这严格来说是不需要的，实际上会减慢计算速度。但是，如果我们决定将数组分成两个以上的段，这将是有用的。它提供了一个方便的方法，在子任务加入时重新组合元素。'
- en: The `fork` method was used to split up the subtasks. They entered the thread
    pool and will eventually be executed. The `join` method returned the results when
    the subtask completed. The sum of the subtasks was added together and then returned.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork`方法用于拆分子任务。它们进入线程池，最终将被执行。`join`方法在子任务完成时返回结果。然后将子任务的总和相加并返回。'
- en: In the `main` method, the first code segment computed the sum of squares using
    a `for` loop. The start and stop time were based on the current time measured
    in milliseconds. The second segment created an instance of the `ForkJoinPool`
    class, and then used its `invoke` method with a new instance of the `SumOfSquaresTask`
    object. The arguments passed to the `SumOfSquaresTask` constructor, instructed
    it to start with the first element of the array and end with the last. Upon completion,
    the execution time was displayed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`方法中，第一个代码段使用`for`循环计算了平方的和。开始和结束时间基于以毫秒为单位测量的当前时间。第二段创建了`ForkJoinPool`类的一个实例，然后使用其`invoke`方法与`SumOfSquaresTask`对象的新实例。传递给`SumOfSquaresTask`构造函数的参数指示它从数组的第一个元素开始，直到最后一个元素。完成后，显示执行时间。
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `ForkJoinPool` class has several methods that report on the state of the
    pool, including:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinPool`类有几种报告池状态的方法，包括：'
- en: '`getPoolSize:` This method returns the number of threads that are started but
    are not completed'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPoolSize:`该方法返回已启动但尚未完成的线程数'
- en: '`getRunningThreadCount:` This method returns an estimate of the number of threads
    that are not blocked but are waiting to join other tasks'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getRunningThreadCount:`该方法返回未被阻塞但正在等待加入其他任务的线程数的估计值'
- en: '`getActiveThreadCount:` This method returns an estimate of the number of threads
    executing tasks'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getActiveThreadCount:`该方法返回执行任务的线程数的估计值'
- en: 'The `ForkJoinPool` class'' `toString` method returns several aspects of the
    pool. Add the following statement immediately after the `invoke` method is executed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`ForkJoinPool`类的`toString`方法返回池的几个方面。在`invoke`方法执行后立即添加以下语句：'
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the program executes, you will get an output similar to the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序执行时，将获得类似以下的输出：
- en: '**forkJoinPool: java.util.concurrent.ForkJoinPool@18fb53f6[Running, parallelism
    = 4, size = 55, active = 0, running = 0, steals = 171, tasks = 0, submissions
    = 0]**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**forkJoinPool: java.util.concurrent.ForkJoinPool@18fb53f6[Running, parallelism
    = 4, size = 55, active = 0, running = 0, steals = 171, tasks = 0, submissions
    = 0]**'
- en: See also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Using the reusable synchronization barrier Phaser* recipe offers a different
    approach for executing multiple threads.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用可重用同步障碍`Phaser`*的方法提供了执行多个线程的不同方法。'
- en: Using the reusable synchronization barrier Phaser
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可重用的同步障碍`Phaser`
- en: The `java.util.concurrent.Phaser` class is concerned with the synchronization
    of threads that work together in cyclic type phases. The threads will execute
    and then wait for the completion of the other threads in the group. When all of
    the threads are completed, one phase is done. The `Phaser` can then be used to
    coordinate the execution of the same set of threads again.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.Phaser`类涉及协调一起工作的线程在循环类型阶段中的同步。线程将执行，然后等待组中其他线程的完成。当所有线程都完成时，一个阶段就完成了。然后可以使用`Phaser`来协调再次执行相同一组线程。'
- en: The `java.util.concurrent.CountdownLatch` class provided a way of doing this,
    but required a fixed number of threads, and is executed once by default. The `java.util.concurrent.CyclicBarrier`,
    which was introduced in Java 5, also used a fixed number of threads, but is reusable.
    However, it is not possible to advance to the next phase. This is useful when
    a problem is characterized by a series of steps/phases that advance from one phase
    to the next based on some criteria.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.CountdownLatch`类提供了一种方法来做到这一点，但需要固定数量的线程，并且默认情况下只执行一次。`java.util.concurrent.CyclicBarrier`，它是在Java
    5中引入的，也使用了固定数量的线程，但是可重用。但是，不可能进入下一个阶段。当问题以一系列基于某些标准的步骤/阶段进行推进时，这是有用的。'
- en: With the introduction of the `Phaser` class in Java 7, we now have a concurrency
    abstraction that combines the features of `CountDownLatch` and `CyclicBarrier`
    and adds support of a dynamic number of threads. The term, phase, refers to the
    idea that the threads can be coordinated to execute in distinct phases, or steps.
    All of the threads will execute and then wait for the others to complete. Once
    they have completed, they will then begin anew and complete a second or subsequent
    phase of operation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Java 7中`Phaser`类的引入，我们现在有了一个结合了`CountDownLatch`和`CyclicBarrier`功能并支持动态线程数量的并发抽象。术语“phase”指的是线程可以协调执行不同阶段或步骤的想法。所有线程将执行，然后等待其他线程完成。一旦它们完成，它们将重新开始并完成第二个或后续阶段的操作。
- en: A barrier is a type of block that prevents a task from proceeding further until
    some condition is met. A common condition is when all of the related threads have
    completed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 屏障是一种阻止任务继续进行的类型的块，直到满足某些条件。一个常见的条件是当所有相关线程都已完成时。
- en: 'The `Phaser` class provides several features, which makes it useful:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Phaser`类提供了几个功能，使其非常有用：'
- en: Parties can be added and removed from the thread pool dynamically
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以动态地向线程池中添加和删除参与者
- en: There is a unique phase number associated with each phase
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个阶段都有一个唯一的阶段号。
- en: The `Phaser` can be terminated causing any waiting threads to return immediately
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Phaser`可以被终止，导致任何等待的线程立即返回'
- en: Exceptions that occur do not affect the state of the barrier
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生的异常不会影响屏障的状态
- en: The `register` method increments the number of parties that are participating.
    The termination of a phaser occurs when the internal count reaches zero or as
    determined by some other criteria set.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`register`方法增加了参与的方数量。当内部计数达到零或根据其他条件确定时，屏障终止。'
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: We will develop an application that mimics the operation of a game engine. The
    first version will create a series of tasks representing participants in a game.
    We will use the `Phaser` class to coordinate their interaction.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个模拟游戏引擎操作的应用程序。第一个版本将创建一系列代表游戏中参与者的任务。我们将使用`Phaser`类来协调它们的交互。
- en: 'To use the `Phaser` class to synchronize the start of a set of tasks:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Phaser`类来同步一组任务的开始：
- en: Create a collection of `Runnable` objects that will participate in the phaser.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将参与`Phaser`的`Runnable`对象集合。
- en: Create an instance of the `Phaser` class.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Phaser`类的一个实例。
- en: 'For each participant:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个参与者：
- en: Register the participant
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册参与者
- en: Create a new thread using the participants' `Runnable` object
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参与者的`Runnable`对象创建一个新线程
- en: Use the `arriveAndAwaitAdvance` method to wait for the other tasks to be created
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`arriveAndAwaitAdvance`方法等待其他任务的创建
- en: Execute the thread
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行线程
- en: Use the `Phaser` object's `arriveAndDeregister` to start the execution of the
    participants.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Phaser`对象的`arriveAndDeregister`来启动参与者的执行。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application with a class called `GamePhaserExample`. We
    will create a simple hierarchy of inner classes that represent the participants
    in a game. Add the `Entity` class as the base abstract class, defined as follows.
    While not absolutely necessary, we''ll be using inheritance to simplify the development
    of these types of applications:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`GamePhaserExample`的新控制台应用程序类。我们将创建一系列内部类的简单层次结构，这些类代表游戏中的参与者。将`Entity`类添加为基本抽象类，定义如下。虽然不是绝对必要的，但我们将使用继承来简化这些类型应用程序的开发：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we will create two derived classes: `Player` and `Zombie`. These classes
    implement the `run` method and a `toString` method. The `run` method uses the
    `sleep` method to simulate the work performed. As expected, zombies are slower
    than humans:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建两个派生类：`Player`和`Zombie`。这些类实现`run`方法和`toString`方法。`run`方法使用`sleep`方法来模拟执行的工作。预期地，僵尸比人类慢：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To make the example clearer, add the following `main` methoid to the `GamePhaserExample`
    class:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使示例更清晰，将以下`main`方法添加到`GamePhaserExample`类中：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, add the following `execute` method where we create a list of participants
    and then call the `gameEngine` method:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加以下`execute`方法，我们在其中创建参与者列表，然后调用`gameEngine`方法：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `gameEngine` method follows. A `for each` loop creates a thread for each
    participant:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`gameEngine`方法。`for each`循环为每个参与者创建一个线程：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Execute the application. The output is non-deterministic, but should be similar
    to the following:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行应用程序。输出是不确定的，但应该类似于以下内容：
- en: '**Player #1 joined the game**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1加入游戏**'
- en: '**Zombie #1 joined the game**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1加入游戏**'
- en: '**Zombie #2 joined the game**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃2加入游戏**'
- en: '**Player #1 waiting for the remaining participants**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1等待剩余参与者**'
- en: '**Zombie #1 waiting for the remaining participants**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1等待剩余参与者**'
- en: '**Zombie #3 joined the game**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃3加入游戏**'
- en: '**Phaser continuing**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**Phaser继续**'
- en: '**Zombie #3 waiting for the remaining participants**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃3等待剩余参与者**'
- en: '**Zombie #2 waiting for the remaining participants**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃2等待剩余参与者**'
- en: '**Zombie #1 starting run**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1开始奔跑**'
- en: '**Zombie #1 started**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1开始**'
- en: '**Zombie #3 starting run**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃3开始奔跑**'
- en: '**Zombie #3 started**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃3开始**'
- en: '**Zombie #2 starting run**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃2开始奔跑**'
- en: '**Zombie #2 started**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃2开始**'
- en: '**Player #1 starting run**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1开始奔跑**'
- en: '**Player #1 started**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1开始**'
- en: '**Player #1 stopped**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1停止**'
- en: '**Zombie #1 stopped**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1停止**'
- en: '**Zombie #3 stopped**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃3停止**'
- en: '**Zombie #2 stopped**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃2停止**'
- en: Notice that the `Phaser` object waits until all of the participants have joined
    the game.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`Phaser`对象会等待直到所有参与者都加入游戏。
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `sleep` method was used to simulate the work involved by that entity. Notice
    the use of the `ThreadLocalRandom` class. Its `nextInt` method returned a random
    number between the values specified in its parameters. When using concurrent threads,
    this is the preferred way of generating random numbers as detailed in the *Supporting
    multiple threads using the ThreadLocalRandom class* recipe.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`sleep` 方法用于模拟实体所涉及的工作。请注意 `ThreadLocalRandom` 类的使用。其 `nextInt` 方法返回其参数中指定的值之间的随机数。在使用并发线程时，这是生成随机数的首选方式，如*使用
    ThreadLocalRandom 类支持多个线程*配方中所述。'
- en: An instance of the `AtomicInteger` class was used to assign unique IDs to each
    object created. This is a safe way of generating numbers in threads. The `toString`
    method returns a simple string representation of the entity.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`AtomicInteger` 类的一个实例用于为每个创建的对象分配唯一的ID。这是在线程中生成数字的安全方式。`toString` 方法返回实体的简单字符串表示形式。'
- en: In the `execute` method, we created an `ArrayList` to hold the participants.
    Notice the use of the diamond operator in the creation of the `ArrayList`. This
    Java 7 language improvement is explained in the *Using the diamond operator for
    constructor type inference* recipe in [Chapter 1](ch01.html "Chapter 1. Java Language
    Improvements"), *Java Language Improvements*. One player and three zombies were
    added. The zombies always seem to outnumber the humans. The `gameEngine` method
    was then called.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`execute` 方法中，我们创建了一个 `ArrayList` 来保存参与者。请注意在创建 `ArrayList` 时使用了菱形操作符。这是Java
    7语言改进，在[第1章](ch01.html "第1章. Java语言改进")的*使用菱形操作符进行构造类型推断*配方中有解释，*Java语言改进*。添加了一个玩家和三个僵尸。僵尸似乎总是比人类多。然后调用了
    `gameEngine` 方法。
- en: A `Phaser` object was created with an argument of one and that represented the
    first participant. It is not an entity and simply served as a mechanism to help
    control the phaser.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数为一的 `Phaser` 对象创建了一个代表第一个参与者的对象。它不是一个实体，只是作为帮助控制阶段器的机制。
- en: In the for each loop, the number of parties in the phaser was incremented by
    one using the `register` method. A new thread was created using an anonymous inner
    class. In its `run` method, the entity was not started until all of the participants
    arrived. The `arriveAndAwaitAdvance` method resulted in the notification that
    a participant has arrived, and that the method should not return until all of
    the participants have arrived and the phase has finished.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个循环中，使用 `register` 方法将阶段器中的方的数量增加一。使用匿名内部类创建了一个新线程。在其 `run` 方法中，直到所有参与者到达之前，实体才会开始。`arriveAndAwaitAdvance`
    方法导致通知参与者已到达，并且该方法在所有参与者到达并且阶段完成之前不返回。
- en: At the start of each iteration of the `while` loop, the number of registered
    participants was one larger than the number of participants who have arrived.
    The `register` method incremented this internal count by one. The internal count
    was then two more than the number that had arrived. When the `arriveAndAwaitAdvance`
    method is executed, the number of participants who are waiting now will be one
    more than those who had registered.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环的每次迭代开始时，注册参与者的数量比已到达的参与者数量多一个。`register` 方法将内部计数增加一。然后内部计数比已到达的数量多两个。当执行
    `arriveAndAwaitAdvance` 方法时，现在等待的参与者数量将比已注册的多一个。
- en: After the loop terminated, there was still one more registered party than participants
    who had arrived. However, when the `arriveAndDeregister` method executed, the
    internal count of the number of participants who had arrived matched the number
    of participants, and the threads started. In addition, the number of registered
    parties was decreased by one. When all of the threads terminated, the application
    terminated.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 循环结束后，仍然有一个比已到达的参与者多的注册方。但是，当执行 `arriveAndDeregister` 方法时，已到达的参与者数量的内部计数与参与者数量匹配，并且线程开始。此外，注册方的数量减少了一个。当所有线程终止时，应用程序终止。
- en: There's more...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is possible to register a group of parties using the `bulkRegister` method.
    This method takes a single integer argument specifying the number of parties to
    register.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `bulkRegister` 方法注册一组方。此方法接受一个整数参数，指定要注册的方的数量。
- en: Under some conditions, it may be desirable to force the termination of the phaser.
    The `forceTermination` method is used for this purpose.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能希望强制终止阶段器。`forceTermination` 方法用于此目的。
- en: 'During the execution of a phaser, there are several methods that will return
    information about the state of the phaser as detailed in the following table.
    If the phaser has terminated, then these methods will have no effect:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行阶段器时，有几种方法可以返回有关阶段器状态的信息，如下表所述。如果阶段器已终止，则这些方法将不起作用：
- en: '| Method | Description |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 描述 |'
- en: '| --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `getRoot` | Returns the root Phaser. Used with a tree of Phasers |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `getRoot` | 返回根阶段器。与阶段器树一起使用 |'
- en: '| `getParent` | Returns the parent of the Phaser |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `getParent` | 返回阶段器的父级 |'
- en: '| `getPhase` | Returns the current phase number |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `getPhase` | 返回当前阶段编号 |'
- en: '| `getArrivedParties` | The number of parties that have arrived at this current
    phase |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `getArrivedParties` | 已到达当前阶段的方的数量 |'
- en: '| `getRegisteredParties` | The number of registered parties |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `getRegisteredParties` | 注册方的数量 |'
- en: '| `getUnarrivedParties` | The number of parties that have not yet arrived at
    this current phase |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `getUnarrivedParties` | 尚未到达当前阶段的方的数量 |'
- en: A tree of phasers can be constructed, where a phaser is created as a branch
    of the task. The `getRoot` method is useful in this situation. The phaser construct
    is discussed at [http://www.cs.rice.edu/~vs3/PDF/SPSS08-phasers.pdf](http://www.cs.rice.edu/~vs3/PDF/SPSS08-phasers.pdf).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以构建阶段器树，其中阶段器作为任务的分支创建。在这种情况下，`getRoot` 方法非常有用。阶段器构造在[http://www.cs.rice.edu/~vs3/PDF/SPSS08-phasers.pdf](http://www.cs.rice.edu/~vs3/PDF/SPSS08-phasers.pdf)中讨论。
- en: Using a phaser to repeat a series of tasks
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用阶段器重复一系列任务
- en: We can also use the `Phaser` class to support a series of phases where tasks
    are executed, a possible intermediate action is performed, and then the series
    of tasks are repeated again.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`Phaser`类来支持一系列阶段，其中执行任务，执行可能的中间操作，然后再次重复一系列任务。
- en: 'To support this behavior, we will modify the `gameEngine` method. The modification
    will include:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这种行为，我们将修改`gameEngine`方法。修改将包括：
- en: The addition of an `iterations` variable
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个`iterations`变量
- en: The overriding of the `Phaser` class' `onAdvance` method
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖`Phaser`类的`onAdvance`方法
- en: Using a `while` loop within each task's `run` method controlled by the `isTerminated`
    method
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个任务的`run`方法中使用`while`循环，由`isTerminated`方法控制
- en: 'Add a variable called `iterations` and initialize it to `3`. This is used to
    specify how many phases we will use. Also, override the `onAdvance` method shown
    as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为`iterations`的变量，并将其初始化为`3`。这用于指定我们将使用多少个阶段。还要重写如下所示的`onAdvance`方法：
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each phase is uniquely numbered and starts at zero. A call to the `onAdvance`
    passes the current phase number and the current number of parties registered to
    the phaser. The default implementation of this method returns `true` when the
    number of registered parties becomes zero. This results in the phaser being terminated.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都有唯一的编号，从零开始。调用`onAdvance`传递当前阶段编号和注册到phaser的当前参与方数量。当注册方数量变为零时，此方法的默认实现返回`true`。这将导致phaser被终止。
- en: The implementation of this method resulted in the method returning `true` only
    if the phase number exceeded the `iterations` value, that is, minus 1, or there
    are no registered parties using the phaser.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的实现导致仅当阶段编号超过`iterations`值（即减1）或没有使用phaser的注册方时，该方法才返回`true`。
- en: 'Modify the `run` method as highlighted in the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下代码中突出显示的内容修改`run`方法：
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The entity is allowed to run first, and then it waits for the other participants
    to complete and arrive. As long as the phaser has not been terminated as determined
    by the `isTerminated` method, the next phase will be executed when everyone is
    ready.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 实体被允许先运行，然后等待其他参与者完成和到达。只要通过`isTerminated`方法确定的phaser尚未终止，当每个人准备好时，下一阶段将被执行。
- en: 'The last step is to use the `arriveAndAwaitAdvance` method to advance the phaser
    to the next phase. Again, as long as the phaser has not terminated, the phaser
    will advance to the next phase when every participant has arrived. Use the following
    code sequence to accomplish this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用`arriveAndAwaitAdvance`方法将phaser推进到下一个阶段。同样，只要phaser尚未终止，当每个参与者到达时，phaser将推进到下一个阶段。使用以下代码序列来完成此操作：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Execute the program using only one player and one zombie. This will reduce
    the amount of output and should be similar to the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用一个玩家和一个僵尸执行程序。这将减少输出量，并且应与以下内容类似：
- en: '**Player #1 joined the game**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1加入游戏**'
- en: '**Zombie #1 joined the game**'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1加入游戏**'
- en: '**Player #1 starting run**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1开始运行**'
- en: '**Player #1 started**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1开始**'
- en: '**Zombie #1 starting run**'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1开始运行**'
- en: '**Zombie #1 started**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1开始**'
- en: '**Player #1 stopped**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1停止**'
- en: '**Player #1 waiting for the remaining participants during phase 0**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1在第0阶段等待剩余参与者**'
- en: '**Zombie #1 stopped**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1停止**'
- en: '**Zombie #1 waiting for the remaining participants during phase 0**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1在第0阶段等待剩余参与者**'
- en: '**Phase number 0 completed**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**第0阶段完成**'
- en: '**Player #1 starting run**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1开始运行**'
- en: '**Player #1 started**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1开始**'
- en: '**Zombie #1 starting run**'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1开始运行**'
- en: '**Zombie #1 started**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1开始**'
- en: '**Player #1 stopped**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1停止**'
- en: '**Player #1 waiting for the remaining participants during phase 1**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1在第1阶段等待剩余参与者**'
- en: '**Zombie #1 stopped**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1停止**'
- en: '**Zombie #1 waiting for the remaining participants during phase 1**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1在第1阶段等待剩余参与者**'
- en: '**Phase number 1 completed**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**第1阶段完成**'
- en: '**Zombie #1 starting run**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1开始运行**'
- en: '**Player #1 starting run**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1开始运行**'
- en: '**Zombie #1 started**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1开始**'
- en: '**Player #1 started**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1开始**'
- en: '**Player #1 stopped**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1停止**'
- en: '**Player #1 waiting for the remaining participants during phase 2**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家＃1在第2阶段等待剩余参与者**'
- en: '**Zombie #1 stopped**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1停止**'
- en: '**Zombie #1 waiting for the remaining participants during phase 2**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**僵尸＃1在第2阶段等待剩余参与者**'
- en: '**Phase number 2 completed**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**第2阶段完成**'
- en: '**Phaser continuing**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**Phaser继续**'
- en: See also
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: See the *Using a random number generator isolated to the current thread* recipe
    for further information about generating random numbers for multiple threads.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有关为多个线程生成随机数的更多信息，请参阅*使用当前线程隔离的随机数生成器*。
- en: Using the new ConcurrentLinkedDeque safely with multiple threads
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全地使用新的`ConcurrentLinkedDeque`与多个线程
- en: The `java.util.concurrent.ConcurrentLinkedDeque` class, which is a member of
    the Java Collections Framework, offers the ability for multiple threads to safely
    access the same data collection concurrently. The class implements a double-ended
    queue, known as a **deque**, and allows for the insertion and removal of elements
    from both ends of the deque. It is also known as a head-tail linked list and,
    like other concurrent collections, does not allow the usage of null elements.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.ConcurrentLinkedDeque`类是Java集合框架的成员，它允许多个线程安全地同时访问相同的数据集合。该类实现了一个双端队列，称为**deque**，并允许从deque的两端插入和删除元素。它也被称为头尾链接列表，并且与其他并发集合一样，不允许使用空元素。'
- en: In this recipe we will demonstrate a basic implementation of the `ConcurrentLinkedDeque`
    class and illustrate the use of some of the most common methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将演示`ConcurrentLinkedDeque`类的基本实现，并说明一些最常用方法的使用。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备好了
- en: 'To use a `ConcurrentLinkedDeque` in a producer/consumer framework:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产者/消费者框架中使用`ConcurrentLinkedDeque`：
- en: Create an instance of a `ConcurrentLinkedDeque`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ConcurrentLinkedDeque`的实例。
- en: Define the element to place into the deque.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义要放入双端队列的元素。
- en: Implement a producer thread to generate elements to be placed in the deque.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个生产者线程来生成要放入双端队列中的元素。
- en: Implement a consumer thread to remove elements from the deque.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个消费者线程来从双端队列中删除元素。
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new console application. Declare a private static instance of a `ConcurrentLinkedDeque`
    using a generic type of `Item`. The `Item` class is declared as an inner class.
    Include get methods and constructors, as shown in the following code, using two
    attributes, `description` and `itemId:`
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。使用`Item`的泛型类型声明一个私有静态实例的`ConcurrentLinkedDeque`。`Item`类被声明为内部类。包括获取方法和构造函数，如下面的代码所示，使用两个属性`description`和`itemId`：
- en: '[PRE12]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then create a producer class to generate elements of the type `Item`. For this
    recipe''s purposes, we are only going to generate seven items and then print out
    a statement to demonstrate that the item has been added to the deque. We use the
    `ConcurrentLinkedDeque` class'' `add` method to add the elements. After each addition,
    the thread sleeps briefly:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个生产者类来生成`Item`类型的元素。为了这个示例的目的，我们只会生成七个项目，然后打印出一个声明来证明该项目已添加到双端队列中。我们使用`ConcurrentLinkedDeque`类的`add`方法来添加元素。每次添加后，线程会短暂休眠：
- en: '[PRE13]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, create a consumer class. To ensure that the deque will have elements
    in it by the time the consumer thread tries to access it, we make the thread sleep
    for one second prior to retrieving elements. Then we use the `pollFirst` method
    to retrieve the first element in the deque. If the element is not null then we
    pass the element to a `generateOrder` method. In this method, we print out information
    about the item:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个消费者类。为了确保在消费者线程尝试访问它之前，双端队列中将有元素，我们让线程在检索元素之前睡眠一秒钟。然后我们使用`pollFirst`方法来检索双端队列中的第一个元素。如果元素不为空，那么我们将元素传递给`generateOrder`方法。在这个方法中，我们打印有关该项目的信息：
- en: '[PRE14]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, in our `main` method, we start both threads:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的`main`方法中，启动两个线程：
- en: '[PRE15]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When you execute the program, you should see output similar to the following:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您执行程序时，您应该看到类似以下的输出：
- en: '**New Item Added:Item1 1**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**新项目已添加：Item1 1**'
- en: '**New Item Added:Item2 2**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**新项目已添加：Item2 2**'
- en: '**New Item Added:Item3 3**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**新项目已添加：Item3 3**'
- en: '**New Item Added:Item4 4**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**新项目已添加：Item4 4**'
- en: '**Part Order**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**零件订单**'
- en: '**Item description: Item1**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item1**'
- en: '**Item ID # 1**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目ID＃1**'
- en: '**New Item Added:Item5 5**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**新项目已添加：Item5 5**'
- en: '**New Item Added:Item6 6**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**新项目已添加：Item6 6**'
- en: '**New Item Added:Item7 7**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**新项目已添加：Item7 7**'
- en: '**Part Order**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**零件订单**'
- en: '**Item description: Item2**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item2**'
- en: '**Item ID # 2**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目ID＃2**'
- en: '**Part Order**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**零件订单**'
- en: '**Item description: Item3**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item3**'
- en: '**Item ID # 3**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目ID＃3**'
- en: '**Part Order**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**零件订单**'
- en: '**Item description: Item4**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item4**'
- en: '**Item ID # 4**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目ID＃4**'
- en: '**Part Order**'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**零件订单**'
- en: '**Item description: Item5**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item5**'
- en: '**Item ID # 5**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目ID＃5**'
- en: '**Part Order**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**零件订单**'
- en: '**Item description: Item6**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item6**'
- en: '**Item ID # 6**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目ID＃6**'
- en: '**Part Order**para'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**零件订单**para'
- en: '**Item description: Item7**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item7**'
- en: '**Item ID # 7**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目ID＃7**'
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we started both threads, we gave the producer thread a head start to populate
    our deque with items. After a second, the consumer thread began retrieving elements.
    The use of the `ConcurrentLinkedDeque` class allowed both threads to safely access
    elements of the deque at the same time.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动两个线程时，我们让生产者线程提前一点时间来填充我们的双端队列。一秒钟后，消费者线程开始检索元素。使用`ConcurrentLinkedDeque`类允许两个线程同时安全地访问双端队列的元素。
- en: In our example, we made use of the methods `add` and `pollFirst` to add and
    remove elements of the deque. There are a number of methods available, many of
    which operate in essentially the same fashion. The *There's more..*. section provides
    more detail about the various options for accessing the deque elements.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了`add`和`pollFirst`方法来添加和删除双端队列的元素。有许多可用的方法，其中许多方法基本上以相同的方式运行。*还有更多...*部分提供了有关访问双端队列元素的各种选项的更多详细信息。
- en: There's more...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We will cover several topics including:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖几个主题，包括：
- en: Problems with asynchronous concurrent threads
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步并发线程存在问题
- en: Adding elements to the deque
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向双端队列添加元素
- en: Retrieving elements from the deque
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从双端队列中检索元素
- en: Accessing a specific element of the deque
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问双端队列的特定元素
- en: Problems with asynchronous concurrent threads
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步并发线程存在问题
- en: Due to the fact that multiple threads may be accessing the collection at any
    given moment, the `size` method is not always going to return an accurate result.
    This is also true when using the `iterator` or `descendingIterator` methods. Additionally,
    any bulk data operations, such as `addAll` or `removeAll`, are not always going
    to achieve the desired results. If one thread is accessing an item in the collection
    and another thread tries to pull all items, the bulk action is not guaranteed
    to function atomically.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多个线程可能在任何给定时刻访问集合，因此`size`方法并不总是会返回准确的结果。当使用`iterator`或`descendingIterator`方法时，情况也是如此。此外，任何批量数据操作，例如`addAll`或`removeAll`，也不总是会达到预期的结果。如果一个线程正在访问集合中的一个项目，而另一个线程尝试拉取所有项目，则批量操作不能保证以原子方式运行。
- en: 'There are two `toArray` methods available for retrieving all elements of the
    deque and storing them in an array. The first returns an array of objects representing
    all of the elements of the deque and can be cast to the appropriate data type.
    This is useful when the elements of the deque are of different data types. The
    following is an example of how to use the first form of the `toArray` method using
    our previous thread example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种`toArray`方法可用于检索双端队列的所有元素并将它们存储在数组中。第一个返回表示双端队列所有元素的对象数组，并且可以转换为适当的数据类型。当双端队列的元素是不同的数据类型时，这是有用的。以下是如何使用`toArray`方法的第一种形式的示例，使用我们之前的线程示例：
- en: '[PRE16]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The other `toArray` method requires an initialized array of a specific data
    type as an argument and returns an array of elements of that data type.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`toArray`方法需要一个特定数据类型的初始化数组作为参数，并返回该数据类型的元素数组。
- en: '[PRE17]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Adding elements to the deque
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向双端队列添加元素
- en: 'The following table lists some of the methods available for adding elements
    to the deque. The methods that are grouped together in the following table perform
    essentially the same function. This variety of similar methods is the result of
    the `ConcurrentLinkedDeque` class implementing slightly different interfaces:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '以下表格列出了一些可用于向双端队列中添加元素的方法。在下表中分组在一起的方法本质上执行相同的功能。这种类似方法的多样性是`ConcurrentLinkedDeque`类实现略有不同接口的结果： '
- en: '| Method name | Adds an element to |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: 方法名 | 添加元素到 |
- en: '| --- | --- |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `add(Element e)``offer(Element e)``offerLast(Element e)``addLast(Element
    e)` | End of the deque |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `add(Element e)``offer(Element e)``offerLast(Element e)``addLast(Element
    e)` | 双端队列的末尾 |'
- en: '| `addFirst(Element e)``offerFirst(Element e)``push(Element e)` | Front of
    the deque |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `addFirst(Element e)``offerFirst(Element e)``push(Element e)` | 双端队列的前端 |'
- en: Retrieving elements from the deque
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从双端队列中检索元素
- en: 'The following are some of the methods available for retrieving elements from
    the deque:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些用于从双端队列中检索元素的方法：
- en: '| Method name | Error action | Function |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 方法名 | 错误操作 | 功能 |'
- en: '| --- | --- | --- |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `element()` | Throws exception if deque is empty | Retrieves but does not
    remove the first element of the deque |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `element()` | 如果双端队列为空则抛出异常 | 检索但不移除双端队列的第一个元素 |'
- en: '| `getFirst()` |   |   |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `getFirst()` |   |   |'
- en: '| `getLast()` |   |   |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `getLast()` |   |   |'
- en: '| `peek()` | Returns null if deque is empty |   |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `peek()` | 如果双端队列为空则返回null |   |'
- en: '| `peekFirst()` |   |   |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `peekFirst()` |   |   |'
- en: '| `peekLast()` |   |   |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `peekLast()` |   |   |'
- en: '| `pop()` | Throws exception if deque is empty | Retrieves and removes first
    element of deque |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `pop()` | 如果双端队列为空则抛出异常 | 检索并移除双端队列的第一个元素 |'
- en: '| `removeFirst()` |   |   |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `removeFirst()` |   |   |'
- en: '| `poll()` | Returns null if deque is empty |   |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `poll()` | 如果双端队列为空则返回null |   |'
- en: '| `pollFirst()` |   |   |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `pollFirst()` |   |   |'
- en: '| `removeLast()` | Throws exception if deque is empty | Retrieves and removes
    last element of deque |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `removeLast()` | 如果双端队列为空则抛出异常 | 检索并移除双端队列的最后一个元素 |'
- en: '| `pollLast()` | Returns null if deque is empty |   |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `pollLast()` | 如果双端队列为空则返回null |   |'
- en: Accessing a specific element of the deque
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问双端队列的特定元素
- en: 'The following are some of the methods available for accessing specific elements
    of a deque:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些用于访问双端队列特定元素的方法：
- en: '| Method name | Function | Comments |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 方法名 | 功能 | 注释 |'
- en: '| --- | --- | --- |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `contains(Element e)` | Returns `true` if the deque contains at least one
    element that equals `Element e` |   |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `contains(Element e)` | 如果双端队列包含至少一个等于`Element e`的元素则返回`true` |   |'
- en: '| `remove(Element e)``removeFirstOccurrence(Element e)` | Removes the first
    occurrence of an element in the deque that equals `Element e` | If the element
    does not exist in the deque, the deque is unchanged. Throws exception if `e` is
    null |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `remove(Element e)``removeFirstOccurrence(Element e)` | 移除双端队列中第一个等于`Element
    e`的元素 | 如果元素在双端队列中不存在，则双端队列保持不变。如果`e`为null则抛出异常 |'
- en: '| `removeLastOccurrence(Element e)` | Removes the last occurrence of an element
    in the deque that equals `Element e` |   |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| `removeLastOccurrence(Element e)` | 移除双端队列中最后一个等于`Element e`的元素 |   |'
- en: Using the new LinkedTransferQueue class
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用新的LinkedTransferQueue类
- en: The `java.util.concurrent.LinkedTransferQueue` class implements the `java.util.concurrent.TransferQueue`
    interface and is an unbounded queue that follows a **First In First Out** model
    for the queue elements. This class provides blocking methods and non-blocking
    methods for retrieving elements and is an appropriate choice for concurrent access
    by multiple threads. In this recipe we will create a simple implementation of
    a `LinkedTransferQueue` and explore some of the methods available in this class.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.LinkedTransferQueue`类实现了`java.util.concurrent.TransferQueue`接口，是一个无界队列，遵循**先进先出**模型。该类提供了用于检索元素的阻塞方法和非阻塞方法，并且适合于多个线程的并发访问。在本示例中，我们将创建一个`LinkedTransferQueue`的简单实现，并探索该类中的一些可用方法。'
- en: Getting ready
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To use a `LinkedTransferQueue` in a producer/consumer framework:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要在生产者/消费者框架中使用`LinkedTransferQueue`：
- en: Create an instance of a `LinkedTransferQueue`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`LinkedTransferQueue`的实例。
- en: Define a type of element to place into the queue.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义要放入队列的元素类型。
- en: Implement a producer thread to generate elements to be placed in the queue.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个生产者线程来生成要放入队列的元素。
- en: Implement a consumer thread to remove elements from the queue.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个消费者线程来从队列中移除元素。
- en: How to do it...
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application. Declare a private static instance of a `LinkedTransferQueue`
    using a generic type of `Item`. Then create the inner class `Item` and include
    get methods and constructors, as shown in the following code, using two attributes,
    `description` and `itemId` as follows:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。使用`Item`的泛型类型声明一个`LinkedTransferQueue`的私有静态实例。然后创建内部类`Item`，并包括如下代码所示的get方法和构造函数，使用`description`和`itemId`这两个属性：
- en: '[PRE18]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, create a producer class to generate elements of the type `Item`. For
    this recipe''s purposes, we are only going to generate seven items and then print
    out a statement to demonstrate that the item has been added to the queue. We will
    use the `LinkedTransferQueue` class'' `offer` method to add the elements. After
    each addition, the thread sleeps briefly and we print out the name of the item
    added. We then use the `hasWaitingConsumer` method to determine if there are any
    consumer threads waiting for items to become available:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个生产者类来生成`Item`类型的元素。为了本示例的目的，我们只会生成七个项目，然后打印一条语句来演示该项目已被添加到队列中。我们将使用`LinkedTransferQueue`类的`offer`方法来添加元素。在每次添加后，线程会短暂休眠，然后我们打印出添加的项目的名称。然后我们使用`hasWaitingConsumer`方法来确定是否有任何消费者线程正在等待可用的项目：
- en: '[PRE19]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, create a consumer class. To demonstrate the function of the `hasWaitingConsumer`
    method, we make the thread sleep for one second prior to retrieving elements to
    ensure there is no waiting consumer at first. Then, within a `while` loop, we
    use the `take` method to remove the first item in the list. We chose the `take`
    method because it is a blocking method and will wait until the queue has an available
    element. Once the consumer thread is able to take an element, we pass the element
    to the `generateOrder` method, which prints out information about the item:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个消费者类。为了演示`hasWaitingConsumer`方法的功能，我们让线程在检索元素之前睡眠一秒钟，以确保一开始没有等待的消费者。然后，在`while`循环内，我们使用`take`方法来移除列表中的第一个项目。我们选择了`take`方法，因为它是一个阻塞方法，会等待直到队列有可用的元素。一旦消费者线程能够取出一个元素，我们将元素传递给`generateOrder`方法，该方法打印有关项目的信息：
- en: '[PRE20]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, in our `main` method, we start both threads:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的`main`方法中，我们启动了两个线程：
- en: '[PRE21]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When you execute the program, you should see output similar to the following:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您执行程序时，您应该看到类似以下的输出：
- en: '**New Item Added:Item1 1**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**新添加的项目：Item1 1**'
- en: '**New Item Added:Item2 2**'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**新添加的项目：Item2 2**'
- en: '**New Item Added:Item3 3**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**新添加的项目：Item3 3**'
- en: '**New Item Added:Item4 4**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**新添加的项目：Item4 4**'
- en: '**Part Order**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 零件订单
- en: '**Item description: Item1**'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item1**'
- en: '**Item ID # 1**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目编号＃1**'
- en: '**Part Order**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 零件订单
- en: '**Item description: Item2**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item2**'
- en: '**Item ID # 2**'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目编号＃2**'
- en: '**Part Order**'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 零件订单
- en: '**Item description: Item3**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item3**'
- en: '**Item ID # 3**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目编号＃3**'
- en: '**Part Order**'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 零件订单
- en: '**Item description: Item4**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item4**'
- en: '**Item ID # 4**'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目编号＃4**'
- en: '**Hurry up!**'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '**快点！**'
- en: '**New Item Added:Item5 5**'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**新添加的项目：Item5 5**'
- en: '**Part Order**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 零件订单
- en: '**Item description: Item5**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item5**'
- en: '**Item ID # 5**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目编号＃5**'
- en: '**Hurry up!**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**快点！**'
- en: '**Part Order**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 零件订单
- en: '**Item description: Item6**'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item6**'
- en: '**Item ID # 6**'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目编号＃6**'
- en: '**New Item Added:Item6 6**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**新添加的项目：Item6 6**'
- en: '**Hurry up!**'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**快点！**'
- en: '**Part Order**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 零件订单
- en: '**Item description: Item7**'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目描述：Item7**'
- en: '**Item ID # 7**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 项目编号＃7
- en: '**New Item Added:Item7 7**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**新添加的项目：Item7 7**'
- en: '**Hurry up!**'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 快点！
- en: How it works...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we started both threads, we gave the producer thread a **head start** to
    populate our queue with items by sleeping for one second in the `ItemConsumer`
    class. Notice that the `hasWaitingConsumer` method returned `false` initially
    because the `take` method had not yet been executed by the consumer thread. After
    a second, the consumer thread began retrieving elements. With each retrieval,
    the `generateOrder` method printed out information about the element retrieved.
    After all elements in the queue were retrieved, notice a final *Hurry up!* statement,
    indicating there is still a consumer waiting. In this example, because the consumer
    is using a blocking method within a `while` loop, the thread will never terminate.
    In a real life situation, the thread should be terminated in a more graceful manner,
    such as sending a terminate message to the consumer thread.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动了两个线程时，我们让生产者线程有一个**领先**，通过在`ItemConsumer`类中睡眠一秒钟来填充我们的队列。请注意，`hasWaitingConsumer`方法最初返回`false`，因为消费者线程尚未执行`take`方法。一秒钟后，消费者线程开始检索元素。在每次检索时，`generateOrder`方法打印有关检索到的元素的信息。在检索队列中的所有元素之后，请注意最后的*快点！*语句，表示仍有消费者在等待。在这个例子中，因为消费者在`while`循环中使用了一个阻塞方法，线程永远不会终止。在现实生活中，线程应该以更优雅的方式终止，比如向消费者线程发送终止消息。
- en: In our example, we used the methods `offer` and `take` to add and remove elements
    of the queue. There are other methods available and these are discussed in the
    *There's more..*. section.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用了`offer`和`take`方法来添加和移除队列的元素。还有其他可用的方法，这些方法在*还有更多..*部分中讨论。
- en: There's more...
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here we will discuss the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将讨论以下内容：
- en: Problems with asynchronous concurrent threads
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步并发线程的问题
- en: Adding elements to the queue
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向队列添加元素
- en: Retrieving elements from the deque
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从双端队列中检索元素
- en: Problems with asynchronous concurrent threads
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步并发线程的问题
- en: Due to the fact that multiple threads may be accessing the collection at any
    given moment, the `size` method is not always going to return an accurate result.
    Additionally, any bulk data operations, such as `addAll` or `removeAll`, are not
    always going to achieve the desired results. If one thread is accessing an item
    in the collection and another thread tries to pull all items, the bulk action
    is not guaranteed to function atomically.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多个线程可能在任何给定时刻访问集合，因此`size`方法不总是会返回准确的结果。此外，任何批量数据操作，如`addAll`或`removeAll`，也不总能达到期望的结果。如果一个线程正在访问集合中的一个项目，另一个线程尝试拉取所有项目，则不保证批量操作会以原子方式运行。
- en: Adding elements to the queue
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向队列添加元素
- en: 'The following are some of the methods available for adding elements to the
    queue:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可用于向队列添加元素的方法：
- en: '| Method name | Adds element to the | Comments |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 方法名称 | 添加元素到 | 评论 |'
- en: '| --- | --- | --- |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `add(Element e)` | End of the queue | Queue is unbounded, so the method will
    never return `false` or throw an exception |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `add（Element e）` | 队列末尾 | 队列是无界的，因此该方法永远不会返回`false`或抛出异常 |'
- en: '| `offer(Element e)` |   | Queue is unbounded, so the method will never return
    `false` |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `offer（Element e）` |  | 队列是无界的，因此该方法永远不会返回`false` |'
- en: '| `put(Element e)` |   | Queue is unbounded, so the method will never block
    |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `put（Element e）` |  | 队列是无界的，因此该方法永远不会阻塞 |'
- en: '| `offer(Element``e, Long t`,`TimeUnit u)` | End of the queueWait for t time
    units of type u before giving up | Queue is unbounded, so the method will always
    return `true` |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `offer（Element``e, Long t`,`TimeUnit u）` | 队列末尾等待t个时间单位的类型u然后放弃 | 队列是无界的，因此该方法将始终返回`true`
    |'
- en: Retrieving elements from the deque
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从双端队列中检索元素
- en: 'The following are some of the methods available for retrieving elements from
    the deque:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可用于从双端队列中检索元素的方法：
- en: '| Method name | Function | Comments |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 方法名称 | 功能 | 评论 |'
- en: '| --- | --- | --- |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `peek()` | Retrieves, but does not remove the first element of the queue
    | Returns null if the queue is empty |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `peek()` | 检索队列的第一个元素，但不移除 | 如果队列为空，则返回null |'
- en: '| `poll()` | Removes the first element of the queue | Returns null if the queue
    is empty |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `poll()` | 移除队列的第一个元素 | 如果队列为空，则返回null |'
- en: '| `poll(Long t, TimeUnit u)` | Removes element from front of the queue, waiting
    time t (in units u) before giving up | Returns null if the time limit is up before
    an element is available |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `poll(Long t, TimeUnit u)` | 从队列前面移除元素，在时间t（以单位u计）之前放弃 | 如果时间限制在元素可用之前到期，则返回null
    |'
- en: '| `remove(Object e)` | Removes element from the queue that equals `Object e`
    | Returns `true` if the element is found and removed |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `remove(Object e)` | 从队列中移除等于`Object e`的元素 | 如果找到并移除元素，则返回`true` |'
- en: '| `take()` | Removes the first element of the queue | Throws an exception if
    interrupted while blocking |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| `take()` | 移除队列的第一个元素 | 如果在阻塞时被中断，则抛出异常 |'
- en: '| `transfer(Element e)` | Transfers an element to the consumer thread, waiting
    if necessary | Will insert an element at the end of the queue and wait for the
    consumer thread to retrieve it |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| `transfer(Element e)` | 将元素传输给消费者线程，必要时等待 | 将元素插入队列末尾，并等待消费者线程检索它 |'
- en: '| `tryTransfer(Element e)` | Transfers an element immediately to the consumer
    | Returns `false` if the consumer is not available |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| `tryTransfer(Element e)` | 立即将元素传输给消费者 | 如果消费者不可用，则返回`false` |'
- en: '| `tryTransfer(Element e, Time t, TimeUnit u)` | Transfers an element to the
    consumer immediately, or within time specified by t (in units u) | Returns `false`
    if the consumer is not available when the time limit has elapsed |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| `tryTransfer(Element e, Time t, TimeUnit u)` | 立即将元素传输给消费者，或在t（以单位u计）指定的时间内
    | 如果消费者在时间限制到期时不可用，则返回`false` |'
- en: Supporting multiple threads using the ThreadLocalRandom class
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ThreadLocalRandom类支持多个线程
- en: The `java.util.concurrent` package has a new class, `ThreadLocalRandom`, which
    supports functionality similar to the `Random` class. However, the use of this
    new class, with multiple threads, will result in less contention and better performance
    as compared to their use with the `Random` class. When multiple threads need to
    use random numbers, the `ThreadLocalRandom` class should be used. The random number
    generator is local to the current thread. This recipe examines how to use this
    class.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`包中有一个新的类`ThreadLocalRandom`，它支持类似于`Random`类的功能。然而，使用这个新类与多个线程将导致较少的争用和更好的性能，与`Random`类相比。当多个线程需要使用随机数时，应该使用`ThreadLocalRandom`类。随机数生成器是局部的。本食谱将介绍如何使用这个类。'
- en: Getting ready
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The recommended way of using this class is to:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类的推荐方法是：
- en: Use the static `current` method to return an instance of the `ThreadLocalRandom`
    class.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用静态的`current`方法返回`ThreadLocalRandom`类的一个实例。
- en: Use the methods of the class against this object.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该对象的方法。
- en: How to do it...
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new console application. Add the following code to the `main` method:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序。将以下代码添加到`main`方法中：
- en: '[PRE22]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Execute the program. Your output should appear similar to the following:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行程序。您的输出应该类似于以下内容：
- en: '**Five random integers**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**五个随机整数**'
- en: '**0**'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**0**'
- en: '**4232237**'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '**4232237**'
- en: '**178803790**'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**178803790**'
- en: '**758674372**'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '**758674372**'
- en: '**1565954732**'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**1565954732**'
- en: '**Random double number between 0.0 and 35.0**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**0.0和35.0之间的随机双精度数**'
- en: '**3.196571144914888**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**3.196571144914888**'
- en: '**Five random Long numbers between 1234567 and 7654321**'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**1234567和7654321之间的五个随机长整数**'
- en: '**7525440**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**7525440**'
- en: '**2545475**'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**2545475**'
- en: '**1320305**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**1320305**'
- en: '**1240628**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**1240628**'
- en: '**1728476**'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**1728476**'
- en: How it works...
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `nextInt` method was executed five times with its return value being displayed.
    Notice that the method returns 0 initially. The `ThreadLocalRandom` class extends
    the `Random` class. However, the `setSeed` method is not supported. If you try
    to use it, it will throw an `UnsupportedOperationException.`
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextInt`方法被执行了五次，其返回值被显示出来。注意该方法最初返回0。`ThreadLocalRandom`类扩展了`Random`类。然而，不支持`setSeed`方法。如果尝试使用它，将抛出`UnsupportedOperationException`。'
- en: The `nextDouble` method was then executed. This version of the overloaded method
    returned a number between 0.0 and 35.0\. The `nextLong` method was executed five
    times using two parameters, which specified its starting (inclusive) and ending
    (exclusive) range values.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行了`nextDouble`方法。这个重载方法返回了一个介于0.0和35.0之间的数字。使用两个参数执行了五次`nextLong`方法，指定了其起始（包括）和结束（不包括）的范围值。
- en: There's more...
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The methods of this class return uniformly distributed numbers. The following
    table summarizes its methods:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的方法返回均匀分布的数字。以下表总结了它的方法：
- en: Tip
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When a range is specified, the start value is inclusive and the end value is
    exclusive.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 当指定范围时，起始值是包含的，结束值是不包含的。
- en: '| Method | Parameters | Returns |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 参数 | 返回 |'
- en: '| --- | --- | --- |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `current` | None | The thread''s current instance |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
  zh: '| `current` | 无 | 线程的当前实例 |'
- en: '| `next` | Integer value representing the number of bits for the return value
    | An integer in the range specified by the number of bits |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '| `next` | 代表返回值位数的整数值 | 位数范围内的整数 |'
- en: '| `nextDouble` | doubledouble, double | A double number between 0.0 and its
    argumentA double number between its arguments |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
  zh: '| `nextDouble` | doubledouble, double | 0.0和其参数之间的双精度数0.0和其参数之间的双精度数 |'
- en: '| `nextInt` | int, int | An integer number between its arguments |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
  zh: '| `nextInt` | int, int | 其参数之间的整数 |'
- en: '| `nextLong` | longlong, long | A long number between 0 and its argumentA long
    number between its arguments |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
  zh: '| `nextLong` | longlong, long | 0和其参数之间的长整数0和其参数之间的长整数 |'
- en: '| `setSeed` | long | Throws `UnsupportedOperationException` |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
  zh: '| `setSeed` | long | 抛出 `UnsupportedOperationException` |'
- en: See also
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Examples of its use are found in the *Using the reusable synchronization barrier
    Phaser* recipe.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用可重用同步障碍Phaser*食谱中找到了它的用法示例。
