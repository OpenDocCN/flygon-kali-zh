- en: Chapter 3. Using a Thread Pool
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用线程池
- en: 'In this chapter, we will describe common techniques for working with shared
    resources from multiple threads. You will learn about:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将描述使用多个线程从共享资源中工作的常见技术。您将了解：
- en: Invoking a delegate on a thread pool
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程池上调用委托
- en: Posting an asynchronous operation on a thread pool
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程池上发布异步操作
- en: Thread pool and the degree of parallelism
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程池和并行度
- en: Implementing a cancellation option
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现取消选项
- en: Using a wait handle and a timeout with a thread pool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用等待句柄和线程池的超时
- en: Using a timer
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用定时器
- en: Using the BackgroundWorker component
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用BackgroundWorker组件
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapters, we discussed several ways to create threads and organize
    their cooperation. Now let's consider another scenario where we create many asynchronous
    operations that take very little time to complete. As we discussed in the *Introduction*
    section of [Chapter 1](ch01.html "Chapter 1. Threading Basics"), *Threading Basics*,
    creating a thread is an expensive operation, so doing this for each short-lived,
    asynchronous operation will include a significant overhead expense.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了创建线程和组织它们的合作的几种方法。现在让我们考虑另一种情况，即创建许多需要很短时间完成的异步操作。正如我们在[第1章](ch01.html
    "第1章。线程基础")的*介绍*部分中讨论的那样，创建线程是一项昂贵的操作，因此为每个短暂的异步操作进行这样的操作将包含显着的开销。
- en: To deal with this problem, there is a common approach called **pooling** that
    can be successfully applied to any situation when we need many short-lived, expensive
    resources. We allocate a certain amount of those resources in advance, and organize
    them into a resource pool. Each time we need a new resource, we just take it from
    the pool, instead of creating a new one, and return it to the pool after the resource
    is no longer needed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，有一种称为**池化**的常见方法，可以成功应用于任何需要许多短暂的昂贵资源的情况。我们预先分配一定数量的这些资源，并将它们组织成资源池。每当我们需要新资源时，我们只需从池中取出，而不是创建一个新的，并在资源不再需要时将其返回到池中。
- en: The **.NET thread pool** is an implementation of this concept. It is accessible
    via the `System.Threading.ThreadPool` type. A thread pool is managed by .NET **Common
    Language Runtime** (**CLR**), which means that there is one instance of a thread
    pool per CLR. The `ThreadPool` type has a `QueueUserWorkItem` static method that
    accepts a **delegate**, representing a user-defined, asynchronous operation. After
    this method is called, this delegate goes to the internal queue. Then, if there
    are no threads inside the pool, it creates a new **worker thread** and puts the
    first delegate in the queue on it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET线程池**是这个概念的一种实现。它可以通过`System.Threading.ThreadPool`类型访问。线程池由.NET **公共语言运行时**（**CLR**）管理，这意味着每个CLR都有一个线程池实例。`ThreadPool`类型有一个`QueueUserWorkItem`静态方法，接受一个代表用户定义的异步操作的**委托**。调用此方法后，该委托进入内部队列。然后，如果线程池中没有线程，它会创建一个新的**工作线程**，并将第一个委托放入队列中。'
- en: If we put new operations on a thread pool, after the previous operations are
    completed, it is possible to re-use this one thread to execute these operations.
    However, if we put new operations faster, the thread pool will create more threads
    to serve these operations. There is a limit to prevent creating too many threads,
    and in that case, new operations will wait in the queue until the worker threads
    in the pool become free to serve them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在线程池中放置新操作，那么在前面的操作完成后，可以重用这个线程来执行这些操作。但是，如果我们更快地放置新操作，线程池将创建更多线程来为这些操作提供服务。有一个限制来防止创建太多的线程，在这种情况下，新操作将在队列中等待，直到线程池中的工作线程空闲为止。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is very important to keep operations on a thread pool short-lived! Do not
    put long-running operations on a thread pool or block worker threads. This will
    lead to all worker threads becoming busy, and they would no longer be able to
    serve user operations. This, in turn, will lead to performance problems and errors
    that are very hard to debug.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是，要保持线程池中的操作生命周期短暂！不要将长时间运行的操作放在线程池中或阻塞工作线程。这将导致所有工作线程都变得忙碌，它们将无法再为用户操作提供服务。这反过来会导致性能问题和非常难以调试的错误。
- en: When we stop putting new operations on a thread pool, it will eventually remove
    threads that are no longer needed after being idle for some time. This will free
    up any operating system resources that are no longer required.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们停止在线程池上放置新操作时，它最终会删除不再需要的线程，这些线程在一段时间后处于空闲状态。这将释放不再需要的任何操作系统资源。
- en: I would like to emphasize once again that a thread pool is intended to execute
    short-running operations. Using a thread pool gives us the possibility to save
    operating system resources at the cost of reducing the degree of parallelism.
    We use fewer threads, but execute asynchronous operations slower than usual, batching
    them by a number of worker threads available. This makes sense if operations are
    fast to complete, but it will degrade the performance for executing many long-running,
    compute-bound operations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我想再次强调，线程池旨在执行短期操作。使用线程池可以节省操作系统资源，但会降低并行度。我们使用较少的线程，但执行异步操作比通常慢，通过可用的工作线程数量进行批处理。如果操作完成速度很快，这是有意义的，但对于执行许多长时间运行的计算密集型操作，性能会下降。
- en: Another important thing to be very careful of is using a thread pool in ASP.NET
    applications. ASP.NET infrastructure uses a thread pool itself, and if you waste
    all worker threads from a thread pool, a web server will no longer be able to
    serve incoming requests. It is recommended to use only input/output bound asynchronous
    operations in ASP.NET, because they use a different mechanics called **I/O threads**.
    We will discuss I/O threads in [Chapter 9](ch09.html "Chapter 9. Using Asynchronous
    I/O"), *Using asynchronous I/O*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要非常小心的重要事情是在ASP.NET应用程序中使用线程池。ASP.NET基础设施本身使用线程池，如果浪费了所有线程池的工作线程，Web服务器将无法再服务传入的请求。建议在ASP.NET中只使用输入/输出绑定的异步操作，因为它们使用一种称为I/O线程的不同机制。我们将在第9章中讨论I/O线程，*使用异步I/O*。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that worker threads of a thread pool are background threads. This
    means that when all of the threads in the foreground (including the main application
    thread) are complete, then all the background threads will be stopped.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，线程池的工作线程是后台线程。这意味着当前台中的所有线程（包括主应用程序线程）完成后，所有后台线程将停止。
- en: In this chapter, we will learn to use a thread pool to execute asynchronous
    operations. We will cover different ways to put an operation on a thread pool,
    and how to cancel an operation and prevent it from running for a long time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用线程池执行异步操作。我们将涵盖将操作放在线程池上的不同方法，以及如何取消操作并防止其长时间运行。
- en: Invoking a delegate on a thread pool
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线程池上调用委托
- en: This recipe will show you how to execute a delegate asynchronously on a thread
    pool. In addition, we will discuss an approach called **Asynchronous Programming
    Model** (**APM**), which was historically the first asynchronous programming pattern
    in .NET.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向你展示如何在线程池上异步执行委托。此外，我们将讨论一种称为**异步编程模型**（**APM**）的方法，这是.NET中历史上第一种异步编程模式。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe1`
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 进入这个配方，你需要Visual Studio 2012。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter3\Recipe1`中找到
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to invoke a delegate on a thread pool, perform the following
    steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在线程池上调用委托，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C# **控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code inside the `Main` method:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中添加以下代码：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program runs, it creates a thread in an old-fashioned way, and then
    starts it and waits for its completion. Since a thread constructor accepts only
    a method that does not return any result, we use a **lambda expression** to wrap
    up a call to the `Test` method. We make sure that this thread is not from the
    thread pool by printing out the `Thread.CurrentThread.IsThreadPoolThread` property
    value. We also print out a managed thread ID to identify a thread on which this
    code was executed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行时，以一种老式的方式创建一个线程，然后启动它并等待其完成。由于线程构造函数只接受一个不返回任何结果的方法，我们使用**lambda表达式**来包装对`Test`方法的调用。我们确保这个线程不是来自线程池，通过打印`Thread.CurrentThread.IsThreadPoolThread`属性值。我们还打印一个托管线程ID来标识执行此代码的线程。
- en: Then we define a delegate and run it by calling the `BeginInvoke` method. This
    method accepts a callback that will be called after the asynchronous operation
    completes, and a user-defined state to pass into the callback. This state is usually
    used to distinguish one asynchronous call from another. As a result, we get a
    `result` object that implements the `IAsyncResult` interface. `BeginInvoke` returns
    the result immediately, allowing us to continue with any work while the asynchronous
    operation is being executed on a worker thread of the thread pool. When we need
    the result of an asynchronous operation, we use the `result` object returned from
    the `BeginInvoke` method call. We can poll on it using a result property `IsCompleted`,
    but in this case, we use the `AsyncWaitHandle` result property to wait on it until
    the operation is complete. After this is done, to get a result from it, we call
    the `EndInvoke` method on a delegate, passing the delegate arguments and our `IAsyncResult`
    object.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义一个委托，并通过调用`BeginInvoke`方法来运行它。这个方法接受一个回调函数，在异步操作完成后将被调用，以及一个用户定义的状态传递到回调函数中。这个状态通常用于区分一个异步调用和另一个。结果，我们得到一个实现`IAsyncResult`接口的`result`对象。`BeginInvoke`立即返回结果，允许我们在异步操作在线程池的工作线程上执行时继续进行任何工作。当我们需要异步操作的结果时，我们使用从`BeginInvoke`方法调用返回的`result`对象。我们可以使用`result`属性`IsCompleted`进行轮询，但在这种情况下，我们使用`AsyncWaitHandle`结果属性来等待，直到操作完成。完成后，要从中获取结果，我们在委托上调用`EndInvoke`方法，传递委托参数和我们的`IAsyncResult`对象。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Actually, using `AsyncWaitHandle` is not necessary. If we comment out `r.AsyncWaitHandle.WaitOne`,
    the code will still run successfully, because the `EndInvoke` method actually
    waits for the asynchronous operation to complete. It is always important to call
    `EndInvoke` (or `EndOperationName` for other asynchronous APIs), because it throws
    any unhandled exceptions back to the calling thread. Always call both the `Begin`
    and `End` methods when using this kind of asynchronous API.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，使用`AsyncWaitHandle`是不必要的。如果我们注释掉`r.AsyncWaitHandle.WaitOne`，代码仍然会成功运行，因为`EndInvoke`方法实际上会等待异步操作完成。始终重要的是调用`EndInvoke`（或对于其他异步API，调用`EndOperationName`），因为它会将任何未处理的异常抛回到调用线程。在使用这种类型的异步API时，始终调用`Begin`和`End`方法。
- en: When the operation completes, a callback passed to the `BeginInvoke` method
    will be posted on a thread pool, more specifically, a worker thread. If we comment
    out the `Thread.Sleep` method call at the end of the `Main` method definition,
    the callback will not be executed. This is because when the main thread completes,
    all the background threads will be stopped, including this callback. It is possible
    that both asynchronous calls to a delegate and a callback will be served by the
    same worker thread, which is easy to see by a worker thread ID.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作完成时，传递给`BeginInvoke`方法的回调将被发布到线程池，更具体地说，是一个工作线程。如果我们在`Main`方法定义的末尾注释掉`Thread.Sleep`方法调用，回调将不会被执行。这是因为当主线程完成时，所有后台线程都将被停止，包括这个回调。可能会有两个异步调用委托和一个回调将由同一个工作线程提供服务，这很容易通过工作线程ID看到。
- en: This approach of using the `BeginOperationName`/`EndOperationName` method and
    the `IAsyncResult` object in .NET is called Asynchronous Programming Model or
    the APM pattern, and such methods' pairs are called Asynchronous Methods. This
    pattern is still being used in various .NET class library APIs, but in modern
    programming, it is preferable to use **Task Parallel Library** (**TPL**) for organizing
    an asynchronous API. We will cover this topic in [Chapter 4](ch04.html "Chapter 4. Using
    Task Parallel Library"), *Using Task Parallel Library*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中使用`BeginOperationName`/`EndOperationName`方法和`IAsyncResult`对象的方法被称为异步编程模型或APM模式，这样的方法对被称为异步方法。这种模式仍然被用于各种.NET类库API中，但在现代编程中，最好使用**任务并行库**（**TPL**）来组织异步API。我们将在[第4章](ch04.html
    "第4章。使用任务并行库")中涵盖这个主题，*使用任务并行库*。
- en: Posting an asynchronous operation on a thread pool
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线程池上发布异步操作
- en: This recipe will describe how to put an asynchronous operation on a thread pool.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将描述如何将异步操作放在线程池中。
- en: Getting ready
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe2`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入这个配方，你需要Visual Studio 2012。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter3\Recipe2`中找到。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to post an asynchronous operation on a thread pool, perform
    the following steps:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解如何将异步操作发布到线程池，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the program.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we define the `AsyncOperation` method that accepts a single parameter
    of the object type. Then, we post this method on a thread pool using the `QueueUserWorkItem`
    method. Then we post this method once again, but this time we pass a `state` object
    to this method call. This object will be passed to the `AsynchronousOperation`
    method as the `state` parameter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了接受一个对象类型参数的`AsyncOperation`方法。然后，我们使用`QueueUserWorkItem`方法将这个方法发布到线程池。然后我们再次发布这个方法，但这次我们将一个`state`对象传递给这个方法调用。这个对象将作为`state`参数传递给`AsynchronousOperation`方法。
- en: Make a thread sleep for 1 second after those operations provide a thread pool
    with the possibility to re-use threads for new operations. If you comment these
    `Thread.Sleep` calls, most certainly, thread IDs will be different in all cases.
    If not, probably the first two threads will be re-used to run the following two
    operations.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些操作之后让一个线程休眠1秒，为线程池提供重用线程的可能性进行新的操作。如果你注释掉这些`Thread.Sleep`调用，几乎可以肯定，所有情况下线程ID都会不同。如果不是，可能前两个线程将被重用来运行接下来的两个操作。
- en: First, we post a lambda expression to a thread pool. Nothing special here; instead
    of defining a separate method, we use the lambda expression syntax.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将一个lambda表达式发布到线程池。这里没有什么特别的；我们使用lambda表达式语法来定义一个单独的方法。
- en: Secondly, instead of passing the state of a lambda expression, we use **closure**
    mechanics. It gives us more flexibility, and allows us to provide more than one
    object to the asynchronous operation and static typing for those objects. So the
    previous mechanism of passing an object into a method callback is really redundant
    and obsolete. There is no need to use it now when we have closures in C#.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们不是传递lambda表达式的状态，而是使用**闭包**机制。这给了我们更多的灵活性，并允许我们为异步操作提供多个对象和这些对象的静态类型。因此，以前将对象传递给方法回调的机制实际上是多余和过时的。现在当我们在C#中有闭包时，就没有必要使用它了。
- en: Thread pool and the degree of parallelism
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池和并行度
- en: This recipe will show how a thread pool works with many asynchronous operations,
    and how it is different from creating many separate threads.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示线程池如何处理许多异步操作，以及它与创建许多单独线程的不同之处。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe3`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入这个配方，你需要Visual Studio 2012。没有其他先决条件。这个配方的源代码可以在`BookSamples\Chapter3\Recipe3`中找到。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To learn how a thread pool works with many asynchronous operations and how
    it is different from creating many separate threads, perform the following steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解线程池如何处理许多异步操作以及它与创建许多单独线程的不同之处，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the program.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the main program starts, we create many different threads and run an operation
    on each one of them. This operation prints out a thread ID and blocks a thread
    for 100 milliseconds. As a result, we create 500 threads, which run all of those
    operations in parallel. The total time on my machine is about 300 milliseconds,
    but we consume many operating system resources for all those threads.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当主程序启动时，我们创建许多不同的线程，并在每个线程上运行一个操作。这个操作打印出一个线程ID，并阻塞一个线程100毫秒。结果，我们创建了500个线程，它们都并行运行这些操作。在我的机器上，总时间约为300毫秒，但我们消耗了许多操作系统资源来运行所有这些线程。
- en: Then, we follow the same procedure, but instead of creating a thread for each
    operation, we post them on a thread pool. After this, the thread pool starts to
    serve these operations; it begins to create more threads near the end, but still,
    it takes much more time, about 12 seconds on my machine. We save memory and threads
    for an operating system usage but pay with an execution time for it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按照相同的程序进行，但是不是为每个操作创建一个线程，而是将它们发布到线程池上。之后，线程池开始为这些操作提供服务；它在最后开始创建更多的线程，但仍然需要更多的时间，大约在我的机器上需要12秒。我们节省了内存和线程供操作系统使用，但为此付出了执行时间。
- en: Implementing a cancellation option
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现取消选项
- en: In this recipe, there is an example on how to cancel an asynchronous operation
    on a thread pool.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，有一个关于如何在线程池上取消异步操作的示例。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe4`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入这个示例，您需要Visual Studio 2012。没有其他先决条件。这个示例的源代码可以在`BookSamples\Chapter3\Recipe4`中找到。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand how to implement a cancellation option on a thread, perform the
    following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何在线程上实现取消选项，执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the program.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Here, we introduce new `CancellationTokenSource` and `CancellationToken` constructs.
    They appeared in .NET 4.0, and now are the de facto standard for implementing
    asynchronous operations' cancellation process. Since a thread pool has been existing
    for long time, it has no special API for cancellation tokens; however, they still
    could be used.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们引入了新的`CancellationTokenSource`和`CancellationToken`构造。它们出现在.NET 4.0中，现在已经成为实现异步操作取消过程的事实标准。由于线程池已经存在很长时间，它没有专门的API用于取消标记；然而，它们仍然可以使用。
- en: In this program, we see three ways to organize a cancellation process. The first
    is just to poll and check the `CancellationToken.IsCancellationRequested` property.
    If it is set to `true`, it means that our operation is being cancelled, and we
    must abandon the operation.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们看到了三种组织取消过程的方法。第一种方法是轮询和检查`CancellationToken.IsCancellationRequested`属性。如果它被设置为`true`，这意味着我们的操作正在被取消，我们必须放弃这个操作。
- en: The second way is to throw an `OperationCancelledException` exception. This
    allows for controlling the cancellation process not from inside the operation,
    which is being cancelled, but from the code on the outside.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是抛出`OperationCancelledException`异常。这允许从被取消的操作内部控制取消过程，而不是从外部代码控制。
- en: The last option is to register a **callback** that will be called on a thread
    pool when an operation is cancelled. This will allow chaining a cancellation logic
    into another asynchronous operation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的选择是在线程池上注册一个**回调**，当操作被取消时将在线程池上调用。这将允许将取消逻辑链接到另一个异步操作中。
- en: Using a wait handle and timeout with a thread pool
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用等待句柄和线程池的超时
- en: This recipe will describe how to implement a timeout for thread pool operations,
    and how to wait properly on a thread pool.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将描述如何为线程池操作实现超时，以及如何在线程池上正确等待。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe5`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入这个示例，您需要Visual Studio 2012。没有其他先决条件。这个示例的源代码可以在`BookSamples\Chapter3\Recipe5`中找到。
- en: How to do it...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To learn how to implement a timeout and how to wait properly on a thread pool,
    perform the following steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何实现超时以及如何在线程池上正确等待，执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内添加以下代码片段：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the program.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A thread pool has another useful method: `ThreadPool.RegisterWaitForSingleObject`.
    This method allows us to queue a callback on a thread pool, and this callback
    will be executed when the provided wait handle is signaled or a timeout has occurred.
    This allows us to implement a timeout for thread pool operations.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 线程池还有另一个有用的方法：`ThreadPool.RegisterWaitForSingleObject`。这个方法允许我们在线程池上排队一个回调，当提供的等待句柄被信号或超时发生时，这个回调将被执行。这允许我们为线程池操作实现超时。
- en: First, we queue a long-running operation on a thread pool. It runs for 6 seconds
    and then sets a `ManualResetEvent` signaling construct, in case it completes successfully.
    In other case, if cancellation is requested, the operation is just abandoned.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在线程池上排队一个长时间运行的操作。它运行了6秒，然后设置了一个`ManualResetEvent`信号构造，以防它成功完成。在其他情况下，如果请求取消，操作就会被放弃。
- en: Then, we register the second asynchronous operation that will be called when
    it receives a signal from the `ManualResetEvent` object, which is set by the first
    operation if it is completed successfully. Another option is when a timeout has
    occurred before the first operation is completed. If this happens, we use `CancellationToken`
    to cancel the first operation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们注册第二个异步操作，当它从`ManualResetEvent`对象接收到信号时将被调用，该对象由第一个操作设置，如果第一个操作成功完成。另一个选项是在第一个操作完成之前发生超时。如果发生这种情况，我们使用`CancellationToken`来取消第一个操作。
- en: Finally, if we provide a 5-second timeout for the operation, it would not be
    enough. This is because the operation takes 6 seconds to complete, and we'd need
    to cancel this operation. So if we provide a 7-second timeout, which is acceptable,
    the operation completes successfully.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们为操作提供了5秒的超时，这是不够的。这是因为操作需要6秒才能完成，我们需要取消这个操作。所以如果我们提供了一个7秒的超时，这是可以接受的，操作将成功完成。
- en: There's more…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This is very useful when you have a large number of threads that must wait in
    the blocked state for some multithreaded event construct to signal. Instead of
    blocking all those threads, we are able to use the thread pool infrastructure.
    It will allow to free up these threads until the event is set. This is a very
    important scenario for server applications, which require scalability and performance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有大量的线程必须在阻塞状态下等待某个多线程事件构造发出信号时，这是非常有用的。我们可以使用线程池基础设施，而不是阻塞所有这些线程。它将允许释放这些线程，直到事件被设置。这对于需要可伸缩性和性能的服务器应用程序来说是一个非常重要的场景。
- en: Using a timer
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用定时器
- en: This recipe will describe how to use a `System.Threading.Timer` object to create
    periodically-called asynchronous operations on a thread pool.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将描述如何使用`System.Threading.Timer`对象在线程池上创建周期调用的异步操作。
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe6`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入这个食谱，您将需要Visual Studio 2012。没有其他先决条件。这个食谱的源代码可以在`BookSamples\Chapter3\Recipe6`中找到。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To learn how to create periodically-called asynchronous operations on a thread
    pool, perform the following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何在线程池上创建周期调用的异步操作，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中添加以下代码片段：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the program.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we create a new `Timer` instance. The first parameter is a lambda expression
    that will be executed on a thread pool. We call the `TimerOperation` method providing
    it with a start date. We do not use the user `state` object, so the second parameter
    is null; then, we specify when are we going to run `TimerOperation` for the first
    time, and what will be the period between calls. So the first value actually means
    that we start the first operation in a second, and then we run each of them for
    2 seconds.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个新的`Timer`实例。第一个参数是一个将在线程池上执行的lambda表达式。我们调用`TimerOperation`方法，提供一个开始日期。我们不使用用户`state`对象，所以第二个参数是null；然后，我们指定何时第一次运行`TimerOperation`，以及调用之间的时间间隔。因此，第一个值实际上意味着我们在一秒钟内开始第一个操作，然后每个操作运行2秒。
- en: After this, we wait for 6 seconds and change our timer. We start `TimerOperation`
    in a second after calling the `_timer.Change` method, and then run each of them
    for 4 seconds.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们等待6秒并改变我们的定时器。我们在调用`_timer.Change`方法后的一秒钟开始`TimerOperation`，然后每个运行4秒。
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Timer could be more complex than this!**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**定时器可能比这更复杂！**'
- en: It is possible to use a timer in a more complicated way. For instance, we can
    run the timer operation only once, providing a timer period parameter with the
    `Timeout.Infinte` value. Then, inside the timer asynchronous operation, we are
    able to set the next time when the timer operation will be executed, depending
    on some custom logic.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以更复杂的方式使用定时器。例如，我们可以仅运行定时器操作一次，提供一个`Timeout.Infinte`值的定时器周期参数。然后，在定时器异步操作中，我们能够根据一些自定义逻辑设置下一次定时器操作将被执行的时间。
- en: Lastly, we wait for the *Enter* key to be pressed and finish the application.
    While it is running, we can see the time passed since the program started.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们等待*Enter*键被按下并完成应用程序。当它运行时，我们可以看到自程序启动以来经过的时间。
- en: Using the BackgroundWorker component
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BackgroundWorker组件
- en: This recipe describes another approach to asynchronous programming by example
    of a `BackgroundWorker` component. With the help of this object, we are able to
    organize our asynchronous code as a set of events and event handlers. You will
    learn how to use this component for asynchronous programming.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱描述了另一种异步编程的方法，以`BackgroundWorker`组件为例。借助这个对象，我们能够将异步代码组织成一组事件和事件处理程序。您将学习如何使用这个组件进行异步编程。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step into this recipe, you will need Visual Studio 2012\. There are no other
    prerequisites. The source code for this recipe could be found in `BookSamples\Chapter3\Recipe7`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入这个食谱，您将需要Visual Studio 2012。没有其他先决条件。这个食谱的源代码可以在`BookSamples\Chapter3\Recipe7`中找到。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To learn how to use the `BackgroundWorker` component, perform the following
    steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何使用`BackgroundWorker`组件，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下方添加以下代码片段：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中添加以下代码片段：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the program.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program starts, we create an instance of a `BackgroundWorker` component.
    We explicitly state that we want our background-worker-supported operations' cancellation
    and notifications on the operation's progress.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 程序启动时，我们创建了一个`BackgroundWorker`组件的实例。我们明确表示我们希望我们支持后台工作的操作取消和操作进度的通知。
- en: Now, this is where the most interesting part comes into play. Instead of manipulating
    with a thread pool and delegates, we use another C# idiom called **events**. An
    event represents one *source* of some notification and a number of *subscribers*
    ready to react when a notification arrives. In our case, we state that we would
    subscribe for three events, and when they occur, we would call the corresponding
    **event handlers**. These are methods with a specially defined signature that
    will be called when an event notifies its subscribers.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最有趣的部分出现了。与其使用线程池和委托进行操作，我们使用另一个C#习语，称为**事件**。事件代表某种通知的一个*源*，以及一些准备好在通知到达时做出反应的*订阅者*。在我们的情况下，我们声明我们将订阅三个事件，当它们发生时，我们将调用相应的**事件处理程序**。这些是具有特别定义签名的方法，当事件通知其订阅者时将被调用。
- en: Therefore, instead of organizing an asynchronous API in a pair of `Begin`/`End`
    methods, it is possible to just start an asynchronous operation and then subscribe
    to different events that could happen while this operation is being executed.
    This approach is called **Event-based Asynchronous Pattern** (**EAP)**. It was
    historically the second attempt to structure asynchronous programs, and now it
    is recommended to use TPL, which will be described in [Chapter 4](ch04.html "Chapter 4. Using
    Task Parallel Library"), *Using Task Parallel Library*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，与其在一对“Begin”/“End”方法中组织异步API，不如只是启动异步操作，然后订阅在执行此操作时可能发生的不同事件。这种方法被称为**基于事件的异步模式**（**EAP**）。这在历史上是对异步程序进行结构化的第二次尝试，现在建议使用TPL，这将在[第4章](ch04.html
    "第4章。使用任务并行库")中描述，*使用任务并行库*。
- en: So, we have subscribed to three events. The first of them is the `DoWork` event.
    A handler of this event will be called when a background worker object starts
    an asynchronous operation with the `RunWorkerAsync` method. The event handler
    will be executed on a thread pool, and this is the main operating point where
    work is canceled if cancellation is requested, and where we provide information
    on the progress of the operation. At last, when we get the result, we set it to
    event arguments, and then the `RunWorkerCompleted` event handler is called. Inside
    this method, we find out whether our operation is succeeded, or maybe there were
    some errors, or it was canceled.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经订阅了三个事件。其中之一是`DoWork`事件。当后台工作程序对象使用`RunWorkerAsync`方法开始异步操作时，将调用此事件的处理程序。事件处理程序将在线程池上执行，这是主要的操作点，在这里，如果请求取消，则工作将被取消，并且我们提供操作的进度信息。最后，当我们获得结果时，我们将其设置为事件参数，然后调用`RunWorkerCompleted`事件处理程序。在此方法内部，我们会找出我们的操作是否成功，或者可能出现了一些错误，或者它被取消了。
- en: Besides that, a `BackgroundWorker` component is actually intended to be used
    in **Windows Forms Applications** (**WPF**). Its implementation makes working
    with UI controls possible from a background worker event handler's code directly,
    which is very comfortable as compared to the interaction of worker threads of
    a thread pool with UI controls.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`BackgroundWorker`组件实际上是用于**Windows窗体应用程序**（**WPF**）。它的实现使得可以直接从后台工作程序事件处理程序的代码中使用UI控件，这与线程池的工作线程与UI控件的交互相比非常方便。
