- en: Chapter 6. Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。函数式编程
- en: Functional programming is a different approach to development than the heavily
    object oriented approach that we have focused on so far. Object oriented programming
    is a fantastic tool for solving a great number of problems but it has some issues.
    Parallel programming within an object oriented context is difficult as the state
    can be changed by various different threads with unknown side effects. Functional
    programming does not permit state or mutable variables. Functions act as primary
    building blocks in functional programming. Places where you might have used a
    variable in the past will now use a function.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种与我们迄今为止专注的面向对象编程方法不同的开发方法。面向对象编程是解决许多问题的绝佳工具，但也存在一些问题。在面向对象的上下文中进行并行编程是困难的，因为状态可能会被各种不同的线程改变，产生未知的副作用。函数式编程不允许状态或可变变量。函数在函数式编程中充当主要的构建块。在过去可能使用变量的地方现在将使用函数。
- en: Even in a single threaded program, functions can have side-effects that change
    global state. This means that, when calling an unknown function, it can alter
    the whole flow of the program. This makes debugging a program quite difficult.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在单线程程序中，函数也可能具有改变全局状态的副作用。这意味着，当调用一个未知的函数时，它可能会改变程序的整个流程。这使得调试程序变得非常困难。
- en: 'JavaScript is not a functional programming language but we can still apply
    some functional principles to our code. We''ll look at a number of patterns in
    the functional space:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript并不是一种函数式编程语言，但我们仍然可以将一些函数式原则应用到我们的代码中。我们将在函数式空间中看到许多模式：
- en: Function passing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数传递
- en: Filters and pipes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤器和管道
- en: Accumulators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累加器
- en: Memoization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记忆化
- en: Immutability
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: Lazy instantiation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟实例化
- en: Functional functions are side-effect-free
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式函数是无副作用的
- en: A core tenant of functional programming is that functions should not change
    state. Values local to the function may be set but nothing outside the function
    may change. This approach is very useful for making code more maintainable. There
    need no longer be any concern that passing an array into a function is going to
    play havoc with its contents. This is especially a concern when using libraries
    that are not under your control.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的一个核心原则是函数不应该改变状态。函数内部的值可以被设置，但是函数外部的任何东西都不应该改变。这种方法对于使代码更易维护非常有用。不再需要担心将数组传递到函数中会对其内容造成严重影响。特别是在使用不受控制的库时，这是一个值得关注的问题。
- en: There is no mechanism within JavaScript to prevent you from changing global
    state. Instead you must rely on developers to write side-effect-free functions.
    This may be difficult or not, depending on the maturity of the team.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript内部没有机制可以阻止你改变全局状态。相反，你必须依赖开发人员编写无副作用的函数。这可能很困难，也可能不是，这取决于团队的成熟度。
- en: It may not be desirable to put all the code from your application into functions,
    but separating as much as possible is desirable. There is a pattern called command
    query separation that suggests that methods should fall into two categories. Either
    they are a function that reads a value or they are a command that sets a value.
    Never the twain should meet. Keeping methods categorized like this eases in debugging
    and in code reuse.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 也许不希望将应用程序中的所有代码都放入函数中，但尽可能地分离是可取的。有一种称为命令查询分离的模式建议方法应该分为两类。要么是一个读取值的函数，要么是一个设置值的命令。二者不应混合。像这样对方法进行分类可以方便调试和代码重用。
- en: One of the consequences of side effect-free functions is that they can be called
    any number of times with the same inputs and the result will be the same. Furthermore,
    because there are no changes to state, calling the function many times will not
    cause any ill side effects, other than making it run slower.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 无副作用的函数的一个后果是，它们可以用相同的输入任意次数调用，结果都将是相同的。此外，由于没有状态的改变，多次调用函数不会产生任何不良的副作用，除了使其运行速度变慢。
- en: Function passing
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数传递
- en: In functional programming languages, functions are first class citizens. Functions
    can be assigned to variables and passed around just like you would with any other
    variable. This is not entirely a foreign concept. Even languages such as C had
    function pointers that could be treated just like other variables. C# has delegates
    and, in more recent versions, lambdas. The latest release of Java has also added
    support for lambdas as they have proven to be so useful.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程语言中，函数是一等公民。函数可以被赋值给变量，并像其他变量一样传递。这并不是完全陌生的概念。即使像C这样的语言也有可以像其他变量一样对待的函数指针。C#有委托，在更近期的版本中有lambda。最新版本的Java也添加了对lambda的支持，因为它们被证明非常有用。
- en: JavaScript allows for functions to be treated as variables and even as objects
    and strings. In this way JavaScript is functional in nature.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript允许将函数视为变量，甚至作为对象和字符串。这样JavaScript在本质上是函数式的。
- en: 'Because of JavaScript''s single threaded nature, callbacks are a common convention
    and you can find them pretty much everywhere. Consider calling a function at a
    later date on a web page. This is done by setting a timeout on the window object
    like so:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript是单线程的，回调是一种常见的约定，你几乎可以在任何地方找到它们。考虑在网页上延迟调用一个函数。这是通过在window对象上设置一个超时来完成的，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The arguments for the set timeout function are a function to call and a time
    to delay in milliseconds.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 设置超时函数的参数是要调用的函数和以毫秒为单位的延迟时间。
- en: 'Irrespective of the JavaScript environment in which you''re working, it is
    almost impossible to avoid functions in the shape of callbacks. Node.js'' asynchronous
    processing model is highly dependent on being able to call a function and pass
    in something to be completed at a later date. Making calls to external resources
    in a browser is also dependent on a callback to notify the caller that some asynchronous
    operation has completed. In basic JavaScript this looks like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您在哪种JavaScript环境中工作，几乎不可能避免以回调函数的形式使用函数。Node.js的异步处理模型高度依赖于能够调用函数并传递一些东西以在以后的某个日期完成。在浏览器中调用外部资源也依赖于回调来通知调用者某些异步操作已经完成。在基本的JavaScript中，这看起来可能像以下的样子：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You may notice that we assign the `onreadystatechange` function before we even
    send the request. This is because assigning it later may result in a race condition
    in which the server responds before the function is attached to the ready state
    change. In this case, we''ve used an inline function to process the returned data.
    Because functions are first class citizens we can change this to look like the
    following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到我们在发送请求之前就分配了`onreadystatechange`函数。这是因为稍后分配可能会导致服务器在函数附加到准备状态更改之前做出响应。在这种情况下，我们使用内联函数来处理返回的数据。因为函数是一等公民，我们可以将其更改为以下的样子：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is typically a cleaner approach and avoids performing complex processing
    in line with another function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是一种更清晰的方法，避免在另一个函数中执行复杂的处理。
- en: 'However, you might be more familiar with the jQuery version of this, which
    looks something like the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能更熟悉jQuery版本的，看起来可能是以下的样子：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case the boiler plate of dealing with ready state changes is handled
    for you. There is even convenience provided for you if the request for data fails:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，处理准备状态变化的样板已经为您处理。如果数据请求失败，甚至为您提供了方便：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, we've passed an object into the `ajax` call which defines a number
    of properties. Amongst these properties are function callbacks for success and
    failure. This method of passing numerous functions into another suggests a great
    way of providing expansion points for classes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将一个对象传递给了`ajax`调用，该对象定义了许多属性。其中包括成功和失败的函数回调。将多个函数传递给另一个函数的方法表明了为类提供扩展点的一种很好的方式。
- en: Likely you've seen this pattern in use before without even realizing it. Passing
    functions into constructors as part of an options object is a commonly used approach
    to providing extension hooks in JavaScript libraries. We saw some treatment of
    functions in the previous chapter, [Chapter 5](part0111_split_000.html#39REE1-015e68c68a464f18a9559f448be84435
    "Chapter 5. Behavioral Patterns"), *Behavioral Patterns*, when passing function
    into the observer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能之前已经看到过这种模式的使用，甚至没有意识到。将函数作为选项对象的一部分传递给构造函数是JavaScript库中常用的提供扩展钩子的方法。在上一章[第5章](part0111_split_000.html#39REE1-015e68c68a464f18a9559f448be84435
    "第5章。行为模式")中，我们看到了一些关于函数的处理，当将函数传递给观察者时。
- en: Implementation
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: In Westeros the tourism industry is almost non-extant. There are great difficulties
    with bandits killing tourists and tourists becoming entangled in regional conflicts.
    Nonetheless, some enterprising folks have started to advertise a grant tour of
    Westeros in which they will take those with the means on a tour of all the major
    attractions. From King's Landing to Eyrie, to the great mountains of Dorne - the
    tour will cover it all. In fact, a rather mathematically inclined member of the
    tourism board has taken to calling it a Hamiltonian tour as it visits everywhere
    once.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛旅游业几乎不存在。有很大的困难，因为强盗杀害游客，游客卷入地区冲突。尽管如此，一些有远见的人已经开始宣传维斯特洛斯的旅行，他们将带领有能力的人游览所有主要景点。从国王之地到鹰巢，再到多恩的大山脉-旅行将覆盖所有地方。事实上，旅游局的一个数学倾向成员已经开始称之为哈密尔顿之旅，因为它一次性参观所有地方。
- en: 'The `HamiltonianTour` class provides an options object which allows the definition
    of an options object. This object contains the various places to which a callback
    can be attached. In our case the interface for it would look something like the
    following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`HamiltonianTour`类提供了一个选项对象，允许定义一个选项对象。该对象包含可以附加回调的各种地方。在我们的情况下，它的接口看起来可能是以下的样子：'
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The full `HamiltonianTour` class looks like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`HamiltonianTour`类如下所示：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can see in the highlighted code how we check the options and then execute
    the callback as needed. This can be used by simply doing the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在突出显示的代码中看到我们如何检查选项，然后根据需要执行回调。这可以通过以下简单地使用：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output from running this code would be the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码的输出将是以下的样子：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Passing functions is a great approach to solving a number of problems in JavaScript
    and tends to be used extensively by libraries such as jQuery and frameworks such
    as express. It is so commonly adopted that using it provides added barriers to
    your code's readability.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数传递是解决JavaScript中许多问题的一个很好的方法，并且通常被jQuery等库和express等框架广泛使用。它是如此普遍地被采用，以至于使用它会给您的代码的可读性增加障碍。
- en: Filters and pipes
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤器和管道
- en: 'If you''re at all familiar with the Unix command line or, to a lesser extent,
    the Windows command line, then you''ll have probably made use of pipes. A pipe,
    which is represented by the `|` character is shorthand for "take the output of
    program A and put it into program B". This relatively simple idea makes the Unix
    command line incredibly powerful. For instance, if you wanted to list all the
    files in a directory and then sort them and filter for any which start with either
    the letters `b` or `g` and end with an `f` then the command might look like the
    following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Unix命令行或者在较小程度上对Windows命令行有所了解，那么您可能已经使用过管道。管道，由`|`字符表示，是“获取程序A的输出并将其放入程序B”的简写。这个相对简单的想法使得Unix命令行非常强大。例如，如果您想要列出目录中的所有文件，然后对它们进行排序并过滤出以字母`b`或`g`开头并以`f`结尾的文件，那么命令可能看起来像以下的样子：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `ls` command lists all files and directories, the `sort` command sorts
    them, and the `grep` command matches file names against a regular expression.
    Running this command in the `etc` directory on an Ubuntu box in `/etc` would give
    a result which looks something like the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls`命令列出所有文件和目录，`sort`命令对它们进行排序，`grep`命令匹配文件名与正则表达式。在Ubuntu框中的`etc`目录中运行此命令，结果看起来像下面这样：'
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Some functional programming languages such as F# offer a special syntax for
    piping between functions. In F#, filtering a list for even numbers can be done
    in the following way:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一些函数式编程语言，如F#，提供了一种特殊的语法，用于在函数之间进行管道传递。在F#中，可以通过以下方式对列表进行偶数过滤：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This syntax is very nice-looking, especially when used for long chains of functions.
    As an example, taking a number, casting it to a float, square rooting it, and
    then rounding it would look like the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法看起来非常漂亮，特别是在长链式函数中使用时。例如，取一个数字，将其转换为浮点数，对其进行平方根运算，然后四舍五入，看起来会像下面这样：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is a clearer syntax than the C-style syntax that would look more like
    the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是比C风格语法更清晰的语法，看起来更像下面这样：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Unfortunately, there is no ability to write pipes in JavaScript using a nifty
    F# style syntax, but we can still improve upon the normal method shown in the
    preceding code by using method chaining.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，JavaScript中没有使用巧妙的F#风格语法编写管道的能力，但是我们仍然可以通过方法链接来改进前面代码中显示的普通方法。
- en: Everything in JavaScript is an object, which means that we can have some real
    fun adding functionality to existing objects to improve their look. Operating
    on collections of objects is a space in which functional programming provides
    some powerful features. Let's start by adding a simple filtering method to the
    array object. You can think of these queries as being like SQL database queries
    written in a functional fashion.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的一切都是对象，这意味着我们可以通过添加功能来改进现有对象的外观。对对象集合进行操作是函数式编程提供一些强大功能的领域。让我们首先向数组对象添加一个简单的过滤方法。您可以将这些查询视为以函数方式编写的SQL数据库查询。
- en: Implementation
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'We would like to provide a function that performs a match against each member
    of the array and returns a set of results:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望提供一个函数，对数组的每个成员执行匹配，并返回一组结果：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The rather simple looking function allows us to quickly filter an array:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看起来相当简单的函数允许我们快速过滤一个数组：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What we return is also an object, an array object in this case. We can continue
    to chain methods onto it like the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回的也是一个对象，这种情况下是一个数组对象。我们可以继续像下面这样链接方法：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The result of this is an array containing only the number 6, as it is the only
    number between 1 and 10 which is both even and divisible by three. This method
    of returning a modified version of the original object without changing the original
    is known as a fluent interface. By not changing the original item array, we've
    introduced a small degree of immutability into our variables.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个只包含数字6的数组，因为它是1到10之间唯一既是偶数又能被三整除的数字。这种返回原始对象的修改版本而不改变原始对象的方法称为流畅接口。通过不改变原始的项目数组，我们在变量中引入了一定程度的不可变性。
- en: 'If we add another function to our library of array extensions, we can start
    to see how useful these pipes can be:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向数组扩展库添加另一个函数，我们就可以开始看到这些管道有多么有用：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This extension allows for projections of the original items based on an arbitrary
    projection function. Given a set of objects which contain IDs and names, we can
    use our fluent extensions to array to perform complex operations:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展允许根据任意投影函数对原始项目进行投影。给定一组包含ID和名称的对象，我们可以使用我们的流畅扩展到数组来执行复杂的操作：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code will build a new array which contains only children with even IDs
    and instead of full objects, the array will contain only their names: `Sansa`
    and `Brandon`. For those familiar with .Net these functions may look very familiar.
    The **Language Integrated Queries** (**LINQ**) library on .Net provides similarly
    named functional inspired functions for the manipulation of collections.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将构建一个新的数组，其中只包含偶数ID的孩子，而不是完整的对象，数组中只包含他们的名字：“Sansa”和“Brandon”。对于熟悉.Net的人来说，这些函数可能看起来非常熟悉。.Net上的**语言集成查询**（**LINQ**）库提供了类似命名的函数，用于操作集合。
- en: 'Chaining functions in this manner can be both easier to understand and easier
    to build than alternatives: temporary variables are avoided and the code made
    terser. Consider the preceding example re-implemented using loops and temporary
    variables:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式链接函数既易于理解又易于构建，比起使用临时变量，代码更加简洁。考虑使用循环和临时变量重新实现前面的示例：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A number of JavaScript libraries such as d3 are constructed to encourage this
    sort of programming. At first it seems like the code created following this convention
    is bad due to very long line length. I would argue that this is a function of
    line length not being a very good tool to measure complexity rather than an actual
    problem with the approach.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 许多JavaScript库，如d3，都是为了鼓励这种编程方式而构建的。起初，似乎按照这种约定创建的代码由于行长很长而不好。我认为这是行长不是衡量复杂性的很好的工具，而不是这种方法的实际问题。
- en: Accumulators
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 累加器
- en: We've looked at some simple array functions which add filtering and pipes to
    arrays. Another useful tool is the accumulator. Accumulators aid in building up
    a single result by iterating over a collection. Many common operations such as
    summing up the elements of an array can be implemented using an accumulator instead
    of a loop.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过一些简单的数组函数，它们为数组添加了过滤和管道。另一个有用的工具是累加器。累加器通过对集合进行迭代来构建单个结果。许多常见操作，如对数组元素求和，可以使用累加器来实现，而不是使用循环。
- en: Recursion is popular within functional programming languages and many of them
    actually offer an optimization called "tail call optimization". A language that
    supports this provides optimizations for functions using recursion in which the
    stack frame is reused. This is very efficient and can easily replace most loops.
    Details on whether tail call optimization is supported in any JavaScript interpreter
    are sketchy. For the most part it doesn't seem like it is but we can still make
    use of recursion.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 递归在函数式编程语言中很受欢迎，其中许多语言实际上提供了一种优化称为“尾调用优化”。支持这一点的语言为使用递归的函数提供了优化，其中堆栈帧被重用。这非常高效，可以轻松替代大多数循环。关于任何JavaScript解释器是否支持尾调用优化的细节还不清楚。在大多数情况下似乎并不支持，但我们仍然可以利用递归。
- en: 'The problem with `for` loops is that the control flow through the loop is mutable.
    Consider this rather easy-to-make mistake:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的问题在于循环的控制流是可变的。考虑这个相当容易犯的错误：'
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Did you spot the error? It took me several attempts to get a working version
    of this code I could break. The problem is in the loop counter in the second loop,
    it should read as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你发现错误了吗？我尝试了几次才得到一个可破解的工作版本。问题在第二个循环的循环计数器中，它应该如下所示：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Obviously this could be somewhat mitigated through better variable naming but
    we would like to avoid the problem altogether.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，通过更好的变量命名可以在一定程度上缓解这个问题，但我们希望完全避免这个问题。
- en: Instead we can make use of an accumulator, a tool for combining multiple values
    from a collection into a single value. We've rather missed Westeros for a couple
    of patterns so let's get back to our mythical example land. Wars cost a great
    deal of money but fortunately there are a great number of peasants to pay taxes
    and finance the lords in their games for the throne.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以利用累加器，这是一个将集合中的多个值组合成单个值的工具。我们错过了维斯特洛大陆的一些模式，所以让我们回到我们的神话般的例子。战争花费了大量的金钱，但幸运的是有大量的农民来交税，为领主们的王位之争提供资金。
- en: Implementation
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'Our peasants are represented by a simple model which looks like the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的农民由一个简单的模型表示，看起来像这样：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Over this set of peasants we have an accumulator which looks like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这组农民中，我们有一个累加器，看起来像这样：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code takes a list of items, an accumulator value, and a function that projects
    the value to be integrated into the accumulation.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码接受一个项目列表，一个累加器值，以及一个将值投影到累加中的函数。
- en: 'The projection function looks something like the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 投影函数看起来像下面这样：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In order to prime this function, we simply need to pass in an initial value
    for the accumulator along with the array and projection. The priming value will
    vary but more often than not it will be an identity; an empty string in the case
    of a string accumulator and a 0 or 1 in the case of mathematical ones.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动这个函数，我们只需要传入一个累加器的初始值，以及数组和投影。启动值会有所不同，但往往是一个身份；在字符串累加器的情况下是一个空字符串，在数学累加器的情况下是0或1。
- en: Each pass through the accumulator shrinks the size of the array over which we
    are operating. All this is done without a single mutable variable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每次通过累加器时，我们都会缩小我们操作的数组的大小。所有这些都是在没有一个可变变量的情况下完成的。
- en: 'The inner accumulation can really be any function you like: string appending,
    addition, or something more complicated. The accumulator is somewhat like the
    visitor pattern except that modifying values in the collection inside an accumulator
    is frowned upon. Remember that functional programming is side-effect-free.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 内部累积实际上可以是任何你喜欢的函数：字符串追加，加法，或者更复杂的东西。累加器有点像访问者模式，只是在累加器内部修改集合中的值是不被赞同的。请记住，函数式编程是无副作用的。
- en: Memoization
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备忘录
- en: Not to be confused with memorization, memoization is a specific term for retaining
    a number of previously calculated values from a function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不要与记忆混淆，备忘录是一个特定术语，用于保留从函数中计算出的先前计算过的值。
- en: As we saw earlier, side-effect-free functions can be called multiple times without
    causing problems. The corollary to this is that a function can also be called
    fewer times than needed. Consider an expensive function which does some complex
    or, at least, time-consuming math. We know that the result of the function is
    entirely predicated on the inputs to the function. So the same inputs will always
    produce the same outputs. Why, then, would we need to call the function multiple
    times? If we saved the output of the function, we could retrieve that instead
    of redoing the time-consuming math.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，无副作用的函数可以被多次调用而不会引起问题。与此相关的是，函数也可以被调用的次数少于需要的次数。考虑一个昂贵的函数，它进行一些复杂或至少耗时的数学运算。我们知道函数的结果完全取决于函数的输入。因此，相同的输入将始终产生相同的输出。那么，为什么我们需要多次调用函数呢？如果我们保存函数的输出，我们可以检索到它，而不是重新进行耗时的数学运算。
- en: Trading off space for time is a classic computing science problem. By caching
    the result, we make the application faster but we will consume more memory. Deciding
    when to perform caching and when to simply recalculate the result is a difficult
    problem.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以空间换时间是一个经典的计算科学问题。通过缓存结果，我们可以使应用程序更快，但会消耗更多内存。决定何时进行缓存，何时简单地重新计算结果是一个困难的问题。
- en: Implementation
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: In the land of Westeros, learned men, known as Maesters, have long had a fascination
    with a sequence of numbers which seems to reappear a great deal in the natural
    world. In a strange coincidence they call this sequence the Fibonacci sequence.
    It is defined by adding the two previous terms in the sequence to get the next
    one. The sequence is bootstrapped by defining the first few terms as 0, 1, 1\.
    So to get the next term we would simply add 1 and 1 to get 2\. The next term would
    add 2 and 1 to get 3 and so forth. Finding an arbitrary member of the sequence
    requires finding the two previous members, so it can end up being a bit of calculation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛大陆上，被称为大师的学者们长期以来对一个在自然界中似乎经常出现的数字序列产生了浓厚的兴趣。出奇的巧合是，他们称这个序列为斐波那契数列。它的定义是将序列中的前两个项相加以得到下一个项。这个序列的起始是定义为0,
    1, 1。所以要得到下一个项，我们只需将1和1相加得到2。下一个项将2和1相加得到3，依此类推。找到序列的任意成员需要找到前两个成员，所以可能需要进行一些计算。
- en: In our world we have discovered a closed form that avoids much of this calculation
    but in Westeros no such discovery has been made.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的世界中，我们已经发现了一个避免大部分计算的封闭形式，但在维斯特洛还没有做出这样的发现。
- en: 'A naïve approach is to simply calculate every term like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个朴素的方法是简单地计算每个项，如下所示：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This solution works very quickly for small numbers such as 10\. However, for
    larger numbers, say greater than 40, there is a substantial slow-down. This is
    because the base case is called 102,334,155 times.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案对于10这样的小数字非常快。然而，对于更大的数字，比如大于40，会有显著的减速。这是因为基本情况被调用了102,334,155次。
- en: 'Let''s see if we can improve things by memoizing some values:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看是否可以通过记忆化一些值来改进事情：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We have just memoized every item we encounter. As it turns out for this algorithm
    we store *n+1* items, which is a pretty good trade-off. Without memoization, calculating
    the 40th fibonacci number took 963ms while the memoization version took only 11ms.
    The difference is far more pronounced when the functions become more complex to
    calculate. Fibonacci of 140 took 12 ms for the memoization version while the naïve
    version took… well, it is has been a day and it is still running.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚对我们遇到的每个项目进行了记忆化。事实证明，对于这个算法，我们存储了*n+1*个项目，这是一个相当不错的折衷。没有记忆化，计算第40个斐波那契数需要963毫秒，而记忆化版本只需要11毫秒。当函数变得更复杂时，差异会更加明显。记忆化版本的斐波那契数140只需要12毫秒，而朴素版本……嗯，已经过了一天，它还在运行。
- en: The best part of this memoization is that subsequent calls to the function with
    the same parameter will be lightning-fast as the result is already computed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这种记忆化的最好之处在于对具有相同参数的函数的后续调用将会非常快，因为结果已经计算过了。
- en: In our example only a very small cache was needed. In more complex examples
    it is difficult to know how large a cache should be or how frequently a value
    will need to be recomputed. Ideally your cache will be large enough that there
    will always be room to put more results in. However, this may not be realistic
    and tough decisions will need to be made about which members of the cache should
    be removed to save space. There is a plethora of methods for performing cache
    invalidation. It has been said that cache invalidation is one of the toughest
    problems in computing science, the reason being that we're effectively trying
    to predict the future. If anybody has perfected a method of telling the future,
    it is likely they are applying their skills in a more important domain than cache
    invalidation. Two options are to prey on the least recently used member of the
    cache or the least frequently used member. It is possible that the shape of the
    problem may dictate a better strategy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，只需要一个非常小的缓存。在更复杂的例子中，很难知道缓存应该有多大，或者一个值需要重新计算的频率是多少。理想情况下，你的缓存应该足够大，总是有空间放更多的结果。然而，这可能并不现实，需要做出艰难的决定，哪些缓存成员应该被移除以节省空间。有很多方法可以进行缓存失效。有人说缓存失效是计算科学中最棘手的问题之一，原因是我们实际上在试图预测未来。如果有人完善了一种预测未来的方法，很可能他们正在将自己的技能应用于比缓存失效更重要的领域。两个选择是依赖于缓存中最近最少使用的成员，或者最不经常使用的成员。问题的形状可能决定了更好的策略。
- en: Memoization is a fantastic tool for speeding up calculations which need to be
    performed multiple times or even calculations which have common sub-calculations.
    One can consider memoization as just a special case of caching, which is a commonly
    used technique when building web servers or browsers. It is certainly worthwhile
    exploring in more complex JavaScript applications.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是加速需要多次执行的计算或者具有常见子计算的计算的一种奇妙工具。人们可以将记忆化视为缓存的一种特殊情况，这是在构建网络服务器或浏览器时常用的技术。在更复杂的JavaScript应用程序中，值得进一步探索。
- en: Immutability
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不变性
- en: 'One of the cornerstones of functional programming is that so called variables
    can be assigned only once. This is known as immutability. ECMAScript 2015 supports
    a new keyword, `const`. The `const` keyword can be used in the same way as `var`
    except that variables assigned with `const` will be immutable. For instance, the
    following code shows a variable and a constant that are both manipulated in the
    same way:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的基石之一是所谓的变量只能被赋值一次。这就是不变性。ECMAScript 2015支持一个新关键字，`const`。`const`关键字可以像`var`一样使用，只是用`const`赋值的变量是不可变的。例如，下面的代码展示了一个变量和一个常量，它们都以相同的方式被操作：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output of running this is the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行的输出如下：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, the results for the constant and variable are different.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，常量和变量的结果是不同的。
- en: 'If you''re using an older browser without support, then `const` won''t be available
    to you. A possible workaround is to make use of the `Object.freeze` functionality
    which is more widely adopted:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是不支持`const`的旧浏览器，那么`const`对你来说将不可用。一个可能的解决方法是利用更广泛采用的`Object.freeze`功能：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, the syntax here is not very user-friendly. Also an issue is
    that attempting to assign to an already assigned `const` simply fails silently
    instead of throwing an error. Failing silently in this fashion is not at all a
    desirable behavior; a full exception should be thrown. If you enable strict mode,
    a more rigorous parsing mode is added in ECMAScript 5, and an exception is actually
    thrown:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这里的语法并不是非常用户友好。另一个问题是，尝试对已分配的`const`进行赋值会静默失败，而不是抛出错误。以这种方式静默失败绝对不是一种理想的行为；应该抛出完整的异常。如果启用严格模式，ECMAScript
    5中添加了更严格的解析模式，实际上会抛出异常：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code will throw the following error:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将抛出以下错误：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'An alternative is the `object.Create` syntax we spoke about earlier. When creating
    properties on the object, one can specify `writable: false` to make the property
    immutable:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '另一种方法是我们之前提到的`object.Create`语法。在创建对象的属性时，可以指定`writable: false`来使属性不可变：'
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, even in strict mode no exception is thrown when attempting to write
    to a non-writable property. Thus I would claim that the `const` keyword is not
    perfect for implementing immutable objects. You're better off using freeze.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使在严格模式下，当尝试写入不可写属性时也不会抛出异常。因此，我认为`const`关键字并不完美用于实现不可变对象。最好使用freeze。
- en: Lazy instantiation
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒惰实例化
- en: If you go into a higher-end coffee shop and place an order for some overly complex
    beverage (Grande Chai Tea Latte, 3 Pump, Skim Milk, Lite Water, No Foam, Extra
    Hot anybody?) then that beverage is going to be made on-the-fly and not in advance.
    Even if the coffee shop knew which orders were going to come in that day, they
    would still not make all the beverages up front. First, because it would result
    in a large number of ruined, cold beverages, and second, it would be a very long
    time for the first customer to get their order if they had to wait for all the
    orders of the day to be completed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你去一个高端的咖啡店点一杯过于复杂的饮料（大杯奶茶拿铁，3泵，脱脂牛奶，少水，无泡沫，超热，有人吗？），那么这种饮料将是临时制作的，而不是提前制作的。即使咖啡店知道今天会有哪些订单，他们也不会提前制作所有的饮料。首先，因为这会导致大量的变质、冷却的饮料，其次，如果他们必须等待当天所有订单完成，第一个顾客拿到他们的订单将需要很长时间。
- en: Instead coffee shops follow a just-in-time approach to crafting beverages. They
    make them when they're ordered. We can apply a similar approach to our code through
    the use of a technique known as lazy instantiation or lazy initialization.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，咖啡店采用按需制作饮料的方法。他们在点单时制作。我们可以通过使用一种称为懒惰实例化或懒惰初始化的技术来将类似的方法应用到我们的代码中。
- en: Consider an object which is expensive to create; that is to say that it takes
    a great deal of time to create the object. If we are unsure if the object's value
    will be needed, we can defer its full creation until later.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个昂贵的创建对象；也就是说，创建对象需要很长时间。如果我们不确定对象的值是否需要，我们可以推迟到以后再完全创建它。
- en: Implementation
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'Let''s jump into an example of this. Westeros isn''t really big on expensive
    coffee shops but they do love a good bakery. This bakery takes requests for different
    bread types in advance and then bakes them all at once should they get an order.
    However, creating the bread object is an expensive operation so we would like
    to defer that until somebody actually comes to pick up the bread:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。Westeros并不是非常喜欢昂贵的咖啡店，但他们确实喜欢好的面包店。这家面包店提前接受不同种类的面包请求，然后一旦有订单，就会一次性烘烤所有面包。然而，创建面包对象是一个昂贵的操作，所以我们希望推迟到有人来取面包时再创建：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We start by creating a list of bread types to be created as needed. This list
    is appended to by ordering a bread type:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个要根据需要创建的面包类型列表。通过订购面包类型来追加这个列表：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This allows for breads to be rapidly added to the required bread list without
    paying the price for each bread to be created.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以快速地将面包添加到所需的面包列表中，而不必为每个面包的创建付出代价。
- en: 'Now when `pickUpBread` is called we''ll actually create the breads:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当调用`pickUpBread`时，我们将实际创建面包：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here we call a series of operations:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用了一系列操作：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will result in the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下结果：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can see that the collection of actual breads is left until after the pickup
    has been requested.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到实际面包的收集是在取面包请求之后进行的。
- en: Lazy instantiation can be used to simplify asynchronous programming. Promises
    are an approach to simplifying callbacks which are common in JavaScript. Instead
    of building up complicated callbacks, a promise is an object which contains a
    state and a result. When first called, the promise is in an unresolved state;
    once the `async` operation completes, the state is updated to complete and the
    result is filled in. You can think of the result as being lazily instantiated.
    We'll look at promises and promise libraries in more detail in [Chapter 9](part0147_split_000.html#4C62M2-015e68c68a464f18a9559f448be84435
    "Chapter 9. Web Patterns"), *Web Patterns*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰实例化可以用来简化异步编程。Promise是简化JavaScript中常见的回调的一种方法。Promise是一个包含状态和结果的对象。首次调用时，promise处于未解决状态；一旦`async`操作完成，状态就会更新为完成，并填充结果。你可以把结果想象成是懒惰实例化的。我们将在[第9章](part0147_split_000.html#4C62M2-015e68c68a464f18a9559f448be84435
    "第9章. Web Patterns") *Web Patterns*中更详细地讨论promise和promise库。
- en: Being lazy can save you quite a bit of time in creating expensive objects that
    end up never being used.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰可以节省你在创建昂贵对象上的时间，最终这些对象可能根本不会被使用。
- en: Hints and tips
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: 'Although callbacks are the standard way of dealing with asynchronous methods
    in JavaScript they can get out of hand easily. There are a number of approaches
    to solving this spaghetti code: promise libraries provide a more fluent way of
    handling callbacks and future versions of JavaScript may adopt an approach similar
    to the C# `async/await` syntax.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管回调是JavaScript中处理异步方法的标准方式，但很容易失控。有许多方法来解决这种混乱的代码：promise库提供了一种更流畅的处理回调的方式，未来的JavaScript版本可能会采用类似C#
    `async/await`语法的方法。
- en: I really like accumulators but they can be inefficient in terms of memory use.
    The lack of tail recursion means that each pass through adds another stack frame,
    so this approach may result in memory pressure. All things are a trade-off in
    this case between memory and code maintainability.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很喜欢累加器，但它们在内存使用方面可能效率低下。缺乏尾递归意味着每次通过都会增加一个堆栈帧，因此这种方法可能会导致内存压力。在这种情况下，所有事情都是在内存和代码可维护性之间进行权衡。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: JavaScript is not a functional programming language. That is not to say that
    it isn't possible to apply some of the ideas from functional programming to it.
    These approaches enable cleaner, easier to debug code. Some might even argue that
    the number of issues will be reduced although I have never seen any convincing
    studies on that.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript不是一种函数式编程语言。这并不是说不可能将一些函数式编程的思想应用到它上面。这些方法可以使代码更清晰、更容易调试。有些人甚至会认为问题的数量会减少，尽管我从未见过任何令人信服的研究。
- en: In this chapter we looked at six different patterns. Lazy instantiation, memoization,
    and immutability are all creational patterns. Function passing is a structural
    pattern as well as a behavioral one. Accumulators are also behavioral in nature.
    Filters and pipes don't really fall into any of the GoF categories so one might
    think of them as a style pattern.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了六种不同的模式。延迟实例化、记忆化和不可变性都是创建模式。函数传递是一种结构模式，也是一种行为模式。累加器在性质上也是一种行为模式。过滤器和管道实际上并不属于GoF的任何类别，因此人们可能会将它们视为一种样式模式。
- en: In the next chapter we'll look at a number of patterns for dividing the logic
    and presentation in applications. These patterns have become more important as
    JavaScript applications have grown.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一些在应用程序中划分逻辑和呈现的模式。随着JavaScript应用程序的增长，这些模式变得更加重要。
