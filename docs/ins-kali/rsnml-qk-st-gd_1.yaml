- en: Introduction to ReasonML
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍ReasonML
- en: The last decade has seen numerous paradigm shifts in the way we build user interfaces.
    Web applications have moved from server-side frameworks to client-side frameworks
    in order to provide better user experiences. Devices and browsers have become
    powerful enough to run robust client-side applications, and the JavaScript language
    itself has seen many improvements over the years. Progressive web apps provides
    a native-like user experience and WebAssembly allows for native-like performance on
    the web platform. An increasing number of applications are being built for the
    browser, resulting in larger client-side codebases needing to be maintained.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 过去十年，我们构建用户界面的方式发生了许多范式转变。Web应用程序已经从服务器端框架转移到客户端框架，以提供更好的用户体验。设备和浏览器已经足够强大，可以运行强大的客户端应用程序，而JavaScript语言本身多年来也有许多改进。渐进式Web应用程序提供了类似本机的用户体验，WebAssembly允许在Web平台上获得类似本机的性能。越来越多的应用程序正在为浏览器构建，导致需要维护更大的客户端代码库。
- en: During this period, several frameworks, libraries, tools, and general best practices
    gained and then lost popularity, resulting in **JavaScript fatigue** for many
    developers. Companies are becoming increasingly cautious in committing to newer
    technologies due to their impact on hiring and retaining engineering talent, as
    well as productivity and maintainability. It can be an expensive mistake if you
    introduce the wrong technology (or the right technology at the wrong time) to
    your team.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段时间内，几个框架、库、工具和一般最佳实践获得了然后失去了流行，导致许多开发人员出现了**JavaScript疲劳**。由于对招聘和留住工程人才、生产力和可维护性的影响，公司越来越谨慎地承诺使用新技术。如果您向团队引入错误的技术（或者在错误的时间引入正确的技术），这可能是一个昂贵的错误。
- en: For many companies and developers, React has proven to be a solid choice. In
    2013, Facebook made the library open source after having used it internally since
    2011\. They challenged us to rethink best practices ([https://www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be](https://www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be))
    and it has since taken over frontend development ([https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76](https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76)).
    Encapsulating markup, behavior, and style into reusable components has become
    a huge productivity and maintainability win. The abstraction of the DOM has allowed
    for components to be simple, declarative functions of its props that are easy
    to reason about, compose, and test.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多公司和开发人员来说，React已被证明是一个可靠的选择。2013年，Facebook在2011年内部使用了这个库后，将其开源。他们挑战我们重新思考最佳实践（[https://www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be](https://www.youtube.com/watch?v=DgVS-zXgMTk&feature=youtu.be)），自那时起，它已经接管了前端开发（[https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76](https://medium.freecodecamp.org/yes-react-is-taking-over-front-end-development-the-question-is-why-40837af8ab76)）。将标记、行为和样式封装到可重用的组件中已成为巨大的生产力和可维护性优势。DOM的抽象化使得组件变得简单、声明式，易于理解、组合和测试。
- en: Via React, Facebook has done an incredible job educating the frontend-developer
    community on traditional functional programming paradigms that make it easier
    to reason about and maintain code. And now, Facebook believes the time is right
    for ReasonML.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过React，Facebook在教育前端开发人员社区方面做得非常出色，传统的函数式编程范式使得更容易理解和维护代码。现在，Facebook认为是使用ReasonML的时机。
- en: 'This is a two-year chart from [npmtrends.com](https://www.npmtrends.com/) that
    shows the number of weekly npm downloads for some of the top JavaScript libraries
    and frameworks. ReactJS looks to be a clear winner and has reached over 2,500,000
    downloads per week:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自[npmtrends.com](https://www.npmtrends.com/)的两年图表，显示了一些顶级JavaScript库和框架的每周npm下载次数。ReactJS似乎是一个明显的赢家，每周下载量已经超过250万次：
- en: '![](img/b5957f88-9ae0-4aaa-ba2a-f1ec78579b88.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5957f88-9ae0-4aaa-ba2a-f1ec78579b88.png)'
- en: npmtrends.com
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: npmtrends.com
- en: 'In this chapter, we''ll do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Discuss what ReasonML is and what problems it tries to solve
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论ReasonML是什么，以及它试图解决什么问题
- en: Understand some of the reasons why Facebook chose ReasonML as the future of
    ReactJS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Facebook选择ReasonML作为ReactJS未来的一些原因
- en: Experiment with ReasonML in an online playground and examine its compiled (JavaScript)
    output
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在在线游乐场中尝试ReasonML，并检查其编译（JavaScript）输出
- en: What is ReasonML?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是ReasonML？
- en: Reason is a layer of syntax & tooling on top of OCaml, a language Facebook uses
    actively. Jordan [Walke] started the concept of Reason before React, in fact.
    We’re taking it and using it as an actual frontend language (among other uses)
    because we think that after three and half years, the React experiment has succeeded
    and people are now ready for Reason...
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Reason是OCaml语言的一层语法和工具，Facebook积极使用这种语言。实际上，乔丹[沃尔克]在React之前就开始了Reason的概念。我们正在将其用作实际的前端语言（以及其他用途），因为我们认为在三年半之后，React实验已经成功，人们现在已经准备好使用Reason...
- en: – Cheng Lou, January, 2017
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '- 郑楼，2017年1月'
- en: ([https://www.reactiflux.com/transcripts/cheng-lou/](https://www.reactiflux.com/transcripts/cheng-lou/))
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ([https://www.reactiflux.com/transcripts/cheng-lou/](https://www.reactiflux.com/transcripts/cheng-lou/))
- en: Let's expand on this quote. ReasonML is not a new language; it's a new syntax
    for the OCaml language that is meant to be familiar to JavaScript developers.
    Reason, as we'll call it from now on, has the exact same AST as OCaml, so Reason
    and OCaml only differ by syntax. The semantics are the same. By learning Reason,
    you're also learning OCaml. In fact, there's a command-line tool that converts
    between OCaml and Reason syntax, called `refmt`, which formats Reason/OCaml code
    similar to JavaScript's prettier—in fact, prettier was inspired by `refmt`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展一下这个引用。ReasonML不是一种新语言；它是OCaml语言的一种新语法，旨在让JavaScript开发人员感到熟悉。从现在开始，我们将称之为Reason，它与OCaml具有完全相同的AST，因此Reason和OCaml只在语法上有所不同。语义是相同的。通过学习Reason，您也在学习OCaml。事实上，有一个命令行工具可以在OCaml和Reason语法之间转换，称为`refmt`，它格式化Reason/OCaml代码类似于JavaScript的prettier——事实上，prettier受`refmt`启发。
- en: OCaml is a general-purpose programming language with an emphasis on expressiveness
    and safety. It was initially released in 1996 and has an advanced type system
    that helps catch your mistakes without getting in the way. Like JavaScript, OCaml
    features garbage collection for automatic memory management and first-class functions
    that can be passed around as arguments to other functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: OCaml是一种以表现力和安全性为重点的通用编程语言。它最初发布于1996年，具有先进的类型系统，可以帮助捕捉错误而不妨碍编程。与JavaScript一样，OCaml具有垃圾回收功能，用于自动内存管理，并且具有一流函数，可以作为参数传递给其他函数。
- en: Reason is also a toolchain that makes getting started easier for those coming
    from a JavaScript background. This toolchain allows us to take advantage of both
    the JavaScript and OCaml ecosystems. We will dive deeper here in [Chapter 2](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml),
    *Setting Up a Development Environment*. For now, we'll experiment directly in
    the online playground by visiting Reason's online playground at [https://reasonml.github.io/try](https://reasonml.github.io/try).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Reason也是一个工具链，使得那些来自JavaScript背景的人更容易入门。这个工具链允许我们充分利用JavaScript和OCaml生态系统。我们将在[第2章](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml)中深入探讨这一点，*设置开发环境*。现在，我们将直接在在线游乐场进行实验，访问Reason的在线游乐场[https://reasonml.github.io/try](https://reasonml.github.io/try)。
- en: 'Try typing in this Hello World example into the online playground:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在在线游乐场中输入这个Hello World的例子：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are two things you''ll notice:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事你会注意到：
- en: The OCaml syntax is automatically generated in the lower-left section of the
    editor (not shown)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OCaml语法会自动生成在编辑器的左下角（未显示）
- en: 'The Reason/OCaml code is compiled to JavaScript directly in the browser:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reason/OCaml代码直接在浏览器中编译为JavaScript：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may be wondering how the Reason/OCaml code is being compiled from within
    the browser. BuckleScript, Reason's partner project, compiles the OCaml AST to
    JavaScript. Since Reason and OCaml both get converted into the same OCaml AST,
    BuckleScript supports both Reason and OCaml. Furthermore, since BuckleScript is
    itself written in OCaml, it can be compiled to JavaScript and run directly in
    the browser.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道Reason/OCaml代码是如何在浏览器中编译的。BuckleScript是Reason的合作项目，它将OCaml AST编译为JavaScript。由于Reason和OCaml都转换为相同的OCaml
    AST，BuckleScript同时支持Reason和OCaml。此外，由于BuckleScript本身是用OCaml编写的，它可以被编译为JavaScript并直接在浏览器中运行。
- en: 'Inspecting the compiled JavaScript reveals just how readable it is. Looking
    closer, you''ll notice that the compiled output has also been optimized: within
    the `console.log` statement, the `"Hello World"` string has been inlined directly
    instead of using the `message` variable.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 检查编译后的JavaScript代码，你会发现它是多么易读。更仔细地观察，你会注意到编译后的输出也经过了优化：在`console.log`语句中，`"Hello
    World"`字符串直接内联，而不是使用`message`变量。
- en: BuckleScript, using features of the OCaml type-system and compiler implementation
    is able to provide many optimizations during offline compilation, allowing the
    runtime code to be extremely fast.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript利用OCaml类型系统和编译器实现的特性，在离线编译期间能够提供许多优化，使得运行时代码非常快速。
- en: – BuckleScript docs
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '- BuckleScript文档'
- en: ([https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)[)](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ([https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)[)](https://bucklescript.github.io/bucklescript/Manual.html#_why_bucklescript)
- en: 'Notably, BuckleScript also supports string interpolation ([https://bucklescript.github.io/docs/en/common-data-types.html#interpolation](https://bucklescript.github.io/docs/en/common-data-types.html#interpolation)):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，BuckleScript还支持字符串插值([https://bucklescript.github.io/docs/en/common-data-types.html#interpolation](https://bucklescript.github.io/docs/en/common-data-types.html#interpolation))：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Why Reason?
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择Reason？
- en: What makes Reason so compelling? What can Reason do that TypeScript or Flow
    cannot? Is it just about having a static type-checker? These are some of the questions
    I had when first getting started with Reason.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Reason有什么让人着迷的？Reason能做到TypeScript或Flow做不到的吗？它只是拥有静态类型检查器吗？这些是我刚开始接触Reason时的一些问题。
- en: Support for immutability and purity
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对不可变性和纯度的支持
- en: Reason isn't just about having a static type system. Also important is the fact
    that Reason is immutable by default. Immutability is an important concept in functional
    programming. In practice, using immutable data structures (data structures that
    can't change) results in safer, easier-to-reason-about, and more maintainable
    code than their mutable counterparts. This will be a recurring theme throughout
    this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 理由不仅仅是拥有静态类型系统。同样重要的是Reason默认是不可变的。不可变性是函数式编程中的重要概念。在实践中，使用不可变数据结构（无法更改的数据结构）比可变数据结构产生更安全、更易于推理和更易于维护的代码。这将是本书中的一个重要主题。
- en: 'Purity is another important concept in functional programming. A function is
    said to be pure if its output is determined only by its input, without observable
    side-effects. In other words, a pure function doesn''t do anything outside of
    returning a value. The following is an example of a pure function:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 纯度是函数式编程中的另一个重要概念。如果一个函数的输出仅由其输入决定，没有可观察的副作用，那么这个函数就是纯的。换句话说，纯函数除了返回一个值之外不做任何事情。以下是一个纯函数的例子：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And, this is an example of an impure function:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不纯的函数的例子：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The side-effect in this case is writing to the browser's console. That's why,
    in our preceding `Hello World` example, BuckleScript included the `/* Not a pure
    module */` comment at the end of the compiled output.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下的副作用是写入浏览器的控制台。这就是为什么在我们之前的Hello World例子中，BuckleScript在编译输出的末尾包含了`/* Not
    a pure module */`注释。
- en: 'Mutating a global variable is also a side-effect. Consider the following JavaScript:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 改变全局变量也是一种副作用。考虑以下JavaScript：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The global object was mutated, and now its `total` property is `42`. We now
    have to be aware of all areas where this `globalObject` is mutated whenever using
    it. Forgetting that this object is both global and mutable can lead to hard-to-debug
    problems. One idiomatic solution to this problem is to move `globalObject` into
    a module where it's no longer global. This way, only that module has access to
    it. However, we'd still need to be aware of all areas within this module that
    can update the object.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 全局对象被改变了，现在它的`total`属性是`42`。现在我们必须意识到在使用它时，所有可以改变`globalObject`的区域。忘记这个对象既是全局的又是可变的，可能会导致难以调试的问题。解决这个问题的一种成语解决方案是将`globalObject`移到一个不再是全局的模块中。这样，只有该模块才能访问它。然而，我们仍然需要意识到这个模块内所有可以更新对象的区域。
- en: 'If `globalObject` was immutable instead, there would be no way to mutate it.
    Therefore, we wouldn''t need an awareness of all the areas that can mutate `globalObject`,
    since there wouldn''t be any of these areas. We''ll see that, with Reason, it''s
    fairly simple and natural to build real applications in this way by creating updated
    copies of the original data. Consider the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`globalObject`是不可变的，就不会有改变它的方法。因此，我们不需要意识到所有可以改变`globalObject`的区域，因为不会有这些区域。我们将看到，使用Reason，通过创建原始数据的更新副本来构建真实应用程序是相当简单和自然的。考虑以下内容：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The syntax feels quite natural. As we'll see later in this book, immutability—changing
    by returning updated copies instead of applying destructive changes in place—fits
    the React/Redux way of doing things quite well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 语法感觉非常自然。正如我们将在本书的后面看到的，不可变性——通过返回更新的副本而不是在原地应用破坏性的更改——非常适合React/Redux的做事情方式。
- en: 'The original `foo` was not mutated; it was shadowed. Once shadowed, the old
    `foo` binding is unavailable. Bindings can be shadowed in local scopes as well
    as global scopes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的`foo`没有被改变；它被遮蔽了。一旦被遮蔽，旧的`foo`绑定就不可用了。绑定可以在局部作用域和全局作用域中被遮蔽：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Trying to mutate `foo` results in a compilation error:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试改变`foo`会导致编译错误：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that immutability and purity are related topics. Having a language
    that supports immutability allows you to program in a pure way without side-effects.
    However, what if there are times when purity would cause the code to become more
    complex and harder to reason about than using side-effects? You may be relieved
    to learn that Reason (interchangeable with OCaml throughout the rest of this book)
    is a pragmatic language that let's us cause side-effects when needed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，不可变性和纯度是相关的主题。拥有支持不可变性的语言可以让你以无副作用的方式编程。然而，如果纯度会导致代码变得比使用副作用更复杂和难以理解，怎么办？你可能会松一口气地得知，Reason（在本书的其余部分可以与OCaml互换使用）是一种实用的语言，让我们在需要时引起副作用。
- en: The key thing when using a language like [Reason] is not to avoid side-effects,
    because avoiding side-effects is equivalent to avoiding doing anything useful.
    It turns out, in reality, programs don't just *compute* things, they *do *things.
    They send messages and they write files and they do all sorts of stuff. The doing
    of things is automatically involving side-effects. The thing that a language which
    supports purity gives you, is it gives you the ability to, by and large, segment
    out the part that is side-effecting to clear and controlled areas of your code,
    and that makes it much easier to reason about.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像[Reason]这样的语言时，关键是不要避免副作用，因为避免副作用等同于避免做任何有用的事情。事实证明，在现实中，程序不仅仅是*计算*事情，它们*做*事情。它们发送消息，写文件，做各种各样的事情。做事情自动涉及副作用。支持纯度的语言给你的是，它让你能够在很大程度上将具有副作用的部分分割到代码的清晰和可控的区域，这样更容易推理。
- en: – Yaron Minsky
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '- Yaron Minsky'
- en: ([https://www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s](https://www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s))
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: （[https://www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s](https://www.youtube.com/watch?v=-J8YyfrSwTk&feature=youtu.be&t=47m29s)）
- en: It's also important to know that immutability doesn't come at the cost of performance.
    Under the hood, there are optimizations in place that keeps Reason's immutable
    data structures fast.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还要知道的是，不可变性并不会影响性能。在底层，有优化措施可以保持Reason的不可变数据结构快速。
- en: Module system
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块系统
- en: Reason has a sophisticated module system that allows for modular development
    and code organization. All modules are globally available in Reason, and module
    interfaces can be used to hide implementation details when needed. We will be
    exploring this concept in [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml),
    *Effective ML*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Reason有一个复杂的模块系统，允许模块化开发和代码组织。在Reason中，所有模块都是全局可用的，当需要时，模块接口可以用来隐藏实现细节。我们将在[第5章](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml)中探讨这个概念，*Effective
    ML*。
- en: Type system
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型系统
- en: Reason's type system is sound, which means that, once compiled, there won't
    be runtime type errors. There is no `null` in the language, nor are there any
    bugs related to `null`. In JavaScript, when something is of the `number` type,
    it can also be `null`. Reason uses a special type for things that can also be
    `null`, and forces the developer to handle those cases appropriately by refusing
    to compile otherwise.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Reason的类型系统是可靠的，这意味着一旦编译，就不会有运行时类型错误。语言中没有`null`，也没有与`null`相关的任何错误。在JavaScript中，当某个东西是`number`类型时，它也可以是`null`。Reason使用一个特殊类型来表示那些也可以是`null`的东西，并通过拒绝编译来强制开发人员适当处理这些情况。
- en: So far, we've already written some, albeit basic, Reason code without even talking
    about types. Reason infers types automatically. As we'll learn throughout this
    book, the type system is a tool that provides guarantees without getting in our
    way, and when used properly, can allow us to offload things to the compiler that
    we used to keep in our heads.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经写了一些，尽管基本的Reason代码，甚至没有谈论类型。Reason会自动推断类型。正如我们将在本书中学到的那样，类型系统是一个工具，可以在不妨碍我们的情况下提供保证，并且当正确使用时，可以让我们将一些事情交给编译器，而不是留在我们的脑海中。
- en: Reason's support for immutable programming, sound type system, and sophisticated
    module system are big parts of why Reason is so great, and there's something to
    be said about using all of these features together in one language that was built
    with these features in mind. When Facebook initially released React, they asked
    us to give it five minutes ([https://signalvnoise.com/posts/3124-give-it-five-minutes](https://signalvnoise.com/posts/3124-give-it-five-minutes))
    and, hopefully, that same frame of mind will pay off here as well.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Reason对不可变编程、健全类型系统和复杂的模块系统的支持是Reason如此出色的重要原因，而且在一个语言中同时使用所有这些特性，这是有意思的。当Facebook最初发布React时，他们要求我们给它五分钟（[https://signalvnoise.com/posts/3124-give-it-five-minutes](https://signalvnoise.com/posts/3124-give-it-five-minutes)），希望这种心态在这里也会有所收获。
- en: Cross-platform
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨平台
- en: Building React applications with Reason is a lovely experience and, what's more,
    since OCaml is able to compile to native, we will be able to use these same skills
    to build apps that compile to assembly, iOS/Android, and much more. In fact, Jared
    Forsyth has already created a game called Gravitron ([https://github.com/jaredly/gravitron](https://github.com/jaredly/gravitron))
    that compiles to iOS, Android, web, and macOS from one Reason codebase. That being
    said, the frontend JavaScript story is much more polished as of this writing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Reason构建React应用是一种愉快的体验，而且由于OCaml能够编译成本地代码，我们将能够利用这些技能构建编译成汇编、iOS/Android等更多应用。事实上，Jared
    Forsyth已经从一个Reason代码库中创建了一个名为Gravitron的游戏，可以编译成iOS、Android、Web和macOS（[https://github.com/jaredly/gravitron](https://github.com/jaredly/gravitron)）。话虽如此，就目前而言，前端JavaScript的情况要更加完善。
- en: Maintainability
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: Reason may take some time to get comfortable with, but you can think of this
    time as an investment in the maintenance and confidence of your future product.
    Although languages with gradual type systems, such as TypeScript, may be easier
    to get started with, they don't provide the sorts of guarantees that a sound type
    system such as Reason's can provide. Reason's true benefits cannot be completely
    conveyed within simple examples, and only really shine when they save you time
    and energy in reasoning about, refactoring, and maintaining your code. Put it
    this way; if someone told me they were 99% sure a spider wasn't in my bed, I would
    still have to check the entire bed because I don't like bugs!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Reason可能需要一些时间来适应，但你可以把这段时间看作是对未来产品维护和信心的投资。尽管渐进式类型系统的语言，如TypeScript，可能更容易入门，但它们无法提供Reason这样健全类型系统所能提供的保证。Reason的真正优势无法完全通过简单的例子来传达，只有在节省你在推理、重构和维护代码方面的时间和精力时才能真正展现出来。换句话说，如果有人告诉我他对我的床上没有蜘蛛有99%的把握，我仍然会检查整个床，因为我不喜欢虫子！
- en: As long as you're 100% in Reason and your code compiles, the type system guarantees
    there will be no runtime type errors. It's true that when you are interoperating
    with non-Reason code (JavaScript, for example), you introduce the possibility
    of runtime type errors. Reason's sound type system allows you to trust that the
    Reason parts of the application won't cause runtime type errors, which therefore
    allows you to focus extra attention on ensuring that these areas of the application
    are safe. In my experience, programming in a dynamic language can feel noticeably
    dangerous. Reason on the other hand feels like it always has your back.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 只要你百分之百使用Reason并且你的代码编译通过，类型系统保证不会有运行时类型错误。当你与非Reason代码（例如JavaScript）进行互操作时，会引入运行时类型错误的可能性。Reason的健全类型系统使你可以相信应用程序的Reason部分不会引起运行时类型错误，因此可以专注于确保这些应用程序区域是安全的。根据我的经验，在动态语言中编程可能会感觉明显危险。另一方面，Reason总是给人一种有保障的感觉。
- en: Interoperability
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互操作性
- en: That being said, sometimes—and especially when first learning about type systems—you
    may be unsure as to how to get your code to compile. Reason, through BuckleScript,
    allows you to drop down to raw JavaScript when you need to, either via bindings
    or directly inside your Reason (`.re`) files. This gives you the freedom to figure
    things out as you go along in JavaScript, and then once you're ready, convert
    that section of the code to type-safe Reason.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，有时候，特别是在初学类型系统时，你可能不确定如何使你的代码编译通过。通过BuckleScript，Reason允许你在需要时直接使用原始JavaScript，无论是通过绑定还是直接在你的Reason（.re）文件中。这使你可以在JavaScript中逐步解决问题，然后一旦准备好，将代码部分转换为类型安全的Reason。
- en: BuckleScript also lets us bind to idiomatic JavaScript in a very reasonable
    way. As you'll learn in [Chapter 4](201d7348-8175-4caf-b4f3-285b669b9cf1.xhtml),
    *BuckleScript, Belt, and Interoperability*, BuckleScript is an incredibly powerful
    part of Reason.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript还让我们以一种非常合理的方式绑定到惯用的JavaScript。正如你将在第4章《BuckleScript、Belt和互操作性》中了解到的那样，BuckleScript是Reason的一个非常强大的部分。
- en: ES2030
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ES2030
- en: Writing in Reason feels like writing in a future version of JavaScript. Some
    Reason language features, including the pipe operator ([https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator)) and
    pattern matching ([https://github.com/tc39/proposal-pattern-matching](https://github.com/tc39/proposal-pattern-matching)),
    are currently being proposed to the TC39 Committee to add into the JavaScript
    language. With Reason, we can take advantage of these features, and much more,
    today.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Reason感觉就像在编写JavaScript的未来版本。一些Reason语言特性，包括管道操作符（[https://github.com/tc39/proposal-pipeline-operator](https://github.com/tc39/proposal-pipeline-operator)）和模式匹配（[https://github.com/tc39/proposal-pattern-matching](https://github.com/tc39/proposal-pattern-matching)），目前正在向TC39委员会提议将其添加到JavaScript语言中。通过Reason，我们可以立即利用这些特性以及更多。
- en: Community
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 社区
- en: The Reason community is, hands down, one of the most helpful, supportive, and
    inclusive communities I've ever been a part of. If you have a question, or are
    stuck on something, the Reason Discord channel is the place to go for realtime
    support.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Reason社区无疑是我参与过的最乐于助人、支持和包容的社区之一。如果你有问题或遇到困难，Reason Discord频道是实时支持的好去处。
- en: 'Reason Discord channel:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 原因Discord频道：
- en: '[https://discord.gg/reasonml](https://discord.gg/reasonml)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://discord.gg/reasonml](https://discord.gg/reasonml)'
- en: Often, when starting with a new technology, talking to someone with experience
    for five minutes can save you hours of frustration. I've personally asked questions
    at all hours of the day (and night) and am so incredibly grateful for and amazed
    by how quickly someone helps me out. Take a moment to join the Discord channel,
    introduce yourself, ask questions, and share your feedback on how to make Reason
    better!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当开始使用新技术时，与有经验的人交谈五分钟可以节省你几个小时的挫败感。我个人在一天（和夜晚）的所有时间都问问题，并对有多快有人帮助我感到非常感激和惊讶。花点时间加入Discord频道，介绍自己，提问，并分享如何使Reason变得更好的反馈！
- en: The Future of ReactJS
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ReactJS的未来
- en: In practice, few real-world applications use just ReactJS. Additional technologies,
    such as Babel, ESLint, Redux, Flow/TypeScript, and Immutable.js, are typically
    brought in to help increase the maintainability of a codebase. Reason replaces
    the need for these additional technologies with its core language features.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，很少有真实世界的应用程序仅使用ReactJS。通常会引入其他技术，如Babel、ESLint、Redux、Flow/TypeScript和Immutable.js，以帮助增加代码库的可维护性。Reason通过其核心语言特性取代了对这些额外技术的需求。
- en: ReasonReact is a Reason library that binds to ReactJS and provides a simpler,
    safer way to build ReactJS components. Just like ReactJS is just JavaScript, ReasonReact
    is just Reason. Additionally, it's easy to incrementally adopt because it was
    made by the same person who created ReactJS.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonReact是一个与ReactJS绑定并提供了一种更简单、更安全的构建ReactJS组件的Reason库。就像ReactJS只是JavaScript一样，ReasonReact只是Reason。此外，它很容易逐步采用，因为它是由创建ReactJS的同一个人制作的。
- en: ReasonReact comes with a built in router, Redux-like data management, and JSX.
    You'll feel quite at home coming from a ReactJS background.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonReact带有内置路由器、类似Redux的数据管理和JSX。如果你来自ReactJS背景，你会感到非常亲切。
- en: It's important to mention that Reason/ReasonReact is already being used by several
    companies in production, including within one of the largest codebases in the
    world. Facebook's messenger.com codebase is already over 50% converted to ReasonReact.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，Reason/ReasonReact已经被一些公司在生产中使用，包括世界上最大的代码库之一。Facebook的messenger.com代码库已经超过50%转换为ReasonReact。
- en: Every ReasonReact feature has been extensively tested on the messenger.com codebase.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonReact的每个功能都在messenger.com代码库上进行了广泛测试。
- en: – Cheng Lou
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '- Cheng Lou'
- en: ([https://reason.town/reason-philosophy](https://reason.town/reason-philosophy))
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ([https://reason.town/reason-philosophy](https://reason.town/reason-philosophy))
- en: As a result, new releases of Reason and ReasonReact come with code mods that
    automate much, if not all, of the upgrade process for your code base. New features
    are thoroughly tested internally at Facebook before they're released to the public,
    and this results in a pleasant developer experience.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Reason和ReasonReact的新版本都配备了代码修改，自动化了大部分甚至全部的代码库升级过程。在发布给公众之前，新功能在Facebook内部经过了彻底的测试，这带来了愉快的开发者体验。
- en: Exploring Reason
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Reason
- en: 'Ask yourself whether the following is a statement or an expression:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请问以下是一个语句还是一个表达式：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In JavaScript, it's a statement, but in Reason, it's an expression. Another
    example of an expression is `4 + 3`, which can also be represented as `4 + (2
    + 1)`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，它是一个语句，但在Reason中，它是一个表达式。另一个表达式的例子是`4 + 3`，也可以表示为`4 + (2 + 1)`。
- en: 'Many things in Reason are expressions, including control structures such as `if-else`,
    `switch`, `for` and `while`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Reason中的许多东西都是表达式，包括`if-else`、`switch`、`for`和`while`等控制结构：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also have ternaries in Reason. Here is another way to express the preceding
    code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Reason中也有三元运算符。以下是表达前述代码的另一种方式：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Even anonymous block scopes are expressions that evaluate to the last line''s
    expression:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是匿名块作用域也是表达式，其结果为最后一行的表达式：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A `tuple` is an immutable data structure that can hold different types of values
    and can be of any length:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`元组`是一个不可变的数据结构，可以容纳不同类型的值，并且可以是任意长度的：'
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s use what we know so far and dive right in with the `FizzBuzz` example
    from Reason''s online playground. `FizzBuzz` was a popular interview question
    to determine whether a candidate is able to code. The challenge is to write a
    problem that prints the numbers from `1` to `100`, but instead prints `Fizz` for
    multiples of three, `Buzz` for multiples of five, and `FizzBuzz` for multiples
    of both three and five:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用我们已经知道的知识，从Reason的在线游乐场中的`FizzBuzz`示例开始。`FizzBuzz`曾是一个流行的面试问题，用来确定候选人是否能编程。挑战是编写一个问题，打印从`1`到`100`的数字，但对于三的倍数打印`Fizz`，对于五的倍数打印`Buzz`，对于三和五的倍数打印`FizzBuzz`：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, `fizzbuzz` is a function that accepts an integer and returns a string.
    An imperative `for` loop logs its output to the console.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fizzbuzz`是一个接受整数并返回字符串的函数。一个命令式的`for`循环将其输出记录到控制台。
- en: 'In Reason, a function''s last expression becomes the function''s return value.
    The `switch` expression is the only `fizzbuzz` expression, so whatever that evaluates
    to becomes the output of `fizzbuzz`. Like JavaScript, the `switch` evaluates an
    expression and the first matched case gets its branch executed. In this case,
    the `switch` evaluates the tuple expression: `(i mod 3, i mod 5)`.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reason中，函数的最后一个表达式成为函数的返回值。`switch`表达式是唯一的`fizzbuzz`表达式，所以无论它评估为什么都成为`fizzbuzz`的输出。与JavaScript一样，`switch`评估一个表达式，并执行第一个匹配的分支。在这种情况下，`switch`评估元组表达式：`(i
    mod 3, i mod 5)`。
- en: Given `i=1`, `(i mod 3, i mod 5)` becomes `(1, 1)`. Since `(1, 1)` isn't matched
    by `(0, 0)`, `(0, _)`, or `(_, 0)`, in that order, the last case of `_` (that
    is, *anything*) is matched, and `"1"` is returned. Similarly, `fizzbuzz` returns
    `"2"` when given `i=2`. When given `i=3`, `"Fizz"` is returned.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`i=1`，`(i mod 3, i mod 5)`变为`(1, 1)`。由于`(1, 1)`不匹配`(0, 0)`、`(0, _)`或`(_, 0)`，按顺序，最后一个`_`（也就是*任何东西*）被匹配，返回`"1"`。类似地，当给定`i=2`时，`fizzbuzz`返回`"2"`。当给定`i=3`时，返回`"Fizz"`。
- en: 'Alternatively, we could have implemented `fizzbuzz` using `if-else`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`if-else`来实现`fizzbuzz`：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However, the switch version is much more readable. And as we'll see later in
    this chapter, the switch expression, also called **pattern matching**, is much
    more powerful than we've seen so far.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，switch版本更易读。正如我们将在本章后面看到的那样，switch表达式，也称为**模式匹配**，比我们迄今为止看到的更强大。
- en: Data structures and types
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构和类型
- en: 'A type is a set of values. More concretely, `42` has the `int` type because
    it''s a value that''s contained in the set of integers. A float is a number that
    includes a decimal point, that is, `42.` and `42.0`. In Reason, integers and floating
    point numbers have separate operators:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是一组值。更具体地说，`42`具有`int`类型，因为它是包含在整数集合中的值。浮点数是包含小数点的数字，即`42.`和`42.0`。在Reason中，整数和浮点数有不同的运算符：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The same is true for `-.`, `-`, `*.`, `*`, `/.`, and `/`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`-.`, `-`, `*.`，`*`，`/.`和`/`也是如此。
- en: Reason uses double quotes for the `string` type and single quotes for the `char` type.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Reason使用双引号表示`string`类型，单引号表示`char`类型。
- en: Creating our own types
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们自己的类型
- en: 'We can also create our types:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以创建我们自己的类型：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s how we create a person of the `person` type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何创建`person`类型的人：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also annotate any expression with its type:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用它的类型注释任何表达式：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Pattern matching
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: 'We can use pattern matching on our person:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的人身上进行模式匹配：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s use a record instead of a tuple for our person. Records are similar
    JavaScript objects except they''re much lighter and are immutable by default:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用记录而不是元组来表示我们的人。记录类似于JavaScript对象，只是它们更轻量，并且默认情况下是不可变的：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can use pattern matching on records too:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在记录上进行模式匹配：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Like JavaScript, `{name: "Zoe", age: age}` can be represented as `{name: "Zoe",
    age}`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '与JavaScript一样，`{name: "Zoe", age: age}`可以表示为`{name: "Zoe", age}`。'
- en: 'We can create a new record from an existing one using the spread ( `...` )
    operator:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用扩展（`...`）运算符从现有记录创建新记录：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Records require type definitions before they can be used. Otherwise, the compiler
    will error with something like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 记录在使用之前需要类型定义。否则，编译器将出现以下类似的错误：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'A record must be the same shape as its type. Therefore, we cannot add arbitrary
    fields to our `person` record:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 记录必须与其类型具有相同的形状。因此，我们不能向我们的`person`记录添加任意字段：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tuples and records are examples of product types. In our recent examples, our `person` type
    required both an `int` and an `age`. Almost all of JavaScript's data structures
    are product types; one exception is the `boolean` type, which is either `true`
    or `false`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 元组和记录是产品类型的例子。在我们最近的例子中，我们的`person`类型需要一个`int`和一个`age`。几乎所有JavaScript的数据结构都是产品类型；唯一的例外是`boolean`类型，它要么是`true`，要么是`false`。
- en: 'Reason''s variant type, which is an example of a sum type, allows us to express
    this or that. We can define the `boolean` type as a variant:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Reason的变体类型是求和类型的一个例子，它允许我们表达这个或那个。我们可以将`boolean`类型定义为一个变体：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can have as many constructors as we need:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有尽可能多的构造函数：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Yes`, `No`, and `Maybe` are called constructors because we can use them to
    construct values. They''re also commonly called **tags**. Because these tags can
    construct values, variants are both a type and a data structure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Yes`，`No`和`Maybe`被称为构造函数，因为我们可以使用它们来构造值。它们也通常被称为**标签**。因为这些标签可以构造值，变体既是一种类型，也是一种数据结构：'
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And, of course, we can pattern match on `decision`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以在`decision`上进行模式匹配：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we were to forget to handle a case, the compiler would warn us:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记处理一个情况，编译器会警告我们：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we'll learn in [Chapter 2](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml), *Setting
    Up a Development Environment*, the compiler can be configured to turn this warning
    into an error. Let's see one way to help make our code more resilient to future
    refactors by taking advantage of these exhaustiveness checks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](4e4e3057-fca6-4c81-b6a7-05575aeeace3.xhtml)中，我们将学习*设置开发环境*，编译器可以配置为将此警告转换为错误。让我们看一种方法，通过利用这些穷尽性检查来帮助使我们的代码更具弹性，以应对未来的重构。
- en: 'Take the following example where we are tasked with calculating the price of
    a concert venue''s seat given its section. Floor seats are $55, while all other
    seats are $45:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的例子中，我们的任务是根据座位的区域来计算音乐会场地的座位价格。地板座位价格为55美元，而其他座位价格为45美元：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If, later, the concert venue allows the sale of seats in the orchestra pit
    area for $65, we would first add another constructor to `seat`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以后音乐会场地允许在管弦乐区出售座位，价格为65美元，我们首先会向`seat`添加另一个构造函数：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, due to the usage of the catch-all `_` case, our compiler doesn't complain
    after this change. It would be much better if it did since that would help us
    during our refactoring process. Stepping through compiler messages after changing
    type definitions is how Reason (and the ML family of languages in general) makes
    refactoring and extending code a safer, more pleasant process. This is, of course,
    not limited to variant types. Adding another field to our `person` type would
    also result in the same process of stepping through compiler messages.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于使用了通配符`_`，我们的编译器在此更改后没有投诉。如果它这样做会更好，因为这将在重构过程中帮助我们。在更改类型定义后，逐步浏览编译器消息是Reason（以及ML语言系列）如何使重构和扩展代码成为一个更安全、更愉快的过程。当然，这不仅限于变体类型。向`person`类型添加另一个字段也会导致相同的逐步浏览编译器消息的过程。
- en: 'Instead, we should reserve using `_` for an infinite number of cases (such
    as our `fizzbuzz` example). We can refactor `getSeatPrice` to use explicit cases
    instead:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们应该保留使用`_`来处理无限数量的情况（例如我们的`fizzbuzz`示例）。我们可以重构`getSeatPrice`以使用显式情况：
- en: '[PRE33]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, we welcome the compiler nicely informing us of our unhandled case and
    then add it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们欢迎编译器友好地通知我们未处理的情况，然后添加它：
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s now imagine that each seat, even ones in the same section (that is,
    ones that have the same tag) can have different prices. Well, Reason variants
    can also hold data:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们想象，即使在同一区域的座位（即具有相同标签的座位）也可以有不同的价格。好吧，Reason变体也可以保存数据：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And we can access this data with pattern matching:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用模式匹配访问这些数据：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Variants are not just limited to one piece of data. Let''s imagine that we
    want our `seat` type to store its price as well as whether it''s still available.
    If it''s not available, it should store the ticket holder''s information:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 变体不仅限于一个数据。假设我们希望我们的`seat`类型存储其价格以及它是否仍然可用。如果不可用，它应该存储持票人的信息：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before explaining what the `option` type is, let''s have a look at its implementation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释`option`类型之前，让我们看一下它的实现：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `''a` in the preceding code is called a **type variable**. Type variables
    always start with a `''`. This type definition uses a type variable so that it
    could work for any type. If it didn''t, we would need to create a `personOption` type
    that would only work for the `person` type:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中的`'a`称为**类型变量**。类型变量总是以`'`开头。这种类型定义使用类型变量，以便它可以适用于任何类型。如果没有，我们将需要创建一个`personOption`类型，它只适用于`person`类型：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: What if we wanted an option for another type as well? Instead of repeating this
    type declaration over and over, we declare a polymorphic type. A polymorphic type
    is a type that includes a type variable. The `'a` (pronounced alpha) type variable
    will be swapped with `person` in our example. Since this type definition is so
    common, it's included in Reason's standard library, so there's no need to declare
    the `option` type in your code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要另一种选项呢？我们可以声明一个多态类型，而不是一遍又一遍地重复这个类型声明。多态类型是包含类型变量的类型。在我们的例子中，`'a`（读作alpha）类型变量将与`person`交换。由于这种类型定义非常常见，Reason的标准库中已经包含了它，所以在你的代码中不需要声明`option`类型。
- en: 'Jumping back to our `seat` example, we store its price as an `int` and its
    holder as an `option(person)`. If there''s no holder, it''s still available. We
    could have an `isAvailable` function that would take a `seat` and return a `bool`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的`seat`示例，我们将其价格存储为`int`，持票人存储为`option(person)`。如果没有持票人，它仍然可用。我们可以有一个`isAvailable`函数，它将接受一个`seat`并返回一个`bool`：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s take a step back and look at the implementations of `getSeatPrice` and
    `isAvailable`. It''s a shame that both functions need to be aware of the different
    constructors when they don''t have anything to do with the price or availability
    of the seat. Taking another look at our `seat` type, we see that `(int, option(person))`
    is repeated for each constructor. Also, there isn''t really a nice way to avoid
    using the `_` case in `isAvailable`. These are all signs that another type definition
    might serve our needs better. Let''s remove the arguments from the `seat` type
    and rename it `section`. We''ll declare a new record type, called `seat`, with
    fields for `section`, `price`, and `person`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，看看`getSeatPrice`和`isAvailable`的实现。很遗憾，当它们与座位的价格或可用性无关时，这两个函数都需要知道不同的构造函数。再看一下我们的`seat`类型，我们发现对于每个构造函数，`(int,
    option(person))`都是重复的。此外，在`isAvailable`中没有一个很好的方法来避免使用`_`情况。这些都是另一种类型定义可能更好地满足我们需求的迹象。让我们从`seat`类型中删除参数，并将其重命名为`section`。我们将声明一个新的记录类型，称为`seat`，其中包含`section`、`price`和`person`字段：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, our `getSeatPrice` and `isAvailable` functions have a higher signal-to-noise
    ratio, and don't need to change when the `section` type changes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`getSeatPrice`和`isAvailable`函数的信噪比更高，当`section`类型发生变化时，它们不需要改变。
- en: As a side note, `_` is used to prefix a variable to prevent the compiler from
    warning us about the variable being unused.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，`_`用于在变量前加前缀，以防止编译器警告我们未使用变量。
- en: Making Invalid States Impossible
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使无效状态不可能
- en: 'Let''s say that we''d like to add a field to `seat` to hold the date a seat
    was purchased:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要向`seat`添加一个字段来保存座位购买日期：
- en: '[PRE42]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we''ve introduced the possibility of an invalid state in our code. Here''s
    an example of such a state:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在我们的代码中引入了一个无效状态的可能性。以下是这种状态的一个例子：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In theory, the `dateSold` field should only hold a date when the `person` field
    holds a ticket holder. The ticket has a sold date, but no owner. We could look
    through our imaginary implementation to verify that this state would never happen,
    but there would still be the possibility that we missed something, or that some
    minor refactor introduced a bug that was overlooked.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，`dateSold`字段应该只在`person`字段持有票持有者时保存日期。票有一个售出日期，但没有所有者。我们可以查看我们的想象实现，以验证这种状态永远不会发生，但仍然有可能我们遗漏了一些东西，或者一些微小的重构引入了一个被忽视的错误。
- en: Since we now have the power of Reason's type system at our disposal, let's offload
    this work to the compiler. We are going to use the type system to enforce invariants
    in our code. If our code breaks these rules, it won't compile.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在可以利用Reason的类型系统的功能，让我们把这项工作交给编译器。我们将使用类型系统来强制执行代码中的不变量。如果我们的代码违反这些规则，它将无法编译。
- en: 'One giveaway that this invalid state could exist is the use of `option` types
    within our record field. In these cases, there may be a way to use a variant instead
    such that each constructor only holds the relevant data. In our case, our sold-date
    and ticket-holder data should only exist when the seat has been sold:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个暗示这种无效状态可能存在的信号是在我们的记录字段中使用`option`类型。在这些情况下，可能有一种方法可以使用变体，使得每个构造函数只包含相关的数据。在我们的情况下，我们的售出日期和持票人数据应该只在座位被售出时存在：
- en: '[PRE44]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Check out our new `status` type. The `Available` constructor holds no data,
    and `Sold` holds the sold date as well as the ticket holder.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们的新`status`类型。`Available`构造函数不包含数据，`Sold`包含售出日期以及持票人。
- en: With this `seat` type, there's no way to represent the previous invalid state
    of having a sold date without a ticket holder. It's also a good sign that our
    `seat` type no longer includes `option` types.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个`seat`类型，就没有办法表示之前的无效状态，即没有票持有者的售出日期。我们的`seat`类型也不再包含`option`类型，这是一个好迹象。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got a feel for what Reason is and what problems it tries
    to solve. We saw how Reason's type inference removes much of the burden associated
    with statically-typed languages. We learned that the type system is a tool that
    can be used to provide codebases with powerful guarantees that provide an excellent
    developer experience. While Reason may take some time to get used to, it's well
    worth the investment for medium-sized to larger codebases.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对Reason是什么以及它试图解决什么问题有了一定的了解。我们看到Reason的类型推断消除了与静态类型语言相关的许多负担。我们了解到类型系统是一个可以用来为代码库提供强大保证的工具，从而提供出色的开发者体验。虽然可能需要一些时间来适应Reason，但对于中等规模到较大规模的代码库来说，这是非常值得投资的。
- en: In the next chapter, we'll learn about Reason's toolchain when we set up our
    development environment. In [Chapter 3](21586d11-fa31-446f-99f1-dae3beecdb9b.xhtml),
    *Creating ReasonReact Components*, we'll start to build an application that we'll
    use throughout the rest of this book. By the end of this book, you'll be comfortable
    building real-world React applications in Reason.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，当我们设置开发环境时，我们将了解Reason的工具链。在第3章《创建ReasonReact组件》中，我们将开始构建一个应用程序，这个应用程序将贯穿本书的其余部分。通过本书的学习，您将能够在Reason中轻松构建真实世界的React应用程序。
