["```kt\ntestImplementation 'junit:junit:4.13.1'\n```", "```kt\nclass MyClass {\n\u00a0\u00a0\u00a0\u00a0fun factorial(n: Int): Int {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return IntArray(n) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0it+1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}.reduce { acc, i ->\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0acc * i\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```kt\nimport org.junit.Assert.assertEquals\nimport org.junit.Test\nclass MyClassTest {\n\u00a0\u00a0\u00a0\u00a0private val myClass = MyClass()\n\u00a0\u00a0\u00a0\u00a0@Test\n\u00a0\u00a0\u00a0\u00a0fun computesFactorial() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val n = 3\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val result = myClass.factorial(n)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assertEquals(6, result)\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```kt\n@RunWith(Parameterized::class)\nclass MyClassTest(\n\u00a0\u00a0\u00a0\u00a0private val input: Int,\n\u00a0\u00a0\u00a0\u00a0private val expected: Int\n) {\n\u00a0\u00a0\u00a0\u00a0companion object {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0@Parameterized.Parameters\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0@JvmStatic\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fun getData(): Collection<Array<Int>> = listOf(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(0, 1),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(1, 1),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(2, 2),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(3, 6),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(4, 24),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(5, 120)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0)\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0private val myClass = MyClass()\n\u00a0\u00a0\u00a0\u00a0@Test\n\u00a0\u00a0\u00a0\u00a0fun computesFactorial() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val result = myClass.factorial(input)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assertEquals(expected, result)\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```kt\nfun factorial(n: Int): Int {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return IntArray(n) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0it + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}.fold(1, { acc, i -> acc * i })\n\u00a0\u00a0\u00a0\u00a0}\n```", "```kt\nclass MyClassTest2 {\n\u00a0\u00a0\u00a0\u00a0private val myClass = MyClass()\n\u00a0\u00a0\u00a0\u00a0@Test(expected = MyClass.FactorialNotFoundException::class)\n\u00a0\u00a0\u00a0\u00a0fun computeNegatives() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0myClass.factorial(-10)\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```kt\nclass MyClass {\n\u00a0\u00a0\u00a0\u00a0@Throws(FactorialNotFoundException::class)\n\u00a0\u00a0\u00a0\u00a0fun factorial(n: Int): Int {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (n < 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw FactorialNotFoundException\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return IntArray(n) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0it + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}.fold(1, { acc, i -> acc * i })\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0object FactorialNotFoundException : Throwable()\n}\n```", "```kt\n@RunWith(Parameterized::class)\nclass MyClassTest(\n\u00a0\u00a0\u00a0\u00a0private val input: Int,\n\u00a0\u00a0\u00a0\u00a0private val expected: BigInteger\n) {\n\u00a0\u00a0\u00a0\u00a0companion object {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0@Parameterized.Parameters\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0@JvmStatic\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fun getData(): Collection<Array<Any>> = listOf(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(0, BigInteger.ONE),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(1, BigInteger.ONE),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(2, BigInteger.valueOf(2)),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(3, BigInteger.valueOf(6)),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(4, BigInteger.valueOf(24)),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(5, BigInteger.valueOf(120)),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(13, BigInteger(\"6227020800\")),\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arrayOf(25, BigInteger(\"15511210043330985984000000\"))\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0)\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0private val myClass = MyClass()\n\u00a0\u00a0\u00a0\u00a0@Test\n\u00a0\u00a0\u00a0\u00a0fun computesFactorial() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val result = myClass.factorial(input)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assertEquals(expected, result)\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```kt\n\u00a0\u00a0\u00a0\u00a0@Throws(FactorialNotFoundException::class)\n\u00a0\u00a0\u00a0\u00a0fun factorial(n: Int): BigInteger {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (n < 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw FactorialNotFoundException\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return IntArray(n) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0it + 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}.fold(BigInteger.ONE, { acc, i -> acc * i.toBigInteger() })\n\u00a0\u00a0\u00a0\u00a0}\n```", "```kt\n\u00a0\u00a0\u00a0\u00a0@Throws(FactorialNotFoundException::class)\n\u00a0\u00a0\u00a0\u00a0fun factorial(n: Int): BigInteger {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (n < 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw FactorialNotFoundException\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var result = BigInteger.ONE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (i in 1..n){\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = result.times(i.toBigInteger())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return result\n\u00a0\u00a0\u00a0\u00a0}\n```", "```kt\n\u00a0\u00a0\u00a0\u00a0companion object {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0var result: BigInteger = BigInteger.ONE\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0@Throws(FactorialNotFoundException::class)\n\u00a0\u00a0\u00a0\u00a0fun factorial(n: Int): BigInteger {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (n < 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0throw FactorialNotFoundException\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (i in 1..n) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result = result.times(i.toBigInteger())\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return result\n\u00a0\u00a0\u00a0\u00a0}\n```", "```kt\n\u00a0\u00a0\u00a0\u00a0@Before\n\u00a0\u00a0\u00a0\u00a0fun setUp(){\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MyClass.result = BigInteger.ONE\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0@After\n\u00a0\u00a0\u00a0\u00a0fun tearDown(){\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MyClass.result = BigInteger.ONE\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0@Test\n\u00a0\u00a0\u00a0\u00a0fun computesFactorial() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val result = myClass.factorial(input)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assertEquals(expected, result)\n\u00a0\u00a0\u00a0\u00a0}\n```", "```kt\nclass ResultRule : TestRule {\n\u00a0\u00a0\u00a0\u00a0override fun apply(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0base: Statement,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0description: Description?\n\u00a0\u00a0\u00a0\u00a0): Statement? {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return object : Statement() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0@Throws(Throwable::class)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0override fun evaluate() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MyClass.result = BigInteger.ONE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0try {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0base.evaluate()\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} finally {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0MyClass.result = BigInteger.ONE\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```kt\n\u00a0\u00a0\u00a0\u00a0@JvmField\n\u00a0\u00a0\u00a0\u00a0@Rule\n\u00a0\u00a0\u00a0\u00a0val resultRule = ResultRule()\n\u00a0\u00a0\u00a0\u00a0private val myClass = MyClass()\n\u00a0\u00a0\u00a0\u00a0@Test\n\u00a0\u00a0\u00a0\u00a0fun computesFactorial() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val result = myClass.factorial(input)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assertEquals(expected, result)\n\u00a0\u00a0\u00a0\u00a0}\n```", "```kt\ntestImplementation 'org.mockito:mockito-core:3.6.0'\n```", "```kt\nclass StringConcatenator(private val context: Context) {\n\u00a0\u00a0\u00a0\u00a0fun concatenate(@StringRes stringRes1: Int, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0@StringRes stringRes2: Int): String {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return context.getString(stringRes1).plus(context\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.getString(stringRes2))\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```kt\nclass StringConcatenatorTest {\n\u00a0\u00a0\u00a0\u00a0private val context = Mockito.mock(Context::class.java)\n\u00a0\u00a0\u00a0\u00a0private val stringConcatenator = StringConcatenator(context)\n\u00a0\u00a0\u00a0\u00a0@Test\n\u00a0\u00a0\u00a0\u00a0fun concatenate() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val stringRes1 = 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val stringRes2 = 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val string1 = \"string1\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val string2 = \"string2\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Mockito.`when`(context.getString(stringRes1)).thenReturn(string1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Mockito.`when`(context.getString(stringRes2)).thenReturn(string2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val result = stringConcatenator.concatenate(stringRes1,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stringRes2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assertEquals(string1.plus(string2), result)\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```kt is an escape character present in Kotlin and should not be confused with a quote mark. It allows the developer to give methods any name that they want, including special characters or reserved words.\n\nIn the test, we have created a `mock` context. When the `concatenate` method was tested, we used Mockito to return a specific string when the `getString()` method was called with a particular input. This allowed us to then assert the final result.\n\nMockito is not limited to mocking Android Framework classes only. We can create a `SpecificStringConcatenator` class that will use `StringConcatenator` to concatenate two specific strings from `strings.xml`:\n\n```", "```kt\n\nWe can write the test for it as follows:\n\n```", "```kt\n\nHere, we are mocking the previous `StringConcatenator` and instructing the mock to return a specific result. If we run the test, it will fail because Mockito is limited to mocking final classes. Here, it encounters a conflict with Kotlin that makes all classes *final* unless we specify them as *open*. Luckily, there is a configuration we can apply that solves this dilemma without making the classes under test *open*:\n\n1.  Create a folder named `resources` in the `test` package.\n2.  In `resources`, create a folder named `mockito-extensions`.\n3.  In the `mockito-extensions` folder, create a file named `org.mockito.plugins.MockMaker`.\n4.  Inside the file, add the following line:\n\n    ```", "```kt\n\nIn situations where you have callbacks or asynchronous work and cannot use the JUnit assertions, you can use `mockito` to verify the invocation on the callback or\u00a0lambdas:\n\n```", "```kt\n\nIn the preceding example, we have added the `concatenateWithCallback` method, which will invoke the callback with the result of the `concatenateSpecificStrings` method. The test for this method would look something like this:\n\n```", "```kt\n\nHere, we are creating a mock `Callback` object, which we can then verify at the end with the expected result. Notice that we had to duplicate the setup of the `concatenateSpecificStrings` method in order to test the `concatenateWithCallback` method. You should never mock the objects you are testing; however, you can use `spy` to change their behavior. We can spy the `stringConcatenator` object in order to change the outcome of the `concatenateSpecificStrings` method:\n\n```", "```kt\n\nMockito also relies on dependency injection to initialize class variables and has a custom build JUnit test runner. This can simplify the initialization of our variables, as\u00a0follows:\n\n```", "```kt\n\nIn the preceding example, `MockitoRunner` will inject the variables with the `@Mock` annotation with mocks. Next, it will create a new non-mocked instance of the field with the `@InjectionMocks` annotation. When this instance is created, Mockito will try to inject the mock objects that will match the signature of the constructor of that\u00a0object.\n\n## mockito-kotlin\n\nYou may have noticed, in the preceding example, that the `when` method from Mockito has escaped. This is because of a conflict with the Kotlin programming language. Mockito is built mainly for Java, and when Kotlin was created, it introduced this keyword. Conflicts like this are escaped using the ```", "```kt\ntestImplementation \"com.nhaarman.mockitokotlin2:mockito-kotlin:2.2.0\"\n```", "```kt\nclass StringConcatenatorTest {\n\u00a0\u00a0\u00a0\u00a0private val context = mock<Context>()\n\u00a0\u00a0\u00a0\u00a0private val stringConcatenator = StringConcatenator(context)\n\u00a0\u00a0\u00a0\u00a0@Test\n\u00a0\u00a0\u00a0\u00a0fun concatenate() {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val stringRes1 = 1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val stringRes2 = 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val string1 = \"string1\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val string2 = \"string2\"\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0whenever(context.getString(stringRes1)).thenReturn(string1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0whenever(context.getString(stringRes2)).thenReturn(string2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0val result =           stringConcatenator.concatenate(stringRes1, stringRes2)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0assertEquals(string1.plus(string2), result)\n\u00a0\u00a0\u00a0\u00a0}\n}\n```", "```kt character has disappeared, and our mock initialization for the `Context` object has been simplified. We can apply the same thing for the `SpecificConcatenatorTest` class (import statements have been removed for\u00a0brevity):\n\n```", "```kt\n\n## Exercise 9.01: Testing the Sum of Numbers\n\nUsing JUnit, Mockito, and `mockito-kotlin`, write a set of tests for the following class that should cover the following scenarios:\n\n*   Assert the values for `0`, `1`, `5`, `20`, and `Int.MAX_VALUE`.\n*   Assert the outcome for a negative number.\n*   Fix the code and replace the sum of numbers with the formula *n*(n+1)/2*.\n\n    Note\n\n    Throughout this exercise, import statements are not shown. To see full code files, refer to [http://packt.live/35TW8JI](http://packt.live/35TW8JI)):\n\nThe code to test is as follows.\n\n```", "```kt\n\nPerform the following steps to complete this exercise:\n\n1.  Let's make sure the necessary libraries are added to the `app/build.gradle`\u00a0file:\n\n    ```", "```kt\n\n2.  Create a class named `NumberAdder` and copy the preceding code inside it.\n3.  Move the cursor inside the newly created class and, with *Command* + *Shift* + *T* or *Ctrl* + *Shift* + *T*, create a test class called `NumberAdderParameterTest`.\n4.  Create a parametrized test inside this class that will assert the outcomes for the `0`, `1`, `5`, `20`, and `Int.MAX_VALUE` values:\n\n    ```", "```kt\n\n5.  Create a separate test class that handles the exception thrown when there are negative numbers, named `NumberAdderErrorHandlingTest`:\n\n    ```", "```kt\n\n6.  Since *1 + 2 + ...n = n * (n + 1) / 2*, we can use the formula in the code and this would make the execution of the method run faster:\n\n    ```", "```kt\n\nRun the tests by right-clicking the package in which the tests are located and selecting `Run all in [package_name]`. An output similar to the following will appear, signifying that the tests have passed:\n\n![Figure 9.5: Output of Exercise 9.01\n](img/B15216_09_05.jpg)\n\nFigure 9.5: Output of Exercise 9.01\n\nBy completing this exercise, we have taken the first steps into unit testing, managed to create multiple test cases for a single operation, taken the first steps into understanding Mockito, and used tests to guide us on how to refactor code without introducing any new issues.\n\n# Integration Tests\n\nLet's assume your project is covered by unit tests where a lot of your logic is held. You now have to add these tested classes to an activity or a fragment and require them to update your UI. How can you be certain that these classes will work well with each other? The answer to that question is through integration testing. The idea behind this type of testing is to ensure that different components within your application integrate well with each other. Some examples include the following:\n\n*   Ensuring that your API-related components parse the data well and interact well with your storage components.\n*   The storage components are capable of storing and retrieving the data correctly.\n*   The UI components load and display the appropriate data.\n*   The transition between different screens in your application.\n\nTo aid with integration testing, the requirements are sometimes written in the format `Given - When - Then`. These usually represent acceptance criteria for a user story. Take the following example:\n\n```", "```kt\n\nWe can use these steps to approach how we can write the integration tests for the feature we are developing.\n\nOn the Android platform, integration testing can be achieved with two libraries:\n\n*   **Robolectric**: This library gives developers the ability to test Android components as unit tests; that is, executing integration tests without an actual device or\u00a0emulator.\n*   **Espresso**: This library is helpful in instrumentation tests on an Android device or\u00a0emulator.\n\nWe'll have a look at these libraries in detail in the next sections.\n\n## Robolectric\n\nRobolectric started as an open source library that was meant to give users the ability to unit test classes from the Android framework as part of their local tests instead of the instrumented tests. Recently, it has been endorsed by Google and has been integrated with AndroidX Jetpack components. One of the main benefits of this library is the simplicity of testing activities and fragments. This is a benefit when it comes to integration tests because we can use this feature to make sure that our components integrate well with each other. Some of Robolectric's features are as follows:\n\n*   The possibility to instantiate and test the activity and fragment life cycle\n*   The possibility to test view inflation\n*   The possibility to provide configurations for different Android APIs, orientations, screen size, layout direction, and so on\n*   The possibility to change the `Application` class, which then helps to change the modules to permit data mocks to be inserted\n\nIn order to add Robolectric, along with the AndroidX integration, we will need the following libraries:\n\n```", "```kt\n\nThe second library will bring a set of `utility` methods and classes required for testing Android components.\n\nLet's assume we have to deliver a feature in which we display the text `Result x`, where `x` is the factorial function for a number that the user will insert in the `EditText` element. In order to achieve this, we have two classes, one that computes the factorial and another that concatenates the word `Result` with the factorial if the number is positive, or it will return the text `Error` if the number is negative. The factorial class will look something like this (throughout this example, import statements have been removed for brevity):\n\n```", "```kt\n\nThe `TextFormatter` class will look like this:\n\n```", "```kt\n\nWe can combine these two components in our activity and have something similar to\u00a0this:\n\n```", "```kt\n\nWe can observe three components interacting with each other in this case. We can use Robolectric to test our activity. By testing the activity that creates the components, we can also test the interaction between all three of the components. We can write a test that looks like this:\n\n```", "```kt\n\nIn the preceding example, we can see the AndroidX support for the activity test. The `AndroidJUnit4` test runner will set up Robolectric and create the necessary configurations, while the `launch` method will return a `scenario` object, which we can then play with in order to achieve the necessary conditions for the test.\n\nIf we want to add configurations for the test, we can use the `@Config` annotation both on the class and on each of the test methods:\n\n```", "```kt\n\nWe can also specify global configurations in the `test/resources` folder in the `robolectric.properties` file, like so:\n\n```", "```kt\n\nAnother important feature that has recently been added to Robolectric is support for the Espresso library. This allows developers to use the syntax from Espresso in order to interact with views and make assertions on the views. Another library that can be used in combination with Robolectric is `FragmentScenario`, which allows the possibility to test fragments. These libraries can be added in Gradle using the\u00a0following:\n\n```", "```kt\n\nTesting fragments is similar to activities using the `scenario` setup:\n\n```", "```kt\n\n## Espresso\n\nEspresso is a library designed to perform interactions and assertions in a concise way. It was initially designed to be used in instrumented tests and now it has migrated to be used with Robolectric as well. The typical usage for performing an action is as\u00a0follows:\n\n```", "```kt\n\nFor verification, we can use the following:\n\n```", "```kt\n\nWe can provide custom `ViewMatchers` if none can be found in the `ViewMatchers` class. Some of the most common ones are `withId` and `withText`. These two allow us to identify views based on their `R.id.myId` identifier or the text identifier. Ideally, the first one should be used to identify a particular view. Another interesting aspect of Espresso is the reliance on the `Hamcrest` library for matchers. This is a Java library that aims to improve testing. This allows multiple matchers to be combined if necessary. Let's say that the same ID is present in different views on your UI. You can narrow your search for a specific view using the following expression:\n\n```", "```kt\n\nThe `allOf` expression will evaluate all of the other operators and will pass only if all of the operators inside will pass. The preceding expressions will translate to \"Find the view with `id=edit_text` that has the parent with `id=R.id.root`.\" Other `Hamcrest` operators may include `anyOf`, `both`, `either`, `is`, `isA`, `hasItem`, `equalTo`, `any`, `instanceOf`, `not`, `null`, and `notNull`.\n\n`ViewActions` have a similar approach to `ViewMatchers`. We can find common ones in the `ViewActions` class. Common ones include `typeText`, `click`, `scrollTo`, `clearText`, `swipeLeft`, `swipeRight`, `swipeUp`, `swipeDown`, `closeSoftKeyboard`, `pressBack`, `pressKey`, `doubleClick`, and `longClick`. If you have custom views and certain actions are required, then you can implement your own `ViewAction` element by implementing the `ViewAction` interface.\n\nSimilar to the preceding examples, `ViewAssertions` have their own class. Typically, the `matches` method is used where you can then use `ViewMatchers` and `Hamcrest` matchers to validate the result:\n\n```", "```kt\n\nThe preceding example will verify that the view with the `text_view` ID will contain the text `My text`:\n\n```", "```kt\n\nThis will click the view with the ID button.\n\nWe can now rewrite the Robolectric test and add Espresso, which will give us this (import statement not shown):\n\n```", "```kt\n\nIn the preceding code sample, we can observe how, using Espresso, we input the number `5` in `EditText`, then click on the button, and then assert the text displayed in `TextView` with the help of the `onView()` method to obtain a reference to the view, and then execute actions using `perform()` or make assertions using\u00a0`check()`.\n\nNote\n\nFor the following exercise, you will need an emulator or a physical device with USB debugging enabled. You can do so by selecting `Tools` | `AVD Manager` in Android Studio. Then, you can create one with the `Create Virtual Device` option by selecting the type of emulator, clicking `Next`, and then selecting an x86 image. Any image larger than Lollipop should be alright for this exercise. Next, you can give your image a name and click `Finish`.\n\n## Exercise 9.02: Double Integration\n\nDevelop an application that observes the following requirements:\n\n```", "```kt\n\nYou should implement both unit tests and integration tests using Robolectric and Espresso, and migrate the integration tests to become instrumentation tests.\n\nNote\n\nThroughout this exercise, import statements are not shown. To see full code files, refer to [http://packt.live/2M1MtcY](http://packt.live/2M1MtcY)):\n\nImplement the following steps to complete this exercise:\n\n1.  Let's start by adding the necessary test libraries to `app/build.gradle`:\n\n    ```", "```kt\n\n2.  For Robolectric, we will need to add extra configurations, the first of which is to add the following line to `app/build.gradle` in the `android` closure:\n\n    ```", "```kt\n\n3.  Create a `resources` directory in the `test` package.\n4.  Add the `robolectric.properties` file and add the following configuration to that file:\n\n    ```", "```kt\n\n5.  Create a folder named `resources` in the test package.\n6.  In `resources`, create a folder named `mockito-extensions`.\n7.  In the `mockito-extensions` folder, create a file named `org.mockito.plugins.MockMaker`, and inside the file, add the following line:\n\n    ```", "```kt\n\n8.  Create the `NumberAdder` class. This is similar to the one in *Exercise 9.01*:\n\n    ```", "```kt\n\n9.  Create the tests for `NumberAdder` in the `test` folder. First, create `NumberAdderParameterTest`:\n\n    ```", "```kt\n\n10.  Then, create the `NumberAdderErrorHandlingTest` test:\n\n    ```", "```kt\n\n11.  Create a class that will format the sum and concatenate it with the necessary\u00a0strings:\n\n    ```", "```kt\n\n12.  Unit test this class for both the success and error scenarios. Start with the success scenario:\n\n    ```", "```kt\n\n    Then, create the test for the error scenario:\n\n    ```", "```kt\n\n13.  Create the layout for `activity_main.xml`:\n\n    ```", "```kt\n\n14.  Create the `MainActivity` class, which will contain all the other components:\n\n    ```", "```kt\n\n15.  Create a test for `MainActivity` and place it in the `test` directory. It will contain two test methods, one for success and one for error:\n\n    ```", "```kt\n\n    If you run the tests by right-clicking the package in which the tests are located and select `Run all in [package_name]`, then an output similar to the following will appear:\n\n    ![Figure 9.6: Result of executing the tests in the test folder for Exercise 9.02\n    ](img/B15216_09_06.jpg)\n\n    Figure 9.6: Result of executing the tests in the test folder for Exercise 9.02\n\n    If you execute the preceding tests, you should see an output similar to *Figure 9.6*. The Robolectric test is executed in the same way as a regular unit test; however, there is an increase in the execution time.\n\n16.  Let's now migrate the preceding test to an instrumented integration test. In order to do this, we will copy the preceding test from the `test` package into the `androidTest` package and remove the code related to scenarios from our tests. After copying the file, we will use `ActivityTestRule`, which will launch our activity before every test is executed. We will also need to rename the class to avoid duplicates and rename the test methods because the syntax is not supported for instrumented tests:\n\n    ```", "```kt\n\n    If you run the tests by right-clicking the package in which the tests are located and select `Run all in [package_name]`, then an output similar to the following will appear:\n\n![Figure 9.7: Result of executing the tests in the androidTest folder for Exercise 9.02\n](img/B15216_09_07.jpg)\n\nFigure 9.7: Result of executing the tests in the androidTest folder for Exercise 9.02\n\nIn *Figure 9.7*, we can see what Android Studio displays as an output for the result. If you pay attention to the emulator while the tests are executing, you can see that for each test, your activity will be opened, the input will be set in the field, and the button will be clicked. Both of our integration tests (on the workstation and the emulator) try to match the accepted criteria of the requirement. The integration tests verify the same behavior, the only difference being that one checks it locally and the other checks it on an Android device or emulator. The main benefit here is the fact that Espresso was able to bridge the gap between them, making integration tests easier to set up and execute.\n\n# UI Tests\n\nUI tests are instrumented tests where developers can simulate user journeys and verify the interactions between different modules of the application. They are also referred to as end-to-end tests. For small applications, you can have one test suite, but for larger applications, you should split your test suites to cover particular user journeys (logging in, creating an account, setting up flows, and so on). Because they are executed on the device, you will need to write them in the `androidTest` package, which means they will run with the **Instrumentation** framework. Instrumentation works as follows:\n\n*   The app is built and installed on the device.\n*   A testing app will also be installed on the device that will monitor your app.\n*   The testing app will execute the tests on your app and record the results.\n\nOne of the drawbacks of this is the fact that the tests will share persisted data, so if a test stores data on the device, then the second test can have access to that data, which means that there is a risk of failure. Another drawback is that if a test comes across a crash, this will stop the entire testing because the application under test is stopped. These issues were solved in the Jetpack updates with the introduction of the `app/build.gradle` file:\n\n```", "```kt\n\nYou can execute the orchestrator test on a connected device using Gradle's `connectedCheck` command, either from `Terminal` or from the list of Gradle\u00a0commands.\n\nIn the configuration, you will notice the following line: `testInstrumentationRunner`. This allows us to create a custom configuration for the test, which gives us the opportunity to inject mock data into the modules:\n\n```", "```kt\n\n`CustomTestRunner` looks like this (import statements not shown in following code\u00a0snippets):\n\n```", "```kt\n\nThe test classes themselves can be written by applying the JUnit4 syntax with the help of the `androidx.test.ext.junit.runners.AndroidJUnit4` test runner:\n\n```", "```kt\n\nAnother important feature that comes from the AndroidX testing support is the activity rule. When this rule is used with the default constructor, the activity will be launched before each test and will be ready for interactions and assertions:\n\n```", "```kt\n\nYou can also use the rule to avoid starting the activity and customize the intent used to start it in your test:\n\n```", "```kt\n\nThe `@Test` methods themselves run in a dedicated test thread, which is why a library such as Espresso is helpful. Espresso will automatically move every interaction with a view on the UI thread. Espresso can be used for UI tests in a similar way as it is used with Robolectric tests:\n\n```", "```kt\n\nTypically, in UI tests, you will find interactions and assertions that may get repetitive. In order to avoid duplicating multiple scenarios in your code, you can apply a pattern called `Robot` class in which the interactions and assertions can be grouped into specific methods. Your test code will use the robots and assert them. A typical robot will look something like this:\n\n```", "```kt\n\nThe test will look like this:\n\n```", "```kt\n\nBecause apps can be multithreaded and sometimes it takes a while to load data from various sources (internet, files, local storage, and so on), the UI tests will have to know when the UI is available for interactions. One way to implement this is through the usage of idling resources. These are objects that can be registered to Espresso before the test and injected into your application's components where multithreaded work is done. The apps will mark them as non-idle when the work is in progress and idle when the work is done. It is at this point where Espresso will then start executing the test. One of the most commonly used ones is `CountingIdlingResource`. This specific implementation uses a counter that should be incremented when you want Espresso to wait for your code to complete its execution and decremented when you want to let Espresso verify your code. When the counter reaches `0`, Espresso will resume testing. An example of a component with an idling resource looks something like this:\n\n```", "```kt\n\nThe `Application` class can be used to inject the idling resource, like this:\n\n```", "```kt\n\nThen, in the test, we can access the `Application` class and register the resource to\u00a0Espresso:\n\n```", "```kt\n\nEspresso comes with a set of extensions that can be used to assert different Android components. One extension is intents testing. This is useful when you want to test an activity in isolation (more appropriate for integration tests). In order to use this, you need to add the library to Gradle:\n\n```", "```kt\n\nAfter you add the library, you need to use `IntentsTestRule` in order to set up the necessary intent monitoring. This rule is a subclass of `ActivityTestRule`:\n\n```", "```kt\n\nIn order to assert the values of the intent, you need to trigger the appropriate action and then use the `intended` method:\n\n```", "```kt\n\nThe `intended` method works in a similar way to the `onView` method. It requires a matcher that can be combined with a `Hamcrest` matcher. The intent-related matchers can be found in the `IntentMatchers` class. This class contains methods to assert different methods of the `Intent` class: extras, data, components, bundles, and so on.\n\nAnother important extension library comes to the aid of `RecyclerView`. The `onData` method from Espresso is only capable of testing `AdapterViews` such as `ListView` and isn't capable of asserting `RecyclerView`. In order to use the extension, you need to add the following library to your project:\n\n```", "```kt\n\nThis library provides a `RecyclerViewActions` class, which contains a set of methods that allow you to perform actions on items inside `RecyclerView`:\n\n```", "```kt\n\nThe preceding statement will click the item at position `0`:\n\n```", "```kt\n\nThis will scroll to the tenth item in the list:\n\n```", "```kt\n\nThe preceding code will check whether a view with the `myText` text is displayed, which will also apply to `RecyclerView` items.\n\n## Exercise 9.03: Random Waiting Times\n\nWrite an application that will have two screens. The first screen will have a button. When the user presses the button, it will wait a random time between 1 and 5 seconds and then launch the second screen, which will display the text `Opened after x seconds`, where `x` is the number of seconds that passed. Write a UI test that will cover this scenario with the following features adjusted for the test:\n\n*   The `random` function will return the value `1` when the test is run.\n*   `CountingIdlingResource` will be used to indicate when the timer has\u00a0stopped.\n\n    Note\n\n    Throughout this exercise, import statements are not shown. To see full code files, refer to [http://packt.live/38V7krh](http://packt.live/38V7krh)):\n\nTake the following steps to complete this exercise:\n\n1.  Add the following libraries to `app/build.gradle`:\n\n    ```", "```kt\n\n2.  Then, start with a `Randomizer` class:\n\n    ```", "```kt\n\n3.  Next, create a `Synchronizer` class, which will use `Randomizer` and `Timer` to wait for the random time interval. It will also use `CountingIdlingResource` to mark the start of the task and the end of the task:\n\n    ```", "```kt\n\n4.  Now create an `Application` class that will be responsible for creating all the instances of the preceding classes:\n\n    ```", "```kt\n\n5.  Add the `MyApplication` class to `AndroidManifest` in the `application` tag with the `android:name` attribute.\n6.  Create an `activity_1` layout file, which will contain a parent layout and a\u00a0button:\n\n    ```", "```kt\n\n7.  Create an `activity_2` layout file, which will contain a parent layout and\u00a0`TextView`:\n\n    ```", "```kt\n\n8.  Create the `Activity1` class, which will implement the logic for the button click:\n\n    ```", "```kt\n\n9.  Create the `Activity2` class, which will display the received data through the\u00a0intent:\n\n    ```", "```kt\n\n10.  Create a `FlowTest` class in the `androidTest` directory, which will register `IdlingResource` from the `MyApplication` object and will assert the outcome of the click:\n\n    ```", "```kt\n\n11.  Run the test multiple times and check the test results. Notice that the test will have a 20% chance of success, but it will wait until the button is clicked. This means that the idling resource is working. Another thing to observe is that there is an element of randomness here.\n12.  Tests don't like randomness, so we need to eliminate it by making the `Randomizer` class open and create a sub-class in the `androidTest` directory. We can do the same for the `MyApplication` class and provide a different randomizer called `TestRandomizer`:\n\n    ```", "```kt\n\n13.  Now, modify the `MyApplication` class in a way in which we can override the randomizer from a subclass:\n\n    ```", "```kt\n\n14.  In the `androidTest` directory, create `TestMyApplication`, which will extend `MyApplication` and override the `createRandomizer` method:\n\n    ```", "```kt\n\n15.  Finally, create an instrumentation test runner that will use this new `Application` class inside the test:\n\n    ```", "```kt\n\n16.  Add the new test runner to the Gradle configuration:\n\n    ```", "```kt\n\n    By running the test now, everything should pass similar to *Figure 9.8*:\n\n![Figure 9.8: Output of Exercise 9.03\n](img/B15216_09_08.jpg)\n\nFigure 9.8: Output of Exercise 9.03\n\nThis type of exercise shows how to avoid randomness in a test and provide concrete and repeatable inputs to make our tests reliable. Similar approaches are taken with dependency injection frameworks where entire modules can be replaced in the test suite in order to ensure the test's reliability. One of the most common things to be replaced is API communication. Another issue this approach solves is the decrease in waiting time. If this type of scenario were to have been repeated across your tests, then the execution time of them would have increased as a result of this.\n\n# Test-Driven Development\n\nLet's assume that you are tasked with building an activity that displays a calculator with the add, subtract, multiply, and divide options. You must also write tests for your implementation. Typically, you would build your UI and your activity and a separate `Calculator` class. Then, you would write the unit tests for your `Calculator` class and then your activity class.\n\nUnder the `Calculator` test. Here, you would also need to create the necessary methods in the `Calculator` class to avoid compile-time errors.\n\nIf you run your tests in this phase, they would fail. This would force you to implement your code until the tests pass. Once your `Calculator` tests pass, you can connect your calculator to your UI until your UI tests pass. While this seems like a counter-intuitive approach, it solves two issues once the process is mastered:\n\n*   Less time will be spent writing code because you will ensure that your code is testable, and you need to write only the amount of code necessary for the test to\u00a0pass.\n*   Fewer bugs will be introduced because developers will be able to analyze different outcomes.\n\nHave a look at the following diagram, which shows the TDD cycle:\n\n![Figure 9.9: TDD cycle\n](img/B15216_09_09.jpg)\n\nFigure 9.9: TDD cycle\n\nIn the preceding figure, we can see the development cycle in a TDD process. You should start from a point where your tests are failing. Implement changes in order for the tests to pass. When you update or add new features, you can repeat the process.\n\nGoing back to our factorial examples, we started with a factorial function that didn't cover all our scenarios and had to keep updating the function every time a new test was added. TDD is built with that idea in mind. You start with an empty function. You start defining your testing scenarios: What are the conditions for success? What's the minimum? What's the maximum? Are there any exceptions from the main rule? What are they? These questions can help developers define their test cases. Then, these cases can be written. Let's now see how this can be done practically through the next\u00a0exercise.\n\n## Exercise 9.04: Using TDD to Calculate the Sum of Numbers\n\nWrite a function that will take as input the integer *n* and will return the sum of numbers from 1 to *n*. The function should be written with a TDD approach, and the following criteria should be satisfied:\n\n*   For *n<=0*, the function will return the value `-1`.\n*   The function should be able to return the correct value for `Int.MAX_VALUE`.\n*   The function should be quick, even for `Int.MAX_VALUE`.\n\n    Note\n\n    Throughout this exercise, import statements are not shown. To see full code files, refer to [http://packt.live/3a0jJd9](http://packt.live/3a0jJd9)):\n\nPerform the following steps to complete this exercise:\n\n1.  Make sure that the following library is added to `app/build.gradle`:\n\n    ```", "```kt\n\n2.  Create an `Adder` class with the `sum` method, which will return `0`, to satisfy the\u00a0compiler:\n\n    ```", "```kt\n\n3.  Create an `AdderTest` class in the test directory and define our test cases. We will have the following test cases: *n=1*, *n=2*, *n=0*, *n=-1*, *n=10*, *n=20*, and *n=Int.MAX_VALUE*. We can split the successful scenarios into one method and the unsuccessful ones into a separate method:\n\n    ```", "```kt\n\n4.  If we run the tests for the `AdderTest` class, we will see an output similar to the following figure, meaning that all our tests failed:![Figure 9.10: Initial test status for Exercise 9.04\n    ](img/B15216_09_10.jpg)\n\n    Figure 9.10: Initial test status for Exercise 9.04\n\n5.  Let's first address the success scenarios by implementing the sum in a loop from 1 to *n*:\n\n    ```", "```kt\n\n6.  If we run the tests now, you will see that one will pass and the other will fail, similar to the following figure:![Figure 9.11: Test status after resolving the success scenario for Exercise 9.04\n    ](img/B15216_09_11.jpg)\n\n    Figure 9.11: Test status after resolving the success scenario for Exercise 9.04\n\n7.  If we take a look at the time it took to execute the successful test, it seems a bit long. This can add up when thousands of unit tests are present in one project. We can now optimize our code to deal with the issue by applying the *n(n+1)/2*\u00a0formula:\n\n    ```", "```kt\n\n    Running the tests now will drastically reduce the speed to a few milliseconds.\n\n8.  Now, let's focus on solving our failure scenarios. We can do this by adding a condition for when *n* is smaller than or equal to `0`:\n\n    ```"]