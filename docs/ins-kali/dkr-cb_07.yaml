- en: Chapter 7. Docker Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。Docker性能
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Benchmarking CPU performance
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试CPU性能
- en: Benchmarking disk performance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试磁盘性能
- en: Benchmarking network performance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试网络性能
- en: Getting container resource usage using the stats feature
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用统计功能获取容器资源使用情况
- en: Setting up performance monitoring
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置性能监控
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In [Chapter 3](part0038.xhtml#aid-147LC1 "Chapter 3. Working with Docker Images"),
    *Working with Docker Images*, we saw, how Dockerfiles can be used to create images
    consisting of different services/software and later in [Chapter 4](part0055.xhtml#aid-1KEEU2
    "Chapter 4. Network and Data Management for Containers"), *Network and Data Management
    for Containers*, we saw, how one Docker container can talk to the outside world
    with respect to data and network. In [Chapter 5](part0062.xhtml#aid-1R42S1 "Chapter 5. Docker
    Use Cases"), *Docker Use Cases*, we looked into the different use cases of Docker,
    and in [Chapter 6](part0069.xhtml#aid-21PMQ1 "Chapter 6. Docker APIs and Language
    Bindings"), *Docker APIs and Language Bindings*, we looked at how to use remote
    APIs to connect to a remote Docker host.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](part0038.xhtml#aid-147LC1 "第3章。使用Docker镜像")中，*使用Docker镜像*，我们看到了Dockerfile如何用于创建由不同服务/软件组成的镜像，稍后在[第4章](part0055.xhtml#aid-1KEEU2
    "第4章。容器的网络和数据管理")中，*容器的网络和数据管理*，我们看到了一个Docker容器如何与外部世界进行数据和网络交流。在[第5章](part0062.xhtml#aid-1R42S1
    "第5章。Docker使用案例")中，*Docker使用案例*，我们研究了Docker的不同使用案例，在[第6章](part0069.xhtml#aid-21PMQ1
    "第6章。Docker API和语言绑定")中，*Docker API和语言绑定*，我们看到了如何使用远程API连接到远程Docker主机。
- en: 'Ease of use is all good, but before going into production, performance is one
    of the key aspects that is considered. In this chapter, we''ll see the performance
    impacting features of Docker and what approach we can follow to benchmark different
    subsystems. While doing performance evaluation, we need to compare Docker performance
    against the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 易用性都很好，但在投入生产之前，性能是考虑的关键因素之一。在本章中，我们将看到Docker的性能影响特性以及我们可以遵循的基准测试不同子系统的方法。在进行性能评估时，我们需要将Docker性能与以下进行比较：
- en: Bare metal
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裸金属
- en: Virtual machine
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机
- en: Docker running inside a virtual machine
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker在虚拟机内运行
- en: In the chapter, we will look at the approach you can follow to do performance
    evaluation rather than performance numbers collected from runs to do comparison.
    However, I'll point out performance comparisons done by different companies, which
    you can refer to.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨进行性能评估的方法，而不是从运行中收集的性能数据进行比较。但是，我会指出不同公司进行的性能比较，供您参考。
- en: 'Let''s first look at some of the Docker performance impacting features:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一些影响Docker性能的特性：
- en: '**Volumes**: While putting down any enterprise class workload, you would like
    to tune the underlying storage accordingly. You should not use the primary/root
    filesystem used by containers to store data. Docker provides the facility to attach/mount
    external storage through volumes. As we have seen in [Chapter 4](part0055.xhtml#aid-1KEEU2
    "Chapter 4. Network and Data Management for Containers"), *Network and Data Management
    for Containers*, there are two types of volumes, which are as follows:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**卷**：在放置任何企业级工作负载时，您希望相应地调整底层存储。您不应该使用容器使用的主/根文件系统来存储数据。Docker提供了通过卷附加/挂载外部存储的功能。正如我们在[第4章](part0055.xhtml#aid-1KEEU2
    "第4章。容器的网络和数据管理")中所看到的，*容器的网络和数据管理*，有两种类型的卷，如下所示：'
- en: Volumes that are mounted through host machines using the `--volume` option
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`--volume`选项通过主机机器挂载的卷
- en: Volumes that are mounted through another container using the `--volumes-from`
    option
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`--volumes-from`选项通过另一个容器挂载的卷
- en: '**Storage drivers**: We looked at different storage drivers in [Chapter 1](part0015.xhtml#aid-E9OE2
    "Chapter 1. Introduction and Installation"), *Installation and Introduction*,
    which are vfs, aufs, btrfs, devicemapper, and overlayFS. Support for ZFS has been
    merged recently as well. You can check the currently supported storage drivers
    and their priority of selection if nothing is chosen as the Docker start time
    at [https://github.com/docker/docker/blob/master/daemon/graphdriver/driver.go](https://github.com/docker/docker/blob/master/daemon/graphdriver/driver.go).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储驱动程序**：我们在[第1章](part0015.xhtml#aid-E9OE2 "Chapter 1. Introduction and Installation")中查看了不同的存储驱动程序，即vfs、aufs、btrfs、devicemapper和overlayFS。最近还合并了对ZFS的支持。您可以在[https://github.com/docker/docker/blob/master/daemon/graphdriver/driver.go](https://github.com/docker/docker/blob/master/daemon/graphdriver/driver.go)上检查当前支持的存储驱动程序及其选择优先级，如果没有选择Docker启动时间。'
- en: If you are running Fedora, CentOS, or RHEL, then the device mapper will be the
    default storage driver. You can find some device mapper specific tuning at [https://github.com/docker/docker/tree/master/daemon/graphdriver/devmapper](https://github.com/docker/docker/tree/master/daemon/graphdriver/devmapper).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行Fedora、CentOS或RHEL，则设备映射器将是默认的存储驱动程序。您可以在[https://github.com/docker/docker/tree/master/daemon/graphdriver/devmapper](https://github.com/docker/docker/tree/master/daemon/graphdriver/devmapper)找到一些特定于设备映射器的调整。
- en: 'You can change the default storage driver with the `-s` option to the Docker
    daemon. You can update the distribution-specific configuration/systems file to
    make changes across service restart. For Fedora/RHEL/CentOS, you will have the
    update `OPTIONS` field in `/etc/sysconfig/docker`. Something like the following
    to use the `btrfs` backend:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`-s`选项更改Docker守护程序的默认存储驱动程序。您可以更新特定于发行版的配置/系统文件，以在服务重新启动时进行更改。对于Fedora/RHEL/CentOS，您需要在`/etc/sysconfig/docker`中更新`OPTIONS`字段。类似以下内容可用于使用`btrfs`后端：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following graph shows you how much time it takes to start and stop 1,000
    containers with different configurations of storage driver:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了使用不同存储驱动程序配置启动和停止1,000个容器所需的时间：
- en: '![Introduction](../Images/image00375.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction](../Images/image00375.jpeg)'
- en: '[http://developerblog.redhat.com/2014/09/30/overview-storage-scalability-docker/](http://developerblog.redhat.com/2014/09/30/overview-storage-scalability-docker/)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developerblog.redhat.com/2014/09/30/overview-storage-scalability-docker/](http://developerblog.redhat.com/2014/09/30/overview-storage-scalability-docker/)'
- en: As you can see, overlayFS performs better than other storage drivers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，overlayFS的性能优于其他存储驱动程序。
- en: '**--net=host**: As we know, by default, Docker creates a bridge and associates
    IPs from it to the containers. Using `--net=host` exposes host networking stack
    to the container by skipping the creation of a network namespace for the container.
    From this, it is clear that this option always gives better performance compared
    to the bridged one.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--net=host**：我们知道，默认情况下，Docker会创建一个桥接，并将IP分配给容器。使用`--net=host`将主机网络堆栈暴露给容器，跳过为容器创建网络命名空间。由此可见，与桥接方式相比，此选项始终提供更好的性能。'
- en: This has some limitations, such as not being able to have two containers or
    host apps listening on the same port.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一些限制，比如不能让两个容器或主机应用程序监听相同的端口。
- en: '**Cgroups**: Docker''s default execution driver, `libcontainer`, exposes different
    Cgroups knobs, which can be used to fine tune container performance. Some of them
    are as follows:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cgroups**：Docker的默认执行驱动程序`libcontainer`公开了不同的Cgroups旋钮，可用于微调容器性能。其中一些如下：'
- en: '**CPU shares**: With this, we can give proportional weight to the containers
    and accordingly the resource will be shared. Consider the following example:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU份额**：通过这个，我们可以为容器分配比例权重，并相应地共享资源。考虑以下示例：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**CPUsets**: This allows you to create CPU masks, using which execution of
    threads inside a container on host CPUs is controlled. For example, the following
    code will run threads inside a container on the 0th and 3rd core:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPUsets：这允许您创建CPU掩码，使用它可以控制容器内线程在主机CPU上的执行。例如，以下代码将在容器内的第0和第3个核心上运行线程：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Memory limits**: We can set memory limits to a container. For example, the
    following command will limit the memory usage to 512 MB for the container:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存限制：我们可以为容器设置内存限制。例如，以下命令将限制容器的内存使用量为512 MB：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Sysctl and ulimit settings**: In a few cases, you might have to change some
    of the `sysclt` values depending on the use case to get optimal performance, such
    as changing the number of open files. With Docker 1.6 ([https://docs.docker.com/v1.6/release-notes/](https://docs.docker.com/v1.6/release-notes/))
    and above we can change the `ulimit` settings with the following command:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sysctl和ulimit设置：在某些情况下，您可能需要根据用例更改一些`sysclt`值以获得最佳性能，例如更改打开文件的数量。使用Docker 1.6（[https://docs.docker.com/v1.6/release-notes/](https://docs.docker.com/v1.6/release-notes/)）及以上版本，我们可以使用以下命令更改`ulimit`设置：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding command will change the settings for just that given container,
    it is a per container tuning variable. We can also set some of these settings
    through the systemd configuration file of Docker daemon, which will be applicable
    to all containers by default. For example, looking at the systemd configuration
    file for Docker on Fedora, you will see something like the following in the service
    section:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将仅更改给定容器的设置，这是一个每个容器的调整变量。我们还可以通过Docker守护程序的systemd配置文件设置其中一些设置，默认情况下将适用于所有容器。例如，在Fedora上查看Docker的systemd配置文件，您将在服务部分看到类似以下内容：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can update this as per your need.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要进行更新。
- en: 'You can learn about Docker performance by studying the work done by others.
    Over the last year, some Docker performance-related studies have been published
    by a few companies:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过研究他人的工作来了解Docker的性能。在过去一年中，一些公司已经发表了一些与Docker性能相关的研究：
- en: 'From Red Hat:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自Red Hat：
- en: 'Performance Analysis of Docker on Red Hat Enterprise Linux:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Red Hat Enterprise Linux上对Docker的性能分析：
- en: '[http://developerblog.redhat.com/2014/08/19/performance-analysis-docker-red-hat-enterprise-linux-7/](http://developerblog.redhat.com/2014/08/19/performance-analysis-docker-red-hat-enterprise-linux-7/)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developerblog.redhat.com/2014/08/19/performance-analysis-docker-red-hat-enterprise-linux-7/](http://developerblog.redhat.com/2014/08/19/performance-analysis-docker-red-hat-enterprise-linux-7/)'
- en: '[https://github.com/jeremyeder/docker-performance](https://github.com/jeremyeder/docker-performance)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/jeremyeder/docker-performance](https://github.com/jeremyeder/docker-performance)'
- en: 'Comprehensive Overview of Storage Scalability in Docker:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker中存储可扩展性的综合概述：
- en: '[http://developerblog.redhat.com/2014/09/30/overview-storage-scalability-docker/](http://developerblog.redhat.com/2014/09/30/overview-storage-scalability-docker/)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developerblog.redhat.com/2014/09/30/overview-storage-scalability-docker/](http://developerblog.redhat.com/2014/09/30/overview-storage-scalability-docker/)'
- en: 'Beyond Microbenchmarks—breakthrough container performance with Tesla efficiency:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超越微基准-以特斯拉效率突破容器性能：
- en: '[http://developerblog.redhat.com/2014/10/21/beyond-microbenchmarks-breakthrough-container-performance-with-tesla-efficiency/](http://developerblog.redhat.com/2014/10/21/beyond-microbenchmarks-breakthrough-container-performance-with-tesla-efficiency/)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developerblog.redhat.com/2014/10/21/beyond-microbenchmarks-breakthrough-container-performance-with-tesla-efficiency/](http://developerblog.redhat.com/2014/10/21/beyond-microbenchmarks-breakthrough-container-performance-with-tesla-efficiency/)'
- en: 'Containerizing Databases with Red Hat Enterprise Linux:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Red Hat Enterprise Linux容器化数据库：
- en: '[http://rhelblog.redhat.com/2014/10/29/containerizing-databases-with-red-hat-enterprise-linux/](http://rhelblog.redhat.com/2014/10/29/containerizing-databases-with-red-hat-enterprise-linux/)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://rhelblog.redhat.com/2014/10/29/containerizing-databases-with-red-hat-enterprise-linux/](http://rhelblog.redhat.com/2014/10/29/containerizing-databases-with-red-hat-enterprise-linux/)'
- en: From IBM
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自IBM
- en: 'An Updated Performance Comparison of Virtual Machines and Linux Containers:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机和Linux容器的性能比较的更新版本：
- en: '[http://domino.research.ibm.com/library/cyberdig.nsf/papers/0929052195DD819C85257D2300681E7B/$File/rc25482.pdf](http://domino.research.ibm.com/library/cyberdig.nsf/papers/0929052195DD819C85257D2300681E7B/%24File/rc25482.pdf)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://domino.research.ibm.com/library/cyberdig.nsf/papers/0929052195DD819C85257D2300681E7B/$File/rc25482.pdf](http://domino.research.ibm.com/library/cyberdig.nsf/papers/0929052195DD819C85257D2300681E7B/%24File/rc25482.pdf)'
- en: '[https://github.com/thewmf/kvm-docker-comparison](https://github.com/thewmf/kvm-docker-comparison)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/thewmf/kvm-docker-comparison](https://github.com/thewmf/kvm-docker-comparison)'
- en: From VMware
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自VMware
- en: Docker Containers Performance in VMware vSphere
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VMware vSphere中的Docker容器性能
- en: '[http://blogs.vmware.com/performance/2014/10/docker-containers-performance-vmware-vsphere.html](http://blogs.vmware.com/performance/2014/10/docker-containers-performance-vmware-vsphere.html)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://blogs.vmware.com/performance/2014/10/docker-containers-performance-vmware-vsphere.html](http://blogs.vmware.com/performance/2014/10/docker-containers-performance-vmware-vsphere.html)'
- en: To do the benchmarking, we need to run similar workload on different environments
    (bare metal/VM/Docker) and then collect the results with the help of different
    performance stats. To simplify things, we can write common benchmark scripts which
    can be used to run on different environments. We can also create Dockerfiles to
    spin off containers with workload generation scripts. For example, in the *Performance
    Analysis of Docker on Red Hat Enterprise Linux* article, which is listed earlier
    ([https://github.com/jeremyeder/docker-performance/blob/master/Dockerfiles/Dockerfile](https://github.com/jeremyeder/docker-performance/blob/master/Dockerfiles/Dockerfile)),
    the author has used a Dockerfile to create a CentOS image and used the `container`
    environment variable to select Docker and non-Docker environment for benchmark
    script `run-sysbench.sh`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行基准测试，我们需要在不同的环境（裸机/虚拟机/Docker）上运行类似的工作负载，然后借助不同的性能统计数据收集结果。为了简化事情，我们可以编写通用的基准测试脚本，这些脚本可以用于不同的环境。我们还可以创建Dockerfiles来生成带有工作负载生成脚本的容器。例如，在*Red
    Hat企业Linux上Docker性能分析*文章中，作者使用了一个Dockerfile来创建一个CentOS镜像，并使用`container`环境变量来选择Docker和非Docker环境的基准测试脚本`run-sysbench.sh`。
- en: Similarly, Dockerfiles and related scripts are published by IBM for their study
    available at [https://github.com/thewmf/kvm-docker-comparison](https://github.com/thewmf/kvm-docker-comparison).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，IBM发布了用于其研究的Dockerfiles和相关脚本，可在[https://github.com/thewmf/kvm-docker-comparison](https://github.com/thewmf/kvm-docker-comparison)上找到。
- en: We will be using some of the Docker files and scripts mentioned earlier in the
    recipes of this chapter.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的示例中使用一些之前提到的Docker文件和脚本。
- en: Benchmarking CPU performance
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试CPU性能
- en: We can use benchmarks such as Linpack ([http://www.netlib.org/linpack/](http://www.netlib.org/linpack/))
    and sysbench ([https://github.com/nuodb/sysbench](https://github.com/nuodb/sysbench))
    to benchmark CPU performance. For this recipe, we'll use sysbench. We'll see how
    to run the benchmark on bare metal and inside the container. Similar steps can
    be performed in other environments, as mentioned earlier.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用诸如Linpack（[http://www.netlib.org/linpack/](http://www.netlib.org/linpack/)）和sysbench（[https://github.com/nuodb/sysbench](https://github.com/nuodb/sysbench)）之类的基准测试来测试CPU性能。对于这个示例，我们将使用sysbench。我们将看到如何在裸机和容器内运行基准测试。如前所述，类似的步骤可以在其他环境中执行。
- en: Getting ready
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will use the CentOS 7 container to run the benchmark inside the container.
    Ideally, we should have a system with CentOS 7 installed to get benchmark results
    on bare metal. For the container test, let''s build the image from the GitHub
    repository that we referred to earlier:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用CentOS 7容器在容器内运行基准测试。理想情况下，我们应该有一个安装了CentOS 7的系统，以便在裸机上获得基准测试结果。对于容器测试，让我们从之前提到的GitHub存储库构建镜像：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How to do it…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Inside the same GitHub repository, we have a script to run sysbench, `docker-performance/bench/sysbench/run-sysbench.sh`.
    It has some configurations, which you can modify according to your needs.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个GitHub存储库中，我们有一个用于运行sysbench的脚本，`docker-performance/bench/sysbench/run-sysbench.sh`。它有一些配置，您可以根据需要进行修改。
- en: 'As the root user, create the `/results` directory on the host:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为root用户，在主机上创建`/results`目录：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, run the benchmark after setting the container environment variable to
    something other than Docker, which we used while building the `c7perf` image on
    the host machine, run the following commands:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在将容器环境变量设置为与Docker不同的值后运行基准测试，我们在主机上使用该值构建`c7perf`镜像，运行以下命令：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By default, the results are collected in `/results`. Make sure you have write
    access to it or change the `OUTDIR` parameter in the benchmark script.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，结果会收集在`/results`中。确保您对其具有写访问权限，或者在基准测试脚本中更改`OUTDIR`参数。
- en: 'To run the benchmark inside the container, we need to first start the container
    and then run the benchmark script:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在容器内运行基准测试，我们需要先启动容器，然后运行基准测试脚本：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we mounted the host directory, `/results_container`,inside the `/results`
    container`,` the result will be collected on the host.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们挂载了主机目录`/results_container`到容器内的`/results`，因此结果将在主机上收集。
- en: 'While running the preceding test on Fedora/RHEL/CentOS, where SELinux is enabled,
    you will get a `Permission denied` error. To fix it, relabel the host directory
    while mounting it inside the container as follows:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Fedora/RHEL/CentOS上运行上述测试时，如果启用了SELinux，您将收到`Permission denied`错误。要解决此问题，请在将其挂载到容器内时重新标记主机目录，如下所示：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, for the time being, put SELinux in permissive mode:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，暂时将SELinux设置为宽松模式：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, after the test, put it back in permissive mode:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在测试之后，将其恢复为宽松模式：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to [Chapter 9](part0092.xhtml#aid-2NNJO2 "Chapter 9. Docker Security"),
    *Docker Security*, for more details about SELinux.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有关SELinux的更多详细信息，请参阅[第9章](part0092.xhtml#aid-2NNJO2 "第9章。Docker安全性")，“Docker安全性”。
- en: How it works…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The benchmark script internally calls sysbench's CPU benchmark for the given
    input. CPU is benchmarked by using the 64-bit integer manipulation using Euklid
    algorithms for prime number computation. The result for each run gets collected
    in the corresponding results directory, which can be used for comparison.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试脚本在内部调用sysbench的CPU基准测试，用于给定输入。CPU是通过使用Euklid算法进行64位整数操作来进行基准测试，用于计算素数。每次运行的结果都会收集在相应的结果目录中，可用于比较。
- en: There's more…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Almost no difference is reported in bare metal and Docker CPU performance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 裸机和Docker CPU性能报告几乎没有差异。
- en: See also
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Look at the CPU benchmark results published in IBM and VMware using Linpack
    in the links referenced earlier in this chapter.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看IBM和VMware在本章前面引用的链接中使用Linpack发布的CPU基准测试结果。
- en: Benchmarking disk performance
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试磁盘性能
- en: There are tools such as Iozone ([http://www.iozone.org/](http://www.iozone.org/)),
    smallfile ([https://github.com/bengland2/smallfile](https://github.com/bengland2/smallfile)),
    and Flexible IO ([https://github.com/axboe/fio](https://github.com/axboe/fio))
    available to benchmark disk performance. For this recipe, we will use FIO. For
    that, we need to write a job file, which mimics the workload you want to run.
    Using this job file, we can simulate the workload on the target. For this recipe,
    let's take the FIO example from the benchmark results, which IBM has published
    ([https://github.com/thewmf/kvm-docker-comparison/tree/master/fio](https://github.com/thewmf/kvm-docker-comparison/tree/master/fio)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可用于基准测试磁盘性能，例如Iozone ([http://www.iozone.org/](http://www.iozone.org/))，smallfile
    ([https://github.com/bengland2/smallfile](https://github.com/bengland2/smallfile))和Flexible
    IO ([https://github.com/axboe/fio](https://github.com/axboe/fio))。对于本教程，我们将使用FIO。为此，我们需要编写一个作业文件，模拟您想要运行的工作负载。使用此作业文件，我们可以在目标上模拟工作负载。对于本教程，让我们使用IBM发布的基准测试结果中的FIO示例（[https://github.com/thewmf/kvm-docker-comparison/tree/master/fio](https://github.com/thewmf/kvm-docker-comparison/tree/master/fio)）。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In the bare metal / VM / Docker container, install FIO and mount the disk containing
    a filesystem for each test under `/ferrari` or anything which is mentioned in
    the FIO job file. On bare metal, you can mount natively and on VM it can be mounted
    using the virtual disk driver or we can do device pass through. On Docker, we
    can attach the filesystem from the host machine using Docker volumes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在裸机/虚拟机/Docker容器上，安装FIO并挂载包含文件系统的磁盘以进行每个测试，挂载在`/ferrari`下或在FIO作业文件中提到的任何位置。在裸机上，您可以进行本地挂载，在虚拟机上，可以使用虚拟磁盘驱动程序进行挂载，或者可以进行设备透传。在Docker上，我们可以使用Docker卷从主机机器附加文件系统。
- en: 'Prepare the workload file. We can pick [https://github.com/thewmf/kvm-docker-comparison/blob/master/fio/mixed.fio](https://github.com/thewmf/kvm-docker-comparison/blob/master/fio/mixed.fio):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 准备工作负载文件。我们可以选择[https://github.com/thewmf/kvm-docker-comparison/blob/master/fio/mixed.fio](https://github.com/thewmf/kvm-docker-comparison/blob/master/fio/mixed.fio)：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using the preceding job file, we can do random direct I/O on `/ferrari/fio-test-file`
    with 4K block size using the `libaio` driver on a 16 GB file. The I/O depth is
    32 and the number of parallel jobs is 8\. It is a mix workload, which does 70
    percent read and 30 percent write.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述作业文件，我们可以在`/ferrari/fio-test-file`上进行4K块大小的随机直接I/O，使用16GB文件上的`libaio`驱动程序。I/O深度为32，并行作业数为8。这是一个混合工作负载，其中70％为读取，30％为写入。
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For the bare metal and VM tests, you can just run the FIO job file and collect
    the result:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于裸机和虚拟机测试，您只需运行FIO作业文件并收集结果：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For the Docker test, you can prepare a Docker file as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于Docker测试，您可以按以下方式准备Docker文件：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, create an image using the following command:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下命令创建一个镜像：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Start the container as follows to run the benchmark and collect the results:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式启动容器以运行基准测试并收集结果：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'While running the preceding test on Fedora/RHEL/CentOS, where SELinux is enabled,
    you will get the `Permission denied` error. To fix it, re-label the host directory
    while mounting it inside the container as follows:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Fedora/RHEL/CentOS上运行上述测试时，启用SELinux，您将收到“权限被拒绝”的错误。要解决此问题，请在容器内部挂载主机目录时重新标记主机目录，如下所示：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works…
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: FIO will run the workload given in the job file and spit out the results.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: FIO将运行作业文件中给定的工作负载并输出结果。
- en: There's more…
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Once the results are collected, you can do the result comparison. You can even
    try out different kinds of I/O patterns using the job file and get the desired
    result.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 收集结果后，您可以进行结果比较。您甚至可以尝试使用作业文件进行不同类型的I/O模式，并获得所需的结果。
- en: See also
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Look at the disk benchmark results published in IBM and VMware using FIO in
    the links referenced earlier in this chapter
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看IBM和VMware使用FIO在本章前面引用的链接中发布的磁盘基准测试结果
- en: Benchmarking network performance
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试网络性能
- en: 'Network is one of the key aspects to consider while deploying the applications
    in the container environment. To do performance comparison with bare metal, VM
    and containers, we have to consider different scenarios as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是在容器环境中部署应用程序时需要考虑的关键因素之一。为了与裸机、虚拟机和容器进行性能比较，我们必须考虑以下不同的场景：
- en: Bare metal to bare metal
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 裸机到裸机
- en: VM to VM
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机到虚拟机
- en: Docker container to container with the default networking mode (bridge)
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认网络模式（桥接）的Docker容器到容器
- en: Docker container to container with host net (`--net=host`)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用主机网络（`--net=host`）的Docker容器到容器
- en: Docker container running inside VM with the external world
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker容器在虚拟机中运行，与外部世界连接
- en: In any of the preceding cases, we can pick up two endpoints to do the benchmarking.
    We can use tools such as `nuttcp` ([http://www.nuttcp.net/](http://www.nuttcp.net/))
    and `netperf` ([http://netperf.org/netperf/](http://netperf.org/netperf/)) to
    measure the network bandwidth and request/response, respectively.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述任何情况下，我们可以选择两个端点进行基准测试。我们可以使用工具如`nuttcp` ([http://www.nuttcp.net/](http://www.nuttcp.net/))和`netperf`
    ([http://netperf.org/netperf/](http://netperf.org/netperf/))来分别测量网络带宽和请求/响应。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Make sure both the endpoints can reach each other and have the necessary packages/software
    installed. On Fedora 21, you can install `nuttcp` with the following command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 确保两个端点可以相互到达并安装了必要的软件包/软件。在Fedora 21上，您可以使用以下命令安装`nuttcp`：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And, get `netperf` from its website.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从其网站获取`netperf`。
- en: How to do it…
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To measure the network bandwidth using `nuttcp`, perform the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`nuttcp`测量网络带宽，执行以下步骤：
- en: 'Start the `nuttcp` server on one endpoint:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个端点上启动`nuttcp`服务器：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Measure the transmit throughput (client to server) from the client with the
    following command:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令从客户端测量传输吞吐量（客户端到服务器）：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Measure the receiver throughput on the client (server to client) with the following
    command:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在客户端上测量接收吞吐量（服务器到客户端）：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To run the request/response benchmark using `netperf`, perform the following
    steps:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`netperf`运行请求/响应基准测试，执行以下步骤：
- en: 'Start `netserver` on one endpoint:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个端点上启动`netserver`：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Connect to the server from the other endpoint and run the request/response
    test:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从另一个端点连接到服务器并运行请求/响应测试：
- en: 'For TCP:'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于TCP：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For UDP:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于UDP：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In both the cases mentioned earlier, one endpoint becomes the client and sends
    the requests to the server on the other endpoint.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面提到的两种情况中，一个端点成为客户端，向另一个端点上的服务器发送请求。
- en: There's more…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: We can collect the benchmark results for different scenarios and compare them.
    `netperf` can also be used for throughput tests.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以收集不同场景的基准测试结果并进行比较。`netperf`也可以用于吞吐量测试。
- en: See also
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Look at the network benchmark results published by IBM and VMware in the links
    referenced earlier in this chapter
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看IBM和VMware在本章前面引用的链接中发布的网络基准测试结果。
- en: Getting container resource usage using the stats feature
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用统计功能获取容器资源使用情况
- en: With the release of version 1.5, Docker added a feature to get container resource
    usage from in-built commands.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 随着1.5版本的发布，Docker增加了一个功能，可以从内置命令中获取容器资源使用情况。
- en: Getting ready
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: A Docker host with version 1.5 or later installed, which can be accessed via
    the Docker client. Also, start a few containers to get stats.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了1.5或更高版本的Docker主机，可以通过Docker客户端访问。同时，启动一些容器以获取统计信息。
- en: How to do it…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Run the following command to get stats from one or more containers:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令从一个或多个容器获取统计信息：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For example, if we have two containers with the names `some-mysql` and `backstabbing_turing`,
    then run the following command to get the stats:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有两个名为`some-mysql`和`backstabbing_turing`的容器，然后运行以下命令以获取统计信息：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![How to do it…](../Images/image00376.jpeg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法…](../Images/image00376.jpeg)'
- en: How it works…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The Docker daemon fetches the resource information from the Cgroups and serves
    it through the APIs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护程序从Cgroups获取资源信息，并通过API提供它。
- en: See also
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the release notes of Docker 1.5 at [https://docs.docker.com/v1.5/release-notes/](https://docs.docker.com/v1.5/release-notes/)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考Docker 1.5的发布说明[https://docs.docker.com/v1.5/release-notes/](https://docs.docker.com/v1.5/release-notes/)
- en: Setting up performance monitoring
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置性能监控
- en: We have tools such as SNMP, Nagios, and so on to monitor bare metal and VM performance.
    Similarly, there are a few tools/plugins available to monitor container performance
    such as cAdvisor ([https://github.com/google/cadvisor](https://github.com/google/cadvisor))
    and sFlow ([http://blog.sflow.com/2014/06/docker-performance-monitoring.html](http://blog.sflow.com/2014/06/docker-performance-monitoring.html)).
    In this recipe, let's see how we can configure cAdvisor.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有诸如SNMP、Nagios等工具来监视裸机和虚拟机的性能。同样，有一些可用于监视容器性能的工具/插件，如cAdvisor（[https://github.com/google/cadvisor](https://github.com/google/cadvisor)）和sFlow（[http://blog.sflow.com/2014/06/docker-performance-monitoring.html](http://blog.sflow.com/2014/06/docker-performance-monitoring.html)）。在本教程中，让我们看看如何配置cAdvisor。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Setting up cAdvisor.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 设置cAdvisor。
- en: 'The easiest way to run cAdvisor is to run its Docker container, which can be
    done with the following command:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行cAdvisor的最简单方法是运行其Docker容器，可以使用以下命令完成：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you want to run cAdvisor outside Docker, then follow the instructions given
    on the cAdvisor home page at [https://github.com/google/cadvisor/blob/master/docs/running.md#standalone](https://github.com/google/cadvisor/blob/master/docs/running.md#standalone)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想在Docker之外运行cAdvisor，请按照cAdvisor主页上给出的说明进行操作[https://github.com/google/cadvisor/blob/master/docs/running.md#standalone](https://github.com/google/cadvisor/blob/master/docs/running.md#standalone)
- en: How to do it…
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法…
- en: After the container starts, point your browser to `http://localhost:8080`. You
    will first get the graphs for CPU, memory usage and other information for the
    host machine. Then, by clicking on the Docker Containers link, you will get the
    URLs for the containers running on the machine under the **Subcontainers** section.
    If you click on any one of them, you will see the resource usage information for
    the corresponding container.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动后，将浏览器指向`http://localhost:8080`。您将首先获得有关主机机器的CPU、内存使用情况和其他信息的图表。然后，通过单击Docker容器链接，您将在**子容器**部分下获得运行在机器上的容器的URL。如果单击其中任何一个，您将看到相应容器的资源使用信息。
- en: 'The following is the screenshot of one such container:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个这样的容器的屏幕截图：
- en: '![How to do it…](../Images/image00377.jpeg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![操作方法…](../Images/image00377.jpeg)'
- en: How it works…
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: With the `docker run` command, we have mounted few volumes from host machines
    in read-only mode. cAdvisor will read the relevant information from those like
    the Cgroup details for containers and show them graphically.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker run`命令，我们已经以只读模式挂载了一些卷，cAdvisor将从中读取相关信息，比如容器的Cgroup详细信息，并以图形方式显示它们。
- en: There's more…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: cAdvisor supports exporting the performance matrices to influxdb ([http://influxdb.com/](http://influxdb.com/)).
    Heapster ([https://github.com/GoogleCloudPlatform/heapster](https://github.com/GoogleCloudPlatform/heapster))
    is another project from Google, which allows cluster-wide (Kubernetes) monitoring
    using cAdvisor.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: cAdvisor支持将性能矩阵导出到influxdb（[http://influxdb.com/](http://influxdb.com/)）。Heapster（[https://github.com/GoogleCloudPlatform/heapster](https://github.com/GoogleCloudPlatform/heapster)）是Google的另一个项目，它允许使用cAdvisor进行集群范围（Kubernetes）监控。
- en: See also
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: You can look at the matrices used by cAdvisor from Cgroups in the documentation
    on the Docker website [https://docs.docker.com/articles/runmetrics/](https://docs.docker.com/articles/runmetrics/)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在Docker网站的文档中查看cAdvisor从Cgroups中使用的矩阵[https://docs.docker.com/articles/runmetrics/]。
