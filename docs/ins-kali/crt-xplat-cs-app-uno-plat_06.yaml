- en: '*Chapter 4*: Mobilizing Your App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：使您的应用程序移动化'
- en: This chapter will show you how to develop apps with Uno Platform for mobile
    devices. Such apps can be quite different from ones that run on a desktop device
    or the web and bring their own challenges that you must take into account.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示如何使用Uno平台为移动设备开发应用程序。这样的应用程序可能与在桌面设备或Web上运行的应用程序有很大的不同，并带来了您必须考虑的挑战。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building for mobile devices running iOS and Android
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为运行iOS和Android的移动设备构建
- en: Working with remote data in occasionally connected environments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在偶尔连接的环境中使用远程数据
- en: Styling the app for the platform it is running on
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为其运行的平台设计应用程序的样式
- en: Using the capabilities of the device that the app is running on
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用应用程序所在设备的功能
- en: By the end of this chapter, you'll have created a mobile app that runs on Android
    and iOS devices, looks different on each platform, and communicates with a remote
    server to retrieve and send data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将创建一个在Android和iOS设备上运行的移动应用程序，每个平台上的外观都不同，并与远程服务器通信以检索和发送数据。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter assumes that you already have your development environment set
    up, as well as the necessary project templates installed, as we covered in [*Chapter
    1*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015), *Introducing Uno Platform*.
    The source code for this chapter can be found at [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter04](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter04).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已经设置好了开发环境，并安装了必要的项目模板，就像我们在[*第1章*](B17132_01_Final_VK_ePub.xhtml#_idTextAnchor015)
    *介绍Uno平台*中所介绍的那样。本章的源代码可以在[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter04](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/Chapter04)找到。
- en: 'The code in this chapter makes use of the following library: [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码使用以下库：[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/SharedLibrary)。
- en: This chapter also retrieves data from a remote web server that you can recreate
    with the code at [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/WebApi](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/WebApi).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还从远程Web服务器检索数据，您可以使用[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/WebApi](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform/tree/main/WebApi)的代码重新创建。
- en: 'Check out the following video to see the code in action: [https://bit.ly/3jKGRkI](https://bit.ly/3jKGRkI)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：[https://bit.ly/3jKGRkI](https://bit.ly/3jKGRkI)
- en: Introducing the app
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍应用程序
- en: 'The app we''ll be building in this chapter is called **Network Assist**. It''s
    an application that will be made available to all staff. It is particularly useful
    to those working at stations in a public-facing capacity. The real version of
    this app would have many features, but we''re only going to implement two:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中构建的应用程序称为**Network Assist**。这是一个将提供给所有员工使用的应用程序。对于在公共场合工作的人来说，这是特别有用的。这个应用程序的真实版本将有许多功能，但我们只会实现两个：
- en: Showing when the next trains will arrive at each station
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示下一班火车将到达每个车站的时间
- en: Recording and reporting details of events happening around the network.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和报告发生在网络周围的事件的细节。
- en: As this application will be used by staff members as they perform their jobs
    across the network, it will be built to run on Android and iOS devices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个应用程序将被员工在整个网络上执行工作时使用，它将被构建为在Android和iOS设备上运行。
- en: What does "mobile" mean?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: “移动”是什么意思？
- en: It's easy to think of "mobile" as only being about the device an app is on,
    but to do so is limiting. "Mobile" can be a helpful shorthand for "Android and
    iOS devices." However, it's essential to remember more than phones (or tablets)
    are mobile. It's also the person who is using the device who is mobile. Considering
    the people who will be using the application is often more important than the
    device that it will be running on. The device is just one factor to consider.
    A person may use multiple devices as part of a process, thereby requiring the
    experience to be mobile as they move between devices – perhaps starting a task
    on one device and finishing it on another.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易认为“移动”只是关于应用程序所在的设备，但这样做是有限制的。“移动”可以是“Android和iOS设备”的一个有用的简称。然而，重要的是要记住，移动不仅仅是指手机（或平板电脑）。使用设备的人也是移动的。考虑将使用应用程序的人通常比运行应用程序的设备更重要。设备只是要考虑的一个因素。一个人可能在过程中使用多个设备，因此需要体验在他们在设备之间移动时也是移动的
    - 也许在一个设备上开始一个任务，然后在另一个设备上完成它。
- en: The reason we're building the Network Assist app as a mobile one is primarily
    because the people who will use it will be travelling around all day. It's because
    the person is mobile that we're building a "mobile" app, that runs on a "mobile"
    device.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建Network Assist应用程序为移动应用程序的主要原因是因为将使用它的人将整天四处旅行。正因为人是移动的，我们才构建了一个在“移动”设备上运行的“移动”应用程序。
- en: Rather than spending a lot of time explaining the functionality in advance,
    let's get on with building the app. We'll expand on the requirements as we write
    the code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与其花费大量时间事先解释功能，不如开始构建应用程序。我们将在编写代码时扩展需求。
- en: Creating the app
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: 'We''ll start by creating the solution for the app:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建应用程序的解决方案开始：
- en: In Visual Studio, create a new project with the **Multi-Platform App (Uno Platform)**
    template.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，使用**多平台应用程序（Uno平台）**模板创建一个新项目。
- en: Call the project `NetworkAssist`. You can use a different name, but you'll need
    to adjust all subsequent code snippets accordingly.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为`NetworkAssist`。你可以使用不同的名称，但需要相应地调整所有后续的代码片段。
- en: Remove all the platform head projects *except* for the **Android**, **iOS**,
    and **UWP** ones.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除所有平台头项目，*除了* **Android**，**iOS**和**UWP**。
- en: Always keep the UWP head in the solution
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 始终保留UWP头在解决方案中
- en: Even if you're not going to release a UWP version of an app, there are two reasons
    to keep the UWP head in the solution. Firstly, this can be helpful when diagnosing
    any compilation errors, to check if the code has a fundamental problem or if the
    issue is related to the Uno-specific tooling. Secondly, and more importantly,
    Visual Studio can provide additional tooling and IntelliSense when the UWP head
    is selected. By having the UWP head in the project, your Uno Platform development
    experience will be more straightforward.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不打算发布应用程序的UWP版本，保留UWP头在解决方案中也有两个原因。首先，当诊断任何编译错误时，这可能是有帮助的，以检查代码是否存在基本问题，或者问题是否与Uno特定的工具有关。其次，更重要的是，当选择UWP头时，Visual
    Studio可以提供额外的工具和智能感知。通过在项目中添加UWP头，您的Uno平台开发体验将更加简单。
- en: To avoid the need to write more code than necessary, we'll add a reference to
    the shared library project. Right-click on the solution node in `UnoBookRail.Common.csproj`
    file, and click **Open**.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免写更多的代码，我们将添加对共享库项目的引用。在`UnoBookRail.Common.csproj`文件中，右键单击解决方案节点，然后点击**打开**。
- en: For each of the platform-specific projects, we need to add a reference to the
    common library project. Right-click on the **Android** project node in **Solution
    Explorer** and select **Add > Reference… > Projects**. Then, check the entry for
    **UnoBookRail.Common** and click **OK**. Now, *repeat this process for the iOS
    and UWP projects*.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个特定平台的项目，我们需要添加对通用库项目的引用。在**解决方案资源管理器**中右键单击**Android**项目节点，然后选择**添加 > 引用...
    > 项目**。然后，选中**UnoBookRail.Common**的条目，然后点击**确定**。现在，*重复此过程用于iOS和UWP项目*。
- en: With the basic solution structure now ready, we can add some functionality to
    the main page.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 基本解决方案结构现在已经准备就绪，我们可以向主页添加一些功能。
- en: Creating the main page
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建主页
- en: As this will be a simple application, we will put all the functionality on a
    single page. The requirement for the design is that the app has tabs or buttons
    at the bottom of the screen to enable switching between the different areas of
    functionality. We'll put the different pieces of functionality in separate controls
    and change the control that's shown based on the button (or tab) the user presses.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这将是一个简单的应用程序，我们将把所有功能放在一个页面上。设计要求是应用程序在屏幕底部有选项卡或按钮，以便在不同功能区域之间进行切换。我们将把不同的功能放在单独的控件中，并根据用户按下的按钮（或选项卡）来更改显示的控件。
- en: This is appropriate because the user does not need to navigate backward through
    the tabs they have viewed already.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是合适的，因为用户不需要通过他们已经查看过的选项卡后退。
- en: Allowing for camera notches, cutouts, and safe areas
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许相机凹口、切口和安全区域
- en: Before we add any of our own content, you may wish to run the app to check that
    everything compiles and can be debugged without issue. Depending on the device
    or simulator you run the app on, you may see something like the left-hand side
    of *Figure 4.1*, which shows the default app running on an iPhone 12 simulator.
    In this figure, you can see that the **Hello, World!** text overlaps (or crashes
    into) the time and goes behind the camera notch.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加任何自己的内容之前，您可能希望运行应用程序，以检查是否一切都可以编译和调试。根据您运行应用程序的设备或模拟器，您可能会看到*图4.1*左侧的内容，显示了在iPhone
    12模拟器上运行的默认应用程序。在这个图中，您可以看到**Hello, World!**文本重叠（或撞到）时间，并且在相机凹口后面。
- en: 'If you don''t have a device that allows you to test this, some emulators are
    available that have this notch. Other emulators will have a configurable option
    to allow testing with and without the cutout. Look under **Settings > System >
    Developer Options > Simulate a display with a cutout**:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有设备可以测试这个功能，一些模拟器可以模拟这个凹口。其他模拟器将有一个可配置的选项，允许在有或没有切口的情况下进行测试。在**设置 > 系统 >
    开发人员选项 > 模拟具有切口的显示**下查找：
- en: '![Figure 4.1 – Before and after screenshots showing content allowing for the
    status bar and camera notch'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 - 显示允许状态栏和相机凹口的内容的前后截图'
- en: '](img/Author_Figure_4.01_B17132.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Author_Figure_4.01_B17132.jpg)'
- en: Figure 4.1 – Before and after screenshots showing content allowing for the status
    bar and camera notch
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - 显示允许状态栏和相机凹口的内容的前后截图
- en: Our app won't have the **Hello, World!** text, but we don't want our content
    to be obscured. Fortunately, Uno Platform comes with a helper class that will
    allow space for camera notches, regardless of the device they are on or the position
    they are in.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序不会有**Hello, World!**文本，但我们不希望我们的内容被遮挡。幸运的是，Uno平台带有一个辅助类，可以为相机凹口留出空间，无论它们在哪种设备上或者它们的位置如何。
- en: 'To use this helper class, we need to do the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个辅助类，我们需要做以下几步：
- en: Add `xmlns:toolkit="using:Uno.UI.Toolkit"` to the `Page` element at the root
    of `MainPage.xaml`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainPage.xaml`的根元素`Page`中添加`xmlns:toolkit="using:Uno.UI.Toolkit"`。
- en: Add `toolkit:VisibleBoundsPadding.PaddingMask="All"` to the `Grid` element inside
    the `Page` element. By setting a value of `All`, the helper will provide the appropriate
    space if the device is turned sideways, and the notch will be shown at the side
    of the screen.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Page`元素内部的`Grid`元素中添加`toolkit:VisibleBoundsPadding.PaddingMask="All"`。通过设置`All`的值，如果设备横向旋转，辅助类将提供适当的空间，并且凹口将显示在屏幕的侧面。
- en: When you run the app now, you will see something like the right-hand side image
    in *Figure 4.1*, which demonstrates how adequate space has been added to the layout.
    This keeps the status bar or camera notch from obscuring our content.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，你会看到类似于*图4.1*右侧图像的东西，它展示了布局已经添加了足够的空间。这样可以防止状态栏或相机凹口遮挡我们的内容。
- en: Now that we have taken care of allowing notches on the screen, we can implement
    the functionality we need for the app.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了屏幕上的切口，我们可以实现应用程序所需的功能。
- en: Implementing the main page's content
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现主页面的内容
- en: 'As we only have one page in the app, we''ll implement it now:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序中只有一个页面，我们现在将实现它：
- en: 'Replace the existing contents of `Grid` with the following:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换`Grid`的现有内容：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The top row of the grid will contain the controls for the different elements
    of functionality. The bottom row will host the buttons for selecting the different
    controls.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 网格的顶行将包含不同功能元素的控件。底行将承载选择不同控件的按钮。
- en: We're using a `CommandBar` as this is the UWP control that's best suited for
    providing buttons for selecting areas of functionality within the app. This is
    only an approximation of how we want things to look on iOS and Android, and we'll
    address those shortly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`CommandBar`，因为这是最适合在应用程序中提供选择功能区域按钮的UWP控件。这只是我们希望在iOS和Android上看到的外观的近似值，我们将很快解决这些问题。
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: XAML provides multiple ways of doing things that all produce comparable results.
    With the code in this chapter, we've used the simplest approach to provide a consistent
    output on all platforms.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: XAML提供了多种方法来实现相似的结果。在本章的代码中，我们使用了最简单的方法来在所有平台上提供一致的输出。
- en: We now need custom controls for displaying the different pieces of functionality.
    Start by right-clicking on the `Views` so that it matches the convention for where
    to store UI-related controls.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要自定义控件来显示不同的功能。首先右键单击`Views`，以匹配存储UI相关控件的约定。
- en: If you wish, you can move the `MainPage` files into the `Views` folder, but
    it doesn't matter for the functionality of this app.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，可以将`MainPage`文件移入`Views`文件夹，但这对应用程序的功能并不重要。
- en: In the new folder, right-click and select `ArrivalsControl`. Repeat this to
    add a control named `QuickReportControl`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中，右键单击并选择`ArrivalsControl`。重复此操作以添加名为`QuickReportControl`的控件。
- en: 'We''ll now add the controls to `MainPage.xaml`. Declare a new XML namespace
    alias at the page level, with the value of `xmlns:views="using:Network Assist.Views"`.
    After the opening of the `Grid` tag and before `CommandBar`, add the following
    to create instances of our new controls:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将控件添加到`MainPage.xaml`。在页面级别声明一个新的XML命名空间别名，值为`xmlns:views="using:Network
    Assist.Views"`。在`Grid`标签的开头和`CommandBar`之前，添加以下内容以创建我们新控件的实例：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the code-behind file (`MainPage.xaml.cs`), we need to add the methods to
    handle the `Click` events referenced in the XAML for the AppBarButtons:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码后台文件（`MainPage.xaml.cs`）中，我们需要添加处理XAML中`AppBarButtons`引用的`Click`事件的方法：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We'll use click events and code-behind here as the logic is tightly coupled
    to the UI and won't benefit from having coded tests. It's possible and acceptable
    to use `ICommand` implementations and bindings to control when each control is
    shown, but it is up to you to implement it that way if you wish.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用点击事件和代码后台，因为逻辑与UI紧密耦合，并且不会受益于编写的测试。可以使用`ICommand`实现和绑定来控制每个控件何时显示，但如果您希望这样实现，可以自行实现。
- en: MVVM and Code-Behind
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM和代码后台
- en: In this chapter, we will use a combination of code-behind files and the **Model-View-ViewModel**
    (**MVVM**) pattern. There are three reasons for this. Firstly, it allows us to
    keep the code shorter and simpler, so that it is easier for you to follow along.
    Secondly, it avoids the need to explain a specific MVVM framework or implementation,
    and we can instead focus on the code that's relevant to the application. Finally,
    it demonstrates that Uno Platform doesn't force you to work in a specific way.
    You can use the coding style, pattern, or framework you prefer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用代码后台文件和**Model-View-ViewModel**（**MVVM**）模式的组合。有三个原因。首先，它使我们可以使代码更短，更简单，这样您就更容易跟随。其次，它避免了解释特定的MVVM框架或实现的需要，而我们可以专注于与应用程序相关的代码。最后，它表明Uno平台不会强迫您以特定方式工作。您可以使用您喜欢的编码风格、模式或框架。
- en: With the main page up and running, we can now add the functionality for displaying
    details of upcoming arrivals.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 主页面已经运行，现在我们可以添加显示即将到达的详细信息的功能。
- en: Showing upcoming arrival details
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示即将到达的详细信息
- en: 'The requirements for showing upcoming arrivals are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 显示即将到达的要求如下：
- en: A list of stations is displayed, and when one is selected, the arrival times
    of the next three trains in each direction are shown.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示站点列表，并在选择一个站点时，显示每个方向的下三列火车的到达时间。
- en: The data can be refreshed to ensure the latest information is always available.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据可以刷新以确保始终有最新的信息可用。
- en: The time when the last piece of data was retrieved is displayed.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示检索到最后一条数据的时间。
- en: Prompts are shown if no station is selected or there's a problem retrieving
    data.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未选择站点或检索数据时出现问题，则会显示提示。
- en: The app indicates when it is retrieving data.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序指示正在检索数据时。
- en: 'You can see an example of the final functionality we''ll create by the end
    of this chapter in the following figure:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本章结束时创建的最终功能示例中看到以下图示：
- en: '![Figure 4.2 – Upcoming arrival details shown on an iPhone (left) and on an
    Android device (right)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 - iPhone上显示的即将到达的详细信息（左）和Android设备上（右）'
- en: '](img/Figure_4.02_B17132.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.02_B17132.jpg)'
- en: Figure 4.2 – Upcoming arrival details shown on an iPhone (left) and on an Android
    device (right)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - iPhone上显示的即将到达的详细信息（左）和Android设备上（右）
- en: 'This user control for showing the upcoming arrivals is going to be the most
    complicated piece of UI in the app. It may seem like a lot of steps, but each
    one is simple:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 用于显示即将到达的用户控件将是应用程序中最复杂的UI部分。看起来可能有很多步骤，但每一步都很简单：
- en: 'Start by adding two column definitions, and four row definitions to `Grid`
    in `ArrivalsControl.xaml`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在`ArrivalsControl.xaml`中的`Grid`中添加两个列定义和四个行定义：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The top row will contain a `ComboBox` control for selecting the station and
    a `Button` element to request that the data be refreshed:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶部行将包含一个用于选择车站的`ComboBox`控件和一个用于请求刷新数据的`Button`元素：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next two rows will use `TextBlocks` to show the time when data was last
    retrieved and if there was a problem retrieving data:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的两行将使用`TextBlocks`来显示上次检索数据的时间以及检索数据时是否出现问题：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`ListView` will use a couple of data templates that we''ll define at the control
    level. Add the following after the opening `UserControl` tag:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ListView`将使用我们在控件级别定义的一些数据模板。在打开的`UserControl`标签之后添加以下内容：'
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The fourth, and last, row contains a `ListView` that shows the upcoming arrival
    times:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四行，也是最后一行，包含一个`ListView`，显示即将到达的到站时间：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The fourth row also contains a `Grid` that hosts other informational controls
    that are displayed over or instead of the `ListView` as appropriate:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四行还包含一个`Grid`，其中包含其他信息控件，根据需要显示在`ListView`上或替代`ListView`：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ve added quite a lot of XAML here. The first step to seeing how it looks
    is to wire up a ViewModel so that we can access the relevant properties and commands.
    Change the contents of `ArrivalsControlxaml.cs` to the following:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里添加了相当多的XAML。看看它的外观的第一步是连接ViewModel，以便我们可以访问相关属性和命令。将`ArrivalsControlxaml.cs`的内容更改为以下内容：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following `using` declarations to the top of the file so that the compiler
    can find the types we just added:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`声明添加到文件顶部，以便编译器可以找到我们刚刚添加的类型：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We're now ready to create a ViewModel that will contain the remaining logic
    for the functionality. We'll start by creating a folder called `ViewModels`. Within
    that folder, create a class called `ArrivalsViewModel`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备创建一个包含剩余功能逻辑的ViewModel。我们将首先创建一个名为`ViewModels`的文件夹。在该文件夹中，创建一个名为`ArrivalsViewModel`的类。
- en: 'To avoid writing common code that''s needed when following the MVVM pattern,
    add a reference to the `Microsoft.Toolkit.Mvvm` NuGet package *in each of the
    platform head projects*:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免在遵循MVVM模式时编写常见的代码，需要在每个平台头项目中添加对`Microsoft.Toolkit.Mvvm` NuGet包的引用*：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Update the `ArrivalsViewModel` class so that it inherits from `Microsoft.Toolkit.Mvvm.ComponentModel.ObservableObject`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`ArrivalsViewModel`类，使其继承自`Microsoft.Toolkit.Mvvm.ComponentModel.ObservableObject`。
- en: '`ArrivalsViewModel` will use types from different places, so we need to reference
    the following namespaces:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ArrivalsViewModel`将使用来自不同位置的类型，因此我们需要引用以下命名空间：'
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Start by adding the following fields to the class:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在类中添加以下字段：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our `ViewModel` requires the following properties as they were referenced in
    the bindings of the XAML we defined previously. They will use the backing fields
    we just added:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`ViewModel`需要以下属性，因为它们在我们之前定义的XAML绑定中被引用。它们将使用我们刚刚添加的后备字段：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ll use the constructor to initialize the list of stations and the commands:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用构造函数来初始化车站列表和命令：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, add the method that handles retrieving and displaying the data:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加处理检索和显示数据的方法：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You may have noticed that the data was retrieved from a singleton `DataService`
    class. We''ll start by creating a simple version of this that we''ll expand upon
    later. Common convention suggests putting this class in a directory called `Services`,
    though you could put this in the `ViewModels` folder as well:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能已经注意到数据是从单例`DataService`类中检索的。我们将首先创建一个简单版本，稍后再扩展。通常约定将此类放在名为`Services`的目录中，尽管您也可以将其放在`ViewModels`文件夹中：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we have the `DataService` class, we can retrieve the arrival details,
    but we need to do a little bit more work to display them. There is one more class
    we need. This is `StationArrivalDetails`, and it allows us to group the information
    by the platform and direction the train is traveling in. Create this in the `ViewModels`
    directory:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了`DataService`类，可以检索到达详情，但是我们需要做更多工作来显示它们。我们还需要另一个类。这是`StationArrivalDetails`，它允许我们按站台和列车行驶方向对信息进行分组。在`ViewModels`目录中创建这个类：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: CollectionViewSource with grouped data in Uno
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Uno中使用分组数据的CollectionViewSource
- en: Displaying grouped lists with Uno Platform is more complicated than on UWP.
    If you've previously used a `CollectionViewSource` in a UWP app, you've probably
    defined it in XAML and not as an `IEnumerable<object>`. Unfortunately, it's necessary
    to define our `CollectionViewSource` as an `IEnumerable<IEnumerable>` for Uno
    Platform to correctly render all the groups and headers on Android and iOS. Without
    doing this, we'd see the group headings missing on iOS and only the first group's
    contents on Android.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Uno平台上显示分组列表比在UWP上更复杂。如果您以前在UWP应用程序中使用过`CollectionViewSource`，那么您可能已经在XAML中定义了它，而不是作为`IEnumerable<object>`。不幸的是，为了Uno平台能够正确渲染Android和iOS上的所有组和标题，我们需要将我们的`CollectionViewSource`定义为`IEnumerable<IEnumerable>`。如果不这样做，我们将在iOS上看到缺少组标题，而在Android上只能看到第一组的内容。
- en: We now have a working app, but there are two improvements we'll make in the
    next two sections. There, we'll improve the look of the app and use some native
    controls, but before that, we'll switch to use "as live" data from a remote source
    and not data that ships with the app.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可用的应用程序，但在接下来的两个部分中，我们将进行两项改进。在那里，我们将改善应用程序的外观并使用一些本机控件，但在此之前，我们将切换到使用来自远程源的“实时”数据，而不是应用程序自带的数据。
- en: Retrieving remote data
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索远程数据
- en: Very few apps only work with the data that they ship with. The value the **Network
    Assist** provides is based on giving real-time information. There is a lot more
    value in knowing when trains will actually arrive rather than just when they are
    scheduled to arrive. To gather this information, the app must connect to a remote
    source of real-time data.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有应用程序仅使用其自带的数据。**网络辅助**提供的价值是基于提供实时信息。知道火车实际到达的时间比知道计划到达时间更有价值。为了收集这些信息，应用程序必须连接到远程实时数据源。
- en: Most mobile applications connect to external data sources, and the most common
    way to do this is over HTTP(S). If you're only developing an application that
    runs on desktop, you might be able to assume that a connection is always available.
    For mobile apps, it's necessary to consider the device as being **occasionally
    connected**.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数移动应用程序连接到外部数据源，最常见的方式是通过HTTP(S)。如果您只开发运行在桌面上的应用程序，您可能可以假设始终有可用的连接。对于移动应用程序，必须考虑设备为**偶尔连接**。
- en: As it's impossible to assume that an app will have a connection available or
    that it will be fast, it's necessary to account for this when designing an app.
    These issues apply to all mobile apps and are not something unique to developing
    with Uno Platform. The correct way to handle the occasional connectivity and availability
    of data will vary by application. It's too big an issue for us to fully cover
    here but important to bring up. At a minimum, accounting for occasional connectivity
    means needing to consider retrying failed connection requests and managing data.
    The code we wrote previously in the `LoadArrivalsDataAsync` method already does
    a crude form of caching, by not getting rid of the current information when refreshing
    the data until a successful request is made and newer data is available to display.
    While the information shown in the app can become outdated very quickly, it's
    considered more appropriate for the app to show something that it acknowledges
    is a few minutes out of date than to show nothing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不可能假设应用程序始终可用连接或连接速度很快，因此在设计应用程序时必须考虑这一点。这些问题适用于所有移动应用程序，并不是Uno平台开发中的独特问题。正确处理偶尔的连接性和数据可用性的方式因应用程序而异。这个问题太大，我们无法在这里完全覆盖，但重要的是提出来。至少，考虑偶尔的连接性意味着需要考虑重试失败的连接请求和管理数据。我们之前在`LoadArrivalsDataAsync`方法中编写的代码已经以一种粗糙的缓存形式，通过在刷新数据时不丢弃当前信息，直到成功请求并有新数据可用于显示。虽然应用程序中显示的信息可能会很快过时，但相对于不显示任何内容，显示应用程序承认为几分钟前的内容更为合适。
- en: In another app, it may be more appropriate to save data in a file or database
    so that it can be retrieved and shown when remote data is not available. [*Chapter
    5*](B17132_05_Final_VK_ePub.xhtml#_idTextAnchor083), *Making Your App Ready for
    the Real World*, shows how you may do this using an SQLite database.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个应用程序中，将数据保存在文件或数据库中可能更合适，以便在远程数据不可用时检索和显示。[*第5章*](B17132_05_Final_VK_ePub.xhtml#_idTextAnchor083)，*使您的应用程序准备好面对现实*，展示了如何使用SQLite数据库来实现这一点。
- en: We'll look at how the app can handle failures in connecting to the remote data
    shortly, but first, we'll look at how to connect to the remote data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快看到应用程序如何处理连接到远程数据的失败，但首先，我们将看看如何连接到远程数据。
- en: Connecting to a remote data source
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到远程数据源
- en: The GitHub repository for this book at [https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform)
    includes a **WebAPI** project that will return train arrival data for the app.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的GitHub存储库位于[https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform](https://github.com/PacktPublishing/Creating-Cross-Platform-C-Sharp-Applications-with-Uno-Platform)，其中包括一个**WebAPI**项目，该项目将为应用程序返回火车到站数据。
- en: 'You can choose to run the code and access it via your local machine, or you
    can connect to the version available at [https://unobookrail.azurewebsites.net/](https://unobookrail.azurewebsites.net/).
    If you''re connecting to the hosted version, note that it bases data on the local
    time for the server, and this may be different from where you are. If the server
    continually says there is a long time until the next train as it''s the early
    hours of the morning where the server is, you''ll see more varied data if you
    run the project yourself:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择运行代码并通过本地机器访问，或者您可以连接到[https://unobookrail.azurewebsites.net/](https://unobookrail.azurewebsites.net/)上提供的版本。如果连接到托管版本，请注意它基于服务器的本地时间，并且这可能与您所在的地方不同。如果服务器不断表示下一班火车还有很长时间，因为服务器所在地的凌晨，如果您自己运行项目，您将看到更多不同的数据：
- en: 'We''ll use `System.Net.Http.HttpClient` to connect to the server. To be able
    to do this, we must add package references to `System.Net.Http` in the *Android
    and iOS* projects:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`System.Net.Http.HttpClient`连接到服务器。为了能够做到这一点，我们必须在*Android和iOS*项目中添加对`System.Net.Http`的包引用：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As the data that''s returned by the API is in JSON format, we''ll also add
    a reference to the `Newtonsoft.Json` library in *all platform projects* so that
    we can deserialize the responses:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于API返回的数据是JSON格式，因此我们还将在*所有平台项目*中添加对`Newtonsoft.Json`库的引用，以便我们可以对响应进行反序列化：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''re now ready to retrieve remote data. The changes will all be in the `DataService.cs`
    file. Start by adding an instance of an `HttpClient`. We will use this for all
    requests:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备检索远程数据。所有更改都将在`DataService.cs`文件中进行。首先添加一个`HttpClient`的实例。我们将使用这个实例进行所有请求：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To connect to the server, we need to specify where it is. As we will eventually
    be making multiple requests, it's sensible to define the server domain in a single
    place. We'll do this by `__ANDROID__` constant, which is available to the `#if`
    preprocessor directive. See [*Chapter 2*](B17132_02_Final_VK_ePub.xhtml#_idTextAnchor033)*,
    Writing Your First Uno Platform App*, for more on this.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要连接到服务器，我们需要指定它的位置。由于我们最终将进行多个请求，因此在一个地方定义服务器域是明智的。我们将通过`__ANDROID__`常量来实现这一点，该常量可用于`#if`预处理指令。有关更多信息，请参见[*第2章*](B17132_02_Final_VK_ePub.xhtml#_idTextAnchor033)*，编写您的第一个Uno平台应用程序*。
- en: If you're connecting to a locally hosted WebAPI instance from an Android emulator,
    it's necessary to use the IP address of `10.0.2.2` to connect. This is a special
    IP address that the emulator uses to refer to the host machine. You can use conditional
    compilation to specify this, as in the preceding snippet. If you're connecting
    to an external server, you can set the address directly and don't need any conditional
    code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从Android模拟器连接到本地托管的WebAPI实例，则需要使用IP地址`10.0.2.2`进行连接。这是模拟器用来指代主机机器的特殊IP地址。您可以使用条件编译来指定这一点，就像前面的代码片段中所示。如果您连接到外部服务器，您可以直接设置地址，不需要任何条件代码。
- en: 'We can now update the `GetArrivalsForStationAsync` method to get the live data.
    *Replace* the current implementation with the following:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以更新`GetArrivalsForStationAsync`方法以获取实时数据。*用以下内容替换*当前的实现：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you run the app now, the data will come from the remote location. You might
    notice that data retrieval is no longer instantaneous and that a busy indicator
    is shown while waiting. We added the code for showing the progress indicator in
    the original version of the app but haven't seen it displayed until now. This
    highlights another potential issue when working with data that takes time to retrieve.
    *It is crucial to keep the user informed when something is happening*. We're using
    a `ProgressRing` here to indicate that something is happening. Without this, the
    user may be wondering if anything is happening and become frustrated or press
    the refresh button repeatedly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行应用程序，数据将来自远程位置。您可能会注意到数据检索不再是瞬间完成的，等待时会显示一个忙指示器。我们在应用程序的原始版本中添加了显示进度指示器的代码，但直到现在才看到它显示出来。这突显了在处理需要时间检索的数据时可能出现的另一个潜在问题。*在发生某事时让用户了解情况至关重要*。我们在这里使用`ProgressRing`来指示发生了某事。如果没有这个，用户可能会想知道是否有任何事情发生，并变得沮丧或反复按刷新按钮。
- en: At this point, we've retrieved data from a remote source and kept the user informed
    while this is happening, but we need to do more for when things go wrong. So,
    we'll look at that next.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从远程源检索到数据，并在此过程中让用户了解情况，但是当事情出错时，我们需要做更多。所以，我们接下来会看看这一点。
- en: Using Polly to handle exceptions and retry requests
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Polly处理异常并重试请求
- en: 'The need to handle exceptions and retry failed requests is common across almost
    all applications. Fortunately, many solutions exist to handle some of the complexity
    for us. **Polly** ([https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly))
    is a popular, open source library for handling transient errors that we''ll use
    in our app. Let''s take a look:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异常并重试失败的请求的需求几乎适用于所有应用程序。幸运的是，有许多解决方案可以帮助我们处理一些复杂性。**Polly** ([https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly))是一个流行的开源库，用于处理瞬态错误，我们将在我们的应用程序中使用。让我们来看一下：
- en: 'We''ll start by adding a reference to the `Polly.Extensions.Http` package to
    *all the platform projects*:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先向*所有平台项目*添加对`Polly.Extensions.Http`包的引用：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This extends the standard Polly capabilities and simplifies handling HTTP-related
    faults.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这扩展了标准的Polly功能，并简化了处理与HTTP相关的故障。
- en: We'll now update the `GetArrivalsForStationAsync` method again so that it uses
    a Polly `HandleTransientHttpError`. This tells Polly to retry the request if the
    HTTP response is a server error (HTTP 5xx) or a timeout error (HTTP 408).
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将再次更新`GetArrivalsForStationAsync`方法，使其使用Polly的`HandleTransientHttpError`。这告诉Polly如果HTTP响应是服务器错误（HTTP
    5xx）或超时错误（HTTP 408），则重试请求。
- en: The call to `WaitAndRetryAsync` tells Polly to retry up to three times. We also
    specify a delay between each request using an `policy.ExecuteAsync` and pass it
    the action we wish to apply the policy to.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对`WaitAndRetryAsync`的调用告诉Polly最多重试三次。我们还使用`policy.ExecuteAsync`指定每个请求之间的延迟，并将其传递给我们希望应用策略的操作。
- en: 'If the request fails for a reason not covered by our policy, the code we created
    earlier causes a message to be shown at the top of the screen, as shown in the
    following screenshot, that indicates the problem. Other applications may need
    to log or report such problems differently, but it''s rarely appropriate to do
    nothing:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果请求因我们策略未覆盖的原因而失败，我们之前创建的代码会导致屏幕顶部显示一条消息，如下面的屏幕截图所示，指示问题所在。其他应用可能需要以不同方式记录或报告此类问题，但通常不适合什么都不做：
- en: '![Figure 4.3 – App showing a message to indicate a connectivity problem'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 - 应用程序显示连接问题的消息'
- en: '](img/Figure_4.03_B17132.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.03_B17132.jpg)'
- en: Figure 4.3 – App showing a message to indicate a connectivity problem
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - 应用程序显示连接问题的消息
- en: We now have an app that provides useful data from a remote source, and in a
    reliable way. The final thing we want to do is improve how it looks on different
    platforms.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可以可靠地从远程源提供有用数据的应用程序。我们想要做的最后一件事是改善它在不同平台上的外观。
- en: Making your app look like it belongs on each platform
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使您的应用程序看起来像属于每个平台
- en: So far, everything in the app has used the default styling provided by Uno Platform.
    Because Uno Platform bases everything on UWP and WinUI, our apps have been styled
    based on the Fluent Design system as this is the default on Windows. This is fine
    if we want our apps to look this way, but what if we want our apps to use the
    default styles for Android or iOS? Fortunately, Uno Platform has a solution for
    us. It provides libraries in the **Material** and **Cupertino** styles that we
    can apply to our apps. While these are native for Android and iOS devices, respectively,
    they can be used anywhere.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应用程序中的所有内容都使用了Uno Platform提供的默认样式。因为Uno Platform基于UWP和WinUI，我们的应用程序的样式是基于Fluent
    Design系统的，因为这是Windows的默认样式。如果我们希望我们的应用程序看起来这样，这是可以的，但是如果我们希望我们的应用程序使用Android或iOS的默认样式怎么办？幸运的是，Uno
    Platform为我们提供了解决方案。它为我们提供了**Material**和**Cupertino**样式的库，我们可以应用到我们的应用程序中。虽然这些库分别是为Android和iOS设备本地化的，但它们可以在任何地方使用。
- en: We'll now use the resources these libraries provide to apply the Material Design
    styling to the Android version of our app, and the Cupertino styles to the iOS
    version.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用这些库提供的资源，将Material Design样式应用于我们应用程序的Android版本，将Cupertino样式应用于iOS版本。
- en: Applying Material styles to the Android version of the app
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Material样式应用于应用程序的Android版本
- en: 'Let''s get started:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'We''ll start by adding a reference to the `Uno.Material` package to the *Android
    project*. Note that this is a prerelease package, so enable this if you''re searching
    via the UI:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先向*Android项目*添加对`Uno.Material`软件包的引用。请注意，这是一个预发布软件包，因此如果您通过UI搜索，请启用此软件包：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'While the `Uno.Material` library knows how to style controls, it doesn''t contain
    all the assets and references to use them. For this, *add* the `Xamarin.AndroidX.Lifecycle.LiveData`
    and `Xamarin.AndroidX.AppCompat.AppCompatResources` packages *to the Android project*:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然`Uno.Material`库知道如何为控件设置样式，但它并不包含所有资产和引用以使用它们。为此，*在Android项目*中*添加*`Xamarin.AndroidX.Lifecycle.LiveData`和`Xamarin.AndroidX.AppCompat.AppCompatResources`软件包：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To use the styles in the Android library, we must add them to the styles available
    in the app by referencing them in `App.xaml`:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Android库中使用样式，我们必须通过在`App.xaml`中引用它们来将它们添加到应用程序中可用的样式中：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Some controls will pick up Material styling automatically, while others will
    need to have the styles applied directly. To show this, we'll apply a specific
    style to the refresh `Button`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些控件将自动应用Material样式，而其他控件将需要直接应用样式。为了展示这一点，我们将为刷新`Button`应用特定样式。
- en: 'In `ArrivalsControl.xaml`, *add the Android namespace alias* to the top of
    the file. We will only use this when running on Android. Then, apply the style
    to the `Button` element:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ArrivalsControl.xaml`中，*在文件顶部添加Android命名空间别名*。我们只在Android上运行时才会使用这个。然后，将样式应用于`Button`元素：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Rather than using the Windows `CommandBar`, the Material Design system has
    a separate control that is more appropriate for showing navigation-related buttons
    at the bottom of the screen. This is called `BottomNavigationBar`. We''ll start
    by adding this to `MainPage.xaml` and wrapping the existing `CommandBar` in a
    `Grid` that will only be shown on Windows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与使用Windows `CommandBar`不同，Material Design系统具有一个单独的控件，更适合在屏幕底部显示与导航相关的按钮。这称为`BottomNavigationBar`。我们将首先将其添加到`MainPage.xaml`中，并将现有的`CommandBar`包装在一个`Grid`中，该`Grid`仅在Windows上显示：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If you run the app now, you'll see that the button and navigation bar are purple.
    This is part of a color scheme defined in the `Uno.Material` library. You can
    use your own color scheme by including a `ResourceDictionary` that provides different
    values for the predefined Material colors. Then, you can reference this when you
    add the resources shown in *step 2*. A guide to doing this can be found at [https://platform.uno/docs/articles/features/uno-material.html#getting-started](https://platform.uno/docs/articles/features/uno-material.html#getting-started).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在运行应用程序，您会看到按钮和导航栏是紫色的。这是`Uno.Material`库中定义的颜色方案的一部分。您可以通过包含提供预定义Material颜色的不同值的`ResourceDictionary`来使用自己的颜色方案。然后，当您添加*步骤2*中显示的资源时，您可以引用它。有关如何执行此操作的指南，请参阅[https://platform.uno/docs/articles/features/uno-material.html#getting-started](https://platform.uno/docs/articles/features/uno-material.html#getting-started)。
- en: Now that we've improved the app's look on Android, let's do the same for iOS.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经改善了Android上应用程序的外观，让我们为iOS做同样的事情。
- en: Applying Cupertino styles to the iOS version of the app
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Cupertino样式应用于应用程序的iOS版本
- en: 'Let''s get started:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: 'A separate package includes the Cupertino styles, so we must add a reference
    to `Uno.Cupertino` *in the iOS project*:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单独的软件包包含Cupertino样式，因此我们必须在iOS项目中添加对`Uno.Cupertino`的引用：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As with the Material package in the previous section, we need to load the resources
    from this package in `App.xaml` by adding the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一节中的Material软件包一样，我们需要通过添加以下内容在`App.xaml`中加载此软件包的资源：
- en: '[PRE30]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This package doesn't include a native tab bar control (a `UITabBar`) yet, but
    we can easily create something that matches Apple's Human Interface Guidelines.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此软件包尚未包含原生选项卡栏控件（`UITabBar`），但我们可以轻松创建与苹果的人机界面指南相匹配的内容。
- en: '*Add* the following to `MainPage.xaml`, after the `win:Grid` element:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*在`MainPage.xaml`中*添加*以下内容，添加到`win:Grid`元素之后：'
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: using Windows.UI.Xaml.Data;
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Windows.UI.Xaml.Data;
- en: 'public class CupertinoButtonColorConverter : IValueConverter'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: public class CupertinoButtonColorConverter：IValueConverter
- en: '{'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: public object Convert(object value, Type targetType,
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: public object Convert(object value, Type targetType，
- en: object parameter, string language)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对象参数，字符串语言）
- en: '{'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: if (value?.ToString() == parameter?.ToString())
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（value？.ToString() == parameter？.ToString()）
- en: '{'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return App.Current.Resources[
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: return App.Current.Resources[
- en: '"CupertinoBlueBrush"];'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '"CupertinoBlueBrush"];'
- en: '}'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: else
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 否则
- en: '{'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: return App.Current.Resources[
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: return App.Current.Resources[
- en: '"CupertinoSecondaryGrayBrush"];'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '"CupertinoSecondaryGrayBrush"];'
- en: '}'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public object ConvertBack(object value, Type
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: public object ConvertBack(object value, Type
- en: targetType, object parameter, string language)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: targetType，对象参数，字符串语言）
- en: => throw new NotImplementedException();
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: => 抛出未实现的异常();
- en: '}'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As with the Android project, the Cupertino styles won''t be automatically applied
    to the buttons in the app. However, rather than applying styles to each `Button`
    element directly, we can create an *implicit style* that will be applied to all
    the `Button` elements throughout the app. To do this, *modify* `App.xaml` to add
    the style, as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与Android项目一样，Cupertino样式不会自动应用于应用程序中的按钮。但是，我们可以创建一个*隐式样式*，将其应用于整个应用程序中的所有`Button`元素，而不是直接将样式应用于每个`Button`元素。要做到这一点，*修改*
    `App.xaml`以添加样式，如下所示：
- en: '[PRE33]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Implicit styles can be used for any platform so, if you wanted, you could do
    a similar thing in the Android version of the app.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式样式可以用于任何平台，因此，如果您愿意，您可以在应用程序的Android版本中执行类似的操作。
- en: We now have an app that looks like it belongs on each platform, and it can display
    content we retrieve from an external server. Now, let's look at how we can use
    the device's capabilities to create data and send it to a remote source.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个看起来属于每个平台的应用程序，并且它可以显示我们从外部服务器检索的内容。现在，让我们看看如何使用设备的功能来创建数据并将其发送到远程源。
- en: Accessing device capabilities
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问设备功能
- en: The final piece of functionality we'll add to the app is different from what
    we've done so far. So far we've looked at consuming data, but we'll now look at
    creating it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向应用程序添加的最后一个功能与我们迄今为止所做的不同。到目前为止，我们已经研究了消耗数据，但现在我们将研究如何创建数据。
- en: 'The requirement from the company for this part of the app is that it provides
    a way for staff to capture information whenever an incident occurs. An "incident"
    could be anything that the business may need to record or know about. It could
    be something minor such as a customer tripping while on company property to a
    major accident. All these incidents have something in common: that it''s beneficial
    to capture details when they happen rather than relying on people remembering
    details later. The goal is that giving staff a way to capture an image or some
    text as quickly and simply as possible will increase the amount of information
    that''s captured. The software will augment the captured information with the
    time and location of the incident and add who recorded it. This will be aggregated
    and further documented in a separate backend system.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 公司对应用程序的要求是，它提供了一种让员工在发生事故时捕获信息的方式。所谓的“事故”可以是企业可能需要记录或了解的任何事情。它可能是一些小事，比如顾客在公司财产上绊倒，也可能是一起重大事故。所有这些事件都有一个共同点：捕获详细信息比依靠人们以后记住细节更有益。目标是让员工尽可能快速、简单地捕获图像或一些文本，以增加捕获的信息量。软件将使用事件发生的时间和位置以及记录者的信息来增强捕获的信息。这些信息将被汇总并在一个单独的后端系统中进一步记录。
- en: 'Let''s create a simple way of meeting these requirements as a way of demonstrating
    how Uno Platform provides a way to use UWP APIs on different platforms:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一种简单的方式来满足这些要求，以演示Uno平台如何提供一种在不同平台上使用UWP API的方式：
- en: To use the camera and get the location of the device, we need to indicate that
    the app will require the permissions that are necessary to do this. The way we
    specify permissions is done slightly differently on each platform.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相机并获取设备位置，我们需要指示应用程序将需要必要的权限来执行此操作。我们在每个平台上指定权限的方式略有不同。
- en: On Android, open the project's `info.plist` and open it with `Package.appxmanfiest`,
    go to `CameraCaptureUI`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android上，打开项目的`info.plist`并使用`Package.appxmanfiest`打开它，转到`CameraCaptureUI`。
- en: 'We can create the UI by adding the following to `Grid` in `QuickReportControl.xaml`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过在`QuickReportControl.xaml`的`Grid`中添加以下内容来创建UI：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In `QuickReportControl.xaml.cs`, let''s add the code to handle what happens
    when the user clicks on the button to add a photo:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`QuickReportControl.xaml.cs`中，让我们添加处理用户单击按钮添加照片时发生的情况的代码：
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We''ll now create a method to encapsulate the logic to retrieve the device''s
    location:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个方法来封装检索设备位置的逻辑：
- en: '[PRE36]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The final step is to add the event handler for the `"success"` when valid data
    is submitted. The app checks for this and displays an appropriate message to the
    user.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是为“成功”提交有效数据时添加事件处理程序。应用程序会检查这一点，并向用户显示适当的消息。
- en: Note
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may think it will be more convenient to allow the user to speak to the app
    and record their voice. This is a sensible suggestion and something that could
    easily be added in the future. We're not including it here as most devices have
    built-in capabilities to use speech to text to enter details. It can be quicker
    and easier to use the existing functionality of a device rather than duplicating
    what's already there.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认为允许用户与应用程序交谈并记录他们的声音会更方便。这是一个明智的建议，也是可以很容易在将来添加的内容。我们在这里没有包括它，因为大多数设备都具有内置功能，可以使用语音转文字来输入详细信息。使用设备的现有功能可能比复制已有功能更快捷、更容易。
- en: 'With this final piece of functionality now complete, our app is finished. You
    can see how it looks when run in the following figure:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序已经完成了这最后一部分功能。您可以在下图中看到它的运行效果：
- en: '![Figure 4.4 – The Quick Report screen running on an iPhone (left) and showing
    a selected image, and an Android device (right) showing the entry of some dictated
    text'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4-快速报告屏幕在iPhone上运行（左）并显示所选图像，以及Android设备（右）显示输入的一些口述文本'
- en: '](img/Figure_4.04_B17132.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.04_B17132.jpg)'
- en: Figure 4.4 – The Quick Report screen running on an iPhone (left) and showing
    a selected image, and an Android device (right) showing the entry of some dictated
    text
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4-快速报告屏幕在iPhone上运行（左）并显示所选图像，以及Android设备（右）显示输入的一些口述文本
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we built an app that works on both iOS and Android devices.
    This allowed you to learn what it means to create "mobile" apps, work with remote
    data, apply native platform theming to apps, and use native device capabilities.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个可以在iOS和Android设备上运行的应用程序。这使您了解了创建“移动”应用程序的含义，处理远程数据，将本机平台主题应用于应用程序，并使用本机设备功能。
- en: In the next chapter, we'll build another mobile app. This will be different
    from the ones we've made so far in that it is intended to be used by customers
    rather than the company's staff. Among other things, we'll use this app as an
    opportunity to look at accessibility, localization, and using an SQLite database.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建另一个移动应用程序。这将与迄今为止制作的应用程序不同，因为它旨在供客户使用，而不是公司员工使用。除其他事项外，我们将利用这个应用程序来研究可访问性、本地化和使用SQLite数据库。
