- en: Functions as First-Class Citizens
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为一等公民
- en: In the previous chapter, we saw how Kotlin features relate to OOP. This chapter
    will introduce advanced functional programming features that were previously not
    present in standard Android development. Some of them were introduced in Java
    8 (in Android through the Retrolambda plugin), but Kotlin introduces many more
    functional programming features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了Kotlin特性与面向对象编程的关系。本章将介绍以前在标准Android开发中不存在的高级函数式编程特性。其中一些在Java 8中引入（通过Retrolambda插件在Android中引入），但Kotlin引入了更多的函数式编程特性。
- en: This chapter is about high-level functions and functions as first-class citizens.
    Most of the concepts are going to be familiar to readers who have used functional
    languages in the past.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章是关于高级函数和函数作为一等公民的。大多数概念对于过去使用过函数式语言的读者来说都是熟悉的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Function types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数类型
- en: Anonymous functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Lambda expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: Implicit name of a single parameter in a lambda expression
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lambda表达式中单个参数的隐式名称
- en: Higher-order functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Last lambda in argument convention
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个参数中的lambda约定
- en: Java **Single Abstract Method** (**SAM** ) lambda interface
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java **Single Abstract Method**（**SAM**）lambda接口
- en: Java methods with Java Single Abstract Method on parameters usage
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在参数上使用Java方法和Java Single Abstract Method
- en: Named parameters in function types
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数类型中的命名参数
- en: Type aliases
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型别名
- en: Inline functions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联函数
- en: Function references
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数引用
- en: Function type
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'Kotlin supports functional programming, and functions are first-class citizens
    in Kotlin. A first-class citizen, in a given programming language, is a term that
    describes an entity that supports all the operations generally available to other
    entities. These operations typically include being passed as an argument, returned
    from a function, and assigned to a variable. The sentence "*a function is a first-class
    citizen in Kotlin* " should then be understood as: *it is possible in Kotlin to
    pass functions as an argument, return them from functions, and assign them to
    variables* . While Kotlin is a statically typed language, there needs to be a
    function type defined to allow these operations. In Kotlin, the notation used
    to define a function type is following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin支持函数式编程，函数在Kotlin中是一等公民。在给定的编程语言中，一等公民是指支持其他实体通常可用的所有操作的实体。这些操作通常包括作为参数传递，从函数返回，并分配给变量。因此，“函数在Kotlin中是一等公民”这句话应该被理解为：“在Kotlin中可以将函数作为参数传递，从函数返回，并将其分配给变量”。虽然Kotlin是一种静态类型语言，但需要定义函数类型以允许这些操作。在Kotlin中，用于定义函数类型的表示法如下：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here are some examples:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些例子：
- en: '`(Int)->Int` : A function that takes `Int` as an argument and returns `Int`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(Int)->Int`：接受`Int`作为参数并返回`Int`的函数'
- en: '`()->Int` : A function that takes no arguments and returns `Int`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()->Int`：不接受任何参数并返回`Int`的函数'
- en: '`(Int)->Unit` : A function that takes `Int` and does not return anything (only
    `Unit` , which does not need to be returned)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(Int)->Unit`：接受`Int`并不返回任何东西（只有`Unit`，不需要返回）'
- en: 'Here are some examples of properties that can hold functions:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可以保存函数的属性的示例：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The term *function type* is most often defined as the type of a variable or
    parameter to which a function can be assigned, or the argument or result type
    of a higher-order function taking or returning a function. In Kotlin, the function
    type can be treated like an interface.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数类型*通常被定义为变量或参数的类型，可以将函数分配给它们，或者作为高阶函数的参数或结果类型。在Kotlin中，函数类型可以被视为接口。'
- en: 'We will see later in this chapter that Kotlin functions can take other functions
    in arguments, or even return them:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到，Kotlin函数可以在参数中接受其他函数，甚至返回它们：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If a function can take or return a function, then the function type also needs
    to be able to define functions that take a function as an argument, or return
    a function. This is done by simply placing a function type notation as a parameter
    or a return type. Here are some examples:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数可以接受或返回一个函数，那么函数类型也需要能够定义接受函数作为参数或返回函数的函数。这可以通过简单地将函数类型表示法放置为参数或返回类型来实现。以下是一些例子：
- en: '`(String)->(Int)->Int` : A function that takes `String` and returns a function
    that takes `Int` type and returns `Int` .'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(String)->(Int)->Int`：接受`String`并返回一个接受`Int`类型并返回`Int`的函数。'
- en: '`(()->Int)->String` : A function that takes another function as an argument,
    and returns `String` type. Function in argument takes no arguments and returns
    `Int` .'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(()->Int)->String`：接受另一个函数作为参数，并返回`String`类型的函数。参数中的函数不接受任何参数，并返回`Int`。'
- en: 'Each property with a function type can be called like a function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个带有函数类型的属性都可以像函数一样被调用：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Functions can not only be stored in variables, they can also be used as a generic.
    For example, we can keep the functions in the list:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不仅可以存储在变量中，还可以用作泛型。例如，我们可以将函数保存在列表中：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding list can store functions with the `() -> Unit` signature.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表可以存储带有`() -> Unit`签名的函数。
- en: What is function type under the hood?
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 底层的函数类型是什么？
- en: 'Under the hood, function types are just a syntactic sugar for generic interfaces.
    Let''s look at some examples:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，函数类型只是泛型接口的一种语法糖。让我们看一些例子：
- en: The `()->Unit` signature is an interface for `Function0<Unit>` . The expression
    is `Function0` , because it has zero parameters, and `Unit` because it is the
    return type.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()->Unit`签名是`Function0<Unit>`的接口。表达式是`Function0`，因为它没有参数，而`Unit`是返回类型。'
- en: The `(Int)->Unit` signature is interface for `Function1<Int, Unit>` . The expression
    is `Function1` because it has one parameter.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(Int)->Unit`签名是`Function1<Int, Unit>`的接口。表达式是`Function1`，因为它有一个参数。'
- en: The `()->(Int, Int)->String` signature is an interface for `Function0<Function2<Int,
    Int, String>>` .
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()->(Int, Int)->String`签名是`Function0<Function2<Int, Int, String>>`的接口。'
- en: 'All of these interfaces have only one method, `invoke` , which is an operator.
    It allows an object to be used like a function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些接口只有一个方法，`invoke`，它是一个操作符。它允许对象像函数一样使用：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These two statements have the same meaning
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这两个语句具有相同的含义
- en: Function interfaces are not present in a standard library. They are synthetic
    compiler-generated types (they are generated during compilation). Because of this,
    there is no artificial limit in number of function type arguments, and the standard
    library size is not increased.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接口不在标准库中。它们是合成的编译器生成的类型（它们在编译过程中生成）。因此，函数类型参数的数量没有人为限制，标准库的大小也不会增加。
- en: Anonymous functions
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数
- en: 'One way of defining a function as an object is by using **anonymous functions**
    . They work the same way as normal functions, but they have no name between the
    `fun` keyword and the parameters declaration, so by default they are treated as
    objects. Here are a few examples:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 定义函数为对象的一种方式是使用**匿名函数**。它们的工作方式与普通函数相同，但在`fun`关键字和参数声明之间没有名称，因此默认情况下它们被视为对象。以下是一些示例：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is an anonymous single expression function. Note that like in a normal
    single expression function, the return type does not need to be specified when
    it is inferred from the expression return type.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个匿名的单表达式函数。请注意，与普通的单表达式函数一样，当它从表达式返回类型中推断出时，不需要指定返回类型。
- en: 'Consider the following usage:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用法：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the previous examples, function types were defined explicitly, but while
    Kotlin has a good type inference system, the function type can also be inferred
    from types defined by an anonymous default function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，函数类型是显式定义的，但是由于Kotlin有很好的类型推断系统，函数类型也可以从匿名默认函数定义的类型中推断出来：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It also works in the opposite way. When we define the type of a property, then
    we don''t need to set parameter types in anonymous functions explicitly, because
    they are inferred:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以反过来。当我们定义属性的类型时，我们不需要在匿名函数中显式设置参数类型，因为它们是从表达式返回类型中推断出来的：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we check out the methods of function types, then we will see that there
    is only the `invoke` method inside. The `invoke` method is an operator function,
    and it can be used in the same way as function invocation. This is why the same
    result can be achieved by using the `invoke` call inside brackets:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看函数类型的方法，那么我们将看到里面只有`invoke`方法。`invoke`方法是一个操作符函数，它可以像函数调用一样使用。这就是为什么可以通过在括号内使用`invoke`调用来实现相同的结果：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This knowledge can be helpful, for example, when we are keeping function in
    a nullable variable. We can, for example, use the `invoke` method by using the
    safe call:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种知识在某些情况下是有帮助的，比如当我们将函数保存在可空变量中时。例如，我们可以使用`invoke`方法通过安全调用：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Variable `a` is nullable, we are using invoke by a safe call.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量`a`是可空的，我们使用安全调用来调用。
- en: 'Let''s look at an Android example. We often want to define a single error handler
    that will include multiple logging methods and pass it to different objects as
    an argument. Here is how we can implement it using anonymous functions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个Android示例。我们经常希望定义一个单一的错误处理程序，其中包括多个日志记录方法，并将其作为参数传递给不同的对象。以下是我们可以使用匿名函数来实现它的方式：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Anonymous functions are simple and useful. They are a simple way of defining
    functions that can be used and passed as objects. But there is a simpler way of
    achieving similar behavior, and it is called lambda expressions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数简单而有用。它们是定义可以用作对象并传递的函数的简单方式。但是有一种更简单的方法可以实现类似的行为，它被称为lambda表达式。
- en: Lambda expressions
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: 'The simplest way to define anonymous functions in Kotlin is by using a feature
    called lambda expressions. They are similar to Java 8 lambda expressions, but
    the biggest difference is that Kotlin lambdas are actually closures, so they allow
    us to change variables from the creation context. This is not allowed in Java
    8 lambdas. We will discuss this difference later in this section. Let''s start
    with some simple examples. Lambda expressions in Kotlin have the following notation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中定义匿名函数的最简单方式是使用一个称为lambda表达式的特性。它们类似于Java 8的lambda表达式，但最大的区别是Kotlin的lambda实际上是闭包，因此允许我们从创建上下文更改变量。这在Java
    8的lambda中是不允许的。我们将在本节后面讨论这种差异。让我们从一些简单的示例开始。Kotlin中的lambda表达式具有以下表示法：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Instead of return, result of the last expression is returned. Here are some
    simple lambda expression examples:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值是最后一个表达式的结果。以下是一些简单的lambda表达式示例：
- en: '`{ 1 }` : A lambda expression that takes no arguments and returns 1\. Its type
    is `()->Int` .'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ 1 }`：一个lambda表达式，不接受参数并返回1。它的类型是`()->Int`。'
- en: '`{ s: String -> println(s) }` : A lambda expression that takes one argument
    of type `String` , and prints it. It returns `Unit` . Its type is `(String)->Unit`
    .'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ s: String -> println(s) }`：一个lambda表达式，接受一个`String`类型的参数，并打印它。它返回`Unit`。它的类型是`(String)->Unit`。'
- en: '`{ a: Int, b: Int -> a + b }` : A lambda expression that takes two `Int` arguments
    and returns the sum of them. Its type is `(Int, Int)->Int` .'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{ a: Int, b: Int -> a + b }`：一个lambda表达式，接受两个`Int`参数并返回它们的和。它的类型是`(Int, Int)->Int`。'
- en: 'Functions we defined in the previous chapter can be defined using lambda expressions:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中定义的函数可以使用lambda表达式来定义：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While the returned value is taken from the last statement in lambda expressions,
    return is not allowed unless it has a `return` statement qualified by a label:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然lambda表达式中的返回值是从最后一个语句中取得的，但是除非有带有标签的`return`语句，否则是不允许使用`return`的：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lambda expressions can be multiline:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式可以是多行的：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is the last statement, so the result of this expression will be a returned
    value.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是最后一个语句，因此这个表达式的结果将是一个返回值。
- en: 'Multiple statements can also be defined in a single line when they are separated
    by semicolons:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 多个语句也可以在一行中定义，当它们用分号分隔时：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A lambda expression does not need to only operate on values provided by arguments.
    Lambda expressions in Kotlin can use all properties and functions from the context
    where they are created:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式不仅需要操作由参数提供的值。Kotlin中的lambda表达式可以使用创建它们的上下文中的所有属性和函数：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is the biggest difference between Kotlin and Java 8 lambda usage. Both
    Java anonymous objects and Java 8 lambda expressions allow us to use fields from
    the context, but Java does not allow us to assign different values to these variables
    (Java variables used in lambda must be final):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Kotlin和Java 8 lambda使用之间最大的区别。Java匿名对象和Java 8 lambda表达式都允许我们使用上下文中的字段，但Java不允许我们为这些变量分配不同的值（lambda中使用的Java变量必须是final）：
- en: '![](img/Image00036.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00036.jpg)'
- en: 'Kotlin has gone a step ahead by allowing lambda expressions and anonymous functions
    to modify these variables. Lambda expressions that enclose local variables and
    allow us to change them inside the function body are called **closures** . Kotlin
    fully supports closure definition. To avoid confusion between lambdas and closures,
    in this book, we will always call both of them lambdas. Let''s look at an example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin通过允许lambda表达式和匿名函数修改这些变量迈出了一步。包围局部变量并允许我们在函数体内更改它们的lambda表达式称为**闭包**。Kotlin完全支持闭包定义。为了避免混淆lambda和闭包，在本书中，我们将始终称它们为lambda。让我们看一个例子：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lambda expressions can use and modify variables from the local context. Here
    is an example of counter, where the value is kept in a local variable:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式可以使用和修改局部上下文中的变量。这是一个计数器的例子，其中值保存在一个局部变量中：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here is how View `onClickListener` can be set in Kotlin using a lambda expression.
    This will be described in the *Java SAM support in Kotlin* section.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是如何在Kotlin中使用lambda表达式设置View `onClickListener`。这将在*Java SAM support in Kotlin*部分中描述。
- en: 'Thanks to this feature, it is simpler to use lambda expressions. Note that,
    in the preceding example, the `showValue` type was not specified. This is because
    in Kotlin lambdas, typing arguments is optional when the compiler can infer it
    from the context:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个特性，使用lambda表达式变得更简单。请注意，在前面的例子中，没有指定`showValue`的类型。这是因为在Kotlin lambda中，当编译器可以从上下文中推断出类型时，参数的类型是可选的：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The inferred type of `i` is `Int` , because the function type defines an `Int`
    parameter.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`i`的推断类型是`Int`，因为函数类型定义了一个`Int`参数。'
- en: The inferred type of `s` is `String` , because the function type defines a `String`
    parameter.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`s`的推断类型是`String`，因为函数类型定义了一个`String`参数。'
- en: 'As we can see in the following example, we don''t need to specify the type
    of parameter because it is inferred from the type of the property. Type inference
    also works in the another way--we can define the type of a lambda expression''s
    parameter to infer the property type:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下面的例子中看到的，我们不需要指定参数的类型，因为它是从属性的类型中推断出来的。类型推断也可以以另一种方式工作--我们可以定义lambda表达式的参数类型以推断属性类型：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The inferred type is `()->Int` , because `4` is `Int` and there is no parameter
    type.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推断的类型是`()->Int`，因为`4`是`Int`，并且没有参数类型。
- en: The inferred type is `(String)->Unit` , because the parameter is typed as `String`
    , and the return type of the `println` method is `Unit` .
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推断的类型是`(String)->Unit`，因为参数被定义为`String`，而`println`方法的返回类型是`Unit`。
- en: The inferred type is `(Int)->Int` , because `i` is typed as `Int` , and the
    return type of the times operation from `Int` is also `Int` .
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推断的类型是`(Int)->Int`，因为`i`被定义为`Int`，并且`Int`的times操作的返回类型也是`Int`。
- en: This inference simplifies lambda expression definition. Often, when we are defining
    lambda expressions as function parameters, we don't need to specify parameter
    types each time. But there is also another benefit--while the parameter type can
    be inferred, a simpler notation for single parameter lambda expressions can be
    used. Let's discuss this in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种推断简化了lambda表达式的定义。通常，在我们将lambda表达式定义为函数参数时，我们不需要每次指定参数类型。但还有另一个好处--虽然参数类型可以被推断，但可以使用更简单的表示法来表示单个参数的lambda表达式。让我们在下一节中讨论这个问题。
- en: Implicit name of a single parameter
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单个参数的隐式名称
- en: 'We can omit lambda parameter definitions and access parameters using the `it`
    keyword when two conditions are met:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当满足两个条件时，我们可以省略lambda参数定义并使用`it`关键字访问参数：
- en: There is only one parameter
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个参数
- en: Parameter type can be inferred from the context
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数类型可以从上下文中推断出来
- en: 'As an example, let''s define the properties `a` and `c` again, but this time
    using the implicit name of a single parameter:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们再次定义属性`a`和`c`，但这次使用单个参数的隐式名称：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Same as `{ i -> i * 2 }` .
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`{ i -> i * 2 }`相同。
- en: Same as `{ s -> println(s) }` .
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`{ s -> println(s) }`相同。
- en: 'This notation is really popular in Kotlin, mostly because it is shorter and
    it allows us to avoid parameter type specification. It also improves the readability
    of processing defined in LINQ style. This style needs components that have not
    yet been introduced, but just to show the idea, let''s see an example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示法在Kotlin中非常流行，主要是因为它更短，可以避免参数类型的指定。它还提高了LINQ风格中定义的处理的可读性。这种风格需要尚未介绍的组件，但只是为了展示这个想法，让我们看一个例子：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Supposing that strings is `List<String>` , this expression filters strings with
    a length equal to `5` and converts them to uppercase.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 假设strings是`List<String>`，这个表达式会过滤长度等于`5`的字符串，并将它们转换为大写。
- en: Note that in the body of lambda expressions, we can use methods of the `String`
    class. This is because function type (such as `(String)->Boolean` for the `filter`
    ) is interred from the method definition, which infers `String` from the iterable
    type (`List<String>` ). Also, the type of the returned list (`List<String>` )
    depends on what is returned by the lambda (`String` ).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在lambda表达式的主体中，我们可以使用`String`类的方法。这是因为函数类型（例如`filter`的`(String)->Boolean`）是从方法定义中推断出来的，它从可迭代类型（`List<String>`）中推断出`String`。此外，返回的列表的类型（`List<String>`）取决于lambda返回的内容（`String`）。
- en: LINQ style is popular in functional languages because it makes the syntax of
    collections or String processing really simple and concise. It will be discussed
    in much more detail in [Chapter 7](text00171.html) , *Extension Functions and
    Properties* .
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ风格在函数式语言中很受欢迎，因为它使集合或字符串处理的语法变得非常简单和简洁。它将在[第7章](text00171.html) *扩展函数和属性*中更详细地讨论。
- en: Higher-order functions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'A higher-order function is a function that takes at least one function as an
    argument, or returns a function as its result. It is fully supported in Kotlin,
    as functions are first-class citizens. Let''s see it in an example. Let''s suppose
    that we need two functions: a function that will add all `BigDecimal` numbers
    from list, and a function that will get the product (the result of multiplication
    between all the elements in this list) of all these numbers:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是一个至少接受一个函数作为参数或将函数作为其结果返回的函数。在Kotlin中，它得到了充分的支持，因为函数是一等公民。让我们在一个例子中看看它。假设我们需要两个函数：一个函数将从列表中添加所有`BigDecimal`数字，另一个函数将得到所有这些数字的乘积（列表中所有元素之间的乘法结果）：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These are readable functions, but also these functions are nearly the same.
    The only difference is name, accumulator (`BigDecimal.ZERO` or `BigDecimal.ONE`
    ), and operation. If we use the **DRY** (**Don''t Repeat Yourself** ) rule then
    we shouldn''t leave two parts of similar code in the project. While it is easy
    to define a function that will have similar behavior and just differ in the objects
    used, it is harder to define a function that will differ in the operation performed
    (here, functions differ by the operation used to accumulate). Solution comes with
    the function type, because we can pass the operation as an argument. In this example,
    it is possible to extract the common method this way:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可读的函数，但这些函数几乎相同。唯一的区别是名称、累加器（`BigDecimal.ZERO`或`BigDecimal.ONE`）和操作。如果我们遵循**DRY**（**不要重复自己**）规则，那么我们不应该在项目中留下两个相似代码的部分。虽然很容易定义一个函数，它将具有类似的行为，只是使用的对象不同，但很难定义一个函数，它将根据执行的操作不同（这里，函数根据用于累加的操作不同）。解决方案是使用函数类型，因为我们可以将操作作为参数传递。在这个例子中，可以这样提取公共方法：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `fold` function iterates through numbers and updates `acc` using each element.
    Note that the function parameter is defined like any other type, and it can be
    used like any other function. For example, we can have the vararg function type
    parameter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`fold`函数遍历数字并使用每个元素更新`acc`。请注意，函数参数像任何其他类型一样定义，并且可以像任何其他函数一样使用。例如，我们可以有可变参数函数类型参数：'
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `longOperation` , `for` is used to iterate over all the observers and invokes
    them one after another. This function allows multiple functions to be provided
    as arguments. Here''s an example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`longOperation`中，`for`用于迭代所有观察者并依次调用它们。这个函数允许提供多个函数作为参数。这里是一个例子：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Functions in Kotlin can also return functions. For example, we can define a
    function that will create custom error handlers with the same error logging but
    different tags:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中的函数也可以返回函数。例如，我们可以定义一个函数，它将创建具有相同错误日志记录但不同标记的自定义错误处理程序：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The three most common cases when functions in arguments are used are:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数中使用函数的三种最常见情况是：
- en: Providing operations to functions
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为函数提供操作
- en: The observer (listener) pattern
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者（监听器）模式
- en: Callback after a threaded operation
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程操作后的回调
- en: Let's look at them in detail.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看它们。
- en: Providing operations to functions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为函数提供操作
- en: 'As we saw in the previous section, sometimes we want to extract common functionality
    from functions, but they differ in an operation they use. In such situations,
    we can still extract this functionality, but we need to provide an argument with
    operation that distinguishes them. This way, any common pattern can be extracted
    and reused. For example, we often only need elements of the list that match some
    predicate, such as when we only want to show elements that are active. Classically,
    this would be implemented like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中看到的，有时我们想从函数中提取公共功能，但它们在使用的操作上有所不同。在这种情况下，我们仍然可以提取这个功能，但是我们需要提供一个区分它们的操作参数。这样，任何常见的模式都可以被提取和重用。例如，我们通常只需要列表中与某些谓词匹配的元素，比如当我们只想显示活动元素时。传统上，这样实现：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'While it is a common operation, we can extract the functionality of only filtering
    some elements according to the predicate to separate the function and use it more
    easily:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个常见的操作，但我们可以提取仅根据谓词过滤一些元素的功能，以分离函数并更容易使用它：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This way of using higher-order functions is very important and it will be described
    often throughout the book, but this is not the only way that higher-order functions
    are often used.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高阶函数的这种方式非常重要，并且在整本书中经常会被描述，但这并不是高阶函数经常被使用的唯一方式。
- en: Observer (Listener) pattern
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者（监听器）模式
- en: 'We use the Observer (Listener) pattern when we want to perform operations when
    an event occurs. In Android development, observers are often set to view elements.
    Common examples are on-click listeners, on-touch listeners, or text watchers.
    In Kotlin, we can set listeners with no boilerplate. For example, setting listener
    on button click looks as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件发生时，我们使用观察者（监听器）模式来执行操作。在Android开发中，观察者经常设置为视图元素。常见的例子是点击监听器、触摸监听器或文本监视器。在Kotlin中，我们可以在没有样板文件的情况下设置监听器。例如，设置按钮点击监听器如下所示：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Note that the `setOnClickListener` is a Java method from the Android library.
    Later, we will see in detail why we can use it with lambda expression. The creation
    of listeners is very simple. Here is an example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`setOnClickListener`是Android库中的一个Java方法。稍后，我们将详细看到为什么我们可以使用它与lambda表达式。监听器的创建非常简单。这是一个例子：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we create an empty list to hold all listeners.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个空列表来保存所有监听器。
- en: We can simply add a listener to the listeners list.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以简单地将监听器添加到监听器列表中。
- en: We can iterate through the listeners and invoke them one after another.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以遍历监听器并依次调用它们。
- en: It is hard to imagine a simpler implementation of this pattern. There is another
    common use case where parameters with function types are commonly used--callback
    after a threaded operation.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象有一个更简单的实现方式。还有另一个常见的用例，即在线程操作后常用的参数。
- en: Callback after a threaded operation
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程操作后的回调
- en: 'If we need to do a long operation, and we don''t want to make the user wait
    for it, then we have to start it in another thread. To be able to use callback
    after long operation called in separate thread, we need to pass it as an argument.
    Here''s an example function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要执行一个长时间的操作，并且不想让用户等待，那么我们必须在另一个线程中启动它。为了能够在单独的线程中调用长时间操作后的回调，我们需要将其作为参数传递。这是一个示例函数：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we create `Thread` . We also pass a lambda expression that we would like
    to execute on the constructor argument.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们创建`Thread`。我们还传递了一个我们想要在构造函数参数上执行的lambda表达式。
- en: Here, we are executing a long operation.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们正在执行一个长时间的操作。
- en: Here, we start the callback operation provided in the argument.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们启动了提供的回调操作。
- en: '`start` is a method that starts the defined thread.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`start`是启动定义线程的方法。'
- en: Is printed after one second delay.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一秒延迟后打印。
- en: Is printed immediately .
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 立即打印。
- en: Actually, there are some popular alternatives to using callbacks, such as RxJava.
    Still, classic callbacks are in common use, and in Kotlin they can be implemented
    with no boilerplate.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有一些流行的替代方案可以使用回调，例如RxJava。不过，经典的回调仍然常用，在Kotlin中可以无样板实现。
- en: These are the most common use cases where higher-order functions are used. All
    of them allow us to extract common behavior and decrease boilerplate. Kotlin allows
    a few more improvements regarding higher-order functions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用高阶函数的最常见用例。所有这些都允许我们提取公共行为并减少样板文件。Kotlin允许在高阶函数方面进行一些改进。
- en: Combination of named arguments and lambda expressions
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名参数和lambda表达式的组合
- en: 'Using default named arguments and lambda expressions can be really useful in
    Android. Let''s look at some other practical Android examples. Let''s suppose
    we have a function that downloads elements and shows them to user. We will add
    a few parameters:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中使用默认命名参数和lambda表达式可以非常有用。让我们看一些其他实际的Android示例。假设我们有一个函数，它下载元素并将它们显示给用户。我们将添加一些参数：
- en: '`onStart` : This will be called before the network operation'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStart`：这将在网络操作之前调用'
- en: '`onFinish` : This will be called after the network operation'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onFinish`：这将在网络操作之后调用'
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we can show and hide loading spinner in `onStart` and `onFinish` :'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`onStart`和`onFinish`中显示和隐藏加载旋转器：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we start it from `swipeRefresh` , then we just need to hide it when it finishes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从`swipeRefresh`开始，那么当它完成时我们只需要隐藏它：
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we want to make a quiet refresh, then we just call this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想进行一个安静的刷新，那么我们只需调用这个：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Named argument syntax and lambda expressions are a perfect match for multi-purpose
    functions. This connects both the ability to choose the arguments we want to implement
    and the operations that should be implemented. If a function contains more than
    one function type parameter, then in most cases, it should be used by named argument
    syntax. This is because lambda expressions are rarely self-explanatory when more
    than one is used as arguments.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数语法和lambda表达式是多用途函数的完美匹配。这连接了选择要实现的参数和应该实现的操作的能力。如果一个函数包含多个函数类型参数，那么在大多数情况下，应该使用命名参数语法。这是因为当使用多个lambda表达式作为参数时，它们很少是自解释的。
- en: Last lambda in argument convention
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数约定中的最后一个lambda
- en: 'In Kotlin, higher-order functions are really important, and so it is also important
    to make their usage as comfortable as possible. This is why Kotlin introduced
    a special convention that makes higher-order functions more simple and clear.
    It works this way: if the last parameter is a function, then we can define a lambda
    expression outside of the brackets. Let''s see how it looks if we use it with
    the `longOperationAsync` function, which is defined as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，高阶函数非常重要，因此使它们的使用尽可能舒适也很重要。这就是为什么Kotlin引入了一种特殊的约定，使高阶函数更简单和清晰。它的工作方式是：如果最后一个参数是一个函数，那么我们可以在括号外定义lambda表达式。让我们看看如果我们将其与`longOperationAsync`函数一起使用，该函数定义如下：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The function type is in the last position in the arguments. This is why we
    can execute it this way:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 函数类型在参数的最后位置。这就是为什么我们可以这样执行它：
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Thanks to the last lambda in argument convention, we can locate the lambda after
    the brackets. It looks as if it is outside the arguments.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于最后一个lambda在参数约定中，我们可以将lambda定位在括号后面。看起来好像它在参数之外。
- en: 'As an example, let''s see how the invocation of code in another thread can
    be done in Kotlin. The standard way of starting a new thread in Kotlin is by using
    the `thread` function from Kotlin standard library. Its definition is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看看在Kotlin中如何在另一个线程中调用代码。在Kotlin中启动新线程的标准方式是使用Kotlin标准库中的`thread`函数。它的定义如下：
- en: '[PRE41]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As we can see, the `block` parameter, which takes operations that should be
    invoked asynchronously, is in the last position. All other parameters have a default
    argument defined. That is why we can use the `thread` function in this way:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`block`参数，它接受应该异步调用的操作，位于最后位置。所有其他参数都有默认参数定义。这就是为什么我们可以这样使用`thread`函数：
- en: '[PRE42]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `thread` definition has lots of other arguments, and we can set them either
    by using named argument syntax or just by providing them one after another:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`thread`定义有很多其他参数，我们可以通过使用命名参数语法或依次提供它们来设置它们：'
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The last lambda in argument convention is syntactic sugar, but it makes it
    much easier to use higher-order functions. These are the two most common cases
    where this convention really makes a difference:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 参数约定中的最后一个lambda是语法糖，但它使使用高阶函数变得更容易。这是这种约定真正产生差异的两种最常见情况：
- en: Named code surrounding
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名代码周围
- en: Processing data structures using LINQ-style
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LINQ风格处理数据结构
- en: Let's look at them closely.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看它们。
- en: Named code surrounding
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名代码环绕
- en: 'Sometimes we need to mark some part of the code to be executed in different
    way. The `thread` function is this kind of situation. We need some code to be
    executed asynchronously, so we surround it with bracket starting from the `thread`
    function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要标记代码的某些部分以不同的方式执行。`thread`函数就是这种情况。我们需要一些代码以异步方式执行，因此我们用从`thread`函数开始的括号将其包围起来。
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'From the outside, it looks as if it is a part of code that is surrounded by
    a block named `thread` . Let''s look at another example. Let''s suppose that we
    want to log the execution time of a certain code block. As a helper, we will define
    the `addLogs` function, which will print logs together with the execution time.
    We will define it in the following way:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从外部看，它看起来好像是由名为`thread`的块包围的代码的一部分。让我们看另一个例子。假设我们想要记录某个代码块的执行时间。作为辅助，我们将定义`addLogs`函数，它将与执行时间一起打印日志。我们将以以下方式定义它：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following is the usage of the function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该函数的用法：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here''s an example of its execution:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其执行示例：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'On executing the preceding code, the following output is presented:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行前面的代码时，将呈现以下输出：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The exact number of printed milliseconds may differ a little bit.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 打印的毫秒数可能会有所不同。
- en: 'This pattern is really useful in Kotlin projects because some patterns are
    connected to blocks of code. For example, it is common to check whether the version
    of the API is after Android 5.x Lollipop before the execution of features that
    need at least this version to work. To check it, we used the following condition:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式在Kotlin项目中非常有用，因为一些模式与代码块相关联。例如，在执行至少需要此版本才能工作的功能之前，通常会检查API的版本是否在Android
    5.x Lollipop之后。为了检查它，我们使用了以下条件：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'But in Kotlin, we can just extract the function in the following way:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但在Kotlin中，我们可以以以下方式提取函数：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is not only comfortable, but also it is lowering redundancy in the code.
    This is often referred as very good practice. Also note that this convention allows
    us to define control structures that work in a similar way to standard ones. We
    can, for example, define a simple control structure that is running as long as
    the statement in the body does not return an error. Here is the definition and
    usage:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅舒适，而且还减少了代码中的冗余。这通常被称为非常好的实践。还要注意，这种约定使我们能够定义与标准结构类似工作的控制结构。例如，我们可以定义一个简单的控制结构，只要主体中的语句不返回错误，就会一直运行。以下是定义和用法：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: An additional advantage is that our custom data structure can return a value.
    The impressive part is that is doesn't need any extra language support, and we
    can define nearly any control structure we want.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的优势是我们的自定义数据结构可以返回一个值。令人印象深刻的是，它不需要任何额外的语言支持，我们可以定义几乎任何我们想要的控制结构。
- en: Processing data structures using LINQ style
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LINQ风格处理数据结构
- en: 'We''ve already mentioned that Kotlin allows LINQ-style processing. The last
    lambda in argument convention is another component that aids its readability.
    For example, look at the following code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到Kotlin允许LINQ风格的处理。参数中的最后一个lambda约定是另一个有助于其可读性的组件。例如，看下面的代码：
- en: '[PRE52]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'It is more readable than notation that does not use the last lambda in argument
    convention:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它比不使用参数中的最后一个lambda约定的表示法更易读：
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Again, this processing will be discussed in detail later, in [Chapter 7](text00171.html)
    , *Extension Functions and Properties* , but for now we have learned about two
    features that improve its readability (the last lambda in argument convention
    and the implicit name of a single parameter).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这种处理将在稍后的[第7章](text00171.html)中详细讨论，*扩展函数和属性*，但现在我们已经了解了两个改进其可读性的特性（参数中的最后一个lambda约定和单个参数的隐式名称）。
- en: The last lambda in argument convention is one of the Kotlin features that was
    introduced to improve the use of lambda expressions. There are more such improvements,
    and how they work together is important to make the use of higher-order functions
    simple, readable, and efficient.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 参数中的最后一个lambda约定是Kotlin引入的一个特性，旨在改进lambda表达式的使用。还有更多这样的改进，它们如何一起工作对于使高阶函数的使用简单、可读和高效非常重要。
- en: Java SAM support in Kotlin
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin中的Java SAM支持
- en: 'It is really easy to use higher-order functions in Kotlin. The problem is that
    we often need to interoperate with Java, which natively doesn''t support it. It
    achieves substitution by using interfaces with only one method. This kind of interface
    is called a **Single Abstract Method** (**SAM** ) or functional interface. The
    best example of situation in which we need to set up a function this way, is when
    we are using `setOnClickListener` on a `View` element. In Java (until 8) there
    was no simpler way than by using an anonymous inner class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中使用高阶函数非常容易。问题在于，我们经常需要与Java进行交互，而Java本身不支持它。它通过使用只有一个方法的接口来实现替代。这种接口称为**单一抽象方法**（**SAM**）或功能接口。我们需要以这种方式设置函数的最佳示例是在使用`View`元素上的`setOnClickListener`时。在Java（直到8）中，没有比使用匿名内部类更简单的方法：
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In the preceding example, the `OnClickListener` method is the SAM, because
    it contains only a single method, `onClick` . While SAMs are really often used
    as a replacement for function definitions, Kotlin also generates a constructor
    for them that contains the function type as a parameter. It is called a SAM constructor.
    A SAM constructor allows us to create an instance of a Java SAM interface just
    by calling its name and passing a *function literal* . Here''s an example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`OnClickListener`方法是SAM，因为它只包含一个方法`onClick`。虽然SAM经常被用作函数定义的替代，但Kotlin也为它们生成了一个包含函数类型作为参数的构造函数。它被称为SAM构造函数。SAM构造函数允许我们通过调用其名称并传递*函数文字*来创建Java
    SAM接口的实例。以下是一个例子：
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'A *function literal* is an expression that defines unnamed function. In Kotlin,
    there are two kinds of *function literal* :'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数文字*是定义未命名函数的表达式。在Kotlin中，有两种*函数文字*：'
- en: 1\. Anonymous functions
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 匿名函数
- en: 2\. Lambda expressions
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 2. Lambda表达式
- en: 'Both Kotlin *function literal* have already been described:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin *function literal* 已经被描述过了：
- en: '`val a = fun() {} // Anonymous function`'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`val a = fun() {} // Anonymous function`'
- en: '`val b = {} // Lambda expression`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`val b = {} // Lambda expression`'
- en: 'Even better, for each Java method that takes a SAM, the Kotlin compiler is
    generating a version that instead takes a function as an argument. This is why
    we can set `OnClickListener` as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，对于每个接受 SAM 的 Java 方法，Kotlin 编译器都会生成一个接受函数作为参数的版本。这就是为什么我们可以这样设置 `OnClickListener`：
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Remember that the Kotlin compiler is generating SAM constructors and function
    methods only for Java SAMs. It is not generating SAM constructors for Kotlin interfaces
    with a single method. It is because the Kotlin community is pushing to use function
    types and not SAMs in Kotlin code. When a function is written in Kotlin and includes
    a SAM, then we cannot use it as Java methods with SAM on parameter:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Kotlin 编译器只为 Java SAM 生成 SAM 构造函数和函数方法。它不会为具有单个方法的 Kotlin 接口生成 SAM 构造函数。这是因为
    Kotlin 社区正在推动在 Kotlin 代码中使用函数类型而不是 SAM。当一个函数是用 Kotlin 编写的并包含 SAM 时，我们无法将其用作具有
    SAM 参数的 Java 方法：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This does not work because the `setOnClick` function is written in Kotlin.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这不起作用，因为 `setOnClick` 函数是用 Kotlin 编写的。
- en: 'In Kotlin, interfaces shouldn''t be used this way. The preferred way is to
    use function types instead of SAMs:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，不应该以这种方式使用接口。首选的方式是使用函数类型而不是 SAM：
- en: '[PRE58]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The Kotlin compiler generates a SAM constructor for every SAM interface defined
    in Java. This interface only includes the function type that can substitute a
    SAM. Look at the following interface:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 编译器为在 Java 中定义的每个 SAM 接口生成一个 SAM 构造函数。这个接口只包括可以替代 SAM 的函数类型。看看下面的接口：
- en: '[PRE59]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can use it in Kotlin this way:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Kotlin 中这样使用它：
- en: '[PRE60]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Or we can provide it as function argument:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以将其作为函数参数提供：
- en: '[PRE61]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here are more examples of the Java SAM lambda interface and methods from Android:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Java SAM lambda 接口和 Android 方法的更多示例：
- en: '[PRE62]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'And here''s some examples from RxJava:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自 RxJava 的一些示例：
- en: '[PRE63]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, let's look at how a Kotlin alternative to SAM definition can be implemented.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Kotlin 中如何实现对 SAM 定义的替代方案。
- en: Named Kotlin function types
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名 Kotlin 函数类型
- en: 'Kotlin does not support SAM conversions of types defined in Kotlin, because
    the preferred way is to use function types instead. But SAM has some advantages
    over classic function types: named and named parameters. It is good to have the
    function type named when its definition is long or it is passed multiple times
    as an argument. It is good to have named parameters when it is not clear what
    each parameter means just by its type.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 不支持在 Kotlin 中定义的类型的 SAM 转换，因为首选的方式是使用函数类型。但是 SAM 在经典函数类型上有一些优势：命名参数。当函数类型的定义很长或者作为参数传递多次时，最好将函数类型命名。当仅凭类型无法清楚地知道每个参数的含义时，最好使用命名参数。
- en: In the upcoming sections, we are going to see that it is possible to name both
    the parameters and the whole definition of a function type. It can be done with
    type aliases and named parameters in the function type. This way, it is possible
    to have all the advantages of SAM while sticking with function types.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到可以为函数类型的参数和整个定义命名。可以通过类型别名和函数类型中的命名参数来实现。这样，可以在坚持使用函数类型的同时获得 SAM
    的所有优势。
- en: Named parameters in function type
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数类型中的命名参数
- en: 'Until now, we''ve only seen definitions of function types where only the types
    were specified, but not parameter names. Parameter names have been specified in
    *function literals* :'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了函数类型的定义，其中只指定了类型，而没有指定参数名称。参数名称已在 *function literals* 中指定：
- en: '[PRE64]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The problem comes when the parameters are not self-explanatory, and the developer
    does not know what the parameters mean. With SAMs there were suggestions, while
    in the function type defined in the previous example, they are not really helpful:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数不是自解释的，开发人员不知道参数的含义时就会出现问题。在 SAM 中有建议，而在前面示例中定义的函数类型中，它们并不真正有帮助：
- en: '![](img/Image00037.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00037.jpg)'
- en: 'The solution is to define function type with named parameters. Here is what
    it looks like:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是使用带有命名参数的函数类型。以下是它的样子：
- en: '[PRE65]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The benefit of this notation is that the IDE suggests these names as the names
    of the parameters in the *function literal* . Because of this, programmer can
    avoid any confusion:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这种表示法的好处是，IDE 建议这些名称作为 *function literal* 中参数的名称。由于这个原因，程序员可以避免任何混淆：
- en: '![](img/Image00038.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00038.jpg)'
- en: The problem occurs when the same function type is used multiple times, then
    it is not easy to define those parameters for each definition. In that situation,
    a different Kotlin feature is used - the one we describe in next section--*type
    alias* .
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一函数类型多次使用时，定义每个函数类型的参数并不容易。在这种情况下，使用了不同的 Kotlin 功能 - 我们在下一节中描述的 *type alias*
    。
- en: Type alias
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型别名
- en: 'From version 1.1, Kotlin has had a feature called **type alias** , which allows
    us to provide alternative names for existing types. Here is an example of a type
    alias definition where we have made a list of `Users` :'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 从 1.1 版本开始，Kotlin 具有称为 **type alias** 的功能，允许我们为现有类型提供替代名称。以下是一个类型别名定义的示例，我们已经制作了一个
    `Users` 的列表：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This way, we can add more meaningful names to existing data types:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以为现有的数据类型添加更有意义的名称：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Type aliases must be declared at the top level. A visibility modifier can be
    applied to a type alias to adjust its scope, but they are public by default. This
    means that the type aliases defined previously can be used without any limitations:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名必须在顶层声明。可以应用可见性修饰符来调整类型别名的范围，但它们默认是公共的。这意味着之前定义的类型别名可以无限制地使用：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Keep in mind that aliases are used to improve code readability, and the original
    types can still be used interchangably:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，别名用于提高代码的可读性，原始类型仍然可以互换使用：
- en: '[PRE69]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Another application of `typealias` is to shorten long generic types and give
    them more meaningful names. This improves code readability and consistency when
    the same type is used in multiple places in the code:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`typealias`的另一个应用是缩短长泛型类型并为其提供更有意义的名称。当相同类型在代码中的多个位置使用时，这可以提高代码的可读性和一致性：'
- en: '[PRE70]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Type aliases are often used to name function types:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名通常用于命名函数类型：
- en: '[PRE71]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can use them together with function type parameter names:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将它们与函数类型参数名称一起使用：
- en: '[PRE72]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'And then we get parameter suggestions:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们得到参数建议：
- en: '![](img/Image00039.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00039.jpg)'
- en: 'Let''s look at an example of how function types named by type alias can be
    implemented by class. Parameter names from function types are also suggested as
    method parameters names in this example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，函数类型由类型别名命名的方法可以通过类实现。在这个例子中，函数类型的参数名称也建议作为方法参数名称：
- en: '[PRE73]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'These are the main reasons why we are using named function types:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们使用命名函数类型的主要原因：
- en: Names are often shorter and easier than whole function type definitions
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称通常比整个函数类型定义更短更容易
- en: When we are passing functions, after changing their definitions, we don't have
    to change it everywhere if we are using type aliases
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们传递函数时，在更改其定义后，如果我们使用类型别名，则无需在所有地方都进行更改
- en: It is easier to have defined parameter names when we use type aliases
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用类型别名时，更容易定义参数名称
- en: These two features (named parameter in function types and type aliases) combined
    are the reasons why there is no need to define SAMs in Kotlin--all the advantages
    of SAMs over function types (name and named parameters) can be achieved with named
    parameters in function type definitions and type aliases. This is another example
    of how Kotlin supports functional programming.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个特性（函数类型中的命名参数和类型别名）的结合是Kotlin中不需要定义SAM的原因--所有SAM相对于函数类型的优势（名称和命名参数）都可以通过函数类型定义中的命名参数和类型别名来实现。这是Kotlin支持函数式编程的另一个例子。
- en: Underscore for unused variables
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未使用的变量下划线
- en: 'In some cases, we are defining a lambda expression that does not use all its
    parameters. When we leave them named, then they might be destructing a programmer
    who is reading this lambda expression and trying to understand its purpose. Let''s
    look at the function that is filtering every second element. The second parameter
    is the element value, and it is unused in this example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们正在定义一个不使用所有参数的lambda表达式。当我们保留它们的名称时，可能会对阅读此lambda表达式并尝试理解其目的的程序员进行解构。让我们看一下过滤每个第二个元素的函数。第二个参数是元素值，在这个例子中没有使用：
- en: '[PRE74]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To prevent misunderstanding, there are some conventions used, such as the ignoring
    the parameter names:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止误解，有一些惯例，比如忽略参数名称：
- en: '[PRE75]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Because these conventions were unclear and problematic, Kotlin introduced underscore
    notation, which is used as a replacement for the names of parameters that are
    not used:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些约定不清晰且有问题，Kotlin引入了下划线表示法，用作未使用的参数的名称的替代：
- en: '[PRE76]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This notation is suggested, and there is a warning displayed when a lambda
    expression parameter is unused:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用此表示法，并在未使用lambda表达式参数时显示警告：
- en: '![](img/Image00040.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00040.jpg)'
- en: Destructuring in lambda expressions
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在lambda表达式中解构
- en: 'In [Chapter 4](text00088.html) , *Classes and Objects* , we''ve seen how objects
    can be destructured into multiple properties using destructuring declarations:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](text00088.html) *类和对象* 中，我们已经看到了如何使用解构声明将对象解构为多个属性：
- en: '[PRE77]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Since version 1.1, Kotlin can use destructuring declarations syntax for lambda
    parameters. To use them, you should use parentheses that include all the parameters
    that we want to destructure into:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 自1.1版本以来，Kotlin可以使用解构声明语法来进行lambda参数。要使用它们，您应该使用包含我们想要解构的所有参数的括号：
- en: '[PRE78]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Kotlin''s destructing declaration is position-based, as opposed to the property
    name-based destructuring declaration that can be found, for example, in TypeScript.
    In position-based destructing declarations, the order of properties decides which
    property is assigned to which variable. In property name-based destructuring,
    it is determined by the names of variables:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的解构声明是基于位置的，与基于属性名称的解构声明相反，例如在TypeScript中可以找到。在基于位置的解构声明中，属性的顺序决定了分配给哪个变量。在基于属性名称的解构中，它由变量的名称决定：
- en: '`//TypeScript`'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`//TypeScript`'
- en: '`const obj = { first: ''Jane'', last: ''Doe'' };`'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`const obj = { first: ''Jane'', last: ''Doe'' };`'
- en: '`const { last, first } = obj;`'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`const { last, first } = obj;`'
- en: '`console.log(first); // Prints: Jane`'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(first); // 打印：Jane`'
- en: '`console.log(last); // Prints: Doe`'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log(last); // 打印：Doe`'
- en: Both solutions have its pros and cons. Position-based destructing declarations
    are secured for renaming a property, but they are not safe for property reordering.
    Name-based destructuring declarations are safe for property reordering but are
    vulnerable for property renaming.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种解决方案各有优缺点。基于位置的解构声明对于重命名属性是安全的，但对于属性重新排序是不安全的。基于名称的解构声明对于属性重新排序是安全的，但对于属性重命名是脆弱的。
- en: 'Destructuring declarations can be used multiple times in a single lambda expression,
    and it can be used together with normal parameters:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 解构声明可以在单个lambda表达式中多次使用，并且可以与普通参数一起使用：
- en: '[PRE79]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Deconstruction of `Pair`
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Pair`的解构'
- en: Deconstruction of `Pair` and other element
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Pair`和其他元素的解构'
- en: Multiple deconstructions in single lambda expression
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单个lambda表达式中的多个解构
- en: 'Note that we can destructure a class into less than all components:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以将类解构为不到所有组件：
- en: '[PRE80]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Underscore notation is allowed in destructuring declarations. It is most often
    used to get to the further components:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 解构声明中允许使用下划线表示法。它最常用于获取更多的组件：
- en: '[PRE81]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'It is possible to specify the type of the destructured parameter:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 可以指定解构参数的类型：
- en: '[PRE82]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The type is inferred from the lambda expression
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型是从lambda表达式中推断出来的
- en: 'Also, parameters defined by destructuring declaration:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 还有解构声明定义的参数：
- en: '[PRE83]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The type is inferred from the lambda expression.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型是从lambda表达式中推断出来的。
- en: The type cannot be inferred because there is not enough information about types
    inside the lambda expression.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于lambda表达式内部的类型信息不足，无法推断类型。
- en: 'This all makes destructuring in lambdas a really useful feature. Let''s look
    at some most common use cases in Android where deconstruction in lambdas is used.
    It is used to process the elements of `Map` because they are of type `Map.Entry`
    , which can be destructed to the `key` and `value` parameters:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都使得lambda中的解构成为一个非常有用的特性。让我们看一些在Android中使用解构在lambda中的最常见用例。它用于处理`Map`的元素，因为它们是`Map.Entry`类型，可以被解构为`key`和`value`参数：
- en: '[PRE84]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Similarly, lists of pairs can be destructed:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，成对的列表也可以被解构：
- en: '[PRE85]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Destructuring declarations are also used when we want to simplify data objects
    processing:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 解构声明在我们想要简化数据对象处理时也会被使用：
- en: '[PRE86]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'This is especially useful in libraries that are used to asynchronously process
    elements (such as RxJava). Their functions are designed to process single elements,
    and if we want multiple elements to be processed, then we need to pack them in
    `Pair` , `Triple` , or some other data class and use a destructuring declaration
    on each step:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这在用于异步处理元素的库中特别有用（例如RxJava）。它们的函数被设计用于处理单个元素，如果我们想要处理多个元素，那么我们需要将它们打包在`Pair`、`Triple`或其他一些数据类中，并在每一步使用解构声明：
- en: '[PRE87]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Inline functions
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联函数
- en: Higher-order functions are very helpful and they can really improve the reusability
    of code. However, one of the biggest concerns about using them is efficiency.
    Lambda expression are compiled to classes (often anonymous classes), and object
    creation in Java is a heavy operation. We can still use higher-order functions
    in an effective way while keeping all the benefits by making functions inline.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数非常有用，可以真正提高代码的可重用性。然而，使用它们的最大担忧之一是效率。Lambda表达式被编译为类（通常是匿名类），在Java中对象的创建是一个繁重的操作。我们仍然可以以有效的方式使用高阶函数，同时保持所有的好处，方法是使函数内联。
- en: 'The concept of inline functions is pretty old, and it is mostly related to
    C++ or C. When a function is marked as inline, during code compilation the compiler
    will replace all the function calls with the actual body of the function. Also,
    lambda expressions provided as arguments are replaced with their actual body.
    They will not be treated as functions, but as actual code. This is makes bytecode
    longer, but runtime execution is much more efficient. Later, we will see that
    nearly all higher-order functions from standard library are marked as inline.
    Let''s look at the example. Suppose we marked the `printExecutionTime` function
    with the `inline` modifier:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 内联函数的概念相当古老，主要与C++或C有关。当一个函数被标记为内联时，在代码编译期间，编译器将所有函数调用替换为函数的实际体。此外，作为参数提供的lambda表达式将被替换为它们的实际体。它们不会被视为函数，而是作为实际的代码。这使得字节码更长，但运行时执行更加高效。后来，我们会看到标准库中几乎所有的高阶函数都被标记为内联。让我们看一个例子。假设我们用`inline`修饰符标记了`printExecutionTime`函数：
- en: '[PRE88]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'When we compile and decompile `measureOperation` , we are going to find out
    that the function call is replaced with its actual body, and the parameter function
    call is replaced by the lambda expression''s body:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译和反编译`measureOperation`时，我们会发现函数调用被其实际体替换，参数函数调用被lambda表达式的体替换：
- en: '[PRE89]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Code from `printExecutionTime` was added to `measureOperation` function body.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 来自`printExecutionTime`的代码被添加到`measureOperation`函数体中。
- en: Code located inside the lambda was located on its call. If the function used
    it multiple times, then the code would replace each call.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位于lambda内部的代码位于其调用处。如果函数多次使用它，那么代码将替换每个调用。
- en: The body of `printExecutionTime` can still be found in the code. It was skipped
    to make the example more readable. It is kept in the code because it might be
    used after compilation, for example, if this code is added to a project as a library.
    What is more, this function will still work as inline when used by Kotlin.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`printExecutionTime`的体仍然可以在代码中找到。为了使示例更易读，它被跳过了。它被保留在代码中，因为在编译后可能会被使用，例如，如果这段代码被添加到项目中作为库。而且，当被Kotlin使用时，这个函数仍然会作为内联函数工作。'
- en: 'While there is no need to create classes for lambda expressions, inline functions
    can speed up the execution of functions with function parameters. This difference
    is so important that it is recommended to use the inline modifier for all short
    functions with at least one function parameter. Unfortunately, using the inline
    modifier also has its bad sides. The first, we''ve already mentioned--the produced
    bytecode is longer. This is because function calls are replaced by function bodies
    and because lambda calls inside this body are replaced with the body of the *function
    literal* . Also, inline functions cannot be recursive and they cannot use functions
    or classes that have more restrictive visibility modifier than this lambda expression.
    For example, public inline functions cannot use private functions. The reason
    is that it could lead to the injection of code into functions that cannot use
    them. This would lead to a compilation error. To prevent it, Kotlin does not permit
    the use of elements with less restrictive modifiers than the lambda expression
    in which they are placed. Here''s an example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不需要为lambda表达式创建类，但内联函数可以加速带有函数参数的函数的执行。这种差异非常重要，建议对至少有一个函数参数的所有短函数使用内联修饰符。不幸的是，使用内联修饰符也有其不好的一面。首先，我们已经提到了--生成的字节码更长。这是因为函数调用被函数体替换，而在此体内部的lambda调用被*函数文字*的体替换。此外，内联函数不能是递归的，也不能使用比此lambda表达式更严格的可见性修饰符的函数或类。例如，公共内联函数不能使用私有函数。原因是这可能导致代码注入到不能使用它们的函数中。这将导致编译错误。为了防止这种情况发生，Kotlin不允许在放置它们的lambda表达式中使用比lambda表达式更不严格的修饰符的元素。这里有一个例子：
- en: '[PRE90]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In fact, it is possible in Kotlin to use elements with more restrictive visibility
    in `inline` functions if we suppress this warning, but this is bad practice and
    it should never be used this way:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，在Kotlin中，如果我们抑制此警告，可以在`inline`函数中使用更严格可见性的元素，但这是不好的做法，绝不能这样使用：
- en: '`// Tester1.kt`'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`// Tester1.kt`'
- en: '`fun main(args: Array<String>) { a() }`'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`fun main(args: Array<String>) { a() }`'
- en: '`// Tester2.kt`'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`// Tester2.kt`'
- en: '`inline fun a() { b() }`'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`inline fun a() { b() }`'
- en: '`private fun b() { print("B") }` How is it possible? For the internal modifier
    it is simpler, because the internal modifier is public under the hood. For private
    functions, there is an additional `access$b` function created that has `public`
    visibility and that is only invoking the `b` function:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`private fun b() { print("B") }` 这是怎么可能的？对于内部修饰符来说更简单，因为内部修饰符在底层是公共的。对于私有函数，会创建一个额外的`access$b`函数，它具有`public`可见性，并且只调用`b`函数：'
- en: '`public static final void access$b() { b(); }`'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`public static final void access$b() { b(); }`'
- en: This behavior is presented here just to explain why less restrictive modifiers
    can sometimes be used inside `inline` functions (these situations can be found
    in Kotlin standard library in Kotlin 1.1). In the projects, we should design elements
    in such a way that there is no need to use such suppressions.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为只是为了解释为什么在`inline`函数内有时可以使用较不严格的修饰符（这些情况可以在Kotlin 1.1的Kotlin标准库中找到）。在项目中，我们应该设计元素，以便不需要使用这样的抑制。
- en: 'Another problem is less intuitive. While no lambda has been created, we cannot
    pass parameters that are of the function type to another function. Here is an
    example:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题不太直观。虽然没有创建lambda，但我们无法将函数类型的参数传递给另一个函数。这是一个例子：
- en: '[PRE91]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: When function is `inline` , then its function arguments cannot be passed to
    function that are not inline.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数是`inline`时，它的函数参数不能传递给不是内联的函数。
- en: This doesn't work because no `f` parameter has been created. It has just been
    defined to be replaced by the *function literal* body. This is why it cannot be
    passed to another function as an argument.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这不起作用，因为没有创建`f`参数。它只是被定义为由*函数字面值*主体替换。这就是为什么它不能作为参数传递给另一个函数。
- en: 'The simplest way to deal with it is by making the `boo` function inline as
    well. Then it will be OK. In most cases, we cannot make too many functions inline.
    Here are a few reasons why:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 处理它的最简单方法是将`boo`函数也设置为内联。然后就可以了。在大多数情况下，我们不能使太多的函数内联。以下是一些原因：
- en: The `inline` functions should be used for smaller functions. If we are making
    `inline` functions that are using other `inline` functions, then it can lead to
    a large structure being generated after compilation. This is a problem both because
    of compilation time and because of the resulting code's size.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inline`函数应该用于较小的函数。如果我们正在创建使用其他`inline`函数的`inline`函数，那么在编译后可能会生成一个大的结构。这是一个问题，因为编译时间和生成的代码大小都会受到影响。'
- en: While `inline` functions cannot use element with visibility modifiers more strict
    than the one they have, it would be a problem if we would like to use them in
    libraries where as many functions as possible should be private to protect the
    API.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然`inline`函数不能使用比它们更严格的可见性修饰符的元素，但如果我们想在库中使用它们，这将是一个问题，因为尽可能多的函数应该是私有的，以保护API。
- en: The simplest way to deal with this problem is by making function parameters
    that we do want to pass to another function `noinline` .
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的最简单方法是将我们想要传递给另一个函数的函数参数设置为`noinline`。
- en: The noinline modifier
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`noinline`修饰符'
- en: 'The `noinline` is a modifier for function type parameters. It makes a specific
    argument treated as normal function type parameter (its calls are not replaced
    with the *function literal* body). Let''s look at a `noinline` example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`noinline`是函数类型参数的修饰符。它使特定参数被视为普通函数类型参数（其调用不会被*函数字面值*主体替换）。让我们看一个`noinline`的例子：'
- en: '[PRE92]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The `noinline` annotation modifier before parameter `f` .
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在参数`f`之前使用`noinline`注解修饰符。
- en: The before function will be replaced by the body of the lambda expression used
    as an argument.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前的函数将被用作参数的lambda表达式的主体所替换。
- en: '`f` is `noinline` so it can be passed to the boo function.'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`f`是`noinline`，所以可以将其传递给`boo`函数。'
- en: 'Two main reasons to use `noinline` modifier are as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`noinline`修饰符的两个主要原因如下：
- en: When we need to pass a specific lambda to some other function
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要将特定的lambda传递给其他函数时
- en: When we are calling the lambda intensively and we don't want to swell the code
    too much
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们频繁调用lambda并且不希望代码膨胀太多时
- en: Note that when we make all function parameters `noinline,` then there will be
    nearly no performance improvement from making the functions inline. While it is
    unlikely that using `inline` will be beneficial, the compiler will show a warning.
    This is why, in most cases, `noinline` is only used when there are multiple function
    parameters and we only apply it to some of them.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们将所有函数参数都设置为`noinline`时，几乎不会因为将函数设置为内联而获得性能提升。虽然使用`inline`可能不会有益，但编译器会显示警告。这就是为什么在大多数情况下，只有在有多个函数参数时才使用`noinline`，并且我们只将其应用于其中一些参数。
- en: Non-local returns
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非局部返回
- en: 'Functions with function parameters might act similarly to native structures
    (such as loops). We''ve already seen the `ifSupportsLolipop` function and the
    `repeatUntilError` function. An even more common example is the `forEach` modifier.
    It is an alternative to the `for` control structure, and it calls a parameter
    function with each element one after another. This is how it could be implemented
    (there is a `forEach` modifier in Kotlin standard library, but we will see it
    later because it includes elements that have not yet been presented):'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 具有函数参数的函数可能类似于本地结构（例如循环）。我们已经看到了`ifSupportsLolipop`函数和`repeatUntilError`函数。更常见的例子是`forEach`修饰符。它是`for`控制结构的替代品，并且依次调用每个元素的参数函数。它的实现方式如下（在Kotlin标准库中有一个`forEach`修饰符，但我们稍后会看到它，因为它包含了尚未介绍的元素）：
- en: '[PRE93]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The big problem is that inside the `forEach` function defined this way we cannot
    return from outer function. For example, this is how we could implement the `maxBounded`
    function using a `for` loop:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一个大问题是，在这种方式定义的`forEach`函数内部，我们无法从外部函数返回。例如，我们可以使用`for`循环来实现`maxBounded`函数：
- en: '[PRE94]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'If we want to treat `forEach` as an alternative to a `for` loop, then similar
    possibility should be allowed there. The problem is that the same code, but with
    `forEach` used instead of `for` loop, would not compile:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望将`forEach`作为`for`循环的替代方案，那么应该允许类似的可能性。问题在于，相同的代码，但使用`forEach`而不是`for`循环，将无法编译：
- en: '![](img/Image00041.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00041.jpg)'
- en: The reason is related to how the code is compiled. We have already discussed
    that lambda expressions are compiled to class of anonymous objects with a method
    that includes the defined code, and over there we cannot return from the `maxBounded`
    function because we are in a different context.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 原因与代码的编译方式有关。我们已经讨论过，lambda表达式被编译为包含定义代码的匿名对象的类，而在那里我们无法从`maxBounded`函数中返回，因为我们处于不同的上下文中。
- en: 'We encounter a situation when the `forEach` function is marked as inline. As
    we have already mentioned, the body of this function replaces its calls during
    compilation, and all of the functions from the parameters are replaced with their
    body. So, there is no problem with using the `return` modifier there. Then, if
    we make `forEach` inline, we can use return inside the lambda expression:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当`forEach`函数被标记为内联时，我们会遇到一种情况。正如我们已经提到的，这个函数的主体在编译期间会替换其调用，参数中的所有函数都会被其主体替换。因此，在那里使用`return`修饰符是没有问题的。然后，如果我们将`forEach`设置为内联，我们可以在lambda表达式中使用return：
- en: '[PRE95]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This is how the `maxBounded` function has compiled in Kotlin, and the code
    looks like this (after some clean-up and simplification) when it is decompiled
    to Java:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`maxBounded`函数在Kotlin中的编译方式，当它被反编译为Java时，代码看起来是这样的（经过一些清理和简化）：
- en: '[PRE96]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In the preceding code, `return` is important--it was defined in the lambda expression,
    and it is returning from the `maxBounded` function.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`return`很重要--它在lambda表达式中被定义，并且从`maxBounded`函数中返回。
- en: The `return` modifier used inside the lambda expression of the `inline` function
    is called a non-local return.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在`inline`函数的lambda表达式中使用的`return`修饰符称为非局部返回。
- en: Labeled return in lambda expressions
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在lambda表达式中标记返回
- en: 'Let''s look at a case in which we need to return from a lambda expression and
    not from a function. We can do this using labels. Here is an example of a return
    from a lambda expression using labels:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个需要从lambda表达式返回而不是从函数返回的情况。我们可以使用标签来实现这一点。以下是使用标签从lambda表达式返回的示例：
- en: '[PRE97]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This is generic implementation of `forEach` function, where list with any type
    can be processed.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`forEach`函数的通用实现，可以处理任何类型的列表。
- en: We define label for lambda expression inside `forEach` argument.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为`forEach`参数中的lambda表达式定义标签。
- en: We return from lambda expression specified by label.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从由标签指定的lambda表达式中返回。
- en: 'Another Kotlin feature is that lambda expressions that are defined as function
    arguments have a default label whose name is the same as the function in which
    they are defined. This label is called an **implicit label** . When we want to
    return from a lambda expression defined in a `forEach` function, we can do it
    just by using `return@forEach` . Let''s look at an example:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个Kotlin特性是，作为函数参数定义的lambda表达式具有一个默认标签，其名称与它们所定义的函数相同。这个标签称为**隐式标签**。当我们想要从`forEach`函数中定义的lambda表达式返回时，我们可以通过使用`return@forEach`来实现。让我们看一个例子：
- en: '[PRE98]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Implicit label name is taken from function name.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 隐式标签名称取自函数名称。
- en: 'Note that while the `forEach` function is inline, we can also use a non-local
    return to return from the `processMessageButNotError` function:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然`forEach`函数是内联的，我们也可以使用非局部返回来从`processMessageButNotError`函数中返回：
- en: '[PRE99]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Let''s move onto a more complex example of using non-local return labels. Let''s
    suppose that we have two `forEach` loops, one inside another. When we use an implicit
    label, it will return from the deeper loop. In our example, we can use it to skip
    the processing of the specific message:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个更复杂的使用非局部返回标签的例子。假设我们有两个`forEach`循环，一个嵌套在另一个内部。当我们使用隐式标签时，它将从更深层的循环中返回。在我们的例子中，我们可以用它来跳过特定消息的处理：
- en: '[PRE100]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This will return from the lambda defined in the `forEach` function that also
    takes messages as an argument.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将从`forEach`函数中定义的lambda中返回，该函数还将消息作为参数。
- en: We cannot return from another lambda expression in the same context using implicit
    label, because it is shadowed by a deeper implicit label.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用隐式标签从同一上下文中的另一个lambda表达式中返回，因为它被更深层次的隐式标签所遮蔽。
- en: 'In these situations, we need to use a non-local implicit label return. It is
    only permissible with inline function parameters. In our example, while `forEach`
    is inline, we can return from a *function literal* this way:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，我们需要使用非局部隐式标签返回。这只允许在内联函数参数中使用。在我们的例子中，当`forEach`是内联的时，我们可以通过这种方式从*函数字面值*返回：
- en: '[PRE101]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This will return from the lambda defined in `forEach` called on conversations.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将从在conversations上调用的`forEach`中定义的lambda中返回。
- en: 'We can also just use a non-local return (a return without any labels) to finish
    the processing:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以只使用非局部返回（没有任何标签的返回）来完成处理：
- en: '[PRE102]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This will return from the `processMessageButNotError` function and finish the
    processing.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将从`processMessageButNotError`函数中返回并完成处理。
- en: Crossinline modifier
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Crossinline修饰符
- en: 'Sometimes we need to use function type parameters from inline functions not
    directly in the function body, but in another execution context, such as a local
    object or a nested function. But standard function type parameters of inline functions
    are not allowed to be used this way, because they are allowing non-local returns,
    and it should not be allowed if this function could be used inside another execution
    context. To inform the compiler that non-local returns are not allowed, this parameter
    must be annotated as `crossinline` . Then it will act like a substitution that
    we are expecting in an `inline` function, even when it is used inside another
    lambda expression:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要在内联函数的函数类型参数中，不直接在函数体中使用，而是在另一个执行上下文中使用，比如本地对象或嵌套函数。但是内联函数的标准函数类型参数不允许以这种方式使用，因为它们允许非局部返回，如果这个函数可以在另一个执行上下文中使用，就不应该允许这种情况。为了通知编译器不允许非局部返回，这个参数必须被注释为`crossinline`。然后它将像我们在`inline`函数中期望的替换一样起作用，即使它在另一个lambda表达式中使用时：
- en: '[PRE103]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This will be compiled as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被编译如下：
- en: '[PRE104]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'While no property has been created with the function, it is not possible to
    pass the crossinline parameter to another function as an argument:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有使用函数创建属性，但不可能将`crossinline`参数传递给另一个函数作为参数：
- en: '![](img/Image00042.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00042.jpg)'
- en: 'Let''s look at a practical example. In Android, we don''t need `Context` to
    execute an operation on the main thread of the application because we can get
    a main loop using the `getMainLooper` static function from the `Looper` class.
    Therefore, we can write a top-level function that will allow a simple thread change
    into the main thread. To optimize it, we are first checking if the current thread
    is not the main thread. When it is, then the action is just invoked. When it is
    not, then we create a handler that operates on the main thread and a post operation
    to invoke it from there. To make the execution of this function faster, we are
    going to make the `runOnUiThread` function inline, but then to allow the action
    invocation from another thread, we need to make it crossinline. Here is an implementation
    of this described function:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个实际的例子。在Android中，我们不需要`Context`来在应用程序的主线程上执行操作，因为我们可以使用`Looper`类的`getMainLooper`静态函数获取主循环。因此，我们可以编写一个顶级函数，允许简单地将线程切换到主线程。为了优化它，我们首先检查当前线程是否不是主线程。当它是时，操作就被调用。当它不是时，我们创建一个在主线程上操作的处理程序，并进行一个后续操作以从那里调用它。为了加快此函数的执行，我们将使`runOnUiThread`函数内联，但然后为了允许从另一个线程调用操作，我们需要使它`crossinline`。这是这个描述的函数的实现：
- en: '[PRE105]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We can run `action` inside a lambda expression thanks to the `crossinline` modifier.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过`crossinline`修饰符在lambda表达式中运行`action`。
- en: The `crossinline` annotation is useful because it allows to use function types
    in the context of lambda expressions or local functions while maintaining the
    advantages of making the function `inline` (there's no need for lambda creation
    in this context).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`crossinline`注解很有用，因为它允许在lambda表达式或本地函数的上下文中使用函数类型，同时保持使函数`inline`的优势（在这种情况下不需要lambda创建）。'
- en: Inline properties
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联属性
- en: 'Since Kotlin 1.1, the `inline` modifier can be used on properties that do not
    have a backing field. It can be either applied to separate accessors, which will
    result in their body replacing usage, or it can be used for whole property, which
    will have the same result as making both accessors inline. Let''s make an inline
    property that will be used to check and change an element''s visibility. Here
    is an implementation where both accessors are inline:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 自Kotlin 1.1以来，`inline`修饰符可以用于没有后备字段的属性。它可以应用于单独的访问器，这将导致它们的主体替换使用，或者它可以用于整个属性，这将产生与使两个访问器都是内联的相同结果。让我们创建一个内联属性，用于检查和更改元素的可见性。这是一个实现，其中两个访问器都是内联的：
- en: '[PRE106]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We can achieve the same result if we annotate the whole property as inline:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将整个属性标注为内联，也可以实现相同的结果：
- en: '[PRE107]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The preceding code be compiled as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将被编译如下：
- en: '[PRE108]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: This way, we have omitted the setter and getter function calls, and we should
    expect a performance improvement with the cost of increased compiled code size.
    Still, for most properties, it should be profitable to use the `inline` modifier.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们省略了setter和getter函数调用，并且应该期望在编译代码大小增加的代价下获得性能改进。尽管如此，对于大多数属性来说，使用`inline`修饰符应该是有利的。
- en: Function References
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数引用
- en: 'Sometimes, functions that we want to pass as an argument are already defined
    as a separate function. Then we can just define the lambda with its call:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要作为参数传递的函数已经定义为一个单独的函数。然后我们可以只定义带有其调用的lambda：
- en: '[PRE109]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'But Kotlin also allows us to pass a function as a value. To be able to use
    a top-level function as a value, we need to use a function reference, which is
    used as a double colon and the function name (`::functionName` ). Here is an example
    how it can be used to provide a predicate to `filter` :'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 但Kotlin也允许我们将函数作为值传递。为了能够将顶级函数用作值，我们需要使用函数引用，它用作双冒号和函数名（`::functionName`）。这是一个例子，说明它如何用于为`filter`提供谓词：
- en: '[PRE110]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Here is an example:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE111]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Function reference is example of reflection, and this is why the object returned
    by this operation also contains information about the referred function:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 函数引用是反射的一个例子，这就是为什么这个操作返回的对象也包含有关所引用函数的信息：
- en: '[PRE112]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'But this object also implements the function type, and it can be used this
    way:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个对象也实现了函数类型，可以这样使用：
- en: '[PRE113]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'It is also possible to reference to methods. To do it, we need to write the
    type name, two colons, and the method name (`Type::functionName` ). Here is an
    example:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以引用方法。要这样做，我们需要写类型名称，两个冒号和方法名（`Type::functionName`）。这是一个例子：
- en: '[PRE114]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'As in the preceding example, when we are referencing a non-static method, there
    needs to be a provided instance of the class as an argument. The `isEmpty` function
    is a `String` method that takes no arguments. The reference to `isEmpty` has a
    `String` parameter that will be used as an object on which the function is invoked.
    The reference to the object is always located as the first parameter. Here is
    another example, where the method has the property `food` already defined:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的例子类似，当我们引用非静态方法时，需要提供类的实例作为参数。`isEmpty`函数是一个不带参数的`String`方法。对`isEmpty`的引用有一个`String`参数，该参数将被用作调用该函数的对象。对象的引用总是位于第一个参数。这里是另一个例子，其中方法已经定义了属性`food`：
- en: '[PRE115]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'There is a different situation when we are referencing a Java static method,
    because it does not need instance of the class on which it is defined. This is
    similar to methods of *objects* or *companion objects* , where the object is known
    in advance and does not need to be provided. In these situations, there is a function
    created with the same parameters as the referenced function and the same return
    type:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们引用Java静态方法时，情况就不同了，因为它不需要定义它所在的类的实例。这类似于*对象*或*伴生对象*的方法，其中对象是预先知道的，不需要提供。在这些情况下，有一个与被引用函数相同参数和相同返回类型的函数被创建：
- en: '[PRE116]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'In function reference usage, there are common use cases where we want to use
    function references to provide method from a class we have reference to. Common
    example is when we want to extract some operations as method of the same class,
    or when we want to reference to functions from reference member function from
    class we have reference to. A simple example is when we define what should be
    done after a network operation. It is defined in a Presenter (such as `MainPresenter`
    ), but it is referencing all the View operations, that are defined by the `view`
    property (which is, for example, of type `MainView` ):'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数引用的使用中，有一些常见的用例，我们希望使用函数引用来提供对我们引用的类的方法。常见的例子是当我们想要将一些操作提取为同一类的方法时，或者当我们想要引用来自我们引用的类的引用成员函数的函数时。一个简单的例子是当我们定义网络操作之后应该做什么。它是在一个Presenter（比如`MainPresenter`）中定义的，但它引用了所有的View操作，这些操作由`view`属性定义（例如，类型为`MainView`）：
- en: '[PRE117]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '`showProgress` , `displayError` , and `hideProgress` are defined in `MainView`
    .'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`showProgress`，`displayError`和`hideProgress`在`MainView`中定义。'
- en: '`onUsersLoaded` is method defined in `MainPresenter` .'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`onUsersLoaded`是在`MainPresenter`中定义的方法。'
- en: 'To help in this kind of situation, Kotlin introduced in version 1.1 feature
    called **bound references** , which provide references that are bound to a specific
    object. Thanks to that, this object does not need to be provided by an argument.
    Using this notation, we can replace the previous definition this way:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助这种情况，Kotlin在1.1版本中引入了一个叫做**bound references**的功能，它提供了绑定到特定对象的引用。由于这个，这个对象不需要通过参数提供。使用这种表示法，我们可以用以下方式替换之前的定义：
- en: '[PRE118]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Another function that we might want to reference is a constructor. An example
    use case is when we need to map from a **data transfer object** (**DTO** ) to
    a class that is part of a model:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要引用的另一个函数是构造函数。一个例子是当我们需要从**数据传输对象**（**DTO**）映射到模型中的类时：
- en: '[PRE119]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Here, `User` needs to have a constructor that defines how it is constructed
    from `UserDto` .
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`User`需要有一个构造函数，定义了它如何从`UserDto`构造。
- en: A DTO is an object that carries data between processes. It is used because classes
    used during communications between a system (in an API) are different than actual
    classes used inside the system (a model).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: DTO是在进程之间传递数据的对象。它被使用是因为在系统之间的通信中使用的类（在API中）与系统内部使用的实际类（模型）不同。
- en: 'In Kotlin, constructors are used and treated similarly to functions. We can
    also reference to them with a double colon and a class name:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，构造函数的使用和处理类似于函数。我们也可以用双冒号和类名引用它们：
- en: '[PRE120]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'This way, we can replace the lambda with a constructor call with a constructor
    reference:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以用构造函数引用替换lambda的构造函数调用：
- en: '[PRE121]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Using function references instead of lambda expressions gives us shorter and
    often more readable notation. It is also especially useful when we are passing
    multiple functions as parameters, or functions that are long and need to be extracted.
    In other cases, there is the useful bounded reference, which provides a reference
    that is bound to a specific object.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数引用而不是lambda表达式给我们提供了更短和更易读的表示法。当我们传递多个函数作为参数，或者函数很长需要被提取时，这种表示法尤其有用。在其他情况下，有一个有用的bounded
    reference，它提供了一个绑定到特定对象的引用。
- en: Summary
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we''ve discussed using functions as first-class citizens.
    We''ve seen how function types are used. We have seen how to define *function
    literals* (anonymous functions and lambda expressions), and that any function
    can be used as an object thanks to function references. We''ve also discussed
    higher-order functions and different Kotlin features that support them: the implicit
    name of a single parameter, the last lambda in argument convention, Java SAM support,
    using an underscore for unused variables, and destructuring declarations in lambda
    expressions. This features provide great support for higher-order functions, and
    they make functions even more than first-class citizens.'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了将函数作为一等公民。我们已经看到了函数类型是如何被使用的。我们已经看到了如何定义*函数字面量*（匿名函数和lambda表达式），以及任何函数都可以作为对象使用，这要归功于函数引用。我们还讨论了高阶函数和不同的Kotlin特性来支持它们：单个参数的隐式名称、参数中的最后一个lambda、Java
    SAM支持、使用下划线表示未使用的变量，以及lambda表达式中的解构声明。这些特性为高阶函数提供了很好的支持，使函数不仅仅是一等公民。
- en: In the next chapter, we are going to see how generics work in Kotlin. This will
    allow us to define much more powerful classes and functions. We will also see
    how well they can be used when connected to higher-order functions.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到Kotlin中泛型是如何工作的。这将使我们能够定义更强大的类和函数。我们还将看到当与高阶函数连接时它们可以如何被使用。
