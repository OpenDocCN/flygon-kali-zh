- en: Chapter 5. RenderBox Engine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。RenderBox引擎
- en: While the Cardboard Java SDK and OpenGL ES are powerful and robust libraries
    for mobile VR applications, they're pretty low level. Software development best
    practices expect that we abstract common programming patterns into new classes
    and data structures. In [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard
    Box*, we got some hands-on experience with the nitty gritty details. This time,
    we're revisiting those details while abstracting them into a reusable library
    that we'll call **RenderBox**. There'll be vector math, materials, lighting, and
    more, all rolled up into a neat little package.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Cardboard Java SDK和OpenGL ES是移动VR应用程序强大而稳健的库，但它们的层次相对较低。软件开发最佳实践期望我们将常见的编程模式抽象成新的类和数据结构。在[第3章](ch03.html
    "第3章。Cardboard Box")中，*Cardboard Box*，我们对细节有了一些实际经验。这一次，我们将重温这些细节，同时将它们抽象成一个可重用的库，我们将称之为**RenderBox**。这将涉及向量数学、材料、光照等，全部打包成一个整洁的包。
- en: 'In this chapter, you will learn to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: Create a new Cardboard project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的Cardboard项目
- en: Write a `Material` class with shaders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个带有着色器的`Material`类
- en: Explore our `Math` package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索我们的`Math`包
- en: Write a `Transform` class
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个`Transform`类
- en: Write a `Component` class with `RenderObject Cube`, `Camera`, and `Light` components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个带有`RenderObject Cube`、`Camera`和`Light`组件的`Component`类
- en: Add a `Material` class for rendering cubes with vertex colors and lighting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个用于渲染带有顶点颜色和光照的`Material`类
- en: Write a `Time` animation class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个`Time`动画类
- en: Export all this into a `RenderBox` library for reuse
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有这些导出到一个可重用的`RenderBox`库中
- en: The source code for this project can be found on the Packt Publishing website,
    and on GitHub at [https://github.com/cardbookvr/renderboxdemo](https://github.com/cardbookvr/renderboxdemo)
    (with each topic as a separate commit). The final `RenderBoxLib` project, which
    will continue to be maintained and reused in other projects in this book, can
    also be found on the Packt Publishing website and on GitHub at [https://github.com/cardbookvr/renderboxlib](https://github.com/cardbookvr/renderboxlib).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的源代码可以在Packt Publishing网站上找到，并且在GitHub上也可以找到[https://github.com/cardbookvr/renderboxdemo](https://github.com/cardbookvr/renderboxdemo)（每个主题作为单独的提交）。最终的`RenderBoxLib`项目将继续在本书的其他项目中进行维护和重用，也可以在Packt
    Publishing网站和GitHub上找到[https://github.com/cardbookvr/renderboxlib](https://github.com/cardbookvr/renderboxlib)。
- en: Introducing RenderBox – a graphics engine
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍RenderBox - 一个图形引擎
- en: In a virtual reality app, you are creating a three-dimensional space with a
    bunch of objects. The user's viewpoint, or camera, is also located in this space.
    With the help of the Cardboard SDK, the scene is rendered twice, once for the
    left and right eye, to create the side-by-side stereoscopic views. The second
    and equally important feature translates the sensor data into a head look direction,
    tracking the real-life user's head. The pixels are drawn on the screen, or rendered,
    using the OpenGL ES library, which talks to the hardware **graphics processor**
    (**GPU**) on your device.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟现实应用程序中，您正在创建一个三维空间，其中包含一堆对象。用户的视点，或者说摄像头，也位于这个空间中。借助Cardboard SDK的帮助，场景被渲染两次，一次为左眼和右眼，以创建并排的立体视图。第二个同样重要的功能是将传感器数据转换为头部朝向，跟踪现实生活中用户的头部。像素是使用OpenGL
    ES库在屏幕上绘制或渲染的，该库与设备上的硬件**图形处理器**（**GPU**）通信。
- en: We're going to organize the graphics rendering code into separate Java classes,
    which we'll be able to extract into a reusable graphics engine library. We'll
    call this library **RenderBox**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把图形渲染代码组织成单独的Java类，然后将其提取到一个可重用的图形引擎库中。我们将称这个库为**RenderBox**。
- en: As you'll see, the `RenderBox` class implements the `CardboardView.StereoRender`
    interface. But it's more than that. Virtual reality needs 3D graphics rendering,
    and to do all this in low-level OpenGL ES calls (and other supporting APIs) can
    be tedious, to say the least, especially as your application grows. Furthermore,
    these APIs require you to think like a semiconductor chip! Buffers, shaders, and
    matrix math, oh my! I mean seriously, who wants to think like that all the time?
    I'd rather think like a 3D artist and VR developer.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将看到的，`RenderBox`类实现了`CardboardView.StereoRender`接口。但它不仅仅是这样。虚拟现实需要3D图形渲染，而在低级别的OpenGL
    ES调用（和其他支持的API）中进行所有这些工作可能会很繁琐，至少可以这么说，特别是当您的应用程序不断增长时。此外，这些API要求您像半导体芯片一样思考！缓冲区、着色器和矩阵数学，哦！我是说，谁想一直这样思考？我宁愿像一个3D艺术家和VR开发人员一样思考。
- en: There are many distinct pieces to track and manage, and they can get complicated.
    As software developers, it's our role to identify common patterns and implement
    layers of abstraction, which serve to reduce this complexity, avoid duplicated
    code, and express the program as objects (software classes) closer to the problem
    domain. In our case, this domain makes 3D scenes that can be rendered on Cardboard
    VR devices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的部分需要跟踪和管理，它们可能会变得复杂。作为软件开发人员，我们的角色是识别常见模式并实现抽象层，以减少这种复杂性，避免重复的代码，并将程序表达为更接近问题域的对象（软件类）。在我们的情况下，这个领域制作可以在Cardboard
    VR设备上渲染的3D场景。
- en: '`RenderBox` starts to abstract away details into a nice clean layer of code.
    It is designed to take care of OpenGL calls and complex arithmetic, while still
    letting us set up our app-specific code the way we want. It also creates a common
    pattern known as the **entity component pattern** ([https://en.wikipedia.org/wiki/Entity_component_system](https://en.wikipedia.org/wiki/Entity_component_system))
    for new materials and component types if our projects demand any special cases.
    Here''s an illustration of the major classes in our library:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderBox`开始将细节抽象成一个干净的代码层。它旨在处理OpenGL调用和复杂的算术，同时仍然让我们以我们想要的方式设置我们的特定于应用程序的代码。如果我们的项目需要任何特殊情况，它还会创建一个称为**实体组件模式**（[https://en.wikipedia.org/wiki/Entity_component_system](https://en.wikipedia.org/wiki/Entity_component_system)）的常见模式，用于新材料和组件类型。这是我们库中主要类的一个示例：'
- en: '![Introducing RenderBox – a graphics engine](img/B05144_05_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![介绍RenderBox - 一个图形引擎](img/B05144_05_01.jpg)'
- en: The `RenderBox` class implements `CardboardView.StereoRenderer`, relieving that
    responsibility from the app's `MainActivity` class. As we'll see, `MainActivity`
    communicates with `RenderBox` through the `IRenderBox` interface (with the setup,
    `preDraw`, and `postDraw` hooks) so that `MainActivity` implements `IRenderBox`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderBox`类实现了`CardboardView.StereoRenderer`，从而将这个责任从应用的`MainActivity`类中解放出来。正如我们将看到的，`MainActivity`通过`IRenderBox`接口（具有设置、preDraw和postDraw钩子）与`RenderBox`进行通信，以便`MainActivity`实现`IRenderBox`。'
- en: 'Let''s consider the kinds of `Component` that can participate in a 3D VR scene:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑可以参与3D VR场景的`Component`类型：
- en: '`RenderObject`: These are drawable models in the scene, such as cubes and spheres'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RenderObject`：这些是场景中的可绘制模型，例如立方体和球体。'
- en: '`Camera`: This is the viewpoint of the user, which is used to render the scene'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Camera`：这是用户的视点，用于渲染场景'
- en: '`Light`: These are sources of illumination used for shading and shadows'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Light`：这些是用于阴影和阴影的照明源'
- en: Every object in our scene has an X, Y, and Z location in space, a rotation,
    and three scale dimensions. These properties are defined by the `Transform` class.
    Transforms can be arranged in a hierarchy, letting you build more complex objects
    that are assembled from simpler ones.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们场景中的每个对象都在空间中具有X、Y和Z位置、旋转和三个比例尺。这些属性由`Transform`类定义。变换可以按层次结构排列，让您构建更复杂的对象，这些对象由更简单的对象组装而成。
- en: Each `Transform` class can be associated with one or more `Component` classes.
    Different kinds of components (for example, `Camera`, `Light`, and `RenderObject`)
    extend the `Component` class. A component should not exist without being attached
    to a `Transform` class but the reverse (a transform with no components) is perfectly
    fine.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Transform`类可以与一个或多个`Component`类关联。不同类型的组件（例如`Camera`、`Light`和`RenderObject`）扩展了`Component`类。组件不应该存在于没有附加到`Transform`类的情况下，但反之（没有组件的变换）是完全可以的。
- en: Internally, `RenderBox` maintains a list of `RenderObjects`. These are the geometric
    models in the scene. Types of `RenderObjects` include `Cube` and `Sphere`, for
    example. These objects are associated with a `Material`, which defines their color,
    texture, and/or shading properties. Materials, in turn, reference, compile, and
    execute low-level shader programs. Maintaining a flat list of components to render
    each frame is more efficient than traversing the transform hierarchy every frame.
    It is a perfect example of why we use the entity component pattern.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`RenderBox`维护着一个`RenderObjects`列表。这些是场景中的几何模型。`RenderObjects`的类型包括`Cube`和`Sphere`等。这些对象与`Material`相关联，定义了它们的颜色、纹理和/或阴影属性。材料又引用、编译和执行低级着色器程序。每帧维护一个扁平的组件列表比每帧遍历变换层次结构更有效。这是我们使用实体组件模式的一个完美例子。
- en: Other things in the `RenderBox` package include a `Time` class used to implement
    animations, and a library of `Math` functions used for vector and matrix operations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderBox`包中的其他内容包括用于实现动画的`Time`类，以及用于向量和矩阵操作的`Math`函数库。'
- en: Now, let's start putting this together.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始把这些放在一起。
- en: What's the game plan? The end goal is to create our `RenderBox` graphics engine
    library. It will be handy to maintain it in its own project (and repository if
    you're using source control, such as Git), so it can be improved and maintained
    independently. However, to kick this off, we need a simple app to build it, show
    you how to use it, and verify (if not test) that it is working properly. This
    will be called `RenderBoxDemo`. At the end of the chapter, we will extract the
    `RenderBox` code into an Android library module and then export it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏计划是什么？最终目标是创建我们的`RenderBox`图形引擎库。将其保留在自己的项目中（如果您使用源代码控制，如Git，则还可以保留在自己的存储库中）将非常方便，因此可以独立地进行改进和维护。但是，为了开始这个过程，我们需要一个简单的应用程序来构建它，向您展示如何使用它，并验证（如果不是测试）它是否正常工作。这将被称为`RenderBoxDemo`。在本章结束时，我们将`RenderBox`代码提取到一个Android库模块中，然后导出它。
- en: Creating a new project
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: 'If you''d like more details and explanation about these steps, refer to the
    *Creating a new Cardboard project* section [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, and follow along
    there:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解有关这些步骤的更多详细信息和解释，请参考[第2章](ch02.html "第2章。骨架Cardboard项目")中的*创建新的Cardboard项目*部分，*骨架Cardboard项目*，并在那里跟着做：
- en: With Android Studio opened, create a new project. Let's name it `RenderBoxDemo`
    and target **Android 4.4 KitKat (API 19)** with an **Empty Activity**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Android Studio，创建一个新项目。让我们将其命名为`RenderBoxDemo`，并以**空活动**为目标**Android 4.4 KitKat（API
    19）**。
- en: Add the Cardboard SDK `common.aar` and `core.aar` library files to your project
    as new modules, using **File** | **New** | **New Module...**.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Cardboard SDK的`common.aar`和`core.aar`库文件作为新模块添加到项目中，使用**文件** | **新建** | **新建模块...**。
- en: Set the library modules as dependencies to the project app, using **File** |
    **Project Structure**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件** | **项目结构**将库模块作为项目应用程序的依赖项。
- en: Edit the `AndroidManifest.xml` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, being careful
    to preserve the `package` name for this project.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`AndroidManifest.xml`文件，如[第2章](ch02.html "第2章。骨架Cardboard项目")中所述，*骨架Cardboard项目*，务必保留此项目的`package`名称。
- en: Edit the `build.gradle` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, to compile against
    SDK 22.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`build.gradle`文件，如[第2章](ch02.html "第2章。骨架Cardboard项目")中所述，*骨架Cardboard项目*，以便针对SDK
    22进行编译。
- en: Edit the `activity_main.xml` layout file as explained in [Chapter 2](ch02.html
    "Chapter 2. The Skeleton Cardboard Project"), *The Skeleton Cardboard Project*.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`activity_main.xml`布局文件，如[第2章](ch02.html "第2章。骨架Cardboard项目")中所述，*骨架Cardboard项目*。
- en: 'Now, open the `MainActivity.java` file and edit the `MainActivity` Java class
    to extend `CardboardActivity`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`MainActivity.java`文件，并编辑`MainActivity` Java类以扩展`CardboardActivity`：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that unlike the previous chapters, we do not implement `CardboardView.StereoRender`.
    Instead, we will implement that interface in the `RenderBox` class (in the next
    topic).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与之前的章节不同，我们不实现`CardboardView.StereoRender`。相反，我们将在`RenderBox`类中实现该接口（在下一个主题中）。
- en: Creating the RenderBox package folder
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建RenderBox包文件夹
- en: Since our plan is to export the `RenderBox` code as a library, let's put it
    all into its own package.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的计划是将`RenderBox`代码导出为一个库，让我们把它放到自己的包中。
- en: In the Android hierarchy panel, use the `Gear` icon and uncheck **Compact Empty
    Middle Packages** so that we can insert the new package under **com.cardbookvr**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android层次结构面板中，使用`Gear`图标，取消选中**紧凑的空中间包**，以便我们可以在**com.cardbookvr**下插入新的包。
- en: Right-click on the `app/java/com/carbookvr/` folder in the project view, navigate
    to **New** | **Package**, and name it `renderbox`. You may now wish to enable
    **Compact Empty Middle Packages** again.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目视图中右键单击`app/java/com/carbookvr/`文件夹，导航到**新建** | **包**，并命名为`renderbox`。您现在可能希望再次启用**紧凑的空中间包**。
- en: 'Within the `renderbox` folder, create three package subfolders named `components`,
    `materials`, and `math`. The project should now have the same folders as shown
    in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在`renderbox`文件夹中，创建三个包子文件夹，分别命名为`components`、`materials`和`math`。项目现在应该有与以下截图中显示的相同的文件夹：
- en: '![Creating the RenderBox package folder](img/B05144_05_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![创建RenderBox包文件夹](img/B05144_05_02.jpg)'
- en: Creating an empty RenderBox class
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个空的RenderBox类
- en: Let's begin by creating a skeleton of the `RenderBox` class Java code. Right-click
    on the `renderbox/` folder, navigate to **New** | **Java Class**, and name it
    `RenderBox`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建`RenderBox`类Java代码的框架。右键单击`renderbox/`文件夹，导航到**新建** | **Java类**，并命名为`RenderBox`。
- en: 'Now, open the `RenderBox.java` file and edit it to implement the `CardboardView.StereoRenderer`
    interfaces. Add the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`RenderBox.java`文件并编辑它以实现`CardboardView.StereoRenderer`接口。添加以下代码：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It's primarily housekeeping at this point. The `RenderBox` class is defined
    as `implements` `CardboardView.StereoRenderer`. Its constructor will receive a
    reference to the `MainActivity` instance and the `IRenderBox` implementer (in
    this case, also the `MainActivity`) class. `MainActivity` will now have to implement
    the `IRenderBox` methods (to be defined next). In this way, we instantiate the
    framework and implement the critical methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是在这一点上进行的一些日常工作。`RenderBox`类被定义为`implements` `CardboardView.StereoRenderer`。它的构造函数将接收对`MainActivity`实例和`IRenderBox`实现者（在这种情况下也是`MainActivity`）类的引用。`MainActivity`现在必须实现`IRenderBox`方法（下面将定义）。通过这种方式，我们实例化了框架并实现了关键方法。
- en: Note that we also make `RenderBox` a singleton by registering the `this` instance
    in the class constructor.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还通过在类构造函数中注册`this`实例，使`RenderBox`成为单例。
- en: 'We must also add the method overrides for the `StereoRenderer` class. From
    the intellisense menu, select **Implement Methods…** (or *Ctrl* + *I*) to add
    the stub method overrides for the interface, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须为`StereoRenderer`类添加方法覆盖。从智能感知菜单中选择**实现方法...**（或*Ctrl* + *I*），以添加接口的存根方法覆盖，如下所示：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It is now a good time to add an error reporting method, `checkGLError`, to
    `RenderBox` to log OpenGL rendering errors, as illustrated in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是添加一个错误报告方法`checkGLError`到`RenderBox`中来记录OpenGL渲染错误的好时机，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the previous chapter projects, we defined `MainActivity` so that it implements
    `CardboardView.StereoRenderer`. Now this is delegated to our new `RenderBox` object.
    Let's tell `MainActivity` to use it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节项目中，我们定义了`MainActivity`，使其实现了`CardboardView.StereoRenderer`。现在这个任务被委托给了我们的新的`RenderBox`对象。让我们告诉`MainActivity`去使用它。
- en: 'In `MainActivity.java`, modify the `onCreate` method to create a new instance
    of `RenderBox` and set it as the view renderer, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity.java`中，修改`onCreate`方法，创建`RenderBox`的新实例并将其设置为视图渲染器，如下所示：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that `cardboardView.setRender` is passed new `RenderBox`, which takes the
    `MainActivity` instance as both the `Activity` and `IRenderBox` arguments. Voila,
    we've taken control of the Cardboard SDK integration entirely, and now it's all
    about implementing `IRenderbox`. In this way, we have wrapped the Cardboard SDK,
    OpenGL, and a variety of other external dependencies in our own library. Now,
    if these specifications change, all we have to do is keep `RenderBox` up to date,
    and our app can tell `RenderBox` what to do, the same way as always.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`cardboardView.setRender`传递了新的`RenderBox`，它将`MainActivity`实例作为`Activity`和`IRenderBox`参数。哇，我们完全控制了Cardboard
    SDK的集成，现在一切都是关于实现`IRenderbox`。通过这种方式，我们将Cardboard SDK、OpenGL和各种其他外部依赖封装在我们自己的库中。现在，如果这些规范发生变化，我们只需要保持`RenderBox`更新，我们的应用程序就可以像以前一样告诉`RenderBox`该做什么。
- en: Adding the IRenderBox interface
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加IRenderBox接口
- en: Once we've put all this together, the `MainActivity` class will implement the
    `IRenderBox` interface. The interface provides callbacks for the `setup`, `preDraw`,
    and `postDraw` functions that the activity may implement.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们把所有这些放在一起，`MainActivity`类将实现`IRenderBox`接口。该接口为活动提供了`setup`、`preDraw`和`postDraw`函数的回调。
- en: The setup method will be called after doing some generic work in `onSurfaceCreated`.
    The `preDraw` and `postDraw` methods will be called during `onDrawEye`. We'll
    get to see this later in the chapter.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onSurfaceCreated`中进行一些通用工作后，将调用设置方法。在`onDrawEye`期间将调用`preDraw`和`postDraw`方法。我们将在本章后面看到这一点。
- en: 'We can set that up now. Right-click on `renderbox` in the hierarchy panel,
    navigate to **New** | **Java Class**, select **Kind: "Interface"**, and name it
    `IRenderBox`. It''s only a few lines and should include just the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以设置它了。在层次结构面板中右键单击`renderbox`，导航到**新建** | **Java类**，选择**类型："接口"**，并命名为`IRenderBox`。这只是几行代码，应该包括以下代码：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, modify `MainActivity` so that it implements `IRenderBox`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改`MainActivity`以使其实现`IRenderBox`：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Select intellisense **Implement Methods** (or *Ctrl* + *I*), to add the interface
    methods overrides. Android Studio will automatically fill in the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 选择智能感知**实现方法**（或*Ctrl* + *I*），以添加接口方法的覆盖。Android Studio将自动填充以下内容：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you run the empty app now, you will not get any build errors, and it''ll
    display the empty Cardboard split view:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行空白应用程序，将不会出现任何构建错误，并且它将显示空的Cardboard分屏视图：
- en: '![Adding the IRenderBox interface](img/B05144_05_03.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![添加IRenderBox接口](img/B05144_05_03.jpg)'
- en: Now we have created a skeleton app, ready to implement the `RenderBox` package
    and utilities, which we can use to help build new Cardboard VR applications.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个骨架应用程序，准备实现`RenderBox`包和实用程序，这将帮助我们构建新的Cardboard VR应用程序。
- en: In the next few topics, we will build some of the classes needed in `RenderBox`.
    Unfortunately, we can't display anything interesting on your Cardboard device
    until we get these coded up. This also limits our ability to test and verify that
    the coding is correct. This could be an appropriate time to introduce unit testing,
    such as JUnit. Refer to the *Unit testing support* docs for details ([http://tools.android.com/tech-docs/unit-testing-support](http://tools.android.com/tech-docs/unit-testing-support)).
    Unfortunately, space does not allow us to introduce this subject and use it for
    the projects in this book. But we encourage you to pursue this on your own. (And
    I'll remind you that the GitHub repository for this project has separate commits
    for each topic, incrementally adding code as we go along).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个主题中，我们将构建`RenderBox`中需要的一些类。不幸的是，在我们编写完这些代码之前，我们无法在您的Cardboard设备上显示任何有趣的东西。这也限制了我们测试和验证编码是否正确的能力。这可能是引入单元测试的合适时机，比如JUnit。有关详细信息，请参阅*Unit
    testing support*文档（[http://tools.android.com/tech-docs/unit-testing-support](http://tools.android.com/tech-docs/unit-testing-support)）。不幸的是，空间不允许我们介绍这个主题并在本书的项目中使用它。但我们鼓励您自己去追求这个。
    （我会提醒您，这个项目的GitHub存储库为每个主题都有单独的提交，随着我们的进行逐步添加代码）。
- en: Materials, textures, and shaders
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料、纹理和着色器
- en: In [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard Box*, we introduced
    the OpenGL ES 2.0 graphics pipeline and simple shaders. We will now extract that
    code into a separate `Material` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章 Cardboard Box")中，我们介绍了OpenGL ES 2.0图形管线和简单的着色器。现在我们将把这些代码提取到一个单独的`Material`类中。
- en: In computer graphics, materials refer to the visual surface characteristics
    of geometric models. When rendering an object in the scene, materials are used
    together with lighting and other scene information required by the shader code
    and the OpenGL graphics pipeline.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中，材料指的是几何模型的视觉表面特性。在场景中渲染对象时，材料与照明和着色器代码以及OpenGL图形管线所需的其他场景信息一起使用。
- en: A solid colored material is the simplest; the entire surface of the object is
    a single color. Any color variation in the final rendering will be due to lighting,
    shadows, and other features in a different shader variant. It is quite possible
    to produce solid color materials with lighting and shadows, but the simplest possible
    example just fills raster segments with the same color, such as our very first
    shader.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实色材料是最简单的；物体的整个表面是单一颜色。最终渲染中的任何颜色变化都是由于照明、阴影和其他着色器变体中的特性。完全可以使用照明和阴影来产生实色材料，但最简单的例子只是用相同的颜色填充光栅段，就像我们的第一个着色器一样。
- en: A textured material may have surface details defined in an image file (such
    as a JPG). Textures are like wallpapers pasted on the surface of the object. They
    can be used to a great extent and are responsible for most of the details that
    the user perceives on an object. A solid colored sphere may look like a ping pong
    ball. A textured sphere may look like the Earth. More texture channels can be
    added to define variations in shading or even to emit light when the surface is
    in shadow. You will see this kind of effect at the end of [Chapter 6](ch06.html
    "Chapter 6. Solar System"), *Solar System*, when we add an artificial light to
    the dark side of the Earth.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理材料可能在图像文件（如JPG）中定义表面细节。纹理就像贴在物体表面上的墙纸。它们可以被广泛使用，并负责用户在物体上感知到的大部分细节。一个实色的球体可能看起来像一个乒乓球。一个纹理球可能看起来像地球。可以添加更多的纹理通道来定义阴影的变化，甚至在表面处于阴影时发光。在[第6章](ch06.html
    "第6章 太阳系")结束时，您将看到这种效果，当我们在地球的黑暗一侧添加人造光源时。
- en: More realistic physically-based shading goes beyond texture maps to include
    simulated height maps, metallic shininess, and other imperfections, such as rust
    or dirt. We won't be going into that in this book, but it's common in graphics
    engines such as Unity 3D and the Unreal Engine. Our `RenderBox` library could
    be extended to support it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 更真实的基于物理的着色超出了纹理贴图，还包括模拟的高度图、金属光泽和其他瑕疵，比如锈迹或污垢。我们不会在本书中涉及到这一点，但在图形引擎如Unity 3D和虚幻引擎中很常见。我们的`RenderBox`库可以扩展以支持它。
- en: Presently, we'll build the infrastructure for a basic solid colored material
    and associated shaders. Later in the chapter, we'll expand it with lighting.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将为基本的实色材料和相关着色器构建基础设施。在本章的后面，我们将扩展它以支持照明。
- en: Abstract material
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象材料
- en: 'In the `renderbox/materials/` folder, create a new Java class named `Material`
    and begin to write it as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`renderbox/materials/`文件夹中，创建一个名为`Material`的新Java类，并开始编写如下：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This defines an abstract class that will be used to extend the various types
    of materials we define. The `createProgram` method loads the designated shader
    scripts and builds an OpenGL ES program with the shaders attached.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个抽象类，将用于扩展我们定义的各种类型的材料。`createProgram`方法加载指定的着色器脚本，并构建一个附有着色器的OpenGL ES程序。
- en: We also define an abstract `draw()` method that will be implemented in each
    shader separately. Among other things, it requires the `modelView` and `modelViewProjection`
    transformation matrices be declared at the top of the class. At this point, we
    will actually only use `modelViewProjection`, but a separate reference to the
    `modelView` matrix will be needed when we add lighting.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个抽象的`draw()`方法，将在每个着色器中单独实现。除其他事项外，它要求在类的顶部声明`modelView`和`modelViewProjection`变换矩阵。在这一点上，我们实际上只会使用`modelViewProjection`，但当我们添加照明时，将需要一个单独的引用`modelView`矩阵。
- en: 'Next, add the following utility methods to the `Material` class to load the
    shaders:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下实用方法添加到`Material`类中以加载着色器：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As discussed in [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard
    Box*, these methods will load a shader script and compile it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第3章](ch03.html "第3章。纸箱") *纸箱*中所讨论的，这些方法将加载一个着色器脚本并对其进行编译。
- en: Later on, we'll derive specific materials from this class, and define specific
    shaders that each one will use.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将从这个类派生特定的材料，并定义每个材料将使用的特定着色器。
- en: The Math package
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Math包
- en: In [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard Box*, we introduced
    3D geometry and matrix math calculations. We will wrap these up into even more
    useful functions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。纸箱") *纸箱*中，我们介绍了3D几何和矩阵数学计算。我们将把这些整合成更有用的函数。
- en: Much of this math code that we've put together is from existing open source
    projects (attributions are given in comments in the source code). After all, we
    might as well take advantage of the math geniuses who like this stuff and have
    open sourced excellent true and tested code. The code list is included with the
    file downloads for this book.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们组合的许多数学代码来自现有的开源项目（在源代码的注释中给出了归属）。毕竟，我们不妨利用那些喜欢这些东西并且开源了优秀的真实和经过测试的代码的数学天才。代码列表包含在本书的文件下载中。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The following list documents our math API. The actual code is included with
    the file downloads for this book and the GitHub repository.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表记录了我们的数学API。实际代码包含在本书的文件下载和GitHub存储库中。
- en: Generally speaking, the mathematics falls within the subject of linear algebra,
    but most of it is specific to graphics programming and works within the constraints
    of fast floating point math on modern CPUs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，这些数学都属于线性代数的范畴，但其中大部分是特定于图形编程的，并且在现代CPU上进行快速浮点数运算的限制内运行。
- en: We encourage you to browse the source code included with the book, which you
    will obviously need access to in order to complete the project. Suffice it to
    say that everything included is pretty standard fare for a 3D game engine and
    was, in fact, largely sourced from (or checked against) an open source engine
    called **LibGDX**. The math library for LibGDX is pretty vast, optimized for mobile
    CPUs, and could make a great drop-in replacement for our simpler math package.
    We will also use the Android `Matrix` class extensively, which, in most cases,
    runs in native code and avoids the overhead of the **Java Virtual Machine** (**JVM**
    or Dalvik VM in the case of Android).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您浏览本书附带的源代码，显然您需要访问才能完成项目。可以说，所有包含的内容对于3D游戏引擎来说都是非常标准的，并且实际上在很大程度上是从一个名为**LibGDX**的开源引擎中获取的（或者经过检查）。LibGDX的数学库非常庞大，针对移动CPU进行了优化，并且可以成为我们更简单的数学包的很好的替代品。我们还将广泛使用Android的`Matrix`类，在大多数情况下，它在本机代码中运行，并避免了**Java虚拟机**（**JVM**或在Android情况下的Dalvik
    VM）的开销。
- en: Here's a summary of our math API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们数学API的摘要。
- en: MathUtils
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MathUtils
- en: 'The `MathUtils` variables and methods are mostly self-explanatory: `PI`, `sin`,
    `cos`, and so on, defined to use `floats` as an alternative to Java''s `Math`
    class, which contains doubles. In computer graphics, we speak floats. The math
    takes less power and fewer transistors and the precision loss is acceptable. Your
    `MathUtils` class should look like the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`MathUtils`变量和方法大多是不言自明的：`PI`、`sin`、`cos`等，定义为使用`floats`作为Java的`Math`类的替代，该类包含双精度。在计算机图形学中，我们使用浮点数。数学计算需要更少的功率和更少的晶体管，精度损失是可以接受的。您的`MathUtils`类应该如下所示：'
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Matrix4
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Matrix4
- en: 'The `Matrix4` class manages 4 x 4 transformation matrices and is used to translate
    (position), rotate, and scale points in three-dimensional space. We''ll make good
    use of these soon. Here is an abridged version of the `Matrix4` class with function
    bodies removed:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Matrix4`类管理4x4变换矩阵，用于在三维空间中平移（位置）、旋转和缩放点。我们很快将充分利用这些。以下是`Matrix4`类的缩减版本，其中删除了函数体：'
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Make a special note of the TRS function. It is used by the `Transform` class
    to combine the position, rotation, and scale information into a useful matrix,
    which represents all three. The order in which this matrix is created is important.
    First, we generate a translation matrix, and then we rotate and scale it. The
    resulting matrix can be multiplied by any 3D point (our vertices) to apply these
    three operations hierarchically.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意TRS函数。它被`Transform`类用于将位置、旋转和缩放信息组合成一个有用的矩阵，代表所有三个。创建此矩阵的顺序很重要。首先，我们生成一个平移矩阵，然后我们旋转和缩放它。生成的矩阵可以与任何3D点（我们的顶点）相乘，以按层次应用这三个操作。
- en: Quaternion
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 四元数
- en: A **quaternion** represents a rotational orientation in three-dimensional space
    in such a way that, when two quaternions are combined, no information is lost.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**四元数**以这样的方式表示三维空间中的旋转方向，当两个四元数组合时，不会丢失任何信息。'
- en: 'From a human point of view, it''s easier to think of rotational orientation
    as three Euler (pronounced "oiler") angles since we think of three dimensions
    of rotation: pitch, yaw, and roll. The reason we use quaternions as opposed to
    a more straightforward vector representation of rotations is that depending on
    the order in which you apply the three Euler rotations to an object, the resulting
    3D orientation will be different.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从人类的角度来看，更容易将旋转方向视为三个欧拉（发音为“欧拉”）角，因为我们考虑旋转的三个维度：俯仰、偏航和滚动。我们使用四元数而不是更直接的旋转向量表示的原因是，根据您将三个欧拉旋转应用于对象的顺序，结果的3D方向将不同。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on quaternions and Euler angles, refer to the following
    links:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有关四元数和欧拉角的更多信息，请参考以下链接：
- en: '[https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation](https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation)'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation](https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation)'
- en: '[https://en.wikipedia.org/wiki/Euler_angles](https://en.wikipedia.org/wiki/Euler_angles)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Euler_angles](https://en.wikipedia.org/wiki/Euler_angles)'
- en: '[http://mathworld.wolfram.com/EulerAngles.html](http://mathworld.wolfram.com/EulerAngles.html)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://mathworld.wolfram.com/EulerAngles.html](http://mathworld.wolfram.com/EulerAngles.html)'
- en: '[https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles](https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles](https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles)'
- en: 'Even though quaternions are a four-dimensional construct, we treat each quaternion
    as a single value, which represents a 3D orientation. Thus, when we apply multiple
    rotation operations in a row, we don''t run into issues where one axis'' rotation
    influences the effect of another. If none of this makes any sense, don''t worry.
    This is one of the trickiest concepts in 3D graphics. Here is the abridged `Quaternion`
    class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管四元数是一个四维结构，但我们将每个四元数视为一个单一值，它代表一个3D方向。因此，当我们连续应用多个旋转操作时，不会出现一个轴的旋转影响另一个轴的效果的问题。如果这一切都毫无意义，不要担心。这是3D图形中最棘手的概念之一。以下是简化的`Quaternion`类：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Vector2
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vector2
- en: 'A **Vector2** is a two-dimensional point or direction vector defined by (X,Y)
    coordinates. With the `Vector2` class, you can transform and manipulate vectors.
    Here is the abridged `Vector2` class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vector2**是由（X，Y）坐标定义的二维点或方向向量。使用`Vector2`类，您可以转换和操作向量。以下是简化的`Vector2`类：'
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Vector3
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vector3
- en: 'A **Vector3** is a three-dimensional point or direction vector defined by X,
    Y, and Z coordinates. With the `Vector3` class, you can transform and manipulate
    vectors. Here is the abridged `Vector3` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vector3**是由X、Y和Z坐标定义的三维点或方向向量。使用`Vector3`类，您可以转换和操作向量。以下是简化的`Vector3`类：'
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`Vector2` and `Vector3` share a lot of the same functionality, but pay special
    attention to the functions that exist in 3D, and that do not exist in 2D. Next,
    we''ll see how the math library gets used when we implement the `Transform` class.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector2`和`Vector3`共享许多相同的功能，但要特别注意3D中存在而2D中不存在的函数。接下来，我们将看到在实现`Transform`类时如何使用数学库。'
- en: The Transform class
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Transform类
- en: A 3D virtual reality scene will be constructed from various objects, each with
    a position, rotation, and scale in 3D dimensional space defined by a `Transform`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 3D虚拟现实场景将由各种对象构建，每个对象在3D空间中由`Transform`定义了位置、旋转和缩放。
- en: It will also be naturally useful to permit transforms to be grouped hierarchically.
    This grouping also creates a distinction between local space and world space,
    where children only keep track of the difference between their **translation,
    rotation, and scale** (**TRS**) and that of their parent (local space). The actual
    data that we are storing is the local position (we'll use the words position and
    translation interchangeably), rotation, and scale. Global position, rotation,
    and scale are computed by combining the local TRS all the way up the chain of
    parents.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 允许对变换进行分层分组也是自然而然的有用的。这种分组还创建了本地空间和世界空间之间的区别，其中子对象只跟踪它们的**平移、旋转和缩放**（**TRS**）与其父对象的差异（本地空间）。我们存储的实际数据是本地位置（我们将使用位置和平移这两个词），旋转和缩放。全局位置、旋转和缩放是通过将本地TRS组合到所有父级链中计算出来的。
- en: First, let's define the `Transform` class. In the Android Studio hierarchy panel,
    right-click on `renderbox/`, go to **New** | **Java Class**, and name it `Transform`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义`Transform`类。在Android Studio的层次结构面板中，右键单击`renderbox/`，转到**新建** | **Java类**，并将其命名为`Transform`。
- en: 'Each `Transform` may have one or more associated components. Typically there
    is just one, but it is possible to add as many as you want (as we''ll see in the
    other projects in this book). We''ll maintain a list of components in the transform,
    as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Transform`可能有一个或多个关联的组件。通常只有一个，但可以添加尽可能多的组件（正如我们将在本书的其他项目中看到的）。我们将在变换中维护组件列表，如下所示：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will define the `Component` class in the next topic. If it really bothers
    you to reference it now before it's defined, you can start with an empty Component
    Java class in the `renderbox/components` folder.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个主题中定义`Component`类。如果在定义之前现在引用它真的让你困扰，你可以从`renderbox/components`文件夹中的空Component
    Java类开始。
- en: Now back to the `Transform` class. A `Transform` object has a location, orientation,
    and scale in space, defined by its `localPosition`, `localRotation`, and `localScale`
    variables. Let's define these private variables, and then add the methods to manipulate
    them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到`Transform`类。`Transform`对象在空间中有一个位置、方向和缩放，由其`localPosition`、`localRotation`和`localScale`变量定义。让我们定义这些私有变量，然后添加方法来操作它们。
- en: 'Also, as transforms can be arranged in a hierarchy, we''ll include a reference
    to a possible `parent` transform, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于变换可以按层次结构排列，我们将包括对可能的`parent`变换的引用，如下所示：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The position, rotation, and scale values are initialized to identity values,
    that is, no positional offset, rotation, or resizing until they are explicitly
    set elsewhere. Note that the identity scale is (1, 1, 1).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 位置、旋转和缩放值被初始化为身份值，也就是说，直到它们在其他地方被明确设置之前，没有位置偏移、旋转或调整大小。请注意，身份缩放是（1,1,1）。
- en: The `parent` transform variable allows each transform to have a single parent
    in the hierarchy. You can keep the list of children in the transform, but you
    might be surprised to know how far you can get without having to move down the
    hierarchy. If you can avoid it, as we have, you can save a good deal of branching
    when setting/unsetting a parent reference. Maintaining the list of children means
    an *O(n)* operation every time you unparent an object, and an extra *O(1)* insertion
    cost on setting a parent. It is also not very efficient to hunt through children
    looking for a particular object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`parent`变换变量允许每个变换在层次结构中有一个父级。你可以在变换中保留子对象的列表，但你可能会惊讶地知道，在不必深入层次结构的情况下，你可以走得很远。如果你可以避免，就像我们一样，你可以在设置/取消父引用时节省大量的分支。维护子对象列表意味着每次取消父对象的操作都需要*O(n)*的时间，设置父对象时还需要额外的*O(1)*插入成本。在子对象中寻找特定对象也不是很有效率。'
- en: Parent methods
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 父级方法
- en: 'The transform can be added or removed from its position in the hierarchy with
    the `setParent` and `unParent` methods, respectively. Let''s define them now:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setParent`和`unParent`方法可以将变换添加到层次结构中的位置或从中移除。现在让我们来定义它们：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Simply, the `setParent` method sets `this.parent` to the given parent transform.
    Optionally, you can specify that the position is updated relative to the parent.
    We added an optimization to skip this procedure if the parent is already set.
    Setting the parent to `null` is equivalent to calling `unParent`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，`setParent`方法将`this.parent`设置为给定的父级变换。可选地，您可以指定相对于父级更新位置。我们添加了一个优化，如果父级已经设置，则跳过此过程。将父级设置为`null`等同于调用`unParent`。
- en: The `unParent` method removes the transform from the hierarchy. Optionally,
    you can specify that the position is updated relative to the (previous) parents,
    so that the transform is now disconnected from the hierarchy but remains in the
    same position in world space.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`unParent`方法将变换从层次结构中移除。可选地，您可以指定相对于（先前的）父级更新位置，以便变换现在与层次结构断开连接，但仍保持在世界空间中的相同位置。'
- en: Note that the rotation and scale can, and should, also be updated when parenting
    and unparenting. We don't need that in the projects in this book, so they have
    been left as an exercise for the reader. Also, note that our `setParent` methods
    include an argument for whether to update the position. If it is `false`, the
    operation runs a little faster, but the global state of the object will change
    if the parent transform was not set to identity (no translation, rotation, or
    scale). For convenience, you may set `updatePosition` to `true`, which will apply
    the current global transformation to the local variables, keeping the object fixed
    in space, with its current rotation and scale.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当进行父子关系的设置和解除时，旋转和缩放也可以并且应该更新。在本书的项目中我们不需要这些，所以它们留作读者的练习。另外，注意我们的`setParent`方法包括一个参数来决定是否更新位置。如果设置为`false`，操作会更快一些，但是如果父变换没有设置为单位矩阵（无平移、旋转或缩放），对象的全局状态会发生变化。为了方便起见，您可以将`updatePosition`设置为`true`，这将将当前的全局变换应用到局部变量中，保持对象在空间中固定，保持当前的旋转和缩放。
- en: Position methods
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位置方法
- en: The `setPosition` methods set the transform position relative to the parent,
    or apply absolute world position to the local variable if there is no parent.
    Two overloads are provided if you want to use a vector or individual component
    values. `getPosition` will compute the world space position based on parent transforms,
    if they exist. Note that this will have a CPU cost related to the depth of the
    transform hierarchy. As an optimization, you may want to include a system to cache
    world space positions within the `Transform` class, invalidating the cache whenever
    a parent transform is modified. A simpler alternative would be to make sure that
    you store the position in a local variable right after calling `getPosition`.
    The same optimization applies for rotation and scale.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPosition`方法设置相对于父级的变换位置，或者如果没有父级，则将绝对世界位置应用于局部变量。如果要使用向量或单独的分量值，提供了两个重载。`getPosition`将基于父级变换计算世界空间位置。请注意，这将与变换层次的深度相关的CPU成本。作为优化，您可能希望在`Transform`类中包含一个系统来缓存世界空间位置，在修改父级变换时使缓存失效。一个更简单的替代方法是确保在调用`getPosition`后立即将位置存储在局部变量中。相同的优化也适用于旋转和缩放。'
- en: 'Define the position getters and setters as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 定义位置的获取器和设置器如下：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Rotation methods
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转方法
- en: 'The `setRotation` methods set the transform rotation relative to the parent,
    or the absolute world rotation is applied to the local variable if there is no
    parent. Again, multiple overloads provide options for different input data. Define
    the rotation getters and setters as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`setRotation`方法设置相对于父级的变换旋转，如果没有父级，则将绝对世界旋转应用于局部变量。同样，多个重载提供了不同输入数据的选项。定义旋转的获取器和设置器如下：'
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Scale methods
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩放方法
- en: 'The `setScale` methods set the transform scale relative to the parent, or apply
    the absolute scale to the local variable if there is no parent. Define getters
    and setters for the scale as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`setScale`方法设置相对于父级的变换比例，或者如果没有父级，则将绝对比例应用于局部变量。定义比例的获取器和设置器如下：'
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Transform to matrix and draw
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变换为矩阵并绘制
- en: The last thing we need to do with the `Transform` class is transform an identity
    matrix into one that will tell OpenGL how to draw the object correctly. To do
    this, we translate, rotate, and scale the matrix, in that order. Technically,
    we can also do cool things with matrices, such as shearing and skewing models,
    but the math is complicated enough as it is. If you want to learn more, type `transformation
    matrix`, `quaternion to matrix`, and some of the other terms that we have been
    throwing around into a search engine. The actual math behind all of this is fascinating
    and way too detailed to explain in a single paragraph.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transform`类的最后一件事是将单位矩阵转换为一个告诉OpenGL如何正确绘制对象的矩阵。为此，我们按顺序对矩阵进行平移、旋转和缩放。从技术上讲，我们还可以使用矩阵做一些很酷的事情，比如扭曲和倾斜模型，但数学已经足够复杂了。如果您想了解更多，请在搜索引擎中输入`变换矩阵`、`四元数到矩阵`以及我们一直在讨论的其他术语。所有这些背后的数学都是迷人的，而且太详细了，无法在一个段落中解释清楚。'
- en: We also provide the `drawMatrix()` function that sets up the lighting and model
    matrices for a draw call. Since the lighting model is an intermediate step, it
    makes sense to combine this call;
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提供了`drawMatrix()`函数，用于设置绘制调用的光照和模型矩阵。由于光照模型是一个中间步骤，将这个调用合并起来是有意义的；
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `drawMatrices` method uses variables from the `RenderObject` class, which
    will be defined later. It might seem very anti-Java that we are just setting our
    matrices to static variables in the `RenderObject` class. As you will see, there
    is actually no need for multiple instances of the `lightingModel` object and model
    to exist. They are always calculated just in time for each object as they are
    drawn. If we were to introduce optimizations that avoid recomputing this matrix
    all the time, it would make sense to keep the information around. For the sake
    of simplicity, we just recalculate the matrix every time each object is drawn,
    since it might have changed since the last frame.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`drawMatrices`方法使用了`RenderObject`类的变量，这些变量稍后将被定义。我们只是将我们的矩阵设置为`RenderObject`类中的静态变量，这似乎非常反Java。正如您将看到的，实际上并不需要多个`lightingModel`对象和模型的实例存在。它们总是在每个对象绘制时及时计算出来。如果我们要引入避免一直重新计算这个矩阵的优化，保留这些信息就是有意义的。为了简单起见，我们只是在每次绘制每个对象时重新计算矩阵，因为它可能与上一帧不同。'
- en: Next, we'll see how the `Transform` class gets used when we implement the `Component`
    class, which will be extended by a number of classes that define objects in the
    3D scene.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到`Transform`类在我们实现`Component`类时是如何被使用的，这个类将被一些定义3D场景中对象的类所扩展。
- en: The Component class
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组件类
- en: Our 3D virtual reality scenes consist of various kinds of components. Components
    may include geometric objects, lights, and cameras. Components can be positioned,
    rotated, and scaled in 3D space, according to their associated transform. Let's
    create a `Component` class that will serve as the basis for other object classes
    in the scene.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的3D虚拟现实场景由各种组件组成。组件可能包括几何对象、灯光和摄像机。根据其关联的变换，组件可以在3D空间中定位、旋转和缩放。让我们创建一个`Component`类，它将作为场景中其他对象类的基础。
- en: 'If you haven''t created `Component.java` yet, create one now in the `renderbox/components`
    folder. Define it as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有创建`Component.java`，现在在`renderbox/components`文件夹中创建一个。定义如下：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We've included an `enabled` flag, which will come in handy to easily hide/show
    objects when we draw our scene.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了一个`enabled`标志，当我们绘制场景时，这将非常方便地隐藏/显示对象。
- en: That's it. Next, we'll define our first component, `RenderObject`, to represent
    geometric objects in the scene.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。接下来，我们将定义我们的第一个组件`RenderObject`，以表示场景中的几何对象。
- en: The RenderObject component
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RenderObject组件
- en: '`RenderObject` will serve as the parent class of geometric objects that can
    be rendered in the scene. `RenderObject` extends `Component`, so it has a `Transform`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderObject`将作为可以在场景中渲染的几何对象的父类。`RenderObject`扩展了`Component`，因此它有一个`Transform`。'
- en: 'In the `renderbox/components` folder, create a new Java class, `RenderObject`.
    Define it as an abstract class that extends `Component`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`renderbox/components`文件夹中，创建一个名为`RenderObject`的新Java类。将其定义为扩展`Component`的抽象类：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first thing we do is have each instance add itself to the list of `renderObjects`
    maintained by the `RenderBox` instance. Let's jump over to the `RenderBox` class
    now and add support for this list.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是让每个实例将自己添加到由`RenderBox`实例维护的`renderObjects`列表中。现在让我们转到`RenderBox`类，并为这个列表添加支持。
- en: 'Open the `RenderBox.java` file and add a `renderObjects` list:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`RenderBox.java`文件并添加一个`renderObjects`列表：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, back to the `RenderObject` class; we''ll implement three methods: `allocateFloatBuffer`,
    `allocateShortBuffer`, and `draw`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`RenderObject`类；我们将实现三个方法：`allocateFloatBuffer`、`allocateShortBuffer`和`draw`。
- en: 'OpenGL ES requires us to allocate a number of different memory buffers for
    various data, including model vertices, normal vectors, and index lists. The `allocateFloatBuffer`
    and `allocateShortBuffer` methods are utility methods that objects can use for
    floats and integers, respectively. Indexes are integers (specifically, shorts);
    everything else will be floats. These will be available to derived object classes:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES要求我们为各种数据分配许多不同的内存缓冲区，包括模型顶点、法向量和索引列表。`allocateFloatBuffer`和`allocateShortBuffer`方法是对象可以用于浮点数和整数的实用方法。索引是整数（具体来说是short）；其他所有内容都将是浮点数。这些将可供派生对象类使用：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Clever readers might have noticed that we're using `ByteBuffer` first, and then
    converting it to `FloatBuffer` or `ShortBuffer`. While the conversion from a byte
    to float might make sense—raw memory is not often represented as floats—some might
    wonder why we don't allocate the `ShortBuffer` as a `ShortBuffer` from the start.
    The reason is actually the same in both cases. We want to take advantage of the
    `allocateDirect` method, which is more efficient and only exists within the `ByteBuffer`
    class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 聪明的读者可能已经注意到我们首先使用`ByteBuffer`，然后将其转换为`FloatBuffer`或`ShortBuffer`。虽然从字节到浮点的转换可能是有道理的——原始内存通常不表示为浮点数——但有些人可能会想知道为什么我们不从一开始就分配`ShortBuffer`作为`ShortBuffer`。实际上，原因在这两种情况下是一样的。我们希望利用`allocateDirect`方法，这是更有效率的，只存在于`ByteBuffer`类中。
- en: 'Ultimately, the purpose of a `RenderObject` component is to draw geometry on
    the screen. This is done by transforming the 3D view and rendering through a `Material`
    class. Let''s define variables for the material, some setter and getter methods,
    and the `draw` method:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，`RenderObject`组件的目的是在屏幕上绘制几何图形。这是通过对3D视图进行变换并通过`Material`类进行渲染来实现的。让我们为材质定义变量，一些setter和getter方法以及`draw`方法：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `draw` method prepares the model transform for this object, and most of
    the draw action happens in materials. The `draw` method will be called from the
    current `Camera` component as it responds to the pose from the Cardboard SDK's
    `onDrawEye` hook. If the component isn't enabled, it's skipped.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`方法为这个对象准备了模型变换，大部分绘制动作发生在材质中。`draw`方法将从当前的`Camera`组件中调用，因为它响应Cardboard
    SDK的`onDrawEye`挂钩的姿势。如果组件未启用，则会被跳过。'
- en: The `RenderObject` class is abstract; we will not be working with `RenderObjects`
    directly. Instead, we'll derive object classes, such as `Cube` and `Sphere`. Let's
    create the `Cube` class from the `RenderObject` component next.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderObject`类是抽象的；我们不会直接使用`RenderObjects`。相反，我们将派生对象类，比如`Cube`和`Sphere`。让我们从`RenderObject`组件中创建`Cube`类。 '
- en: The Cube RenderObject component
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cube RenderObject组件
- en: 'For demonstration purposes, we''ll start with a simple cube. Later on, we''ll
    improve it with lighting. In [Chapter 3](ch03.html "Chapter 3. Cardboard Box"),
    *Cardboard Box*, we defined a `Cube` model. We''ll start by using the same class
    and data structure here. You can even copy the code, but it''s shown in the following
    text. Create a `Cube` Java class in the `renderbox/components/` folder:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示目的，我们将从一个简单的立方体开始。稍后，我们将通过光照对其进行改进。在[第3章](ch03.html "第3章 Cardboard Box")中，我们定义了一个`Cube`模型。我们将从这里使用相同的类和数据结构。您甚至可以复制代码，但它在下面的文本中显示。在`renderbox/components/`文件夹中创建一个`Cube`Java类：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We list the coordinates for each face of the cube. Each face is made up of two
    triangles, resulting in 12 triangles, or a total of 36 sets of coordinates to
    define the cube.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列出了立方体每个面的坐标。每个面由两个三角形组成，共12个三角形，或者共36组坐标来定义立方体。
- en: We also list the different colors for each face of the cube. Rather than duplicating
    the colors 36 times, there's the `cubeFacesToArray` method to generate them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还列出了立方体每个面的不同颜色。而不是将颜色重复36次，有`cubeFacesToArray`方法来生成它们。
- en: Now, we need to upgrade `Cube` for `RenderBox`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要升级`Cube`以适用于`RenderBox`。
- en: 'First, add the words `extends` `RenderObject`. This will provide the `super()`
    method in the constructor and allow you to call the `draw()` method:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加`extends` `RenderObject`。这将在构造函数中提供`super()`方法，并允许您调用`draw()`方法：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Allocate buffers for its vertices and colors, and create the `Material` class
    that''ll be used for rendering:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为其顶点和颜色分配缓冲区，并创建将用于渲染的`Material`类：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We ensure that `allocateBuffers` is run only once by checking whether `vertexBuffer`
    is `null`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查`vertexBuffer`是否为`null`来确保`allocateBuffers`只运行一次。
- en: We plan to use the `VertexColorMaterial` class for rendering most cubes. That
    will be defined next.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划使用`VertexColorMaterial`类来渲染大多数立方体。接下来将定义它。
- en: A `Camera` component will call the `draw` method of the `Cube` class (inherited
    from `RenderObject`), which, in turn, calls the `Material` class's `draw` method.
    The `draw` method will be called from the main `Camera` component as it responds
    to the Cardboard SDK's `onDrawEye` hook.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera`组件将调用`Cube`类的`draw`方法（从`RenderObject`继承），然后调用`Material`类的`draw`方法。`draw`方法将从主`Camera`组件中调用，因为它响应Cardboard
    SDK的`onDrawEye`挂钩。'
- en: Vertex color material and shaders
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点颜色材质和着色器
- en: The `Cube` component needs a `Material` to render it on the display. Our `Cube`
    has separate colors for each face, defined as separate vertex colors. We'll define
    a `VertexColorMaterial` instance and the corresponding shaders.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cube`组件需要一个`Material`来在显示器上呈现。我们的`Cube`为每个面定义了单独的颜色，这些颜色被定义为单独的顶点颜色。我们将定义一个`VertexColorMaterial`实例和相应的着色器。'
- en: Vertex color shaders
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 顶点颜色着色器
- en: 'At a minimum, the OpenGL pipeline requires that we define a vertex shader,
    which transforms vertices from 3D space to 2D, and a fragment shader, which calculates
    the pixel color values for a raster segment. Similar to the simple shaders that
    we created in [Chapter 3](ch03.html "Chapter 3. Cardboard Box"), *Cardboard Box*,
    we''ll create two files, `vertex_color_vertex.shader` and `vertex_color_fragment.shader`.
    Unless you have done so already, create a new Android resource directory with
    the `raw` type and name it `raw`. Then, for each file, right-click on the directory,
    and go to **New** | **File**. Use the following code for each of the two files.
    The code for the vertex shader is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，OpenGL管道要求我们定义一个顶点着色器，它将顶点从3D空间转换到2D空间，以及一个片段着色器，它计算光栅段的像素颜色值。与我们在[第3章](ch03.html
    "第3章 Cardboard Box")中创建的简单着色器*Cardboard Box*类似，我们将创建两个文件，`vertex_color_vertex.shader`和`vertex_color_fragment.shader`。除非你已经这样做了，否则创建一个新的Android资源目录，类型为`raw`，并将其命名为`raw`。然后，对于每个文件，右键单击目录，然后转到**新建**
    | **文件**。对于这两个文件，使用以下代码。顶点着色器的代码如下：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The code for the fragment shader is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器的代码如下：
- en: '[PRE31]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `vertex` shader transforms each vertex by the `u_MVP` matrix, which will
    be supplied by the `Material` class's draw function. The fragment shader simply
    passes through the color specified by the vertex shader.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`vertex`着色器通过`u_MVP`矩阵转换每个顶点，这个矩阵将由`Material`类的绘制函数提供。片段着色器只是通过顶点着色器指定的颜色。'
- en: VertexColorMaterial
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VertexColorMaterial
- en: 'Now, we''re ready to implement our first material, the `VertexColorMaterial`
    class. Create a new Java class named `VertexColorMaterial` in the `renderbox/materials/`
    directory. Define the class as `extends Material`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备实现我们的第一个材质，`VertexColorMaterial`类。在`renderbox/materials/`目录中创建一个名为`VertexColorMaterial`的新Java类。将类定义为`extends
    Material`：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The methods we''re going to implement are as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的方法如下：
- en: '`VertexColorMaterial`: These are constructors'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VertexColorMaterial`：这些是构造函数'
- en: '`setupProgram`: This creates the shader program and gets its OpenGL variable
    locations'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setupProgram`：这将创建着色器程序并获取其OpenGL变量位置'
- en: '`setBuffers`: This sets the allocated buffer used in rendering'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setBuffers`：这将设置用于渲染的分配的缓冲区'
- en: '`draw`: This draws a model from a view perspective'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw`：这将从视图角度绘制模型'
- en: 'Here''s the complete code:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的代码：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `setupProgram` method creates an OpenGL ES program for the two shaders that
    we created in `res/raw/` directory—`vertex_color_vertex` and `vertex_color_fragment`.
    It then gets references to the `positionParam`, `colorParam`, and `MVPParm` shader
    variables using the `GetAttribLocation` and `GetUniformLocation` calls that provide
    memory locations within the shader program, which are used later for drawing.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupProgram`方法为我们在`res/raw/`目录中创建的两个着色器`vertex_color_vertex`和`vertex_color_fragment`创建了一个OpenGL
    ES程序。然后，它使用`GetAttribLocation`和`GetUniformLocation`调用获取`positionParam`、`colorParam`和`MVPParm`着色器变量的引用，这些引用在稍后用于绘制。'
- en: The `setBuffers` method sets the memory buffers for vertices that define an
    object that will be drawn using this material. The method assumes that an object
    model consists of a set of 3D vertices (X, Y, and Z coordinates).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`setBuffers`方法设置了用于定义将使用此材质绘制的对象的内存缓冲区。该方法假定对象模型由一组3D顶点（X、Y和Z坐标）组成。'
- en: The `draw()` method renders the object specified in the buffers with a given
    set of **model-view-perspective** (**MVP**) transformation matrices. (Refer to
    the *3D camera, perspective, and head rotation* section of [Chapter 3](ch03.html
    "Chapter 3. Cardboard Box"), *Cardboard Box*, for detailed explanations.)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()`方法使用给定的**模型视图透视**（**MVP**）变换矩阵在缓冲区中渲染指定的对象。（有关详细解释，请参阅[第3章](ch03.html
    "第3章。Cardboard Box")中的*3D相机、透视和头部旋转*部分，*Cardboard Box*。）'
- en: You may have noticed that we aren't using that `ShortBuffer` function mentioned
    earlier. Later on, materials will use the `glDrawElements` call along with an
    index buffer. `glDrawArrays` is essentially a degenerate form of `glDrawElements`,
    which assumes a sequential index buffer (that is, 0, 1, 2, 3, and so on). It is
    more efficient with complex models to reuse vertices between triangles, which
    necessitates an index buffer.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们没有使用之前提到的`ShortBuffer`函数。稍后，材料将使用`glDrawElements`调用以及索引缓冲区。`glDrawArrays`本质上是`glDrawElements`的退化形式，它假定一个顺序的索引缓冲区（即0、1、2、3等）。对于复杂的模型，重用三角形之间的顶点是更有效的，这就需要一个索引缓冲区。
- en: For completeness, we will also provide a `destroy()` method for each of the
    `Material` classes. We will come to know exactly why the material must be destroyed
    a little later.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们还将为每个`Material`类提供一个`destroy()`方法。稍后我们将确切地知道为什么必须销毁材料。
- en: As you can see, `Material` encapsulates much of the lower level OpenGL ES 2.0
    calls to compile the shader script, create a render program, set the model-view-perspective
    matrices in the shader, and draw the 3D graphic elements.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`Material`封装了许多底层的OpenGL ES 2.0调用，用于编译着色器脚本，创建渲染程序，在着色器中设置模型视图透视矩阵，并绘制3D图形元素。
- en: We can now implement the `Camera` component.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现`Camera`组件了。
- en: The Camera component
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Camera`组件'
- en: A `Camera` class is another type of `Component`, positioned in space like other
    component objects. The camera is special because through the camera's eyes, we
    render the scene. For VR, we render it twice, once for each eye.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera`类是另一种`Component`类型，像其他组件对象一样在空间中定位。摄像机很特殊，因为通过摄像机的眼睛，我们渲染场景。对于VR，我们为每只眼睛渲染一次。'
- en: 'Let''s create the `Camera` class, and then see how it works. Create it in the
    `renderbox/components` folder and define it as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`Camera`类，然后看看它是如何工作的。在`renderbox/components`文件夹中创建它，并定义如下：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `Camera` class implements two methods: `onNewFrame` and `onDrawEye`, which
    will be delegated from the `RenderBox` class (which, in turn, is delegated from
    `MainActivity`).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`Camera`类实现了两个方法：`onNewFrame`和`onDrawEye`，这些方法将从`RenderBox`类委托而来（而`RenderBox`类又是从`MainActivity`委托而来）。'
- en: As the name implies, `onNewFrame` is called on each new frame update. It is
    passed the current Cardboard SDK's `HeadTransform`, which describes the user's
    head orientation. Our camera actually doesn't need the `headTransform` value,
    because `Eye.getEyeView()`, which is combined with the camera matrix, also contains
    rotation information. Instead, we just need to define its position and initial
    direction using `Matrix.setLookAtM` (refer to [http://developer.android.com/reference/android/opengl/Matrix.html](http://developer.android.com/reference/android/opengl/Matrix.html)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`onNewFrame`在每个新帧更新时被调用。它接收当前Cardboard SDK的`HeadTransform`，描述了用户的头部方向。我们的摄像机实际上不需要`headTransform`值，因为`Eye.getEyeView()`中已经包含了旋转信息，它与摄像机矩阵结合在一起。相反，我们只需要使用`Matrix.setLookAtM`来定义其位置和初始方向（参考[http://developer.android.com/reference/android/opengl/Matrix.html](http://developer.android.com/reference/android/opengl/Matrix.html)）。
- en: The `onDrawEye` method is called by the Cardboard SDK once for each eye view.
    Given a Cardboard SDK eye view, the method begins to render the scene. It clears
    the surface, including the depth buffer (used to determine visible pixels), applies
    the eye transformation to the camera (including perspective), and then draws each
    `RenderObject` object in the scene.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`onDrawEye`方法由Cardboard SDK为每只眼睛视图调用一次。给定一个Cardboard SDK眼睛视图，该方法开始渲染场景。它清除表面，包括深度缓冲区（用于确定可见像素），将眼睛变换应用于摄像机（包括透视），然后绘制场景中的每个`RenderObject`对象。'
- en: RenderBox methods
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`RenderBox`方法'
- en: Alright! We're getting closer. We're now ready to build a little scene in `RenderBox`
    using the code we created earlier. To start, the scene will simply consist of
    a colored cube and, of course, a camera.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 好了！我们离目标更近了。现在，我们准备使用之前创建的代码在`RenderBox`中构建一个小场景。首先，场景将简单地由一个有颜色的立方体和一个摄像机组成。
- en: At the beginning of this project, we created the skeleton `RenderBox` class,
    which implements `CardboardView.StereoRenderer`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目开始时，我们创建了骨架`RenderBox`类，它实现了`CardboardView.StereoRenderer`。
- en: 'To this, we now add a `Camera` instance. At the top of the `RenderBox` class,
    declare `mainCamera`, which will get initialized in `onSurfaceCreated`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们添加一个`Camera`实例。在`RenderBox`类的顶部，声明`mainCamera`，它将在`onSurfaceCreated`中初始化：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that Android Studio may find other `Camera` classes; ensure that it uses
    the one that we created in this package.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Android Studio可能会找到其他`Camera`类；确保它使用我们在此包中创建的类。
- en: 'Shortly after your app starts and the `MainActivity` class is instantiated,
    the `onSurfaceCreated` callback is called. This is where we can clear the screen,
    allocate buffers, and build shader programs. Let''s add that now:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序启动后不久，`MainActivity`类被实例化，`onSurfaceCreated`回调被调用。这是我们可以清除屏幕、分配缓冲区和构建着色器程序的地方。现在让我们添加它：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To be safe, the first thing it does is call reset, which will destroy any materials
    that might have already been compiled by resetting their program handles, before
    possibly compiling others. The need for this will become clear in the later projects
    where we will implement the intent feature to launch/relaunch the apps:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，它首先调用reset，这将销毁可能已经通过重置其程序句柄编译的任何材料，然后可能编译其他材料。这个需要稍后的项目中会变得清楚，我们将实现意图功能来启动/重新启动应用程序：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The last thing `onSurfaceCreated` does is invoke the `setup` callback. This
    will be implemented in the interface implementer, which in our case is `MainActivity`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`onSurfaceCreated`的最后一件事是调用`setup`回调。这将在接口实现者中实现，我们的情况下是`MainActivity`。'
- en: In each new frame, we will call the camera's `onNewFrame` method to build the
    camera matrix and apply it to its model-view.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个新帧中，我们将调用相机的`onNewFrame`方法来构建相机矩阵并将其应用于其模型视图。
- en: 'Let''s also capture the current head pose (`headView` and `headAngles` as transformation
    matrices and angles, respectively) if we want to reference it in the later projects
    (refer to [https://developers.google.com/cardboard/android/latest/reference/com/google/vrtoolkit/cardboard/HeadTransform#public-constructors](https://developers.google.com/cardboard/android/latest/reference/com/google/vrtoolkit/cardboard/HeadTransform#public-constructors)).
    Still in `RenderBox`, add the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在以后的项目中引用当前的头部姿势（分别作为变换矩阵和角度的`headView`和`headAngles`），我们也可以在`RenderBox`中添加以下代码：
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, when the Cardboard SDK goes to draw each eye (for the left and right
    split screen stereoscopic views), we will call the camera''s `onDrawEye` method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当Cardboard SDK开始绘制每只眼睛（用于左右分屏立体视图），我们将调用相机的`onDrawEye`方法：
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: While we're at it, we can also enable the `preDraw` and `postDraw` callbacks
    (in the previous code, in `onNewFrame`, and in `onFinishFrame`, respectively).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们还可以启用`preDraw`和`postDraw`回调（在先前的代码中，在`onNewFrame`中以及在`onFinishFrame`中）。
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Should these interface callbacks be implemented in `MainActivity`, they will
    be called from here.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些接口回调在`MainActivity`中实现，它们将从这里调用。
- en: Now, we can build a scene that uses a `Camera`, a `Cube`, and the `VertexColorMaterial`
    class.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建一个使用`Camera`、`Cube`和`VertexColorMaterial`类的场景。
- en: A simple box scene
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的盒子场景
- en: '*Let''s rock this riddim!* Make a scene with just a cube and, of course, a
    camera (which has been set up automatically by `RenderBox`). Set up the `MainActivity`
    class using the `IRenderBox` interface''s `setup` callback.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们摇滚这个旋律！只需一个立方体和当然，一个相机（已经由`RenderBox`自动设置）。使用`IRenderBox`接口的`setup`回调设置`MainActivity`类。
- en: 'In `setup` of `MainActivity`, we create a `Transform` for the cube and position
    it so that it''s set back and slightly offset in space:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`的`setup`中，我们为立方体创建一个`Transform`并将其定位，使其在空间中被设置回并略微偏移：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In Android Studio, click on **Run**. The program should compile, build, and
    install onto your connected Android phone. If you receive any compile errors,
    fix them now! As mentioned earlier, with the `Matrix` class, make sure that you
    are importing the right `Camera` type. There is also a `Camera` class within the
    SDK, which represents the phone's physical camera.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中，点击**运行**。程序应该编译、构建并安装到您连接的Android手机上。如果收到任何编译错误，请立即修复！如前所述，使用`Matrix`类时，请确保导入正确的`Camera`类型。SDK中还有一个`Camera`类，表示手机的物理摄像头。
- en: You will see something like this on your device display. (Remember to start
    the app while the device is facing you, or you might need to look behind you to
    find the cube!)
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在设备显示上看到类似于这样的东西。（记住在设备面对您时启动应用程序，否则您可能需要转身才能找到立方体！）
- en: '![A simple box scene](img/B05144_05_04.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的盒子场景](img/B05144_05_04.jpg)'
- en: I don't know about you, but I'm excited! Now, let's add some light and shading.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道你，但我很兴奋！现在，让我们添加一些光和阴影。
- en: Cube with face normals
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有面法线的立方体
- en: Now, let's add a light to the scene and render the cube with it. To do this,
    we also need to define normal vectors for each face of the cube, which are used
    in the shader calculations.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向场景中添加光，并用它来渲染立方体。为此，我们还需要为立方体的每个面定义法线向量，这些向量在着色器计算中使用。
- en: 'If you derive `Cube` from the one in [Chapter 3](ch03.html "Chapter 3. Cardboard
    Box"), *Cardboard Box*, you may already have this code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从[第3章](ch03.html "第3章。纸箱")中的`Cube`派生，*纸箱*，你可能已经有这段代码：
- en: '[PRE42]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, add a buffers for the normals, like we have for colors and vertices, and
    allocate them:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为法线添加一个缓冲区，就像我们为颜色和顶点分配的一样，并为它们分配空间：
- en: '[PRE43]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We''re going to add a lighting option argument to `createMaterial` and implement
    it using `VertexColorLightingMaterial` if it is set to `true`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`createMaterial`中添加一个光照选项参数，并使用`VertexColorLightingMaterial`来实现它，如果设置为`true`：
- en: '[PRE44]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Of course, the `VertexColorLightingMaterial` class hasn't been written yet.
    That's coming up soon. However, first we should create a `Light` component that
    can also be added to illuminate the scene.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`VertexColorLightingMaterial`类还没有编写。这很快就会出现。然而，首先我们应该创建一个`Light`组件，也可以添加到照亮场景。
- en: 'We will refactor the `Cube()` constructor method with two variations. When
    no arguments are given, the `Cube` does not create any `Material`. When a Boolean
    lighting argument is given, that gets passed to `createMaterial` in order to choose
    the material:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用两种变体重构`Cube()`构造方法。当没有给出参数时，`Cube`不会创建任何`Material`。当给出一个布尔光照参数时，它会传递给`createMaterial`以选择材料：
- en: '[PRE45]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We'll remind you later, but don't forget to modify the call to new `Cube(true)`
    in `MainActivity` to pass the lighting option.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会提醒你，但不要忘记在`MainActivity`中修改对`Cube(true)`的调用以传递光照选项。
- en: Note that we're creating the material in the constructor out of convenience.
    There is nothing to stop us from just adding a `setMaterial()` method to `RenderObject`
    or making the material variable public. In fact, as the number of object and material
    types increases, this becomes the only sane way to proceed. This is a drawback
    of our simplified `Material` system, which expects a different class per material
    type.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，出于方便起见，我们在构造函数中创建了材料。没有什么能阻止我们只是向`RenderObject`添加一个`setMaterial()`方法或使材料变量公开。事实上，随着对象和材料类型的增加，这成为唯一合理的进行的方式。这是我们简化的`Material`系统的一个缺点，它期望每种材料类型有一个不同的类。
- en: The Light component
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光组件
- en: A light source in our scene is a type of `Component` with a color and a float
    array that is used to represent the calculated location in eye space. Let's create
    the `Light` class now.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，光源是一种带有颜色和浮点数组的“组件”，用于表示在眼睛空间中计算出的位置。现在让我们创建“光源”类。
- en: 'Create a new `Light` Java class in the `renderbox/components` folder. Define
    it as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在`renderbox/components`文件夹中创建一个新的`Light` Java类。定义如下：
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our default light is white (color 1,1,1).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的默认光源是白色（颜色为1,1,1）。
- en: The `onDraw` method calculates the actual light position in eye space based
    on the position of `Transform` multiplied by the current view matrix.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`onDraw`方法根据`Transform`的位置乘以当前视图矩阵来计算眼睛空间中的实际光源位置。'
- en: It's possible to extend `RenderBox` to support multiple light sources and other
    fancy rendering, such as shadows and so on. However, we will limit the scene to
    a single light source. Thus, we'll keep it as an instance variable in `RenderBox`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 可以扩展`RenderBox`以支持多个光源和其他复杂的渲染，比如阴影等等。但是，我们将限制场景中只有一个光源。因此，我们将保持它作为`RenderBox`中的实例变量。
- en: 'Now, we can add a default light to the scene in `RenderBox`, like how we added
    the `Camera` component earlier. In `RenderBox.java`, add the following code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`RenderBox`中向场景添加一个默认光源，就像我们之前添加`Camera`组件一样。在`RenderBox.java`中，添加以下代码：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Modify `onSurfaceCreated` to initialize the light and add it to the scene:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`onSurfaceCreated`以初始化光源并将其添加到场景中：
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, compute its position in the `Camera` class''s `onDrawEye` (it might change
    for every frame). Edit the `Camera` class in `Camera.java`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Camera`类的`onDrawEye`中计算其位置（它可能会在每一帧中改变）。编辑`Camera.java`中的`Camera`类：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Then, we'll also be able to reference the `mainLight` object in our `Material`
    class's `draw` method. We could have declared the color and position as static
    variables, since we are only using one light, but it makes more sense to plan
    for supporting multiple lights in the future.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们还可以在`Material`类的`draw`方法中引用`mainLight`对象。我们本可以将颜色和位置声明为静态变量，因为我们只使用一个光源，但是为了未来支持多个光源，这样做更有意义。
- en: Vertex color lighting material and shaders
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顶点颜色照明材质和着色器
- en: This next topic gets a bit complicated. We're going to write new vertex and
    fragment shaders that handle lighting and write a corresponding class extending
    `Material` that makes use of them. Don't worry though, we've already done this
    once before. We're just going to actually explain it this time.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题有点复杂。我们将编写新的顶点和片段着色器来处理光照，并编写一个扩展`Material`的相应类来使用它们。不过，不用担心，我们之前已经做过一次了。这次我们只是要真正解释一下。
- en: Let's dive right into it. Locate the `res/raw/` folder. Then, for each file,
    right-click on it, and go to **New** | **File** to create new files.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始。找到`res/raw/`文件夹。然后，对于每个文件，右键单击它，然后转到**新建** | **文件**以创建新文件。
- en: 'File: `res/raw/vertex_color_lighting_vertex.shader`'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`res/raw/vertex_color_lighting_vertex.shader`
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The vertex shader maps a 3D vertex to 2D screen space using a model-view transformation
    matrix. Then, it finds the light distance and direction to calculate the light
    color and intensity at that point. These values are passed through the graphics
    pipeline. The fragment shader then determines the pixel colors in the raster segment.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器使用模型视图变换矩阵将3D顶点映射到2D屏幕空间。然后，它找到光源距离和方向，计算该点的光颜色和强度。这些值通过图形管线传递。片段着色器然后确定光栅段中的像素颜色。
- en: '[PRE51]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we''ll create the `Material`. In the `renderbox/materials/` folder, create
    a `VertexColorLightingMaterial` class. Define it so it extends `Material`, and
    then declare its buffers and methods for `setupProgram` and `draw`. Here''s the
    code in all its gory glory:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建`Material`。在`renderbox/materials/`文件夹中，创建一个`VertexColorLightingMaterial`类。定义它以扩展`Material`，然后声明其缓冲区和`setupProgram`和`draw`方法。以下是完整的代码：
- en: '[PRE52]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: There's a lot going on here, but you can follow along if you read through it
    carefully. Mostly, the material code sets up the parameters that we wrote in the
    shader program.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情要做，但是如果你仔细阅读，就可以跟上。大多数情况下，材质代码设置了我们在着色器程序中编写的参数。
- en: It is especially important that in the `draw()` method, we obtain the current
    position transformation matrix, `RenderBox.instance.mainLight.lightPosInEyeSpace`
    of `mainLight` and the light color, and pass them along to the shader program.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw()`方法中特别重要的是，我们获取当前位置变换矩阵，`mainLight`的`RenderBox.instance.mainLight.lightPosInEyeSpace`和光颜色，并将它们传递给着色器程序。
- en: Now is a good time to bring up the calls to `GLES20.glEnableVertexAttribArray`,
    which is required for each vertex attribute you are using. Vertex attributes are
    any data which are specified for each vertex, so in this case, we have positions,
    normals, and colors. Unlike before, we're now using normal and colors.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是一个很好的时机来提及`GLES20.glEnableVertexAttribArray`的调用，这对于你使用的每个顶点属性都是必需的。顶点属性是为每个顶点指定的任何数据，因此在这种情况下，我们有位置、法线和颜色。与以前不同，我们现在使用法线和颜色。
- en: 'Having introduced a new `Material`, let''s follow our pattern of adding it
    to `RenderBox.reset()`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍了新的`Material`后，让我们按照惯例将其添加到`RenderBox.reset()`中：
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, in the `setup()` method of `MainActivity`, make sure that you pass
    the lighting parameter to the `Cube` constructor:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`MainActivity`的`setup()`方法中，确保将光照参数传递给`Cube`构造函数：
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Run your app. TAADAA!! There, we have it. The difference from the nonlit material
    view may be subtle, but it's more real, virtually.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的应用程序。TAADAA！现在我们有了。与非光照材质视图的差异可能很微妙，但它更真实，更虚拟。
- en: '![Vertex color lighting material and shaders](img/B05144_05_05.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![顶点颜色照明材质和着色器](img/B05144_05_05.jpg)'
- en: If you'd like to adjust the shading, you might need to play with the attenuation
    value used to calculate the diffuse lighting (for example, change `COEFF = 0.00001`
    to `0.001`) in `vertex_color_lighting_vertex.shader`, depending on the scale of
    your scene. For those still in the dark (pun intended), attenuation is a fancy
    word for how light intensity diminishes over distance, and actually refers to
    the same property of any physical signal (for example, light, radio, sound, and
    so on). If you have a very large scene, you might want a smaller value (so light
    reaches distant regions) or the inverse (so not everything is in light). You might
    also want to make the attenuation a uniform float parameter, which can be adjusted
    and set on a per-material or per-light basis, in order to achieve just the right
    lighting conditions.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想调整阴影，您可能需要调整用于计算漫反射光照的衰减值（例如，将`COEFF = 0.00001`更改为`0.001`）在`vertex_color_lighting_vertex.shader`中，具体取决于您场景的规模。对于那些仍然在黑暗中的人（意思是不了解），衰减是一个用于描述光强随距离减弱的术语，实际上也适用于任何物理信号（例如光、无线电、声音等）。如果您有一个非常大的场景，您可能需要一个较小的值（以便光线到达遥远的区域）或者相反（以便不是所有东西都在光线下）。您可能还希望将衰减设置为统一的浮点参数，可以根据材质或光源进行调整和设置，以实现恰到好处的光照条件。
- en: So far, we've been using a single point light to light our scene. A **point
    light** is a light source with a position in 3D space, which casts light equally
    in all directions. Just like a standard light bulb placed at a specific location
    in a room, all that matters is the distance between it and the object, and the
    angle at which the ray strikes the surface. Rotation doesn't matter for point
    lights, unless a cookie is used to apply a texture to the light. We do not implement
    light cookies in the book, but they're super cool.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用单个点光源照亮我们的场景。**点光源**是一个在3D空间中具有位置的光源，它在所有方向上均匀地投射光线。就像在房间的特定位置放置标准灯泡一样，重要的是它与物体之间的距离，以及光线击中表面的角度。对于点光源，旋转并不重要，除非使用cookie来将纹理应用到光线上。我们在书中没有实现光cookie，但它们非常酷。
- en: Other light sources can be directional lights, which will imitate sunlight on
    earth, where all of the light rays are going essentially in the same direction.
    Directional lights have a rotation that affects the direction of the light rays,
    but they do not have a position, as we assume that the theoretical source is infinitely
    far away along that direction vector. The third type of light source, from a graphics
    perspective, is a spotlight, where the light takes a cone shape and casts a circle
    or ellipse on the surface that it hits. The spotlight will end up working in a
    similar way to the perspective transformation that we do to our MVP matrix. We
    will only be using a single point light for the examples in this book. Implementation
    of other light source types is left as an exercise for the reader.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 其他光源可以是定向光，它们将模拟地球上的阳光，所有光线基本上都朝着同一个方向。定向光具有影响光线方向的旋转，但它们没有位置，因为我们假设理论上的光源在沿着该方向矢量的无限远处。从图形学的角度来看，第三种光源是聚光灯，其中光线呈锥形，并在其击中的表面上投射出一个圆形或椭圆形。聚光灯最终将以与我们对MVP矩阵进行的透视变换类似的方式工作。在本书的示例中，我们将只使用单个点光源。其他光源类型的实现留给读者作为练习。
- en: Time for animation
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画时间
- en: It's time to throw in a little more excitement. Let's animate the cube so that
    it rotates. This'll help demonstrate the shading as well.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候增加一些兴奋了。让我们动画化立方体，使其旋转。这将有助于演示阴影效果。
- en: For this, we need a `Time` class. This is a singleton utility class that ticks
    off frames and makes that information available to the application, for example,
    via `getDeltaTime`. Note that this is a `final` class, which explicitly means
    that it cannot be extended. There is no such thing as a static class in Java,
    but if we make the constructor private, we can ensure that nothing will ever instantiate
    it.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要一个`Time`类。这是一个单例实用程序类，用于计算帧并使该信息可用于应用程序，例如通过`getDeltaTime`。请注意，这是一个`final`类，这意味着它不能被扩展。在Java中没有静态类，但如果我们将构造函数设置为私有，我们可以确保没有东西会实例化它。
- en: 'Create a new `Time` class in the `renderbox/` folder. It won''t be getting
    extended, so we can declare it `final`. Here''s the code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在`renderbox/`文件夹中创建一个新的`Time`类。它不会被扩展，所以我们可以将其声明为`final`。以下是代码：
- en: '[PRE55]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Start the timer in the `RenderBox` setup:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RenderBox`设置中启动计时器：
- en: '[PRE56]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, in the `onNewFrame` method of `RenderBox`, call `Time.update()`:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`RenderBox`的`onNewFrame`方法中调用`Time.update()`：
- en: '[PRE57]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we can use it to modify the cube''s transform each frame, via the `preDraw()`
    interface hook. In `MainActivity`, make the cube rotate 5 degrees per second about
    the *X* axis, 10 degrees on the *Y* axis, and 7.5 degrees on the *Z* axis:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用它来修改每帧的立方体变换，通过`preDraw()`接口挂钩。在`MainActivity`中，使立方体每秒围绕*X*轴旋转5度，*Y*轴旋转10度，*Z*轴旋转7.5度：
- en: '[PRE58]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `getDeltaTime()` method returns the fraction of a second since the previous
    frame. So, if we want it to rotate 5 degrees around the *X* axis each second,
    we multiply `deltaTime` by 5 to get the fraction of a degree to turn this particular
    frame.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDeltaTime()`方法返回自上一帧以来的秒数。因此，如果我们希望它每秒围绕*X*轴旋转5度，我们将`deltaTime`乘以5，以获得这一帧要旋转的度数的比例。'
- en: Run the app. Rock and roll!!!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序。摇滚起来！！！
- en: Detect looking at objects
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测物体的朝向
- en: Wait, there's more! Just one more thing to add. Building interactive applications
    require us to be able to determine whether the user is gazing at a specific object.
    We can put this into `RenderObject`, so any objects in the scene can be gaze detected.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，还有更多！只需再添加一件事。构建交互式应用程序需要我们能够确定用户是否凝视特定对象。我们可以将其放入`RenderObject`中，以便场景中的任何对象都可以被凝视检测到。
- en: The technique that we'll implement is straightforward. Considering each object
    we render is projected onto a camera plane, we really only need to determine whether
    the user is looking at the object's plane. Basically, we check whether the vector
    between the camera and the plane position is the same as the camera's view direction.
    But we'll throw in some tolerance, so you don't have to look exactly at the center
    of the plane (that'd be impractical). We will check a narrow range. A good way
    to do this is to calculate the angle between the vectors. We calculate the pitch
    and yaw angles between these vectors (the up/down *X* axis angle and left/right
    *Y* axis angle, respectively). Then, we check whether these angles are within
    a narrow threshold range, indicating that the user is looking at the plane (more
    or less).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现的技术很简单。考虑到我们渲染的每个对象都投影到相机平面上，我们实际上只需要确定用户是否在观察对象的平面。基本上，我们检查相机和平面位置之间的向量是否与相机的视角方向相同。但我们会加入一些容差，这样你就不必完全看着平面的中心（那样是不切实际的）。我们将检查一个狭窄的范围。一个好的方法是计算这些向量之间的角度。我们计算这些向量之间的俯仰和偏航角度（分别是上/下*X*轴角度和左/右*Y*轴角度）。然后，我们检查这些角度是否在一个狭窄的阈值范围内，表明用户正在观察平面（多多少少）。
- en: This method is just like the one used in [Chapter 3](ch03.html "Chapter 3. Cardboard
    Box"), *Cardboard Box,* although at that time, we put it in `MainActivity`. Now,
    we'll move it into the `RenderObject` component.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法就像[第3章](ch03.html "第3章。纸板箱")*纸板箱*中使用的方法一样，尽管当时我们把它放在了`MainActivity`中。现在，我们将其移动到`RenderObject`组件中。
- en: Note that this can get inefficient. This technique is fine for our projects
    because there is a limited number of objects, so the calculation isn't expensive.
    But if we had a large complex scene with many objects, this setup would fall short.
    In that case, one solution is to add an `isSelectable` flag so that only those
    objects that should be interactive in a given frame will be interactive.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这可能会变得低效。这种技术对我们的项目来说是可以的，因为对象的数量有限，所以计算并不昂贵。但是，如果我们有一个包含许多对象的大型复杂场景，这种设置就会不够用了。在这种情况下，一个解决方案是添加一个`isSelectable`标志，以便只有在给定帧中应该是交互式的对象才会是交互式的。
- en: If we were using a fully-featured game engine, we would have a physics engine
    capable of doing a `raycast` to precisely determine whether the center of your
    gaze intersects the object with a high degree of accuracy. While this might be
    great in the context of a game, it is overkill for our purposes.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用一个功能齐全的游戏引擎，我们将拥有一个物理引擎，能够进行`raycast`来精确确定你的凝视中心是否与对象交叉，具有很高的准确度。虽然在游戏中这可能很棒，但对于我们的目的来说有些过度了。
- en: 'At the top of `RenderObject`, add a Boolean variable for an `isLooking` value.
    Also, add two variables to hold the yaw and pitch range limits to detect the camera
    viewing angle, and a `modelView` matrix that we''ll use for calculations:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RenderObject`的顶部，添加一个布尔变量来存储`isLooking`值。还要添加两个变量来保存偏航和俯仰范围限制，以检测相机的观察角度，以及我们将用于计算的`modelView`矩阵：
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The implementation of the `isLookingAtObject` method is as follows. We convert
    the object space to the camera space, using the `headView` value from `onNewFrame`,
    calculate the pitch and yaw angles, and then check whether they''re within the
    range of tolerance:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`isLookingAtObject`方法的实现如下。我们将对象空间转换为相机空间，使用`onNewFrame`中的`headView`值，计算俯仰和偏航角度，然后检查它们是否在容差范围内：'
- en: '[PRE60]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'For convenience, we''ll set the `isLooking` flag at the same time the object
    is drawn. Add the call at the end of the `draw` method:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们将在对象绘制时同时设置`isLooking`标志。在`draw`方法的末尾添加调用：
- en: '[PRE61]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: That should do it.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。
- en: 'For a simple test, we''ll log some text to the console when the user is gazing
    at the cube. In `MainActivity`, make a separate variable for the `Cube` object:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的测试，当用户凝视立方体时，我们将在控制台上记录一些文本。在`MainActivity`中，为`Cube`对象创建一个单独的变量：
- en: '[PRE62]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, test it in `postDraw`, as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`postDraw`中进行测试，如下所示：
- en: '[PRE63]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Exporting the RenderBox package
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导出RenderBox包
- en: Now that we've finished creating this beautiful `RenderBox` library, how do
    we reuse it in other projects? This is where **modules** and `.aar` files come
    into play. There are a number of ways to share code between Android projects.
    The most obvious way is to literally copy pieces of code into the next project
    as you see fit. While this is perfectly acceptable in certain situations, and
    in fact should be part of your normal process, it can become quite tedious. What
    if we have a bunch of files that reference each other and depend on a certain
    file hierarchy, such as `RenderBox`? If you're familiar with Java development,
    you might say, "Well, obviously just export the compiled classes in a `.jar` file."
    You would be right, except that this is Android. We have some generated classes
    as well as the `/res` folder, which contains, in this case, our shader code. What
    we actually want is an `.aar` file. Android programmers might be familiar with
    `.aidl` files, which are used for similar purposes, but specifically to establish
    interfaces between apps, and not encapsulate feature code.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经完成了创建这个美丽的`RenderBox`库，那么我们如何在其他项目中重用它呢？这就是**模块**和`.aar`文件发挥作用的地方。在Android项目之间共享代码有许多方法。最明显的方法是根据需要将代码片段直接复制到下一个项目中。虽然在某些情况下这是完全可以接受的，实际上应该是你正常流程的一部分，但这可能会变得相当乏味。如果我们有一堆相互引用并依赖于某个文件层次结构的文件，比如`RenderBox`，那该怎么办呢？如果你熟悉Java开发，你可能会说，“显然只需将编译后的类导出为`.jar`文件。”你说得对，除了这是Android。我们还有一些生成的类以及包含，这种情况下，我们的着色器代码的`/res`文件夹。实际上我们想要的是一个`.aar`文件。Android程序员可能熟悉`.aidl`文件，它们用于类似的目的，但专门用于在应用程序之间建立接口，而不是封装功能代码。
- en: To generate an `.aar` file, we first need to put our code inside an Android
    Studio module with a different output than an app. You have a few options from
    this point onward. We recommend that you create a dedicated Android Studio project,
    which contains the `RenderBox` module as well a test app, which will build alongside
    the library and serve as a means to ensure that any changes you make to the library
    don't break anything. You can also just copy the `renderbox` package and the `/res/raw`
    folders into a new project and go from there, but eventually, you'll see that
    a module is much more convenient.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个`.aar`文件，我们首先需要将我们的代码放入一个具有与应用程序不同输出的Android Studio模块中。从这一点开始，您有几个选项。我们建议您创建一个专用的Android
    Studio项目，其中包含`RenderBox`模块以及一个测试应用程序，它将与库一起构建，并作为一种手段来确保您对库所做的任何更改不会破坏任何内容。您也可以只是将`renderbox`包和`/res/raw`文件夹复制到一个新项目中，然后从那里开始，但最终您会发现模块更加方便。
- en: You might think "We're gonna call this new project `RenderBox`," but you might
    run into a snag. Basically, the build system can't handle a situation where a
    project and module have the same name (they would be expected to have the same
    package name, which is a no-no). If you call your project `RenderBox`, (technically,
    you shouldn't have if you followed the instructions) and include an activity,
    and then create a module called `RenderBox`, you will see a build error that complains
    about the project and module sharing a name. If you create an empty project with
    no activity called `RenderBox` and add a module called `RenderBox`, you happen
    to get away with it, but as soon as you try to build an app from this project,
    you'll find that you cannot. Hence, we suggest that your next step from here is
    to create a new project called `RenderBoxLib`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为"我们将把这个新项目称为`RenderBox`"，但您可能会遇到问题。基本上，构建系统无法处理项目和模块具有相同名称的情况（它们应该具有相同的包名称，这是不允许的）。如果您将项目命名为`RenderBox`（从技术上讲，如果您遵循了说明，您不应该这样做），并包含一个活动，然后创建一个名为`RenderBox`的模块，您将看到一个构建错误，抱怨项目和模块共享名称。如果您创建一个没有活动的空项目，称为`RenderBox`，并添加一个名为`RenderBox`的模块，您可能会得逞，但一旦您尝试从该项目构建应用程序，您会发现无法构建。因此，我们建议您从这里的下一步是创建一个名为`RenderBoxLib`的新项目。
- en: Building the RenderBoxLib module
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建RenderBoxLib模块
- en: Let's give it a shot. Go to **File** | **New** | **New Project**. Name the project
    `RenderBoxLib`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看。转到**文件** | **新建** | **新项目**。将项目命名为`RenderBoxLib`。
- en: We don't need a `MainActivity` class, but we're still going to want one, as
    discussed, as a test case to ensure that our library works. Adding a test app
    to the library project not only gives us the convenience of testing changes to
    the library in a single step, but also ensures that we cannot build a new version
    of the library without ensuring that an app that uses it can also compile it.
    Even if your library is free of syntax errors, it might still break compilation
    when you include it in a new project.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要`MainActivity`类，但我们仍然需要一个，如前所述，作为测试用例来确保我们的库正常工作。在库项目中添加一个测试应用程序不仅使我们能够在一个步骤中测试对库的更改，而且还确保我们不能构建库的新版本而不确保使用它的应用程序也可以编译它。即使您的库没有语法错误，当您将其包含在新项目中时，它可能仍会破坏编译。
- en: So, go ahead and add an **Empty Activity**, and click on **Finish** in the default
    options.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，继续添加一个**空活动**，然后在默认选项中点击**完成**。
- en: 'All familiar territory so far. However, now we''re going to create a new module:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止都是熟悉的领域。然而，现在我们要创建一个新模块：
- en: Go to **File** | **New** | **New Module** and select **Android Library**:![Building
    the RenderBoxLib module](img/B05144_05_06.jpg)
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**文件** | **新建** | **新模块**，然后选择**Android库**：![构建RenderBoxLib模块](img/B05144_05_06.jpg)
- en: Name it `RenderBox`.![Building the RenderBoxLib module](img/B05144_05_07.jpg)
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`RenderBox`。![构建RenderBoxLib模块](img/B05144_05_07.jpg)
- en: Now, we have a new folder in our project view:![Building the RenderBoxLib module](img/B05144_05_08.jpg)
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们在项目视图中有一个新文件夹：![构建RenderBoxLib模块](img/B05144_05_08.jpg)
- en: Instead of performing the next steps in Android Studio, let's just use our file
    manager (Windows Explorer or Finder, or the terminal if you're a pro) to copy
    our `RenderBox` files from the existing project into the new one. If you're using
    version control, you might consider transferring your repository to the new project,
    or creating an init commit before the copy; it's up to you and how much you care
    about preserving your history.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在Android Studio中执行下一步，让我们使用文件管理器（Windows资源管理器或Finder，或者如果您是专业人士，则使用终端）将`RenderBox`文件从现有项目复制到新项目中。如果您使用版本控制，您可能考虑将存储库转移到新项目，或在复制之前创建一个初始提交；这取决于您以及您对保留历史记录的重视程度。
- en: We want to copy all your `RenderBox` code to the new module from the `RenderBoxDemo`
    project's `/app/src/main/java/com/cardbookvr/renderbox` folder to the `/renderbox/src/main/java/com/cardbookvr/renderbox`
    folder of `RenderBoxLib`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将所有`RenderBox`代码从`RenderBoxDemo`项目的`/app/src/main/java/com/cardbookvr/renderbox`文件夹复制到`RenderBoxLib`的`/renderbox/src/main/java/com/cardbookvr/renderbox`文件夹中。
- en: The same goes for the resources; copy them from the `RenderBoxDemo` project's
    `/app/src/main/res/raw` folder to `/renderbox/src/main/res/raw`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 资源也是一样的；从`RenderBoxDemo`项目的`/app/src/main/res/raw`文件夹复制到`/renderbox/src/main/res/raw`文件夹。
- en: This means that almost every `.java` and `.shader` file that we created in the
    original project goes into the module of the new project, in their corresponding
    locations.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们在原始项目中创建的几乎每个`.java`和`.shader`文件都会放入新项目的模块中，放在相应的位置。
- en: We won't be transferring `MainActivity.java`, or any of the XML files, such
    as `layouts/activity_main.xml` or `AndroidManifest.xml` to the module. These are
    app-specific files, which are not included in the library.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会将`MainActivity.java`或任何XML文件，比如`layouts/activity_main.xml`或`AndroidManifest.xml`转移到模块中。这些都是特定于应用程序的文件，不包括在库中。
- en: Once you've copied the files, go back to Android Studio, and click on the **Synchronize**
    button. This will ensure that Android Studio has noticed the new files.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 复制文件后，返回到Android Studio，点击**同步**按钮。这将确保Android Studio已经注意到了新文件。
- en: '![Building the RenderBoxLib module](img/B05144_05_09.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![构建RenderBoxLib模块](img/B05144_05_09.jpg)'
- en: Then, with `renderbox` selected in the hierarchy panel, initiate a build by
    navigating to **Build** | **Make Module 'RenderBox'** (or *Ctrl* + *Shift* + *F9*).
    You will see a bunch of errors. Let's take care of them.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在层次结构面板中选择`renderbox`，通过导航到**构建** | **构建模块'RenderBox'**（或*Ctrl* + *Shift*
    + *F9*）来启动构建。您会看到一堆错误。让我们处理一下。
- en: '`RenderBox` references the Cardboard SDK, and as such, we must include it in
    the `RenderBox` module as a dependency in a similar way to how we do it for the
    main app, like at the beginning of this project:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '`RenderBox`引用了Cardboard SDK，因此，我们必须以类似的方式将其作为依赖项包含在`RenderBox`模块中，就像在项目开始时那样：'
- en: Add the Cardboard SDK `common.aar` and `core.aar` library files to your project
    as new modules, using **File** | **New** | **New Module...** and **Import .JAR/.AAR
    Package**.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Cardboard SDK的`common.aar`和`core.aar`库文件作为新模块添加到项目中，使用**文件** | **新建** | **新建模块...**和**导入.JAR/.AAR包**。
- en: Set the library modules as dependencies to the `RenderBox` model, using **File**
    | **Project Structure**. In the left-side panel, select `RenderBox`, then choose
    the **Dependencies** tab | **+** | **Module Dependency**, and add common and core
    modules.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将库模块设置为`RenderBox`模型的依赖项，使用**文件** | **项目结构**。在左侧面板中，选择`RenderBox`，然后选择**依赖项**选项卡
    | **+** | **模块依赖项**，并添加common和core模块。
- en: Once you sync the project and trigger a build, you will hopefully see those
    errors related to `CardboardView` and so on disappear.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您同步项目并触发构建，您希望看到与`CardboardView`相关的错误和其他错误消失。
- en: Another build. Still, other errors?
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 又一次构建。还有其他错误吗？
- en: This is because of the naming issues mentioned earlier. If the package name
    of your module doesn't match the package name from the original project (that
    is, `com.cardbookvr.renderbox`), you will have to rename it in the copied Java
    files. Even if these match, we named our original project `RenderBoxDemo`, which
    means that the generated R class will be part of the `com.cardbookvr.renderboxdemo`
    package. Any import references to this package will need to be changed.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为之前提到的命名问题。如果您的模块包名称与原始项目的包名称不匹配（即`com.cardbookvr.renderbox`），则必须在复制的Java文件中将其重命名。即使这些匹配，我们将原始项目命名为`RenderBoxDemo`，这意味着生成的R类将成为`com.cardbookvr.renderboxdemo`包的一部分。对这个包的任何导入引用都需要更改。
- en: 'Start by deleting the line that references `com.cardbookvr.renderboxdemo` (such
    as the `Material` Java files). Then, any references to the R class will show up
    as errors:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 首先删除引用`com.cardbookvr.renderboxdemo`（如`Material` Java文件）的行。然后，任何对R类的引用都会显示为错误：
- en: '![Building the RenderBoxLib module](img/B05144_05_12.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![构建RenderBoxLib模块](img/B05144_05_12.jpg)'
- en: Delete this line, and Android Studio will generate a new valid import line.
    Try and build it again. If it's error-free, we're good to go.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 删除这行，Android Studio将生成一个新的有效导入行。尝试再次构建。如果没有错误，我们就可以继续了。
- en: 'You will now see references to R show up as errors with a suggestion:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您会看到关于R的引用显示为错误，并提出建议：
- en: '![Building the RenderBoxLib module](img/B05144_05_13.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![构建RenderBoxLib模块](img/B05144_05_13.jpg)'
- en: If you go ahead and press *Alt* + *Enter*, Android Studio will add the appropriate
    import line to your code. If you don't see the *Alt* + *Enter* tooltip, try placing
    your cursor next to R. Using the feature this way, you'll have to select **Import
    Class** from the menu you see after pressing *Alt* + *Enter*. If you still see
    errors, make sure that you've copied the shader code into the `/renderbox/res/raw`
    folder, and that there aren't other errors interfering with this process. Essentially,
    we are removing any external references from the code and getting `RenderBox`
    to build on its own. We can also accomplish this code fix by simply pasting `import
    com.cardbook.renderbox.R;` over `import com.cardbook.renderboxdemo.R;`. That's
    probably easier than the first method, but then you wouldn't have learned about
    *Alt* + *Enter*.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您继续按*Alt* + *Enter*，Android Studio将为您的代码添加适当的导入行。如果您看不到*Alt* + *Enter*工具提示，请尝试将光标放在R旁边。通过这种方式使用该功能，您必须从按*Alt*
    + *Enter*后看到的菜单中选择**导入类**。如果仍然看到错误，请确保您已将着色器代码复制到`/renderbox/res/raw`文件夹中，并且没有其他错误干扰此过程。基本上，我们正在从代码中删除任何外部引用，并使`RenderBox`能够独立构建。我们也可以通过简单地将`import
    com.cardbook.renderbox.R;`粘贴到`import com.cardbook.renderboxdemo.R;`上来完成此代码修复。这可能比第一种方法更容易，但那样您就不会了解*Alt*
    + *Enter*了。
- en: Once this is done, we should be able to build without errors. This might seem
    like a messy way to work, but it doesn't hurt to get messy once in a while. You
    might even learn something new about the build pipeline you didn't know earlier.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们应该能够无错误地构建。这可能看起来有点凌乱，但偶尔凌乱一下也无妨。您甚至可能会对构建流程有所了解。
- en: If everything goes well, you will see a file called `renderbox-debug.aar` in
    `renderbox/build/outputs/aar/`. If so, you're done. Whew!
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您会在`renderbox/build/outputs/aar/`中看到一个名为`renderbox-debug.aar`的文件。如果是这样，您就完成了。哇！
- en: 'One final thought: you should include `renderbox-release.aar` in your final
    applications, but you will lose useful debugging features in the meantime. We
    will not discuss how to switch back and forth between debug and release in this
    book, but understanding build configurations is essential to the publication process.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点想法：您应该在最终应用程序中包含`renderbox-release.aar`，但与此同时将失去有用的调试功能。我们不会在本书中讨论如何在调试和发布之间切换，但了解构建配置对发布流程至关重要。
- en: The RenderBox test app
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RenderBox测试应用程序
- en: This new project houses the `renderbox` module, but there's also an `app` folder
    that we created in the first place. `app` is where we can implement a test application
    to make sure, at a minimum, that the library is built and basically runs.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新项目包含了`renderbox`模块，但也有一个我们最初创建的`app`文件夹。`app`是我们可以实现测试应用程序的地方，以确保至少库已构建并基本运行。
- en: 'We''re going to do the same thing to the app module in `RenderBoxLib` that
    we did in our new projects (like `renderbox`, `app` is a module. It turns out
    that we''ve been using modules the whole time!):'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对`RenderBoxLib`中的应用程序模块执行与我们的新项目相同的操作（就像`renderbox`一样，`app`是一个模块。原来我们一直在使用模块！）：
- en: Right-click on the `app` folder, go to **Open Module Settings**, and add the
    existing `renderbox` module as a **Module dependency** with **Compile Scope**.
    Notice that the dependencies cannot be circular. Now that `renderbox` is a dependency
    of the app, the reverse cannot be true.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`app`文件夹，转到**打开模块设置**，并将现有的`renderbox`模块作为**模块依赖项**添加到**编译范围**中。请注意，依赖项不能是循环的。现在`renderbox`是应用程序的依赖项，反之则不成立。
- en: Update `/res/layout/activity_main.xml` and `AndroidManifest.xml`, as we saw
    at the top of this chapter. (If you're just copying code, make sure that you change
    the `package=` value to the current name, for example, `com.cardbookvr.renderboxlib`).
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`/res/layout/activity_main.xml`和`AndroidManifest.xml`，就像我们在本章开头看到的那样。（如果您只是复制代码，请确保将`package=`值更改为当前名称，例如`com.cardbookvr.renderboxlib`）。
- en: Set up `class MainActivity extends CardboardActivity implements IRenderBox`.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`class MainActivity extends CardboardActivity implements IRenderBox`。
- en: We now also want our `MainActivity` class to instantiate `RenderBox` and define
    a `setup()` method, just like `MainActivity` in `RenderBoxDemo`. In fact, just
    go ahead and copy the entire `MainActivity` class from `RenderBoxDemo`, and make
    that you do not copy/overwrite the package definition at the top of the new file
    in your new project.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在还希望我们的`MainActivity`类实例化`RenderBox`并定义一个`setup()`方法，就像`RenderBoxDemo`中的`MainActivity`一样。实际上，只需复制整个`RenderBoxDemo`中的`MainActivity`类，并确保您不要复制/覆盖新文件的顶部的包定义。
- en: With any luck, you should be able to click on the green run button, select your
    target device, and see a running app with our buddy, the vertex color cube. We've
    officially gone backward in terms of the final result, but our application-specific
    code is so clean and simple!
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的话，您应该能够单击绿色运行按钮，选择目标设备，并看到一个运行中的应用程序，其中包含我们的伙伴，顶点颜色立方体。从最终结果来看，我们已经正式倒退了，但我们的应用程序特定代码非常干净和简单！
- en: Using RenderBox in future projects
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在未来项目中使用RenderBox
- en: 'Now that we''ve gone through all of this trouble, let''s do a trial run to
    see how to use our pretty little package all tied up with a bow. One more time.
    You can perform the following steps to start each of the subsequent projects in
    this book:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经经历了所有这些麻烦，让我们进行一次试运行，看看如何使用我们漂亮的小包装。再来一次。您可以执行以下步骤来启动本书中的每个后续项目：
- en: Create a new project, called whatever you like, such as `MyCardboardApp`, for
    API 19 KitKat. Include **Empty Activity**.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新项目，可以随意命名，例如`MyCardboardApp`，用于API 19 KitKat。包括**空活动**。
- en: Now, go to **File** | **New** | **New Module…**. It's a little counterintuitive,
    but even though we are importing an existing module, we're adding a new one to
    this project. Choose **Import .JAR/.AAR Package**.![Using RenderBox in future
    projects](img/B05144_05_14.jpg)
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，转到**文件** | **新建** | **新建模块...**。这有点违反直觉，尽管我们正在导入一个现有模块，但我们正在将一个新模块添加到这个项目中。选择**导入.JAR/.AAR包**。![在未来项目中使用RenderBox](img/B05144_05_14.jpg)
- en: 'You''ll need to navigate to the `RenderBoxLib/renderbox/build/outputs` folder
    of your `RenderBox` lib project, and select the `.aar` file. We recommend that
    you rename the module to `renderbox`, as opposed to `renderbox-debug`. Click on
    **Finish**. For a production app, you would want to have two different modules
    in your project: one for debug and one for release, but we will only be using
    debug for the projects in this book.'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要导航到`RenderBoxLib/renderbox/build/outputs`文件夹，选择`.aar`文件。我们建议将模块重命名为`renderbox`，而不是`renderbox-debug`。单击**完成**。对于生产应用程序，您希望在项目中有两个不同的模块：一个用于调试，一个用于发布，但是在本书的项目中，我们只使用调试。
- en: Now that we have this new module, we need to add it as a dependency to the default
    app. Go back to the familiar **Module Settings** screen, and head over to the
    **Dependencies** tab for `app`. Click on the plus tab on the right-hand side,
    and choose **Module dependency**:![Using RenderBox in future projects](img/B05144_05_15.jpg)
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们有了这个新模块，我们需要将其添加为默认应用程序的依赖项。返回熟悉的**模块设置**屏幕，转到`app`的**依赖项**选项卡。单击右侧的加号标签，并选择**模块依赖项**：![在未来项目中使用RenderBox](img/B05144_05_15.jpg)
- en: Then, you can add `renderbox`:![Using RenderBox in future projects](img/B05144_05_16.jpg)
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您可以添加`renderbox`：![在未来项目中使用RenderBox](img/B05144_05_16.jpg)
- en: We now have a copy of the `.aar` file in our new project's `/renderbox` module
    folder. When you've made changes to the `RenderBox` library, you just need to
    build a new `.aar` file (build menu, `MakeProject`), overwrite the copy in the
    new project, and trigger a project sync, or clean and rebuild if you want to be
    sure. The new project does not maintain a link to the build folder of your library
    output project.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在新项目的`/renderbox`模块文件夹中有了`.aar`文件的副本。当您对`RenderBox`库进行更改时，您只需要构建一个新的`.aar`文件（构建菜单，`MakeProject`），覆盖新项目中的副本，并触发项目同步，或者如果您想确保，可以进行清理和重建。新项目不会保持与库输出项目的构建文件夹的链接。
- en: 'The remaining steps required to setup a new project are as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 设置新项目所需的其余步骤如下：
- en: Use **File** | **New Module** to import the Cardboard SDK `.aar` packages `common`
    and `core`, and add them as dependencies to the app.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件** | **新建模块**导入Cardboard SDK的`.aar`包`common`和`core`，并将它们作为应用程序的依赖项添加进去。
- en: Update `/res/layout/activity_main.xml` and `AndroidManifest.xml`, as we've just
    done for `RenderBoxDemo`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`/res/layout/activity_main.xml`和`AndroidManifest.xml`，就像我们刚刚为`RenderBoxDemo`所做的那样。
- en: Set up the `MainActivity` class so that it extends `CardboardActivity` and implements
    `IRenderBox`, using the same code as before.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`MainActivity`类，使其扩展`CardboardActivity`并实现`IRenderBox`，使用与以前相同的代码。
- en: We now also want our `MainActivity` class to instantiate `RenderBox` and define
    a `setup()` method, just like our `MainActivity` class in `RenderBoxDemo`. In
    fact, just go ahead and copy the entire `MainActivity` class, and be careful not
    to copy/overwrite the package definition at the top of the file.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在也希望我们的`MainActivity`类实例化`RenderBox`并定义一个`setup()`方法，就像我们在`RenderBoxDemo`中的`MainActivity`类一样。实际上，只需复制整个`MainActivity`类，并小心不要复制/覆盖文件顶部的包定义。
- en: Build and run it yet again. Bagged it! We can now proceed with the cool stuff.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建和运行。搞定了！我们现在可以继续进行一些很酷的东西。
- en: Note
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This will be our new project process from now on, since the rest of the projects
    in this book make use of the `RenderBox` library module.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，这将是我们的新项目流程，因为本书中的其余项目都使用`RenderBox`库模块。
- en: 'A final word on the module process: there''s more than one way to peel an orange.
    You could have just created a new module in the `RenderBox` demo project, grabbed
    its output, and been off and running. You can also just copy source files around
    and try using Git submodules or subtrees to synchronize the sources. This page
    from the IntelliJ docs discusses some of the finer points as well ([https://www.jetbrains.com/idea/help/sharing-android-source-code-and-resources-using-library-projects.html](https://www.jetbrains.com/idea/help/sharing-android-source-code-and-resources-using-library-projects.html)).
    We''ve also made certain decisions in terms of keeping the main activity and layout
    files completely application-specific, and including most or all of our shaders
    and materials in the `RenderBox` module, instead of in application code. At any
    one of these decision points, there are pros and cons, and we recommend that you
    think carefully about how you structure your own code in future projects.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 关于模块流程的最后一句话：剥橙子的方法不止一种。您可以在`RenderBox`演示项目中创建一个新模块，获取其输出，然后开始运行。您还可以只是复制源文件并尝试使用Git子模块或子树来同步源代码。IntelliJ文档中的这一页讨论了一些更细节的内容（[https://www.jetbrains.com/idea/help/sharing-android-source-code-and-resources-using-library-projects.html](https://www.jetbrains.com/idea/help/sharing-android-source-code-and-resources-using-library-projects.html)）。在关于保持主要活动和布局文件完全特定于应用程序的决定以及在`RenderBox`模块中包含大部分或全部着色器和材料的决定方面，我们也做出了某些决定。在这些决策点中，都有利弊，我们建议您在未来的项目中仔细考虑如何构建自己的代码。
- en: Summary
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we created a short and sweet, lightweight graphics engine to
    build new Cardboard VR applications. We abstracted the low-level OpenGL ES API
    calls into a suite of `Material` classes and a `Camera` class. We defined `RenderObject`
    for geometric entities, a `Camera` and `Light` components which inherit from a
    `Component` class. We defined a `Transform` class to organize and orient entities
    (which contain components) hierarchically in 3D space. All of this is integrated
    under the `RenderBox` class, which is instantiated and controlled in the `MainActivity`
    class, which, in turn, implements the `IRenderBox` interface. We complete the
    circle by specifying the `MainActivity` class as the implementer of `IRenderBox`
    and implementing `setup`, `preDraw`, and `postDraw`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个简短而轻巧的图形引擎，用于构建新的Cardboard VR应用程序。我们将低级别的OpenGL ES API调用抽象成一套`Material`类和一个`Camera`类。我们为几何实体定义了`RenderObject`，以及从`Component`类继承的`Camera`和`Light`组件。我们定义了一个`Transform`类，用于在3D空间中层次化地组织和定位实体（包含组件）。所有这些都集成在`RenderBox`类下，该类在`MainActivity`类中实例化和控制，而`MainActivity`类又实现了`IRenderBox`接口。我们通过指定`MainActivity`类作为`IRenderBox`的实现者，并实现`setup`、`preDraw`和`postDraw`来完成循环。
- en: To develop the library, we followed much of what was covered in [Chapter 3](ch03.html
    "Chapter 3. Cardboard Box"), *Cardboard Box*, with less explanation of how to
    use OpenGL ES and matrix libraries and more focus on implementing our `RenderBox`
    software architecture.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开发这个库，我们遵循了[第3章](ch03.html "第3章。纸板盒")*纸板盒*中涵盖的大部分内容，少了一些关于如何使用OpenGL ES和矩阵库的解释，更多地关注实现我们的`RenderBox`软件架构。
- en: The resulting `RenderBox` engine library is now in its own project. In subsequent
    chapters we will reuse this library, and we will expand it, including new Components
    and Materials. You are encouraged to maintain your `RenderBoxLib` code in a source
    code repository, such as Git. Of course, the final code is provided with the book
    assets and in our GitHub repository.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`RenderBox`引擎库现在在自己的项目中。在接下来的章节中，我们将重用这个库，并且我们将扩展它，包括新的组件和材料。我们鼓励您将`RenderBoxLib`代码保存在源代码仓库中，比如Git。当然，最终的代码是与书籍资产一起提供的，并且在我们的GitHub仓库中也有。
- en: The next chapter is a science project! We're going to build a model of our Solar
    System, replete with the Sun, planets, moons, and a starscape. Using `RenderBox`,
    we will add a `Sphere` component, and we will also add textured shaders to our
    suite of materials.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是一个科学项目！我们将建立一个我们太阳系的模型，包括太阳、行星、卫星和星空。使用`RenderBox`，我们将添加一个`Sphere`组件，并将纹理着色器添加到我们的材料套件中。
