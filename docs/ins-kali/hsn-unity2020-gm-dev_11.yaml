- en: '*Chapter 11*: User Interface Design'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：用户界面设计'
- en: Everything that is shown on the screen and transmits through the speakers of
    a computer is forms of communication. In previous chapters, we used three-dimensional
    models to let the user know that they are in a base in the middle of the mountains,
    and we reinforced that idea with the appropriate sound and music. But for our
    game, we need to communicate other information, such as the amount of life the
    user has left, the current score, and so on, and sometimes, it is difficult to
    express these things using the in-game graphics (there are some successful cases
    that manage to do this, such as *Dead Space*, but let's keep things simple). In
    order to transmit this information, we will add another layer of graphics on top
    of our scene, which is usually called the **User Interface** (**UI**) or **Heads-Up
    Display** (**HUD**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上显示的一切并通过计算机的扬声器传达的都是一种形式的沟通。在之前的章节中，我们使用三维模型让用户知道他们在山中的基地，并通过适当的声音和音乐加强了这个想法。但对于我们的游戏，我们需要传达其他信息，比如用户剩余的生命值、当前得分等，有时很难使用游戏内图形来表达这些信息（有一些成功的案例可以做到这一点，比如*死亡空间*，但让我们保持简单）。为了传达这些信息，我们将在我们的场景顶部添加另一层图形，通常称为**用户界面**（**UI**）或**抬头显示**（**HUD**）。
- en: 'This will contain different visual elements, such as text fields, bars, and
    buttons, to prepare the user to take an informed decision based on things such
    as fleeing to a safe place when their life is low:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这将包含不同的视觉元素，如文本字段、条形图和按钮，以便用户可以根据诸如生命值低时逃到安全地方等情况做出知情决策：
- en: '![Figure 11.1 – Character creation UI displays info about the character stats
    with numbers'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 – 角色创建UI显示有关角色统计信息的数字'
- en: '](img/Figure_11.01_B14199.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.01_B14199.jpg)'
- en: Figure 11.1 – Character creation UI displays info about the character stats
    with numbers
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 角色创建UI显示有关角色统计信息的数字
- en: 'In this chapter, we will examine the following UI concepts:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下UI概念：
- en: Understanding **Canvas** and **RectTransform**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解**Canvas**和**RectTransform**
- en: Canvas object types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Canvas对象类型
- en: Creating a responsive UI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建响应式UI
- en: By the end of this chapter, you will be able to use the Unity UI system to create
    interfaces capable of informing the user about the state of the game and allowing
    them to take action by pressing buttons. Let's start discussing one of the basic
    concepts of the Unity UI system—RectTransform.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够使用Unity UI系统创建能够通知用户游戏状态并允许他们通过按按钮来采取行动的界面。让我们开始讨论Unity UI系统的基本概念之一——RectTransform。
- en: Understanding Canvas and RectTransform
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Canvas和RectTransform
- en: 'Currently, there are three UI systems available in Unity for different purposes:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Unity中有三种不同用途的UI系统：
- en: '**UI Elements**: A system to extend the Unity Editor with custom windows and
    tools. This uses several web concepts, such as stylesheets and XML-based language,
    to lay out your UI. In the future, it will be available to use in-game.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI元素**：用于扩展Unity编辑器的系统，具有自定义窗口和工具。它使用了一些Web概念，如样式表和基于XML的语言来布局您的UI。将来，它将可用于游戏中使用。'
- en: '**Unity UI**: A GameObject-based UI only applicable for in-game UIs (not editor
    extensions). You create it using GameObjects and components like any other object
    we have edited so far.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity UI**：基于GameObject的UI仅适用于游戏内UI（不是编辑器扩展）。您可以像编辑其他对象一样使用GameObject和组件来创建它。'
- en: '**IMGUI**: A legacy code-based UI created entirely by using scripting. A long
    time ago, this was the only UI system used in both the editor and the in-game
    UI. Nowadays, it is only used to extend the editor and will soon be completely
    replaced by UI Elements.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IMGUI**：一种完全使用脚本创建的遗留代码UI。很久以前，这是编辑器和游戏内UI中唯一使用的UI系统。如今，它只用于扩展编辑器，并很快将被UI元素完全取代。'
- en: In this chapter, we are only going to focus on in-game UI to communicate different
    information to the player regarding the state of the game, so we are going to
    use Unity UI. At the time of writing this book, there are plans to replace Unity
    UI with UI Elements, but there's no estimated date as to when this will happen.
    Anyway, even if Unity releases UI Elements as an in-game UI system soon, Unity
    UI will still be there for a while and is perfectly capable of handling all types
    of UI that you need to create.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只关注游戏内UI，以向玩家传达有关游戏状态的不同信息，因此我们将使用Unity UI。在撰写本书时，有计划用UI元素替换Unity UI，但尚无预计的时间。无论如何，即使Unity很快发布UI元素作为游戏内UI系统，Unity
    UI仍将存在一段时间，并且完全能够处理您需要创建的所有类型的UI。
- en: If you are going to work with Unity UI, you first need to understand its two
    main concepts—Canvas and **RectTransform**. Canvas is the master object that will
    contain and render our UI and RectTransform is the feature in charge of positioning
    and adapting each UI element on our screen.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要使用Unity UI，首先需要了解它的两个主要概念——Canvas和**RectTransform**。Canvas是将包含和渲染我们的UI的主对象，而RectTransform是负责在屏幕上定位和调整每个UI元素的功能。
- en: 'In this section, we will examine the following Unity UI concepts:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将研究以下Unity UI概念：
- en: Creating a UI with Canvas
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Canvas创建UI
- en: Positioning elements with RectTransform
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RectTransform定位元素
- en: Let's start using the Canvas component to create our UI.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用Canvas组件来创建我们的UI。
- en: Creating a UI with Canvas
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Canvas创建UI
- en: In Unity UI, each image, text, and element you see in the UI is a GameObject
    with a set of proper components, but in order for them to work, they must be a
    child of a master GameObject with the Canvas component. This component is responsible
    for triggering the UI generation and drawing iterations over each child object.
    We can configure this component to specify exactly how that process works and
    adapt it to different possible requirements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity UI中，你在UI中看到的每个图像、文本和元素都是一个GameObject，具有一组适当的组件，但为了让它们工作，它们必须是带有Canvas组件的主GameObject的子对象。这个组件负责触发UI生成并在每个子对象上进行绘制迭代。我们可以配置这个组件来指定这个过程的工作方式，并使其适应不同的可能要求。
- en: 'To start, you can simply create a canvas with the **GameObject** | **UI** |
    **Canvas** option. After doing that, you will see a rectangle in the scene, which
    represents the user screen, so you can put elements inside it and preview where
    they will be located relative to the user''s monitor. You can see an example of
    this rectangle in the following screenshot:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可以通过**GameObject** | **UI** | **Canvas**选项简单地创建一个画布。这样做后，您将在场景中看到一个矩形，代表用户屏幕，因此您可以在其中放置元素，并预览它们相对于用户监视器的位置。您可以在以下截图中看到这个矩形的示例：
- en: '![Figure 11.2 – Canvas screen rectangle'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2 - 画布屏幕矩形'
- en: '](img/Figure_11.02_B14199.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.02_B14199.jpg)'
- en: Figure 11.2 – Canvas screen rectangle
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 - 画布屏幕矩形
- en: You are probably wondering two things here. First, "why is the rectangle is
    in the middle of the scene? I want it to always be on the screen!". Don't worry
    because that will exactly be the case. When you edit the UI, you will see it as
    part of the level, as an object inside it, but when you play the game, it will
    be always projected over the screen, on top of every object. Also, you may be
    wondering why the rectangle is huge, and that's because one pixel of the screen
    maps to one meter on the scene. So again, don't worry about that; you will see
    all your UI elements in their proper size and position on the user's screen when
    you see the game in Game view.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想到两件事。首先，“为什么矩形在场景中间？我希望它始终显示在屏幕上！”。不用担心，因为情况确实如此。当您编辑UI时，您将把它视为级别的一部分，作为其中的一个对象，但当您玩游戏时，它将始终投影到屏幕上，覆盖在每个对象的顶部。此外，您可能会想知道为什么矩形如此巨大，这是因为屏幕上的一个像素在场景上对应一米。所以不用担心这一点；当您在游戏视图中看到游戏时，您将看到所有UI元素在用户屏幕上的正确大小和位置。
- en: Before adding elements to our UI, it's worth noting that when you created the
    UI, a second object is created alongside the canvas, called Event System. This
    object is not necessary to render a UI, but is necessary if you want the UI to
    be interactable, which means including actions such as clicking buttons, introducing
    text in fields, or navigating the UI with the joystick. The **EventSystem** component
    is responsible for sampling the user input, such as with a keyboard, mouse, or
    joystick, and sending that data to the UI to react accordingly. We can change
    the exact buttons to interact with the UI, but the defaults are OK for now, so
    just know that you need this object if you want to interact with the UI. If for
    some reason you delete the object, you can recreate it again in **GameObject**
    | **UI** | **Event System**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在向UI添加元素之前，值得注意的是，当您创建UI时，会在画布旁边创建第二个对象，称为事件系统。这个对象对于渲染UI并不是必要的，但如果您希望UI可以交互，也就是包括点击按钮、在字段中输入文本或使用摇杆导航UI等操作，那么它就是必要的。**EventSystem**组件负责对用户输入进行采样，比如键盘、鼠标或摇杆，并将数据发送给UI以做出相应反应。我们可以更改与UI交互的确切按钮，但默认值现在可以接受，所以只需知道如果要与UI交互，就需要这个对象。如果出于某种原因删除了该对象，可以在**GameObject**
    | **UI** | **Event System**中重新创建它。
- en: Now that we have the base objects to create our UI, let's add elements to it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建UI的基本对象，让我们向其中添加元素。
- en: Positioning elements with RectTransform
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RectTransform定位元素
- en: In Unity UI, each image, text, and element you see in the UI is a GameObject
    with a set of proper components according to its usage, but you will see that
    most of them have one component in common—**RectTransform**. Each piece of the
    UI is essentially a rectangle filled with text or images and has different behavior,
    so it is important to understand how the **RectTransform** component works and
    how to edit it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity UI中，您在UI中看到的每个图像、文本和元素都是一个GameObject，具有一组适合其用途的组件，但您会发现它们大多数都有一个共同的组件-**RectTransform**。UI的每个部分本质上都是一个填充有文本或图像的矩形，并且具有不同的行为，因此了解**RectTransform**组件的工作原理以及如何编辑它是很重要的。
- en: 'In order to experiment with this component, let''s create and edit the position
    of a simple white rectangle element for the UI by doing the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试这个组件，让我们通过以下步骤创建和编辑UI的一个简单白色矩形元素的位置：
- en: Go to **GameObject** | **UI** | **Image**. After that, you will see that a new
    GameObject is created within the **Canvas** element. Unity will take care of setting
    any new UI element as a child of **Canvas**; outside it, the element will not
    be visible:![Figure 11.3 – A default image UI element—a white box
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**GameObject** | **UI** | **Image**。之后，您将看到在**Canvas**元素内创建了一个新的GameObject。Unity会负责将任何新的UI元素设置为**Canvas**的子元素；在外面，该元素将不可见：![图11.3
    - 默认图像UI元素-白色框
- en: '](img/Figure_11.03_B14199.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.03_B14199.jpg)'
- en: Figure 11.3 – A default image UI element—a white box
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 - 默认图像UI元素-白色框
- en: Click on the 2D button in the top bar of the **Scene** view. This will just
    change the perspective of the Scene view to one that is better suited to edit
    the UI (and also two-dimensional games):![Figure 11.4 – The 2D button location
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**场景**视图顶部栏中的2D按钮。这将只是改变场景视图的透视，以更适合编辑UI（以及二维游戏）：![图11.4 - 2D按钮位置
- en: '](img/Figure_11.04_B14199.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.04_B14199.jpg)'
- en: Figure 11.4 – The 2D button location
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 - 2D按钮位置
- en: Double-click on the canvas in the **Hierarchy** window to make the UI fit entirely
    in the Scene view. This will allow us to edit the UI clearly. You can also navigate
    the UI using the mouse scroll wheel to zoom, and click and drag the scroll wheel
    to pan the camera:![Figure 11.5 – The Scene view in 2D edit mode
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击**层次结构**窗口中的画布，使UI完全适应场景视图。这将使我们能够清楚地编辑UI。您还可以使用鼠标滚轮导航UI进行缩放，并单击并拖动滚轮以平移相机：![图11.5
    - 2D编辑模式下的场景视图
- en: '](img/Figure_11.05_B14199.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.05_B14199.jpg)'
- en: Figure 11.5 – The Scene view in 2D edit mode
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 - 2D编辑模式下的场景视图
- en: Disable the **PPVolume** object to disable postprocessing. The final UI won't
    have postprocessing, but the editor view still applies it. Remember to re-enable
    it later:![Figure 11.6 – Disabling a game object—in this case, the postprocessing
    volume
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 禁用**PPVolume**对象以禁用后期处理。最终的UI不会有后期处理，但编辑器视图仍然会应用它。记得稍后重新启用它：![图11.6 - 禁用游戏对象-在这种情况下是后期处理体积
- en: '](img/Figure_11.06_B14199.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.06_B14199.jpg)'
- en: Figure 11.6 – Disabling a game object—in this case, the postprocessing volume
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 – 禁用游戏对象—在这种情况下是后期处理体积
- en: Enable (if it is not already enabled) the **RectTrasform** tool, which is the
    fifth button in the top-left part of the Unity Editor (or press the *T* key).
    That will enable the rectangle gizmo, which allows you to move, rotate, and scale
    two-dimensional elements. You can use the usual transform, rotate, and scale gizmos,
    which were the ones we used in 3D mode, but the rectangle gizmo causes less trouble,
    especially with scaling:![Figure 11.7 – The rectangle gizmo button
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用（如果尚未启用）**RectTrasform**工具，这是Unity编辑器左上部的第五个按钮（或按*T*键）。这将启用矩形标尺，允许您移动、旋转和缩放二维元素。您可以使用通常的变换、旋转和缩放标尺，这些是我们在3D模式下使用的标尺，但矩形标尺会带来更少的麻烦，特别是在缩放方面:![图11.7
    – 矩形标尺按钮
- en: '](img/Figure_11.07_B14199.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.07_B14199.jpg)'
- en: Figure 11.7 – The rectangle gizmo button
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 矩形标尺按钮
- en: Using the rectangle gizmo, drag the object to move it, use the blue dots to
    change its size, or locate the mouse in a tricky position near the blue dots to
    rotate it. Consider that resizing the object using this gizmo is not the same
    as scaling the object, but more on that in a moment:![Figure 11.8 – The rectangle
    gizmo for editing two-dimensional elements
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用矩形标尺，拖动对象以移动它，使用蓝点改变其大小，或者将鼠标放在靠近蓝点的棘手位置以旋转它。请注意，使用这个标尺调整对象的大小并不等同于缩放对象，但稍后会详细介绍:![图11.8
    – 用于编辑二维元素的矩形标尺
- en: '](img/Figure_11.08_B14199.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.08_B14199.jpg)'
- en: Figure 11.8 – The rectangle gizmo for editing two-dimensional elements
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 用于编辑二维元素的矩形标尺
- en: 'In the Inspector window, notice that after changing the size of the UI element,
    the `1`, `1`, `1`), but you can see how the **Width** and **Height** properties
    changed. **Rect Transform** is essentially a classic transform but with **Width**
    and **Height** added (among other properties to explore later). You can set the
    exact values you want here expressed in pixels:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在检视器窗口中，注意在更改UI元素的大小后，`1`，`1`，`1`），但是您可以看到**宽度**和**高度**属性已经改变。**Rect Transform**本质上是一个经典的变换，但增加了**宽度**和**高度**（以及其他稍后要探索的属性）。您可以在这里设置以像素表示的确切值:'
- en: '![Figure 11.9 – The Rect Transform properties'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.9 – 矩形变换属性'
- en: '](img/Figure_11.09_B14199.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.09_B14199.jpg)'
- en: Figure 11.9 – The Rect Transform properties
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – 矩形变换属性
- en: Now that we know the very basics of how to position any UI object, let's explore
    the different types of elements you can add to Canvas.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何定位任何UI对象的基础知识，让我们来探索可以添加到画布中的不同类型的元素。
- en: Canvas objects types
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 画布对象类型
- en: So far, we have used the simplest Canvas object type—a white box—but there are
    plenty of other object types we can use, such as images, buttons, text, and much
    more. All of them use **RectTransform** to define their display area, but each
    one has its own concepts and configurations to understand.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了最简单的画布对象类型—白色框，但是还有很多其他对象类型可以使用，比如图像、按钮、文本等等。它们都使用**RectTransform**来定义它们的显示区域，但每种对象都有自己的概念和配置需要理解。
- en: 'In this section, we will explore the following Canvas object concepts:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索以下画布对象的概念：
- en: Integrating assets for the UI
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成UI资产
- en: Creating UI controls
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建UI控件
- en: Let's first start exploring how we can integrate images and fonts to use in
    our canvas so that we can integrate them in our UI using the Images and Text UI
    object types.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先开始探索如何集成图像和字体，以便在画布中使用它们，这样我们就可以使用图像和文本UI对象类型将它们集成到我们的UI中。
- en: Integrating assets for the UI
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成UI资产
- en: 'Before making our UI use nice graphics assets, we need, as always, to integrate
    them properly into Unity. In the following screenshot, you will find the UI design
    we proposed in [*Chapter 1*](B14199_01_Final_SK_ePub.xhtml#_idTextAnchor015),
    *Designing a Game From Scratch*:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '在使我们的UI使用漂亮的图形资产之前，我们需要像往常一样将它们正确地集成到Unity中。在下面的截图中，您将找到我们在[*第1章*](B14199_01_Final_SK_ePub.xhtml#_idTextAnchor015)中提出的UI设计，*从头开始设计游戏*:'
- en: '![Figure 11.10 – Chapter 1''s UI design'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.10 – 第1章的UI设计'
- en: '](img/Figure_11.10_B14199.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.10_B14199.jpg)'
- en: Figure 11.10 – Chapter 1's UI design
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – 第1章的UI设计
- en: 'On top of that, we will add a Pause menu, which will be activated when the
    user presses *Esc*. It will look as in the following screenshot:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们还将添加一个暂停菜单，当用户按下*Esc*键时将被激活。它将如下截图所示：
- en: '![Figure 11.11 – The Pause menu design'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.11 – 暂停菜单设计'
- en: '](img/Figure_11.11_B14199.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.11_B14199.jpg)'
- en: Figure 11.11 – The Pause menu design
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – 暂停菜单设计
- en: 'Based on these designs, we can determine that we will need the following assets:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些设计，我们可以确定我们将需要以下资产：
- en: The hero's avatar image
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 英雄的头像图像
- en: A health bar image
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命值条图像
- en: A Pause menu background image
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停菜单背景图像
- en: A Pause menu buttons image
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停菜单按钮图像
- en: Font for the text
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本的字体
- en: 'As always, we can find the required assets on the internet or on Asset Store.
    In my case, I will use a mixture of both. Let''s start with the simplest one—the
    avatar. Take the following steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '像往常一样，我们可以在互联网上或者资产商店上找到所需的资产。在我的情况下，我会混合使用两者。让我们从最简单的一个开始—头像。采取以下步骤:'
- en: Download the avatar you want from the internet:![Figure 11.12 – Downloaded avatar
    asset
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从互联网上下载你想要的头像:![图11.12 – 下载的头像资产
- en: '](img/Figure_11.12_B14199.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.12_B14199.jpg)'
- en: Figure 11.12 – Downloaded avatar asset
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.12 – 下载的头像资产
- en: Add it into your project, either by dragging it to the Project window or by
    using the `Sprites` folder.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其添加到你的项目中，可以通过将其拖放到项目窗口中，或者使用`Sprites`文件夹。
- en: Select the texture and in the Inspector window, set the **Texture Type** setting
    to **Sprite (2D and UI)**. All textures are prepared to be used in 3D by default.
    This option prepares everything to be used in 2D.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择纹理，在检视器窗口中，将**纹理类型**设置为**精灵（2D和UI）**。所有纹理默认都准备用于3D。此选项准备好所有用于2D的内容。
- en: 'For the bars, buttons, and the window background, I will use Asset Store to
    look for a UI pack. In my case, I found the package in the following screenshot
    a good one to start my UI. As usual, remember that this exact package might not
    be available right now. In that case remember to look for another similar package,
    or pick the Sprites from the GitHub repo:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于条形、按钮和窗口背景，我将使用资产商店寻找UI包。在我的情况下，我发现以下截图中的包是一个很好的开始我的UI。通常情况下，请记住这个确切的包现在可能不可用。在这种情况下，请记住寻找另一个类似的包，或者从GitHub存储库中选择精灵：
- en: '![Figure 11.13 – Selected UI pack'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.13 - 选择的UI包'
- en: '](img/Figure_11.13_B14199.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.13_B14199.jpg)'
- en: Figure 11.13 – Selected UI pack
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13 - 选择的UI包
- en: 'At first, the pack contains lots of images configured the same way, as sprites,
    but we can further modify the import settings to achieve advanced behavior, as
    we will need for the buttons. The button asset comes with a fixed size, but what
    happens if you need a bigger button? One option is to use other button assets
    with different sizes, but this will lead to a lot of repetitions of the buttons
    and other assets, such as different-sized backgrounds for different windows, which
    will consume unnecessary RAM. Another option is to use the nine slices method,
    which consists of splitting an image so that the corners are separated from the
    other parts. This allows Unity to stretch the middle parts of the image to fit
    different sizes, keeping the corners at their original size, which, when combined
    with a clever image, can be used to create almost any size you need. In the following
    diagram, you can see a shape with nine slices in the bottom-left corner, and at
    the bottom-right corner of the same diagram, you can see the shape is stretched
    but keeps its corners at their original size. The top-right corner shows the shape
    stretched without slices. You can see that the non-sliced version is distorted,
    while the sliced version is not:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，包含许多以精灵形式配置的图像，但我们可以进一步修改导入设置以实现高级行为，这是我们在按钮中需要的。按钮资产具有固定大小，但如果需要更大的按钮怎么办？一种选择是使用不同尺寸的其他按钮资产，但这将导致大量重复的按钮和其他资产，例如不同大小的背景用于不同的窗口，这将消耗不必要的RAM。另一种选择是使用九片方法，这种方法包括将图像分割，使角落与其他部分分离。这允许Unity拉伸图像的中间部分以适应不同的大小，保持角落的原始大小，当与巧妙的图像结合时，可以用来创建几乎任何所需的大小。在下图中，您可以看到左下角有九片的形状，在同一图中的右下角，您可以看到形状被拉伸但保持其角落的原始大小。右上角显示了拉伸的形状没有片。您可以看到非切片版本被扭曲，而切片版本没有被扭曲：
- en: '![Figure 11.14 – Sliced versus non-sliced image stretching'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.14 - 切片与非切片图像拉伸'
- en: '](img/Figure_11.14_B14199.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.14_B14199.jpg)'
- en: Figure 11.14 – Sliced versus non-sliced image stretching
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.14 - 切片与非切片图像拉伸
- en: 'In this case, we can apply the nine-slices to the button and the panel background
    images to use them in different parts of our game. In order to do this, do the
    following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以将九片应用于按钮和面板背景图像，以在游戏的不同部分使用它们。为了做到这一点，请执行以下操作：
- en: Open Package Manager using the **Window** | **Package Manager** option.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**窗口** | **包管理器**选项打开包管理器。
- en: Verify that `Unity Registry`:![Figure 11.15 – Showing all packages in Package
    Manager
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`Unity Registry`：![图11.15 - 包管理器中显示所有包
- en: '](img/Figure_11.15_B14199.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.15_B14199.jpg)'
- en: Figure 11.15 – Showing all packages in Package Manager
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15 - 包管理器中显示所有包
- en: Install the **2D Sprite** package to enable the sprite editing tools (if it
    is not already installed):![Figure 11.16 – The 2D Sprite package in Package Manager
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装**2D Sprite**包以启用精灵编辑工具（如果尚未安装）：![图11.16 - 包管理器中的2D Sprite包
- en: '](img/Figure_11.16_B14199.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.16_B14199.jpg)'
- en: Figure 11.16 – The 2D Sprite package in Package Manager
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16 - 包管理器中的2D Sprite包
- en: Select the button sprite in the **Project** window and click on the **Sprite
    Editor** button in the **Inspector** window:![Figure 11.17 – The Sprite Editor
    button in the Inspector window
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中选择按钮精灵，然后单击**检查器**窗口中的**精灵编辑器**按钮：![图11.17 - 检查器窗口中的精灵编辑器按钮
- en: '](img/Figure_11.17_B14199.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.17_B14199.jpg)'
- en: Figure 11.17 – The Sprite Editor button in the Inspector window
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17 - 检查器窗口中的精灵编辑器按钮
- en: In the **Sprite Editor** window, locate and drag the green dots at the edges
    of the image to move the slice rulers. Try to ensure that the slices are not located
    in the middle of the edges of the button. One thing to notice is that in our case,
    we will work with three slices instead of nine because our button won't be stretched
    vertically.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**精灵编辑器**窗口中，找到并拖动图像边缘的绿点以移动切片标尺。尝试确保切片不位于按钮边缘的中间。需要注意的一件事是，在我们的情况下，我们将使用三个切片而不是九个，因为我们的按钮不会在垂直方向上拉伸。
- en: Click on the **Apply** button in the top-right corner of the window and close
    it:![Figure 11.18 – Nine slices in the Sprite Editor window
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击窗口右上角的**应用**按钮，然后关闭它：![图11.18 - 精灵编辑器窗口中的九片
- en: '](img/Figure_11.18_B14199.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.18_B14199.jpg)'
- en: Figure 11.18 – Nine slices in the Sprite Editor window
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18 - 精灵编辑器窗口中的九片
- en: 'Repeat the same steps for the **Background** panel. In my case, you can see
    in the following screenshot that this background is not prepared with nine slices
    in mind because all the middle areas of the image can be made smaller, and if
    the nine-slicing method is used to stretch them, they will look the same. So,
    we can edit it with any image editing tool or just work with it as it is for now:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对**背景**面板重复相同的步骤。在我的情况下，您可以在以下截图中看到，这个背景并没有考虑到九片，因为图像的所有中间区域都可以变小，如果使用九片方法来拉伸它们，它们看起来会一样。因此，我们可以使用任何图像编辑工具对其进行编辑，或者暂时使用它：
- en: '![Figure 11.19 – Nine slices in the Sprite Editor window'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.19 - 精灵编辑器窗口中的九片'
- en: '](img/Figure_11.19_B14199.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.19_B14199.jpg)'
- en: Figure 11.19 – Nine slices in the Sprite Editor window
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.19 - 精灵编辑器窗口中的九片
- en: 'Now that we have prepared our sprites, we can find a font, which is a pretty
    easy task. Just download any font in the `.ttf` or `.otf` formats and import it
    to Unity, and that''s all—no further configuration required. You can find lots
    of good, free font websites on the internet. I am used to working with the classic
    [DaFont.com](http://DaFont.com) site, but there''s plenty of other sites that
    you can use. In my case, I will work with the following font:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好我们的精灵，我们可以找到一个字体，这是一个非常简单的任务。只需下载任何`.ttf`或`.otf`格式的字体并将其导入Unity，就可以了，无需进一步配置。您可以在互联网上找到许多好的免费字体网站。我习惯于使用经典的[DaFont.com](http://DaFont.com)网站，但还有很多其他网站可以使用。在我的情况下，我将使用以下字体：
- en: '![Figure 11.20 – My chosen font from DaFont.com to use in the project'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.20 - 我从DaFont.com选择的用于项目的字体'
- en: '](img/Figure_11.20_B14199.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.20_B14199.jpg)'
- en: Figure 11.20 – My chosen font from DaFont.com to use in the project
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.20 - 我从DaFont.com选择的用于项目的字体
- en: If the zipped file contains several font files, you can just drag them all into
    Unity and then use the one that you like the most. Also, as usual, try to put
    the font inside a folder called `Fonts`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果压缩文件包含多个字体文件，您可以将它们全部拖入Unity，然后使用您最喜欢的字体。同样，尝试将字体放在名为“字体”的文件夹中。
- en: Now that we have all the required assets to create our UI, let's explore the
    different types of components to create all the required UI elements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好创建UI所需的所有资产，让我们探索不同类型的组件以创建所有所需的UI元素。
- en: Creating UI controls
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建UI控件
- en: 'Almost every single part of the UI will be a combination of images and texts
    configured cleverly. In this section, we will explore the following components:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎UI的每个部分都将是巧妙配置的图像和文本的组合。在本节中，我们将探索以下组件：
- en: '`Image`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`图像`'
- en: '`Text`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`文本`'
- en: '`Button`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`按钮`'
- en: 'Let''s start exploring **Image**. Actually, we have already an image in our
    UI—the white rectangle we created previously in this chapter. If you select it
    and look at the Inspector window, you will notice that it has an Image component,
    like the one in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索**图像**。实际上，我们的UI中已经有一个图像 - 我们在本章前面创建的白色矩形。如果选择它并查看检查器窗口，您会注意到它有一个图像组件，就像以下截图中的一个：
- en: '![Figure 11.21 – The Image component''s Inspector window'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.21 - 图像组件的检查器窗口'
- en: '](img/Figure_11.21_B14199.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.21_B14199.jpg)'
- en: Figure 11.21 – The Image component's Inspector window
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.21 - 图像组件的检查器窗口
- en: 'Let''s start exploring the different settings of this component, starting with
    our hero''s avatar. Take the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始探索该组件的不同设置，从我们的英雄头像开始。采取以下步骤：
- en: Using the rectangle gizmo, locate the white rectangle at the top-left part of
    the UI:![Figure 11.22 – The white rectangle located at the top-left part of the
    UI
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用矩形图标，将白色矩形定位在UI的左上角：![图11.22 - 位于UI左上角的白色矩形
- en: '](img/Figure_11.22_B14199.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.22_B14199.jpg)'
- en: Figure 11.22 – The white rectangle located at the top-left part of the UI
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.22 - 位于UI左上角的白色矩形
- en: In the `Source Image` property and pick the downloaded hero avatar sprite:![Figure
    11.23 – Setting the sprite of our Image component
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“源图像”属性中选择并拾取下载的英雄头像精灵：![图11.23 - 设置我们的图像组件的精灵
- en: '](img/Figure_11.23_B14199.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.23_B14199.jpg)'
- en: Figure 11.23 – Setting the sprite of our Image component
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.23 - 设置我们的图像组件的精灵
- en: 'We need to correct the aspect ratio of the image to prevent distortion. One
    way to do this is to click the `Image` component to make the image use the same
    size as the original sprite. However, by doing this, the image can become too
    big, so you can reduce the image size by pressing *Shift* to modify both the `Width`
    and `Height` values. Another option is to check the **Preserve Aspect** checkbox
    to make sure the image fits the rectangle without stretching. In my case, I will
    use both:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要校正图像的纵横比以防止失真。做到这一点的一种方法是单击“图像”组件，使图像使用与原始精灵相同的大小。但是，通过这样做，图像可能会变得太大，因此您可以按*Shift*减小图像大小以修改“宽度”和“高度”值。另一种选择是选中“保持纵横比”复选框，以确保图像适合矩形而不会拉伸。在我的情况下，我将两者都使用：
- en: '![Figure 11.24 – The Preserve Aspect and Set Native Size image options'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.24 - 保持纵横比和设置原生大小图像选项'
- en: '](img/Figure_11.24_B14199.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.24_B14199.jpg)'
- en: Figure 11.24 – The Preserve Aspect and Set Native Size image options
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.24 - 保持纵横比和设置原生大小图像选项
- en: 'Now, let''s create the life bars by doing the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下步骤创建生命条：
- en: Create another `Image` component using the **GameObject** | **UI** | **Image**
    option.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“GameObject”|“UI”|“图像”选项创建另一个“图像”组件。
- en: Set the `Source Image` property to the life bar image you downloaded:![Figure
    11.25 – The avatar and life bar
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“源图像”属性设置为您下载的生命条图像：![图11.25 - 头像和生命条
- en: '](img/Figure_11.25_B14199.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.25_B14199.jpg)'
- en: Figure 11.25 – The avatar and life bar
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.25 - 头像和生命条
- en: Set the **Image Type** property to **Filled**.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“图像类型”属性设置为“填充”。
- en: Set the **Fill Method** property to **Horizontal**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“填充方法”属性设置为“水平”。
- en: Drag the `Fill Amount` slider to see how the bar is cut according to the value
    of the slider. We will change that value via scripting when we code the life system
    in *Part 3* of the book, where we will be code out own scripts:![Figure 11.26
    – The Fill Amount slider, cutting the image width by 73% of its size
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动“填充量”滑块，查看根据滑块值切割条的方式。当我们在书的第3部分编写生命系统时，我们将通过脚本更改该值，那里我们将编写自己的脚本：![图11.26
    - 填充量滑块，将图像宽度切割为其大小的73%
- en: '](img/Figure_11.26_B14199.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.26_B14199.jpg)'
- en: Figure 11.26 – The Fill Amount slider, cutting the image width by 73% of its
    size
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.26 - 填充量滑块，将图像宽度切割为其大小的73%
- en: In my case, the bar image also comes with a bar frame, so I will create another
    image, set the sprite, and position it on top of the life bar to frame it. Bear
    in mind that the order the objects are in in the **Hierarchy** window determines
    the order in which they will be drawn. So, in my case, I need to be sure the frame
    GameObject is below the health bar image:![Figure 11.27 – Putting one image on
    top of the other to create a frame effect
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我的情况下，条图像也带有条框，因此我将创建另一个图像，设置精灵，并将其定位在生命条顶部以形成框架。请记住，**层次结构**窗口中对象的顺序决定了它们绘制的顺序。因此，在我的情况下，我需要确保框架游戏对象在生命条图像下方：![图11.27
    – 将一个图像放在另一个图像上创建框架效果
- en: '](img/Figure_11.27_B14199.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.27_B14199.jpg)'
- en: Figure 11.27 – Putting one image on top of the other to create a frame effect
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.27 – 将一个图像放在另一个图像上创建框架效果
- en: Repeat steps *1 to 6* to create the base bar at the bottom, or just copy and
    paste the bar and the frame and locate it at the bottom of the screen:![Figure
    11.28 – Two bars
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤1至6，创建底部的基本条，或者只需复制并粘贴条和框架，并将其定位在屏幕底部：![图11.28 – 两个条
- en: '](img/Figure_11.28_B14199.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.28_B14199.jpg)'
- en: Figure 11.28 – Two bars
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.28 – 两个条
- en: Click on the **+** button in the **Project** window and select the **Sprites**
    | **Square** option. This will create a simple squared sprite. This is the same
    as downloading a *4 x 4* resolution full-white image and importing it into Unity.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中单击“+”按钮，然后选择**Sprites** | **Square**选项。这将创建一个简单的方形精灵。这与下载一个*4 x 4*分辨率的全白图像并将其导入Unity相同。
- en: Set the sprite as the base bar instead of the downloaded bar sprite. This time,
    we will be using a plain-white image for the bar because in my case, the original
    one is red, and changing the color of a red image to green is not possible. However,
    a white image can be easily tinted. Take into account the detail of the original
    bar—for example, the little shadow in my original bar won't be present here, but
    if you want to preserve it, you should get a white bar with that detail.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将精灵设置为基本条，而不是下载的条精灵。这一次，我们将使用一个纯白色的图像作为条的背景，因为在我的情况下，原始图像是红色的，将红色图像改为绿色是不可能的。然而，白色图像可以很容易地着色。考虑原始条的细节，例如，我的原始条中的小阴影在这里不会出现，但如果您想保留它，您应该获得一个带有该细节的白色条。
- en: Select the base health bar and set the **Color** property to green:![Figure
    11.29 – A bar with a squared sprite and green tint
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择基本生命条并将“颜色”属性设置为绿色：![图11.29 – 带有方形精灵和绿色色调的条
- en: '](img/Figure_11.29_B14199.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.29_B14199.jpg)'
- en: Figure 11.29 – A bar with a squared sprite and green tint
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.29 – 带有方形精灵和绿色色调的条
- en: One optional step would be to convert the bar frame image into a nine-slices
    image to allow us to change the original width to fit the screen.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个可选的步骤是将条框图像转换为九切片图像，以便我们可以更改原始宽度以适应屏幕。
- en: 'Now, let''s add the text fields for the Score, Bullets, Remaining Waves, and
    Remaining Enemies labels by doing the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下方式为得分、子弹、剩余波数和剩余敌人标签添加文本字段：
- en: Create a text label using the **GameObject** | **UI** | **Text** option. This
    will be the Score label.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**GameObject** | **UI** | **Text**选项创建一个文本标签。这将是得分标签。
- en: Position the label at the top-right part of the screen.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标签定位在屏幕的右上角。
- en: 'In the `Score: 0`.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“得分：0”中。
- en: Set the `20`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置为“20”。
- en: Apply the downloaded font by clicking on the circle to the right of the **Font**
    property and selecting the desired font.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过单击**Font**属性右侧的圆圈并选择所需的字体来应用下载的字体。
- en: Check the horizontal alignment option (the one on the far right) for the **Alignment**
    property and the central option for the vertical options:![Figure 11.30 – The
    settings for a text label
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查“对齐”属性的水平对齐选项（最右边的选项）和垂直选项的中心选项：![图11.30 – 文本标签的设置
- en: '](img/Figure_11.30_B14199.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.30_B14199.jpg)'
- en: Figure 11.30 – The settings for a text label
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.30 – 文本标签的设置
- en: Repeat *steps 1 to 6* to create the other three labels (or just copy and paste
    the score three times). For the **Remaining Waves** label, you can use the left
    alignment option to better match the original design:![Figure 11.31 – All the
    labels for our UI
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤1至6，创建其他三个标签（或者只需将得分复制并粘贴三次）。对于“剩余波数”标签，您可以使用左对齐选项来更好地匹配原始设计：![图11.31 –
    我们UI的所有标签
- en: '](img/Figure_11.31_B14199.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.31_B14199.jpg)'
- en: Figure 11.31 – All the labels for our UI
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.31 – 我们UI的所有标签
- en: Set the color of all the labels to white as our scene will be mainly dark.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有标签的颜色设置为白色，因为我们的场景主要是黑暗的。
- en: 'Now that we have completed the original UI design, let''s create the Pause
    menu by doing the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了原始的UI设计，让我们通过以下方式创建暂停菜单：
- en: Create an `Image` component for the menu's background (**GameObject** | **UI**
    | **Image**).
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为菜单的背景创建一个“图像”组件（**GameObject** | **UI** | **Image**）。
- en: Set the **Background** panel sprite with the nine slices we made earlier.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们之前制作的九切片设置**Background**面板精灵。
- en: Set the **Image Type** property to **Sliced** if it is not already. This mode
    will apply the nine-slices method to prevent the corners from stretching.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未这样做，请将“图像类型”属性设置为“切片”。此模式将应用九切片方法以防止角落拉伸。
- en: There's a chance that the image will stretch the corners anyway, which happens
    because sometimes the corners are quite big compared to the `Pixels Per Unit`
    value of the sprite, which will reduce the scale of the original image while preserving
    its resolution.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有可能图像会在任何情况下拉伸角落，这是因为有时角落相对于精灵的“每单位像素”值来说相当大，这将减小原始图像的比例，同时保留其分辨率。
- en: 'In the following two screenshots, you can see the background image with a `Pixels
    Per` Unit value of `100` and again with `700`. Remember to only do this for the
    nine-slices or tiled-image types, or if you don''t have an artist to adjust it
    for you:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个屏幕截图中，您可以看到背景图像的“每单位像素”值为“100”，然后再次为“700”。请记住，只有对于九切片或平铺图像类型，或者如果您没有艺术家为您调整它时，才能这样做：
- en: '![Figure 11.32 – On top, a large nine-slices image in a small RectTransform
    component, small enough to shrink the corners, on the bottom, the same image with
    Pixels Per Unit set to 700'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.32 - 顶部是一个小的RectTransform组件中的大九宫格图像，足够小以缩小角落，底部是将每单位像素设置为700的相同图像'
- en: '](img/Figure_11.32_B14199.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.32_B14199.jpg)'
- en: Figure 11.32 – On top, a large nine-slices image in a small RectTransform component,
    small enough to shrink the corners, on the bottom, the same image with Pixels
    Per Unit set to 700
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.32 - 顶部是一个小的RectTransform组件中的大九宫格图像，足够小以缩小角落，底部是将每单位像素设置为700的相同图像
- en: Create a `Text` field, position it where you want the Pause label to be in your
    diagram, set it to display the Pause text, and set the font. Remember that you
    can change the text color with the `Color` property.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`文本`字段，将其放置在您的图表中想要暂停标签的位置，将其设置为显示暂停文本，并设置字体。请记住，您可以使用`Color`属性更改文本颜色。
- en: Drag the text field onto the background image. The parenting system in **Canvas**
    works the same—if you move the parent, the children will move with it. The idea
    is that if we disable the panel, it will also disable the buttons and all its
    content:![Figure 11.33 – The Pause label
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本字段拖放到背景图像上。**Canvas**中的父子关系系统工作原理相同 - 如果移动父级，则子级将随之移动。这样做的想法是，如果我们禁用面板，它也将禁用按钮和所有其内容：![图11.33
    - 暂停标签
- en: '](img/Figure_11.33_B14199.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.33_B14199.jpg)'
- en: Figure 11.33 – The Pause label
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.33 - 暂停标签
- en: Create two Buttons by going to **GameObject** | **UI** | **Button**. Position
    them where you want them on the background image.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**GameObject** | **UI** | **Button**来创建两个按钮。将它们放置在背景图像上的所需位置。
- en: Set them as children of the **Pause** background image by dragging them in the
    **Hierarchy** window.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将它们在**层次结构**窗口中拖动到**暂停**背景图像中，将它们设置为**暂停**背景图像的子级。
- en: Select the buttons and set the `Source Image` property of their Image components
    to use the button sprite that we downloaded earlier. Remember our **Pixels Per
    Unit** fix from earlier if you have the same problem as before.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择按钮，并将它们的图像组件的`Source Image`属性设置为我们之前下载的按钮精灵。如果您遇到与之前相同的问题，请记住我们之前的**每单位像素**修复。
- en: You will notice that the button is essentially an image with a child Text object.
    Change the text of both buttons to `Resume` and `Quit`, respectively:![Figure
    11.34 – The Pause menu implementation
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会注意到按钮本质上是一个带有子文本对象的图像。将两个按钮的文本分别更改为`恢复`和`退出`：![图11.34 - 暂停菜单实现
- en: '](img/Figure_11.34_B14199.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.34_B14199.jpg)'
- en: Figure 11.34 – The Pause menu implementation
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.34 - 暂停菜单实现
- en: 'Remember that you can hide the panel by unchecking the checkbox to the right
    of the name of the object in the top part of the **Inspector** window:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，您可以通过取消顶部**检查器**窗口对象名称右侧复选框旁边的复选框来隐藏面板：
- en: '![Figure 11.35 – Disabling a GameObject'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.35 - 禁用游戏对象'
- en: '](img/Figure_11.35_B14199.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.35_B14199.jpg)'
- en: Figure 11.35 – Disabling a GameObject
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.35 - 禁用游戏对象
- en: As you can see, you can create almost any kind of UI just by using Image and
    Text components. Of course, there are more advanced components that enable you
    to create buttons, text fields, checkboxes, lists, and so on, but let's stick
    to the basics one. One thing to notice is that we have created buttons, but they
    do nothing so far. Later, in *Part 3* of the book, we will see how to script them
    to have a function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，您可以通过使用图像和文本组件来创建几乎任何类型的UI。当然，还有更高级的组件可以让您创建按钮、文本字段、复选框、列表等，但让我们先从基础知识开始。需要注意的一点是，我们已经创建了按钮，但到目前为止它们什么也没做。在本书的*第3部分*中，我们将看到如何编写脚本使它们具有功能。
- en: In this section, we discussed how to import images and fonts to be integrated
    through the Image, Text, and Button components to create a rich and informative
    UI. Having done that, let's discuss how to make them adapt to different devices.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何导入图像和字体，通过图像、文本和按钮组件进行集成，以创建丰富和信息丰富的UI。做到这一点后，让我们讨论如何使它们适应不同的设备。
- en: Creating a responsive UI
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建响应式UI
- en: Nowadays, it is almost impossible to design a UI in a single resolution, and
    our target audience display devices can vary a lot. A PC has a variety of different
    kinds of monitors with different resolutions (such as 1080p, 4k, and so on) and
    aspect ratios (such as 16:9, 16:10, ultra-wide, and so one), and the same goes
    for mobile devices. We need to prepare our UI to adapt to the most common displays,
    and Unity UI has the tools needed to do so.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，几乎不可能在单一分辨率下设计UI，我们的目标受众显示设备可能差异很大。PC具有各种不同分辨率的显示器（如1080p、4k等）和不同的宽高比（如16:9、16:10、超宽等），移动设备也是如此。我们需要准备我们的UI以适应最常见的显示器，Unity
    UI具有所需的工具来实现这一点。
- en: 'In this section, we will explore the following UI responsiveness concepts:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨以下UI响应性概念：
- en: Adapting objects' positions
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整对象的位置
- en: Adapting objects' sizes
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整对象的大小
- en: We are going to explore how the UI elements can adapt their position and size
    to different screen sizes using advanced features of the Canvas and **RectTransform**
    components, such as Anchors and Scalers.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何使用Canvas和**RectTransform**组件的高级功能（如锚点和缩放器）使UI元素能够适应不同的屏幕尺寸和位置。
- en: Adapting objects' positions
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整对象的位置
- en: 'Right now, if we play our game, we will see how the UI fits nicely onto our
    screen. But if for some reason we change the **Game** view size, we will see how
    objects start to disappear from the screen. In the following screenshots, you
    can see different sized game windows and how the UI looks nice in one but bad
    in the others:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们玩我们的游戏，我们会看到UI如何很好地适应我们的屏幕。但是，如果由于某种原因我们改变了**游戏**视图大小，我们会看到对象开始从屏幕上消失。在以下截图中，您可以看到不同大小的游戏窗口以及UI在一个窗口中看起来很好，但在其他窗口中看起来很糟糕：
- en: '![Figure 11.36 – The same UI but on different screen sizes'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.36 - 相同的UI但在不同的屏幕尺寸上'
- en: '](img/Figure_11.36_B14199.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.36_B14199.jpg)'
- en: Figure 11.36 – The same UI but on different screen sizes
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.36 - 相同的UI但在不同的屏幕尺寸上
- en: 'The problem is that we created the UI using whatever resolution we had in the
    editor, but as soon as we change it slightly, the UI keeps its design for the
    previous resolution. Also, if you look closely, you will notice that the UI is
    always centered, such as in the middle image, where the UI is cropped at its sides,
    or the third image, where extra space is visible along the borders of the screen.
    This happens because every single element in the UI has its own Anchor, a little
    cross you can see when you select an object, such as the one in the following
    screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们使用编辑器中的任何分辨率创建了UI，但一旦我们稍微改变它，UI就会保留先前分辨率的设计。此外，如果你仔细观察，你会注意到UI总是居中，比如在中间的图像中，UI在两侧被裁剪，或者第三个图像中，屏幕边缘可见额外空间。这是因为UI中的每个元素都有自己的锚点，当你选择一个对象时，你可以看到一个小交叉点，就像下面的截图中所示：
- en: '![Figure 11.37 – An Anchor cross at the bottom-right part of the screen belonging'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.37 - 位于屏幕右下部分的锚点交叉属于'
- en: to the hero avatar in the top-left part of the screen
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到屏幕的左上部分的英雄角色
- en: '](img/Figure_11.37_B14199.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.37_B14199.jpg)'
- en: Figure 11.37 – An Anchor cross at the bottom-right part of the screen belonging
    to the hero avatar in the top-left part of the screen
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.37 - 位于屏幕右下部分的英雄角色的锚点交叉
- en: The X and Y position of the object is measured as a distance to that Anchor,
    and the Anchor has a position relative to the screen, with its default position
    being at the center of the screen. This means that on an 800 x 600 screen, the
    Anchor will be placed at the 400 x 300 position, and on a 1920 x 1080 screen,
    the Anchor will be located at the 960 x 540 position. If the X and Y position
    of the element (the one in RectTransform) is 0, the object will always be at a
    distance of 0 from the center. In the middle screenshot of the previous three
    examples, the hero avatar falls outside of the screen because its distance from
    the center is greater than half the screen, and the current distance was calculated
    based on the previous, bigger screen size. So, what we can do about that? Move
    the Anchor!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的X和Y位置是相对于该锚点的距离，而锚点相对于屏幕有一个位置，其默认位置是在屏幕的中心。这意味着在800 x 600的屏幕上，锚点将放置在400 x
    300的位置，在1920 x 1080的屏幕上，锚点将位于960 x 540的位置。如果元素（RectTransform中的元素）的X和Y位置为0，则对象将始终与中心的距离为0。在前三个示例的中间截图中，英雄角色超出了屏幕，因为它与中心的距离大于屏幕的一半，并且当前距离是基于先前更大的屏幕尺寸计算的。那么，我们能做些什么呢？移动锚点！
- en: 'By setting a relative position, we can position the Anchor at different parts
    of our screen and make that part of the screen our reference position. In the
    case of our hero avatar, we can place the Anchor at the top-left corner of the
    screen to guarantee that our avatar will be at a fixed distance from that corner.
    We can do that by doing the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置相对位置，我们可以将锚点放在屏幕的不同部分，并使屏幕的该部分成为我们的参考位置。对于我们的英雄角色，我们可以将锚点放在屏幕的左上角，以确保我们的角色与该角落的距离固定。我们可以通过以下方式实现：
- en: Select your hero avatar.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的英雄角色。
- en: Drag the Anchor cross with your mouse to the top-left part of the screen. If
    for some reason the Anchor breaks into pieces when you drag it, undo the change
    (press *Ctrl* + *Z*, or *Command* + *Z* on macOS) and try to drag it by clicking
    in the center. We will break the Anchor later:![Figure 11.38 – An image with an
    Anchor at the top-left part of the screen
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用鼠标将锚点交叉拖动到屏幕的左上角。如果由于某种原因，当你拖动它时锚点会分裂成几部分，撤消更改（按*Ctrl* + *Z*，或者在macOS上按*Command*
    + *Z*）并尝试通过点击中心来拖动它。我们稍后会打破锚点：![图11.38 - 一个带有锚点的图像，位于屏幕的左上角
- en: '](img/Figure_11.38_B14199.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.38_B14199.jpg)'
- en: Figure 11.38 – An image with an Anchor at the top-left part of the screen
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.38 - 一个带有锚点的图像，位于屏幕的左上角
- en: Put the Anchor of the **Health Bar** object and its frame in the same position.
    We want the bar to always be at the same distance from that corner so that it
    will move alongside the hero avatar if the screen size changes.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**生命条**对象和其框架的锚点放在同一位置。我们希望该条始终与该角落保持相同的距离，以便在屏幕大小改变时，它将随着英雄角色一起移动。
- en: For the **Boss Bar** object, place the Anchor at the bottom-center part of the
    screen so that it will always be centered. Later, we will deal with adjusting
    its size.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**Boss Bar**对象，将锚点放在屏幕底部中心位置，这样它将始终居中。稍后，我们将调整其大小。
- en: Put the **Remaining Waves** label at the bottom-left corner and **Remaining
    Enemies** in the bottom-right corner:![Figure 11.39 – The Anchors for the life
    bar and the labels
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**剩余波数**标签放在左下角，**剩余敌人**放在右下角：![图11.39 - 生命条和标签的锚点
- en: '](img/Figure_11.39_B14199.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.39_B14199.jpg)'
- en: Figure 11.39 – The Anchors for the life bar and the labels
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.39 - 生命条和标签的锚点
- en: Put the **Score** and **Bullets** Anchors at the top-right corner:![Figure 11.40
    – The Anchors for the Score and Bullets labels
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**得分**和**子弹**锚点放在右上角：![图11.40 - 得分和子弹标签的锚点
- en: '](img/Figure_11.40_B14199.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.40_B14199.jpg)'
- en: Figure 11.40 – The Anchors for the Score and Bullets labels
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.40 - 得分和子弹标签的锚点
- en: 'Select any element and drag the sides of the Canvas rectangle with your mouse
    to preview how the elements will adapt to their positions. Take into account that
    you must select any object that is a direct child of Canvas; the text within the
    buttons won''t have that option:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何元素，并用鼠标拖动Canvas矩形的边缘，以预览元素将如何适应它们的位置。请注意，你必须选择Canvas的直接子对象；按钮内的文本将没有这个选项：
- en: '![Figure 11.41 – Previewing canvas resizing'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.41 - 预览画布调整大小'
- en: '](img/Figure_11.41_B14199.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.41_B14199.jpg)'
- en: Figure 11.41 – Previewing canvas resizing
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.41 - 预览画布调整大小
- en: Now that our UI elements have adapted to their positions, let's consider scenarios
    where the object size must adapt as well.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的UI元素已经适应了它们的位置，让我们考虑对象大小必须适应的情况。
- en: Adapting objects' sizes
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整对象的大小
- en: The first thing to consider when dealing with different aspect ratios is that
    our screen elements may not only move from their original design position (which
    we fixed in the previous section) but also they may not fit into the original
    design. In our UI, we have the case of the health bar, where the bar clearly doesn't
    adapt to the screen width when we previewed it on a wider screen. We can fix this
    by breaking our Anchors.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 处理不同宽高比的第一件事是，我们的屏幕元素可能不仅会从它们的原始设计位置移动（我们在上一节中固定了），而且它们可能不适合原始设计。在我们的UI中，我们有生命条的情况，当我们在更宽的屏幕上预览时，条明显不适应屏幕宽度。我们可以通过打破我们的锚点来解决这个问题。
- en: 'When we break our Anchors, the position and size of our object are calculated
    as a distance relative to the different Anchor parts. If we split the Anchor horizontally,
    instead of having an X and Width property, we will have a Left and Right property,
    representing the distance to the left and right Anchor. We can use this in the
    following way:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打破我们的锚点时，对象的位置和大小被计算为相对于不同锚点部分的距离。如果我们水平分割锚点，我们将有左和右属性，而不是X和宽度属性，它们代表到左和右锚点的距离。我们可以这样使用：
- en: Select the health bar and drag the left part of the anchor all the way to the
    left part of the screen, and the right part to the right part of the screen.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择生命条，将锚点的左部分拖到屏幕的左部分，右部分拖到屏幕的右部分。
- en: Do the same for the health bar frame:![Figure 11.42 – The splitter Anchor in
    the health bar
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于生命条框架也是一样的：![图11.42 - 生命条中的分隔锚点
- en: '](img/Figure_11.42_B14199.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.42_B14199.jpg)'
- en: Figure 11.42 – The splitter Anchor in the health bar
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.42 - 生命条中的分隔锚点
- en: 'Check the **Rect Transform** setting''s **Left** and **Right** properties in
    the Inspector window, which represent the current distance to their respective
    Anchors. If you want, you can add a specific value, especially if your health
    bars are displaying outside the screen:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检视器窗口中检查**Rect Transform**设置的**左**和**右**属性，它们代表当前到各自锚点的距离。如果你愿意，你可以添加一个特定的值，特别是如果你的生命条显示在屏幕外：
- en: '![Figure 11.43 – The Left and Right properties of a split anchor'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.43 - 分隔锚点的左右属性'
- en: '](img/Figure_11.43_B14199.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.43_B14199.jpg)'
- en: Figure 11.43 – The Left and Right properties of a split anchor
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.43 - 分隔锚点的左右属性
- en: 'This way, the object will always be at a fixed distance of a relative position
    to the screen—in this case, the sides of the screen. If you are working with a
    child object, as is the case of the Text and Image components of the buttons,
    the Anchors are relative to the parent. If you pay attention to the Anchors of
    the text, they are not only split horizontally but also vertically. This allows
    the text to adapt its position to the size of the button, so you won''t have to
    change it manually:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，对象将始终保持相对于屏幕的固定距离，即屏幕的两侧。如果你正在处理一个子对象，比如按钮的文本和图像组件，锚点是相对于父对象的。如果你注意到文本的锚点，它们不仅在水平方向上分割，而且在垂直方向上也分割。这允许文本根据按钮的大小调整位置，这样你就不必手动更改它：
- en: '![Figure 11.44 – The split Anchors of the text of the button'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.44 - 按钮文本的分隔锚点'
- en: '](img/Figure_11.44_B14199.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.44_B14199.jpg)'
- en: Figure 11.44 – The split Anchors of the text of the button
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.44 - 按钮文本的分隔锚点
- en: Now, this solution is not suitable for all scenarios. Let's consider a case
    where the hero avatar is displayed in higher resolution than what it was designed
    for. Even if the avatar is correctly placed, it will be displayed smaller because
    the screen has more pixels per inch that the other resolution. You consider using
    split Anchors, but the width and height Anchors could be scaled differently in
    different aspect ratio screens, so the original image becomes distorted. Instead,
    we can use the Canvas Scaler component.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这种解决方案并不适用于所有情况。让我们考虑一个情况，英雄头像显示的分辨率比它设计的要高。即使头像被正确放置，它也会显示得更小，因为屏幕的像素密度比其他分辨率更高。你可以考虑使用分隔锚点，但是在不同宽高比的屏幕上，宽度和高度锚点可能会以不同的比例进行缩放，所以原始图像会变形。相反，我们可以使用画布缩放器组件。
- en: The Canvas Scaler component defines what 1 pixel means in our scenario. If our
    UI design resolution is 1080p, but we see it in a 4k display (which is twice the
    resolution of 1080p), we can scale the UI so that a pixel becomes 2, adapting
    its size to keep the same proportional size as the original design. Basically,
    the idea is that if the screen is bigger, our elements should also be bigger.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 画布缩放器组件定义了在我们的场景中1像素的含义。如果我们的UI设计分辨率是1080p，但我们在4k显示器上看到它（这是1080p分辨率的两倍），我们可以缩放UI，使得一个像素变为2，调整其大小以保持与原始设计相同的比例大小。基本上，这个想法是，如果屏幕更大，我们的元素也应该更大。
- en: 'We can use this component by doing the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式使用这个组件：
- en: Select the **Canvas** object and locate the **Canvas Scaler** component in the
    **Inspector** window.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Canvas**对象，并在**检视器**窗口中找到**Canvas Scaler**组件。
- en: Set the **UI Scale Mode** property to **Scale with Screen Size**.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**UI Scale Mode**属性设置为**Scale with Screen Size**。
- en: This isn't the case for us, but if in the future you are working with an artist,
    set the reference resolution to the resolution in which the artist created the
    UI, keeping in mind that it must be the highest target device resolution. In our
    case, we are not sure which resolution the artist of the downloaded assets had
    in mind, so we can put `1920 x 1080`, which is the full HD resolution size and
    is very common nowadays.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这对我们来说并不是问题，但是如果将来你和一个艺术家合作，将参考分辨率设置为艺术家创建UI的分辨率，记住它必须是最高目标设备分辨率。在我们的情况下，我们不确定下载资产的艺术家有没有考虑过分辨率，所以我们可以设置为`1920
    x 1080`，这是全高清分辨率大小，现在非常常见。
- en: 'Set the `Width` value in this case because we can have extreme widths in screens,
    such as ultra-wide, and if we picked that option, those screens would scale the
    UI unnecessarily. Another option is to set this value to `0.5` to consider the
    two values, but on a PC, this doesn''t make too much sense. On a mobile device,
    you should choose this based on the orientation of the game, setting the height
    for landscape mode and the width for portrait mode. Try previewing a wider and
    higher screen and see how this setting works:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下设置“宽度”值，因为屏幕的宽度可能会非常宽，比如超宽屏，如果我们选择了那个选项，那些屏幕会不必要地缩放UI。另一个选项是将此值设置为“0.5”以考虑这两个值，但在PC上，这并没有太多意义。在移动设备上，您应该根据游戏的方向选择这个值，为横向模式设置高度，为纵向模式设置宽度。尝试预览更宽和更高的屏幕，看看这个设置是如何工作的：
- en: '![Figure 11.45 – Canvas Scaler with the correct settings for standard PC games'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.45 - 带有标准PC游戏正确设置的画布缩放器'
- en: '](img/Figure_11.45_B14199.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.45_B14199.jpg)'
- en: Figure 11.45 – Canvas Scaler with the correct settings for standard PC games
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.45 - 带有标准PC游戏正确设置的画布缩放器
- en: You will find that your UI will be smaller than your original design, which
    is because we should have set these properties before. Right now, the only fix
    is to resize everything again. Take this into account the next time you try this
    exercise; we only followed this order for learning purposes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现您的UI比原始设计要小，这是因为我们应该在之前设置这些属性。现在，唯一的解决办法是重新调整大小。下次尝试这个练习时要考虑到这一点；我们只是按照这个顺序进行学习。
- en: Before moving on, remember to reactivate the postprocessing volume object to
    show those effects again. You will notice that the UI is not affected by them
    in the Game view.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请记得重新激活后期处理体积对象以再次显示这些效果。您会注意到UI在游戏视图中不受它们的影响。
- en: 'Important note:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: If you want your UI to be affected by postprocessing effects, you can set `–
    Camera`. Drag the main camera to the `Render Camera` property and set `Plane Distance`
    to `5`. This will put the UI in the world with the rest of the objects, aligned
    to the camera view with a distance of 5 meters.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望您的UI受到后期处理效果的影响，您可以设置为“-相机”。将主摄像机拖动到“渲染相机”属性，并将“平面距离”设置为“5”。这将使UI与其他对象一起放置在世界中，与相机视图对齐，距离为5米。
- en: '![Figure 11.46 – Canvas Render Mode set to Camera mode to receive postprocessing
    effects'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.46 - 画布渲染模式设置为相机模式以接收后期处理效果'
- en: '](img/Figure_11.46_B14199.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.46_B14199.jpg)'
- en: Figure 11.46 – Canvas Render Mode set to Camera mode to receive postprocessing
    effects
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.46 - 画布渲染模式设置为相机模式以接收后期处理效果
- en: With this knowledge, you are now ready to start creating your firsts UIs by
    yourself.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，现在您已经准备好开始自己创建您的第一个UI了。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the basics of UI, understanding the `Image` and
    `Text`, to give life to our UI layout and make it appealing to the user. Finally,
    we discussed how to adapt UI objects to different resolutions and aspect ratios
    to make our UI adapt to different screen sizes, even though we cannot predict
    the exact monitor our user will be playing the game on.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了UI的基础知识，理解了“图像”和“文本”，为我们的UI布局赋予生命，并使其对用户具有吸引力。最后，我们讨论了如何使UI对象适应不同的分辨率和宽高比，使我们的UI适应不同的屏幕尺寸，即使我们无法预测用户将在哪种显示器上玩游戏。
- en: In the next chapter, we will start seeing how to add animated characters to
    our game.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始看如何向我们的游戏中添加动画角色。
