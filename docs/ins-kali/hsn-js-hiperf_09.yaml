- en: Practical Example - Building a Static Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际示例 - 构建静态服务器
- en: We have looked at Node.js and what it has to offer in the past few chapters.
    While we have not gone over every module or everything that Node.js has to offer,
    we have all the pieces to put together a static content/generator site. This means
    that we will set up a server to listen for requests and build pages off of that
    request.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们已经了解了Node.js及其提供的功能。虽然我们没有涵盖每个模块或Node.js提供的所有内容，但我们已经有了所有的要素来构建一个静态内容/生成器站点。这意味着我们将设置一个服务器来监听请求，并根据该请求构建页面。
- en: 'To implement this server, we will need to understand how site generation works,
    and how we might implement this as an on-the-fly operation. On top of this, we
    will look at caching so that we do not have to recompile every single time a page
    is requested. Overall, in this chapter, we will look at and implement the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个服务器，我们需要了解站点生成的工作原理，以及如何将其作为即时操作实现。除此之外，我们还将研究缓存，以便我们不必在每次请求页面时重新编译。总的来说，在本章中，我们将查看并实现以下内容：
- en: Understanding static content
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解静态内容
- en: Setting up our server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的服务器
- en: Adding caching and clustering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加缓存和集群
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A text editor or **integrated development environment** (**IDE**), preferably
    VS Code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本编辑器或**集成开发环境**（**IDE**），最好是VS Code
- en: An operating system that supports Node.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持Node.js的操作系统
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter09/microserve](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter09/microserve).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下网址找到：[https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter09/microserve](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter09/microserve)。
- en: Understanding static content
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解静态内容
- en: 'Static content means exactly that: content that does not change. This can be
    HTML pages, JavaScript, images, and so on. Anything that does not need to run
    through a database or some external system for processing can be considered as
    static content.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 静态内容就是不变的内容。这可以是HTML页面、JavaScript、图像等。任何不需要通过数据库或某些外部系统进行处理的内容都可以被视为静态内容。
- en: While we will not be implementing a static content server directly, we will
    be implementing an on-the-fly static content generator. For those that do not
    know, a static content generator is a system that builds the static content and
    then serves that content up. The content is usually built by some type of templating
    system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会直接实现静态内容服务器，但我们将实现一个即时静态内容生成器。对于不了解的人来说，静态内容生成器是一个构建静态内容然后提供该内容的系统。内容通常由某种模板系统构建。
- en: Some common templating systems that are out there include Mustache, Handlebars.js,
    and Jade. These template engines look for some sort of tags and replace the content
    based on some variables. While we will not be looking at any of these templating
    engines directly, know that they are out there and that they can be quite useful
    for things such as code documentation generation, or even creating JavaScript
    files based off of some API specification.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的模板系统包括Mustache、Handlebars.js和Jade。这些模板引擎寻找某种标记，并根据一些变量替换内容。虽然我们不会直接查看这些模板引擎，但要知道它们存在，并且它们对于诸如代码文档生成或甚至根据某些API规范创建JavaScript文件等方面非常有用。
- en: 'Instead of using one of these common formats, we will implement our own version
    of a templating system to see how templating works. We will try to keep it as
    simple as possible since we want to use a minimal amount of dependencies for our
    server. The one dependency that we will be utilizing is a Markdown to HTML converter
    called `Remarkable`: [https://github.com/jonschlinkert/remarkable](https://github.com/jonschlinkert/remarkable).
    It depends on two libraries and each of those depends on one library, so we will
    be importing a total of five libraries.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现自己的模板系统版本，而不是使用其中一个常见格式，以了解模板的工作原理。我们将尽量保持简单，因为我们希望为我们的服务器使用最少的依赖项。我们将使用一个名为`Remarkable`的Markdown到HTML转换器作为依赖项：[https://github.com/jonschlinkert/remarkable](https://github.com/jonschlinkert/remarkable)。它依赖于两个库，每个库又依赖于一个库，因此我们将导入总共五个库。
- en: While creating all of the pages on-the-fly will allow us to make changes quite
    easily, we would not want to keep doing this unless we were in a development environment.
    To make sure that we do not keep building the HTML files over and over again,
    we will implement an in-memory cache to store the files that have been requested
    the most.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然即时创建所有页面将使我们能够轻松进行更改，但除非我们处于开发环境中，否则我们不希望一直这样做。为了确保我们不一遍又一遍地构建HTML文件，我们将实现一个内存缓存来存储被请求最多的文件。
- en: With all of this, let's go ahead and get started with building out our application,
    by setting up our server and getting a response sent out.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，让我们继续开始构建我们的应用程序，通过设置我们的服务器并发送响应。
- en: Starting our application
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动我们的应用程序
- en: 'First, let''s go ahead and set up our project by creating our `package.json`
    file in a folder of our choosing. We can start with the following basic `package.json`
    file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过在我们选择的文件夹中创建我们的`package.json`文件来设置我们的项目。我们可以从以下基本的`package.json`文件开始：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should be fairly straightforward now. The main thing is that the type
    is set to `module` so we can utilize modules inside of Node.js. Next, let''s go
    ahead and add the `Remarkable` dependency by running `npm install remarkable`
    inside the folder in which we put our `package.json` file. With that, we should
    now have `remarkable` listed as a dependency in our `package.json` file. Next,
    let''s go ahead and get our server set up. To do so, create a `main.js` file and
    do the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该相当简单了。主要的是将类型设置为`module`，这样我们就可以在Node.js中使用模块。接下来，让我们继续通过在放置`package.json`文件的文件夹中运行`npm
    install remarkable`来添加`Remarkable`依赖项。有了这个，我们现在应该在我们的`package.json`文件中列出`remarkable`作为一个依赖项。接下来，让我们继续设置我们的服务器。为此，创建一个`main.js`文件并执行以下操作：
- en: 'Import the `http2` and `fs` modules, since we will use them to start our server
    and read our private key and certificate files, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`http2`和`fs`模块，因为我们将使用它们来启动我们的服务器和读取我们的私钥和证书文件，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create our server and read in our key and certificate files. We will generate
    these after setting up our main file, like this:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的服务器并读取我们的密钥和证书文件。我们将在设置主文件后生成这些文件，就像这样：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Respond to the error event by just crashing our server (we should probably
    handle this better, but for now, this will work). We will also handle an incoming
    request by just responding with a simple message and a status of `200` (which
    means all good), like this:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过崩溃我们的服务器来响应错误事件（我们可能应该更好地处理这个问题，但现在这样做就可以了）。我们还将通过简单的消息和状态码`200`（表示一切正常）来处理传入的请求，就像这样：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, we will start listening in on port `50000` (a random port number can
    be used here).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将开始监听端口`50000`（这里可以使用一个随机端口号）。
- en: 'Now, if we do try to run this, we should be greeted by a nasty error message
    similar to the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试运行这个，我们应该会被类似以下的一个令人讨厌的错误消息所打招呼：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have not generated our self-signed private key and certificate yet. Remember
    from [Chapter 6](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml), *Message Passing
    – Learning about the Different Types*, that we cannot serve any content over an
    unsecured channel (HTTP); instead, we have to utilize HTTPS. To do this, we need
    to either get a certificate from a certificate authority or we need to generate
    one ourselves. From [Chapter 6](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml), *Message
    Passing – Learning about the Different Types*, we should have the `openssl` application
    installed on our computers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有生成自签名的私钥和证书。请记住从[第6章](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml)中了解到，我们不能在不安全的通道（HTTP）上提供任何内容；相反，我们必须使用HTTPS。为此，我们需要从证书颁发机构获取证书，或者我们需要自己生成一个。从[第6章](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml)中了解到，我们应该在我们的计算机上安装`openssl`应用程序。
- en: 'Let''s go ahead and generate that by running the following command and just
    pressing *Enter* through the Command Prompts:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续通过运行以下命令来生成它，并只需通过命令提示符按*Enter*：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We should now have both of those files in our current directory, and now, if
    we try running our application, we should have a server listening on port `50000`.
    We can check this by going to the following address: `127.0.0.1:50000`. If everything
    worked correctly, we should see the message A okay!'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该在当前目录中有这两个文件，现在，如果我们尝试运行我们的应用程序，我们应该有一个在端口`50000`上监听的服务器。我们可以通过访问以下地址来检查：`127.0.0.1:50000`。如果一切正常，我们应该看到消息A
    okay！
- en: 'While having variables such as the port, private key, and certificate hardcoded
    is okay for development purposes, we should still move these to our `package.json`
    file so another user could make the changes to them in a single place, instead
    of having to go into the code and make the changes. Let''s go ahead and make these
    changes right now. Inside of our `package.json` file, let''s add the following
    fields:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然像端口、私钥和证书这样的变量在开发过程中硬编码是可以的，但我们仍然应该将它们移到我们的`package.json`文件中，这样另一个用户可以在一个地方进行更改，而不是必须进入代码并进行更改。让我们继续进行这些更改。在我们的`package.json`文件中，让我们添加以下字段：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `config` section will allow us to pass in various variables that we will
    let the user of the package set, either with the `package.json` `config` section,
    or when running our file by using the `npm config set tinyserve:<variable>` command.
    The `scripts` section, as we saw from [Chapter 5](6c403493-7028-408c-9da6-b6650ad6bfcb.xhtml),
    *Switching Contexts – No DOM, Different Vanilla*, allows us access to these variables
    and allows the user of our package to now just use `npm start`, instead of using
    `node --experimental-modules main.js`. With this, we can change our `main.js`
    file by declaring all of these variables near the top of our file, like so:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`config`部分将允许我们传递各种变量，让包的用户使用`package.json`的`config`部分设置，或者在运行我们的文件时使用`npm
    config set tinyserve:<variable>`命令设置。正如我们从[第5章](6c403493-7028-408c-9da6-b6650ad6bfcb.xhtml)中看到的，`scripts`部分允许我们访问这些变量，并允许我们的包的用户现在只需使用`npm
    start`，而不是使用`node --experimental-modules main.js`。有了这个，我们可以通过在我们的`main.js`文件中声明所有这些变量来改变我们的`main.js`文件，就像这样：'
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All of the configuration variables can be found on our `process.env` variable,
    so we declare a shortcut to it at the top of our file. We can then get access
    to the various variables, as we have seen in [Chapter 5](6c403493-7028-408c-9da6-b6650ad6bfcb.xhtml),
    *Switching Contexts – No DOM, Different Vanilla*. We also set defaults, just in
    case the user does not run our file using the `npm start` script that we declared.
    Users will also notice that we have declared a few extra variables. These are
    variables that we will talk about later, but they deal with where we hyperlink
    to and whether we want to enable the caching or not (the development variable).
    Next, we will take a look at how we will access the templating system that we
    want to set up.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有配置变量都可以在我们的`process.env`变量中找到，因此我们在文件顶部声明了一个快捷方式。 然后，我们可以访问各种变量，就像我们在[第5章](6c403493-7028-408c-9da6-b6650ad6bfcb.xhtml)中看到的那样，*切换上下文-没有DOM，不同的Vanilla*。
    我们还设置了默认值，以防用户没有使用我们声明的`npm start`脚本运行我们的文件。 用户还会注意到我们声明了一些额外的变量。 这些是我们稍后会讨论的变量，但它们涉及到我们要超链接到的位置以及我们是否要启用缓存（开发变量）。
    接下来，我们将看一下我们将如何访问我们想要设置的模板系统。
- en: Setting up our templating system
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的模板系统
- en: We are going to use Markdown for the various content we want to host, but there
    are going to be certain sections of our files that we will want to use across
    all of the articles. These will be things such as the header, footer, and the
    sidebar of our pages. Instead of having to have these inserted into all of the
    Markdown files that we will create for our articles, we can template these in.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Markdown来托管我们想要托管的各种内容，但我们将希望在所有文章中使用某些部分。 这些将是我们页面的页眉、页脚和侧边栏等内容。 我们可以将这些内容模板化，而不必将它们插入到我们为文章创建的所有Markdown文件中。
- en: 'We will put these sections in a folder that will be known at runtime, by using
    the `templateDirectory` variable that we declared. This will also allow users
    of our package to change out the look and feel of our static site server without
    having to do anything too crazy. Let''s go ahead and create the directory structure
    for the template section. This should look like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些部分放在一个在运行时将被知道的文件夹中，通过我们声明的`templateDirectory`变量。 这也将允许我们包的用户更改我们的静态站点服务器的外观和感觉，而无需做任何太疯狂的事情。
    让我们继续创建模板部分的目录结构。 这应该看起来像下面这样：
- en: '**Template**: Where we should look for the static content across all pages'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：我们应该在所有页面中查找静态内容'
- en: '**HTML**: Where all of our static HTML code will go'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML**：我们所有静态HTML代码将放在这里'
- en: '**CSS**: Where our stylesheets will live'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CSS**：我们的样式表将存放在这里'
- en: 'With this directory structure, we can now create some basic header, footer,
    and sidebar HTML files, and also some basic **Cascading Style Sheets** (**CSS**),
    to get a page structure that should be familiar to everyone. So, let''s begin,
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个目录结构，我们现在可以创建一些基本的页眉、页脚和侧边栏HTML文件，以及一些基本的**层叠样式表**（**CSS**），以获得一个对每个人都应该熟悉的页面结构。
    所以，让我们开始，如下所示：
- en: 'We will write the `header` HTML, like so:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将编写`header` HTML，如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this basic structure, we have the name of our website, and then a couple
    of links that most blog sites will have.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个基本结构，我们有了网站的名称，然后是大多数博客网站都会有的一些链接。
- en: 'Next, let''s create the `footer` section, like this:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`footer`部分，就像这样：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, fairly self-explanatory. Finally, we will create the sidebar, as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，相当容易理解。 最后，我们将创建侧边栏，如下所示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is where our templating engine comes into play. First, we are going to
    use `<% %>` character pattern to denote that we want to replace this with some
    static content. Next, `loop <number>` will let our templating engine know that
    we plan on looping through the next piece of content a certain amount of times
    before stopping the engine. Finally, the `<a href="article/${location}">${name}</a>`
    pattern will tell our templating engine that this is the content we want to put
    in, but we will want to replace the `${}` tags with variables in an object that
    we pass in our code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的模板引擎发挥作用的地方。 首先，我们将使用`<% %>`字符模式来表示我们要用一些静态内容替换它。 接下来，`loop <number>`将让我们的模板引擎知道我们计划在停止引擎之前循环一定次数的下一个内容。
    最后，`<a href="article/${location}">${name}</a>`模式将告诉我们的模板引擎这是我们要放入的内容，但我们将要用我们在代码中传递的对象中的变量替换`${}`标签。
- en: 'Next, let''s go ahead and create the basic CSS for our page, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续创建我们页面的基本CSS，如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Most of the CSS file has been cut since a majority of it is boilerplate code.
    The only piece that is worth mentioning is the custom variables. With CSS, we
    can declare our own custom variables by using the pattern `--<name> : <content>`,
    and then we can use it later in the CSS file by using the `var()` declaration.
    This allows us to reuse variables such as colors and heights without having to
    use a preprocessor such as **Syntactically Awesome Style Sheets** (**SASS**).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '由于大部分是样板代码，CSS文件已经被剪切了。 值得一提的是自定义变量。 使用CSS，我们可以通过使用模式`--<name> : <content>`声明自定义变量，然后我们可以在CSS文件中使用`var()`声明来使用它。
    这使我们能够重用变量，如颜色和高度，而无需使用预处理器，如**SASS**。'
- en: CSS variables are scoped. This means if you define the variable for the `header`
    section, it will only be available in the `header` section. This is why we decided
    to put our colors at the `:root` pseudo element level since it will be available
    across our entire page. Just remember that CSS variables have scope similar to
    the `let` and `const` variables we declare in JavaScript.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: CSS变量是有作用域的。 这意味着如果您为`header`部分定义变量，它将仅在`header`部分中可用。 这就是为什么我们决定将我们的颜色放在`:root`伪元素级别，因为它将在整个页面中可用。
    只需记住，CSS变量的作用域类似于我们在JavaScript中声明的`let`和`const`变量。
- en: 'With our CSS laid out, we can now write our main HTML file in our `template`
    file. We will move this outside of the HTML folder since this is the main file
    that we will want in order to put everything together. It will also let users
    of our package know that this is the main file that we will use to put together
    all of the pieces and that if they want to change it up, they should do it here.
    For now, let''s create a `main.html` file that looks like the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的CSS布局，我们现在可以在我们的`template`文件中编写我们的主HTML文件。我们将把这个文件移到HTML文件夹之外，因为这是我们想要的主文件，以便把所有东西放在一起。这也会让我们的包的用户知道这是我们将用来组合所有部分的主文件，如果他们想要改变它，他们应该在这里做。现在，让我们创建一个看起来像下面这样的`main.html`文件：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The top section should look familiar, but we now have a new template type. The
    `from` directive lets us know that we are going to source this file from somewhere
    else. The next statement says it is an `HTML` file, so we will look inside the
    `HTML` folder. Finally, we see the name of the file, so we know that we want to
    bring in the `header.html` file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部部分应该看起来很熟悉，但是现在我们有了一个新的模板类型。`from`指令让我们知道我们将从其他地方获取这个文件。下一个语句表示它是一个`HTML`文件，所以我们将在`HTML`文件夹中查找。最后，我们看到文件的名称，所以我们知道我们要引入`header.html`文件。
- en: With all of this, we can now write the templating system that we are going to
    use to build our pages. We will be implementing our templating system utilizing
    a `Transform` stream. While we could utilize something like a `Writable` stream,
    it makes more sense to utilize a `Transform` stream since we are changing the
    output based on some input criteria.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些，我们现在可以编写我们将用来构建页面的模板系统。我们将利用`Transform`流来实现我们的模板系统。虽然我们可以利用类似`Writable`流的东西，但是利用`Transform`流更有意义，因为我们根据一些输入条件改变输出。
- en: 'To implement the `Transform` stream, we will need to keep track of a few things
    so, that way, we can process our keys correctly. First, let''s get us reading
    and sending off the proper chunks to be processed. We can do this by implementing
    the `transform` method and spitting out the chunks that we are going to replace.
    To do this, we will do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`Transform`流，我们需要跟踪一些东西，这样我们才能正确处理我们的键。首先，让我们读取并发送适当的块进行处理。我们可以通过实现`transform`方法并输出我们要替换的块来实现这一点。为此，我们将执行以下操作：
- en: 'We will extend a `Transform` stream and set up the basic structure, as we did
    in [Chapter 7](81cf1aa1-6ded-4d94-8686-e2bd65db6a8c.xhtml), *Streams – Understanding
    Streams and Non-Blocking I/O*. We will also create a custom class to hold the
    start and end locations of a buffer. This will allow us to know if we got the
    start of the pattern matcher in the same loop. We will need this later. We will
    also set up some private variables for our class, such as the `begin` and `end`
    template buffers, on top of state variables such as the `#pattern` variable, as
    follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将扩展一个`Transform`流并设置基本结构，就像我们在[第7章](81cf1aa1-6ded-4d94-8686-e2bd65db6a8c.xhtml)中所做的那样，*流-理解流和非阻塞I/O*。我们还将创建一个自定义类来保存缓冲区的开始和结束位置。这将允许我们知道我们是否在同一个循环中得到了模式匹配的开始。我们以后会需要这个。我们还将为我们的类设置一些私有变量，比如`begin`和`end`模板缓冲区，以及`#pattern`变量等状态变量，如下所示：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we will have to check if we have data held in our `#pattern` state variable.
    If we do not, then we know to look for the beginning of a template. Once we do
    the check for the beginning of a template statement, we can check to see if it
    is actually in this chunk of data. If it is, we set the `start` property of `#pair`
    to this location so our loop can keep going; otherwise, we have no template in
    this chunk and we can start to process the next chunk, as shown here:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将不得不检查我们的`#pattern`状态变量中是否保存了数据。如果没有，那么我们知道要寻找模板的开始。一旦我们检查到模板语句的开始，我们可以检查它是否实际上在这个数据块中。如果是，我们将`#pair`的`start`属性设置为这个位置，这样我们的循环就可以继续进行；否则，我们在这个块中没有模板，我们可以开始处理下一个块，如下所示：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To handle the other condition (we are looking for the end of a template), we
    have quite a bit more state to deal with. First, if our `#pair` variable''s `start`
    is not `-1` (we set it), we know we are still processing a current chunk. This
    means we need to check if we can find the `end` template buffer in the current
    chunk. If we do, then we can process the pattern and reset our `#pair` variable.
    Otherwise, we just push the current chunk from the `start` member location of
    `#pair` to our `#pattern` holder at the end of the chunk, as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要处理另一个条件（我们正在寻找模板的结尾），我们需要处理更多的状态。首先，如果我们的`#pair`变量的`start`不是`-1`（我们设置它），我们知道我们仍在处理当前的块。这意味着我们需要检查我们是否可以在当前块中找到`end`模板缓冲区。如果我们找到了，那么我们可以处理模式并重置我们的`#pair`变量。否则，我们只是将当前块从`#pair`的`start`成员位置推送到我们的`#pattern`持有者的块末端，如下所示：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, if `start` member of `#pair` is set, we check for the `end` template
    pattern. If we do not find it, we just push the entire chunk to the `#pattern`
    array. If we do find it, we slice the chunk from the beginning of it to where
    we found our `end` template string. We then concatenate all this together and
    process it. We will then also reset our `#pattern` variable back to holding nothing,
    like this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果`#pair`的`start`成员被设置，我们检查`end`模板模式。如果我们找不到它，我们只是将整个块推送到`#pattern`数组。如果我们找到它，我们就从它的开头切割块，直到我们找到我们的`end`模板字符串。然后我们将所有这些连接在一起并进行处理。然后我们还将我们的`#pattern`变量重置为什么都不持有，就像这样：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All of this will be wrapped in a `do`/`while` loop since we want to run this
    piece of code at least once, and we will know that we are finished when our `location`
    variable is `-1` (this is what is returned from an `indexOf` check when it does
    not find what we want). After the `do`/`while` loop, we run the callback to tell
    our stream that we are ready to process more data, as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些都将包装在一个`do`/`while`循环中，因为我们至少要运行这段代码一次，当我们的`location`变量是`-1`时，我们就知道我们已经完成了（这是从`indexOf`检查返回的，当它找不到我们想要的时）。在`do`/`while`循环之后，我们运行回调，告诉我们的流我们已经准备好处理更多数据，如下所示：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With all of this put together, we now have a `transform` loop that should handle
    almost all of the conditions to grab our templating system. We can test this by
    passing in our `main.html` file and putting the following code inside of our `processPattern`
    method, like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们现在有一个`transform`循环，应该处理几乎所有情况来获取我们的模板系统。我们可以通过将我们的`main.html`文件传递进去并将以下代码放入我们的`processPattern`方法中来测试这一点，就像这样：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can create a test script to run our `main.html` file through. Go ahead and
    create a `test.js` file and put the following code in it:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以创建一个测试脚本来运行我们的`main.html`文件。继续创建一个`test.js`文件，并将以下代码放入其中：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this, we should get a nice printout with the template syntax that we were
    looking for, such as `from html header`*.* If we ran our `sidebar.html` file through
    it, it should look something like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们应该得到一个漂亮的输出，其中包含我们正在寻找的模板语法，比如`from html header`*.* 如果我们通过`sidebar.html`文件运行它，它应该看起来像下面这样：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we know our `Transform` stream's template-finding code works, we just
    need to write our process chunk system to handle the preceding cases we have.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的`Transform`流的模板查找代码是有效的，我们只需要编写我们的处理块系统来处理我们之前的情况。
- en: 'To now process the chunks, we will need to know where to look for the files.
    Remember from before, when we declared various variables inside of our `package.json`
    file? Now, we will utilize the `templateDirectory` one. Let''s go ahead and pass
    that in as an argument for our stream, like so:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要处理这些块，我们需要知道在哪里查找文件。还记得之前我们在`package.json`文件中声明各种变量吗？现在，我们将利用`templateDirectory`。让我们将其作为流的参数传递进去，就像这样：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, when we call `processPattern`, we can pass in the chunk and the `template`
    directory as arguments. From here, we can now implement the `processPattern` method.
    We will handle two cases: when we find a `for` loop and when we find a `find`
    statement.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们调用`processPattern`时，我们可以将块和`template`目录作为参数传递。从这里，我们现在可以实现`processPattern`方法。我们将处理两种情况：当我们找到一个`for`循环和当我们找到一个`find`语句。
- en: 'To process a `for` loop and a `find` statement, we will proceed as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理`for`循环和`find`语句，我们将按以下步骤进行：
- en: 'We will build out an array of buffers that will be what the template held,
    other than the `for` loop. We can do this with the following code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将构建一个缓冲区数组，除了`for`循环之外，它将是模板保存的内容。我们可以使用以下代码来实现这一点：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We will look for the loop directive and then take the second argument, which
    should be a number. If we print this out, we will see that we have buffers that
    are all filled with the same exact data.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将查找循环指令，然后获取第二个参数，它应该是一个数字。如果我们打印出来，我们会看到我们有一堆填满相同数据的缓冲区。
- en: 'Next, we will need to make sure that we are filling in all of the templated
    string locations. These look like the pattern `${<name>}`. To do this, we will
    add another argument to this loop that will give the name of the variable we want
    to use. Let''s go ahead and add this to the `sidebar.html` file, as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保填写所有的模板字符串位置。这些看起来像`${<name>}`的模式。为此，我们将在这个循环中添加另一个参数，用于指定我们想要使用的变量的名称。让我们将其添加到`sidebar.html`文件中，如下所示：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With this, we should now pass in a list of variables that we are going to want
    to use for our templating system—in this case, one named `articles` that is an
    array of objects that have a `location` and `name` key. This could look like the
    following:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们现在应该传入一个我们想要在模板系统中使用的变量列表——在这种情况下，一个名为`articles`的数组，其中包含具有`location`和`name`键的对象。这可能看起来像下面这样：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With enough to satisfy our `for` loop condition, we can now head back to the
    `Transform` stream and add this as an item we will process in our constructor,
    and send it to our `processPattern` method. Once we have added these items here,
    we will update our loop case with the following code inside of the `for` loop:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 满足我们`for`循环条件的条件足够多，现在我们可以回到`Transform`流，并将其作为我们在构造函数中要处理的项目之一，并将其发送到我们的`processPattern`方法。一旦我们在这里添加了这些项目，我们将在`for`循环内更新我们的循环情况，使用以下代码：
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Our temporary string holds all of the data that we consider a template, and
    the `varName` variable tells us where to look in our object that we pass into
    `processPattern` to do our replacement strategy. Next, we will use a regular expression
    to pull out the name of the variable. This specific regular expression says to
    look for the `${<name>}` pattern while also saying to capture whatever is in the
    `<name>` section. This allows us to easily get to the name of the variable. We
    will also keep looping through the template to see if there are more regular expressions
    that pass these criteria. Finally, we will replace that templated code with the
    variable we have stored.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的临时字符串包含我们认为是模板的所有数据，而`varName`变量告诉我们在我们传递给`processPattern`的对象中查找的位置以执行我们的替换策略。接下来，我们将使用正则表达式提取变量的名称。这个特定的正则表达式表示查找`${<name>}`模式，同时也表示捕获`<name>`部分的内容。这样我们就可以轻松地获取变量的名称。我们还将继续循环遍历模板，看看是否有更多的正则表达式符合这些条件。最后，我们将用我们存储的变量替换模板代码。
- en: Once all of this is done, we will concatenate all of these buffers together
    and return all of them. That is a lot for that piece of code; luckily, the `from`
    section of our template is quite a bit easier to handle. The `from` section of
    our templating code will just look for a file with that name from our `templateDirectory`
    variable and will return the buffer form of it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些后，我们将所有这些缓冲区连接在一起并返回它们。这对于那段代码来说是很多的；幸运的是，我们的模板的`from`部分要容易处理得多。我们的模板代码的`from`部分只需从我们的`templateDirectory`变量中查找具有该名称的文件，并将其返回为缓冲形式。
- en: 'It should look something like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像下面这样：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We first grab the type of file from the second argument. If it is not an `HTML`
    or `CSS` file, we will reject it. Otherwise, we will try reading the file in and
    sending it to our stream.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从第二个参数中获取文件类型。如果不是`HTML`或`CSS`文件，我们将拒绝它。否则，我们将尝试读取文件并将其发送到我们的流中。
- en: Some of you may be wondering how we will handle the templating in the other
    files. Right now, if we run our system on the `main.html` file, we will get all
    the separate chunks, but our `sidebar.html` file is not filled out. This is one
    weakness of our templating system. One way around this is to create another function
    that will call our `Transform` stream a certain amount of times. This will make
    sure we get the templating done for these separate pieces. Let's go ahead and
    create that function right now.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的一些人可能会想知道我们将如何处理其他文件中的模板。现在，如果我们在`main.html`文件上运行我们的系统，我们将得到所有单独的块，但我们的`sidebar.html`文件没有填充。这是我们模板系统的一个弱点。解决这个问题的一种方法是创建另一个函数，它将调用我们的`Transform`流一定次数。这将确保我们为这些单独的部分完成模板。让我们现在就创建这个函数。
- en: 'This is not the only way to handle this. Instead, we could utilize another
    system: when we see template directives in a file, we add that buffer to the list
    of items needed for processing. This would allow our stream to process the directives
    instead of looping through the buffers again and again. This leads to its own
    problems since someone could write an infinitely recursing template and would
    cause our stream to break. Everything is a trade-off, and right now, we are going
    for ease of coding over ease of use.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是处理这个问题的唯一方法。相反，我们可以利用另一个系统：当我们在文件中看到模板指令时，我们将该缓冲区添加到需要处理的项目列表中。这将允许我们的流处理指令，而不是一遍又一遍地循环缓冲区。这会导致它自己的问题，因为有人可能会编写一个无限递归的模板，这将导致我们的流中断。一切都是一种权衡，现在，我们选择编码的简易性而不是使用的简易性。
- en: 'First, we will need to import the `once` function from the `events` module
    and the `PassThrough` stream from the `stream` module. Let''s update those dependencies
    now, like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从`events`模块中导入`once`函数和从`stream`模块中导入`PassThrough`流。让我们现在更新这些依赖关系，就像这样：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we will create a new `Transform` stream that will bring in the same information
    as before, but now, we will also add in a loop counter. We will also respond to
    the `transform` event and push it onto a private variable until we have read in
    the entire starting template, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的`Transform`流，它将带入与以前相同的信息，但现在，我们还将添加一个循环计数器。我们还将响应`transform`事件，并将其推送到一个私有变量，直到我们读取完整的起始模板为止，如下所示：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we will make our `flush` event `async` since we will utilize an async
    `for` loop, like so:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使我们的`flush`事件`async`，因为我们将利用一个异步`for`循环，就像这样：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Essentially, we will put all of the initial template data together. Then, we
    will run this data through our `TemplateBuilder`, building a new template for
    it to run over. We utilize the `await once(templateBuilder, ‘end')` system to
    let us treat this code synchronously. Once we have gone through the counter, we
    will spit out the data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们将把所有的初始模板数据放在一起。然后，我们将通过我们的`TemplateBuilder`运行这些数据，构建一个新的模板来运行。我们利用`await
    once(templateBuilder, ‘end')`系统让我们以同步的方式处理这段代码。一旦我们完成了计数，我们将输出数据。
- en: 'We can test this with our old test harness. Let''s go ahead and set it up to
    utilize our new `Transform` stream, along with spitting the data out to a file,
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用旧的测试工具来测试这一点。让我们继续设置它来利用我们的新的`Transform`流，并将数据输出到文件，如下所示：
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we now run this, we will notice that the `test.html` file holds our fully
    built-out `template` file! We now have a functioning template system we can use.
    Let's hook this up to our server.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行这个，我们会注意到`test.html`文件包含了我们完全构建的`template`文件！我们现在有一个可以使用的模板系统。让我们把它连接到我们的服务器上。
- en: Setting up our server
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的服务器
- en: 'With our templating system working, let''s go ahead and hook all of this up
    to our server. Instead of now responding with a simple message of A okay!, we
    will respond with our template all put together. We can do this easily by running
    the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的模板系统工作，让我们继续把所有这些连接到我们的服务器上。现在不再简单地回复“一切正常！”，而是用我们的模板回复。我们可以通过运行以下代码轻松实现这一点：
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This should look almost exactly like our test harness. If we now head to `https://localhost:50000`,
    we should see a very basic HTML page, but we have our templated file created!
    If we now head into the development tools and look at the sources, we will see
    something odd. The CSS states that we loaded in our `main.css` file, but the contents
    of the file look exactly like our HTML file!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该几乎和我们的测试工具一模一样。如果我们现在转到`https://localhost:50000`，我们应该会看到一个非常基本的HTML页面，但我们已经创建了我们的模板文件！如果我们现在进入开发工具并查看源代码，我们会看到一些奇怪的东西。CSS表明我们加载了我们的`main.css`文件，但文件的内容看起来和我们的HTML文件完全一样！
- en: 'Our server is responding to every request with our HTML file! What we need
    to do is some extra work so our server can respond to the requests correctly.
    We will do this by mapping the URL of the request to the files that we have. For
    simplicity''s sake, we will only respond to HTML and CSS requests (we will not
    be sending any JavaScript across), but this system can easily be added upon to
    add in return types for images, and even files. We will add all of this by doing
    the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器对每个请求都以我们的HTML文件进行响应！我们需要做的是一些额外的工作，让我们的服务器能够正确地响应请求。我们将通过将请求的URL映射到我们拥有的文件来实现这一点。为了简单起见，我们只会响应HTML和CSS请求（我们不会发送任何JavaScript），但是这个系统可以很容易地添加返回类型的图片，甚至文件。我们将通过以下方式添加所有这些：
- en: 'We will set up a lookup table for our file endings, like this:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为我们的文件结尾设置一个查找表，就像这样：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we will use this map to pull the files based off of `headers` of the
    request, like this:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用这个映射根据请求的`headers`来拉取文件，就像这样：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The basic idea is to loop through our supported file types to see if we have
    them. If we do, then we will respond with the file and also tell the browser whether
    it is an HTML or CSS file through the `content-type` header.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 基本思想是循环遍历我们支持的文件类型，看看我们是否有这些文件。如果有，我们将用文件进行响应，并通过`content-type`头告诉浏览器它是HTML文件还是CSS文件。
- en: 'Now, we need a way to tell if a request is bad or not. Currently, we can go
    to any URL and we will just get the same response over and over again. We will
    utilize a `publishedDirectory` environment variable for this. Based on the name
    of the files in there, those will be our endpoints. For every sub-URL pattern,
    we will look for subdirectories that follow the same pattern. This is illustrated
    as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一种方法来判断请求是否良好。目前，我们可以转到任何URL，我们将一遍又一遍地得到相同的响应。我们将利用`publishedDirectory`环境变量来实现这一点。根据其中的文件名，这些将是我们的端点。对于每个子URL模式，我们将寻找遵循相同模式的子目录。如下所示：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `.md` extension means that it is a Markdown file. This is how we will write
    out pages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`.md`扩展名表示它是一个Markdown文件。这就是我们将编写页面的方式。'
- en: 'For now, let''s get this mapping working. To do this, we will put the following
    code below our `for` loop:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们让这个映射工作。为此，我们将在我们的`for`循环下面放入以下代码：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We wrap our method for finding the file (`fs.statSync`) inside of a `try`/`catch`
    block. With this, if we error out, this will usually mean that we did not find
    the file, and we will send a `404` message to the user. Otherwise, we will just
    send what we have been sending: our example `template`. If we now run our server,
    we will be greeted with the following message: File Not Found! Turn Back!. We
    have nothing in that directory!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用`try`/`catch`块包装我们查找文件的方法(`fs.statSync`)。如果出现错误，这通常意味着我们没有找到文件，我们将向用户发送一个`404`消息。否则，我们将发送我们一直发送的内容：我们的示例`template`。如果我们现在运行服务器，我们将收到以下消息：文件未找到！回头吧！我们在那个目录中什么都没有！
- en: 'Let''s go ahead and create the directory, and add a file called `first.md`.
    If we add this directory and the file and rerun our server, we will still get
    the error message if we head to `https://localhost:50000/first`! We are getting
    this because we did not tack on the Markdown file extension when checking for
    the file! Let''s go ahead and add this to the `fs.statSync` check, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建目录，并添加一个名为`first.md`的文件。如果我们添加这个目录和文件并重新运行服务器，如果我们转到`https://localhost:50000/first`，我们仍然会收到错误消息！我们之所以会收到这个消息，是因为在检查文件时我们没有添加Markdown文件扩展名！让我们继续将其添加到`fs.statSync`检查中，如下所示：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, when we rerun our server, we will see the normal template that we had before.
    If we add content to the `first.md` file, we will not get that file. We now need
    to add this addition to our templating system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们重新运行服务器时，我们将看到以前的正常模板。如果我们向`first.md`文件添加内容，我们将得不到该文件。现在我们需要将此添加到我们的模板系统中。
- en: 'Remember at the start of the chapter we added the `npm` package `remarkable`?
    We will now add the Markdown renderer, `remarkable`, and a new keyword that our
    templating language will look for to render the Markdown, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在本章开头我们添加了`npm`包`remarkable`吗？现在我们将添加Markdown渲染器`remarkable`，以及我们的模板语言将寻找的新关键字，以渲染Markdown，如下所示：
- en: 'Let''s add `Remarkable` as an import to our `template.js` file, like this:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`Remarkable`作为一个导入添加到我们的`template.js`文件中，就像这样：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will look for the following directive to include that Markdown file into
    `<% file <filename> %>` template, like this:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将寻找以下指令来将Markdown文件包含到`<% file <filename> %>`模板中，就像这样：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will now need to add the `publishDir` variable to our `Transform` stream''s
    possible options in the constructor, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在构造函数中的`Transform`流的可能选项中添加`publishDir`变量，如下所示：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Remember**: Quite a bit of code has been removed from these examples to make
    them easier to read. For the full examples, head on over to the book''s code repository.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**记住**：为了使其更易于阅读，这些示例中删除了大量代码。要获取完整的示例，请转到本书的代码存储库。'
- en: 'Create a `LoopingStream` class that will loop and run the `TemplateBuilder`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`LoopingStream`类，它将循环并运行`TemplateBuilder`：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will need to update our template with the following templated line:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用以下模板化行更新我们的模板：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we need to pass in the `publish` directory to our stream from the
    server. We can do this with the following code addition:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将`publish`目录传递给服务器的流。我们可以通过以下代码进行此操作：
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With all of this, we should get something back from the server that is not
    just our base template. If we added some Markdown to the file, we should just
    see that Markdown with our template. We now need to make sure that this Markdown
    gets processed. Let''s head back to our transformation method and call the `Remarkable`
    method so that it processes the Markdown and gives us back HTML, as shown in the
    following code block:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些，我们应该从服务器那里得到一些不仅仅是我们的基本模板。如果我们向文件中添加了一些Markdown，我们应该只看到带有我们模板的Markdown。现在我们需要确保这个Markdown被处理。让我们回到我们的转换方法，并调用`Remarkable`方法，以便它处理Markdown并以HTML的形式返回给我们，如下面的代码块所示：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this change, we now have a generic Markdown parser that enables us to
    take our template files and send them back with our `main.html` file. The final
    change we will need to make in order to have a functioning templating system and
    static server is to make sure that instead of the `main.html` file having the
    exact template, it has the directive state that we want in order to put a file
    there and have our templating system put the file that is declared in our stream
    constructor. We can do this easily with the following changes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改变，我们现在有了一个通用的Markdown解析器，它使我们能够获取我们的模板文件，并将它们与我们的`main.html`文件一起发送。为了使模板系统和静态服务器正常运行，我们需要做的最后一个改变是，确保`main.html`文件不再具有精确的模板，而是具有我们想要的指令状态，以便在那里放置一个文件，并且我们的模板系统将放置在我们流构造函数中声明的文件。我们可以通过以下更改轻松实现这一点：
- en: 'In our `template.js` file, we will utilize a unique variable called `fileToProcess`.
    We get this the same way we get the variables that we want to process for the
    `sidebar.html` file, through the `vars` that we pass through. We will utilize
    the file we have in the second part of the `template` directive if we do not have
    the file from the `fileToProcess` variable, as shown in the following code block:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`template.js`文件中，我们将利用一个名为`fileToProcess`的独特变量。我们以与我们通过传递的`vars`获取`sidebar.html`文件要处理的变量相同的方式获取它。如果我们没有来自`fileToProcess`变量的文件，我们将利用我们在`template`指令的第二部分中拥有的文件，如下面的代码块所示：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will need to pass this variable from our server to the stream, like this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将这个变量从我们的服务器传递到流中，就像这样：
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The final change we will make is to change the `html` file, to have a new base
    Markdown file for pages that we do not have. This could allow us to have a base
    page for the root URL. We will not be implementing this, but this is a way for
    us to do that:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将进行的最后一个改变是改变`html`文件，为我们没有的页面创建一个新的基本Markdown文件。这可以让我们为根URL创建一个基本页面。我们不会实现这一点，但这是我们可以这样做的一种方式：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With this change, if we now run our server, we have a fully functioning templating
    system with Markdown support! This is an amazing achievement! However, we will
    need to add two features to our server so that it will be able to handle more
    requests and process the same requests quickly. These features are caching and
    clustering.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个改变，如果我们现在运行我们的服务器，我们就有了一个完全功能的模板系统，支持Markdown！这是一个了不起的成就！然而，我们需要向我们的服务器添加两个功能，以便它能够处理更多的请求并快速处理相同的请求。这些功能是缓存和集群。
- en: Adding caching and clustering
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加缓存和集群
- en: First, we will start by adding a cache to our server. We do not want to constantly
    recompile pages that we have already compiled before. To do this, we will implement
    a class that surrounds a map. This class will keep track of 10 files at a time.
    We will also implement the timestamp when the file was last used. When we reach
    the eleventh file, we will see that it is not in the cache and that we have hit
    the maximum number of files we can hold in the cache. We will replace the compiled
    page with the earliest timestamped file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过向我们的服务器添加缓存来开始。我们不希望不断重新编译我们以前已经编译过的页面。为此，我们将实现一个围绕地图的类。这个类将同时跟踪10个文件。我们还将实现文件上次使用的时间戳。当我们达到第十一个文件时，我们将看到它不在缓存中，并且我们已经达到了我们可以在缓存中保存的文件的最大数量。我们将用时间戳最早的文件替换编译后的页面。
- en: This is known as a **Least Recently Used** (**LRU**) cache. There are many other
    types of caching strategies out there, such as a **Time To Live** (**TTL**) cache.
    This type of cache will eliminate files that have been in the cache for too long.
    This is a great type of cache for when we keep using the same files over and over
    again, but we eventually want to free up space when the server has not been hit
    for a while. An LRU cache will always keep these files in place, even if the server
    has not been hit for hours. We could always implement both caching strategies,
    but we will just implement the LRU cache for now.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为**最近最少使用**（**LRU**）缓存。还有许多其他类型的缓存策略，比如**生存时间**（**TTL**）缓存。这种缓存类型将消除在缓存中时间过长的文件。这是一种很好的缓存类型，当我们一遍又一遍地使用相同的文件，但当服务器有一段时间没有被访问时，我们最终希望释放空间。LRU缓存将始终保留这些文件，即使服务器已经有好几个小时没有被访问。我们可以实现两种缓存策略，但现在我们只实现LRU缓存。
- en: 'First, we will create a new file called `cache.js`. Inside of here, we will
    do the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个名为`cache.js`的新文件。在这里，我们将执行以下操作：
- en: 'Create a new class. We don''t need to extend any other class since we are just
    writing a wrapper around the `Map` data structure built into JavaScript, as shown
    in the following code block:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类。我们不需要扩展任何其他类，因为我们只是在JavaScript内置的`Map`数据结构周围编写一个包装器，如下面的代码块所示：
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will then have a constructor that will take in the number of files that
    we want to store in the cache before we use our strategy to replace one of the
    files, like this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将有一个构造函数，它将接受我们想要在缓存中存储的文件数量，然后使用我们的策略来替换其中一个文件，就像这样：
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we will add the `add` operation to our cache. It will take in the buffer
    form of our page and the URL that we hit to get it. The key will be the URL, and
    the value will be the buffer form of our page, as shown in the following code
    block:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向我们的缓存添加`add`操作。它将接受我们页面的缓冲形式和我们用来获取它的URL。键将是URL，值将是我们页面的缓冲形式，如下面的代码块所示：
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we will implement the `get` operation, whereby we try to grab a file
    based on the URL. If we do not have it, we will return `null`. If we do retrieve
    a file, we will update the time, since this would be considered the latest page
    grab. This is illustrated as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将实现`get`操作，通过它我们尝试根据URL获取文件。如果我们没有它，我们将返回`null`。如果我们检索到一个文件，我们将更新时间，因为这将被视为最新的页面抓取。如下所示：
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we can update our `add` method''s `if` statement. If we are at the limit,
    we will iterate through our map and see what the shortest time is. We will remove
    that file and replace it with the newly created one, like this:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以更新我们的`add`方法的`if`语句。如果我们达到了限制，我们将遍历我们的地图，看看最短的时间是什么。我们将删除那个文件，并用新创建的文件替换它，就像这样：
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We now have a basic LRU cache in place for our files. To attach this to our
    server, we will need to put it in the middle of our pipeline:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的文件建立了一个基本的LRU缓存。要将其附加到我们的服务器上，我们需要将其放在我们的管道中间：
- en: 'Let''s head back into the main file and import this file:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到主文件并导入这个文件：
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will now change a bit of the logic in our stream handler. If we notice the
    URL is something that we have in the cache, we will just grab the data and pipe
    it into our response. Otherwise, we will compile the template, set it in our cache,
    and stream the compiled version down, like this:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将稍微改变我们的流处理程序中的逻辑。如果我们注意到URL是我们在缓存中有的东西，我们将只是获取数据并将其传送到我们的响应中。否则，我们将编译模板，将其设置在我们的缓存中，并将编译后的版本传送下来，就像这样：
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If we try to run the preceding code, we will now see that we grab files from
    the cache if we hit the same page twice; and if we hit them for the first time,
    it will compile through our template stream and then set it in the cache.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行上述代码，我们现在将看到如果我们两次访问相同的页面，我们将从缓存中获取文件；如果我们第一次访问它，它将通过我们的模板流进行编译，然后将其设置在缓存中。
- en: 'To make sure that our replace strategy works, let''s go ahead and set the size
    of the cache to only `1`, and see if we constantly replace the file if we hit
    a new URL, as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保我们的替换策略有效，让我们将缓存的大小设置为只有`1`，看看如果我们访问一个新的URL，我们是否不断替换文件，如下所示：
- en: '[PRE54]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If we now log our cache when each method is hit, we will now see that we are
    replacing the file when we hit a new page, but if we stay on the same page, we
    are just sending the cached file back.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在在每个方法被调用时记录我们的缓存，我们将看到当我们访问新页面时，我们正在替换文件，但如果我们停留在同一个页面，我们只是发送缓存的文件回去。
- en: 'Now that we have added caching, let''s add one more piece to our server so,
    that way, we can handle a lot of connections. We will be adding in the `cluster`
    module, just as we did in [Chapter 6](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml),
    *Message Passing – Learning about the Different Types*. We''ll proceed as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了缓存，让我们在服务器上再添加一个部分，这样我们就可以处理大量的连接。我们将添加`cluster`模块，就像我们在[第6章](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml)中所做的那样，*消息传递-了解不同类型*。我们将按照以下步骤进行：
- en: 'Let''s import the `cluster` module in the `main.js` file:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`main.js`文件中导入`cluster`模块：
- en: '[PRE55]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We will now have the initialization of the server in our main process. For our
    other processes, we will process the requests.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在主进程中初始化服务器。对于其他进程，我们将处理请求。
- en: 'Now, let''s change our strategy to handle the incoming requests inside of our
    child processes, like this:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们改变策略，处理子进程内部的传入请求，就像这样：
- en: '[PRE56]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With this single change, we are now handling the requests between four different
    processes. Just as we learned in [Chapter 6](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml),
    *Message Passing – Learning about the Different Types*, we can share a single
    port for our `cluster` module.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个单一的改变，我们现在可以在四个不同的进程之间处理请求。就像我们在[第6章](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml)中学到的那样，*消息传递-了解不同类型*，我们可以为`cluster`模块共享一个端口。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: While there is one piece left to add (hooking our sidebar up to point to real
    files), this should be a great general-purpose templating server. All that needs
    to be done is modifying our `FILE` template and hooking it into the sidebar of
    our templating system. With everything we have learned about Node.js, we should
    be able to handle almost any type of server-side application. We should also be
    able to understand how implementations of web servers such as Express are created
    from these basic building blocks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然还有一个部分需要添加（将我们的侧边栏连接到实际文件），但这应该是一个非常通用的模板服务器。需要做的就是修改我们的`FILE`模板，并将其连接到我们模板系统的侧边栏。通过我们对Node.js的学习，我们应该能够处理几乎任何类型的服务器端应用程序。我们还应该能够理解像Express这样的Web服务器是如何从这些基本构建块中创建的。
- en: From here, we will head back into the browser and take some of the concepts
    we learned from this part of the book and apply them to the web over the next
    couple of chapters. We will start by looking at worker threads in the browser,
    known as dedicated workers. We will then take a look at shared workers, and how
    we can benefit from being able to offload work to these workers, but still be
    able to grab the data from them. Finally, we will take a look at service workers,
    and see how they can help us with various optimizations, such as caching in the
    browser.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们将回到浏览器，并将书中这部分学到的一些概念应用到接下来的几章中。我们将首先看一下浏览器中的工作线程，即专用工作线程。然后我们将看一下共享工作线程，以及我们如何从这些工作线程中获益，但仍然能够从中获取数据。最后，我们将看一下服务工作者，并看看它们如何帮助我们进行各种优化，比如在浏览器中进行缓存。
