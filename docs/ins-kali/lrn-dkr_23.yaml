- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出的问题的一些示例答案：
- en: The correct answers are **D** and **E**.
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确答案是**D**和**E**。
- en: A Docker container is to IT what a shipping container is to the transportation
    industry. It defines a standard on how to package goods. In this case, goods are the
    application(s) developers write. The suppliers (in this case, the developers) are
    responsible for packaging the goods into the container and making sure everything
    fits as expected. Once the goods are packaged into a container, it can be shipped.
    Since it is a standard container, the shippers can standardize their means of
    transportation, such as lorries, trains, or ships. The shipper doesn't really care
    what's in a container. Also, the loading and unloading process from one transportation
    means to another (for example, train to ship) can be highly standardized. This
    massively increases the efficiency of transportation. Analogous to this is an
    operations engineer in IT, who can take a software container built by a developer
    and ship it to a production system and run it there in a highly standardized way,
    without worrying about what's in the container. It will just work.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker容器对IT来说就像运输业的集装箱一样。它定义了如何打包货物的标准。在这种情况下，货物是开发人员编写的应用程序。供应商（在这种情况下是开发人员）负责将货物打包到集装箱中，并确保一切都符合预期。一旦货物被打包到集装箱中，它就可以被运输。由于它是一个标准的集装箱，承运人可以标准化他们的运输方式，如卡车、火车或船只。承运人并不真正关心集装箱里装的是什么。此外，从一种运输方式到另一种运输方式（例如，从火车到船）的装卸过程可以高度标准化。这极大地提高了运输的效率。类似于这一点的是IT中的运维工程师，他可以接收开发人员构建的软件容器，并以高度标准化的方式将其运输到生产系统并在那里运行，而不必担心容器里装的是什么。它会正常工作。
- en: 'Some of the reasons why containers are game changers are as follows:'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器改变游戏规则的一些原因如下：
- en: Containers are self-contained and thus if they run on one system, they run anywhere
    that a container can run.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是自包含的，因此如果它们在一个系统上运行，它们就可以在任何容器可以运行的地方运行。
- en: Containers run on premises and in the cloud, as well as in hybrid environments.
    This is important for today's typical enterprises since it allows a smooth transition
    from on premises to the cloud.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器可以在本地和云端以及混合环境中运行。这对于今天的典型企业非常重要，因为它允许顺利地从本地过渡到云端。
- en: Container images are built or packaged by the people who know best – the developers.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像是由最了解的人构建或打包的-开发人员。
- en: Container images are immutable, which is important for good release management.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像是不可变的，这对于良好的发布管理非常重要。
- en: Containers are enablers of a secure software supply chain based on encapsulation
    (using Linux namespaces and cgroups), secrets, content trust, and image vulnerability
    scanning.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是基于封装（使用Linux命名空间和cgroups）、秘密、内容信任和镜像漏洞扫描的安全软件供应链的推动者。
- en: 'Any given container runs anywhere where containers can run for the following
    reasons:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何给定的容器之所以可以在任何容器可以运行的地方运行，是因为：
- en: Containers are self-contained black boxes. They encapsulate not only an application
    but all its dependencies, such as libraries and frameworks, configuration data,
    certificates, and so on.
  id: totrans-12
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是自包含的黑匣子。它们不仅封装了应用程序，还包括所有的依赖项，如库和框架、配置数据、证书等。
- en: Containers are based on widely accepted standards such as OCI.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是基于广泛接受的标准，如OCI。
- en: The answer is **B**. Containers are useful for modern applications as well as
    to containerize traditional applications. The benefits for an enterprise when
    doing the latter are huge. Cost savings in the maintenance of legacy apps of 50%
    or more have been reported. The time between new releases of such legacy applications
    could be reduced by up to 90%. These numbers have been publicly reported by real enterprise
    customers.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 答案是**B**。容器对于现代应用程序以及将传统应用程序容器化都非常有用。对企业来说，后者的好处是巨大的。据报道，维护传统应用程序的成本节约了50%或更多。这些传统应用程序发布新版本的时间可以减少高达90%。这些数字是由真实的企业客户公开报道的。
- en: 50% or more.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 50%或更多。
- en: Containers are based on Linux namespaces (network, process, user, and so on) and
    cgroups (control groups).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器基于Linux命名空间（网络、进程、用户等）和cgroups（控制组）。
- en: Chapter 2
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出的问题的一些示例答案：
- en: '`docker-machine` can be used for the following scenarios:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker-machine`可用于以下情景：'
- en: To create a VM on various providers such as VirtualBox, Hyper-V, AWS, MS Azure,
    or Google Compute Engine that will serve as a Docker Host.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在各种提供商上创建一个VM，例如VirtualBox、Hyper-V、AWS、MS Azure或Google Compute Engine，该VM将用作Docker主机。
- en: To start, stop, or kill a previously generated VM.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动、停止或终止先前生成的VM。
- en: To SSH into a local or remote Docker Host VM created with this tool.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过此工具创建的本地或远程Docker主机VM进行SSH。
- en: To re-generate certificates for the secure use of a Docker Host VM.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新生成用于安全使用Docker主机VM的证书。
- en: A. True. Yes, with Docker for Windows, you can develop and run Linux containers.
    It is also possible, but not discussed in this book, to develop and run native
    Windows containers with this edition of Docker for Desktop. With the macOS edition,
    you can only develop and run Linux containers.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A. 是的，使用Docker for Windows，您可以开发和运行Linux容器。还可以使用此版本的Docker for Desktop开发和运行本机Windows容器，但本书中未讨论。使用macOS版本，您只能开发和运行Linux容器。
- en: Scripts are used to automate processes and hence avoid human errors. Building,
    testing, sharing, and running Docker containers are tasks that should always be
    automated to increase their reliability and repeatability.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本用于自动化流程，从而避免人为错误。构建、测试、共享和运行Docker容器是应该始终自动化以增加其可靠性和可重复性的任务。
- en: 'The following Linux distros are certified to run Docker: RedHat Linux (RHEL),
    CentOS, Oracle Linux, Ubuntu, and more.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下Linux发行版已获得Docker认证：RedHat Linux（RHEL）、CentOS、Oracle Linux、Ubuntu等。
- en: 'The following Windows OS are certified to run Docker: Windows 10 Pro, Windows
    Server 2016, and Windows Server 2019'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下Windows操作系统已获得Docker认证：Windows 10专业版，Windows Server 2016和Windows Server 2019
- en: Chapter 3
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出的问题的一些示例答案：
- en: 'The possible states of a Docker container are as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker容器的可能状态如下：
- en: '`created`: A container that has been created but not started'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`已创建`：已创建但尚未启动的容器'
- en: '`restarting`: A container that is in the process of being restarted'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`重新启动`：正在重新启动的容器'
- en: '`running`: A currently running container'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`运行`：当前正在运行的容器'
- en: '`paused`: A container whose processes have been paused'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`暂停`：进程已暂停的容器'
- en: '`exited`: A container that ran and completed'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`退出`：运行并完成的容器'
- en: '`dead`: A container that the Docker engine tried and failed to stop'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`死亡`：Docker引擎尝试但未能停止的容器'
- en: We can use `docker container ls` (or the old, shorter version, `docker ps`)
    to list all containers that are currently running on our Docker host. Note that
    this will NOT list the stopped containers, for which you need the extra parameter`--all` (or `-a`).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`docker container ls`（或旧的更短版本`docker ps`）来列出当前在Docker主机上运行的所有容器。请注意，这不会列出已停止的容器，对于这些容器，您需要额外的参数`--all`（或`-a`）。
- en: To list all IDs of containers, running or stopped, we can use `docker container
    ls -a -q`, where `-q` stands for output ID only.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要列出所有容器的ID，无论是运行还是停止，我们可以使用`docker container ls -a -q`，其中`-q`表示仅输出ID。
- en: Chapter 4
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出的问题的一些示例答案：
- en: 'The `Dockerfile` could look like this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dockerfile`可能是这样的：'
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that in Ubuntu, the `ping` tool is part of the `iputils-ping` package.
    Build the image called `pinger`—for example— with `docker image build -t my-pinger`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Ubuntu中，`ping`工具是`iputils-ping`包的一部分。构建名为`pinger`的镜像，例如，使用`docker image
    build -t my-pinger`。
- en: '2\. The `Dockerfile` could look like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 2. `Dockerfile`可能是这样的：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Build the image with `docker image build -t my-alpine:1.0`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker image build -t my-alpine:1.0`构建镜像。
- en: '3\. The `Dockerfile` for a Go application could look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 用于Go应用程序的`Dockerfile`可能是这样的：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can find the full solution in the `~/fod/ch04/answer03` folder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`~/fod/ch04/answer03`文件夹中找到完整的解决方案。
- en: '4\. A Docker image has the following characteristics:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 4. Docker镜像具有以下特征：
- en: 1\. It is immutable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 它是不可变的。
- en: 2\. It consists of one-to-many layers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 它由一到多个层组成。
- en: 3\. It contains the files and folders needed for the packaged application to
    run.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 它包含打包应用程序运行所需的文件和文件夹。
- en: 5\. **C.** First, you need to log in to Docker Hub; then, tag your image correctly
    with the username; and finally, push the image.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 5. **C.** 首先，您需要登录Docker Hub；然后，使用用户名正确标记您的镜像；最后，推送镜像。
- en: Chapter 5
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出的问题的一些示例答案：
- en: The easiest way to play with volumes is to use the Docker Toolbox because when
    directly using Docker for Desktop, the volumes are stored inside a (somewhat hidden)
    Linux VM that Docker for Desktop uses transparently.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 玩弄卷的最简单方法是使用Docker Toolbox，因为当直接使用Docker for Desktop时，卷存储在Docker for Desktop透明使用的（有点隐藏的）Linux
    VM中。
- en: 'Thus, we suggest the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们建议以下操作：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And now that you''re inside a Linux VM called `volume-test`, you can do the following
    exercise:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您在名为`volume-test`的Linux VM中，可以进行以下练习：
- en: 'To create a named volume, run the following command:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个命名卷，运行以下命令：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Execute the following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get the path on the host for the volume, use this command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取卷在主机上的路径，请使用此命令：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This (if you''re using `docker-machine` and VirtualBox) should result in this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: （如果您使用`docker-machine`和VirtualBox）应该导致这样：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now execute the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行以下命令：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Execute the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In another terminal, execute this command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，执行此命令：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Execute a command such as this:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行这样的命令：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Exit both containers and then, back on the host, execute this command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出两个容器，然后回到主机上，执行此命令：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The answer is B. Each container is a sandbox and thus has its very own environment.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 答案是B。每个容器都是一个沙盒，因此具有自己的环境。
- en: 'Collect all environment variables and their respective values in a configuration
    file, which you then provide to the container with the `--env-file` command-line
    parameter in the `docker run` command, like so:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集所有环境变量及其相应的值到一个配置文件中，然后在`docker run`命令中使用`--env-file`命令行参数将其提供给容器，就像这样：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Chapter 6
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出的问题的一些示例答案：
- en: 'Possible answers: a) Volume mount your source code in the container; b) use
    a tool that automatically restarts the app running inside the container when code
    changes are detected; c) configure your container for remote debugging.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能的答案：a) 在容器中挂载源代码；b) 使用工具，在检测到代码更改时自动重新启动容器内运行的应用程序；c) 为远程调试配置容器。
- en: You can mount the folder containing the source code on your host in the container.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在容器中将包含源代码的文件夹挂载到主机上。
- en: If you cannot cover certain scenarios easily with unit or integration tests
    and if the observed behavior of the application cannot be reproduced when the
    application runs on the host. Another scenario is a situation where you cannot
    run the application on the host directly due to the lack of the necessary language
    or framework.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你无法轻松地通过单元测试或集成测试覆盖某些场景，如果观察到的应用程序行为无法在主机上重现。另一种情况是由于缺乏必要的语言或框架，无法直接在主机上运行应用程序的情况。
- en: Once the application is running in production, we cannot easily gain access
    to it as developers. If the application shows unexpected behavior or even crashes,
    logs are often the only source of information we have to help us reproduce the
    situation and pinpoint the root cause of the bug.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序在生产环境中运行，作为开发人员，我们无法轻易访问它。如果应用程序出现意外行为甚至崩溃，日志通常是我们唯一的信息来源，帮助我们重现情况并找出错误的根本原因。
- en: Chapter 7
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出的问题的一些示例答案：
- en: 'Pros and cons:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优缺点：
- en: 'Pro: We don''t need to have the particular shell, tool, or language required
    by the task installed on our host.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：我们不需要在主机上安装任务所需的特定shell、工具或语言。
- en: 'Pro: We can run on any Docker host, from Raspberry Pi to a mainframe computer;
    the only requirement is that the host can run containers.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：我们可以在任何Docker主机上运行，从树莓派到大型计算机；唯一的要求是主机能够运行容器。
- en: 'Pro: After a successful run, the tool is removed without leaving any traces
    from the host when the container is removed.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：成功运行后，当容器被移除时，工具会从主机上完全清除痕迹。
- en: 'Con: We need to have Docker installed on the host.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：我们需要在主机上安装Docker。
- en: Con: The user needs to have a basic understanding of Docker containers.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：用户需要对Docker容器有基本的了解。
- en: Con: Use of the tool is a bit more indirect than when using it natively.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：使用该工具比直接在本机使用要间接一些。
- en: 'Running tests in a container has the following advantages:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器中运行测试具有以下优点：
- en: They run equally well on a developer machine than on a test or CI system.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在开发者机器上和测试或CI系统上同样运行良好。
- en: It is easier to start each test run with the same initial conditions.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易以相同的初始条件开始每次测试运行。
- en: All developers working with the code use the same setup, for example, versions
    of libraries and frameworks.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有使用代码的开发人员使用相同的设置，例如库和框架的版本。
- en: Here, we expect a diagram that shows a developer writing code and checking it
    in, for example, GitHub. We then want to see an automation server such as Jenkins
    or TeamCity in the picture that is either periodically polling GitHub for changes
    or the GitHub triggers the automation server (with an HTTP callback) to create
    a new build. The diagram should also show that the automation server then runs
    all tests against the built artifacts and, if they all succeed, deploys the application
    or service to an integration system where it is again tested, for example, with
    a few smoke tests. Once again, if those tests succeed, the automation server should
    either ask a human for approval to deploy to production (this equals to continuous
    delivery) or the automation server should automatically deploy to production (continuous
    deployment).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们期望看到一个图表，显示开发人员编写代码并将其检入，例如 GitHub。然后我们希望在图中看到一个自动化服务器，比如 Jenkins 或 TeamCity，它要么定期轮询
    GitHub 进行更改，要么 GitHub 触发自动化服务器（通过 HTTP 回调）创建新的构建。图表还应显示自动化服务器然后运行所有测试以针对构建的工件，如果所有测试都成功，则部署应用程序或服务到集成系统，在那里再次进行测试，例如进行一些
    smoke 测试。再次，如果这些测试成功，自动化服务器应该要么要求人类批准部署到生产环境（这相当于持续交付），要么自动部署到生产环境（持续部署）。
- en: Chapter 8
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出的问题的一些示例答案：
- en: You could be working on a workstation with limited resources or capabilities,
    or your workstation could be locked down by your company so that you are not allowed
    to install any software that is not officially approved. Sometimes, you might
    need to do proof of concepts or experiments using languages or frameworks that
    are not yet approved by your company (but might be in the future if the proof
    of concept is successful).
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能正在使用资源或功能有限的工作站工作，或者您的工作站可能被公司锁定，以便您不被允许安装任何未经官方批准的软件。有时，您可能需要使用公司尚未批准的语言或框架进行概念验证或实验（但如果概念验证成功，可能将来会被批准）。
- en: Bind-mounting a Docker socket into a container is the recommended method when
    a containerized application needs to automate some container-related tasks. This
    can be an application such as an automation server such as Jenkins that you are
    using to build, test, and deploy Docker images.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Docker 套接字绑定到容器是当容器化应用程序需要自动执行一些与容器相关的任务时的推荐方法。这可以是一个应用程序，比如您正在使用它来构建、测试和部署
    Docker 镜像的自动化服务器，比如 Jenkins。
- en: Most business applications do not need root-level authorizations to do their
    job. From a security perspective, it is hence strongly recommended to run such
    applications with the least necessary access rights to their job. Any unnecessary
    elevated privileges could possibly be exploited by hackers in a malicious attack.
    By running the application as a non-root user, you make it more difficult for
    potential hackers to compromise your system.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数商业应用程序不需要根级授权来完成其工作。从安全的角度来看，强烈建议以尽可能少的访问权限来运行这些应用程序。任何不必要的提升权限都可能被黑客利用进行恶意攻击。通过以非根用户身份运行应用程序，可以使潜在黑客更难以
    compromise 您的系统。
- en: Volumes contain data and the lifespan of data most often needs to go far beyond
    the life cycle of a container or an application, for that matter. Data is often
    mission-critical and needs to be stored safely for days, months, even years. When
    you delete a volume, you irreversibly delete the data associated with it. Hence,
    make sure you know what you're doing when deleting a volume.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卷包含数据，数据的寿命往往需要远远超出容器或应用程序的生命周期。数据通常是至关重要的，并且需要安全地存储数天、数月，甚至数年。当您删除一个卷时，您将不可逆地删除与其关联的数据。因此，在删除卷时，请确保知道自己在做什么。
- en: Chapter 9
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出的问题的一些示例答案：
- en: In a distributed application architecture, every piece of the software and infrastructure
    needs to be redundant in a production environment, where the continuous uptime
    of the application is mission-critical. A highly distributed application consists
    of many parts and the likelihood of one of the pieces failing or misbehaving increases
    with the number of parts. It is guaranteed that, given enough time, every part
    will eventually fail. To avoid outages of the application, we need redundancy
    in every part, be it a server, a network switch, or a service running on a cluster
    node in a container.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分布式应用架构中，软件和基础设施的每个部分在生产环境中都需要冗余，因为应用的持续运行时间至关重要。高度分布式的应用程序由许多部分组成，其中一个部分失败或行为不当的可能性随着部分数量的增加而增加。可以保证，足够长的时间后，每个部分最终都会失败。为了避免应用中断，我们需要在每个部分都有冗余，无论是服务器、网络交换机还是在容器中运行的集群节点上的服务。
- en: In highly distributed, scalable, and fault-tolerant systems, individual services
    of the application can move around due to scaling needs or due to component failures.
    Thus, we cannot hardwire different services with each other. Service A, which
    needs access to Service B, should not have to know details such as the IP address
    of Service B. It should rely on an external provider of this information. DNS
    is such a provider of location information. Service A just tells it that it wants
    to talk to Service B and the DNS service will figure out the details.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在高度分布式、可扩展和容错的系统中，应用程序的各个服务可能会因为扩展需求或组件故障而移动。因此，我们不能将不同的服务硬编码在一起。需要访问服务B的服务A不应该知道诸如服务B的IP地址之类的细节，而应该依赖于提供此信息的外部提供者。DNS就是这样一个位置信息的提供者。服务A只需告诉DNS它想要与服务B通信，DNS服务将找出详细信息。
- en: A circuit breaker is a means to avoid cascading failures if a component in a
    distributed application is failing or misbehaving. Similar to a circuit breaker
    in electric wiring, a software-driven circuit breaker cuts the communication between
    a client and a failed service. The circuit breaker will directly report an error
    back to the client component if the failed service is called. This gives the system
    the opportunity to recover or heal from failure.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断路器是避免级联故障的一种手段，如果分布式应用程序中的一个组件失败或行为不当。类似于电气布线中的断路器，软件驱动的断路器会切断客户端与失败服务之间的通信。如果调用了失败的服务，断路器将直接向客户端组件报告错误。这为系统提供了从故障中恢复或修复的机会。
- en: A monolithic application is easier to manage that a multi-service application
    since it consists of a single deployment package. On the other hand, a monolith
    is harder to scale to account for increased demand. In a distributed application,
    each service can be scaled individually and each service can run on optimized
    infrastructure, while a monolith needs to run on infrastructure that is OK for
    all or most of the features implemented in it. Maintaining and updating a monolith
    is much harder than a multi-service application, where each service can be updated
    and deployed independently. The monolith is often a big, complex, and tightly
    coupled pile of code. Minor modifications can have unexpected side effects. (Micro-)
    Services, on the other hand, are self-contained, simple components that behave
    like black boxes. Dependent services know nothing about the inner workings of
    the service and thus do not depend on it.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体应用程序比多服务应用程序更容易管理，因为它由单个部署包组成。另一方面，单体应用程序很难扩展以满足增加的需求。在分布式应用程序中，每个服务都可以单独扩展，并且每个服务都可以在优化的基础设施上运行，而单体应用程序需要在适用于其实现的所有或大多数功能的基础设施上运行。维护和更新单体应用程序比多服务应用程序要困难得多，因为每个服务都可以独立更新和部署。单体通常是一堆复杂且紧密耦合的代码。小的修改可能会产生意想不到的副作用。另一方面，（微）服务是自包含的、简单的组件，其行为类似于黑匣子。依赖服务对服务的内部工作一无所知，因此不依赖于它。
- en: A blue-green deployment is a form of software deployment that allows for zero
    downtime deployments of new versions of an application or an application service.
    If, say, Service A needs to be updated with a new version, then we call the currently
    running version blue. The new version of the service is deployed into production,
    but not yet wired up with the rest of the application. This new version is called
    green. Once the deployment succeeds and smoke tests have shown it's ready to go,
    the router that funnels traffic to blue is reconfigured to switch to green. The
    behavior of green is observed for a while and if everything is OK, blue is decommissioned.
    On the other hand, if green causes difficulties, the router can simply be switched
    back to blue and green can be fixed and later redeployed.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 蓝绿部署是一种软件部署形式，允许无零停机部署应用程序或应用程序服务的新版本。例如，如果服务A需要使用新版本进行更新，那么我们称当前运行的版本为蓝色。服务的新版本部署到生产环境，但尚未与应用程序的其余部分连接。这个新版本被称为绿色。一旦部署成功并且冒烟测试表明它已经准备就绪，将负责将流量引导到蓝色的路由器重新配置为切换到绿色。观察绿色的行为一段时间，如果一切正常，蓝色将被废弃。另一方面，如果绿色造成困难，路由器可以简单地切换回蓝色，然后修复绿色并稍后重新部署。
- en: Chapter 10
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出的一些问题的样本答案：
- en: The three core elements are **sandbox**, **endpoint**, and **network**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个核心元素是**沙盒**、**端点**和**网络**。
- en: 'Execute this command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此命令：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run this command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此命令：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Test that both NGINX instances are up and running:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 测试两个NGINX实例是否正常运行：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should be seeing the welcome page of NGINX in both cases.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，您应该看到NGINX的欢迎页面。
- en: 'To get the IPs of all attached containers, run this command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取所有已附加容器的IP，请运行此命令：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see something similar to the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下内容：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To get the subnet used by the network, use the following (for example):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取网络使用的子网，请使用以下命令（例如）：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should receive something along the lines of the following (obtained from
    the previous example):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该收到类似以下内容的信息（从上一个示例中获得）：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `host` network allows us to run a container in the networking namespace
    of the host.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “主机”网络允许我们在主机的网络命名空间中运行容器。
- en: Only use this network for debugging purposes or when building a system-level tool.
    Never use the `host` network for an application container running a production
    environment!
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅在调试目的或构建系统级工具时使用此网络。永远不要在运行生产环境的应用程序容器中使用`host`网络！
- en: The `none` network is basically saying that the container is not attached to
    any network. It should be used for containers that do not need to communicate
    with other containers and do not need to be accessed from outside.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`none`网络基本上表示容器未连接到任何网络。它应该用于不需要与其他容器通信并且不需要从外部访问的容器。'
- en: The `none` network could, for example, be used for a batch process running in
    a container that only needs access to local resources such as files that could
    be accessed via a host mounted volume.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，`none`网络可以用于在容器中运行的批处理过程，该过程只需要访问本地资源，例如可以通过主机挂载卷访问的文件。
- en: Traefik can be used to provide Layer 7 or application-level routing. This is
    especially useful if you want to break out functionality from a monolith with
    a well-defined API. In this case, you have a need to reroute certain HTTP calls
    to the new container/service. This is just one of the possible usage scenarios,
    but it's also the most important one. Another one could be to use Traefik as a
    load balancer.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Traefik可用于提供第7层或应用程序级别的路由。如果要从单体中分离功能并具有明确定义的API，则这将非常有用。在这种情况下，您需要重新路由某些HTTP调用到新的容器/服务。这只是可能的使用场景之一，但也是最重要的一个。另一个可能是将Traefik用作负载均衡器。
- en: Chapter 11
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出的问题的一些示例答案：
- en: 'The following code can be used to run the application in detached or daemon
    mode:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码可用于以分离或守护程序模式运行应用程序：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Execute the following command to display the details of the running service:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令以显示运行服务的详细信息：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This should result in the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该导致以下输出：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following command can be used to scale up the web service:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令可用于扩展Web服务：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Chapter 12
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出的问题的一些示例答案：
- en: A mission-critical, highly available application that is implemented as a highly
    distributed system of interconnected application services that are just too complex
    to manually monitor, operate, and manage. Container orchestrators help in this
    regard. They automate most of the typical tasks, such as reconciling a desired
    state, or collecting and aggregating key metrics of the system. Humans cannot
    react quick enough to make such an application elastic or self-healing. Software
    support is needed for this in the form of the mentioned container orchestrators.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为高度分布式的关键任务，高可用性应用程序实现为相互连接的应用程序服务系统，这些系统过于复杂，无法手动监视、操作和管理。容器编排器在这方面有所帮助。它们自动化了大部分典型任务，例如协调所需状态，或收集和聚合系统的关键指标。人类无法快速反应，以使这样的应用程序具有弹性或自我修复能力。软件支持是必要的，这就是所提到的容器编排器的形式。
- en: 'A container orchestrator frees us from mundane and cumbersome tasks such as
    the following:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器编排器使我们摆脱了以下繁琐和繁重的任务：
- en: Scaling services up and down
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展服务的规模
- en: Load balancing requests
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡请求
- en: Routing requests to the desired target
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求路由到所需的目标
- en: Monitoring the health of service instances
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视服务实例的健康状况
- en: Securing a distributed application
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护分布式应用程序
- en: The winner in this space is Kubernetes, which is open sourced and owned by the
    CNCF. It was originally developed by Google. We also have Docker Swarm, which
    is proprietary and has been developed by Docker. AWS offers a container service
    called ECS, which is also proprietary and tightly integrated into the AWS ecosystem.
    Finally, Microsoft offers AKS, which has the same pros and cons as AWS ECS.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个领域的赢家是Kubernetes，它是由CNCF开源并拥有。它最初是由Google开发的。我们还有Docker Swarm，它是专有的，并由Docker开发。AWS提供了一个名为ECS的容器服务，它也是专有的，并且与AWS生态系统紧密集成。最后，微软提供了AKS，它与AWS
    ECS具有相同的优缺点。
- en: Chapter 13
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出的一些问题的样本答案：
- en: 'The correct answer is as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确答案如下：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `--advertise-addr` is optional and is only needed if you the host have more than
    one IP address.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`--advertise-addr`是可选的，只有在主机有多个IP地址时才需要。'
- en: 'On the worker node that you want to remove, execute the following command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在要移除的工作节点上执行以下命令：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: On one of the master nodes, execute the command `$ docker node rm -f<node ID>`,
    where <`node ID>` is the ID of the worker node to remove.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中一个主节点上执行命令`$ docker node rm -f<node ID>`，其中`<node ID>`是要移除的工作节点的ID。
- en: 'The correct answer is as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确答案如下：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The correct answer is as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确答案如下：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The correct answer is as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确答案如下：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Chapter 14
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出的一些问题的样本答案：
- en: Zero-downtime deployment means that a new version of a service in a distributed
    application is updated to a new version without the application needing to stop
    working. Usually, with Docker SwarmKit or Kubernetes (as we will see), this is
    done in a rolling fashion. A service consists of multiple instances and those
    are updated in batches so that the majority of the instances are up and running
    at all times.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 零停机部署意味着在分布式应用程序中，服务的新版本可以更新到新版本，而无需停止应用程序的运行。通常情况下，使用Docker SwarmKit或Kubernetes（如我们将看到的那样），这是以滚动方式完成的。一个服务由多个实例组成，这些实例会分批更新，以确保大多数实例始终处于运行状态。
- en: By default, Docker SwarmKit uses a rolling updated strategy to achieve zero-downtime
    deployments.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Docker SwarmKit使用滚动更新策略来实现零停机部署。
- en: Containers are self-contained units of deployment. If a new version of a service
    is deployed and does not work as expected, we (or the system) need to only roll
    back to the previous version. The previous version of the service is also deployed
    in the form of self-contained containers. Conceptually, there is no difference
    in rolling forward (update) or backward (rollback). One version of a container
    is replaced by another one. The host itself is not affected by such changes in
    any way.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器是部署的自包含单元。如果部署的服务的新版本不如预期地工作，我们（或系统）只需要回滚到以前的版本。服务的以前版本也是以自包含容器的形式部署的。在概念上，向前（更新）或向后（回滚）滚动没有区别。一个容器的版本被另一个版本替换。主机本身不会受到这些变化的任何影响。
- en: Docker secrets are encrypted at rest. They are only transferred to the services
    and containers that use the secrets. Secrets are transferred encrypted due to
    the fact that the communication between swarm nodes uses mutual TLS. Secrets are
    never physically stored on a worker node.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker secrets在静止状态下是加密的。它们只会传输给使用这些秘密的服务和容器。秘密之间的通信是加密的，因为swarm节点之间的通信使用相互TLS。秘密从未在工作节点上物理存储。
- en: 'The command to achieve this is as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现此目的的命令如下：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '6\. First, we need to remove the old secret from the service, and then we need
    to add the new version to it (directly updating a secret is not possible):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 6.首先，我们需要从服务中删除旧的秘密，然后将新版本添加到其中（直接更新秘密是不可能的）：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Chapter 15
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出的问题的一些示例答案：
- en: The Kubernetes master is responsible for managing the cluster. All requests
    to create objects, reschedule pods, manage ReplicaSets, and more happen on the
    master. The master does not run the application workload in a production or production-like
    cluster.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes主节点负责管理集群。所有创建对象、重新调度pod、管理ReplicaSets等请求都在主节点上进行。主节点不会在生产或类似生产的集群中运行应用程序工作负载。
- en: On each worker node, we have the kubelet, the proxy, and container runtime.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个工作节点上，我们都有kubelet、代理和容器运行时。
- en: The answer is A. **Yes**. You cannot run standalone containers on a Kubernetes
    cluster. Pods are the atomic units of deployment in such a cluster.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 答案是A。**是**。你不能在Kubernetes集群上运行独立的容器。Pods是这样一个集群中部署的原子单位。
- en: All containers running inside a pod share the same Linux kernel network namespace.
    Thus, all processes running inside those containers can communicate with each
    other through `localhost` in a similar way to how processes or applications directly
    running on the host can communicate with each other through `localhost`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个pod内运行的所有容器共享相同的Linux内核网络命名空间。因此，所有在这些容器内运行的进程可以通过`localhost`相互通信，类似于直接在主机上运行的进程或应用程序可以通过`localhost`相互通信的方式。
- en: The `pause` container's sole role is to reserve the namespaces of the pod for
    containers that run in it.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pause`容器的唯一作用是为在其中运行的容器保留pod的命名空间。'
- en: This is a bad idea since all containers of a pod are co-located, which means
    they run on the same cluster node. Also, if multiple containers run in the same
    pod, they can only be scaled up or down all at once. However, the different components
    of the application (that is, `web`, `inventory`, and `db`) usually have very different
    requirements with regard to scalability or resource consumption. The `web` component
    might need to be scaled up and down depending on the traffic and the `db` component,
    in turn, has special requirements regarding storage that the others don't have.
    If we do run every component in its own pod, we are much more flexible in this
    regard.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个坏主意，因为一个pod的所有容器都是共同定位的，这意味着它们运行在同一个集群节点上。此外，如果多个容器在同一个pod中运行，它们只能一起扩展或缩减。然而，应用程序的不同组件（即`web`、`inventory`和`db`）通常在可伸缩性或资源消耗方面有非常不同的要求。`web`组件可能需要根据流量进行扩展或缩减，而`db`组件则对存储有特殊要求，而其他组件则没有。如果我们将每个组件都运行在自己的pod中，我们在这方面会更加灵活。
- en: We need a mechanism in order to run multiple instances of a pod in a cluster
    and make sure that the actual number of pods running always corresponds to the
    desired number, even when individual pods crash or disappear due to network partition or
    cluster node failures. The ReplicaSet is the mechanism that provides scalability
    and self-healing to any application service.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一种机制来在集群中运行多个pod实例，并确保实际运行的pod数量始终与期望的数量相对应，即使个别pod由于网络分区或集群节点故障而崩溃或消失。
    ReplicaSet是为任何应用程序服务提供可伸缩性和自愈能力的机制。
- en: We need deployment objects whenever we want to update an application service in
    a Kubernetes cluster without causing downtime to the service. Deployment objects
    add rolling updates and rollback capabilities to ReplicaSets.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当我们想要在Kubernetes集群中更新应用程序服务而不会导致服务中断时，我们都需要部署对象。部署对象为ReplicaSets添加了滚动更新和回滚功能。
- en: 'Kubernetes service objects are used to make application services participate
    in service discovery. They provide a stable endpoint to a set of pods (normally
    governed by a ReplicaSet or a deployment). Kube services are abstractions that define
    a logical set of pods and a policy regarding how to access them. There are four types
    of Kube service:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes服务对象用于使应用程序服务参与服务发现。它们为一组pod提供了一个稳定的端点（通常由ReplicaSet或部署管理）。Kube服务是定义了一组逻辑pod和访问它们的策略的抽象。有四种类型的Kube服务：
- en: '**ClusterIP**: Exposes the service on an IP address that''s only accessible
    from inside the cluster; this is a virtual IP (VIP).'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClusterIP**：在集群内部的IP地址上公开服务；这是一个虚拟IP（VIP）。'
- en: '**NodePort**: Publishes a port in the range 30,000–32,767 on every cluster node.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NodePort**：在每个集群节点上发布30,000-32,767范围内的端口。'
- en: '**LoadBalancer**: This type exposes the application service externally using
    a cloud provider''s load balancer, such as ELB on AWS.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoadBalancer**：这种类型使用云提供商的负载均衡器（如AWS上的ELB）来外部公开应用程序服务。'
- en: '**ExternalName**: Used when you need to define a proxy for a cluster''s external
    service such as a database.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ExternalName**：当您需要为集群的外部服务（如数据库）定义代理时使用。'
- en: Chapter 16
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出的问题的一些示例答案：
- en: 'Assuming we have a Docker image in a registry for the two application services, the
    web API and Mongo DB, we then need to do the following:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们在两个应用程序服务的注册表中有一个Docker镜像，web API和Mongo DB，然后我们需要做以下操作：
- en: Define a deployment for Mongo DB using a StatefulSet; let's call this deployment `db-deployment`.
    The StatefulSet should have one replica (replicating Mongo DB is a bit more involved
    and is outside the scope of this book).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用StatefulSet为Mongo DB定义一个部署；让我们称之为`db-deployment`。StatefulSet应该有一个副本（复制Mongo
    DB需要更多的工作，超出了本书的范围）。
- en: Define a Kubernetes service called `db` of the `ClusterIP` type for `db-deployment`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`db-deployment`定义一个名为`db`的Kubernetes服务，类型为`ClusterIP`。
- en: Define a deployment for the web API; let's call it `web-deployment`. Let's scale
    this service to three instances.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为web API定义一个部署；让我们称之为`web-deployment`。将这个服务扩展到三个实例。
- en: Define a Kubernetes service called `api` of the `NodePort` type for `web-deployment`.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为`web-deployment`定义一个名为`api`的Kubernetes服务，类型为`NodePort`。
- en: If we use secrets, then define those secrets directly in the cluster using kubectl.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用secrets，那么使用kubectl直接在集群中定义这些secrets。
- en: Deploy the application using kubectl.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用kubectl部署应用程序。
- en: To implement layer 7 routing for an application, we ideally use an IngressController.
    The IngressController is a reverse proxy such as Nginx that has a sidecar listening
    on the Kubernetes Server API for relevant changes and updating the reverse proxy's
    configuration and restarting it if such a change has been detected. Then, we need
    to define Ingress resources in the cluster that define the routing, for example,
    from a context-based route such as `https://example.com/pets to <a service name>/<port>` or
    a pair such as `api/32001`. The moment Kubernetes creates or changes this Ingress
    object, the IngressController's sidecar picks it up and updates the proxy's routing configuration.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了实现应用程序的第7层路由，我们理想情况下使用IngressController。IngressController是一个反向代理，比如Nginx，它有一个sidecar监听Kubernetes
    Server API的相关变化，并更新反向代理的配置，如果检测到变化，则重新启动。然后，我们需要在集群中定义Ingress资源，定义路由，例如基于上下文的路由，比如`https://example.com/pets`到`<服务名称>/<端口>`，或者一对，比如`api/32001`。一旦Kubernetes创建或更改了这个Ingress对象，IngressController的sidecar就会接收并更新代理的路由配置。
- en: 'Assuming this is a cluster internal inventory service, then we do the following:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设这是一个集群内部的库存服务，那么我们需要做以下操作：
- en: 'When deploying version 1.0, we define a deployment called `inventory-deployment-blue` and
    label the pods with a label of `color: blue`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在部署版本1.0时，我们定义了一个名为`inventory-deployment-blue`的部署，并使用`color: blue`的标签标记pod。'
- en: 'We deploy the Kubernetes service of the `ClusterIP` type called inventory for
    the preceding deployment with the selector containing `color: blue`.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们部署了Kubernetes服务的`ClusterIP`类型，称为inventory，前面的部署中包含选择器`color: blue`。'
- en: 'When we''re ready to deploy the new version of the payments service, we define
    a deployment for version 2.0 of the service and call it `inventory-deployment-green`.
    We add a label of `color: green` to the pods.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '当我们准备部署支付服务的新版本时，我们为服务的2.0版本定义一个部署，并称其为`inventory-deployment-green`。我们向pod添加了`color:
    green`的标签。'
- en: 'We can now smoke test the "green" service and when everything is OK, we can
    update the inventory service so that the selector contains `color: green`.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '现在我们可以对“green”服务进行冒烟测试，当一切正常时，我们可以更新inventory服务，以便选择器包含`color: green`。'
- en: Some forms of information that are confidential and thus should be provided
    to services through Kubernetes secrets include passwords, certificates, API key
    IDs, API key secrets, and tokens.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些机密的信息形式应通过Kubernetes secrets提供给服务，包括密码、证书、API密钥ID、API密钥密钥和令牌。
- en: Sources for secret values can be files or base64-encoded values.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 秘密值的来源可以是文件或base64编码的值。
- en: Chapter 17
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出的问题的一些示例答案：
- en: We cannot do any live debugging on a production system for performance and security
    reasons. This includes interactive or remote debugging. Yet application services
    can show unexpected behavior to code defects or other infrastructure-related issues
    such as network glitches or external services that are not available. To quickly
    pinpoint the reason for the misbehavior or failure of a service, we need as much
    logging information as possible. This information should give us a clue about,
    and guide us to, the root cause of the error. When we instrument a service, we
    do exactly this — we produce as much information as reasonable in the form of
    log entries and published metrics.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出于性能和安全原因，我们不能在生产系统上进行任何实时调试。这包括交互式或远程调试。然而，应用服务可能会因代码缺陷或其他基础设施相关问题（如网络故障或不可用的外部服务）而表现出意外行为。为了快速找出服务的异常行为或失败的原因，我们需要尽可能多的日志信息。这些信息应该给我们一个线索，并引导我们找到错误的根本原因。当我们对服务进行仪器化时，我们确实做到了这一点——以日志条目和发布的指标的形式产生尽可能多的信息。
- en: Prometheus is a service that is used to collect functional or non-functional
    metrics that are provided by other infrastructure services and most importantly
    by application services. Since Prometheus itself is pulling those metrics periodically
    from all configured services, the services themselves do not have to worry about
    sending data. Prometheus also defines the format in which the metrics are to be
    presented by the producers.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Prometheus是一个用于收集其他基础设施服务和最重要的应用服务提供的功能或非功能指标的服务。由于Prometheus本身定期从所有配置的服务中拉取这些指标，因此服务本身不必担心发送数据。Prometheus还定义了生产者呈现指标的格式。
- en: 'To instrument a Node.js-based application service we need to do the following
    four steps:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要对基于Node.js的应用服务进行仪器化，我们需要执行以下四个步骤：
- en: Add a Prometheus adapter to the project. The maintainers of Prometheus recommend
    the library called `siimon/prom-client`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目添加Prometheus适配器。Prometheus的维护者推荐使用名为`siimon/prom-client`的库。
- en: Configure the Prometheus client during startup of the application. This includes
    the definition of a metrics registry.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序启动期间配置Prometheus客户端。这包括定义一个指标注册表。
- en: Expose an HTTP GET endpoint/metrics where we return the collection of metrics
    defined in the metrics registry.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公开一个HTTP GET端点/度量标准，返回度量标准注册表中定义的度量集合。
- en: Finally, we define custom metrics of the `counter`, `gauge`, or `histogram` type,
    and use them in our code; for example, we increase a metric of the `counter` type
    each time a certain endpoint is called.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义`counter`、`gauge`或`histogram`类型的自定义度量标准，并在我们的代码中使用它们；例如，每次调用特定端点时，我们增加`counter`类型的度量标准。
- en: Normally in production, a Kubernetes cluster node only contains a minimal OS
    to keep its attack surface as limited as possible and to not waste precious resources.
    Thus we cannot assume that the tools typically used to troubleshoot applications
    or processes are available on the respective host. A powerful and recommended
    way to troubleshoot is to run a special tools or troubleshoot container as part
    of an ad hoc pod. This container can then be used as a bastion from which we can
    investigate network and other issues with the troubled service. A container that
    has been successfully used by many Docker field engineers at their customers site is `netshoot`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常在生产环境中，Kubernetes集群节点只包含最小的操作系统，以尽可能限制其攻击面，并且不浪费宝贵的资源。因此，我们不能假设通常用于排除应用程序或进程的工具在相应的主机上可用。排除故障的一种强大且推荐的方法是作为临时Pod的一部分运行特殊工具或排除故障容器。然后，该容器可以用作我们可以调查受困扰的服务的网络和其他问题的堡垒。许多Docker现场工程师在客户现场成功使用的容器是`netshoot`。
- en: Chapter 18
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出的问题的一些示例答案：
- en: 'To install UCP in AWS, we do the following:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在AWS中安装UCP，我们执行以下操作：
- en: Create a VPC with subnets and an SG.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有子网和SG的VPC。
- en: Then, provision a cluster of Linux VMs, possibly as part of an ASG. Many Linux
    distributions are supported, such as CentOS, RHEL, and Ubuntu.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，提供一组Linux VM的集群，可能作为ASG的一部分。支持许多Linux发行版，如CentOS、RHEL和Ubuntu。
- en: Next, install Docker on each VM.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在每个VM上安装Docker。
- en: Finally, select one VM on which to install UCP using the `docker/ucp` image.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，选择一个VM来安装UCP，使用`docker/ucp`镜像。
- en: Once UCP is installed, join the other VMs to the cluster either as worker nodes
    or manager nodes.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装UCP后，将其他VM加入集群，作为工作节点或管理节点。
- en: 'Here are a few reasons to consider a hosted Kubernetes offering:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是考虑托管Kubernetes的一些原因：
- en: You do not want to, or do not have the resources to, install and manage a Kubernetes
    cluster.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不希望或没有资源来安装和管理Kubernetes集群。
- en: You want to concentrate on what brings value to your business, which in most
    cases is the applications that are supposed to run on Kubernetes and not Kubernetes
    itself.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您希望专注于为您的业务带来价值的内容，这在大多数情况下是应该在Kubernetes上运行的应用程序，而不是Kubernetes本身。
- en: You prefer a cost model where you pay only for what you need.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您更喜欢按需付费的成本模型。
- en: The nodes of your Kubernetes cluster are automatically patched and updated.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的Kubernetes集群节点会自动打补丁和更新。
- en: Upgrading the version of Kubernetes with zero downtime is easy and straightforward.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级Kubernetes版本而无需停机时间非常简单和直接。
- en: 'The two main reasons to host container images on the cloud provider''s container
    registry (such as ACR on Microsoft Azure) are these:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将容器镜像托管在云提供商的容器注册表（例如Microsoft Azure上的ACR）的两个主要原因是：
- en: The images are geographically close to your Kubernetes cluster and thus the
    latency and transfer network costs are minimal.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像地理位置靠近您的Kubernetes集群，因此延迟和传输网络成本最小。
- en: Production or production-like clusters are ideally sealed from the internet,
    and thus the Kubernetes cluster nodes cannot access Docker Hub directly.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产或类似生产的集群理想情况下应该与互联网隔离，因此Kubernetes集群节点无法直接访问Docker Hub。
