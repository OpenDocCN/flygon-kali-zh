- en: Reactive Programming and Future Developments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程和未来发展
- en: Event-driven architectures have been around for a long time, and asynchronous
    method invocations, message-driven beans, event control logic, and so on are constructs
    that developers are familiar with. However, with the popularity and adoption of
    cloud resources and on-demand scalability, organizations have a renewed interest
    in reactive programming approaches that can exploit serverless and function as
    service-type environments. Eclipse MicroProfile also includes specifications related
    to reactive programming in projects that currently live outside the Eclipse MicroProfile
    umbrella/platform release.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 事件驱动架构已经存在很长时间，异步方法调用、消息驱动的bean、事件控制逻辑等都是开发人员熟悉的构造。然而，随着云资源和按需可伸缩性的普及和采用，组织对能够利用无服务器和函数服务类型环境的响应式编程方法重新产生了兴趣。Eclipse
    MicroProfile还包括与响应式编程相关的规范，这些规范目前属于Eclipse MicroProfile沙盒/平台发布之外的项目。
- en: 'In addition to these, there are also projects in the Eclipse MicroProfile sandbox
    that the community is currently discussing, implementing, and evaluating to decide
    whether or not they should be promoted to official MicroProfile projects. This
    chapter will help you learn about the current MicroProfile specifications related
    to reactive programming as well as give you a glimpse into what is already in
    motion and what is upcoming in relation to the projects that sit outside the umbrella/platform
    release and in the MicroProfile sandbox. The following topics will be covered
    in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Eclipse MicroProfile沙盒中还有一些项目，社区目前正在讨论、实施和评估，以决定它们是否应该被提升为官方的MicroProfile项目。本章将帮助您了解与响应式编程相关的当前MicroProfile规范，以及让您一窥目前正在进行和即将进行的与沙盒之外的项目相关的动态。本章将涵盖以下主题：
- en: An overview of what reactive messaging is
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应式消息的概述
- en: An explanation of the reactive messaging architecture within Eclipse MicroProfile
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile中的响应式消息架构的解释
- en: A description of the Eclipse MicroProfile specifications related to reactive
    programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Eclipse MicroProfile相关的响应式编程规范的描述
- en: Examples of how to use the reactive message specification of Eclipse MicroProfile
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Eclipse MicroProfile的响应式消息规范的示例
- en: An overview of MicroProfile projects/specifications that sit outside the umbrella
    or platform release
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位于Umbrella或平台发布之外的MicroProfile项目/规范概述
- en: A description of projects that sit within the Eclipse MicroProfile sandbox
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位于Eclipse MicroProfile沙盒中的项目描述
- en: An insight into the current relationship between Eclipse MicroProfile and Jakarta
    EE and an analysis of their possible futures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile与Jakarta EE之间当前关系的洞察和可能未来的分析
- en: Reactive programming work in Eclipse MicroProfile
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile中的响应式编程工作
- en: At the time of writing, the reactive-related specifications that are part of
    Eclipse MicroProfile are Reactive Streams Operators, Reactive Messaging, and Context
    Propagation. Reactive work within the MicroProfile community continues to evolve,
    and new specifications may surface in the future as well as newer releases of
    existing reactive-related ones.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Eclipse MicroProfile中与响应式相关的规范包括Reactive Streams Operators、Reactive Messaging和Context
    Propagation。MicroProfile社区内的响应式工作仍在不断发展，未来可能会出现新的规范，以及现有的与响应式相关的规范的更新版本。
- en: An overview of Reactive Messaging
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式消息概述
- en: 'The [Reactive Manifesto](https://www.reactivemanifesto.org/) defines the characteristics
    of reactive systems to including an asynchronous messaging core that is used to
    build elastic, resilient systems. This is typically illustrated via a diagram
    such as the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[响应式宣言](https://www.reactivemanifesto.org/)定义了响应式系统的特征，包括用于构建弹性、有弹性的系统的异步消息核心。通常可以通过以下示意图来说明：'
- en: '![](img/a5e7920f-3372-4247-a4d6-a9e52c974d3f.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5e7920f-3372-4247-a4d6-a9e52c974d3f.png)'
- en: The idea is that interaction via asynchronous messages promotes resilience,
    elasticity, and, in turn, responsiveness.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过异步消息进行交互有助于提高弹性、伸缩性，并进而提高响应性。
- en: The **MicroProfile Reactive Messaging** (**MP-RM**) specification aims to enable
    microservice-based applications with the characteristics of reactive systems via
    event-driven microservices. The specification focuses on versatility and is suitable
    for building different types of architecture and applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**MicroProfile响应式消息**（**MP-RM**）规范旨在通过事件驱动的微服务使基于微服务的应用具有响应式系统的特征。该规范侧重于多功能性，适用于构建不同类型的架构和应用程序。'
- en: Asynchronous interactions with different services and resources can be implemented
    using reactive messaging. Typically, asynchronous database drivers can be used
    in conjunction with reactive messaging to read and write into a data store in
    a non-blocking and asynchronous manner.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用响应式消息可以实现与不同服务和资源的异步交互。通常情况下，可以将异步数据库驱动程序与响应式消息结合使用，以非阻塞和异步方式读取和写入数据存储。
- en: When building microservices, **Command Query Responsibility Segregation** (**CQRS**)
    and event-sourcing patterns provide an answer to data sharing between microservices
    ([https://martinfowler.com/bliki/CQRS.html](https://martinfowler.com/bliki/CQRS.html)).
    Reactive messaging can also be used as the foundation for CQRS and the event-sourcing
    mechanism, as these patterns embrace message-passing as a core communication pattern.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 构建微服务时，**命令查询责任分离**（**CQRS**）和事件溯源模式提供了在微服务之间共享数据的解决方案（[https://martinfowler.com/bliki/CQRS.html](https://martinfowler.com/bliki/CQRS.html)）。响应式消息也可以作为CQRS和事件溯源机制的基础，因为这些模式采用消息传递作为核心通信模式。
- en: MicroProfile reactive messaging architecture
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile响应式消息架构
- en: 'An application using reactive messaging is composed of CDI beans that consume,
    produce, and process messages. The messages can be internal to the application,
    or can be sent and received via external message brokers, as illustrated in the
    following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用响应式消息的应用程序由消费、生产和处理消息的CDI bean组成。消息可以是应用程序内部的，也可以通过外部消息代理发送和接收，如下图所示：
- en: '![](img/8aec63b4-925c-414e-97b0-409c29421e65.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8aec63b4-925c-414e-97b0-409c29421e65.png)'
- en: This figure shows a Kafka topic publishing messages to a first bean, which does
    some processing and publishes it to a second bean, which does its own processing/filtering,
    and finally publishes the message as an AMQP topic.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图显示了一个Kafka主题将消息发布到第一个bean，该bean进行一些处理并将其发布到第二个bean，该bean进行自己的处理/过滤，最后将消息发布为AMQP主题。
- en: As we will see when we look into MP-RM examples, application beans contain methods
    annotated with `@Incoming` and/or `@Outgoing ...`
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看MP-RM示例时，应用程序bean包含带有`@Incoming`和/或`@Outgoing`注解的方法...
- en: Message shapes
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息形状
- en: 'The MP-RM specification defines a number of supported signature types that
    beans can use to define publish and subscriber behaviors. These signatures depend
    on a few key types that are outlined in the following list:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: MP-RM规范定义了一些支持的签名类型，bean可以使用这些类型来定义发布和订阅行为。这些签名取决于以下列表中概述的一些关键类型。
- en: '`org.reactivestreams.Publisher`: A Reactive Streams `Publisher<T>` is a provider
    of a potentially unlimited number of sequenced elements, publishing them according
    to the demand received from its link subscriber(s).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.reactivestreams.Publisher`：Reactive Streams `Publisher<T>`是一个可能无限数量的序列元素的提供者，根据从其链接订阅者接收到的需求发布它们。'
- en: '`org.reactivestreams.Subscriber`: A Reactive Stream `Subscriber<T>` interface
    that is used to signal demand to `Publisher`. It provides events for subscription
    information, zero or more data events, and error and completion events.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.reactivestreams.Subscriber`：用于向`Publisher`发出需求信号的Reactive Stream `Subscriber<T>`接口。它提供订阅信息、零个或多个数据事件、错误和完成事件的事件。'
- en: '`org.reactivestreams.Processor`: This Reactive Stream `Processor<T,R>` interface
    simply extends both `Subscriber<T>` and `Publisher<R>`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.reactivestreams.Processor`：这个Reactive Stream `Processor<T,R>`接口简单地扩展了`Subscriber<T>`和`Publisher<R>`。'
- en: '`org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder`: The
    MP Reactive Streams Operators `PublisherBuilder` interface allows you to build
    up a Reactive Streams `Publisher` from various sources and apply operations to
    transform/filter ultimately published messages.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder`：MP Reactive
    Streams Operators `PublisherBuilder`接口允许您从各种来源构建Reactive Streams `Publisher`并应用操作以转换/过滤最终发布的消息。'
- en: '`org.eclipse.microprofile.reactive.streams.operators.ProcessorBuilder`: The MP
    Reactive Streams Operators `ProcessorBuilder` interface allows you to build up
    a Reactive Streams `Processor` from various sources and apply operations to transform/filter
    ultimately published messages.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.eclipse.microprofile.reactive.streams.operators.ProcessorBuilder`：MP Reactive
    Streams Operators `ProcessorBuilder`接口允许您从各种来源构建Reactive Streams `Processor`并应用操作以转换/过滤最终发布的消息。'
- en: '`org.eclipse.microprofile.reactive.streams.operators.SubscriberBuilder`: The MP
    Reactive Streams Operators `ProcessorBuilder` interface allows you to build up
    a Reactive Streams `Subscriber` from various sources and apply operations to transform/filter
    ultimately published messages.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.eclipse.microprofile.reactive.streams.operators.SubscriberBuilder`：MP
    Reactive Streams Operators `ProcessorBuilder`接口允许您从各种来源构建Reactive Streams `Subscriber`并应用操作以转换/过滤最终发布的消息。'
- en: '`java.util.concurrent.CompletionStage`: This JDK concurrent `util` package
    interface defines a stage of computation that is typically asynchronous, and computes
    an action or value. `CompletionStage` can be combined so that a graph of stages
    may be executed to produce the final result.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent.CompletionStage`：这个JDK并发`util`包接口定义了一个通常是异步的计算阶段，并计算一个动作或值。`CompletionStage`可以组合，以便执行一系列阶段以产生最终结果。'
- en: '`org.eclipse.microprofile.reactive.messaging.Message<T>`: An MP-RM interface
    that provides a wrapper around the payload of type `T` and an `ack` method to
    acknowledge receipt of the message.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`org.eclipse.microprofile.reactive.messaging.Message<T>`：MP-RM接口，提供了围绕类型为`T`的有效载荷的包装器和一个`ack`方法来确认收到消息。'
- en: 'With these types defined, we can look at the various types of method that produce
    data by pushing messages onto outgoing channels that MP-RM supports. The publisher
    method types of methods all have an `@Outgoing("channel-name")` annotation and
    support signatures as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些定义的类型，我们可以看看MP-RM支持的通过将消息推送到传出通道来产生数据的各种方法类型。方法的发布者类型都有一个`@Outgoing("channel-name")`注解，并支持以下签名：
- en: '`Publisher<Message<T>> method()`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<Message<T>> method()`'
- en: '`Publisher<T> method()`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<T> method()`'
- en: '`PublisherBuilder<Message<T>> method()`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<Message<T>> method()`'
- en: '`PublisherBuilder<T> method()`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<T> method()`'
- en: '`T method()`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T method()`'
- en: '`CompletionStage<T> method()`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<T> method()`'
- en: 'Consumer methods all have an `@Incoming("channel-name")` annotation and support
    signatures as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者方法都有一个`@Incoming("channel-name")`注解，并支持以下签名：
- en: '`Subscriber<Message<T>> method()`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subscriber<Message<T>> method()`'
- en: '`Subscriber<T> method()`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subscriber<T> method()`'
- en: '`SubscriberBuilder<Message<T>>`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubscriberBuilder<Message<T>>`'
- en: '`SubscriberBuilder<T>`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubscriberBuilder<T>`'
- en: '`void method(Message<T> payload)`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void method(Message<T> payload)`'
- en: '`void method(T payload)`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void method(T payload)`'
- en: '`CompletionStage<?> method(Message<T> payload)`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<?> method(Message<T> payload)`'
- en: '`CompletionStage<?> method(T payload)`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<?> method(T payload)`'
- en: 'Methods that both consume and produce data are known as processors, and will
    have both an `@Incoming("channel-in")` and `@Outgoing("channel-out")` annotation.
    Supported signatures are as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 同时消耗和产生数据的方法被称为处理器，将具有`@Incoming("channel-in")`和`@Outgoing("channel-out")`注解。支持的签名如下：
- en: '`Processor<Message<I>, Message<O>> method()`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Processor<Message<I>, Message<O>> method()`'
- en: '`Processor<I, O> method();`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Processor<I, O> method();`'
- en: '`ProcessorBuilder<Message<I>, Message<O>>method()`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessorBuilder<Message<I>, Message<O>> method()`'
- en: '`ProcessorBuilder<I, O> method();`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessorBuilder<I, O> method();`'
- en: '`Publisher<Message<O>> method(Message<I> msg)`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<Message<O>> method(Message<I> msg)`'
- en: '`Publisher<O> method(I payload)`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<O> method(I payload)`'
- en: '`PublisherBuilder<Message<O>> method(Message<I> msg)`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<Message<O>> method(Message<I> msg)`'
- en: '`PublisherBuilder<O> method(I payload)`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<O> method(I payload)`'
- en: '`Message<O> method(Message<I> msg)`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message<O> method(Message<I> msg)`'
- en: '`O method(I payload)`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`O method(I payload)`'
- en: '`CompletionStage<Message<O>> method(Message<I> msg)`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<Message<O>> method(Message<I> msg)`'
- en: '`CompletionStage<O> method(I payload)`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<O> method(I payload)`'
- en: '`Publisher<Message<O>> method(Publisher<Message<I>> pub)`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<Message<O>> method(Publisher<Message<I>> pub)`'
- en: '`PublisherBuilder<Message<O>> method(PublisherBuilder<Message<I>> pub)`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<Message<O>> method(PublisherBuilder<Message<I>> pub)`'
- en: '`Publisher<O> method(Publisher<I> pub)`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<O> method(Publisher<I> pub)`'
- en: '`PublisherBuilder<O> method(PublisherBuilder<I> pub)`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<O> method(PublisherBuilder<I> pub)`'
- en: Now, we will look at some examples of using beans with these signatures to build
    up message processing chains.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看一些使用具有这些签名的bean来构建消息处理链的示例。
- en: MicroProfile Reactive Streams operators
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile响应式流操作符
- en: Reactive Streams requires more than just plumbing publishers to subscribers.
    Typically, a stream needs to be manipulated in some way, such as applying operations
    including `map`, `filter`, and `flatMap`. Neither Reactive Streams nor the JDK
    provide an API for performing these manipulations. Since users are not meant to
    implement Reactive Streams themselves, this means the only way to do these manipulations
    currently is to depend on a third-party library providing operators, such as Akka
    Streams, RxJava, or Reactor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式流需要的不仅仅是将发布者连接到订阅者。通常，流需要以某种方式进行操作，例如应用包括`map`，`filter`和`flatMap`在内的操作。Reactive
    Streams和JDK都没有提供执行这些操作的API。由于用户不打算自己实现Reactive Streams，这意味着目前执行这些操作的唯一方法是依赖于提供操作符的第三方库，例如Akka
    Streams，RxJava或Reactor。
- en: The MicroProfile Reactive Streams Operators API seeks to fill that gap so that
    MicroProfile application developers can manipulate Reactive Streams without bringing
    in a third-party dependency. ...
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile响应式流操作符API旨在填补这一空白，以便MicroProfile应用程序开发人员可以操作响应式流而无需引入第三方依赖。
- en: MicroProfile Context Propagation
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile上下文传播
- en: This specification, which sits outside the MicroProfile umbrella of platform
    release, is still in the proposed or draft state. We will discuss this specification
    in more detail in the *MicroProfile Future Developments* section later in this
    chapter, but we would like to give you a high-level introduction here.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范位于MicroProfile平台发布之外，仍处于提议或草案状态。我们将在本章后面的*MicroProfile未来发展*部分更详细地讨论这个规范，但我们想在这里给您一个高层次的介绍。
- en: The MicroProfile Context Propagation specification introduces APIs for propagating
    contexts across units of work that are thread-agnostic. It makes it possible to
    propagate context that was traditionally associated with the current thread across
    various types of units of work, such as `CompletionStage`, `CompletableFuture`,
    `Function`, and `Runnable`, regardless of which particular thread ends up executing
    them.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile上下文传播规范引入了在不受线程限制的工作单元之间传播上下文的API。它使得可以传播传统上与当前线程相关联的上下文，例如`CompletionStage`，`CompletableFuture`，`Function`和`Runnable`，无论最终执行它们的是哪个特定的线程。
- en: MicroProfile reactive messaging examples
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile响应式消息示例
- en: In this section, we will cover some examples of using MP-RM to create CDI beans
    that produce and consume messages.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些使用MP-RM创建CDI bean来生产和消费消息的示例。
- en: 'Let''s say you want a CDI bean to act as a source of a `Message<String>` such
    that whenever its `publishMessage(String)` method is called, an MP-RM message
    is posted to some MP-RM channel. To do this, we need to define a connector that
    bridges between the CDI bean and the MP-RM layer. An example of an incoming message
    connector that does this is shown in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望CDI bean充当`Message<String>`的来源，每当调用其`publishMessage(String)`方法时，都会将MP-RM消息发布到某个MP-RM通道。为此，我们需要定义一个连接器，用于在CDI
    bean和MP-RM层之间建立桥接。以下是一个执行此操作的传入消息连接器示例：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: MicroProfile future developments
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile未来发展
- en: As mentioned in [Chapter 2](0f9d569f-1ffb-4662-8cea-c8b230a4d627.xhtml), *Governance
    and Contributions*, new ideas brought to the Eclipse MicroProfile project are
    first tried in the MicroProfile sandbox following an implementation-first approach
    to innovation. The sandbox exercise gives the opportunity for the implementor
    and the community to discuss, analyze, and evaluate how this new idea fits in
    with the MicroProfile project. If, at the end of the sandbox exercise, the community
    deems that this new idea is worth adding to the project, a specific MicroProfile
    sub-project is created for it. The sub-project must issue at least one release
    before it can be considered for addition to a MicroProfile umbrella/platform release.
    At a very high-level, this is the process that new ideas and future developments
    follow under the MicroProfile project.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[第2章](0f9d569f-1ffb-4662-8cea-c8b230a4d627.xhtml)中提到的，*治理和贡献*，Eclipse MicroProfile项目中带来的新想法首先在MicroProfile沙箱中尝试，遵循创新的先实施方法。沙箱练习为实施者和社区提供了讨论、分析和评估这个新想法如何与MicroProfile项目相适应的机会。如果在沙箱练习结束时，社区认为这个新想法值得添加到项目中，将为其创建一个特定的MicroProfile子项目。在被考虑添加到MicroProfile总体/平台发布之前，子项目必须发布至少一个版本。在非常高的层面上，这是MicroProfile项目下新想法和未来发展遵循的过程。
- en: In the next sections, we will discuss two types of projects those globally that
    are currently MicroProfile sub-projects that presebtly sit outside the MicroProfile
    umbrella/platform release (think of these as projects that have already graduated
    out of the MicroProfile sandbox), and the ones that are still in the MicroProfile
    sandbox. Lastly, we will discuss the current relationship between Eclipse MicroProfile
    and Jakarta EE and how their roadmaps may or may not meet.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论两种类型的项目，全球范围内目前是MicroProfile子项目，目前位于MicroProfile总体/平台发布之外（将这些项目视为已经毕业离开MicroProfile沙箱的项目），以及仍在MicroProfile沙箱中的项目。最后，我们将讨论Eclipse
    MicroProfile和Jakarta EE之间的当前关系，以及它们的路线图可能会或可能不会满足。
- en: Projects outside the umbrella
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总体之外的项目
- en: 'In this section, we will cover projects that sit outside the Eclipse MicroProfile
    umbrella release, at the time of writing, of course. These are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些不属于Eclipse MicroProfile总体发布的项目，当然，目前是这样。具体如下：
- en: Reactive Streams Operators
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应流操作符
- en: Reactive Messaging
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式消息
- en: Long Running Actions
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间运行的操作
- en: Context Propagation
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文传播
- en: GraphQL
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL
- en: Reactive Streams Operators and Reactive Messaging projects were already discussed
    in the previous sections of this chapter, so in this section we will cover only
    Long Running Actions, Context Propagation, and GraphQL.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 反应流操作符和反应式消息项目已经在本章的前几节中讨论过，因此在本节中我们将只涵盖长时间运行的操作，上下文传播和GraphQL。
- en: Long Running Actions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 长时间运行的操作
- en: 'In a loosely-coupled service environment, the motivation behind the **Long
    Running Actions** (**LRA**) specification is to provide consistent outcomes by
    business processes comprised of calls to many microservices without the need to
    lock data. One way to think about LRA is as *transactions for microservices*.
    Examples of situations when you need LRA include the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在松散耦合的服务环境中，**长时间运行的操作**（LRA）规范的动机是在不锁定数据的情况下通过对许多微服务的调用组成的业务流程提供一致的结果。 LRA的一种思考方式是*微服务的事务*。需要LRA的情况包括以下情况：
- en: Ordering a book online will require the retirement of a book from the inventory,
    the processing of a payment, and finally shipping of the book. All these tasks
    need to happen atomically, in other words, they need to be processed all together,
    in that, if any of the tasks fail, then all tasks must be undone.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线订购一本书将需要从库存中退货一本书，处理付款，最后发货。所有这些任务都需要以原子方式发生，换句话说，它们需要一起处理，如果任何任务失败，则必须撤消所有任务。
- en: Making a flight reservation will require the removal of a seat from the airplane's
    list of available seats, the selection and assignment of a specific seat to the
    traveler, processing the payment, and the creation of a record locator. Again,
    all these tasks have to happen within the same long running action.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预订航班将需要从飞机的可用座位列表中删除一个座位，选择并分配一个特定的座位给旅客，处理付款，并创建一个记录定位器。同样，所有这些任务都必须在同一个长时间运行的操作中发生。
- en: Not only do the preceding examples have to happen atomically, but they also
    have to generate a result where the data is consistent, even if any of their intermediate
    steps failed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子不仅需要以原子方式发生，而且还需要生成一个结果，其中数据是一致的，即使它们的任何中间步骤失败。
- en: The current proposed solution for MicroProfile LRA has taken its inspiration
    from the *OASIS Web Services Composite Application Framework Technical Committee* ([https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=ws-caf](https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=ws-caf)),
    namely, the *Web Services **Long Running Action transaction model* ([https://www.oasis-open.org/committees/document.php?document_id=12794](https://www.oasis-open.org/committees/document.php?document_id=12794)),
    but has been updated to be more suited for use in microservice-based architectures.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile LRA的当前提议解决方案受到了*OASIS Web Services Composite Application Framework
    Technical Committee*（[https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=ws-caf](https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=ws-caf)）的启发，即*Web
    Services Long Running Action transaction model*（[https://www.oasis-open.org/committees/document.php?document_id=12794](https://www.oasis-open.org/committees/document.php?document_id=12794)），但已更新以更适合在基于微服务的架构中使用。
- en: For further information on the MicroProfile LRA specification, refer to [https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc](https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有关MicroProfile LRA规范的更多信息，请参阅[https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc](https://github.com/eclipse/microprofile-lra/blob/master/spec/src/main/asciidoc/microprofile-lra-spec.adoc)。
- en: 'The MicroProfile Long Running Actions specification model includes three main entities:
    compensators, a logical coordinator, and a client. A client can explicitly start
    a new LRA in two different ways:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile长时间运行操作规范模型包括三个主要实体：补偿者、逻辑协调器和客户端。客户端可以以两种不同的方式显式地启动新的LRA：
- en: Via an annotation, or
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过注释，或者
- en: Via an API call
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过API调用
- en: Either one creates a new LRA. If a service does something that may need to be
    later undone, then the client needs to register a compensator with the LRA. If
    the client chooses to close or cancel the LRA, the compensator will undo the work
    the service performed within the scope of the LRA or compensate for any uncompleted
    work.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要么创建一个新的LRA。如果服务执行的操作可能需要稍后撤消，那么客户端需要向LRA注册一个补偿者。如果客户端选择关闭或取消LRA，则补偿者将撤消服务在LRA范围内执行的工作，或者补偿任何未完成的工作。
- en: 'The following are globally some of the main LRA annotations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些主要的LRA注释：
- en: '`@LRA` controls the life cycle of an LRA.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@LRA`控制LRA的生命周期。'
- en: '`@Compensate` indicates that the method should be invoked if the LRA is canceled.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Compensate`表示如果LRA被取消，则应调用该方法。'
- en: '`@Complete` indicates that the method should be invoked if the LRA is closed.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Complete`表示如果LRA关闭，则应调用该方法。'
- en: '`@Forget` indicates that the method may release any resources that were allocated
    for this LRA.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Forget`表示该方法可能释放为此LRA分配的任何资源。'
- en: '`@Leave` indicates that this class is no longer interested in this LRA.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Leave`表示此类不再对此LRA感兴趣。'
- en: '`@Status` reports the status when the annotated method is invoked.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Status`在调用带注释的方法时报告状态。'
- en: You can use these annotations with JAX-RS and non-JAX-RS methods. In addition,
    this specification supports asynchronous and reactive features of JAX-RS, LRA
    nesting, and timeouts. Finally, it is worth mentioning that the LRA specification
    ensures atomicity and eventual consistency by placing certain requirements on
    the entities that participate in the protocol. As a MicroProfile project, the
    MicroProfile LRA specification, at the time of writing, is in a proposed or draft
    state.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在JAX-RS和非JAX-RS方法中使用这些注释。此外，该规范支持JAX-RS的异步和响应式特性，LRA嵌套和超时。最后，值得一提的是，LRA规范通过对参与协议的实体施加一定要求来确保原子性和最终一致性。作为MicroProfile项目，MicroProfile
    LRA规范在撰写本文时处于提议或草案状态。
- en: Context Propagation
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文传播
- en: The goal of the MicroProfile Context Propagation specification is to propagate
    context across units of work that are thread-agnostic. In a reactive model, the
    execution of logic is split into units of work that are chained together to assemble
    a reactive pipeline. Each unit of work executes within a context, which is often
    unpredictable and depends on the particular reactive engine being used. Some units
    might run with the context of a thread awaiting completion, or the context of
    a previous unit that completed and triggered the dependent unit, or with no context
    at all. The MicroProfile Context Propagation specification makes it possible for
    thread context propagation to easily be done in a type-safe manner, keeping boilerplate
    ...
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile上下文传播规范的目标是在与线程无关的工作单元之间传播上下文。在响应式模型中，逻辑的执行被分割成工作单元，这些工作单元被链接在一起以组装成一个响应式管道。每个工作单元在一个上下文中执行，这通常是不可预测的，并取决于所使用的特定响应式引擎。一些单元可能在等待完成的线程上下文中运行，或者在完成并触发依赖单元的上一个单元的上下文中运行，或者根本没有上下文。MicroProfile上下文传播规范使得线程上下文传播可以以类型安全的方式轻松完成，避免样板文件...
- en: GraphQL
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL
- en: GraphQL is an open source data query and manipulation language for APIs, and
    a runtime for fulfilling queries with existing data. It interprets strings from
    the client and returns data in an understandable, predictable, and predefined
    manner. GraphQL is an alternative to REST, though not necessarily a replacement. The
    goal of the MicroProfile GraphQL specification is to provide a set of APIs to
    enable users to quickly develop portable GraphQL-based applications in Java. As
    a MicroProfile project, the MicroProfile GraphQL specification is currently, at
    the time of writing, in a proposed or draft state.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL是用于API的开源数据查询和操作语言，以及用于使用现有数据满足查询的运行时。它解释来自客户端的字符串，并以可理解、可预测和预定义的方式返回数据。GraphQL是REST的一种替代方案，尽管不一定是替代品。MicroProfile
    GraphQL规范的目标是在Java中提供一组API，以便用户快速开发可移植的基于GraphQL的应用程序。作为MicroProfile项目，MicroProfile
    GraphQL规范目前在撰写本文时处于提议或草案状态。
- en: GraphQL is based on a Facebook specification. For more information on this, please
    refer to `https://graphql.github.io/graphql-spec`. A more general overview of
    GraphQL can be found on [https://graphql.org/](https://graphql.org/).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL基于Facebook的规范。有关更多信息，请参阅`https://graphql.github.io/graphql-spec`。有关GraphQL的更一般概述，请访问[https://graphql.org/](https://graphql.org/)。
- en: GraphQL and REST have many similarities and are both widely used in modern microservice-based applications.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL和REST有许多相似之处，并且在现代基于微服务的应用程序中都被广泛使用。
- en: Differences between GraphQL and REST
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL和REST之间的区别
- en: 'Here are the main differentiating features of GraphQL when compared to REST:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是GraphQL与REST相比的主要区别特征：
- en: '**Schema-driven**: The schema acts as a contract between the server and its
    clients.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于模式驱动**：模式充当服务器和其客户端之间的合同。'
- en: '**Single HTTP endpoint**: A single endpoint and access to data and operations
    are achieved through the query language.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一HTTP端点**：通过查询语言实现单一端点和对数据和操作的访问。'
- en: '**Flexible data retrieval**: Enables the client to select data in the response
    with a fine level of granularity, thereby avoiding over- or under-fetching data.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活的数据检索**：使客户端能够以细粒度选择响应中的数据，从而避免过度或不足获取数据。'
- en: '**Reduction of server requests**: The language allows the client to aggregate
    the expected data into a single request.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少服务器请求**：该语言允许客户端将预期数据聚合到单个请求中。'
- en: '**Easier version management**: Enables the creation of new data while deprecating
    old ones.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易的版本管理**：能够创建新数据同时废弃旧数据。'
- en: '**Partial results**: A result is made up of data and errors. Clients are responsible
    ...'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部分结果**：结果由数据和错误组成。客户端负责...'
- en: GraphQL and databases
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GraphQL和数据库
- en: GraphQL is not a database technology. Instead, it is a data query and manipulation
    tool for APIs and is agnostic to any database or storage technologies. However,
    it can be used in front of any backend and is capable of aggregating data from
    multiple backend data sources with a single API.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL不是一种数据库技术。相反，它是用于API的数据查询和操作工具，并且与任何数据库或存储技术无关。但是，它可以用在任何后端，并且能够通过单个API从多个后端数据源聚合数据。
- en: Projects in the sandbox
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 沙箱中的项目
- en: The MicroProfile Project sandbox is where the community can come up with ideas
    by trying out an implementation of features and capabilities to elicit feedback,
    discussion, and evaluation from members within the community with the goal of
    deciding whether or not the idea should become a new API/specification for the
    MicroProfile project.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile项目沙箱是社区可以通过尝试实现功能和能力来提出反馈、讨论和评估的地方，以决定该想法是否应成为MicroProfile项目的新API/规范。
- en: The MicroProfile sandbox is located at [https://github.com/eclipse/microprofile-sandbox](https://github.com/eclipse/microprofile-sandbox).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile沙箱位于[https://github.com/eclipse/microprofile-sandbox](https://github.com/eclipse/microprofile-sandbox)。
- en: Past project proposals that graduated from the sandbox into official MicroProfile
    projects were GraphQL and Reactive Streams Operators. At the time of writing,
    there is only one proposal project in the sandbox, Boost.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从沙箱毕业成为官方MicroProfile项目的过去项目提案包括GraphQL和Reactive Streams Operators。在撰写本文时，沙箱中只有一个提案项目，即Boost。
- en: MicroProfile Boost
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MicroProfile Boost
- en: At the time of writing, the MicroProfile Boost is under community evaluation
    in the MicroProfile sandbox. Boost is a Maven plugin that enhances builds for
    your MicroProfile applications.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，MicroProfile Boost正在MicroProfile沙箱中进行社区评估。Boost是一个增强您的MicroProfile应用程序构建的Maven插件。
- en: For more information on Boost, go to [https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/boost](https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/boost).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Boost的更多信息，请访问[https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/boost](https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/boost)。
- en: Boost defines Maven dependencies, known as **boosters**, for MicroProfile APIs,
    for example `mpConfig` for MicroProfile Config, as well as for Java EE APIs. In
    addition, it defines dependencies for the runtimes that implement the different
    MicroProfile APIs, for example `openliberty`. One more Boost-defined maven dependency
    specified as a BOM (Bill-of-Material) indicates the version of the MicroProfile
    umbrella project to use for the maven build with respect to the MicroProfile APIs.
    The BOM contents are managed by the plugin. As a user of Boost, you include these
    dependencies in your `pom.xml` file to ease the build process of your MicroProfile
    application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Boost为MicroProfile API定义了Maven依赖项，称为**boosters**，例如`mpConfig`用于MicroProfile
    Config，以及用于Java EE API。此外，它还为实现不同MicroProfile API的运行时定义了依赖项，例如`openliberty`。Boost定义的另一个Maven依赖项被指定为BOM（材料清单），指示要在Maven构建中使用MicroProfile总项目的版本。BOM内容由插件管理。作为Boost的用户，您将这些依赖项包含在您的`pom.xml`文件中，以简化MicroProfile应用程序的构建过程。
- en: Eclipse MicroProfile and Jakarta EE
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile和Jakarta EE
- en: 'What is the relationship between the Eclipse Jakarta Enterprise Java project
    and the Eclipse MicroProfile project? Short answer: it remains to be seen. Long
    answer: let''s begin.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse Jakarta Enterprise Java项目与Eclipse MicroProfile项目之间的关系是什么？简短回答：尚待观察。长答案：让我们开始吧。
- en: The Eclipse MicroProfile project was initiated to address a lack of progress
    in the Java EE specifications under the **Java Community Process** (**JCP**).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile项目是为了解决**Java社区流程**（**JCP**）下Java EE规范的进展不足而发起的。
- en: For more information on the Java Community Process, please visit `https://jcp.org/en/home/index`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Java社区流程的更多信息，请访问`https://jcp.org/en/home/index`。
- en: It has been over two years since the MicroProfile project moved to the Eclipse
    Foundation. Approximately one year later, Oracle announced its intention to move
    Java EE over to the Eclipse Foundation and rename it Jakarta EE. The move to Jakarta
    has been a long drawn-out process that is still ...
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 自MicroProfile项目移至Eclipse Foundation已经两年多了。大约一年后，Oracle宣布其打算将Java EE移至Eclipse
    Foundation并将其更名为Jakarta EE。迁移到Jakarta是一个漫长而拖沓的过程，仍在进行中…
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we learned about future developments in the MicroProfile specification
    with the Long Running Actions, Context Propagation, and GraphQL projects outside
    the umbrella release, and the Boost project that''s still in the MicroProfile
    sandbox. In addition, you learned about reactive messaging concepts, the MicroProfile
    reactive messaging architecture, and how to implement reactive microservices using
    Eclipse MicroProfile reactive constructs via code examples. You also gained some
    knowledge of the background of each of these projects, their capabilities, annotations,
    and code examples when applicable, as well as their current state. Lastly, we
    presented the relationship between two similar but different projects: Eclipse
    MicroProfile and Jakarta EE, and discussed how their possible relationship could
    evolve in the future.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了MicroProfile规范中未来发展的情况，包括长时间运行操作、上下文传播和GraphQL项目在总项目发布之外，以及仍在MicroProfile沙箱中的Boost项目。此外，您还了解了响应式消息传递概念、MicroProfile响应式消息传递架构，以及如何通过代码示例使用Eclipse
    MicroProfile响应式构造实现响应式微服务。您还了解了每个项目的背景、能力、注释和代码示例（如果适用），以及它们的当前状态。最后，我们介绍了两个相似但不同的项目之间的关系：Eclipse
    MicroProfile和Jakarta EE，并讨论了它们未来可能的关系如何发展。
- en: In the next chapter, we will learn about Eclipse MicroProfile in multi-cloud
    environments and deployments.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将了解Eclipse MicroProfile在多云环境和部署中的情况。
- en: Questions
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: If I have a source of messages, how do I integrate this into my MicroProfile
    applications?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我有消息来源，如何将其集成到我的MicroProfile应用程序中？
- en: Which of the existing MicroProfile specifications will MicroProfile Context
    Propagation best support?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MicroProfile上下文传播将最好支持现有的哪些MicroProfile规范？
- en: What are the current MicroProfile specifications that support reactive programming?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前支持响应式编程的MicroProfile规范是哪些？
- en: What are the MicroProfile specifications that currently sit outside the umbrella/platform
    MicroProfile release?
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前在总项目/平台MicroProfile发布之外的MicroProfile规范是哪些？
- en: What is the purpose of having a MicroProfile sandbox?
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拥有MicroProfile沙箱的目的是什么？
- en: What are the projects that currently sit in the MicroProfile sandbox?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前在MicroProfile沙箱中的项目是哪些？
- en: What is the current relationship between Eclipse MicroProfile and Jakarta EE?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile和Jakarta EE之间的当前关系是什么？
- en: What will the future relationship between Eclipse MicroProfile and Jakarta EE
    look like?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Eclipse MicroProfile和Jakarta EE之间的未来关系将是什么样的？
- en: Further reading
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For MicroProfile reactive messaging, the [http://reactivex.io/](http://reactivex.io/)
    site provides motivation, tutorials, language bindings, and more.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于MicroProfile响应式消息传递，[http://reactivex.io/](http://reactivex.io/)网站提供了动机、教程、语言绑定等。
- en: A good starting point for GraphQL is the [https://graphql.org/](https://graphql.org/)
    site, which provides more background on the motivation behind it, as well as many
    resources for exploring how to put it to use.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL的一个很好的起点是[https://graphql.org/](https://graphql.org/)网站，该网站提供了更多关于其背后动机的背景，以及许多资源来探索如何使用它。
