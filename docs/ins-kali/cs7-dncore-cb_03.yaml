- en: Object-Oriented Programming in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#中的面向对象编程
- en: 'This chapter will introduce you to the foundation of C# and **object-oriented
    programming** (**OOP**). In this chapter, you will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍C#和面向对象编程（OOP）的基础。在本章中，您将学习以下内容：
- en: Using inheritance in C#
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#中使用继承
- en: Using abstraction
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象
- en: Leveraging encapsulation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用封装
- en: Implementing polymorphism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现多态
- en: Single responsibility principle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Open/closed principle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Exception handling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'During your career as a creator of software, you will hear the term OOP many
    times. This design philosophy allows for objects to exist independently and can
    be reused by different sections of code. This is all made possible by what we
    refer to as the four pillars of OOP: inheritance, encapsulation, abstraction,
    and polymorphism.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在您作为软件创建者的职业生涯中，您会多次听到OOP这个术语。这种设计理念允许对象独立存在，并可以被代码的不同部分重复使用。这一切都是由我们所说的OOP的四大支柱所实现的：继承、封装、抽象和多态。
- en: 'In order to grasp this, you need to start thinking of objects (which are basically
    instantiated classes) that perform a specific task. Classes need to adhere to
    the SOLID design principle. This principle is explained here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，您需要开始思考执行特定任务的对象（基本上是实例化的类）。类需要遵循SOLID设计原则。这个原则在这里解释：
- en: Single responsibility principle (SRP)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）
- en: Open/closed principle
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Liskov substitution principle (LSP)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 里斯科夫替换原则（LSP）
- en: Interface segregation principle
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: Dependency inversion principle
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖反转原则
- en: Let's start off with an explanation of the four pillars of OOP, after which
    we will take a look at the SOLID principle in more detail.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从解释OOP的四大支柱开始，然后我们将更详细地看一下SOLID原则。
- en: Using inheritance in C#
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中使用继承
- en: In today's world, inheritance is usually associated with the end of things.
    In OOP, however, it is associated with the beginning of something new and better.
    When we create a new class, we can take an already existing class and inherit
    it on our new class. This means that our new object will have all the features
    of the inherited class as well as the additional features added to the new class.
    This is at the root of inheritance. We call a class that inherits from another
    a derived class.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的世界中，继承通常与事物的结束联系在一起。然而，在OOP中，它与新事物的开始和改进联系在一起。当我们创建一个新类时，我们可以取一个已经存在的类，并在我们的新类上继承它。这意味着我们的新对象将具有继承类的所有特性，以及添加到新类的附加特性。这就是继承的根本。我们称从另一个类继承的类为派生类。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: To illustrate the concept of inheritance, we will create a few classes that
    inherit from another to form new, more feature-rich objects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明继承的概念，我们将创建一些从另一个类继承的类，以形成新的、更具特色的对象。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Create a new console application and add a class called `SpaceShip` to your
    console application.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的控制台应用程序，并在其中添加一个名为`SpaceShip`的类。
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our `SpaceShip` class will contain a few methods that describe the basics of
    a spaceship. Go ahead and add these methods to your `SpaceShip` class:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`SpaceShip`类将包含一些描述飞船基本情况的方法。继续将这些方法添加到您的`SpaceShip`类中：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Because the `SpaceShip` class forms part of all other intergalactic vessels,
    it becomes the blueprint for every other vessel.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`SpaceShip`类是所有其他星际飞船的一部分，它成为了每艘其他飞船的蓝图。
- en: 'Next, we want to create a `Destroyer` class. To accomplish this, we will create
    a `Destroyer` class and use a colon after the class name to indicate that we want
    to inherit from another class (the `SpaceShip` class). Therefore, the following
    needs to be added when creating the `Destroyer` class:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想创建一个`Destroyer`类。为了实现这一点，我们将创建一个`Destroyer`类，并在类名后使用冒号表示我们想要从另一个类（`SpaceShip`类）继承。因此，在创建`Destroyer`类时需要添加以下内容：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can also say that the `Destroyer` class is derived from the `SpaceShip` class.
    The `SpaceShip` class is therefore the base class of all other intergalactic vessels.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以说`Destroyer`类是从`SpaceShip`类派生的。因此，`SpaceShip`类是所有其他星际飞船的基类。
- en: 'Next, add a few methods to the `Destroyer` class that are unique to a destroyer.
    These methods belong only to the `Destroyer` class and not to the `SpaceShip`
    class:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向`Destroyer`类添加一些仅适用于驱逐舰的方法。这些方法仅属于`Destroyer`类，而不属于`SpaceShip`类：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, create a third class called `Annihilator`. This is the most powerful
    intergalactic vessel and is used to wage war on planets. Let the `Annihilator` class
    inherit from the `Destroyer` class by creating the class and marking it derived
    from the `Destroyer` class as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个名为`Annihilator`的第三个类。这是最强大的星际飞船，用于对抗行星。通过创建该类并标记为从`Destroyer`类派生的类，让`Annihilator`类继承`Destroyer`类：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, add a few methods to the `Annihilator` class that only belong to this
    type of `SpaceShip` class:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，向`Annihilator`类添加一些仅属于这种`SpaceShip`类的方法：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What we see now is that when we create a new instance of the `SpaceShip` class
    in our console application, only the methods defined in that class are available
    to us. This is because the `SpaceShip` class does not inherit from any other classes:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们看到，当我们在控制台应用程序中创建`SpaceShip`类的新实例时，我们只能使用该类中定义的方法。这是因为`SpaceShip`类没有继承自其他类：
- en: '![](img/B06434_03_04.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_04.png)'
- en: 'Go ahead and create the `SpaceShip` class with its methods in the console application:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续在控制台应用程序中创建`SpaceShip`类及其方法：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You will see that these are the only methods available to us when instantiating
    a new instance of this class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化这个类的新实例时，您会看到这些是我们唯一可用的方法。
- en: 'Next, create a new instance of the `Destroyer` class. You will notice that
    the `Destroyer` class contains more methods than what we defined when we created
    the class. This is because the `Destroyer` class is inheriting the `SpaceShip`
    class and therefore inherits the methods of the `SpaceShip` class:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`Destroyer`类中创建一个新实例。您会注意到`Destroyer`类包含的方法比我们在创建类时定义的要多。这是因为`Destroyer`类继承了`SpaceShip`类，因此继承了`SpaceShip`类的方法：
- en: '![](img/B06434_03_05.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_05.png)'
- en: 'Go ahead and create the `Destroyer` class with all its methods in the console
    application:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中创建`Destroyer`类及其所有方法：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, create a new instance of the `Annihilator` class. This class contains
    all the methods of the `Destroyer` class as well as the methods from the `SpaceShip`
    class. This is because `Annihilator` inherits from the `Destroyer`, which, in
    turn, inherits from `SpaceShip`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建`Annihilator`类的新实例。这个类包含了`Destroyer`类的所有方法，以及`SpaceShip`类的方法。这是因为`Annihilator`继承自`Destroyer`，而`Destroyer`又继承自`SpaceShip`：
- en: '![](img/B06434_03_06.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_06.png)'
- en: 'Go ahead and create the `Annihilator` class with all its methods in the console
    application:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中创建`Annihilator`类及其所有方法：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: We can see that inheritance allows us to easily extend our classes by reusing
    functionality that already exists within another class created earlier. You also
    need to be aware though that any changes to the `SpaceShip` class will be inherited,
    all the way up to the top-most derived class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到继承允许我们通过重用先前创建的另一个类中已经存在的功能来轻松扩展我们的类。但是需要注意的是，对`SpaceShip`类的任何更改都将被继承，一直到最顶层的派生类。
- en: Inheritance is a very powerful feature of C# that allows developers to write
    less code, and reuse working and tested methods.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是C#的一个非常强大的特性，它允许开发人员编写更少的代码，并重用工作和经过测试的方法。
- en: Using abstraction
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用抽象
- en: With abstraction, we take from the object we want to create the basic functionality
    that all objects derived from the abstracted object must have. To explain this
    in simple terms, we abstract the common functionality and put it in a single class
    that will be used to provide this shared functionality to all classes that inherit
    from it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过抽象，我们从我们想要创建的对象中提取出所有派生对象必须具有的基本功能。简单来说，我们将共同功能抽象出来，放入一个单独的类中，用于为所有继承自它的类提供这些共享功能。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To explain abstraction, we will use abstract classes. Imagine that you are dealing
    with trainee space astronauts who need to progress through the ranks as they get
    trained. The truth is that once you as trainee learn a new skill, that skill is
    learned and will remain with you even though you learn more advanced ways to do
    things. You must also implement all the previous skills learned in the new object
    you create. Abstract classes demonstrate this concept very nicely.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释抽象，我们将使用抽象类。想象一下，你正在处理需要通过训练逐渐晋升的实习太空宇航员。事实上，一旦你作为实习生学会了一项新技能，那项技能就会被学会，并且会一直保留在你身上，即使你学会了更高级的做事方式。你还必须在你创建的新对象中实现所有之前学到的技能。抽象类非常好地展示了这个概念。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create an abstract class called `SpaceCadet`. This is the first type of astronaut
    you can get when starting with training. The abstract class and its members are
    defined using the `abstract` keyword. A thing to note is that abstract classes
    cannot be instantiated. The members represent the skills that `SpaceCadet` will
    have, such as negotiation and basic weapons training:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SpaceCadet`的抽象类。这是在开始训练时可以获得的第一种宇航员类型。使用`abstract`关键字定义抽象类及其成员。需要注意的是，抽象类不能被实例化。成员代表`SpaceCadet`将拥有的技能，比如谈判和基本武器训练。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, create another abstract class called `SpacePrivate`. This abstract class
    inherits from the `SpaceCadet` abstract class. What we are basically saying is
    that when a space cadet is trained as a space private, they will still have all
    the skills learned as a space cadet:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建另一个名为`SpacePrivate`的抽象类。这个抽象类继承自`SpaceCadet`抽象类。基本上，我们要表达的是，当一个太空学员被训练成为太空士兵时，他们仍然会拥有作为太空学员学到的所有技能：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To demonstrate this, create a class called `LabResearcher` and inherit the
    `SpaceCadet` abstract class. Inheriting from the abstract class is done by defining
    a colon and abstract class name after the newly created class name. This tells
    the compiler that the `LabResearcher` class inherits from the `SpaceCadet` class:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示这一点，创建一个名为`LabResearcher`的类，并继承`SpaceCadet`抽象类。通过在新创建的类名后定义冒号和抽象类名，来继承抽象类。这告诉编译器`LabResearcher`类继承自`SpaceCadet`类：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Because we are inheriting an abstract class, the compiler will underline the
    `LabResearcher` class name to warn us that the derived class does not implement
    any of the methods in the `SpaceCadet` abstract class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们继承了一个抽象类，编译器会在`LabResearcher`类名下划线，警告我们派生类没有实现`SpaceCadet`抽象类中的任何方法。
- en: 'If you hover your mouse over the squiggly line, you will see that the lightbulb
    tip provides us with the issues discovered:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将鼠标悬停在波浪线上，你会发现灯泡提示会告诉我们发现的问题：
- en: '![](img/B06434_03_09.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_09.png)'
- en: 'Visual Studio does a great job of providing a solution to the issues discovered.
    By typing *Ctrl* + *.* (control key and period), you can let Visual Studio show
    you some potential fixes (in this case, only one fix) for the issues identified:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio在发现的问题上提供了一个很好的解决方案。通过输入*Ctrl* + *.* (控制键和句点)，你可以让Visual Studio显示一些潜在的修复方法（在这种情况下，只有一个修复方法）：
- en: '![](img/B06434_03_10.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_10.png)'
- en: 'After Visual Studio has added the required methods, you will see that these
    are the same methods defined in the `SpaceCadet` abstract class. Abstract classes,
    therefore, require the classes inheriting from the abstract class to implement
    the methods defined in the abstract class. You will also notice that the methods
    added to the `LabResearcher` class contain no implementation and will throw an
    exception if used as is:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio添加了所需的方法之后，您会发现这些方法与`SpaceCadet`抽象类中定义的方法相同。因此，抽象类要求从抽象类继承的类实现抽象类中定义的方法。您还会注意到添加到`LabResearcher`类中的方法不包含任何实现，如果按原样使用，将会抛出异常：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Next, create a class called `PlanetExplorer` and make this class inherit from
    the `SpacePrivate` abstract class. You will remember that the `SpacePrivate` abstract
    class inherited from the `SpaceCadet` abstract class:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`PlanetExplorer`的类，并使该类继承自`SpacePrivate`抽象类。您会记得`SpacePrivate`抽象类继承自`SpaceCadet`抽象类：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Visual Studio will once again warn you that your new class does not implement
    the methods of the abstract class that you are inheriting from. Here, however,
    you will notice that the lightbulb tip informs you that you are not implementing
    any of the methods in the `SpacePrivate` and `SpaceCadet` abstract classes. This
    is because the `SpacePrivate` abstract class is inheriting from the `SpaceCadet`
    abstract class:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio将再次警告您，您的新类没有实现继承的抽象类的方法。然而，在这里，您会注意到灯泡提示通知您，您没有实现`SpacePrivate`和`SpaceCadet`抽象类中的任何方法。这是因为`SpacePrivate`抽象类继承自`SpaceCadet`抽象类：
- en: '![](img/B06434_03_11.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_11.png)'
- en: As before, to fix the issues identified, type *Ctrl* + *.* (control key and
    period) and let Visual Studio show you some potential fixes (in this case, only
    one fix) for the issues identified.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与以前一样，要解决识别出的问题，输入*Ctrl* + *.*（控制键和句点），让Visual Studio显示一些潜在的修复方法（在这种情况下，只有一个修复方法）。
- en: 'After the fixes have been added to your code, you will see that the `PlanetExplorer`
    class contains all the methods in the `SpacePrivate` and `SpaceCadet` abstract
    classes:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中添加修复后，您会发现`PlanetExplorer`类包含`SpacePrivate`和`SpaceCadet`抽象类中的所有方法：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Abstraction has allowed us to define a common set of functionality that is to
    be shared among all the classes that derive from the abstract classes. The difference
    between inheriting from the abstract class and a normal class is that with an
    abstract class, you have to implement all the methods defined in that abstract
    class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象化使我们能够定义一组共享的功能，这些功能将在所有从抽象类派生的类之间共享。从抽象类继承和从普通类继承的区别在于，使用抽象类，您必须实现该抽象类中定义的所有方法。
- en: This makes the class easy to version and change. If you need to add new functionality,
    you can do so by adding that functionality to the abstract class without breaking
    any of the existing code. Visual Studio will require that all inherited classes
    implement the new method defined in the abstract class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得类易于版本控制和更改。如果需要添加新功能，可以通过将该功能添加到抽象类中而不破坏任何现有代码来实现。Visual Studio将要求所有继承类实现抽象类中定义的新方法。
- en: You can, therefore, be assured that the change applied will be implemented in
    all your classes that derive from the abstract classes in your code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以放心，应用的更改将在您代码中从抽象类派生的所有类中实现。
- en: Leveraging encapsulation
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用封装
- en: 'What is encapsulation? Simply put, it is hiding the inner workings of a class
    that aren''t necessary for the implementation of that class. Think of encapsulation
    as follows: most people who own a car know that it runs on gas- they don''t need
    to know the inner working of an internal combustion engine to be able to use a
    car. They only need to know that they need to fill it up with gas when it is close
    to empty and that they need to check the oil and tyre pressure. Even then, it
    is usually not done by the car owner. This is true for classes and encapsulation.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是什么？简单来说，它是隐藏类的内部工作，这些内部工作对于该类的实现并不必要。将封装视为以下内容：拥有汽车的大多数人知道汽车是用汽油驱动的-他们不需要知道内燃机的内部工作就能使用汽车。他们只需要知道当汽车快没油时需要加油，以及需要检查机油和轮胎气压。即使这样，通常也不是由汽车所有者来做。这对于类和封装来说也是如此。
- en: The owner of the class is the one who uses it. The inner workings of that class
    need not be exposed to the developer using the class. The class is, therefore,
    like a black box. You know that the class will be consistent in its functionality,
    given the correct set of parameters. How exactly the class gets to the output
    is of no concern to the developer as long as the input is correct.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 类的所有者是使用它的人。该类的内部工作不需要暴露给使用该类的开发人员。因此，该类就像一个黑匣子。只要输入正确，开发人员就知道该类的功能是一致的。开发人员并不关心类如何得到输出，只要输入正确即可。
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: To illustrate the concept of encapsulation, we will create a class that is somewhat
    complex in its inner working. We need to calculate the **thrust-to-weight ratio **(**TWR**)
    of a space shuttle to determine whether it will be able to take off vertically.
    It needs to exert more thrust than its weight to counteract gravity and get into
    a stable orbit. This also depends on which planet the shuttle takes off, because
    different planets exert different gravitational forces on objects on their surface.
    In simple terms, the TWR must be greater than one.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明封装的概念，我们将创建一个在内部工作上有些复杂的类。我们需要计算太空飞船的**推重比**（**TWR**），以确定它是否能够垂直起飞。它需要施加比自身重量更大的推力来抵消重力并进入稳定轨道。这也取决于太空飞船从哪个行星起飞，因为不同的行星对其表面上的物体施加不同的重力。简单来说，推重比必须大于一。
- en: How to do it...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new class called `LaunchSuttle`. Then, add the following private variables
    to the class for engine thrust, the mass of the shuttle, the local gravitational
    acceleration, the constant values for the gravity of the Earth, Moon, and Mars
    (these are constants because they will never change), the universal gravitational
    constant, and an enumerator for the planet we are dealing with:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`LaunchSuttle`的新类。然后，向该类添加以下私有变量，用于引擎推力、航天飞机的质量、当地的重力加速度、地球、月球和火星的重力常数（这些是常数，因为它们永远不会改变）、宇宙引力常数，以及用于处理的行星的枚举器：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To our class, we will add three overloaded constructors that are essential to
    perform the calculation of the TWR based on the known facts at the time of instantiation
    (we assume that we will always know the engine thrust capability and mass of the
    shuttle). We will pass the gravitational acceleration for the first constructor.
    This is useful if we know beforehand what that value will be. For example, the
    gravitational acceleration of the Earth is 9.81 m/s².
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的类，我们将添加三个重载的构造函数，这些函数对于根据实例化时的已知事实进行TWR计算至关重要（我们假设我们将始终知道发动机推力能力和航天飞机的质量）。我们将为第一个构造函数传递重力加速度。如果我们事先知道该值，这将非常有用。例如，地球的重力加速度为9.81
    m/s²。
- en: The second constructor will use the `Planet` enumerator to calculate the TWR
    that uses the constant variable values.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数将使用`Planet`枚举器来计算使用常量变量值的TWR。
- en: 'The third constructor will use the radius and mass of the planet to calculate
    the gravitational acceleration, when those values are known, to return the TWR:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个构造函数将使用行星的半径和质量来计算重力加速度，当这些值已知时，以返回TWR：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In order to use the second overloaded constructor that passes the `Planet`
    enumerator as a parameter to the class, we need to create another method that
    has been scoped as `private` to calculate the gravitational acceleration. We also
    need to set the `_LocalGravitationalAcceleration` variable to the specific constant
    that matches the enumerator value. This method is something that the user of the
    class does not need to see in order to use the class. It is, therefore, scoped
    as `private` in order to hide that functionality from the user:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用第二个重载的构造函数，将`Planet`枚举器作为参数传递给类，我们需要创建另一个方法，将其范围设置为`private`，以计算重力加速度。我们还需要将`_LocalGravitationalAcceleration`变量设置为与枚举器值匹配的特定常数。这个方法是类的用户不需要看到的，以便使用类。因此，它被设置为`private`，以隐藏用户的功能：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Of the following methods, only one is defined as public and will, therefore,
    be visible to the user of the class. Create the private methods to set the universal
    gravitational constant and to calculate the TWR and the gravitational acceleration.
    These are all scoped as private, because the developer does not need to know what
    these methods do in order to use the class:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下方法中，只有一个被定义为公共的，因此对类的用户可见。创建私有方法来设置通用引力常数，并计算TWR和重力加速度。这些都被设置为私有，因为开发人员不需要知道这些方法的功能就能使用类：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, in your console application, create the following variables with their
    known values:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在您的控制台应用程序中，创建以下变量及其已知的值：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a new instance of the `LaunchShuttle` class and pass it the values needed
    to calculate the TWR:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`LaunchShuttle`类的新实例，并传递需要计算TWR的值：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When you use the dot operator on the `NasaShuttle1` variable, you will notice
    that the IntelliSense only shows the `TWR` method. The class exposes nothing of
    the inner workings of how it gets to the calculated TWR value. The only thing
    that the developer knows is that the `LaunchShuttle` class will consistently return
    the correct TWR value, given the same input parameters:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您在`NasaShuttle1`变量上使用点运算符时，您会注意到IntelliSense只显示`TWR`方法。该类不会暴露出如何计算得到TWR值的内部工作方式。开发人员唯一知道的是，`LaunchShuttle`类将始终返回正确的TWR值，给定相同的输入参数：
- en: '![](img/B06434_03_13.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_13.png)'
- en: 'To test this, create two more instances of the `LaunchShuttle` class and call
    a different constructor each time:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试这一点，创建`LaunchShuttle`类的另外两个实例，并每次调用不同的构造函数：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you run your console application, you will see that the same value is returned
    for the TWR. The value indicates that a shuttle weighing 16.12 tons with a rocket
    that puts out 220 kilonewtons of thrust will be able to lift off the surface of
    the Earth (if only just):'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果运行您的控制台应用程序，您会看到TWR返回相同的值。该值表明，一个重16.12吨的航天飞机，配备产生220千牛的推力的火箭，将能够从地球表面起飞（即使只是刚刚）：
- en: '![](img/B06434_03_14.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_14.png)'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '工作原理... '
- en: 'The class uses the scoping rules to hide certain functionality inside the class
    from the developer using the class. As mentioned earlier, the developer does not
    need to know how the calculations are done to return the value for the TWR. This
    all aids in making the class more useful and easy to implement. Here is a list
    of the various scopes available in C# along with their uses:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用作用域规则，将类内部的某些功能隐藏在开发人员使用类时。如前所述，开发人员不需要知道如何进行计算以返回TWR值。所有这些都有助于使类更有用且易于实现。以下是C#中可用的各种作用域及其用途的列表：
- en: '`Public`: This is used with variables, properties, types, and methods and is
    visible anywhere.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Public`：这用于变量、属性、类型和方法，可在任何地方可见。'
- en: '`Private`: This is used with variables, properties, types, and methods and
    is visible only in the block where they are defined.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Private`：这用于变量、属性、类型和方法，仅在定义它们的块中可见。'
- en: '`Protected`: This is used with variables, properties, and methods. Don''t think
    of this in terms of public or private. The protected scope is only visible inside
    the class in which it is used as well as in any inherited classes.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Protected`：这用于变量、属性和方法。不要将其视为公共或私有。受保护的范围仅在使用它的类内部可见，以及在任何继承的类中可见。'
- en: '`Friend`: This is used with variables, properties, and methods and can only
    be used by code in the same project or assembly.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Friend`：这用于变量、属性和方法，只能被同一项目或程序集中的代码使用。'
- en: '`ProtectedFriend`: This is used with variables, properties, and methods and
    is a combination (as the name suggests) of the protected and friend scopes.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProtectedFriend`：这用于变量、属性和方法，是受保护和友元范围的组合（正如名称所示）。'
- en: Implementing polymorphism
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现多态性
- en: Polymorphism is a concept that is quite easy to grasp once you have looked at
    and understood the other pillars of OOP. Polymorphism literally means that something
    can have many forms. This means that from a single interface, you can create multiple
    implementations thereof.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性是一个概念，一旦您查看并理解了面向对象编程的其他支柱，就会很容易理解。多态性字面上意味着某物可以有多种形式。这意味着从单个接口，您可以创建多个实现。
- en: There are two subsections to this, namely, static and dynamic polymorphism.
    With **static polymorphism**, you are dealing with the overloading of methods
    and functions. You can use the same method, but perform many different tasks.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这有两个小节，即静态和动态多态性。通过**静态多态性**，您正在处理方法和函数的重载。您可以使用相同的方法，但执行许多不同的任务。
- en: With **dynamic polymorphism**, you are dealing with the creation and implementation
    of abstract classes. These abstract classes act as a blueprint that tells you
    what a derived class should implement. The following section looks at both.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**动态多态性**，您正在处理抽象类的创建和实现。这些抽象类充当了告诉您派生类应该实现什么的蓝图。接下来的部分将同时查看这两者。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will begin by illustrating the use of an abstract class, which is an example
    of dynamic polymorphism. We will then create overloaded constructors as an example
    of static polymorphism.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先说明抽象类的用法，这是动态多态性的一个例子。然后，我们将创建重载构造函数作为静态多态性的一个例子。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create an abstract class called `Shuttle` and give it a member called `TWR`,
    which is the calculation of the TWR of the shuttle:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Shuttle`的抽象类，并给它一个名为`TWR`的成员，这是对航天飞机的推重比进行计算：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, create a class called `NasaShuttle` and have it inherit from the abstract
    class `Shuttle` by putting the abstract class name after a colon at the end of
    the `NasaShuttle` class declaration:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`NasaShuttle`的类，并让它继承自抽象类`Shuttle`，方法是在`NasaShuttle`类声明的末尾冒号后放置抽象类名称：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Visual Studio will underline the `NasaShuttle` class because you have told
    the compiler that the class inherits from an abstract class, but you have not
    yet implemented the members of that abstract class:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio会下划线标记`NasaShuttle`类，因为您已经告诉编译器该类继承自抽象类，但尚未实现该抽象类的成员：
- en: '![](img/B06434_03_15.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_15.png)'
- en: 'To fix the issues identified, type *Ctrl* + *.* (control key and period) and
    let Visual Studio show you some potential fixes (in this case, only one fix) for
    the issues identified:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解决识别出的问题，请键入*Ctrl* + *.*（控制键和句点），让Visual Studio为您显示一些潜在的修复方法（在这种情况下，只有一个修复方法）：
- en: '![](img/B06434_03_16.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_16.png)'
- en: 'Visual Studio then adds the missing implementation to your `NasaShuttle` class.
    By default, it will add it as not implemented, because you are required to provide
    implementation for the abstract member you overrode in the abstract class:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，Visual Studio会向`NasaShuttle`类添加缺少的实现。默认情况下，它将添加为未实现，因为您需要为抽象类中覆盖的抽象成员提供实现：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create another class called `RoscosmosShuttle` and inherit from the same `Shuttle`
    abstract class:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`RoscosmosShuttle`的类，并从相同的`Shuttle`抽象类继承：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As before, Visual Studio will underline the `RoscosmosShuttle` class because
    you have told the compiler that the class inherits from an abstract class, but
    you have not yet implemented the members of that abstract class.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与以前一样，Visual Studio会下划线标记`RoscosmosShuttle`类，因为您已经告诉编译器该类继承自抽象类，但尚未实现该抽象类的成员。
- en: To fix the issues identified, type *Ctrl* + *.* (control key and period) and
    let Visual Studio show you some potential fixes (in this case, only one fix) for
    the issues identified.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解决识别出的问题，请键入*Ctrl* + *.*（控制键和句点），让Visual Studio为您显示一些潜在的修复方法（在这种情况下，只有一个修复方法）。
- en: 'The overridden method is then added to the `RoscosmosShuttle` class as not
    implemented. You have just seen an example of dynamic polymorphism in action:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，重写的方法将作为未实现添加到`RoscosmosShuttle`类中。您刚刚看到了动态多态性的一个示例：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To see an example of static polymorphism, create the following overloaded constructor
    for `NasaShuttle`. The constructor name stays the same, but the signature of the
    constructor changes, which makes it overloaded:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看静态多态性的示例，请为`NasaShuttle`创建以下重载构造函数。构造函数名称保持不变，但构造函数的签名发生变化，这使其成为重载：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Polymorphism is something you will easily be using already by simply applying
    good object-oriented principles to the design of your classes. With the abstract
    `Shuttle` class, we saw that the class took on the shape of the `NasaShuttle` class
    and the `RoscosmosShuttle` class when it was used to derive those new classes
    from its abstraction. The constructor of the `NasaShuttle` class was then overridden
    to provide the same method name, but implemented using different signatures.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性是您通过将良好的面向对象原则应用于类的设计而已经在使用的东西。通过抽象的`Shuttle`类，我们看到该类在用于从其抽象中派生这些新类时，采用了`NasaShuttle`类和`RoscosmosShuttle`类的形式。然后，`NasaShuttle`类的构造函数被覆盖，以提供相同的方法名称，但使用不同的签名进行实现。
- en: This is at the heart of polymorphism. Most likely, you have been using it without
    knowing about it.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是多态性的核心。很可能，您一直在使用它，却不知道它。
- en: Single responsibility principle
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: When talking about SOLID principles, we will start off with the **single responsibility
    principle** (**SRP**). Here, we are actually saying that a class has a specific
    task that it needs to fulfill and it should not do anything else.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论SOLID原则时，我们将从**单一职责原则**（**SRP**）开始。在这里，我们实际上是在说一个类有一个特定的任务需要完成，不应该做其他任何事情。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will create a new class and write code to log an error to the database when
    an exception is thrown on adding more troops to the star ship, causing it to be
    over capacity. For this recipe, ensure that you have added `using System.Data;`
    and `using System.Data.SqlClient;` namespaces to your application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当向星际飞船添加更多的部队时引发异常，导致其超载时，您将创建一个新的类并编写代码将错误记录到数据库中。对于此示例，请确保已将`using System.Data;`和`using
    System.Data.SqlClient;`命名空间添加到您的应用程序中。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new class called `StarShip`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`StarShip`的新类：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To your class, add a new method that will set the maximum troop capacity of
    the `StarShip` class:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向您的类中添加一个新方法，该方法将设置`StarShip`类的最大部队容量：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Inside this method, add a `trycatch` clause that will attempt to set the maximum
    troop capacity, but for some reason, it will fail. Upon failure, it will write
    the error to the log table inside the database:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，添加一个`trycatch`子句，将尝试设置最大的部队容量，但由于某种原因，它将失败。失败时，它将错误写入数据库内的日志表：
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you have code that looks like the preceding one, you are in contravention
    of the SRP. The `StarShip` class is no longer responsible for just itself and
    things that have to do with star ships. It now has to fulfill the role of logging
    errors to the database too. You see the problem here is that the database-logging
    code does not belong in the `catch` clause of the `SetMaximumTroopCapacity` method.
    A better approach would be to create a separate `DatabaseLogging` class with methods
    to create connections and write exceptions to the appropriate log table. You will
    also find that you are going to have to write that logging code in multiple places
    (in every `catch` clause). If you are finding that you are repeating code (by
    copying and pasting from other areas), you probably need to put that code into
    a common class, and you have likely broken the SRP rule.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的代码看起来像前面的代码，那么您就违反了SRP。`StarShip`类不再仅负责自身和与星际飞船有关的事物。它现在还必须履行将错误记录到数据库的角色。您在这里看到的问题是数据库记录代码不属于`SetMaximumTroopCapacity`方法的`catch`子句。更好的方法是创建一个单独的`DatabaseLogging`类，其中包含创建连接和将异常写入适当日志表的方法。您还会发现您将不得不在多个地方编写该记录代码（在每个`catch`子句中）。如果您发现自己重复编写代码（通过从其他地方复制和粘贴），那么您可能需要将该代码放入一个公共类中，并且您可能已经违反了SRP规则。
- en: Open/closed principle
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则
- en: When creating classes, we need to ensure that the class prohibits any breaking
    modifications by needing to change internal code. We say that such a class is
    closed. If we need to change it somehow, we can do so by extending the class.
    This extensibility is where we say that the class is open for extensions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建类时，我们需要确保该类通过需要更改内部代码来禁止任何破坏性修改。我们说这样的类是封闭的。如果我们需要以某种方式更改它，我们可以通过扩展类来实现。这种可扩展性是我们说类是开放的扩展。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will create a class that determines the skills of a trooper by looking at
    the class of trooper. We will show you the way many developers create such a class
    and the way it can be created using the open/closed principle.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您将创建一个类，通过查看trooper的类来确定trooper的技能。我们将向您展示许多开发人员创建这样一个类的方式，以及如何使用开闭原则创建它。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a class called `StarTrooper`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`StarTrooper`的类：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To this class, add an enumerator called `TrooperClass` to identify the type
    of trooper we want to return the skills of. Also, create a `List<string>` variable
    to contain the skills of the specific trooper class. Finally, create a method
    called `GetSkills` that returns the specific set of skills for the given trooper
    class.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中，添加一个名为`TrooperClass`的枚举器，以标识我们想要返回技能的trooper类型。还要创建一个`List<string>`变量，以包含特定trooper类的技能。最后，创建一个名为`GetSkills`的方法，返回给定trooper类的特定技能集。
- en: The class is quite straightforward, but the implementation of the code is something
    we see a lot. Sometimes, instead of a `switch` statement, you will see a whole
    lot of `if...else` statements. While the functionality of the code is clear, it
    is not easy to add another class of trooper to the `StarTrooper` class without
    changing code. Assume that you now have to add an additional `Engineer` class
    to the `StarTrooper` class. You would have to modify the `TrooperClass` enumeration
    and the code in the `switch` statement.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常简单，但代码的实现是我们经常看到的。有时，您会看到一大堆`if...else`语句，而不是`switch`语句。虽然代码的功能很明确，但很难在不更改代码的情况下向`StarTrooper`类添加另一个trooper类。假设您现在必须向`StarTrooper`类添加一个额外的`Engineer`类。您将不得不修改`TrooperClass`枚举和`switch`语句中的代码。
- en: 'This changing of code can cause you to introduce bugs into the code that was
    previously working fine. We now see that the `StarTrooper` class is not closed
    and can''t be extended easily to accommodate additional `TrooperClass` objects:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的更改可能会导致您在先前正常工作的代码中引入错误。我们现在看到`StarTrooper`类没有关闭，无法轻松地扩展以适应其他`TrooperClass`对象：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The solution to this problem is inheritance. Instead of having to change code,
    we extend it. Start off by rewriting the preceding `StarTrooper` class and create
    a `Trooper` class. The `GetSkills` method is declared as `virtual`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个问题的解决方案是继承。我们不需要更改代码，而是扩展它。首先，重新编写前面的`StarTrooper`类并创建一个`Trooper`类。`GetSkills`方法声明为`virtual`：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we can easily create derived classes for the `Soldier`, `Medic`, and `Scientist`
    trooper classes available. Create the following derived classes that inherit from
    the `Trooper` class. You can see that the `override` keyword is used when creating
    the `GetSkills` method:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以轻松地为可用的`Soldier`、`Medic`和`Scientist`trooper类创建派生类。创建以下继承自`Trooper`类的派生类。您可以看到在创建`GetSkills`方法时使用了`override`关键字：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The code becomes extremely easy to implement when extending the class to add
    an additional class of `Trooper`. If we now want to add the `Engineer` class,
    we would simply override the `GetSkills` method after inheriting from the `Trooper`
    class created earlier:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当扩展类以添加`Trooper`的附加类时，代码变得非常容易实现。如果现在我们想要添加`Engineer`类，我们只需在从之前创建的`Trooper`类继承后重写`GetSkills`方法：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The classes derived from the `Trooper` class are extensions of the `Trooper`
    class. We can say that each class is closed, because modifying it does not necessitate
    changing the original code. The `Trooper` class is also extensible because we
    have been able to easily extend the class by creating derived classes from it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Trooper`类派生的类是`Trooper`类的扩展。我们可以说每个类都是封闭的，因为修改它不需要改变原始代码。`Trooper`类也是可扩展的，因为我们已经能够通过创建从中派生的类轻松扩展该类。
- en: Another byproduct of this design is smaller, more manageable code that is easier
    to read and understand.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计的另一个副产品是更小、更易管理的代码，更容易阅读和理解。
- en: Exception handling
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: Exception handling is something that you as a developer need to be aware of,
    and you must also be very good at discerning what information to display to the
    end user and what information to log. Believe it or not, writing good error messages
    is harder than it looks. Too much information displayed to the user might instill
    a sense of distrust in the software. Too little information logged for debugging
    purposes is also not useful at all to the poor soul that needs to fix the error.
    This is why you need to have an **exception handling strategy**.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理是您作为开发人员需要了解的内容，您还必须非常擅长辨别要向最终用户显示什么信息以及要记录什么信息。信不信由你，编写良好的错误消息比看起来更难。向用户显示太多信息可能会在软件中灌输一种不信任感。为了调试目的记录的信息太少对于需要修复错误的可怜人来说也毫无用处。这就是为什么您需要有一个**异常处理策略**。
- en: A nice rule of thumb is to display a message to the user stating that something
    went wrong, but that a notification has been sent to support personnel. Think
    of Google, Dropbox, Twitter (remember the blue whale?), and other big companies.
    Humorous error pages with a little robot whose arm fell off, or a popular meme
    displayed to the user is far better than a threatening error page with a full
    stack trace and red text. It is something that momentarily takes the user's mind
    off a frustrating situation. Most importantly of all, it lets you save face.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是向用户显示一条消息，说明出了问题，但已向支持人员发送了通知。想想谷歌、Dropbox、Twitter（还记得蓝鲸吗？）和其他大公司。有趣的错误页面，上面有一个手臂掉了的小机器人，或者向用户显示一个流行的表情图，远比一个充满堆栈跟踪和红色文本的威胁性错误页面要好得多。这是一种暂时让用户从令人沮丧的情况中抽离的方式。最重要的是，它让您保持面子。
- en: So let's start off by looking at exception filters. These have been around for
    some time. Visual Basic.NET (VB.NET) and F# devs have had this functionality for
    a while. It was introduced in C# 6.0 and does more than meets the eye. At first
    glance, it looks as if exception filters merely specify a condition when an exception
    needs to be caught. This is, after all, what the name *exception filter* implies.
    Upon closer inspection, however, we see that exception filters act as more than
    just syntactical sugar.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们首先看一下异常过滤器。这已经存在一段时间了。Visual Basic.NET（VB.NET）和F#开发人员已经拥有了这个功能一段时间。它在C#
    6.0中引入，并且功能远不止看上去的那么简单。乍一看，异常过滤器似乎只是指定需要捕获异常的条件。毕竟，这就是*异常过滤器*这个名字所暗示的。然而，仔细观察后，我们发现异常过滤器的作用远不止是一种语法糖。 '
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a new class called `Chapter3` and call a method that reads an
    XML file. The file read logic is determined by a Boolean flag being set to `true`.
    Imagine that there is some other database flag that when set, also sets our Boolean
    flag to `true`, and thus, our application knows to read the given XML file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`Chapter3`的新类，并调用一个方法来读取XML文件。文件读取逻辑由设置为`true`的布尔标志确定。想象一下，还有一些其他数据库标志，当设置时，也会将我们的布尔标志设置为`true`，因此，我们的应用程序知道要读取给定的XML文件。
- en: 'Begin by ensuring that you have added the following `using` statement:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确保已添加以下`using`语句：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How to do it...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a class called `Chapter3` (if you have not done so already) that contains
    two methods. One method reads the XML file, and the second method logs any exception
    errors:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Chapter3`的类（如果还没有），其中包含两个方法。一个方法读取XML文件，第二个方法记录任何异常错误：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the console application, add the following code to call the `ReadXMLFile`
    method, passing it the filename to read:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，添加以下代码来调用`ReadXMLFile`方法，并将文件名传递给它以进行读取：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Running the application will generate an error (assuming that you actually
    don''t have a file called `XMLFile.xml` in your `temp` folder. Visual Studio will
    break on the `throw` statement:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序将生成一个错误（假设您的`temp`文件夹中实际上没有名为`XMLFile.xml`的文件）。Visual Studio将在`throw`语句上中断：
- en: '![](img/B06434_03_01.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_01.png)'
- en: The `Log(ex)` method has logged the exception, but have a look at the Watch1
    window. We have no idea what the value of `blnReadFileFlag` is. When an exception
    is caught, the stack is unwound (adding overhead to your code) to whatever the
    actual catch block is. Therefore, the state of the stack before the exception
    happened is lost.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Log(ex)`方法已记录了异常，但是看看Watch1窗口。我们不知道`blnReadFileFlag`的值是多少。当捕获异常时，堆栈被展开（为您的代码增加了开销）到实际的catch块。因此，异常发生之前的堆栈状态丢失了。'
- en: '![](img/B06434_03_02.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_02.png)'
- en: 'Modify your `ReadXMLFile` and `Log` methods as follows to include an exception
    filter:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改您的`ReadXMLFile`和`Log`方法如下以包括异常过滤器：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Running the console application again, Visual Studio will break on the actual
    line of code that caused the exception:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行控制台应用程序，Visual Studio将在导致异常的实际代码行上中断：
- en: '![](img/B06434_03_03.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_03.png)'
- en: 'More importantly, the value of `blnReadFileFlag` is still in scope. This is
    because exception filters can see the state of the stack at the point where the
    exception occurred instead of where the exception was handled. Looking at the
    locals window in Visual Studio, you will see that the variables are still in scope
    at the point where the exception occurred:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更重要的是，`blnReadFileFlag`的值仍然在作用域内。这是因为异常过滤器可以看到异常发生的地点的堆栈状态，而不是异常处理的地点。在Visual
    Studio的本地窗口中查看，您会发现变量在异常发生的地点仍然在作用域内。
- en: '![](img/B06434_03_04.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_03_04.png)'
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Imagine being able to view the exception information in a log file with all
    the local variable values available. Another interesting point to note is the
    return `false` statement in the `Log(ex)` method. Using this method to log the
    error and return `false` will allow the application to continue and have the exception
    handled elsewhere. As you know, catching `Exception ex` will catch everything.
    By returning `false`, the exception filter doesn''t run into the `catch` statement,
    and more specific `catch` exceptions (for example, `catch (FileNotFoundException
    ex)` after our `catch (Exception ex)` statement) can be used to handle specific
    errors. Normally, when catching exceptions, `FileNotFoundException` will never
    be caught in the following code example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下能够在日志文件中查看异常信息，并且所有局部变量值都可用。另一个有趣的地方要注意的是`Log(ex)`方法中的返回`false`语句。使用这种方法记录错误并返回`false`将允许应用程序继续并在其他地方处理异常。如您所知，捕获`Exception
    ex`将捕获一切。通过返回`false`，异常过滤器不会进入`catch`语句，并且可以使用更具体的`catch`异常（例如，在`catch (Exception
    ex)`语句之后的`catch (FileNotFoundException ex)`）来处理特定错误。通常，在捕获异常时，`FileNotFoundException`不会在以下代码示例中被捕获：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is because the order of the exceptions being caught is wrong. Traditionally,
    developers must catch exceptions in their order of specificity, which means that
    `FileNotFoundException` is more specific than `Exception` and must, therefore,
    be placed before `catch (Exception ex)`. With exception filters that call a `false`
    returning method, we can inspect and log an exception accurately:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为捕获异常的顺序是错误的。传统上，开发人员必须按照特异性的顺序捕获异常，这意味着`FileNotFoundException`比`Exception`更具体，因此必须在`catch
    (Exception ex)`之前放置。通过调用返回`false`的方法的异常过滤器，我们可以准确检查和记录异常：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding code will catch all exceptions, and in doing so, log the exception
    accurately but not step into the exception handler because the `Log(ex)` method
    returns `false`. Another implementation of exception filters is that they can
    allow developers to retry code in the event of a failure. You might not specifically
    want to catch the first exception, but implement a type of timeout element to
    your method. When the error counter has reached the maximum iterations, you can
    catch and handle the exception. You can see an example of catching an exception
    based on a `try` clauses'' count here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将捕获所有异常，并在这样做时准确记录异常，但不会进入异常处理程序，因为`Log(ex)`方法返回`false`。异常过滤的另一个实现是，它们可以允许开发人员在发生故障时重试代码。您可能不希望特别捕获第一个异常，而是在方法中实现一种超时元素。当错误计数器达到最大迭代次数时，您可以捕获并处理异常。您可以在这里看到基于`try`子句计数捕获异常的示例：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Exception filtering is a very useful and extremely powerful way to handle exceptions
    in your code. The behind-the-scenes workings of exception filters are not as immediately
    obvious as one might imagine, but here lies the actual power of exception filters.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 异常过滤是处理代码中异常的一种非常有用且非常强大的方式。异常过滤的幕后工作并不像人们想象的那样立即显而易见，但这就是异常过滤的实际力量所在。
