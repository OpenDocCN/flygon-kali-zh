- en: '*Chapter 2*: Working with Docker Data'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第2章*：使用Docker数据'
- en: At one time, containers were used for stateless workloads that could scale up,
    scale quickly, and move from one location to another without impacting the workload.
    Stateless workloads limit the type of containers you can run, prohibiting you
    from running anything beyond items that are stored in the base image.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，容器用于无状态工作负载，可以快速扩展，快速移动，并且在不影响工作负载的情况下从一个位置移动到另一个位置。无状态工作负载限制了您可以运行的容器类型，禁止您运行除基础镜像中存储的项目之外的任何内容。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why you need persistent data
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么需要持久数据
- en: Docker volumes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker卷
- en: Docker bind mounts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker绑定挂载
- en: Docker tmpfs mounts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker tmpfs挂载
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not have any technical requirements.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有任何技术要求。
- en: If you want to create volumes using the examples in this chapter, you can use
    the Docker host that we created in [*Chapter 1*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018),
    *Docker and Container Essentials*. The volumes that we'll be using for examples
    in this chapter are not required for future chapters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用本章中的示例创建卷，可以使用我们在[*第1章*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018)中创建的Docker主机，*Docker和容器基础*。本章中将使用的卷对于未来章节并非必需。
- en: 'You can access the code to create a Docker host from [*Chapter 1*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018),
    *Docker and Containers Essentials* by going to the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问[*第1章*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018)中创建Docker主机的代码，*Docker和容器基础*，访问以下GitHub存储库：[https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide)。
- en: Why you need persistent data
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么需要持久数据
- en: Let's consider an example use case where you may want to write data to a persistent
    location from a container.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个示例用例，您可能希望从容器向持久位置写入数据。
- en: Let's say you have a system that requires you to deploy a **MySQL** database
    fronted by a web-based application running on **NGINX**. You start both containers
    for the application using standard **docker run** commands. You do some initial
    testing with the users and they confirm that everything is working as expected.
    The users were successful when it came to adding records, querying for records,
    editing, and deletions – this all worked correctly. After a few days of the container
    running, you receive an email from security telling all users that all MySQL servers
    need to have a new patch deployed as soon as possible to address a security vulnerability.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个系统，需要您部署由**MySQL**数据库和运行在**NGINX**上的基于Web的应用程序。您使用标准**docker run**命令为应用程序启动两个容器。您与用户进行了一些初始测试，他们确认一切都按预期工作。用户在添加记录、查询记录、编辑和删除方面都取得了成功
    - 一切都正常工作。容器运行几天后，您收到一封来自安全部门的电子邮件，告知所有用户所有MySQL服务器需要尽快部署新补丁以解决安全漏洞。
- en: 'You quickly work on a new MySQL image that includes the newest patch and push
    it to your container registry. Working with the users, you decide a time to deploy
    the new container and start the process by doing the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以快速处理一个包含最新补丁的新MySQL镜像，并将其推送到您的容器注册表。与用户一起工作，您决定部署新容器的时间，并通过以下方式开始该过程：
- en: Stopping the running container.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止运行的容器。
- en: Running the new image using the same container name that the previous image
    used. To do this, you need to remove the current container using the **docker
    rm** command.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与先前图像相同的容器名称运行新图像。为此，您需要使用**docker rm**命令删除当前容器。
- en: Starting the new MySQL container.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动新的MySQL容器。
- en: After the container starts up, you log in to verify that MySQL is running and
    to confirm that the patch has been applied. Next, you log into the application
    and search for a record in the database and receive a record not found error.
    You find this to be odd since the system has been running for a few days. To troubleshoot
    further, you log into the database directly to check the health of the database
    and discover that there are no databases on the server.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动后，你登录验证MySQL是否在运行，并确认补丁已经应用。接下来，你登录应用程序并搜索数据库中的记录，收到一个未找到记录的错误。你觉得这很奇怪，因为系统已经运行了几天。为了进一步排除故障，你直接登录数据库检查数据库的健康状况，发现服务器上没有数据库。
- en: What happened to your database? Why does it appear that the database server
    has been wiped out and reinitialized? You know the system was working over the
    last few days and everything was running as expected, that is, right up to the
    point that you downloaded a new MySQL image and started it in place of the original
    container.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数据库发生了什么？为什么看起来数据库服务器已经被清空并重新初始化？你知道系统在过去几天一直在运行，一切都按预期运行，也就是说，直到你下载了一个新的MySQL镜像并在原始容器的位置启动它。
- en: Recall from our ephemeral discussion in [*Chapter 1*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018),
    *Docker and Container Essentials*, that the writeable layer for the container
    is ephemeral and that all the data that's written to it will be lost when the
    container is removed, even if you start a container with the same name. When you
    removed the container to reuse the name, the container layer that contained the
    database was deleted. When the new container was started, it created a new container
    layer and when MySQL started up, it didn't see any of its base files and created
    a new, fully initialized, MySQL instance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在[*第1章*](B15514_01_Final_ASB_ePub.xhtml#_idTextAnchor018)中关于短暂讨论，*Docker和容器基础*，容器的可写层是短暂的，当容器被移除时，所有写入其中的数据都会丢失，即使你使用相同的名称启动一个容器。当你移除容器以重用名称时，包含数据库的容器层被删除。新容器启动时，它创建了一个新的容器层，当MySQL启动时，它没有看到任何基本文件，并创建了一个新的、完全初始化的MySQL实例。
- en: Of course, you don't want to lose your database every time you need to deploy
    a new version of the database server. Since the container layer is ephemeral,
    you need to store your database outside the base layer on something that will
    persist between image upgrades. So far, we have been telling you that containers
    are ephemeral, so how can you configure your container to save data?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不希望每次需要部署数据库服务器的新版本时都丢失数据库。由于容器层是短暂的，你需要将数据库存储在基础层之外的某个东西上，这样在镜像升级之间可以持久存在。到目前为止，我们一直告诉你容器是短暂的，那么你如何配置容器来保存数据呢？
- en: 'Luckily, Docker includes the ability to add persistent data to a container
    using two methods:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Docker包括使用两种方法向容器添加持久数据的能力：
- en: Docker volumes
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker卷
- en: Docker bind mounts
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker绑定挂载
- en: There is also a third option that offers storage using the host's RAM, called
    **tmpfs**. This type of mount is not persistent through container restarts, Docker
    restarts, or host reboots. It is only used as a location to temporarily store
    data in high-speed RAM and is truly ephemeral. While it does not offer persistency,
    there are specific use cases where selecting tmpfs can be beneficial.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三种选项，使用主机的RAM提供存储，称为**tmpfs**。这种类型的挂载在容器重启、Docker重启或主机重启时不是持久的。它只用作临时存储数据的位置，存储在高速RAM中，是真正的短暂的。虽然它不提供持久性，但在选择tmpfs的特定用例中可能是有益的。
- en: Which option should you select when you need to run containers that require
    persistent data? Both volumes and bind mounts function similarly, storing files
    on the local host filesystem to provide persistency to your container. The final
    decision comes down to understanding how each option is managed, and what data
    it may expose if used improperly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要运行需要持久数据的容器时，应选择哪个选项？卷和绑定挂载都类似地存储文件在本地主机文件系统上，以提供持久性给您的容器。最终决定取决于理解每个选项是如何管理的，以及如果不正确使用可能会暴露哪些数据。
- en: Docker volumes
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker卷
- en: 'Docker volumes are the preferred option to add persistent data to a container.
    A volume is nothing more than a directory on the local host that is mapped to
    the container using a volume mount. When you create a volume, a new directory
    is created on the host filesystem, commonly under **/var/lib/docker/volumes/<volume
    ID>/**. If you have root access to the host, you can look at the file structure
    as you would any other directory. The following screenshot shows the directories
    under the **volumes** directory from a Docker host running containers using volumes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Docker卷是向容器添加持久数据的首选选项。卷只是本地主机上的一个目录，通过卷挂载映射到容器中。创建卷时，在主机文件系统上创建一个新目录，通常在**/var/lib/docker/volumes/<volume
    ID>/**下。如果您有主机的root访问权限，您可以像查看其他目录一样查看文件结构。以下屏幕截图显示了在运行使用卷的Docker主机上**volumes**目录下的目录：
- en: '![Figure 2.1 – Docker folder directories'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 - Docker文件夹目录'
- en: '](image/Fig_2.1_B15514.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_2.1_B15514.jpg)'
- en: Figure 2.1 – Docker folder directories
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 - Docker文件夹目录
- en: 'To maintain information between restarts, Docker stores key metadata in various
    databases on the host using Boltdb, which is a fast database written in Go that''s
    used to store persistent key values. There are two Boltdb databases that you may
    come across when browsing the **/var/lib/docker** folder:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在重启之间保持信息，Docker使用Boltdb在主机上的各种数据库中存储关键元数据，Boltdb是用Go编写的快速数据库，用于存储持久键值。当浏览**/var/lib/docker**文件夹时，您可能会遇到两个Boltdb数据库：
- en: '**/var/lib/docker/volumes/metadata.db**: Maintains metadata for Docker volumes,
    such as the name, driver, labels, and options'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/var/lib/docker/volumes/metadata.db**：维护Docker卷的元数据，如名称、驱动程序、标签和选项'
- en: '**/var/lib/docker/network/files/local-kv.db**: Maintains metadata for Docker
    networks'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/var/lib/docker/network/files/local-kv.db**：维护Docker网络的元数据'
- en: Since we are focusing on data in this chapter, we will use the **metadata.db**
    database. As you will see later in this chapter, when you create a Docker volume,
    you can provide options such as a name or label. This information is stored in
    the database to maintain volume persistence.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章重点是数据，我们将使用**metadata.db**数据库。正如您将在本章后面看到的，当您创建Docker卷时，可以提供名称或标签等选项。这些信息存储在数据库中以保持卷的持久性。
- en: 'Here is an example from **metadata.db** in JSON format for a Docker volume
    called **webdata**:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是JSON格式的**metadata.db**中关于名为**webdata**的Docker卷的示例：
- en: webdata{"Name":"webdata","Driver":"local","Labels":null,"Options":null}
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: webdata{"Name":"webdata","Driver":"local","Labels":null,"Options":null}
- en: Every Docker volume has a directory in the **/var/lib/docker/volumes** directory.
    In each volume folder, there is a directory called **_data** that contains the
    actual data for the container.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Docker卷在**/var/lib/docker/volumes**目录中都有一个目录。在每个卷文件夹中，有一个名为**_data**的目录，其中包含容器的实际数据。
- en: Before using a volume with a container, it must be created. Creating a Docker
    volume can be done manually using the Docker CLI or automatically by the Docker
    daemon when a container is started. Since both methods are created by Docker,
    they are owned and managed by Docker itself, making it is easy to manage and track
    them using the Docker CLI.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用卷与容器之前，必须创建它。可以使用Docker CLI手动创建Docker卷，也可以在启动容器时由Docker守护程序自动创建。由于这两种方法都是由Docker创建的，它们由Docker自身拥有和管理，因此可以使用Docker
    CLI轻松管理和跟踪它们。
- en: Creating a volume using the CLI
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CLI创建卷
- en: 'To create a Docker volume, we can use the volume management options:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建Docker卷，我们可以使用卷管理选项：
- en: docker volume <option>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: docker volume <选项>
- en: 'The available options are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的选项如下：
- en: '![Table 2.1 – Volume management options'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![表2.1 - 卷管理选项'
- en: '](image/B15514_Table_2.1.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15514_Table_2.1.jpg)'
- en: Table 2.1 – Volume management options
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 - 卷管理选项
- en: 'To create a new volume, use the **create** option:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新卷，请使用 **create** 选项：
- en: docker volume create <optional volume name>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: docker volume create <可选卷名称>
- en: 'After executing **create**, you will see the volume name that was created.
    If you did not provide the optional volume name, Docker will assign a volume ID
    as the name. Creating a volume without providing a volume name is known as an
    anonymous volume:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 **create** 后，您将看到创建的卷名称。如果您没有提供可选的卷名称，Docker将分配卷ID作为名称。在不提供卷名称的情况下创建卷称为匿名卷：
- en: '![Figure 2.2 – Anonymous volume output'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.2 - 匿名卷输出'
- en: '](image/Fig_2.2_B15514.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_2.2_B15514.jpg)'
- en: Figure 2.2 – Anonymous volume output
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 - 匿名卷输出
- en: An anonymous volume can be difficult to keep track of as you add additional
    containers to your host that use volumes. Therefore, it is considered a best practice
    to name your volume at creation time, rather than allowing Docker to generate
    a long anonymous volume name.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名卷在向主机添加使用卷的额外容器时可能难以跟踪。因此，最佳做法是在创建时为卷命名，而不是允许Docker生成一个很长的匿名卷名称。
- en: 'Any volume that you provide a volume name for at creation is called a named
    volume. To create a named volume, you need to supply the volume name to the **docker
    volume create** command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建时为其提供卷名称的任何卷都称为命名卷。要创建命名卷，您需要将卷名称提供给 **docker volume create** 命令：
- en: '![Figure 2.3 – Named volume output'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 - 命名卷输出
- en: '](image/Fig_2.3_B15514.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_2.3_B15514.jpg)'
- en: Figure 2.3 – Named volume output
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 - 命名卷输出
- en: Once a volume is created using either method, you can verify that the directory
    was created for your volume by looking in **/var/lib/docker/volumes**. You will
    find a directory with the name of the volume that was returned by the **create**
    command.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任一方法创建卷后，您可以通过查看 **/var/lib/docker/volumes** 来验证为您的卷创建了目录。您会发现一个以 **create**
    命令返回的卷名称命名的目录。
- en: Now that you know how to create a volume, the next step is to use it with a
    container.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何创建卷，下一步是将其与容器一起使用。
- en: Mounting a volume in a container
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器中挂载卷
- en: The process to mount a volume in a container is the same as the one that's followed
    for a named or anonymous volume. We already went over the process of creating
    a volume using the Docker CLI, but we didn't explain how to let Docker automatically
    create a volume.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中挂载卷的过程与命名卷或匿名卷的过程相同。我们已经介绍了使用Docker CLI创建卷的过程，但我们没有解释如何让Docker自动创建卷。
- en: In this section, we will explain how to have Docker automatically create a volume
    and mount it. We will also explain how to mount a previously created named volume
    to a container.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释如何让Docker自动创建卷并挂载它。我们还将解释如何将先前创建的命名卷挂载到容器中。
- en: When mounting a volume in a container, you need to provide one of two options
    to the **docker start** command. The two options you can use to mount volumes
    are **--mount** or **-v**. If you are running a standard container, you can use
    either option, but **-v** is the most commonly used option.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中挂载卷时，您需要为**docker start**命令提供两个选项中的一个。您可以使用**--mount**或**-v**这两个选项来挂载卷。如果您运行的是标准容器，您可以使用任一选项，但**-v**是最常用的选项。
- en: 'Earlier in this chapter, we created a volume called **pv-mysql-data**. We now
    want to start our MySQL container with the named volume so that we will have a
    persistent database. To mount a volume in your container, you need to pass the
    **-v** option when starting the container. The **-v** option requires two arguments:
    the volume name and the container mountpoint. In the following example command,
    you can see the command to start MySQL with a named volume mount. We also added
    some additional options that are being passed to the container, specifically the
    **-e** option, which is used to set an environment variable:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们创建了一个名为**pv-mysql-data**的卷。现在我们想要使用命名卷启动我们的MySQL容器，这样我们就会有一个持久的数据库。要在容器中挂载卷，您需要在启动容器时传递**-v**选项。**-v**选项需要两个参数：卷名称和容器挂载点。在下面的示例命令中，您可以看到启动MySQL的命令，使用了命名卷挂载。我们还添加了一些额外的选项传递给容器，特别是**-e**选项，用于设置环境变量：
- en: docker run --name mysql-01 -v pv-mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-password
    -d mysql
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: docker run --name mysql-01 -v pv-mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-password
    -d mysql
- en: This will start a container running MySQL, with a name of **mysql-01**, that
    mounts a volume called **pv-mysql-data** in a mount point called **/var/lib/mysql**
    in the container. The last option, which is using **-e**, creates an environment
    variable that is called **MYSQL_ROOT_PASSWORD**, which is set to **my-password**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个运行MySQL的容器，名称为**mysql-01**，在容器中挂载了一个名为**pv-mysql-data**的卷，挂载点为**/var/lib/mysql**。最后一个选项，使用了**-e**，创建了一个名为**MYSQL_ROOT_PASSWORD**的环境变量，其值为**my-password**。
- en: 'Once the container is up and running, you can look at the volume directory
    to verify that MySQL mounted the volume correctly by checking the data in the
    directory:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动后，您可以查看卷目录，通过检查目录中的数据来验证MySQL是否正确挂载了卷：
- en: '![Figure 2.4 – MySQL persistent volume'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 – MySQL持久卷'
- en: '](image/Fig_2.4_B15514.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_2.4_B15514.jpg)'
- en: Figure 2.4 – MySQL persistent volume
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – MySQL持久卷
- en: As you can see, the new volume contains all the standard files that are created
    when a new MySQL server is started for the first time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，新卷包含了在第一次启动新的MySQL服务器时创建的所有标准文件。
- en: We also mentioned that you can let Docker create the volume automatically, instead
    of creating the volume yourself. To have Docker create the volume upon container
    startup, run the same command that you would if you were using a pre-created volume.
    For example, using the previous MySQL example, let's assume *we did not* pre-create
    the volume using the **docker volume create** command.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到过，您可以让Docker自动创建卷，而不是自己创建卷。要让Docker在容器启动时创建卷，请运行与使用预先创建的卷相同的命令。例如，使用之前的MySQL示例，假设*我们没有*使用**docker
    volume create**命令预先创建卷。
- en: 'Let''s execute the same command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行相同的命令：
- en: docker run --name mysql-01 -v pv-mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-password
    -d mysql
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: docker run --name mysql-01 -v pv-mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-password
    -d mysql
- en: When we do this, the Docker daemon will recognize that there is no existing
    volume named **pv-mysql-data** and one will be created before it's mounted in
    the container.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，Docker守护程序将会意识到没有名为**pv-mysql-data**的现有卷，它将在挂载到容器之前创建一个。
- en: Mounting an existing volume
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载现有卷
- en: Unlike the container layers, which are also stored on the local host, volumes
    are not lost if a container is removed from Docker. In our MySQL upgrade example
    from earlier, we upgraded our database server to a newer version. Since we wanted
    to keep the container name the same as the previously deployed container, we removed
    the old container and started the new container with the same name. By removing
    the container, we removed the container layer that was stored on the local filesystem.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与容器层不同，卷也存储在本地主机上，如果容器从Docker中移除，卷不会丢失。在我们之前的MySQL升级示例中，我们将数据库服务器升级到了一个更新的版本。由于我们希望保持容器名称与先前部署的容器相同，我们移除了旧容器，并使用相同的名称启动了新容器。通过移除容器，我们移除了存储在本地文件系统上的容器层。
- en: To avoid losing our database after an upgrade, or after a container has been
    removed from our host, we can mount the existing volume in our new running container.
    Since volumes are not deleted by default, the data is still on the local filesystem
    and ready to be used by any other container.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在升级后丢失我们的数据库，或者在容器从主机中移除后，我们可以在新运行的容器中挂载现有卷。由于卷默认情况下不会被删除，数据仍然存储在本地文件系统上，并且可以被任何其他容器使用。
- en: 'When we stop and remove our MySQL server, the volume remains intact. When we
    start the new MySQL container, we only need to supply the **-v** option using
    the same volume name that was used in the original container. This is why creating
    a named volume is preferred over an anonymous volume. In our example, we created
    a named volume called **pv-mysql-data**. To run the new container, using the same
    volume, we can use the **docker run** command with the **-v** option, as shown
    here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们停止并移除我们的MySQL服务器时，卷仍然保持完好。当我们启动新的MySQL容器时，我们只需要使用相同的卷名称提供**-v**选项。这就是为什么创建一个命名卷优于匿名卷。在我们的例子中，我们创建了一个名为**pv-mysql-data**的命名卷。要运行新的容器，使用相同的卷，我们可以使用**docker
    run**命令和**-v**选项，如下所示：
- en: docker run --name mysql-01 -v pv-mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-password
    -d mysql:v2
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: docker run --name mysql-01 -v pv-mysql-data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=my-password
    -d mysql:v2
- en: This will launch our new **mysql:v2** container with the same volume as the
    previous container, with the existing database completely intact.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用与先前容器相同的卷启动我们的新**mysql:v2**容器，现有数据库完全完好无损。
- en: Mounting a volume in multiple containers
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在多个容器中挂载卷
- en: What if you had an application that requires multiple containers, and each of
    them requires the exact same data? While you could create a volume for each container
    and copy the data into each, a more efficient method would be to share a single
    volume between multiple containers.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个需要多个容器的应用程序，并且每个容器都需要相同的数据，那么您可以为每个容器创建一个卷并将数据复制到每个容器中，但更有效的方法是在多个容器之间共享单个卷。
- en: 'One unique characteristic of Docker volumes is that multiple containers can
    access the same volume. While this sounds like an easy solution to provide a single
    location to shared data, you need to keep in mind that not every application plays
    nicely when multiple processes access the same data. Using our database example,
    starting up a second container using the same volume would cause the second container''s
    MySQL server to fail at startup. Since the files are locked by the first container''s
    database, the second container cannot gain exclusive access to the database to
    mount it. If you look at the logs for the second instance, you will see the error
    shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Docker卷的一个独特特性是多个容器可以访问同一个卷。虽然这听起来像是一个提供共享数据的简单解决方案，但你需要记住，并非每个应用程序在多个进程访问相同数据时都能很好地运行。以我们的数据库示例为例，启动使用相同卷的第二个容器会导致第二个容器的MySQL服务器在启动时失败。由于文件被第一个容器的数据库锁定，第二个容器无法获得对数据库的独占访问以挂载它。如果你查看第二个实例的日志，你会看到这里显示的错误：
- en: '![Figure 2.5 – Locking error output'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.5 – 锁定错误输出'
- en: '](image/Fig_2.5_B15514.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_2.5_B15514.jpg)'
- en: Figure 2.5 – Locking error output
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 锁定错误输出
- en: There are use cases where a shared volume will offer benefits to your application.
    Imagine that you were running a few instances of a web server on your host that
    only presented data that was retrieved from a folder that changed nightly. One
    option would be to create a new container each night using a pipeline, but for
    this example, we will assume that you do not have a CI/CD system in place.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些用例中，共享卷将为你的应用程序带来好处。想象一下，你在主机上运行了几个实例的Web服务器，它们只呈现每晚从一个文件夹中检索的数据。一个选择是每晚使用流水线创建一个新的容器，但是在这个例子中，我们假设你没有建立CI/CD系统。
- en: Instead, you may have a process on the host that pulls the data into the directory
    where the Docker volume has been created. Each web server will use a volume mount,
    using the same Docker volume. This allows each container to access the data from
    a single shared location, without any changes needing to be made to the base image.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你可能在主机上有一个过程将数据拉入到创建了Docker卷的目录中。每个Web服务器将使用卷挂载，使用相同的Docker卷。这允许每个容器从单个共享位置访问数据，而无需对基本镜像进行任何更改。
- en: 'To accomplish this, you simply need to supply the same mount option to each
    container when the container starts. For example, we have created a volume called
    **webdata** on our host, and we want to launch four NGINX servers that will use
    the data in the Docker volume. When you start each instance, you just use the
    same **webdata** named volume:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，当容器启动时，你只需要为每个容器提供相同的挂载选项。例如，我们在主机上创建了一个名为**webdata**的卷，我们想要启动四个NGINX服务器，它们将使用Docker卷中的数据。当你启动每个实例时，只需使用相同的**webdata**命名卷：
- en: docker run --name webserver01 -v webdata:/opt/web/data -d bitnami/nginx:latest
    docker run --name webserver02 -v webdata:/opt/web/data -d bitnami/nginx:latest
    docker run --name webserver03 -v webdata:/opt/web/data -d bitnami/nginx:latest
    docker run --name webserver04 -v webdata:/opt/web/data -d bitnami/nginx:latest
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: docker run --name webserver01 -v webdata:/opt/web/data -d bitnami/nginx:latest
    docker run --name webserver02 -v webdata:/opt/web/data -d bitnami/nginx:latest
    docker run --name webserver03 -v webdata:/opt/web/data -d bitnami/nginx:latest
    docker run --name webserver04 -v webdata:/opt/web/data -d bitnami/nginx:latest
- en: Since the NGINX server is only going to read the data, we will not run into
    any of the locking errors that we encountered for MySQL.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NGINX服务器只会读取数据，我们不会遇到我们在MySQL中遇到的任何锁定错误。
- en: Now that we have been talking about volumes and have created a few of them,
    you might recognize that when you have many volumes on a host, it can become difficult
    to remember what volumes exist. The next section will discuss some basic management
    options for our volumes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在谈论卷并创建了一些卷，您可能会意识到当主机上有许多卷时，可能会难以记住存在哪些卷。下一节将讨论我们卷的一些基本管理选项。
- en: Listing Docker volumes
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出Docker卷
- en: 'Remember that volumes are managed by Docker, so the daemon knows about every
    volume that was created. If you want to list every volume that you or the Docker
    daemon has created, use the **docker volume list** option:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，卷由Docker管理，因此守护程序知道每个已创建的卷。如果要列出您或Docker守护程序创建的每个卷，请使用**docker volume list**选项：
- en: '![Figure 2.6 – docker volume list output'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.6 - docker卷列表输出'
- en: '](image/Fig_2.6_B15514.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_2.6_B15514.jpg)'
- en: Figure 2.6 – docker volume list output
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 - docker卷列表输出
- en: This option will display all the volumes that are currently being managed by
    Docker.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项将显示Docker当前管理的所有卷。
- en: Cleaning up volumes
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理卷
- en: By default, Docker never deletes the volumes that are created for containers.
    We already know that when we stop and start a container using a volume, the data
    persists, but what can we do about the data after we no longer need it?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker永远不会删除为容器创建的卷。我们已经知道，当我们使用卷停止和启动容器时，数据会持久存在，但是当我们不再需要数据时该怎么办呢？
- en: Imagine that the amount of data in the **/var/lib/docker/volumes** folder can
    grow at a tremendous rate. Because of this, it is a best practice to prune or
    remove the volumes to free up disk space – we often refer to this as part of a
    garbage collection process.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，**/var/lib/docker/volumes**文件夹中的数据量可能会以惊人的速度增长。因此，最佳做法是修剪或删除卷以释放磁盘空间 -
    我们通常将其称为垃圾收集过程的一部分。
- en: 'The simplest way to delete the data from an image that''s no longer required
    is to use the **-v** option when you remove the container from Docker. We have
    used **docker rm <image name>** a few times in this book to remove an image from
    the host. If you have a volume attached to the container and you want to delete
    the data when you remove the image, you can add the **-v** option to the **rm**
    command, which will delete all the volumes that were associated with the container.
    To delete our MySQL server and the persistent data, we would use the following
    command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从不再需要的镜像中删除数据的最简单方法是在从Docker中删除容器时使用**-v**选项。在本书中，我们已经多次使用**docker rm <image
    name>**来从主机中删除镜像。如果您有一个附加到容器的卷，并且希望在删除镜像时删除数据，可以将**-v**选项添加到**rm**命令中，这将删除与容器关联的所有卷。要删除我们的MySQL服务器和持久数据，我们将使用以下命令：
- en: docker rm -v mysql
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: docker rm -v mysql
- en: There will be times where you will not want to delete the data by removing the
    container. Deleting a volume cannot be undone, so a better practice is to remove
    the container and keep the volume for a set number of days. After a defined period
    of time, you may be more comfortable deleting the volume or volumes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能不希望通过删除容器来删除数据。删除卷是无法撤消的，因此更好的做法是删除容器并保留卷一段时间。在一定时间后，您可能更愿意删除卷或卷。
- en: If you wanted to delete a single or multiple volumes, you can use the **docker
    volume rm** option. You can supply the volume name, or names, after the **rm**
    option. Each volume that is supplied will be delete by the system, freeing up
    disk space on the host system.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要删除单个或多个卷，可以使用**docker volume rm**选项。您可以在**rm**选项后提供卷名称或名称。系统将删除提供的每个卷，从而释放主机系统上的磁盘空间。
- en: 'You may be nervous that you might delete a volume that is being used by a container.
    Fear not – Docker has you covered. If you attempt to delete any volume that is
    currently in use by a running container, or assigned to a stopped container, you
    will receive an error:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能担心自己可能会删除正在容器使用的卷。不用担心 – Docker已经为您考虑到了。如果您尝试删除任何当前正在运行的容器使用的卷，或者分配给已停止容器的卷，您将收到错误：
- en: 'Error response from daemon: remove test-auto: volume is in use - [51000e2f61c79ae705cdac78692fa5590fb2b26d3d0eb0a3916df230
    daf1b617]'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '守护程序的错误响应：删除test-auto: 卷正在使用 - [51000e2f61c79ae705cdac78692fa5590fb2b26d3d0eb0a3916df230
    daf1b617]'
- en: Docker will only allow you to delete a volume that has not been opened by a
    running container.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Docker只允许您删除尚未被运行容器打开的卷。
- en: You may have many volumes that you want to delete. While you could supply each
    name using the **remove** command, Docker provides another option, known as pruning.
    Pruning will look at all the volumes and remove any volume that is not currently
    mounted on a running container.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能有许多要删除的卷。虽然您可以使用**remove**命令提供每个名称，但Docker提供了另一个选项，称为清理。清理将查看所有卷，并删除任何当前未挂载在运行容器上的卷。
- en: Be careful using this option – only use it if you know that the volumes that
    are not in use do not contain data that you need for any reason. This process
    is final and once run, it will delete *all* the volumes that are not in use.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎使用此选项 – 只有在您知道未使用的卷不包含您出于任何原因需要的数据时才使用它。此过程是最终的，一旦运行，它将删除*所有*未使用的卷。
- en: 'To delete unused volumes, we use the **docker volume prune** option. This command
    will look at all the volumes, and any volume that is not attached to a running
    container will be deleted. When you issue the command, it will warn you that it
    will delete any volume without at least one running container:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除未使用的卷，我们使用**docker volume prune**选项。此命令将查看所有卷，并删除任何未附加到运行容器的卷。当您发出命令时，它将警告您它将删除任何没有至少一个运行容器的卷：
- en: '![Figure 2.7 – docker prune confirmation'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.7 – docker清理确认'
- en: '](image/Fig_2.7_B15514.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_2.7_B15514.jpg)'
- en: Figure 2.7 – docker prune confirmation
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – docker清理确认
- en: '**Select** **y** **for yes carefully** – there is no undo command for this
    action. Once executed, you will receive a summary of the deleted volumes, including
    their names and the total reclaimed disk space:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**谨慎选择** **y** **以确认** – 此操作没有撤销命令。一旦执行，您将收到已删除卷的摘要，包括它们的名称和总共回收的磁盘空间：'
- en: '![Figure 2.8 – docker prune results'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.8 – docker清理结果'
- en: '](image/Fig_2.8_B15514.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_2.8_B15514.jpg)'
- en: Figure 2.8 – docker prune results
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – docker清理结果
- en: That completes the Docker volume section of this chapter. Remember that volumes
    are just one way to provide data persistence to your containers. The other method
    is called a bind mount, and while it also uses the host filesystem like a volume,
    bind mounts have a very different use case.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了本章的Docker卷部分。请记住，卷只是为容器提供数据持久性的一种方式。另一种方法称为绑定挂载，虽然它也像卷一样使用主机文件系统，但绑定挂载有一个非常不同的用例。
- en: Docker bind mounts
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker绑定挂载
- en: 'The second option you can use to provide persistent data to a container is
    called a bind mount. Overall, volumes and bind mounts may look similar; both use
    the local host''s filesystem, and both are mounted using the **docker -v** option.
    While they do share many of the same characteristics, a bind mount differs from
    a volume mount in one main area: it is *not* managed by Docker.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用来为容器提供持久数据的第二个选项称为绑定挂载。总的来说，卷和绑定挂载可能看起来相似；两者都使用本地主机的文件系统，并且都使用**docker -v**选项进行挂载。虽然它们共享许多相同的特征，但绑定挂载与卷挂载在一个主要领域有所不同：它
    *不* 由Docker管理。
- en: Unlike a Docker volume, a bind mount cannot be created by Docker. You cannot
    create a bind mount using the **docker volume create** option; however, a bind
    mount can be created automatically by Docker when a container starts. Even though
    Docker can create the bind mount location on the host, it does not "manage" the
    mount.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与Docker卷不同，绑定挂载不能由Docker创建。您不能使用**docker volume create**选项创建绑定挂载；但是，当容器启动时，Docker可以自动创建绑定挂载。尽管Docker可以在主机上创建绑定挂载位置，但它不会“管理”挂载。
- en: Since Docker does not manage the bind mounts, they cannot be deleted using a
    Docker command. Docker does not track the location of bind mounts in a list. If
    you create bind mounts in different areas of the filesystem on the host, you need
    to track the location of each one to remove once you no longer need the data manually.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker不管理绑定挂载，因此无法使用Docker命令删除它们。Docker不会在列表中跟踪绑定挂载的位置。如果您在主机的文件系统的不同区域创建绑定挂载，您需要跟踪每个挂载的位置，以便在不再需要数据时手动删除它们。
- en: A bind mount is a directory located anywhere on the host's filesystem that is
    bound to the container using the **docker -v** option. Unlike a volume, which
    is always located in a predefined location usually, such as **/var/lib/docker/volumes**,
    a bind mount can be anywhere on the host's filesystem. Since the directory is
    on the filesystem, you may run into permission issues when trying to access a
    directory. This discussion is outside the scope of this book and moves into the
    realms of Linux file system permissions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定挂载是主机文件系统上的任何位置的目录，使用**docker -v**选项绑定到容器中。与卷不同，卷通常位于预定义位置，例如**/var/lib/docker/volumes**，绑定挂载可以位于主机文件系统的任何位置。由于目录位于文件系统上，当尝试访问目录时可能会遇到权限问题。这个讨论超出了本书的范围，并涉及到Linux文件系统权限的领域。
- en: You can bind any existing directory or create a new directory either by pre-creating
    the directory or letting Docker create the directory on container startup.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以绑定任何现有目录或创建一个新目录，可以通过预先创建目录或让Docker在容器启动时创建目录。
- en: Before we explain how to use a bind mount, you might be asking yourself, *"Why
    would I use a bind mount?"* or *"Why would I use a volume? Why do I care which
    one I should use?".* We'll explain why you may or may not want to use a bind mount
    and then compare them to volumes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解释如何使用绑定挂载之前，您可能会问自己，“为什么要使用绑定挂载？”或“为什么要使用卷？我为什么要关心我应该使用哪一个？”我们将解释为什么您可能或可能不想使用绑定挂载，然后将它们与卷进行比较。
- en: 'A bind mount can be beneficial when you need to share something on the host
    system with a running container. For example, you develop an application on your
    local laptop and you want to test the application before finalizing the code.
    Rather than running it on your local console, you want to test it in a container.
    You could store your source code in **/source** and then, when you compile, you
    could store the executable and any libraries in **/apps/testapp**. Let''s take
    a look:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要与运行的容器共享主机系统上的某些内容时，绑定挂载可能是有益的。例如，您在本地笔记本电脑上开发应用程序，并且希望在最终编写代码之前测试应用程序。您可以将源代码存储在**/source**中，然后在编译时，您可以将可执行文件和任何库存储在**/apps/testapp**中。让我们来看一下：
- en: 'You start a container with the **-v** option, which will bind mount the local
    host''s **/apps/testapp** folder in the container. This doesn''t change very much
    from using a volume in a container. In fact, the syntax to mount a bind location
    is the same as mounting a volume to a container when using the **docker run -v**
    option. However, rather than providing a volume name in the **-v** option, you
    need to provide the local host directory instead; for example:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用**-v**选项启动一个容器，该选项将在容器中绑定挂载本地主机的**/apps/testapp**文件夹。这与在容器中使用卷并没有太大区别。实际上，当使用**docker
    run -v**选项将卷挂载到容器时，挂载绑定位置的语法与挂载卷到容器时相同。但是，与在**-v**选项中提供卷名称不同，您需要提供本地主机目录；例如：
- en: '**docker run -d -v /apps/testapp:/bin/testapp ubuntu:latest**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker run -d -v /apps/testapp:/bin/testapp ubuntu:latest**'
- en: This will start a container running Ubuntu with a mount inside the container
    that binds to the local host's **/apps/testapp** path, where the compiled application
    is located.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个运行Ubuntu的容器，容器内部有一个挂载点，绑定到本地主机的**/apps/testapp**路径，编译的应用程序就在这里。
- en: To test the application, you would attach to the running image and execute the
    application by running **/bin/testapp/testapp**. Since the container's mount is
    using the local hosts directory, you can test the app and if any errors are encountered,
    you can fix the code and simply recompile the executable.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试应用程序，您需要附加到运行中的镜像，并通过运行**/bin/testapp/testapp**来执行应用程序。由于容器的挂载使用了本地主机目录，您可以测试该应用程序，如果遇到任何错误，您可以修复代码并简单地重新编译可执行文件。
- en: Once recompiled, you can run the new executable in the container again to test
    the application. This saves you from creating multiple test images, iterating
    through images after an issue is discovered. Once you have successfully tested
    the application, you can stop the container and create the final container image
    that includes the application.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦重新编译，您可以再次在容器中运行新的可执行文件来测试应用程序。这样可以避免在发现问题后创建多个测试镜像并在镜像之间进行迭代。一旦成功测试了应用程序，您可以停止容器并创建包含应用程序的最终容器镜像。
- en: Docker volumes cannot provide the same solution since they are all located in
    a directory on the host and cannot be pointed to an existing directory.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Docker卷无法提供相同的解决方案，因为它们都位于主机上的一个目录中，无法指向现有目录。
- en: There are other example use cases for using bind mounts. The main point to remember
    is that bind mounts can be used to share data anywhere on the host system with
    a container. When used in the correct scenario, bind mounts are very useful, but
    when used incorrectly, their use can lead to an unstable system or a security
    breach.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定挂载还有其他示例用例。要记住的主要观点是，绑定挂载可以用于在主机系统上的任何位置与容器共享数据。在正确的场景中使用绑定挂载非常有用，但如果使用不当，可能会导致系统不稳定或安全漏洞。
- en: It should go without saying that you should be careful when using any existing
    directory on the host system with a container. Binding your host's **/etc** directory
    in a container may lead to unexpected results. Someone running a shell in a container
    could easily delete or edit a file, or multiple files, making the host's system
    unstable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，当在容器中使用主机系统上的任何现有目录时，您应该小心。将主机的**/etc**目录绑定到容器中可能会导致意想不到的结果。在容器中运行shell的人可以轻松地删除或编辑文件，或多个文件，使主机系统不稳定。
- en: Docker tmpfs mounts
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker tmpfs挂载
- en: 'At the beginning of this chapter, we mentioned that Docker allows you to use
    the host''s RAM as a temporary storage location for container data. This type
    of mount will not persist data but for the right workload, it can be a very useful
    storage location. tmpfs offers a few unique advantages that are not available
    in volumes or bind mounts:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们提到Docker允许您将主机的RAM用作容器数据的临时存储位置。这种类型的挂载不会持久化数据，但对于适当的工作负载，它可以是一个非常有用的存储位置。tmpfs提供了一些独特的优势，这些优势在卷或绑定挂载中是不可用的：
- en: The size can be pre-defined to limit the amount of RAM that is consumed for
    storage.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大小可以预先定义以限制所消耗的RAM量。
- en: Offers very fast data access.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供非常快速的数据访问。
- en: 'There are also some limitations to tmpfs mounts:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: tmpfs挂载也有一些限制：
- en: They are only available on Linux; Windows is not supported.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们仅在Linux上可用；不支持Windows。
- en: A single tmpfs can only be mounted to one container.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个tmpfs只能挂载到一个容器。
- en: Using a tmpfs mount in a container
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在容器中使用tmpfs挂载
- en: A container can be started with a tmpfs mount by adding either **--mount** or
    using the **--tmpfs** option. In general, you should use the **--mount** option
    by default since **--tmpfs** does not allow for any customizations on the mount.
    If you use **--tmpfs**, you will not be able to set a size limit, or any file
    mode security. Since this type of mount will use an expensive resource, namely
    the host's RAM, you will want to create a size for your mount. Due to these limitations,
    we highly suggest that you do not use **--tmpfs** to create your tmpfs mounts.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过添加**--mount**或使用**--tmpfs**选项来启动容器并使用tmpfs挂载。一般来说，您应该默认使用**--mount**选项，因为**--tmpfs**不允许对挂载进行任何自定义。如果使用**--tmpfs**，您将无法设置大小限制或任何文件模式安全性。由于这种类型的挂载将使用昂贵的资源，即主机的RAM，您将希望为您的挂载创建一个大小。由于这些限制，我们强烈建议您不要使用**--tmpfs**来创建您的tmpfs挂载。
- en: 'To use a tmpfs mount for a NGINX container, you need to use the **--mount**
    option when you start the image:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要为NGINX容器使用tmpfs挂载，您需要在启动镜像时使用**--mount**选项：
- en: docker run --mount type=tmpfs,target=/opt/html,tmpfs-mode=1770,tmpfs-size=1000000
    --name nginx-test -d bitnami/nginx:latest
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: docker run --mount type=tmpfs,target=/opt/html,tmpfs-mode=1770,tmpfs-size=1000000
    --name nginx-test -d bitnami/nginx:latest
- en: 'The mount option allows you to add multiple options after specifying **--mount**
    in your **run** command. In our example, we are adding options for the type of
    mount, the target mount in the container, the file mode, and the size. The following
    table shows the details for each option:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在**run**命令中指定**--mount**后，挂载选项允许您添加多个选项。在我们的示例中，我们添加了挂载类型、容器中的目标挂载、文件模式和大小的选项。以下表格显示了每个选项的详细信息：
- en: '![Table 2.2 – Docker tmpfs optiond'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![表2.2 - Docker tmpfs选项'
- en: '](image/B15514_Table_2.2.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15514_Table_2.2.jpg)'
- en: Table 2.2 – Docker tmpfs optiond
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.2 - Docker tmpfs选项
- en: 'Now that we have created a tmpfs mount, we want to list the volumes on the
    host to verify we have a tmpfs mount. You may recall that we can list the volumes
    using the **docker volume ls** command. The output after creating the tmpfs mount
    is shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个tmpfs挂载，我们想要列出主机上的卷，以验证我们有一个tmpfs挂载。您可能还记得，我们可以使用**docker volume
    ls**命令列出卷。创建tmpfs挂载后的输出如下所示：
- en: '![Figure 2.9 – Docker volume list'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.9 - Docker卷列表'
- en: '](image/Fig_2.9_B15514.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_2.9_B15514.jpg)'
- en: Figure 2.9 – Docker volume list
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 - Docker卷列表
- en: Notice that the list is empty; there are no volumes in use according to the
    Docker daemon. tmpfs mounts will not appear in the volume list since they are
    not "true" volumes; only volumes appear when using the **docker volume ls** command.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，列表是空的；根据Docker守护程序，没有正在使用的卷。tmpfs挂载不会出现在卷列表中，因为它们不是“真正的”卷；只有在使用**docker
    volume ls**命令时才会出现卷。
- en: 'If you want to verify the tmpfs mount in the container, you can look at the
    **docker inspect** command''s output from the container and look for the **"Mounts"**
    section:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想验证容器中的tmpfs挂载，可以查看容器的**docker inspect**命令输出，并查找**"Mounts"**部分：
- en: '![Figure 2.10 – Docker inspect output'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.10 – Docker检查输出'
- en: '](image/Fig_2.10_B15514.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_2.10_B15514.jpg)'
- en: Figure 2.10 – Docker inspect output
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – Docker检查输出
- en: 'You can also verify the mount inside the running container by executing a Linux
    **df** command when using the **docker exec** command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用**docker exec**命令执行Linux **df**命令来验证运行中的容器内的挂载：
- en: '![Figure 2.11 – tmpfs mount in Linux'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.11 – Linux中的tmpfs挂载'
- en: '](image/Fig_2.11_B15514.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_2.11_B15514.jpg)'
- en: Figure 2.11 – tmpfs mount in Linux
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – Linux中的tmpfs挂载
- en: As you can see in the highlighted section of the **df** command's output, the
    mount exists in the container and the size is correct.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在**df**命令输出的突出显示部分中所看到的，挂载点存在于容器中，大小是正确的。
- en: We want to show one last example of using a mount where we do not specify a
    size for the tmpfs space. If you do not specify a size, Docker will create a mount
    using half the RAM of the host. Our example server has **26 GB** of RAM and we
    have executed a **docker run** command with the same container without specifying
    a size.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想展示一个最后的例子，即使用一个未指定tmpfs空间大小的挂载。如果您未指定大小，Docker将使用主机RAM的一半创建一个挂载。我们的示例服务器有**26
    GB** RAM，并且我们已经使用相同的容器执行了**docker run**命令，而没有指定大小。
- en: Notice that we do specify a size in the **mount** command. To verify the container
    has the **/opt/html** target, we can execute a **df -u** command using **docker
    exec** and confirm that the **/opt/html** mount was created. As you may have noticed,
    the volume size is **13 GB**, which is **half** of the **26 GB** of RAM for the
    host. It is important to point out that while the volume is set to 26 GB, it has
    no data at this time, so it is not consuming any RAM yet. RAM is not consumed
    until data is stored in the container, so you need to be very careful with tmpfs
    volumes or you may run out of RAM on your host and may crash your system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在**mount**命令中我们确实指定了大小。要验证容器是否具有**/opt/html**目标，我们可以使用**docker exec**执行**df
    -u**命令，并确认已创建**/opt/html**挂载。正如您可能已经注意到的那样，卷的大小为**13 GB**，这是主机**26 GB** RAM的**一半**。需要指出的是，虽然卷设置为26
    GB，但目前没有数据，因此尚未消耗任何RAM。只有在容器中存储数据时才会消耗RAM，因此您需要非常小心处理tmpfs卷，否则可能会在主机上耗尽RAM并可能导致系统崩溃。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned multiple ways you can handle data in a container.
    After reading this chapter you should know how to decide on the appropriate type
    of storage to use for your containers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了多种处理容器中数据的方法。阅读完本章后，您应该知道如何决定要为容器使用何种适当类型的存储。
- en: In the next chapter, we'll learn about Docker networking by learning about the
    Docker default bridge network. We'll also learn how to use and create user-defined
    bridges and expose container services on the network.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过学习Docker默认桥接网络来学习Docker网络。我们还将学习如何使用和创建用户定义的桥接，并在网络上公开容器服务。
- en: Questions
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following volumes provides persistent storage for containers?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种卷为容器提供持久存储？
- en: A. tmpfs
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: A. tmpfs
- en: B. Bind mounts
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: B. 绑定挂载
- en: C. Volumes
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: C. 卷
- en: D. SAN
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: D. SAN
- en: Docker volumes must be created before they can be mounted.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker卷必须在挂载之前创建。
- en: A. True
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: A. 真
- en: B. False
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误
- en: You create a tmpfs volume on a host that has 64 GB of RAM. During its creation,
    you failed to set a size. What size volume will Docker create?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您在具有64 GB RAM的主机上创建了一个tmpfs卷。在创建过程中，您未设置大小。Docker会创建多大的卷？
- en: A. 1 GB
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: A. 1 GB
- en: B. 64 GB
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: B. 64 GB
- en: C. 20 GB
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: C. 20 GB
- en: D. 32 GB
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: D. 32 GB
- en: Docker volumes are automatically deleted when you remove a container.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您删除一个容器时，Docker卷会自动删除。
- en: A. True
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: A. 真
- en: B. False
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误
- en: Which volume type is managed by the Docker daemon?
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种卷类型由Docker守护程序管理？
- en: A. Bind volumes
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: A. 绑定卷
- en: B. Named volumes
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: B. 命名卷
- en: C. All volumes
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: C. 所有卷
- en: D. None
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: D. 无
- en: How do you delete an unused bind volume?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何删除未使用的绑定卷？
- en: A. There is no need to; Docker will delete it automatically
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: A. 不需要；Docker会自动删除它
- en: B. **docker volume prune**
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: B. **docker volume prune**
- en: C. **docker volume bind prune**
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: C. **docker volume bind prune**
- en: D. You must manually delete the bind folder
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: D. 您必须手动删除绑定文件夹
