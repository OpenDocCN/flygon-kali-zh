- en: Chapter 1. Thread Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。线程管理
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating and running a thread
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和运行线程
- en: Getting and setting thread information
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取和设置线程信息
- en: Interrupting a thread
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断线程
- en: Controlling the interruption of a thread
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制线程的中断
- en: Sleeping and resuming a thread
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 休眠和恢复线程
- en: Waiting for the finalization of a thread
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待线程的最终化
- en: Creating and running a daemon thread
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和运行守护线程
- en: Processing uncontrolled exceptions in a thread
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在线程中处理不受控制的异常
- en: Using local thread variables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地线程变量
- en: Grouping threads into a group
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将线程分组
- en: Processing uncontrolled exceptions in a group of threads
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一组线程中处理不受控制的异常
- en: Creating threads through a factory
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过工厂创建线程
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the computer world, when we talk about **concurrency** , we talk about a
    series of tasks that run simultaneously in a computer. This simultaneity can be
    real if the computer has more than one processor or a multi-core processor, or
    apparent if the computer has only one core processor.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机世界中，当我们谈论**并发**时，我们谈论的是在计算机中同时运行的一系列任务。如果计算机有多个处理器或多核处理器，这种同时性可以是真实的，或者如果计算机只有一个核心处理器，这种同时性可以是表面的。
- en: All modern operating systems allow the execution of concurrent tasks. You can
    read your e-mails while you listen to music and read the news in a web page. We
    can say that this kind of concurrency is a **process-level** concurrency. But
    inside a process, we can also have various simultaneous tasks. The concurrent
    tasks that run inside a process are called **threads** .
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代操作系统都允许执行并发任务。您可以在读取电子邮件的同时听音乐和在网页上阅读新闻。我们可以说这种并发是**进程级**的并发。但在一个进程内部，我们也可以有各种同时进行的任务。在进程内部运行的并发任务称为**线程**。
- en: Another concept related to concurrency is **parallelism** . There are different
    definitions and relations with the concurrency concept. Some authors talk about
    concurrency when you execute your application with multiple threads in a single-core
    processor, so simultaneously you can see when your program execution is apparent.
    Also, you can talk about parallelism when you execute your application with multiple
    threads in a multi-core processor or in a computer with more than one processor.
    Other authors talk about concurrency when the threads of the application are executed
    without a predefined order, and talk about parallelism when you use various threads
    to simplify the solution of a problem, where all these threads are executed in
    an ordered way.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与并发相关的另一个概念是**并行**。并发概念有不同的定义和关系。一些作者在你在单核处理器上使用多个线程执行应用程序时谈论并发，因此同时你可以看到你的程序执行是表面的。此外，当您在多核处理器或具有多个处理器的计算机上使用多个线程执行应用程序时，您也可以谈论并行。其他作者在应用程序的线程在没有预定义顺序的情况下执行时谈论并发，并在使用各种线程简化问题解决方案时谈论并行，其中所有这些线程都以有序的方式执行。
- en: This chapter presents a number of recipes that show how to perform basic operations
    with threads using the Java 7 API. You will see how to create and run threads
    in a Java program, how to control their execution, and how to group some threads
    to manipulate them as a unit.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些示例，展示了如何使用Java 7 API执行线程的基本操作。您将看到如何在Java程序中创建和运行线程，如何控制它们的执行，以及如何将一些线程分组以将它们作为一个单元进行操作。
- en: Creating and running a thread
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和运行线程
- en: 'In this recipe, we will learn how to create and run a thread in a Java application.
    As with every element in the Java language, threads are **objects** . We have
    two ways of creating a thread in Java:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在Java应用程序中创建和运行线程。与Java语言中的每个元素一样，线程都是**对象**。在Java中创建线程有两种方式：
- en: Extending the `Thread` class and overriding the `run()` method
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`Thread`类并重写`run()`方法
- en: Building a class that implements the `Runnable` interface and then creating
    an object of the `Thread` class passing the `Runnable` object as a parameter
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个实现`Runnable`接口的类，然后创建一个`Thread`类的对象，将`Runnable`对象作为参数传递
- en: In this recipe, we will use the second approach to create a simple program that
    creates and runs 10 threads. Each thread calculates and prints the multiplication
    table of a number between one and 10.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用第二种方法创建一个简单的程序，创建并运行10个线程。每个线程计算并打印1到10之间的数字的乘法表。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or another IDE such as NetBeans, open it and create a new Java project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Calculator` that implements the `Runnable` interface.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Calculator`的类，实现`Runnable`接口。
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Declare a `private``int` attribute named `number` and implement the constructor
    of the class that initializes its value.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`number`的`private`整数属性，并实现初始化其值的类的构造函数。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Implement the `run()` method. This method will execute the instructions of the
    thread that we are creating, so this method will calculate the multiplication
    table of the number.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。这个方法将执行我们正在创建的线程的指令，因此这个方法将计算数字的乘法表。
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, implement the main class of the application. Create a class named `Main`
    that contains the `main()` method.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现应用程序的主类。创建一个名为`Main`的类，其中包含`main()`方法。
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Inside the `main()` method, create a `for` loop with 10 iterations. Inside the
    loop, create an object of the `Calculator` class, an object of the `Thread` class,
    pass the `Calculator` object as a parameter, and call the `start()` method of
    the thread object.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`方法中，创建一个有10次迭代的`for`循环。在循环内，创建一个`Calculator`类的对象，一个`Thread`类的对象，将`Calculator`对象作为参数传递，并调用线程对象的`start()`方法。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the program and see how the different threads work in parallel.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序，看看不同的线程如何并行工作。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows part of the output of the program. We can see
    that all the threads we have created, run in parallel to do their job, as shown
    in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出部分如下截图所示。我们可以看到，我们创建的所有线程都并行运行以完成它们的工作，如下截图所示：
- en: '![How it works...](img/7881_01_01.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/7881_01_01.jpg)'
- en: Every Java program has at least one execution thread. When you run the program,
    the JVM runs this execution thread that calls the `main()` method of the program.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Java程序至少有一个执行线程。运行程序时，JVM会运行调用程序的`main()`方法的执行线程。
- en: When we call the `start()` method of a `Thread` object, we are creating another
    execution thread. Our program will have as many execution threads as calls to
    the `start()` method are made.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`Thread`对象的`start()`方法时，我们正在创建另一个执行线程。我们的程序将有多少执行线程，就会调用多少次`start()`方法。
- en: A Java program ends when all its threads finish (more specifically, when all
    its non-daemon threads finish). If the initial thread (the one that executes the
    `main()` method) ends, the rest of the threads will continue with their execution
    until they finish. If one of the threads use the `System.exit()` instruction to
    end the execution of the program, all the threads end their execution.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Java程序在所有线程完成时结束（更具体地说，当所有非守护线程完成时）。如果初始线程（执行`main()`方法的线程）结束，其余线程将继续执行直到完成。如果其中一个线程使用`System.exit()`指令来结束程序的执行，所有线程都将结束执行。
- en: Creating an object of the `Thread` class doesn't create a new execution thread.
    Also, calling the `run()` method of a class that implements the `Runnable` interface
    doesn't create a new execution thread. Only calling the `start()` method creates
    a new execution thread.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Thread`类的对象并不会创建新的执行线程。调用实现`Runnable`接口的类的`run()`方法也不会创建新的执行线程。只有调用`start()`方法才会创建新的执行线程。
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: As we mentioned in the introduction of this recipe, there is another way of
    creating a new execution thread. You can implement a class that extends the `Thread`
    class and overrides the `run()` method of this class. Then, you can create an
    object of this class and call the `start()` method to have a new execution thread.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本示例的介绍中提到的，还有另一种创建新执行线程的方法。您可以实现一个继承`Thread`类并重写这个类的`run()`方法的类。然后，您可以创建这个类的对象并调用`start()`方法来创建一个新的执行线程。
- en: See also
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating threads through a factory* recipe in [Chapter 1](ch01.html "Chapter 1. Thread
    Management"), *Thread Management*
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 线程管理")的*通过工厂创建线程*示例中，*线程管理*
- en: Getting and setting thread information
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取和设置线程信息
- en: 'The `Thread` class saves some information attributes that can help us to identify
    a thread, know its status, or control its priority. These attributes are:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类保存了一些信息属性，可以帮助我们识别线程、了解其状态或控制其优先级。这些属性包括：'
- en: '**ID**: This attribute stores a unique identifier for each `Thread`.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID**：此属性为每个`Thread`存储一个唯一标识符。'
- en: '**Name**: This attribute store the name of `Thread`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：此属性存储`Thread`的名称。'
- en: '**Priority**: This attribute stores the priority of the `Thread` objects. Threads
    can have a priority between one and 10, where one is the lowest priority and 10
    is the highest one. It''s not recommended to change the priority of the threads,
    but it''s a possibility that you can use if you want.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：此属性存储`Thread`对象的优先级。线程的优先级可以在1到10之间，其中1是最低优先级，10是最高优先级。不建议更改线程的优先级，但如果需要，可以使用这个选项。'
- en: '**Status**: This attribute stores the status of `Thread`. In Java, `Thread`
    can be in one of these six states: `new`, `runnable`, `blocked`, `waiting`, `time``waiting`,
    or `terminated`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：此属性存储`Thread`的状态。在Java中，`Thread`可以处于以下六种状态之一：`new`、`runnable`、`blocked`、`waiting`、`time``waiting`或`terminated`。'
- en: In this recipe, we will develop a program that establishes the name and priority
    for 10 threads and then shows information about their status until they finish.
    The threads will calculate the multiplication table of a number.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将开发一个程序，为10个线程设置名称和优先级，然后显示它们的状态信息，直到它们完成。这些线程将计算一个数字的乘法表。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to implement the example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class named `Calculator` and specify that it implements the `Runnable`
    interface.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Calculator`的类，并指定它实现`Runnable`接口。
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Declare an `int``private` attribute named `number` and implement the constructor
    of the class that initializes this attribute.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`number`的`int`私有属性，并实现初始化该属性的类的构造函数。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Implement the `run()` method. This method will execute the instructions of the
    thread that we are creating, so this method will calculate and print the multiplication
    table of a number.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。这个方法将执行我们正在创建的线程的指令，因此这个方法将计算并打印一个数字的乘法表。
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we implement the main class of this example. Create a class named `Main`
    and implement the `main()` method.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们实现这个示例的主类。创建一个名为`Main`的类，并实现`main()`方法。
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create an array of 10 `threads` and an array of 10 `Thread.State` to store the
    threads we are going to execute and their status.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含10个`threads`和10个`Thread.State`的数组，用于存储我们将要执行的线程及其状态。
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create 10 objects of the `Calculator` class, each initialized with a different
    number, and 10 `threads` to run them. Set the priority of five of them to the
    maximum value and set the priority of the rest to the minimum value.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建10个`Calculator`类的对象，每个对象都初始化为不同的数字，并创建10个`threads`来运行它们。将其中五个的优先级设置为最大值，将其余的优先级设置为最小值。
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Create a `PrintWriter` object to write to a file on the evolution of the status
    of the threads.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`PrintWriter`对象来写入线程状态的文件。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Write on this file the status of the 10 `threads`. Now, it becomes `NEW`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件上写下10个“线程”的状态。现在，它变成了“NEW”。
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Start the execution of the 10 `threads`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始执行这10个线程。
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Until the 10 `threads` end, we are going to check their status. If we detect
    a change in the status of a thread, we write them on the file.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直到这10个线程结束，我们将检查它们的状态。如果我们检测到线程状态的变化，我们就把它们写在文件中。
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Implement the method `writeThreadInfo()` which writes the ID, name, priority,
    old status, and new status of `Thread`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`writeThreadInfo()`方法，该方法写入`Thread`的ID、名称、优先级、旧状态和新状态。
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the example and open the `log.txt` file to see the evolution of the 10 `threads`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并打开`log.txt`文件，查看这10个线程的演变。
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The following screenshot shows some lines of the `log.txt` file in an execution
    of this program. In this file, we can see that the threads with the highest priority
    end before the ones with the lowest priority. We also can see the evolution of
    the status of every thread.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了该程序执行过程中`log.txt`文件的一些行。在这个文件中，我们可以看到优先级最高的线程在优先级最低的线程之前结束。我们还可以看到每个线程状态的演变。
- en: '![How it works...](img/7881_01_02.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_01_02.jpg)'
- en: The program shown in the console is the multiplication tables calculated by
    the threads and the evolution of the status of the different threads in the file
    `log.txt`. By this way, you can better see the evolution of the threads.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台显示的程序是线程计算的乘法表和文件`log.txt`中不同线程状态的演变。通过这种方式，你可以更好地看到线程的演变。
- en: The class `Thread` has attributes to store all the information of a thread.
    The JVM uses the priority of the threads to select the one that uses the CPU at
    each moment and actualizes the status of every thread according to its situation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类有属性来存储线程的所有信息。JVM使用线程的优先级来选择在每个时刻使用CPU的线程，并根据每个线程的情况更新每个线程的状态。'
- en: If you don't specify a name for a thread, the JVM automatically assigns it one
    with the format, Thread-XX where XX is a number. You can't modify the ID or status
    of a thread. The `Thread` class doesn't implement the `setId()` and `setStatus()`
    methods to allow their modification.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为线程指定名称，JVM会自动分配一个格式为Thread-XX的名称，其中XX是一个数字。你不能修改线程的ID或状态。`Thread`类没有实现`setId()`和`setStatus()`方法来允许它们的修改。
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, you learned how to access the information attributes using a
    `Thread` object. But you can also access these attributes from an implementation
    of the `Runnable` interface. You can use the static method `currentThread()` of
    the `Thread` class to access the `Thread` object that is running the `Runnable`
    object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你学会了如何使用`Thread`对象访问信息属性。但你也可以从`Runnable`接口的实现中访问这些属性。你可以使用`Thread`类的静态方法`currentThread()`来访问运行`Runnable`对象的`Thread`对象。
- en: You have to take into account that the `setPriority()` method can throw an `IllegalArgumentException`
    exception if you try to establish a priority that isn't between one and 10.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须考虑到，如果你尝试设置一个不在1到10之间的优先级，`setPriority()`方法可能会抛出`IllegalArgumentException`异常。
- en: See Also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Interrupting a Thread* recipe in [Chapter 1](ch01.html "Chapter 1. Thread
    Management"), *Thread Management*
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*中断线程*在[第1章](ch01.html "第1章. 线程管理")中的*线程管理*中的示例'
- en: Interrupting a thread
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断线程
- en: A Java program with more than one execution thread only finishes when the execution
    of all of its threads end (more specifically, when all its non-daemon threads
    end its execution or when one of the threads use the `System.exit()` method).
    Sometimes, you will need to finish a thread, because you want to terminate a program,
    or when a user of the program wants to cancel the tasks that a `Thread` object
    is doing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个具有多个执行线程的Java程序只有在所有线程的执行结束时才会结束（更具体地说，当所有非守护线程结束执行或其中一个线程使用`System.exit()`方法时）。有时，你需要结束一个线程，因为你想终止一个程序，或者程序的用户想取消`Thread`对象正在执行的任务。
- en: Java provides the interruption mechanism to indicate to a thread that we want
    to finish it. One peculiarity of this mechanism is that `Thread` has to check
    if it has been interrupted or not, and it can decide if it responds to the finalization
    request or not. `Thread` can ignore it and continue with its execution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了中断机制来指示线程我们想要结束它。这种机制的一个特点是`Thread`必须检查它是否被中断，它可以决定是否响应最终化请求。`Thread`可以忽略它并继续执行。
- en: In this recipe, we will develop a program that creates `Thread` and, after 5
    seconds, will force its finalization using the interruption mechanism.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将开发一个程序，创建`Thread`，并在5秒后使用中断机制强制结束它。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用Eclipse IDE实现。如果你使用Eclipse或其他IDE，如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class called `PrimeGenerator` that extends the `Thread` class.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PrimeGenerator`的类，该类扩展了`Thread`类。
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Override the `run()` method including a loop that will run indefinitely. In
    this loop, we are going to process consecutive numbers beginning at one. For each
    number, we will calculate if it's a prime number and, in that case, we are going
    to write it to the console.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`run()`方法，包括一个将无限运行的循环。在这个循环中，我们将处理从1开始的连续数字。对于每个数字，我们将计算它是否是一个质数，如果是，我们将把它写入控制台。
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After processing a number, check if the thread has been interrupted by calling
    the `isInterrupted()` method. If this method returns `true`, we write a message
    and end the execution of the thread.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理完一个数字后，通过调用`isInterrupted()`方法来检查线程是否被中断。如果这个方法返回`true`，我们就写一条消息并结束线程的执行。
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Implement the `isPrime()` method. It returns a `boolean` value indicating if
    the number that is received as a parameter is a prime number (`true`) or not (`false`).
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`isPrime()`方法。它返回一个`boolean`值，指示接收的参数是否为质数（`true`）还是不是（`false`）。
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, implement the main class of the example by implementing a class called
    `Main` and implementing the `main()` method.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过实现一个名为`Main`的类并实现`main()`方法来实现示例的主类。
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Create and start an object of the `PrimeGenerator` class.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动`PrimeGenerator`类的对象。
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Wait for 5 seconds and interrupt the `PrimeGenerator` thread.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待5秒并中断`PrimeGenerator`线程。
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the example and see the results.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并查看结果。
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following screenshot shows the result of execution of the previous example.
    We can see how the `PrimeGenerator` thread writes the message and ends its execution
    when it detects that it has been interrupted. Refer to the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了上一个示例的执行结果。我们可以看到`PrimeGenerator`线程在检测到被中断时写入消息并结束其执行。请参考以下屏幕截图：
- en: '![How it works...](img/7881_01_03.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_01_03.jpg)'
- en: The `Thread` class has an attribute that stores a `boolean` value indicating
    whether the thread has been interrupted or not. When you call the `interrupt()`
    method of a thread, you set that attribute to `true.` The `isInterrupted()` method
    only returns the value of that attribute.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类有一个属性，用于存储一个`boolean`值，指示线程是否已被中断。当您调用线程的`interrupt()`方法时，您将该属性设置为`true`。`isInterrupted()`方法只返回该属性的值。'
- en: There's more...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Thread` class has another method to check whether `Thread` has been interrupted
    or not. It's the static method, `interrupted()`, that checks whether the current
    executing thread has been interrupted or not.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类还有另一个方法来检查`Thread`是否已被中断。它是静态方法`interrupted()`，用于检查当前执行线程是否已被中断。'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is an important difference between the `isInterrupted()` and the `interrupted()`
    methods. The first one doesn't change the value of the `interrupted` attribute,
    but the second one sets it to `false`. As the `interrupted()` method is a static
    method, the utilization of the `isInterrupted()` method is recommended.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`isInterrupted()`和`interrupted()`方法之间有一个重要的区别。第一个不会改变`interrupted`属性的值，但第二个会将其设置为`false`。由于`interrupted()`方法是一个静态方法，建议使用`isInterrupted()`方法。'
- en: As I mentioned earlier, `Thread` can ignore its interruption, but this is not
    the expected behaviour.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，`Thread`可以忽略其中断，但这不是预期的行为。
- en: Controlling the interruption of a thread
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制线程的中断
- en: In the previous recipe, you learned how you can interrupt the execution of a
    thread and what you have to do to control this interruption in the `Thread` object.
    The mechanism shown in the previous example can be used if the thread that can
    be interrupted is simple. But if the thread implements a complex algorithm divided
    into some methods, or it has methods with recursive calls, we can use a better
    mechanism to control the interruption of the thread. Java provides the `InterruptedException`
    exception for this purpose. You can throw this exception when you detect the interruption
    of the thread and catch it in the `run()` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，您学习了如何中断线程的执行以及如何控制`Thread`对象中的中断。在上一个示例中展示的机制可以用于可以被中断的简单线程。但是，如果线程实现了分为一些方法的复杂算法，或者它具有具有递归调用的方法，我们可以使用更好的机制来控制线程的中断。Java为此提供了`InterruptedException`异常。当检测到线程中断时，您可以抛出此异常并在`run()`方法中捕获它。
- en: In this recipe, we will implement `Thread` that looks for files with a determined
    name in a folder and in all its subfolders to show how to use the `InterruptedException`
    exception to control the interruption of a thread.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将实现一个`Thread`，它在文件夹及其所有子文件夹中查找具有确定名称的文件，以展示如何使用`InterruptedException`异常来控制线程的中断。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用Eclipse IDE实现。如果您使用Eclipse或其他IDE（如NetBeans），请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to implement the example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class called `FileSearch` and specify that it implements the `Runnable`
    interface.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FileSearch`的类，并指定它实现`Runnable`接口。
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Declare two `private` attributes, one for the name of the file we are going
    to search for and one for the initial folder. Implement the constructor of the
    class, which initializes these attributes.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明两个`private`属性，一个用于要搜索的文件名，另一个用于初始文件夹。实现类的构造函数，初始化这些属性。
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Implement the `run()` method of the `FileSearch` class. It checks if the attribute
    `fileName` is a directory and, if it is, calls the method `processDirectory()`.
    This method can throw an `InterruptedException` exception, so we have to catch
    them.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`FileSearch`类的`run()`方法。它检查属性`fileName`是否为目录，如果是，则调用`processDirectory()`方法。该方法可能会抛出`InterruptedException`异常，因此我们必须捕获它们。
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Implement the `directoryProcess()` method. This method will obtain the files
    and subfolders in a folder and process them. For each directory, the method will
    make a recursive call passing the directory as a parameter. For each file, the
    method will call the `fileProcess()` method. After processing all files and folders,
    the method checks if `Thread` has been interrupted and, in this case, throws an
    `InterruptedException` exception.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`directoryProcess()`方法。该方法将获取文件夹中的文件和子文件夹并对它们进行处理。对于每个目录，该方法将使用递归调用并将目录作为参数传递。对于每个文件，该方法将调用`fileProcess()`方法。在处理所有文件和文件夹后，该方法检查`Thread`是否已被中断，如果是，则抛出`InterruptedException`异常。
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Implement the `processFile()` method. This method will compare the name of the
    file it's processing with the name we are searching for. If the names are equal,
    we will write a message in the console. After this comparison, `Thread` will check
    if it has been interrupted and, in this case, it throws an `InterruptedException`
    exception.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`processFile()`方法。此方法将比较其正在处理的文件的名称与我们正在搜索的名称。如果名称相等，我们将在控制台中写入一条消息。在此比较之后，`Thread`将检查它是否已被中断，如果是，则抛出`InterruptedException`异常。
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, let's implement the main class of the example. Implement a class called
    `Main` that contains the `main()` method.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现示例的主类。实现一个名为`Main`的类，其中包含`main()`方法。
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Create and initialize an object of the `FileSearch` class and `Thread` to execute
    its task. Then, start executing `Thread`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并初始化`FileSearch`类的对象和`Thread`以执行其任务。然后，开始执行`Thread`。
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Wait for 10 seconds and interrupt `Thread`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待10秒并中断`Thread`。
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run the example and see the results.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并查看结果。
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The following screenshot shows the result of an execution of this example.
    You can see how the `FileSearch` object ends its execution when it detects that
    it has been interrupted. Refer to the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了此示例执行的结果。您可以看到`FileSearch`对象在检测到已被中断时结束其执行。请参考以下屏幕截图：
- en: '![How it works...](img/7881_01_04.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/7881_01_04.jpg)'
- en: In this example, we use Java exceptions to control the interruption of `Thread`.
    When you run the example, the program starts going through folders by checking
    if they have the file or not. For example, if you enter in the folder `\b\c\d`,
    the program will have three recursive calls to the `processDirectory()` method.
    When it detects that it has been interrupted, it throws an `InterruptedException`
    exception and continues the execution in the `run()` method, no matter how many
    recursive calls have been made.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用Java异常来控制`Thread`的中断。运行示例时，程序开始通过检查文件夹来检查它们是否有文件。例如，如果您进入文件夹`\b\c\d`，程序将对`processDirectory()`方法进行三次递归调用。当它检测到已被中断时，它会抛出`InterruptedException`异常，并在`run()`方法中继续执行，无论已经进行了多少次递归调用。
- en: There's more...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `InterruptedException` exception is thrown by some Java methods related
    with the concurrency API such as `sleep()`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`InterruptedException`异常由一些与并发API相关的Java方法抛出，例如`sleep()`。'
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Interrupting a thread recipe* in [Chapter 1](ch01.html "Chapter 1. Thread
    Management"), *Thread Management*
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章 线程管理")中的*中断线程示例*，*线程管理*'
- en: Sleeping and resuming a thread
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 休眠和恢复线程
- en: Sometimes, you'll be interested in interrupting the execution of `Thread` during
    a determined period of time. For example, a thread in a program checks a sensor
    state once per minute. The rest of the time, the thread does nothing. During this
    time, the thread doesn't use any resources of the computer. After this time, the
    thread will be ready to continue with its execution when the JVM chooses it to
    be executed. You can use the `sleep()` method of the `Thread` class for this purpose.
    This method receives an integer as the parameter indicates the number of milliseconds
    that the thread suspends its execution. When the sleeping time ends, the thread
    continues with its execution in the instruction, after the `sleep()` method calls,
    when the JVM assigns them CPU time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能会对在一定时间内中断`Thread`的执行感兴趣。例如，程序中的一个线程每分钟检查一次传感器状态。其余时间，线程什么也不做。在此期间，线程不使用计算机的任何资源。此时间结束后，当JVM选择执行时，线程将准备好继续执行。您可以使用`Thread`类的`sleep()`方法来实现这一目的。该方法接收一个整数作为参数，表示线程暂停执行的毫秒数。当休眠时间结束时，线程在`sleep()`方法调用后的指令中继续执行，当JVM分配给它们CPU时间时。
- en: Another possibility is to use the `sleep()` method of an element of the `TimeUnit`
    enumeration. This method uses the `sleep()` method of the `Thread` class to put
    the current thread to sleep, but it receives the parameter in the unit that it
    represents and converts it to milliseconds.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是使用`TimeUnit`枚举的元素的`sleep()`方法。此方法使用`Thread`类的`sleep()`方法将当前线程置于休眠状态，但它以表示的单位接收参数，并将其转换为毫秒。
- en: In this recipe, we will develop a program that uses the `sleep()` method to
    write the actual date every second.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将开发一个程序，使用`sleep()`方法每秒写入实际日期。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例已使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class called `FileClock` and specify that it implements the `Runnable`
    interface.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`FileClock`的类，并指定它实现`Runnable`接口。
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Implement the `run()` method.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Write a loop with 10 iterations. In each iteration, create a `Date` object,
    write it to the file, and call the `sleep()` method of the `SECONDS` attribute
    of the `TimeUnit` class to suspend the execution of the thread for one second.
    With this value, the thread will be sleeping for approximately one second. As
    the `sleep()` method can throw an `InterruptedException` exception, we have to
    include the code to catch it. It's a good practice to include code that frees
    or closes the resources the thread is using when it's interrupted.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个具有10次迭代的循环。在每次迭代中，创建一个`Date`对象，将其写入文件，并调用`TimeUnit`类的`SECONDS`属性的`sleep()`方法，以暂停线程的执行一秒钟。使用此值，线程将大约休眠一秒钟。由于`sleep()`方法可能会抛出`InterruptedException`异常，因此我们必须包含捕获它的代码。在线程被中断时，包括释放或关闭线程正在使用的资源的代码是一个良好的实践。
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have implemented the thread. Now, let's implement the main class of the example.
    Create a class called `FileMain` that contains the `main()` method.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经实现了线程。现在，让我们实现示例的主类。创建一个名为`FileMain`的类，其中包含`main()`方法。
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Create an object of the `FileClock` class and a thread to execute it. Then,
    start executing `Thread`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`FileClock`类的对象和一个线程来执行它。然后，开始执行`Thread`。
- en: '[PRE35]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Call the `sleep()` method of the SECONDS attribute of the `TimeUnit` class in
    the main `Thread` to wait for 5 seconds.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主`Thread`中调用`TimeUnit`类的SECONDS属性的`sleep()`方法，等待5秒。
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Interrupt the `FileClock` thread.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 中断`FileClock`线程。
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Run the example and see the results.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这个例子并查看结果。
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you run the example, you can see how the program writes a `Date` object
    per second and then, the message indicating that the `FileClock` thread has been
    interrupted.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个例子时，你可以看到程序每秒写入一个`Date`对象，然后显示`FileClock`线程已被中断的消息。
- en: When you call the `sleep()` method, `Thread` leaves the CPU and stops its execution
    for a period of time. During this time, it's not consuming CPU time, so the CPU
    can be executing other tasks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`sleep()`方法时，`Thread`离开CPU并停止执行一段时间。在这段时间内，它不会消耗CPU时间，所以CPU可以执行其他任务。
- en: When `Thread` is sleeping and is interrupted, the method throws an `InterruptedException`
    exception immediately and doesn't wait until the sleeping time finishes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Thread`正在睡眠并被中断时，该方法会立即抛出`InterruptedException`异常，而不会等到睡眠时间结束。
- en: There's more...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Java concurrency API has another method that makes a `Thread` object leave
    the CPU. It's the `yield()` method, which indicates to the JVM that the `Thread`
    object can leave the CPU for other tasks. The JVM does not guarantee that it will
    comply with this request. Normally, it's only used for debug purposes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API还有另一个方法，可以让`Thread`对象离开CPU。这就是`yield()`方法，它告诉JVM`Thread`对象可以离开CPU去做其他任务。JVM不能保证会遵守这个请求。通常，它只用于调试目的。
- en: Waiting for the finalization of a thread
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待线程的最终化
- en: In some situations, we will have to wait for the finalization of a thread. For
    example, we may have a program that will begin initializing the resources it needs
    before proceeding with the rest of the execution. We can run the initialization
    tasks as threads and wait for its finalization before continuing with the rest
    of the program.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要等待线程的最终化。例如，我们可能有一个程序，在继续执行之前需要开始初始化所需的资源。我们可以将初始化任务作为线程运行，并在继续程序的其余部分之前等待其最终化。
- en: For this purpose, we can use the `join()` method of the `Thread` class. When
    we call this method using a thread object, it suspends the execution of the calling
    thread until the object called finishes its execution.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以使用`Thread`类的`join()`方法。当我们使用一个线程对象调用这个方法时，它会暂停调用线程的执行，直到被调用的对象完成执行。
- en: In this recipe, we will learn the use of this method with the initialization
    example.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在初始化示例中使用这个方法。
- en: Getting ready
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是使用Eclipse IDE实现的。如果你使用Eclipse或其他IDE，比如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class called `DataSourcesLoader` and specify that it implements the
    `Runnable` interface.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`DataSourcesLoader`的类，并指定它实现`Runnable`接口。
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Implement the `run()` method. It writes a message to indicate that it starts
    its execution, sleeps for 4 seconds, and writes another message to indicate that
    it ends its execution.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。它写入一个消息表示它开始执行，睡眠4秒，然后写入另一个消息表示它结束执行。
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Create a class called `NetworkConnectionsLoader` and specify that it implements
    the `Runnable` interface. Implement the `run()` method. It will be equal to the
    `run()` method of the `DataSourcesLoader` class, but this will sleep for 6 seconds.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`NetworkConnectionsLoader`的类，并指定它实现`Runnable`接口。实现`run()`方法。它将与`DataSourcesLoader`类的`run()`方法相同，但这将睡眠6秒。
- en: Now, create a class called `Main` that contains the `main()` method.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个包含`main()`方法的`Main`类。
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Create an object of the `DataSourcesLoader` class and `Thread` to run it.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`DataSourcesLoader`类的对象和一个`Thread`来运行它。
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Create an object of the `NetworkConnectionsLoader` class and `Thread` to run
    it.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`NetworkConnectionsLoader`类的对象和一个`Thread`来运行它。
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Call the `start()` method of both the `Thread` objects.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用两个`Thread`对象的`start()`方法。
- en: '[PRE43]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Wait for the finalization of both threads using the `join()` method. This method
    can throw an `InterruptedException` exception, so we have to include the code
    to catch it.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待使用`join()`方法来完成两个线程的最终化。这个方法可能会抛出`InterruptedException`异常，所以我们必须包含捕获它的代码。
- en: '[PRE44]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Write a message to indicate the end of the program.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写一个消息表示程序结束。
- en: '[PRE45]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Run the program and see the results.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并查看结果。
- en: How it works...
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you run this program, you can see how both `Thread` objects start their
    execution. First, the `DataSourcesLoader` thread finishes its execution. Then,
    the `NetworkConnectionsLoader` class finishes its execution and, at that moment,
    the main `Thread` object continues its execution and writes the final message.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你可以看到两个`Thread`对象开始执行。首先，`DataSourcesLoader`线程完成执行。然后，`NetworkConnectionsLoader`类完成执行，此时，主`Thread`对象继续执行并写入最终消息。
- en: There's more...
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Java provides two additional forms of the `join()` method:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了`join()`方法的另外两种形式：
- en: join (long milliseconds)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: join (long milliseconds)
- en: join (long milliseconds, long nanos)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: join (long milliseconds, long nanos)
- en: 'In the first version of the `join()` method, instead of waiting indefinitely
    for the finalization of the thread called, the calling thread waits for the milliseconds
    specified as a parameter of the method. For example, if the object `thread1` has
    the code, `thread2.join(1000)`, the thread `thread1` suspends its execution until
    one of these two conditions is true:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`join()`方法的第一个版本中，调用线程不是无限期地等待被调用的线程的最终化，而是等待方法参数指定的毫秒数。例如，如果对象`thread1`有代码`thread2.join(1000)`，线程`thread1`会暂停执行，直到以下两种情况之一为真：
- en: '`thread2` finishes its execution'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thread2`完成了它的执行'
- en: 1000 milliseconds have been passed
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经过去了1000毫秒
- en: When one of these two conditions is true, the `join()` method returns.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 当这两个条件中的一个为真时，`join()`方法返回。
- en: The second version of the `join()` method is similar to the first one, but receives
    the number of milliseconds and the number of nanoseconds as parameters.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()`方法的第二个版本与第一个版本类似，但接收毫秒数和纳秒数作为参数。'
- en: Creating and running a daemon thread
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和运行守护线程
- en: Java has a special kind of thread called **daemon** thread. These kind of threads
    have very low priority and normally only executes when no other thread of the
    same program is running. When daemon threads are the only threads running in a
    program, the JVM ends the program finishing these threads.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Java有一种特殊类型的线程称为**守护**线程。这种类型的线程具有非常低的优先级，通常只有在程序中没有其他线程运行时才会执行。当守护线程是程序中唯一运行的线程时，JVM会结束程序并完成这些线程。
- en: With these characteristics, the daemon threads are normally used as service
    providers for normal (also called user) threads running in the same program. They
    usually have an infinite loop that waits for the service request or performs the
    tasks of the thread. They can't do important jobs because we don't know when they
    are going to have CPU time and they can finish any time if there aren't any other
    threads running. A typical example of these kind of threads is the Java garbage
    collector.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 具有这些特性，守护线程通常用作运行在同一程序中的普通（也称为用户）线程的服务提供者。它们通常有一个无限循环，等待服务请求或执行线程的任务。它们不能执行重要的工作，因为我们不知道它们何时会有CPU时间，并且如果没有其他线程运行，它们随时可以结束。这种类型线程的典型例子是Java垃圾收集器。
- en: In this recipe, we will learn how to create a daemon thread developing an example
    with two threads; one user thread that writes events on a queue and a daemon one
    that cleans that queue, removing the events which were generated more than 10
    seconds ago.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何创建一个守护线程，开发一个包含两个线程的示例；一个用户线程在队列中写入事件，一个守护线程清理队列，删除超过10秒前生成的事件。
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例已经使用Eclipse IDE实现。如果你使用Eclipse或其他IDE，比如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create the `Event` class. This class only stores information about the events
    our program will work with. Declare two private attributes, one called `date`
    of `java.util.Date` type and the other called `event` of `String` type. Generate
    the methods to write and read their values.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Event`类。这个类只存储我们的程序将使用的事件的信息。声明两个私有属性，一个叫做`date`，类型为`java.util.Date`，另一个叫做`event`，类型为`String`。生成方法来写入和读取它们的值。
- en: Create the `WriterTask` class and specify that it implements the `Runnable`
    interface.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`WriterTask`类并指定它实现`Runnable`接口。
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Declare the queue that stores the events and implement the constructor of the
    class, which initializes this queue.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明存储事件的队列并实现类的构造函数，初始化这个队列。
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Implement the `run()` method of this task. This method will have a loop with
    100 iterations. In each iteration, we create a new `Event`, save it in the queue,
    and sleep for one second.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现这个任务的`run()`方法。这个方法将有一个循环，循环100次。在每次迭代中，我们创建一个新的`Event`，将其保存在队列中，并休眠一秒。
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Create the `CleanerTask` class and specify that it extends the `Thread` class.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`CleanerTask`类并指定它扩展`Thread`类。
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Declare the queue that stores the events and implement the constructor of the
    class, which initializes this queue. In the constructor, mark this `Thread` as
    a daemon thread with the `setDaemon()` method.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明存储事件的队列并实现类的构造函数，初始化这个队列。在构造函数中，使用`setDaemon()`方法将这个`Thread`标记为守护线程。
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Implement the `run()` method. It has an infinite loop that gets the actual date
    and calls the `clean()` method.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。它有一个无限循环，获取实际日期并调用`clean()`方法。
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Implement the `clean()` method. It gets the last event and, if it was created
    more than 10 seconds ago, it deletes it and checks the next event. If an event
    is deleted, it writes the message of the event and the new size of the queue,
    so you can see its evolution.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`clean()`方法。获取最后一个事件，如果它是在10秒前创建的，就删除它并检查下一个事件。如果删除了一个事件，就写入事件的消息和队列的新大小，这样你就可以看到它的演变。
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, implement the main class. Create a class called `Main` with a `main()`
    method.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现主类。创建一个名为`Main`的类，其中包含一个`main()`方法。
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Create the queue to store the events using the `Deque` class.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Deque`类创建队列来存储事件。
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Create and start three `WriterTask` threads and one `CleanerTask`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并启动三个`WriterTask`线程和一个`CleanerTask`。
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Run the program and see the results.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并查看结果。
- en: How it works...
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: If you analyze the output of one execution of the program, you can see how the
    queue begins to grow until it has 30 events and then, its size will vary between
    27 and 30 events until the end of the execution.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分析程序的一次执行输出，可以看到队列开始增长，直到有30个事件，然后在执行结束之前，它的大小将在27和30个事件之间变化。
- en: The program starts with three `WriterTask` threads. Each `Thread` writes an
    event and sleeps for one second. After the first 10 seconds, we have 30 threads
    in the queue. During these 10 seconds, `CleanerTasks` has been executing while
    the three `WriterTask` threads were sleeping, but it hasn't deleted any event,
    because all of them were generated less than 10 seconds ago. During the rest of
    the execution, `CleanerTask` deletes three events every second and the three `WriterTask`
    threads write another three, so the size of the queue varies between 27 and 30
    events.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 程序以三个`WriterTask`线程开始。每个`Thread`写入一个事件并休眠一秒。在第一个10秒之后，我们在队列中有30个线程。在这10秒内，`CleanerTasks`一直在执行，而三个`WriterTask`线程在休眠，但它没有删除任何事件，因为它们都是在不到10秒前生成的。在执行的其余时间里，`CleanerTask`每秒删除三个事件，而三个`WriterTask`线程写入另外三个事件，所以队列的大小在27和30个事件之间变化。
- en: You can play with the time until the `WriterTask` threads are sleeping. If you
    use a smaller value, you will see that `CleanerTask` has less CPU time and the
    size of the queue will increase because `CleanerTask` doesn't delete any event.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以调整`WriterTask`线程睡眠的时间。如果使用较小的值，您会发现`CleanerTask`的CPU时间较少，并且队列的大小会增加，因为`CleanerTask`不会删除任何事件。
- en: There's more...
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You only can call the `setDaemon()` method before you call the `start()` method.
    Once the thread is running, you can't modify its daemon status.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`start()`方法之前，您只能调用`setDaemon()`方法。一旦线程正在运行，就无法修改其守护进程状态。
- en: You can use the `isDaemon()` method to check if a thread is a daemon thread
    (the method returns `true`) or a user thread (the method returns `false)`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`isDaemon()`方法来检查线程是否是守护线程（方法返回`true`）还是用户线程（方法返回`false）。
- en: Processing uncontrolled exceptions in a thread
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理线程中的未受控异常
- en: 'There are two kinds of exceptions in Java:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Java中有两种异常：
- en: '**Checked exceptions**: These exceptions must be specified in the `throws`
    clause of a method or caught inside them. For example, `IOException` or `ClassNotFoundException`.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已检查的异常**：这些异常必须在方法的`throws`子句中指定或在其中捕获。例如，`IOException`或`ClassNotFoundException`。'
- en: '**Unchecked exceptions**: These exceptions don''t have to be specified or caught.
    For example, `NumberFormatException`.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未检查的异常**：这些异常不必指定或捕获。例如，`NumberFormatException`。'
- en: When a checked exception is thrown inside the `run()` method of a `Thread` object,
    we have to catch and treat them, because the `run()` method doesn't accept a `throws`
    clause. When an unchecked exception is thrown inside the `run()` method of a `Thread`
    object, the default behaviour is to write the stack trace in the console and exit
    the program.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`Thread`对象的`run()`方法中抛出已检查的异常时，我们必须捕获和处理它们，因为`run()`方法不接受`throws`子句。当在`Thread`对象的`run()`方法中抛出未检查的异常时，默认行为是在控制台中写入堆栈跟踪并退出程序。
- en: Fortunately, Java provides us with a mechanism to catch and treat the unchecked
    exceptions thrown in a `Thread` object to avoid the program ending.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Java为我们提供了一种机制来捕获和处理`Thread`对象中抛出的未检查异常，以避免程序结束。
- en: In this recipe, we will learn this mechanism using an example.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用一个示例来学习这个机制。
- en: Getting ready
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: 'First of all, we have to implement a class to treat the unchecked exceptions.
    This class must implement the `UncaughtExceptionHandler` interface and implement
    the `uncaughtException()` method declared in that interface. In our case, call
    this class `ExceptionHandler` and make the method to write information about `Exception`
    and `Thread` that threw it. Following is the code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须实现一个类来处理未检查的异常。这个类必须实现`UncaughtExceptionHandler`接口，并实现该接口中声明的`uncaughtException()`方法。在我们的情况下，将这个类命名为`ExceptionHandler`，并使该方法写入有关抛出异常的`Exception`和`Thread`的信息。以下是代码：
- en: '[PRE56]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now, implement a class that throws an unchecked exception. Call this class `Task`,
    specify that it implements the `Runnable` interface, implement the `run()` method,
    and force the exception, for example, try to convert a `string` value into an
    `int` value.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现一个抛出未检查异常的类。将这个类命名为`Task`，指定它实现`Runnable`接口，实现`run()`方法，并强制异常，例如，尝试将`string`值转换为`int`值。
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, implement the main class of the example. Implement a class called `Main`
    with a `main()` method.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现示例的主类。使用`main()`方法实现一个名为`Main`的类。
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Create a `Task` object and `Thread` to run it. Set the unchecked exception handler
    using the `setUncaughtExceptionHandler()` method and start executing `Thread`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Task`对象和`Thread`来运行它。使用`setUncaughtExceptionHandler()`方法设置未检查的异常处理程序，并开始执行`Thread`。
- en: '[PRE59]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Run the example and see the results.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并查看结果。
- en: How it works...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the following screenshot, you can see the results of the execution of the
    example. The exception is thrown and captured by the handler that writes the information
    in console about `Exception` and `Thread` that threw it. Refer to the following
    screenshot:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到示例执行的结果。异常被抛出并被处理程序捕获，该处理程序在控制台中写入有关抛出异常的`Exception`和`Thread`的信息。请参考以下屏幕截图：
- en: '![How it works...](img/7881_01_05.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_01_05.jpg)'
- en: When an exception is thrown in a thread and is not caught (it has to be an unchecked
    exception), the JVM checks if the thread has an uncaught exception handler set
    by the corresponding method. If it has, the JVM invokes this method with the `Thread`
    object and `Exception` as arguments.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当线程中抛出异常并且未被捕获（必须是未检查的异常）时，JVM会检查线程是否有相应方法设置的未捕获异常处理程序。如果有，JVM将使用`Thread`对象和`Exception`作为参数调用此方法。
- en: If the thread has not got an uncaught exception handler, the JVM prints the
    stack trace in the console and exits the program.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线程没有未捕获的异常处理程序，JVM会在控制台中打印堆栈跟踪并退出程序。
- en: There's more...
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `Thread` class has another method related to the process of uncaught exceptions.
    It's the static method `setDefaultUncaughtExceptionHandler()` that establishes
    an exception handler for all the `Thread` objects in the application.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类还有另一个与未捕获异常处理相关的方法。这是静态方法`setDefaultUncaughtExceptionHandler()`，它为应用程序中的所有`Thread`对象建立异常处理程序。'
- en: When an uncaught exception is thrown in `Thread`, the JVM looks for three possible
    handlers for this exception.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`Thread`中抛出未捕获的异常时，JVM会寻找此异常的三个可能处理程序。
- en: First, it looks for the uncaught exception handler of the `Thread` objects as
    we learned in this recipe. If this handler doesn't exist, then the JVM looks for
    the uncaught exception handler for `ThreadGroup` of the `Thread` objects as was
    explained in the *Processing uncontrolled exceptions in a group of threads* recipe.
    If this method doesn't exist, the JVM looks for the default uncaught exception
    handler as we learned in this recipe.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查找`Thread`对象的未捕获异常处理程序，就像我们在这个示例中学到的那样。如果这个处理程序不存在，那么JVM将查找`Thread`对象的`ThreadGroup`的未捕获异常处理程序，就像在*在一组线程中处理不受控制的异常*示例中解释的那样。如果这个方法不存在，JVM将查找默认的未捕获异常处理程序，就像我们在这个示例中学到的那样。
- en: If none of the handlers exits, the JVM writes the stack trace of the exception
    in the console and exits the program.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有处理程序退出，JVM会在控制台中写入异常的堆栈跟踪，并退出程序。
- en: See also
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Processing uncontrolled exceptions in a group of threads* recipe in [Chapter
    1](ch01.html "Chapter 1. Thread Management"), *Thread Management*
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章. 线程管理")中的*在一组线程中处理不受控制的异常*示例，*线程管理*'
- en: Using local thread variables
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地线程变量
- en: One of the most critical aspects of a concurrent application is shared data.
    This has special importance in those objects that extend the `Thread` class or
    implement the `Runnable` interface.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 并发应用程序中最关键的一个方面是共享数据。这在那些扩展了`Thread`类或实现了`Runnable`接口的对象中尤为重要。
- en: If you create an object of a class that implements the `Runnable` interface
    and then start various `Thread` objects using the same `Runnable` object, all
    the threads share the same attributes. This means that, if you change an attribute
    in a thread, all the threads will be affected by this change.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个实现了`Runnable`接口的类的对象，然后使用相同的`Runnable`对象启动各种`Thread`对象，所有线程都共享相同的属性。这意味着，如果你在一个线程中改变了一个属性，所有线程都会受到这个改变的影响。
- en: Sometimes, you will be interested in having an attribute that won't be shared
    between all the threads that run the same object. The Java Concurrency API provides
    a clean mechanism called thread-local variables with a very good performance.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会对一个属性感兴趣，这个属性不会在运行相同对象的所有线程之间共享。Java并发API提供了一个称为线程本地变量的清晰机制，性能非常好。
- en: In this recipe, we will develop a program that has the problem exposed in the
    first paragraph and another program that solves this problem using the thread-local
    variables mechanism.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将开发一个程序，其中包含第一段中暴露的问题，以及使用线程本地变量机制解决这个问题的另一个程序。
- en: Getting ready
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例已经使用Eclipse IDE实现。如果你使用Eclipse或其他IDE，比如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: First, we are going to implement a program that has the problem exposed previously.
    Create a class called `UnsafeTask` and specify that it implements the `Runnable`
    interface. Declare a `private``java.util.Date` attribute.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将实现一个程序，其中包含先前暴露的问题。创建一个名为`UnsafeTask`的类，并指定它实现了`Runnable`接口。声明一个`private``java.util.Date`属性。
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Implement the `run()` method of the `UnsafeTask` object. This method will initialize
    the `startDate` attribute, write its value to the console, sleep for a random
    period of time, and again write the value of the `startDate` attribute.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`UnsafeTask`对象的`run()`方法。这个方法将初始化`startDate`属性，将它的值写入控制台，休眠一段随机时间，然后再次写入`startDate`属性的值。
- en: '[PRE61]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, let's implement the main class of this problematic application. Create
    a class called `Main` with a `main()` method. This method will create an object
    of the `UnsafeTask` class and start three threads using that object, sleeping
    for 2 seconds between each thread.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现这个有问题的应用程序的主类。创建一个名为`Main`的类，其中包含一个`main()`方法。这个方法将创建一个`UnsafeTask`类的对象，并使用该对象启动三个线程，在每个线程之间休眠2秒。
- en: '[PRE62]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the following screenshot, you can see the results of this program's execution.
    Each `Thread` has a different start time but, when they finish, all have the same
    value in its `startDate` attribute.![How to do it...](img/7881_01_06.jpg)
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下面的截图中，你可以看到这个程序执行的结果。每个`Thread`有不同的开始时间，但当它们完成时，所有的`startDate`属性都有相同的值。![如何做...](img/7881_01_06.jpg)
- en: As mentioned earlier, we are going to use the thread-local variables mechanism
    to solve this problem.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用线程本地变量机制来解决这个问题。
- en: Create a class called `SafeTask` and specify that it implements the `Runnable`
    interface.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SafeTask`的类，并指定它实现了`Runnable`接口。
- en: '[PRE63]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Declare an object of the `ThreadLocal<Date>` class. This object will have an
    implicit implementation that includes the method `initialValue()`. This method
    will return the actual date.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`ThreadLocal<Date>`类的对象。这个对象将具有一个包含`initialValue()`方法的隐式实现。这个方法将返回实际的日期。
- en: '[PRE64]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Implement the `run()` method. It has the same functionality as the `run()` method
    of `UnsafeClass`, but it changes the way to access to the `startDate` attribute.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。它具有与`UnsafeClass`的`run()`方法相同的功能，但它改变了访问`startDate`属性的方式。
- en: '[PRE65]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The main class of this example is the same as the unsafe example, changing the
    name of the `Runnable` class.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个示例的主类与不安全的示例相同，只是改变了`Runnable`类的名称。
- en: Run the example and analyze the difference.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并分析差异。
- en: How it works...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the following screenshot, you can see the results of the execution of the
    safe sample. Now, the three `Thread` objects have their own value of the `startDate`
    attribute. Refer to the following screenshot:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，你可以看到安全示例执行的结果。现在，三个`Thread`对象都有自己的`startDate`属性的值。参考下面的截图：
- en: '![How it works...](img/7881_01_07.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_01_07.jpg)'
- en: Thread-local variables store a value of an attribute for each `Thread` that
    uses one of these variables. You can read the value using the `get()` method and
    change the value using the `set()` method. The first time you access the value
    of a thread-local variable, if it has no value for the `Thread` object that it
    is calling, the thread-local variable calls the `initialValue()` method to assign
    a value for that `Thread` and returns the initial value.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 线程本地变量为使用这些变量的每个`Thread`存储一个属性的值。您可以使用`get()`方法读取该值，并使用`set()`方法更改该值。第一次访问线程本地变量的值时，如果它对于调用它的`Thread`对象没有值，则线程本地变量将调用`initialValue()`方法为该`Thread`分配一个值，并返回初始值。
- en: There's more...
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The thread-local class also provides the `remove()` method that deletes the
    value stored in the thread-local variable for the thread that it's calling.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 线程本地类还提供了`remove()`方法，用于删除调用它的线程的线程本地变量中存储的值。
- en: The Java Concurrency API includes the `InheritableThreadLocal` class that provides
    inheritance of values for threads created from a thread. If a thread A has a value
    in a thread-local variable and it creates another thread B, the thread B will
    have the same value as the thread A in the thread-local variable. You can override
    the `childValue()` method that is called to initialize the value of the child
    thread in the thread-local variable. It receives the value of the parent thread
    in the thread-local variable as a parameter.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API包括`InheritableThreadLocal`类，它提供了从线程创建的线程继承值的功能。如果线程A在线程本地变量中有一个值，并且它创建另一个线程B，则线程B将在线程本地变量中具有与线程A相同的值。您可以重写`childValue()`方法，该方法用于初始化线程本地变量中子线程的值。它将父线程在线程本地变量中的值作为参数。
- en: Grouping threads into a group
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将线程分组
- en: An interesting functionality offered by the concurrency API of Java is the ability
    to group the threads. This allows us to treat the threads of a group as a single
    unit and provides access to the `Thread` objects that belong to a group to do
    an operation with them. For example, you have some threads doing the same task
    and you want to control them, irrespective of how many threads are still running,
    the status of each one will interrupt all of them with a single call.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API提供的一个有趣功能是能够对线程进行分组。这使我们能够将组中的线程视为单个单位，并提供对属于组的`Thread`对象的访问，以对它们进行操作。例如，如果有一些线程执行相同的任务，并且您想要控制它们，无论有多少线程正在运行，每个线程的状态都将通过单个调用中断所有线程。
- en: Java provides the `ThreadGroup` class to work with groups of threads. A `ThreadGroup`
    object can be formed by `Thread` objects and by another `ThreadGroup` object,
    generating a tree structure of threads.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了`ThreadGroup`类来处理线程组。`ThreadGroup`对象可以由`Thread`对象和另一个`ThreadGroup`对象组成，生成线程的树形结构。
- en: In this recipe, we will learn to work with `ThreadGroup` objects developing
    a simple example. We will have 10 threads sleeping during a random period of time
    (simulating a search, for example) and, when one of them finishes, we are going
    to interrupt the rest.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何使用`ThreadGroup`对象开发一个简单的示例。我们将有10个线程在随机时间段内休眠（例如模拟搜索），当其中一个完成时，我们将中断其余的线程。
- en: Getting ready
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用Eclipse IDE实现。如果您使用Eclipse或其他IDE，如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: First, create a class called `Result`. It will store the name of `Thread` that
    finishes first. Declare a `private``String` attribute called `name` and the methods
    to read and set the value.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`Result`的类。它将存储首先完成的`Thread`的名称。声明一个名为`name`的`private`字符串属性和用于读取和设置该值的方法。
- en: Create a class called `SearchTask` and specify that it implements the `Runnable`
    interface.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SearchTask`的类，并指定它实现`Runnable`接口。
- en: '[PRE66]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Declare a `private` attribute of the `Result` class and implement the constructor
    of the class that initializes this attribute.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`Result`类的`private`属性并实现该类的构造函数以初始化此属性。
- en: '[PRE67]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Implement the `run()` method. It will call the `doTask()` method and wait for
    it to finish or for a `InterruptedException` exception. The method will write
    messages to indicate the start, end, or interruption of this `Thread`.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。它将调用`doTask()`方法并等待其完成或出现`InterruptedException`异常。该方法将写入消息以指示此`Thread`的开始、结束或中断。
- en: '[PRE68]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Implement the `doTask()` method. It will create a `Random` object to generate
    a random number and call the `sleep()` method with that random number.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`doTask()`方法。它将创建一个`Random`对象来生成一个随机数，并调用`sleep()`方法来休眠该随机数的时间。
- en: '[PRE69]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, create the main class of the example by creating a class called `Main`
    and implement the `main()` method.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过创建一个名为`Main`的类并实现`main()`方法来创建示例的主类。
- en: '[PRE70]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: First, create a `ThreadGroup` object and call them `Searcher`.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`ThreadGroup`对象并将其命名为`Searcher`。
- en: '[PRE71]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Then, create a `SearchTask` object and a `Result` object.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个`SearchTask`对象和一个`Result`对象。
- en: '[PRE72]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now, create 10 `Thread` objects using the `SearchTask` object. When you call
    the constructor of the `Thread` class, pass it as the first argument of the `ThreadGroup`
    object.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`SearchTask`对象创建10个`Thread`对象。当调用`Thread`类的构造函数时，将其作为`ThreadGroup`对象的第一个参数传递。
- en: '[PRE73]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Write information about the `ThreadGroup` object using the `list()` method.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`list()`方法写入关于`ThreadGroup`对象的信息。
- en: '[PRE74]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Use the `activeCount()` and `enumerate()` methods to know how many `Thread`
    objects are associated with the `ThreadGroup` objects and get a list of them.
    We can use this method to get, for example, the state of each `Thread`.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`activeCount()`和`enumerate()`方法来了解有多少`Thread`对象与`ThreadGroup`对象相关联，并获取它们的列表。我们可以使用此方法来获取每个`Thread`的状态，例如。
- en: '[PRE75]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Call the method `waitFinish()`. We will implement this method later. It will
    wait until one of the threads of the `ThreadGroup` objects ends.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`waitFinish()`方法。我们稍后将实现此方法。它将等待直到`ThreadGroup`对象的一个线程结束。
- en: '[PRE76]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Interrupt the rest of the threads of the group using the `interrupt()` method.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`interrupt()`方法中断组中其余的线程。
- en: '[PRE77]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Implement the `waitFinish()` method. It will use the `activeCount()` method
    to control the end of one of the threads.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`waitFinish()`方法。它将使用`activeCount()`方法来控制其中一个线程的结束。
- en: '[PRE78]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Run the example and see the results.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并查看结果。
- en: How it works...
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the following screenshot, you can see the output of the `list()` method
    and the output generated when we write the status of each `Thread` object, as
    shown in the following screenshot:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到`list()`方法的输出以及当我们写入每个`Thread`对象的状态时生成的输出，如下面的屏幕截图所示：
- en: '![How it works...](img/7881_01_08.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/7881_01_08.jpg)'
- en: The `ThreadGroup` class stores the `Thread` objects and the other `ThreadGroup`
    objects associated with it, so it can access all of their information (status,
    for example) and perform operations over all its members (interrupt, for example).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadGroup`类存储`Thread`对象和与之关联的其他`ThreadGroup`对象，因此它可以访问它们所有的信息（例如状态）并对其所有成员执行操作（例如中断）。'
- en: There's more...
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `ThreadGroup` class has more methods. Check the API documentation to have
    a complete explanation of all of these methods.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadGroup`类有更多的方法。查看API文档以获得所有这些方法的完整解释。'
- en: Processing uncontrolled exceptions in a group of threads
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一组线程中处理不受控制的异常
- en: A very important aspect in every programming language is the mechanism that
    provides management of error situations in your application. Java language, as
    almost all modern programming languages, implements an exception-based mechanism
    to manage error situations. It provides a lot of classes to represent different
    errors. Those exceptions are thrown by the Java classes when an error situation
    is detected. You can also use those exceptions, or implement your own exceptions,
    to manage the errors produced in your classes.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种编程语言中，一个非常重要的方面是提供管理应用程序中错误情况的机制。Java语言，就像几乎所有现代编程语言一样，实现了基于异常的机制来管理错误情况。它提供了许多类来表示不同的错误。当检测到错误情况时，Java类会抛出这些异常。您也可以使用这些异常，或者实现自己的异常来管理类中产生的错误。
- en: Java also provides a mechanism to capture and process those exceptions. There
    are exceptions that must be captured or re-thrown using the `throws` clause of
    a method. These exceptions are called checked exceptions. There are exceptions
    that don't have to be specified or caught. These are the unchecked exceptions.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Java还提供了一种机制来捕获和处理这些异常。有些异常必须使用方法的`throws`子句捕获或重新抛出。这些异常称为已检查异常。有些异常不必指定或捕获。这些是未检查的异常。
- en: In the recipe, *Controlling the interruption of a Thread*, you learned how to
    use a generic method to process all the uncaught exceptions that are thrown in
    a `Thread` object.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，*控制线程的中断*，你学会了如何使用一个通用方法来处理`Thread`对象中抛出的所有未捕获的异常。
- en: Another possibility is to establish a method that captures all the uncaught
    exceptions thrown by any `Thread` of the `ThreadGroup` class.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是建立一个方法，捕获`ThreadGroup`类的任何`Thread`抛出的所有未捕获的异常。
- en: In this recipe, we will learn to set this handler using an example.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习使用一个例子来设置这个处理程序。
- en: Getting ready
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用Eclipse IDE实现。如果你使用Eclipse或其他IDE如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Follow these steps to implement the example:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: First, we have to extend the `ThreadGroup` class by creating a class called
    `MyThreadGroup` that extends from `ThreadGroup`. We have to declare a constructor
    with one parameter, because the `ThreadGroup` class doesn't have a constructor
    without it.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须通过创建一个名为`MyThreadGroup`的类来扩展`ThreadGroup`类，该类从`ThreadGroup`类扩展。我们必须声明一个带有一个参数的构造函数，因为`ThreadGroup`类没有没有参数的构造函数。
- en: '[PRE79]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Override the `uncaughtException()` method. This method is called when an exception
    is thrown in one of the threads of the `ThreadGroup` class. In this case, this
    method will write in the console information about the exception and `Thread`
    that throws it and interrupts the rest of the threads in the `ThreadGroup` class.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`uncaughtException()`方法。当`ThreadGroup`类的一个线程抛出异常时，将调用此方法。在这种情况下，此方法将在控制台中写入有关异常和抛出异常的`Thread`的信息，并中断`ThreadGroup`类中的其余线程。
- en: '[PRE80]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Create a class called `Task` and specify that it implements the `Runnable` interface.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，并指定它实现`Runnable`接口。
- en: '[PRE81]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Implement the `run()` method. In this case, we will provoke an `AritmethicException`
    exception. For this, we will divide 1000 between random numbers until the random
    generator generates a zero and the exception is thrown.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`run()`方法。在这种情况下，我们将引发一个`AritmethicException`异常。为此，我们将在随机数之间除以1000，直到随机生成器生成零并抛出异常。
- en: '[PRE82]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now, we are going to implement the main class of the example by creating a class
    called `Main` and implement the `main()` method.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过创建一个名为`Main`的类并实现`main()`方法来实现示例的主类。
- en: '[PRE83]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Create an object of the `MyThreadGroup` class.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MyThreadGroup`类的对象。
- en: '[PRE84]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Create an object of the `Task` class.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Task`类的对象。
- en: '[PRE85]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Create two `Thread` objects with this `Task` and start them.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个带有这个`Task`的`Thread`对象并启动它们。
- en: '[PRE86]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Run the example and see the results.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并查看结果。
- en: How it works...
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you run the example, you will see how one of the `Thread` objects threw
    the exception and the other one was interrupted.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行示例时，你会看到其中一个`Thread`对象抛出了异常，另一个被中断了。
- en: When an uncaught exception is thrown in `Thread`, the JVM looks for three possible
    handlers for this exception.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`Thread`中抛出未捕获的异常时，JVM会寻找这个异常的三个可能的处理程序。
- en: First, it looks for the uncaught exception handler of the thread, as was explained
    in the *Processing uncontrolled exceptions in a Thread* recipe. If this handler
    doesn't exist, then the JVM looks for the uncaught exception handler for the `ThreadGroup`
    class of the thread, as we learned in this recipe. If this method doesn't exist,
    the JVM looks for the default uncaught exception handler, as was explained in
    the *Processing uncontrolled exceptions in a Thread* recipe.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查找线程的未捕获异常处理程序，就像在*处理线程中的不受控制的异常*配方中所解释的那样。如果这个处理程序不存在，那么JVM会查找线程的`ThreadGroup`类的未捕获异常处理程序，就像我们在这个配方中学到的那样。如果这个方法不存在，JVM会查找默认的未捕获异常处理程序，就像在*处理线程中的不受控制的异常*配方中所解释的那样。
- en: If none of the handlers exit, the JVM writes the stack trace of the exception
    in the console and exits the program.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有处理程序退出，JVM会在控制台中写入异常的堆栈跟踪，并退出程序。
- en: See also
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Processing uncontrolled exceptions in a thread* recipe in [Chapter 1](ch01.html
    "Chapter 1. Thread Management"), *Thread Management*
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章 线程管理")中的*处理线程中的不受控制的异常*配方，*线程管理*'
- en: Creating threads through a factory
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过工厂创建线程
- en: The factory pattern is one of the most used design patterns in the object-oriented
    programming world. It is a creational pattern and its objective is to develop
    an object whose mission will be creating other objects of one or several classes.
    Then, when we want to create an object of one of those classes, we use the factory
    instead of using the `new` operator.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式是面向对象编程世界中最常用的设计模式之一。它是一种创建模式，其目标是开发一个使命将是创建一个或多个类的其他对象的对象。然后，当我们想要创建其中一个类的对象时，我们使用工厂而不是使用`new`运算符。
- en: 'With this factory, we centralize the creation of objects with some advantages:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个工厂，我们可以集中创建对象，并获得一些优势：
- en: It's easy to change the class of the objects created or the way we create these
    objects.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易改变创建的对象的类或创建这些对象的方式。
- en: It's easy to limit the creation of objects for limited resources. For example,
    we can only have *n* objects of a type.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易限制为有限资源创建对象。例如，我们只能有一个类型的*n*个对象。
- en: It's easy to generate statistical data about the creation of the objects.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易生成有关对象创建的统计数据。
- en: Java provides an interface, the `ThreadFactory` interface to implement a `Thread`
    object factory. Some advanced utilities of the Java concurrency API use thread
    factories to create threads.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Java提供了一个接口，即`ThreadFactory`接口，用于实现`Thread`对象工厂。Java并发API的一些高级工具使用线程工厂来创建线程。
- en: In this recipe, we will learn how to implement a `ThreadFactory` interface to
    create `Thread` objects with a personalized name while we save statistics of the
    `Thread` objects created.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何实现`ThreadFactory`接口，以创建具有个性化名称的`Thread`对象，同时保存创建的`Thread`对象的统计数据。
- en: Getting ready
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方的示例是使用Eclipse IDE实现的。如果您使用Eclipse或其他IDE，如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to implement the example:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: Create a class called `MyThreadFactory` and specify that it implements the `ThreadFactory`
    interface.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MyThreadFactory`的类，并指定它实现`ThreadFactory`接口。
- en: '[PRE87]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Declare three attributes: an integer number called `counter`, which we will
    use to store the number of the `Thread` object created, a `String` called `name`
    with the base name of every `Thread` created, and a `List` of `String` objects
    called `stats` to save statistical data about the `Thread` objects created. We
    also implement the constructor of the class that initializes these attributes.'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明三个属性：一个名为`counter`的整数，我们将用它来存储创建的`Thread`对象的数量，一个名为`name`的`String`，它是每个创建的`Thread`的基本名称，以及一个名为`stats`的`String`对象列表，用于保存有关创建的`Thread`对象的统计数据。我们还实现了初始化这些属性的类的构造函数。
- en: '[PRE88]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Implement the `newThread()` method. This method will receive a `Runnable` interface
    and returns a `Thread` object for this `Runnable` interface. In our case, we generate
    the name of the `Thread` object, create the new `Thread` object, and save the
    statistics.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`newThread()`方法。这个方法将接收一个`Runnable`接口，并为这个`Runnable`接口返回一个`Thread`对象。在我们的例子中，我们生成`Thread`对象的名称，创建新的`Thread`对象，并保存统计数据。
- en: '[PRE89]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Implement the method `getStatistics()` that returns a `String` object with the
    statistical data of all the `Thread` objects created.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`getStatistics()`方法，返回包含所有创建的`Thread`对象的统计数据的`String`对象。
- en: '[PRE90]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Create a class called `Task` and specify that it implements the `Runnable` interface.
    For this example, these tasks are going to do nothing apart from sleeping for
    one second.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Task`的类，并指定它实现`Runnable`接口。在这个例子中，这些任务除了睡一秒钟之外什么也不做。
- en: '[PRE91]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Create the main class of the example. Create a class called `Main` and implement
    the `main()` method.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建示例的主类。创建一个名为`Main`的类，并实现`main()`方法。
- en: '[PRE92]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Create a `MyThreadFactory` object and a `Task` object.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MyThreadFactory`对象和一个`Task`对象。
- en: '[PRE93]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Create 10 `Thread` objects using the `MyThreadFactory` object and start them.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`MyThreadFactory`对象创建10个`Thread`对象并启动它们。
- en: '[PRE94]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Write in the console the statistics of the thread factory.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中写入线程工厂的统计数据。
- en: '[PRE95]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Run the example and see the results.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例并查看结果。
- en: How it works...
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ThreadFactory` interface has only one method called `newThread`. It receives
    a `Runnable` object as a parameter and returns a `Thread` object. When you implement
    a `ThreadFactory` interface, you have to implement that interface and override
    this method. Most basic `ThreadFactory`, has only one line.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadFactory`接口只有一个名为`newThread`的方法。它接收一个`Runnable`对象作为参数，并返回一个`Thread`对象。当您实现`ThreadFactory`接口时，您必须实现该接口并重写此方法。大多数基本的`ThreadFactory`只有一行。'
- en: '[PRE96]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You can improve this implementation by adding some variants by:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加一些变体来改进这个实现：
- en: Creating personalized threads, as in the example, using a special format for
    the name or even creating our own `thread` class that inherits the Java `Thread`
    class
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建个性化的线程，就像示例中使用特殊格式的名称或甚至创建我们自己的`thread`类一样，该类继承了Java的`Thread`类。
- en: Saving thread creation statistics, as shown in the previous example
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存线程创建统计信息，如前面的示例所示
- en: Limiting the number of threads created
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制创建的线程数量
- en: Validating the creation of the threads
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证线程的创建
- en: And anything more you can imagine
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及您可以想象的任何其他内容
- en: The use of the factory design pattern is a good programming practice but, if
    you implement a `ThreadFactory` interface to centralize the creation of threads,
    you have to review the code to guarantee that all threads are created using that
    factory.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂设计模式是一种良好的编程实践，但是，如果您实现了`ThreadFactory`接口来集中创建线程，您必须审查代码以确保所有线程都是使用该工厂创建的。
- en: See also
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Implementing the ThreadFactory interface to generate custom threads* recipe
    in [Chapter 7](ch07.html "Chapter 7. Customizing Concurrency Classes"), *Customizing
    Concurrency Classes*
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章 自定义并发类")中的*实现ThreadFactory接口生成自定义线程*配方，*自定义并发类*'
- en: The *Using our ThreadFactory in an Executor object* recipe in [Chapter 7](ch07.html
    "Chapter 7. Customizing Concurrency Classes"), *Customizing Concurrency Classes*
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第7章](ch07.html "第7章 自定义并发类")中的*在Executor对象中使用我们的ThreadFactory*配方，*自定义并发类*'
