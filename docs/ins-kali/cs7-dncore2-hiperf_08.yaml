- en: Microservices Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构
- en: Microservices application development is growing at a rapid pace in the software
    industry. It is widely used for developing performant applications that are resilient,
    scalable, distributed, and cloud-ready. Many organizations and software companies
    are transforming their applications into the microservices architecture style.
    Amazon, eBay, and Uber are good examples of companies that have transformed their
    applications into microservices.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应用程序开发在软件行业以快速的速度增长。它被广泛用于开发具有弹性、可扩展、分布式和云就绪的高性能应用程序。许多组织和软件公司正在将他们的应用程序转变为微服务架构风格。亚马逊、eBay和Uber是将他们的应用程序转变为微服务的好例子。
- en: Microservices split the application horizontally and vertically into smaller
    components, where the components are independent of one another and communicate
    through an endpoint. With the recent development in the industry of containers,
    we can use containers to deploy/run microservices that can scale up or scale out
    independently without any dependency on other components of the application and
    are leveraged with the pay-as-you-go model.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务将应用程序水平和垂直地分解成较小的组件，其中这些组件彼此独立，并通过端点进行通信。随着容器行业的最新发展，我们可以使用容器来部署/运行可以独立扩展的微服务，而不依赖于应用程序的其他组件，并且可以利用按需付费模式。
- en: Today, we can use **Azure Container Service **(**ACS**) or Service Fabric to
    deploy .NET Core applications in the cloud and provide a containerization model
    with the consortium of Docker, Kubernetes, and other third-party components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们可以使用Azure容器服务（ACS）或Service Fabric在云中部署.NET Core应用程序，并提供一个与Docker、Kubernetes和其他第三方组件联合使用的容器化模型。
- en: In this chapter, we will learn the fundamentals of microservices architecture
    and its challenges, and create a basic application following microservices principles
    and practices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习微服务架构的基础知识和挑战，并根据微服务的原则和实践创建一个基本的应用程序。
- en: 'The following are the topics we will learn in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章我们将学习的主题：
- en: Microservices architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务架构
- en: Benefits and standard practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好处和标准实践
- en: Stateless versus stateful microservices
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态与有状态的微服务
- en: Decomposing databases and its challenges
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分解数据库及其挑战
- en: Developing microservices in .NET Core
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在.NET Core中开发微服务
- en: Running .NET Core microservices on Docker
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker上运行.NET Core微服务
- en: Microservices architecture
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构
- en: Microservices architecture is an architectural style in which the application
    is loosely coupled; it is divided into components based on business capability
    or domain, and scales independently without affecting other services or components
    of the application. This contrasts with the monolithic architecture, where a full
    application is deployed on a server or a **Virtual Machine** (**VM**) and scaling
    out is not a cost-effective or easy solution. For each scale-out operation, a
    new VM instance has to be cloned and the application needs to be deployed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构是一种架构风格，其中应用程序松散耦合；它根据业务能力或领域划分为组件，并且可以独立扩展而不影响应用程序的其他服务或组件。这与单体架构相反，单体架构将整个应用程序部署在服务器或虚拟机上，并且扩展不是一种经济有效或简单的解决方案。对于每个扩展操作，都必须克隆一个新的虚拟机实例，并且必须部署应用程序。
- en: 'The following diagram shows the architecture of a monolithic application, where
    most of the functionality is isolated within a single process and scaling out
    to multiple servers requires the full deployment of the application on the other
    server:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了单体应用程序的架构，其中大部分功能被隔离在单个进程中，并且在多个服务器上进行扩展需要在其他服务器上部署整个应用程序：
- en: '![](img/00092.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00092.jpeg)'
- en: 'The following is a representation of microservices architecture, which separates
    an application into smaller services and, based on the workload, scales independently:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是微服务架构的表示，它将应用程序分成较小的服务，并根据工作负载独立扩展：
- en: '![](img/00093.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00093.jpeg)'
- en: In microservices architecture, the application is divided into loosely coupled
    services, each of which exposes an endpoint and is deployed on a separate server
    or, most likely, container. Each service communicates with the other services
    through some endpoint.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，应用程序被划分为松散耦合的服务，每个服务都公开一个端点，并部署在单独的服务器上，或者更可能是容器上。每个服务通过某些端点与其他服务通信。
- en: Benefits of microservices architecture
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构的好处
- en: 'There are various benefits of microservices architecture, which are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构有各种好处，如下所示：
- en: Microservices are autonomous and expose a self-contained unit of functionality
    with loosely coupled dependencies on other services
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务是自治的，并且通过与其他服务松散耦合的依赖关系公开了一个独立的功能单元
- en: It exposes features to a caller via a well-defined API contract
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过明确定义的API合同向调用者公开功能
- en: It degrades gracefully if any service fails
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何服务失败，它会优雅地降级
- en: It scales up and scales out independently
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以独立扩展。
- en: It is best suited for containerized deployment, which is a cost-effective solution
    when compared to VMs
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与VM相比，它最适合容器化部署，这是一种经济有效的解决方案
- en: Each component can be reused through an endpoint and modifying any service does
    not affect other services
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个组件可以通过端点重用，并且修改任何服务不会影响其他服务
- en: Development is faster when compared to monolithic architecture
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与单体架构相比，开发速度更快
- en: As each microservice provides a particular business capability, it is easily
    reusable and composable
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个微服务提供特定的业务能力，因此它很容易被重用和组合
- en: As each service is independent, using old architecture or technology is not
    a concern.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于每个服务都是独立的，因此使用旧的架构或技术并不是一个问题。
- en: It is resilient and eliminates monolith failover scenarios
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是弹性的，消除了单体故障转移场景
- en: Standard practice when developing microservices
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发微服务的标准实践
- en: As standard practice, microservices are designed and decomposed based on business
    capability or business domain. Business domain decomposition follows a **Domain-Driven
    Design** (**DDD**) pattern, where each service is developed to provide specific
    functionality of the business domain. This contrasts with a layered architecture
    approach, in which the application is divided into multiple layers, where each
    layer is dependent on another layer and has tight dependencies on it, and removing
    any layer breaks the whole application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为标准做法，微服务是根据业务能力或业务领域设计和分解的。业务领域分解遵循**领域驱动设计**（**DDD**）模式，其中每个服务都被开发为提供业务领域的特定功能。这与分层架构方法相反，分层架构方法将应用程序分成多个层，其中每个层依赖于另一层，并且对其有严格的依赖性，移除任何一层都会破坏整个应用程序。
- en: 'The following diagram illustrates the difference between layered architecture
    and microservices architecture:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了分层架构和微服务架构之间的区别：
- en: '![](img/00094.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00094.jpeg)'
- en: Types of microservices
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务的类型
- en: 'Microservices are divided into two categories, which are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务分为两类，如下所示：
- en: Stateless microservices
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态微服务
- en: Stateful microservices
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有状态的微服务
- en: Stateless microservices
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无状态微服务
- en: A stateless service has either no state or the state can be retrieved from an
    external data store. As the state is stored separately, multiple instances can
    run at the same time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态服务要么没有状态，要么可以从外部数据存储中检索状态。由于状态是单独存储的，多个实例可以同时运行。
- en: Stateful microservices
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有状态的微服务
- en: A stateful service maintains the state within its own context. Only a single
    instance is active at a time. However, the state is replicated to other inactive
    instances as well.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态服务在其自己的上下文中维护状态。一次只有一个实例是活动的。但是，状态也会复制到其他非活动实例中。
- en: DDD
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DDD
- en: DDD is a pattern that emphasizes the business domain of the application. When
    building the application following a DDD pattern, we divide the application based
    on business domains, where each domain has one or more bounded contexts and the
    bounded context represents the business requirement. In technical terms, each
    bounded context has its own code and persistence mechanism and is independent
    of the others. Consider a vendor-management system where a vendor registers with
    the website, logs into the website, updates their profile, and attaches quotations.
    Each type of action will be termed the bounded context and is independent of the
    others. A set of vendor-operations can be termed a vendor domain.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: DDD是一种强调应用程序业务域的模式。在按照DDD模式构建应用程序时，我们根据业务域划分应用程序，每个域都有一个或多个有界上下文，有界上下文代表业务需求。在技术术语中，每个有界上下文都有自己的代码和持久性机制，并且独立于其他上下文。考虑一个供应商管理系统，供应商在网站上注册，登录网站，更新其个人资料并附加报价。每种操作都被称为有界上下文，并且独立于其他操作。一组供应商操作可以称为供应商领域。
- en: DDD splits the requirement into domain-specific chunks known as bounded contexts,
    where each bounded context has its own model, logic, and data. There are chances
    that a single service is used by many services because of the core functionality
    it provides. For example, a vendor registration service uses an identity service
    to create a new user and the same identity service may be used by some other service
    to log into the system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: DDD将需求分解为特定领域的块，称为有界上下文，每个有界上下文都有自己的模型，逻辑和数据。有可能一个单一服务被许多服务使用，因为它提供了核心功能。例如，供应商注册服务使用身份验证服务来创建新用户，同样的身份验证服务可能被其他服务用来登录系统。
- en: Data manipulation with microservices
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用微服务进行数据操作
- en: 'As a general practice, each service provides specific business functionality
    to the user and involves **Create**, **Read**, **Update**, and **Delete** (**CRUD**) operations.
    In enterprise applications, we have one or more databases that have a number of
    tables. Following the DDD pattern, we can design each service that focuses on
    the specific domain. However, there are conditions where we need to extract the
    data from some other databases or tables that are out of scope from the service''s
    domain. However, there are two options to address this challenge:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般做法，每个服务为用户提供特定的业务功能，并涉及**创建**，**读取**，**更新**和**删除**（**CRUD**）操作。在企业应用程序中，我们有一个或多个具有许多表的数据库。遵循DDD模式，我们可以设计每个专注于特定领域的服务。但是，有时我们需要从一些其他超出服务领域范围的数据库或表中提取数据。然而，有两种方法可以解决这个挑战：
- en: Wrapping microservices behind an API gateway
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将微服务包装在API网关后面
- en: Decomposing data into a flat schema for read/query purposes
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据分解为扁平模式以供读取/查询目的
- en: Wrapping microservices behind an API gateway
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将微服务包装在API网关后面
- en: 'An enterprise application that is based on microservices architecture contains
    many services. An **Entity Resource Planning** (**ERP**) system contains many
    modules, such as **Human Resources** (**HR**), financial, purchase requisition,
    and others. Each module may have a number of services providing specific business
    features. For example, the HR module may contain the following three services:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基于微服务架构的企业应用程序包含许多服务。**企业资源规划**（**ERP**）系统包含许多模块，如**人力资源**（**HR**），财务，采购申请等。每个模块可能有许多提供特定业务功能的服务。例如，HR模块可能包含以下三个服务：
- en: Personal record management
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人记录管理
- en: Appraisal management
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估管理
- en: Recruitment management
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 招聘管理
- en: The personal record management service exposes certain methods to create, update,
    or delete an employee's basic information. The appraisal-management service exposes
    certain methods to create appraisal requests for an employee, and the recruitment-management
    service performs new hiring decisions. Suppose we need to develop a web page that
    contains the basic employee information and the total number of appraisals done
    in the last five years. In this case, we will be calling two services, namely
    personal-record management and appraisal management, and two separate calls will
    be made by the caller to these services. Alternatively, we can wrap these two
    calls into a single call using an API gateway. The technique to address this scenario
    is known as **API composition** and is discussed in the *What is API composition?*
    section later in the chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 个人记录管理服务公开了一些方法，用于创建、更新或删除员工的基本信息。绩效管理服务公开了一些方法，用于为员工创建绩效评估请求，招聘管理服务执行新的招聘决策。假设我们需要开发一个包含基本员工信息和过去五年内完成的评估总数的网页。在这种情况下，我们将调用两个服务，即个人记录管理和绩效管理，调用者将对这些服务进行两次单独的调用。或者，我们可以将这两个调用封装成一个单一的调用，使用API网关。解决这种情况的技术称为**API组合**，在本章后面的*什么是API组合？*部分中进行了讨论。
- en: Denormalizing data into a flat schema for read/query purposes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据非规范化为扁平模式以供读取/查询
- en: This is another technique where we want to consume a service to read data from
    heterogeneous sources. It could be from multiple tables or databases. To transform
    multiple service calls into a single call, we can design each service and use
    patterns such as publisher/subscriber or mediator that listen for any CRUD operation
    to be performed on any service, save the data into a flat schema, and develop
    a service that only reads the data from that table(s). The technique to address
    this scenario is known as  **Command Query Responsibility Segregation** (**CQRS**)
    and is discussed in the CQRS section later in the chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种技术，我们希望消费一个服务来从异构源读取数据。它可以来自多个表或数据库。为了将多个服务调用转换为单个调用，我们可以设计每个服务，并使用发布者/订阅者或中介等模式，监听要在任何服务上执行的任何CRUD操作，将数据保存到扁平模式中，并开发一个仅从该表中读取数据的服务。解决这种情况的技术称为**命令查询责任分离**（**CQRS**），在本章后面的CQRS部分中进行了讨论。
- en: Consistency across business scenarios
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务场景的一致性
- en: 'As we understand that each service is designed to serve a specific business
    functionality, let''s take an example of an order-management system where a customer
    comes to the website and places an order. Once the order is placed, it is reflected
    in the inventory. In this scenario, we can have two microservices: one that places
    an order and creates a database record into the order database and an inventory
    service that performs CRUD on the inventory-related tables:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们了解到每个服务都设计为提供特定的业务功能，让我们以订单管理系统为例，客户访问网站并下订单。下订单后，库存会反映出来。在这种情况下，我们可以有两个微服务：一个用于下订单并在订单数据库中创建数据库记录，另一个是执行库存相关表上的CRUD的库存服务：
- en: '![](img/00095.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00095.jpeg)'
- en: The important practice to follow when implementing an end-to-end business scenario
    and bringing consistency across multiple microservices is to keep the data and
    model specific to their domain. Considering the preceding example, the order placement
    service should not access or perform CRUD operations other than order tables,
    and if it is necessary to access any data which is out of the domain of that service,
    it should call that service directly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施端到端业务场景并在多个微服务之间保持一致性时，要遵循的重要实践是保持数据和模型特定于其领域。考虑前面的例子，订单放置服务不应访问或执行订单表以外的CRUD操作，如果需要访问任何超出该服务领域的数据，应直接调用该服务。
- en: An **Atomicity, Consistency, Integrity, and Durability** (**ACID**) transaction
    is another challenge. We may have multiple services serving one complete transaction,
    where each transaction is behind and operated by a separate service. To accommodate
    ACID transactions with the microservices architecture style, we can implement
    **asynchronous event-driven communication**, which is discussed later in the chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**原子性、一致性、完整性和持久性**（**ACID**）事务是另一个挑战。我们可能有多个服务为一个完整的事务提供服务，其中每个事务都在一个单独的服务后面运行。为了适应微服务架构风格的ACID事务，我们可以实现**异步事件驱动通信**，这将在本章后面进行讨论。'
- en: Communication with microservices
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与微服务通信
- en: In microservices architecture, each microservice is hosted at some server, most
    likely a container, and exposes an endpoint. These endpoints can be used to communicate
    to that service. There are many protocols that we can use but REST-based HTTP
    endpoints are most widely used due to their accessibility support on many platforms.
    In ASP.NET Core, we can create microservices using the ASP.NET Core MVC framework
    and use them through a RESTful endpoint. There are microservices that use other
    microservices as well to complete a particular operation and this can easily be
    done using the `HttpClient` class in .NET Core. However, we should design in such
    a way that our service offers resiliency and handles transient faults.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个微服务都托管在某个服务器上，很可能是一个容器，并公开一个端点。这些端点可以用于与该服务进行通信。有许多协议可以使用，但由于在许多平台上具有可访问性支持，基于REST的HTTP端点是最广泛使用的。在ASP.NET
    Core中，我们可以使用ASP.NET Core MVC框架创建微服务，并通过RESTful端点使用它们。还有一些微服务也使用其他微服务来完成特定操作，这可以很容易地通过.NET
    Core中的`HttpClient`类来实现。然而，我们应该设计成这样，使我们的服务具有弹性，并处理瞬态故障。
- en: Database architecture in microservices
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构中的数据库架构
- en: With microservices architecture, each service provides a certain functionality
    and has minimal dependencies on other services. However, porting the relational
    database into the smaller sets is a challenge, where each set represents a particular
    domain and contains tables related to that domain. Segregating tables based on
    domain and making them individual databases needs proper consideration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构，每个服务提供特定功能，并且对其他服务的依赖性很小。然而，将关系数据库转换为较小的集合是一个挑战，其中每个集合代表一个特定领域，并包含与该领域相关的表。根据领域对表进行分离并使它们成为独立的数据库需要适当的考虑。
- en: 'Let''s consider the vendor management system that provides **Business-to-Consumer**
    (**B2C**) and **B****usiness-to-Business** (**B2B**) processes and involves the
    following operations:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑提供**企业对消费者**（B2C）和**企业对企业**（B2B）流程的供应商管理系统，并涉及以下操作：
- en: Vendor registers with the website
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商在网站上注册
- en: Vendor adds products that can be purchased by other vendors or customers
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商添加其他供应商或客户可以购买的产品。
- en: Vendor places orders to purchase products
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商下订单购买产品
- en: 'To implement the preceding scenario, we can decompose the database based on
    the following two patterns:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现上述场景，我们可以根据以下两种模式对数据库进行分解：
- en: Tables per service
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务的表
- en: Database per service
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务的数据库
- en: Tables per service
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个服务的表
- en: 'With this design, each service is designed to use specific tables in the database.
    In this scenario, the database is centralized and hosted at one place. Other microservices
    also connect to the same database but deal with their own domain-specific tables:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种设计，每个服务都设计为使用数据库中的特定表。在这种情况下，数据库是集中的，托管在一个地方。其他微服务也连接到同一个数据库，但处理自己的领域特定表：
- en: '![](img/00096.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00096.jpeg)'
- en: This helps us to use the central database but any modification in the schema
    may break or require an update for one or many microservices.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于我们使用中央数据库，但模式的任何修改可能会破坏或需要更新一个或多个微服务。
- en: Database per service
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个服务的数据库
- en: 'With this design, each service has its own database and the application is
    loosely coupled. Modifications in the database do not harm or break any other
    service and offer complete isolation. This design is good for deployment scenarios,
    as each service contains its own database deployed in its own container:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种设计，每个服务都有自己的数据库，应用程序松散耦合。对数据库的修改不会损害或破坏任何其他服务，并提供完全隔离。这种设计对部署场景很有好处，因为每个服务都包含自己的数据库，部署在自己的容器中：
- en: '![](img/00097.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00097.jpeg)'
- en: Challenges in segregating tables or databases per service
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按服务分离表或数据库的挑战
- en: 'Segregating tables or databases as per business capability or business domain
    is recommended to limit dependencies and keep it intact with the domain model.
    But it also comes with some challenges. For example, we have two services: a vendor
    service and an order service. The vendor service is used to create a vendor record
    in its own vendor database, and the order service to place orders for a particular
    vendor. The challenge comes when we need to return the aggregated record of both
    the vendor and their orders to the user. To solve this problem, we can use either
    of the following two approaches:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 根据业务能力或业务领域对表或数据库进行分离，建议限制依赖关系并使其与领域模型保持完整。但这也带来了一些挑战。例如，我们有两个服务：供应商服务和订单服务。供应商服务用于在自己的供应商数据库中创建供应商记录，订单服务用于为特定供应商下订单。当我们需要将供应商及其订单的聚合记录返回给用户时，就会面临挑战。为了解决这个问题，我们可以使用以下两种方法之一：
- en: API composition
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API组合
- en: CQRS
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CQRS
- en: What is API composition?
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是API组合？
- en: API composition is a technique in which multiple microservices are composed
    to expose one endpoint to the user and provides an aggregated view. In a single
    database, this is easily possible by making a SQL query join and getting the data
    from different tables.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: API组合是一种技术，其中多个微服务被组合以向用户公开一个端点，并提供聚合视图。在单个数据库中，通过进行SQL查询连接并从不同表中获取数据，这是很容易实现的。
- en: Let's consider the vendor management system, where we have two services. One
    is used to register a new vendor and has a corresponding database to persist vendor
    demographics, address, and other information. The other service is the order service,
    which is used to store the transactional data of the vendor and contains order
    information such as order number, quantity, and so on. Suppose we have a requirement
    to display the list of vendors with all the orders that are completed. With this
    scenario, we can provide a method in the vendor registration service that first
    loads the vendor details from its own data store, then loads their orders by calling
    the order service, and finally returns the aggregated data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑供应商管理系统，我们有两个服务。一个用于注册新供应商，并有相应的数据库来保存供应商的人口统计学、地址和其他信息。另一个服务是订单服务，用于存储供应商的交易数据，并包含订单信息，如订单号、数量等。假设我们有一个要求显示已完成订单的供应商列表。在这种情况下，我们可以在供应商注册服务中提供一个方法，首先从自己的数据存储中加载供应商详细信息，然后通过调用订单服务加载他们的订单，最后返回聚合数据。
- en: CQRS
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS
- en: CQRS is a principle in which application commands such as create, update, and
    delete are segregated by read operations. It works on the event-based model and
    when any create, update, or delete action is taken on the API, the event handler
    is invoked and stores that information into its own corresponding data store.
    We can implement CQRS in the previous vendor registration example, which will
    facilitate querying the vendor and their orders from a single service. When any
    command (create, update, delete) operation is performed on the vendor or order
    service, it will invoke the handler that invokes the query service to save the
    updated data into its store.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS是一个原则，其中应用程序命令（如创建，更新和删除）被读操作分隔。它基于事件模型工作，当API上采取任何创建，更新或删除操作时，事件处理程序被调用并将该信息存储到其相应的数据存储中。我们可以在先前的供应商注册示例中实现CQRS，这将方便从单个服务查询供应商及其订单。当在供应商或订单服务上执行任何命令（创建，更新，删除）操作时，它将调用处理程序来调用查询服务，将更新的数据保存到其存储中。
- en: 'We can keep the data in a flat schema or used NoSQL database to hold all the
    information about the vendor and their orders and read them when required:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将数据保留在扁平模式中，或者使用NoSQL数据库来保存有关供应商及其订单的所有信息，并在需要时读取它们：
- en: '![](img/00098.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00098.jpeg)'
- en: 'The preceding diagram represents three services: vendor service, order service,
    and query service. When any create, update, or delete operation is performed on
    the vendor service, the event is raised and the corresponding handler is invoked
    that makes the HTTP POST, PUT, or DELETE request on the query service to save
    or update its data store. The same goes for the order service, which calls the
    query service and stores the information related to orders. Finally, the query
    service is used to read the cumulative data of independent services in a single
    call.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表代表了三个服务：供应商服务，订单服务和查询服务。当在供应商服务上执行任何创建，更新或删除操作时，事件被触发，并调用相应的处理程序，使HTTP POST，PUT或DELETE请求在查询服务上保存或更新其数据存储。订单服务也是如此，它调用查询服务并存储与订单相关的信息。最后，查询服务用于在单个调用中读取独立服务的累积数据。
- en: 'The benefits of this approach are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处如下：
- en: We can make optimize the query database by defining cluster and non-cluster
    indexes
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过定义集群和非集群索引来优化查询数据库
- en: We can use some other database model, such as NoSQL, MongoDB, or Elasticsearch,
    to provide a faster retrieval and search experience to the user
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用其他数据库模型，如NoSQL，MongoDB或Elasticsearch，为用户提供更快的检索和搜索体验
- en: Each service has its own data store but, with this approach, we can aggregate
    the data in one place
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都有自己的数据存储，但是通过这种方法，我们可以将数据聚合在一个地方
- en: We can use the query data for reporting purposes
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用查询数据进行报告
- en: CQRS can be implemented using the mediator pattern, which we will discuss later
    in the chapter.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS可以使用中介者模式来实现，我们将在本章后面讨论。
- en: Developing microservices architecture with .NET Core
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET Core开发微服务架构
- en: 'So far, we have learned the fundamentals of microservices and the importance
    of DDD. In this section, we will develop a microservices architecture for a sample
    application that contains the following features:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了微服务的基础知识和DDD的重要性。在本节中，我们将为一个包含以下功能的示例应用程序开发微服务架构：
- en: Identity service
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份服务
- en: Vendor service
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 供应商服务
- en: Creating a sample app in .NET Core using microservices architecture
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用微服务架构在.NET Core中创建一个示例应用程序
- en: 'In this section, we will create a sample app in .NET Core and define services
    that include the authorization server, a vendor service, and an order service.
    To start with, we can use either Visual Studio 2017 or Visual Studio Code and
    create projects using dotnet **Command-Line Interface** (**CLI**) tools. The advantage
    of choosing Visual Studio 2017 is that it provides an option while creating the
    project to enable Docker support, add the Docker-related files, and make Docker
    the startup project:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在.NET Core中创建一个示例应用程序，并定义包括授权服务器、供应商服务和订单服务在内的服务。首先，我们可以使用Visual Studio
    2017或Visual Studio Code，并使用dotnet **命令行界面**（**CLI**）工具创建项目。选择Visual Studio 2017的优势在于，在创建项目时提供了一个选项，可以启用Docker支持，添加与Docker相关的文件，并将Docker设置为启动项目：
- en: '![](img/00099.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00099.jpeg)'
- en: Solution structure
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案结构
- en: 'The structure of the solution will look like the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的结构将如下所示：
- en: '![](img/00100.jpeg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.jpeg)'
- en: In the preceding structure, we have root folders, namely `Core`, `Microservices`,
    and `WebFront`. The common and core components reside in `Core`, all the microservices
    reside in the `Microservices` folder, and `WebFront` contains the frontend projects,
    most likely the ASP.NET MVC Core project, mobile application, and so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述结构中，我们有根文件夹，即`核心`，`微服务`和`WebFront`。共同和核心组件驻留在`核心`中，所有微服务驻留在`微服务`文件夹中，`WebFront`包含前端项目，很可能是ASP.NET
    MVC Core项目，移动应用程序等。
- en: Creating projects inside designated folders gives proper meaning to the solution
    and makes it easy to understand the overall picture of the solution.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定文件夹内创建项目可以为解决方案赋予适当的含义，并且使得理解解决方案的整体图像变得容易。
- en: 'The following table shows the projects created inside each folder:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了每个文件夹中创建的项目：
- en: '| **Folder** | **Project name** | **Project type** | **Description** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **文件夹** | **项目名称** | **项目类型** | **描述** |'
- en: '| `Core` | `Infrastructure` | .NET Standard 2.0 | Contains repository classes,
    `UnitOfWork` and `BaseEntity` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `核心` | `基础设施` | .NET标准2.0 | 包含存储库类，`UnitOfWork`和`BaseEntity` |'
- en: '| `Core` | `APIComponents` | .NET Standard 2.0 | Contains `BaseController`,
    `LoggingActionFilter` and `ResilientHttpClient`  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `核心` | `API组件` | .NET标准2.0 | 包含`BaseController`，`LoggingActionFilter`和`ResilientHttpClient`
    |'
- en: '| `Microservices > AuthServer` | `Identity.AuthServer` | ASP.NET Core 2.0 web
    API | Authorization server using OpenIddict and ASP.NET Core Identity |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `微服务 > 认证服务器` | `Identity.AuthServer` | ASP.NET Core 2.0 web API | 使用OpenIddict和ASP.NET
    Core Identity的授权服务器 |'
- en: '| `Microservices >``Vendor` | `Vendor.API` | ASP.NET Core 2.0 web API | Contains
    vendor API controllers |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `微服务 >``供应商` | `供应商.API` | ASP.NET Core 2.0 web API | 包含供应商API控制器 |'
- en: '| `Microservices >``Vendor` | `Vendor.Domain` | .NET Standard 2.0 | Contains
    domain models specific to the vendor domain |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `微服务 >``供应商` | `供应商.Domain` | .NET Standard 2.0 | 包含特定于供应商领域的领域模型 |'
- en: '| `Microservices >``Vendor` | `Vendor.Infrastructure` | .NET Standard 2.0 |
    Contains vendor-specific repository and database context |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `微服务 >``供应商` | `供应商.Infrastructure` | .NET Standard 2.0 | 包含特定于供应商的存储库和数据库上下文
    |'
- en: '| `WebFront` | `FraymsWebApp` | ASP.NET Core 2.0 web app | Contains frontend
    views, pages, and client-side framework |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `WebFront` | `FraymsWebApp` | ASP.NET Core 2.0 web app | 包含前端视图、页面和客户端框架
    |'
- en: Logical architecture
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑架构
- en: 'The logical architecture of the sample application represents two microservices,
    namely the identity service and vendor service. The identity service is used to
    perform user authentication and authorization, whereas the vendor service is used
    to perform vendor registration:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用的逻辑架构代表了两个微服务，即身份服务和供应商服务。身份服务用于执行用户身份验证和授权，而供应商服务用于执行供应商注册：
- en: '![](img/00101.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.jpeg)'
- en: We will be using the DDD approach to articulate the data model, where each service
    will have its own corresponding tables.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用DDD方法来表达数据模型，其中每个服务将有其自己对应的表。
- en: The vendor service is based on business domain and is divided into three layers,
    namely the API that exposes HTTP endpoints and is used by the client, the domain
    that contains domain entities, aggregates, and DDD patterns, and the infrastructure
    layer that contains all common classes that include repository, **Entity Framework**
    (**EF**), Core context, and other helper classes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商服务基于业务领域，分为三层，即暴露HTTP端点并由客户端使用的API层，包含领域实体、聚合和DDD模式的领域层，以及包含所有通用类的基础设施层，包括存储库、**Entity
    Framework** (**EF**)、Core上下文和其他辅助类。
- en: The domain layer is the actual layer that defines the business logic and the
    entities, usually **Plain Old CLR Object** (**POCO**), for a particular business
    scenario. It should not have any direct dependency on any database framework or
    **Object Relationship Mapping** (**ORM**) such as EF, Hibernate, and others. However,
    with EF Core, we have a provision to keep entities separate from other assemblies
    and define them as POCO entities, removing dependencies from EF Core libraries.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 领域层是实际定义业务逻辑和实体的层，通常是特定业务场景的**Plain Old CLR Object** (**POCO**)。它不应直接依赖于任何数据库框架或**对象关系映射**
    (**ORM**)，如EF、Hibernate等。然而，使用EF Core，我们可以将实体与其他程序集分开，并将它们定义为POCO实体，从而消除对EF Core库的依赖。
- en: 'When a request comes to an API, it uses the domain layer to execute a particular
    business scenario and pass the data it receives. The domain layer executes the
    business logic and uses the infrastructure layer to perform CRUD on the database.
    Finally, the response is sent back to the caller from an API:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当API收到请求时，它使用领域层执行特定的业务场景并传递接收到的数据。领域层执行业务逻辑并使用基础设施层对数据库执行CRUD操作。最后，API将响应发送回调用者：
- en: '![](img/00102.gif)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00102.gif)'
- en: Developing a Core infrastructure project
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发核心基础设施项目
- en: This project contains the core classes and components used by the application.
    It will contain some generic or base classes, façade, and other helper classes
    that are common throughout the application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目包含应用程序使用的核心类和组件。它将包含一些通用或基础类、门面和其他在整个应用程序中通用的辅助类。
- en: We will create the following classes and discuss how they are useful for other
    projects specific to microservices.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下类，并讨论它们对于特定于微服务的其他项目的用处。
- en: Creating the BaseEntity class
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建BaseEntity类
- en: '[PRE0]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Any property being annotated with the `NotMapped` attribute does not create
    corresponding fields in the backend database.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NotMapped`属性注释的任何属性都不会在后端数据库中创建相应的字段。
- en: The UnitOfWork pattern
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UnitOfWork模式
- en: 'We will implement the `UnitOfWork` pattern to save the context changes in a
    single call to the backend database. Updating the database on each object state
    change is not good practice and reduces the application performance. Consider
    an example of a form that contains a table where each row is editable. Committing
    a change in a database on each row update reduces application performance. The
    better way is to keep each row state in memory and update the database once the
    form is posted. With the Unit of Work pattern, we can define an interface that
    contains the following four methods:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现`UnitOfWork`模式，以便在单个调用中保存上下文更改到后端数据库。在每个对象状态更改时更新数据库不是一个好的做法，会降低应用程序性能。考虑一个包含可编辑表格的表单的例子。在每次行更新时提交更改到数据库会降低应用程序性能。更好的方法是将每行状态保存在内存中，并在提交表单后一次性更新数据库。使用Unit
    of Work模式，我们可以定义一个包含以下四个方法的接口：
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The interface contains transaction-related methods, namely `BeginTransaction`,
    `RollbackTransaction`, and `CommitTransaction`, where `SaveChangesAsync` is used
    to save the changes to the database. Each service has its own database context
    implementation and implements the `IUnitOfWork` interface to provide transaction
    handling and save changes to a backend database.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接口包含与事务相关的方法，即`BeginTransaction`、`RollbackTransaction`和`CommitTransaction`，其中`SaveChangesAsync`用于保存对数据库的更改。每个服务都有自己的数据库上下文实现，并实现了`IUnitOfWork`接口，以提供事务处理并将更改保存到后端数据库。
- en: Creating a repository interface
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储库接口
- en: 'We will create a generic repository interface that will be implemented by each
    service''s repository class, as each service will be following a DDD approach
    and has its own repository to give meaningful information to the developer based
    on the business domain. In this interface, we can keep generic methods such as `All`
    and `Contains` and a property to return `UnitOfWork`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个通用的存储库接口，每个服务的存储库类都将实现该接口，因为每个服务都将遵循DDD方法，并且都有自己的存储库，以便根据业务域向开发人员提供有意义的信息。在这个接口中，我们可以保留通用方法，如`All`和`Contains`，以及返回`UnitOfWork`的属性：
- en: '[PRE3]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Logging
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录
- en: 'Logging is an essential part of any enterprise application. Through logging,
    we can trace or troubleshoot actual errors when the application is running. In
    any good product, we usually see that each error has an error code. Defining error
    codes and then using them while logging exceptions intuitively tells the developers
    or the support team to troubleshoot and reach the point where the actual error
    occurred and provide a solution. For all application-level errors, we can create
    a `LoggingEvents` class and specify the constant values that can be further used
    during development. Here is the `LoggingEvents` class that contains a few `GET`,
    `CREATE`, `UPDATE`, and other event codes. We can create this class under a `Façade`
    folder inside the `Infrastructure` project:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是任何企业应用程序的重要部分。通过日志记录，我们可以在应用程序运行时跟踪或排除实际错误。在任何优秀的产品中，我们通常看到每个错误都有一个错误代码。定义错误代码，然后在记录异常时使用它们直观地告诉开发人员或支持团队进行故障排除，并达到实际错误发生的地点并提供解决方案。对于所有应用程序级错误，我们可以创建一个`LoggingEvents`类，并指定在开发过程中可以进一步使用的常量值。这是包含一些`GET`、`CREATE`、`UPDATE`和其他事件代码的`LoggingEvents`类。我们可以在`Infrastructure`项目的`Façade`文件夹下创建这个类：
- en: '[PRE4]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating the APIComponents infrastructure project
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建APIComponents基础设施项目
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`BaseController` takes `ILogger` in a parametrized constructor that will be
    injected through the built-in **Dependency Injection** (**DI**) component of ASP.NET
    Core.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseController`在参数化构造函数中使用`ILogger`，它将通过ASP.NET Core的内置**依赖注入**（**DI**）组件进行注入。'
- en: The `LogException` method is used to log the exception and returns the `HttpResponseMessage`
    that will be returned by the derived controller to the user in case of any error.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`LogException`方法用于记录异常并返回`HttpResponseMessage`，在发生任何错误时，派生控制器将返回给用户。'
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this project, we also have `ResilientHttpClient` that we learned in [Chapter
    7](part0173.html#54VHA0-84c100e6bea3438e8844d99ae7f5dfa9), *Securing and Implementing
    Resilience in .NET Core Applications*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们还有`ResilientHttpClient`，我们在[第7章](part0173.html#54VHA0-84c100e6bea3438e8844d99ae7f5dfa9)中学习了*在.NET
    Core应用程序中实现弹性和安全*。
- en: Developing an identity service for user authorization
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为用户授权开发身份服务
- en: In ASP.NET Core, we have a choice of authenticating applications from various
    authentication providers. In microservices architecture, services are deployed
    and hosted separately in different containers. We can use ASP.NET Core Identity
    and add it as middleware in the service itself, or we can use IdentityServer and
    develop a central authentication server to perform authentication and authorization
    centrally, access all the services that are registered with the **Central Authentication
    Server** (**CAS**), and access protected resources by passing tokens.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中，我们可以选择从各种身份验证提供程序对应用程序进行身份验证。在微服务架构中，服务是分别部署和托管在不同的容器中的。我们可以使用ASP.NET
    Core Identity并将其添加为服务本身的中间件，或者我们可以使用IdentityServer并开发一个中央身份验证服务器来执行身份验证和授权中心化，访问所有注册到**中央身份验证服务器**（**CAS**）的服务，并通过传递令牌访问受保护的资源。
- en: The identity service basically acts as a CAS that registers all the services
    in the enterprise. When the request comes to the service, it asks for the token
    that can be obtained from the authorization server. Once the token is obtained,
    it can be used to access the resource service.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 身份服务基本上充当注册企业中所有服务的CAS。当请求到达服务时，它会请求可以从授权服务器获取的令牌。一旦获得令牌，就可以用它来访问资源服务。
- en: 'There are various libraries to build the authentication server, which are as
    follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种库来构建身份验证服务器，如下所示：
- en: '**IdentityServer4**: IdentityServer4 is an OpenID Connect and OAuth 2.0 framework
    for ASP.NET Core'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IdentityServer4：IdentityServer4是ASP.NET Core的OpenID Connect和OAuth 2.0框架
- en: '**OpenIddict**: Easy to plug in solution to implement OpenID Connect server
    in ASP.NET Core project'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenIddict**：在ASP.NET Core项目中实现OpenID Connect服务器的易于插入的解决方案'
- en: '**ASOS (AspNet.Security.OpenIdConnect.Server)**: ASOS is an advanced OpenID
    Connect server designed to offer a low-level protocol-first approach'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASOS (AspNet.Security.OpenIdConnect.Server)**：ASOS是一个高级的OpenID Connect服务器，旨在提供低级协议优先的方法'
- en: We will be using OpenIddict in our identity service.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的身份服务中使用OpenIddict。
- en: OpenIddict connect flows
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenIddict连接流
- en: OpenIddict offers various types of flows, including authorization code flow,
    password flow, client credentials flow, and others. However, we have used implicit
    flow in this chapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: OpenIddict提供各种类型的流，包括授权代码流、密码流、客户端凭据流等。然而，在本章中，我们使用了隐式流。
- en: 'In implicit flow, the tokens are retrieved through the authorization endpoint
    by passing a username and password. All communication is done with the authorization
    server in a single round trip. Once the authentication is done, the token is added
    in the redirect URI and can be later used by passing in the request header for
    subsequent requests. The following diagram depicts how implicit flow works:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在隐式流中，令牌是通过授权端点通过传递用户名和密码来检索的。所有通信都在单次往返中与授权服务器完成。认证完成后，令牌被添加到重定向URI中，并且可以在后续请求中通过传递请求标头来使用。以下图表描述了隐式流的工作原理：
- en: '![](img/00103.gif)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00103.gif)'
- en: Implicit flow is widely used with **Single-Page Applications** (**SPAs**). The
    process starts when an SPA web application wants to access the protected web API
    from the resource server. As the web API is protected, it needs a token to authenticate
    the request and validate the caller. To obtain the token (commonly known as a
    bearer token), the SPA web app first proceeds to the authorization server and
    enters the username and password. After successful authentication, the authorization
    server returns the token and appends it to the redirect URI itself. The web application
    parses the **Uniform Resource Locator** (**URL**) and retrieves the token and
    further used to access the protected resources.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式流广泛用于**单页应用程序**（**SPAs**）。该过程始于单页应用程序Web应用程序希望访问受保护的资源服务器上的受保护的Web API。由于Web
    API受保护，它需要一个令牌来验证请求并验证调用者。为了获取令牌（通常称为持有者令牌），单页应用程序首先前往授权服务器并输入用户名和密码。成功验证后，授权服务器返回令牌并将其附加到重定向URI本身。Web应用程序解析**统一资源定位符**（**URL**）并检索令牌，进一步用于访问受保护的资源。
- en: Creating the identity service project
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建身份服务项目
- en: 'The identity service is an ASP.NET Core web API project. To use OpenIddict
    libraries, we have to add an `aspnet-contrib` reference to our Visual Studio package
    sources dialog. To add this source from Visual Studio, click on the NuGet Package
    Manager by right-clicking on the project and then hitting the settings button,
    as shown in the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 身份服务是一个ASP.NET Core Web API项目。要使用OpenIddict库，我们必须在Visual Studio的包源对话框中添加一个`aspnet-contrib`引用。要从Visual
    Studio中添加此源，请右键单击项目，然后点击设置按钮，如下截图所示：
- en: '![](img/00104.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00104.jpeg)'
- en: 'Then add the entry of `aspnet-contrib` with the source as [https://www.myget.org/F/aspnet-contrib/api/v3/index.json](https://www.myget.org/F/aspnet-contrib/api/v3/index.json):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加`aspnet-contrib`的条目，源为[https://www.myget.org/F/aspnet-contrib/api/v3/index.json](https://www.myget.org/F/aspnet-contrib/api/v3/index.json)：
- en: '![](img/00105.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00105.jpeg)'
- en: Once this is added, we can now easily add OpenIddict packages from the NuGet
    Package Manager window.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这些后，我们现在可以在NuGet包管理器窗口中轻松添加OpenIddict包。
- en: Remember to check that the Include prerelease checkbox is selected.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住检查是否选中了包括预发布复选框。
- en: 'The following are the packages that we can add directly to our project file
    or from the NuGet Package Manager window in Visual Studio:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以直接添加到项目文件或从Visual Studio的NuGet包管理器窗口中添加的包：
- en: '[PRE10]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Add custom UserEntity and UserRole classes**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加自定义UserEntity和UserRole类**'
- en: ASP.NET Core Identity contains `IdentityUser` and `IdentityRole` classes and
    uses EF Core to create a backend database. However, if we want to customize the
    default tables, we can do so by inheriting from these base classes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core Identity包含`IdentityUser`和`IdentityRole`类，并使用EF Core来创建后端数据库。但是，如果我们想要自定义默认表，可以通过继承这些基类来实现。
- en: 'We will create a `Models` folder and customize `IdentityUser` by creating a
    custom `UserEntity` class and adding the following four fields:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Models`文件夹，并通过创建自定义的`UserEntity`类来自定义`IdentityUser`，并添加以下四个字段：
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have added these fields so when a vendor registers, we will keep their first
    name, last name, and ID in this table. Next, we add another class, `UserRole`,
    which derives from `IdentityRole`, and add the parametrized constructor as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了这些字段，所以当供应商注册时，我们将在这个表中保留他们的名字、姓氏和ID。接下来，我们添加另一个类`UserRole`，它派生自`IdentityRole`，并添加以下参数化构造函数：
- en: '[PRE12]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will add the custom database context class that derives from `IdentityDbContext`
    and specify `UserEntity` and `UserRoleEntity` types as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个自定义数据库上下文类，它派生自`IdentityDbContext`，并指定`UserEntity`和`UserRoleEntity`类型如下：
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can run EF Core migrations to create ASP.NET Identity tables, and we can
    run migration using EF CLI tooling. Before running the migration, we add the following
    entries in the `ConfigureServices` method of our `Startup` class:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行EF Core迁移来创建ASP.NET Identity表，也可以使用EF CLI工具运行迁移。在运行迁移之前，我们在`Startup`类的`ConfigureServices`方法中添加以下条目：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can run the EF migrations from the Visual Studio Package Manager Console
    window. To add migration, first run the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从Visual Studio的包管理器控制台窗口运行EF迁移。要添加迁移，首先运行以下命令：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Add-Migration` is the command of EF CLI toolset, where `Initial` is the name
    of the migration. Once we run this command, it will add the `Migrations` folder
    into our project and the `Initial` class containing `Up` and `Down` methods to
    apply or remove changes to the database. Next, we can run the `Update-Database`
    command that loads the `Initial` class and apply the changes to the backend database.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add-Migration`是EF CLI工具集的命令，其中`Initial`是迁移的名称。一旦我们运行这个命令，它将在我们的项目中添加`Migrations`文件夹和包含`Up`和`Down`方法的`Initial`类，以应用或移除对数据库的更改。接下来，我们可以运行`Update-Database`命令，加载`Initial`类并将更改应用到后端数据库。'
- en: 'Now we add the configuration related to the OpenIddict implicit flow in our
    `Startup` class. Here is the modified `ConfigureServices` method that adds the
    OpenIddict implicit flow:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在`Startup`类中添加与OpenIddict隐式流相关的配置。以下是修改后的`ConfigureServices`方法，添加了OpenIddict隐式流：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding method, we first add the `UseOpenIddict` method in the `AddDbContext`
    options that will create the OpenIddict-related tables in the database. Then,
    we configure Identity to use the same **JSON Web Tokens (JWT****)** claims as
    OpenIddict by setting the `IdentityOptions` as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们首先在`AddDbContext`选项中添加`UseOpenIddict`方法，它将在数据库中创建与OpenIddict相关的表。然后，我们通过设置`IdentityOptions`来配置Identity，以使用与OpenIddict相同的**JSON
    Web Tokens (JWT)**声明，如下所示：
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, we register the OpenIddict features and specify values by calling the
    `services.AddOpenIddict` method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用`services.AddOpenIddict`方法注册OpenIddict功能并指定值。
- en: 'Here is the `Configure` method that first enables** Cross-Origin Resource Sharing**
    (**CORS**), which allows requests from any header, origin, and method. Then, add
    authentication and call the `InitializeAsync` method to populate the OpenIddict
    tables with the application and resources (services) information:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Configure`方法，首先启用**跨源资源共享**（**CORS**），允许来自任何标头、来源和方法的请求。然后，添加身份验证并调用`InitializeAsync`方法，以填充OpenIddict表中的应用程序和资源（服务）信息：
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the `InitializeAsync` method shown as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是所示的`InitializeAsync`方法：
- en: '[PRE19]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding method, we have added the following three applications:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述方法中，我们添加了以下三个应用程序：
- en: '`bfrwebapp`: An ASP.NET Core web application. When the user hits the web application,
    it checks whether the user is authenticated based on whether the token is provided.
    If the user is not authenticated, it will redirect it to the authorization server.
    The user enters the credentials and, with successful authentication, it will redirect
    back to the `bfrwebapp`. The redirect URI specified within this scope is the URI
    of `bfrwebapp`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bfrwebapp`：一个ASP.NET Core Web应用程序。当用户访问Web应用程序时，它会检查用户是否经过身份验证，根据是否提供了令牌。如果用户未经身份验证，它将重定向到授权服务器。用户输入凭据，并在成功验证后，将重定向回`bfrwebapp`。在此范围内指定的重定向URI是`bfrwebapp`的URI。'
- en: '`vendor-api`: A vendor microservice with a unique client secret key.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vendor-api`：具有唯一客户端密钥的供应商微服务。'
- en: The preceding configuration is the server-side configuration and we will see
    what configuration needs to be added on the client side.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置是服务器端配置，我们将看到客户端需要添加哪些配置。
- en: '[PRE20]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`AuthorizationController` exposes two methods, namely `authorize` and `logout`.
    The `authorize` method checks whether the user is authenticated and returns a
    challenge that shows the login page, where the user can enter their username and
    password. Once the correct credentials are entered and the user is validated from
    the identity tables, the authorization server creates a new authentication token
    and returns it to the client application based on the redirect URI specified for
    `bfrwebapp`. To see the working example, please refer to the code repository.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizationController`公开两种方法，即`authorize`和`logout`。`authorize`方法检查用户是否经过身份验证，并返回一个挑战，显示登录页面，用户可以输入其用户名和密码。一旦输入了正确的凭据并且用户从身份表中验证通过，授权服务器将创建一个新的身份验证令牌，并根据为`bfrwebapp`指定的重定向URI将其返回给客户端应用程序。要查看工作示例，请参考代码存储库。'
- en: Implementing the vendor service
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现供应商服务
- en: 'The vendor service is a web API that exposes a method to perform vendor registration.
    This service implements the actual business domain of the vendor system where
    a vendor can register. As we learned in the previous section, we can decompose
    an application based on business capability or business domain. This service implements
    a DDD principle and decomposes based on business domain. It contains the following
    three projects:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商服务是一个Web API，公开了一个执行供应商注册的方法。该服务实现了供应商系统的实际业务领域，供应商可以注册。正如我们在前一节中所学到的，我们可以根据业务能力或业务领域来分解应用程序。该服务实现了DDD原则，并根据业务领域进行了分解。它包含以下三个项目：
- en: '`Vendor.API`: An ASP.NET Core Web API project that exposes methods to register
    a vendor'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vendor.API`：一个ASP.NET Core Web API项目，公开注册供应商的方法'
- en: '`Vendor.Domain`: .NET Standard 2.0 class library that contains POCO models
    such as `VendorMaster` and `VendorDocument`, and an `IVendorRepository` interface
    to define methods essential for a vendor domain.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vendor.Domain`：.NET Standard 2.0类库，包含诸如`VendorMaster`和`VendorDocument`之类的POCO模型，以及一个`IVendorRepository`接口，用于定义供应商领域的基本方法。'
- en: '`Vendor.Infrastructure`: .NET Standard 2.0 class library that contains a `VendorRepository`
    that implements the `IVendorRepository` interface and a `VendorDBContext` to perform
    database operations.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vendor.Infrastructure`：.NET Standard 2.0类库，包含实现`IVendorRepository`接口的`VendorRepository`和执行数据库操作的`VendorDBContext`。'
- en: Creating a vendor domain
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建供应商领域
- en: Create a new .NET Standard library project and name it `Vendor.Domain`. We will
    reference our `Infrastructure` project created previously to derive our POCO entities
    from the `BaseEntity` class.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的.NET Standard库项目，并将其命名为`Vendor.Domain`。我们将引用先前创建的`Infrastructure`项目，以从`BaseEntity`类派生我们的POCO实体。
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating the vendor infrastructure
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建供应商基础设施
- en: This project is a .NET Standard 2.0 class library project that reference the
    core `Infrastructure` and `Vendor.Domain` projects. This contains the actual implementation
    of the `VendorRepository` and a database context to connect with the backend SQL
    Server database.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目是一个.NET Standard 2.0类库项目，引用了核心`Infrastructure`和`Vendor.Domain`项目。其中包含了`VendorRepository`的实际实现以及与后端SQL
    Server数据库连接的数据库上下文。
- en: 'Here is the `VendorDBContext` class that derives from the `DbContext` class
    of EF Core and defines `DbSet` for the `VendorMaster` and `VendorDocument` entities:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`VendorDBContext`类，它从EF Core的`DbContext`类派生，并为`VendorMaster`和`VendorDocument`实体定义了`DbSet`：
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will also implement the `IUnitOfWork` interface, so when the `VendorRepository`
    is injected in a controller, we can perform transaction handling and save the
    changes to the associated database in a single call.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现`IUnitOfWork`接口，因此当`VendorRepository`被注入到控制器中时，我们可以执行事务处理并在单个调用中保存与关联数据库的更改。
- en: 'Here is the `VendorRepository` that implements the `IVendorRepository` interface:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现`IVendorRepository`接口的`VendorRepository`：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Creating the vendor service
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建供应商服务
- en: We will now create a vendor-service project that will expose methods for use
    by client applications to register a vendor. To start with, let's create a new
    ASP.NET Core web API project and name it `Vendor.API`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个供应商服务项目，该项目将公开供客户端应用程序使用的方法来注册供应商。首先，让我们创建一个新的ASP.NET Core Web API项目，并将其命名为`Vendor.API`。
- en: Implementing the mediator pattern in the vendor service
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在供应商服务中实现中介者模式
- en: In microservices architecture, an application is split into multiple services,
    where each service connects to the other services through an endpoint. There are
    possibilities that one service may invoke or interact with multiple services when
    the event is invoked. Segregating the interaction between services is always a
    recommended approach and solves tight dependencies on other services. For example,
    an application invokes this service to register a vendor and then invoke the identity
    service to create its user account and send an email by calling the messaging
    service. We can implement the mediator pattern to solve this scenario.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，一个应用被分割成多个服务，每个服务通过端点连接到其他服务。当事件被调用时，有可能一个服务会调用或与多个服务交互。隔离服务之间的交互始终是一种推荐的方法，并解决了对其他服务的紧密依赖。例如，一个应用程序调用此服务来注册供应商，然后调用身份服务来创建其用户帐户，并通过调用消息服务发送电子邮件。我们可以实现中介者模式来解决这种情况。
- en: The mediator pattern is based on the event-driven topology that works as a publisher/subscriber
    model. When any event is invoked, the registered handlers are called and execute
    the underlying logic. This encapsulates the logic of how services interact with
    one another, keeping the actual logic separate for each interaction. Moreover,
    the code is clean and easy to change.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者模式基于事件驱动的拓扑结构，作为发布者/订阅者模型。当任何事件被调用时，注册的处理程序被调用并执行底层逻辑。这封装了服务之间如何相互交互的逻辑，使得每个交互的实际逻辑保持分离。此外，代码清晰且易于更改。
- en: In `Vendor.API`, we will implement the mediator pattern using the `MediatR`
    library of .NET. `MediatR` is the implementation of the mediator pattern that
    supports command handling and domain event publishing. In the following section,
    we will implement mediator when the user registers and invoke the identity service
    to create a new user and send an email.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Vendor.API`中，我们将使用.NET的`MediatR`库实现中介者模式。`MediatR`是中介者模式的实现，支持命令处理和领域事件发布。在接下来的部分中，我们将在用户注册时实现中介者，并调用身份服务来创建新用户并发送电子邮件。
- en: 'To use `MediatR`, we have to add the following two packages:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`MediatR`，我们必须添加以下两个包：
- en: '`MediatR`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MediatR`'
- en: '`MediatR.Extensions.Microsoft.DependencyInjection`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MediatR.Extensions.Microsoft.DependencyInjection`'
- en: 'After adding these packages, we can add it in the `ConfigureServices` method
    by calling the `services.AddMediatR` method. `MediatR` provides the following
    two types of messages:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些包后，我们可以在`ConfigureServices`方法中调用`services.AddMediatR`方法添加它。`MediatR`提供以下两种类型的消息：
- en: '**Request/response**: Requests are commands that may or may not return a value'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求/响应**：请求是可能返回值的命令'
- en: '**Notification**: Notifications are events that may not return a value'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知**：通知是可能不返回值的事件'
- en: In our example, we will implement both request/response to save a vendor record
    into a database and, once it returns Boolean true as a response, we will invoke
    notification events to create a vendor user and send an email.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将实现请求/响应来将供应商记录保存到数据库中，并且一旦返回布尔值true作为响应，我们将调用通知事件来创建供应商用户并发送电子邮件。
- en: To implement request/response, we should define a class that implements the
    interface of `IRequestHandler`or `IRequestHandlet<TRequest, TResponse>`, where
    `TRequest` is the request object type and `TResponse` is the response object type.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现请求/响应，我们应该定义一个实现`IRequestHandler`或`IRequestHandlet<TRequest, TResponse>`接口的类，其中`TRequest`是请求对象类型，`TResponse`是响应对象类型。
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It implements the `IRequest` class that returns a Boolean value as a response.
    We have also specified our `VendorViewModel` that will be injected by the `MediatR`
    library when we pass them while calling the `send` method in the `VendorController`
    class.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 它实现了返回布尔值作为响应的`IRequest`类。我们还指定了我们的`VendorViewModel`，在调用`VendorController`类中的`send`方法时，将由`MediatR`库注入。
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When this handler is invoked, it will call the `Handle` method and pass the
    command and the cancellation token. From the command object, we can get the object
    we have passed while calling the `Send` method of the `IMediator` object in the
    `VendorController` class. This method calls the `Add` method of the `VendorRepository`
    and saves the information into the database. With the request/response approach,
    only one command handler is executed even if you have multiple handlers defined
    for the command. To call all the handlers, we can use notifications. We will extend
    the preceding example and add notification events and corresponding handlers that
    will be invoked once the command is executed successfully.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此处理程序时，它将调用`Handle`方法并传递命令和取消令牌。从命令对象中，我们可以获取在调用`VendorController`类中的`IMediator`对象的`Send`方法时传递的对象。该方法调用`VendorRepository`的`Add`方法并将信息保存到数据库中。使用请求/响应方法，即使为命令定义了多个处理程序，也只执行一个命令处理程序。要调用所有处理程序，我们可以使用通知。我们将扩展上述示例，并添加通知事件和相应的处理程序，一旦成功执行命令，将调用这些处理程序。
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We can add more notification handlers based on the requirements. For example,
    if we want to initiate a workflow notification once the vendor record is saved
    into the database, we can create a vendor workflow notification handler, and so
    on.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要求，我们可以添加更多的通知处理程序。例如，如果我们想要在将供应商记录保存到数据库后启动工作流通知，我们可以创建供应商工作流通知处理程序，依此类推。
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, we have a `Post` method that will be called by the client
    application to create a new vendor. It first calls the `Send` method, which invokes
    the `CreateVendorCommandHandler` and saves the record in the database, and, once
    the record is created and the response is true, it will invoke the `SendEmailHandler`
    to send an email.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们有一个`Post`方法，客户端应用程序将调用该方法来创建一个新的供应商。它首先调用`Send`方法，该方法调用`CreateVendorCommandHandler`并将记录保存在数据库中，一旦记录创建并且响应为true，它将调用`SendEmailHandler`发送电子邮件。
- en: You can access the complete sample application from the GitHub link provided
    with the book.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从提供的GitHub链接中访问完整的示例应用程序。
- en: Deploying microservices on Docker containers
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker容器上部署微服务
- en: Microservices are best suited for containerization deployment. A container is
    a process that provides an isolated and controlled environment for an application
    to run without affecting the system or vice versa. Most of us have experienced
    hosting applications inside VMs, which provide an isolated space to install, configure,
    and run applications and use the dedicated resources without affecting the underlying
    system or application. In contrast to VMs, containers provide the same level of
    isolation but are more lightweight in terms of startup time and overhead. Unlike
    VMs, containers do not preallocate resources such as memory, disk, and CPU usage.
    We can run multiple containers on the same machine, where the containers are isolated
    from each other but share the memory, disk, and CPU usage. This enables any application
    running in a container to use the maximum resources available without having any
    preallocated or assigned.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务最适合容器化部署。容器是一个进程，为应用程序提供了一个隔离和受控的环境，使其能够在不影响系统或反之的情况下运行。我们大多数人都有在VM中托管应用程序的经验，VM提供了一个隔离的空间来安装、配置和运行应用程序，并使用专用资源而不影响底层系统或应用程序。与VM相比，容器提供了相同级别的隔离，但在启动时间和开销方面更轻量。与VM不同，容器不会预分配内存、磁盘和CPU使用率等资源。我们可以在同一台机器上运行多个容器，其中容器彼此隔离，但共享内存、磁盘和CPU使用率。这使得在容器中运行的任何应用程序能够利用最大的可用资源，而不需要任何预分配或分配。
- en: 'The following diagram depicts how VMs run on the host OS:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了虚拟机在主机操作系统上的运行方式：
- en: '![](img/00106.gif)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00106.gif)'
- en: We run applications on the host OS and VMs on a guest OS. The virtualization
    is done at the hardware level, where VMs can talk to the host hardware using drivers
    available in the hypervisor virtualization system, as provided by the host OS.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主机操作系统上运行应用程序，而在客用操作系统上运行虚拟机。虚拟化是在硬件级别进行的，其中虚拟机可以使用主机操作系统提供的hypervisor虚拟化系统中的驱动程序与主机硬件进行通信。
- en: 'Here is how containers run on the host OS:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是容器在主机操作系统上的运行方式：
- en: '![](img/00107.gif)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00107.gif)'
- en: With containers, the kernel is shared between multiple containers. The kernel
    is a core component of the operating system that is responsible for interacting
    with different processes and hardware, and manages resources such as CPU cycles
    and virtual management. The kernel is the component that creates isolation between
    different containers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器时，内核在多个容器之间共享。内核是操作系统的核心组件，负责与不同的进程和硬件进行交互，并管理CPU周期和虚拟管理等资源。内核是在不同容器之间创建隔离的组件。
- en: What is Docker?
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker是什么？
- en: Docker is a software company that provides containers. Docker containers are
    very popular in the software industry to run microservices. They are best suited
    to microservices application development and provide a set of command-line tools
    that provide a unified way of building and maintaining different container images.
    We can create custom images or use existing ones from a registry such as Docker
    Hub ([http://hub.docker.com](http://hub.docker.com)).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一家提供容器的软件公司。Docker容器在软件行业中非常流行，用于运行微服务。它们最适合于微服务应用程序开发，并提供一组命令行工具，提供了一种统一的方式来构建和维护不同的容器映像。我们可以创建自定义映像，或者使用来自Docker
    Hub（[http://hub.docker.com](http://hub.docker.com)）等注册表中的现有映像。
- en: 'Here are a few benefits of Docker:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Docker的一些好处：
- en: '| **Benefit** | **Description** |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| **好处** | **描述** |'
- en: '| Simplicity | Provides a powerful tool for application creation and orchestration
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 简单性 | 为应用程序创建和编排提供了强大的工具 |'
- en: '| Openness | Built with open source technology and easy to integrate into existing
    environments |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 开放性 | 使用开源技术构建，并易于集成到现有环境中 |'
- en: '| Independence | Creates separation of concerns between application and infrastructure
    |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 独立性 | 在应用程序和基础设施之间创建关注点分离 |'
- en: Using Docker with .NET Core
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker与.NET Core
- en: .NET Core is modular and faster when compared to the .NET framework and helps
    in running applications side by side, where each application is running its own
    set of CLR libraries and runtime. This makes it perfect for running on Docker
    containers. The image of .NET Core is far smaller when compared to the image having
    .NET framework installed. .NET Core uses a Windows Nano server or Linux image,
    which is a lot smaller than the Windows service core image. As .NET Core runs
    cross-platform, we can also create Docker images of other platforms and run applications
    on them.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core是模块化的，与.NET框架相比更快，并有助于并行运行应用程序，其中每个应用程序都在运行其自己的CLR库和运行时。这使其非常适合在Docker容器上运行。与安装.NET框架的映像相比，.NET
    Core的映像要小得多。.NET Core使用Windows Nano服务器或Linux映像，比Windows服务核心映像要小得多。由于.NET Core是跨平台运行的，我们还可以创建其他平台的Docker映像，并在其上运行应用程序。
- en: 'With Visual Studio 2017, we can choose Docker while creating a .NET Core or
    ASP.NET Core project, and it auto scaffolds the Docker files and sets up the basic
    configuration to run applications on Docker. The following screenshot shows the
    Docker options available in Visual Studio 2017 to provision Docker containers:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Visual Studio 2017，我们可以在创建.NET Core或ASP.NET Core项目时选择Docker，并自动创建Docker文件并设置基本配置以在Docker上运行应用程序。以下截图显示了Visual
    Studio 2017中可用的Docker选项，用于配置Docker容器：
- en: '![](img/00108.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00108.jpeg)'
- en: Alternatively, if the project is already created, we can add Docker support
    by right-clicking on the .NET Core project and clicking on the Add | Docker Support
    option.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果项目已经创建，我们可以通过右键单击.NET Core项目并单击“添加| Docker支持”选项来添加Docker支持。
- en: 'Once we create or enable Docker support in our application, it creates the
    Docker files in our project and also adds another project, named `docker-compose`*,*
    as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在应用程序中创建或启用Docker支持，它会在我们的项目中创建Docker文件，并添加另一个名为`docker-compose`的项目，如下所示：
- en: '![](img/00109.gif)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00109.gif)'
- en: 'The `docker-compose` project contains set of YAML (`.yml`) files that contain
    the configuration related to the application hosted in the container and a reference
    to the path of the Dockerfile created for the project when Docker support was
    added. Here is the sample `docker-compose.yml` file that contains two services
    having details such as the image name, `dockerfile` path, and so on. This file
    is from the sample application we discussed previously:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 项目包含一组 YAML（`.yml`）文件，其中包含与容器中托管的应用程序相关的配置，以及在添加 Docker 支持时为项目创建的
    Dockerfile 的路径引用。以下是包含两个服务详细信息的示例 `docker-compose.yml` 文件，例如镜像名称、`dockerfile`
    路径等。此文件来自我们之前讨论的示例应用程序。'
- en: '[PRE38]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following is the content of the `Dockerfile` residing inside the `Vendor.API`
    project we created in the sample application above:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在上面示例应用程序中创建的 `Vendor.API` 项目内的 `Dockerfile` 的内容：
- en: '[PRE39]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding `Dockerfile` starts referencing a base image `microsoft/aspnetcore:2.0-nanoserver-1709`
    that will be used to create a Docker container. The `COPY` command is the actual
    path where the project files reside. It will then use dotnet CLI commands such
    as `dotnet restore` to restore all the NuGet packages inside the container, `dotnet
    build` to build the application, and `dotnet publish` to build and publishes the
    compiled output into a publish folder inside the container.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `Dockerfile` 开始引用一个基础镜像 `microsoft/aspnetcore:2.0-nanoserver-1709`，该镜像将用于创建一个
    Docker 容器。`COPY` 命令是项目文件所在的实际路径。然后将使用 dotnet CLI 命令，如 `dotnet restore` 在容器内还原所有
    NuGet 包，`dotnet build` 构建应用程序，以及 `dotnet publish` 构建和发布编译输出到容器内的发布文件夹。
- en: Running Docker images
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 Docker 镜像
- en: We can run Docker images either from the command line or from Visual Studio
    directly. As we saw in the previous section, a new `docker-compose` project is
    created on adding Docker support into our project. Running the `docker-compose`
    project reads the `docker-compose` YAML file and hooks up containers for the services
    defined. Docker is a first-class citizen in Visual Studio. It not only supports
    running the Docker containers but fully-fledged debugging capabilities are also
    provided.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从命令行或直接从 Visual Studio 运行 Docker 镜像。正如我们在前一节中看到的，添加 Docker 支持到我们的项目后会创建一个新的
    `docker-compose` 项目。运行 `docker-compose` 项目会读取 `docker-compose` YAML 文件，并为定义的服务连接容器。Docker
    在 Visual Studio 中是一等公民。它不仅支持运行 Docker 容器，还提供了完整的调试功能。
- en: 'Alternatively, from the command line, we can run Docker containers by going
    to the root path where the `docker-compose.yml` file resides and running the following
    command:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，从命令行，我们可以通过转到 `docker-compose.yml` 文件所在的根路径并运行以下命令来运行 Docker 容器：
- en: '[PRE40]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once the containers are up, each application has its own IP assigned at runtime.
    To inspect the actual IP of each service running on a separate container, we can
    run the `docker inspect` command to retrieve it. However, the `docker inspect`
    command requires the container ID as a parameter. To get the list of the containers
    running, we can first call the `docker ps` command as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器启动，每个应用程序在运行时都有自己的 IP 地址。要检查运行在单独容器上的每个服务的实际 IP，我们可以运行 `docker inspect`
    命令来检索它。但是，`docker inspect` 命令需要容器 ID 作为参数。要获取正在运行的容器列表，我们可以首先调用 `docker ps` 命令如下：
- en: '[PRE41]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding command displays the list of containers as shown in the following
    screenshot:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令显示了容器列表，如下截图所示：
- en: '![](img/00110.gif)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00110.gif)'
- en: 'Finally, we can use the container ID and execute `docker inspect` command to
    get its IP address as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用容器 ID 并执行 `docker inspect` 命令来获取其 IP 地址，如下所示：
- en: '[PRE42]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding command displays the IP address as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令显示 IP 地址如下：
- en: '![](img/00111.gif)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00111.gif)'
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the microservices architecture for developing
    highly performant and scalable applications for the cloud-based on microservices.
    We learned some of the fundamentals of microservices, their benefits, and patterns
    and practices used when designing the architecture. We discussed certain challenges
    in decomposing the enterprise applications into the microservices architecture
    style and learned patterns such as API composition and CQRS to address them. Later
    in the chapter, we developed a basic application in .NET Core and discussed the
    solution structure and components of microservices, and developed identity and
    vendor services.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了用于基于微服务开发高性能和可扩展云应用程序的微服务架构。我们学习了一些微服务的基础知识、它们的优势，以及在设计架构时使用的模式和实践。我们讨论了将企业应用程序分解为微服务架构风格的某些挑战，并学习了诸如
    API 组合和 CQRS 等模式来解决这些挑战。在本章后期，我们在 .NET Core 中开发了一个基本应用程序，并讨论了微服务的解决方案结构和组件，并开发了身份和供应商服务。
- en: In the next chapter, we will discuss securing and implementing resilience in
    .NET Core applications.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论在 .NET Core 应用程序中实现安全性和弹性。
