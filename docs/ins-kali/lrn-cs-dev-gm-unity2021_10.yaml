- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Revisiting Types, Methods, and Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视类型、方法和类
- en: Now that you've programmed the game's mechanics and interactions with Unity's
    built-in classes, it's time to expand our core C# knowledge and focus on the intermediate
    applications of the foundation we've laid. We'll revisit old friends—variables,
    types, methods, and classes—but we'll target their deeper applications and relevant
    use cases. Many of the topics we'll be covering don't apply to *Hero Born* in
    its current state, so some examples will be standalone rather than being applied
    directly to the game prototype.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经使用Unity内置类编写了游戏的机制和交互，是时候扩展我们的核心C#知识，专注于我们所奠定的基础的中级应用。我们将重新审视旧朋友——变量、类型、方法和类——但我们将针对它们的更深层次应用和相关用例。我们将要讨论的许多主题并不适用于*Hero
    Born*的当前状态，因此一些示例将是独立的，而不是直接应用于游戏原型。
- en: 'I''ll be throwing a lot of new information your way, so if you feel overwhelmed
    at any point, don''t hesitate to revisit the first few chapters to solidify those
    building blocks. We''ll also be using this chapter to break away from gameplay
    mechanics and features specific to Unity by focusing on the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您介绍大量新信息，所以如果您在任何时候感到不知所措，请不要犹豫，重新阅读前几章以巩固这些基础知识。我们还将利用本章来摆脱游戏机制和特定于Unity的功能，而是专注于以下主题：
- en: Intermediate modifiers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中级修饰符
- en: Method overloading
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法重载
- en: Using the `out` and `ref` parameters
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`out`和`ref`参数
- en: Working with interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口
- en: Abstract classes and overriding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类和重写
- en: Extending class functionality
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展类功能
- en: Namespace conflicts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间冲突
- en: Type aliasing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型别名
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Access modifiers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符
- en: While we've gotten into the habit of pairing the public and private access modifiers
    with our variable declarations, like we did with player health and items collected,
    there remains a laundry list of modifier keywords that we haven't seen. We can't
    go into detail about every one of them in this chapter, but the five that we'll
    focus on will further your understanding of the C# language and give your programming
    skills a boost.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经习惯了将公共和私有访问修饰符与变量声明配对，就像我们对玩家健康和收集的物品所做的那样，但我们还有一长串修饰符关键字没有看到。在本章中，我们无法详细介绍每一个，但我们将专注于五个关键字，这将进一步加深您对C#语言的理解，并提高您的编程技能。
- en: 'This section will cover the first three modifiers in the following list, while
    the remaining two will be discussed later on in the *Intermediate OOP* section:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖以下列表中的前三个修饰符，而剩下的两个将在*中级OOP*部分讨论：
- en: '`const`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`const`'
- en: '`readonly`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readonly`'
- en: '`static`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`静态`'
- en: '`abstract`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`抽象`'
- en: '`override`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override`'
- en: You can find a full list of available modifiers at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/modifiers).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/modifiers)找到可用修饰符的完整列表。
- en: Let's start with the first three access modifiers provided in the preceding
    list.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从前面列表中提供的前三个访问修饰符开始。
- en: Constant and read-only properties
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量和只读属性
- en: 'There will be times when you need to create variables that store constant,
    unchanging values. Adding the `const` keyword after a variable''s access modifier
    will do just that, but only for built-in C# types. For example, you couldn''t
    mark an instance of our `Character` class as a constant. A good candidate for
    a constant value is `MaxItems` in the `GameBehavior` class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要创建存储常量、不变值的变量。在变量的访问修饰符后添加`const`关键字就可以做到这一点，但只适用于内置的C#类型。例如，您不能将我们的`Character`类的实例标记为常量。`GameBehavior`类中`MaxItems`是一个常量值的好选择：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The above code would essentially lock the value of `MaxItems` at `4`, making
    it unchangeable. The problem you''ll run into with constant variables is that
    they can only be assigned a value in their declaration, meaning we can''t leave
    `MaxItems` without an initial value. As an alternative, we can use `readonly`,
    which won''t let you write to the variable, meaning it can''t be changed:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码本质上将`MaxItems`的值锁定为`4`，使其不可更改。常量变量的问题在于它们只能在声明时分配一个值，这意味着我们不能让`MaxItems`没有初始值。作为替代方案，我们可以使用`readonly`，它不允许您写入变量，这意味着它不能被更改：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the `readonly` keyword to declare a variable will give us the same unmodifiable
    value as a constant, while still letting us assign its initial value at any time.
    A good place for this would be the `Start()` or `Awake()` methods in one of our
    scripts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`readonly`关键字声明变量将为我们提供与常量相同的不可修改的值，同时仍然允许我们随时分配其初始值。这个关键字的一个好地方可能是我们脚本中的`Start()`或`Awake()`方法。
- en: Using the static keyword
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`static`关键字
- en: We've already gone over how objects, or instances, are created from a class
    blueprint, and that all properties and methods belong to that particular instance,
    like we had with our very first `Character` class instance. While this is great
    for object-oriented functionality, not all classes need to be instantiated, and
    not all properties need to belong to a specific instance. However, static classes
    are sealed, meaning they cannot be used in class inheritance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何从类蓝图创建对象或实例，以及所有属性和方法都属于特定的实例，就像我们的第一个`Character`类实例一样。虽然这对于面向对象的功能非常有用，但并非所有类都需要被实例化，也不是所有属性都需要属于特定的实例。但是，静态类是封闭的，这意味着它们不能用于类继承。
- en: Utility methods are a good case for this situation, where we don't necessarily
    care about instantiating a particular `Utility` class instance since all its methods
    wouldn't be dependent on a particular object. Your task is to create just such
    a utility method in a new script.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 实用方法是这种情况的一个很好的例子，我们不一定关心实例化特定的`Utility`类实例，因为它的所有方法都不依赖于特定对象。您的任务是在一个新的脚本中创建这样一个实用方法。
- en: 'Let''s create a new class to hold some of our future methods that deal with
    raw computations or repeated logic that doesn''t depend on the gameplay:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的类来保存一些未来处理原始计算或重复逻辑的方法，这些方法不依赖于游戏玩法：
- en: Create a new C# script in the `Scripts` folder and name it `Utilities`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，并将其命名为`Utilities`。
- en: 'Open it up and add the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开它并添加以下代码：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Delete the code inside `RestartLevel()` from `GameBehavior` and instead call
    the new `utility` method with the following code:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`GameBehavior`中删除`RestartLevel()`中的代码，而是使用以下代码调用新的`utility`方法：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s break down the code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: First, it adds the `using SceneManagement` directive so that we can access the
    `LoadScene()` method.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它添加了`using SceneManagement`指令，以便我们可以访问`LoadScene()`方法。
- en: Then, it declares `Utilities` as a public `static` class that does not inherit
    from `MonoBehavior` because we won't need it to be in the game scene.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将`Utilities`声明为一个不继承自`MonoBehavior`的公共`static`类，因为我们不需要它在游戏场景中。
- en: Next, it creates a public `static` variable to hold the number of times our
    player has died and restarted the game.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它创建一个公共的`static`变量来保存我们的玩家死亡并重新开始游戏的次数。
- en: After, it declares a public `static` method to hold our level restart logic,
    which is currently hardcoded in `GameBehavior`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它声明一个公共的`static`方法来保存我们的级别重启逻辑，这目前是硬编码在`GameBehavior`中的。
- en: Finally, our update to `GameBehavior` calls `RestartLevel()` from the static
    `Utilities` class when the win or the lose button is pressed. Notice that we didn't
    need an instance of the `Utilities` class to call the method because it's static—it's
    just dot notation.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们在`GameBehavior`中对`RestartLevel()`的更新在赢或输按钮被按下时从静态的`Utilities`类调用。请注意，我们不需要`Utilities`类的实例来调用该方法，因为它是静态的——只需使用点符号。
- en: We've now extracted the restart logic from `GameBehavior` and put it into its
    static class, which makes it easier to reuse across our codebase. Marking it as
    `static` will also ensure that we never have to create or manage instances of
    the `Utilities` class before we use its class members.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将重启逻辑从`GameBehavior`中提取出来，并放入其静态类中，这样可以更容易地在整个代码库中重用。将其标记为`static`也将确保我们在使用其类成员之前永远不必创建或管理`Utilities`类的实例。
- en: Non-static classes can have properties and methods that are static and non-static.
    However, if an entire class is marked as static, all properties and methods must
    follow suit.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 非静态类可以具有静态和非静态的属性和方法。但是，如果整个类标记为静态，所有属性和方法都必须遵循相同的规则。
- en: That wraps up our second visit of variables and types, which will enable you
    to build out your own set of utilities and tools when managing larger and more
    complex projects down the road. Now it's time to move on to methods and their
    intermediate capabilities, which includes method overloading and `ref` and `out`
    parameters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对变量和类型的第二次访问，这将使您能够在未来管理更大更复杂的项目时构建自己的一套工具和实用程序。现在是时候转向方法及其中级功能，其中包括方法重载和`ref`和`out`参数。
- en: Revisiting methods
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重温方法
- en: 'Methods have been a big part of our code since we learned how to use them in
    *Chapter 3*, *Diving into Variables, Types, and Methods*, but there are two intermediate
    use cases we haven''t covered yet: method overloading and using the `ref` and
    `out` parameter keywords.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们在*第3章*学习如何使用方法以来，方法一直是我们代码的重要组成部分，但有两种中级用例我们还没有涵盖：方法重载和使用`ref`和`out`参数关键字。
- en: Overloading methods
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法重载
- en: 'The term **method overloading** refers to creating multiple methods with the
    same name but with different signatures. A method''s signature is made up of its
    name and parameters, which is how the C# compiler recognizes it. Take the following
    method as an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**方法重载**指的是创建多个具有相同名称但不同签名的方法。方法的签名由其名称和参数组成，这是C#编译器识别它的方式。以以下方法为例：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The method signature of `AttackEnemy()` is written as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`AttackEnemy()`的方法签名如下所示：'
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we know the signature of `AttackEnemy()`, it can be overloaded by changing
    the number of parameters or the parameter types themselves, while still keeping
    its name. This provides added flexibility when you need more than one option for
    a given operation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了`AttackEnemy()`的签名，可以通过改变参数的数量或参数类型本身来重载它，同时保持其名称不变。这在您需要给定操作的多个选项时提供了额外的灵活性。
- en: The `RestartLevel()` method in `Utilities` is a great example of a situation
    where method overloading comes in handy. Right now, `RestartLevel()` only restarts
    the current level, but what happens if we expand the game so that it includes
    multiple scenes? We could refactor `RestartLevel()` to accept parameters, but
    that often leads to bloated and confusing code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Utilities`中的`RestartLevel()`方法是方法重载派上用场的一个很好的例子。目前，`RestartLevel()`只重新启动当前级别，但如果我们扩展游戏，使其包含多个场景会怎么样？我们可以重构`RestartLevel()`以接受参数，但这通常会导致臃肿和混乱的代码。'
- en: The `RestartLevel()` method is, once again, a good candidate for testing out
    our new knowledge. Your task is to overload it to take in different parameters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestartLevel()`方法再次是测试我们新知识的一个很好的候选项。您的任务是重载它以接受不同的参数。'
- en: 'Let''s add an overloaded version of `RestartLevel()`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个重载版本的`RestartLevel()`：
- en: 'Open up `Utilities` and add the following code:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Utilities`并添加以下代码：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open `GameBehavior` and update the call to the `Utilities.RestartLevel()` method
    to the following:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GameBehavior`并将对`Utilities.RestartLevel()`方法的调用更新为以下内容：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let''s break down the code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: First, it declares an overloaded version of the `RestartLevel()` method that
    takes in an `int` parameter and returns a `bool`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一个重载版本的`RestartLevel()`方法，该方法接受一个`int`参数并返回一个`bool`。
- en: Then, it calls `LoadScene()` and passes in the `sceneIndex` parameter instead
    of manually hardcoding that value.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它调用`LoadScene()`并传入`sceneIndex`参数，而不是手动硬编码该值。
- en: Next, it returns `true` after the new scene is loaded and the `timeScale` property
    has been reset.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在新场景加载后，它将返回`true`并且`timeScale`属性已被重置。
- en: Finally, our update to `GameBehavior` calls the overloaded `RestartLevel()`
    method and passes in `0` as the `sceneIndex`. Overloaded methods are automatically
    detected by Visual Studio and are displayed by number, as shown here:![](img/B17573_10_01.png)
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们对`GameBehavior`的更新调用了重载的`RestartLevel()`方法，并将`0`作为`sceneIndex`传入。重载方法会被Visual
    Studio自动检测到，并按数字显示，如下所示：![](img/B17573_10_01.png)
- en: 'Figure 10.1: Multiple method overloads in Visual Studio'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：Visual Studio中的多个方法重载
- en: The functionality in the `RestartLevel()` method is now much more customizable
    and can account for additional situations you may need later. In this case, it
    is restarting the game from any scene we choose.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestartLevel()`方法中的功能现在更加可定制，可以处理以后可能需要的其他情况。在这种情况下，它是从我们选择的任何场景重新开始游戏。'
- en: Method overloading is not limited to static methods—this was just in line with
    the previous example. Any method can be overloaded as long as its signature differs
    from the original.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载不仅限于静态方法——这只是与前面的示例一致。只要其签名与原始方法不同，任何方法都可以进行重载。
- en: Next up, we're going to cover two additional topics that can take your method
    game to a whole new level—`ref` and `out` parameters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍另外两个可以提升你的方法游戏水平的主题——`ref`和`out`参数。
- en: ref parameters
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ref参数
- en: 'When we talked about classes and structs back in *Chapter 5*, *Working with
    Classes, Structs*, *and OOP*, we discovered that not all objects are passed the
    same way: value types are passed by copy, while reference types are passed by
    reference. However, we didn''t go over how objects, or values, are used when they''re
    passed into methods as parameter arguments.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*第5章* *使用类、结构体和面向对象编程*中讨论类和结构体时，我们发现并非所有对象都是以相同的方式传递的：值类型是按副本传递的，而引用类型是按引用传递的。然而，我们没有讨论当对象或值作为参数传递到方法中时，它们是如何使用的。
- en: By default, all arguments are passed by value, meaning that a variable passed
    into a method will not be affected by any changes that are made to its value inside
    the method body. This protects us from making unwanted changes to existing variables
    when we use them as method parameters. While this works for most cases, there
    are situations where you'll want to pass in a method argument by reference so
    that it can be updated and have that change reflected in the original variable.
    Prefixing a parameter declaration with either the `ref` or `out` keyword will
    mark the argument as a reference.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有参数都是按值传递的，这意味着传递到方法中的变量不会受到方法体内对其值所做更改的影响。当我们将它们用作方法参数时，这可以保护我们免受不需要的变量更改。虽然这对大多数情况都适用，但在某些情况下，您可能希望通过引用传递方法参数，以便可以更新它并在原始变量中反映出这种更改。在参数声明前加上`ref`或`out`关键字将标记参数为引用。
- en: 'Here are a few key points to keep in mind about using the `ref` keyword:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`ref`关键字时需要牢记的几个关键点：
- en: Arguments have to be initialized before being passed into a method.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数在传递到方法之前必须初始化。
- en: You don't need to initialize or assign the reference parameter value before
    ending the method.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在结束方法之前，您不需要初始化或分配引用参数值。
- en: Properties with get or set accessors can't be used as `ref` or `out` arguments.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有get或set访问器的属性不能用作`ref`或`out`参数。
- en: Let's try this out by adding some logic to keep track of how many times a player
    has restarted the game.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一些逻辑来跟踪玩家重新开始游戏的次数来尝试一下。
- en: Let's create a method to update `PlayerDeaths` to see the method arguments that
    are being passed by reference in action.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个方法来更新`PlayerDeaths`，以查看正在通过引用传递的方法参数的作用。
- en: 'Open up `Utilities` and add the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`Utilities`并添加以下代码：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s break down the code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: First, it declares a new `static` method that returns a `string` and takes in
    an `int` passed by reference.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，声明一个新的`static`方法，返回一个`string`并接受一个通过引用传递的`int`。
- en: Then, it updates the reference parameter directly, incrementing its value by
    `1` and returning a string that contains the new value.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它直接更新引用参数，将其值增加1，并返回一个包含新值的字符串。
- en: Finally, it debugs the `PlayerDeaths` variable in `RestartLevel(int sceneIndex)`
    before and after it is passed by reference to `UpdateDeathCount()`. We also store
    a reference to the returned string value from `UpdateDeathCount()` in the `message`
    variable and print it out.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它在将`PlayerDeaths`变量传递给`UpdateDeathCount()`之前和之后，在`RestartLevel(int sceneIndex)`中对其进行调试。我们还将`UpdateDeathCount()`返回的字符串值的引用存储在`message`变量中并打印出来。
- en: 'If you play the game and lose, the debug log will show that `PlayerDeaths`
    has increased by 1 inside `UpdateDeathCount()` because it was passed by reference
    and not by value:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩游戏并且失败，调试日志将显示`UpdateDeathCount()`内的`PlayerDeaths`增加了1，因为它是通过引用而不是通过值传递的：
- en: '![](img/B17573_10_02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_10_02.png)'
- en: 'Figure 10.2: Example output from ref parameters'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：`ref`参数的示例输出
- en: For clarity, we could have updated the player death count without a `ref` parameter
    because `UpdateDeathCount()` and `PlayerDeaths` are in the same script. However,
    if this wasn't the case and you wanted the same functionality, `ref` parameters
    are super useful.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，我们可以在没有`ref`参数的情况下更新玩家死亡计数，因为`UpdateDeathCount()`和`PlayerDeaths`在同一个脚本中。但是，如果情况不是这样，而你希望具有相同的功能，`ref`参数非常有用。
- en: We're using the `ref` keyword in this situation for the sake of our example,
    but we could have also updated `PlayerDeaths` directly inside `UpdateDeathCount()`
    or added logic inside `RestartLevel()` to only fire `UpdateDeathCount()` when
    the restart was due to a loss.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`ref`关键字是为了举例说明，但我们也可以直接在`UpdateDeathCount()`内更新`PlayerDeaths`，或者在`RestartLevel()`内添加逻辑，只有在由于失败而重新开始时才触发`UpdateDeathCount()`。
- en: Now that we know how to use a `ref` parameter in our project, let's take a look
    at the `out` parameter and how it serves a slightly different purpose.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何在项目中使用`ref`参数，让我们来看看`out`参数以及它如何起到略有不同的作用。
- en: out parameters
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: out参数
- en: 'The `out` keyword does the same job as `ref` but with different rules, which
    means they''re similar tools but they''re not interchangeable—each has its own
    use cases:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`关键字和`ref`执行相同的工作，但有不同的规则，这意味着它们是相似的工具，但不能互换使用，每个都有自己的用例。'
- en: Arguments do not need to be initialized before being passed into a method.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数在传递到方法之前不需要初始化。
- en: The referenced parameter value does need to be initialized or assigned in the
    calling method before it's returned.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用的参数值在调用方法中返回之前不需要初始化或赋值。
- en: 'For instance, we could have replaced `ref` with `out` in `UpdateDeathCount()`
    as long as we initialized or assigned the `countReference` parameter before returning
    from the method:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在`UpdateDeathCount()`中用`out`替换`ref`，只要在方法返回之前初始化或赋值`countReference`参数：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Methods that use the `out` keyword are better suited to situations where you
    need to return multiple values from a single function, while the `ref` keyword
    works best when a reference value only needs to be modified. It's also more flexible
    than the `ref` keyword because the initial parameter values don't need to be set
    before they're used in the method. The `out` keyword is especially useful if you
    need to initialize the parameter value before you change it. Even though these
    keywords are a little more esoteric, it's important to have them in your C# toolkit
    for special use cases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`out`关键字的方法更适合需要从单个函数返回多个值的情况，而`ref`关键字在只需要修改引用值时效果最好。它也比`ref`关键字更灵活，因为在方法中使用参数之前不需要设置初始参数值。`out`关键字在需要在更改之前初始化参数值时特别有用。尽管这些关键字有点晦涩，但对于特殊用例来说，将它们放入你的C#工具包中是很重要的。
- en: 'With these new method features under our belts, it''s time to revisit the big
    one: **object-oriented programming** (**OOP**). There''s so much to this topic
    that it''s impossible to cover everything in a chapter or two, but there are a
    few key tools that will come in handy early on in your development career. OOP
    is one of those topics that you''re encouraged to follow up on after finishing
    this book.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些新的方法特性，现在是重新审视**面向对象编程**（**OOP**）的时候了。这个主题涉及的内容太多，不可能在一两章中覆盖所有内容，但在你的开发生涯初期，有一些关键工具会很有用。OOP是一个你鼓励在完成本书后继续学习的主题。
- en: Intermediate OOP
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中级OOP
- en: 'An object-oriented mindset is crucial to creating meaningful applications and
    understanding how the C# language works behind the scenes. The tricky part is
    that classes and structs by themselves aren''t the end of the line when it comes
    to OOP and designing your objects. They''ll always be the building blocks of your
    code, but classes are limited to single inheritance, meaning they can only ever
    have one parent or superclass, and structs can''t inherit at all. So, the question
    you should be asking yourself right about now is simple: *"How can I create objects
    from the same blueprint and have them perform different actions based on a specific
    scenario?"*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的思维方式对于创建有意义的应用程序和理解C#语言在幕后的工作方式至关重要。棘手的部分在于，类和结构本身并不是面向对象编程和设计对象的终点。它们始终是你的代码的构建块，但是类在单一继承方面受到限制，这意味着它们只能有一个父类或超类，而结构根本不能继承。因此，你现在应该问自己的问题很简单：“我如何才能根据特定情况创建出相同蓝图的对象，并让它们执行不同的操作？”
- en: To answer this question, we'll be learning about interfaces, abstract classes,
    and class extensions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们将学习接口、抽象类和类扩展。
- en: Interfaces
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: 'One of the ways to gather groups of functionality together is through interfaces.
    Like classes, interfaces are blueprints for data and behaviors, but with one important
    difference: they can''t have any actual implementation logic or stored values.
    Instead, they contain the implementation blueprint, and it''s up to the adopting
    class or struct to fill in the values and methods outlined in the interface. You
    can use interfaces with both classes and structs, and there''s no upper limit
    to how many interfaces a single class or struct can adopt.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将功能组合在一起的一种方法是通过接口。与类一样，接口是数据和行为的蓝图，但有一个重要的区别：它们不能有任何实际的实现逻辑或存储值。相反，它们包含了实现蓝图，由采用的类或结构填写接口中概述的值和方法。你可以在类和结构中使用接口，一个类或结构可以采用的接口数量没有上限。
- en: Remember, a single class can only have one parent class, and structs can't subclass
    at all. Breaking out functionality into interfaces lets you build up classes like
    building blocks, picking and choosing how you want them to behave like food from
    a menu. This would be a huge efficiency boost to your code base, breaking away
    from long, messy subclassing hierarchies.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个类只能有一个父类，结构根本不能有子类。将功能分解为接口可以让你像从菜单中选择食物一样构建类，选择你希望它们表现的方式。这将极大地提高你的代码库的效率，摆脱了冗长、混乱的子类层次结构。
- en: For example, what if we wanted our enemies to be able to shoot back at our player
    when they're in close range? We could create a parent class that both the player
    and enemy could derive from, which would base them both on the same blueprint.
    The problem with that approach, however, is that enemies and players won't necessarily
    share the same behaviors and data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们希望我们的敌人在靠近时能够还击我们的玩家，我们可以创建一个父类，玩家和敌人都可以从中派生，这将使它们都基于相同的蓝图。然而，这种方法的问题在于敌人和玩家不一定会共享相同的行为和数据。
- en: The more efficient way to handle this would be to define an interface with a
    blueprint for what shootable objects need to do, and then have both the enemy
    and player adopt it. That way, they have the freedom to be separate and exhibit
    different behaviors while still sharing common functionality.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更有效的处理方式是定义一个接口，其中包含可射击对象需要执行的蓝图，然后让敌人和玩家都采用它。这样，它们就可以自由地分开并展示不同的行为，同时仍然共享共同的功能。
- en: Refactoring the shooting mechanic into an interface is a challenge I'll leave
    to you, but we still need to know how to create and adopt interfaces in code.
    For this example, we'll create an interface that all manager scripts might need
    to implement for sharing a common structure.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将射击机制重构为接口是一个我留给你的挑战，但我们仍然需要知道如何在代码中创建和采用接口。在这个例子中，我们将创建一个所有管理器脚本可能需要实现的接口，以共享一个公共结构。
- en: 'Create a new C# script in the `Scripts` folder, name it `IManager`, and update
    its code as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，命名为`IManager`，并更新其代码如下：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s break down the code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: First, it declares a public interface called `IManager` using the `interface`
    keyword.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它使用`interface`关键字声明了一个名为`IManager`的公共接口。
- en: Then, it adds a `string` variable to `IManager` named `State` with `get` and
    `set` accessors to hold the current state of the adopting class.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它在`IManager`中添加了一个名为`State`的`string`变量，带有`get`和`set`访问器来保存采用类的当前状态。
- en: All interface properties need at least a get accessor to compile but can have
    both get and set accessors if necessary.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有接口属性至少需要一个get访问器才能编译，但如果需要的话也可以有get和set访问器。
- en: Finally, it defines a method named `Initialize()` with no return type for the
    adopting class to implement. However, you could absolutely have a return type
    for a method inside an interface; there's no rule against it.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它定义了一个名为`Initialize()`的方法，没有返回类型，供采用类实现。但是，你绝对可以在接口内部的方法中有一个返回类型；没有规定不允许这样做。
- en: You've now created a blueprint for all manager scripts, meaning that each manager
    script adopting this interface needs to have a state property and an initialize
    method. Your next task is to use the `IManager` interface, which means it needs
    to be adopted by another class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在为所有管理器脚本创建了一个蓝图，这意味着采用这个接口的每个管理器脚本都需要有一个状态属性和一个初始化方法。你的下一个任务是使用`IManager`接口，这意味着它需要被另一个类采用。
- en: To keep things simple, let's have the game manager adopt our new interface and
    implement its blueprint.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，让游戏管理器采用我们的新接口并实现其蓝图。
- en: 'Update `GameBehavior` with the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码更新`GameBehavior`：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s break down the code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: First, it declares that `GameBehavior` adopts the `IManager` interface using
    a comma and its name, just like with subclassing.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了`GameBehavior`采用`IManager`接口，使用逗号和它的名称，就像子类化一样。
- en: Then, it adds a private variable that we'll use to back the public `State` value
    we have to implement from `IManager`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它添加了一个私有变量，我们将用它来支持我们必须从`IManager`实现的公共`State`值。
- en: Next, it adds the public `State` variable declared in `IManager` and uses `_state`
    as its private backing variable.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它添加了在`IManager`中声明的公共`State`变量，并使用`_state`作为其私有备份变量。
- en: After that, it declares the `Start()` method and calls the `Initialize()` method.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，它声明了`Start()`方法并调用了`Initialize()`方法。
- en: Finally, it declares the `Initialize()` method declared in `IManager` with an
    implementation that sets and prints out the public `State` variable.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它声明了在`IManager`中声明的`Initialize()`方法，其中包含一个设置和打印公共`State`变量的实现。
- en: 'With this, we specified that `GameBehavior` adopts the `IManager` interface
    and implemented its `State` and `Initialize()` members, as shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们指定`GameBehavior`采用`IManager`接口，并实现其`State`和`Initialize()`成员，如下所示：
- en: '![](img/B17573_10_03.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_10_03.png)'
- en: 'Figure 10.3: Example output from an interface'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：接口的示例输出
- en: 'The great part of this is that the implementation is specific to `GameBehavior`;
    if we had another manager class, we could do the same thing but with different
    logic. Just for fun, let''s set up a new manager script to test this out:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是，实现是特定于`GameBehavior`的；如果我们有另一个管理器类，我们可以做同样的事情，但逻辑不同。只是为了好玩，让我们设置一个新的管理器脚本来测试一下：
- en: In the **Project**, right-click inside the **Scripts** folder and choose **Create**
    | **C# Script**, then name it `DataManager`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Project**中，在**Scripts**文件夹内右键单击，选择**Create** | **C# Script**，然后命名为`DataManager`。
- en: 'Update the new script with the following code and adopt the `IManager` interface:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新新脚本并采用`IManager`接口：
- en: '[PRE12]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Drag and drop the new script onto the **Game_Manager** object in the **Hierarchy**
    panel:![](img/B17573_10_04.png)
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新脚本拖放到**Hierarchy**面板中的**Game_Manager**对象上：![](img/B17573_10_04.png)
- en: 'Figure 10.4: Data manager script attached to a GameObject'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：附加到GameObject的数据管理器脚本
- en: Then click play:![](img/B17573_10_05.png)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击播放：![](img/B17573_10_05.png)
- en: 'Figure 10.5: Output from data manager initialization'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：数据管理器初始化的输出
- en: While we could have done all of this with subclassing, we'd be limited to one
    parent class for all our managers. Instead, we have the option of adding new interfaces
    if we choose. We'll revisit this new manager script in *Chapter 12*, *Saving,
    Loading, and Serializing Data*. This opens up a whole world of possibilities for
    building classes, one of which is a new OOP concept called abstract classes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过子类化来完成所有这些工作，但我们将受到一个父类限制，适用于所有我们的管理器。相反，我们可以选择添加新的接口。我们将在*第12章*“保存、加载和序列化数据”中重新讨论这个新的管理器脚本。这为构建类打开了一整个新的可能性世界，其中之一是一个称为抽象类的新面向对象编程概念。
- en: Abstract classes
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类
- en: Another approach to separating common blueprints and sharing them between objects
    is the abstract class. Like interfaces, abstract classes cannot include any implementation
    logic for their methods; they can, however, store variable values. This is one
    of the key differences from interfaces—in situations where you might need to set
    initial values, an abstract class would be the way to go.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种分离常见蓝图并在对象之间共享它们的方法是抽象类。与接口类似，抽象类不能包含任何方法的实现逻辑；但是，它们可以存储变量值。这是与接口的关键区别之一——在可能需要设置初始值的情况下，抽象类将是一种选择。
- en: Any class that subclasses from an abstract class must fully implement all variables
    and methods marked with the `abstract` keyword. They can be particularly useful
    in situations where you want to use class inheritance without having to write
    out a base class's default implementation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 任何从抽象类继承的类都必须完全实现所有标记为`abstract`关键字的变量和方法。在想要使用类继承而不必编写基类默认实现的情况下，它们可能特别有用。
- en: 'For example, let''s take the `IManager` interface functionality we just wrote
    and see what it would look like as an abstract base class. *Don''t change any
    of the actual code in our project*, as we still want to keep things working as
    they are:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们将刚刚编写的`IManager`接口功能作为抽象基类来看看它会是什么样子。*不要更改我们项目中的任何实际代码*，因为我们仍然希望保持事情的正常运行：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s break down the code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: First, it declares a new class named `BaseManager` using the `abstract` keyword.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`abstract`关键字声明了一个名为`BaseManager`的新类。
- en: 'Then, it creates two variables: A `protected string` named `_state` that can
    only be accessed by classes that inherit from `BaseManager`. We''ve also set an
    initial value for `_state`, something we couldn''t do in our interface.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它创建了两个变量：一个名为`_state`的`protected string`，只能被从`BaseManager`继承的类访问。我们还为`_state`设置了一个初始值，这是我们在接口中无法做到的。
- en: We also have an abstract string named `State` with `get` and `set` accessors
    to be implemented by the subclass.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有一个名为`State`的抽象字符串，带有要由子类实现的`get`和`set`访问器。
- en: Finally, it adds `Initialize()` as an `abstract` method, also to be implemented
    in the subclass.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它将`Initialize()`作为`abstract`方法添加，也要在子类中实现。
- en: 'In doing so, we have created an abstract class that does the same thing as
    an interface. In this setup, `BaseManager` has the same blueprint as `IManager`,
    allowing any subclasses to define their implementations of `state` and `Initialize()`
    using the `override` keyword:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，我们创建了一个与接口相同的抽象类。在这种设置中，`BaseManager`具有与`IManager`相同的蓝图，允许任何子类使用`override`关键字定义它们对`state`和`Initialize()`的实现：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we break down the preceding code, we can see the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分解前面的代码，我们可以看到以下内容：
- en: First, it declares a new class called `CombatManager` that inherits from the
    `BaseManager` abstract class.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一个名为`CombatManager`的新类，该类继承自`BaseManager`抽象类。
- en: Then, it adds the `State` variable implementation from `BaseManager` using the
    `override` keyword.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它使用`override`关键字添加了从`BaseManager`中实现的`State`变量。
- en: Finally, it adds the `Initialize()` method implementation from `BaseManager`
    using the `override` keyword again and sets the protected `_state` variable.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它再次使用`override`关键字从`BaseManager`中添加了`Initialize()`方法的实现，并设置了受保护的`_state`变量。
- en: Even though this is only the tip of the iceberg of interfaces and abstract classes,
    their possibilities should be jumping around in your programming brain. Interfaces
    will allow you to spread and share pieces of functionality between unrelated objects,
    leading to a building block-like assembly when it comes to your code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这只是接口和抽象类的冰山一角，但它们的可能性应该在你的编程大脑中跳动。接口将允许您在不相关的对象之间传播和共享功能片段，从而在代码方面形成类似构建块的组装。
- en: Abstract classes, on the other hand, will let you keep the single-inheritance
    structure of OOP while separating a class's implementation from its blueprint.
    These approaches can even be mixed and matched, as abstract classes can adopt
    interfaces just like non-abstract ones.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，抽象类将允许您保持OOP的单继承结构，同时将类的实现与其蓝图分离。这些方法甚至可以混合使用，因为抽象类可以像非抽象类一样采用接口。
- en: As always with complicated topics, your first stop should be the documentation.
    Check it out at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract)
    and [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂的主题，您的第一站应该是文档。在[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract)和[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface)上查看它。
- en: You won't always need to build a new class from scratch. Sometimes, it's enough
    to add the feature or logic you want to an existing class, which is called a class
    extension.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您并不总是需要从头开始构建一个新类。有时，向现有类添加您想要的功能或逻辑就足够了，这称为类扩展。
- en: Class extensions
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类扩展
- en: 'Let''s step away from custom objects and talk about how we can extend existing
    classes so that they fit our own needs. The idea behind class extensions is simple:
    take an existing built-in C# class and add on any functionality that you need
    it to have. Since we don''t have access to the underlying code that C# is built
    on, this is the only way to get custom behavior out of objects the language already
    has.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们远离自定义对象，谈谈如何扩展现有类，使它们符合我们自己的需求。类扩展的理念很简单：取一个现有的内置C#类，并添加任何您需要的功能。由于我们无法访问C#构建的底层代码，这是获取对象语言已经具有的自定义行为的唯一方法。
- en: 'Classes can only be modified with methods—no variables or other entities are
    allowed. However limiting this might be, it makes the syntax consistent:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 类只能通过方法进行修改——不允许变量或其他实体。然而，尽管这可能有所限制，但它使语法保持一致：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Extension methods are declared using the same syntax as normal methods, but
    with a few caveats:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法的声明与普通方法相同，但有一些注意事项：
- en: All extension methods need to be marked as `static`.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有扩展方法都需要标记为`static`。
- en: 'The first parameter needs to be the `this` keyword, followed by the name of
    the class we want to extend and a local variable name:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数需要是`this`关键字，后面跟着我们想要扩展的类的名称和一个本地变量名称：
- en: This special parameter lets the compiler identify the method as an extension,
    and gives us a local reference for the existing class.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个特殊的参数让编译器识别该方法为扩展方法，并为我们提供了现有类的本地引用。
- en: Any class methods and properties can then be accessed through the local variable.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何类方法和属性都可以通过局部变量访问。
- en: It's common to store extension methods inside a static class, which, in turn,
    is stored inside its namespace. This allows you to control what other scripts
    have access to your custom functionality.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将扩展方法存储在静态类中是常见的，而静态类又存储在其命名空间中。这使您可以控制其他脚本可以访问您的自定义功能。
- en: Your next task is to put class extensions into practice by adding a new method
    to the built-in C# `String` class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您的下一个任务是通过向内置的C# `String`类添加一个新方法来将类扩展付诸实践。
- en: 'Let''s take a look at extensions in practice by adding a custom method to the
    `String` class. Create a new C# script in the `Scripts` folder, name it `CustomExtensions`,
    and add the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向`String`类添加自定义方法来实践扩展。在`Scripts`文件夹中创建一个新的C#脚本，命名为`CustomExtensions`，并添加以下代码：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s break down the code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: First, it declares a namespace named `CustomExtensions` to hold all the extension
    classes and methods.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，它声明了一个名为`CustomExtensions`的命名空间，用于保存所有扩展类和方法。
- en: Then, it declares a `static` class named `StringExtensions` for organizational
    purposes; each group of class extensions should follow this setup.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为了组织目的，它声明了一个名为`StringExtensions`的`static`类；每组类扩展都应遵循此设置。
- en: 'Next, it adds a `static` method named `FancyDebug` to the `StringExtensions`
    class:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它向`StringExtensions`类添加了一个名为`FancyDebug`的`static`方法：
- en: The first parameter, `this string str`, marks the method as an extension.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数`this string str`标记该方法为扩展。
- en: The `str` parameter will hold a reference to the actual text value that `FancyDebug()`
    is called from; we can operate on `str` inside the method body as a stand-in for
    all string literals.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str`参数将保存对`FancyDebug()`所调用的实际文本值的引用；我们可以在方法体内操作`str`，作为所有字符串文字的替代。'
- en: Finally, it prints out a debug message whenever `FancyDebug` is executed, using
    `str.Length` to reference the string variable that the method is called on.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，每当执行`FancyDebug`时，它都会打印出一个调试消息，使用`str.Length`来引用调用该方法的字符串变量。
- en: In practice, this will let you add any of your own custom functionality to existing
    C# classes or even your own custom ones. Now that the extension is part of the
    `String` class, let's test it out. To use our new custom string method, we'll
    need to include it in whatever class we want to have access to it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这将允许您向现有的C#类或甚至您自己的自定义类添加任何自定义功能。现在扩展是`String`类的一部分，让我们来测试一下。要使用我们的新自定义字符串方法，我们需要在想要访问它的任何类中包含它。
- en: 'Open up `GameBehavior` and update the class with the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`GameBehavior`并使用以下代码更新类：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s break down the code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解一下代码：
- en: First, it adds the `CustomExtensions` namespace with a `using` directive at
    the top of the file.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在文件顶部使用`using`指令添加`CustomExtensions`命名空间。
- en: Then, it calls `FancyDebug` on the `_state` string variable with dot notation
    inside `Initialize()` to print out the number of individual characters its value
    has.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它在`Initialize()`内部使用点表示法在`_state`字符串变量上调用`FancyDebug`，以打印出其值具有的个体字符数。
- en: 'Extending the entire `string` class with `FancyDebug()` means that any string
    variable has access to it. Since the first extension method parameter has a reference
    to whatever `string` value that `FancyDebug()` is called on, its length will be
    printed out properly, as shown here:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`FancyDebug()`扩展整个`string`类意味着任何字符串变量都可以访问它。由于第一个扩展方法参数引用了`FancyDebug()`所调用的任何`string`值，因此其长度将被正确打印出来，如下所示：
- en: '![](img/B17573_10_06.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_10_06.png)'
- en: 'Figure 10.6: Example output from custom extension'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：自定义扩展的示例输出
- en: A custom class can also be extended using the same syntax, but it's more common
    to just add extra functionality directly into the class if it's one you control.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用相同的语法扩展自定义类，但如果您控制一个类，直接将额外功能添加到类中更常见。
- en: The last topic we'll explore in this chapter is namespaces, which we briefly
    learned about earlier in the book. In the next section, you'll learn about the
    larger role that namespaces play in C# and how to create your type alias.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨的最后一个主题是命名空间，我们在本书的前面简要了解过。在下一节中，您将了解命名空间在C#中扮演的更大角色，以及如何创建您自己的类型别名。
- en: Namespace conflicts and type aliasing
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间冲突和类型别名
- en: As your applications get more complicated, you'll start to section off your
    code into namespaces, ensuring that you have control over where and when it's
    accessed. You'll also use third-party software tools and plugins to save on time
    implementing a feature from the ground up that someone else has already made available.
    Both of these scenarios show that you're progressing with your programming knowledge,
    but they can also cause namespace conflicts.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的应用程序变得更加复杂，您将开始将代码分成命名空间，确保您可以控制何时何地访问它。您还将使用第三方软件工具和插件，以节省实现已经可用的功能的时间。这两种情况都表明您正在不断提高您的编程知识，但它们也可能引起命名空间冲突。
- en: '**Namespace conflicts** happen when there are two or more classes or types
    with the same name, which happens more than you''d think.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间冲突**发生在有两个或更多具有相同名称的类或类型时，这种情况比你想象的要多。'
- en: 'Good naming habits tend to produce similar results, and before you know it,
    you''re dealing with multiple classes named `Error` or `Extension`, and Visual
    Studio is throwing out errors. Luckily, C# has a simple solution to these situations:
    **type aliasing**.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的命名习惯往往会产生类似的结果，不知不觉中，您将处理多个名为`Error`或`Extension`的类，而Visual Studio则会抛出错误。幸运的是，C#对这些情况有一个简单的解决方案：**类型别名**。
- en: 'Defining a type alias lets you explicitly choose which conflicting type you
    want to use in a given class, or create a more user-friendly name for a long-winded
    existing one. Type aliases are added at the top of the class file with a `using`
    directive, followed by the alias name and the assigned type:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类型别名可以让您明确选择在给定类中要使用的冲突类型，或者为现有的冗长名称创建一个更用户友好的名称。类型别名是通过`using`指令在类文件顶部添加的，后跟别名和分配的类型：
- en: '[PRE18]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For instance, if we wanted to create a type alias to refer to the existing
    `Int64` type, we could say the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要创建一个类型别名来引用现有的`Int64`类型，我们可以这样说：
- en: '[PRE19]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that `CustomInt` is a type alias for the `System.Int64` type, the compiler
    will treat it as an `Int64`, letting us use it like any other type:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`CustomInt`是`System.Int64`类型的类型别名，编译器将把它视为`Int64`，让我们可以像使用其他类型一样使用它：
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can use type aliasing with your custom types, or existing ones with the
    same syntax, as long as they're declared at the top of script files with the other
    `using` directives.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类型别名来使用你的自定义类型，或者使用相同的语法来使用现有的类型，只要它们在脚本文件的顶部与其他`using`指令一起声明。
- en: For more information on the `using` keyword and type aliasing, check out the
    C# documentation at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`using`关键字和类型别名的更多信息，请查看C#文档[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/using-directive)。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: With new modifiers, method overloading, class extensions, and object-oriented
    skills under our belts, we are only one step away from the end of our C# journey.
    Remember, these intermediate topics are intended to get you thinking about more
    complex applications of the knowledge you've been gathering throughout this book;
    don't think that what you've learned in this chapter is all that there is to know
    on these concepts. Take it as a starting point and continue from there.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有了新的修饰符、方法重载、类扩展和面向对象的技能，我们离C#之旅的终点只有一步之遥。记住，这些中级主题旨在让你思考知识的更复杂应用；不要认为你在本章学到的就是这些概念的全部。把它当作一个起点，然后继续前进。
- en: In the next chapter, we'll discuss the basics of generic programming, get a
    little hands-on experience with delegates and events, and wrap up with an overview
    of exception handling.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论泛型编程的基础知识，获得一些委托和事件的实际经验，并最后概述异常处理。
- en: Pop quiz – leveling up
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小测验-升级
- en: Which keyword would mark a variable as unmodifiable but requires an initial
    value?
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个关键字会将变量标记为不可修改，但需要初始值？
- en: How would you create an overloaded version of a base method?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何创建一个基本方法的重载版本？
- en: What is the main difference between classes and interfaces?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类和接口之间的主要区别是什么？
- en: How would you solve a namespace conflict in one of your classes?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何解决类中的命名空间冲突？
- en: JOIN us on Discord!
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C#专家和Harrison Ferrone一起阅读本书。提出问题，为其他读者提供解决方案，通过*问我任何事*与作者交流等等。
- en: Join Now!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
