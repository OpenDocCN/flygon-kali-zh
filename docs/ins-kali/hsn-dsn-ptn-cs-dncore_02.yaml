- en: Overview of OOP in .NET Core and C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core和C#中OOP的概述
- en: For over 20 years, the most popular programming languages have been based on
    the principles of **object-oriented programming** (**OOP**). The rise in popularity
    of OOP languages is largely to do with the benefits of being able to abstract
    complex logic into a structure, called an object, that can be more easily explained,
    and, more importantly, reused within an application. In essence, OOP is a software
    design approach, that is, a pattern for developing software using the concept
    of objects that contain data and functionality. As the software industry matured,
    patterns appeared in OOP for commonly occurring problems, as they were effective
    in solving the same problems but across different contexts and industries. As
    software moved from the mainframe to client servers and then to the cloud, additional
    patterns have emerged to help in reducing development costs and improving reliability.
    This book will explore design patterns, from the foundation of OOP to the architecture
    design patterns for cloud-based software.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 20多年来，最流行的编程语言都是基于面向对象编程（OOP）原则的。OOP语言的流行主要是因为能够将复杂逻辑抽象成一个称为对象的结构，这样更容易解释，更重要的是在应用程序中更容易重用。实质上，OOP是一种软件设计方法，即使用包含数据和功能的对象概念来开发软件的模式。随着软件行业的成熟，OOP中出现了用于常见问题的模式，因为它们在解决相同问题时在不同的上下文和行业中都是有效的。随着软件从大型机移动到客户服务器，然后再到云端，出现了额外的模式，以帮助降低开发成本和提高可靠性。本书将探讨设计模式，从OOP的基础到面向云端软件的架构设计模式。
- en: OOP is based on the concept of an object. This object generally contains data,
    referred to as properties and fields, and code or behavior referred to as methods.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: OOP基于对象的概念。这个对象通常包含数据，称为属性和字段，以及代码或行为，称为方法。
- en: '**Design patterns** are solutions to general problems that software programmers
    face during development, and are built from the experience of what works and what
    doesn''t. These solutions are trialed and tested by numerous developers in various
    situations. The benefits of using a pattern based on this previous activity ensure
    that the same efforts are not repeated again and again. In addition to this, using
    a pattern adds a sense of reliability that the problem will be solved without
    introducing a defect or issue.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是软件程序员在开发过程中面临的一般问题的解决方案，是根据经验构建的，这些解决方案经过多位开发人员在各种情况下的试验和测试。使用基于以前活动的模式的好处确保不会一遍又一遍地重复相同的努力。此外，使用模式会增加一种可靠性感，即问题将在不引入缺陷或问题的情况下得到解决。
- en: 'This chapter reviews OOP and how it applies to C#. Note that this is simply
    intended as a brief introduction and it is not meant to be a complete primer for
    OOP or C#; instead, the chapter will cover aspects of both in enough detail to
    introduce you to the design patterns that will be covered in subsequent chapters.
    This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将回顾OOP以及它如何应用于C#。请注意，这只是一个简要介绍，不是OOP或C#的完整入门；相反，本章将详细介绍这两个方面，以便向您介绍后续章节中将涵盖的设计模式。本章将涵盖以下主题：
- en: A discussion of OOP and how classes and objects work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OOP的讨论以及类和对象的工作原理
- en: Inheritance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Encapsulation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Polymorphism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态性
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain these concepts. The code
    is kept simple and is just for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例来解释这些概念。代码保持简单，仅用于演示目的。大多数示例涉及使用C#编写的.NET Core控制台应用程序。
- en: 'To run and execute the code, you will need the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，您需要以下内容：
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017 version
    3 or later)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（您也可以使用Visual Studio 2017版本3或更高版本运行应用程序）
- en: .NET Core
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core
- en: SQL Server (the Express Edition is used in this chapter)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章中使用Express Edition）
- en: Installing Visual Studio
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: 'In order to run these code examples, you will need to install Visual Studio
    or later (you can also use your preferred IDE). To do this, follow these instructions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这些代码示例，您需要安装Visual Studio或更高版本（也可以使用您喜欢的IDE）。要做到这一点，请按照以下说明进行操作：
- en: Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载Visual Studio：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions included in the link. Multiple versions
    of Visual Studio are available; in this chapter, we are using Visual Studio for
    Windows.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照链接中包含的安装说明进行操作。有多个版本的Visual Studio可用；在本章中，我们使用的是Windows版的Visual Studio。
- en: Setting up .NET Core
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置.NET Core
- en: 'If you do not have .NET Core installed, you will need to follow these instructions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有安装.NET Core，您需要按照以下说明进行操作：
- en: Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载.NET Core：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)。
- en: Follow the installation instructions in the related library: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照相关库中的安装说明进行操作：[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: The complete source code is available in GitHub. The source code shown in the
    chapter might not be complete, so it is recommended that you retrieve the source
    code in order to run the examples ([https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter1](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter1)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在GitHub上找到。本章中显示的源代码可能不完整，因此建议您检索源代码以运行示例（[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter1](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter1)）。
- en: The models used in this book
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书中使用的模型
- en: As a learning aid, this book will contain many code samples in C# alongside
    diagrams and images to help describe specific concepts where possible. This is
    not a **Unified Modeling Language** (**UML**) book; however, for those with a
    knowledge of UML, many of the diagrams should seem familiar. This section provides
    a description of the class diagrams that will be used in this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为学习辅助，本书将包含许多C#代码示例，以及图表和图像，以帮助尽可能清楚地描述特定概念。本书不是**统一建模语言**（**UML**）书；然而，对于了解UML的人来说，许多图表应该看起来很熟悉。本节提供了本书中将使用的类图的描述。
- en: 'Here, a class will be defined as including both fields and methods separated
    by a dashed line. If important to the discussion, then accessibility will be indicated
    as `-` for private, `+` for public, `#` for protected, and `~` for internal. The
    following screenshot illustrates this by showing a `Car` class with a private `_name` variable
    and a public `GetName()` method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个类将被定义为包括由虚线分隔的字段和方法。如果讨论重要，可通过`-`表示私有，`+`表示公共，`#`表示受保护，`~`表示内部来指示可访问性。以下截图通过显示一个带有私有`_name`变量和公共`GetName()`方法的`Car`类来说明这一点：
- en: '![](img/3d37335f-9e59-494a-bdf4-67d30cd832d0.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3d37335f-9e59-494a-bdf4-67d30cd832d0.png)'
- en: 'When showing relationships between objects, an association is shown with a
    solid line, an aggregation is shown with an open diamond, and a composition is
    shown with a filled diamond. When important to the discussion, multiplicity will
    be shown next to the class in question. The following diagram illustrates the `Car`
    class as having a single **Owner**, and up to three **Passengers**; it consists
    of four **Wheels**:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当展示对象之间的关系时，用实线表示关联，用开放的菱形表示聚合，用填充的菱形表示组合。如果讨论重要，多重性将显示在相关类旁边。以下图表说明了`Car`类有一个**Owner**和最多三个**Passengers**；它由四个**Wheels**组成：
- en: '![](img/cc1fc18d-dc06-4b38-ae24-f7898b19c050.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc1fc18d-dc06-4b38-ae24-f7898b19c050.png)'
- en: '**Inheritance** is shown using an open triangle on the base class using a solid
    line. The following diagram shows the relationship between an `Account` base class
    and the `CheckingAccount` and `SavingsAccount` child classes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**使用实线在基类上显示一个开放的三角形。以下图表显示了`Account`基类与`CheckingAccount`和`SavingsAccount`子类之间的关系：'
- en: '![](img/7fe47763-223e-4667-8003-38f5116f7c82.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7fe47763-223e-4667-8003-38f5116f7c82.png)'
- en: '**Interfaces** are shown in a similar manner to inheritance, but they use a
    dashed line as well as an additional `<<interface>>` label, as shown in the following
    diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口**的显示方式与继承类似，但它们使用虚线以及额外的`<<interface>>`标签，如下图所示：'
- en: '![](img/b9fa7abd-7fda-4877-acf8-971a8c3fc429.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9fa7abd-7fda-4877-acf8-971a8c3fc429.png)'
- en: This section provides an overview of the models used in this book. This style/approach
    was chosen because, hopefully, it will be familiar to the majority of readers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了本书中使用的模型。选择这种风格/方法是因为希望大多数读者都能熟悉。
- en: OOP and how classes and objects work
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程和类与对象的工作原理
- en: OOP refers to a software programming approach that uses objects defined as classes.
    These definitions include fields, sometimes called attributes, to store data and
    methods in order to provide functionality. The first OOP language was a simulation
    of real systems known as Simula ([https://en.wikipedia.org/wiki/Simula](https://en.wikipedia.org/wiki/Simula))
    and was developed at the Norwegian Computing Center in 1960\. The first pure OOP
    language came into existence in 1970 as the Smalltalk ([https://en.wikipedia.org/wiki/Smalltalk](https://en.wikipedia.org/wiki/Smalltalk))
    language. This language was designed to program the Dynabook ([http://history-computer.com/ModernComputer/Personal/Dynabook.html](http://history-computer.com/ModernComputer/Personal/Dynabook.html)),
    which is a personal computer created by Alan Kay. Several OOP languages evolved
    from there, with the most popular being Java, C++, Python, and C#.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是指使用类定义的对象的软件编程方法。这些定义包括字段，有时称为属性，用于存储数据和方法以提供功能。第一种面向对象编程语言是称为Simula的真实系统模拟语言（[https://en.wikipedia.org/wiki/Simula](https://en.wikipedia.org/wiki/Simula)），于1960年在挪威计算中心开发。第一种纯面向对象编程语言诞生于1970年，名为Smalltalk（[https://en.wikipedia.org/wiki/Smalltalk](https://en.wikipedia.org/wiki/Smalltalk)）。这种语言旨在为Alan
    Kay创建的个人计算机Dynabook（[http://history-computer.com/ModernComputer/Personal/Dynabook.html](http://history-computer.com/ModernComputer/Personal/Dynabook.html)）编程。从那时起，有几种面向对象编程语言发展而来，最流行的是Java、C++、Python和C#。
- en: OOP is based on objects that contain data. The OOP paradigm allows developers
    to arrange/organize code into an abstract or logical structure called an object.
    An object can contain both data and behavior.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是基于包含数据的对象。面向对象编程范式允许开发人员将代码组织成一个称为对象的抽象或逻辑结构。对象可以包含数据和行为。
- en: 'With the use of the OOP approach, we are doing the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用面向对象的方法，我们正在做以下事情：
- en: '**Modularizing**: Here, an application is decomposed into different modules.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化：在这里，一个应用程序被分解成不同的模块。
- en: '**Reusing the software**: Here, we rebuild or compose an application from different
    (that is, existing or new) modules.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重用软件**：在这里，我们重新构建或组合一个应用程序，使用不同的（即现有的或新的）模块。'
- en: In the following sections, we will discuss and understand the concepts of OOP
    in more detail.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地讨论和理解面向对象编程的概念。
- en: Explaining OOP
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释面向对象编程
- en: Earlier, programming approaches had limitations and they often became difficult
    to maintain. OOP offered a new paradigm in software development that had advantages
    over other approaches. The concept of organizing code into objects is not difficult
    to explain and this is a huge advantage for the adoption of a new pattern. Many
    examples can be taken from the real world in order to explain the concept. Complex
    systems can also be described using smaller building blocks (that is, an *objects*).
    These allow developers to look at sections of the solution individually while
    understanding how they fit into the entire solution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的编程方法有局限性，通常变得难以维护。面向对象编程提供了一种新的软件开发范式，优于其他方法。将代码组织成对象的概念并不难解释，这对于采用新模式是一个巨大的优势。可以从现实世界中找到许多例子来解释这个概念。复杂的系统也可以用更小的构建块（即*对象*）来描述。这使开发人员能够单独查看解决方案的各个部分，同时了解它们如何适应整个解决方案。
- en: 'With this in mind, let''s define a program as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，让我们定义一个程序如下：
- en: '"A program is a list of instructions that instructs the language compiler on
    what to do."'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 程序是一系列指令的列表，指示语言编译器该做什么。
- en: As you can see, an object is a way of organizing a list of instructions in a
    logical manner. Going back to the example of the house, the architect's instructions
    help us to build a house, but they are not the house itself. Instead the architect's
    instructions are an abstract representation of a house. A class is similar as
    it defines the features of an object. An object is then created from the definition
    of a class. This is often called **instantiating the object***.*
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，对象是以一种逻辑方式组织指令的一种方式。回到房子的例子，建筑师的指令帮助我们建造房子，但它们不是房子本身。相反，建筑师的指令是房子的抽象表示。类似的，类定义了对象的特征。然后从类的定义中创建对象。这通常被称为*实例化对象*。
- en: 'To understand OOP more closely, we should mention two other significant programming
    approaches:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更近距离地了解面向对象编程，我们应该提到另外两种重要的编程方法：
- en: '**Structured programming**: This is a term coined by Edsger W. Dijkstra in
    1966. Structured programming is a programming paradigm that solves a problem to handle
    1,000 lines of code and divides these into small parts. These small parts are
    mostly called **subroutines**, **block structures**, **for** and **while** loops,
    and more. Languages that use structured programming techniques include ALGOL,
    Pascal, PL/I, and more.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化编程**：这是由Edsger W. Dijkstra在1966年创造的一个术语。结构化编程是一种解决问题的编程范式，将1000行代码分成小部分。这些小部分通常被称为**子程序**、**块结构**、**for**和**while**循环等。使用结构化编程技术的语言包括ALGOL、Pascal、PL/I等。'
- en: '**Procedural programming**: This is a paradigm derived from structured programming and
    is simply based on how we make a call (also known as a **procedu****ral call**).
    Languages that use procedural programming techniques include COBOL, Pascal, and
    C. A recent example of the Go programming language was published in 2009.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程式编程**：这是从结构化编程派生出来的一种范式，简单地基于我们如何进行调用（也称为**过程调用**）。使用过程式编程技术的语言包括COBOL、Pascal和C。一个最近的例子是2009年发布的Go编程语言。'
- en: Procedural calls
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 过程调用
- en: A procedural call is where a collection of statements, known as a *procedure*,is
    activated. This is sometimes referred to as a procedure that is *invoked*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 程序调用是指一组语句，称为*过程*，被激活。有时这被称为*调用*的过程。
- en: 'The main problem with these two approaches is that programs are not easily
    manageable once they grow. Programs with more complex and larger code bases strain
    these two approaches, leading to difficult-to-understand and difficult-to-maintain
    applications. To overcome such problems, OOP provides the following features:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法的主要问题是，一旦程序变得更加复杂和庞大，就不容易管理。更复杂和更大的代码库会使这两种方法变得紧张，导致难以理解和难以维护的应用程序。为了克服这些问题，面向对象编程提供了以下功能：
- en: Inheritance
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Encapsulation
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Polymorphism
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: In the following sections, we will discuss these features in more detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将更详细地讨论这些功能。
- en: Inheritance, encapsulation, and polymorphism are sometimes referred to as the
    three pillars of OOP.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 继承、封装和多态有时被称为面向对象编程的三大支柱。
- en: Before we begin, let's discuss some structures that are found in OOP.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们讨论一些在面向对象编程中发现的结构。
- en: A class
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个类
- en: A **class** is a group or template definition of the methods and variables that
    describe an object. In other words, a class is a blueprint, containing the definition
    of the variables and the methods that are common to all instances of the class
    called objects.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**是描述对象的方法和变量的组或模板定义。换句话说，类是一个蓝图，包含了对所有类实例（称为对象）通用的变量和方法的定义。'
- en: 'Let''s take a look at the following code example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码示例：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, we have a `PetAnimal` class that has two private fields
    called `PetName` and `PetColor`, and one method called `MyPet()`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个名为`PetAnimal`的类，其中有两个名为`PetName`和`PetColor`的私有字段，以及一个名为`MyPet()`的方法。
- en: An object
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个对象
- en: 'In the real world, objects share two characteristics, that is, state and behavior.
    In other words, we can say that every object has a name, color, and more; these
    characteristics are simply the state of an object. Let''s take the example of
    any type of pet: a dog and a cat will both have a name by which they called. So,
    in this way, my dog is named Ace and my cat is named Clementine. Similarly, dogs
    and cats have specific behaviors, for example, dogs barks and cats meow.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，对象共享两个特征，即状态和行为。换句话说，我们可以说每个对象都有一个名字，颜色，等等；这些特征只是对象的状态。让我们以任何类型的宠物为例：狗和猫都有一个名字，它们被称为。所以，以这种方式，我的狗叫Ace，我的猫叫Clementine。同样，狗和猫有特定的行为，例如，狗会叫，猫会喵喵叫。
- en: In the *Explaining OOP* section, we discussed that OOP is a programming model
    that is supposed to combine a state or structure (data) and the behavior (method)
    to deliver software functionality. In the previous example, the different states
    of pets make up the actual data, while the behavior of the pets is the method.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在*解释面向对象编程*部分，我们讨论了面向对象编程是一种旨在将状态或结构（数据）与行为（方法）结合起来以提供软件功能的编程模型。在之前的例子中，宠物的不同状态构成了实际数据，而宠物的行为则是方法。
- en: An object stores the information (which is simply data) in attributes and discloses
    its behavior through methods.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对象通过属性存储信息（即数据），并通过方法展示其行为。
- en: In terms of an OOP language such as C#, an object is an instance of a class.
    In our previous example, the real-world object, `Dog`, would be an object of the `PetAnimal` class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的语言（如C#）中，对象是类的一个实例。在我们之前的例子中，现实世界中的对象`Dog`将是`PetAnimal`类的一个对象。
- en: Objects can be concrete (that is, a real-world object, such as a dog or cat,
    or any type of file, such as physical file or a computer file) or they can be
    conceptual, such as database schemas or code blueprints.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对象可以是具体的（即现实世界中的对象，如狗或猫，或任何类型的文件，如物理文件或计算机文件），也可以是概念性的，如数据库模式或代码蓝图。
- en: 'The following code snippet shows how an object contains data and a method,
    and how you can use it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了一个对象包含数据和方法，以及如何使用它：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the previous code snippet, we have created two objects: `dog` and `cat`.
    These objects are two different instances of a `PetAnimal` class. You can see
    that the fields or properties that contain data about the animal are given values
    using the constructor method. The constructor method is a special method used
    to create an instance of the class.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们创建了两个对象：`dog`和`cat`。这些对象是`PetAnimal`类的两个不同实例。可以看到，包含有关于动物的数据的字段或属性是通过构造方法赋值的。构造方法是用于创建类的实例的特殊方法。
- en: 'Let''s visualize this example in the following diagram:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下图中将这个例子可视化：
- en: '![](img/831ba13f-467e-4a85-9819-0d19dad2a714.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/831ba13f-467e-4a85-9819-0d19dad2a714.png)'
- en: The preceding diagram is a pictorial representation of our previous code example,
    where we created two different `Dog` and `Cat` objects of the `PetAnimal` class.
    The diagram is relatively self-explanatory; it tells us that the object of `Dog` class
    is an instance of the `PetAnimal` class, as is the `Cat` object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上图是我们之前代码示例的图示表示，我们创建了两个不同的`Dog`和`Cat`对象，它们属于`PetAnimal`类。图示相对容易理解；它告诉我们`Dog`类的对象是`PetAnimal`类的一个实例，`Cat`对象也是如此。
- en: Associations
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联
- en: Object associations are an important feature of OOP. Relationships exist between
    objects in the real world, and, in OOP, an association allows us to define a *has-a*
    relationship; for example, a bicycle *has a *rider or a cat *has a* nose.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对象关联是面向对象编程的一个重要特性。现实世界中对象之间存在关系，在面向对象编程中，关联允许我们定义*拥有*关系；例如，自行车*拥有*骑手或猫*拥有*鼻子。
- en: 'The types of *has-a* relationship are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*拥有*关系的类型如下：'
- en: '**Association**: An association is used to describe a relationship between
    objects so that there is no ownership described, for example, the relationship
    between a car and a person. The car and person have a relationship described,
    such as a driver. A person can drive multiple cars and a car can be driven by
    multiple people.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关联**：关联用于描述对象之间的关系，不涉及所有权的描述，例如汽车和人之间的关系。汽车和人之间有一个关系，比如司机。一个人可以驾驶多辆汽车，一辆汽车也可以被多个人驾驶。'
- en: '**Aggregation**: An aggregation is a specialized form of association. Similar
    to associations, objects have their own life cycle in aggregations, but it involves ownership.
    This means that a child object cannot belong to another parent object. Aggregation
    is a one-way relationship where the lives of the objects are independent from
    each other. For example, the child and parent relationship is an aggregation, because
    every child has a parent but it''s not necessary that every parent has a child.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚合**：聚合是关联的一种特殊形式。与关联类似，对象在聚合中有自己的生命周期，但它涉及所有权。这意味着子对象不能属于另一个父对象。聚合是一种单向关系，对象的生命周期彼此独立。例如，子对象和父对象的关系是一种聚合，因为每个子对象都有一个父对象，但并不是每个父对象都有一个子对象。'
- en: '**Composition**: A composition refers to a relationship of death; it represents
    the relationship between two objects where one object (child) depends on another
    object (parent). If the parent object is deleted, all its children automatically
    get deleted. Let''s consider a house and a room as an example. One house has multiple
    rooms, but a single room cannot belong to multiple houses. If we demolished the
    house, the rooms will automatically be deleted.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：组合指的是一种依赖关系；它代表了两个对象之间的关系，其中一个对象（子对象）依赖于另一个对象（父对象）。如果父对象被删除，所有子对象将自动被删除。让我们以房子和房间为例。一个房子有多个房间，但一个房间不能属于多个房子。如果我们拆除了房子，房间将自动被删除。'
- en: Let's illustrate these concepts in C# by extending the previous pet example
    and introducing a `PetOwner` class. The `PetOwner` class could be associated with
    one or more `PetAnimal` instances. As the `PetAnimal` class can exist with or
    without having an owner, the relationship is an aggregation. `PetAnimal` is related
    to `PetColor` and, in this system, `PetColor` only exists if it is related to
    `PetAnimal`, making the association a composition.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过扩展之前的宠物示例并引入`PetOwner`类来在C#中说明这些概念。`PetOwner`类可以与一个或多个`PetAnimal`实例相关联。由于`PetAnimal`类可以存在有或没有主人，所以这种关系是一种聚合。`PetAnimal`与`PetColor`相关联，在这个系统中，只有当`PetColor`与`PetAnimal`相关联时，`PetColor`才存在，使得关联成为一种组合。
- en: 'The following diagram illustrates both aggregation and composition:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了聚合和组合：
- en: '![](img/d132053d-f041-4a26-a000-436ad74ddaa6.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d132053d-f041-4a26-a000-436ad74ddaa6.png)'
- en: The preceding model is based on UML and might not be familiar to you; so, let's
    point out some important things about the diagram. The class is represented by
    a box containing the class name as well as its attributes and methods (separated
    by a dashed line). For now, ignore the symbol before the name, for example, `+` or
    `-`, as we will cover access modifiers when we discuss encapsulation later. The
    associations are shown with a line connecting the classes. In the case of compositions,
    a solid diamond on the side of the parent is used, whereas an open diamond on
    the side of the parent is used to show aggregations. Additionally, note that the
    diagram supports a multiplicity value that indicates the number of possible children.
    In the diagram, a `PetOwner` class can have `0` or more `PetAnimal` classes (note
    that ***** indicates no enforced limit to the number of associations).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模型是基于UML的，可能对你来说不太熟悉；所以，让我们指出一些关于图表的重要事项。类由一个包含类名以及其属性和方法（用虚线分隔）的方框表示。现在先忽略名称前面的符号，例如`+`或`-`，因为我们将在后面讨论封装时涵盖访问修饰符。关联关系用连接类的线表示。在组合的情况下，父类的一侧使用实心菱形，而聚合的情况下，父类的一侧使用空心菱形。此外，注意图表支持表示可能的子类数量的多重性值。在图表中，`PetOwner`类可以有`0`个或更多个`PetAnimal`类（注意*****表示关联数量没有限制）。
- en: UML
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: UML
- en: The UML is a modeling language specifically developed for software engineering.
    It was developed over 20 years and is managed by the **Object Management Group**
    (**OMG**). You can refer to [http://www.uml.org/](http://www.uml.org/) for more
    details.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: UML是一种专门为软件工程开发的建模语言。它已经发展了20多年，由**对象管理组**（**OMG**）管理。你可以参考[http://www.uml.org/](http://www.uml.org/)了解更多细节。
- en: An interface
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: In C#, an **interface** defines what an object contains, or its contract; in
    particular, the methods, properties, events, or indices of the object. However,
    the interface does not provide implementation. Interfaces cannot contain attributes.
    This is in contrast to a base class, where the base class provides both the contract
    and the implementation. A class that implements an interface must implement everything
    specified in the interface.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，**接口**定义了一个对象包含的内容，或者说它的契约；特别是对象的方法、属性、事件或索引。然而，接口不提供实现。接口不能包含属性。这与基类形成对比，基类既提供了契约又提供了实现。实现接口的类必须实现接口中指定的所有内容。
- en: An abstract class
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类
- en: An abstract class is a bit of a hybrid between the interface and base class
    as it provides both implementations and attributes as well as methods that must
    be defined in the child classes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是接口和基类之间的混合体，因为它既提供实现和属性，也提供必须在子类中定义的方法。
- en: Signature
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 签名
- en: The term *signature* can also be used to describe the contract of an object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*签名*也可以用来描述对象的契约。
- en: Inheritance
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: One of the most important concepts in OOP is inheritance. Inheritance between
    classes allows us to define an *is-a-type-of relationship*; for example, a car
    *is a type of* vehicle. The importance of this concept is that it allows for objects
    of the same type to share similar features. Let's say that we have a system for
    managing different products of an online bookstore. We might have one class for
    storing information about a physical book and a different one for storing information
    about a digital or online book. The features that are similar between the two,
    such as the name, publisher, and author, could be stored in another class. Both
    the physical and digital book classes could then inherit from the other class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程中最重要的概念之一是继承。类之间的继承允许我们定义一个*是一种*关系；例如，汽车*是一种*车辆。这个概念的重要性在于它允许相同类型的对象共享相似的特征。假设我们有一个在线书店管理不同产品的系统。我们可能有一个类用于存储关于实体书的信息，另一个类用于存储关于数字或在线书的信息。两者之间相似的特征，比如名称、出版商和作者，可以存储在另一个类中。然后实体书和数字书类可以继承自另一个类。
- en: 'There are different terms to describe classes in inheritance: a *child* or
    *derived* class inherits from another class while the class being inherited from
    can be called the *parent* or *base* class.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在继承中有不同的术语来描述类：*子类*或*派生类*继承自另一个类，而被继承的类可以被称为*父类*或*基类*。
- en: In the following sections, we will discuss inheritance in more detail.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将更详细地讨论继承。
- en: Types of inheritance
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承的类型
- en: Inheritance helps us to define a child class. This child class inherits the behavior
    of the parent or base class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 继承帮助我们定义一个子类。这个子类继承了父类或基类的行为。
- en: In C#, inheritance is symbolically defined using a colon (`:`).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，继承是用冒号(`:`)来表示的。
- en: 'Let''s take a look at the different types of inheritance:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看不同类型的继承：
- en: '**Single inheritance**: As the most common type of inheritance, single inheritance
    describes a single class that is is derived from another class.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单继承**：作为最常见的继承类型，单继承描述了一个类从另一个类派生出来的情况。'
- en: 'Let''s revisit the `PetAnimal` class previously mentioned and, instead, use
    inheritance to define our `Dog` and `Cat` classes. With inheritance, we can define
    some attributes that are common for both. For example, the name of the pet and
    the color of the pet would be common, so they would be located in a base class.
    The specifics of a cat or a dog would then be defined in a specific class; for
    example, the sound the cat and dog make. The following diagram illustrates a `PetAnimal`
    base class with two child classes:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视之前提到的`PetAnimal`类，并且使用继承来定义我们的`Dog`和`Cat`类。通过继承，我们可以定义一些两者共有的属性。例如，宠物的名字和颜色是共有的，所以它们会位于一个基类中。猫或狗的具体信息会在特定的类中定义；例如，猫和狗发出的声音。下图展示了一个`PetAnimal`基类和两个子类：
- en: '![](img/dcf9f6cd-c935-4973-a43a-4139b3d6ff1d.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dcf9f6cd-c935-4973-a43a-4139b3d6ff1d.png)'
- en: C# only supports single inheritance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: C#只支持单继承。
- en: '**Multiple inheritance**: Multiple inheritance happens when a derived class
    inherits multiple base classes. Languages such as C++ support multiple inheritance.
    C# does not support multiple inheritance, but we can achieve behaviors similar
    to multiple inheritance with the help of interfaces.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多重继承**：多重继承发生在派生类继承多个基类的情况下。诸如C++的语言支持多重继承。C#不支持多重继承，但我们可以通过接口实现类似多重继承的行为。'
- en: 'You can refer to the following post for more information about C# and multiple
    inheritance:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下帖子了解有关C#和多重继承的更多信息：
- en: '[https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-supportmultiple-inheritance/](https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-supportmultiple-inheritance/).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-supportmultiple-inheritance/](https://blogs.msdn.microsoft.com/csharpfaq/2004/03/07/why-doesnt-c-supportmultiple-inheritance/)。'
- en: '**Hierarchical inheritance**: Hierarchical inheritance happens when more than
    one class inherits from another class.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分层继承**：当多个类从另一个类继承时发生分层继承。'
- en: '**Multilevel inheritance**: When a class is derived from a class that is already
    a derived class, it is called multilevel inheritance.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多级继承**：当一个类从已经是派生类的类中派生时，称为多级继承。'
- en: '**Hybrid inheritance**: Hybrid inheritance is a combination of more than one
    inheritance.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合继承**：混合继承是多种继承的组合。'
- en: C# does not support hybrid inheritance.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: C#不支持混合继承。
- en: '**Implicit inheritance**: All the types in .NET Core implicitly inherit from
    the `System.Object` class and its derived classes.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式继承**：.NET Core中的所有类型都隐式继承自`System.Object`类及其派生类。'
- en: Encapsulation
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: Encapsulation is another fundamental concept in OOP where the details of a class,
    that is, the attributes and methods, can be visible or not visible outside the
    object. With encapsulation, a developer is providing guidance on how a class should
    be used as well as helping to prevent a class from being handled incorrectly.
    For example, let's say we wanted to only allow adding `PetAnimal` objects by using
    the `AddPet(PetAnimal)` method. We would do this by having the `PetOwner` class's
    `AddPet(PetAnimal)` method available while having the `Pets` attribute restricted to
    anything outside the `PetAnimal` class. In C#, this is possible by making the
    `Pets` attribute private. One reason for doing this would be if additional logic
    was required whenever a `PetAnimal` class was added, such as logging or validating
    that the `PetOwner` class could have a pet.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是面向对象编程中的另一个基本概念，其中类的细节，即属性和方法，可以在对象外部可见或不可见。通过封装，开发人员提供了关于如何使用类以及如何防止类被错误处理的指导。例如，假设我们只允许使用`AddPet（PetAnimal）`方法添加`PetAnimal`对象。我们可以通过将`PetOwner`类的`AddPet（PetAnimal）`方法设置为可用，同时将`Pets`属性限制为`PetAnimal`类之外的任何内容来实现这一点。在C#中，通过将`Pets`属性设置为私有，这是可能的。这样做的一个原因是，如果需要在添加`PetAnimal`类时需要额外的逻辑，例如记录或验证`PetOwner`类是否可以拥有宠物。
- en: 'C# supports different levels of access that can be set on an item. An item
    could be a class, a class''s attribute or method, or an enumeration:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: C#支持可以在项上设置的不同访问级别。项可以是类、类的属性或方法，或枚举：
- en: '**Public**: This indicates that access is available outside the item.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Public**：表示该项可以在外部访问。'
- en: '**Private**: This indicates that only the object has access to the item.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Private**：表示只有对象可以访问该项。'
- en: '**Protected**: This indicates that only the object (and objects of classes
    that extended the class) can access the attribute or method.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Protected**：表示只有对象（以及扩展了该类的类的对象）可以访问属性或方法。'
- en: '**Internal**: This indicates that only objects within the same assembly have
    access to the item.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Internal**：表示只有同一程序集中的对象可以访问该项。'
- en: '**Protected Internal**: This indicates that only the object (and objects of
    classes that extended the class) can access the attribute or method within the
    same assembly.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Protected Internal**：表示只有对象（以及扩展了该类的类的对象）可以在同一程序集中访问属性或方法。'
- en: 'In the following diagram, access modifiers have been applied to `PetAnimal`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，访问修饰符已应用于`PetAnimal`：
- en: '![](img/d4bb8946-f4a2-416c-938c-f39dc212a197.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4bb8946-f4a2-416c-938c-f39dc212a197.png)'
- en: As an example, the name of the pet and the color were made private to prevent
    access from outside the `PetAnimal` class. In this example, we are restricting
    the `PetName` and `PetColor` properties so only the `PetAnimal` class can access
    them in order to ensure that only the base class, `PetAnimal`, can change their
    values. The constructor of `PetAnimal` was protected to ensure only a child class
    could access it. In this application, only classes within the same library as
    the `Dog` class have access to the `RegisterInObedienceSchool()` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，宠物的名称和颜色被设置为私有，以防止外部访问`PetAnimal`类。在这个例子中，我们限制了`PetName`和`PetColor`属性，所以只有`PetAnimal`类才能访问它们，以确保只有基类`PetAnimal`可以更改它们的值。`PetAnimal`的构造函数被保护，以确保只有子类可以访问它。在这个应用程序中，只有与`Dog`类相同的库中的类才能访问`RegisterInObedienceSchool（）`方法。
- en: Polymorphism
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: 'The ability to handle different objects using the same interface is called
    polymorphism. This provides developers with the ability to build flexibility into
    applications by writing a single piece of functionality that can be applied to
    different forms as long as they share a common interface. There are different
    definitions of polymorphism in OOP, and we will distinguish between two main types:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同接口处理不同对象的能力称为多态性。这为开发人员提供了通过编写单个功能来构建灵活性的能力，只要它们共享一个公共接口，就可以应用于不同的形式。在面向对象编程中有不同的多态性定义，我们将区分两种主要类型：
- en: '**Static or early binding**: This form of polymorphism happens when the application
    is compiled.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态或早期绑定**：当应用程序编译时发生这种形式的多态性。'
- en: '**Dynamic or late binding**: This form of polymorphism happens when the application
    is running.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态或晚期绑定**：当应用程序正在运行时发生这种形式的多态性。'
- en: Static polymorphism
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态多态性
- en: 'Static or early binding polymorphism happens at compile time and it primarily
    consists of method overloading, where a class has multiple methods with the same
    name but with different parameters. This is often useful to convey a meaning behind
    the method or to simplify the code. For example, in a calculator, it is more readable
    to have multiple methods for adding different types of number rather than having
    a different method name for each scenario; let''s compare the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 静态或早期绑定多态发生在编译时，主要由方法重载组成，其中一个类具有多个具有相同名称但具有不同参数的方法。这通常有助于传达方法背后的含义或简化代码。例如，在计算器中，为不同类型的数字添加多个方法比为每种情况使用不同的方法名更可读；让我们比较以下代码：
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the following, the code is shown again with the same functionality, but
    without overloading the `Add()` method:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，展示了相同功能的代码，但没有重载`Add()`方法：
- en: '[PRE3]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the pet example, an owner will use different food to feed objects of the `cat` and
    `dog` class. We can define this as the `PetOwner` class with two methods for `Feed()`,
    as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在宠物的例子中，主人会使用不同的食物来喂养`cat`和`dog`类的对象。我们可以定义`PetOwner`类，其中有两个`Feed()`方法，如下所示：
- en: '[PRE4]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both methods use a `PetFeeder` class to feed the pet, while the `dog` class
    is given `Kibble` and the `cat` instance is given `Fish`. The `PetFeeder` class
    is described in the *Generics* section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都使用`PetFeeder`类来喂养宠物，而`dog`类被给予`Kibble`，`cat`实例被给予`Fish`。`PetFeeder`类在*泛型*部分中描述。
- en: Dynamic polymorphism
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态多态
- en: 'Dynamic or late binding polymorphism happens while the application is running.
    There are multiple situations where this can occur and we''ll cover three common
    forms in C#: interface, inheritance, and generics.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 动态或后期绑定多态发生在应用程序运行时。有多种情况会发生这种情况，我们将涵盖C#中的三种常见形式：接口、继承和泛型。
- en: Interface polymorphism
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口多态
- en: 'An interface defines the signature that a class must implement. In the `PetAnimal`
    example, imagine that we define pet food as providing an amount of energy, as
    follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义了类必须实现的签名。在`PetAnimal`的例子中，假设我们将宠物食物定义为提供一定数量的能量，如下所示：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By itself, the interface cannot be instantiated but describes what an instance
    of `IPetFood` must implement. For example, `Kibble` and `Fish` might provide different
    levels of energy, as shown in the following code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接口本身不能被实例化，但描述了`IPetFood`的实例必须实现的内容。例如，`Kibble`和`Fish`可能提供不同级别的能量，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code snippet, `Kibble` provides less energy than `Fish`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，`Kibble`提供的能量比`Fish`少。
- en: Inheritance polymorphism
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承多态
- en: 'Inheritance polymorphism allows for functionality to be determined at runtime
    in a similar way to an interface but applies to class inheritance. In our example,
    a pet can be fed, so we can define this as having a new `Feed(IPetFood)` method,
    which uses the interface that was defined previously:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 继承多态允许在运行时确定功能，类似于接口，但适用于类继承。在我们的例子中，宠物可以被喂食，所以我们可以定义一个新的`Feed(IPetFood)`方法，它使用之前定义的接口：
- en: '[PRE7]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code indicates that all implementations of `PetAnimal` will have
    a `Feed(IPetFood)` method and child classes can provide a different implementation.
    `Eat(IPetFood food)` is not marked as virtual, as it is intended that all `PetAnimal`
    objects will use the method without needing to override its behavior. It is also
    marked as protected to prevent it being accessed from outside the object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码表明，`PetAnimal`的所有实现都将有一个`Feed(IPetFood)`方法，子类可以提供不同的实现。`Eat(IPetFood food)`没有标记为虚拟，因为预期所有`PetAnimal`对象都将使用该方法，而无需覆盖其行为。它还被标记为受保护，以防止从对象外部访问它。
- en: A virtual method does not have to be defined in a child class; this differs
    from an interface, where all methods in an interface must be implemented.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虚方法不必在子类中定义；这与接口不同，接口中的所有方法都必须被实现。
- en: '`PetDog` will not override the behavior of the base class as a dog will eat
    both `Kibble` and `Fish`. A cat is more discerning, as shown in the following
    code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`PetDog`不会覆盖基类的行为，因为狗既吃`Kibble`又吃`Fish`。而猫更挑剔，如下面的代码所示：'
- en: '[PRE8]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the override keyword, `PetCat` will change the behavior of the base class,
    resulting in a cat only eating fish.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用override关键字，`PetCat`将改变基类的行为，导致猫只吃鱼。
- en: Generics
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: A generic defines a behavior that can be applied to a class. A commonly used
    form of this is in collections, where the same approach to handling an object
    can be applied regardless of the type of object. For example, a list of strings
    or a list of integers can be handled using the same logic without having to differentiate
    between the specific types.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型定义了可以应用于类的行为。这种常用形式在集合中使用，无论对象的类型如何，都可以使用相同的处理对象的方法。例如，可以使用相同的逻辑处理字符串列表或整数列表，而无需区分特定类型。
- en: 'Going back to pets, we could define a generic class for feeding a pet. This
    class simply feeds a pet given both the pet and some food, as shown in the following
    code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 回到宠物，我们可以为喂养宠物定义一个通用类。这个类简单地给宠物和食物喂食，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There are a couple of interesting thing to point out here. First of all, the
    class does not have to be instantiated as both the class and method are marked
    as static. The generic method is described using the method signature, `FeedPet<TP,
    TF>`. The `where` keyword is used to indicate additional requirements as to what
    `TP` and `TF` must be. In this example, the `where` keyword defines `TP` as having
    to be a type of `PetAnimal`, while `TF` must implement the `IPetFood` interface.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件有趣的事情要指出。首先，由于类和方法都被标记为静态，所以类不必被实例化。使用方法签名`FeedPet<TP, TF>`描述了通用方法。`where`关键字用于指示对`TP`和`TF`的额外要求。在这个例子中，`where`关键字将`TP`定义为必须是`PetAnimal`类型，而`TF`必须实现`IPetFood`接口。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed OOP and its three main features: inheritance,
    encapsulation, and polymorphism. Using these features, the classes within an application
    can be abstracted to provide definitions that are both easy to understand and
    protected against being used in a manner that is inconsistent with its purpose.
    This is an essential difference between OOP and some earlier types of software
    development language such as structural and procedural programming. With the ability
    to abstract functionality, the ability to reuse and maintain code is increased.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了面向对象编程及其三个主要特征：继承、封装和多态性。使用这些特性，应用程序中的类可以被抽象化，以提供易于理解且受到保护的定义，以防止其被用于与其目的不一致的方式。这是面向对象编程与一些早期类型的软件开发语言（如结构化和过程化编程）之间的重要区别。通过抽象功能，增加了代码重用和维护的能力。
- en: In the next chapter, we will discuss various patterns used in enterprise software
    development. We will cover programming patterns as well as software development
    principles and patterns used in the **Software Development Life Cycle** (**SDLC**).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论企业软件开发中使用的各种模式。我们将涵盖编程模式以及软件开发原则和在**软件开发生命周期**（**SDLC**）中使用的模式。
- en: Questions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章中包含的信息：
- en: What do the terms late and early binding refer to?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 术语“晚绑定”和“早绑定”是指什么？
- en: Does C# support multiple inheritance?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C#支持多重继承吗？
- en: In C#, what level of encapsulation could be used to prevent access to a class
    from outside the library?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在C#中，可以使用什么级别的封装来防止外部库访问类？
- en: What is the difference between aggregation and composition?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 聚合和组合之间有什么区别？
- en: Can interfaces contain properties? (This is a bit of a trick question.)
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口可以包含属性吗？（这有点像是一个陷阱问题。）
- en: Do dogs eat fish?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 狗会吃鱼吗？
