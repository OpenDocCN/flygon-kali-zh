- en: Writing Clean Functions
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 编写干净的函数
- en: Clean functions are methods that are small (they have two or fewer arguments)
    and avoid duplication. The ideal method has no parameters and does not modify
    the program's state. Small methods are less prone to exceptions, so you will be
    writing much more robust code that benefits you in the long run as you will have
    fewer bugs to fix.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 干净的函数是小方法（它们有两个或更少的参数）并且避免重复。理想的方法没有参数，也不修改程序的状态。小方法不太容易出现异常，因此你将编写更加健壮的代码，从长远来看，你将有更少的错误需要修复。
- en: Functional programming is a software coding methodology that treats computations
    as the mathematical evaluation of computations. This chapter will teach you the
    benefits of treating computations as the evaluation of mathematical functions
    in order to void changing an object's state.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一种将计算视为数学计算的软件编码方法。本章将教你将计算视为数学函数的评估的好处，以避免改变对象的状态。
- en: Large methods (also known as functions) can be unwieldy to read and prone to
    errors, so writing small methods has its advantages. Hence, we will look at how
    large methods can be broken up into smaller methods. In this chapter, we will
    cover functional programming in C# and how to write small, clean methods.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大方法（也称为函数）阅读起来笨拙且容易出错，因此编写小方法有其优势。因此，我们将看看如何将大方法分解为小方法。在本章中，我们将介绍C#中的函数式编程以及如何编写小而干净的方法。
- en: Constructors and methods with multiple parameters can become a real pain to
    work with, so we will have to look for ways to work around and pass multiple parameters,
    as well as how to avoid using more than two parameters. The main reason for reducing
    the number of parameters we have is that they can become hard to read, be a source
    of irritation to fellow programmers, and cause visual stress if there are enough
    of them. They can also be a sign that the method is trying to do too much, or
    that you need to consider refactoring your code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和具有多个参数的方法可能会变得非常麻烦，因此我们需要寻找解决方法来处理和传递多个参数，以及如何避免使用超过两个参数。减少参数数量的主要原因是它们可能变得难以阅读，会让其他程序员感到烦恼，并且如果参数足够多的话会造成视觉压力。它们也可能表明该方法试图做太多的事情，或者你需要考虑重构你的代码。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding functional programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解函数式编程
- en: Keeping methods small
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持方法小
- en: Avoiding duplication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免重复
- en: Avoiding multiple parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免多个参数
- en: 'By the time you have worked through this chapter, you will have the skills
    to do the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，你将具备以下技能：
- en: Describe what functional programming is
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述函数式编程是什么
- en: Provide existing examples of functional programming in the C# programming language
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C#编程语言中提供现有的函数式编程示例
- en: Write functional C# code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写函数式的C#代码
- en: Avoid writing methods with more than two arguments
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免编写超过两个参数的方法
- en: Write immutable data objects and structures
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写不可变的数据对象和结构
- en: Keep your methods small
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持你的方法小
- en: Write code that adheres to the **Single Responsibility Principle** (**SRP**)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写符合单一职责原则（SRP）的代码
- en: Let's get started!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Understanding functional programming
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解函数式编程
- en: The only thing that sets functional programming aside from other methods of
    programming is that functions do not modify data or state. You will use functional
    programming in scenarios such as deep learning, machine learning, and artificial
    intelligence when it is necessary to perform different sets of operations on the
    same set of data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程与其他编程方法的唯一区别在于函数不修改数据或状态。在深度学习、机器学习和人工智能等场景中，当需要对相同的数据集执行不同的操作时，你将使用函数式编程。
- en: The *LINQ syntax* within .NET Framework is an example of functional programming.
    So, if you are wondering what functional programming looks like, and if you have
    used LINQ before, then you have been subjected to functional programming and should
    know what it looks like.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework中的LINQ语法是函数式编程的一个例子。因此，如果你想知道函数式编程是什么样子，如果你以前使用过LINQ，那么你已经接触过函数式编程，并且应该知道它是什么样子的。
- en: Since functional programming is a deep subject and many books, courses, and
    videos exist on this topic, we will only touch on the topic briefly in this chapter
    by looking at pure functions and immutable data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数式编程是一个深入的主题，关于这个主题存在许多书籍、课程和视频，所以我们在本章中只会简要涉及这个主题，通过查看纯函数和不可变数据。
- en: A pure function is restricted to only operating on the data that is passed into
    it. As a result, the method is predictable and avoids producing side effects.
    This benefits programmers because such methods are easier to reason about and
    test.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数只能对传入的数据进行操作。因此，该方法是可预测的，避免产生副作用。这对程序员有好处，因为这样的方法更容易推理和测试。
- en: Once an immutable data object or data structure has been initialized, the contained
    data values will not be modified. Because the data is only set and not modified,
    you can easily reason about what the data is, how it is set, and what the outcome
    of any operation will be, given the inputs. Immutable data is also easier to test
    as you know what your inputs are and what outputs are expected. This makes writing
    test cases much easier as you don't have so many things to consider, such as object
    state. The benefit of immutable objects and structures is that they are thread-safe.
    Thread-safe objects and structures make for good **data transfer objects** (**DTOs**)
    that can be passed between threads.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始化了一个不可变的数据对象或数据结构，其中包含的数据值将不会被修改。因为数据只是被设置而不是修改，你可以很容易地推断出数据是什么，它是如何设置的，以及任何操作的结果会是什么，给定了输入。不可变数据也更容易测试，因为你知道你的输入是什么，以及期望的输出是什么。这使得编写测试用例变得更容易，因为你不需要考虑那么多事情，比如对象状态。不可变对象和结构的好处在于它们是线程安全的。线程安全的对象和结构可以作为良好的数据传输对象（DTOs）在线程之间传递。
- en: But structs can still be mutable if they contain reference types. One way around
    this would be to make the reference type immutable. C# 7.2 added support for `readonly
    struct` and `ImmutableStruct`. So, even if our structures contain reference types,
    we can now use these new C# 7.2 constructs to make structures with reference types
    immutable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果结构包含引用类型，它们仍然可以是可变的。解决这个问题的一种方法是使引用类型成为不可变的。C# 7.2增加了对`readonly struct`和`ImmutableStruct`的支持。因此，即使我们的结构包含引用类型，我们现在也可以使用这些新的C#
    7.2构造来使具有引用类型的结构成为不可变的。
- en: 'Now, let''s have a look at a pure function example. The only way to set the
    properties of an object is via the constructor at construction time. The class
    is a `Player` class whose only job is to hold the name of the player and their
    high score. A method is provided that updates the player''s high score:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个纯函数的例子。对象属性的唯一设置方式是通过构造函数在构造时进行。这个类是一个`Player`类，其唯一工作是保存玩家的姓名和他们的最高分。提供了一个方法来更新玩家的最高分：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that the `UpdateHighScore` method does not update the `HighScore` property.
    Instead, it instantiates and returns a new `Player` class by passing in the `PlayerName` variable,
    which is already set in the class, and `highScore`, which is the method parameter.
    You have now seen a very simple example of how to program your software without
    changing its state.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`UpdateHighScore`方法不会更新`HighScore`属性。相反，它通过传入已在类中设置的`PlayerName`变量和方法参数`highScore`来实例化并返回一个新的`Player`类。您现在已经看到了一个非常简单的示例，说明如何在不改变其状态的情况下编写软件。
- en: Functional programming is a very large subject and requires a mind shift that
    can be very difficult for both procedural and object-oriented programmers. Since
    it is outside the scope of this book (to delve deep into the topic of functional
    programming), you are actively encouraged to peruse the functional programming
    resources on offer from PacktPub for yourself.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是一个非常庞大的主题，对于过程式和面向对象的程序员来说，它需要进行思维转变，这可能非常困难。由于这超出了本书的范围（深入探讨函数式编程的主题），我们鼓励您自行查阅PacktPub提供的函数式编程资源。
- en: Packt has some very good books and videos that specialize in teaching the top
    tiers of functional programming. You will find links to some Packt functional
    programming resources at the end of this chapter, in the *Further reading* section.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Packt有一些非常好的书籍和视频，专门教授功能编程的顶级知识。您将在本章末尾的*进一步阅读*部分找到一些Packt功能编程资源的链接。
- en: 'Before we move on, we will look at some LINQ examples since LINQ is an example
    of functional programming in C#. It will be good to have an example dataset. The
    following code builds a list of vendors and products. We''ll start by writing
    the `Product` structure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们将看一些LINQ示例，因为LINQ是C#中函数式编程的一个例子。有一个例子数据集会很有帮助。以下代码构建了一个供应商和产品列表。我们将首先编写`Product`结构：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have our struct, we will add some sample data inside the `GetProducts()`
    method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了结构体，我们将在`GetProducts()`方法中添加一些示例数据：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, we can start to use LINQ on our list. In the preceding example, we
    will get a distinct list of products, ordered by the vendor''s names, and print
    out the results:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以开始在我们的列表上使用LINQ。在前面的示例中，我们将获得一个按供应商名称排序的产品的不同列表，并打印出结果：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we obtain a list of vendors by calling `GetProducts()` and selecting only
    the `Vendor` column. Then, we filter the list so that it only includes a vendor
    once by calling the `Distinct()` method. The list of vendors is then ordered alphabetically
    by calling `OrderBy(x => x)`, where `x` is the vendor's name. Upon obtaining the
    ordered list of distinct vendors, we then loop through the list and print the
    vendor's name. Finally, we wait for the user to press any key to exit the program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过调用`GetProducts()`获取供应商列表，并仅选择`Vendor`列。然后，我们过滤列表，使其只包括一个供应商，通过调用`Distinct()`方法。然后，通过调用`OrderBy(x
    => x)`按字母顺序对供应商列表进行排序，其中`x`是供应商的名称。在获得排序后的不同供应商列表后，我们遍历列表并打印供应商的名称。最后，我们等待用户按任意键退出程序。
- en: One of the benefits of functional programming is that your methods are much
    smaller than the methods in other types of programming. Next, we will take a look
    at why it is good to keep methods small, as well as the techniques we can use,
    including functional programming.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的一个好处是，您的方法比其他类型的编程方法要小得多。接下来，我们将看一下为什么保持方法小巧是有益的，以及我们可以使用的技术，包括函数式编程。
- en: Keeping methods small
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持方法的小巧
- en: While programming clean and readable code, it is important to keep the methods
    small. Preferably, in the C# world, it is best to keep methods *under 10 lines*
    long. The perfect length is no more than *4 lines*. A good way to keep methods
    small is to consider if you should be trapping for errors or bubbling them further
    up the call stack. With defensive programming, you can become a little too defensive,
    and this can add to the amount of code you find yourself writing. Besides, methods
    that trap errors will be longer than methods that don't.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写干净和可读的代码时，保持方法小巧是很重要的。在C#世界中，最好将方法保持在*10行以下*。最佳长度不超过*4行*。保持方法小巧的一个好方法是考虑是否应该捕获错误或将其传递到调用堆栈的更高层。通过防御性编程，您可能会变得过于防御，这可能会增加您发现自己编写的代码量。此外，捕获错误的方法将比不捕获错误的方法更长。
- en: 'Let''s consider the following code, which can throw an `ArgumentNullException`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下可能会抛出`ArgumentNullException`的代码：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we can clearly see that there are two locations where
    an `ArgumentNullException` may be raised. The first line of code to potentially
    raise an `ArgumentNullException` is `nameTextBox.Text = _dataItem.Name;`; the
    second line of code that may potentially raise the same exception is `DescriptionTextBox.Text
    = _dataItem.Description;`. We can see that the exception handler catches the exception
    when it occurs, writes it to the console, and then simply throws it back up the
    stack.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们可以清楚地看到有两个位置可能会引发`ArgumentNullException`。可能引发`ArgumentNullException`的第一行代码是`nameTextBox.Text
    = _dataItem.Name;`；可能引发相同异常的第二行代码是`DescriptionTextBox.Text = _dataItem.Description;`。我们可以看到异常处理程序在发生异常时捕获异常，将其写入控制台，然后简单地将其抛回堆栈。
- en: Notice that, from a human reading perspective, there are *8 lines* of code that
    form the `try/catch` block.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从人类阅读的角度来看，有*8行*代码形成了`try/catch`块。
- en: You can completely replace the `try/catch` exception handling with a single
    line of text by writing your own argument validator. To explain this, we will
    provide an example.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过编写自己的参数验证器，用一行文本完全替换`try/catch`异常处理。为了解释这一点，我们将提供一个例子。
- en: 'Let''s start by looking at the `ArgumentValidator` class. The purpose of this
    class is to throw an `ArgumentNullException` with the name of the method that
    contains the null argument:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下`ArgumentValidator`类。这个类的目的是抛出一个带有包含空参数的方法名称的`ArgumentNullException`：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we have our null validation class, we can perform the new way of validating
    parameters for null values in our methods. So, let''s look at a simple example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的空验证类，我们可以对我们的方法中的空值参数执行新的验证方式。所以，让我们看一个简单的例子：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can clearly see, we have replaced the whole of the `try catch` block
    with a one-liner at the top of the method. When this validation detects a null
    argument, an `ArgumentNullException` is thrown, preventing the code from continuing.
    This makes the code much easier to read, and also helps with debugging.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以清楚地看到的，我们用一个一行代码替换了整个`try catch`块。当这个验证检测到空参数时，会抛出一个`ArgumentNullException`，阻止代码继续执行。这使得代码更容易阅读，也有助于调试。
- en: Now, we'll look at formatting functions with indentation so that they are easy
    to read.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看一下如何使用缩进格式化函数，使其易于阅读。
- en: Indenting code
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩进代码
- en: A very long method is hard to read and follow at the best of times, especially
    when you have to scroll through the method many times to get to the bottom of
    it. But having to do that with methods that are not properly formatted with the
    correct levels of indentation can be a real nightmare.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常长的方法在任何时候都很难阅读和跟踪，特别是当你不得不多次滚动方法才能到达底部时。但是，如果方法没有正确格式化并且缩进级别不正确，那么这将是一个真正的噩梦。
- en: 'If you ever encounter any method code that is poorly formatted, then make it
    your own responsibility, as a professional coder, to tidy the code up before you
    do anything else. Any code between braces is known as a **code block**. Code within
    a code block should be indented by one level. Code blocks within code blocks should
    also be indented by one level, as shown in the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到任何格式不良的方法代码，那么作为专业程序员，在你做任何其他事情之前，要把代码整理好是你自己的责任。大括号之间的任何代码被称为**代码块**。代码块内的代码应该缩进一级。代码块内的代码块也应该缩进一级，如下面的例子所示：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding example demonstrates bad indentation and also bad loop programming.
    Here, you can see that a list of students is being searched in order to find and
    return a student with the specified ID that was passed in as a parameter. What
    annoys some programmers and reduces the performance of the application is that
    the loop in the preceding code continues, even when the student has been found.
    We can improve the indentation and the performance of the preceding code as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子展示了糟糕的缩进和糟糕的循环编程。在这里，你可以看到正在搜索学生列表，以便找到并返回具有指定ID的学生，该ID作为参数传递。一些程序员感到恼火并降低了应用程序的性能，因为在上面的代码中，即使找到了学生，循环仍在继续。我们可以改进上面的代码的缩进和性能如下：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we have improved the formatting and made sure that the
    code is properly indented. We've added a `break` to the `for` loop so that the
    `foreach` loop is terminated when a match is found.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们改进了格式，并确保代码正确缩进。我们在`for`循环中添加了`break`，以便在找到匹配项时终止`foreach`循环。
- en: Not only is the code now more readable, but it also performs much better. Imagine
    that the code is being run against a university with 73,000 students on campus
    and via distance learning. Consider that if the student matches the ID is the
    first in the list, then without the `break` statement, the code would have to
    run 72,999 unnecessary computations. You can see how much of a difference the
    `break` statement makes to the performance of the preceding code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不仅代码更易读，而且性能也更好。想象一下，代码正在针对一个校园有73,000名学生的大学以及远程学习进行运行。考虑一下，如果学生与ID匹配是列表中的第一个，那么如果没有`break`语句，代码将不得不运行72,999次不必要的计算。你可以看到`break`语句对上面的代码性能有多大的影响。
- en: We have left the return value in its original location as the compiler can complain
    that not all code paths return a value. This is also why we added the `break`
    statement. It is clear that proper indentation improves the readability of the
    code, thus aiding the programmer's understanding of it. This enables the programmer
    to make any changes that they deem necessary.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将返回值保留在原始位置，因为编译器可能会抱怨并非所有代码路径都返回一个值。这也是我们添加`break`语句的原因。很明显，正确的缩进提高了代码的可读性，从而帮助程序员理解代码。这使程序员能够进行任何他们认为必要的更改。
- en: Avoiding duplication
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免重复
- en: Code can be either **DRY** or **WET**. WET code stands for **Write Every Time** and
    is the opposite of DRY, which stands for **Don't Repeat Yourself**. The problem
    with WET code is that it is the perfect candidate for *bugs*. Let's say your test
    team or a customer finds a bug and reports it to you. You fix the bug and pass
    it on, only for it to come back and bite you as many times as that code is encountered
    within your computer program.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以是**DRY**或**WET**。WET代码代表**每次写**，是DRY的相反，DRY代表**不要重复自己**。WET代码的问题在于它是*bug*的完美候选者。假设您的测试团队或客户发现了一个bug并向您报告。您修复了bug并传递了它，但它会在您的计算机程序中遇到该代码的次数一样多次回来咬您。
- en: Now, we DRY our WET code by removing duplication. One way we can do this is
    by extracting the code and putting it into a method and then centralizing the
    method in such a way that it is accessible to all the areas of the computer program
    that need it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过消除重复来DRY我们的WET代码。我们可以通过提取代码并将其放入方法中，然后以一种可访问所有需要它的计算机程序区域的方式将方法集中起来。
- en: Time for an example. Imagine that you have a collection of expense items that
    consist of `Name` and `Amount` properties. Now, consider having to get the decimal
    `Amount` for an expense item by `Name`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子。假设您有一个费用项目集合，其中包含`Name`和`Amount`属性。现在，考虑通过`Name`获取费用项目的十进制`Amount`。
- en: 'Say you had to do this 100 times. For this, you could write the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要这样做100次。为此，您可以编写以下代码：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There is no reason why you can''t write that same code 100 times. But there
    is a way to write it only once, thus reducing the size of your codebase and making
    you more productive. Let''s have a look at how we can do this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由您不能写相同的代码100次。但有一种方法可以只写一次，从而减少代码库的大小并提高您的生产力。让我们看看我们可以如何做到这一点：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To extract the required value from the `ExpenseLines` collection within your
    `ViewModel`, all you have to do is pass the name of the value you require into
    the `GetValueName(string name)` method, as shown in the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`ViewModel`中的`ExpenseLines`集合中提取所需的值，您只需将所需值的名称传递给`GetValueName(string name)`方法，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That one line of code is very readable, and the lines of code to get the value
    are contained in a single method. So, if the method needs to be changed for whatever
    reason (such as a bug fix), you only have to modify the code in one place.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那一行代码非常易读，获取值的代码行包含在一个方法中。因此，如果出于任何原因（例如修复bug）需要更改方法，您只需在一个地方修改代码。
- en: The next logical step to writing good functions is to have as few parameters
    as possible. In the next section, we'll look at why we should have no more than
    two parameters, as well as how to work with just parameters, even if we need plenty
    more.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编写良好的函数的下一个逻辑步骤是尽可能少地使用参数。在下一节中，我们将看看为什么我们不应该超过两个参数，以及如何处理参数，即使我们需要更多。
- en: Avoiding multiple parameters
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免多参数
- en: Niladic methods are the ideal type of methods in C#. Such methods have no parameters
    (also known as *arguments*). Monadic methods only have one parameter. Dyadic methods
    have two parameters. Triadic methods have three parameters. Methods that have
    more than three parameters are known as polyadic methods. You should aim to keep
    the number of parameters to a minimum (preferably less than three).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Niladic方法是C#中理想的方法类型。这种方法没有参数（也称为*参数*）。Monadic方法只有一个参数。Dyadic方法有两个参数。Triadic方法有三个参数。具有三个以上参数的方法称为多参数方法。您应该尽量保持参数数量最少（最好少于三个）。
- en: In the ideal world of C# programming, you should do your best to avoid triadic
    and polyadic methods. The reason for this is not because it is bad programming,
    but because it makes your code easier to read and understand. Methods with lots
    of parameters can cause visual stress to programmers, and can also be a source
    of irritation. IntelliSense can also be difficult to read and understand as you
    add more parameters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#编程的理想世界中，您应尽力避免三参数和多参数方法。这不是因为它是糟糕的编程，而是因为它使您的代码更易于阅读和理解。具有大量参数的方法可能会给程序员带来视觉压力，并且也可能成为烦恼的根源。随着添加更多参数，IntelliSense也可能变得难以阅读和理解。
- en: 'Let''s look at a bad example of a polyadic method that updates a user''s account
    information:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更新用户帐户信息的多参数方法的不良示例：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As shown by the `UpdateUserInfo` method, the code is horrible to read. How
    can we modify the method so that it transforms from a polyadic method into a monadic
    method? The answer is simple – we pass in a `UserInfo` object. First of all, before
    we modify the method, let''s take a look at our `UserInfo` class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如`UpdateUserInfo`方法所示，代码难以阅读。我们如何修改该方法，使其从多参数方法转变为单参数方法？答案很简单 - 我们传入一个`UserInfo`对象。首先，在修改方法之前，让我们看一下我们的`UserInfo`类：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We now have a class that contains all the information we need to pass into
    the `UpdateUserInfo` method. The `UpdateUserInfo` method can now be transformed
    from a polyadic method into a monadic method, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个包含所有需要传递给`UpdateUserInfo`方法的信息的类。`UpdateUserInfo`方法现在可以从多参数方法转变为单参数方法，如下所示：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How much better does the preceding code look? It is smaller and much more readable.
    The rule of thumb should be to have less than three parameters, and ideally none.
    If your class is obeying the SRP, then consider implementing the *parameter object
    pattern*, as we have done here.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码看起来好多了吗？它更小，更易读。经验法则应该是少于三个参数，理想情况下是零。如果您的类遵守SRP，则考虑实现*参数对象模式*，就像我们在这里所做的那样。
- en: Implementing SRP
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施SRP
- en: All objects and methods that you write should, at most, have one responsibility
    and no more. Objects can have multiple methods, but those methods, when combined,
    should all work toward the single purpose of the object they belong to. Methods
    can call multiple methods, where each does different things. But the method itself
    should only do one thing.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您编写的所有对象和方法应该最多只有一个职责，而不再有其他。对象可以有多个方法，但这些方法在组合时应该都朝着它们所属的对象的单一目的工作。方法可以调用多个方法，每个方法都做不同的事情。但方法本身应该只做一件事。
- en: 'A method that knows and does far too much is known as a **God method**. And
    likewise, an object that knows and does too much is known as a **God object**.
    God objects and methods are hard to read, maintain, and debug. Such objects and
    methods can often have the same bug repeated many times. People who are good at
    the programming craft will avoid God objects and God methods. Let''s look at a
    method that is doing more than one thing:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一个了解和做得太多的方法被称为**上帝方法**。同样，一个了解和做得太多的对象被称为**上帝对象**。上帝对象和方法很难阅读、维护和调试。这样的对象和方法通常会多次重复相同的错误。擅长编程技艺的人会避免上帝对象和上帝方法。让我们看一个做了不止一件事的方法：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`SrpBrokenMethod` is clearly doing more than one thing, so it breaks the SRP.
    We will now break this method down into a number of smaller methods that only
    do one thing. We will also address the issue of the polyadic nature of the method
    in that it has more than two parameters.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`SrpBrokenMethod`显然做了不止一件事，因此它违反了SRP。我们现在将这个方法分解为多个只做一件事的较小方法。我们还将解决该方法的多参数性质的问题。'
- en: 'Before we begin to break down the method into smaller methods that do only
    one thing, we need to look at all the actions that the method is performing. The
    method starts by writing text to a file. It then creates an email message, assigns
    an attachment, and finally sends the email. So, for this, we need methods for
    the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始将方法分解为只做一件事的较小方法之前，我们需要查看方法执行的所有操作。该方法首先将文本写入文件。然后创建电子邮件消息，分配附件，最后发送电子邮件。因此，我们需要以下方法：
- en: Write text to file
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文本写入文件
- en: Create an email message
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建电子邮件消息
- en: Add an email attachment
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加电子邮件附件
- en: Send email
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: 'Looking at the current method, we have four parameters that are passed into
    it for writing text to a file: one for the folder, one for the filename, one for
    the text, and one for the media type. The folder and filename can be combined
    into a single parameter called `filename`. If `filename` and `folder` are two
    separate variables that are used inside the calling code, then they can be passed
    into the method as a single interpolated string, such as `$"{folder}{filename}"`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 查看当前方法，我们有四个参数传递给它来写入文本到文件：一个用于文件夹，一个用于文件名，一个用于文本，一个用于媒体类型。文件夹和文件名可以合并为一个名为`filename`的单个参数。如果`filename`和`folder`是在调用代码中分开使用的两个变量，则可以将它们作为单个插值字符串传递到方法中，例如`$"{folder}{filename}"`。
- en: 'As for the media type, this could be privately set inside a struct during construction
    time. We could use that struct to set the properties we need so that we can pass
    the struct in with the three properties as a single parameter. Let''s look at
    the code that accomplishes this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 至于媒体类型，这可以在构造时私下设置在一个结构体内。我们可以使用该结构体来设置我们需要的属性，以便我们可以将该结构体作为单个参数传递进去。让我们看一下实现这一点的代码：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `TextFileData` constructor ensures that the `FileName` value is unique
    by calling the `GetFileTimestamp()` method and appending it to the end of `FileName`.
    To save the text file, we call the `SaveTextFile()` method. Notice that `MimeType`
    is set internally and is set to `MimeType.TextPlain`. We could have simply hardcoded
    `MimeType` as `MimeType = "text/plain";`, but the advantage of using an `enum`
    is that the code is reusable, with the added benefit of you not having to remember
    the text for a specific `MimeType` or look it up on the internet. Now, we''ll
    code `enum` and add a description to the `enum` value:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextFileData`构造函数通过调用`GetFileTimestamp()`方法并将其附加到`FileName`的末尾来确保`FileName`的值是唯一的。要保存文本文件，我们调用`SaveTextFile()`方法。请注意，`MimeType`在内部设置为`MimeType.TextPlain`。我们本可以简单地将`MimeType`硬编码为`MimeType
    = "text/plain";`，但使用`enum`的优势在于代码是可重用的，而且您不必记住特定`MimeType`的文本或在互联网上查找它的好处。现在，我们将编写`enum`并为`enum`值添加描述：'
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Well, we''ve got our `enum`, but now we need a way to extract the description
    so that it can be easily assigned to a variable. Therefore, we will create an
    extension class that will enable us to get the description of an `enum`. This
    enables us to set `MimeType`, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们有了我们的`enum`，但现在我们需要一种方法来提取描述，以便可以轻松地分配给一个变量。因此，我们将创建一个扩展类，它将使我们能够获取`enum`的描述。这使我们能够设置`MimeType`，如下所示：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Without the extension method, the value of `MimeType` would be `0`. But with
    the extension method, the value of `MimeType` is `"text/plain"`. You can now reuse
    this extension in other projects and build it up as you require.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 没有扩展方法，`MimeType`的值将为`0`。但是通过扩展方法，`MimeType`的值为`"text/plain"`。现在您可以在其他项目中重用这个扩展，并根据需要构建它。
- en: 'The next class we will write is the `Smtp` class, whose responsibility is to
    send an email via the `Smtp` protocol:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写的下一个类是`Smtp`类，其职责是通过`Smtp`协议发送电子邮件：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Smtp` class has a constructor that takes a single parameter of the `Credential` type.
    This credential is used to log into the email server. The server is configured
    in the constructor. When the `SendMessage(MailMessage mailMessage)` method is
    called, the message is sent.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Smtp`类有一个构造函数，它接受一个`Credential`类型的参数。这个凭据用于登录到电子邮件服务器。服务器在构造函数中配置。当调用`SendMessage(MailMessage
    mailMessage)`方法时，消息被发送。'
- en: 'Let''s write a `DemoWorker` class that splits the work into different methods:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个`DemoWorker`类，将工作分成不同的方法：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `DemoWorker`  class shows a much cleaner version of sending an email message.
    The main method responsible for saving an attachment and sending it as an attachment
    via email is called `DoWork()`. This method only contains two lines of code. The
    first line calls the `SaveTextFile()` method, while the second line calls the
    `SendEmail()` method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`DemoWorker`类展示了发送电子邮件消息的更清晰版本。负责保存附件并通过电子邮件作为附件发送的主要方法称为`DoWork()`。这个方法只包含两行代码。第一行调用`SaveTextFile()`方法，而第二行调用`SendEmail()`方法。'
- en: The `SaveTextFile()` method creates a new `TextFileData` struct and passes in
    the filename and some text. It then calls the `SaveTextFile()` method in the `TextFileData`
    struct, which is responsible for saving the text to the file specified.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`SaveTextFile()`方法创建一个新的`TextFileData`结构，并传入文件名和一些文本。然后调用`TextFileData`结构中的`SaveTextFile()`方法，负责将文本保存到指定的文件中。'
- en: The `SendEmail()` method creates a new `Smtp` class. The `Smtp` class has a
    `Credential` parameter, while the `Credential` class has two string parameters
    for email address and password. The email and password are used to log into the
    SMTP server. Once the SMTP server has been created, the `SendMessage(MailMessage
    mailMessage)` method is called.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendEmail()`方法创建一个新的`Smtp`类。`Smtp`类有一个`Credential`参数，而`Credential`类有两个字符串参数用于电子邮件地址和密码。电子邮件和密码用于登录SMTP服务器。一旦SMTP服务器被创建，就会调用`SendMessage(MailMessage
    mailMessage)`方法。'
- en: This method requires a `MailMessage` object to be passed in. So, we have a method
    called `GetMailMethod()` that builds a `MailMessage` object that is then passed
    into the `SendMessage(MailMessage mailMessage)` method. `GetMailMethod()` adds
    an attachment to `MailMessage` by calling the `GetAttachment()` method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法需要传入一个`MailMessage`对象。因此，我们有一个名为`GetMailMethod()`的方法，它构建一个`MailMessage`对象，然后将其传递给`SendMessage(MailMessage
    mailMessage)`方法。`GetMailMethod()`通过调用`GetAttachment()`方法向`MailMessage`添加附件。
- en: 'As you can see from these modifications, our code is now more compact and readable.
    That is the key to good quality code that is easy to modify and maintain: it must
    be easy to read and understand. That is why it is important for your methods to
    be small and clean with as few parameters as possible.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些修改中可以看出，我们的代码现在更加简洁和易读。这是良好质量的代码的关键，它必须易于阅读和理解。这就是为什么你的方法应该尽可能小而干净，参数尽可能少的原因。
- en: Does your method break the SRP? If it does, you should consider breaking the
    method up into as many methods as there are responsibilities. And that concludes
    this chapter on writing clean functions. It is now time to summarize what you
    have learned and test your knowledge.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你的方法是否违反了SRP？如果是，你应该考虑将方法分解为尽可能多的方法来承担责任。这就结束了关于编写清晰函数的章节。现在是时候总结你所学到的知识并测试你的知识了。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have seen how functional programming can improve the safety
    of your code by not modifying the state, which can give rise to bugs, especially
    in multithreaded applications. By keeping methods small with meaningful names
    and no more than two parameters, you have seen how much cleaner your code is and
    easier to read. You have also seen how we can remove duplication in our code and
    the benefits of doing so. Code that is easy to read is easier to maintain and
    extend than code that is hard to read and decipher!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到函数式编程如何通过不修改状态来提高代码的安全性，这可能会导致错误，特别是在多线程应用程序中。通过保持方法小而有意义的名称，以及不超过两个参数，您已经看到您的代码有多么清晰和易于阅读。您还看到了我们如何消除代码中的重复部分以及这样做的好处。易于阅读的代码比难以阅读和解释的代码更容易维护和扩展！
- en: We will now move on and look at the topic of exception handling. In the next
    chapter, you will learn how to use exception handling appropriately, write your
    own custom C# exceptions that provide meaningful information, and write code that
    avoids raising `NullPointerExceptions`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续并看一下异常处理的主题。在下一章中，您将学习如何适当地使用异常处理，编写自己的自定义C#异常以提供有意义的信息，并编写避免引发`NullPointerExceptions`的代码。
- en: Questions
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What do you call a method that has no parameters?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何称呼一个没有参数的方法？
- en: What do you call a method that has one parameter?
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何称呼一个有一个参数的方法？
- en: What do you call a method that has two parameters?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何称呼一个有两个参数的方法？
- en: What do you call a method that has three parameters?
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何称呼一个有三个参数的方法？
- en: What do you call a method that has more than three parameters?
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何称呼一个有超过三个参数的方法？
- en: What two method types should be avoided and why?
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该避免哪两种方法类型，为什么？
- en: In layman's terms, what is functional programming?
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用通俗的语言来说，什么是函数式编程？
- en: What are some advantages of functional programming?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程有哪些优点？
- en: Name one disadvantage of functional programming.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数式编程的一个缺点是什么？
- en: What is WET code, and why should it be avoided?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是WET代码，为什么应该避免？
- en: What is DRY code, and why should you use it?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是DRY代码，为什么应该使用它？
- en: How do you DRY out WET code?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何去除WET代码中的重复部分？
- en: Why should methods be as small as possible?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么方法应该尽可能小？
- en: How do you implement validation without having to implement `try/catch` blocks?
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在不实现`try/catch`块的情况下实现验证？
- en: Further reading
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some additional resources so that you can delve deeper into the realms
    of C# functional programming:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些额外资源，让您可以深入了解C#函数式编程的领域：
- en: '*Functional C#* by Wisnu Anggoro: [https://www.packtpub.com/application-development/functional-c](https://www.packtpub.com/application-development/functional-c).
    This book is devoted to C# functional programming and is a good place to start
    if you want to know more.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Functional C#* by Wisnu Anggoro: [https://www.packtpub.com/application-development/functional-c](https://www.packtpub.com/application-development/functional-c)。这本书致力于C#函数式编程，如果您想了解更多，这是一个很好的起点。'
- en: '*Functional Programming in C#* by Jovan Poppavic (MSFT): [https://www.codeproject.com/Articles/375166/Functional-programming-in-Csharp](https://www.codeproject.com/Articles/375166/Functional-programming-in-Csharp).
    This is an in-depth article on functional C# programming. It contains diagrams
    and has a 5-star rating.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《C#中的函数式编程》由Jovan Poppavic（微软）编写：[https://www.codeproject.com/Articles/375166/Functional-programming-in-Csharp](https://www.codeproject.com/Articles/375166/Functional-programming-in-Csharp)。这是一篇关于函数式C#编程的深度文章。它包含了图表，并且有5星的评分。
