- en: Chapter 16. Adapters and Recyclers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。适配器和回收器
- en: We will achieve much in this brief chapter. We will first go through the theory
    of adapters and lists. We will then look at how we can use a `RecyclerAdapter`
    instance in Kotlin code and add a `RecyclerView` widget to the layout, which acts
    as a list for our UI, and then, through the apparent magic of the Android API,
    bind them together so that the `RecyclerView` instance displays the contents of
    the `RecyclerAdapter` instance and allows the user to scroll through the contents
    of an `ArrayList` instance full of `Note` instances. You have probably guessed
    that we will be using this technique to display our list of notes in the Note
    to self app.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将取得很大的进展。我们将首先学习适配器和列表的理论。然后，我们将看看如何在Kotlin代码中使用`RecyclerAdapter`实例，并将`RecyclerView`小部件添加到布局中，它作为我们UI的列表，然后通过Android
    API的明显魔法将它们绑定在一起，以便`RecyclerView`实例显示`RecyclerAdapter`实例的内容，并允许用户滚动查看一个充满`Note`实例的`ArrayList`实例的内容。你可能已经猜到，我们将使用这种技术在Note
    to self应用程序中显示我们的笔记列表。
- en: 'In this chapter, we will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将做以下事情：
- en: Explore another type of Kotlin class – the **inner class**
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索另一种Kotlin类 - **内部类**
- en: Look at the theory of adapters and examine binding them to our UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看适配器的理论并检查将它们绑定到我们的UI上
- en: Implement the layout with `RecyclerView`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RecyclerView`实现布局
- en: Lay out a list item for use in `RecyclerView`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在`RecyclerView`中使用的列表项布局
- en: Implement the adapter with `RecyclerAdapter`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`RecyclerAdapter`实现适配器
- en: Bind the adapter to `RecyclerView`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将适配器绑定到`RecyclerView`
- en: Store notes in `ArrayList` and display them in `RecyclerView` via `RecycleAdapter`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`ArrayList`中存储笔记，并通过`RecycleAdapter`在`RecyclerView`中显示它们
- en: Soon, we will have a self-managing layout that holds and displays all our notes,
    so let's get started.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，我们将拥有一个自管理的布局，用来保存和显示所有的笔记，所以让我们开始吧。
- en: Inner classes
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部类
- en: 'In this project, we will use a type of class we have not seen yet – an **inner**
    class. Suppose that we have a regular class called `SomeRegularClass`, with a
    property called `someRegularProperty`, and a function called `someRegularFunction`,
    as shown in this next code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用一种我们以前没有见过的类 - **内部**类。假设我们有一个名为`SomeRegularClass`的常规类，其中有一个名为`someRegularProperty`的属性和一个名为`someRegularFunction`的函数，就像下面的代码中所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An inner class is a class that is declared inside of a regular class, like
    in this next highlighted code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 内部类是在常规类内部声明的类，就像下面的高亮代码中所示：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding highlighted code shows an inner class called `MyInnerClass`, with
    a property called `myInnerProperty`, and a function called `myInnerFunction`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上面高亮显示的代码显示了一个名为`MyInnerClass`的内部类，其中有一个名为`myInnerProperty`的属性和一个名为`myInnerFunction`的函数。
- en: 'One advantage is that the outer class can use the properties and functions
    of the inner class by declaring an instance of it, as shown highlighted in the
    next code snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优点是外部类可以通过声明它的实例来使用内部类的属性和函数，就像下面的代码片段中所示：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Furthermore, the inner class can also access the properties of the regular
    class, perhaps from the `myInnerFunction` function. This next code snippet shows
    this in action:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，内部类还可以从`myInnerFunction`函数中访问常规类的属性。下面的代码片段展示了这一点：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This ability to define a new type within a class and create instances and share
    data is very useful in certain circumstances and for encapsulation. We will use
    an inner class in the Note to self app later in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中定义新类型并创建实例并共享数据的能力在某些情况下非常有用，并且用于封装。我们将在本章后面的Note to self应用程序中使用内部类。
- en: RecyclerView and RecyclerAdapter
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RecyclerView和RecyclerAdapter
- en: In [Chapter 5](ch05.html "Chapter 5. Beautiful Layouts with CardView and ScrollView"),
    *Beautiful Layouts with CardView and ScrollView*, we used a `ScrollView` widget
    and we populated it with a few `CardView` widgets so that we could see it scrolling.
    We could take what we have just learned about `ArrayList` and create a container
    of `TextView` objects, use them to populate a `ScrollView` widget, and, within
    each `TextView`, place the title of a note. This sounds like a perfect solution
    for showing each note so that it is clickable in the Note to self app.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。使用CardView和ScrollView创建美丽的布局")中，我们使用了`ScrollView`小部件，并用一些`CardView`小部件填充它，以便我们可以看到它滚动。我们可以利用我们刚刚学到的关于`ArrayList`的知识，创建一个`TextView`对象的容器，用它们来填充`ScrollView`小部件，并在每个`TextView`中放置一个笔记的标题。这听起来像是在Note
    to self应用程序中显示每个笔记并使其可点击的完美解决方案。
- en: We could create the `TextView` objects dynamically in Kotlin code, set their
    `text` property to be the title of a note, and then add the `TextView` objects
    to a `LinearLayout` contained in `ScrollView`. But this is imperfect.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Kotlin代码中动态创建`TextView`对象，将它们的`text`属性设置为笔记的标题，然后将`TextView`对象添加到`ScrollView`中包含的`LinearLayout`中。但这并不完美。
- en: The problem with displaying lots of widgets
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示大量小部件的问题
- en: This might seem fine, but what if there were dozens, hundreds, or even thousands
    of notes? We couldn't have thousands of `TextView` objects in memory because the
    Android device might simply run out of memory, or, at the very least, grind to
    a halt as it tries to handle the scrolling of such a vast amount of data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不错，但是如果有几十个、几百个，甚至上千个笔记怎么办？我们不能在内存中有成千上万个`TextView`对象，因为Android设备可能会因为尝试处理如此大量的数据而耗尽内存，或者至少会变得非常缓慢。
- en: Now, also imagine that we wanted (which we do) each note in the `ScrollView`
    widget to show whether it was important, a to-do, or an idea. And how about a
    short snippet from the text of the note as well?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下我们希望（我们确实希望）`ScrollView`小部件中的每个笔记都显示它是重要的、待办事项还是想法。还有关于笔记文本的简短片段呢？
- en: We would need to devise some clever code that loads and destroys `Note` objects
    and `TextView` objects from `ArrayList`. It can be done – but to do it efficiently
    is far from straightforward.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设计一些巧妙的代码，从`ArrayList`中加载和销毁`Note`对象和`TextView`对象。这是可以做到的 - 但要高效地做到这一点远非易事。
- en: The solution to the problem with displaying lots of widgets
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决显示大量小部件的问题
- en: Fortunately, this is a problem faced so commonly by mobile developers that the
    Android API has a solution built in.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这是移动开发人员如此常见的问题，以至于Android API中已经内置了解决方案。
- en: We can add a single widget, called `RecyclerView` (like an environmentally friendly
    `ScrollView`, but with boosters too), to our UI layout. The `RecyclerView` class
    was designed as a solution to the problem we have been discussing. In addition,
    we need to interact with `RecyclerView` with a special type of class that understands
    how `RecyclerView` works. We will interact with it using an **adapter**. We will
    use the `RecyclerAdapter` class, inherit from it, customize it, and then use it
    to control the data from our `ArrayList` and display it in the `RecyclerView`
    class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在UI布局中添加一个名为`RecyclerView`的小部件（就像一个环保的`ScrollView`，但也有增强功能）。`RecyclerView`类是为我们讨论的问题设计的解决方案。此外，我们需要使用一种特殊类型的类与`RecyclerView`进行交互，这个类了解`RecyclerView`的工作原理。我们将使用一个**适配器**与它进行交互。我们将使用`RecyclerAdapter`类，继承它，定制它，然后使用它来控制我们的`ArrayList`中的数据，并在`RecyclerView`类中显示它。
- en: Let's find out a bit more about how the `RecyclerView` and `RecyclerAdapter`
    classes work.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更多地了解一下`RecyclerView`和`RecyclerAdapter`类的工作原理。
- en: How to use RecyclerView and RecyclerAdapter
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用RecyclerView和RecyclerAdapter
- en: We already know how to store almost unlimited notes – we can do so in `ArrayList`,
    although we haven't implemented it yet. We also know that there is a UI layout
    called `RecyclerView` that is specifically designed to display potentially long
    lists of data. We just need to see how to put it all into action.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何存储几乎无限的笔记 - 我们可以在`ArrayList`中这样做，尽管我们还没有实现它。我们还知道有一个名为`RecyclerView`的UI布局，专门设计用于显示潜在的长列表数据。我们只需要看看如何将它付诸实践。
- en: To add a `RecyclerView` widget to our layout, we can simply drag and drop it
    from the palette onto our UI in the usual way.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们的布局中添加一个`RecyclerView`小部件，我们只需从调色板中像往常一样拖放它。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't do it yet. Let's just discuss it for a while first.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不要这样做。让我们先讨论一会儿。
- en: 'The `RecyclerView` class will look like this in the UI designer:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecyclerView`类在UI设计中将如下所示：'
- en: '![How to use RecyclerView and RecyclerAdapter](img/B12806_16_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![如何使用RecyclerView和RecyclerAdapter](img/B12806_16_01.jpg)'
- en: This appearance, however, is more a representation of the possibilities than
    the actual appearance in an app. If we run the app at once after adding a `RecyclerView`
    widget, we will just get a blank screen.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种外观更多地代表了可能性，而不是在应用程序中的实际外观。如果我们在添加了`RecyclerView`小部件后立即运行应用程序，我们将只会得到一个空白屏幕。
- en: The first thing we need to do to make practical use of a `RecyclerView` widget
    is decide what each item in the list will look like. It could be just a single
    `TextView` widget, or it could be an entire layout. We will use `LinearLayout`.
    To be clear and specific, we will use a `LinearLayout` instance that holds three
    `TextView` widgets for each item in our `RecyclerView` widget. This will allow
    us to display the note status (important/idea/to-do), the note title, and a short
    snippet of text from the actual note contents.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际使用`RecyclerView`小部件，我们需要做的第一件事是决定列表中的每个项目将是什么样子。它可以只是一个单独的`TextView`小部件，也可以是整个布局。我们将使用`LinearLayout`。为了清晰和具体，我们将使用一个`LinearLayout`实例，它为我们的`RecyclerView`小部件中的每个项目包含三个`TextView`小部件。这将允许我们显示笔记状态（重要/想法/待办事项）、笔记标题以及实际笔记内容中的一小段文本。
- en: A list item needs to be defined in its own XML file, then the `RecyclerView`
    widget can hold multiple instances of this list item layout.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 列表项需要在自己的XML文件中定义，然后`RecyclerView`小部件可以容纳多个此列表项布局的实例。
- en: Of course, none of this explains how we overcome the complexity of managing
    what data is shown in which list item and how it is retrieved from `ArrayList`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这一切都没有解释我们如何克服管理显示在哪个列表项中的数据的复杂性，以及如何从`ArrayList`中检索数据。
- en: This data handling is taken care of by our own customized implementation of
    `RecyclerAdapter`. The `RecyclerAdapter` class implements the `Adapter` interface.
    We don't need to know how `Adapter` works internally, we just need to override
    some functions, and then `RecyclerAdapter` will do all the work of communicating
    with our `RecyclerView` widget.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据处理是由我们自己定制的`RecyclerAdapter`来处理的。`RecyclerAdapter`类实现了`Adapter`接口。我们不需要知道`Adapter`内部是如何工作的，我们只需要重写一些函数，然后`RecyclerAdapter`将负责与我们的`RecyclerView`小部件进行通信的所有工作。
- en: Wiring up an implementation of `RecyclerAdapter` to a `RecyclerView` widget
    is certainly more complicated than dragging 20 `TextView` widgets onto a `ScrollView`
    widget, but once it is done we can forget about it, and it will keep on working
    and manage itself regardless of how many notes we add to `ArrayList`. It also
    has built-in features for handling things such as neat formatting and detecting
    which item in a list was clicked.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将`RecyclerAdapter`的实现与`RecyclerView`小部件连接起来的过程，肯定比将20个`TextView`小部件拖放到`ScrollView`小部件上要复杂得多，但一旦完成，我们就可以忘记它，它将继续工作并自行管理，无论我们向`ArrayList`中添加了多少笔记。它还具有处理整洁格式和检测列表中哪个项目被点击的内置功能。
- en: We will need to override some functions of `RecyclerAdapter` and add a little
    code of our own.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重写`RecyclerAdapter`的一些函数，并添加一些我们自己的代码。
- en: What we will do to set up RecyclerView with RecyclerAdapter and an ArrayList
    of notes
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们将如何使用RecyclerView与RecyclerAdapter和笔记的ArrayList
- en: 'Look at this outline of the required steps so we know what to expect. To get
    the whole thing up and running, we would do the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下所需步骤的大纲，这样我们就知道可以期待什么。为了让整个事情运转起来，我们需要做以下事情：
- en: Delete the temporary button and related code and then add a `RecyclerView` widget
    to our layout with a specific `id` property.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除临时按钮和相关代码，然后向我们的布局中添加一个具有特定`id`属性的`RecyclerView`小部件。
- en: Create an XML layout to represent each item in the list. We have already mentioned
    that each item in the list will be a `LinearLayout` that contains three `TextView`
    widgets.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个XML布局来表示列表中的每个项目。我们已经提到列表中的每个项目将是一个包含三个`TextView`小部件的`LinearLayout`。
- en: Create a new class that inherits from `RecyclerAdapter`, and add code to several
    overridden functions to control how it looks and behaves, including using our
    list item layout and `ArrayList` full of `Note` instances.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类，该类继承自`RecyclerAdapter`，并添加代码到几个重写的函数中，以控制它的外观和行为，包括使用我们的列表项布局和装满`Note`实例的`ArrayList`。
- en: Add code in `MainActivity` to use `RecyclerAdapter` and the `RecyclerView` widget
    and bind it to our `ArrayList` instance.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`中添加代码，以使用`RecyclerAdapter`和`RecyclerView`小部件，并将其绑定到我们的`ArrayList`实例。
- en: Add an `ArrayList` instance to `MainActivity` to hold all our notes, and update
    the `createNewNote` function to add any new notes created in the `DialogNewNote`
    class to this `ArrayList.`
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity`中添加一个`ArrayList`实例，用于保存所有我们的笔记，并更新`createNewNote`函数，以将在`DialogNewNote`类中创建的任何新笔记添加到这个`ArrayList`中。
- en: Let's go through and implement each of those steps in detail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步实现这些步骤。
- en: Adding RecyclerView, RecyclerAdapter, and ArrayList to the Note to Self project
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向“Note to Self”项目添加RecyclerView、RecyclerAdapter和ArrayList
- en: Open the Note to self project. As a reminder, if you want to see the completed
    code and working app based on completing this chapter, it can be found in the
    `Chapter16/Note to self` folder.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 打开“Note to self”项目。作为提醒，如果您想要查看基于完成本章的完整代码和工作中的应用程序，可以在`Chapter16/Note to self`文件夹中找到。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As the required action in this chapter jumps around between different files,
    classes, and functions, I encourage you to follow along with the files from the
    download bundle open in your preferred text editor for reference.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章中所需的操作在不同的文件、类和函数之间跳转，我鼓励您在首选的文本编辑器中打开下载包中的文件，以供参考。
- en: Removing the temporary "Show Note" button and adding RecyclerView
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除临时的“显示笔记”按钮并添加RecyclerView
- en: 'These next few steps will get rid of the temporary code we added in [Chapter
    14](ch14.html "Chapter 14. Android Dialog Windows"), *Android Dialog Windows*,
    and set up our `RecyclerView` ready for binding to `RecyclerAdapter` later in
    the chapter:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个步骤将消除我们在[第14章](ch14.html "第14章。Android对话框窗口")中添加的临时代码，*Android对话框窗口*，并设置我们的`RecyclerView`准备好在本章后期绑定到`RecyclerAdapter`：
- en: In the `content_main.xml` file, remove the temporary `Button` with an `id` of
    `button`, which we added previously for testing purposes.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`content_main.xml`文件中，删除临时的`Button`，该按钮具有`id`为`button`，我们之前为测试目的添加的。
- en: 'In the `onCreate` function of `MainActivity.kt`, delete the `Button` instance
    declaration and initialization along with the lambda that handles its clicks,
    as this code now creates an error. We will delete some more temporary code later
    in this chapter. Delete the code shown next:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity.kt`的`onCreate`函数中，删除`Button`实例的声明和初始化，以及处理其点击的lambda，因为这段代码现在会产生错误。稍后在本章中，我们将删除更多临时代码。删除下面显示的代码：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, switch back to `content_main.xml` in design view and drag a **RecyclerView**
    widget from the **Common** category of the palette onto the layout.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，切换回设计视图中的`content_main.xml`，并从调色板的**常用**类别中将一个**RecyclerView**小部件拖放到布局中。
- en: Set its `id` property to `recyclerView`.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其`id`属性设置为`recyclerView`。
- en: Now we have removed the temporary UI aspects from our project, and we have a
    `RecyclerView` widget complete with a unique `id` attribute ready to be referenced
    from our Kotlin code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经从项目中删除了临时的UI方面，并且我们有一个完整的`RecyclerView`小部件，具有一个独特的`id`属性，可以在我们的Kotlin代码中引用。
- en: Creating a list item for RecyclerView
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为RecyclerView创建列表项
- en: Next, we need a layout to represent each item in our `RecyclerView` widget.
    As previously mentioned, we will use a `LinearLayout` instance that holds three
    `TextView` widgets.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个布局来表示`RecyclerView`小部件中的每个项目。如前所述，我们将使用一个包含三个`TextView`小部件的`LinearLayout`实例。
- en: 'These are the steps needed to create a list item for use within `RecyclerView`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是创建用于`RecyclerView`中使用的列表项所需的步骤：
- en: Right-click on the `layout` folder in the project explorer and select **New
    | Layout resource file**. Enter `listitem` in the **Name:** field and make the
    **Root element:** `LinearLayout`. The default orientation attribute is vertical,
    which is just what we need.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器中右键单击`layout`文件夹，然后选择**新建 | 布局资源文件**。在**名称：**字段中输入`listitem`，并将**根元素：**设置为`LinearLayout`。默认的方向属性是垂直的，这正是我们需要的。
- en: Look at the next screenshot to see what we are trying to achieve with the remaining
    steps of this section. I have annotated it to show what each part will be in the
    finished app:![Creating a list item for RecyclerView](img/B12806_16_02.jpg)
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看下一个屏幕截图，以了解我们在本节剩余步骤中要实现的目标。我已经对其进行了注释，以显示成品应用程序中的每个部分将是什么样子：![为RecyclerView创建列表项](img/B12806_16_02.jpg)
- en: Drag three `TextView` instances onto the layout, one above the other, as per
    the reference screenshot. The first (top) will hold the note status/type (idea/important/to-do),
    the second (middle) will hold the note title, and the third (bottom) will hold
    a snippet of the note itself.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个`TextView`实例拖放到布局中，一个在另一个上方，如参考屏幕截图所示。第一个（顶部）将保存笔记状态/类型（想法/重要/待办事项），第二个（中间）将保存笔记标题，第三个（底部）将保存笔记本身的片段。
- en: 'Configure the various attributes of the `LinearLayout` instance and the `TextView`
    widgets as shown in the following table:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下表格中显示的内容，配置`LinearLayout`实例和`TextView`小部件的各种属性：
- en: '| **Widget type** | **Property** | **Value to set to** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **小部件类型** | **属性** | **要设置的值** |'
- en: '| --- | --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| LinearLayout | `layout_height` | `wrap_contents` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| LinearLayout | `layout_height` | `wrap_contents` |'
- en: '| LinearLayout | `Layout_Margin all` | `5dp` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| LinearLayout | `Layout_Margin all` | `5dp` |'
- en: '| TextView (top) | `id` | `textViewStatus` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| TextView（顶部） | `id` | `textViewStatus` |'
- en: '| TextView (top) | `textSize` | `24sp` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| TextView（顶部） | `textSize` | `24sp` |'
- en: '| TextView (top) | `textColor` | `@color/colorAccent` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| TextView（顶部） | `textColor` | `@color/colorAccent` |'
- en: '| TextView (middle) | `id` | `textViewTitle` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| TextView（中间） | `id` | `textViewTitle` |'
- en: '| TextView (middle) | `textSize` | `24sp` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| TextView（中间） | `textSize` | `24sp` |'
- en: '| TextView (top) | `id` | `textViewDescription` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| TextView（顶部） | `id` | `textViewDescription` |'
- en: Now we have a `RecylerView` widget for the main layout and a layout to use for
    each item in the list. We can go ahead and code our `RecyclerAdapter` implementation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在主布局中有一个`RecylerView`小部件和一个用于列表中每个项目的布局。我们可以继续编写我们的`RecyclerAdapter`实现。
- en: Coding the RecyclerAdapter class
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写RecyclerAdapter类
- en: We will now create and code a brand-new class. Let's call our new class `NoteAdapter`.
    Create a new class called `NoteAdapter` in the same folder as the `MainActivity`
    class (and all the other classes) in the usual way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建并编写一个全新的类。让我们称我们的新类为`NoteAdapter`。以通常的方式在与`MainActivity`类（以及所有其他类）相同的文件夹中创建一个名为`NoteAdapter`的新类。
- en: 'Edit the code for the `NoteAdapter` class by adding these `import` statements
    and inheriting from the `RecyclerView.Adapter` class, then add the two properties
    as shown. Edit the `NoteAdapter` class to be the same as the following code that
    we have just discussed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加这些`import`语句并继承`RecyclerView.Adapter`类来编辑`NoteAdapter`类的代码，然后添加如下所示的两个属性。编辑`NoteAdapter`类，使其与我们刚刚讨论过的代码相同：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the previous code, we declare and initialize two properties of the `NoteAdapter`
    class using the primary constructor. Notice the parameters of the constructor.
    It receives a `MainActivity` reference as well as a `List` reference. This implies
    that, when we use this class, we will need to send in a reference to the main
    activity of this app (`MainActivity`) as well as a `List` reference. We will see
    what use we put the `MainActivity` reference to shortly, but we can sensibly guess
    that the reference to a `List` with a type of `<Note>` will be a reference to
    our `Note` instances, which we will soon code in the `MainActivity` class. `NoteAdapter`
    will then hold a permanent reference to all the users' notes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用主构造函数声明和初始化了`NoteAdapter`类的两个属性。注意构造函数的参数。它接收一个`MainActivity`引用以及一个`List`引用。这意味着当我们使用这个类时，我们需要发送一个对这个应用程序的主活动（`MainActivity`）的引用，以及一个`List`引用。我们很快就会看到我们如何使用`MainActivity`的引用，但我们可以合理地猜测，带有`<Note>`类型的`List`引用将是对我们很快在`MainActivity`类中编写的`Note`实例的引用。`NoteAdapter`将永久持有所有用户笔记的引用。
- en: You will notice, however, that the class declaration and other areas of the
    code are underlined in red, showing that there are errors in our code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您会注意到类声明和代码的其他部分都被红色下划线标出，显示我们的代码中存在错误。
- en: The first error is because the `RecylerView.Adapter` class (which we are inheriting
    from) needs us to override some of its abstract functions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个错误是因为我们需要重写`RecylerView.Adapter`类（我们正在继承的类）的一些抽象函数。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We discussed abstract classes and their functions in [Chapter 11,](ch11.html
    "Chapter 11. Inheritance in Kotlin") *Inheritance in Kotlin*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第11章](ch11.html "第11章。Kotlin中的继承")*Kotlin中的继承*中讨论了抽象类及其函数。
- en: 'The quickest way to do this is to click the class declaration, hold the *Alt*
    key, and then tap the *Enter* key. Choose **Implement members,** as shown in the
    next screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最快的方法是点击类声明，按住*Alt*键，然后点击*Enter*键。选择**实现成员**，如下一个截图所示：
- en: '![Coding the RecyclerAdapter class](img/B12806_16_03.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![编写RecyclerAdapter类](img/B12806_16_03.jpg)'
- en: 'In the window that follows, hold down *Shift* and left-click all three options
    (functions to add) and then click **OK**. This process adds the following three
    functions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的窗口中，按住*Shift*键并左键单击所有三个选项（要添加的函数），然后点击**确定**。这个过程添加了以下三个函数：
- en: The `onCreateViewHolder` function, which is called when a layout for a list
    item is required
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateViewHolder`函数在需要列表项的布局时调用'
- en: The `onBindViewHolder` function, which is called when the `RecyclerAdapter`
    instance is bound to (connected/associated with) the `RecyclerView` instance in
    the layout
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onBindViewHolder`函数在将`RecyclerAdapter`实例绑定到布局中的`RecyclerView`实例时调用'
- en: The `getItemCount` function, which will be used to return the number of `Note`
    instances in `ArrayList`
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getItemCount`函数将用于返回`ArrayList`中`Note`实例的数量'
- en: We will soon add code to each of these functions to do the required work at
    the specific time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快将为这些函数中的每一个添加代码，以在特定时间做出所需的工作。
- en: Note, however, that we still have multiple errors in our code, including in
    the newly autogenerated functions as well as the class declaration. We need to
    do some work to resolve these errors.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，我们的代码中仍然存在多个错误，包括新生成的函数以及类声明中。我们需要做一些工作来解决这些错误。
- en: The errors are because the `NoteAdapter.ListItemHolder` class does not exist.
    `ListItemHolder` was added by us when we extended `NoteAdapter`. It is our chosen
    class type that will be used as the holder for each list item. Currently, it doesn't
    exist – hence the error. The two functions that also have the same error for the
    same reason were autogenerated when we asked Android Studio to implement the missing
    functions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是因为`NoteAdapter.ListItemHolder`类不存在。当我们扩展`NoteAdapter`时，我们添加了`ListItemHolder`。这是我们选择的类类型，将用作每个列表项的持有者。目前它不存在
    - 因此出现错误。另外两个函数也因为同样的原因出现了相同的错误，因为当我们要求Android Studio实现缺失的函数时，它们是自动生成的。
- en: Let's solve the problem by making a start on the required `ListItemHolder` class.
    It is useful to us for `ListItemHolder` instances to share data/variables with
    `NoteAdapter`; therefore, we will create `ListItemHolder` as an inner class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过开始创建所需的`ListItemHolder`类来解决这个问题。对于`ListItemHolder`实例与`NoteAdapter`共享数据/变量对我们很有用，因此我们将`ListItemHolder`创建为内部类。
- en: 'Click the error in the class declaration and select **Create class ''ListItemHolder''**,
    as shown in this next screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 点击类声明中的错误，然后选择**创建类'ListItemHolder'**，如下一个截图所示：
- en: '![Coding the RecyclerAdapter class](img/B12806_16_05.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![编写RecyclerAdapter类](img/B12806_16_05.jpg)'
- en: In the pop-up window that follows, choose **NoteAdapter** to generate `ListItemHolder`
    inside `NoteAdapter`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的弹出窗口中，选择**NoteAdapter**以在`NoteAdapter`内生成`ListItemHolder`。
- en: 'The following code has been added to the `NoteAdapter` class:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码已添加到`NoteAdapter`类中：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But we still have multiple errors. Let''s fix one of them now. Hover your mouse
    over the red-underlined error in the class declaration as shown in the next screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然有多个错误。让我们现在修复其中一个。将鼠标悬停在类声明中的红色下划线错误上，如下一个截图所示：
- en: '![Coding the RecyclerAdapter class](img/B12806_16_06.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![编写RecyclerAdapter类](img/B12806_16_06.jpg)'
- en: 'The error message reads **Type argument is not within its bounds. Expected:**
    **RecyclerView.ViewHolder! Found: NoteAdapter.ListItemHolder**. The reason for
    this is because we may have added `ListItemHolder`, but `ListItemHolder` must
    also implement `RecyclerView.ViewHolder` in order to be used as the correct type.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '错误消息显示**Type argument is not within its bounds. Expected:** **RecyclerView.ViewHolder!
    Found: NoteAdapter.ListItemHolder**。这是因为我们可能已经添加了`ListItemHolder`，但`ListItemHolder`必须也实现`RecyclerView.ViewHolder`才能作为正确的类型使用。'
- en: 'Amend the declaration of the `ListItemHolder` class to match this code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`ListItemHolder`类的声明以匹配此代码：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now the error is gone from the `NoteAdapter` class declaration, but because
    we also implemented `View.OnClickListener`, we need to implement the `onClick`
    function. Furthermore, `ViewHolder` doesn''t provide a default constructor, so
    we need to do it. Add the following `onClick` function (empty for now) and this
    `init` block (empty for now) to the `ListItemHolder` class:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`NoteAdapter`类声明中的错误已经消失，但因为我们还实现了`View.OnClickListener`，我们需要实现`onClick`函数。此外，`ViewHolder`没有提供默认构造函数，所以我们需要添加。将以下`onClick`函数（现在为空）和这个`init`块（现在为空）添加到`ListItemHolder`类中：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Be sure you added the code to the inner `ListItemHolder` class and not the `NoteAdapter`
    class.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你添加的代码是在内部的`ListItemHolder`类中，而不是`NoteAdapter`类中。
- en: 'Let''s clear up the final remaining errors. When the `onBindViewHolder` function
    was autogenerated, Android Studio didn''t add the type for the `holder` parameter.
    This is causing an error in the function and an error in the class declaration.
    Update the `onBindViewHolder` function''s signature, as shown in the next code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们清理掉最后剩下的错误。当`onBindViewHolder`函数被自动生成时，Android Studio没有为`holder`参数添加类型。这导致函数和类声明中出现错误。根据下面的代码更新`onBindViewHolder`函数的签名：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `onCreateViewHolder` function signature, the return type has not been
    autogenerated. Amend the signature of the `onCreateViewHolder` function, as shown
    in this next code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreateViewHolder`函数签名中，返回类型没有被自动生成。修改`onCreateViewHolder`函数的签名，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As a last bit of good housekeeping, let''s delete the three `// TODO…` comments
    that were autogenerated but not required. There is one in each of the autogenerated
    functions. They look like the one highlighted in this next screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一点良好的整理，让我们删除自动生成但不需要的三个`// TODO…`注释。每个自动生成的函数中都有一个。它们看起来像下一个截图中突出显示的那样：
- en: '![Coding the RecyclerAdapter class](img/B12806_16_10.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![编写RecyclerAdapter类](img/B12806_16_10.jpg)'
- en: As you delete the `TODO…` comments, more errors will appear. We need to add
    `return` statements to some of the autogenerated functions. We will do this as
    we proceed with coding the class.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当你删除`TODO…`注释时，会出现更多的错误。我们需要在一些自动生成的函数中添加`return`语句。随着我们继续编写类，我们将会这样做。
- en: After much tinkering and autogenerating, we finally have an almost error-free
    `NoteAdapter` class, complete with overridden functions and an inner class that
    we can code to get our `RecyclerAdapter` instance working. In addition, we can
    write code to respond to clicks (in `onClick`) on each of our `ListItemHolder`
    instances.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多次调整和自动生成，我们最终有了一个几乎没有错误的`NoteAdapter`类，包括重写的函数和一个内部类，我们可以编写代码来使我们的`RecyclerAdapter`实例工作。此外，我们可以编写代码来响应每个`ListItemHolder`实例上的点击（在`onClick`中）。
- en: 'What follows is a complete listing of what the code should look like at this
    stage (excluding the import statements):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是代码在这个阶段应该看起来的完整清单（不包括导入语句）：
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You could have just copy and pasted the preceding code instead of enduring the
    machinations of the previous pages, but then you wouldn't have experienced the
    process of implementing interfaces and inner classes so closely.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你本可以只复制并粘贴前面的代码，而不必忍受之前页面的折磨，但那样你就不会如此近距离地体验到实现接口和内部类的过程。
- en: Now, let's code the functions and get this class operational.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写函数并使这个类运行起来。
- en: Coding the onCreateViewHolder function
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写onCreateViewHolder函数
- en: 'Next, we will adapt the autogenerated `onCreateViewHolder` function. Add the
    highlighted lines of code to the `onCreateViewHolder` function and study them:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调整自动生成的`onCreateViewHolder`函数。将下面的代码行添加到`onCreateViewHolder`函数中并学习它们：
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code works by initializing `itemView` using `LayoutInflater` and our newly
    designed `listitem` layout. It then returns a new `ListItemHolder` instance, complete
    with an inflated and ready-to-use layout.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过使用`LayoutInflater`和我们新设计的`listitem`布局来初始化`itemView`。然后返回一个新的`ListItemHolder`实例，包括一个已经膨胀并且可以立即使用的布局。
- en: Coding the onBindViewHolder function
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写onBindViewHolder函数
- en: 'Next, we will adapt the `onBindViewHolder` function. Add the highlighted code
    to make the function the same as this code, and be sure to study the code as well:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将调整`onBindViewHolder`函数。添加高亮代码，使函数与此代码相同，并确保也学习代码：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, the code truncates the text to 15 characters so that it looks sensible
    in the list. Note that if the user enters a very short note below 15 characters
    this will cause a crash. It is left as an exercise for the reader to come back
    to this project and discover a solution to this imperfection.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码将文本截断为15个字符，以便在列表中看起来合理。请注意，如果用户输入的笔记长度小于15个字符，这将导致崩溃。读者可以自行回到这个项目中，发现解决这个缺陷的方法。
- en: It then checks what type of note it is (idea/to-do/important) and assigns the
    appropriate label from the string resources using a `when` expression.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后检查它是什么类型的笔记（想法/待办/重要），并使用`when`表达式从字符串资源中分配适当的标签。
- en: This new code has left some errors in the code with `holder.title`, `holder.description`,
    and `holder.status`, because we need to add them to our `ListItemHolder` inner
    class. We will do this very soon.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码在`holder.title`，`holder.description`和`holder.status`的代码中留下了一些错误，因为我们需要将它们添加到我们的`ListItemHolder`内部类中。我们将很快做到这一点。
- en: Coding getItemCount
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写`getItemCount`
- en: 'Amend the code in the `getItemCount` function, as shown next:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`getItemCount`函数中的代码，如下所示：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This function is used internally by the class, and it supplies the current number
    of items in `List`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是类内部使用的，它提供了`List`中当前项目的数量。
- en: Coding the ListItemHolder inner class
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写`ListItemHolder`内部类
- en: 'Now we can turn our attention to the `ListItemHolder` inner class. Adapt the
    `ListItemHolder` inner class by adding the following highlighted code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将注意力转向`ListItemHolder`内部类。通过添加以下突出显示的代码来调整`ListItemHolder`内部类：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `ListItemHolder` properties get a reference to each of the `TextView` widgets
    in the layout. The `init` block code sets the whole view as clickable so that
    the OS will call the next function we discuss, `onClick`, when a holder is clicked.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListItemHolder`属性引用布局中的每个`TextView`小部件。`init`块代码将整个视图设置为可点击，这样操作系统将在点击持有者时调用我们讨论的下一个函数`onClick`。'
- en: In `onClick`, the call to `mainActivity.showNote` has an error because the function
    doesn't exist yet, but we will fix that in the next section. The call will simply
    show the clicked note using our custom `DialogFragment` instance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onClick`中，对`mainActivity.showNote`的调用存在错误，因为该函数尚不存在，但我们将在下一节中修复这个问题。该调用将简单地使用我们的自定义`DialogFragment`实例显示单击的笔记。
- en: Coding MainActivity to use the RecyclerView and RecyclerAdapter classes
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写MainActivity以使用RecyclerView和RecyclerAdapter类
- en: 'Now, switch over to the `MainActivity` class in the editor window. Add these
    three new properties to the `MainActivity` class and remove the temporary code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，切换到编辑窗口中的`MainActivity`类。将这三个新属性添加到`MainActivity`类中，并删除临时代码：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These three properties are our `ArrayList` instance for all our `Note` instances,
    our `RecyclerView` instance, and an instance of our `NoteAdapter` class.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个属性是我们所有`Note`实例的`ArrayList`实例，我们的`RecyclerView`实例和我们的`NoteAdapter`类的一个实例。
- en: Adding code to onCreate
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`onCreate`中添加代码
- en: 'Add the following highlighted code in the `onCreate` function after the code
    that handles the user pressing on the floating action button (shown again for
    context):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理用户按下浮动操作按钮的代码之后，在`onCreate`函数中添加以下突出显示的代码（为了上下文再次显示）：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we initialize `recyclerView` with the `RecyclerView` widget from the layout.
    Our `NoteAdapter` (`adapter`) instance is initialized by calling the constructor
    we coded. Note that a reference to `MainActivity` (`this`) and the `ArrayList`
    instance is passed in, just as required by the class we have coded previously.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用布局中的`RecyclerView`小部件初始化`recyclerView`。通过调用我们编写的构造函数来初始化我们的`NoteAdapter`（`adapter`）实例。请注意，我们传入了对`MainActivity`（`this`）和`ArrayList`实例的引用，正如我们之前编写的类所要求的那样。
- en: Next, we create a new object – a `LayoutManager` object. In the next four lines
    of code, we configure some properties of `recyclerView`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个新对象 - 一个`LayoutManager`对象。在接下来的四行代码中，我们配置了`recyclerView`的一些属性。
- en: The `itemAnimator` property and `addItemDecoration` function make each list
    item a little more visually enhanced with a separator line between each item in
    the list. Later, when we build a "Settings" screen, we will give the user the
    option to add and remove this separator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`itemAnimator`属性和`addItemDecoration`函数使每个列表项在列表中的每个项目之间都有一个分隔线，从视觉上更加美观。稍后，当我们构建一个“设置”屏幕时，我们将让用户选择添加和删除这个分隔线的选项。'
- en: The last thing we do is initialize the `adapter` property of `recylerView` with
    our adapter, which combines our adapter with our view.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的最后一件事是用我们的适配器初始化`recylerView`的`adapter`属性，将我们的适配器与我们的视图结合在一起。
- en: Now, we will make some changes to the `createNewNote` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将对`createNewNote`函数进行一些更改。
- en: Modifying the createNewNote function
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改`createNewNote`函数
- en: 'In the `createNewNote` function, delete the temporary code we added in [Chapter
    14](ch14.html "Chapter 14. Android Dialog Windows"), *Android Dialog Windows*
    (shown commented out). and add the new highlighted code shown next:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在`createNewNote`函数中，删除我们在[第14章](ch14.html "第14章。Android对话框窗口")中添加的临时代码，*Android对话框窗口*（显示为注释）。并添加下一个显示的新突出代码：
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The new highlighted code adds a note to the `ArrayList` instance instead of
    simply initializing a solitary `Note` object, which has now been commented out.
    Then, we need to call `notifyDataSetChanged`, which lets our adapter know that
    a new note has been added.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 新添加的突出显示的代码将一个笔记添加到`ArrayList`实例中，而不是简单地初始化一个孤立的`Note`对象，现在已经被注释掉。然后，我们需要调用`notifyDataSetChanged`，让我们的适配器知道已添加新的笔记。
- en: Coding the showNote function
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写`showNote`函数
- en: 'Add the `showNote` function, which is called from the `NoteAdapter` class using
    the reference to this class that was passed into the `NoteAdapter` constructor.
    Or, more accurately, it is called from the `ListerItemHolder` inner class when
    one of the items in the `RecyclerView` widget is tapped by the user. Add the `showNote`
    function to the `MainActivity` class:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`showNote`函数，它是从`NoteAdapter`类中使用传递给`NoteAdapter`构造函数的对这个类的引用来调用的。更准确地说，当用户点击`RecyclerView`小部件中的一个项目时，它是从`ListerItemHolder`内部类中调用的。将`showNote`函数添加到`MainActivity`类中：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All the errors in the `NoteAdapter.kt` file are now gone.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`NoteAdapter.kt`文件中的所有错误现在都已经消失。'
- en: The code just added will launch a new instance of `DialogShowNote`, passing
    in the specific required note as referenced by `noteToShow`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚添加的代码将启动一个新的`DialogShowNote`实例，传入由`noteToShow`引用的特定所需的笔记。
- en: Running the app
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'You can now run the app and enter a new note, as shown in this next screenshot:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行应用程序并输入一个新的笔记，如下一个屏幕截图所示：
- en: '![Running the app](img/B12806_16_07.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用程序](img/B12806_16_07.jpg)'
- en: 'After you have entered several notes of several types, the list (`RecyclerView`)
    will look something like this next screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入了几种类型的笔记后，列表（`RecyclerView`）将看起来像下一个屏幕截图所示：
- en: '![Running the app](img/B12806_16_08.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用程序](img/B12806_16_08.jpg)'
- en: 'And, if you click to view one of the notes, it will look like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，如果您点击查看其中一条笔记，它会看起来像这样：
- en: '![Running the app](img/B12806_16_09.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用程序](img/B12806_16_09.jpg)'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 笔记
- en: '**Reader challenge**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**读者挑战**'
- en: We could have spent more time formatting the layouts of our two dialog windows.
    Why not refer to [Chapter 5](ch05.html "Chapter 5. Beautiful Layouts with CardView
    and ScrollView"), *Beautiful Layouts with CardView and ScrollView*, as well as
    the Material Design website, [https://material.io/design/](https://material.io/design/),
    and do a better job than this. Furthermore, you could enhance the `RecyclerView`
    list of notes by using `CardView` instead of `LinearLayou` `t`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以花更多时间格式化我们的两个对话框窗口的布局。为什么不参考[第5章](ch05.html "第5章。使用CardView和ScrollView创建美丽的布局")，*使用CardView和ScrollView创建美丽的布局*，以及Material
    Design网站，[https://material.io/design/](https://material.io/design/)，做得比这更好。此外，您可以通过使用`CardView`而不是`LinearLayout`来增强`RecyclerView`的笔记列表。
- en: 'Don''t spend too long adding new notes, however, because there is a slight
    problem: close and restart the app. Uh oh, all the notes are gone!'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不要花太长时间添加新的笔记，因为有一个小问题：关闭并重新启动应用程序。哦哦，所有的笔记都消失了！
- en: Frequently asked questions
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经常问的问题
- en: Q.1) I still don't understand how `RecyclerAdapter` works?
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Q.1) 我仍然不明白`RecyclerAdapter`是如何工作的？
- en: 'A) That''s because we haven''t really discussed it. The reason we have not
    discussed the behind-the-scenes details is because we don''t need to know them.
    If we override the required functions, as we have just seen, everything will work.
    This is how `RecyclerAdapter` and most other classes we use are meant to be: hidden
    implementation with public functions to expose the necessary functionality.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: A) 那是因为我们实际上并没有讨论过。我们没有讨论幕后的细节是因为我们不需要知道它们。如果我们重写所需的函数，就像我们刚刚看到的那样，一切都会正常工作。这就是`RecyclerAdapter`和我们使用的大多数其他类的意图：隐藏实现并公开函数以暴露必要的功能。
- en: Q.2) I feel like I *need* to know what is going on inside `RecyclerAdapter`
    and other classes as well. How can I do this?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Q.2) 我觉得我*需要*知道`RecyclerAdapter`和其他类的内部情况。我该怎么做？
- en: A) It is true that there are more details for `RecyclerAdapter` (and almost
    every class that we use in this book) that we don't have the space to discuss.
    It is good practice to read the official documentation of the classes you use.
    You can read more about it at [https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: A) 的确，`RecyclerAdapter`（以及我们在本书中使用的几乎每个类）有更多细节，我们没有空间来讨论。阅读您使用的类的官方文档是一个好的做法。您可以在[https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter](https://developer.android.com/reference/android/support/v7/widget/RecyclerView.Adapter)上阅读更多信息。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now we have added the functionality to hold multiple notes and implemented the
    ability to display them.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了保存多个笔记的功能，并实现了显示它们的能力。
- en: We achieved this by learning about and using the `RecyclerAdapter` class, which
    implements the `Adapter` interface, which allows us to bind together a `RecyclerView`
    instance and an `ArrayList` instance, allowing for the seamless display of data
    without us (the programmer) having to worry about the complex code that is part
    of these classes, and which we don't even see.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过学习和使用`RecyclerAdapter`类来实现了这一点，该类实现了`Adapter`接口，允许我们将`RecyclerView`实例和`ArrayList`实例绑定在一起，从而无缝显示数据，而我们（程序员）不必担心这些类的复杂代码，甚至看不到。
- en: In the next chapter, we will start with making the user's notes persist when
    they quit the app or switch off their device. In addition, we will create a "Settings"
    screen, and see how we can make the settings persist as well. We will use different
    techniques to achieve each of these goals.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始使用户的笔记在退出应用程序或关闭设备时持久化。此外，我们将创建一个“设置”屏幕，并看看如何使设置也持久化。我们将使用不同的技术来实现这些目标。
