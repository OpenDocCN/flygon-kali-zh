- en: Chapter 6. Inheritance, Abstraction, Extension, and Specialization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。继承，抽象，扩展和特殊化
- en: 'In this chapter, we will learn about one of the most important pillars of object-oriented
    programming in Java 9: inheritance. We will work with examples on how to create
    class hierarchies, override and overload methods, and work with the constructors
    defined in superclasses. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Java 9中面向对象编程最重要的支柱之一：继承。我们将使用示例来学习如何创建类层次结构，覆盖和重载方法，并处理超类中定义的构造函数。我们将：
- en: Create class hierarchies to abstract and specialize behavior
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类层次结构以抽象和特殊化行为
- en: Understand inheritance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解继承
- en: Create an abstract base class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个抽象基类
- en: Declare classes that inherit from another class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明从另一个类继承的类
- en: Overload constructors
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载构造函数
- en: Override instance methods
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖实例方法
- en: Overload instance methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载实例方法
- en: Creating class hierarchies to abstract and specialize behavior
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类层次结构以抽象和特殊化行为
- en: In the previous chapters, we have been creating classes in Java 9 to generate
    blueprints for real-life objects. We declared classes and then we created instances
    of these classes in JShell. Now it is time to take advantage of many of the most
    advanced features of object-oriented programming included in Java 9 and start
    designing a hierarchy of classes instead of working with isolated classes. First,
    we will design all the classes that we need based on the requirements, and then
    we will use the features available in Java 9 to code the designed classes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们一直在使用Java 9创建类来生成现实生活中对象的蓝图。我们声明了类，然后在JShell中创建了这些类的实例。现在是时候利用Java
    9中包含的许多最先进的面向对象编程特性，开始设计一个类层次结构，而不是使用孤立的类。首先，我们将根据需求设计所有需要的类，然后使用Java 9中可用的功能来编写设计的类。
- en: 'We worked with classes to represent virtual creatures. Now, let''s imagine
    that we have to develop a complex Web Service that requires us to work with dozens
    of types of virtual animal. Many of these virtual animals will be similar to pets
    and domestic animals in the first stage of the project. The requirements specify
    that our Web Service will start working with the following four virtual animals
    that are going to be similar to the domestic animal species:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类来表示虚拟生物。现在，让我们想象一下，我们必须开发一个复杂的Web服务，需要我们处理数十种虚拟动物。在项目的第一阶段，许多这些虚拟动物将类似于宠物和家畜。需求规定，我们的Web服务将开始处理以下四种与家畜动物物种相似的虚拟动物：
- en: '**Horse** (**Equus ferus caballus**). Do not confuse this with a wild horse
    (Equus ferus). We will have male and female horses, and female horses might be
    pregnant. In addition, we will have to work with the following three specific
    horse breeds: American Quarter Horse, Shire Horse, and Thoroughbred.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**马**（**Equus ferus caballus**）。不要将其与野马（Equus ferus）混淆。我们将拥有雄性和雌性马，雌性马可能怀孕。此外，我们将需要处理以下三种特定的马种：美国四分之一马，夏尔马和纯种马。'
- en: '**Cockatiel** (**Nymphicus hollandicus**). This bird is also known as quarrion
    or weiro.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鹦鹉**（**Nymphicus hollandicus**）。这种鸟也被称为鹦鹉或维罗。'
- en: '**Maine Coon**. This is one of the largest domesticated breeds of cat (Felis
    silvestris catus).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缅因库恩**。这是最大的家养猫品种之一（Felis silvestris catus）。'
- en: '**Domestic rabbit** (**Oryctolagus cuniculus**). This rabbit is also known
    as European rabbit.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**家兔**（**Oryctolagus cuniculus**）。这种兔子也被称为欧洲兔。'
- en: The previous list includes the scientific name for each domestic animal species.
    We will definitely work with the most common name for each species and just have
    the scientific name as a class constant of type `String`. Hence, we won't have
    a complex class name, such as `VirtualEquusFerusCaballus`, but we will use `VirtualHorse`
    instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表包括每种家畜动物物种的学名。我们肯定会使用每种物种的最常见名称，并将学名作为`String`类型的类常量。因此，我们不会有复杂的类名，比如`VirtualEquusFerusCaballus`，而是使用`VirtualHorse`。
- en: Our first requirements specify that we have to work with a limited number of
    breeds for the previously enumerated four domestic animal species. Additionally,
    in the future it will be necessary to work with other members of the listed domestic
    animal species, other domestic mammals, additional domestic birds, specific horse
    breeds, and even reptiles and birds that don't belong to the domestic animal species.
    Our object-oriented design must be ready to be expanded for the future requirements,
    as always happens in real-life projects. In fact, we will use this example to
    understand how object-oriented programming makes it easy to expand an existing
    design to consider future requirements.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个需求规定，我们必须处理先前列举的四种家畜动物物种的有限数量品种。此外，将来将需要处理其他列出的家畜动物物种的其他成员，其他家畜哺乳动物，额外的家禽，特定的马种，甚至不属于家畜动物物种的爬行动物和鸟类。我们的面向对象设计必须准备好为未来的需求进行扩展，就像在现实项目中经常发生的那样。事实上，我们将使用这个例子来理解面向对象编程如何轻松地扩展现有设计以考虑未来的需求。
- en: We don't want to model a complete representation of the animal kingdom and its
    classification. We will just create the necessary classes to have a flexible model
    that can be easily expanded based on future requirements. The animal kingdom is
    extremely complex. We will keep our focus on just a few members of this huge family.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想模拟动物王国及其分类的完整表示。我们只会创建必要的类，以便拥有一个灵活的模型，可以根据未来的需求轻松扩展。动物王国非常复杂。我们将把重点放在这个庞大家族的一些成员上。
- en: One of the main goals for the following examples is to learn that object-oriented
    programming doesn't sacrifice flexibility. We will start with a simple class hierarchy
    that we will expand as the required features complexity increases and we have
    more information about these new requirements. Let's remember that requirements
    aren't fixed and that we always must add new features, and make changes to the
    existing classes based on these new features.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例的主要目标之一是了解面向对象编程并不会牺牲灵活性。我们将从一个简单的类层次结构开始，随着所需功能的复杂性增加以及对这些新需求的更多了解，我们将扩展它。让我们记住，需求并不是固定的，我们总是必须根据这些新需求添加新功能并对现有类进行更改。
- en: 'We will create a hierarchy of classes to represent a complex classification
    of virtual animals and their breeds. When we extend a class, we create a subclass
    of this class. The following list enumerates the classes that we will create and
    their descriptions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个类层次结构来表示虚拟动物及其品种的复杂分类。当我们扩展一个类时，我们创建这个类的子类。以下列表列举了我们将创建的类及其描述：
- en: '`VirtualAnimal`: This class generalizes all the members of the animal kingdom.
    Horses, cats, birds, rabbits, and reptiles have one thing in common: they are
    animals. Hence, it makes sense to create a class that will be the baseline for
    the different classes of virtual animals that we may have to represent in our
    object-oriented design.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VirtualAnimal`：这个类概括了动物王国的所有成员。马、猫、鸟、兔子和爬行动物有一个共同点：它们都是动物。因此，创建一个类作为我们面向对象设计中可能需要表示的不同类别的虚拟动物的基线是有意义的。'
- en: '`VirtualMammal`: This class generalizes all the mammalian virtual animals.
    Mammals are different from insects, birds, amphibians, and reptiles. We already
    know that we can have female horses and that they can be pregnant. We also know
    that we will have to model reptiles and birds, and therefore, we create a `VirtualMammal`
    class that extends `VirtualAnimal` and becomes a subclass of it.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VirtualMammal`：这个类概括了所有哺乳动物的虚拟动物。哺乳动物与昆虫、鸟类、两栖动物和爬行动物不同。我们已经知道我们可以有母马，并且它们可以怀孕。我们还知道我们将需要对爬行动物和鸟类进行建模，因此我们创建了一个扩展`VirtualAnimal`并成为其子类的`VirtualMammal`类。'
- en: '`VirtualBird`: This class generalizes all the birds. Birds are different from
    mammals, insects, amphibians, and reptiles. We already know that we will also
    have to model reptiles. A Cockatiel is a bird, and therefore, we will create a
    `VirtualBird` class at the same level as `VirtualMammal`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VirtualBird`：这个类概括了所有鸟类。鸟类与哺乳动物、昆虫、两栖动物和爬行动物不同。我们已经知道我们还将需要对爬行动物进行建模。鹦鹉是一种鸟，因此我们将在与`VirtualMammal`同级别创建一个`VirtualBird`类。'
- en: '`VirtualDomesticMammal`: This class extends the `VirtualMammal` class. Let''s
    do some research and we will realize that the tiger (Panthera tigris) is the largest
    and heaviest living species of the cat family. A tiger is a cat, but it is completely
    different from a Maine Coon, which is a small domestic cat. The initial requirements
    specified that we work with both virtual domestic and virtual wild animals, so
    we will create a class that generalizes all the virtual domestic mammal animals.
    In the future, we will have a `VirtualWildMammal` subclass that will generalize
    all the virtual wild mammalian animals.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VirtualDomesticMammal`：这个类扩展了`VirtualMammal`类。让我们进行一些研究，我们会意识到老虎（Panthera
    tigris）是目前最大和最重的猫科动物。老虎是一种猫，但它与缅因猫完全不同，缅因猫是一种小型家养猫。最初的需求规定我们要处理虚拟家养和虚拟野生动物，因此我们将创建一个概括所有虚拟家养哺乳动物的类。将来，我们将有一个`VirtualWildMammal`子类，它将概括所有虚拟野生哺乳动物。'
- en: '`VirtualDomesticBird`: This class extends the `VirtualBird` class. Let''s do
    some research and we will realize that the ostrich (Struthio camelus) is the largest
    living bird. An ostrich is a bird, but it is completely different from a Cockatiel,
    which is a small domestic bird. We will work with both virtual domestic and virtual
    wild birds, so we will create a class that generalizes all virtual domestic birds.
    In the future, we will have a `VirtualWildBird` class that will generalize all
    virtual wild birds.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VirtualDomesticBird`：这个类扩展了`VirtualBird`类。让我们进行一些研究，我们会意识到鸵鸟（Struthio camelus）是目前最大的活鸟。鸵鸟是一种鸟，但它与鹦鹉完全不同，鹦鹉是一种小型家养鸟。我们将处理虚拟家养和虚拟野生鸟，因此我们将创建一个概括所有虚拟家养鸟的类。将来，我们将有一个`VirtualWildBird`类，它将概括所有虚拟野生鸟。'
- en: '`VirtualHorse`: This class extends the `VirtualDomesticMammal` class. We could
    go on specializing the `VirtualDomesticMammal` class with additional subclasses
    until we reach a `VirtualHorse` class. For example, we might create a `VirtualHerbivoreDomesticMammal`
    subclass and then make the `VirtualHorse` class inherit from it. However, the
    kind of Web Service we have to develop doesn''t require any intermediary class
    between `VirtualDomesticMammal` and `VirtualHorse`. The `VirtualHorse` class generalizes
    the fields and methods required for a virtual horse in our application. The different
    subclasses of the `VirtualHorse` class will represent the diverse families of
    the virtual horse breed.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VirtualHorse`：这个类扩展了`VirtualDomesticMammal`类。我们可以继续用额外的子类专门化`VirtualDomesticMammal`类，直到达到`VirtualHorse`类。例如，我们可以创建一个`VirtualHerbivoreDomesticMammal`子类，然后让`VirtualHorse`类继承它。然而，我们需要开发的Web服务不需要在`VirtualDomesticMammal`和`VirtualHorse`之间有任何中间类。`VirtualHorse`类概括了我们应用程序中虚拟马所需的所有字段和方法。`VirtualHorse`类的不同子类将代表虚拟马品种的不同家族。'
- en: '`VirtualDomesticRabbit`: This class extends the `VirtualDomesticMammal` class.
    The `VirtualDomesticRabbit` class generalizes all the fields and methods required
    for a virtual domestic rabbit in our application.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VirtualDomesticRabbit`：这个类扩展了`VirtualDomesticMammal`类。`VirtualDomesticRabbit`类概括了我们应用程序中虚拟家养兔所需的所有字段和方法。'
- en: '`VirtualDomesticCat`: This class extends the `VirtualDomesticMammal` class.
    The `VirtualDomesticCat` class generalizes all the fields and methods required
    for a virtual domestic cat in our application.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VirtualDomesticCat`：这个类扩展了`VirtualDomesticMammal`类。`VirtualDomesticCat`类概括了我们应用程序中虚拟家养猫所需的所有字段和方法。'
- en: '`AmericanQuarterHorse`: This class extends the `VirtualHorse` class. The `AmericanQuarterHorse`
    class generalizes all the fields and methods required for a virtual horse that
    belongs to the American Quarter Horse breed.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`美国四分之一马`：这个类扩展了`虚拟马`类。`美国四分之一马`类概括了属于美国四分之一马品种的虚拟马所需的所有字段和方法。'
- en: '`ShireHorse`: This class extends the `VirtualHorse` class. The `ShireHorse`
    class generalizes all the fields and methods required for a virtual horse that
    belongs to the Shire Horse breed.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShireHorse`：这个类扩展了`虚拟马`类。`ShireHorse`类概括了属于莱茵马品种的虚拟马所需的所有字段和方法。'
- en: '`Thoroughbred`: This class extends the `VirtualHorse` class. The `Thoroughbred`
    class generalizes all the fields and methods required for a virtual horse that
    belongs to the Thoroughbred breed.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thoroughbred`：这个类扩展了`虚拟马`类。`Thoroughbred`类概括了属于纯种马品种的虚拟马所需的所有字段和方法。'
- en: '`Cockatiel`: This class extends the `VirtualDomesticBird` class. The `Cockatiel`
    class generalizes all the fields and methods required for a virtual domestic bird
    that belongs to the Cockatiel family.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cockatiel`：这个类扩展了`虚拟家禽`类。`Cockatiel`类概括了属于鹦鹉家族的虚拟家禽所需的所有字段和方法。'
- en: '`MaineCoon`: This class extends the `VirtualDomesticCat` class. The `MaineCoon`
    class generalizes all the fields and methods required for a virtual domestic cat
    that belongs to the Maine Coon breed.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaineCoon`：这个类扩展了`虚拟家猫`类。`MaineCoon`类概括了属于缅因库恩品种的虚拟家猫所需的所有字段和方法。'
- en: The following table shows each of the classes from the previous list with its
    superclass, parent class, or supertype.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了前述列表中的每个类及其超类、父类或超类型。
- en: '| Subclass, child class, or subtype | Superclass, parent class, or supertype
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 子类、子类或子类型 | 超类、父类或超类型 |'
- en: '| --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `VirtualMammal` | `VirtualAnimal` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `虚拟哺乳动物` | `虚拟动物` |'
- en: '| `VirtualBird` | `VirtualAnimal` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `虚拟鸟` | `虚拟动物` |'
- en: '| `VirtualDomesticMammal` | `VirtualMammal` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `虚拟家畜哺乳动物` | `虚拟哺乳动物` |'
- en: '| `VirtualDomesticBird` | `VirtualBird` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `虚拟家禽` | `虚拟鸟` |'
- en: '| `VirtualHorse` | `VirtualDomesticMammal` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: 虚拟马 | 虚拟家畜哺乳动物
- en: '| `VirtualDomesticRabbit` | `VirtualDomesticMammal` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `虚拟家兔` | `虚拟家畜哺乳动物` |'
- en: '| `VirtualDomesticCat` | `VirtualDomesticMammal` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `虚拟家猫` | `虚拟家畜哺乳动物` |'
- en: '| `AmericanQuarterHorse` | `VirtualHorse` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `美国四分之一马` | `虚拟马` |'
- en: '| `ShireHorse` | `VirtualHorse` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `ShireHorse` | `虚拟马` |'
- en: '| `Thoroughbred` | `VirtualHorse` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `Thoroughbred` | `虚拟马` |'
- en: '| `Cockatiel` | `VirtualDomesticBird` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `Cockatiel` | `虚拟家禽` |'
- en: '| `MaineCoon` | `VirtualDomesticCat` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `MaineCoon` | `虚拟家猫` |'
- en: The following UML diagram shows the previous classes organized in a class hierarchy.
    The class names that use italic text format indicate that they are abstract classes.
    Notice that the diagram doesn't include any members, just the class names. We
    will add the members later.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的UML图显示了以类层次结构组织的前述类。使用斜体文本格式的类名表示它们是抽象类。注意图表中不包括任何成员，只有类名。我们稍后会添加成员。
- en: '![Creating class hierarchies to abstract and specialize behavior](img/00065.jpeg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![创建类层次结构以抽象和特殊化行为](img/00065.jpeg)'
- en: Understanding inheritance
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解继承
- en: When a class inherits from another class, it inherits all the members that compose
    the parent class, which is also known as the **superclass**. The class that inherits
    the elements is known as a **subclass** of the superclass. For example, the `VirtualBird`
    subclass inherits all the instance fields, class fields, instance methods, and
    class methods defined in the `VirtualAnimal` superclass.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类继承自另一个类时，它继承了组成父类的所有成员，这也被称为**超类**。继承元素的类被称为超类的**子类**。例如，`VirtualBird`子类继承了`VirtualAnimal`超类中定义的所有实例字段、类字段、实例方法和类方法。
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In Java 9, a subclass doesn't inherit any constructor from its superclass. However,
    it is possible to call the constructors defined in the superclass and we will
    do this in the next examples. Only the usage of the `private` access modifier
    in any constructor defined in a superclass can make it impossible for a subclass
    to call this constructor.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，子类不会从其超类那里继承任何构造函数。但是，可以调用超类中定义的构造函数，在下面的示例中我们将这样做。只有在超类中定义的任何构造函数中使用`private`访问修饰符才会使子类无法调用该构造函数。
- en: The `VirtualAnimal` abstract class is the baseline for our class hierarchy.
    We say that it is an **abstract class** because we cannot create instances of
    the `VirtualAnimal` class. Instead, we must create instances of the specific subclasses
    of `VirtualAnimal`, any subclass that isn't an abstract class. The classes that
    we can use to create instances of them are known as **concrete classes** or just
    classes in most cases. Java 9 allows us to declare classes as abstract classes
    when they aren't intended to generate instances.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualAnimal`抽象类是我们类层次结构的基线。我们说它是一个**抽象类**，因为我们不能创建`VirtualAnimal`类的实例。相反，我们必须创建`VirtualAnimal`的具体子类的实例，任何不是抽象类的子类。我们可以用来创建它们的类通常被称为**具体类**或在大多数情况下只是类。Java
    9允许我们声明类为抽象类，当它们不打算生成实例时。'
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We cannot create instances of an abstract class by using the `new` keyword followed
    by the class name.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用`new`关键字后跟类名来创建抽象类的实例。
- en: We require each `VirtualAnimal` to specify its age but we don't need to specify
    any name for them. We put names to domestic animals only. Hence, we will have
    to specify an age value when we create any `VirtualAnimal`, that is, any instance
    of any `VirtualAnimal` subclass. The class will define an `age` field and print
    a message whenever a virtual animal is being created.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求每个`VirtualAnimal`指定它的年龄，但我们不需要为它们指定任何名字。我们只给家养动物取名字。因此，当我们创建任何`VirtualAnimal`，也就是任何`VirtualAnimal`子类的实例时，我们将不得不指定一个年龄值。该类将定义一个`age`字段，并在创建虚拟动物时打印一条消息。
- en: But wait; we just explained that we are talking about an abstract class and
    that Java won't allow us to create an instance of an abstract class. We cannot
    create an instance of the `VirtualAnimal` abstract class but we will be able to
    create an instance of any concrete class that has `VirtualAnimal` as a superclass
    and this subclass can end up calling the constructor defined in the `VirtualAnimal`
    abstract class. It sounds a bit complicated but we will easily understand the
    situation after we code the classes and run the examples in JShell. We will print
    messages in each constructor we define to make it easy to understand what happens
    when we create an instance of a concrete class that has one or more superclasses,
    including one or more abstract superclasses. All the instances of the subclasses
    of `VirtualAnimal` will be instances of `VirtualAnimal` too.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等；我们刚刚解释过，我们正在谈论一个抽象类，并且Java不允许我们创建抽象类的实例。我们不能创建`VirtualAnimal`抽象类的实例，但我们将能够创建具有`VirtualAnimal`作为超类的任何具体类的实例，这个子类最终可以调用`VirtualAnimal`抽象类中定义的构造函数。听起来有点复杂，但在我们编写类并在JShell中运行示例后，我们将很容易理解情况。我们将在我们定义的每个构造函数中打印消息，以便更容易理解当我们创建具有一个或多个超类的具体类的实例时会发生什么，包括一个或多个抽象超类。`VirtualAnimal`的所有子类的实例也将是`VirtualAnimal`的实例。
- en: The `VirtualAnimal` abstract class will define abstract class methods and abstract
    instance methods. An **abstract class method** is a class method that is declared
    without an implementation. An **abstract instance method**, also known as an abstract
    method, is an instance method that is declared without an implementation.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualAnimal`抽象类将定义抽象类方法和抽象实例方法。**抽象类方法**是声明而没有实现的类方法。**抽象实例方法**，也称为抽象方法，是声明而没有实现的实例方法。'
- en: Tip
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When we declare any of the two types of abstract methods, we only declare the
    arguments (if any) and then put a semicolon (`;`). We don't use curly braces at
    all. We can only declare abstract methods in an abstract class. A concrete subclass
    of any abstract class must provide an implementation for all the inherited abstract
    methods to become a class that we can use to create instances with the `new` keyword.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明任何两种类型的抽象方法时，我们只声明参数（如果有），然后放一个分号（`;`）。我们根本不使用花括号。我们只能在抽象类中声明抽象方法。任何抽象类的具体子类必须为所有继承的抽象方法提供实现，以成为我们可以使用`new`关键字创建实例的类。
- en: The `VirtualAnimal` class will declare the following seven abstract methods
    that fulfill requirements that are going to be common to all the members of a
    specific family or type. The class will just declare their required arguments
    without an implementation for the method. The subclasses will be responsible for
    fulfilling the explained requirements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualAnimal`类将声明以下七个抽象方法，满足特定家族或类型的所有成员的要求。该类只声明它们所需的参数，而不实现方法。子类将负责满足解释的要求。'
- en: '`isAbleToFly`: This returns a `boolean` value indicating whether the virtual
    animal is able to fly.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAbleToFly`：返回一个布尔值，指示虚拟动物是否能飞。'
- en: '`isRideable`: This returns a `boolean` value indicating whether the virtual
    animal is rideable. A rideable animal is capable of being ridden over.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isRideable`：返回一个布尔值，指示虚拟动物是否可骑。可骑的动物能够被骑乘。'
- en: '`isHerbivore`: This returns a `boolean` value indicating whether the virtual
    animal is herbivore.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isHerbivore`：返回一个布尔值，指示虚拟动物是否是食草动物。'
- en: '`isCarnivore`: This returns a `boolean` value indicating whether the virtual
    animal is carnivore.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isCarnivore`：返回一个布尔值，指示虚拟动物是否是肉食动物。'
- en: '`getAverageNumberOfBabies`: This returns the average number of babies at a
    time that are usually born for the virtual animal type.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAverageNumberOfBabies`：返回通常为虚拟动物类型一次出生的平均婴儿数量。'
- en: '`getBaby`: This returns a `String` representation of a baby for the virtual
    animal type.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getBaby`：返回虚拟动物类型的婴儿的`String`表示。'
- en: '`getAsciiArt`: This returns a `String` with the ASCII art (text-based visual
    art) that represents the virtual animal.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsciiArt`：返回表示虚拟动物的ASCII艺术（基于文本的视觉艺术）的`String`。'
- en: The `VirtualAnimal` class will define the following five methods that fulfill
    the requirements for each instance. These will be concrete methods that will be
    coded in the `VirtualAnimal` class and inherited by all its subclasses. Some of
    these methods call the previously explained abstract methods. We will understand
    how this works in detail later.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualAnimal`类将定义以下五个方法，满足每个实例的要求。这些将是具体方法，将在`VirtualAnimal`类中编码，并由其所有子类继承。其中一些方法调用先前解释的抽象方法。我们将在稍后详细了解这是如何工作的。'
- en: '`printAsciiArt`: This prints the `String` returned by the `getAsciiArt` method.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: printAsciiArt：这将打印`getAsciiArt`方法返回的`String`。
- en: '`isYoungerThan`: This returns a `boolean` value indicating whether the `age`
    value for the `VirtualAnimal` is lower than the age for the `VirtualAnimal` instance
    received as an argument.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isYoungerThan`：返回一个布尔值，指示`VirtualAnimal`的`age`值是否低于作为参数接收的`VirtualAnimal`实例的年龄。'
- en: '`isOlderThan`: This returns a `boolean` value indicating whether the `age`
    value for the `VirtualAnimal` class is greater than the age for the `VirtualAnimal`
    instance received as an argument.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isOlderThan`：返回一个布尔值，指示`VirtualAnimal`类的`age`值是否大于作为参数接收的`VirtualAnimal`实例的年龄。'
- en: '`printAge`: This prints the `age` value for the virtual animal.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printAge`：打印虚拟动物的`age`值。'
- en: '`printAverageNumberOfBabies`: This prints a representation of the average number
    of babies at a time that are usually born for the virtual animal. This method
    will take into account the value returned by the `getAverageNumberOfBabies` method
    that is going to be implemented in the different concrete subclasses.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printAverageNumberOfBabies`：打印通常为虚拟动物一次出生的平均婴儿数量的表示。该方法将考虑由不同具体子类中实现的`getAverageNumberOfBabies`方法返回的值。'
- en: The `VirtualMammal` class inherits from `VirtualAnimal`. We will have to specify
    its age and whether it is pregnant or not when we create a new `VirtualMammal`
    instance. The class inherits the `age` property from the `VirtualAnimal` superclass,
    so it is only necessary to add a field to specify whether the virtual mammal is
    pregnant or not. Note that we will not specify the gender at any time in order
    to keep things simple. If we added gender, we would need a validation to avoid
    a male being pregnant. Right now, our focus is on inheritance. The class will
    display a message whenever a virtual mammalian animal is created; that is, whenever
    its constructor is executed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualMammal`类继承自`VirtualAnimal`。当创建新的`VirtualMammal`实例时，我们将不得不指定其年龄和是否怀孕。该类从`VirtualAnimal`超类继承了`age`属性，因此只需要添加一个字段来指定虚拟哺乳动物是否怀孕。请注意，我们将不会在任何时候指定性别，以保持简单。如果我们添加了性别，我们将需要验证以避免雄性怀孕。现在，我们的重点是继承。该类将在创建虚拟哺乳动物时显示一条消息；也就是说，每当执行其构造函数时。'
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Each class inherits from one class, and therefore, each new class we will define
    has just one superclass. In this case, we will always work with **single inheritance**.
    In Java, a class cannot inherit from multiple classes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都继承自一个类，因此，我们将定义的每个新类都只有一个超类。在这种情况下，我们将始终使用**单一继承**。在Java中，一个类不能从多个类继承。
- en: The `VirtualDomesticMammal` class inherits from `VirtualMammal`. We will have
    to specify its name and its favorite toy when we create a new `VirtualDomesticMammal`
    instance. We put names to any domestic mammal and they always pick a favorite
    toy. It is true that sometimes they just choose an object that satisfies their
    appetite for destruction. In many cases, the favorite toy is not exactly the toy
    we would like them to pick (our shoes, sneakers, flip flops, or electronic devices),
    but let's keep the focus on our classes. We won't be able to change the name but
    we can change the favorite toy. We never change the name for any domestic mammal,
    but we can definitely force it to change its favorite toy. The class displays
    a message whenever a virtual domestic mammalian animal is created.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualDomesticMammal`类继承自`VirtualMammal`。当创建新的`VirtualDomesticMammal`实例时，我们将不得不指定其名称和最喜欢的玩具。我们给任何家养哺乳动物都起名字，它们总是会挑选一个最喜欢的玩具。有时它们只是选择满足它们破坏欲望的物品。在许多情况下，最喜欢的玩具并不一定是我们希望它们选择的玩具（我们的鞋子、运动鞋、拖鞋或电子设备），但让我们专注于我们的类。我们无法改变名称，但可以改变最喜欢的玩具。我们永远不会改变任何家养哺乳动物的名称，但我们绝对可以强迫它改变最喜欢的玩具。该类在创建虚拟家养哺乳动物时显示一条消息。'
- en: The `VirtualDomesticMammal` class will declare a `talk` instance method that
    will display a message indicating the virtual domestic mammal's name concatenated
    with the message `"says something"`. Each subclass must make the specific domestic
    mammal talk in a different way. A parrot can really talk, but we will consider
    a horse's nicker and a rabbit's tooth purring as if they were talking. Notice
    that, in this case, the `talk` instance method has a concrete implementation in
    the `VirtualDomesticMammal` class and it is not an abstract instance method. The
    subclasses will be able to provide a different implementation for this method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualDomesticMammal`类将声明一个`talk`实例方法，该方法将显示一条消息，指示虚拟家养哺乳动物的名称与消息“说了些什么”的连接。每个子类必须以不同的方式让特定的家养哺乳动物说话。鹦鹉确实会说话，但我们将把马的嘶鸣和兔子的牙齿咕噜声视为它们在说话。请注意，在这种情况下，`talk`实例方法在`VirtualDomesticMammal`类中具有具体的实现，而不是抽象的实例方法。子类将能够为此方法提供不同的实现。'
- en: The `VirtualHorse` class inherits from `VirtualDomesticMammal` and implements
    all the abstract methods inherited from the `VirtualAnimal` superclass except
    `getBaby` and `getAsciiArt`. These two methods will be implemented in each subclass
    of `VirtualHorse` that determines a horse breed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualHorse`类继承自`VirtualDomesticMammal`，并实现了从`VirtualAnimal`超类继承的所有抽象方法，除了`getBaby`和`getAsciiArt`。这两个方法将在`VirtualHorse`的每个子类中实现，以确定马的品种。'
- en: We want horses to be able to neigh and nicker. Thus, we need both a `neigh`
    and a `nicker` method. Horses usually neigh when they are angry and they nicker
    when they are happy. It is a bit more complex than this, but we will keep things
    simple for our example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望马能够嘶鸣和嘶鸣。因此，我们需要`neigh`和`nicker`方法。马通常在生气时嘶鸣，在快乐时嘶鸣。情况比这更复杂一些，但我们将为我们的示例保持简单。
- en: 'The `neigh` method has to allow a virtual horse to do the following things:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`neigh`方法必须允许虚拟马执行以下操作：'
- en: Neigh just once
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只嘶鸣一次
- en: Neigh a specific number of times
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定次数的嘶鸣
- en: Neigh to another virtual domestic mammal that has a name just once
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与另一个只有一次名字的虚拟家养哺乳动物相邻
- en: Neigh to another virtual domestic mammal that has a name a specific number of
    times
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对另一个只有特定次数名字的虚拟家养哺乳动物嘶鸣
- en: 'The `nicker` method has to allow a virtual horse to do the following things:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`nicker`方法必须允许虚拟马执行以下操作：'
- en: Nicker just once
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只嘶鸣一次
- en: Nicker a specific number of times
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定次数的嘶鸣
- en: Nicker to another virtual domestic mammal that has a name just once
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只对另一个只有一次名字的虚拟家养哺乳动物嘶鸣
- en: Nicker to another virtual domestic mammal that has a name a specific number
    of times
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对另一个只有特定次数名字的虚拟家养哺乳动物嘶鸣
- en: In addition, a horse can neigh or nicker either happily or angrily. We can have
    just one `neigh` method with default values for many of the arguments or many
    `neigh` methods. Java 9 provides many mechanisms to solve the challenges of the
    different ways in which a virtual horse must be able to neigh. We will apply the
    same solution for both the `neigh` and `nicker` methods.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，马可以愉快地或愤怒地嘶鸣或嘶鸣。我们可以有一个`neigh`方法，其中许多参数具有默认值，或者有许多`neigh`方法。Java 9提供了许多机制来解决虚拟马必须能够嘶鸣的不同方式的挑战。我们将对`neigh`和`nicker`方法应用相同的解决方案。
- en: When we call the `talk` method for any virtual horse, we want it to nicker happily
    once. We don't want to display the message defined in the `talk` method introduced
    in the `VirtualDomesticMammal` class. Thus, the `VirtualHorse` class must overwrite
    the inherited `talk` method with its own definition.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为任何虚拟马调用`talk`方法时，我们希望它开心地嘶鸣一次。我们不希望显示在`VirtualDomesticMammal`类中引入的`talk`方法中定义的消息。因此，`VirtualHorse`类必须用自己的定义覆盖继承的`talk`方法。
- en: We want to know the breed to which a virtual horse belongs. Thus, we will define
    a `getBreed` abstract method. Each subclass of `VirtualHorse` must return the
    appropriate `String` with a name when this method is called. The `VirtualHorse`
    class will define a method named `printBreed` that uses the `getBreed` method
    to retrieve the name and print the breed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想知道虚拟马属于哪个品种。因此，我们将定义一个`getBreed`抽象方法。`VirtualHorse`的每个子类在调用此方法时必须返回适当的`String`名称。`VirtualHorse`类将定义一个名为`printBreed`的方法，该方法使用`getBreed`方法来检索名称并打印品种。
- en: At this point, all the classes we have mentioned are abstract classes. We cannot
    create instances of them. The `AmericanQuarterHorse`, `ShireHorse`, and `Thoroughbred`
    classes inherit from the `VirtualHorse` class and implement the inherited `getBaby`,
    `getAsciiArt`, and `getBreed` methods. In addition, their constructors will print
    a message indicating that we are creating an instance of the respective class.
    The three classes are concrete classes and we can create instances of them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们提到的所有类都是抽象类。我们不能创建它们的实例。`AmericanQuarterHorse`、`ShireHorse`和`Thoroughbred`类继承自`VirtualHorse`类，并实现了继承的`getBaby`、`getAsciiArt`和`getBreed`方法。此外，它们的构造函数将打印一条消息，指示我们正在创建相应类的实例。这三个类都是具体类，我们可以创建它们的实例。
- en: We will work with the `VirtualBird`, `VirtualDomesticBird`, `Cockatiel`, `VirtualDomesticCat`,
    and `MaineCoon` classes later. First, we will create the base `VirtualAnimal`
    abstract class in Java 9, and then we will use simple inheritance to create the
    subclasses up to the `VirtualHorse` class. We will override methods and overload
    methods to fulfill all the requirements. We will take advantage of polymorphism,
    which is a very important feature in object-oriented programming that we will
    understand while working with the created classes in JShell. Of course, we will
    dive deeply into many of the topics introduced while analyzing the different classes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将稍后使用`VirtualBird`、`VirtualDomesticBird`、`Cockatiel`、`VirtualDomesticCat`和`MaineCoon`类。首先，我们将在Java
    9中创建基类`VirtualAnimal`抽象类，然后使用简单的继承创建子类，直到`VirtualHorse`类。我们将重写方法和重载方法以满足所有要求。我们将利用多态性，这是面向对象编程中非常重要的特性，我们将在JShell中使用创建的类时了解到。当然，我们将深入研究分析不同类时引入的许多主题。
- en: 'The following UML diagram shows the members for all the abstract classes we
    will code in this chapter: `VirtualAnimal`, `VirtualMammal`, `VirtualDomesticMammal`,
    and `VirtualHorse`. We will code the other classes in the next chapter and we
    will add their members to the diagram later. We use the italic text format to
    indicate abstract methods. Remember that public members have a plus sign (**+**)
    as a prefix. One class has a protected member that uses a hash as a prefix (**#**).
    We will use the bold text format to indicate a method that overrides an existing
    method in a superclass. In this case, the `VirtualHorse` class overrides the `tal`
    `k()` method.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下UML图显示了我们将在本章中编写的所有抽象类的成员：`VirtualAnimal`、`VirtualMammal`、`VirtualDomesticMammal`和`VirtualHorse`。我们将在下一章中编写其他类，并稍后将它们的成员添加到图中。我们使用斜体文本格式表示抽象方法。请记住，公共成员以加号（**+**）作为前缀。一个类有一个受保护的成员，使用井号作为前缀（**#**）。我们将使用粗体文本格式表示覆盖超类中现有方法的方法。在这种情况下，`VirtualHorse`类覆盖了`talk()`方法。
- en: '![Understanding inheritance](img/00066.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![理解继承](img/00066.jpeg)'
- en: In the previous UML diagram we will notice the following conventions. We will
    use these conventions in all the UML diagrams that include class members.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个UML图中，我们将注意到以下约定。我们将在包括类成员的所有UML图中使用这些约定。
- en: The constructors have the same name as the classes and do not specify any return
    type. They are always the first methods listed in the methods section.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数与类名相同，不指定任何返回类型。它们始终是方法部分中列出的第一个方法。
- en: The type for a field is indicated after the field name separated by a colon
    (**:**).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段的类型在字段名称之后用冒号（**：**）分隔。
- en: Each parameter in the parameter list for each method is separated by a semicolon
    (**;**).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个方法的参数列表中的参数都用分号（**;**）分隔。
- en: The return type of a method is indicated after the parameter list for the method,
    separated by a colon (**:**).
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的返回类型在参数列表之后用冒号（**：**）分隔。
- en: We always use Java type names.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们始终使用Java类型名称。
- en: Creating an abstract base class
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建抽象基类
- en: First, we will create the abstract class that will become our base class for
    the other classes. The following lines show the code for the `VirtualAnimal` abstract
    base class in Java 9\. The `abstract` keyword before `class` indicates to Java
    that we are creating an abstract class. The code file for the sample is included
    in the `java_9_oop_chapter_06_01` folder, in the `example06_01.java` file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建抽象类，该类将成为其他类的基类。以下是Java 9中`VirtualAnimal`抽象基类的代码。`class`之前的`abstract`关键字表示我们正在创建一个抽象类。示例的代码文件包含在`java_9_oop_chapter_06_01`文件夹中的`example06_01.java`文件中。
- en: '[PRE0]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding class declares an immutable field of type `int` named `age`. The
    constructor requires an `age` value to create an instance of the class and prints
    a message indicating that a virtual animal is created. The class declares the
    following abstract methods that include the `abstract` keyword before the returned
    type to let Java know we just want to declare the required arguments and that
    we won't provide an implementation for the methods. We have already explained
    the goals for these methods that will be implemented in subclasses of `VirtualAnimal`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '前面的类声明了一个名为`age`的`int`类型的不可变字段。构造函数需要一个`age`值来创建类的实例，并打印一条消息指示创建了一个虚拟动物。该类声明了以下抽象方法，这些方法在返回类型之前包含`abstract`关键字，以便让Java知道我们只想声明所需的参数，并且不会为这些方法提供实现。我们已经解释了这些方法的目标，它们将在`VirtualAnimal`的子类中实现。 '
- en: '`isAbleToFly`'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAbleToFly`'
- en: '`isRideable`'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isRideable`'
- en: '`isHerbivore`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isHerbivore`'
- en: '`isCarnivore`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isCarnivore`'
- en: '`getAverageNumberOfBabies`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取平均婴儿数量
- en: '`getBaby`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getBaby`'
- en: '`getAsciiArt`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getAsciiArt`'
- en: 'In addition, the class declares the following five methods:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该类声明了以下五个方法：
- en: '`printAsciiArt`: This method calls `System.out.println` to print the `String`
    returned by the `getAsciiArt` method.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印AsciiArt：此方法调用`System.out.println`来打印`getAsciiArt`方法返回的`String`。
- en: '`printAverageNumberOfBabies`: This method creates a new `char` array with a
    number of elements equal to the value returned by the `getAverageNumberOfBabies`
    method. Then, the code creates a new `String` initialized with the `char` array
    and calls the `replace` method to substitute each `"\0"`, with the `String` returned
    by the `getBaby` method. This way, we generate a `String` that concatenates `getAverageNumberOfBabies`
    times the `String` returned by `getBaby`. The code calls `System.out.println`
    to print the generated `String`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`printAverageNumberOfBabies`：此方法创建一个新的`char`数组，其元素数量等于`getAverageNumberOfBabies`方法返回的值。然后，代码创建一个初始化为`char`数组的新`String`，并调用`replace`方法来用`getBaby`方法返回的`String`替换每个`"\0"`。这样，我们生成一个`String`，其中包含`getBaby`返回的`String`的`getAverageNumberOfBabies`倍。代码调用`System.out.println`来打印生成的`String`。'
- en: '`printAge`: This method calls `System.out.println` to print the `String` generated
    with `String.format` that includes the value of the `age` immutable field.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印年龄：此方法调用`System.out.println`来打印使用`String.format`生成的`String`，其中包括`age`不可变字段的值。
- en: '`isYoungerThan`: This method receives a `VirtualAnimal` instance in the `otherAnimal`
    argument and returns the result of applying the less than operator between the
    value of the `age` field for this instance and `otherAnimal.age`. This way, the
    method will return `true` only if the age for this instance is lower than the
    age for `otherAnimal`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isYoungerThan`：此方法在`otherAnimal`参数中接收一个`VirtualAnimal`实例，并返回在此实例的`age`字段值和`otherAnimal.age`之间应用小于运算符的结果。这样，只有当此实例的年龄小于`otherAnimal`的年龄时，该方法才会返回`true`。'
- en: '`isOlderThan`: This method receives a `VirtualAnimal` instance in the `otherAnimal`
    argument and returns the result of applying the greater than operator between
    the value of the `age` field for this instance and `otherAnimal.age`. This way,
    the method will return `true` only if the age for this instance is greater than
    the age for `otherAnimal`.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isOlderThan`：此方法在`otherAnimal`参数中接收一个`VirtualAnimal`实例，并返回在此实例的`age`字段值和`otherAnimal.age`之间应用大于运算符的结果。这样，只有当此实例的年龄大于`otherAnimal`的年龄时，该方法才会返回`true`。'
- en: If we execute the following line in JShell after declaring the `VirtualAnimal`
    class, Java will generate a fatal error and indicate that the `VirtualAnimal`
    class is abstract and that it cannot be instantiated. The code file for the sample
    is included in the `java_9_oop_chapter_06_01` folder, in the `example06_02.java`
    file.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在声明`VirtualAnimal`类之后在JShell中执行以下行，Java将生成致命错误，并指出`VirtualAnimal`类是抽象的，不能被实例化。示例的代码文件包含在`java_9_oop_chapter_06_01`文件夹中的`example06_02.java`文件中。
- en: '[PRE1]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot shows the results of the execution of the previous
    code in JShell:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在JShell中执行上一个代码的结果：
- en: '![Creating an abstract base class](img/00067.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![创建抽象基类](img/00067.jpeg)'
- en: Declaring classes that inherit from another class
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明从另一个类继承的类
- en: Now we will create another abstract class. Specifically, we will create a subclass
    of the recently created `VirtualAnimal` abstract class. The following lines show
    the code for the `VirtualMammal` abstract class that extends the `VirtualAnimal`
    class. Note the `abstract class` keywords followed by the class name, `VirtualMammal`,
    the `extends` keyword, and `VirtualAnimal`, that is, the superclass.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建另一个抽象类。具体来说，我们将创建一个最近创建的`VirtualAnimal`抽象类的子类。以下行显示了扩展`VirtualAnimal`类的`VirtualMammal`抽象类的代码。请注意`abstract
    class`关键字后面跟着类名`VirtualMammal`，`extends`关键字和`VirtualAnimal`，即超类。
- en: The class name that follows the `extends` keyword indicates the superclass from
    which the new class inherits in the class definition. The code file for the sample
    is included in the `java_9_oop_chapter_06_01` folder, in the `example06_03.java`
    file.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义中，跟在`extends`关键字后面的类名表示新类从中继承的超类。示例的代码文件包含在`java_9_oop_chapter_06_01`文件夹中的`example06_03.java`文件中。
- en: '[PRE2]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `VirtualMammal` abstract class inherits the members from the previously
    declared `VirtualAnimal` abstract class and adds a new `boolean` mutable field
    named `isPregnant`. The new abstract class declares two constructors. One of the
    constructors requires an `age` value to create an instance of the class, as it
    happened with the `VirtualAnimal` constructor. The other constructor requires
    the `age` and `isPregnant` values.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualMammal`抽象类继承了先前声明的`VirtualAnimal`抽象类的成员，并添加了一个名为`isPregnant`的新的`boolean`可变字段。新的抽象类声明了两个构造函数。其中一个构造函数需要一个`age`值来创建类的实例，就像`VirtualAnimal`构造函数一样。另一个构造函数需要`age`和`isPregnant`值。'
- en: If we create an instance of this class with just one `age` argument, Java will
    use the first constructor. If we create an instance of this class with two arguments,
    an `int` value for `age` and a `boolean` value for `isPregnant`, Java will use
    the second constructor.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只用一个 `age` 参数创建这个类的实例，Java 将使用第一个构造函数。如果我们用两个参数创建这个类的实例，一个是 `age` 的 `int`
    值，一个是 `isPregnant` 的 `boolean` 值，Java 将使用第二个构造函数。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We have overloaded the constructor and provided two different constructors.
    We won't use these constructors with the `new` keyword because we are declaring
    an abstract class. However, we will be able to call these constructors from subclasses
    by using the `super` keyword.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重载了构造函数并提供了两个不同的构造函数。我们不会使用 `new` 关键字来使用这些构造函数，因为我们正在声明一个抽象类。但是，我们将能够通过使用
    `super` 关键字从子类中调用这些构造函数。
- en: The first constructor that requires the `isPregnant` argument uses the `super`
    keyword to call the constructor from the base class or superclass, that is, the
    constructor defined in the `VirtualAnimal` class that requires the `age` argument.
    After the constructor defined in the superclass finishes its execution, the code
    sets the value for the `isPregnant` mutable field and prints a message indicating
    that a virtual mammal has been created.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 需要 `isPregnant` 参数的第一个构造函数使用 `super` 关键字来调用基类或超类中的构造函数，也就是在 `VirtualAnimal`
    类中定义的需要 `age` 参数的构造函数。在超类中定义的构造函数执行完毕后，代码会设置 `isPregnant` 可变字段的值，并打印一条消息，指示已创建了一个虚拟哺乳动物。
- en: Tip
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We use the `super` keyword to reference the superclass, and we can use this
    keyword to call any constructor defined in the superclass. In Java 9, subclasses
    do not inherit the constructors from its superclasses. In other programming languages,
    subclasses inherit constructors or initializers, and therefore, it is very important
    to understand that this doesn't happen in Java 9.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `super` 关键字来引用超类，并且可以使用这个关键字来调用超类中定义的任何构造函数。在Java 9中，子类不会继承其超类的构造函数。在其他编程语言中，子类会继承构造函数或初始化程序，因此，非常重要的是要理解在Java
    9中这种情况并不会发生。
- en: The second constructor uses the `this` keyword to call the previously explained
    constructor with the received `age` and with `false` as the value for the `isPregnant`
    argument.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数使用 `this` 关键字来调用先前解释的构造函数，接收 `age` 和 `false` 作为 `isPregnant` 参数的值。
- en: We will create another abstract class. Specifically, we will create a subclass
    of the recently created `VirtualMammal` abstract class. The following lines show
    the code for the `VirtualDomesticMammal` abstract class that extends the `VirtualMammal`
    class. Note the `abstract class` keywords followed by the class name, `VirtualDomesticMammal`,
    the `extends` keyword, and `VirtualMammal`, that is, the superclass. The class
    name that follows the `extends` keyword indicates the superclass from which the
    new class inherits in the class definition. The code file for the sample is included
    in the `java_9_oop_chapter_06_01` folder, in the `example06_04.java` file.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建另一个抽象类。具体来说，我们将创建一个最近创建的 `VirtualMammal` 抽象类的子类。以下几行显示了扩展 `VirtualMammal`
    类的 `VirtualDomesticMammal` 抽象类的代码。注意 `abstract class` 关键字后面跟着类名 `VirtualDomesticMammal`，`extends`
    关键字和 `VirtualMammal`，也就是超类。跟在 `extends` 关键字后面的类名指示了新类在类定义中继承的超类。示例的代码文件包含在 `java_9_oop_chapter_06_01`
    文件夹中的 `example06_04.java` 文件中。
- en: '[PRE3]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `VirtualDomesticMammal` abstract class inherits the members from the previously
    declared `VirtualMammal` abstract class. It is important to understand that the
    new class also inherits the members that the superclass inherited from its superclass,
    that is, from the `VirtualAnimal` abstract class. For example, our new class inherits
    the `age` immutable field declared in the `VirtualAnimal` abstract class and all
    the other members declared in this class.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualDomesticMammal` 抽象类继承了先前声明的 `VirtualMammal` 抽象类的成员。重要的是要理解，新类也继承了超类从其超类继承的成员，也就是从
    `VirtualAnimal` 抽象类继承的成员。例如，我们的新类继承了在 `VirtualAnimal` 抽象类中声明的 `age` 不可变字段以及在这个类中声明的所有其他成员。'
- en: 'The `VirtualDomesticMammal` class adds a new `String` immutable field called
    `name` and a new `String` mutable field named `favoriteToy`. The new abstract
    class declares two constructors. One of the constructors requires four arguments
    to create an instance of the class: `age`, `isPregnant`, `name`, and `favoriteToy`.
    The other constructor requires all the arguments except `isPregnant`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualDomesticMammal` 类添加了一个名为 `name` 的新的不可变字段和一个名为 `favoriteToy` 的新的可变字段。这个新的抽象类声明了两个构造函数。其中一个构造函数需要四个参数来创建类的实例：`age`、`isPregnant`、`name`
    和 `favoriteToy`。另一个构造函数需要除了 `isPregnant` 之外的所有参数。'
- en: 'The first constructor that requires the four arguments uses the `super` keyword
    to call the constructor from the base class or superclass, that is, the constructor
    defined in the `VirtualMammal` class that requires two arguments: `age` and `isPregnant`.
    After the constructor defined in the superclass finishes its execution, the code
    sets the value for the `name` and `favoriteToy` fields and prints a message indicating
    that a virtual domestic mammal has been created.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 需要四个参数的第一个构造函数使用 `super` 关键字来调用基类或超类中的构造函数，也就是在 `VirtualMammal` 类中定义的需要两个参数
    `age` 和 `isPregnant` 的构造函数。在超类中定义的构造函数执行完毕后，代码会设置 `name` 和 `favoriteToy` 字段的值，并打印一条消息，指示已创建了一个虚拟家养哺乳动物。
- en: The second constructor uses the `this` keyword to call the previously explained
    constructor with the received arguments and with `false` as the value for the
    `isPregnant` argument.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个构造函数使用 `this` 关键字来调用先前解释的构造函数，接收参数和 `false` 作为 `isPregnant` 参数的值。
- en: Finally, the class declares a `talk` method that displays a message with the
    `name` value followed by a colon (`:`) and `says something`. Note that we will
    be able to override this method in any subclass of `VirtualDomesticMammal` because
    each virtual domestic mammal has a different way of talking.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个类声明了一个`talk`方法，显示了一个以`name`值开头，后跟一个冒号(`:`)和`says something`的消息。请注意，我们可以在`VirtualDomesticMammal`的任何子类中覆盖这个方法，因为每个虚拟家养哺乳动物都有自己不同的说话方式。
- en: Overriding and overloading methods
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 覆盖和重载方法
- en: Java allows us to define a method with the same name many times with different
    arguments. This feature is known as **method overloading**. When we created the
    previous abstract classes, we overloaded the constructor.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Java允许我们多次使用相同的方法名定义不同参数的方法。这个特性被称为**方法重载**。在之前创建的抽象类中，我们重载了构造函数。
- en: For example, we can take advantage of method overloading to define multiple
    versions of the `neigh` and `nicker` method that we have to define in the `VirtualHorse`
    abstract class. However, it is very important to avoid code duplication when we
    overload methods.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以利用方法重载来定义`VirtualHorse`抽象类中必须定义的`neigh`和`nicker`方法的多个版本。然而，在重载方法时，避免代码重复是非常重要的。
- en: Sometimes, we define a method in a class, and we know that a subclass might
    need to provide a different version of the method. A clear example is the `talk`
    method we defined in the `VirtualDomesticMammal` class. When a subclass provides
    a different implementation of a method defined in a superclass with the same name,
    arguments, and return type, we say that we are **overriding** a method. When we
    override a method, the implementation in the subclass overwrites the code provided
    in the superclass.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们在一个类中定义一个方法，我们知道子类可能需要提供一个不同版本的方法。一个明显的例子就是我们在`VirtualDomesticMammal`类中定义的`talk`方法。当一个子类提供了一个与超类中同名、参数和返回类型相同的方法的不同实现时，我们称之为**覆盖**方法。当我们覆盖一个方法时，子类中的实现会覆盖超类中提供的代码。
- en: '[PRE4]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `VirtualHorse` class overrides the `talk` method inherited from `VirtualDomesticMammal`.
    The code just invokes the `nicker` method without parameters because horses don't
    talk, they nicker. The method doesn't invoke the method with the same name for
    its superclass; that is, we don't use the `super` keyword to invoke the `talk`
    method defined in `VirtualDomesticMammal`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualHorse`类覆盖了从`VirtualDomesticMammal`继承的`talk`方法。代码只是调用了没有参数的`nicker`方法，因为马不会说话，它们会嘶叫。这个方法不会调用其超类中同名的方法；也就是说，我们没有使用`super`关键字来调用`VirtualDomesticMammal`中定义的`talk`方法。'
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We use the `@Override` annotation before the method declaration to inform the
    Java 9 compiler that the method is meant to override the method with the same
    name declared in a superclass. It isn't mandatory to add this annotation when
    we override methods, but it is a good practice to include it and we will always
    use it when we override methods because it helps to prevent errors. For example,
    in case we have a typo and we write `tak()` instead of `talk()` as the method
    name and arguments, the usage of the `@Override` annotation makes the Java 9 compiler
    generate an error because the `talk` method marked with `@Override` fails to override
    a method with this name and arguments in one of the superclasses.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在方法声明之前使用`@Override`注解来通知Java 9编译器，该方法意在覆盖在超类中声明的同名方法。当我们覆盖方法时，添加这个注解并不是强制的，但是将其包括进去是一个好习惯，我们在覆盖方法时总是会使用它，因为它有助于防止错误。例如，如果我们在方法名和参数中写成了`tak()`而不是`talk()`，使用`@Override`注解会使Java
    9编译器生成一个错误，因为标记为`@Override`的`talk`方法未能成功覆盖其中一个超类中具有相同名称和参数的方法。
- en: 'The `nicker` method is overloaded with four declarations with different arguments.
    The following lines show the four different declarations included within the class
    body:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`nicker`方法被重载了四次，使用了不同的参数声明。以下几行展示了类体中包括的四个不同声明：'
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This way, we can call any of the defined `nicker` methods based on the provided
    arguments. The four methods end up invoking the `printNicker` public method with
    different default values for the arguments with the same names not provided in
    the call to `nicker`. The method calls the `printSoundInWords` public method with
    `"Nicker "` as the value for the `soundInWords` arguments and the other arguments
    set to the received arguments that have the same names. This way, the `printNicker`
    method builds and prints a nicker message according to the specified number of
    times (`times`), the optional destination virtual domestic mammal (`otherDomesticMammal`),
    and whether the horse is angry or not (`isAngry`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以根据提供的参数调用任何定义的`nicker`方法。这四个方法最终都会调用`printNicker`公共方法，使用不同的默认值来调用具有相同名称但未在`nicker`调用中提供的参数。该方法调用`printSoundInWords`公共方法，将`"Nicker
    "`作为`soundInWords`参数的值，并将其他参数设置为接收到的具有相同名称的参数。这样，`printNicker`方法根据指定的次数(`times`)、可选的目标虚拟家养哺乳动物(`otherDomesticMammal`)以及马是否生气(`isAngry`)来构建并打印嘶叫消息。
- en: The `VirtualHorse` class uses a similar approach for the `neigh` method. This
    method is also overloaded with four declarations with different arguments. The
    following lines show the four different declarations included within the class
    body. They have the same arguments we just analyzed for the `nicker` method.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualHorse`类对`neigh`方法也使用了类似的方法。这个方法也被重载了四次，使用了不同的参数声明。以下几行展示了类体中包括的四个不同声明。它们使用了我们刚刚分析过的`nicker`方法的相同参数。'
- en: '[PRE11]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This way, we can call any of the defined `neigh` methods based on the provided
    arguments. The four methods end up invoking the `printNeigh` public method with
    different default values for the arguments with the same names not provided in
    the call to `nicker`. The method calls the `printSoundInWords` public method with
    `"Neigh "` as the value for the `soundInWords` arguments and the other arguments
    set to the received arguments that have the same names.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以根据提供的参数调用任何定义的`neigh`方法。这四种方法最终会使用不同的默认值调用`printNeigh`公共方法，这些默认值是与调用`nicker`时未提供的同名参数。该方法调用`printSoundInWords`公共方法，将`"Neigh
    "`作为`soundInWords`参数的值，并将其他参数设置为具有相同名称的接收参数。
- en: Test your knowledge
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'In Java 9, a subclass:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java 9中，一个子类：
- en: Inherits all the constructors from its superclass.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承其超类的所有构造函数。
- en: Doesn't inherit any constructor from its superclass.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不继承任何构造函数。
- en: Inherits the constructor with the largest number of arguments from its superclass.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其超类继承具有最大数量参数的构造函数。
- en: 'We can declare abstract methods:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以声明抽象方法：
- en: In any class.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何类中。
- en: Only in an abstract class.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只在抽象类中。
- en: Only in a concrete subclass of an abstract class.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只在抽象类的具体子类中。
- en: 'A concrete subclass of any abstract class:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何抽象类的具体子类：
- en: Must provide an implementation for all the inherited abstract methods.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须为所有继承的抽象方法提供实现。
- en: Must provide an implementation for all the inherited constructors.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须为所有继承的构造函数提供实现。
- en: Must provide an implementation for all the inherited abstract fields.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须为所有继承的抽象字段提供实现。
- en: 'Which of the following lines declare an abstract class named `Dog` as a subclass
    of `VirtualAnimal`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行声明了一个名为`Dog`的抽象类，作为`VirtualAnimal`的子类：
- en: '`public abstract class Dog subclasses VirtualAnimal`'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public abstract class Dog subclasses VirtualAnimal`'
- en: '`public abstract Dog subclasses VirtualAnimal`'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public abstract Dog subclasses VirtualAnimal`'
- en: '`public abstract class Dog extends VirtualAnimal`'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`public abstract class Dog extends VirtualAnimal`'
- en: 'Which of the following annotations indicated before a method''s declaration
    informs the Java 9 compiler that the method is meant to override the method with
    the same name declared in a superclass:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在方法声明之前指示Java 9编译器该方法意味着重写超类中同名方法的注解是：
- en: '`@Overridden`'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Overridden`'
- en: '`@OverrideMethod`'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@OverrideMethod`'
- en: '`@Override`'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@Override`'
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned the difference between abstract and concrete classes.
    We learned how to take advantage of simple inheritance to specialize a base abstract
    class. We designed many classes from top to bottom using chained constructors,
    immutable fields, mutable fields, and instance methods.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了抽象类和具体类之间的区别。我们学会了如何利用简单的继承来专门化基本抽象类。我们设计了许多类，从上到下使用链接的构造函数，不可变字段，可变字段和实例方法。
- en: Then we coded many of these classes in JShell, taking advantage of different
    features provided by Java 9\. We overloaded constructors, overrode, and overloaded
    instance methods, and we took advantage of a special annotation to make overridden
    methods.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在JShell中编写了许多这些类，利用了Java 9提供的不同特性。我们重载了构造函数，重写和重载了实例方法，并利用了一个特殊的注解来重写方法。
- en: Now that you have learned about inheritance, abstraction, extension, and specialization,
    we are ready to finish coding the additional classes and understand how to work
    with typecasting and polymorphism, which are the topics we are going to discuss
    in the next chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了继承，抽象，扩展和专门化，我们准备完成编写其他类，并了解如何使用类型转换和多态，这是我们将在下一章讨论的主题。
