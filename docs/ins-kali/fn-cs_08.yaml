- en: Chapter 8. Optimizing the Code using Laziness and Caching Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。使用懒惰和缓存技术优化代码
- en: 'We discussed recursion, which help us to iterate sequences easily, in the previous
    chapter. Furthermore, we need to discuss about optimizing code since it is an
    essential technique if we want to develop a good program. In a functional approach,
    we can use laziness and caching techniques to make our code efficient so that
    it will run faster. By discussing laziness and caching techniques, we will be
    able to develop efficient code. To learn more about laziness and caching techniques,
    in this chapter, we will discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中讨论了递归，它帮助我们轻松地迭代序列。此外，我们需要讨论优化代码，因为这是一个必要的技术，如果我们想要开发一个好的程序。在函数方法中，我们可以使用懒惰和缓存技术来使我们的代码更有效，从而使其运行更快。通过讨论懒惰和缓存技术，我们将能够开发出高效的代码。在本章中，我们将讨论以下主题以了解更多关于懒惰和缓存技术的知识：
- en: 'Implementing laziness in our code: lazy enumeration, lazy evaluation, nonstrict
    evaluation, and lazy initialization'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的代码中实现懒惰：懒惰枚举、懒惰评估、非严格评估和懒惰初始化
- en: The benefit of being lazy
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒惰的好处
- en: Caching expensive resources using precomputation and memoization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预计算和记忆化缓存昂贵的资源
- en: Introduction to laziness
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒惰的介绍
- en: When we talk about being lazy in our daily activity, we might think about something
    we don't do but we actually have to do. Or, we might put off doing something just
    because we are lazy. In functional programming, laziness is analogous to our laziness
    in daily activities. The execution of particular code is deferred due to the concept
    of laziness thinking. In [Chapter 5](text00039.html#page "Chapter 5. Querying
    Any Collection Easily with LINQ") , *Querying Any Collection Easily with LINQ*
    we mentioned that LINQ implemented deferred execution when querying data from
    a collection.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论日常活动中的懒惰时，我们可能会想到一些我们不做但实际上必须做的事情。或者，我们可能因为懒惰而推迟做某事。在函数式编程中，懒惰类似于我们在日常活动中的懒惰。由于懒惰思维的概念，特定代码的执行被推迟。在[第5章](text00039.html#page
    "第5章。使用LINQ轻松查询任何集合")中，*使用LINQ轻松查询任何集合*，我们提到LINQ在查询数据时实现了延迟执行。
- en: The query will be executed only when it's enumerated. Now, let's discuss the
    laziness concept we can use in the functional approach.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 查询只有在枚举时才会执行。现在，让我们讨论一下我们可以在函数方法中使用的懒惰概念。
- en: Lazy enumeration
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒惰枚举
- en: In the .NET framework, there are some techniques to enumerate a collection of
    data, such as array and `List<T>` . However, implicitly, they are eager evaluations
    since in an array, we have to define its size first and then fill in the allocated
    memory before we use it. `List<T>` has a similar concept compared to array. It
    adopts the array mechanism. The difference between these two enumeration techniques
    is that we can easily expand the size in `List<T>` rather than array.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET框架中，有一些枚举数据集合的技术，例如数组和`List<T>`。然而，从内在上来说，它们是急切的评估，因为在数组中，我们必须先定义其大小，然后填充分配的内存，然后再使用它。`List<T>`与数组相比具有类似的概念。它采用了数组机制。这两种枚举技术之间的区别在于我们可以很容易地扩展`List<T>`的大小，而不是数组。
- en: In contrast, the .NET framework has `IEnumerable<T>` to enumerate data collection,
    and fortunately, it will be evaluated lazily. Actually, array and `List<T>` implement
    the `IEnumerable<T>` interface, but because it has to be filled by data it has
    to be eagerly evaluated. We used this `IEnumerable<T>` interface when we dealt
    with LINQ in [Chapter 5](text00039.html#page "Chapter 5. Querying Any Collection
    Easily with LINQ") , *Querying Any Collection Easily with LINQ* .
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，.NET框架有`IEnumerable<T>`来枚举数据集合，并且幸运的是，它将被懒惰地评估。实际上，数组和`List<T>`实现了`IEnumerable<T>`接口，但由于它必须由数据填充，因此必须急切地评估。在[第5章](text00039.html#page
    "第5章。使用LINQ轻松查询任何集合")中，*使用LINQ轻松查询任何集合*，我们在处理LINQ时使用了这个`IEnumerable<T>`接口。
- en: 'The `IEnumerable<T>` interface implements the `IEnumerable` interface, which
    is defined like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>`接口实现了`IEnumerable`接口，其定义如下：'
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There is only a single method that the `IEnumerable<T>` interface has: `GetEnumerator()`
    . The definition of this method is similar to what is shown in the following code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEnumerable<T>`接口只有一个方法：`GetEnumerator()`。该方法的定义与下面的代码中所示的类似：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, the `GetEnumerator()` method returns the `IEnumerator<T>` data
    type. This type has only three methods and a single property. Here are the methods
    and properties it has:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`GetEnumerator()`方法返回`IEnumerator<T>`数据类型。该类型只有三种方法和一个属性。以下是它具有的方法和属性：
- en: '`Current` : This is a property that stores the element of the collection for
    the current position of the enumerator.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Current`：这是一个存储枚举器当前位置的集合元素的属性。'
- en: '`Reset()` : This is a method that sets the enumerator to the initial position,
    which is before the first element of the collection. The index of the initial
    position is usually *-1* (minus one).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reset()`：这是一个将枚举器设置为初始位置的方法，即在集合的第一个元素之前。初始位置的索引通常是*-1*（减一）。'
- en: '`MoveNext()` : This is a method to move the enumerator to the next collection
    element.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MoveNext()`：这是一个将枚举器移动到下一个集合元素的方法。'
- en: '`Dispose()` : This is a method to free, release, or reset unmanaged resources.
    It''s inherited from the `IDisposable` interface.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dispose()`：这是一个释放、释放或重置非托管资源的方法。它是从`IDisposable`接口继承而来的。'
- en: 'Now, let''s play with the Fibonacci algorithm, which will generate infinite
    numbers. The algorithm will generate sequences by adding the previous two elements.
    In mathematical terms, the formula can be defined as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们玩玩斐波那契算法，它将生成无限的数字。该算法将通过添加前两个元素来生成序列。在数学术语中，该公式可以定义如下：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first two numbers for the calculation of this algorithm can be 0 and 1 or
    1 and 1.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的计算的前两个数字可以是0和1或1和1。
- en: 'Using this algorithm, we are going to prove that the `IEnumerable` interface
    is a lazy evaluation. So, we create a class named `FibonacciNumbers` , which implements
    the `IEnumerable<Int64>` interface that we can find in the `LazyEnumeration.csproj`
    project, as shown in the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个算法，我们将证明`IEnumerable`接口是一种惰性求值。因此，我们创建了一个名为`FibonacciNumbers`的类，它实现了`IEnumerable<Int64>`接口，我们可以在`LazyEnumeration.csproj`项目中找到，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since the `FibonacciNumbers` class implements the `IEnumerable<T>` interface,
    it has the `GetEnumerator()` method, as we discussed earlier, to enumerate the
    data collection. And because the `IEnumerable<T>` interface implements the `IEnumerator<T>`
    interface, we create the `FibEnumerator` class, as shown in the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`FibonacciNumbers`类实现了`IEnumerable<T>`接口，它具有我们之前讨论过的`GetEnumerator()`方法来枚举数据集合。并且因为`IEnumerable<T>`接口实现了`IEnumerator<T>`接口，我们创建了`FibEnumerator`类，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now, we have the `FibEnumerator` class that implements the `IEnumerator<T>`
    interface. Since the class implements `IEnumerator<T>` , it has the `Reset()`
    , `MoveNext()` , and `Dispose()` methods, as we have discussed already. It also
    has the `Current` property from the implementation of the `IEnumerator<T>` interface.
    We add the `Last` property to save the last current number.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了实现`IEnumerator<T>`接口的`FibEnumerator`类。由于该类实现了`IEnumerator<T>`，它具有我们已经讨论过的`Reset()`、`MoveNext()`和`Dispose()`方法。它还具有从`IEnumerator<T>`接口的实现中添加的`Current`属性。我们添加了`Last`属性来保存最后一个当前数字。
- en: 'Now, it''s time to create the caller to instantiate the `FibonacciNumbers`
    class. We can create the `GetFibonnacciNumbers()` function, which has an implementation
    similar to what is shown in the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建调用者来实例化`FibonacciNumbers`类了。我们可以创建`GetFibonnacciNumbers()`函数，其实现类似于以下代码所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because the `FibonacciNumbers` class will enumerate infinite numbers, we have
    to use the `Take()` method, as shown in the following code snippet, in order not
    to create an infinite loop:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`FibonacciNumbers`类将枚举无限数字，我们必须使用`Take()`方法，如下面的代码片段所示，以免创建无限循环：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Suppose we need to enumerate 40 numbers from the sequence; we can pass 40 as
    an argument to the `GetFibonnacciNumbers()` function, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要从序列中枚举40个数字；我们可以将40作为参数传递给`GetFibonnacciNumbers()`函数，如下所示：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And if we run the preceding function, we will get the following output on the
    console:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述函数，将在控制台上获得以下输出：
- en: '![Lazy enumeration](img/Image00094.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![惰性枚举](img/Image00094.jpg)'
- en: We can get the preceding output on the console since `IEnumerable` is a lazy
    evaluation. This is because the `MoveNext()` method will only be called to calculate
    the result if it's asked to do so. Imagine if it's not lazy and is always called;
    then, our previous code will spin and result in an infinite loop.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在控制台上获得前面的输出，因为`IEnumerable`是一种惰性求值。这是因为只有在要求时才会调用`MoveNext()`方法来计算结果。想象一下，如果它不是惰性的并且总是被调用；那么，我们之前的代码将会旋转并导致无限循环。
- en: Lazy evaluation
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惰性求值
- en: 'The simple example we have on lazy evaluation is when we deal with two Boolean
    statements and need to compare them. Let''s take a look at the following code,
    which demonstrates lazy evaluation, which we can find in the `SimpleLazyEvaluation.csproj`
    project:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在惰性求值中的一个简单例子是当我们处理两个布尔语句并需要比较它们时。让我们看一下以下代码，它演示了我们可以在`SimpleLazyEvaluation.csproj`项目中找到的惰性求值：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And here is the `MemberData` class we use in the preceding code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在前面代码中使用的`MemberData`类：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And if we run the preceding `GetMember()` method, we will get the following
    output on the console:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`GetMember()`方法，将在控制台上获得以下输出：
- en: '![Lazy evaluation](img/Image00095.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![惰性求值](img/Image00095.jpg)'
- en: 'As we know, when we use the `||`  (OR) operator in the Boolean expression,
    it will result in `TRUE` if at least one expression is `TRUE` . Now take a look
    at the following code snippet:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在布尔表达式中使用`||`（OR）运算符时，如果至少有一个表达式为`TRUE`，则结果为`TRUE`。现在看一下以下代码片段：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, when the compiler finds that member `!= null` is `FALSE`
    , it then evaluates the other expression, which is `member.Age > 50` . Since the
    member is null, it has no `Age` property; so, when we try to access this property,
    it will throw an exception.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，当编译器发现成员`!= null`为`FALSE`时，它会评估另一个表达式，即`member.Age > 50`。由于成员为空，它没有`Age`属性；因此，当我们尝试访问此属性时，它将抛出异常。
- en: 'Now, let''s refactor the preceding code snippet into the following code using
    the `&&` (AND) operator:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将前面的代码片段重构为以下代码，使用`&&`（AND）运算符：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The complete method named `GetMemberANDOperator()` will be as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`GetMemberANDOperator()`的完整方法将如下所示：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we run the preceding `GetMemberANDOperator()` method, we will get the following
    output on the console:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`GetMemberANDOperator()`方法，将在控制台上获得以下输出：
- en: '![Lazy evaluation](img/Image00096.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![惰性求值](img/Image00096.jpg)'
- en: Now, the `if` statement has been successfully executed and it results in `FALSE`
    after being evaluated. However, the `member.Age > 50` expression is never evaluated
    in this case so that the exception is not thrown. The reason why the `member.Age
    > 50` expression is not evaluated is that the compiler is too lazy to do it since
    the first expression, `member != null` , is `FALSE` and the result of this `&&`
    logical operation will result in `FALSE` regardless of the result of other expression.
    We can now say that laziness is ignoring another expression when it can decide
    the result using only one expression.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`if`语句已成功执行，并在评估后得出`FALSE`。然而，在这种情况下，`member.Age > 50`表达式从未被评估，因此不会抛出异常。`member.Age
    > 50`表达式不被评估的原因是编译器太懒了，因为第一个表达式`member != null`为`FALSE`，而这个`&&`逻辑操作的结果将始终为`FALSE`，而不管其他表达式的结果如何。现在我们可以说，懒惰是在可以仅使用一个表达式决定结果时忽略另一个表达式。
- en: Nonstrict evaluation
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非严格求值
- en: 'Some people may think that lazy evaluation is synonymous with nonstrict evaluation.
    However, it''s not actually synonymous since the evaluation of a particular expression
    will be ignored if it''s not needed in the lazy evaluation, while the reduction
    of evaluation will be applied in a nonstrict evaluation. Let''s take a look at
    the following code in order to distinguish strict and nonstrict evaluation, which
    we can find in the `NonStrictEvaluation.csproj` project:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能认为惰性评估与非严格评估是同义词。然而，实际上并不是同义词，因为在惰性评估中，如果不需要特定表达式的评估，它将被忽略，而在非严格评估中将应用评估的简化。让我们看一下下面的代码，以区分严格和非严格评估，我们可以在`NonStrictEvaluation.csproj`项目中找到：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we are going to calculate the formula of `x + (y * z)`
    . The `InnerFormula()` function will calculate the multiplication of `y` and `z`
    , while the `OuterFormula()` function will calculate the addition of `x` and the
    result of `y * z` . When evaluating the formula in strict evaluation, we first
    calculate the `(y * z)` expression to retrieve the value and then add the result
    to the `x` . The code will be like the following `StrictEvaluation()` function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将计算`x + (y * z)`的公式。`InnerFormula()`函数将计算`y`和`z`的乘法，而`OuterFormula()`函数将计算`x`和`y
    * z`的结果的加法。在严格评估中评估公式时，我们首先计算`(y * z)`表达式以检索值，然后将结果添加到`x`。代码将如下`StrictEvaluation()`函数所示：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, in the preceding code we invoke the `OuterFormula()` function
    like the following code snippet:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的代码片段中所看到的，我们调用`OuterFormula()`函数如下所示：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And for the strict evaluation we discussed earlier, the output we get on the
    console will be as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们之前讨论的严格评估，我们在控制台上得到的输出将如下所示：
- en: '![Nonstrict evaluation](img/Image00097.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![非严格评估](img/Image00097.jpg)'
- en: As you can see in the preceding figure, when we calculate `4 + (3 * 2)` , we
    first calculate the result of `(3 * 2)` and then after getting the result, we
    add it to `4` .
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的图中所看到的，当我们计算`4 + (3 * 2)`时，我们首先计算`(3 * 2)`的结果，然后在获得结果后，将其添加到`4`。
- en: 'Now, let''s compare it with nonstrict evaluation. In nonstrict evaluation,
    the `+` operator is reduced first and then we reduce the inner formula, which
    is `(y * z)` . We will see that the evaluation will be started from the outside
    to the inside. Now let''s refactor the preceding `OuterFormula()` function to
    the `OuterFormulaNonStrict()` function, as shown in the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们与非严格评估进行比较。在非严格评估中，`+`运算符首先被简化，然后我们简化内部公式`(y * z)`。我们将看到评估将从外到内开始。现在让我们将前面的`OuterFormula()`函数重构为`OuterFormulaNonStrict()`函数，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, we modify the second parameter of the function into the `Func<int,
    int, int>` delegate. We will call `OuterFormulaNonStrict()` from the `NonStrictEvaluation()`
    function, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们将函数的第二个参数修改为`Func<int, int, int>`委托。我们将从`NonStrictEvaluation()`函数中调用`OuterFormulaNonStrict()`，如下所示：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we can see that we pass the `InnerFormula()` function
    into the second parameter of the `OuterFormulaNonStrict()` function, as shown
    in the following code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们可以看到我们将`InnerFormula()`函数传递给了`OuterFormulaNonStrict()`函数的第二个参数，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The expression in the preceding code snippet will be evaluated using nonstrict
    evaluation. To prove this, let''s run the `NonStrictEvaluation()` function, and
    we will get the following output on the console:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，将使用非严格评估来评估表达式。为了证明这一点，让我们运行`NonStrictEvaluation()`函数，我们将在控制台上得到以下输出：
- en: '![Nonstrict evaluation](img/Image00098.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![非严格评估](img/Image00098.jpg)'
- en: 'We can see that our expression is evaluated from the outside to the inside.
    The `OuterFormulaNonStrict()` function is run first even though the result of
    the `InnerFormula()` function is not retrieved yet. And if we run the `OuterFormula()`
    function and the `OuterFormulaNonStrict()` function consecutively, we will get
    a clear difference in the order of the evaluation, as shown in the following output
    screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的表达式是从外到内进行评估的。即使尚未检索到`InnerFormula()`函数的结果，也会首先运行`OuterFormulaNonStrict()`函数。如果我们连续运行`OuterFormula()`函数和`OuterFormulaNonStrict()`函数，我们将会清楚地看到评估顺序的不同，如下面的输出截图所示：
- en: '![Nonstrict evaluation](img/Image00099.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![非严格评估](img/Image00099.jpg)'
- en: Now, we can compare the difference. In strict evaluation, the calculation of
    `(3 * 2)` is run first and then fed to the `(4 + InnerFormula())` expression,
    while in nonstrict evaluation, the `(4 + InnerFormula())` expression is run before
    the calculation of `(3 * 2)` .
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以比较一下。在严格评估中，首先运行`(3 * 2)`的计算，然后将其输入到`(4 + InnerFormula())`表达式中，而在非严格评估中，先运行`(4
    + InnerFormula())`表达式，然后再计算`(3 * 2)`。
- en: Lazy initialization
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惰性初始化
- en: 'Lazy initialization is an optimizing technique where the object creation is
    deferred until it is used. It means that we can define an object but it won''t
    be initialized if the member of the object is not accessed yet. C# introduced
    the `Lazy<T>` class in C# 4.0, and we can use to lazily initialize the object.
    Now, let''s take a look at the following code in order to demonstrate the lazy
    initialization that we can find in the `LazyInitialization.csproj` project:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟初始化是一种优化技术，其中对象的创建被推迟直到使用它。这意味着我们可以定义一个对象，但如果尚未访问对象的成员，则不会初始化该对象。C#在C# 4.0中引入了`Lazy<T>`类，我们可以使用它来延迟初始化对象。现在，让我们看一下下面的代码，以演示我们可以在`LazyInitialization.csproj`项目中找到的延迟初始化：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We define the `PersonName` class as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义`PersonName`类如下：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see in the preceding `LazyInitName()` function implementation, we
    lazily initialize the `PersonName` object using the `Lazy<T>` class, as shown
    in the following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的`LazyInitName()`函数实现中所看到的，我们使用`Lazy<T>`类来延迟初始化`PersonName`对象，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By doing this, `PersonName` isn''t actually initialized after we define the
    `pn` variable, like what we usually get when we define the class directly using
    the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，`PersonName`在定义`pn`变量后实际上并没有初始化，就像我们直接使用以下代码定义类时通常得到的那样：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Instead, using lazy initialization we access the object''s member in order
    to initialize it, as discussed earlier. `Lazy<T>` has a property named `Value`
    , which gets the value for the `Lazy<T>` instance. It also has the `IsValueCreated`
    property to indicate whether a value has been created for this `Lazy<T>` instance.
    In the `LazyInitName()` function, we use the `Value` property, as shown in the
    following code snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，使用延迟初始化，我们访问对象的成员以初始化它，如前所述。`Lazy<T>`有一个名为`Value`的属性，用于获取`Lazy<T>`实例的值。它还有一个`IsValueCreated`属性，用于指示是否已为此`Lazy<T>`实例创建了值。在`LazyInitName()`函数中，我们使用`Value`属性，如下所示：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We use `(pn.Value as PersonName).Name` to access the `Name` property of the
    `PersonName` class, which has been instantiated by the `pn` variable. We use the
    `IsValueCreated` property to prove whether or not the `PersonName` class has been
    initialized, as shown in the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`(pn.Value as PersonName).Name`来访问`pn`变量实例化的`PersonName`类的`Name`属性。我们使用`IsValueCreated`属性来证明`PersonName`类是否已经初始化，如下所示：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let''s run the `LazyInitName()` function and pass `Matthew Maxwell` as
    its argument, as shown in the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们运行`LazyInitName()`函数，并将`Matthew Maxwell`作为其参数传递，如下所示：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will get the following output on the console:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在控制台上获得以下输出：
- en: '![Lazy initialization](img/Image00100.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![延迟初始化](img/Image00100.jpg)'
- en: From the preceding screenshot, we have five lines of information. The first
    line we get is when `PersonName` is defined. We then check the value of the `IsValueCreated`
    property to find whether `PersonName` has been initialized. We get the `FALSE`
    result, which means that it's not initialized yet; so we have the second line
    of the information on the console. The next two lines are the interesting things
    we get from lazy initialization. When we access the `Value` property of the `Lazy<T>`
    class to retrieve the `Name` property of the `PersonName` instance, the code calls
    the constructor of `PersonName` before it accesses the `Name` property of `PersonName`
    class. This is why we have lines 3 and 4 in the preceding console. And after we
    check the `IsValueCreated` property again, we find that `PersonName` has now been
    initialized and the `pn` variable has an instance of `PersonName` .
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，我们获得了五行信息。我们得到的第一行是在定义`PersonName`时。然后我们检查`IsValueCreated`属性的值，以找出`PersonName`是否已经初始化。我们得到了`FALSE`的结果，这意味着它还没有初始化；所以我们在控制台上得到了第二行信息。接下来的两行是我们从延迟初始化中得到的有趣的东西。当我们访问`Lazy<T>`类的`Value`属性以检索`PersonName`实例的`Name`属性时，代码在访问`PersonName`类的`Name`属性之前调用`PersonName`的构造函数。这就是为什么我们在前面的控制台上有第3行和第4行。在我们再次检查`IsValueCreated`属性之后，我们发现`PersonName`现在已经初始化，并且`pn`变量具有`PersonName`的实例。
- en: The advantages and disadvantages of being lazy
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒惰的优缺点
- en: 'We have learned about laziness so far. We can also elaborate the advantages
    of being lazy, such as:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了懒惰。我们还可以详细说明懒惰的优点，比如：
- en: We don't need to pay the initialization time for features we don't use
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要为我们不使用的功能支付初始化时间
- en: The program execution becomes more efficient because sometimes, in the functional
    approach, the order of the execution is not important compared to the imperative
    approach
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序执行变得更加高效，因为有时，在功能性方法中，执行顺序与命令式方法相比并不重要
- en: Being lazy will make a programmer write better code by writing efficient code
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒惰会使程序员通过编写高效的代码来编写更好的代码
- en: 'Besides the advantages, being lazy also has disadvantages, such as:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了优点之外，懒惰也有缺点，比如：
- en: The flow of the application is hard to predict and we can lose control over
    our application sometimes
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的流程很难预测，有时我们会失去对应用程序的控制
- en: The code complexity in laziness can cause a bookkeeping overhead
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 懒惰中的代码复杂性可能会导致簿记开销
- en: Caching expensive resources
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存昂贵的资源
- en: Sometimes, we have to create an expensive resource in our program. It's not
    a problem if we only do it once. It will be a big problem if we do it over and
    over for the same function. Fortunately, in a functional approach, we will get
    the same output if we pass the exact same input or arguments. We can then cache
    this expensive resource and use it again when the passed argument is the same.
    Now we are going to discuss precomputation and memoization in order to cache the
    resources.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们必须在程序中创建昂贵的资源。如果我们只做一次，这不是问题。如果我们为同一个函数一遍又一遍地做同样的事情，那将是一个大问题。幸运的是，在功能性方法中，如果我们传递相同的输入或参数，我们将获得相同的输出。然后，我们可以缓存这些昂贵的资源，并在传递相同的参数时再次使用它。现在我们将讨论预计算和记忆化以缓存资源。
- en: Performing initial computation
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行初始计算
- en: 'One of the caching techniques we have is precomputation, which performs an
    initial computation in order to create a lookup table. This lookup table is used
    to avoid repetitive computation when a particular process is executed. Now we
    are going to create code to compare the difference in the process with and without
    precomputation. Let''s take a look at the following code, which we can find in
    the `Precomputation.csproj` project:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有的缓存技术之一是预计算，它执行初始计算以创建查找表。当执行特定过程时，该查找表用于避免重复计算。现在我们将创建代码来比较使用和不使用预计算的过程中的差异。让我们看一下以下代码，在`Precomputation.csproj`项目中可以找到：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding simple `WithoutPrecomputation()` function will calculate the
    square of the two numbers that we input from 0 to 99\. Suppose we want to calculate
    the number `19` and `85` ; we will get the following output on the console window:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面简单的`WithoutPrecomputation()`函数将计算我们从0到99输入的两个数字的平方。假设我们要计算数字`19`和`85`，我们将在控制台窗口上获得以下输出：
- en: '![Performing initial computation](img/Image00101.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![执行初始计算](img/Image00101.jpg)'
- en: 'As you can see, the function has done its job well. It asks for two input numbers
    from the user with the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该函数已经很好地完成了其工作。它使用以下代码片段向用户请求两个输入数字：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It uses the `Math.Pow()` method in the `System` namespace in order to get to
    the power of n, as shown in the following code snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用“System”命名空间中的“Math.Pow（）”方法来得到n的幂，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can refactor the `WithoutPrecomputation()` function to use precomputation
    techniques so that it doesn''t need any repetition calculation every time the
    user asks to calculate the power of the same numbers by two. The function we are
    going to have will be as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重构“WithoutPrecomputation（）”函数，以使用预计算技术，这样每当用户要求计算相同数字的平方时，它就不需要重复计算。我们将要得到的函数如下：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see in the preceding code, we create a lookup table named `powerOfTwos`
    in the beginning of the function, as shown in the following code snippet:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码中所示，我们在函数开头创建了一个名为“powerOfTwos”的查找表，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Since we ask the user to input a number from 0 to 99, the lookup table will
    store the database of the power of two numbers from the range numbers. Moreover,
    the difference between the `WithPrecomputation()` function and the `WithoutPrecomputation()`
    function is that we have the collection of the power of two result. Now we use
    the `FindThePowerOfTwo()` function, as shown in the following code snippet:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们要求用户输入0到99之间的数字，查找表将存储来自范围数字的两个数字的幂的数据库。此外，“WithPrecomputation（）”函数和“WithoutPrecomputation（）”函数之间的区别在于我们有了两个结果的集合。现在我们使用“FindThePowerOfTwo（）”函数，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `FindThePowerOfTwo()` function will look for the selected number in the
    lookup table, which in this case is `powerOfTwos` . And the implementation of
    the `FindThePowerOfTwo()` function will be as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: “FindThePowerOfTwo（）”函数将在查找表中查找所选数字，本例中为“powerOfTwos”。而“FindThePowerOfTwo（）”函数的实现将如下所示：
- en: '[PRE32]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see, the `FindThePowerOfTwo()` function returns the value of the
    lookup table, whose index we specify with the `baseNumber` parameter. We will
    get the following output on the console if we run the `WithPrecomputation()` function:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，“FindThePowerOfTwo（）”函数返回我们用“baseNumber”参数指定的查找表的值。如果我们运行“WithPrecomputation（）”函数，我们将在控制台上获得以下输出：
- en: '![Performing initial computation](img/Image00102.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![执行初始计算](img/Image00102.jpg)'
- en: Again, we calculate the square of `19` and `85` and, indeed, we have the exact
    same result as what we get when we run the `WithoutPrecomputation()` function.
    Now, we have a lookup table of squared numbers from 0 to 99\. The advantages in
    our program are more effective since every time we ask to calculate the same number
    (`19` and `85` ), it will not need to run the calculation but will look for the
    result in the lookup table.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 再次计算“19”和“85”的平方，确实，我们得到的结果与运行“WithoutPrecomputation（）”函数时得到的完全相同。现在，我们有了一个从0到99的平方数查找表。我们程序中的优势更加有效，因为每次我们要求计算相同的数字（“19”和“85”）时，它都不需要运行计算，而是会在查找表中查找结果。
- en: 'However, the precomputation code we explored earlier is not a functional approach
    since, each time the `FindThePowerOfTwo()` function is called, it will iterate
    the squares again. We can refactor it so that it will be functional using the
    power of currying, a technique to change structure arguments by sequence, which
    we discussed in [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting Functional
    Style in C#") , *Tasting Functional Style in C#* . Now let''s take a look at the
    following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们之前探讨的预计算代码并不是一种功能性方法，因为每次调用“FindThePowerOfTwo（）”函数时，它都会再次迭代平方。我们可以重构它，使其在使用柯里化的幂的情况下变得功能性，这是一种通过顺序更改结构参数的技术，我们在[第1章](text00016.html#ch01
    "第1章。在C#中品尝函数式风格")中讨论过，*在C#中品尝函数式风格*。现在让我们看一下以下代码：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we compare the preceding `WithPrecomputationFunctional()` function with
    the `WithPrecomputation()` function, we can see that it uses the `CurriedPowerOfTwo()`
    function now, as shown in the following code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的“WithPrecomputationFunctional（）”函数与“WithPrecomputation（）”函数进行比较，我们可以看到它现在使用了“CurriedPowerOfTwo（）”函数，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Using the `CurriedPowerOfTwo()` function, we split the function argument so
    that the curried variable can now handle the lookup table and we can call the `WithPrecomputationFunctional()`
    function as many times as we want with no need to iterate the lookup table again.
    The `CurriedPowerOfTwo()` function implementation can be found in the following
    code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“CurriedPowerOfTwo（）”函数，我们分割函数参数，以便柯里化变量现在可以处理查找表，并且我们可以随意调用“WithPrecomputationFunctional（）”函数，而无需再次迭代查找表。以下代码中可以找到“CurriedPowerOfTwo（）”函数的实现：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we run the `WithPrecomputationFunctional()` function, the following output
    will be displayed in our console window:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行“WithPrecomputationFunctional（）”函数，我们的控制台窗口将显示以下输出：
- en: '![Performing initial computation](img/Image00103.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![执行初始计算](img/Image00103.jpg)'
- en: 'Again, we have the exact same output compared to our previous functions: the
    `WithoutPrecomputation()` function and the `WithPrecomputation()` function. We
    have successfully refactored the function and the functional approach has been
    fulfilled in this precomputation technique.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，与我们之前的函数“WithoutPrecomputation（）”函数和“WithPrecomputation（）”函数相比，我们得到了完全相同的输出。我们已成功重构了函数，并且在这种预计算技术中已实现了功能性方法。
- en: Memoization
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备忘录化
- en: Besides performing precomputation techniques to optimize the code, we can also
    use memoization techniques to make our code more optimal. Memoization is the process
    of remembering the result of the function with a specific input. Each time we
    execute a particular function with a specific input argument, the code will remember
    the result. So, each time we call the function with the exact same input argument
    again, the code doesn't need to run the code; instead. it will get it from the
    place it stores the result in.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了执行预计算技术来优化代码之外，我们还可以使用记忆化技术使我们的代码更加优化。记忆化是记住具有特定输入的函数的结果的过程。每次我们用特定的输入参数执行特定的函数时，代码都会记住结果。因此，每次我们再次使用完全相同的输入参数调用函数时，代码就不需要运行代码了；相反。它将从存储结果的位置获取结果。
- en: 'Let''s borrow the repetitive `GetFactorial()` function we discussed in [Chapter
    5](text00039.html#page "Chapter 5. Querying Any Collection Easily with LINQ")
    , *Querying Any Collection Easily with LINQ* and then refactor it in order to
    use the memoization technique. As we know, the implementation of the `GetFactorial()`
    function is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借用我们在[第5章](text00039.html#page "第5章。使用LINQ轻松查询任何集合")中讨论的重复的`GetFactorial()`函数，*使用LINQ轻松查询任何集合*，然后重构它以使用记忆化技术。正如我们所知，`GetFactorial()`函数的实现如下：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To make the `GetFactorial()` function use memoization, we have to save the
    result every time the `GetFactorial()` function returns a value. The refactoring
    code of the preceding `GetFactorial()` function will be as follows and we can
    find it in the `Memoization.csproj` project:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`GetFactorial()`函数使用记忆化，我们必须在`GetFactorial()`函数返回值时保存结果。前面的`GetFactorial()`函数的重构代码将如下所示，并且我们可以在`Memoization.csproj`项目中找到它：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see, we have a `Dictionary` class named `memoizeDict` to store all
    the results when the particular arguments have been passed to the `GetFactorialMemoization()`
    function. The definition of this dictionary is like what is shown in the following
    code snippet:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们有一个名为`memoizeDict`的`Dictionary`类，用于存储当特定参数传递给`GetFactorialMemoization()`函数时的所有结果。该字典的定义如下代码片段所示：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Another difference when we compare the `GetFactorialMemoization()` function
    to the `GetFactorial()` function is that it now saves the result when the `GetFactorialMemoization()`
    function is run with the particular arguments that have been called so far. The
    following code snippet shows the code for this algorithm:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与`GetFactorial()`函数相比，`GetFactorialMemoization()`函数的另一个区别是，当迄今为止已调用具有特定参数的`GetFactorialMemoization()`函数时，它现在保存结果。以下代码片段显示了此算法的代码：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: First, we check whether the particular argument has been passed to the function.
    If so, it doesn't need to run the function; instead, it just retrieves the result
    from the dictionary. If the parameter arguments haven't been passed yet, the function
    is run and we save the result in the dictionary. Using memoization, we can optimize
    the code since we don't need to run the function over and over again if the arguments
    are exactly the same. Suppose we pass 10 to the `GetFactorialMemoization()` function.
    If we run the function again and pass 10 again, the processing speed time will
    increase since it doesn't need to run the repetitive `GetFactorialMemoization()`
    function. Fortunately, by passing 10 to the function parameter, it will also run
    the function with the 1-9 argument since it's a recursive function. The effect
    and the result of the invocation of these 10 items will be saved in the directory
    and calling the function using these arguments will be much faster.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查特定参数是否已传递给函数。如果是，它就不需要运行函数；相反，它只需从字典中检索结果。如果参数尚未传递，函数将运行，并且我们将结果保存在字典中。使用记忆化，我们可以优化代码，因为如果参数完全相同，我们就不需要一遍又一遍地运行函数。假设我们将10传递给`GetFactorialMemoization()`函数。如果我们再次运行函数并再次传递10，处理速度将增加，因为它不需要运行重复的`GetFactorialMemoization()`函数。幸运的是，通过将10传递给函数参数，它还将使用1-9参数运行函数，因为它是一个递归函数。这10个项目的调用效果和结果将保存在目录中，并且使用这些参数调用函数将更快。
- en: 'Now let''s compare the performance of the `GetFactorial()` function with the
    `GetFactorialMemoization()` function. We will pass `9216` as an argument and run
    them it times. The following is the `RunFactorial()` function used to call the
    `GetFactorial()` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们比较`GetFactorial()`函数与`GetFactorialMemoization()`函数的性能。我们将传递`9216`作为参数，并运行它们。以下是用于调用`GetFactorial()`函数的`RunFactorial()`函数：
- en: '[PRE40]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we run the `RunFactorial()` function, we will get the following output on
    the console:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`RunFactorial()`函数，我们将在控制台上得到以下输出：
- en: '![Memoization](img/Image00104.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Memoization](img/Image00104.jpg)'
- en: 'As you can see from the output, we need `281461 ns` in the first invocation
    of the `GetFactorial()` function and about 75,000- 98,000 nanoseconds in the remaining
    invocations. The process speed is almost the same for all invocations since the
    recursive `GetFactorial()` function is invoked everytime. Now let''s move on to
    the following `RunFactorialMemoization()` function in order to call the `GetFactorialMemoization()`
    function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，在第一次调用`GetFactorial()`函数时，我们需要`281461 ns`，而在剩下的调用中需要大约75,000-98,000纳秒。由于递归的`GetFactorial()`函数每次都被调用，所有调用的进程速度几乎相同。现在让我们继续执行以下`RunFactorialMemoization()`函数，以调用`GetFactorialMemoization()`函数：
- en: '[PRE41]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we run the `RunFactorialMemoization()` function, we will get the following
    output on the console:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行`RunFactorialMemoization()`函数，我们将在控制台上得到以下输出：
- en: '![Memoization](img/Image00105.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![Memoization](img/Image00105.jpg)'
- en: Now we can see that, by using memoization, the process speed has increased to
    a great extent. Even though it needs the extra time in the first invocation of
    `GetFactorialMemoization()` , in the invocation 3 to 5, the process becomes faster.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到，通过使用记忆化，进程速度已经大大提高。即使在第一次调用`GetFactorialMemoization()`时需要额外的时间，在第3到5次调用时，进程变得更快。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We discussed that, by being lazy, we can create efficient code. Lazy enumeration
    is useful when we need to iterate an infinite loop so that it will not overflow
    since the `MoveNext()` method in `IEnumerator` will be run only if asked. Also,
    lazy evaluation makes our code run faster because the compiler does not need to
    check all Boolean expressions if one of them has given the result.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了通过懒惰可以创建高效的代码。懒惰枚举在需要迭代无限循环时非常有用，这样就不会溢出，因为`IEnumerator`中的`MoveNext()`方法只有在被要求时才会运行。此外，懒惰评估使我们的代码运行更快，因为编译器不需要检查所有布尔表达式，如果其中一个已经给出结果。
- en: In nonstrict evaluation, we treat a function in programming like we treat a
    mathematical function. Using this evaluation technique, we use the functional
    approach to solve the function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在非严格评估中，我们将编程中的函数视为数学函数。使用这种评估技术，我们使用函数方法来解决函数。
- en: We have also become acquainted with the lazy initialization provided by the
    `Lazy<T>` class to defer the object's initialization, which means that we can
    define an object but it won't be initialized if the member of the object has not
    been accessed yet.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还熟悉了`Lazy<T>`类提供的延迟初始化，这意味着我们可以定义一个对象，但如果尚未访问对象的成员，则不会初始化该对象。
- en: To optimize our code, we discussed caching techniques using precomputation and
    memoization. In precomputation, we prepare something like a lookup table so we
    don't need to run the function with the exact argument; instead, we just need
    to get the result from the table. We also have memoization in order to remember
    the result of the function with a specific input. Using memoization, every time
    we call the function with the exact same input argument again, the code doesn't
    need to run the code; instead, it will get it from the place where it stores the
    result.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化我们的代码，我们讨论了使用预计算和记忆化的缓存技术。在预计算中，我们准备了类似查找表的东西，这样我们就不需要用精确的参数运行函数；相反，我们只需要从表中获取结果。我们还有记忆化，以记住具有特定输入的函数的结果。使用记忆化，每次我们再次使用完全相同的输入参数调用函数时，代码就不需要再次运行代码；相反，它将从存储结果的地方获取结果。
- en: In the next chapter, we will discuss monads and their use in functional programming.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论单子及其在函数式编程中的使用。
