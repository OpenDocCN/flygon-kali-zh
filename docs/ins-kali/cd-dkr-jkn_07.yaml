- en: Continuous Delivery Pipeline
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付流水线
- en: 'We have already covered the most crucial parts of the Continuous Delivery process:
    the commit phase, the artifact repository, automated acceptance testing, and configuration
    management.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了持续交付过程中最关键的部分：提交阶段、构件存储库、自动验收测试和配置管理。
- en: In this chapter, we will focus on the missing parts of the final pipeline, which
    are the environments and infrastructure, application versioning, and nonfunctional
    testing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注最终流水线的缺失部分，即环境和基础设施、应用程序版本控制和非功能性测试。
- en: 'This chapter covers the following points:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下要点：
- en: Designing different software environments and their infrastructures
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计不同的软件环境及其基础设施
- en: Securing the connection between Jenkins agents and servers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护Jenkins代理和服务器之间的连接
- en: Introducing various kinds of nonfunctional tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入各种非功能性测试
- en: Presenting the challenges of nonfunctional tests in the Continuous Delivery
    process
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍持续交付过程中非功能性测试的挑战
- en: Explaining different types of application versioning
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释不同类型的应用程序版本控制
- en: Completing the Continuous Delivery pipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成持续交付流水线
- en: Introducing the concept of smoke testing and adding it to the final pipeline
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍烟雾测试的概念并将其添加到最终流水线中
- en: Environments and infrastructure
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境和基础设施
- en: 'So far, we have always used one Docker host for everything and treated it as
    the virtualization of endless resources where we can deploy everything. Obviously,
    the Docker host can actually be a cluster of machines and we will show how to
    create it using Docker Swarm in the next chapters. However, even if the Docker
    host were unlimited in terms of resources, we still need to think about the underlying
    infrastructure for at least two reasons:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们总是使用一个Docker主机来处理一切，并将其视为无尽资源的虚拟化，我们可以在其中部署一切。显然，Docker主机实际上可以是一组机器，我们将在接下来的章节中展示如何使用Docker
    Swarm创建它。然而，即使Docker主机在资源方面是无限的，我们仍然需要考虑底层基础设施，至少有两个原因：
- en: Physical location of the machines matters
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器的物理位置很重要
- en: No testing should be done on the production physical machines
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不应在生产物理机器上进行测试
- en: Taking these facts into consideration, in this section, we will discuss different
    types of environment, their role in the Continuous Delivery process, and infrastructure
    security aspects.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些事实，在本节中，我们将讨论不同类型的环境，在持续交付过程中的作用以及基础设施安全方面。
- en: Types of environment
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境类型
- en: 'There are four most common environment types: production, staging, QA (testing),
    and development. Let''s discuss each of them and its infrastructure.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种最常见的环境类型：生产、暂存、QA（测试）和开发。让我们讨论每种环境及其基础设施。
- en: Production
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产
- en: Production is the environment that is used by the end user. It exists in every
    company and, of course, it is the most important environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境是最终用户使用的环境。它存在于每家公司中，当然，它是最重要的环境。
- en: 'Let''s look at the following diagram and see how most production environments
    are organized:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的图表，看看大多数生产环境是如何组织的：
- en: '![](assets/3092eae3-1a55-4505-987b-d3aff24db07c.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3092eae3-1a55-4505-987b-d3aff24db07c.png)'
- en: Users access the service through the load balancer, which chooses the exact
    machine. If the application is released in multiple physical locations, then the
    (first) device is usually a DNS-based geographic load balancer. In each location,
    we have a cluster of servers. If we use Docker, then that cluster of servers can
    be hidden behind one or multiple Docker hosts (which are internally composed of
    many machines using Docker Swarm).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过负载均衡器访问服务，负载均衡器选择确切的机器。如果应用程序在多个物理位置发布，那么（首先）设备通常是基于DNS的地理负载均衡器。在每个位置，我们都有一个服务器集群。如果我们使用Docker，那么这个服务器集群可以隐藏在一个或多个Docker主机后面（这些主机在内部由使用Docker
    Swarm的许多机器组成）。
- en: The physical location of machines matters because the request-response time
    can differ significantly depending on the physical distance. Moreover, the database
    and other dependent services should be located on a machine that is close to where
    the service is deployed. What's even more important is that the database should
    be sharded in a way that the replication overhead between different locations
    is minimized. Otherwise, we may end up waiting a lot for the databases to reach
    consensus between its instances located far away from each other. More details
    on the physical aspects are beyond the scope of this book, but it's important
    to remember that Docker is not always a silver bullet.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 机器的物理位置很重要，因为请求-响应时间可能会因物理距离而有显着差异。此外，数据库和其他依赖服务应该位于靠近部署服务的机器上。更重要的是，数据库应该以一种方式进行分片，以使不同位置之间的复制开销最小化。否则，我们可能会等待数据库在彼此相距很远的实例之间达成共识。有关物理方面的更多细节超出了本书的范围，但重要的是要记住，Docker并不总是解决问题的灵丹妙药。
- en: Containerization and virtualization allow you to think about servers as an infinite
    resource; however, some physical aspects such as location are still relevant.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化和虚拟化使您可以将服务器视为无限资源；然而，一些物理方面，如位置，仍然相关。
- en: Staging
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂存
- en: The staging environment is the place where the release candidate is deployed
    in order to perform the final tests before going live. Ideally, this environment
    is a mirror of the production.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 暂存环境是发布候选版本部署的地方，以便在上线之前进行最终测试。理想情况下，这个环境应该是生产环境的镜像。
- en: 'Let''s look at the following to see how such an environment should look in
    the context of the delivery process:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下内容，以了解在交付过程的背景下，这样的环境应该是什么样子的：
- en: '![](assets/3dcb04d1-39d0-4e73-9773-1de9f5de4b47.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3dcb04d1-39d0-4e73-9773-1de9f5de4b47.png)'
- en: Note that the staging environment an exact a production clone. If the application
    is deployed in multiple locations, then the staging should also have multiple
    locations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，暂存环境是生产的精确克隆。如果应用程序在多个位置部署，那么暂存环境也应该有多个位置。
- en: In the Continuous Delivery process, all automated acceptance functional and
    nonfunctional tests are run against this environment. While most functional tests
    don't usually require identical production-like infrastructure, in the case of
    nonfunctional (especially performance) tests, it's a must.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续交付过程中，所有自动接受功能和非功能测试都针对这个环境运行。虽然大多数功能测试通常不需要相同的类似生产的基础设施，但在非功能（尤其是性能）测试的情况下，这是必须的。
- en: It is not uncommon that, for the purpose of cost saving, the staging infrastructure
    differs from the production (usually it contains fewer machines). Such an approach
    can, however, lead to many production issues. *Michael T. Nygard*, in his great
    book *Release It!*, gives an example of a real-life scenario in which fewer machines
    were used in the staging environment than in production.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省成本，暂存基础设施与生产环境不同（通常包含较少的机器）并不罕见。然而，这种方法可能导致许多生产问题。 *Michael T. Nygard* 在他的著作
    *Release It!* 中举了一个真实场景的例子，其中暂存环境使用的机器比生产环境少。
- en: 'The story goes like this: in one company, the system was stable until a certain
    code change, which caused the production to be extremely slow, even though all
    stress tests passed. How was it possible? It happened that there was a synchronization
    point, in which each server communicated with each other. In the case of the staging,
    there was one server, so actually there was no blocker. In production, however,
    there were many servers, which resulted in servers waiting for each other. This
    example is just the tip of the iceberg and many production issues may fail to
    be tested by acceptance tests if the staging environment is different from the
    production environment.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 故事是这样的：在某家公司，系统一直很稳定，直到某个代码更改导致生产环境变得极其缓慢，尽管所有压力测试都通过了。这是怎么可能的？事实上，有一个同步点，每个服务器都要与其他服务器通信。在暂存环境中，只有一个服务器，所以实际上没有阻塞。然而，在生产环境中，有许多服务器，导致服务器相互等待。这个例子只是冰山一角，如果暂存环境与生产环境不同，许多生产问题可能无法通过验收测试来测试。
- en: QA
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA
- en: 'The QA environment (also called the testing environment) is intended for the
    QA team to perform exploratory testing and for external applications (which depend
    on our service) to perform integration testing. The use cases and the infrastructure
    of the QA environment are presented in the following diagram:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: QA环境（也称为测试环境）旨在供QA团队进行探索性测试，以及依赖我们服务的外部应用程序进行集成测试。QA环境的用例和基础设施如下图所示：
- en: '![](assets/e9e70c25-4395-435b-91ff-36d3657f285d.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e9e70c25-4395-435b-91ff-36d3657f285d.png)'
- en: While staging does not need to be stable (in the case of Continuous Delivery,
    it is changed after every code change committed to the repository), the QA instance
    needs to provide a certain stability and expose the same (or backward compatible)
    API as the production. Contrary to the staging environment, the infrastructure
    can be different from the production, since its purpose is not to ensure that
    the release candidate works properly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然暂存环境不需要稳定（在持续交付的情况下，它在每次提交到存储库的代码更改后都会更改），但QA实例需要提供一定的稳定性，并公开与生产环境相同（或向后兼容）的API。与暂存环境相反，基础设施可以与生产环境不同，因为其目的不是确保发布候选版本正常工作。
- en: A very common case is to allocate fewer machines (for example, only from one
    location) for the purpose of the QA instance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的情况是为了QA实例的目的分配较少的机器（例如，只来自一个位置）。
- en: Deploying to the QA environment is usually done in a separate pipeline, so that
    it will be independent from the automatic release process. Such an approach is
    convenient, because the QA instance has a different life cycle than production
    (for instance, the QA team may want to perform testing on the experimental code
    branched from the trunk).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 部署到QA环境通常是在一个单独的流水线中进行的，这样它就可以独立于自动发布流程。这种方法很方便，因为QA实例的生命周期与生产环境不同（例如，QA团队可能希望对从主干分支出来的实验性代码进行测试）。
- en: Development
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发
- en: 'The development environment can be created as a shared server for all developers
    or each developer can have his/her own development environment. A simple diagram
    is presented here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境可以作为所有开发人员共享的服务器创建，或者每个开发人员可以拥有自己的开发环境。这里呈现了一个简单的图表：
- en: '![](assets/4ded0bd8-f76b-4509-bd96-f0cb95bd5606.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4ded0bd8-f76b-4509-bd96-f0cb95bd5606.png)'
- en: The development environment always contains the latest version of the code.
    It is used to enable integration between developers and can be treated the same
    way as the QA environment, but is used by developers, not QAs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 开发环境始终包含代码的最新版本。它用于实现开发人员之间的集成，并且可以像QA环境一样对待，但是由开发人员而不是QA使用。
- en: Environments in Continuous Delivery
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付中的环境
- en: For the purpose of the Continuous Delivery process, the staging environment
    is indispensable. In some very rare cases, when the performance is not important
    and the project does not have many dependencies, we could perform the acceptance
    tests on the local (development) Docker host (like we did in the previous chapter),
    but that should be an exception, not a rule. In such a case, we always risk some
    production issues related to the environment.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于持续交付过程，暂存环境是必不可少的。在一些非常罕见的情况下，当性能不重要且项目没有太多依赖性时，我们可以在本地（开发）Docker主机上执行验收测试（就像我们在上一章中所做的那样），但这应该是一个例外，而不是规则。在这种情况下，我们总是面临与环境相关的一些生产问题的风险。
- en: The other environments are usually not important with regard to Continuous Delivery.
    If we would like to deploy to the QA or development environment with every commit,
    then we can create separate pipelines for that purpose (being careful not to obscure
    the main release pipeline). In many cases, deployment to the QA environment is
    triggered manually, because it can have different life cycles from production.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 其他环境通常对于持续交付并不重要。如果我们希望在每次提交时部署到QA或开发环境，那么我们可以为此创建单独的流水线（小心不要混淆主要发布流水线）。在许多情况下，部署到QA环境是手动触发的，因为它可能与生产环境有不同的生命周期。
- en: Securing environments
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护环境
- en: All environments need to be well secured. That's clear. What's even more obvious
    is that the most important requirement is to keep the production secure, because
    our business depends on it and the consequences of any security flaw can be highest
    there.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有环境都需要得到很好的保护。这是明显的。更明显的是，最重要的要求是保持生产环境的安全，因为我们的业务取决于它，任何安全漏洞的后果在那里可能是最严重的。
- en: Security is a broad topic. In this section, we focus only on the topics related
    to the Continuous Delivery process. Nevertheless, setting up a complete server
    infrastructure requires much more knowledge about security.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是一个广泛的话题。在本节中，我们只关注与持续交付过程相关的主题。然而，建立完整的服务器基础设施需要更多关于安全的知识。
- en: In the Continuous Delivery process, the slave must have access to servers, so
    that it can deploy the application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续交付过程中，从属必须能够访问服务器，以便它可以部署应用程序。
- en: 'There are different approaches for providing slaves with the server''s credentials:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 提供从属机器与服务器凭据的不同方法：
- en: '**Put SSH key into slave**: If we don''t use dynamic Docker slave provisioning,
    then we can configure Jenkins slave machines to contain private SSH keys.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将SSH密钥放入从属中：**如果我们不使用动态Docker从属配置，那么我们可以配置Jenkins从属机器以包含私有SSH密钥。'
- en: '**Put SSH key into slave image:** If we use dynamic Docker slave provisioning,
    we could add the SSH private key into the Docker slave image. However, it creates
    a possible security hole, since anyone who has access to that image would have
    access to the production servers.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将SSH密钥放入从属镜像中：**如果我们使用动态Docker从属配置，我们可以将SSH私钥添加到Docker从属镜像中。然而，这会产生可能的安全漏洞，因为任何访问该镜像的人都将可以访问生产服务器。'
- en: '**Jenkins credentials**: We can configure Jenkins to store credentials and
    use them in the pipeline.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins凭据**：我们可以配置Jenkins来存储凭据并在流程中使用它们。'
- en: '**Copy to Slave Jenkins plugin**: We can copy the SSH key dynamically into
    the slave while starting the Jenkins build.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制到从属Jenkins插件**：我们可以在启动Jenkins构建时动态地将SSH密钥复制到从属系统中。'
- en: Each solution has some advantages and drawbacks. While using any of them we
    have to take extra caution, since, when a slave has access to the production,
    then anyone breaking into the slave breaks into the production.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每种解决方案都有一些优点和缺点。在使用任何一种解决方案时，我们都必须格外小心，因为当一个从属系统可以访问生产环境时，任何人入侵从属系统就等于入侵生产环境。
- en: The most risky solution is to put SSH private keys into the Jenkins slave image,
    since then all the places where the image is stored (the Docker registry or Docker
    host with Jenkins) need to be well secured.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最危险的解决方案是将SSH私钥放入Jenkins从属系统镜像中，因为镜像存储的所有地方（Docker注册表或带有Jenkins的Docker主机）都需要得到很好的保护。
- en: Nonfunctional testing
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非功能性测试
- en: We learned a lot about functional requirements and automated acceptance testing
    in the previous chapter. However, what should we do with nonfunctional requirements?
    Or even more challenging, what if there are no requirements? Should we skip them
    at all in the Continuous Delivery process? Let's answer these questions throughout
    this section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学到了很多关于功能需求和自动化验收测试。然而，对于非功能性需求，我们应该怎么办呢？甚至更具挑战性的是，如果没有需求怎么办？在持续交付过程中，我们应该完全跳过它们吗？让我们在本节中回答这些问题。
- en: Nonfunctional aspects of the software are always important, because they can
    cause a significant risk to the operation of the system.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的非功能性方面总是重要的，因为它们可能对系统的运行造成重大风险。
- en: For example, many applications fail, because they are not able to bear the load
    of a sudden increase in the number of users. In the book *Usability Engineering*,
    *Jakob Nielsen,* writes that 1.0 second is about the limit for the user's flow
    of thought to stay uninterrupted. Imagine that our system, with the growing load,
    starts to exceed that limit. Users can stop using the service just because of
    its performance. Taking it into consideration, nonfunctional testing is as important
    as functional testing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，许多应用程序失败，是因为它们无法承受用户数量突然增加的负载。在《可用性工程》一书中，Jakob Nielsen写道，1.0秒是用户思维流程保持不间断的极限。想象一下，我们的系统在负载增加的情况下开始超过这个极限。用户可能会因为性能问题而停止使用服务。考虑到这一点，非功能性测试与功能性测试一样重要。
- en: 'To cut a long story short, we should always take the following steps for nonfunctional
    testing:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，我们应该始终为非功能性测试采取以下步骤：
- en: Decide which nonfunctional aspects are crucial to our business
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定哪些非功能性方面对我们的业务至关重要
- en: 'For each of them:'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每一个：
- en: Specify the tests the same way we did for acceptance testing
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定测试的方式与我们为验收测试所做的方式相同
- en: Add a stage to the Continuous Delivery pipeline (after acceptance testing, while
    the application is still deployed on the staging environment)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在持续交付流程中添加一个阶段（在验收测试之后，应用程序仍然部署在暂存环境中）
- en: The application comes to the release stage only after all nonfunctional tests
    pass
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序只有在所有非功能性测试通过后才能进入发布阶段
- en: Irrespective of the type of the nonfunctional test, the idea is always the same.
    The approach, however, may slightly differ. Let's examine different test types
    and the challenges they pose.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 无论非功能性测试的类型如何，其思想总是相同的。然而，方法可能略有不同。让我们来看看不同的测试类型以及它们带来的挑战。
- en: Types of nonfunctional test
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非功能性测试的类型
- en: Functional test are always related to the same aspect—the behavior of the system.
    On the contrary, nonfunctional tests concern a lot of different aspects. Let's
    discuss the most common system properties and how they can be tested inside the
    Continuous Delivery process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试总是与系统行为相关。相反，非功能测试涉及许多不同的方面。让我们讨论最常见的系统属性以及它们如何在持续交付过程中进行测试。
- en: Performance testing
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: Performance tests are the most widely used nonfunctional tests. They measure
    the responsiveness and stability of the system. The simplest performance test
    we could create is to send a request to the web service and measure its **round-trip
    time** (**RTT**).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试是最广泛使用的非功能测试。它们衡量系统的响应能力和稳定性。我们可以创建的最简单的性能测试是向Web服务发送请求并测量其往返时间（RTT）。
- en: There are different definitions of performance testing. In many places, they
    are meant to include load, stress, and scalability testing. Sometimes they are
    also described as white-box tests. In this book, we define performance testing
    as the most basic form of black-box test to measure the latency of the system.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试有不同的定义。在许多地方，它们意味着包括负载、压力和可伸缩性测试。有时它们也被描述为白盒测试。在本书中，我们将性能测试定义为衡量系统延迟的最基本的黑盒测试形式。
- en: For the purpose of performance testing, we can use a dedicated framework (for
    Java the most popular is JMeter) or just use the same tool we used for acceptance
    tests. A simple performance test is usually added as a pipeline stage just after
    Acceptance tests. Such a test should fail if the RTT exceeds the given limit and
    it detects bugs that definitely slow down the service.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行性能测试，我们可以使用专用框架（对于Java来说，最流行的是JMeter），或者只是使用我们用于验收测试的相同工具。一个简单的性能测试通常被添加为管道阶段，就在验收测试之后。如果往返时间超过给定限制，这样的测试应该失败，并且它可以检测到明显减慢服务的错误。
- en: The JMeter plugin for Jenkins can show performance trends over the time.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins的JMeter插件可以显示随时间变化的性能趋势。
- en: Load testing
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 负载测试
- en: Load tests are used to check how the system functions when there are a lot of
    concurrent requests. While a system can be very fast with a single request, it
    does not mean that it works fast enough with 1,000 requests at the same time.
    During load testing, we measure the average request-response time of many concurrent
    calls, usually performed from many machines. Load testing is a very common QA
    phase in the release cycle. To automate it, we can use the same tools as with
    the simple performance test; however, in the case of larger systems, we may need
    a separate client environment to perform a large number of concurrent requests.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试用于检查系统在有大量并发请求时的功能。虽然系统对单个请求可能非常快，但这并不意味着它在同时处理1000个请求时速度足够快。在负载测试期间，我们测量许多并发调用的平均请求-响应时间，通常是从许多机器上执行的。负载测试是发布周期中非常常见的QA阶段。为了自动化它，我们可以使用与简单性能测试相同的工具；然而，在较大系统的情况下，我们可能需要一个单独的客户端环境来执行大量并发请求。
- en: Stress testing
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压力测试
- en: Stress testing, also called capacity testing or throughput testing, is a test
    that determines how many concurrent users can access our service. It may sound
    the same as load testing; however, in the case of load testing, we set the number
    of concurrent users (throughput) to a given number, check the response time (latency),
    and make the build fail if the limit is exceeded. During stress testing, however,
    we keep the latency constant and increase the throughput to discover the maximum
    number of concurrent calls when the system is still operable. So the result of
    a stress test may be notification that our system can handle 10,000 concurrent
    users, which helps us prepare for the peak usage time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试，也称为容量测试或吞吐量测试，是一种确定多少并发用户可以访问我们的服务的测试。这听起来与负载测试相同；然而，在负载测试的情况下，我们将并发用户数量（吞吐量）设置为一个给定的数字，检查响应时间（延迟），并且如果超过限制，则使构建失败。然而，在压力测试期间，我们保持延迟恒定，并增加吞吐量以发现系统仍然可操作时的最大并发调用数量。因此，压力测试的结果可能是通知我们的系统可以处理10,000个并发用户，这有助于我们为高峰使用时间做好准备。
- en: Stress testing is not well suited for the Continuous Delivery process, because
    it requires long tests with an increasing number of concurrent requests. It should
    be prepared as a separate script of a separate Jenkins pipeline and triggered
    on demand, when we know that the code change can cause performance issues.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试不太适合连续交付流程，因为它需要进行长时间的测试，同时并发请求数量不断增加。它应该准备为一个独立的脚本或一个独立的Jenkins流水线，并在需要时触发，当我们知道代码更改可能会导致性能问题时。
- en: Scalability testing
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可扩展性测试
- en: Scalability testing explains how latency and throughput change when we add more
    servers or services. The perfect characteristic would be linear, which means if
    we have one server and the average request-response time is 500 ms when used by
    100 parallel users, then adding another server would keep the response time the
    same and allow us to add another 100 parallel users. In reality, it's often hard
    to achieve thsi because of keeping data consistency between servers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性测试解释了当我们增加更多服务器或服务时延迟和吞吐量的变化。完美的特征应该是线性的，这意味着如果我们有一个服务器，当有100个并行用户使用时，平均请求-响应时间为500毫秒，那么添加另一个服务器将保持响应时间不变，并允许我们添加另外100个并行用户。然而，在现实中，由于保持服务器之间的数据一致性，通常很难实现这一点。
- en: Scalability testing should be automated and should provide the graph presenting
    the relationship between the number of machines and the number of concurrent users.
    Such data is helpful in determining the limits of the system and the point at
    which adding more machines does not help.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性测试应该是自动化的，并且应该提供图表，展示机器数量和并发用户数量之间的关系。这些数据有助于确定系统的限制以及增加更多机器不会有所帮助的点。
- en: Scalability tests, similar to stress tests, are hard to put into the Continuous
    Delivery pipeline and should rather be kept separate.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性测试，类似于压力测试，很难放入连续交付流程中，而应该保持独立。
- en: Endurance testing
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 耐久测试
- en: Endurance tests, also called longevity tests, run the system for a long time
    to see if the performance drops after a certain period of time. They detect memory
    leaks and stability issues. Since they require a system running for a long time,
    it doesn't make sense to run them inside the Continuous Delivery pipeline.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 耐久测试，也称为长期测试，长时间运行系统，以查看性能是否在一定时间后下降。它们可以检测内存泄漏和稳定性问题。由于它们需要系统长时间运行，因此在连续交付流程中运行它们是没有意义的。
- en: Security testing
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全测试
- en: Security testing deals with different aspects related to security mechanisms
    and data protection. Some security aspects are purely functional requirements
    such as authentication, authorization, or role assignment. These parts should
    be checked the same way as any other functional requirement—during the acceptance
    test phase. There are also other security aspects that are nonfunctional; for
    example, the system should be protected against SQL injection. No client would
    probably specify such a requirement, but it's implicit.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 安全测试涉及与安全机制和数据保护相关的不同方面。一些安全方面纯粹是功能需求，例如身份验证、授权或角色分配。这些部分应该与任何其他功能需求一样在验收测试阶段进行检查。还有其他安全方面是非功能性的；例如，系统应该受到SQL注入的保护。没有客户可能会明确指定这样的要求，但这是隐含的。
- en: Security tests should be included in Continuous Delivery as a pipeline stage.
    They can be written using the same frameworks as the acceptance tests or with
    dedicated security testing frameworks, for example, BDD security.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 安全测试应该作为连续交付的一个流水线阶段包括在内。它们可以使用与验收测试相同的框架编写，也可以使用专门的安全测试框架，例如BDD安全。
- en: Security should also always be a part the explanatory testing process, in which
    testers and security experts detect security holes and add new testing scenarios.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 安全也应始终成为解释性测试过程的一部分，测试人员和安全专家会发现安全漏洞并添加新的测试场景。
- en: Maintainability testing
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性测试
- en: Maintainability tests explain how simple a system is to maintain. In other words,
    they judge code quality. We already have related stages in the commit phase that
    check the test coverage and perform static code analysis. The Sonar tool can also
    give some overview of the code quality and the technical debt.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性测试解释了系统维护的简单程度。换句话说，它们评判了代码质量。我们已经在提交阶段有了相关的阶段，检查测试覆盖率并进行静态代码分析。Sonar工具也可以提供一些关于代码质量和技术债务的概述。
- en: Recovery testing
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复测试
- en: Recovery testing is a technique to determine how quickly the system can recover
    after it crashed because of a software or hardware failure. The best case would
    be if the system does not fail at all, even if a part of its services is down.
    Some companies even perform production failures on purpose to check if they can
    survive a disaster. The best known example is Netflix and their Chaos Monkey tool,
    which randomly terminates random instances of the production environment. Such
    an approach forces engineers to write code that makes systems resilient to failures.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复测试是一种确定系统在因软件或硬件故障而崩溃后能够多快恢复的技术。最好的情况是，即使系统的一部分服务停止，系统也不会完全崩溃。一些公司甚至会故意进行生产故障，以检查他们是否能够在灾难中生存。最著名的例子是Netflix和他们的混沌猴工具，该工具会随机终止生产环境的随机实例。这种方法迫使工程师编写能够使系统对故障具有弹性的代码。
- en: Recovery testing is obviously not part of the Continuous Delivery process, but
    rather a periodic event to check the overall health.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复测试显然不是连续交付过程的一部分，而是定期事件，用于检查整体健康状况。
- en: You can read more about Chaos Monkey at [https://github.com/Netflix/chaosmonkey](https://github.com/Netflix/chaosmonkey).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/Netflix/chaosmonkey](https://github.com/Netflix/chaosmonkey)了解更多关于混沌猴的信息。
- en: There are many more nonfunctional test types, which are closer to or further
    from the code and the Continuous Delivery process. Some of them relate to the
    law such as compliance testing; others are related to the documentation or internationalization.
    There are also usability testings and volume testings (which check whether the
    system behaves well in the case of large amounts of data). Most of these tests,
    however, have no part in the Continuous Delivery process.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多与代码和持续交付过程更接近或更远的非功能测试类型。其中一些与法律相关，如合规性测试；其他与文档或国际化相关。还有可用性测试和容量测试（检查系统在大量数据情况下的表现）。然而，大多数这些测试在持续交付过程中并没有任何作用。
- en: Nonfunctional challenges
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非功能挑战
- en: 'Nonfunctional aspects pose new challenges to the software development and delivery:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 非功能方面给软件开发和交付带来了新的挑战：
- en: '**Long test run**: The tests can take a long time to run and may need a special
    execution environment.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长时间运行测试**：测试可能需要很长时间运行，并且可能需要特殊的执行环境。'
- en: '**Incremental nature**: It''s hard to set the limit value when the test should
    fail (unless SLA is well defined). Even if the edge limit is set, the application
    would probably incrementally approach the limit. In most cases, actually, no one
    code change caused the test failure.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增量性质**：很难设置测试应该在何时失败的限值（除非SLA定义得很好）。即使设置了边缘限制，应用程序也可能逐渐接近限制。实际上，在大多数情况下，没有任何代码更改导致测试失败。'
- en: '**Vague requirements**: Users usually don''t have much input concerning nonfunctional
    requirements. They may provide some guidelines concerning the request-response
    time or the number of users; however, they won''t probably know much about maintainability,
    security, or scalability.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模糊的需求**：用户通常对非功能需求没有太多的输入。他们可能会提供一些关于请求-响应时间或用户数量的指导，但他们可能不会太了解可维护性、安全性或可扩展性。'
- en: '**Multiplicity**: There are a lot of different nonfunctional tests and choosing
    which should be implemented requires making some compromises.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多样性**：有很多不同的非功能测试，选择应该实施哪些需要做一些妥协。'
- en: 'The best approach to address nonfunctional aspects is to take the following
    steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 解决非功能方面的最佳方法是采取以下步骤：
- en: Make a list of all nonfunctional test types.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有非功能测试类型。
- en: 'Cross out explicitly the test you don''t need for your system. There may be
    a lot of reasons you don''t need one kind of test, for example:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 明确划掉您的系统不需要的测试。您可能不需要某种测试的原因有很多，例如：
- en: The service is super small and a simple performance test is enough
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该服务非常小，简单的性能测试就足够了
- en: The system is internal only and available only for read-only, so it may not
    need any security checks
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该系统仅内部使用，仅供只读，因此可能不需要进行任何安全检查。
- en: The system is designed for one machine only and does not need any scaling
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该系统仅设计用于一台机器，不需要任何扩展
- en: The cost of creating certain tests is too high
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建某些测试的成本太高
- en: 'Split your tests into two groups:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的测试分为两组：
- en: '**Continuous Delivery**: It is possible to add it to the pipeline'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续交付**：可以将其添加到流水线中'
- en: '**Analysis**: It is not possible to add to the pipeline because of their execution
    time, their nature, or the associated cost'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析**：由于执行时间、性质或相关成本，无法将其添加到流水线中'
- en: For the Continuous Delivery group, implement the related pipeline stages.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于持续交付组，实施相关的流水线阶段。
- en: 'For the Analysis group:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于分析组：
- en: Create automated tests
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自动化测试
- en: Schedule when they should be run
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排何时运行它们
- en: Schedule meetings to discuss their results and take action points
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排会议讨论它们的结果并制定行动计划
- en: A very good approach is to have a nightly build with the long tests that don't
    fit the Continuous Delivery pipeline. Then, it's possible to schedule a weekly
    meeting to monitor and analyze the trends of system performance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常好的方法是进行夜间构建，其中包括不适合持续交付流程的长时间测试。然后，可以安排每周一次的会议来监视和分析系统性能的趋势。
- en: As presented, there are many types of nonfunctional test and they pose additional
    challenges to the delivery process. Nevertheless, for the sake of the stability
    of our system, these tests should never be blankly skipped. The technical implementation
    differs depending on the test type, but in most cases they can be implemented
    in a similar manner to functional acceptance tests and should be run against the
    staging environment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，有许多类型的非功能性测试，它们给交付过程带来了额外的挑战。然而，为了系统的稳定性，这些测试绝不能被简单地跳过。技术实现因测试类型而异，但在大多数情况下，它们可以以类似的方式实现功能验收测试，并应该针对暂存环境运行。
- en: If you're interested in the topic of nonfunctional testing, system properties,
    and system stability, then read the book *Release It!* by *Michael T. Nygard*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对非功能性测试、系统属性和系统稳定性感兴趣，请阅读Michael T. Nygard的书《发布它！》。
- en: Application versioning
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用版本控制
- en: 'So far, during every Jenkins build, we have created a new Docker image, pushed
    it into the Docker registry, and used the **latest** version throughout the process.
    However, such a solution has at least three disadvantages:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在每次Jenkins构建期间，我们都创建了一个新的Docker镜像，将其推送到Docker注册表，并在整个过程中使用**最新**版本。然而，这种解决方案至少有三个缺点：
- en: If, during the Jenkins build, after the acceptance tests, someone pushes a new
    version of the image, then we can end up releasing the untested version
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在Jenkins构建期间，在验收测试之后，有人推送了图像的新版本，那么我们可能会发布未经测试的版本。
- en: We always push an image named in the same way; thus, so effectively, it is overwritten
    in the Docker registry
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们总是推送以相同方式命名的镜像；因此，在Docker注册表中，它被有效地覆盖了。
- en: It's very hard to manage images without versions just by their hashed-style
    IDs
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅通过哈希样式ID来管理没有版本的图像非常困难
- en: What is the recommended way of managing Docker image versions together with
    the Continuous Delivery process? In this section, we get to see different versioning
    strategies and learn different ways of creating versions in the Jenkins pipeline.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 管理Docker镜像版本与持续交付过程的推荐方式是什么？在本节中，我们将看到不同的版本控制策略，并学习在Jenkins流水线中创建版本的不同方法。
- en: Versioning strategies
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制策略
- en: There are different ways to version applications.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的应用版本控制方式。
- en: Let's discuss these most popular solutions, which can be applied together with
    the Continuous Delivery process (when each commit creates a new version).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论这些最流行的解决方案，这些解决方案可以与持续交付过程一起应用（每次提交都创建一个新版本）。
- en: '**Semantic versioning**: The most popular solution is to use sequence-based
    identifiers (usually in the form of x.y.z). This method requires a commit to the
    repository done by Jenkins in order to increase the current version number, which
    is usually stored in the build file. This solution is well supported by Maven,
    Gradle, and other build tools. The identifier usually consists of three numbers:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义化版本控制：最流行的解决方案是使用基于序列的标识符（通常以x.y.z的形式）。这种方法需要Jenkins在存储库中进行提交，以增加当前版本号，通常存储在构建文件中。这种解决方案得到了Maven、Gradle和其他构建工具的良好支持。标识符通常由三个数字组成。
- en: '**x**: This is the major version; the software does not need to    be backward-compatible
    when this version is incremented'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**x**：这是主要版本；当增加此版本时，软件不需要向后兼容'
- en: '**y**: This is the minor version; the software needs to be backward compatible
    when the version is incremented'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**y**：这是次要版本；当增加版本时，软件需要向后兼容'
- en: '**z:** This is the build number; this is sometimes also considered as a backward
    and forward-compatible change'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**z:** 这是构建编号；有时也被认为是向后和向前兼容的更改'
- en: '**Timestamp**: Using the date and time of the build for the application version
    is less verbose than sequential numbers, but very convenient in the case of the
    Continuous Delivery process, because it does not require committing back to the
    repository by Jenkins.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间戳**：对于应用程序版本，使用构建的日期和时间比顺序号更简洁，但在持续交付过程中非常方便，因为它不需要Jenkins向存储库提交。'
- en: '**Hash**: A randomly generated hash version shares the benefit of the datetime
    and is probably the simplest solution possible. The drawback is that it''s not
    possible to look at two versions and tell which is the latest one.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**哈希**：随机生成的哈希版本具有日期时间的好处，并且可能是可能的最简单的解决方案。缺点是无法查看两个版本并告诉哪个是最新的。'
- en: '**Mixed**: There are many variations of the solutions described earlier, for
    example, major and minor versions with the datetime.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合**：有许多先前描述的解决方案的变体，例如，带有日期时间的主要和次要版本。'
- en: All solutions are fine to use with the Continuous Delivery process. Semantic
    versioning requires, however, a commit to the repository from the build execution,
    so that the version is increased in the source code repository.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所有解决方案都可以与持续交付流程一起使用。语义化版本控制要求从构建执行向存储库提交，以便在源代码存储库中增加版本。
- en: Maven (and the other build tools) popularized version snapshotting, which added
    a suffix SNAPSHOT to the versions that are not released, but kept just for the
    development process. Since Continuous Delivery means releasing every change, there
    are no snapshots.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Maven（和其他构建工具）推广了版本快照，为未发布的版本添加了后缀SNAPSHOT，但仅用于开发过程。由于持续交付意味着发布每个更改，因此没有快照。
- en: Versioning in the Jenkins pipeline
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins流水线中的版本控制
- en: As described earlier, there are different possibilities when it comes to using
    software versioning and each of them can be implemented in Jenkins.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面所述，使用软件版本控制时有不同的可能性，每种可能性都可以在Jenkins中实现。
- en: As an example, let's use the datetime.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们使用日期时间。
- en: In order to use the timestamp information from Jenkins, you need to install
    the Build Timestamp Plugin and set the timestamp format in the Jenkins configuration
    (for example, to "yyyyMMdd-HHmm").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Jenkins中的时间戳信息，您需要安装Build Timestamp插件，并在Jenkins配置中设置时间戳格式（例如为"yyyyMMdd-HHmm"）。
- en: 'In every place where we use the Docker image, we need to add the tag suffix:
    `${BUILD_TIMESTAMP}`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用Docker镜像的每个地方，我们需要添加标签后缀：`${BUILD_TIMESTAMP}`。
- en: 'For example, the `Docker build` stage should look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Docker构建`阶段应该是这样的：
- en: '[PRE0]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After the changes, when we run the Jenkins build, we should have the image tagged
    with the timestamp version in our Docker registry.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 更改后，当我们运行Jenkins构建时，我们应该在我们的Docker注册表中使用时间戳版本标记图像。
- en: Note that after explicitly tagging the image, it's no longer implicitly tagged
    as the latest.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在显式标记图像后，它不再隐式标记为最新版本。
- en: With versioning completed, we are finally ready to complete the Continuous Delivery
    pipeline.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制完成后，我们终于准备好完成持续交付流程。
- en: Complete Continuous Delivery pipeline
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成持续交付流程
- en: After discussing all the aspects of Ansible, environments, nonfunctional testing,
    and versioning, we are ready to extend the Jenkins pipeline and finalize a simple,
    but complete, Continuous Delivery pipeline.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了Ansible、环境、非功能测试和版本控制的所有方面后，我们准备扩展Jenkins流水线并完成一个简单但完整的持续交付流程。
- en: 'We will do it in a few steps as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分几步来完成：
- en: Create the inventory of staging and production environments
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建暂存和生产环境清单
- en: Update acceptance tests to use the remote host (instead of local)
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新验收测试以使用远程主机（而不是本地）
- en: Release the application to the production environment
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序发布到生产环境
- en: Add a smoke test which makes sure the application was successfully released
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个冒烟测试，确保应用程序已成功发布
- en: Inventory
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清单
- en: 'In their simplest form, we can have two environments: staging and production,
    each having one Docker host machine. In real life, we may want to add more host
    groups for each environment if we want to have servers in different locations
    or having different requirements.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，我们可以有两个环境：暂存和生产，每个环境都有一个Docker主机。在现实生活中，如果我们希望在不同位置拥有服务器或具有不同要求，可能需要为每个环境添加更多的主机组。
- en: 'Let''s create two Ansible inventory files. Starting from the staging, we can
    define the `inventory/staging` file. Assuming the staging address is `192.168.0.241`,
    it would have the following content:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个Ansible清单文件。从暂存开始，我们可以定义`inventory/staging`文件。假设暂存地址是`192.168.0.241`，它将具有以下内容：
- en: '[PRE1]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By analogy, if the production IP address is `192.168.0.242`, then the `inventory/production` should
    look like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 类比而言，如果生产IP地址是`192.168.0.242`，那么`inventory/production`应该如下所示：
- en: '[PRE2]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It may look oversimplified to have just one machine for each environment; however,
    using Docker Swarm (which we show later in this book), a cluster of hosts can
    be hidden behind one Docker host.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 只为每个环境拥有一个机器可能看起来过于简化了；然而，使用Docker Swarm（我们稍后在本书中展示），一组主机可以隐藏在一个Docker主机后面。
- en: Having the inventory defined, we can change acceptance testing to use the staging
    environment.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有了定义的清单，我们可以更改验收测试以使用暂存环境。
- en: Acceptance testing environment
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验收测试环境
- en: 'Depending on our needs, we could test the application by running it on the
    local Docker host (like we did in the previous chapter) or using the remote staging
    environment. The former solution is closer to what happens in production, so it
    can be considered as a better one. This is very close to what was presented in
    the *Method 1: Jenkins-first acceptance testing* section of the previous chapter.
    The only difference is that now we deploy the application on a remote Docker host.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的需求，我们可以通过在本地Docker主机上运行应用程序（就像我们在上一章中所做的那样）或者使用远程暂存环境来测试应用程序。前一种解决方案更接近于生产中发生的情况，因此可以被认为是更好的解决方案。这与上一章的*方法1：首先使用Jenkins验收测试*部分非常接近。唯一的区别是现在我们将应用程序部署到远程Docker主机上。
- en: In order to do this, we could use `docker` (or the `docker-compose` command)
    with the `-H` parameter, which specifies the remote Docker host address. This
    would be a good solution and if you don't plan to use Ansible or any other configuration
    management tool, then that is the way to go. Nevertheless, for the reasons already
    mentioned in this chapter, it is beneficial to use Ansible. In that case, we can
    use the `ansible-playbook` command inside the Continuous Delivery pipeline.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们可以使用带有`-H`参数的`docker`（或`docker-compose`命令），该参数指定了远程Docker主机地址。这将是一个很好的解决方案，如果您不打算使用Ansible或任何其他配置管理工具，那么这就是前进的方式。然而，出于本章已经提到的原因，使用Ansible是有益的。在这种情况下，我们可以在持续交付管道中使用`ansible-playbook`命令。
- en: '[PRE3]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If `playbook.yml` and docker-compose.yml look the same as in the *Ansible with
    Docker* section, then it should be enough to deploy the application with dependencies
    into the staging environment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`playbook.yml`和docker-compose.yml看起来与*使用Docker的Ansible*部分中的内容相同，那么将足以将应用程序与依赖项部署到暂存环境中。
- en: The `Acceptance test` stage looks exactly the same as in the previous chapter.
    The only adjustment can be the hostname of the staging environment (or its load
    balancer). It's also possible to add stages for performance testing or other nonfunctional
    tests against the application running on the staging environment.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: “验收测试”阶段与上一章完全相同。唯一的调整可能是暂存环境的主机名（或其负载均衡器）。还可以添加用于对运行在暂存环境上的应用程序进行性能测试或其他非功能测试的阶段。
- en: After all tests are passed, it's high time to release the application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有测试通过后，是时候发布应用程序了。
- en: Release
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布
- en: The production environment should be as close to the staging environment as
    possible. The Jenkins step for the release should also be very similar to the
    stage that deploys the application to the staging environment.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 生产环境应尽可能接近暂存环境。发布的Jenkins步骤也应与将应用程序部署到暂存环境的阶段非常相似。
- en: In the simplest scenario, the only differences are the inventory file and the
    application configuration (for example, in case of a Spring Boot application,
    we would set a different Spring profile, which results in taking a different properties
    file). In our case, there are no application properties, so the only difference
    is the inventory file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，唯一的区别是清单文件和应用程序配置（例如，在Spring Boot应用程序的情况下，我们将设置不同的Spring配置文件，这将导致使用不同的属性文件）。在我们的情况下，没有应用程序属性，所以唯一的区别是清单文件。
- en: '[PRE4]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In reality, the release step can be a little more complex if we want to provide
    zero downtime deployment. More on that topic is presented in the next chapters.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们想要实现零停机部署，发布步骤可能会更加复杂。关于这个主题的更多内容将在接下来的章节中介绍。
- en: After the release is done, we might think that everything is completed; however,
    there is one more missing stage, a smoke test.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 发布完成后，我们可能认为一切都已完成；然而，还有一个缺失的阶段，即冒烟测试。
- en: Smoke testing
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒烟测试
- en: A smoke test is a very small subset of acceptance tests whose only purpose is
    to check that the release process is completed successfully. Otherwise, we could
    have a situation in which the application is perfectly fine; however, there is
    an issue in the release process, so we may end up with a non-working production.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 冒烟测试是验收测试的一个非常小的子集，其唯一目的是检查发布过程是否成功完成。否则，我们可能会出现这样的情况：应用程序完全正常，但发布过程中出现问题，因此我们可能最终得到一个无法工作的生产环境。
- en: 'The smoke test is usually defined in the same way as the acceptance test. So
    the `Smoke test` stage in the pipeline should look like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 冒烟测试通常与验收测试以相同的方式定义。因此，管道中的“冒烟测试”阶段应该如下所示：
- en: '[PRE5]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After everything is set up, the Continuous Delivery build should run automatically
    and the application should be released to production. With this step, we have
    completed the Continuous Delivery pipeline in its simplest, but fully productive,
    form.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，连续交付构建应该自动运行，并且应用程序应该发布到生产环境。通过这一步，我们已经完成了连续交付管道的最简单但完全有效的形式。
- en: Complete Jenkinsfile
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整的Jenkinsfile
- en: To sum up, throughout the recent chapters we have created quite a few stages,
    which results in a complete Continuous Delivery pipeline that could be successfully
    used in many projects.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，在最近的章节中，我们创建了相当多的阶段，这导致了一个完整的连续交付管道，可以成功地应用于许多项目。
- en: 'Next we see the complete Jenkins file for the calculator project:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们看到计算器项目的完整Jenkins文件：
- en: '[PRE6]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can find this Jenkinsfile on GitHub at [https://github.com/leszko/calculator/blob/master/Jenkinsfile](https://github.com/leszko/calculator/blob/master/Jenkinsfile).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到这个Jenkinsfile：[https://github.com/leszko/calculator/blob/master/Jenkinsfile](https://github.com/leszko/calculator/blob/master/Jenkinsfile)。
- en: Exercises
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'In this chapter, we have covered a lot of new aspects for the Continuous Delivery
    pipeline; to better understand the concept, we recommend you perform the following
    exercises:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了持续交付管道的许多新方面；为了更好地理解这个概念，我们建议您进行以下练习：
- en: 'Add a performance test, which tests the "hello world" service:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个性能测试，测试“hello world”服务：
- en: The "hello world" service can be taken from the previous chapter
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “hello world”服务可以从上一章中获取
- en: Create a `performance_test.sh`  script, which makes 100 calls in parallel and
    checks whether the average request-response time is below 1 second
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个“performance_test.sh”脚本，同时进行100次调用，并检查平均请求-响应时间是否低于1秒
- en: You can use Cucumber or the `curl` command for the script
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用Cucumber或“curl”命令来执行脚本
- en: 'Create a Jenkins pipeline that builds the "hello world" web service as a versioned
    Docker image and performs performance test:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Jenkins管道，构建“hello world”网络服务作为版本化的Docker镜像，并执行性能测试：
- en: Create the `Docker build` stage, which builds the Docker image with the "hello
    world" service and adds a timestamp as a version tag
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建“Docker构建”阶段，用于构建带有“hello world”服务的Docker镜像，并添加时间戳作为版本标记
- en: Create an Ansible playbook that uses the Docker image
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个使用Docker镜像的Ansible剧本
- en: Add the `Deploy to staging` stage, which deploys the image into the remote machine
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加“部署到暂存”阶段，将镜像部署到远程机器
- en: Add the `Performance testing` stage, which executes `performance_test.sh`
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加“性能测试”阶段，执行“performance_test.sh”
- en: Run the pipeline and observe the results
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行管道并观察结果
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have completed the Continuous Delivery pipeline, which
    finally releases the application. The following are the key takeaways from the
    chapter:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了持续交付管道，最终发布了应用程序。以下是本章的要点：
- en: 'For the purpose of Continuous Delivery, two environments are indispensable:
    staging and production.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了持续交付的目的，两个环境是必不可少的：暂存和生产。
- en: Nonfunctional tests are an essential part of the Continuous Delivery process
    and should always be considered as pipeline stages.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非功能测试是持续交付过程的重要组成部分，应始终被视为管道阶段。
- en: Nonfunctional tests that don't fit the Continuous Delivery process should be
    considered as periodic tasks in order to monitor the overall performance trends.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不符合持续交付过程的非功能测试应被视为定期任务，以监控整体性能趋势。
- en: Applications should always be versioned; however, the versioning strategy depends
    on the type of the application.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序应始终进行版本控制；但是，版本控制策略取决于应用程序的类型。
- en: 'The minimal Continuous Delivery pipeline can be implemented as a sequence of
    scripts that ends with two stages: release and smoke test.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小的持续交付管道可以被实现为一系列以发布和冒烟测试为结束的脚本阶段。
- en: The smoke test should always be added as the last stage of the Continuous Delivery
    pipeline in order to check whether the release was successful.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒烟测试应始终作为持续交付管道的最后阶段添加，以检查发布是否成功。
- en: In the next chapter, we will have a look at the Docker Swarm tool, which helps
    us to create a cluster of Docker hosts.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Docker Swarm工具，该工具可帮助我们创建Docker主机集群。
