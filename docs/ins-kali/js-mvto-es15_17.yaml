- en: Chapter 5. Behavioral Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章。行为模式
- en: In the last chapter we looked at structural patterns that describe ways in which
    objects can be constructed to ease interaction.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了一些描述对象如何构造以便简化交互的结构模式。
- en: 'In this chapter we''ll take a look at the final, and largest, grouping of GoF
    patterns: behavioral patterns. These patterns are ones that provide guidance on
    how objects share data or, from a different perspective, how data flows between
    objects.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看一下GoF模式的最终和最大的分组：行为模式。这些模式是提供关于对象如何共享数据，或者从不同的角度来看，数据如何在对象之间流动的指导。
- en: 'The patterns we''ll look at are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的模式如下：
- en: Chain of responsibility
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链
- en: Command
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Interpreter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释器
- en: Iterator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Mediator
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调停者
- en: Memento
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备忘录
- en: Observer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: State
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态
- en: Strategy
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略
- en: Template method
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法
- en: Visitor
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问者
- en: Once again there are a number of more recently identified patterns that could
    well be classified as behavioral patterns. We'll defer looking at those until
    a later chapter, instead keeping to the GoF patterns.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 再次有一些最近确定的模式可能很好地被分类为行为模式。我们将推迟查看这些，直到以后的章节，而是保持GoF模式。
- en: Chain of responsibility
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 责任链
- en: 'We can think of a function call on an object as sending that object a message.
    Indeed this message passing mentality is one that dates back to the days of Smalltalk.
    The chain of responsibility pattern describes an approach in which a message tickles
    down from one class to another. A class can either act on the message or allow
    it to be passed on to the next member of the chain. Depending on the implementation
    there are a few different rules that can be applied to the message passing. In
    some situations only the first matching link in the chain is permitted to act.
    In others, every matching link acts on the message. Sometimes the links are permitted
    to stop processing or even to mutate the message as it continues down the chain:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把对对象的函数调用看作是向该对象发送消息。事实上，这种消息传递的思维方式可以追溯到Smalltalk的时代。责任链模式描述了一种方法，其中消息从一个类传递到另一个类。一个类可以对消息进行操作，也可以将其传递给链中的下一个成员。根据实现，可以应用一些不同的规则来传递消息。在某些情况下，只允许链中的第一个匹配链接来操作。在其他情况下，每个匹配的链接都会对消息进行操作。有时允许链接停止处理，甚至在消息继续下传时改变消息：
- en: '![Chain of responsibility](img/00054.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![责任链](img/00054.jpeg)'
- en: 'Let''s see if we can find a good example of this pattern in our go-to example:
    the land of Westeros.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的示例中是否能找到这种模式的一个很好的例子：维斯特洛大陆。
- en: Implementation
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: There is very little in the way of a legal system in Westeros. Certainly there
    are laws and even city guards who enforce them but the judicial system is scant.
    The law of the land is really decided by the king and his advisors. Those with
    the time and money can petition for an audience with the king who will listen
    to their complaint and pass a ruling. This ruling is law. Of course any king who
    spent his entire day listening to the complaints of peasants would go mad. For
    this reason many of the cases are caught and solved by his advisors before they
    reach his ears.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 维斯特洛大陆几乎没有法律体系。当然有法律，甚至有执行它们的城市警卫，但司法系统很少。这片土地的法律实际上是由国王和他的顾问决定的。有时间和金钱的人可以请求与国王会面，国王会听取他们的投诉并作出裁决。这个裁决就是法律。当然，任何整天听农民的投诉的国王都会发疯。因此，许多案件在达到国王耳朵之前就被他的顾问们解决了。
- en: 'To represent this in code we''ll need to start by thinking about how the chain
    of responsibility would work. A complaint comes in and it starts with the lowest
    possible person who can solve it. If that person cannot or will not solve the
    problem it tickles up to a more senior member of the ruling class. Eventually
    the problem reaches the king who is the final arbiter of disputes. We can think
    of him as the default dispute solver who is called upon when all else fails. The
    chain of responsibility is visible in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在代码中表示这一点，我们需要首先考虑责任链将如何工作。一个投诉进来，它从能够解决它的最低可能的人开始。如果那个人不能或不愿解决问题，它就会上升到统治阶级的更高级成员。最终问题会达到国王，他是争端的最终裁决者。我们可以把他看作是默认的争端解决者，当一切都失败时才会被召唤。责任链在下图中可见：
- en: '![Implementation](img/00055.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/00055.jpeg)'
- en: 'We''ll start with an interface to describe those who might listen to complaints:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个描述可能听取投诉的接口开始：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The interface requires two methods. The first is a simple check to see if the
    class is able to resolve a given complaint. The second listens to and resolves
    the complaint. Next we''ll need to describe what constitutes a complaint:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接口需要两种方法。第一种是简单地检查类是否能够解决给定的投诉。第二种是监听和解决投诉。接下来我们需要描述什么构成了投诉：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next we need a couple of different classes which implement `ComplaintListener`
    and are able to solve complaints:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要几个不同的类，它们实现了`ComplaintListener`并且能够解决投诉：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Each one of these classes implements a different approach to solving the complaint.
    We need to chain them together making sure that the king is in the default position.
    This can be seen in this code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类中的每一个实现了解决投诉的不同方法。我们需要将它们链接在一起，确保国王处于默认位置。这可以在这段代码中看到：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This code will work its way through each of the listeners until it finds one
    that is interested in hearing the complaint. In this version the result is returned
    immediately, halting any further processing. There are variations of this pattern
    in which multiple listeners could fire, even allowing the listeners to mutate
    the parameters for the next listener. The following diagram shows multiple listeners
    configured:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将逐个遍历每个监听器，直到找到一个对听取投诉感兴趣的监听器。在这个版本中，结果会立即返回，停止任何进一步的处理。这种模式有多种变体，其中多个监听器可以触发，甚至允许监听器改变下一个监听器的参数。下图显示了配置了多个监听器：
- en: '![Implementation](img/00056.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/00056.jpeg)'
- en: Chain of responsibility is a highly useful pattern in JavaScript. In browser-based
    JavaScript the events that fire fall through a chain of responsibility. For instance
    you can attach multiple listeners to the click event on a link and each of them
    will fire and then, finally, the default navigation listener. It is likely that
    you're using chain of responsibility in much of your code without even knowing
    it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 责任链是JavaScript中非常有用的模式。在基于浏览器的JavaScript中，触发的事件会经过一条责任链。例如，你可以将多个监听器附加到链接的点击事件上，每个监听器都会触发，最后是默认的导航监听器。很可能你在很多代码中都在使用责任链而不自知。
- en: Command
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令
- en: The command pattern is a method of encapsulating both the parameters to a method,
    as well as the current object state, and which method is to be called. In effect
    the command pattern packs up everything needed to call a method at a later date
    into a nice little package. Using this approach one can issue a command and wait
    until a later date to decide which piece of code will execute the command. This
    package can then be queued or even serialized for later execution. Having a single
    point of command execution also allows for easily adding functionality such as
    undo or command logging.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式是一种封装方法的参数、当前对象状态以及要调用的方法的方法。实际上，命令模式将调用方法所需的一切打包到一个漂亮的包中。使用这种方法，可以发出一个命令，并等到以后再决定哪一段代码将执行该命令。然后可以将此包排队或甚至序列化以供以后执行。具有单一的命令执行点还允许轻松添加功能，如撤消或命令记录。
- en: 'This pattern can be a bit difficult to imagine so let''s break it down into
    its components:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式可能有点难以想象，所以让我们把它分解成它的组成部分：
- en: '![Command](img/00057.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Command](img/00057.jpeg)'
- en: Command message
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令消息
- en: The first component of the command pattern is, predictably, the command itself.
    As I mentioned, the command encapsulates everything needed to invoke a method.
    This includes the method name, the parameters, and any global state. As you can
    imagine keeping track of global state in each command is very difficult. What
    happens if the global state changes after the command has been created? This dilemma
    is yet another reason why using a global state is problematic and should be avoided.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式的第一个组成部分是，可预测的，命令本身。正如我所提到的，命令封装了调用方法所需的一切。这包括方法名称、参数和任何全局状态。你可以想象，在每个命令中跟踪全局状态是非常困难的。如果全局状态在命令创建后发生了变化会发生什么？这个困境是使用全局状态有问题并应该避免的另一个原因。
- en: There are a couple of options for setting up commands. At the simple end of
    the scale all that is needed is to track a function and a set of parameters. Because
    functions are first class objects in JavaScript, they can easily be saved into
    an object. We can also save the parameters to the function into a simple array.
    Let's build a command using this very simple approach.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 设置命令有几种选择。在简单的一端，只需要跟踪一个函数和一组参数。因为在JavaScript中，函数是一等对象，它们可以很容易地保存到一个对象中。我们还可以将函数的参数保存到一个简单的数组中。让我们使用这种非常简单的方法来构建一个命令。
- en: The deferred nature of commands suggests an obvious metaphor in the land of
    Westeros. There are no methods of communicating quickly in Westeros. The best
    method is to attach small messages to birds and release them. The birds have a
    tendency to want to return to their homes, so each lord raises a number of birds
    in their home and, when they come of age, sends them to other lords who might
    wish to communicate with them. The lords keep an aviary of birds and retain records
    of which bird will travel to which other lord. The king of Westeros sends many
    of his commands to his loyal lords through this method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的延迟性质在Westeros的土地上暗示了一个明显的隐喻。在Westeros没有快速通信的方法。最好的方法是将小消息附加到鸟上并释放它们。这些鸟倾向于想要回到它们的家，所以每个领主在家里养了一些鸟，当它们成年时，就把它们送给其他可能想与它们交流的领主。领主们保留了一群鸟，并记录了哪只鸟将飞到哪个其他领主那里。Westeros的国王通过这种方法向他忠诚的领主发送了许多命令。
- en: The commands sent by the king contain all necessary instructions for the lords.
    The command may be something like bring your troops and the arguments to that
    command may be a number of troops, a location, and a date by which the command
    must be carried out.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 国王发送的命令包含了领主所需的所有指示。命令可能是带上你的军队，命令的参数可能是军队的数量、地点和命令必须执行的日期。
- en: 'In JavaScript the simplest way of representing this is through an array:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，表示这一点的最简单方法是通过数组：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This array can be passed around and invoked at will. To invoke it, a generic
    function can be used:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组可以随意传递和调用。要调用它，可以使用一个通用函数：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, this function only works for commands with three arguments.
    You can, of course, expand this to any number:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个函数只适用于具有三个参数的命令。当然，你可以将其扩展到任意数量：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The additional parameters are undefined, but the function doesn't use them so
    there are no ill effects. Of course, this is not at all an elegant solution.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的参数是未定义的，但函数不使用它们，所以没有任何不良影响。当然，这绝对不是一个优雅的解决方案。
- en: It is desirable to build a class for each sort of command. This allows you to
    ensure the correct arguments have been supplied and easily distinguish the different
    sorts of commands in a collection. Typically, commands are named using the imperative,
    as they are instructions. Examples of this are BringTroops, Surrender, SendSupplies,
    and so on.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最好为每种类型的命令构建一个类。这样可以确保已提供了正确的参数，并且可以轻松区分集合中不同类型的命令。通常，命令使用命令式命名，因为它们是指令。例如BringTroops、Surrender、SendSupplies等。
- en: 'Let''s transform our ugly simple command into a proper class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们丑陋的简单命令转换成一个合适的类：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We may wish to implement some logic to ensure that the parameters passed into
    the constructor are correct. This will ensure that the command fails on creation
    instead of on execution. It is easier to debug the issue during creation rather
    than during execution as execution could be delayed, even for days. The validation
    won't be perfect, but even if it catches only a small portion of the errors it
    is helpful.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望实现一些逻辑来确保传递到构造函数中的参数是正确的。这将确保命令在创建时失败，而不是在执行时失败。在创建过程中调试问题比在执行过程中调试问题更容易，因为执行可能会延迟，甚至可能延迟几天。验证可能不完美，但即使它只能捕捉到一小部分错误，也是有帮助的。
- en: As mentioned these commands can be saved for later use in memory or even written
    to disk.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，这些命令可以保存在内存中以供以后使用，甚至可以写入磁盘。
- en: Invoker
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用者
- en: 'The invoker is the part of the command pattern which instructs the command
    to execute its instructions. The invoker can really be anything: a timed event,
    a user interaction, or just the next step in the process may all trigger invocation.
    When we executed the `simpleCommand` command in the preceding section, we were
    playing at being the invoker. In a more rigorous command the invoker might look
    something like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 调用者是命令模式中指示命令执行其指令的部分。调用者实际上可以是任何东西：定时事件、用户交互，或者只是流程中的下一步都可能触发调用。当我们在前面的部分中执行`simpleCommand`命令时，我们在扮演调用者的角色。在更严格的命令中，调用者可能看起来像下面这样：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, invoking a command is very easy. Commands may be invoked at
    once or at some later date. One popular approach is to defer the execution of
    the command to the end of the event loop. This can be done in a node with:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用命令非常容易。命令可以立即执行，也可以在以后的某个时间执行。一个常见的方法是将命令的执行推迟到事件循环的末尾。在Node中可以这样做：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function `process.nextTick` defers the execution of a command to the end
    of the event loop such that, if it is executed next time the process has nothing
    to do.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`process.nextTick`将命令的执行推迟到事件循环的末尾，以便在下次进程没有任务时执行。
- en: Receiver
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收者
- en: 'The final component in the command pattern is the receiver. This is the target
    of the command execution. In our example we created a receiver called `LordInstructions`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式中的最后一个组件是接收者。这是命令执行的目标。在我们的示例中，我们创建了一个名为`LordInstructions`的接收者：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The receiver knows how to perform the action that the command has deferred.
    There need not be anything special about the receiver, in fact it may be any class
    at all.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接收者知道如何执行命令推迟的操作。接收者没有任何特殊之处，实际上可以是任何类。
- en: Together these components make up the command pattern. A client will generate
    a command, pass it off to an invoker that may delay the command or execute it
    at once, and the command will act upon a receiver.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件共同构成了命令模式。客户端将生成一个命令，将其传递给可能延迟命令或立即执行命令的调用者，然后命令将作用于接收者。
- en: In the case of building an undo stack, the commands are special, in that they
    have both an `Execute` and an `Undo` method. One takes the application state forward
    and the other takes it backwards. To perform an undo, simply pop the command off
    the undo stack, execute the `Undo` function, and push it onto a redo stack. For
    redo, pop from redo, execute `Execute`, and push to the undo stack. Simple as
    that, although one must make sure all state mutations are performed through commands.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建撤销堆栈的情况下，命令是特殊的，因为它们既有`Execute`方法，也有`Undo`方法。一个将应用程序状态向前推进，另一个将其向后推进。要执行撤销，只需从撤销堆栈中弹出命令，执行`Undo`函数，然后将其推送到重做堆栈中。对于重做，从重做中弹出，执行`Execute`，并推送到撤销堆栈中。就是这么简单，尽管必须确保所有状态变化都是通过命令执行的。
- en: The GoF book outlines a slightly more complicated set of players for the command
    pattern. This is largely due to the reliance on interfaces that we've avoided
    in JavaScript. The pattern becomes much simpler thanks to the prototype inheritance
    model in JavaScript.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: GoF书中概述了命令模式的一组稍微复杂的参与者。这在很大程度上是由于我们在JavaScript中避免使用接口。由于JavaScript中的原型继承模型，该模式变得更加简单。
- en: The command pattern is a very useful one for deferring the execution of some
    piece of code. We'll actually explore the command pattern and some useful companion
    patterns in [Chapter 10](part0154_split_000.html#4IRMK1-015e68c68a464f18a9559f448be84435
    "Chapter 10. Messaging Patterns"), *Messaging Patterns*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式对于推迟执行某些代码非常有用。我们将在[第10章](part0154_split_000.html#4IRMK1-015e68c68a464f18a9559f448be84435
    "第10章。消息模式")中探讨命令模式和一些有用的伴生模式。
- en: Interpreter
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释器
- en: The interpreter pattern is an interesting pattern as it allows for the creation
    of your own language. This might sound like something of a crazy idea, we're already
    writing JavaScript, why would we want to create a new language? Since the publication
    of the GoF book **Domain specific languages** (**DSLs**) have had something of
    a renaissance. There are situations where it is quite useful to create a language
    that is specific to one requirement. For instance the **Structured Query** **Language**
    (**SQL**) is very good at describing the querying of relational databases. Equally,
    regular expressions have proven themselves to be highly effective for the parsing
    and manipulation of text.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器模式是一种有趣的模式，因为它允许创建自己的语言。这可能听起来有点疯狂，我们已经在编写JavaScript了，为什么还要创建一种新的语言呢？自从GoF书籍《领域特定语言》（DSLs）出版以来，特定领域语言有所复兴。有些情况下，创建一个特定于某一需求的语言非常有用。例如，结构化查询语言（SQL）非常擅长描述关系数据库的查询。同样，正则表达式已被证明在文本的解析和操作方面非常有效。
- en: 'There are many scenarios in which being able to create a simple language is
    useful. That''s really the key: a simple language. Once the language gets more
    complicated, the advantages are quickly lost to the difficulty of creating what
    is, in effect, a compiler.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，能够创建一个简单的语言是有用的。这才是关键：一个简单的语言。一旦语言变得更加复杂，优势很快就会因为创建实际上是一个编译器的困难而丧失。
- en: This pattern is different from those we've seen to this point as there is no
    real class structure that is defined by the pattern. You can design your language
    interpreter however you wish.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式与我们到目前为止所见到的模式不同，因为它没有真正由模式定义的类结构。你可以按照自己的意愿设计你的语言解释器。
- en: Example
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例
- en: 'For our example let us define a language which can be used to describe historical
    battles in the land of Westeros. The language must be simple for clerics to write
    and easy to read. We''ll start by creating a simple grammar:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，让我们定义一种语言，用于描述维斯特洛大陆上的历史战斗。这种语言必须简单，以便牧师们能够书写并且易于阅读。我们将首先创建一个简单的语法：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here you can see that we''re just writing out a rather nice syntax that will
    let people describe battles. A battle between Robert Baratheon and RhaegarTargaryen
    at the river Trident would look like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们只是写出了一个相当不错的语法，让人们描述战斗。Robert Baratheon和RhaegarTargaryen在三叉戟河之间的战斗将如下所示：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using this grammar we would like to build some code which is able to query a
    list of battles for answers. In order to do this we're going to rely on regular
    expressions. For most languages this wouldn't be a good approach as the grammar
    is too complicated. In those cases one might wish to create a lexor and a parser
    and build up syntax trees, however, by that point you may wish to re-examine if
    creating a DSL is really a good idea. For our language the syntax is very simple
    so we can get away with regular expressions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个语法，我们想要构建一些代码，能够查询一系列战斗以获得答案。为了做到这一点，我们将依赖于正则表达式。对于大多数语言来说，这不是一个好的方法，因为语法太复杂。在这种情况下，人们可能希望创建一个词法分析器和一个解析器，并构建语法树，然而，到了那个时候，你可能会希望重新审视一下是否创建DSL真的是一个好主意。对于我们的语言，语法非常简单，所以我们可以使用正则表达式。
- en: Implementation
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'The first thing we establish is a JavaScript data model for the battle like
    so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先建立一个JavaScript数据模型，如下所示：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next we need a parser:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要一个解析器：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It is likely best that you don''t think too much about that regular expression.
    However, the class does take in a list of battles (one per line) and using `next
    Battle`, allows one to parse them. To use the class we simply need to do the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要太在意那个正则表达式。然而，这个类确实接受一系列战斗（每行一个），并使用`next Battle`，允许解析它们。要使用这个类，我们只需要做以下操作：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will be the output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是输出：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This data structure can now be queried like one would for any other structure
    in JavaScript.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以像查询JavaScript中的任何其他结构一样查询这个数据结构。
- en: As I mentioned earlier there is no fixed way to implement this pattern, so the
    implementation done in the preceding code is provided simply as an example. Your
    implementation will very likely look very different and that is just fine.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，实现这种模式没有固定的方式，因此在前面的代码中所做的实现只是提供了一个示例。你的实现很可能看起来会非常不同，这也没关系。
- en: Interpreter can be a useful pattern in JavaScript. It is, however, a pretty
    infrequently used pattern in most situations. The best example of a language interpreted
    in JavaScript is the less language that is compiled, by JavaScript, to CSS.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器在JavaScript中可能是一个有用的模式。然而，在大多数情况下，这是一个相当少用的模式。在JavaScript中解释的最好例子是编译为CSS的less语言。
- en: Iterator
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器
- en: Traversing collections of objects is an amazingly common problem. So much so
    that many languages provide for special constructs just for moving through collections.
    For example C# has a `foreach` loop and Python has `for x in`. These looping constructs
    are frequently built on top of an iterator. An iterator is a pattern that provides
    a simple method for selecting, sequentially, the next item in a collection.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历对象集合是一个非常常见的问题。以至于许多语言都提供了专门的构造来遍历集合。例如，C#有一个`foreach`循环，Python有`for x in`。这些循环结构经常是建立在迭代器之上的。迭代器是一种提供一种简单方法来选择集合中的下一个项目的模式。
- en: 'The interface for an iterator looks like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的接口如下：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Implementation
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'In the land of Westeros there is a well-known sequence of people in line for
    the throne in the very unlikely event that the king was to die. We can set up
    a handy iterator over the top of this collection and simply call `next` on it
    should the ruler die:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛大陆上，有一个众所周知的人物序列，排队等候王位，以防万一国王去世。我们可以在这个集合的顶部设置一个方便的迭代器，如果统治者去世，只需简单地调用`next`：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is primed with an array and then we can call it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用数组初始化的，然后我们可以调用它：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'An interesting application of iterators is to not iterate over a fixed collection.
    For instance an iterator can be used to generate sequential members of an infinite
    set like the fibonacci sequence:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器的一个有趣的应用是不是遍历固定集合。例如，迭代器可以用来生成无限集合的顺序成员，比如斐波那契数列：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is used like so:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法如下：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Iterators are handy constructs allowing for exploring not just arrays but any
    collection or even any generated list. There are a ton of places where this can
    be used to great effect.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是方便的构造，允许探索不仅仅是数组，而且是任何集合，甚至是任何生成的列表。有很多地方可以大显身手。
- en: ECMAScript 2015 iterators
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ECMAScript 2015迭代器
- en: 'Iterators are so useful that they are actually part of the next generation
    of JavaScript. The iterator pattern used in ECMAScript 2015 is a single method
    that returns an object that contains `done` and `value`. `done` is `true` when
    the iterator is at the end of the collection. What is nice about the ECMAScript
    2015 iterators is that the array collection in JavaScript will support the iterator.
    This opens up a new syntax which can largely replace the `for` loop:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器非常有用，它们实际上是JavaScript的下一代的一部分。在ECMAScript 2015中使用的迭代器模式是一个返回包含`done`和`value`的对象的单个方法。当迭代器在集合的末尾时，`done`为`true`。ECMAScript
    2015迭代器的好处在于JavaScript中的数组集合将支持迭代器。这打开了一个新的语法，可以在很大程度上取代`for`循环：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Iterators are a syntactic nicety that has long been missing from JavaScript.
    Another great feature of ECMAScript-2015 are generators. This is, in effect, a
    built in iterator factory. Our fibonacci sequence could be rewritten like the
    following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是JavaScript长期以来一直缺少的一种语法上的美感。ECMAScript-2015的另一个伟大特性是生成器。这实际上是一个内置的迭代器工厂。我们的斐波那契数列可以重写如下：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is used like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这样使用：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Mediator
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调停者
- en: Managing many-to-many relationships in classes can be a complicated prospect.
    Let's consider a form that contains a number of controls, each of which wants
    to know if other controls on the page are valid before performing their action.
    Unfortunately, having each control know about each other control creates a maintenance
    nightmare. Each time a new control is added, each other control needs to be modified.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中管理多对多关系可能是一个复杂的前景。让我们考虑一个包含多个控件的表单，每个控件在执行操作之前都想知道页面上其他控件是否有效。不幸的是，让每个控件都知道其他控件会创建一个维护噩梦。每次添加新控件时，都需要修改每个其他控件。
- en: 'A mediator will sit between the various components and act as a single place
    in which message routing changes can be made. By doing so the mediator simplifies
    the otherwise complex work needed to maintain the code. In the case of controls
    on a form, the mediator is likely to be the form itself. The mediator acts much
    like a real life mediator would, clarifying and routing information exchange between
    a number of parties:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 调停者将坐在各种组件之间，并作为可以进行消息路由更改的单一位置。通过这样做，调停者简化了维护代码所需的复杂工作。在表单控件的情况下，调停者很可能是表单本身。调停者的作用就像现实生活中的调停者，澄清和路由各方之间的信息交流：
- en: '![Mediator](img/00058.jpeg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![调停者](img/00058.jpeg)'
- en: Implementation
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: In the land of Westeros there are many times when a mediator is needed. Frequently
    the mediator ends up deceased, but I'm sure that won't be the case with our example.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛大陆，经常需要调停者。调停者经常会死去，但我相信这不会发生在我们的例子中。
- en: There are a number of great families in Westeros who own large castles and vast
    tracts of land. Lesser lords swear themselves to the great houses forming an alliance,
    frequently supported through marriage.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛大陆有许多伟大的家族拥有大型城堡和广阔的土地。较小的领主向大家族效忠，形成联盟，通常通过婚姻得到支持。
- en: When coordinating the various houses sworn to them, the great lord will act
    as a mediator, communicating information back and forth between the lesser lords
    and resolving any disputes they may have amongst themselves.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在协调向他们宣誓效忠的各家时，伟大领主将充当调停者，来回传递信息并解决他们之间可能发生的任何争端。
- en: 'In this example we''ll greatly simplify the communication between the houses
    and say that all messages pass through the great lord. In this case we''ll use
    the house of Stark as our great lord. They have a number of other houses which
    talk with them. Each of the houses looks roughly like the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将大大简化各家之间的通信，并且假设所有消息都通过伟大的领主传递。在这种情况下，我们将使用史塔克家作为我们的伟大领主。他们有许多其他家族与他们交谈。每个家族看起来大致如下：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'They have two functions, one of which receives messages from a third party
    and one of which sends messages out to their great lord, which is set upon instantiation.
    The `HouseStark` class looks like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 他们有两个函数，一个接收来自第三方的消息，另一个发送消息给他们的伟大领主，这在实例化时设置。`HouseStark`类看起来像下面这样：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By passing all messages through the `HouseStark` class the various other houses
    do not need to concern themselves with how their messages are routed. This responsibility
    is handed off to `HouseStark` which acts as the mediator.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`HouseStark`类传递所有消息，其他各家就不需要关心它们的消息是如何路由的。这个责任被交给了`HouseStark`，它充当了调停者。
- en: Mediators are best used when the communication is both complex and well defined.
    If the communication is not complex then the mediator adds extra complexity. If
    the communication is ill defined then it becomes difficult to codify the communication
    rules in a single place.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 调停者在通信既复杂又明确定义时最好使用。如果通信不复杂，那么调停者会增加额外的复杂性。如果通信不明确定义，那么在一个地方编码通信规则就会变得困难。
- en: 'Simplifying communication between many-to-many objects is certainly useful
    in JavaScript. I would actually argue that in many ways jQuery acts as a mediator.
    When acting on a set of items on the page, it serves to simplify communication
    by abstracting away code''s need to know exactly which objects on the page are
    being changed. For instance:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中简化多对多对象之间的通信肯定是有用的。我实际上认为在许多方面，jQuery充当了调停者的角色。在页面上对一组项目进行操作时，它通过抽象代码的需求来简化通信，使其不需要准确知道页面上正在更改的对象。例如：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Is jQuery shorthand for toggling the visibility of all the elements on the page
    which have the `error` class?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是切换页面上所有具有“error”类的元素可见性的简写吗？
- en: Memento
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备忘录
- en: 'In the section on the command pattern we talked briefly about the ability to
    undo operations. Creating reversible commands is not always possible. For many
    operations there is no apparent reversing operation which can restore the original
    state. For instance, imagine code which squares a number:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令模式的部分，我们简要讨论了撤销操作的能力。创建可逆命令并不总是可能的。对于许多操作，没有明显的逆向操作可以恢复原始状态。例如，想象一下对一个数字求平方的代码：
- en: '[PRE28]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Giving this code -9 will result in 81 but giving it 9 will also result in 81\.
    There is no way to reverse this command without additional information.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 给这段代码-9将得到81，但给它9也将得到81。没有办法在没有额外信息的情况下撤销这个命令。
- en: The memento pattern provides an approach to restore the state of objects to
    a previous state. The memento keeps a record of the previous values of a variable
    and provides the functionality to restore them. Keeping a memento around for each
    command allows for easy restoration of non-reversible commands.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录模式提供了一种将对象状态恢复到先前状态的方法。备忘录记录了变量的先前值，并提供了恢复它们的功能。为每个命令保留一个备忘录可以轻松恢复不可逆转的命令。
- en: 'In addition to an undo-stack there are many instances where having the ability
    to roll back the state of an object is useful. For instance doing what-if analysis
    requires that you make some hypothetical changes to state and then observe how
    things change. The changes are generally not permanent so they could be rolled
    back using the memento pattern or, if the projects are desirable, left in place.
    A diagram of the memento pattern can be seen here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了撤销堆栈之外，还有许多情况下，具有回滚对象状态的能力是有用的。例如，进行假设分析需要对状态进行一些假设性的更改，然后观察事物如何变化。这些更改通常不是永久性的，因此可以使用备忘录模式进行回滚，或者如果项目是可取的，可以保留在原地。备忘录模式的图表可以在这里看到：
- en: '![Memento](img/00059.jpeg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![备忘录](img/00059.jpeg)'
- en: 'A typical memento implementation involves three players:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的备忘录实现涉及三个参与者：
- en: '**Originator**: The originator holds some form of state and provides an interface
    for generating new mementos.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发起人**：发起人持有某种形式的状态，并提供一个生成新备忘录的接口。'
- en: '**Caretaker**: This is the client of the pattern, it is what requests that
    new mementos be taken and governs when they are to be restored.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**看护者**：这是模式的客户端，它请求获取新的备忘录，并管理何时进行恢复。'
- en: '**Memento**: This is a representation of the saved state of the originator.
    This is what can be persisted to storage to allow for rolling back.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备忘录**：这是发起人保存状态的表示。这是可以持久化到存储中以便进行回滚的内容。'
- en: It can help to think of the members of the memento pattern as a boss and a secretary
    taking notes. The boss (caretaker) dictates some memo to the secretary (originator)
    who writes notes in a notepad (memento). From time to time the boss may request
    that the secretary cross out what he has just written.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将备忘录模式的成员想象成老板和秘书记录笔记。老板（看护者）向秘书（发起人）口述备忘录，秘书在备忘录中写下笔记。偶尔，老板可能会要求秘书划掉他刚写的内容。
- en: The involvement of the caretaker can be varied slightly with the memento pattern.
    In some implementation the originator will generate a new memento each time a
    change is made to its state. This is commonly known as copy on write, as a new
    copy of the state is created and the change applied to it. The old version can
    be saved to a memento.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在备忘录模式中，看护者的参与可以稍微有所不同。在一些实现中，发起人每次对其状态进行更改时都会生成一个新的备忘录。这通常被称为写时复制，因为会创建状态的新副本，并将更改应用于它。旧版本可以保存到备忘录中。
- en: Implementation
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: In the land of Westeros there are a number of soothsayers, foretellers of the
    future. They work by using magic to peer into the future and examine how certain
    changes in the present will play out in the future. Often there is need for numerous
    foretelling with slightly different starting conditions. When setting their starting
    conditions, a memento pattern is invaluable.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛大陆上有许多预言者，他们是未来的预言者。他们通过使用魔法来窥视未来，并研究现在的某些变化将如何在未来发挥作用。通常需要进行许多具有略有不同起始条件的预测。在设置其起始条件时，备忘录模式是非常宝贵的。
- en: 'We start off with a world state which gives information on the state of the
    world for a certain starting point:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先有一个世界状态，它提供了某个起始点的世界状态信息：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This `WorldState` class is responsible for tracking all the conditions that
    make up the world. It is what is altered by the application every time a change
    to the starting conditions is made. Because this world state encompasses all the
    states for the application, it can be used as a memento. We can serialize this
    object and save it to disk or send it back to some history server somewhere.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`WorldState`类负责跟踪构成世界的所有条件。每当应用程序对起始条件进行更改时，它就会被改变。因为这个世界状态包含了应用程序的所有状态，它可以被用作备忘录。我们可以将这个对象序列化并保存到磁盘上，或者发送回某个历史服务器。
- en: 'The next thing we need is a class which provides the same state as the memento
    and allows for the creation and restoration of mementos. In our example we''ve
    called this as `WorldStateProvider`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个类，它提供与备忘录相同的状态，并允许创建和恢复备忘录。在我们的示例中，我们将其称为`WorldStateProvider`：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally we need a client for the foretelling, which we''ll call `Soothsayer`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个预言者的客户端，我们将其称为`Soothsayer`：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This class provides a number of convenience methods which alter the state of
    the world and then run a foretelling. Each of these methods pushes the previous
    state into the history array, `startingPoints`. There is also a method, `tryADifferentChange`,
    which undoes the previous state change ready to run another foretelling. The undo
    is performed by loading back the memento which is stored in an array.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类提供了一些方便的方法，它们改变世界的状态，然后运行预测。这些方法中的每一个都将先前的状态推送到历史数组`startingPoints`中。还有一个名为`tryADifferentChange`的方法，它撤消先前的状态更改，准备运行另一个预测。撤消是通过加载存储在数组中的备忘录来执行的。
- en: Despite a great pedigree it is very rare that client side JavaScript applications
    provide an undo function. I'm sure there are various reasons for this, but for
    the most part it is likely that people do not expect such functionality. However
    in most desktop applications, having an undo function is expected. I imagine that,
    as client side applications continue to grow in their capabilities, undo functionality
    will become more important. When it does, the memento pattern is a fantastic way
    of implementing the undo stack.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管客户端JavaScript应用有很好的血统，但提供撤销功能非常罕见。我相信这其中有各种原因，但大部分原因可能是人们并不期望有这样的功能。然而，在大多数桌面应用程序中，撤销功能是被期望的。我想象，随着客户端应用程序在能力上继续增长，撤销功能将变得更加重要。当这种情况发生时，备忘录模式是实现撤销堆栈的一种绝妙方式。
- en: Observer
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者
- en: The observer pattern is perhaps the most used pattern in the JavaScript world.
    The pattern is used especially with modern single pages applications; it is a
    big part of the various libraries that provide **Model View View-Model** (**MVVM**)
    functionality. We'll explore those patterns in some detail in [Chapter 7](part0134_split_000.html#3VPBC1-015e68c68a464f18a9559f448be84435
    "Chapter 7. Reactive Programming"), *Reactive Programming*.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式可能是JavaScript世界中最常用的模式。该模式特别在现代单页面应用程序中使用；它是提供**模型视图视图模型**（**MVVM**）功能的各种库的重要部分。我们将在[第7章](part0134_split_000.html#3VPBC1-015e68c68a464f18a9559f448be84435
    "第7章. 响应式编程")中详细探讨这些模式，*响应式编程*。
- en: 'It is frequently useful to know when the value on an object has changed. In
    order to do so you could wrap up the property of interest with a getter and setter:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 了解对象上的值何时发生变化通常是非常有用的。为了做到这一点，您可以使用getter和setter封装感兴趣的属性：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The setter function can now be augmented with a call to some other object which
    is interested in knowing that a value has changed:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个setter函数可以通过调用对某个对值发生变化感兴趣的其他对象来进行增强：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This setter will now notify the listener that a property change has occurred.
    In this case both the old and new value have been included. This is not necessary
    as the listener can be tasked with keeping track of the previous value.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个setter将通知监听器属性已发生更改。在这种情况下，旧值和新值都已包括在内。这并非必需，因为监听器可以负责跟踪先前的值。
- en: 'The observer pattern generalizes and codifies this idea. Instead of having
    a single call to the listener, the observer pattern allows interested parties
    to subscribe to change notifications. Multiple subscribers can be seen in the
    following diagram:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式概括和系统化了这个想法。观察者模式允许感兴趣的各方订阅更改通知，而不是只有一个对监听器的调用。多个订阅者可以在下图中看到：
- en: '![Observer](img/00060.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![观察者](img/00060.jpeg)'
- en: Implementation
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: The court of Westeros is a place of great intrigue and trickery. Controlling
    who is on the throne and what moves they make is a complex game. Many of the players
    in the game of thrones employ numerous spies to discover what moves others are
    making. Frequently these spies are employed by more than one player and must report
    what they have found to all of the players.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 维斯特洛的法庭是一个充满阴谋和诡计的地方。控制谁坐在王位上以及他们的举动是一场复杂的游戏。权力的游戏中的许多玩家雇佣了许多间谍来发现其他人的举动。这些间谍经常被多个玩家雇佣，并且必须向所有玩家报告他们所发现的情况。
- en: The spy is a perfect place to employ the observer pattern. In our particular
    example, the spy being employed is the official doctor to the king and the players
    are very interested in how much painkiller is being prescribed to the ailing king.
    Knowing this can give a player advanced knowledge of when the king might die –
    a most useful piece of information.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍是应用观察者模式的理想场所。在我们的特定示例中，被使用的间谍是国王的官方医生，玩家们对国王被开了多少止痛药非常感兴趣。了解这一点可以让玩家提前知道国王可能何时去世
    - 这是一条非常有用的信息。
- en: 'The spy looks like the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍看起来像这样：
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In other languages, the subscriber usually has to comply with a certain interface
    and the observer will call only the interface method. This encumbrance doesn''t
    exist with JavaScript and, in fact, we just give the `Spy` class a function. This
    means that there is no strict interface required for the subscriber. This is an
    example:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，订阅者通常必须遵守特定的接口，观察者只会调用接口方法。在JavaScript中不存在这种限制，实际上，我们只是给`Spy`类一个函数。这意味着订阅者不需要严格的接口。这是一个例子：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This can be used like so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可以这样使用：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This provides a very simple and highly effective way of building observers.
    Having subscribers decouples the subscriber from the observable object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一种非常简单且高效的构建观察者的方法。订阅者使订阅者与可观察对象解耦。
- en: The observer pattern can also be applied to methods as well as properties. In
    so doing you can provide hooks for additional behavior to happen. This is a common
    method of providing a plugin infrastructure for JavaScript libraries.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式也可以应用于方法和属性。通过这样做，您可以提供用于发生其他行为的挂钩。这是为JavaScript库提供插件基础设施的常见方法。
- en: 'In browsers all the event listeners on various items in the DOM are implemented
    using the observer pattern. For instance, using the popular jQuery library, one
    can subscribe to all the `click` events on buttons on a page by doing the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，DOM中各种项目的所有事件侦听器都是使用观察者模式实现的。例如，使用流行的jQuery库，可以通过以下方式订阅页面上所有按钮的`click`事件：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Even in vanilla JavaScript the same pattern applies:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在纯JavaScript中，相同的模式也适用：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Clearly the observer pattern is very useful when dealing with JavaScript. There
    is no need to change the pattern in any significant fashion.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当处理JavaScript时，观察者模式非常有用。没有必要在任何重大程度上改变模式。
- en: State
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态
- en: 'State machines are an amazingly useful device in computer programming. Unfortunately
    they are not used very frequently by most programmers. I''m sure that at least
    some of the objection to state machines is that many people implement them as
    a giant `if` statement like so:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机在计算机编程中是一种非常有用的设备。不幸的是，大多数程序员并不经常使用它们。我相信对状态机的一些反对意见至少部分是因为许多人将它们实现为一个巨大的`if`语句，如下所示：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is just a sample of what could be much longer. The `if` statements of this
    length are painful to debug and highly error prone. Simply flipping a greater
    than sign is enough to drastically change how the `if` statement works.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个可能更长的示例。这种长度的`if`语句很难调试，而且容易出错。只需翻转大于号就足以大大改变`if`语句的工作方式。
- en: 'Instead of using a single giant `if` statement block we can make use of the
    state pattern. The state pattern is characterized by having a state manager which
    abstracts away the internal state and proxies a message through to the appropriate
    state which is implemented as a class. All the logic within states and governing
    state transitions is governed by the individual state classes. The state manager
    pattern can be seen in the following diagram:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用状态模式，而不是使用单个巨大的`if`语句块。状态模式的特点是有一个状态管理器，它抽象了内部状态，并将消息代理到适当的状态，该状态实现为一个类。所有状态内部的逻辑和管理状态转换的逻辑都由各个状态类管理。状态管理器模式可以在以下图表中看到：
- en: '![State](img/00061.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![State](img/00061.jpeg)'
- en: Splitting state into a class per state allows for much smaller blocks of code
    to debug and makes testing much easier.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态分为每个状态一个类可以使调试的代码块更小，使测试更容易。
- en: The interface for the state manager is fairly simple and usually just provides
    the methods needed to communicate with the individual states. The manager may
    also contain some shared state variables.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 状态管理器的接口相当简单，通常只提供与各个状态通信所需的方法。管理器还可能包含一些共享状态变量。
- en: Implementation
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: As alluded to in the `if` statement example, Westeros has a banking system.
    Much of it is centered on the island of Braavos. Banking there runs in much the
    same way as banking here, with accounts, deposits, and withdrawals. Managing the
    state of a bank account involves keeping an eye on all of the transactions and
    changing the state of the bank account in accordance with the transactions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在`if`语句示例中所暗示的，维斯特洛有一个银行系统。其中大部分集中在布拉沃斯岛上。那里的银行业务与这里的银行业务基本相同，包括账户、存款和取款。管理银行账户的状态涉及监视所有交易并根据交易改变银行账户的状态。
- en: 'Let''s take a look at some of the code which is needed to manage a bank account
    at the Iron Bank of Braavos. First is the state manager:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看管理布拉沃斯银行账户所需的一些代码。首先是状态管理器：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `BankAccountManager` class provides a state for the current balance and
    also the current state. To protect the balance, it provides an accessory for reading
    the balance and another for adding to the balance. In a real banking application,
    I would rather expect the function that sets the balance, have more protection
    than this. In this version of `BankManager`, the ability to manipulate the current
    state is accessible to the states. They have the responsibility to change states.
    This functionality can be centralized in the manager but that increases the complexity
    of adding new states.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`BankAccountManager`类提供了当前余额和当前状态的状态。为了保护余额，它提供了一个用于读取余额的辅助工具，另一个用于增加余额。在真实的银行应用程序中，我更希望设置余额的功能比这个更有保护性。在这个版本的`BankManager`中，操作当前状态的能力对状态是可访问的。它们有责任改变状态。这个功能可以在管理器中集中，但这会增加添加新状态的复杂性。'
- en: 'We''ve identified three simple states for the bank account: `Overdrawn`, `OnHold`,
    and `GoodStanding`. Each one is responsible for dealing with withdrawals and deposits
    when in that state. The `GoodStandingstate` class looks like the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经确定了银行账户的三种简单状态：`Overdrawn`、`OnHold`和`GoodStanding`。每个状态在该状态下负责处理取款和存款。`GoodStandingstate`类如下所示：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `OverdrawnState` class looks like the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`OverdrawnState`类如下所示：'
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, the `OnHold` state looks like the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`OnHold`状态如下所示：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can see that we've managed to reproduce all the logic of the confusing `if`
    statement in a number of simple classes. The amount of code here looks to be far
    more than the `if` statement but, in the long run, encapsulating the code into
    individual classes will pay off.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们已经成功地将混乱的`if`语句的所有逻辑重现为一些简单的类。这里的代码量看起来比`if`语句要多得多，但从长远来看，将代码封装到单独的类中将会得到回报。
- en: 'There is plenty of opportunity to make use of this pattern within JavaScript.
    Keeping track of state is a typical problem in most applications. When the transitions
    between the states are complex, then wrapping it up in a state pattern is one
    method of simplifying things. It is also possible to build up a simple workflow
    by registering events as sequential. A nice interface for this might be a fluent
    one so that you could register states like the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中有很多机会利用这种模式。跟踪状态是大多数应用程序中的典型问题。当状态之间的转换很复杂时，将其封装在状态模式中是简化事情的一种方法。还可以通过注册事件来构建一个简单的工作流程。这样做的一个不错的接口可能是一个流畅的接口，这样你就可以注册以下状态：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Strategy
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略
- en: 'It has been said that there is more than one way to skin a cat. I have, wisely,
    never looked into how many ways there are. The same is frequently true for algorithms
    in computer programming. Frequently there are numerous versions of an algorithm
    that trades off memory usage for CPU usage. Sometimes there are different approaches
    that provide different levels of fidelity. For example, performing a geo-location
    on a smart phone typically uses one of three different sources of data:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有人说过，剥猫皮有多种方法。我明智地从未探究过有多少种方法。在计算机编程中，算法经常也是如此。通常有许多版本的算法，它们在内存使用和CPU使用之间进行权衡。有时会有不同的方法提供不同级别的保真度。例如，在智能手机上执行地理定位通常使用三种不同的数据来源之一：
- en: GPS chip
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPS芯片
- en: Cell phone triangulation
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手机三角定位
- en: Nearby WiFi points
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附近的WiFi点
- en: Using the GPS chip provides the highest level of fidelity however it is also
    the slowest and requires the most battery. Looking at the nearby WiFi points requires
    very little energy and is very quick, however it provides poor fidelity.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GPS芯片提供了最高级别的保真度，但也是最慢的，需要最多的电池。查看附近的WiFi点需要非常少的能量，速度非常快，但提供的保真度较差。
- en: 'The strategy pattern provides a method of swapping these strategies out in
    a transparent fashion. In a traditional inheritance model each strategy would
    implement the same interface which would allow for any of the strategies to be
    swapped in. The following diagram shows multiple strategies that could be swapped
    in:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式提供了一种以透明方式交换这些策略的方法。在传统的继承模型中，每种策略都应该实现相同的接口，这将允许任何策略被替换。下图显示了可以替换的多种策略：
- en: '![Strategy](img/00062.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![策略](img/00062.jpeg)'
- en: Selecting the correct strategy to use can be done in a number of different ways.
    The simplest method is to select the strategy statically. This can be done through
    a configuration variable or even hard coded. This approach is best for times when
    the strategy changes infrequently or is specific to a single customer or user.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要使用的正确策略可以通过多种不同的方式来完成。最简单的方法是静态选择策略。这可以通过配置变量或甚至硬编码来完成。这种方法最适合策略变化不频繁或特定于单个客户或用户的情况。
- en: Alternately an analysis can be run on the dataset on which the strategy is to
    be run and then a proper strategy selected. If it is known that strategy A works
    better than strategy B when the data passed in is clustered around a mean, then
    a fast algorithm for analyzing spread could be run first and then the appropriate
    strategy selected.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以对要运行策略的数据集进行分析，然后选择适当的策略。如果已知策略A在传入的数据围绕均值聚集时比策略B更有效，那么可以首先运行一个用于分析传播的快速算法，然后选择适当的策略。
- en: If a particular algorithm fails on data of a certain type, this too can be taken
    into consideration when choosing a strategy. In a web application this can be
    used to call a different API depending on the shape of data. It can also be used
    to provide a fallback mechanism should one of the API endpoints be down.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果特定算法在某种类型的数据上失败，这也可以在选择策略时考虑进去。在Web应用程序中，这可以用于根据数据的形状调用不同的API。它还可以用于在API端点之一宕机时提供备用机制。
- en: Another interesting approach is to use progressive enhancement. The fastest
    and least accurate algorithm is run first to provide rapid user feedback. At the
    same time a slower algorithm is also run and, when it is finished, the superior
    results are used to replace the existing results. This approach is frequently
    used in the GPS situation outlined above. You may notice when using a map on a
    mobile device your location is updated a moment after the map loads; this is an
    example of progressive enhancement.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有趣的方法是使用渐进增强。首先运行最快且最不准确的算法，以提供快速的用户反馈。同时，也运行一个较慢的算法，当它完成时，优越的结果将用于替换现有的结果。这种方法经常用于上面概述的GPS情况。您可能会注意到，在移动设备上使用地图时，地图加载后一会儿您的位置会更新；这是渐进增强的一个例子。
- en: Finally, the strategy can be chosen completely at random. It sounds like a strange
    approach but can be useful when comparing the performance of two different strategies.
    In this case, statistics would be gathered about how well each approach works
    and an analysis run to select the best strategy. The strategy pattern can be the
    foundation for A/B testing.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，策略可以完全随机选择。这听起来像是一种奇怪的方法，但在比较两种不同策略的性能时可能会有用。在这种情况下，将收集关于每种方法的表现如何的统计数据，并进行分析以选择最佳策略。策略模式可以成为A/B测试的基础。
- en: Selecting which strategy to use can be an excellent place to apply the factory
    pattern.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要使用的策略可以是应用工厂模式的绝佳地方。
- en: Implementation
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: 'In the land of Westeros there are no planes, trains, or automobiles but there
    is still a wide variety of different ways to travel. One can walk, ride a horse,
    sail on a seagoing vessel, or even take a boat down the river. Each one has different
    advantages and drawbacks but in the end they still take a person from point A
    to point B. The interface might look something like the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛大陆上没有飞机、火车或汽车，但仍然有各种不同的旅行方式。一个人可以步行、骑马、乘坐海上船只航行，甚至可以坐船沿河而下。每种方式都有不同的优势和缺点，但最终它们都可以把一个人从A点带到B点。接口可能看起来像下面这样：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The travel result communicates back to the caller some information about the
    method of travel. In our case we track how long the trip will take, what the risks
    are, and how much it will cost:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行结果向调用者传达了有关旅行方式的一些信息。在我们的情况下，我们跟踪旅行将花费多长时间，有哪些风险，以及它将花费多少钱：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this scenario we might like to have an additional method which predicts some
    of the risks to allow for automating selection of a strategy.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能希望有一个额外的方法来预测一些风险，以便自动选择一种策略。
- en: 'Implementing the strategies is as simple as the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 实施策略就像下面这样简单：
- en: '[PRE47]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In a traditional implementation of the strategy pattern the method signature
    for each strategy should be the same. In JavaScript there is a bit more flexibility
    as excess parameters to a function are ignored and missing parameters can be given
    default values.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在策略模式的传统实现中，每种策略的方法签名应该是相同的。在JavaScript中，有更多的灵活性，因为对函数的多余参数将被忽略，缺少的参数可以给出默认值。
- en: 'Obviously, the actual calculations around risk, cost, and duration would not
    be hard coded in an actual implementation. To make use of these one needs only
    to do the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在实际实现中，围绕风险、成本和持续时间的实际计算不会被硬编码。要使用这些，只需要做以下操作：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To improve the level of abstraction for this strategy we might replace the
    specific strategies with more generally named ones that describe what it is we''re
    optimizing for:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高这种策略的抽象级别，我们可以用更一般的名称替换具体的策略，描述我们正在优化的内容：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Strategy is a very useful pattern in JavaScript. We''re also able to make the
    approach much simpler than in a language which doesn''t use prototype inheritance:
    there is no need for an interface. We don''t need to return the same shaped object
    from each of the different strategies. So long as the caller is somewhat aware
    that the returned object may have additional fields, this is a perfectly reasonable,
    if difficult to maintain, approach.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式在JavaScript中是一种非常有用的模式。我们还能够使这种方法比在不使用原型继承的语言中更简单：不需要接口。我们不需要从不同的策略中返回相同形状的对象。只要调用者有点意识到返回的对象可能有额外的字段，这是一个完全合理的，虽然难以维护的方法。
- en: Template method
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法
- en: 'The strategy pattern allows for replacing an entire algorithm with a complimentary
    one. Frequently, replacing the entire algorithm is overkill: the vast majority
    of the algorithm remains the same in every strategy with only minor variations
    in specific sections.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式允许用补充的算法替换整个算法。经常情况下，替换整个算法是过度的：几乎所有的算法在每个策略中都是相同的，只有特定部分有轻微的变化。
- en: 'The template method pattern is an approach which allows for some sections of
    an algorithm to be shared and other sections implemented using different approaches.
    These farmed out sections can be implemented by any one of a family of methods:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式是一种方法，允许共享算法的一些部分，并使用不同的方法实现其他部分。这些外包部分可以由任何一种方法实现：
- en: '![Template method](img/00063.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![模板方法](img/00063.jpeg)'
- en: The template class implements parts of the algorithm and leaves other parts
    as abstract to later be overridden by classes which extend it. The inheritance
    hierarchy can be several layers deep, with each level implementing more and more
    of the template class.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 模板类实现了算法的部分，并将其他部分作为抽象留待后续由扩展它的类覆盖。继承层次结构可以有几层深，每个级别都实现了模板类的更多部分。
- en: Tip
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: An abstract class is one that contains abstract methods. Abstract methods are
    simply methods that have no body to them. The abstract class cannot be used directly
    and must, instead, be extended by another class that implements the abstract methods.
    An abstract class may extend another abstract class so that not all methods need
    to be implemented by the extending class.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是包含抽象方法的类。抽象方法只是没有具体实现的方法。抽象类不能直接使用，必须由另一个实现抽象方法的类来扩展。抽象类可以扩展另一个抽象类，以便不需要所有方法都由扩展类实现。
- en: 'This approach applies the principles of progressive enhancement to an algorithm.
    We move closer and closer to a fully implemented algorithm and, at the same time,
    build up an interesting inheritance tree. The template method helps keep identical
    code to a single location while still allowing for some deviation. A chain of
    partial implementations can be seen in the following diagram:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法将渐进增强的原则应用到算法中。我们逐渐接近一个完全实现的算法，同时建立一个有趣的继承树。模板方法有助于将相同的代码保持在一个位置，同时允许一些偏差。部分实现的链可以在下图中看到：
- en: '![Template method](img/00064.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![模板方法](img/00064.jpeg)'
- en: Overriding methods left as abstract is a quintessential part of object oriented
    programming. It is likely that this pattern is one which you've used frequently
    without even being aware that it had a name.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖留待为抽象的方法是面向对象编程的一个典型部分。很可能这种模式是你经常使用的，甚至没有意识到它有一个名字。
- en: Implementation
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施
- en: I have been told, by those in the know, that there are many different ways to
    produce beer. These beers differ in their choice of ingredients and in their method
    of production. In fact beer does not even need to contain hops – it can be made
    from any number of grains. However there are similarities between all beers. They
    are all created through the fermentation process and all proper beers contain
    some alcohol content.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我被知情者告知，有许多不同的生产啤酒的方法。这些啤酒在选择原料和生产方法上有所不同。事实上，啤酒甚至不需要含有啤酒花 - 它可以由任意数量的谷物制成。然而，所有的啤酒之间都有相似之处。它们都是通过发酵过程制作的，所有合格的啤酒都含有一定的酒精含量。
- en: 'In Westeros there are a great number of craftsmen who pride themselves on creating
    top notch beers. We would like to describe their processes as a set of classes,
    each one describing a different beer making methodology. We start with a simplified
    implementation of creating a beer:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在维斯特洛有许多自豪地制作顶级啤酒的工匠。我们想要将他们的工艺描述为一组类，每个类描述一种不同的啤酒制作方法。我们从一个简化的啤酒制作实现开始：
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As there is no concept of abstract in JavaScript we''ve added exceptions to
    the various methods which must be overridden. The remaining methods can be changed
    but do not require it. An implementation of this for a raspberry beer would look
    like the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript中没有抽象的概念，我们已经为必须被覆盖的各种方法添加了异常。剩下的方法可以被改变，但不是必须的。树莓啤酒的实现看起来像下面这样：
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Additional sub-classing may be performed at this stage for more specific raspberry
    beers.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段可以进行更具体的覆盖，以制作更具体的树莓啤酒。
- en: The template method remains a fairly useful pattern in JavaScript. There is
    some added syntactic sugar around creating classes, but it isn't anything we haven't
    already seen in a previous chapter. The only warning I would give is that the
    template method uses inheritance and thus strongly couples the inherited classes
    with the parent class. This is generally not a desirable state of affairs.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法在JavaScript中仍然是一个非常有用的模式。在创建类时有一些额外的语法糖，但这并不是我们在之前章节中没有见过的。我唯一的警告是，模板方法使用继承，因此将继承类与父类强烈耦合。这通常不是一种理想的状态。
- en: Visitor
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者
- en: The final pattern in this section is the visitor pattern. The visitor provides
    a method of decoupling an algorithm from the object structure on which it operates.
    If we wanted to perform some action over a collection of objects which differ
    in type and we want to perform a different action depending on the object type,
    we would typically need to make use of a large `if` statement.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的最后一个模式是访问者模式。访问者提供了一种将算法与其操作的对象结构解耦的方法。如果我们想对一组不同类型的对象执行某些操作，并且根据对象类型执行不同的操作，我们通常需要使用一个大的`if`语句。
- en: 'Let''s get right into an example of this in Westeros. An army is made up of
    a few different classes of fighting person (it is important that we be politically
    correct as there are many notable female fighters in Westeros). However, each
    member of the army implements a hypothetical interface called `IMemberOfArmy`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接进入到维斯特洛的一个例子中。一个军队由几个不同类的战斗人员组成（重要的是我们要政治正确，因为维斯特洛有许多著名的女性战士）。然而，军队的每个成员都实现了一个名为`IMemberOfArmy`的假设接口：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A simple implementation of this might be the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个的简单实现可能是以下内容：
- en: '[PRE53]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now we have a collection of these different types, we can use an `if` statement
    to only call the `printName` function on the knights:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些不同类型的集合，我们可以使用`if`语句只在骑士上调用`printName`函数：
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Except, if you run this code, you''ll actually find that all we get is the
    following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你运行这段代码，否则你实际上会发现我们得到的只是以下内容：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is because, despite an object being a knight, it is still an object and
    `typeof` will return object in all cases.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，尽管一个对象是骑士，但它仍然是一个对象，而`typeof`在所有情况下都会返回对象。
- en: 'An alternative approach is to use `instanceof` instead of `typeof`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用`instanceof`而不是`typeof`：
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The instance of approach works great until we run into somebody who makes use
    of the `Object.create` syntax:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`instance of`方法在遇到使用`Object.create`语法的人时效果很好：'
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Despite being a knight this will return `false` when asked if it is an instance
    of `Knight`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管是一名骑士，当被问及是否是`Knight`的实例时，它将返回`false`。
- en: This poses something of a problem for us. The problem is exacerbated by the
    visitor pattern as it requires that the language supports method overloading.
    JavaScript does not really support this. There are various hacks which can be
    used to make JavaScript somewhat aware of overloaded methods but the usual advice
    is to simply not bother and create methods with different names.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们来说构成了一些问题。问题被访问者模式加剧了，因为它要求语言支持方法重载。JavaScript实际上并不支持这一点。有各种各样的技巧可以用来使JavaScript在某种程度上意识到重载的方法，但通常的建议是简单地不要费心，创建具有不同名称的方法。
- en: 'Let''s not abandon this pattern just yet, though; it is a useful pattern. What
    we need is a way to reliably distinguish one type from another. The simplest approach
    is to just define a variable on the class which denotes its type:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，让我们不要放弃这种模式；这是一个有用的模式。我们需要的是一种可靠地区分一种类型和另一种类型的方法。最简单的方法就是在类上定义一个表示其类型的变量：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Given the new `_type` variable we can now fake having real method overrides:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有了新的`_type`变量，我们现在可以伪造真正的方法重写：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Given this approach we can now implement a visitor. The first step is to expand
    our various members of the army to have a generic method on them which takes a
    visitor and applies it:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这种方法，我们现在可以实现一个访问者。第一步是扩展我们军队的各种成员，使它们具有一个接受访问者并应用它的通用方法：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now we need to build a visitor. This code approximates the `if` statements
    we had in the preceding code:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要构建一个访问者。这段代码近似于我们在前面的代码中所使用的`if`语句：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This visitor would be used as such:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个访问者将被用作下面这样：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'As you can see we''ve pushed the decisions about the type of the item in the
    collection down to the visitor. This decouples the items themselves from the visitor
    as can be seen in the following diagram:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们把集合中项目的类型决策推迟给了访问者。这将访问者与项目本身解耦，如下图所示：
- en: '![Visitor](img/00065.jpeg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![Visitor](img/00065.jpeg)'
- en: If we allow the visitor to make decisions about what methods are called on the
    visited objects there is a fair bit of trickery required. If we can provide a
    constant interface for the visited objects then all the visitor needs do is call
    the interface method. This does, however, move logic from the visitor into the
    objects that are visited, which is contrary to the idea that the objects shouldn't
    know they are part of a visitor.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们允许访问者决定对被访问对象调用哪些方法，就需要进行相当多的欺骗。如果我们可以为被访问对象提供一个恒定的接口，那么访问者所需做的就是调用接口方法。然而，这将把逻辑从访问者移到被访问的对象中，这与对象不应该知道它们是访问者的想法相矛盾。
- en: Whether suffering through the trickery is worthwhile is really an exercise for
    you. Personally I would tend to avoid using the visitor pattern in JavaScript
    as the requirements to get it working are complicated and non-obvious.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 忍受这种欺骗是否值得，这实际上是你的事。就我个人而言，我倾向于避免在JavaScript中使用访问者模式，因为使其工作的要求是复杂和不明显的。
- en: Hints and tips
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和技巧
- en: 'Here are a couple of brief tips to keep in mind about some of the patterns
    we''ve seen in this chapter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于本章中一些模式的一些简短提示：
- en: When implementing the interpreter pattern you may be tempted to use JavaScript
    proper as your DSL and then use the `eval` function to execute the code. This
    is actually a very dangerous idea as `eval` opens up an entire world of security
    issues. It is generally considered to be very bad form to use `eval` in JavaScript.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现解释器模式时，你可能会想要使用JavaScript本身作为你的DSL，然后使用`eval`函数来执行代码。这实际上是一个非常危险的想法，因为`eval`打开了整个安全问题的世界。在JavaScript中使用`eval`通常被认为是非常不好的做法。
- en: If you find yourself in the position to audit the changes to data in your project,
    then the memento pattern can easily be modified to suit. Instead of keeping track
    of just the state changes, you can also track when the change was made and who
    changed it. Saving these mementos to disk somewhere allows you to go back and
    rapidly build an audit log pointing to precisely what happened to change the object.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你发现自己需要审计项目中的数据变化，那么备忘录模式可以很容易地进行修改以适应。你不仅可以跟踪状态变化，还可以跟踪变化发生的时间和谁进行了更改。将这些备忘录保存到磁盘的某个地方，可以让你回溯并快速构建审计日志，指出对象发生了什么变化。
- en: The observer pattern is notorious for causing memory leaks when listeners aren't
    properly unregistered. This can happen even in a memory managed environment such
    as JavaScript. Be wary of failing to unhook observers.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式因为监听器没有正确注销而臭名昭著地导致内存泄漏。即使在像JavaScript这样的内存管理环境中，这种情况也可能发生。要小心不要忘记取消观察者的注册。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we've looked at a bunch of behavioral patterns. Some of these
    patterns such as observer and iterator will be ones you'll use almost every day,
    while others such as interpreter you might use no more than a handful of times
    in your entire career. Learning about these patterns should help you identify
    well-defined solutions to common problems.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一堆行为模式。其中一些模式，比如观察者和迭代器，几乎每天都会用到，而另一些模式，比如解释器，你可能在整个职业生涯中只会用到几次。了解这些模式应该有助于你找到常见问题的明确定义的解决方案。
- en: Most of the patterns are directly applicable to JavaScript and some of them,
    such as the strategy pattern, become more powerful in a dynamic language. The
    only pattern we found that has some limitations is the visitor pattern. The lack
    of static classes and polymorphism makes this pattern difficult to implement without
    breaking proper separation of concerns.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数模式都可以直接应用于JavaScript，其中一些模式，比如策略模式，在动态语言中变得更加强大。我们发现的唯一有一些限制的模式是访问者模式。缺乏静态类和多态性使得这种模式很难在不破坏关注点分离的情况下实现。
- en: These aren't, by any means, all of the behavioral patterns in existence. The
    programming community has spent the past two decades building on the ideas of
    the GoF book and identifying new patterns. The remainder of this module is dedicated
    to these newly identified patterns. The solutions may be very old ones but not
    generally recognized as common solutions until more recently. As far as I'm concerned
    this is the point where the module starts to get very interesting as we start
    looking at less well known and more JavaScript-specific patterns.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这些并不是全部存在的行为模式。编程社区在过去的二十年里一直在基于GoF书中的思想并识别新的模式。本模块的其余部分致力于这些新识别的模式。这些解决方案可能是非常古老的，但直到最近才被普遍认可为常见解决方案。就我而言，这是模块开始变得非常有趣的地方，因为我们开始研究不那么知名而且更具JavaScript特色的模式。
