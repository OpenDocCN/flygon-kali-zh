- en: Redux
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux
- en: Hi! Good work with the blog in the preceding chapter, and welcome to the last
    chapter of the book, which is a sequel to the blog that we built in the preceding
    chapter. In this chapter, we will fix that annoying 3 second loading issue on
    the blog by learning about centralized state management with Redux.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嗨！在前一章中博客的工作做得很好，欢迎来到本书的最后一章，这是前一章中构建的博客的续集。在本章中，我们将通过学习使用Redux进行集中状态管理来解决博客中令人讨厌的3秒加载问题。
- en: 'Just as we covered only the basics of React in the preceding chapter, this
    chapter is simple and will cover the basic concepts of Redux, which will change
    building web applications forever. That leaves us with only one simple question:
    What is Redux?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在前一章中只涵盖了React的基础知识一样，本章很简单，将涵盖Redux的基本概念，这将永远改变构建Web应用程序的方式。这让我们只剩下一个简单的问题：Redux是什么？
- en: What is Redux?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux是什么？
- en: According to the Redux documentation at: [http://redux.js.org/](http://redux.js.org/),
    Redux is "*a predictable state container for JavaScript apps*". To explain redux
    in detail, let's take a look at the story of **flux**, an application architecture
    built by Facebook.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Redux文档：[http://redux.js.org/](http://redux.js.org/)，Redux是“*JavaScript应用程序的可预测状态容器*”。为了详细解释redux，让我们来看看Facebook构建的应用程序架构**flux**的故事。
- en: Flux
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux
- en: React is all well and good for a small application such as the ToDo list or
    the blog we built in the preceding chapter, except for an application such as
    Facebook. Facebook has hundreds of stateful React components that work to render
    the web application. In our blog, each React component has its state, and each
    stateful component makes a network request to fill these states with data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像ToDo列表或我们在前一章中构建的博客这样的小型应用，React都很好，但对于像Facebook这样的应用就不行了。Facebook有数百个有状态的React组件用于渲染Web应用程序。在我们的博客中，每个React组件都有自己的状态，并且每个有状态的组件都会发出网络请求来填充这些状态数据。
- en: Once parent components get the data, it will get passed to child components
    as props. However, the child component can have its own states too. Likewise,
    there can be two or more parent components in the same level that require the
    same data for the states. React's one-way data flow has a severe problem here.
    If the data is passed to the child component as props, the child component cannot
    change the props, since it will lead to mutation of the data. Hence, the child
    component will have to call a method in the parent component, which also should
    have passed as a prop to make a simple change. Imagine that you have 10s and 100s
    of parent-child nested components, where the control always has to be passed back
    to the parent and the data flow has to be managed properly between the parent
    and children components.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦父组件获取数据，它将作为props传递给子组件。但是，子组件也可以有自己的状态。同样，在同一级别可能有两个或更多需要相同数据状态的父组件。React的单向数据流在这里存在严重问题。如果将数据作为props传递给子组件，子组件无法更改props，因为这将导致数据的变异。因此，子组件将不得不调用父组件中的一个方法，该方法也应该作为props传递以进行简单的更改。想象一下，您有数十甚至数百个父子嵌套组件，其中控制总是必须传递回父组件，并且必须在父子组件之间正确管理数据流。
- en: Facebook needed a simple and maintainable solution for managing data across
    all these components. The ideal solution they came up with was to take the state
    out of the React component and manage it in a separate place called **stores**.
    The plan was simple--we take the state (data) out of the React component and keep
    it in separate stores. All React components will then depend on stores for their
    data. So, you have to pass the required data from stores to all the necessary
    components as props.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook需要一个简单且可维护的解决方案来管理所有这些组件之间的数据。他们提出的理想解决方案是将状态从React组件中取出，并在一个称为**stores**的独立位置进行管理。计划很简单
    - 我们将状态（数据）从React组件中取出，并将其保存在单独的stores中。然后所有的React组件都将依赖于stores来获取它们的数据。因此，您必须将stores中所需的数据作为props传递给所有必要的组件。
- en: Any change in the stores will lead to a change of props in all the dependent
    components, and whenever props change, React will automatically re-render the
    DOM. They came up with special functions called **actions** and **dispatchers**, which
    are the only ones capable of updating stores. So, if any component needs to update
    a store, it will call these functions with the required data, and they will update
    the store. Since the store gets updated, all the components will receive new props,
    and they will get re-rendered with new data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: stores中的任何更改都将导致所有依赖组件中的props发生变化，每当props发生变化时，React将自动重新渲染DOM。他们提出了称为**actions**和**dispatchers**的特殊函数，它们是唯一能够更新stores的函数。因此，如果任何组件需要更新stores，它将使用所需的数据调用这些函数，它们将更新stores。由于stores被更新，所有组件将接收新的props，并且它们将使用新数据重新渲染。
- en: This explains the architecture of flux. The flux architecture was created not
    only for React, but also for general use by all the JavaScript frameworks. However,
    even though the concept of flux was simple, the implementation was quite complex,
    which was later overcome by a new state management library, that is, Redux. Since
    we focus on Redux in this chapter, we won't be discussing flux; however, if you
    are interested in knowing more about flux, you can visit its official page: [https://facebook.github.io/flux/](https://facebook.github.io/flux/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了flux的架构。flux架构不仅为React创建，还为所有JavaScript框架的一般使用创建。然而，尽管flux的概念很简单，但实现起来相当复杂，后来通过一种新的状态管理库Redux来克服了这一问题。由于本章重点介绍Redux，我们不会讨论flux；但是，如果您对了解更多关于flux感兴趣，可以访问其官方页面：[https://facebook.github.io/flux/](https://facebook.github.io/flux/)。
- en: Introduction to Redux
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux简介
- en: The main problem faced by developers who are using flux is that the application
    state is not quite predictable. It's probably why Redux introduces itself as a
    predictable state container for JavasScript apps. Redux was created as a `stand-alone`
    library that can be used with any JavaScript applications. To use Redux with React,
    we will need another library called `react-redux`, which is provided by the React
    community, available at: [https://github.com/reactjs/react-redux](https://github.com/reactjs/react-redux).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用flux的开发人员面临的主要问题是应用程序状态不够可预测。这可能是Redux自称为JavaScript应用程序的可预测状态容器的原因。Redux被创建为一个可以与任何JavaScript应用程序一起使用的`独立`库。要在React中使用Redux，我们将需要另一个名为`react-redux`的库，这是由React社区提供的，可在[https://github.com/reactjs/react-redux](https://github.com/reactjs/react-redux)上找到。
- en: Redux has one of the best documentations for an open source library. It even
    comes with two free video courses by the creator of the library--*Dan Abramov*--which
    are available on the documentation's home page. Before we start adding Redux to
    our blog application, let's take a look at how Redux works and how it will help
    to improve our React application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Redux拥有最好的开源库文档之一。它甚至附带了由库的创建者*Dan Abramov*提供的两个免费视频课程，这些课程可以在文档的主页上找到。在我们开始向博客应用程序添加Redux之前，让我们看看Redux的工作原理以及它将如何帮助改进我们的React应用程序。
- en: 'Consider the Blog app we created in the preceding chapter. We have an **App
    component** as the parent and all the other components are children of the **App
    component**. In our case, each component has its own state, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们在前一章创建的博客应用。我们有一个**App组件**作为父组件，所有其他组件都是**App组件**的子组件。在我们的情况下，每个组件都有自己的状态，如下所示：
- en: '![](../images/00048.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00048.jpeg)'
- en: 'If we were to use flux, it would have multiple stores, and we could have the
    state of the **Post component** list and **Author component** list as two stores
    and let the entire application share those stores. However, if we use Redux, it
    will maintain a *single store*, which will hold the state for the entire application.
    You application structure will be as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用flux，它将具有多个存储，并且我们可以将**Post组件**列表的状态和**Author组件**列表的状态作为两个存储，并让整个应用程序共享这些存储。但是，如果我们使用Redux，它将维护一个*单一存储*，其中将保存整个应用程序的状态。您的应用程序结构将如下所示：
- en: '![](../images/00049.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00049.jpeg)'
- en: As you can see in the preceding image, Redux will create a *single store* that
    holds the state, which can then be supplied to the required components as props.
    Since the entire application has a single state, it becomes easy to maintain and
    the application state becomes more predictable for developers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图像所示，Redux将创建一个*单一存储*，保存状态，然后将其作为props提供给所需的组件。由于整个应用程序具有单一状态，因此更容易维护，并且应用程序状态对开发人员更加可预测。
- en: 'So, let''s take a look at how Redux manages its store. The Redux implementation
    has three important parts:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来看看Redux是如何管理它的存储的。Redux的实现有三个重要部分：
- en: Store
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Store
- en: Actions
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Actions
- en: Reducers
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducers
- en: Store
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Store
- en: A store is a centralized state that contains the entire application state. Like
    normal states, the store is also a simple JavaScript object, which contains only plain
    data (a store object should not contain any methods). Also, the state is read-only,
    which means that other parts of the application cannot directly make changes to
    the state. The only way to modify the state is to emit an action.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 存储是包含整个应用程序状态的集中状态。与普通状态一样，存储也是一个简单的JavaScript对象，只包含纯数据（存储对象不应包含任何方法）。此外，状态是只读的，这意味着应用程序的其他部分不能直接更改状态。修改状态的唯一方法是发出一个动作。
- en: Actions
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Actions
- en: Actions are functions that are designed to perform a task. Whenever a component
    needs to modify the state, it will have to call an action. Actions are supplied
    to the component as props. The return type of an action function should be a plain
    object. The object returned by an action is supplied to the reducers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Actions是设计执行任务的函数。每当组件需要修改状态时，它将调用一个action。Actions作为props提供给组件。动作函数的返回类型应该是一个普通对象。动作返回的对象被提供给reducers。
- en: Reducers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reducers
- en: Reducers are simple methods whose function is to update the store. Since the
    store is a JavaScript object, organized as key-value pairs, each key will have
    its own reducer. The reducer function accepts two arguments, the object returned
    from the action and the current state, and it will return a new state.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Reducers是简单的方法，其功能是更新存储。由于存储是一个以键值对组织的JavaScript对象，每个键都有自己的reducer。reducer函数接受两个参数，从动作返回的对象和当前状态，并返回一个新状态。
- en: Implementing Redux in the blog
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在博客中实现Redux
- en: Now that you have a good idea of why Redux is being used, let's get started
    with implementing Redux in our Blog application. This chapter uses the same server
    that you used in the preceding chapter, hence, you will have to keep the server
    running while working on this chapter too.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对为什么使用Redux有了一个很好的理解，让我们开始在我们的博客应用程序中实现Redux。本章使用与前一章相同的服务器，因此在本章工作时，您还需要保持服务器运行。
- en: 'The starter files for this chapter are the same as the completed code file
    from the preceding chapter, except the `package.json` file, which has the following
    new libraries included in its dependencies:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起始文件与前一章的完成代码文件相同，只是`package.json`文件中包含以下新库作为依赖项：
- en: '`redux`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redux`'
- en: '`react-redux`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-redux`'
- en: '`redux-thunk`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redux-thunk`'
- en: '`redux-persist`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redux-persist`'
- en: '`localforage`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localforage`'
- en: We'll see what each of these libraries does while building our application.
    We will use the same `.env` file that we used in the preceding chapter with the
    `REACT_APP_SERVER_URL` environment variable, whose value is the URL of the running
    server. Navigate to the project root folder in your terminal and execute `npm
    install` followed by `npm start` to start the development server of the application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的应用程序时，我们将看到这些库各自的作用。我们将使用与前一章相同的`.env`文件，其中包含`REACT_APP_SERVER_URL`环境变量，其值是运行服务器的URL。在终端中导航到项目根文件夹，并执行`npm
    install`，然后执行`npm start`以启动应用程序的开发服务器。
- en: The folder structure
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件夹结构
- en: 'The first thing we will need to do before we start with Redux is to define
    a proper folder structure for the Redux components. Currently, this is how our
    `src/` directory looks:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用Redux之前，我们需要为Redux组件定义一个适当的文件夹结构。目前，我们的`src/`目录看起来是这样的：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will need to create a new directory called `redux`, which will hold our
    `store`, `actions`, and `reducers`. Now, the directory structure will look as
    follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为`redux`的新目录，其中将保存我们的`store`，`actions`和`reducers`。现在，目录结构将如下所示：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the `redux` directory, you will need to create four different directories,
    namely `actions`, `actionTypes`, `reducers`, and `store`. Your `redux` directory
    will now look like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`redux`目录中，您需要创建四个不同的目录，即`actions`，`actionTypes`，`reducers`和`store`。您的`redux`目录现在看起来是这样的：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You might be wondering about the `actionTypes` directory. In Redux, all the
    actions should be predefined. You don't want an uninformed action to happen. Hence,
    we will create the `actionTypes` folder, which will hold constants for all the
    actions that our application can do.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想到`actionTypes`目录。在Redux中，所有操作都应该是预定义的。您不希望发生未知的操作。因此，我们将创建`actionTypes`文件夹，其中将保存应用程序可以执行的所有操作的常量。
- en: Now that we have the required folder structure, let's start with creating our
    initial state.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有了所需的文件夹结构，让我们开始创建我们的初始状态。
- en: Initial state
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始状态
- en: We always define the initial state in our React components in the constructor,
    where we create the state variables. Similarly, we will need to create an initial
    state for our Redux too. The only difference is that the Redux state will have
    to hold the state for the entire app.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是在构造函数中为我们的React组件定义初始状态，我们在那里创建状态变量。同样，我们也需要为我们的Redux创建一个初始状态。唯一的区别是Redux状态将需要保存整个应用程序的状态。
- en: 'Let''s strategize how the initial state will look:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制定初始状态的外观：
- en: The data that is used on the home page of our blog is an array of posts, hence
    we will need a posts array
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在博客主页上使用的数据也是帖子的数组，因此我们需要一个帖子数组
- en: The data used for showing a list of authors is also an array
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于显示作者列表的数据也是一个数组
- en: We also need to maintain states for the AJAX calls and their success or error
    status
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要维护AJAX调用及其成功或错误状态的状态
- en: 'In your `store` directory, create a new file--`initialState.js`--and add the
    following code containing the `initialState` object:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`store`目录中，创建一个新文件--`initialState.js`--并添加包含`initialState`对象的以下代码：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the `initialState` constant contains an empty array for posts
    and authors and an object that has the status information for the three network
    requests (AJAX calls) that we will use in this application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`initialState`常量包含了一个空数组用于帖子和作者，以及一个包含了三个网络请求（AJAX调用）的状态信息的对象，这些我们将在这个应用程序中使用。
- en: Once we add Redux, our application will have to make only three network requests--one
    to get all the posts, one to get all the authors, and the third one to add a new
    post. If we want to see a post in the post details page, we can easily use the
    posts array we got in the first network request.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了Redux，我们的应用程序将只需要进行三个网络请求--一个用于获取所有帖子，一个用于获取所有作者，第三个用于添加新帖子。如果我们想在帖子详情页面看到一个帖子，我们可以轻松地使用我们在第一个网络请求中得到的帖子数组。
- en: 'Your `redux` folder should now look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`redux`文件夹现在应该是这样的：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Action types
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作类型
- en: Now that we have got our initial state ready, let's define all the actions our
    Blog application can do. Actions in our blog are nothing but the network requests
    we make to retrieve data. Each network request will have four actions associated
    with it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了初始状态，让我们定义我们的博客应用程序可以执行的所有操作。在我们的博客中，操作实际上就是我们进行检索数据的网络请求。每个网络请求将与四个操作相关联。
- en: 'Consider the request where we get all the blog posts from the server. The actions
    associated with this network request will be as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下我们从服务器获取所有博客帖子的请求。与这个网络请求相关的操作将如下所示：
- en: Start the AJAX call
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始AJAX调用
- en: Network request success
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络请求成功
- en: Network request failure
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络请求失败
- en: Get posts data
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取帖子数据
- en: 'So, in your `redux/actionTypes` directory, create an `actionTypes.js` file
    that will hold a constant value for all the actions that will happen in our application.
    In the `actionTypes.js` file, add the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在您的`redux/actionTypes`目录中，创建一个`actionTypes.js`文件，其中将保存应用程序中将发生的所有操作的常量值。在`actionTypes.js`文件中，添加以下代码：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Your `redux` folder should have the following structure now:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`redux`文件夹现在应该有以下结构：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have created the `actionTypes`, which we can use throughout the application,
    so let's create the actions that the application should use to update the state.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`actionTypes`，我们可以在整个应用程序中使用它，因此让我们创建应用程序应该使用的操作来更新状态。
- en: Actions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作
- en: Actions are dispatched from the React components when they need to modify the
    state of the application. We need two actions for our application, one for the
    posts page and one for the authors page. However, as in the preceding chapter,
    I'll only focus on the posts page; you can work on the authors page once you are
    done with this chapter. The completed code files have the actions completed for
    the authors page too, so you can use it as your reference.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当React组件需要修改应用程序的状态时，会从React组件中分派操作。我们的应用程序需要两个操作，一个用于帖子页面，一个用于作者页面。然而，就像前一章一样，我只会专注于帖子页面；完成本章后，您可以继续处理作者页面。已完成的代码文件也包含了作者页面的操作，因此您可以将其用作参考。
- en: 'Let''s get started. In the `actions` directory, create two files, `authorActions.js`
    and `postActions.js`. Your `redux` folder should look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。在`actions`目录中，创建两个文件，`authorActions.js`和`postActions.js`。您的`redux`文件夹应该是这样的：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, leave the `authorActions.js` file empty, and we''ll work on the `postActions.js`
    file. This is how a standard action function should look:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，将`authorActions.js`文件保留为空，我们将在`postActions.js`文件上工作。标准操作函数应该如下所示：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, the action returns an object with two properties, namely, `type`
    and `payload`. The type property is used by the *reducers* to identify the type
    of action that happened and the `payload` delivers the result of that action.
    `payload` is optional, since some actions do not produce a direct result, but
    type property should be present in all the objects returned by actions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，该操作返回一个带有两个属性的对象，即`type`和`payload`。`type`属性被*reducers*用来识别发生的操作类型，而`payload`传递了该操作的结果。`payload`是可选的，因为有些操作不会产生直接的结果，但是所有操作返回的对象中应该包含`type`属性。
- en: This works great for simple actions such as the sum of two numbers that we saw
    in the preceding example code, which is synchronous. However, most of the time,
    actions we do in our application are asynchronous, and we cannot simply return
    a JSON object from those actions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于简单的操作非常有效，比如我们在前面示例代码中看到的两个数字的和，这是同步的。然而，大多数情况下，我们在应用程序中执行的操作是异步的，我们不能简单地从这些操作中返回一个JSON对象。
- en: To overcome this problem and do asynchronous actions, Redux has a concept called
    **middleware**. Middleware are libraries that can affect the way Redux works,
    especially for cases such as having asynchronous functions in the actions. The
    middleware that we will use in this application for this purpose is the `redux-thunk`
    library. This library is already included in the `package.json` file of this chapter's
    starter files and would have already been installed when you did `npm install`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题并执行异步操作，Redux有一个叫做**中间件**的概念。中间件是可以影响Redux工作方式的库，特别是在有异步函数的操作中。我们将在这个应用程序中用于此目的的中间件是`redux-thunk`库。这个库已经包含在本章起始文件的`package.json`文件中，并且在你执行`npm
    install`时应该已经安装了。
- en: 'So, here''s how `redux-thunk` works. `redux-thunk` allows actions to dispatch
    other actions instead of returning a plain JavaScript object. This is useful because
    we can call any number of actions we need when the asynchronous event is running.
    The actions that return other actions have the following weird syntax:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这就是`redux-thunk`的工作原理。`redux-thunk`允许操作分派其他操作，而不是返回一个普通的JavaScript对象。这很有用，因为在异步事件运行时，我们可以调用任意数量的操作。返回其他操作的操作具有以下奇怪的语法：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding syntax is quite hard to understand at first, but if you look closely,
    the `ajaxRequestAction` will return another function instead of returning an object.
    That function will have `dispatch` as its argument.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语法一开始很难理解，但是如果你仔细看，`ajaxRequestAction`将返回另一个函数而不是返回一个对象。该函数将以`dispatch`作为其参数。
- en: Let's call the function returned by `ajaxRequestAction` the *dispatcher* (*just
    for our reference*). Once we are inside the dispatcher, we can do any asynchronous
    actions we need. A dispatcher need not return any values. However, the dispatcher
    has the ability to dispatch other actions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`ajaxRequestAction`返回的函数称为*调度程序*（*仅供参考*）。一旦我们进入调度程序，我们可以执行任何需要的异步操作。调度程序不需要返回任何值。但是，调度程序有能力分派其他操作。
- en: 'Let''s create the actions for the posts of our blog in the `postActions.js`
    file. In your `postActions.js` file, you will first need to add two import statements:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`postActions.js`文件中为我们博客的帖子创建操作。在你的`postActions.js`文件中，你首先需要添加两个导入语句：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first one is the actions object that we created in the `actionTypes` folder.
    This contains all the actions that can be performed in our application. The second
    one is the `apiCall` service, which will make the network request.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是我们在`actionTypes`文件夹中创建的操作对象。这包含了我们应用程序中可以执行的所有操作。第二个是`apiCall`服务，它将发出网络请求。
- en: 'There are two types of actions that need to be performed on the posts in our
    blog:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的博客中需要执行的两种类型的操作：
- en: Get all posts
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取所有帖子
- en: Add a new post
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新帖子
- en: Get all posts
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取所有帖子
- en: 'Usually, our React component will have to trigger only a single action--`getAllPosts()`--which
    will make the network request and return the post data. This action will be our
    dispatcher. This action will start the network request and dispatch all the other
    actions based on the result of the network request. In your `postActions.js` file,
    add the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们的React组件只需要触发一个操作--`getAllPosts()`--它将发出网络请求并返回帖子数据。这个操作将是我们的调度程序。这个操作将开始网络请求并根据网络请求的结果分派所有其他操作。在你的`postActions.js`文件中，添加以下代码：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note the `export` keyword before the `getAllPosts` function. This is because
    all the actions will be used from inside the React components, hence, we are prefixing
    them with export keywords so that they can be imported later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在`getAllPosts`函数之前的`export`关键字。这是因为所有操作将从React组件内部使用，因此我们在它们前面加上`export`关键字，以便以后可以导入它们。
- en: 'Our dispatcher, `getAllPosts`, will make the network request and dispatch all
    the other normal actions, which will be used by the reducers of our app. Add the
    following code to your `postActions.js` file, which contains the code for all
    the actions dispatched by the `getAllPosts` action:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的调度程序`getAllPosts`将发出网络请求并分派所有其他正常操作，这些操作将被我们应用程序的reducers使用。将以下代码添加到你的`postActions.js`文件中，其中包含了`getAllPosts`操作分派的所有操作的代码：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The actions for tracking the status of the API calls do not need to return a
    `payload`. Since its status will be a boolean value, it only returns the action's
    type. However, the `getPosts` action, which should return the post details, returns
    a `payload` along with the action type, which is the posts array.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪API调用状态的操作不需要返回`payload`。由于其状态将是一个布尔值，因此它只返回操作的类型。然而，`getPosts`操作应返回帖子详情，除了操作类型之外还返回`payload`，即帖子数组。
- en: This looks like a lot of code for a simple network request, but, trust me, once
    your application scales up, these are the only actions you'll ever need whenever
    you need to get all the posts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的网络请求来说，这看起来是很多代码，但是相信我，一旦你的应用程序扩展起来，这些是你在需要获取所有帖子时唯一需要的操作。
- en: You should always specify the type of the action using the actions object you
    created in the `actionTypes` file. This way, you can prevent other developers
    in the team from accidentally creating unexpected actions in your application.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终使用在`actionTypes`文件中创建的动作对象来指定动作的类型。这样，您可以防止团队中的其他开发人员意外创建意外的动作。
- en: Adding a new post
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加新的帖子
- en: 'Since adding a post is an action related to posts, we will add the actions
    in the same `postActions.js` file. Add the following code for `addNewPost` action,
    which also acts as the dispatcher for adding a new post in your `postActions.js`
    file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于添加帖子是与帖子相关的动作，我们将在同一个`postActions.js`文件中添加动作。在您的`postActions.js`文件中添加以下代码，用于`addNewPost`动作，它还充当添加新帖子的分发器：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `addNewPost` action is pretty much similar to our preceding `getAllPosts`
    action. However, it requires a `body` argument, which will contain the post details
    needed for adding the post to the server. You should also note that, once the
    success response from the server is received that the post has been added, the
    `addNewPost` action will dispatch the `getAllPosts` action, which will retrieve
    all the posts, including the newly created post. This saves our React component
    the trouble of dispatching multiple actions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`addNewPost`动作与我们之前的`getAllPosts`动作非常相似。但是，它需要一个`body`参数，其中包含添加帖子到服务器所需的帖子详情。您还应该注意，一旦接收到来自服务器的成功响应，即帖子已添加，`addNewPost`动作将分发`getAllPosts`动作，该动作将检索所有帖子，包括新创建的帖子。这样可以避免我们的React组件分发多个动作。'
- en: 'The code for the remaining actions, which are dispatched by the `addNewPost`
    action, is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余动作的代码，由`addNewPost`动作分发，如下所示：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'That''s all for the actions part. We currently have the following three parts
    in our blog application:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是动作部分的全部内容。我们当前的博客应用程序中有以下三个部分：
- en: '![](../images/00050.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00050.jpeg)'
- en: However, they are connected with each other at the moment. Our next step is
    to create the reducers, which provide the ability to update the application state.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它们目前是相互连接的。我们的下一步是创建reducers，这些reducers提供了更新应用程序状态的能力。
- en: Reducers
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Reducers
- en: 'Reducers are simple functions that receive the action object returned from
    the actions and then update the state using them. Generally, since our application
    state is represented as an object which is a key-value pair, we will need to create
    a reducer for each key (or property). This is the structure of our application
    state, which we created in the initial state section:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Reducers是简单的函数，它们接收来自动作的动作对象，然后使用它们更新状态。通常，由于我们的应用程序状态表示为键值对的对象，我们将需要为每个键（或属性）创建一个reducer。这是我们在初始状态部分创建的应用程序状态的结构：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have got three properties in our state, hence, we will need three reducers,
    namely, `postsReducer.js`, `authorsReducer.js`, and `ajaxCallsReducer.js`. These
    reducers will represent our application state in the store. We also need another
    reducer, which will be used to combine these three reducers into a single object
    that will be used as our state.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态中有三个属性，因此我们需要三个reducers，分别是`postsReducer.js`，`authorsReducer.js`和`ajaxCallsReducer.js`。这些reducers将代表我们应用程序状态在存储中。我们还需要另一个reducer，用于将这三个reducers组合成一个单一对象，该对象将用作我们的状态。
- en: 'In your `redux` directory, create the four files highlighted in the following
    structure; your `redux` folder structure should now look as follows :'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`redux`目录中，创建以下结构中突出显示的四个文件；您的`redux`文件夹结构现在应如下所示：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is how the reducer function works:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是reducer函数的工作方式：
- en: The reducer function accepts two parameters; the first one is the old state
    and the second one is the action object returned by an action.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reducer函数接受两个参数；第一个是旧状态，第二个是由动作返回的动作对象。
- en: It will return a new state, which will completely overwrite the old state. This
    is because, just like updating state in React components, updating state in Redux
    should also be immutable.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将返回一个全新的状态，完全覆盖旧状态。这是因为，就像在React组件中更新状态一样，在Redux中更新状态也应该是不可变的。
- en: 'Consider the following example. This is how Redux stores states; the value
    of states are the results of the reducers:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。这是Redux存储状态的方式；状态的值是reducers的结果：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If an action happens that receives new posts, the reducer will return all the
    new posts, which will update the post's state without mutating it. Remember that
    all reducers will be listening to all the actions. Hence, we will need to properly
    filter the required action inside the reducer, and if none of the actions affect
    the reducer, it should simply return the old state.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生一个接收新帖子的动作，reducer将返回所有新帖子，这将更新帖子的状态而不会改变它。请记住，所有reducers都将监听所有动作。因此，我们需要在reducer内部正确过滤所需的动作，如果没有任何动作影响reducer，它应该简单地返回旧状态。
- en: 'Open your `postsReducer.js` file, and add the following import statements:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`postsReducer.js`文件，并添加以下导入语句：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you have added these `import` statements, add the following code for the
    posts reducer:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您添加了这些`import`语句，添加以下代码用于帖子reducer：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `postsReducer` function will accept two parameters, as mentioned earlier:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`postsReducer`函数将接受两个参数，如前所述：'
- en: '`state`: It contains the old value of the `posts` state. At first load, however,
    the old state will be null, hence, `initialState.posts` is passed as a default
    parameter for the state.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`：它包含了`posts`状态的旧值。然而，在第一次加载时，旧状态将为null，因此`initialState.posts`被传递为状态的默认参数。'
- en: '`action`: It is the action object returned by the actions.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`：它是由动作返回的动作对象。'
- en: 'Since the reducer gets called for every action, we will simply need to add
    a switch case statement with which we can determine the type of action and whether
    it will affect our state. In our switch case statement, we have added two cases
    for the following conditions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于reducer会为每个动作调用，我们只需要添加一个switch case语句，通过它我们可以确定动作的类型以及它是否会影响我们的状态。在我们的switch
    case语句中，我们为以下条件添加了两个情况：
- en: If the action's type is `GET_POSTS`, we know that it contains all the posts,
    hence, we can simply return the posts from the action's `payload`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作的类型是`GET_POSTS`，我们知道它包含所有帖子，因此我们可以简单地从操作的`payload`中返回帖子。
- en: If it is not, then the `default` case will be executed, which will simply return
    the old state.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是，则将执行`default`情况，它将简单地返回旧状态。
- en: 'The `authorsReducer.js` file is for you to try out, but it can''t be left empty.
    In this file, add the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`authorsReducer.js`文件是供您尝试的，但不能留空。在此文件中，添加以下代码：'
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It will simply return the `initialState` for all the actions. You can work on
    this reducer to try out Redux in the author list page.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它将简单地返回所有操作的`initialState`。您可以在此reducer上工作，以在作者列表页面中尝试Redux。
- en: For `ajaxCallsReducer.js`, the code is too long to be specified in the book,
    so you should copy the contents of the file from the completed code files. The
    exact code will work fine. The working of `ajaxCallsReducer` is very simple. It
    toggles the value of the `loading` and `hasError` properties to `true` or `false`
    based on the result of the network request. Since the state cannot be mutated,
    it uses the spread operator (`...state`) to perform this operation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ajaxCallsReducer.js`，代码太长无法在书中指定，因此您应该从已完成的代码文件中复制文件的内容。确切的代码将正常工作。`ajaxCallsReducer`的工作非常简单。它根据网络请求的结果切换`loading`和`hasError`属性的值为`true`或`false`。由于状态不能被改变，它使用扩展运算符(`...state`)来执行此操作。
- en: 'Consider the case in which `GET_POSTS_AJAX_CALL_START` happens:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`GET_POSTS_AJAX_CALL_START`发生的情况：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, a new state object is created with the loading property inside the `getAllPosts`
    property set to `true`. This state can be useful for showing the loading indicator
    in the application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了一个新的状态对象，其中`getAllPosts`属性内部的`loading`属性设置为`true`。这种状态对于在应用程序中显示加载指示器非常有用。
- en: The Root Reducer
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根reducer
- en: 'The last item we have left in the reducers part is the root reducer. In this
    file, all the reducers are combined together to be used as a state for the application.
    Redux provides a method called `combineReducers`, which can be used for this purpose.
    In your `rootReducer.js` file, add the following import statements:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在reducers部分中我们剩下的最后一项是根reducer。在此文件中，所有reducer都被组合在一起，以用作应用程序的状态。Redux提供了一个名为`combineReducers`的方法，可以用于此目的。在您的`rootReducer.js`文件中，添加以下导入语句：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will import the `combineReducers` function along with other reducers.
    To combine all reducers into a single root reducer, you will simply need to add
    the following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入`combineReducers`函数以及其他reducer。要将所有reducer组合成单个根reducer，只需添加以下代码：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will import this reducer to create our store in the next section. At the
    moment, this is how data flows between actions and reducers:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中导入此reducer以创建我们的store。目前，操作和reducer之间的数据流动方式如下：
- en: '![](../images/00051.jpeg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00051.jpeg)'
- en: Store
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Store
- en: The last stage of working with the Redux part is to create the store object
    using the root reducer. Inside the `redux/store` directory, create the `configureStore.js`
    file, which will create our store object. We will also need to apply our `redux-thunk`
    middleware in this file, which will allow us to use actions that will dispatch
    other actions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用根reducer创建store对象是Redux部分工作的最后阶段。在`redux/store`目录中，创建`configureStore.js`文件，该文件将创建我们的store对象。我们还需要在此文件中应用我们的`redux-thunk`中间件，这将允许我们使用将分派其他操作的操作。
- en: 'Redux provides the `createStore` function to create the store object and the `applyMiddleware`
    function to add middleware. In your `configureStore.js` file, add the following
    code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Redux提供了`createStore`函数来创建store对象和`applyMiddleware`函数来添加中间件。在您的`configureStore.js`文件中，添加以下代码：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To create a store, you will simply need to call the `createReducer` function
    with `rootReducer`, the preceding state, and the `applyMiddleware` method as parameters.
    The first parameter is compulsory, whereas the others are optional. In the `configureStore.js`
    file, add the following code after the `import` statements:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个store，只需使用`createReducer`函数调用`rootReducer`，前面的状态和`applyMiddleware`方法作为参数。第一个参数是必需的，而其他参数是可选的。在`configureStore.js`文件中，在`import`语句之后添加以下代码：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `configureStore` function will be used to create the store object for our
    React components. The final folder structure of our `redux` directory will look
    as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`configureStore`函数将用于为我们的React组件创建store对象。我们的`redux`目录的最终文件夹结构如下：'
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'That''s all for now in the `redux` part. We will now work with the React components
    of our blog and connect Redux with React using the `react-redux` library. Now,
    this is how data flows in the `redux` part:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在`redux`部分就是这些了。我们现在将使用`react-redux`库在我们的博客的React组件中连接Redux和React。现在，这是`redux`部分中数据流动的方式：
- en: '![](../images/00052.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00052.jpeg)'
- en: Connecting Redux with React components
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Redux与React组件连接起来
- en: We wrapped the entire `App` component of our blog inside the `BrowserRouter`
    component of React router to implement routing in the `index.js` file. Redux follows
    a similar approach. We need to wrap the `App` component, which is already wrapped
    inside the router within a `Provider` component of the `react-redux` library.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们博客的整个`App`组件包装在React路由器的`BrowserRouter`组件中，以在`index.js`文件中实现路由。Redux遵循类似的方法。我们需要将`App`组件（已经包装在路由器内部）包装在`react-redux`库的`Provider`组件中。
- en: 'Open your `src/index.js` file, and add the following import statements after
    the `import` statements that are already present in the file:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的`src/index.js`文件，并在文件中已经存在的`import`语句之后添加以下导入语句：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This will import the `Provider` component of `react-redux` and the `configureStore`
    function that we created in the preceding section. We will need to create a `store`
    object from the `configureStore` function. After the preceding `import` statements,
    add the following line to create the store object:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入`react-redux`的`Provider`组件和我们在前一节中创建的`configureStore`函数。我们需要从`configureStore`函数创建一个`store`对象。在前面的`import`语句之后，添加以下行以创建`store`对象：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Currently, this is how your `ReactDOM.render()` method looks:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您的`ReactDOM.render()`方法如下所示：
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You need to replace it with the following lines:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将其替换为以下行：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have now wrapped the entire `App` component inside the `Provider`, which
    provides the React components with the ability to connect with Redux. We'll now
    see how to connect an individual component with the state present in the Redux
    store and its actions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将整个`App`组件包装在`Provider`中，它为React组件提供了与Redux连接的能力。我们现在将看到如何将单个组件与Redux存储中的状态和操作连接起来。
- en: The App component
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: App组件
- en: The first component that we will connect with Redux is the `App` component,
    which acts as the parent component to all the other components in our application.
    This means that, regardless of the URL we visit in our application, the `App`
    component will be executed. This makes the `App` Component the best place to do
    actions, such as `getAllPosts`, which will retrieve the posts array.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先连接到Redux的组件是`App`组件，它充当我们应用程序中所有其他组件的父组件。这意味着无论我们在应用程序中访问的URL是什么，`App`组件都将被执行。这使得`App`组件成为执行操作的最佳位置，例如`getAllPosts`，它将检索帖子数组。
- en: This section is the most confusing part in Redux, hence, you will have to pay
    close attention to how we pass the Redux store and actions to the React component
    as props. Also, make sure that you refer to the completed code files if you face
    any errors at this stage.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分是Redux中最令人困惑的部分，因此，您将需要密切关注我们如何将Redux存储和操作作为props传递给React组件。此外，如果在此阶段遇到任何错误，请确保参考已完成的代码文件。
- en: 'You will need to add a few `import` statements in your `App.js` file. The first
    thing you will need to import is the `connect` component provided by `react-redux`
    library:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的`App.js`文件中添加一些`import`语句。您需要导入的第一件事是`react-redux`库提供的`connect`组件：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will provide a wrapper to connect your React component with Redux. This
    works in the same way as the `withRouter` component of the React router, which
    supplies history, location, and match props to the React component.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您的React组件提供一个与Redux连接的包装器。这与React路由器的`withRouter`组件的工作方式相同，它为React组件提供了history、location和match
    props。
- en: 'You will also need to import the `bindActionCreators` function of Redux, which
    will convert the action functions into simple objects that can be used by React
    components:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要导入Redux的`bindActionCreators`函数，它将操作函数转换为可以被React组件使用的简单对象：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Another important thing we will need to import is the `postActions`, which
    will be used by our `App` component. Since `postActions` contains a lot of functions
    exported individually, we can import all of them together as a single object using
    the following `import` statement:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要导入的另一件重要的事情是`postActions`，它将被我们的`App`组件使用。由于`postActions`包含许多单独导出的函数，我们可以使用以下`import`语句将它们全部作为单个对象一起导入：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We now have all the required `import` statements in place. Our next step is
    the actual implementation part. Currently, this is how the export statement of
    the `App` component looks:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将所有必需的`import`语句放在了适当的位置。我们的下一步是实际的实现部分。目前，`App`组件的导出语句如下所示：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Our `App` component is wrapped inside `withRouter`. To connect this with Redux,
    we will need to wrap the `App` component inside the `connect` function we imported
    from `react-redux`, and the result should be inside the `withRouter` component.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`App`组件被包装在`withRouter`中。要将其与Redux连接，我们需要将`App`组件包装在我们从`react-redux`导入的`connect`函数中，并且结果应该在`withRouter`组件内。
- en: However, the connect function itself requires two functions--`mapStateToProps`
    and `mapDispatchToProps`--as parameters. In these two functions, `mapStateToProps`
    will convert the state from the store and `mapDispatchToProps` will convert the
    actions into props, which can be used by React components. Now, pay close attention,
    because we will be seeing another weird syntax soon.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`connect`函数本身需要两个函数--`mapStateToProps`和`mapDispatchToProps`--作为参数。在这两个函数中，`mapStateToProps`将从存储中转换状态，而`mapDispatchToProps`将将操作转换为可以被React组件使用的props。现在，请密切关注，因为我们很快将看到另一种奇怪的语法。
- en: 'Replace the export code of your `App` component with the following lines of
    code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的`App`组件的导出代码替换为以下代码行：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Take a look at the preceding code snippet carefully. If the export statement
    makes no sense to you, no worries, we''ll sort that out. Let''s see what `connect`
    does. The `connect` function will accept two parameters--`mapStateToProps` and
    `mapDispatchToProps`--which are functions, and it will return a function:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看前面的代码片段。如果导出语句对您来说毫无意义，不用担心，我们会解决这个问题。让我们看看`connect`的作用。`connect`函数将接受两个参数--`mapStateToProps`和`mapDispatchToProps`--它们是函数，并且它将返回一个函数：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `App` component is wrapped inside the `connectFunction` as `connectFunction(App)`.
    The entire component is then wrapped inside the `withRouter()` function. So, basically,
    this is what the export statement works like:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件被包装在`connectFunction`中作为`connectFunction(App)`。整个组件然后被包装在`withRouter()`函数中。因此，基本上，这就是导出语句的工作方式：'
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Which is what we have combined together and writing as:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们已经合并在一起并写成的：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `App` component does not use any states, hence, the `mapStateToProps` function
    will return an empty object. The `mapDispatchToProps` function, however, will
    return `postActions` as an object using the `bindActionCreators` function, which
    will then be supplied to the `App` component as a prop.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`App`组件不使用任何状态，因此`mapStateToProps`函数将返回一个空对象。但是，`mapDispatchToProps`函数将使用`bindActionCreators`函数将`postActions`作为对象返回，然后将其作为prop提供给`App`组件。'
- en: 'We will now have the `App` component make the API call for getting all the
    posts by adding the following line of code in the `componentWillMount()` method:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将让`App`组件通过在`componentWillMount()`方法中添加以下代码行来进行API调用以获取所有帖子：
- en: '[PRE39]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Also, since `postActions` is passed as a prop to our `App` component, add the
    following property to the `propType` validation we added in the `App` component:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于`postActions`作为一个prop传递给我们的`App`组件，因此请将以下属性添加到我们在`App`组件中添加的`propType`验证中：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Refer to the completed code files if you face any problems in including the
    preceding code snippets in the `App.js` file. Once you have completed this step,
    keep the server running from the `Chapter06\Server` directory and open your application
    in Chrome.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在将上述代码片段包含到`App.js`文件中时遇到任何问题，请参考已完成的代码文件。完成此步骤后，从`Chapter06\Server`目录保持服务器运行，并在Chrome中打开你的应用程序。
- en: You should see the blog running with the same 3 second loading time whenever
    we click on the menu items in the navigation bar icon or on the Read More button
    in the post. We will fix this in the next section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击导航栏图标中的菜单项或帖子中的“阅读更多”按钮时，你应该看到博客以相同的3秒加载时间运行。我们将在下一节中修复这个问题。
- en: Home component
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主页组件
- en: In the preceding section, we used the `App` component to retrieve the data from
    the server and store it in the Redux store. This means that we no longer need
    to make any network requests in our Home component. We will simply need to retrieve
    data from the Redux store.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们使用`App`组件从服务器检索数据并将其存储在Redux存储中。这意味着我们不再需要在我们的主页组件中进行任何网络请求。我们只需要从Redux存储中检索数据。
- en: 'The Home component does not trigger any Redux actions, hence, we only need
    to import the connect component from `react-redux`. In your `Home.js` file, add
    the following `import` statement:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 主页组件不会触发任何Redux动作，因此，我们只需要从`react-redux`中导入connect组件。在你的`Home.js`文件中，添加以下`import`语句：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Replace the `export` statement of our `Home.js` file with the following code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换我们的`Home.js`文件中的`export`语句：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Since the Home component will not do any actions, we can safely ignore the `mapDispatchToProps`
    function in connect. However, we got some work for the `mapStateToProps` function,
    which simply returned an empty object in the preceding chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 由于主页组件不会执行任何操作，我们可以安全地忽略connect中的`mapDispatchToProps`函数。但是，我们需要为`mapStateToProps`函数做一些工作，在前一章中它只是简单地返回了一个空对象。
- en: The `mapStateToProps` function has one argument, which is a state that contains
    the entire Redux state of the applications. In the return statement, we will simply
    need to mention which part of the state we need to deliver to the React component
    as props. The best part about connect is that, whenever reducers update the states,
    it will update these props using the `mapStateToProps` function.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapStateToProps`函数有一个参数，即应用程序的整个Redux状态的状态。在return语句中，我们只需要提到我们需要将状态的哪一部分作为props传递给React组件。connect的最好部分是，每当reducers更新状态时，它将使用`mapStateToProps`函数更新这些props。'
- en: 'We have now got some new props for our Home component. So, in your Home component,
    add the following `propType` validation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为主页组件得到了一些新的props。因此，在你的主页组件中，添加以下`propType`验证：
- en: '[PRE43]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Also, we no longer need any states or API calls in our Home component, hence,
    you can *delete both* the *constructor* and the `componentWillMount` methods.
    Instead, in the JSX of your render method, replace `this.state.posts` with `this.props.posts`.
    Do the same for both the `loading` and `hasError` states. Now our Home component
    depends directly on the Redux store. Refer to the completed code files if you
    face any problems.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的主页组件中不再需要任何状态或API调用，因此，你可以*删除*`constructor`和`componentWillMount`方法。而是在你的render方法的JSX中，用`this.props.posts`替换`this.state.posts`。对于`loading`和`hasError`状态也是一样。现在我们的主页组件直接依赖于Redux存储。如果你遇到任何问题，请参考已完成的代码文件。
- en: Here's the cool part--if you click on any other section in the navigation bar
    and return to Home, you will see that the posts load instantly. This is because
    all the posts are stored and ready for use inside our Redux store. If you click
    on the Read More button in the posts list of the home page, you should see a loading
    indicator again, since it is retrieving post details from the server. Let's also
    connect that component with Redux.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的酷部分是-如果你点击导航栏中的任何其他部分并返回到主页，你会发现帖子会立即加载。这是因为所有帖子都存储在Redux存储中，准备供我们使用。如果你在主页帖子列表中点击“阅读更多”按钮，你应该再次看到加载指示器，因为它正在从服务器检索帖子详情。让我们也将该组件与Redux连接起来。
- en: Post component
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帖子组件
- en: 'Open your `src/Components/Post.js` file in VSCode. Our first step is to add
    the required `import` statements:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在VSCode中打开你的`src/Components/Post.js`文件。我们的第一步是添加所需的`import`语句：
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Let''s strategize how we will connect this component with Redux:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制定一下我们将如何将该组件与Redux连接起来的策略：
- en: We will need to get the Post ID, which is present in the URL
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要获取帖子ID，它存在于URL中
- en: Once we have the ID, we should find the post with the ID in our store's posts
    array using the `Array.find()` method
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们有了ID，我们应该使用`Array.find()`方法在我们存储的帖子数组中找到具有该ID的帖子
- en: Finally, we can send the required post as props
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以将所需的帖子作为props发送。
- en: 'Now, replace your `export` statement in `Post.js` with the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Post.js`中用以下代码替换你的`export`语句：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `mapStateToProps` function has a second argument, which is `ownProps`. It
    contains all the props of the Post component. From `ownProps`, we can obtain the
    post ID, which is present in the match object supplied by the `withRouter` component
    of the React router. We will then use the find method to find the post and return
    the required data in the return statement.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapStateToProps`函数有一个第二个参数，即`ownProps`。它包含了Post组件的所有props。从`ownProps`中，我们可以获取帖子ID，它存在于React路由器的`withRouter`组件提供的match对象中。然后我们将使用find方法找到帖子并在return语句中返回所需的数据。'
- en: 'Your `propType` validation inside the Post component should look as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你的帖子组件内的`propType`验证应如下所示：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You can delete the constructor and the `componentWillMount` methods just as
    we did for our Home component, and then, in your render method, replace `this.state.loading`
    with `this.props.loading` and `this.state.hasError` with `this.props.hasError`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以删除构造函数和`componentWillMount`方法，就像我们为我们的主页组件所做的那样，然后在你的render方法中，用`this.props.loading`替换`this.state.loading`，用`this.props.hasError`替换`this.state.hasError`。
- en: 'However, before you replace `this.state.post` with `this.props.post`, we should
    make sure that `this.props.post` has a value, since, during loading, the posts
    array will be empty, and the value of `this.props.post` will be undefined. In
    your render method, replace the three lines where you have used `this.state.post`
    with the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在将`this.state.post`替换为`this.props.post`之前，我们应该确保`this.props.post`有一个值，因为在加载过程中，帖子数组将为空，并且`this.props.post`的值将为undefined。在render方法中，用以下代码替换您使用`this.state.post`的三行代码：
- en: '[PRE47]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now try reloading the page. It will take three seconds for the first load, but
    once your data is loaded, you will see that navigating to other pages (except
    the author page) will be a breeze. Clicking on the Read More button in the home
    page will take you to the post details page instantly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试重新加载页面。第一次加载需要三秒钟，但一旦数据加载完成，您将看到导航到其他页面（除了作者页面）将变得轻而易举。在主页上点击“阅读更多”按钮将立即带您到帖子详情页面。
- en: It's your turn to try this out in the `AuthorList` and `AuthorPosts` components.
    The last component in which we need to connect Redux is the NewPost component.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到您在`AuthorList`和`AuthorPosts`组件中尝试这一点。我们需要连接Redux的最后一个组件是NewPost组件。
- en: The NewPost component
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NewPost组件
- en: 'The NewPost component requires both state and actions from Redux. It needs
    the loading and `hasError` data from state and will have to use `postActions`
    to submit a post to the server. So, let''s start by including the required `import`
    statements in the `src/Components/NewPost/NewPost.js` file:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: NewPost组件需要Redux的状态和操作。它需要来自状态的加载和`hasError`数据，并且必须使用`postActions`将帖子提交到服务器。因此，让我们从在`src/Components/NewPost/NewPost.js`文件中包含所需的`import`语句开始：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, replace your `export` statement in the `NewPost.js` file with the following
    code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请用以下代码替换`NewPost.js`文件中的`export`语句：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since we have got props in our `NewPost` component, add the following `propType`
    validation code inside the `NewPost` class:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在`NewPost`组件中有了props，请在`NewPost`类中添加以下`propType`验证代码：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Unlike the `Home` and `Post` components, the `NewPost` component requires both
    state and props to render the JSX elements. We can delete the loading and `hasError`
    states and replace them with props. You should refer to the completed code files
    (if needed), and replace the loading and `hasError` states inside the JSX of the
    render method with props.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Home`和`Post`组件不同，`NewPost`组件需要状态和props来渲染JSX元素。我们可以删除加载和`hasError`状态，并用props替换它们。您应该参考已完成的代码文件（如果需要），并将render方法中的加载和`hasError`状态替换为props。
- en: 'You should then replace your entire `apiCall().then().catch()` chain inside
    the submit method with this following single line of code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将submit方法中的整个`apiCall().then().catch()`链替换为以下单行代码：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Your `submit` method will now look as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`submit`方法现在将如下所示：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `submit` method will now trigger an action--`addNewPost`, which contains
    the required network request. However, we need to show a success message once
    the network request is complete. To detect the completion of a network request,
    since all our updates to the store are immutable, if the status of loading or
    `hasError` properties in the `ajaxCalls` property of the Redux's state changes,
    it will lead to the creation of a new object, which will automatically be delivered
    to the `NewPost` component by `react-redux`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`submit`方法现在将触发一个包含所需网络请求的`addNewPost`操作。但是，我们需要在网络请求完成后显示成功消息。为了检测网络请求的完成，由于我们对存储的所有更新都是不可变的，如果Redux状态中的`ajaxCalls`属性中的加载或`hasError`属性的状态发生变化，将导致创建一个新对象，该对象将自动通过`react-redux`传递给`NewPost`组件。'
- en: 'This means that new props will be received by the `NewPost` React component
    at the end of the network request. In this case, we can use the `componentWillReceiveProps`
    `lifecycle` method of React to show the success message and clear the input fields
    once the post is submitted. Add the following code of `componentWillReceiveProps`
    to the `NewPost` class:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`NewPost` React组件将在网络请求结束时接收到新的props。在这种情况下，我们可以使用React的`componentWillReceiveProps`生命周期方法来显示成功消息，并在提交帖子后清除输入字段。将以下代码添加到`NewPost`类的`componentWillReceiveProps`中：
- en: '[PRE53]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`componentWillReceiveProps` will have the new props that are supplied to the
    component (in our case, from `react-redux`) as its parameter, which we will call
    `nextProps`. In the `componentWillReceiveProps` method, a simple `this.props !==
    nextProps` check is done to make sure that current props and new props are not
    the same objects. If they both hold the same object, we can skip the operation.
    We then only need to check whether loading is complete and whether there are any
    errors using if else statements, as used in the preceding code snippet.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillReceiveProps`将接收到的新props（在我们的情况下，来自`react-redux`）作为其参数，我们将称之为`nextProps`。在`componentWillReceiveProps`方法中，进行简单的`this.props
    !== nextProps`检查以确保当前props和新props不是相同的对象。如果它们都持有相同的对象，我们可以跳过操作。然后我们只需要使用if else语句检查加载是否完成以及是否存在任何错误，就像在前面的代码片段中使用的那样。'
- en: Once you have included the preceding code snippet, try to add a post (make sure
    that the server is running). It should add the post and display the success message.
    Now, click on the Home menu option. You will see the new post that you added appear
    instantly with no loading time required. The secret to this is that the `addNewPost`
    action will automatically call the `getAllPosts` action, which will update your
    Redux store in the background. With the store updated using the new post, your
    `Home` component can get the updated posts state directly from Redux, which makes
    things appear instantly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您包含了上述代码片段，请尝试添加一个帖子（确保服务器正在运行）。它应该添加帖子并显示成功消息。现在，点击主页菜单选项。您将看到您添加的新帖子立即出现，无需等待加载时间。这其中的秘密是`addNewPost`操作将自动调用`getAllPosts`操作，后者将在后台更新您的Redux存储。使用新帖子更新存储后，您的`Home`组件可以直接从Redux获取更新后的帖子状态，使事情立即出现。
- en: This provides a great user experience for users, as they will find that every
    update happens instantly instead of having to wait for the loading indicator.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这为用户提供了很好的用户体验，因为他们会发现每次更新都是即时的，而不必等待加载指示器。
- en: The Redux data flow
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redux数据流
- en: 'After connecting your Redux code with the React components, you will find that
    Redux follows the same one-way data flow as React. This is the data flow of Redux:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 连接Redux代码与React组件后，你会发现Redux遵循与React相同的单向数据流。这就是Redux的数据流：
- en: '![](../images/00053.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00053.jpeg)'
- en: 'This is how data flow happens in a React component:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是React组件中数据流的方式：
- en: '![](../images/00054.jpeg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00054.jpeg)'
- en: Also, both the state in a React component and the state in a Redux store should
    be immutable. This immutability is essential for React and Redux to work properly.
    However, since JavaScript does not strictly implement any immutable data types
    at the moment, we need to be careful not to mutate the states. In React components,
    we will use the `this.setState()` method, and we use spread operators (`...`)
    inside reducers for Redux to update states without mutating them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，React组件中的状态和Redux存储中的状态都应该是不可变的。这种不可变性对于React和Redux的正常工作是必不可少的。然而，由于JavaScript目前没有严格实现任何不可变的数据类型，我们需要小心不要改变状态。在React组件中，我们将使用`this.setState()`方法，在Redux的reducer中使用扩展运算符(`...`)来更新状态而不是改变它们。
- en: This can prove troublesome for large projects with a huge amount of data. Facebook
    has introduced a library called `Immutable.js`, available at: [https://facebook.github.io/immutable-js/](https://facebook.github.io/immutable-js/),
    which can solve this problem by creating immutable data types in JavaScript. This
    library is out of the scope of this book, but ensure that you give it a try later.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型项目和大量数据可能会有麻烦。Facebook引入了一个叫做`Immutable.js`的库，可以解决这个问题，它可以在JavaScript中创建不可变的数据类型。这个库超出了本书的范围，但是确保你以后试一试。
- en: Persisting Redux store
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化Redux存储
- en: Our blog is fast to load since we have integrated Redux into it, however, our
    users still have to wait three seconds for the initial load. What if we could
    persist the Redux store offline and show it to users while the new data is loading?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的博客加载速度很快，因为我们已经将Redux集成到其中，但是我们的用户仍然需要等待三秒钟进行初始加载。如果我们可以将Redux存储持久化到离线，并在加载新数据时向用户展示它呢？
- en: 'Sounds good, and it''s very simple too! I have already added two libraries
    to the dependencies list for this purpose:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来不错，而且也很简单！我已经为此目的将两个库添加到了依赖列表中：
- en: '`redux-persist`: [https://github.com/rt2zz/redux-persist](https://github.com/rt2zz/redux-persist)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redux-persist`: [https://github.com/rt2zz/redux-persist](https://github.com/rt2zz/redux-persist)'
- en: '`localForage`: [https://github.com/localForage/localForage](https://github.com/localForage/localForage)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localForage`: [https://github.com/localForage/localForage](https://github.com/localForage/localForage)'
- en: '`redux-persist` provides a simple way to persist your Redux store and rehydrate
    it whenever needed. This makes your store available offline when your users visit
    your page for the second time.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`redux-persist`提供了一种简单的方法来持久化你的Redux存储，并在需要时重新填充它。这样当用户第二次访问你的页面时，你的存储就可以离线使用了。'
- en: '`localForage` is a simple storage library that lets you use `indexDB` using
    an API similar to `localStorage`. `redux-persist` works well with `localStorage`,
    but it recommends using `localForage` as its default storage engine for web browsers.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`localForage`是一个简单的存储库，可以让你使用类似`localStorage`的API来使用`indexDB`。`redux-persist`与`localStorage`配合良好，但它建议在web浏览器中使用`localForage`作为默认存储引擎。'
- en: 'Now, persisting the Redux store isn''t that complicated; you just need to add
    a few lines of code in the Redux store to persist it and make the reducers listen
    for a *rehydration* action to rehydrate data from the persisted store. It''s as
    easy as changing just the following three files:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，持久化Redux存储并不那么复杂；你只需要在Redux存储中添加几行代码来持久化它，并让reducers监听*rehydration*动作以从持久化存储中重新填充数据。只需要更改以下三个文件：
- en: '*The first file*: Open your `configureStore.js` file and add the following
    import statement:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个文件：打开你的`configureStore.js`文件，并添加以下导入语句：
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, change the `return` statement inside your `configureStore` method to
    the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将`configureStore`方法中的`return`语句更改为以下内容：
- en: '[PRE55]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, this adds the `autoRehydrate()` function while creating the store that
    will emit the rehydrate actions.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在创建存储时添加`autoRehydrate()`函数，它将发出rehydrate动作。
- en: '*The second file*: Open your `index.js` file and add the following `import`
    statements:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件：打开你的`index.js`文件，并添加以下`import`语句：
- en: '[PRE56]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This will import the `persistStore()` function that can persist your store
    and the `localForage` library that will be used as the storage engine. Now, you
    will need to add a single line of code after the line where you created your store:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导入`persistStore()`函数，它可以持久化你的存储，以及将被用作存储引擎的`localForage`库。现在，你需要在创建存储的代码行之后添加一行代码：
- en: '[PRE57]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '*The third file**: ***Open your `postsReducer.js` file. In this posts reducer,
    we will listen for another action, which is the rehydrate action emitted while
    rehydrating your persisted Redux store. Redux Persist maintains a set of constants,
    which has defined the rehydrate action similar to how we have defined our actions
    in the `actionTypes.js` file.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个文件：打开你的`postsReducer.js`文件。在这个posts reducer中，我们将监听另一个动作，即在重新填充持久化的Redux存储时发出的rehydrate动作。Redux
    Persist维护了一组常量，其中定义了rehydrate动作，类似于我们在`actionTypes.js`文件中定义动作的方式。
- en: 'In the reducers file, add the following `import` statement:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在reducers文件中，添加以下`import`语句：
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This will import the constants from `redux-persist`. You should then add an
    additional case statement inside the `postsReducer` function, which will hydrate
    the Redux store:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从`redux-persist`中导入常量。然后在`postsReducer`函数内添加一个额外的case语句，用于填充Redux存储：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This case will check whether the rehydrate action has occurred, and then it
    uses an `if` condition to check whether the rehydrate action contains the `posts`
    property in the action's payload. Refer to the completed code files if you face
    any issues with it.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个案例将检查rehydrate动作是否发生，然后使用`if`条件来检查rehydrate动作是否在动作的载荷中包含`posts`属性。如果遇到任何问题，请参考已完成的代码文件。
- en: 'Now, once it is complete, open the application in Chrome and try reloading
    the page. You should see that the posts are available even while the data is loading
    from the server, just like in the following image:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦完成，打开Chrome中的应用程序并尝试重新加载页面。您应该看到即使数据正在从服务器加载，帖子也是可用的，就像下面的图片一样：
- en: '![](../images/00055.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00055.jpeg)'
- en: This allows the users to use the application offline even while the posts are
    loading. We have completely removed the 3 second loading issue from the blog.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用户可以在加载帖子的同时离线使用应用程序。我们已经完全解决了博客的3秒加载问题。
- en: Redux is a great library for managing states in a separate state container.
    It's centralized state management with React proved to be very useful and efficient,
    that many libraries were created for centralized state management in other frameworks
    too, such as `@ngrx/store` for Angular and `vuex` for Vue.js. In this chapter,
    we only covered the basics of Redux--refer to the Redux documentation and its
    tutorial videos to learn Redux in-depth. Also, check out **Redux DevTools** at
    [https://github.com/gaearon/redux-devtools](https://github.com/gaearon/redux-devtools),
    which provides cool features, such as hot reloading and time travel debugging
    for your Redux application.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Redux是一个很好的用于管理状态的库，它将状态集中管理在一个单独的状态容器中。它与React的集中状态管理被证明非常有用和高效，以至于许多库也为其他框架创建了集中状态管理，比如`@ngrx/store`用于Angular和`vuex`用于Vue.js。在这一章中，我们只涵盖了Redux的基础知识--请参考Redux文档和其教程视频，以深入学习Redux。此外，查看[Redux
    DevTools](https://github.com/gaearon/redux-devtools)，它提供了一些很酷的功能，比如热重新加载和时间旅行调试，适用于你的Redux应用程序。
- en: The author page hasn't been connected to Redux yet. So, do give it a try and
    complete the blog.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 作者页面尚未连接到Redux。所以，试一试并完成博客。
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations! You have successfully completed the Redux chapter and also
    completed the book. In this chapter, we covered what Redux is and how we can use
    it to improve state management. We then created a Redux store with the actions
    and reducers needed to manage the store data. We used the `react-redux` library
    to connect our Redux code with the React components and used props instead of
    states to render the JSX elements.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已成功完成了Redux章节，也完成了这本书。在这一章中，我们介绍了Redux是什么，以及我们如何使用它来改进状态管理。然后，我们创建了一个Redux存储，其中包括管理存储数据所需的动作和减速器。我们使用`react-redux`库将我们的Redux代码与React组件连接起来，并使用props而不是状态来渲染JSX元素。
- en: Finally, we used `redux-persist` with `localforage` as the storage engine to
    persist our Redux store and make our application work offline. This chapter has
    made the blog faster and more user-friendly for users.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`redux-persist`和`localforage`作为存储引擎来持久化我们的Redux存储，并使我们的应用程序能够离线工作。这一章使博客对用户更快速、更用户友好。
- en: You has now completed your journey through this book, but you have just got
    started with your journey in exploring the world of JavaScript. There's still
    a lot to learn and a lot more to come. So, be prepared to learn and explore, no
    matter what you want to do.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了本书的旅程，但你刚刚开始探索JavaScript世界的旅程。还有很多东西要学，还有更多的东西要来。所以，无论你想做什么，都要做好学习和探索的准备。
