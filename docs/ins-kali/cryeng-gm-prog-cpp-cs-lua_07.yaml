- en: Chapter 7. The User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 用户界面
- en: CryENGINE integrates Scaleform GFx, allowing the rendering of Adobe Flash-based
    user interfaces, HUDs, and animated textures. By tying UI elements together at
    runtime using the UI flowgraph solution, developers can intuitively create and
    expand user interfaces in no time.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: CryENGINE集成了Scaleform GFx，允许呈现基于Adobe Flash的用户界面、HUD和动画纹理。通过在运行时使用UI流程图解决方案将UI元素直观地连接在一起，开发人员可以迅速创建和扩展用户界面。
- en: 'In this chapter we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Learning about the CryENGINE Scaleform implementation, and the benefits it brings.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解CryENGINE Scaleform实现及其带来的好处。
- en: Creating our main menu.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的主菜单。
- en: Implementing a UI game event system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施UI游戏事件系统
- en: Flash movie clips and UI graphs
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flash电影剪辑和UI图形
- en: In order to provide developers with a solution for creating user interfaces,
    CryENGINE integrates Adobe Scaleform GFx, a real-time Flash renderer for game
    engines. The system allows the creation of user interfaces in Adobe Flash, which
    can then be exported for immediate use in the engine.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为开发人员提供创建用户界面的解决方案，CryENGINE集成了Adobe Scaleform GFx，这是一个用于游戏引擎的实时Flash渲染器。该系统允许在Adobe
    Flash中创建用户界面，然后可以导出以立即在引擎中使用。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is also possible to use Flash `.swf` files in materials, allowing the rendition
    of Flash movie clips on 3D objects present in the game world.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在材质中使用Flash `.swf`文件，从而在游戏世界中的3D对象上呈现Flash电影剪辑。
- en: The effort involved in creating modular dynamic user interfaces is greatly simplified
    with the addition of the UI flowgraph, a system that allows the creation and maintenance
    of any Flash UI element using the flowgraph system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过UI流程图系统，创建模块化动态用户界面所需的工作大大简化。
- en: 'The UI flowgraph system is based on the concept of two types: **elements**
    and **actions**. Each element represents a Flash file (`.swf` or `.gfx`), while
    each action is one flowgraph representing a UI state.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: UI流程图系统基于两种类型的概念：**元素**和**动作**。每个元素代表一个Flash文件（`.swf`或`.gfx`），而每个动作是一个表示UI状态的流程图。
- en: Elements
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素
- en: UI elements are configured via XML files in `Game/Libs/UI/UIElements/`, and
    represent each Flash file. By modifying the UI element's configuration, we can
    change the events it receives and alignment mode, as well as expose the different
    functions and callbacks present in the exported SWF file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: UI元素通过`Game/Libs/UI/UIElements/`中的XML文件进行配置，并表示每个Flash文件。通过修改UI元素的配置，我们可以更改它接收的事件和对齐模式，以及公开导出的SWF文件中存在的不同函数和回调。
- en: XML Breakdown
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XML分解
- en: 'The bare minimum for an element can be seen in the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的最低要求可以在以下代码中看到：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous XML code can be saved as `Game/Libs/UI/UIElements/MyMainMenu.xml`,
    and will load the Flash file called `Menus_Startmenu.swf` in the `Game/Libs/UI/`
    folder.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的XML代码可以保存为`Game/Libs/UI/UIElements/MyMainMenu.xml`，并将Flash文件`Menus_Startmenu.swf`加载到`Game/Libs/UI/`文件夹中。
- en: Once created, we'll be able to select our new UI element via flowgraph nodes
    such as **UI:Display:Config** (used to reconfigure any element in order to, for
    example, enable mouse events for an element at runtime).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完成后，我们将能够通过流程图节点选择我们的新UI元素，例如**UI:Display:Config**（用于重新配置任何元素，例如在运行时启用元素的鼠标事件）。
- en: '![XML Breakdown](img/5909_07_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![XML分解](img/5909_07_01.jpg)'
- en: 'Now that we know it works, let''s break it down a bit:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道它是如何工作的，让我们来详细了解一下：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This first element defines the start of the file, and determines in which category
    our element should be placed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这第一个元素定义了文件的开始，并确定了我们的元素应该放在哪个类别中。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `UIElement` XML element is used to decide the initial configuration, including
    the default name, and determining which events should be received by default.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIElement` XML元素用于决定初始配置，包括默认名称，并确定默认应接收哪些事件。'
- en: 'As seen previously, each element can be configured via a set of attributes,
    allowing the developer to define what type of events to listen to:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，每个元素都可以通过一组属性进行配置，允许开发人员定义要监听的事件类型：
- en: '| Attribute name | Description |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 属性名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `name` | Defines the name of the element (String). |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 定义元素的名称（字符串）。 |'
- en: '| `mouseevents` | Determines whether mouse events are sent to the Flash file
    (0/1). |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `mouseevents` | 确定是否将鼠标事件发送到Flash文件（0/1）。 |'
- en: '| `cursor` | Determines whether to display a cursor while the element is visible
    (0/1). |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `cursor` | 确定在元素可见时是否显示光标（0/1）。 |'
- en: '| `keyevents` | Determines whether to send key events to the Flash file (0/1).
    |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `keyevents` | 确定是否将键事件发送到Flash文件（0/1）。 |'
- en: '| `console_mouse` | Determines whether the thumbstick should function as a
    cursor on console hardware (0/1). |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `console_mouse` | 确定在控制台硬件上拇指杆是否应该作为光标（0/1）。 |'
- en: '| `console_cursor` | Determines whether to display a cursor while the element
    is visible while running on console hardware (0/1). |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `console_cursor` | 确定在控制台硬件上运行时是否显示光标（0/1）。 |'
- en: '| `layer` | Defines the order in which the elements are displayed, in case
    multiple elements are present. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `layer` | 定义元素显示顺序，以防多个元素存在。 |'
- en: '| `alpha` | Sets the background alpha of the element (0-1).Allows transparency
    in-game, for example, to feature an in-game level behind your main menu. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `alpha` | 设置元素的背景透明度（0-1）。允许在游戏中使用透明度，例如在主菜单后显示游戏关卡。'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the previously mentioned properties can be tweaked in real time by
    using the **UI:Display:Config** node.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，先前提到的属性可以通过使用**UI:Display:Config**节点实时调整。
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `GFx` element determines which Flash file should be loaded for the element.
    It is possible to load multiple GFx files and put them into different layers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`GFx`元素确定应加载哪个Flash文件用于该元素。可以加载多个GFx文件并将它们放入不同的层。'
- en: This allows for selecting which element layer to use at runtime, for example,
    via the `layer` input on the **UI:Display:Config** node shown in the previous
    screenshot.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许在运行时选择要使用的元素层，例如，通过**UI:Display:Config**节点上的`layer`输入，如前面截图所示。
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Constraints` allow configuring how the GFx element is displayed on screen,
    giving the developer the ability to tweak how the element performs under different
    display resolutions.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Constraints`允许配置GFx元素在屏幕上的显示方式，使开发人员能够调整元素在不同显示分辨率下的表现方式。'
- en: 'There are currently three modes as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有三种模式如下：
- en: '| Mode name | Description | Additional attributes |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 模式名称 | 描述 | 附加属性 |'
- en: '| --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| fixed | In the fixed mode, the developer can use four attributes to set the
    pixel distance from top and left corners, as well as set the desired resolution.
    | top, left, width, and height |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 固定 | 在固定模式下，开发人员可以使用四个属性来设置距离顶部和左侧角的像素距离，以及设置所需的分辨率。 | 顶部、左侧、宽度和高度 |'
- en: '| dynamic | In dynamic mode, the element is aligned on anchors, allowing horizontal
    and vertical alignment.halign can be set to `left`, `center`, or `right`, while
    valign can be set to `top`, `center`, or `bottom`.If scale is set to `1`, the
    element will be scaled to the screen resolution while maintaining aspect ratio.If
    max is set to `1`, the element will be maximized to make sure that 100 percent
    of the screen is covered. | halign, valign, scale, and max |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 动态 | 在动态模式下，元素根据锚点对齐，允许水平和垂直对齐。halign可以设置为`left`、`center`或`right`，而valign可以设置为`top`、`center`或`bottom`。如果比例设置为`1`，元素将按比例缩放到屏幕分辨率。如果最大设置为`1`，元素将被最大化，以确保覆盖屏幕的100%。
    | halign、valign、比例和最大 |'
- en: '| fullscreen | When active in this mode, the element viewport will be exactly
    the same as the render viewport.If scale is set to `1`, the element will be stretched
    to the screen resolution. | scale |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 全屏 | 在此模式下激活时，元素视口将与渲染视口完全相同。如果比例设置为`1`，元素将被拉伸到屏幕分辨率。 | 比例 |'
- en: Actions
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作
- en: UI actions are the core of the UI flowgraph implementation. Each action is represented
    by a flowgraph, and defines a UI state. For example, each screen in a main menu
    would be handled using a separate action.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: UI动作是UI流程图实现的核心。每个动作都由一个流程图表示，并定义了一个UI状态。例如，主菜单中的每个屏幕都将使用单独的动作来处理。
- en: All available UI actions can be seen in the **Flow Graphs** toolbox, inside
    the Flowgraph Editor.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可用的UI动作都可以在**流程图**工具箱中看到，在流程图编辑器中。
- en: '![Actions](img/5909_07_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![动作](img/5909_07_02.jpg)'
- en: 'To create a new UI action, navigate to **File** | **New UI action**, and specify
    the name of your new action in the newly opened **Save As** dialog box:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '要创建新的UI动作，导航到**文件** | **新UI动作**，并在新打开的**另存为**对话框中指定您的新动作的名称： '
- en: '![Actions](img/5909_07_03.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![动作](img/5909_07_03.jpg)'
- en: Actions are started by using the **UI:Action:Control** node and specifying the
    name of the pending action in the **UIAction** input port, and then activating
    the **Start** input.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用**UI:Action:Control**节点启动动作，并在**UIAction**输入端口中指定待处理动作的名称，然后激活**Start**输入来启动动作。
- en: '![Actions](img/5909_07_04.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![动作](img/5909_07_04.jpg)'
- en: 'Once started, the UI graph with the specified name will be activated, assuming
    it contains a **UI:Action:Start** node as shown:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，具有指定名称的UI图将被激活，假设它包含一个如下所示的**UI:Action:Start**节点：
- en: '![Actions](img/5909_07_05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![动作](img/5909_07_05.jpg)'
- en: 'The graph can then initialize the requested UI by listening to the **StartAction**
    output port. Once the action is done, it should call **UI:Action:End** as shown:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，图表可以通过监听**StartAction**输出端口来初始化请求的UI。一旦动作完成，应该调用**UI:Action:End**，如下所示：
- en: '![Actions](img/5909_07_06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![动作](img/5909_07_06.jpg)'
- en: And that's it. UI graphs are saved as flowgraph XML files in `Game/Libs/UI/UIActions/`.
    The initial UI action is called **Sys_StateControl** and will always be active.
    The state controller graph should be responsible for loading and enabling menus
    based on system events such as level load.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。UI图表以flowgraph XML文件的形式保存在`Game/Libs/UI/UIActions/`中。初始UI动作称为**Sys_StateControl**，并且始终处于活动状态。状态控制器图应负责根据系统事件（如关卡加载）加载和启用菜单。
- en: The system state control action (`Sys_StateControl.xml`) is always active, and
    is used to start the initial actions, for example, to display the main menu when
    the engine is started.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 系统状态控制动作（`Sys_StateControl.xml`）始终处于活动状态，并且用于启动初始动作，例如在引擎启动时显示主菜单。
- en: Creating a main menu
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建主菜单
- en: Now that we have a basic understanding of the UI flowgraph implementation, let's
    get started with creating our very own main menu.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对UI流程图实现有了基本的了解，让我们开始创建我们自己的主菜单吧。
- en: Creating menu elements
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建菜单元素
- en: The first thing we need to do is create our UI element definition in order to
    provide the engine with a means for loading our exported SWF file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建我们的UI元素定义，以便为引擎提供加载我们导出的SWF文件的手段。
- en: 'To do so, create a new XML document in `Game/Libs/UI/UIElements/` named `MainMenuSample.xml`.
    The bare minimum code required for our menu can be seen in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，在`Game/Libs/UI/UIElements/`中创建一个名为`MainMenuSample.xml`的新XML文档。我们菜单所需的最低限度的代码可以在以下代码中看到：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the previous code present, the engine will know where to load our SWF file,
    and how to align it on the screen.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上面的代码，引擎就会知道在哪里加载我们的SWF文件，以及如何在屏幕上对齐它。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SWF files can be re-exported by using `GFxExport.exe` (usually present in the
    `<root>/Tools/` directory) to be more efficient for an in-engine use. This is
    usually done before releasing the game.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SWF文件可以通过使用`GFxExport.exe`（通常位于`<root>/Tools/`目录中）重新导出，以便在引擎中更高效地使用。这通常是在发布游戏之前完成的。
- en: Exposing ActionScript assets
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露ActionScript资产
- en: Moving on, we'll need to expose the functions and events we defined in our Flash
    source file in order to allow the engine to invoke and receive these.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要暴露我们在Flash源文件中定义的函数和事件，以便允许引擎调用和接收这些函数和事件。
- en: When exposing functions and events, we create simplistic flowgraph nodes that
    can be used by any flowgraph.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在暴露函数和事件时，我们创建了简单的流程图节点，可以被任何流程图使用。
- en: 'Once created, function nodes can be accessed by navigating to **UI** | **Functions**
    as shown in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，函数节点可以通过导航到**UI** | **函数**来访问，如下面的截图所示：
- en: '![Exposing ActionScript assets](img/5909_07_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![暴露ActionScript资产](img/5909_07_07.jpg)'
- en: Events can be found by navigating to **UI** | **Events**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导航到**UI** | **Events**，可以找到事件。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is also possible to create UI actions and elements in C++, effectively giving
    the user interface the ability to send and get events from native code. We'll
    be going through this in the *Creating UI Game Event System* section later in
    this chapter.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在C++中创建UI操作和元素，有效地使用户界面能够从本机代码发送和接收事件。我们将在本章后面的*创建UI游戏事件系统*部分中介绍这一点。
- en: Functions
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数
- en: 'To expose a method, we need to add a new `<functions>` section into the `UIElement`
    definition as shown in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要公开一个方法，我们需要像以下代码中所示，在`UIElement`定义中添加一个新的`<functions>`部分：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the previous code, the engine will create two nodes that we can utilize
    to invoke the `setupScreen` and `addBigButton` ActionScript methods from our UI
    Graphs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述代码，引擎将创建两个节点，我们可以利用这些节点来调用UI图表中的`setupScreen`和`addBigButton` ActionScript方法。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Functions are always placed in the same flowgraph category: **UI:Functions:ElementName:FunctionName**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 函数始终放置在相同的flowgraph类别中：**UI:Functions:ElementName:FunctionName**
- en: '![Functions](img/5909_07_08.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![函数](img/5909_07_08.jpg)'
- en: When the **Call** port on either of the nodes displayed in the previous screenshot
    is triggered, the ActionScript method will be invoked with the specified parameters.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发前一个截图中显示的任一节点上的**Call**端口时，将调用ActionScript方法并使用指定的参数。
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **instanceID** input port determines which element instance to invoke the
    function on. If the value is set to `-1` (default), it will be invoked on all
    instances, otherwise if set to `-2`, it will be called on all initialized instances.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**instanceID**输入端口确定要在哪个元素实例上调用函数。如果值设置为`-1`（默认值），则将在所有实例上调用，否则如果设置为`-2`，则将在所有初始化的实例上调用。'
- en: Events
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: 'Setting up events is done in a similar way to functions, by using the `<events>`
    tag as shown:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 设置事件的方式与函数类似，使用`<events>`标签如下：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The previous code will result in the engine making the **OnBigButton** node
    available, triggered when the Flash file invokes the `onBigButton` fscommand,
    along with the associated button ID.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将使引擎创建**OnBigButton**节点可用，当Flash文件调用`onBigButton` fscommand时触发，同时会有相关的按钮ID。
- en: '![Events](img/5909_07_09.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![事件](img/5909_07_09.jpg)'
- en: Invoking a `fscommand` from Flash is relatively easy. The following code will
    trigger the `onBigButton` event, along with the associated button ID string.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从Flash中调用`fscommand`相对容易。以下代码将触发`onBigButton`事件，并附带相关的按钮ID字符串。
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Similar to functions, events are always placed in **UI:Events:ElementName:EventName**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数类似，事件始终放置在**UI:Events:ElementName:EventName**中。
- en: Variables
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: It's also possible to define access to variables present in the Flash source
    file via the element definition. This allows for getting and setting the value
    of your variable by using the **UI:Variable:Var** node.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过元素定义定义访问Flash源文件中存在的变量。这允许通过使用**UI:Variable:Var**节点获取和设置变量的值。
- en: 'To start, define your array inside the element definition''s `<variables>`
    block:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在元素定义的`<variables>`块中定义数组：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After restarting the editor, place a new **UI:Variable:Var** node and browse
    for your new variable as shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动编辑器后，放置一个新的**UI:Variable:Var**节点，并按照以下截图中所示浏览您的新变量：
- en: '![Variables](img/5909_07_10.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![变量](img/5909_07_10.jpg)'
- en: 'Then we can simply set or get the value of our variable at any time by using
    flowgraph:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以通过flowgraph随时设置或获取我们的变量的值：
- en: '![Variables](img/5909_07_11.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![变量](img/5909_07_11.jpg)'
- en: Arrays
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: In the previous section, we set the value of a Flash variable at runtime. This
    is also possible for arrays, by using the **UI:Variable:Array** node.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们在运行时设置了Flash变量的值。通过使用**UI:Variable:Array**节点，也可以对数组进行相同操作。
- en: 'To start, expose the array inside your element''s `<arrays>` block as shown:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下方式公开元素`<arrays>`块中的数组：
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then simply restart your array and repeat the previous process, but with the
    **UI:Variable:Array** node. To create a new array via your UI graph, use the **UI:Util:ToArray**
    node:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后简单地重新启动数组并重复之前的过程，但使用**UI:Variable:Array**节点。要通过UI图表创建新数组，请使用**UI:Util:ToArray**节点：
- en: '![Arrays](img/5909_07_12.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![数组](img/5909_07_12.jpg)'
- en: Exposing MovieClip instances to flowgraph
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将MovieClip实例公开给flowgraph
- en: In the same way that variables can be exposed, it's also possible to give direct
    access to MovieClips via the UI graphs. This allows the possibility to go to specific
    frames, change properties, and more.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量可以公开类似，也可以通过UI图表直接访问MovieClips。这允许跳转到特定帧，更改属性等。
- en: 'All nodes that allow MovieClip interaction can be found by navigating to **UI**
    | **MovieClip** within the Flowgraph Editor: as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 所有允许MovieClip交互的节点都可以在Flowgraph编辑器中的**UI** | **MovieClip**中找到，如下截图所示：
- en: '![Exposing MovieClip instances to flowgraph](img/5909_07_13.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![将MovieClip实例公开给flowgraph](img/5909_07_13.jpg)'
- en: 'To start, add or edit the `<movieclips>` block in your element definition as
    shown:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按照以下方式添加或编辑元素定义中的`<movieclips>`块：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will give flowgraph access to the **m_myMovieClip** movieclip present in
    your Flash file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使flowgraph可以访问Flash文件中存在的**m_myMovieClip** MovieClip。
- en: 'Once the editor has been restarted, we can, for example, use the **UI:MovieClip:GotoAndPlay**
    node to skip directly to a different frame in the specified clip as shown in the
    following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器重新启动后，我们可以使用**UI:MovieClip:GotoAndPlay**节点，例如直接跳转到指定剪辑中的不同帧，如下截图所示：
- en: '![Exposing MovieClip instances to flowgraph](img/5909_07_14.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![将MovieClip实例公开给flowgraph](img/5909_07_14.jpg)'
- en: Creating the UI actions
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建UI操作
- en: Now that we've configured the main menu element, it's time to create the UI
    actions that will result in the menu appearing in the Launcher application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了主菜单元素，是时候创建UI操作，使菜单出现在启动器应用程序中了。
- en: Creating the state control graph
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建状态控制图
- en: Start by opening Sandbox and the Flowgraph Editor. Once it is open, create a
    new UI action by navigating to **File** | **New UI Action**. Call the action **Sys_StateControl**.
    This will be the primary UI action in which we trigger the initial menu and handle
    crucial system events.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开Sandbox和Flowgraph Editor。一旦打开，通过导航到**文件**|**新建UI动作**来创建一个新的UI动作。将动作命名为**Sys_StateControl**。这将是我们触发初始菜单和处理关键系统事件的主要UI动作。
- en: 'Once the action has been created, we''ll be using the following three system
    events:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建动作后，我们将使用以下三个系统事件：
- en: OnSystemStarted
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OnSystemStarted
- en: OnLoadingError
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OnLoadingError
- en: OnUnloadComplete
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OnUnloadComplete
- en: Together, these events signify when our main menu should appear. We'll be tying
    them together into a **UI:Action:Control** node, which in turn activates the MainMenu
    UIAction we'll create later.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件一起表示我们的主菜单应该何时出现。我们将把它们绑定到一个**UI:Action:Control**节点中，该节点将激活我们稍后将创建的MainMenu
    UIAction。
- en: '![Creating the state control graph](img/5909_07_15.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![创建状态控制图](img/5909_07_15.jpg)'
- en: Creating the MainMenu action
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建MainMenu动作
- en: When you're done, create another UI action and name it **MainMenu**. Once this
    is open, place a **UI:Action:Start** node. It's **StartAction** output port will
    be automatically activated when the **UI:Action:Control** node we created previously
    is executed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，创建另一个UI动作，并命名为**MainMenu**。一旦打开，放置一个**UI:Action:Start**节点。当我们之前创建的**UI:Action:Control**节点被执行时，它的**StartAction**输出端口将自动激活。
- en: We can now hook the **Start** node to a **UI:Display:Display** and **UI:Display:Config**
    node in order to initialize the main menu, making sure that the user can see it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将**Start**节点连接到**UI:Display:Display**和**UI:Display:Config**节点，以初始化主菜单，并确保用户可以看到它。
- en: '![Creating the MainMenu action](img/5909_07_16.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![创建MainMenu动作](img/5909_07_16.jpg)'
- en: Our flash file will now be displayed when the game starts, but currently lacks
    any additional configuration from flowgraph.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的flash文件现在将在游戏启动时显示，但目前还缺少来自flowgraph的任何额外配置。
- en: Adding buttons
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加按钮
- en: Now that our main menu file is initialized, we'll need to add a bit of ActionScript
    code to the Flash file in order to allow dynamic spawning and handling of buttons
    from our UI graph.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的主菜单文件已初始化，我们需要在Flash文件中添加一些ActionScript代码，以允许从UI图中动态生成和处理按钮。
- en: This section assumes that you have a MovieClip that you can instantiate at runtime.
    In our sample, we'll be using a custom button called **BigButton**.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本节假定您有一个MovieClip可以在运行时实例化。在我们的示例中，我们将使用一个名为**BigButton**的自定义按钮。
- en: '![Adding buttons](img/5909_07_17.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![添加按钮](img/5909_07_17.jpg)'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Flash source file (`.fla`) for our main menu is present in the `Game/Libs/UI/`
    folder of our sample installation, downloadable from [https://github](https://github)
    [.com/inkdev/CryENGINE-Game-Programming-Sample/](http://.com/inkdev/CryENGINE-Game-Programming-Sample/).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主菜单的Flash源文件（.fla）位于我们示例安装的`Game/Libs/UI/`文件夹中，可从[https://github](https://github)
    [.com/inkdev/CryENGINE-Game-Programming-Sample/](http://.com/inkdev/CryENGINE-Game-Programming-Sample/)下载。
- en: 'This section also assumes that you have two ActionScript functions: `SetupScreen`
    and `AddBigButton`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本节还假定您有两个ActionScript函数：`SetupScreen`和`AddBigButton`。
- en: '`SetupScreen` should configure the default settings for the scene, and remove
    all previously spawned objects. In our case, we want buttons spawned using `AddBigButton`
    to be removed whenever we call `SetupScreen`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetupScreen`应该配置场景的默认设置，并删除所有先前生成的对象。在我们的情况下，我们希望使用`AddBigButton`生成的按钮在调用`SetupScreen`时被移除。'
- en: '`AddBigButton` should simply be a function that spawns a pre-created button
    instance as shown:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddBigButton`应该只是一个生成预先创建的按钮实例的函数，如下所示：'
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the button is clicked on, it should invoke an event that we catch in flowgraph:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当单击按钮时，它应该调用一个事件，我们在flowgraph中捕获：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For information on creating functions and events, see the *Exposing ActionScript
    assets* section discussed earlier.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有关创建功能和事件的信息，请参阅前面讨论的*公开ActionScript资产*部分。
- en: 'When you''re done, add the nodes to your MainMenu action, and call them after
    configuring the element:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，将节点添加到MainMenu动作中，并在配置元素后调用它们：
- en: '![Adding buttons](img/5909_07_18.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![添加按钮](img/5909_07_18.jpg)'
- en: Our main menu should now appear when starting the Launcher application, but
    there's no feedback for any user interaction with it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主菜单现在应该在启动启动器应用程序时出现，但是对于用户与之交互没有任何反馈。
- en: 'To resolve this, we can utilize the OnBigButton node that we exposed earlier
    in the chapter. This node will send events when a button has been clicked on,
    along with a string identifier that we can use to figure out which node was clicked:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以利用前面在本章中公开的OnBigButton节点。该节点将在按钮被点击时发送事件，以及一个字符串标识符，我们可以用来确定点击了哪个节点：
- en: '![Adding buttons](img/5909_07_19.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![添加按钮](img/5909_07_19.jpg)'
- en: In the previous graph, we intercept the button events and use the **String:Compare**
    node to check what we need to do with the input. If the **IDD_Quit** button was
    clicked, we exit the game, and if the **IDD_Start** node was clicked, we load
    the **Demo** level.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们拦截按钮事件，并使用**String:Compare**节点来检查我们需要对输入做什么。如果点击了**IDD_Quit**按钮，我们退出游戏，如果点击了**IDD_Start**节点，我们加载**Demo**关卡。
- en: End result
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终结果
- en: 'Assuming that you didn''t create your own menu design, you should now see the
    following screenshot when starting the Launcher:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您没有创建自己的菜单设计，现在启动启动器时应该看到以下截图：
- en: '![End result](img/5909_07_20.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![最终结果](img/5909_07_20.jpg)'
- en: Now that you've learned how easy creating a simple menu is, why not go ahead
    and create a **Heads-Up Display** (**HUD**) that is shown when the player is spawned?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了创建一个简单菜单有多么容易，为什么不继续创建一个在玩家生成时显示的**HUD**（**Heads-Up Display**）呢？
- en: Engine ActionScript callbacks
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引擎ActionScript回调
- en: There are a number of ActionScript callbacks that are automatically called by
    the engine. Simply by defining the functions in your Flash source file root, the
    engine will be able to invoke them.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎会自动调用一些ActionScript回调。只需在Flash源文件根目录中定义这些函数，引擎就能够调用它们。
- en: '`cry_onSetup(isConsole:Boolean)`: This function is called when the SWF file
    is initially loaded by the engine.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cry_onSetup(isConsole:Boolean)`: 当SWF文件被引擎初始加载时调用此函数。'
- en: '`cry_onShow()`: This function is called when the SWF file is shown.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cry_onShow()`: 当SWF文件显示时调用此函数。'
- en: '`cry_onHide()`: This function is called when the SWF file is hidden.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cry_onHide()`: 当SWF文件隐藏时调用此函数。'
- en: '`cry_onResize(_iWidth:Number, _iHeight:Number)`: This function is called when
    the in-game resolution is changed.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cry_onResize(_iWidth:Number, _iHeight:Number)`: 当游戏分辨率更改时调用此函数。'
- en: '`cry_onBack()`: This function is called when the user presses the back button.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cry_onBack()`: 当用户按下返回按钮时调用此函数。'
- en: '`cry_requestHide()`: This function is called when the element is hidden.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cry_requestHide()`: 当元素隐藏时调用此函数。'
- en: Creating UI game event systems
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建UI游戏事件系统
- en: The UI system utilizes the `IUIGameEventSystem` interface to communicate with
    flowgraph, allowing for custom functions and events to be defined in the same
    manner in which the ActionScript assets are exposed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: UI系统利用`IUIGameEventSystem`接口与流程图进行通信，允许以与公开ActionScript资源相同的方式定义自定义函数和事件。
- en: This is used to allow user interfaces to access game and engine functionalities
    such as getting a list of playable levels. Each game event system specifies its
    category, which is then used in the Flowgraph Editor to define the category of
    functions and events registered.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于允许用户界面访问游戏和引擎功能，例如获取可玩关卡列表。每个游戏事件系统都指定其类别，然后在流程图编辑器中用于定义注册的函数和事件的类别。
- en: For example, if we create an event system named MyUI using `IFlashUI::CreateEventSystem`,
    all functions will be found by navigating to **UI** | **Functions** | **MyUI**.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们使用`IFlashUI::CreateEventSystem`创建名为MyUI的事件系统，可以通过导航到**UI** | **Functions**
    | **MyUI**找到所有函数。
- en: Implementing IUIGameEventSystem
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现`IUIGameEventSystem`
- en: 'Implementing `IUIGameEventSystem` doesn''t require much work; there are only
    the following three pure virtuals that we need to assign:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`IUIGameEventSystem`不需要太多工作；我们只需要分配以下三个纯虚函数：
- en: '`GetTypeName`: This is not directly overridden; use the `UIEVENTSYSTEM` macro
    instead.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetTypeName`: 不直接重写；而是使用`UIEVENTSYSTEM`宏。'
- en: '`InitEventSystem`: This is called to initialize the event system.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InitEventSystem`: 调用此函数初始化事件系统。'
- en: '`UnloadEventSystem`: This is called to unload the event system.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnloadEventSystem`: 调用此函数卸载事件系统。'
- en: 'Therefore, the bare minimum is as follows (the following file was saved as
    `MyUIGameEventSystem.h`):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最低要求如下（以下文件保存为`MyUIGameEventSystem.h`）：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have the class definition resolved, we can move on to the code itself.
    Start by creating a new file called `MyUIGameEventSystem.cpp`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解析了类定义，可以继续进行代码本身。首先创建一个名为`MyUIGameEventSystem.cpp`的新文件。
- en: Once this file is created, register the event system by using the `REGISTER_UI_EVENTSYSTEM`
    macro. This is used to automatically create an instance of your class from within
    the `CUIManager` class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此文件后，使用`REGISTER_UI_EVENTSYSTEM`宏注册事件系统。这用于从`CUIManager`类内部自动创建您的类的实例。
- en: 'Place the macro at the bottom of your CPP file, outside of the method scope
    as shown:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将宏放在CPP文件的底部，超出方法范围，如下所示：
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the `REGISTER_UI_EVENTSYSTEM` macro will only work in the CryGame
    project.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`REGISTER_UI_EVENTSYSTEM`宏仅在CryGame项目中有效。
- en: Our event system should now compile, and will be created along with the other
    event systems contained in CryGame.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的事件系统现在应该编译，并将与CryGame中包含的其他事件系统一起创建。
- en: Our event system doesn't do anything at the moment. Read the following sections
    to learn how to expose functions and events to the UI flowgraphs.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的事件系统目前没有任何功能。阅读以下部分以了解如何将函数和事件公开给UI流程图。
- en: Receiving events
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接收事件
- en: Event systems can expose functions that work in the same way that the nodes
    we registered via our Main Menu element do. By exposing functions, we can allow
    the graphs to interact with our game to, for example, request player health.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 事件系统可以公开与我们通过主菜单元素注册的节点相同方式工作的函数。通过公开函数，我们可以允许图形与我们的游戏交互，例如请求玩家健康状况。
- en: 'To start, we''ll need to add two new members to our `CMyUIGameEventSystem`
    class:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向`CMyUIGameEventSystem`类添加两个新成员：
- en: '[PRE16]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The event dispatcher will be responsible for invoking functions as their nodes
    are triggered in flowgraph.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 事件分发器将负责在流程图中触发其节点时调用函数。
- en: 'To start creating a function, add the following code to the class declaration:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建函数，请将以下代码添加到类声明中：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To register our function, add the following code within your `InitEventSystem`
    function:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册我们的函数，请在`InitEventSystem`函数中添加以下代码：
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You should now be able to see your node in the Flowgraph Editor after recompiling
    and restarting Sandbox:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编译并重新启动Sandbox后，您现在应该能够在流程图编辑器中看到您的节点。
- en: '![Receiving events](img/5909_07_21.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![接收事件](img/5909_07_21.jpg)'
- en: Dispatching events
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分派事件
- en: Being able to expose events to the UI graph is very useful, allowing you to
    handle event-based UI logic to, for example, display a scoreboard when the user
    requests it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 能够向UI图形公开事件非常有用，允许您处理基于事件的UI逻辑，例如在用户请求时显示记分牌。
- en: 'To start off, lets add the following code to your class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向您的类添加以下代码：
- en: '[PRE19]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `EUIEvent` enum contains the various events we're going to register, and
    is used as a way for the event sender to know which event you're trying to send
    to the UI system.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`EUIEvent`枚举包含我们要注册的各种事件，并且作为事件发送方知道您要发送到UI系统的事件的一种方式。'
- en: 'Now we''ll need to append a bit of code to the `InitEventSystem` function to
    expose our event as shown:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在`InitEventSystem`函数中添加一些代码来公开我们的事件，如下所示：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The **OnMyUIEvent** node should now appear in the Editor after a successful
    recompilation:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 成功重新编译后，**OnMyUIEvent**节点现在应该出现在编辑器中：
- en: '![Dispatching events](img/5909_07_22.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![分派事件](img/5909_07_22.jpg)'
- en: Dispatching the event
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分派事件
- en: 'To dispatch your UI event, use `SUIEventSenderDispatcher::SendEvent`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要分派您的UI事件，请使用`SUIEventSenderDispatcher::SendEvent`：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how user interfaces are created in CryENGINE,
    and created our own main menu with that knowledge.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在CryENGINE中创建用户界面，并利用这些知识创建了自己的主菜单。
- en: You know have the basic knowledge required to implement your own UI and UI event
    systems..
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经掌握了实现自己的UI和UI事件系统所需的基本知识。
- en: If you would prefer to work more with user interfaces before moving on to the
    next chapter, why not expand the Main Menu we created earlier? A good starting
    point could be to implement a level selection screen.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢在进入下一章之前更多地与用户界面一起工作，为什么不扩展我们之前创建的主菜单呢？一个很好的起点可能是实现一个关卡选择屏幕。
- en: In the next chapter, we'll be covering the process of creating networked games
    to allow multiplayer functionality.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍创建网络游戏的过程，以实现多人游戏功能。
