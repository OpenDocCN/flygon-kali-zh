- en: '*Chapter 14*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第14章*：'
- en: Sorting and Searching
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序和搜索
- en: This chapter covers the most popular sorting and searching algorithms that are
    encountered in technical interviews. We will cover sorting algorithms such as
    Merge Sort, Quick Sort, Radix Sort, Heap Sort, and Bucket Sort, and searching
    algorithms such as Binary Search.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了技术面试中遇到的最流行的排序和搜索算法。我们将涵盖诸如归并排序、快速排序、基数排序、堆排序和桶排序等排序算法，以及二分搜索等搜索算法。
- en: 'By the end of this chapter, you should be able to tackle a wide range of problems
    that involve sorting and searching algorithms. We’ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您应该能够解决涉及排序和搜索算法的各种问题。我们将涵盖以下主题：
- en: Sorting algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序算法
- en: Searching algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索算法
- en: Coding challenges
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码挑战
- en: Let’s get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find all the code files for this chapter on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter14](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter14).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的所有代码文件，网址为[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter14](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter14)。
- en: Sorting algorithms
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序算法
- en: 'Considering the sorting algorithms from the perspective of a person preparing
    for an interview reveals two main categories: a category containing a lot of relatively
    simple sorting algorithms that don’t occur in interviews, such as Bubble Sort,
    Insertion Sort, Counting Sort, and so on, and a category containing Heap Sort,
    Merge Sort, Quick Sort, Bucket Sort, and Radix Sort. These represent the top five
    sorting algorithms that occur in technical interviews.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从准备面试的人的角度考虑排序算法，可以发现两个主要类别：一个类别包含许多相对简单的排序算法，不会在面试中出现，例如冒泡排序、插入排序、计数排序等，另一个类别包含堆排序、归并排序、快速排序、桶排序和基数排序。这些代表了技术面试中出现的前五个排序算法。
- en: If you are not familiar with the simple sorting algorithms, then I strongly
    recommend that you buy my book, *Java Coding Problems* ([www.packtpub.com/programming/java-coding-problems](http://www.packtpub.com/programming/java-coding-problems)),
    published by Packt. In [*Chapter 5*](B15403_05_Final_JM_ePub.xhtml#_idTextAnchor072)*,
    Arrays, Collections, and Data Structures*, of *Java Coding Problems*, you can
    find detailed coverage of Bubble Sort, Insertion Sort, Counting Sort, and so on.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对简单的排序算法不熟悉，那么我强烈建议您购买我的书《Java编程问题》（[www.packtpub.com/programming/java-coding-problems](http://www.packtpub.com/programming/java-coding-problems)），由Packt出版。在《Java编程问题》的[*第5章*](B15403_05_Final_JM_ePub.xhtml#_idTextAnchor072)*，数组、集合和数据结构*中，您可以找到对冒泡排序、插入排序、计数排序等的详细介绍。
- en: 'Furthermore, the application called *SortArraysIn14Ways* contains the implementations
    of 14 different sorting algorithms that you should know. The complete list is
    as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，名为*SortArraysIn14Ways*的应用程序包含了您应该了解的14种不同排序算法的实现。完整列表如下：
- en: Bubble Sort
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: Bubble Sort with a `Comparator`
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`Comparator`的冒泡排序
- en: Bubble Sort optimized
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化的冒泡排序
- en: Bubble Sort optimized with a `Comparator`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化的带有`Comparator`的冒泡排序
- en: Pancake Sort
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 煎饼排序
- en: Exchange Sort
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换排序
- en: Selection Sort
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择排序
- en: Shell Sort
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希尔排序
- en: Insertion Sort
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入排序
- en: Insertion Sort with a `Comparator`
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`Comparator`的插入排序
- en: Counting Sort
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数排序
- en: Merge Sort
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归并排序
- en: Heap Sort
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆排序
- en: Heap Sort with a `Comparator`
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`Comparator`的堆排序
- en: Bucket Sort
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桶排序
- en: Cocktail Sort
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鸡尾酒排序
- en: Cycle Sort
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环排序
- en: Quick Sort
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速排序
- en: Quick Sort with a `Comparator`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有`Comparator`的快速排序
- en: Radix Sort
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基数排序
- en: 'In the following sections, we will have a brief overview of the main algorithms
    that are encountered in interviews: Heap Sort, Merge Sort, Quick Sort, Bucket
    Sort, and Radix Sort. If you are already familiar with these algorithms, then
    consider jumping directly to the *Searching algorithms* section, or even to the
    *Coding challenges* section.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将简要概述面试中遇到的主要算法：堆排序、归并排序、快速排序、桶排序和基数排序。如果您已经熟悉这些算法，请考虑直接跳转到*搜索算法*部分，甚至是*编码挑战*部分。
- en: Heap Sort
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆排序
- en: If you are not familiar with the heap concept, then consider reading the *Binary
    Heaps* section of [*Chapter 13*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*,
    Trees and Graphs*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对堆的概念不熟悉，请考虑阅读[*第13章*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*，树和图*中的*二叉堆*部分。
- en: 'Heap Sort is an algorithm that relies on a binary heap (a complete binary tree).
    The time complexity cases are as follows: best case O(n log n), average case O(n
    log n), worst case O(n log n). The space complexity case is O(1).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 堆排序是一种依赖于二叉堆（完全二叉树）的算法。时间复杂度分别为：最佳情况O(n log n)，平均情况O(n log n)，最坏情况O(n log n)。空间复杂度为O(1)。
- en: Sorting elements in ascending order can be accomplished via a Max Heap (the
    parent node is always greater than or equal to the child nodes), and in descending
    order via a Min Heap (the parent node is always smaller than or equal to the child
    nodes).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最大堆（父节点始终大于或等于子节点）对元素进行升序排序，通过最小堆（父节点始终小于或等于子节点）对元素进行降序排序。
- en: 'The Heap Sort algorithm has several main steps, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 堆排序算法有几个主要步骤，如下：
- en: Transform the given array into a Max Binary Heap.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将给定数组转换为最大二叉堆。
- en: Next, the root is swapped with the last element from the heap and the heap’s
    size is reduced by 1 (this is like deleting the root element of the heap). So,
    the greater element (the heap root) goes to the last position. In other words,
    the elements that are at the root of the heap come out one by one in sorted order.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根节点与堆的最后一个元素交换，并且堆的大小减1（这就像删除堆的根元素）。因此，较大的元素（堆的根）移到最后的位置。换句话说，堆的根元素一个接一个地按排序顺序出来。
- en: The final step consists of *heapifying* the remaining heap (apply the recursive
    process that reconstructs the max heap in a top-down manner).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是*堆化*剩余的堆（以自顶向下的递归过程重建最大堆）。
- en: Repeat from *step 2* while the heap size is greater than 1.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在堆大小大于1时重复*步骤2*。
- en: 'The following diagram represents a test case of applying the Heap Sort algorithm:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表代表了应用堆排序算法的一个测试案例：
- en: '![Figure 14.1 – Heap sort'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.1 - 堆排序'
- en: '](img/Figure_14.1_B15403.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.1_B15403.jpg)'
- en: Figure 14.1 – Heap Sort
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 - 堆排序
- en: 'For example, let’s assume the array from the preceding diagram; that is, 4,
    5, 2, 7, 1:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，让我们假设前面图表中的数组；即4, 5, 2, 7, 1：
- en: 'So, at the first step, we build the Max Heap: 7, 5, 2, 4, 1 (we swapped 5 with
    7, 4 with 7, and 4 with 5).'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，在第一步，我们构建最大堆：7, 5, 2, 4, 1（我们用5和7交换，用4和7交换，用4和5交换）。
- en: 'Next, swap the root (7) with the last element (1) and delete 7\. Result: 1,
    5, 2, 4, **7**.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将根（7）与最后一个元素（1）交换并删除7。结果：1, 5, 2, 4, **7**。
- en: 'Furthermore, we construct the Max Heap again: 5, 4, 2, 1 (we swapped 1 with
    5 and 1 with 4).'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们再次构建最大堆：5, 4, 2, 1（我们用1和5交换，用1和4交换）。
- en: 'We swap the root (5) with the last element (1) and delete 5\. Result: 1, 4,
    2, **5, 7**.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将根（5）与最后一个元素（1）交换并删除5。结果：1, 4, 2, **5, 7**。
- en: 'Next, we construct the Max Heap again: 4, 1, 2 (we swapped 1 with 4).'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们再次构建最大堆：4, 1, 2（我们用1和4交换）。
- en: 'We swap the root (4) with the last element (2) and delete 4\. Result: 2, 1,
    **4, 5, 7**.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将根（4）与最后一个元素（2）交换并删除4。结果：2, 1, **4, 5, 7**。
- en: 'This is a Max Heap already, so we simply swap the root (2) with the last element
    (1) and remove 2: 1, **2, 4, 5, 7**.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这已经是一个最大堆了，所以我们只需将根（2）与最后一个元素（1）交换并移除2：1, **2, 4, 5, 7**。
- en: Done! There is a single element left in the heap (1). So, the final result is
    **1, 2, 4, 5, 7**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成！堆中只剩下一个元素（1）。所以，最终结果是**1, 2, 4, 5, 7**。
- en: 'In terms of code, the preceding example can be generalized as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，上面的例子可以概括如下：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Heap Sort is not a stable algorithm. A stable algorithm guarantees the order
    of duplicate elements. The complete application is called *HeapSort*. This application
    contains an implementation based on `Comparator` as well – this is useful for
    sorting objects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 堆排序不是一个稳定的算法。稳定的算法保证了重复元素的顺序。完整的应用程序称为*HeapSort*。这个应用程序还包含了基于`Comparator`的实现
    - 这对于对对象进行排序很有用。
- en: Merge Sort
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归并排序
- en: 'Now, let’s discuss the Merge Sort algorithm. The time complexity cases are
    as follows: best case O(n log n), average case O(n log n), worst case O(n log
    n). The space complexity may vary, depending on the chosen data structures (it
    can be O(n)).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一下归并排序算法。时间复杂度情况如下：最佳情况O(n log n)，平均情况O(n log n)，最坏情况O(n log n)。空间复杂度可能会有所不同，取决于所选择的数据结构（可能是O(n)）。
- en: The Merge Sort algorithm is a recursive algorithm based on the famous *divide
    and conquer* strategy. Considering that you’ve been given an unsorted array, applying
    the Merge Sort algorithm requires you to continually split the array in half until
    we obtain empty sub-arrays or sub-arrays that contains a single element (this
    is *divide and conquer*). If a sub-array is empty or contains one element, it
    is sorted by its definition – this is the recursion *base case*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序算法是一种基于著名的*分而治之*策略的递归算法。考虑到你已经得到了一个未排序的数组，应用归并排序算法需要你不断地将数组分成两半，直到得到空的子数组或者只包含一个元素的子数组（这就是*分而治之*）。如果一个子数组是空的或者只包含一个元素，那么它根据定义是已排序的
    - 这就是递归的*基本情况*。
- en: 'If we haven’t reached the *base case* yet, we divide both these sub-arrays
    again and attempt to sort them. So, if the array contains more than one element,
    we split it and we recursively invoke the sort operation on both sub-arrays. The
    following diagram shows the splitting process for the 52, 28, 91, 19, 76, 33,
    43, 57, 20 array:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有达到*基本情况*，我们再次将这些子数组分割，并尝试对它们进行排序。所以，如果数组包含多于一个元素，我们将其分割，并在这两个子数组上递归调用排序操作。下面的图表显示了对数组52,
    28, 91, 19, 76, 33, 43, 57, 20的分割过程：
- en: '![Figure 14.2 – Splitting the given array in the merge sort algorithm](img/Figure_14.2_B15403.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 - 在归并排序算法中分割给定的数组](img/Figure_14.2_B15403.jpg)'
- en: Figure 14.2 – Splitting the given array in the Merge Sort algorithm
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 - 在归并排序算法中分割给定的数组
- en: 'Once the splitting is done, we call the fundamental operation of this algorithm:
    the *merge* operation (also known as the *combine* operation). Merging is the
    operation of taking two smaller sorted sub-arrays and combining them into a single,
    sorted, new sub-array. This is done until the entire given array is sorted. The
    following diagram shows the merging operation for our array:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦分割完成，我们调用这个算法的基本操作：*merge*操作（也称为*combine*操作）。合并是将两个较小的排序子数组合并成一个新的排序子数组的操作。这样做直到整个给定的数组排序完成。下面的图表显示了我们数组的合并操作：
- en: '![Figure 14.3 – Merging operation for merge sort'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.3 - 归并排序的合并操作'
- en: '](img/Figure_14.3_B15403.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.3_B15403.jpg)'
- en: Figure 14.3 – Merging operation for Merge Sort
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 - 归并排序的合并操作
- en: 'The following code implements the Merge Sort algorithm. The flow begins from
    the `sort()` method. Here, we begin by asking the *base case* question. If the
    size of the array is greater than 1, then we call the `leftHalf()` and `rightHalf()`
    methods, which will split the given array into two sub-arrays. The rest of the
    code from `sort()` is responsible for calling the `merge()` method, which sorts
    two unsorted sub-arrays:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码实现了归并排序算法。流程从`sort()`方法开始。在这里，我们首先询问*基本情况*的问题。如果数组的大小大于1，那么我们调用`leftHalf()`和`rightHalf()`方法，这将把给定的数组分成两个子数组。`sort()`中的其余代码负责调用`merge()`方法，对两个未排序的子数组进行排序：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, the merge operation places the elements back into the original array
    one at a time by repeatedly taking the smallest element from the sorted sub-arrays:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，合并操作将元素逐个放回原始数组，重复从排序好的子数组中取出最小的元素：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the `left[t1] <= right[t2]` statement guarantees that the algorithm
    is stable. A stable algorithm guarantees the order of duplicate elements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`left[t1] <= right[t2]`语句保证了算法的稳定性。稳定的算法保证了重复元素的顺序。
- en: The complete application is called *MergeSort*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*MergeSort*。
- en: Quick Sort
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速排序
- en: 'Quick Sort is another recursive sorting algorithm based on the famous *divide
    and conquer* strategy. The time complexity cases are as follows: best case O(n
    log n), average case O(n log n), worst case O(n2). The space complexity is O(log
    n) or O(n).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是另一种基于著名的*分而治之*策略的递归排序算法。时间复杂度情况如下：最佳情况O(n log n)，平均情况O(n log n)，最坏情况O(n2)。空间复杂度为O(log
    n)或O(n)。
- en: The Quick Sort algorithm debuts with an important choice. We have to choose
    one of the elements of the given array as the *pivot*. Next, we partition the
    given array so that all the elements that are less than the *pivot* come before
    all the elements that are greater than it. The partitioning operation takes place
    via a bunch of swaps. This is the *divide* step in *divide and conquer*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序算法首次选择很重要。我们必须从给定数组中选择一个元素作为*枢轴*。接下来，我们对给定数组进行分区，使得所有小于*枢轴*的元素都排在所有大于它的元素之前。分区操作通过一系列交换进行。这是*分而治之*中的*分*步骤。
- en: Next, the left and the right sub-arrays are again partitioned using the corresponding
    pivot. This is achieved by recursively passing the sub-arrays into the algorithm.
    This is the *conquer* step in *divide and conquer*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用相应的枢轴递归地将左侧和右侧子数组再次进行分区。这是*分而治之*中的*征服*步骤。
- en: 'The worst case scenario (O(n2)) takes place when all the elements of the given
    array are smaller than the chosen pivot or larger than the chosen pivot. Choosing
    the pivot element can be done in at least four ways, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最坏情况（O(n2)）发生在给定数组的所有元素都小于所选的枢轴或大于所选的枢轴时。可以以至少四种方式选择枢轴元素，如下所示：
- en: Choose the first element as the pivot.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择第一个元素作为枢轴。
- en: Choose the end element as the pivot.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择最后一个元素作为枢轴。
- en: Choose the median element as the pivot.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择中位数作为枢轴。
- en: Choose the random element as the pivot.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择随机元素作为枢轴。
- en: 'Consider the array 4, 2, 5, 1, 6, 7, 3\. Here, we’re going set the pivot as
    the end element. The following diagram depicts how Quick Sort works:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑数组4, 2, 5, 1, 6, 7, 3。在这里，我们将把枢轴设置为最后一个元素。下面的图表描述了快速排序的工作原理：
- en: '![Figure 14.4 – Quick sort'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.4 - 快速排序'
- en: '](img/Figure_14.4_B15403.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.4_B15403.jpg)'
- en: Figure 14.4 – Quick Sort
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 - 快速排序
- en: '**Step 1**: We choose the last element as the pivot, so 3 is the pivot. Partitioning
    begins by locating two position markers – let’s call them *i* and *m*. Initially,
    both point to the first element of the given array. Next, we compare the element
    at position *i* with the pivot, so we compare 4 with 3\. Since 4 > 3, there is
    nothing to do, and *i* becomes 1 (*i*++), while *m* remains 0\.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤1**：我们选择最后一个元素作为枢轴，所以3是枢轴。分区开始时，找到两个位置标记 - 让我们称它们为*i*和*m*。最初，两者都指向给定数组的第一个元素。接下来，我们将位置*i*上的元素与枢轴进行比较，因此我们将4与3进行比较。由于4
    > 3，所以没有什么可做，*i*变为1（*i*++），而*m*保持为0。'
- en: '**Step 2**: We compare the element at position *i* with the pivot, so we compare
    2 with 3\. Since 2<3, we swap the element at position *m* with the element at
    position *i*, so we swap 4 with 2\. Both *m* and *i* are increased by 1, so *m*
    becomes 1 and *i* becomes 2.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤2**：我们将位置*i*上的元素与枢轴进行比较，因此我们将2与3进行比较。由于2 < 3，我们交换位置*m*上的元素与位置*i*上的元素，所以我们交换4与2。*m*和*i*都增加了1，所以*m*变为1，*i*变为2。'
- en: '**Step 3**: We compare the element at position *i* with the pivot, so we compare
    5 with 3\. Since 5 > 3, there is nothing to do, so *i* becomes 3 (*i*++), while
    *m* remains as 1.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤3**：我们将位置*i*上的元素与枢轴进行比较，因此我们将5与3进行比较。由于5 > 3，所以没有什么可做的，所以*i*变为3（*i*++），而*m*保持为1。'
- en: '**Step 4**: We compare the element on position *i* with the pivot, so we compare
    1 with 3\. Since 1 < 3, we swap the element at position *m* with the element at
    position *i*, so we swap 1 with 4\. Both *m* and *i* are increased by 1, so *m*
    becomes 2 and *i* becomes 4.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤4**：我们将位置*i*上的元素与枢轴进行比较，因此我们将1与3进行比较。由于1 < 3，我们交换位置*m*上的元素与位置*i*上的元素，所以我们交换1与4。*m*和*i*都增加了1，所以*m*变为2，*i*变为4。'
- en: '**Step 5 and 6**: We continue to compare the element at position *i* with the
    pivot. Since 6>3 and 7 > 3, there is nothing to do at these two steps. After these
    steps, *i*=7.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤5和6**：我们继续比较位置*i*上的元素与枢轴。由于6 > 3和7 > 3，在这两个步骤中没有什么可做的。完成这些步骤后，*i*=7。'
- en: '**Step 7**: The next element for *i* is the pivot itself, so there are no more
    comparisons to perform. We just swap the element at position *m* with the pivot,
    so we swap 5 with 3\. This brings the pivot to its final position. All the elements
    from its left are smaller than it, while all the elements from its right are greater
    than it. Finally, we return *m*.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤7**：*i*的下一个元素是枢轴本身，因此没有更多的比较要执行。我们只需交换位置*m*上的元素与枢轴，所以我们交换5与3。这将枢轴带到其最终位置。其左侧的所有元素都小于它，而右侧的所有元素都大于它。最后，我们返回*m*。'
- en: Furthermore, the algorithm is repeated for the array bounded by 0 (*left*) and
    *m*-1 and for the array bounded by *m*+1 and the array’s end (*right*). The algorithm
    is repeated as long as *left*<*right* is true. When this condition is evaluated
    as false, the array is sorted.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，算法对由0（*left*）和*m*-1界定的数组以及由*m*+1和数组末尾（*right*）界定的数组重复。只要*left*<*right*为真，算法就会重复。当此条件评估为假时，数组就已排序。
- en: 'The pseudocode for the quick sort algorithm is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序算法的伪代码如下：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To sort the entire array, we call `sort(array, 0, array.length-1)`. Let’s see
    its implementation:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要对整个数组进行排序，我们调用`sort(array, 0, array.length-1)`。让我们看看它的实现：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Quick Sort can swap non-adjacent elements; therefore, it is not stable. The
    complete application is called *QuickSort*. This application contains an implementation
    based on `Comparator` as well – this is useful for sorting objects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序可以交换非相邻元素；因此，它不是稳定的。完整的应用程序称为*QuickSort*。该应用程序还包含基于`Comparator`的实现 - 这对于对对象进行排序很有用。
- en: Bucket Sort
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桶排序
- en: 'Bucket Sort (or Bin Sort) is another sorting technique that’s encountered in
    interviews. It is commonly used in computer science and useful when the elements
    are uniformly distributed over a range. The time complexity cases are as follows:
    the best and average cases O(n+k), where O(k) is the time for creating the bucket
    (this will be O(1) for a linked list or hash table), while O(n) is the time needed
    to put the elements of the given array into the bucket (this will also be O(1)
    for a linked list or hash table). The worst case is O(n2). The space complexity
    is O(n+k).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 桶排序（或者称为箱排序）是面试中遇到的另一种排序技术。它在计算机科学中常用，在元素均匀分布在一个范围内时非常有用。时间复杂度情况如下：最好和平均情况为O(n+k)，其中O(k)是创建桶的时间（对于链表或哈希表来说是O(1)），而O(n)是将给定数组的元素放入桶中所需的时间（对于链表或哈希表来说也是O(1)）。最坏情况为O(n2)。空间复杂度为O(n+k)。
- en: Its climax relies on dividing the elements of the given array into groups that
    are called *buckets*. Next, each bucket is sorted individually using a different
    suitable sorting algorithm or using the bucket sorting algorithm via recursion.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其高潮在于将给定数组的元素分成称为*桶*的组。接下来，使用不同的适当排序算法或使用递归通过桶排序算法单独对每个桶进行排序。
- en: 'Creating the buckets can be done in several ways. One approach relies on defining
    a number of buckets and filling each bucket with a specific range of elements
    from the given array (this is known as *scattering*). Next, each bucket is sorted
    (via bucket sorting or other sorting algorithms). Finally, the elements are collected
    from each bucket to obtain the sorted array (this is known as *gathering*). This
    is also known as the *scatter-sort-gather* technique and is exemplified in the
    following diagram. Here, we are using bucket sort on the 4, 2, 11, 7, 18, 3, 14,
    7, 4, 16 array:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过几种方式来创建桶。一种方法依赖于定义一些桶，并将给定数组中的特定范围的元素填充到每个桶中（这称为*scatter*）。接下来，对每个桶进行排序（通过桶排序或其他排序算法）。最后，从每个桶中收集元素以获得排序后的数组（这称为*gathering*）。这也被称为*scatter-sort-gather*技术，并在下图中进行了示例。在这里，我们在数组4,
    2, 11, 7, 18, 3, 14, 7, 4, 16上使用桶排序：
- en: '![Figure 14.5 – Bucket sort via the scatter-sort-gather approach'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.5 - 通过scatter-sort-gather方法进行桶排序'
- en: '](img/Figure_14.5_B15403.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.5_B15403.jpg)'
- en: Figure 14.5 – Bucket Sort via the scatter-sort-gather approach
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 - 通过scatter-sort-gather方法进行桶排序
- en: So, as the preceding diagram reveals, we have defined four buckets for the elements
    in intervals; that is, 0-5, 5-10, 10-15, and 15-20\. Each element of the given
    array fits into a bucket. After distributing all the elements of the given array
    into buckets, we sort each bucket. The first bucket contains elements 2, 3, 4,
    and 4\. The second bucket contains elements 7, 7, and so on. Finally, we gather
    the elements from the buckets (from left to right) and we obtain the sorted array;
    that is, 2, 3, 4, 4, 7, 7, 11, 14, 16, 18.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如前面的图表所显示的，我们为间隔中的元素定义了四个桶，即0-5, 5-10, 10-15和15-20。给定数组的每个元素都适合一个桶。在将给定数组的所有元素分配到桶中后，我们对每个桶进行排序。第一个桶包含元素2,
    3, 4和4。第二个桶包含元素7, 7等。最后，我们从桶中收集元素（从左到右），并获得排序后的数组；即2, 3, 4, 4, 7, 7, 11, 14, 16,
    18。
- en: 'So, for this, we can write the following pseudocode:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这个，我们可以编写以下伪代码：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'An implementation of this pseudocode using lists can be done as follows (the
    `hash()` methods that are being called in this code are available in the code
    bundled with this book):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过列表实现此伪代码，如下所示（在此代码中调用的`hash()`方法在本书附带的代码中可用）：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another approach to creating buckets consists of putting a single element into
    a bucket, as shown in the following diagram (this time, there is no sorting involved):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建桶的另一种方法是将单个元素放入一个桶，如下图所示（这次不涉及排序）：
- en: '![Figure 14.6 – Bucket sort via the scatter-gather approach'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.6 - 通过scatter-gather方法进行桶排序'
- en: '](img/Figure_14.6_B15403.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.6_B15403.jpg)'
- en: Figure 14.6 – Bucket Sort via the scatter-gather approach
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 - 通过scatter-gather方法进行桶排序
- en: In this *scatter-gather* approach, we store the number of occurrences of an
    element in each bucket, not the element itself, while the position (the index)
    of the bucket represents the element value. For example, in bucket number 2, we
    store the number of occurrences of element 2, which in array 4, 2, 8, 7, 8, 2,
    2, 7, 4, 9 occurs three times. Since elements 1, 3, 5, and 6 are not present in
    the given array, their buckets are empty (have 0s in them). The gathering operation
    collects the elements from left to right and obtains the sorted array.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种*scatter-gather*方法中，我们在每个桶中存储元素的出现次数，而不是元素本身，而桶的位置（索引）代表元素的值。例如，在桶号2中，我们存储元素2的出现次数，在数组4,
    2, 8, 7, 8, 2, 2, 7, 4, 9中出现三次。由于给定数组中不存在元素1, 3, 5和6，它们的桶为空（其中有0）。收集操作从左到右收集元素并获得排序后的数组。
- en: 'So, for this, we can write the following pseudocode:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于这个，我们可以编写以下伪代码：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'An implementation of this pseudocode may look as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式实现此伪代码：
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Bucket Sort is not a stable algorithm. A stable algorithm guarantees the order
    of duplicate elements. The complete application is called *BucketSort*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 桶排序不是一个稳定的算法。稳定的算法保证了重复元素的顺序。完整的应用程序称为*BucketSort*。
- en: Radix Sort
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基数排序
- en: Radix Sort is a sorting algorithm that works very well for integers. In Radix
    Sort, we sort the elements by grouping the individual digits by their positions
    in the numbers. Next, we sort the elements by sorting the digits at each significant
    position. Commonly, this is done via Counting Sort (the Counting Sort algorithm
    is detailed in the book *Java Coding Problems* ([www.packtpub.com/programming/java-coding-problems](http://www.packtpub.com/programming/java-coding-problems)),
    published by Packt, but you can find an implementation of it in the application
    called *SortArraysIn14Ways*). Mainly, sorting the digits can be done via any stable
    sorting algorithm.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 基数排序是一种非常适用于整数的排序算法。在基数排序中，我们通过将数字的各个数字按其在数字中的位置进行分组来对元素进行排序。接下来，我们通过对每个重要位置上的数字进行排序来对元素进行排序。通常，这是通过计数排序来完成的（计数排序算法在Packt出版的书籍*Java
    Coding Problems*中有详细介绍，但您也可以在名为*SortArraysIn14Ways*的应用程序中找到其实现）。主要的，可以通过任何稳定的排序算法来对数字进行排序。
- en: 'A simple approach to understanding the Radix Sort algorithm relies on an example.
    Let’s consider the array 323, 2, 3, 123, 45, 6, 788\. The following image reveals
    the steps of sorting this array by sequentially sorting the units, the tens, and
    the hundreds:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 理解基数排序算法的简单方法是通过一个例子。让我们考虑数组323, 2, 3, 123, 45, 6, 788。下图展示了按顺序对这个数组进行排序的步骤，依次对个位数、十位数和百位数进行排序：
- en: '![Figure 14.7 – Radix sort](img/Figure_14.7_B15403.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图14.7 – 基数排序](img/Figure_14.7_B15403.jpg)'
- en: Figure 14.7 – Radix Sort
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 – 基数排序
- en: So, first, we sort the elements based on the digit corresponding to the unit
    place. Second, we sort the elements based on the digit corresponding to the tenth
    place. Third, we sort the elements based on the digit corresponding to the hundreds
    place. Of course, depending on the maximum number from the array, the process
    continues with thousands, ten thousands, and so on until no more digits are left.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，首先，我们根据个位数对元素进行排序。其次，我们根据十位数对元素进行排序。第三，我们根据百位数对元素进行排序。当然，根据数组中的最大数，这个过程会继续到千位、万位，直到没有更多的数字为止。
- en: 'The following code is an implementation of the Radix Sort algorithm:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是基数排序算法的实现：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The time complexity of Radix Sort depends on the algorithm that’s used to sort
    the digits (remember that this can be any stable sorting algorithm). Since we
    are using the Counting Sort algorithm, the time complexity is O(d(n+b)), where
    *n* is the number of elements, *d* is the number of digits, and *b* is the radix
    or base (in our case, the base is 10). The space complexity is O(n+b).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 基数排序的时间复杂度取决于用于对数字进行排序的算法（请记住，这可以是任何稳定的排序算法）。由于我们使用计数排序算法，时间复杂度为O(d(n+b))，其中*n*是元素的数量，*d*是数字的数量，*b*是基数（在我们的情况下，基数是10）。空间复杂度为O(n+b)。
- en: The complete application is called *RadixSort*. Well, so far, we’ve managed
    to cover the top five sorting algorithms that occur in technical interviews. Now,
    let’s quickly provide an overview of the searching algorithms.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*RadixSort*。到目前为止，我们已经涵盖了技术面试中出现的前五种排序算法。现在，让我们快速概述搜索算法。
- en: Searching algorithms
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索算法
- en: The main searching algorithm that occurs in interviews as a standalone problem
    or part of another problem is the Binary Search algorithm. The best case time
    complexity is O(1), while the average and worst case is O(log n). The worst case
    auxiliary space complexity of Binary Search is O(1) for the iterative implementation
    and O(log n) for the recursive implementation due to the call stack.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在面试中经常出现的主要搜索算法是二分搜索算法，它可能作为一个独立的问题或其他问题的一部分。最佳情况时间复杂度为O(1)，而平均和最坏情况为O(log n)。二分搜索的最坏情况辅助空间复杂度为O(1)（迭代实现）和O(log
    n)（递归实现）。
- en: The Binary Search algorithm relies on the *divide and conquer* strategy. Mainly,
    this algorithm debuts by dividing the given array into two sub-arrays. Furthermore,
    it discards one of these sub-arrays and operates on the other one iteratively
    or recursively. In other words, at each step, this algorithm halves the search
    space (which is initially the whole given array).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 二分搜索算法依赖于“分而治之”的策略。主要是通过将给定的数组分成两个子数组来开始。此外，它会丢弃其中一个子数组，并迭代或递归地对另一个子数组进行操作。换句话说，在每一步中，该算法将搜索空间减半（最初是整个给定数组）。
- en: 'So, these algorithms describe the steps for looking for element *x* in an array,
    *a*. Consider a sorted array, *a*, that contains 16 elements, as shown in the
    following image:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这些算法描述了在数组*a*中查找元素*x*的步骤。考虑一个包含16个元素的排序数组*a*，如下图所示：
- en: '![Figure 14.8 – Ordered array containing 16 elements'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.8 – 包含16个元素的有序数组'
- en: '](img/Figure_14.8_B15403.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.8_B15403.jpg)'
- en: Figure 14.8 – Ordered array containing 16 elements
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – 包含16个元素的有序数组
- en: 'First, we compare *x* with the midpoint of the array, *p*. If they are equal,
    we return. If *x > p*, then we search the right-hand side of the array and discard
    the left-hand side (the search space is the right-hand side of the array). If
    *x < p*, then we search on the left-hand side of the array and discard the right-hand
    side (the search space is the left-hand side of the array). The following is a
    graphical representation of the Binary Search algorithm for finding the number
    17:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将*x*与数组的中点*p*进行比较。如果它们相等，我们返回。如果*x > p*，那么我们在数组的右侧搜索并丢弃左侧（搜索空间是数组的右侧）。如果*x
    < p*，那么我们在数组的左侧搜索并丢弃右侧（搜索空间是数组的左侧）。以下是用于查找数字17的二分搜索算法的图形表示：
- en: '![Figure 14.9 – The binary search algorithm'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.9 – 二分搜索算法'
- en: '](img/Figure_14.9_B15403.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.9_B15403.jpg)'
- en: Figure 14.9 – The Binary Search algorithm
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 – 二分搜索算法
- en: 'Notice that we start with 16 elements and end with 1\. After the first step,
    we are down to 16/2 = 8 elements. At the second step, we are down to 8/2 = 4 elements.
    At the third step, we are down to 4/2 = 2 elements. And, at the final step, we
    find the searched number, 17\. If we put this algorithm into pseudocode, then
    we will obtain something similar to the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们从16个元素开始，最后只剩下1个。第一步之后，我们剩下16/2 = 8个元素。第二步之后，我们剩下8/2 = 4个元素。第三步之后，我们剩下4/2
    = 2个元素。最后一步，我们找到了搜索的数字17。如果我们将这个算法转换成伪代码，那么我们将得到类似以下的内容：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The iterative implementation is listed here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代实现如下所示：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The complete application is called *BinarySearch*. It also contains the recursive
    implementation of the Binary Search algorithm. In [*Chapter 10*](B15403_10_Final_JM_ePub.xhtml#_idTextAnchor217)*,
    Arrays and Strings*, you can find different coding challenges that take advantage
    of the Binary Search algorithm.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*BinarySearch*。它还包含了二分查找算法的递归实现。在[*第10章*](B15403_10_Final_JM_ePub.xhtml#_idTextAnchor217)*，数组和字符串*中，你可以找到利用二分查找算法的不同编码挑战。
- en: Coding challenges
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码挑战
- en: So far, we’ve covered the most popular sorting and searching algorithms that
    are encountered in technical interviews. It is advised that you practice these
    algorithms since they may occur as standalone problems that require the pseudocode
    or the implementation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了在技术面试中遇到的最流行的排序和搜索算法。建议你练习这些算法，因为它们可能作为独立的问题出现，需要伪代码或实现。
- en: That being said, let’s tackle 18 problems that are related to sorting and searching
    algorithms.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们来解决与排序和搜索算法相关的18个问题。
- en: Coding challenge 1 – Merging two sorted arrays
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战1 – 合并两个排序好的数组
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you’ve been given two sorted arrays, *p* and *q*. The
    *p* array is large enough to fit *q* at the end of it. Write a snippet of code
    that merges *p* and *q* in a sorted order.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了两个排序好的数组*p*和*q*。*p*数组足够大，可以容纳*q*放在其末尾。编写一段代码片段，将*p*和*q*按排序顺序合并。'
- en: '**Solution**: It is important to highlight the fact that *p* has enough space
    at the end to fit *q*. This suggests that the solution shouldn’t involve any auxiliary
    space. The solution should output the result of merging *p* and *q* in a sorted
    order by inserting the elements from *q* in *p* in order.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：重要的是要强调*p*在末尾有足够的空间容纳*q*。这表明解决方案不应涉及任何辅助空间。解决方案应该通过按顺序将*q*中的元素插入到*p*中，输出合并*p*和*q*的结果。'
- en: 'Mainly, we should compare the elements from *p* and *q* and insert them into
    *p* in order until we’ve processed all the elements in *p* and *q*. Let’s take
    a look at a meaningful diagram that reveals this action (*p* contains elements
    -1, 3, 8, 0, 0, while *q* contains elements 2, 4):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 主要是，我们应该比较*p*和*q*中的元素，并按顺序将它们插入到*p*中，直到我们处理完*p*和*q*中的所有元素。让我们看一个有意义的图表，揭示了这个动作（*p*包含元素-1,
    3, 8, 0, 0，而*q*包含元素2, 4）：
- en: '![Figure 14.10 – Merging two sorted arrays'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.10 – 合并两个排序好的数组'
- en: '](img/Figure_14.10_B15403.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.10_B15403.jpg)'
- en: Figure 14.10 – Merging two sorted arrays
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10 – 合并两个排序好的数组
- en: Let’s see this test case step by step (let’s denote the index of the last element
    from *p* with *pIdx* and the index of the last element from *q* with *qIdx*).
    In the previous diagram, *pIdx*=2 (corresponding to element 8) and *qIdx*=1 (corresponding
    to element 4).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步看这个测试案例（让我们用*p*的最后一个元素的索引表示为*pIdx*，用*q*的最后一个元素的索引表示为*qIdx*）。在前面的图中，*pIdx*=2（对应元素8），*qIdx*=1（对应元素4）。
- en: '**Step 1**: We compare the last element from *p* (the element at index *pIdx*)
    with the last element from *q* (the element at index *qIdx*), so we compare 8
    with 4\. Since 8 > 4, we copy 8 to the end of *p*. Since both arrays are sorted,
    8 is the maximum of these arrays, so it must go to the last position (index) in
    *p*. It will occupy an empty slot in *p* (remember that *p* is large enough to
    fit *q* at its end). We decrease *pIdx* by 1.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤1**：我们比较*p*的最后一个元素（索引*pIdx*处的元素）和*q*的最后一个元素（索引*qIdx*处的元素），所以我们比较8和4。由于8
    > 4，我们将8复制到*p*的末尾。由于两个数组都是排序好的，8是这些数组中的最大值，所以它必须放在*p*的最后位置（索引）。它将占据*p*中的一个空槽（记住*p*足够大，可以容纳*q*在其末尾）。我们将*pIdx*减1。'
- en: '**Step 2**: We compare the last element from *p* (the element at index *pIdx*)
    with the last element from *q* (the element at index *qIdx*), so we compare 3
    with 4\. Since 3 < 4, we copy 4 to the end of *p*. We decrease *qIdx* by 1.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤2**：我们比较*p*的最后一个元素（索引*pIdx*处的元素）和*q*的最后一个元素（索引*qIdx*处的元素），所以我们比较3和4。由于3
    < 4，我们将4复制到*p*的末尾。我们将*qIdx*减1。'
- en: '**Step 3**: We compare the last element from *p* (the element at index *pIdx*)
    with the last element from *q* (the element at index *qIdx*), so we compare 3
    with 2\. Since 3 > 2, we copy 3 to the end of *p*. We decrease *pIdx* by 1.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤3**：我们比较*p*的最后一个元素（索引*pIdx*处的元素）和*q*的最后一个元素（索引*qIdx*处的元素），所以我们比较3和2。由于3
    > 2，我们将3复制到*p*的末尾。我们将*pIdx*减1。'
- en: '**Step 4**: We compare the last element from *p* (the element at index *pIdx*)
    with the last element from *q* (the element at index *qIdx*), so we compare -1
    with 2\. Since -1 < 2, we copy 2 to the end of *p*. We decrease *qIdx* by 1\.
    There are no more elements to compare and *p* is sorted.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤4**：我们比较*p*的最后一个元素（索引*pIdx*处的元素）和*q*的最后一个元素（索引*qIdx*处的元素），所以我们比较-1和2。由于-1
    < 2，我们将2复制到*p*的末尾。我们将*qIdx*减1。没有更多的元素可以比较，*p*已经排序。'
- en: Check this out! After each comparison, we insert the elements at the end of
    *p*. This way, we don’t need to shift any elements. However, if we choose to insert
    the elements at the beginning of *p*, then we must shift the elements backward
    to make room for each inserted element. This is not efficient!
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个！在每次比较之后，我们将元素插入到*p*的末尾。这样，我们就不需要移动任何元素。然而，如果我们选择将元素插入到*p*的开头，那么我们必须将元素向后移动，为每个插入的元素腾出空间。这是不高效的！
- en: 'Now, it’s time to see the implementation of this algorithm:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看这个算法的实现了：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete application is called *MergeTwoSortedArrays*. If you’d like to
    check/remember how to merge *k* sorted arrays, then revisit [*Chapter 10*](B15403_10_Final_JM_ePub.xhtml#_idTextAnchor217)*,
    Arrays and Strings*, the *Merging k sorted arrays in O(nk log k)* coding challenge.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*MergeTwoSortedArrays*。如果你想检查/记住如何合并*k*个排序数组，那么请回顾[*第10章*](B15403_10_Final_JM_ePub.xhtml#_idTextAnchor217)*，数组和字符串*，*在O(nk
    log k)时间内合并k个排序数组*编码挑战。
- en: Coding challenge 2 – Grouping anagrams together
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战2 - 将变位词分组在一起
- en: '**Adobe**, **Flipkart**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**Flipkart**'
- en: '**Problem**: Consider you’ve been given an array of words (containing characters
    from ''a'' to ''z'') representing several mixed anagrams (for example, "calipers",
    "caret", "slat", "cater", "thickset", "spiracle", "trace", "last", "salt", "bowel",
    "crate", "loop", "polo", "thickest", "below", "thickets", "pool", "elbow", "replicas").
    Write a snippet of code that prints this array so that all the anagrams are grouped
    together (for example, "calipers", "spiracle", "replicas", "caret", "cater", "trace",
    "crate", "slat", "last", "salt", "bowel", "below", "elbow", "thickset", "thickest",
    "thickets", "loop", "polo", "pool" ).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到你已经得到了一个包含来自''a''到''z''的字符的单词数组，代表了几个混合的变位词（例如，“calipers”，“caret”，“slat”，“cater”，“thickset”，“spiracle”，“trace”，“last”，“salt”，“bowel”，“crate”，“loop”，“polo”，“thickest”，“below”，“thickets”，“pool”，“elbow”，“replicas”）。编写一小段代码，以便打印这个数组，以便所有的变位词都被分组在一起（例如，“calipers”，“spiracle”，“replicas”，“caret”，“cater”，“trace”，“crate”，“slat”，“last”，“salt”，“bowel”，“below”，“elbow”，“thickset”，“thickest”，“thickets”，“loop”，“polo”，“pool”）。'
- en: '**Solution**: First, here’s a quick reminder regarding anagrams. Two or more
    strings (words) are considered to be anagrams if they contain the same characters
    but in different orders.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：首先，这里有一个关于变位词的快速提醒。如果两个或更多字符串（单词）包含相同的字符但顺序不同，则被认为是变位词。'
- en: 'Based on the example provided for this problem, let’s define the following
    array of mixed anagrams:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个问题提供的示例，让我们定义以下混合变位词数组：
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Since anagrams contain exactly the same characters, this means that if we sort
    them, then they will be identical (for example, sorting "slat", "salt" and "last"
    result in "alst"). So, we can say that two strings (words) are anagrams by comparing
    their sorted versions. In other words, all we need is a sorting algorithm. The
    most convenient way to do this is to rely on Java's built-in sorting algorithm,
    which is Dual-Pivot Quicksort for primitives and TimSort for objects.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变位词包含完全相同的字符，这意味着如果我们对它们进行排序，它们将是相同的（例如，对“slat”，“salt”和“last”进行排序得到“alst”）。因此，我们可以说两个字符串（单词）通过比较它们的排序版本来判断它们是否是变位词。换句话说，我们只需要一个排序算法。这样做的最方便的方法是依赖于Java的内置排序算法，对于基本类型是双轴快速排序，对于对象是TimSort。
- en: 'The built-in solution is called `sort()` and comes in many different flavors
    in the `java.util.Arrays` class (15+ flavors). Two of these flavors have the following
    signatures:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 内置解决方案称为`sort()`，在`java.util.Arrays`类中有很多不同的版本（15+种）。其中两种版本具有以下签名：
- en: '`void sort(Object[] a)`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void sort(Object[] a)`'
- en: '`<T> void sort(T[] a, Comparator<? super T> c)`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<T> void sort(T[] a, Comparator<? super T> c)`'
- en: 'If we convert a string (word) into `char[]`, then we can sort its characters
    and return the new string via the following helper method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个字符串（单词）转换为`char[]`，然后对其字符进行排序并通过以下辅助方法返回新的字符串：
- en: '[PRE14]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we just need a `Comparator` that indicates that two strings that are
    anagrams of each other are equivalent:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需要一个`Comparator`，指示彼此是变位词的两个字符串是等价的：
- en: '[PRE15]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we sort the given array of strings (words) via this `compareTo()`
    method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过这个`compareTo()`方法对给定的字符串（单词）数组进行排序：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: However, the problem doesn’t actually ask us to sort the given array of anagrams;
    the problem asks us to print the anagrams grouped together. For this, we can rely
    on *hashing* (if you are not familiar with the concept of hashing, then please
    read [*Chapter 6*](B15403_06_Final_JM_ePub.xhtml#_idTextAnchor080)*, Object-Oriented
    Programming*, the *Hash table* problem). In Java, we can use hashing via the built-in
    `HashMap` implementation, so there is no need to write a hashing implementation
    from scratch. But how is this `HashMap` useful? What should we store in an entry
    (key-value pair) of this map?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题实际上并没有要求我们对给定的变位词数组进行排序；问题要求我们打印分组在一起的变位词。为此，我们可以依赖*哈希*（如果你不熟悉哈希的概念，请阅读[*第6章*](B15403_06_Final_JM_ePub.xhtml#_idTextAnchor080)*，面向对象编程*，*哈希表*问题）。在Java中，我们可以通过内置的`HashMap`实现使用哈希，因此无需从头开始编写哈希实现。但是`HashMap`有什么用呢？这个映射的条目（键值对）应该存储什么？
- en: 'Each group of anagrams converges to the same sorted version (for example, the
    group of anagrams containing the strings (words) "slat", "salt" and "last" have
    the unique and common sorted version as "alst"). Being unique, the sorted version
    is a good candidate to be the key in our map. Next, the value represents the list
    of anagrams. So, the algorithm is quite simple; it contains the following steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每组变位词都会收敛到相同的排序版本（例如，包含字符串（单词）“slat”，“salt”和“last”的变位词组具有唯一和共同的排序版本“alst”）。由于唯一，排序版本是成为我们映射中键的一个很好的候选者。接下来，值表示变位词的列表。因此，算法非常简单；它包含以下步骤：
- en: Loop over the given array of words.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环遍历给定的单词数组。
- en: Sort the characters of each word.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个单词的字符进行排序。
- en: Populate the map (add or update the map).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充映射（添加或更新映射）。
- en: Print the result.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印结果。
- en: 'In code lines:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码行中：
- en: '[PRE17]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If *n* is the number of strings (words) and each string (word) has a maximum
    of *m* characters, then the time complexity of the preceding two approaches is
    O(nm log m).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*n*是字符串（单词）的数量，每个字符串（单词）最多有*m*个字符，则前面两种方法的时间复杂度是O(nm log m)。
- en: 'Can we do this better? Well, to do this better, we have to identify the issue
    of the preceding two approaches. The issue consists of the fact that we sort every
    string (word) and that this will cost us extra time. However, we can use an additional
    `char[]` to count up the number of occurrences (frequency) of each character in
    a string (word). After we build this `char[]`, we convert it into a `String` to
    obtain the key that we have to search for in `HashMap`. Since Java handles `char`
    types the same as it does (unsigned) `short`, we can make calculations with `char`.
    Let’s see the code (the `wordToChar` array tracks the frequency of characters
    from *a* to *z* for each string (word) in the given array):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能做得更好吗？嗯，要做得更好，我们必须确定前两种方法的问题。问题在于我们对每个字符串（单词）进行排序，这将花费额外的时间。然而，我们可以使用额外的`char[]`来计算字符串（单词）中每个字符的出现次数（频率）。构建了这个`char[]`之后，我们将其转换为`String`，以获得我们在`HashMap`中搜索的键。由于Java处理`char`类型与（无符号）`short`相同，我们可以使用`char`进行计算。让我们看看代码（`wordToChar`数组跟踪给定数组中每个字符串（单词）的字符频率，从*a*到*z*）：
- en: '[PRE18]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If *n* is the number of strings (words) and each string (word) contains a maximum
    of *m* characters, then the time complexity of the preceding two approaches is
    O(nm). If you need to support more characters, not just from *a* to *z*, then
    use an `int[]` array and `codePointAt()` – more details are available in [*Chapter
    10*](B15403_10_Final_JM_ePub.xhtml#_idTextAnchor217)*, Arrays and Strings*, in
    the *Extracting code points of surrogate pairs* coding challenge. The complete
    application is called *GroupSortAnagrams*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*n*是字符串（单词）的数量，每个字符串（单词）包含最多*m*个字符，则前两种方法的时间复杂度为O(nm)。如果你需要支持更多的字符，而不仅仅是从*a*到*z*，那么使用`int[]`数组和`codePointAt()`
    - 更多细节请参考[*第10章*](B15403_10_Final_JM_ePub.xhtml#_idTextAnchor217)*，数组和字符串*，在*提取代理对的代码点*编码挑战中。完整的应用程序称为*GroupSortAnagrams*。
- en: Coding challenge 3 – List of unknown size
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战3 - 未知大小的列表
- en: '`size()`or similar method) containing only positive numbers. The code for this
    list is as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`size()`或类似的方法）仅包含正数。该列表的代码如下：'
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: However, as you can see, there is a method called `peekAt()` that returns the
    element at the given index in O(1). If the given index is beyond the bounds of
    this list, then `peekAt()` returns -1\. Write a snippet of code that returns the
    index at which an element, *p*, occurs.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你所看到的，有一种方法叫做`peekAt()`，它以O(1)返回给定索引处的元素。如果给定的索引超出了列表的范围，那么`peekAt()`返回-1。编写一小段代码，返回元素*p*出现的索引。
- en: '`list.size()/2`) to find the middle point. The given data structure (list)
    doesn’t reveal its size.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`list.size()/2`)来找到中间点。给定的数据结构（列表）不会显示其大小。'
- en: So, the problem is reduced to finding the size of this list. We know that `peekAt()`
    returns -1 if the given index is beyond the bounds of this list, so we can loop
    the list and count the iterations until `peekAt()` returns -1\. When `peekAt()`
    returns -1, we should know the size of the list, so we can apply the Binary Search
    algorithm. Instead of looping the list element by element (linear algorithm),
    we can try to do so exponentially. So, instead of looping `peekAt(1)`, `peekAt(2)`,
    `peekAt(3)`, `peekAt(4)` ..., we loop `peekAt(1)`, `peekAt(2)`, `peekAt(4)`, `peekAt(8)`,
    .... In other words, instead of doing this in O(n) time, we can do so in O(log
    n) time, where *n* is the size of the list. We can do this because the given list
    is sorted!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，问题被简化为找到这个列表的大小。我们知道如果给定的索引超出了列表的范围，`peekAt()`会返回-1，所以我们可以循环列表并计算迭代次数，直到`peekAt()`返回-1。当`peekAt()`返回-1时，我们应该知道列表的大小，所以我们可以应用二分搜索算法。我们可以尝试以指数方式而不是逐个元素地循环列表（线性算法）。因此，我们可以在O(log
    n)的时间内完成，其中*n*是列表的大小。我们之所以能够这样做，是因为给定的列表是排序的！
- en: 'The following code should clarify this approach and the remaining details:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码应该阐明这种方法和其余细节：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The complete application is called *UnknownSizeList*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*UnknownSizeList*。
- en: Coding challenge 4 – Merge sorting a linked list
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战4 - 对链表进行归并排序
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊，谷歌，Adobe，微软，Flipkart
- en: '**Problem**: Consider you’ve been given a singly linked list. Write a snippet
    of code that sorts this linked list via the Merge Sort algorithm.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了一个单链表。编写一小段代码，使用归并排序算法对这个链表进行排序。'
- en: '**Solution**: Solving this problem requires knowledge of several topics that
    we’ve already covered in this book. First, you must be familiar with linked lists.
    This topic was covered in [*Chapter 11*](B15403_11_Final_JM_ePub.xhtml#_idTextAnchor252)*,
    Linked Lists and Maps*. Second, you will need have read the *Merge Sort* section
    of this chapter.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：解决这个问题需要对我们在本书中已经涵盖的几个主题有所了解。首先，你必须熟悉链表。这个主题在[*第11章*](B15403_11_Final_JM_ePub.xhtml#_idTextAnchor252)*，链表和映射*中有所涵盖。其次，你需要阅读本章的*归并排序*部分。'
- en: 'Conforming to the Merge Sort algorithm, we have to continually split the linked
    list in half until we obtain empty sub-lists or sub-lists that contain a single
    element (this is the *divide and conquer* approach). If a sub-list is empty or
    contains one element, it is sorted by definition – this is known as *base case*
    recursion. The following diagram reveals this process for the initial linked list
    2 → 1 → 4 → 9 → 8 → 3 → 7 → null:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 根据归并排序算法，我们必须不断将链表一分为二，直到获得空子列表或包含单个元素的子列表（这是*分而治之*的方法）。如果子列表为空或包含一个元素，它就是按定义排序的
    - 这被称为*基本情况*递归。以下图表展示了对初始链表2 → 1 → 4 → 9 → 8 → 3 → 7 → null进行此过程：
- en: '![Figure 14.11 – Using divide and conquer on a linked list'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.11 - 在链表上使用分而治之'
- en: '](img/Figure_14.11_B15403.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.11_B15403.jpg)'
- en: Figure 14.11 – Using divide and conquer on a linked list
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 - 在链表上使用分而治之
- en: 'Dividing the given linked list like this can be done via the Fast Runner/Slow
    Runner approach. This approach was detailed in [*Chapter 11*](B15403_11_Final_JM_ePub.xhtml#_idTextAnchor252)*,
    Linked Lists and Maps*, in the *The Fast Runner/Slow Runner approach* section.
    Mainly, when the **Fast Runner** (**FR**) reaches the end of the given linked
    list, the **Slow Runner** (**SR**) points to the middle of this list, so we can
    split the list in two. The code for this is listed here:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快速运行者/慢速运行者方法可以将给定的链表分成这样。这种方法在[*第11章*](B15403_11_Final_JM_ePub.xhtml#_idTextAnchor252)*，链表和映射*中的*快速运行者/慢速运行者方法*部分有详细介绍。主要是，当**快速运行者**（**FR**）到达给定链表的末尾时，**慢速运行者**（**SR**）指向此列表的中间位置，因此我们可以将列表分成两部分。此代码如下所示：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The rest of the code is a classical Merge Sort implementation. The `sort()`
    method is responsible for recursively sorting the sub-lists. Next, the `merge()`
    method places the elements back into the original linked list one at a time by
    repeatedly taking the smallest element from the sorted sub-lists:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分是经典的归并排序实现。`sort()`方法负责递归地对子列表进行排序。接下来，`merge()`方法通过反复从排序后的子列表中取出最小的元素，将元素逐个放回原始链表中：
- en: '[PRE22]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The complete application is called *MergeSortSinglyLinkedList*. Sorting a doubly
    linked list is quite similar. You can find such an implementation in the application
    called *MergeSortDoublyLinkedList*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*MergeSortSinglyLinkedList*。对双向链表进行排序非常类似。您可以在名为*MergeSortDoublyLinkedList*的应用程序中找到这样的实现。
- en: Coding challenge 5 – Strings interspersed with empty strings
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战5-字符串与空字符串交错
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊，谷歌，Adobe，微软，Flipkart
- en: '**Problem**: Consider you’ve been given a sorted array of strings that is interspersed
    with empty strings. Write a snippet of code that returns the index of the given
    non-empty string.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设您已经获得了一个包含空字符串的排序字符串数组。编写一小段代码，返回给定非空字符串的索引。'
- en: '**Solution**: When we must search in a sorted data structure (for example,
    in a sorted array), we know that the Binary Search algorithm is the proper choice.
    So, can we use Binary Search in this case? We have the size of the given array,
    so we can halve the searching space and locate the middle point. If we denote
    the index 0 of the array as *left* and the *array.length-*1 as *right*, then we
    can write *mid =* (*left* + *right*)/2\. So, *mid* is the middle point of the
    given array.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：当我们必须在排序的数据结构中进行搜索（例如，在排序的数组中），我们知道二分搜索算法是正确的选择。那么，在这种情况下我们可以使用二分搜索吗？我们有给定数组的大小，因此可以将搜索空间减半并找到中点。如果我们将数组的索引0表示为*left*，将*array.length-*1表示为*right*，那么我们可以写*mid
    =*（*left* + *right*）/2。因此，*mid*是给定数组的中点。'
- en: 'But what we can do if the *mid* index falls on an empty string? In such a case,
    we don’t know if we should go to the *right* or the *left*. In other words, which
    half should be discarded, and what half should be used for continuing our search?
    The answer can be found in the following diagram (the given string is "cat", "",
    "", "", "", "", "", "rear", ""):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果*中间*索引落在一个空字符串上怎么办？在这种情况下，我们不知道是应该去*右边*还是*左边*。换句话说，应该丢弃哪一半，哪一半应该用于继续搜索？答案可以在下图中找到（给定的字符串是"cat"，""，""，""，""，""，""，"rear"，""）：
- en: '![Figure 14.12 – Computing the middle point in the case of an empty string'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.12-在空字符串情况下计算中点'
- en: '](img/Figure_14.12_B15403.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.12_B15403.jpg)'
- en: Figure 14.12 – Computing the middle point in the case of an empty string
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12-在空字符串情况下计算中点
- en: So, when the middle point (*mid*) falls on an empty string, we must correct
    its index by moving it to the nearest non-empty string. As shown in *step 2* of
    the preceding diagram, we choose *leftMid* as *mid*-1 and *rightMid* as *mid*+1\.
    We keep moving away from *mid* until the *leftMid* or *rightMid* index points
    out a non-empty string (in the preceding diagram, *rightMid* finds the string,
    "rear", after *steps 3* and *4*). When this happens, we update the *mid* position
    and continue the classical Binary Search (*step 4*).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当中点（*mid*）落在一个空字符串上时，我们必须通过将其移动到最近的非空字符串来更正其索引。如前图的*步骤2*所示，我们选择*leftMid*为*mid*-1，*rightMid*为*mid*+1。我们不断远离*mid*，直到*leftMid*或*rightMid*索引指向一个非空字符串（在前图中，*rightMid*在*步骤3*和*4*之后找到字符串"rear"）。当发生这种情况时，我们更新*mid*位置并继续经典的二分搜索（*步骤4*）。
- en: 'In terms of code, this is quite straightforward:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，这非常简单：
- en: '[PRE23]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The worst-case time complexity for this approach is O(n). Notice that if the
    searched string is an empty string, then we return -1, so we treat this case as
    an error. This is correct since the problem says that the given string that needs
    to be found is non-empty. If the problem doesn’t provide any details about this
    aspect, then you have to discuss this with the interviewer. This way, you are
    showing the interviewer that you pay attention to details and corner cases. The
    complete application is called *InterspersedEmptyStrings*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的最坏时间复杂度为O(n)。请注意，如果搜索的字符串是空字符串，则返回-1，因此我们将此情况视为错误。这是正确的，因为问题说需要找到的给定字符串是非空的。如果问题没有提供关于这一方面的任何细节，那么您必须与面试官讨论这一点。这样，您向面试官表明您注意细节和边缘情况。完整的应用程序称为*InterspersedEmptyStrings*。
- en: Coding challenge 6 – Sorting a queue with the help of another queue
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战6-使用另一个队列对队列进行排序
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊，谷歌，Adobe，微软，Flipkart
- en: '**Problem**: Consider you’ve been given a queue of integers. Write a snippet
    of code that sorts this queue with the help of another queue (an extra queue).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设您已经获得了一个整数队列。编写一小段代码，使用另一个队列（额外队列）对该队列进行排序。'
- en: '**Solution**: The solution to this problem must include an extra queue, so
    we must think about how to use this extra queue when sorting the given queue.
    There are different approaches, but a convenient approach for an interview can
    be summarized as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：解决此问题的解决方案必须包括一个额外的队列，因此我们必须考虑如何在对给定队列进行排序时使用这个额外的队列。有不同的方法，但是在面试中的一个方便的方法可以总结如下：'
- en: As long as the elements from the given queue are in ascending order (starting
    from the front of the queue), we dequeue them and enqueue in the extra queue.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要给定队列中的元素按升序排列（从队列的前端开始），我们就将它们出列并排队到额外队列中。
- en: If an element breaks the preceding statement, then we dequeue and enqueue it
    back in the given queue, without touching the extra queue.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个元素违反了前面的陈述，那么我们将其出列并重新排队到给定队列中，而不触及额外队列。
- en: After all the elements have been processed via *step 1* or *2*, we dequeue all
    the elements from the extra queue and enqueue them back in the given queue.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有元素通过*步骤1*或*2*进行处理之后，我们将所有元素从额外队列中出列并重新排队到给定队列中。
- en: As long as the size of the extra queue is not equal to the initial size of the
    given queue, we repeat from *step 1* since the queue is not sorted yet.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只要额外队列的大小不等于给定队列的初始大小，我们就从*步骤1*开始重复，因为队列还没有排序。
- en: 'Let’s consider that the given queue contains the following elements: rear →
    3 → 9 → 1 → 8 → 5 → 2 → front. The following diagram represents the given queue
    and the extra queue (initially empty):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设给定队列包含以下元素：rear → 3 → 9 → 1 → 8 → 5 → 2 → front。下图表示给定队列和额外队列（最初为空）：
- en: '![Figure 14.13 – The given queue and the extra queue'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.13 - 给定队列和额外队列'
- en: '](img/Figure_14.13_B15403.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.13_B15403.jpg)'
- en: Figure 14.13 – The given queue and the extra queue
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13 - 给定队列和额外队列
- en: 'Applying *step 1* of our algorithm means dequeuing 2, 5, and 8 from the given
    queue and enqueuing them in the extra queue, as shown in the following diagram:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 应用我们算法的*步骤1*意味着从给定队列中出列2、5和8，并将它们排队到额外队列中，如下图所示：
- en: '![Figure 14.14 – Enqueuing 2, 5, and 8 in the extra queue'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.14 - 在额外队列中排队2、5和8'
- en: '](img/Figure_14.14_B15403.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.14_B15403.jpg)'
- en: Figure 14.14 – Enqueuing 2, 5, and 8 in the extra queue
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14 - 在额外队列中排队2、5和8
- en: 'Since the next element in the given queue is smaller than the last element
    that’s added to the extra queue, we apply *step 2* of our algorithm, so we dequeue
    1 and enqueue it in the given queue, as shown in the following diagram:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 由于给定队列中的下一个元素比添加到额外队列的最后一个元素小，我们应用我们算法的*步骤2*，所以我们出列1并将其排队到给定队列中，如下图所示：
- en: '![Figure 14.15 – Dequeuing and enqueuing 1 in the given queue'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.15 - 从给定队列中出列并排队1'
- en: '](img/Figure_14.15_B15403.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.15_B15403.jpg)'
- en: Figure 14.15 – Dequeuing and enqueuing 1 in the given queue
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.15 - 从给定队列中出列并排队1
- en: 'Furthermore, we apply *step 1* again since 9 (the front of the given queue)
    is bigger than the last element that’s added to the extra queue (8). So, 9 goes
    in the extra queue, as shown in the following diagram:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们再次应用*步骤1*，因为9（给定队列的前端）比添加到额外队列的最后一个元素（8）大。所以，9进入额外队列，如下图所示：
- en: '![Figure 14.16 – Enqueuing 9 in the extra queue'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.16 - 在额外队列中排队9'
- en: '](img/Figure_14.16_B15403.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.16_B15403.jpg)'
- en: Figure 14.16 – Enqueuing 9 in the extra queue
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.16 - 在额外队列中排队9
- en: 'Next, 3 is smaller than 9, so we must dequeue and enqueue it back in the given
    queue, as shown in the following diagram:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，3小于9，所以我们必须将其出列并重新排队到给定队列中，如下图所示：
- en: '![Figure 14.17 – Dequeuing and enqueuing 3 in the given queue'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.17 - 从给定队列中出列并排队3'
- en: '](img/Figure_14.17_B15403.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.17_B15403.jpg)'
- en: Figure 14.17 – Dequeuing and enqueuing 3 in the given queue
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.17 - 从给定队列中出列并排队3
- en: 'At this point, we’ve processed (visited) all the elements from the given queue,
    so we apply *step 3* of our algorithm. We dequeue all the elements from the extra
    queue and enqueue them in the given queue, as shown in the following diagram:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经处理（访问）了给定队列中的所有元素，所以我们应用我们算法的*步骤3*。我们将所有元素从额外队列中出列并排队到给定队列中，如下图所示：
- en: '![Figure 14.18 – Dequeuing from the extra queue and enqueuing in the given
    queue'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.18 - 从额外队列中出列并加入给定队列'
- en: '](img/Figure_14.18_B15403.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.18_B15403.jpg)'
- en: Figure 14.18 – Dequeuing from the extra queue and enqueuing in the given queue
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.18 - 从额外队列中出列并加入给定队列
- en: 'Now, we repeat the whole process until the given queue is sorted in ascending
    order. Let’s see the code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们重复整个过程，直到给定队列按升序排序。让我们看看代码：
- en: '[PRE24]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code’s runtime is O(n2). The complete application is called *SortQueueViaTempQueue*.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n2)。完整的应用程序称为*SortQueueViaTempQueue*。
- en: Coding challenge 7 – Sorting a queue without extra space
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战7 - 在不使用额外空间的情况下对队列进行排序
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you’ve been given a queue of integers. Write a snippet
    of code that sorts this queue without using extra space.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你有一个整数队列。编写一小段代码，对这个队列进行排序，而不使用额外的空间。'
- en: '**Solution**: In the preceding problem, we had to solve the same problem but
    using an extra queue. This time, we cannot use an extra queue, so we must sort
    the queue in place.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：在前面的问题中，我们必须解决相同的问题，但是使用额外的队列。这一次，我们不能使用额外的队列，所以我们必须在原地对队列进行排序。'
- en: 'We can think of sorting as a continuous process of finding the minimum element
    from the given queue, extracting it from its current position, and adding it to
    the rear of this queue. Expanding this idea may result in the following algorithm:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将排序看作是一个持续的过程，从给定队列中找到最小元素，将其从当前位置提取出来，并将其添加到队列的末尾。扩展这个想法可能会得到以下算法：
- en: Consider the current minimum as `Integer.MAX_VALUE`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前最小值视为`Integer.MAX_VALUE`。
- en: Dequeue an element from the unsorted part of the queue (initially, the unsorted
    part is the entire queue).
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从队列的未排序部分（最初，未排序部分是整个队列）中出列一个元素。
- en: Compare this element with the current minimum.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个元素与当前最小值进行比较。
- en: 'If this element is smaller than the current minimum, then do the following:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个元素比当前最小值小，那么执行以下操作：
- en: a. If the current minimum is `Integer.MAX_VALUE`, then this element becomes
    the current minimum and we do not enqueue it back in the queue.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果当前最小值是`Integer.MAX_VALUE`，那么这个元素就成为当前最小值，我们不会将其重新加入队列。
- en: b. If the current minimum is not `Integer.MAX_VALUE`, then we enqueue the current
    minimum back in the queue and this element becomes the current minimum.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果当前最小值不是`Integer.MAX_VALUE`，那么我们将当前最小值重新加入队列，并且这个元素成为当前最小值。
- en: If this element is bigger than the current minimum value, then we enqueue it
    back in the queue.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个元素大于当前最小值，则将其重新加入队列。
- en: Repeat from *step 2* until the whole unsorted part is traversed.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复从*步骤2*直到整个未排序部分被遍历。
- en: At this step, the current minimum is the minimum of the entire unsorted part,
    so we enqueue it back in the queue.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一步中，当前最小值是整个未排序部分的最小值，因此我们将其重新加入队列。
- en: Set the new boundary of the unsorted part and repeat from *step 1* until the
    unsorted part size is 0 (every time we execute this step, the unsorted part’s
    size is decreased by 1).
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置未排序部分的新边界，并从*步骤1*重复，直到未排序部分的大小为0（每次执行此步骤时，未排序部分的大小减1）。
- en: 'The following diagram is a snapshot of this algorithm for the queue; that is,
    rear → 3 → 9 → 1 → 8 → 5 → 2 → front:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 下图是该算法对队列的快照；即，rear → 3 → 9 → 1 → 8 → 5 → 2 → front：
- en: '![Figure 14.19 – Sorting a queue without extra space'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.19 – 不使用额外空间对队列进行排序'
- en: '](img/Figure_14.19_B15403.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.19_B15403.jpg)'
- en: Figure 14.19 – Sorting a queue without extra space
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.19 – 不使用额外空间对队列进行排序
- en: 'Notice how each minimum of the unsorted part (initially, the whole queue) is
    added back into the queue and becomes a member of the sorted part of the queue.
    Let’s see the code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每个未排序部分（最初是整个队列）的最小值是如何重新加入队列并成为队列的排序部分的成员的。让我们看看代码：
- en: '[PRE25]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code’s runtime is O(n2). The complete application is called *SortQueueWithoutExtraSpace*.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n2)。完整的应用程序称为*SortQueueWithoutExtraSpace*。
- en: Coding challenge 8 – Sorting a stack with the help of another stack
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战8 – 使用另一个栈帮助对栈进行排序
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you’ve been given an unsorted stack. Write a snippet
    of code that sorts the stack in descending or ascending order. You can only use
    an additional temporary stack.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 问题：考虑到你已经得到了一个未排序的栈。编写一小段代码，对栈进行升序或降序排序。你只能使用一个额外的临时栈。
- en: '**Solution**: If we could use two additional stacks, then we could implement
    an algorithm that repeatedly searches the minimum value in the given stack and
    pushes it into the final or resulting stack. A second additional stack will be
    used as a buffer while searching the given stack. However, the problem requires
    us to use only one additional temporary stack.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：如果我们可以使用两个额外的栈，那么我们可以实现一个算法，该算法重复搜索给定栈中的最小值，并将其推入最终或结果栈。第二个额外的栈将用作在搜索给定栈时的缓冲区。然而，问题要求我们只能使用一个额外的临时栈。'
- en: 'Due to this constraint, we are forced to pop from the given stack (let’s denote
    it as *s1*) and push in order into the additional stack (let’s denote it as *s2*).
    To accomplish this, we use a temporary or auxiliary variable (let’s denote it
    as *t*), as shown in the following diagram (the given stack is top → 1 → 4 → 5
    → 3 → 1 → 2):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个限制，我们被迫从给定的栈（我们将其表示为*s1*）中弹出并按顺序推入另一个栈（我们将其表示为*s2*）。为了实现这一点，我们使用一个临时的或辅助变量（我们将其表示为*t*），如下图所示（给定的栈为top
    → 1 → 4 → 5 → 3 → 1 → 2）：
- en: '![Figure 14.20 – Sorting a stack'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.20 – 对栈进行排序'
- en: '](img/Figure_14.20_B15403.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.20_B15403.jpg)'
- en: Figure 14.20 – Sorting a stack
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.20 – 对栈进行排序
- en: 'The solution consists of two main steps:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案由两个主要步骤组成：
- en: 'While *s1* is not empty, do the following:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当*s1*不为空时，执行以下操作：
- en: a. Pop a value from *s1* and store it in *t* (*action 1* in the previous diagram
    shows this for value 3).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: a. 从*s1*中弹出一个值并将其存储在*t*中（前一个图中显示了值3的*动作1*）。
- en: b. Pop from *s2* and push it into *s1* as long as what we pop from *s2* is bigger
    than *t* or *s2* is not empty (*action 2* in the previous diagram).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: b. 从*s2*中弹出并将其推入*s1*，只要从*s2*中弹出的值大于*t*或者*s2*不为空（前一个图中的*动作2*）。
- en: c. Push *t* into *s2* (*action 3* in the previous diagram).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: c. 将*t*推入*s2*（前一个图中的*动作3*）。
- en: Once *step 1* is complete, *s1* is empty and *s2* is sorted. The biggest value
    is at the bottom, so the resulting stack is top → 5 → 4 → 3 → 2 → 1 → 1\. The
    second step consists of copying *s2* into *s1*. This way, *s1* is sorted in the
    reverse order of *s2*, so the smallest value is at the top of *s1* (top → 1 →
    1 → 2 → 3 → 4 → 5).
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦*步骤1*完成，*s1*为空，*s2*已排序。最大值在底部，因此结果栈为top → 5 → 4 → 3 → 2 → 1 → 1。第二步是将*s2*复制到*s1*。这样，*s1*按*s2*的相反顺序排序，因此最小值在*s1*的顶部（top
    → 1 → 1 → 2 → 3 → 4 → 5）。
- en: 'Let’s see the code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE26]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The complete code is called *SortStack*.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码称为*SortStack*。
- en: Coding challenge 9 – Sorting a stack in place
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程挑战9 – 原地对栈进行排序
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '`for`, `while`, and so on.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`，`while`等等。'
- en: '**Solution**: In the preceding problem, we had to solve the same problem but
    using an explicit extra stack. This time, we cannot use an explicit extra stack,
    so we must sort the stack in place.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：在前面的问题中，我们必须解决相同的问题，但是使用一个显式的额外栈。这一次，我们不能使用显式的额外栈，因此我们必须原地对栈进行排序。'
- en: Let’s consider that the given stack is top → 4 → 5 → 3 → 8 → 2 →1\. The solution
    starts by popping the values from the stack until the stack is empty. Afterward,
    we insert the values from the recursion call stack back into the given stack in
    sorted position.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 假设给定的栈为top → 4 → 5 → 3 → 8 → 2 →1。解决方案从栈中弹出值开始，直到栈为空。然后，我们将递归调用栈中的值按排序位置插入回给定的栈。
- en: 'Let’s try to apply this approach to our stack. The following diagram reveals
    the process of popping the values from the stack until the stack is empty. On
    the left-hand side, we have the initial state. On the right-hand side, we have
    the result:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试将这种方法应用到我们的栈上。下图显示了从栈中弹出值直到栈为空的过程。在左侧，我们有初始状态。在右侧，我们有结果：
- en: '![Figure 14.21 – Sorting the stack in place (1)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.21 – 原地对栈进行排序（1）'
- en: '](img/Figure_14.21_B15403.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.21_B15403.jpg)'
- en: Figure 14.21 – Sorting the stack in place (1)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.21 – 原地对栈进行排序（1）
- en: 'Next, we push back into the stack as long as the current element to push is
    smaller than the current top of the stack or the stack is empty. So, we will push
    1, 2, and 8\. We don’t push 3 (the next element to be pushed) since 3 is less
    than 8 (you can see this statement in the following diagram as *action 1*). At
    this point, we need to make room to 3, so we must pop the top of the stack, 8
    (you can see this statement in the following diagram as *action 2*). Finally,
    we push 3 and, afterward, we push 8 into the stack (you can see this statement
    in the following diagram as *action 3*):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，只要要推入的当前元素小于当前堆栈的顶部元素或堆栈为空，我们就将其推回到堆栈中。因此，我们将推入1、2和8。我们不推入3（下一个要推入的元素），因为3小于8（您可以在以下图表中看到这个语句作为*动作1*）。在这一点上，我们需要为3腾出空间，所以我们必须弹出堆栈的顶部，8（您可以在以下图表中看到这个语句作为*动作2*）。最后，我们推入3，然后推入8到堆栈中（您可以在以下图表中看到这个语句作为*动作3*）：
- en: '![Figure 14.22 – Sorting the stack in place (2)](img/Figure_14.22_B15403.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图14.22 – 原地对堆栈进行排序（2）](img/Figure_14.22_B15403.jpg)'
- en: Figure 14.22 – Sorting the stack in place (2)
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.22 – 原地对堆栈进行排序（2）
- en: 'So far, so good! Next, we must repeat the flow presented in the preceding diagram.
    So, the next element to be pushed from the recursion call stack into the given
    stack is 5\. But 5 is less than 8, so we cannot push it (you can see this statement
    in the following diagram as *action 1*). At this point, we need to make room for
    5, so we have to pop the top of the stack, which is 8 (you can see this statement
    in the following diagram as *action 2*). Finally, we push 5 and, afterward, we
    push 8 into the stack (you can see this statement in the following diagram as
    *action 3*):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利！接下来，我们必须重复前面图表中呈现的流程。因此，从递归调用堆栈中推入给定堆栈的下一个元素是5。但是5小于8，所以我们不能推入它（您可以在以下图表中看到这个语句作为*动作1*）。在这一点上，我们需要为5腾出空间，所以我们必须弹出堆栈的顶部，即8（您可以在以下图表中看到这个语句作为*动作2*）。最后，我们推入5，然后推入8到堆栈中（您可以在以下图表中看到这个语句作为*动作3*）：
- en: '![Figure 14.23 – Sorting the stack in place (3)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.23 – 原地对堆栈进行排序（3）'
- en: '](img/Figure_14.23_B15403.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.23_B15403.jpg)'
- en: Figure 14.23 – Sorting the stack in place (3)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.23 – 原地对堆栈进行排序（3）
- en: 'Finally, the last element that should be pushed from the recursion call stack
    into the given stack is 4\. However, 4 is less than 8, so we cannot push it (you
    can see this statement in the following diagram as *action 1*). At this point,
    we need to make room to 4, so we must pop the top of the stack, which is 8 (you
    can see this statement in the following diagram as *action 2*). However, we still
    cannot push 4 into the stack because 4 is less than 5 (the new top element after
    popping 8). We must pop 5 as well (you can see this statement in the following
    diagram as *action 3*). Now, we can push 4\. Next, we push 5 and 8\. You can see
    this in the following diagram as *action 4*:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应该从递归调用堆栈中推入给定堆栈的最后一个元素是4。然而，4小于8，所以我们不能推入它（您可以在以下图表中看到这个语句作为*动作1*）。在这一点上，我们需要为4腾出空间，所以我们必须弹出堆栈的顶部，即8（您可以在以下图表中看到这个语句作为*动作2*）。然而，我们仍然不能将4推入堆栈，因为4小于5（弹出8后的新顶部元素）。我们必须也弹出5（您可以在以下图表中看到这个语句作为*动作3*）。现在，我们可以推入4。接下来，我们推入5和8。您可以在以下图表中看到这一点作为*动作4*：
- en: '![Figure 14.24 – Sorting the stack in place (4)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.24 – 原地对堆栈进行排序（4）'
- en: '](img/Figure_14.24_B15403.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.24_B15403.jpg)'
- en: Figure 14.24 – Sorting the stack in place (4)
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.24 – 原地对堆栈进行排序（4）
- en: 'Done! The given stack has been sorted. Let’s see the code:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！给定的堆栈已经排序。让我们看看代码：
- en: '[PRE27]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The runtime of this code is O(n2) with an auxiliary space of O(n) for the recursion
    call stack (*n* is the number of elements in the given stack). The complete application
    is called *SortStackInPlace*.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n2)，辅助空间是O(n)用于递归调用堆栈（*n*是给定堆栈中的元素数）。完整的应用程序称为*SortStackInPlace*。
- en: Coding challenge 10 – Searching in a full sorted matrix
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战10 – 在完全排序的矩阵中搜索
- en: '**Amazon**, **Microsoft**, **Flipkart**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**微软**，**Flipkart**'
- en: '`true` if a given integer is in this matrix.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`如果给定的整数在这个矩阵中。'
- en: '**Solution**: The brute-force method is quite inefficient. If we try to iterate
    the matrix and compare each (*row, col*) integer with the searched one, then this
    will impose a time complexity of O(mn), where *m* is the number of rows and *n*
    is the number of columns in the matrix.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：暴力方法非常低效。如果我们尝试迭代矩阵并将每个（*行，列*）整数与搜索的整数进行比较，那么这将导致时间复杂度为O(mn)，其中*m*是矩阵中的行数，*n*是列数。'
- en: 'Another solution will rely on the Binary Search algorithm. We have enough experience
    to implement this algorithm for a sorted array, but can we do it for a sorted
    matrix? Yes, we can, thanks to the fact that this sorted matrix is *fully sorted*.
    More precisely, since the first integer of each row is greater than the last integer
    of the previous row, we can look at this matrix as an array of length *rows* x
    *cols*. The following diagram clarifies this statement:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案将依赖于二分搜索算法。我们有足够的经验来为排序数组实现这个算法，但是我们能为排序矩阵实现吗？是的，我们可以，这要归功于这个排序矩阵是*完全排序*。更确切地说，由于每行的第一个整数大于前一行的最后一个整数，我们可以将这个矩阵看作长度为*行数*
    x *列数*的数组。以下图表澄清了这个说法：
- en: '![Figure 14.25 – Fully sorted matrix as an array'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.25 – 完全排序的矩阵作为数组'
- en: '](img/Figure_14.25_B15403.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.25_B15403.jpg)'
- en: Figure 14.25 – Fully sorted matrix as an array
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.25 – 完全排序的矩阵作为数组
- en: 'So, if we see the given matrix as an array, then we can reduce the problem
    of applying the Binary Search to a sorted array. There is no need to physically
    transform the matrix into an array. All we need to do is express the Binary Search
    accordingly using the following statements:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们将给定的矩阵视为数组，那么我们可以将应用二分搜索到排序数组的问题减少。没有必要将矩阵物理转换为数组。我们只需要根据以下语句相应地表达二分搜索：
- en: The left-most integer of the array is at index 0 (let’s denote it as *left*).
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的最左边整数位于索引0（让我们将其表示为*left*）。
- en: The right-most integer of the array is at index (*rows * cols*) - 1 (let’s denote
    it as *right*).
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的最右边整数位于索引（*行数* x *列数*）- 1（让我们将其表示为*right*）。
- en: The middle point of the array is at (*left + right*) / 2.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的中间点在(*left + right*) / 2处。
- en: The integer at the middle point of the index is at *matrix*[*mid / cols*][*mid
    % cols*], where *cols* is the number of columns in the matrix.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引的中间点处的整数为*matrix*[*mid / cols*][*mid % cols*]，其中*cols*是矩阵中的列数。
- en: 'With these statements in place, we can write the following implementation:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些陈述，我们可以编写以下实现：
- en: '[PRE28]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding code performs in O(log mn) time, where *m* is the number of rows
    and *n* is the number of columns in the given matrix. The application is called
    *SearchInFullSortedMatrix*.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在O(log mn)时间内执行，其中*m*是给定矩阵中的行数，*n*是列数。该应用程序称为*SearchInFullSortedMatrix*。
- en: Coding challenge 11 – Searching in a sorted matrix
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战11 - 在排序矩阵中搜索
- en: '**Amazon**, **Microsoft**, **Flipkart**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**微软**，**Flipkart**'
- en: '`true` if a given integer is in this matrix.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`true`如果给定整数在此矩阵中。'
- en: '**Solution**: Notice that this problem is not like the previous coding challenge
    since the first integer of each row doesn’t have to be greater than the last integer
    of the previous row. If we apply the Binary Search algorithm (as we did for the
    previous coding challenge), then we must apply it to every row. Since Binary Search
    has a complexity time of O(log n) and we have to apply it to every row, this means
    that this approach will perform in O(m log n) time, where *m* is the number of
    rows and *n* is the number of columns in the given matrix.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：请注意，这个问题不像前一个编码挑战，因为每行的第一个整数不必大于前一行的最后一个整数。如果我们应用二分搜索算法（就像我们对前一个编码挑战所做的那样），那么我们必须对每一行应用它。由于二分搜索的时间复杂度为O(log
    n)，我们必须对每一行应用它，这意味着这种方法将在O(m log n)时间内执行，其中*m*是给定矩阵中的行数，*n*是列数。'
- en: 'In order to find a solution, let’s consider the following diagram (a matrix
    of 4 x 6):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到解决方案，让我们考虑以下图表（一个4 x 6的矩阵）：
- en: '![Figure 14.26 – Searching in a sorted matrix](img/Figure_14.26_B15403.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![图14.26 - 在排序矩阵中搜索](img/Figure_14.26_B15403.jpg)'
- en: Figure 14.26 – Searching in a sorted matrix
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.26 - 在排序矩阵中搜索
- en: 'Let’s assume that we search for the element 80, which can be found at (2, 3).
    Let’s try to deduce this position. The climax of this deduction orbits the fact
    that the matrix has sorted rows and columns. Let’s analyze the start of the columns:
    if the start of a column is greater than 80 (for example, column 4), then we know
    that 80 cannot be in that column, since the start of the column is the minimum
    element in that column. Moreover, 80 cannot be found in any of the columns to
    the right of that column since the start element of each column must increase
    in size from left to right. Furthermore, we can apply the same logic to rows.
    If the start of a row is greater than 80, then we know that 80 cannot be in that
    row or subsequent (downward) rows.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们搜索元素80，可以在(2, 3)处找到。让我们试着推断这个位置。这个推断的高潮围绕着矩阵有序的行和列。让我们分析列的开始：如果一列的开始大于80（例如，列4），那么我们知道80不能在该列中，因为该列的开始是该列中的最小元素。此外，80不能在该列右侧的任何列中找到，因为每列的开始元素必须从左到右递增。此外，我们可以将相同的逻辑应用于行。如果一行的开始大于80，那么我们知道80不能在该行或随后（向下）的行中。
- en: Now, if we look at the end of the columns and rows, we can deduce some similar
    conclusions (mirrored conclusions). If the end of a column is less than 80 (for
    example, column 2), then we know that 80 cannot be in that column since the end
    of the column is the maximum element in that column. Moreover, 80 cannot be found
    in any of the columns to the left of that column since the start element of each
    column must decrease in size from right to left. Furthermore, we can apply the
    same logic to rows. If the end of a row is less than 80, then we know that 80
    cannot be in that row or subsequent (upward) rows.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们看列和行的末尾，我们可以得出一些类似的结论（镜像结论）。如果一列的末尾小于80（例如，列2），那么我们知道80不能在该列中，因为该列的末尾是该列中的最大元素。此外，80不能在该列左侧的任何列中找到，因为每列的开始元素必须从右到左递减。此外，我们可以将相同的逻辑应用于行。如果一行的末尾小于80，那么我们知道80不能在该行或随后（向上）的行中。
- en: 'If we join, synthesize, and generalize these conclusions for an element, *p*,
    then we can deduce the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些结论综合起来，我们可以推断出以下结论：
- en: If the start of a column is greater than *p*, then *p* must be to the left of
    that column.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一列的开始大于*p*，那么*p*必须在该列的左边。
- en: If the start of a row is greater than *p*, then *p* must be above that row.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一行的开始大于*p*，那么*p*必须在该行的上方。
- en: If the end of a column is less than *p*, then *p* must be to the right of that
    column.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一列的末尾小于*p*，那么*p*必须在该列的右边。
- en: If the end of a row is less than *p*, then *p* must be below that row.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一行的末尾小于*p*，那么*p*必须在该行下方。
- en: This is already starting to look like an algorithm. There is one more thing
    that we must decide, though. Where do we start from? From which row and column?
    Fortunately, we have several options. For example, we can start with the greatest
    column (0, *last column*) and work to the left of the same row, or with the greatest
    row (*last row*, 0) and work up on the same column.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经开始看起来像一个算法。不过，我们还有一件事要决定。我们从哪里开始？从哪一行和哪一列开始？幸运的是，我们有几个选择。例如，我们可以从最大列（0，*最后一列*）开始，并向同一行的左边开始，或者从最大行（*最后一行*，0）开始，并向同一列的上方开始。
- en: 'Let’s assume that we choose to start with the greatest column (0, *last column*)
    and work to the left to find the element, *p*. This means that our flow will be
    as follows (let’s denote *i*=0 and *j=cols*-1):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们选择从最大列（0，*最后一列*）开始，并向左查找元素*p*。这意味着我们的流程将如下（让我们表示*i*=0和*j=cols*-1）：
- en: If *matrix*[*i*][*j*] *> p*, then move left in the same row. The elements in
    this column are definitely greater than *matrix*[*i*][*j*] and hence, by extension,
    greater than *p*. So, we discard the current column, decrease *j* by 1, and repeat.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*matrix*[*i*][*j*] *> p*，那么在同一行向左移动。这一列的元素肯定大于*matrix*[*i*][*j*]，因此，通过推论，大于*p*。因此，我们丢弃当前列，将*j*减1，并重复。
- en: If *matrix*[*i*][*j*] *< p*, then move down in the same column. The elements
    in this row are definitely less than *matrix*[*i*][*j*] and hence, by extension,
    less than *p*. So, we discard the current row, increase *i* by 1, and repeat.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*matrix*[*i*][*j*] < p，则在同一列向下移动。这一行的元素肯定小于*matrix*[*i*][*j*]，因此，通过推论，也小于*p*。因此，我们丢弃当前行，将*i*增加1，并重复。
- en: If *p* is equal to *matrix*[*i*][*j*], return `true`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*p*等于*matrix*[*i*][*j*]，返回`true`。
- en: 'If we apply this algorithm to find element 80 in our 4 x 6 matrix, then the
    path from (0, 5) to (2, 3) will be as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个算法应用于在我们的4 x 6矩阵中查找元素80，那么从（0, 5）到（2, 3）的路径将如下所示：
- en: '![Figure 14.27 – Path to the solution'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.27 - 解决方案的路径'
- en: '](img/Figure_14.27_B15403.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.27_B15403.jpg)'
- en: Figure 14.27 – Path to the solution
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.27 - 解决方案的路径
- en: 'If we put this algorithm into code, then we get the following:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这个算法编写成代码，那么我们会得到以下结果：
- en: '[PRE29]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The time complexity of this algorithm is O(m+n), where *m* is the number of
    rows and *n* is the number of columns. The complete application is called *SearchInSortedMatrix*.
    It also contains a recursive implementation of this algorithm.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的时间复杂度是O(m+n)，其中*m*是行数，*n*是列数。完整的应用程序称为*SearchInSortedMatrix*。它还包含了这个算法的递归实现。
- en: Coding challenge 12 – First position of first one
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战12 - 第一个1的位置
- en: '**Amazon**, **Google**, **Adobe**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**'
- en: '**Problem**: Consider you’ve been given an array that contains only values
    of 0 and 1\. There is at least a 0 and a 1\. All 0s comes first, followed by 1s.
    Write a snippet of code that returns the index of the first 1 in this array.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你得到了一个只包含0和1值的数组。至少有一个0和一个1。所有的0都在前面，然后是1。编写一小段代码，返回这个数组中第一个1的索引。'
- en: '**Solution**: Consider the array *arr*=[0, 0, 0, 1, 1, 1, 1]. The searched
    index is 3 since *arr*[3] is 1, and this is the first 1\.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：考虑数组*arr*=[0, 0, 0, 1, 1, 1, 1]。搜索到的索引是3，因为*arr*[3]是1，这是第一个1。'
- en: Since 0s comes first, followed by 1s, the array is sorted.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 由于0在前面，然后是1，所以数组是排序的。
- en: Note
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Since this is a very common topic in interviews, I’ll say it again: when we
    have to find something in a sorted array, we have to consider the Binary Search
    algorithm.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是面试中非常常见的话题，我再说一遍：当我们在一个排序的数组中查找东西时，我们必须考虑二分搜索算法。
- en: 'In this case, the Binary Search algorithm can be implemented quite easily.
    The middle point that’s computed in Binary Search can fall on 0 or 1\. Since the
    array is sorted, if the middle point falls on 0, then we know for sure that the
    first value of 1 must be on the right-hand side of the middle point, so we discard
    the left-hand side of the middle point. On the other hand, if the middle point
    falls on 1, then we know that the first value of 1 must on the left-hand side
    of the middle point, so we discard the right-hand side of the middle point. The
    following code clarifies this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，二分搜索算法可以很容易地实现。在二分搜索中计算的中间点可以落在0或1上。由于数组是排序的，如果中间点落在0上，那么我们可以确定1的第一个值必须在中间点的右侧，所以我们丢弃中间点的左侧。另一方面，如果中间点落在1上，那么我们知道1的第一个值必须在中间点的左侧，所以我们丢弃中间点的右侧。以下代码阐明了这一点：
- en: '[PRE30]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The complete application is called *PositionOfFirstOne*.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*PositionOfFirstOne*。
- en: Coding challenge 13 – Maximum difference between two elements
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战13 - 两个元素之间的最大差值
- en: '**Problem**: Consider you’ve been given an array of integers, *arr*. Write
    a snippet of code that return the maximum difference between two elements when
    the larger integer appears after the smaller integer.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你得到了一个整数数组*arr*。编写一小段代码，返回当较大的整数出现在较小的整数之后时，两个元素之间的最大差值。'
- en: '**Solution**: Let’s consider several examples.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑几个例子。'
- en: If the given array is 1, 34, 21, 7, 4, 8, 10, then the maximum difference is
    33 (computed as 34 (index 1) - 1 (index 0)). If the given arrays is 17, 9, 2,
    26, 32, 27, 3, then the maximum difference is 30 (computed as 32 (index 4) - 2
    (index 2)).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的数组是1, 34, 21, 7, 4, 8, 10，那么最大差值是33（计算为34（索引1）- 1（索引0））。如果给定的数组是17, 9,
    2, 26, 32, 27, 3，那么最大差值是30（计算为32（索引4）- 2（索引2））。
- en: How about an array sorted in ascending order, such as 3, 7, 9, 11? In this case,
    the maximum difference is 11 - 3 = 8, so this is the difference between the maximum
    and the minimum element. How about an array sorted in descending order such as
    11, 9, 7, 6? In this case, the maximum difference is 6 - 7 = -1, so the maximum
    difference is the difference closest to 0.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是按升序排序的数组，比如3, 7, 9, 11，那么最大差值是11 - 3 = 8，所以这是最大元素和最小元素之间的差值。如果是按降序排序的数组，比如11,
    9, 7, 6，那么最大差值是6 - 7 = -1，所以最大差值是最接近0的差值。
- en: Based on these examples, we can think of several solutions. For example, we
    can start by computing the minimum and maximum of the array. Next, if the index
    of the maximum is greater than the index of the minimum, then the maximum difference
    is the difference between the maximum and the minimum of the array. Otherwise,
    we need to compute the next minimum and maximum of the array and repeat this process.
    This can lead to a complexity time of O(n2).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些例子，我们可以考虑几种解决方案。例如，我们可以先计算数组的最小值和最大值。接下来，如果最大值的索引大于最小值的索引，则最大差值是数组的最大值和最小值之间的差值。否则，我们需要计算数组的下一个最小值和最大值，并重复这个过程。这可能导致O(n2)的时间复杂度。
- en: Another approach can start by sorting the array. Afterward, the maximum difference
    will be the difference between the maximum and the minimum elements (the difference
    between the last and the first elements). This can be implemented via a sorting
    algorithm in O(n log n) runtime.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法可以通过对数组进行排序来开始。之后，最大差值将是最大元素和最小元素之间的差值（最后一个元素和第一个元素之间的差值）。这可以通过O(n log
    n)的运行时间内的排序算法来实现。
- en: How about doing it in O(n) time? Instead of sorting the array or computing its
    maximum or minimum, we try another approach. Note that if we consider that *p*
    is the first element from the array, we can compute the difference between every
    successive element and *p*. While we are doing this, we are tracking the maximum
    difference and updating it accordingly. For example, if the array is 3, 5, 2,
    1, 7, 4 and *p*=3, then the maximum difference is 7-*p*=7-3=4\. However, if we
    look carefully, the real maximum difference is 7-1=6 and 1 is smaller than *p*.
    This leads us to the conclusion that, while traversing the elements successive
    to *p*, if the current traversed element is smaller than *p*, then *p* should
    become that element. Subsequent differences are computed between the successors
    of this *p* until the array is completely traversed or we find another element
    smaller than *p*. In such a case, we repeat this process.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在O(n)时间内完成？我们尝试另一种方法，而不是对数组进行排序或计算其最大值或最小值。请注意，如果我们认为*p*是数组中的第一个元素，我们可以计算每个连续元素与*p*之间的差异。在这样做的同时，我们跟踪最大差异并相应地更新它。例如，如果数组是3,
    5, 2, 1, 7, 4，*p*=3，那么最大差异是7-*p*=7-3=4。然而，如果我们仔细观察，真正的最大差异是7-1=6，而1小于*p*。这导致我们得出结论，当遍历*p*之后的连续元素时，如果当前遍历的元素小于*p*，那么*p*应该变成该元素。在*p*的后继元素之间计算后续差异，直到完全遍历数组或找到另一个小于*p*的元素。在这种情况下，我们重复这个过程。
- en: 'Let’s see the code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE31]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code runs in O(n) time. The complete application is called *MaxDiffBetweenTwoElements*.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行时间为O(n)。完整的应用程序称为*MaxDiffBetweenTwoElements*。
- en: Coding challenge 14 – Stream ranking
  id: totrans-391
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战14 - 流排名
- en: '**Problem:** Consider you’ve been given a stream of integers (such as a continuous
    flux of integer values). Periodically, we want to inspect the rank of a given
    integer, *p*. By rank, we understand the number of values less than or equal to
    *p*. Implement the data structure and algorithm that supports this operation.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题：**假设你得到了一系列整数流（例如连续的整数值流）。定期地，我们想要检查给定整数*p*的排名。通过排名，我们理解小于或等于*p*的值的数量。实现支持此操作的数据结构和算法。'
- en: '**Solution**: Let’s consider the following stream: 40, 30, 45, 15, 33, 42,
    56, 5, 17, 41, 67\. The rank of 45 is 8, the rank of 5 is 0, the rank of 17 is
    2, and so on.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑以下流：40, 30, 45, 15, 33, 42, 56, 5, 17, 41, 67。45的排名是8，5的排名是0，17的排名是2，依此类推。'
- en: 'The brute-force approach may work on a sorted array. Each time a new integer
    is generated, we add it to this array. While this will be very convenient for
    returning the rank of a given integer, this approach has an important drawback:
    each time we insert an element, we have to shift the elements greater than the
    new integer to make room for it. This is needed to maintain the array when it’s
    sorted in ascending order.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 蛮力方法可能适用于排序数组。每次生成一个新整数时，我们将其添加到这个数组中。虽然这对于返回给定整数的排名非常方便，但这种方法有一个重要的缺点：每次插入一个元素，我们都必须将大于新整数的元素移动，以为其腾出空间。这是为了在数组按升序排序时维护数组。
- en: 'A much better choice consists of a **Binary Search Tree** (**BST**). A BST
    maintains a relative order and inserting a new integer will update the tree accordingly.
    Let’s add the integers from our stream to a Binary Search Tree, as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的选择是**二叉搜索树**（**BST**）。BST维护相对顺序，并插入新整数将相应地更新树。让我们将整数从我们的流添加到二叉搜索树中，如下所示：
- en: '![Figure 14.28 – BST for stream ranking'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.28 - 流排名的BST'
- en: '](img/Figure_14.28_B15403.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.28_B15403.jpg)'
- en: Figure 14.28 – BST for stream ranking
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.28 - 流排名的BST
- en: Let’s suppose that we want to find rank 43\. First, we compare 43 with the root
    and we conclude that 43 must be in the right sub-tree of the root, 40\. However,
    the root has 5 nodes in its left sub-tree (obviously, all of them are smaller
    than the root), so the rank of 43 is at least 6 (5 nodes of the left sub-tree
    of the root, plus the root). Next, we compare 43 with 45 and we conclude that
    43 must be to the left of 45, so the rank remains 5\. Finally, we compare 43 with
    42, and we conclude that 43 must be in the right sub-tree of 42\. The rank must
    be increased by 1, so the rank of 43 is 7.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找到排名43。首先，我们将43与根节点进行比较，并得出结论43必须在根节点40的右子树中。然而，根节点的左子树有5个节点（显然，它们都小于根节点），因此43的排名至少为6（根节点的左子树的5个节点，加上根节点）。接下来，我们将43与45进行比较，并得出结论43必须在45的左边，因此排名保持为5。最后，我们将43与42进行比较，并得出结论43必须在42的右子树中。排名必须增加1，因此43的排名为7。
- en: 'So, how can we generalize this example with an algorithm? Here, we noticed
    that, for each node, we already know the rank of its left sub-tree. This doesn’t
    need to be computed each time the rank is required since this will be quite inefficient.
    We can track and update the rank of the left sub-tree each time a new element
    is generated and inserted into the tree. In the preceding diagram, each node has
    its sub-tree rank highlighted above the node. When the rank of a node is required,
    we already know the rank of its left sub-tree. Next, we have to consider the following
    recursive steps, which are applied via `int getRank(Node node, int element)`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何用算法概括这个例子呢？在这里，我们注意到，对于每个节点，我们已经知道了其左子树的排名。这不需要每次需要排名时都计算，因为这将非常低效。每次生成新元素并将其插入树中时，我们可以跟踪和更新左子树的排名。在前面的图中，每个节点都有其子树排名在节点上方突出显示。当需要节点的排名时，我们已经知道了其左子树的排名。接下来，我们必须考虑以下递归步骤，通过`int
    getRank(Node node, int element)`应用：
- en: If `element` is equal to `node.element`, then return `node.leftTreeSize`.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`element`等于`node.element`，则返回`node.leftTreeSize`。
- en: If `element` is on the left of `node`, then return `getRank(node.left, element)`.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`element`在`node`的左边，则返回`getRank(node.left, element)`。
- en: If `element` is on the right of `node`, then return `node.leftTreeSize + 1 +
    getRank(node.right, element)`.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`element`在`node`的右边，则返回`node.leftTreeSize + 1 + getRank(node.right, element)`。
- en: 'If the given integer is not found, then we return -1\. The relevant code is
    listed here:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到给定的整数，则返回-1。相关代码如下：
- en: '[PRE32]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code will run in O(log n) time on a balanced tree and O(n) time
    on an unbalanced tree, where *n* is the number of nodes in the tree. The complete
    application is called *RankInStream*.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将在平衡树上以O(log n)的时间运行，在不平衡树上以O(n)的时间运行，其中*n*是树中的节点数。完整的应用程序称为*RankInStream*。
- en: Coding challenge 15 – Peaks and valleys
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战15 - 山峰和山谷
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you’ve been given an array of positive integers representing
    terrain elevations. If an integer from this array is greater than or equal to
    its neighbors (adjacent integers), then this integer is called a *peak*. On the
    other hand, if an integer from this array is smaller than or equal to its neighbors
    (adjacent integers), then this integer is called a *valley*. For example, for
    array 4, 5, 8, 3, 2, 1, 7, 8, 5, 9, we can see that 8 (both) and 9 are peaks,
    while 4, 1, and 5 (except the last one) are valleys. Write a snippet of code that
    sorts the given array into an alternating sequence of peaks and valleys.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你得到了一个表示地形高程的正整数数组。如果数组中的整数大于或等于其邻居(相邻整数)，则称该整数为*山峰*。另一方面，如果数组中的整数小于或等于其邻居(相邻整数)，则称该整数为*山谷*。例如，对于数组4,
    5, 8, 3, 2, 1, 7, 8, 5, 9，我们可以看到8(两者)和9是山峰，而4, 1和5(除了最后一个)是山谷。编写一小段代码，将给定的数组排序为交替的山峰和山谷序列。'
- en: '**Solution**: At first sight, a handy solution would be to start by sorting
    the array in ascending order. Once the array is sorted as *l1 ≤ l2 ≤ l3 ≤ l4 ≤
    l5 ...*, we can see each triplet of numbers as *large*(*l1*)≤*larger*(*l2*)≤*largest*(*l3*).
    If we swap *l2* with *l3*, then *l1*≤*l3*≥*l2*, so *l3* becomes a peak. For the
    next triplet, *l2*≤ *l4* ≤ *l5*, we swap *l4* with *l5* to obtain *l2*≤*l5*≥*l4*,
    so *l5* is a peak. For the next triplet, *l4*≤*l6*≤*l7*, we swap *l6* with *l7*
    to obtain *l4*≤*l7*≥*l6*, so *l7* is a peak. If we continue these swaps, then
    we obtain something like this: *l1*≤*l3*≥*l2*≤*l5*≥*l4*≤*l7*≥*l6* .... But is
    this efficient? Since we have to sort the array, we can say that the time complexity
    of this solution is O(n log n). Can we do better than this? Yes, we can! Let’s
    assume that we represent our array as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：乍一看，一个方便的解决方案是从升序排序数组开始。一旦数组按*l1 ≤ l2 ≤ l3 ≤ l4 ≤ l5 ...*排序，我们可以将每个三元组看作*large*(*l1*)≤*larger*(*l2*)≤*largest*(*l3*)。如果我们交换*l2*和*l3*，那么*l1*≤*l3*≥*l2*，所以*l3*变成了山峰。对于下一个三元组，*l2*≤
    *l4* ≤ *l5*，我们交换*l4*和*l5*以获得*l2*≤*l5*≥*l4*，所以*l5*是一个山峰。对于下一个三元组，*l4*≤*l6*≤*l7*，我们交换*l6*和*l7*以获得*l4*≤*l7*≥*l6*，所以*l7*是一个山峰。如果我们继续这些交换，那么我们会得到类似这样的结果：*l1*≤*l3*≥*l2*≤*l5*≥*l4*≤*l7*≥*l6*
    .... 但这样有效吗？由于我们必须对数组进行排序，我们可以说这种解决方案的时间复杂度是O(n log n)。我们能做得比这更好吗？是的，我们可以！假设我们将我们的数组表示如下：'
- en: '![Figure 14.29 – Given array of terrain elevations'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.29 - 给定的地形高程数组'
- en: '](img/Figure_14.29_B15403.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.29_B15403.jpg)'
- en: Figure 14.29 – Given array of terrain elevations
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.29 - 给定的地形高程数组
- en: 'Now, we can clearly see the peaks and valleys of the given array. If we focus
    on the first triplet (4, 5, 8) and try to obtain a peak, then we have to swap
    the value from the middle (5) with the maximum between its neighbors (adjacent
    integers). So, by swapping 5 with max(4, 8), we obtain (4, 8, 5). Therefore, 8
    is a peak and can be represented as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以清楚地看到给定数组的山峰和山谷。如果我们关注第一个三元组(4, 5, 8)并尝试获得一个山峰，那么我们必须将中间值(5)与其邻居(相邻整数)的最大值交换。因此，通过将5与max(4,
    8)交换，我们得到(4, 8, 5)。因此，8是一个山峰，可以表示如下：
- en: '![Figure 14.30 – Swapping 5 with 8'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.30 - 用5交换8'
- en: '](img/Figure_14.30_B15403.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.30_B15403.jpg)'
- en: Figure 14.30 – Swapping 5 with 8
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.30 - 用5交换8
- en: 'Next, let’s focus on the next triplet (5, 3, 2). We can obtain a peak by swapping
    3 with max(5, 2), so by swapping 3 with 5\. The result is (3, 5, 2), as shown
    here:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们关注下一个三元组(5, 3, 2)。我们可以通过将3与max(5, 2)交换来获得一个山峰，因此通过将3与5交换。结果是(3, 5, 2)，如下所示：
- en: '![Figure 14.31 – Swapping 3 with 5'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.31 - 用3交换5'
- en: '](img/Figure_14.31_B15403.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.31_B15403.jpg)'
- en: Figure 14.31 – Swapping 3 with 5
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.31 - 用5交换3
- en: 'Now, 5 is a peak and 3 is a valley. We should continue with the triplet (2,
    1, 7) and swap 1 with 7 to obtain the peak (2, 7, 1). The next triplet will be
    (1, 8, 5) and have 8 as a peak (there is nothing to swap). In the end, we obtain
    the final result, as can be seen in the following diagram:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，5是一个山峰，3是一个山谷。我们应该继续处理三元组(2, 1, 7)并交换1与7以获得山峰(2, 7, 1)。下一个三元组将是(1, 8, 5)，并且8是一个山峰(没有东西可以交换)。最后，我们得到最终结果，如下图所示：
- en: '![Figure 14.32 – Final result'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.32 - 最终结果'
- en: '](img/Figure_14.32_B15403.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.32_B15403.jpg)'
- en: Figure 14.32 – Final result
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.32 - 最终结果
- en: The interviewer will want you to pay attention to details and mention them.
    For example, when we swap the middle value with the left value, can we break the
    already processed terrain? Can we break a valley or a peak? The answer is no,
    we cannot break anything. This is because when we swap the middle with the left,
    we already know that the middle value is smaller than the left value and that
    the left value is a valley. Therefore, we just create a deeper valley by adding
    an even smaller value to that place.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 面试官希望你注意细节并提到它们。例如，当我们将中间值与左值交换时，我们是否可以破坏已经处理过的地形？我们能破坏山谷或山峰吗？答案是否定的，我们不能破坏任何东西。这是因为当我们将中间值与左值交换时，我们已经知道中间值小于左值，左值是一个山谷。因此，我们只是通过在那个位置添加一个更小的值来创建一个更深的山谷。
- en: 'Based on these statements, the implementation is quite simple. The following
    code will clarify any remaining details:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些陈述，实现是相当简单的。以下代码将澄清任何剩下的细节：
- en: '[PRE33]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This code performs in O(n) complexity time. The complete application is called
    *PeaksAndValleys*.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的时间复杂度为O(n)。完整的应用程序称为*PeaksAndValleys*。
- en: Coding challenge 16 – Nearest left smaller number
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战16 - 最近的左边较小数
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider you’ve been given an array of integers, *arr*. Write
    a snippet of code that finds and prints the nearest smaller number for every element
    so that the smaller element is on left-hand side.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑到您已经得到了一个整数数组*arr*，编写一小段代码，找到并打印每个元素的最近较小数，使得较小的元素在左侧。'
- en: '**Solution**: Let’s consider the given array; that is, 4, 1, 8, 3, 8, 2, 6,
    7, 4, 9\. The expected result is _, _, 1, 1, 3, 1, 2, 6, 2, 4\. From left to right,
    we have the following:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑给定的数组；即4, 1, 8, 3, 8, 2, 6, 7, 4, 9。预期结果是_，_，1，1，3，1，2，6，2，4。从左到右，我们有以下内容：'
- en: '*arr*[0]=4 and in its left there is no element, so we print _.'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arr*[0]=4，它的左边没有元素，所以我们打印_。'
- en: '*arr*[1]=1 and in its left there is no element smaller than it, so we print
    _.'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arr*[1]=1，它的左边没有比它更小的元素，所以我们打印_。'
- en: '*arr*[2]=8 and the nearest smallest element in its left is 1, so we print 1.'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arr*[2]=8，它左边最近的较小元素是1，所以我们打印1。'
- en: '*arr*[3]=3 and the nearest smallest element in its left is 1, so we print 1.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arr*[3]=3，它左边最近的较小元素是1，所以我们打印1。'
- en: '*arr*[4]=8 and the nearest smallest element in its left is 3, so we print 3.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arr*[4]=8，它左边最近的较小元素是3，所以我们打印3。'
- en: '*arr*[5]=2 and the nearest smallest element in its left is 1, so we print 1.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arr*[5]=2，它左边最近的较小元素是1，所以我们打印1。'
- en: '*arr*[6]=6 and the nearest smallest element in its left is 2, so we print 2'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arr*[6]=6，它左边最近的较小元素是2，所以我们打印2。'
- en: '*arr*[7]=7 and the nearest smallest element in its left is 6, so we print 6'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arr*[7]=7，它左边最近的较小元素是6，所以我们打印6。'
- en: '*arr*[8]=4 and the nearest smallest element in its left is 2, so we print 2'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arr*[8]=4，它左边最近的较小元素是2，所以我们打印2。'
- en: '*arr*[9]=9 and the nearest smallest element in its left is 4, so we print 4'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*arr*[9]=9，它左边最近的较小元素是4，所以我们打印4。'
- en: A simple but inefficient solution relies on two loops. The outer loop can start
    from the second element (index 1) and go to the length of the array (*arr.length*-1),
    while the inner loop traverses all the elements on the left-hand side of the element
    picked by the outer loop. As soon as it finds an element smaller, it stops the
    process. Such an algorithm is very easy to implement, but it runs in O(n2) complexity
    time.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单但低效的解决方案依赖于两个循环。外循环可以从第二个元素（索引1）开始，直到数组的长度（*arr.length*-1），而内循环遍历外循环选择的元素左侧的所有元素。一旦找到一个较小的元素，它就会停止这个过程。这样的算法很容易实现，但运行时间复杂度为O(n2)。
- en: 'However, we can reduce the time complexity to O(n) via a `Stack`. Mainly, we
    can traverse the given array from 0 to *arr.length*-1 and rely on a `Stack` to
    track the subsequence of elements that have been traversed so far that are smaller
    than any later element that has already been traversed. While this statement may
    sound complicated, let’s clarify it by looking at this algorithm’s steps:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过`Stack`将时间复杂度降低到O(n)。主要是，我们可以从0到*arr.length*-1遍历给定的数组，并依赖于`Stack`来跟踪到目前为止已经遍历的子序列元素，这些元素小于已经遍历的任何后续元素。虽然这个说法可能听起来很复杂，但让我们通过查看该算法的步骤来澄清一下：
- en: Create a new, empty stack.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空栈。
- en: 'For every element of *arr*, (*i* = 0 to *arr.length*-1), we do the following:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于*arr*的每个元素（*i* = 0到*arr.length*-1），我们执行以下操作：
- en: a. While the stack is not empty and the top element is greater than or equal
    to *arr*[*i*], we pop from the stack.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: a. 当栈不为空且顶部元素大于或等于*arr*[*i*]时，我们从栈中弹出。
- en: b. If the stack is empty, then there is no element in the left of *arr*[*i*].
    We can print a symbol representing no element found (for example, -1 or _).
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: b. 如果栈为空，则*arr*[*i*]的左边没有元素。我们可以打印一个表示没有找到元素的符号（例如，-1或_）。
- en: c. If the stack is not empty, then the nearest smaller value to *arr*[*i*] is
    the top element of the stack. We can peek and print this element.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: c. 如果栈不为空，则*arr*[*i*]的最近较小值是栈的顶部元素。我们可以查看并打印这个元素。
- en: d. Push *arr*[*i*] into the stack.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: d. 将*arr*[*i*]推入栈中。
- en: 'In terms of code, we have the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下内容：
- en: '[PRE34]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This code has a runtime of O(n), where *n* is the number of elements in the
    given array. The complete application is called *FindNearestMinimum*.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间为O(n)，其中*n*是给定数组中的元素数。完整的应用程序称为*FindNearestMinimum*。
- en: Coding challenge 17 – Word search
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战17 - 单词搜索
- en: '**Amazon**, **Google**'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**'
- en: '`true` if the given word is present on the board. The same letter cell may
    not be used more than once.'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定的单词在板上存在，则返回`true`。同一个字母单元格不能被多次使用。
- en: '**Solution**: Let’s consider that we have the following board:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑一下我们有以下的板：'
- en: '![Figure 14.33 – Board sample'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.33 - 板样本'
- en: '](img/Figure_14.33_B15403.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_14.33_B15403.jpg)'
- en: Figure 14.33 – Board sample
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.33 - 板样本
- en: Remember that this is not the first time where we need to solve a problem that
    requires us to find a certain path in a grid. In [*Chapter 8*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161)*,
    Recursion and Dynamic Programming*, we had the *Robot grid* problems, including
    *Color spots*, *Five Towers*, *The falling ball,* and *Knight tour*. In [*Chapter
    12*](B15403_12_Final_JM_ePub.xhtml#_idTextAnchor276)*, Stacks and Queues*, we
    had *Islands*. Finally, in [*Chapter 13*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*,
    Trees and Graphs*, we had *Chess knight*.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这不是我们第一次需要解决需要在网格中找到某条路径的问题。在[*第8章*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161)*，递归和动态规划*中，我们有*机器人网格*问题，包括*彩色斑点*，*五座塔*，*下落的球*和*骑士之旅*。最后，在[*第12章*](B15403_12_Final_JM_ePub.xhtml#_idTextAnchor276)*，栈和队列*中，我们有*岛屿*。最后，在[*第13章*](B15403_13_Final_JM_ePub.xhtml#_idTextAnchor295)*，树和图*中，我们有*国际象棋骑士*。
- en: Based on the experience you’ve accumulated from these problems, challenge yourself
    to write an implementation for this problem without having any further instructions.
    The complete application is called *WordSearch*. If *k* is the length of the given
    word and the board has a size of *m* x *n*, then this application runs in O(m
    * n * 4k) time.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您从这些问题中积累的经验，挑战自己在没有进一步指示的情况下为这个问题编写一个实现。完整的应用程序称为*WordSearch*。如果*k*是给定单词的长度，而板的大小为*m*
    x *n*，那么此应用程序的运行时间为O(m * n * 4k)。
- en: Coding challenge 18 – Sorting an array based on another array
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战18 - 根据另一个数组对数组进行排序
- en: '**Amazon**, **Google**, **Microsoft**'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**微软**'
- en: '**Problem**: Consider you’ve been given two arrays. Write a snippet of code
    that reorders the elements of the first array according to the order defined by
    the second array.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你已经得到了两个数组。编写一小段代码，根据第二个数组定义的顺序重新排列第一个数组的元素。'
- en: '**Solution**: Let’s consider we’ve been given the following two arrays:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设我们已经得到了以下两个数组：'
- en: '[PRE35]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The expected result is {7, 4, 4, 8, 8, 8, 2, 1, 1, 3, 3, 5, 6, 9}.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果是{7, 4, 4, 8, 8, 8, 2, 1, 1, 3, 3, 5, 6, 9}。
- en: 'The solution to this problem relies on *hashing*. More precisely, we can employ
    the following algorithm:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案依赖于*哈希*。更确切地说，我们可以采用以下算法：
- en: Count and store the frequency of each element from the first array in a map.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算并存储映射中来自第一个数组的每个元素的频率。
- en: For each element of the second array, check if the current element from the
    second array is present in the map or not.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二个数组的每个元素，检查当前元素是否存在于映射中。
- en: 'Then, do the following:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，执行以下操作：
- en: a. If so, then set it *n* times in the first array (*n* is the frequency of
    the current element from the second array in the first array).
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: a. 如果是这样，那么在第一个数组中设置*n*次（*n*是第二个数组中当前元素在第一个数组中的频率）。
- en: b. Remove the current element from the map so that, in the end, the map will
    contain only the elements that are present in the first array but are not present
    in the second array.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: b. 从映射中删除当前元素，这样最终映射中将只包含在第一个数组中存在但不在第二个数组中的元素。
- en: Append the elements from the map to the end of the first array (these are already
    sorted since we used a `TreeSet`).
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将映射中的元素追加到第一个数组的末尾（这些元素已经排序，因为我们使用了`TreeSet`）。
- en: 'Let’s see the code:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码：
- en: '[PRE36]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The runtime of this code is O(m log m + n), where *m* is the number of elements
    in the first array and *n* is the number of elements in the second array. The
    complete application is called *SortArrayBasedOnAnotherArray*.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(m log m + n)，其中*m*是第一个数组中的元素数量，*n*是第二个数组中的元素数量。完整的应用程序称为*SortArrayBasedOnAnotherArray*。
- en: Well, this was the last problem in this chapter. Now, it’s time to summarize
    our work!
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这是本章的最后一个问题。现在，是时候总结我们的工作了！
- en: Summary
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This was a comprehensive chapter that covered sorting and searching algorithms.
    You saw the implementations of Merge Sort, Quick Sort, Radix Sort, Heap Sort,
    Bucket Sort, and Binary Search. Moreover, in the code bundled with this book,
    there’s an application called *SortArraysIn14Ways* that contains the implementations
    of 14 sorting algorithms.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个全面涵盖了排序和搜索算法的章节。您看到了归并排序、快速排序、基数排序、堆排序、桶排序和二分搜索的实现。此外，在本书附带的代码中，还有一个名为*SortArraysIn14Ways*的应用程序，其中包含了14种排序算法的实现。
- en: In the next chapter, we will cover a suite of problems categorized as mathematical
    and puzzle problems.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将涵盖一系列被归类为数学和谜题问题的问题。
