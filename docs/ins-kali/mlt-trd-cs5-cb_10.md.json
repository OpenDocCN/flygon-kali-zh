["```cs\n    using System;\n    using System.Threading;\n    using System.Threading.Tasks;\n    ```", "```cs\n    static async Task ProcessAsynchronously()\n    {\n      var unsafeState = new UnsafeState();\n      Task[] tasks = new Task[4];\n\n      for (int i = 0; i < 4; i++)\n      {\n        tasks[i] = Task.Run(() => Worker(unsafeState));\n      }\n      await Task.WhenAll(tasks);\n      Console.WriteLine(\" --------------------------- \");\n\n      var firstState = new DoubleCheckedLocking();\n      for (int i = 0; i < 4; i++)\n      {\n        tasks[i] = Task.Run(() => Worker(firstState));\n      }\n\n      await Task.WhenAll(tasks);\n      Console.WriteLine(\" --------------------------- \");\n\n      var secondState = new BCLDoubleChecked();\n      for (int i = 0; i < 4; i++)\n      {\n        tasks[i] = Task.Run(() => Worker(secondState));\n      }\n\n      await Task.WhenAll(tasks);\n      Console.WriteLine(\" --------------------------- \");\n\n      var thirdState = new Lazy<ValueToAccess>(Compute);\n      for (int i = 0; i < 4; i++)\n      {\n        tasks[i] = Task.Run(() => Worker(thirdState));\n      }\n\n      await Task.WhenAll(tasks);\n      Console.WriteLine(\" --------------------------- \");\n\n      var fourthState = new BCLThreadSafeFactory();\n      for (int i = 0; i < 4; i++)\n      {\n        tasks[i] = Task.Run(() => Worker(fourthState));\n      }\n\n      await Task.WhenAll(tasks);\n      Console.WriteLine(\" --------------------------- \");\n\n    }\n\n    static void Worker(IHasValue state)\n    {\n      Console.WriteLine(\"Worker runs on thread id {0}\",Thread.CurrentThread.ManagedThreadId);\n      Console.WriteLine(\"State value: {0}\", state.Value.Text);\n    }\n\n    static void Worker(Lazy<ValueToAccess> state)\n    {\n      Console.WriteLine(\"Worker runs on thread id {0}\",Thread.CurrentThread.ManagedThreadId);\n      Console.WriteLine(\"State value: {0}\", state.Value.Text);\n    }\n\n    static ValueToAccess Compute()\n    {\n      Console.WriteLine(\"The value is being constructed on athread id {0}\", Thread.CurrentThread.ManagedThreadId);\n      Thread.Sleep(TimeSpan.FromSeconds(1));\n      return new ValueToAccess(string.Format(\"Constructed on thread id {0}\",Thread.CurrentThread.ManagedThreadId));\n    }\n\n    class ValueToAccess\n    {\n      private readonly string _text; \n      public ValueToAccess(string text)\n      {\n        _text = text;\n      }\n\n      public string Text\n      {\n        get { return _text; }\n      }\n    }\n\n    class UnsafeState : IHasValue\n    {\n      private ValueToAccess _value;\n\n      public ValueToAccess Value\n      {\n        get\n        {\n          if (_value == null)\n          {\n            _value = Compute();\n          }\n          return _value;\n        }\n      }\n\n    }\n\n    class DoubleCheckedLocking : IHasValue\n    {\n      private object _syncRoot = new object();\n      private volatile ValueToAccess _value;\n\n      public ValueToAccess Value\n      {\n        get\n        {\n          if (_value == null)\n          {\n            lock (_syncRoot)\n            {\n              if (_value == null) _value = Compute();\n            }\n          }\n          return _value;\n        }\n      }\n    }\n\n    class BCLDoubleChecked : IHasValue\n    {\n      private object _syncRoot = new object();\n      private ValueToAccess _value;\n      private bool _initialized = false;\n\n      public ValueToAccess Value\n      {\n        get\n        {\n          return LazyInitializer.EnsureInitialized(\n            ref _value, ref _initialized, ref _syncRoot,Compute);\n        }\n      }\n    }\n\n    class BCLThreadSafeFactory : IHasValue\n    {\n      private ValueToAccess _value;\n\n      public ValueToAccess Value\n      {\n        get\n        {\n          return LazyInitializer.EnsureInitialized(ref _value,Compute);\n        }\n      }\n    }\n\n    interface IHasValue\n    {\n      ValueToAccess Value { get; }\n    }\n    ```", "```cs\n    var t = ProcessAsynchronously();\n    t.GetAwaiter().GetResult();\n\n    Console.WriteLine(\"Press ENTER to exit\");\n    Console.ReadLine();\n    ```", "```cs\n    using System;\n    using System.Collections.Concurrent;\n    using System.Linq;\n    using System.Threading;\n    using System.Threading.Tasks;\n    ```", "```cs\n    private const int CollectionsNumber = 4;\n    private const int Count = 10;\n\n    class PipelineWorker<TInput, TOutput>\n    {\n      Func<TInput, TOutput> _processor = null;\n      Action<TInput> _outputProcessor = null;\n      BlockingCollection<TInput>[] _input;\n      CancellationToken _token;\n\n      public PipelineWorker(\n          BlockingCollection<TInput>[] input,\n          Func<TInput, TOutput> processor,\n          CancellationToken token,\n          string name)\n      {\n        _input = input;\n        Output = new BlockingCollection<TOutput>[_input.Length];\n        for (int i = 0; i < Output.Length; i++)\n          Output[i] = null == input[i] ? null : new BlockingCollection<TOutput>(Count);\n\n        _processor = processor;\n        _token = token;\n        Name = name;\n      }\n\n      public PipelineWorker(\n          BlockingCollection<TInput>[] input,\n          Action<TInput> renderer,\n          CancellationToken token,\n          string name)\n      {\n        _input = input;\n        _outputProcessor = renderer;\n        _token = token;\n        Name = name;\n        Output = null;\n      }\n\n      public BlockingCollection<TOutput>[] Output { get; private set; }\n\n      public string Name { get; private set; }\n\n      public void Run()\n      {\n        Console.WriteLine(\"{0} is running\", this.Name);\n        while (!_input.All(bc => bc.IsCompleted) && !_token.IsCancellationRequested)\n        {\n          TInput receivedItem;\n          int i = BlockingCollection<TInput>.TryTakeFromAny(\n              _input, out receivedItem, 50, _token);\n          if (i >= 0)\n          {\n            if (Output != null)\n            {\n              TOutput outputItem = _processor(receivedItem);\n              BlockingCollection<TOutput>.AddToAny(Output,outputItem);\n              Console.WriteLine(\"{0} sent {1} to next,on thread id {2}\", Name, outputItem,Thread.CurrentThread.ManagedThreadId);\n              Thread.Sleep(TimeSpan.FromMilliseconds(100));\n            }\n            else\n            {\n              _outputProcessor(receivedItem);\n            }\n          }\n          else\n          {\n            Thread.Sleep(TimeSpan.FromMilliseconds(50));\n          }\n        }\n        if (Output != null)\n        {\n          foreach (var bc in Output) bc.CompleteAdding();\n        }\n      }\n    }\n    ```", "```cs\n    var cts = new CancellationTokenSource();\n\n    Task.Run(() =>\n    {\n      if (Console.ReadKey().KeyChar == 'c')\n        cts.Cancel();\n    });\n\n    var sourceArrays = new BlockingCollection<int>[CollectionsNumber];\n    for (int i = 0; i < sourceArrays.Length; i++)\n    {\n      sourceArrays[i] = new BlockingCollection<int>(Count);\n    }\n\n    var filter1 = new PipelineWorker<int, decimal>\n    (sourceArrays,\n      (n) => Convert.ToDecimal(n * 0.97),\n      cts.Token,\n      \"filter1\"\n    );\n\n    var filter2 = new PipelineWorker<decimal, string>\n    (filter1.Output,\n      (s) => String.Format(\"--{0}--\", s),\n      cts.Token,\n      \"filter2\"\n      );\n\n    var filter3 = new PipelineWorker<string, string>\n    (filter2.Output,\n      (s) => Console.WriteLine(\"The final result is {0} onthread id {1}\", s,Thread.CurrentThread.ManagedThreadId), cts.Token,\"filter3\");\n\n    try\n    {\n      Parallel.Invoke(\n        () =>\n        {\n          Parallel.For(0, sourceArrays.Length * Count,(j, state) =>\n          {\n            if (cts.Token.IsCancellationRequested)\n            {\n              state.Stop();\n            }\n            int k = BlockingCollection<int>.TryAddToAny(sourceArrays, j);\n            if (k >= 0)\n            {\n              Console.WriteLine(\"added {0} to source data onthread id {1}\", j,Thread.CurrentThread.ManagedThreadId);\n              Thread.Sleep(TimeSpan.FromMilliseconds(100));\n            }\n          });\n          foreach (var arr in sourceArrays)\n          {\n            arr.CompleteAdding();\n          }\n        },\n        () => filter1.Run(),\n        () => filter2.Run(),\n        () => filter3.Run()\n      );\n    }\n    catch (AggregateException ae)\n    {\n      foreach (var ex in ae.InnerExceptions)\n        Console.WriteLine(ex.Message + ex.StackTrace);\n    }\n\n    if (cts.Token.IsCancellationRequested)\n    {\n      Console.WriteLine(\"Operation has been canceled!Press ENTER to exit.\");\n    }\n    else\n    {\n      Console.WriteLine(\"Press ENTER to exit.\");\n    }\n    Console.ReadLine();\n    ```", "```cs\n    using System;\n    using System.Threading;\n    using System.Threading.Tasks;\n    using System.Threading.Tasks.Dataflow;\n    ```", "```cs\n    async static Task ProcessAsynchronously()\n    {\n      var cts = new CancellationTokenSource();\n\n      Task.Run(() =>\n      {\n        if (Console.ReadKey().KeyChar == 'c')\n          cts.Cancel();\n      });\n\n      var inputBlock = new BufferBlock<int>(\n        new DataflowBlockOptions { BoundedCapacity = 5,CancellationToken = cts.Token });\n\n      var filter1Block = new TransformBlock<int, decimal>(\n        n =>\n        {\n          decimal result = Convert.ToDecimal(n * 0.97);\n          Console.WriteLine(\"Filter 1 sent {0} to the nextstage on thread id {1}\", result,Thread.CurrentThread.ManagedThreadId);\n          Thread.Sleep(TimeSpan.FromMilliseconds(100));\n          return result;\n        },\n        new ExecutionDataflowBlockOptions {MaxDegreeOfParallelism = 4, CancellationToken =cts.Token });\n\n      var filter2Block = new TransformBlock<decimal, string>(\n        n =>\n        {\n          string result = string.Format(\"--{0}--\", n);\n          Console.WriteLine(\"Filter 2 sent {0} to the nextstage on thread id {1}\", result,Thread.CurrentThread.ManagedThreadId);\n          Thread.Sleep(TimeSpan.FromMilliseconds(100));\n          return result;\n        },\n        new ExecutionDataflowBlockOptions {\n         MaxDegreeOfParallelism = 4, CancellationToken =cts.Token });\n\n      var outputBlock = new ActionBlock<string>(\n        s =>\n        {\n          Console.WriteLine(\"The final result is {0} on threadid {1}\", s, Thread.CurrentThread.ManagedThreadId);\n        },\n        new ExecutionDataflowBlockOptions {\n          MaxDegreeOfParallelism = 4, CancellationToken =cts.Token });\n\n      inputBlock.LinkTo(filter1Block, new DataflowLinkOptions {PropagateCompletion = true });\n      filter1Block.LinkTo(filter2Block, new DataflowLinkOptions{ PropagateCompletion = true });\n      filter2Block.LinkTo(outputBlock, new DataflowLinkOptions{ PropagateCompletion = true });\n\n      try\n      {\n        Parallel.For(0, 20, new ParallelOptions {MaxDegreeOfParallelism = 4, CancellationToken =cts.Token }\n        , i =>\n        {\n          Console.WriteLine(\"added {0} to source data on threadid {1}\", i, Thread.CurrentThread.ManagedThreadId);\n          inputBlock.SendAsync(i).GetAwaiter().GetResult();\n        });\n        inputBlock.Complete();\n        await outputBlock.Completion;\n        Console.WriteLine(\"Press ENTER to exit.\");\n      }\n      catch (OperationCanceledException)\n      {\n        Console.WriteLine(\"Operation has been canceled!Press ENTER to exit.\");\n      }\n\n      Console.ReadLine();\n    }\n    ```", "```cs\n    var t = ProcessAsynchronously();\n    t.GetAwaiter().GetResult();\n    ```", "```cs\n    using System;\n    using System.Collections.Generic;\n    using System.IO;\n    using System.Linq;\n    ```", "```cs\n    private static readonly char[] delimiters =Enumerable.Range(0, 256).Select(i => (char)i).Where(c =>!char.IsLetterOrDigit(c)).ToArray();\n\n    private const string textToParse = @\"\n    Call me Ishmael. Some years ago - never mind how long precisely - having little or no money in my purse, and nothing particular to interest me on shore, I thought I would sail about a little and see the watery part of the world. It is a way I have of driving off the spleen, and regulating the circulation. Whenever I find myself growing grim about the mouth; whenever it is a damp, drizzly November in my soul; whenever I find myself involuntarily pausing before coffin warehouses, and bringing up the rear of every funeral I meet; and especially whenever my hypos get such an upper hand of me, that it requires a strong moral principle to prevent me from deliberately stepping into the street, and methodically knocking people's hats off - then, I account it high time to get to sea as soon as I can.\n\n    \u2015 Herman Melville, Moby Dick.\n    \";\n    ```", "```cs\n    var q = textToParse.Split(delimiters)\n      .AsParallel()\n      .MapReduce(\n        s => s.ToLower().ToCharArray()\n      , c => c\n      , g => new[] {new {Char = g.Key, Count = g.Count()}})\n      .Where(c => char.IsLetterOrDigit(c.Char))\n      .OrderByDescending( c => c.Count);\n\n    foreach (var info in q)\n    {\n      Console.WriteLine(\"Character {0} occured in the text {1}{2}\", info.Char, info.Count, info.Count == 1 ? \"time\" : \"times\");\n    }\n    Console.WriteLine(\" -------------------------------------------\");\n    const string searchPattern = \"en\";\n\n    var q2 = textToParse.Split(delimiters)\n      .AsParallel()\n      .Where(s => s.Contains(searchPattern))\n      .MapReduce(\n        s => new [] {s}\n        , s => s\n        , g => new[] {new {Word = g.Key, Count = g.Count()}})\n      .OrderByDescending(s => s.Count);\n\n    Console.WriteLine(\"Words with search pattern '{0}':\",searchPattern);\n    foreach (var info in q2)\n    {\n      Console.WriteLine(\"{0} occured in the text {1} {2}\",info.Word, info.Count,\n        info.Count == 1 ? \"time\" : \"times\");\n    }\n\n    int halfLengthWordIndex = textToParse.IndexOf(' ',textToParse.Length/2);\n\n    using(var sw = File.CreateText(\"1.txt\"))\n    {\n      sw.Write(textToParse.Substring(0, halfLengthWordIndex));\n    }\n\n    using(var sw = File.CreateText(\"2.txt\"))\n    {\n      sw.Write(textToParse.Substring(halfLengthWordIndex));\n    }\n\n    string[] paths = new[] { \".\\\\\" };\n\n    Console.WriteLine(\" ------------------------------------------------\");\n    var q3 = paths\n      .SelectMany(p => Directory.EnumerateFiles(p, \"*.txt\"))\n      .AsParallel()\n      .MapReduce(\n        path => File.ReadLines(path).SelectMany(line =>line.Trim(delimiters).Split(delimiters)),word => string.IsNullOrWhiteSpace(word) ? '\\t' :word.ToLower()[0], g => new [] { new {FirstLetter = g.Key, Count = g.Count()}})\n      .Where(s => char.IsLetterOrDigit(s.FirstLetter))\n      .OrderByDescending(s => s.Count);\n\n    Console.WriteLine(\"Words from text files\");\n\n    foreach (var info in q3)\n    {\n      Console.WriteLine(\"Words starting with letter '{0}'occured in the text {1} {2}\", info.FirstLetter,info.Count,\n        info.Count == 1 ? \"time\" : \"times\");\n    }\n    ```", "```cs\n    static class PLINQExtensions\n    {\n      public static ParallelQuery<TResult> MapReduce<TSource,TMapped, TKey, TResult>(\n        this ParallelQuery<TSource> source,\n        Func<TSource, IEnumerable<TMapped>> map,\n        Func<TMapped, TKey> keySelector,\n        Func<IGrouping<TKey, TMapped>,\n        IEnumerable<TResult>> reduce)\n      {\n        return source.SelectMany(map)\n        .GroupBy(keySelector)\n        .SelectMany(reduce);\n      }\n    }\n    ```"]