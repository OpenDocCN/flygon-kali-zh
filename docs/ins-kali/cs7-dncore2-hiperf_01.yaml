- en: What's New in .NET Core 2 and C# 7?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core 2和C# 7中的新功能是什么？
- en: .NET Core is a development platform by Microsoft that runs cross-platform and
    is maintained by Microsoft and the community at GitHub. It is the most emergent
    and popular framework in development communities due to its performance and platform
    portability. It targets every developer that can develop any application for any
    platform that includes web, cloud, mobile, embedded, and IoT scenarios.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core是微软的一个跨平台开发平台，由微软和GitHub社区维护。由于其性能和平台可移植性，它是开发社区中最新兴和最受欢迎的框架。它面向每个开发人员，可以为包括Web、云、移动、嵌入式和物联网在内的任何平台开发任何应用程序。
- en: With .NET Core, we can develop applications using C#, F#, and now VB.NET as
    well. However, C# is the most widely used language among developers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用.NET Core，我们可以使用C#、F#，现在也可以使用VB.NET。然而，C#是开发人员中最广泛使用的语言。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: Performance improvements in .NET Core 2.0
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 2.0中的性能改进
- en: Upgrading the path from .NET Core 1.x to 2.0
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从.NET Core 1.x升级到2.0的路径
- en: .NET Standard 2.0
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET标准2.0
- en: What comes with ASP.NET Core 2.0
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core 2.0带来了什么
- en: New features in C# 7.0
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 7.0中的新功能
- en: Evolution of .NET
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET的演变
- en: In early 2002, when Microsoft first introduced the .NET Framework, it targeted
    developers who were working on classic ASP or VB 6 platforms since they didn't
    have any compelling framework for developing enterprise-level applications. With
    the release of the .NET Framework, developers had a platform to develop applications
    and could choose any of the languages from VB.NET, C#, and F#. Irrespective of
    the language chosen, the code is interoperable, and developers can create a project
    with VB.NET and reference it in their C# or F# project and vice versa.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在2002年初，当微软首次推出.NET Framework时，它面向的是那些在经典ASP或VB 6平台上工作的开发人员，因为他们没有任何引人注目的框架来开发企业级应用程序。随着.NET
    Framework的发布，开发人员有了一个可以选择VB.NET、C#和F#中的任何一种语言来开发应用程序的平台。无论选择哪种语言，代码都是可互操作的，开发人员可以创建一个VB.NET项目并在其C#或F#项目中引用它，反之亦然。
- en: The core component of .NET Framework includes **Common Language Runtime** (**CLR**),
    **Framework Class Libraries** (**FCL**), **Base Class Libraries** (**BCL**), and
    a set of application models. New features and patches have been introduced with
    the newer version of the .NET Framework, which comes with the new release of Windows,
    and developers have had to wait for a year or so to get those improvements. Every
    team at Microsoft worked on a different application model, and each team had to
    wait for the date when the new framework was released to port their fixes and
    improvements. Windows Forms and Web Forms were the primary application models
    at that time that were widely used by .NET developers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Framework的核心组件包括**公共语言运行时**（**CLR**）、**框架类库**（**FCL**）、**基类库**（**BCL**）和一组应用程序模型。随着新版本的.NET
    Framework的推出，新功能和补丁也随之引入，这些新功能和补丁通常随着Windows的新版本一起发布，开发人员必须等待一年左右才能获得这些改进。微软的每个团队都在不同的应用程序模型上工作，每个团队都必须等待新框架发布的日期来移植他们的修复和改进。当时主要使用的应用程序模型是Windows
    Forms和Web Forms。
- en: When Web Forms was first introduced, it was a breakthrough which attracted both
    web developers who worked on Classic ASP and desktop application developers who
    worked on Visual Basic 6.0\. The developer experience was appealing and provided
    a decent set of controls that could easily be dragged and dropped to the screen,
    followed to their events and properties that could be set either through the view
    file (`.aspx`) or code-behind files. Later on, Microsoft introduced the **Model
    View Controller** (**MVC**) application model that implemented the separation
    of concerns design principle, so that View, Model, and Controller are separate
    entities. The View is the user interface that renders the Model, where the Model
    represents the business entity and holds the data, and the Controller that handles
    the request and updates the model and injects it into the View. MVC was a breakthrough
    that let developers write cleaner code and bind their model with the HTML controls
    using model binding. With the passage of time, more features were added and the
    core .NET web assembly `System.Web` became quite big and bloated, and contained
    lots of packages and APIs that were not always useful in every type of application.
    However, with .NET, several groundbreaking changes were introduced and `System.Web`
    got split into NuGet packages that can be referenced and added individually based
    on requirements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当Web Forms首次推出时，它是一个突破，吸引了既在经典ASP上工作的Web开发人员，又在Visual Basic 6.0上工作的桌面应用程序开发人员。开发人员体验非常吸引人，并提供了一套不错的控件，可以轻松地拖放到屏幕上，然后跟随它们的事件和属性，这些属性可以通过视图文件（`.aspx`）或代码后台文件进行设置。后来，微软推出了**模型视图控制器**（**MVC**）应用程序模型，实现了关注点分离设计原则，因此视图、模型和控制器是独立的实体。视图是呈现模型的用户界面，模型代表业务实体并保存数据，控制器处理请求并更新模型，并将其注入视图。MVC是一个突破，让开发人员编写更干净的代码，并使用模型绑定将其模型与HTML控件绑定。随着时间的推移，添加了更多功能，核心.NET
    web程序集`System.Web`变得非常庞大，包含了许多包和API，这些API并不总是在每种类型的应用程序中都有用。然而，随着.NET的推出，引入了一些重大变化，`System.Web`被拆分为NuGet包，可以根据需求引用和单独添加。
- en: '.NET Core (codename .NET vNext) was first introduced in 2014, and the following
    are the core benefits of using .NET Core:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core（代号.NET vNext）首次在2014年推出，以下是使用.NET Core的核心优势：
- en: '| **Benefit** | **Description** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **好处** | **描述** |'
- en: '| **Cross Platform** | .NET Core can run on Windows, Linux, and macOS |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| **跨平台** | .NET Core可以在Windows、Linux和macOS上运行 |'
- en: '| **Host Agnostic** | .NET Core on the server side is not dependent on IIS
    and, with two lightweight servers, *Kestrel* and *WebListener*, it can be self-hosted
    as a Console application and can be also gelled with mature servers such as IIS,
    Apache, and others through a reverse proxy option |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **主机无关** | .NET Core在服务器端不依赖于IIS，并且可以作为控制台应用程序进行自托管，并且可以通过反向代理选项与成熟的服务器（如IIS、Apache等）结合使用，还有两个轻量级服务器*Kestrel*和*WebListener*
    |'
- en: '| **Modular** | Ships as NuGet packages |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **模块化** | 以NuGet包的形式发布 |'
- en: '| **Open Source** | The entire source code is released as open source via the
    .NET Foundation |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **开源** | 整个源代码通过.NET基金会作为开源发布 |'
- en: '| **CLI tooling** | Command line tools to create, build, and run projects from
    the command line |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **CLI工具** | 用于从命令行创建、构建和运行项目的命令行工具 |'
- en: '.NET Core is a cross-platform, open-source framework that implements .NET Standard.
    It provides a runtime known as .NET Core CLR, framework class libraries, which
    are primitive libraries known as *CoreFX,* and APIs that are similar to what .NET
    Framework has, but have a smaller footprint (lesser dependencies on other assemblies):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core是一个跨平台的开源框架，实现了.NET标准。它提供了一个称为.NET Core CLR的运行时，框架类库，即称为*CoreFX*的基本库，以及类似于.NET
    Framework的API，但依赖较少（对其他程序集的依赖较少）：
- en: '![](img/00005.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00005.jpeg)'
- en: '.NET Core provides flexible deployment options as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core提供了以下灵活的部署选项：
- en: '**Framework-Dependent Deployment (FDD)**: needs .NET Core SDK to be installed
    on the machine'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于框架的部署（FDD）**：需要在机器上安装.NET Core SDK'
- en: '**Self-Contained Deployment (SCD)**: No machine-wide installation of .NET Core
    SDK is needed on the machine and .NET Core CLR and framework class libraries are
    part of the application package'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自包含部署（SCD）**：在机器上不需要安装.NET Core SDK，.NET Core CLR和框架类库是应用程序包的一部分'
- en: To install .NET Core 2.0, you can navigate to the following link [https://www.microsoft.com/net/core](https://www.microsoft.com/net/core)
    and go through the options for installing it on Windows, Linux, MAC, and Docker.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装.NET Core 2.0，您可以转到以下链接[https://www.microsoft.com/net/core](https://www.microsoft.com/net/core)并查看在Windows、Linux、MAC和Docker上安装的选项。
- en: New improvements in .NET Core 2.0
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core 2.0的新改进
- en: The most recent version of .NET Core, 2.0, comes with a number of improvements.
    .NET Core 2.0 is the fastest version of all times and can run on multiple platforms
    including various Linux distros, macOS (operating system), and Windows.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最新版本的.NET Core，2.0，带来了许多改进。.NET Core 2.0是有史以来最快的版本，可以在包括各种Linux发行版、macOS（操作系统）和Windows在内的多个平台上运行。
- en: Distros stands for Linux distribution (often abbreviated as distro), and it
    is an operating system made from a software collection, which is based upon the
    Linux kernel and, often, a package management system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Distros代表Linux发行版（通常缩写为distro），它是基于Linux内核和通常是一个软件集合的操作系统。
- en: Performance improvements
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能改进
- en: .NET Core is more robust and performance efficient and, since it's open source,
    the Microsoft team with other community members are bringing more improvements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core更加健壮和高性能，并且由于其开源，微软团队与其他社区成员正在带来更多的改进。
- en: The following are the improvements that are part of .NET Core 2.0.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是.NET Core 2.0的改进部分。
- en: RyuJIT compiler in .NET Core
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core中的RyuJIT编译器
- en: RyuJIT is a next-generation JIT compiler that is a complete rewrite of the **Just
    In Time** (**JIT**) compiler and generates a lot more efficient native machine
    code. It is twice as fast as the previous 64-bit compiler and provides 30% faster
    compilation. Initially, it runs on only X64 architectures, but now it supports
    X86 as well and developers can use the RyuJIT compiler for both X64 and X86\.
    .NET Core 2.0 uses RyuJIT for both X86 and X64 platforms.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: RyuJIT是一种全新的JIT编译器，是对**即时**（**JIT**）编译器的完全重写，并生成更高效的本机机器代码。它比之前的64位编译器快两倍，并提供30%更快的编译速度。最初，它只在X64架构上运行，但现在也支持X86，开发人员可以同时为X64和X86使用RyuJIT编译器。.NET
    Core 2.0在X86和X64平台上都使用RyuJIT。
- en: Profile guided optimization
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于配置文件的优化
- en: '**Profile-guided optimization** (**PGO**) is a compilation technology used
    by C++ compiler to generate optimized code. It applies to the internal native
    compiled components of the runtime and JIT. It performs compilation in two steps,
    which are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于配置文件的优化**（**PGO**）是C++编译器使用的一种编译技术，用于生成优化的代码。它适用于运行时和JIT的内部本机编译组件。它分两步进行编译，如下所示：'
- en: It records the information about code execution.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它记录了有关代码执行的信息。
- en: From this information, it generates better code.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据这些信息，它生成了更好的代码。
- en: 'The following diagram depicts the life cycle of how the code is compiled:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了代码的编译生命周期：
- en: '![](img/00006.gif)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00006.gif)'
- en: In .NET Core 1.1, Microsoft already released the PGO for Windows X64 architecture,
    but in .NET Core 2.0, this has been added for both Windows X64 and X86 architectures.
    Also, as per observatory results, it was noted that the actual startup time is
    mostly taken by `coreclr.dll` and `clrjit.dll` for Windows. Alternatively, on
    Linux, there are `libcoreclr.so` and `libclrjit.so`, respectively.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core 1.1中，微软已经为Windows X64架构发布了PGO，但在.NET Core 2.0中，这已经添加到了Windows X64和X86架构。此外，根据观察结果，实际的启动时间主要由Windows的`coreclr.dll`和`clrjit.dll`占用。而在Linux上，分别是`libcoreclr.so`和`libclrjit.so`。
- en: Comparing RyuJIT with the old JIT compiler known as JIT32, RyuJIT is more efficient
    in code generation. The startup time of the JIT32 was faster than the RyuJIT;
    however, the code is not efficient. To overcome the initial startup time taken
    by the RyuJIT compiler, Microsoft used PGO, which brought the performance closer
    to JIT32 performance and achieved both efficient code and performance on startup.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将RyuJIT与旧的JIT编译器JIT32进行比较，RyuJIT在代码生成方面更加高效。JIT32的启动时间比RyuJIT快，但代码效率不高。为了克服RyuJIT编译器的初始启动时间，微软使用了PGO，这使得性能接近JIT32的性能，并在启动时实现了高效的代码和性能。
- en: For Linux, the compiler toolchain is different for each distro, and Microsoft
    is working on a separate Linux version of .NET that uses the PGO optimizations
    applicable to all distros.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Linux，每个发行版的编译器工具链都不同，微软正在开发一个单独的Linux版本的.NET，该版本使用适用于所有发行版的PGO优化。
- en: Simplified packaging
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化的打包
- en: With .NET Core, we can add libraries to our project from NuGet. All framework
    and third-party libraries can be added as NuGet packages. With a large sized application
    that refers many libraries, adding each library one by one is a cumbersome process.
    .NET Core 2.0 has simplified the packaging mechanism and introduced meta-packages
    that can be added as one single package that contains all the assemblies that
    are linked to it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 使用.NET Core，我们可以从NuGet向我们的项目添加库。所有框架和第三方库都可以作为NuGet包添加。对于引用了许多库的大型应用程序，逐个添加每个库是一个繁琐的过程。.NET
    Core 2.0简化了打包机制，并引入了可以作为一个单一包添加的元包，其中包含了所有与之链接的程序集。
- en: For example, if you wanted to work on ASP.NET Core in .NET Core 2.0, you just
    have to add one single package, `Microsoft.AspNetCore.All`, using NuGet.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想在.NET Core 2.0中使用ASP.NET Core，你只需要添加一个单一的包`Microsoft.AspNetCore.All`，使用NuGet。
- en: 'The following is the command that will install this package into your project:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将此包安装到你的项目中的命令：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Upgrading path from .NET Core 1.x to 2.0
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从.NET Core 1.x升级到2.0的路径
- en: .NET Core 2.0 comes with lots of improvements, and this is the primary reason
    people wanted to migrate their existing .NET Core applications from 1.x to 2.0\.
    However, there is a checklist which we will go through in this topic to ensure
    smooth migration.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 2.0带来了许多改进，这是人们想要将他们现有的.NET Core应用程序从1.x迁移到2.0的主要原因。然而，在这个主题中，我们将通过一个清单来确保平稳迁移。
- en: 1\. Install .NET Core 2.0
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1\. 安装.NET Core 2.0
- en: First of all, install the .NET Core 2.0 SDK on your machine. It will install
    the latest assemblies to your machine, which will help you to execute further
    steps.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的机器上安装.NET Core 2.0 SDK。它将在你的机器上安装最新的程序集，这将帮助你执行后续步骤。
- en: 2\. Upgrade TargetFramework
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2\. 升级TargetFramework
- en: This is the most important step, and this is where the different versions need
    to be upgraded in the .NET Core project file. Since we know that, with the `.csproj`
    type, we don't have `project.json`, to modify the framework and other dependencies,
    we can edit the existing project using any Visual Studio editor and modify the
    XML.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最重要的一步，也是需要在.NET Core项目文件中升级不同版本的地方。由于我们知道，对于`.csproj`类型，我们没有`project.json`，要修改框架和其他依赖项，我们可以使用任何Visual
    Studio编辑器编辑现有项目并修改XML。
- en: 'The XML Node that needs to be changed is the `TargetFramework`. For .NET Core
    2.0, we have to change the `TargetFramework` moniker to `netcoreapp2.0`, which
    is shown as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 需要更改的XML节点是`TargetFramework`。对于.NET Core 2.0，我们需要将`TargetFramework`修改为`netcoreapp2.0`，如下所示：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, you can start building the project which will upgrade the .NET Core dependencies
    to 2.0\. However, there is a chance of a few of them still referencing the older
    version, and upgrading those dependencies needs to be done explicitly using NuGet
    package manager.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以开始构建项目，这将升级.NET Core依赖项到2.0。然而，仍然有一些可能仍然引用旧版本的依赖项，需要使用NuGet包管理器显式地进行升级。
- en: 3\. Update .NET Core SDK version
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3\. 更新.NET Core SDK版本
- en: 'If you have `global.json` added to your project, you have to update the SDK
    version to `2.0.0`, which is shown as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的项目中已经添加了`global.json`，你需要将SDK版本更新为`2.0.0`，如下所示：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 4\. Update .NET Core CLI
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 更新.NET Core CLI
- en: '.NET Core CLI is also an important section in your .NET Core project file.
    When migrating, you have to upgrade the version of `DotNetCliToolReference` to
    `2.0.0`, which is shown as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core CLI也是你的.NET Core项目文件中的一个重要部分。在迁移时，你需要将`DotNetCliToolReference`的版本升级到`2.0.0`，如下所示：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There might be more tools added depending on whether you are using Entity Framework
    Core, User Secrets, and others. You have to update their versions.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你是否使用Entity Framework Core、User Secrets等，可能会添加更多的工具。你需要更新它们的版本。
- en: Changes in ASP.NET Core Identity
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core Identity的更改
- en: 'There have been some more improvements and changes to the ASP.NET Core Identity
    model. Some of the classes are renamed and you can find them at: [http://docs.microsoft.com/en-us/aspnet/core/migration](http://docs.microsoft.com/en-us/aspnet/core/migration).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core Identity模型已经进行了一些改进和更改。一些类已经更名，你可以在以下链接找到它们：[http://docs.microsoft.com/en-us/aspnet/core/migration](http://docs.microsoft.com/en-us/aspnet/core/migration)。
- en: Exploring .NET Core CLI and New Project Templates
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索.NET Core CLI和新项目模板
- en: '**Command Line Interface** (**CLI**) is a very popular tool is almost all popular
    frameworks like Yeoman Generator, Angular, and others. It lends developers access
    to execute commands to create, build, and run projects, restore packages, and
    so on.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令行界面**（**CLI**）是一个非常流行的工具，几乎在所有流行的框架中都有，比如Yeoman Generator，Angular等。它使开发人员能够执行命令来创建、构建和运行项目，恢复包等。'
- en: '.NET CLI provides a toolset with a handful commands that can be executed from
    the command line interface to create .NET Core projects, restore dependencies,
    and build and run projects. Under the wire, Visual Studio 2015/2017 and Visual
    Studio Code even uses this tool to perform different options taken by the developers
    from their IDE; for example, to create a new project using .NET CLI, we can run
    the following command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: .NET CLI提供了一组命令，可以从命令行界面执行，用于创建.NET Core项目，恢复依赖项，构建和运行项目。在幕后，Visual Studio 2015/2017和Visual
    Studio Code甚至使用这个工具来执行开发人员从他们的IDE中采取的不同选项；例如，要使用.NET CLI创建一个新项目，我们可以运行以下命令：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It will list down the available templates and the short name that can be used
    while creating the project.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它将列出可用的模板和在创建项目时可以使用的简称。
- en: 'Here is the screenshot containing the list of project templates that can be
    used to create/scaffold projects using .NET Core CLI:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包含可以使用.NET Core CLI创建/脚手架项目的项目模板列表的屏幕截图：
- en: '![](img/00007.gif)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00007.gif)'
- en: 'And by running the following command, a new ASP.NET Core MVC application will
    be created:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令，将创建一个新的ASP.NET Core MVC应用程序：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following screenshot shows the provisioning of the new MVC project after
    running the preceding command. It creates the project in the same directory where
    the command is running and restores all the dependencies:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在运行上述命令后新的 MVC 项目的配置。它在运行命令的同一目录中创建项目并恢复所有依赖项：
- en: '![](img/00008.gif)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00008.gif)'
- en: To install the .NET Core CLI toolset, there are some native installers available
    for Windows, Linux, and macOS. These installers can install and set up the .NET
    CLI tooling on your machine and developers can run the commands from the CLI.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 .NET Core CLI 工具集，有一些适用于 Windows、Linux 和 macOS 的本机安装程序可用。这些安装程序可以在您的计算机上安装和设置
    .NET CLI 工具，并且开发人员可以从 CLI 运行命令。
- en: 'Here is the list of commands with their descriptions that are provided in the
    .NET Core CLI:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是提供在 .NET Core CLI 中的命令及其描述的列表：
- en: '| **Command** | **Description** | **Example** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** | **示例** |'
- en: '| `new` | Creates a new project based on the template selected | `dotnet new
    razor` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `new` | 根据所选模板创建新项目 | `dotnet new razor` |'
- en: '| `restore` | Restores all the dependencies defined in the project | `dotnet
    restore` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `restore` | 恢复项目中定义的所有依赖项 | `dotnet restore` |'
- en: '| `build` | Builds the project | `dotnet build` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `build` | 构建项目 | `dotnet build` |'
- en: '| `run` | Runs the source code without any additional compile | `dotnet run`
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `run` | 在不进行任何额外编译的情况下运行源代码 | `dotnet run` |'
- en: '| `publish` | Packages the application files into a folder for deployment |
    `dotnet publish` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `publish` | 将应用程序文件打包到一个文件夹中以进行部署 | `dotnet publish` |'
- en: '| `test` | Used to execute unit tests | `dotnet test` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `test` | 用于执行单元测试 | `dotnet test` |'
- en: '| `vstest` | Executes unit tests from specified files | `dotnet vstest [<TEST_FILE_NAMES>]`
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `vstest` | 执行指定文件中的单元测试 | `dotnet vstest [<TEST_FILE_NAMES>]` |'
- en: '| `pack` | Packs the code into a NuGet package | `dotnet pack` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `pack` | 将代码打包成 NuGet 包 | `dotnet pack` |'
- en: '| `migrate` | Migrates .NET Core preview 2 to .NET Core 1.0 | `dotnet migrate`
    |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `migrate` | 将 .NET Core 预览 2 迁移到 .NET Core 1.0 | `dotnet migrate` |'
- en: '| `clean` | Cleans the output of the project | `dotnet clean` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `clean` | 清理项目的输出 | `dotnet clean` |'
- en: '| `sln` | Modifies a .NET Core solution | `dotnet sln` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `sln` | 修改 .NET Core 解决方案 | `dotnet sln` |'
- en: '| `help` | Displays the list of commands available to execute through .NET
    CLI | `dotnet help` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `help` | 显示可通过 .NET CLI 执行的命令列表 | `dotnet help` |'
- en: '| `store` | Stores the specified assemblies in the runtime package store |
    `dotnet store` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `store` | 将指定的程序集存储在运行时包存储中 | `dotnet store` |'
- en: 'Here are some of the project level commands that can be used to add a new NuGet
    package, remove an existing one, list references, and others:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是一些项目级别的命令，可用于添加新的 NuGet 包、删除现有的 NuGet 包、列出引用等： '
- en: '| **Command** | **Description** | **Example** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** | **示例** |'
- en: '| `add package` | Adds a package reference to the project | `dotnet add package
    Newtonsoft.Json` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `add package` | 向项目添加包引用 | `dotnet add package Newtonsoft.Json` |'
- en: '| `remove package` | Removes a package reference from the project | `dotnet
    remove package Newtonsoft.Json` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `remove package` | 从项目中删除包引用 | `dotnet remove package Newtonsoft.Json` |'
- en: '| `add reference` | Adds a project reference to the project | `dotnet add reference
    chapter1/proj1.csproj` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `add reference` | 向项目添加项目引用 | `dotnet add reference chapter1/proj1.csproj`
    |'
- en: '| `remove reference` | Removes the project reference from the project | `dotnet
    remove reference chapter1/proj1.csproj` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `remove reference` | 从项目中删除项目引用 | `dotnet remove reference chapter1/proj1.csproj`
    |'
- en: '| `list reference` | List down all the project references in the project |
    `dotnet list reference` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `list reference` | 列出项目中的所有项目引用 | `dotnet list reference` |'
- en: The following are some common Entity Framework Core commands that can be used
    to add migration, remove migration, update the database, and so on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的 Entity Framework Core 命令，可用于添加迁移、删除迁移、更新数据库等。
- en: '| **Command** | **Description** | **Example** |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** | **示例** |'
- en: '| `dotnet ef migrations add` | Adds a new migration | `dotnet ef migrations
    add Initial`- `Initial` is the name of migration |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet ef migrations add` | 添加新的迁移 | `dotnet ef migrations add Initial`-
    `Initial` 是迁移的名称 |'
- en: '| `dotnet ef migrations list` | List available migrations | `dotnet ef migrations
    list` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet ef migrations list` | 列出可用的迁移 | `dotnet ef migrations list` |'
- en: '| `dotnet ef migrations remove` | Remove specific migration | `dotnet ef migrations
    remove Initial`- `Initial` is the name of migration |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet ef migrations remove` | 删除特定的迁移 | `dotnet ef migrations remove Initial`-
    `Initial` 是迁移的名称 |'
- en: '| `dotnet ef database update` | To update the database to a specified migration
    | `dotnet ef database update Initial`- `Initial` is the name of migration |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet ef database update` | 将数据库更新到指定的迁移 | `dotnet ef database update Initial`-
    `Initial` 是迁移的名称 |'
- en: '| `dotnet ef database drop` | Drops the database | `dotnet ef database drop`
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet ef database drop` | 删除数据库 | `dotnet ef database drop` |'
- en: 'Here are some of the server level commands that can be used to delete the NuGet
    package from its actual source repository from the machine, add NuGet package
    into its actual source repository on the machine, and so on:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些服务器级别的命令，可用于从机器中删除 NuGet 包的实际源存储库，将 NuGet 包添加到机器上的实际源存储库等：
- en: '| **Command** | **Description** | **Example** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** | **示例** |'
- en: '| `nuget delete` | Deletes the package from the server | `dotnet nuget delete
    Microsoft.AspNetCore.App 2.0` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `nuget delete` | 从服务器中删除包 | `dotnet nuget delete Microsoft.AspNetCore.App
    2.0` |'
- en: '| `nuget push` | Pushes a package to the server and publishes it | `dotnet
    nuget push foo.nupkg` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `nuget push` | 将包推送到服务器并发布 | `dotnet nuget push foo.nupkg` |'
- en: '| `nuget locals` | Lists the local NuGet resources | `dotnet nuget locals -l
    all` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `nuget locals` | 列出本地 NuGet 资源 | `dotnet nuget locals -l all` |'
- en: '| `msbuild` | Builds a project and all of its dependencies | `dotnet msbuild`
    |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `msbuild` | 构建项目及其所有依赖项 | `dotnet msbuild` |'
- en: '| `dotnet install script` | The script to install the .NET CLI tools and the
    shared runtime | `./dotnet-install.ps1 -Channel LTS` |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet install script` | 用于安装 .NET CLI 工具和共享运行时的脚本 | `./dotnet-install.ps1
    -Channel LTS` |'
- en: 'To run the preceding commands, we can use the tool known as dotnet from the
    command line and specify the actual command followed by that. When the .NET Core
    CLI is installed, it is set into the PATH variable in Windows OS and can be accessed
    from any folder. So, for example, if you are at your project root folder and wanted
    to restore the dependencies, you can just call the following command and it will
    restore all the dependencies that have been defined in your project file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行上述命令，我们可以使用命令行中的名为dotnet的工具，并指定实际命令，然后跟随其后。当安装了.NET Core CLI时，它会设置到Windows
    OS的PATH变量中，并且可以从任何文件夹访问。因此，例如，如果您在项目根文件夹中并且想要恢复依赖关系，您只需调用以下命令，它将恢复在项目文件中定义的所有依赖项：
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding command will start restoring the dependencies or project-specific
    tools, as defined in the project file. The restoration of tools and dependencies
    are done in parallel:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将开始恢复项目文件中定义的依赖项或特定于项目的工具。工具和依赖项的恢复是并行进行的：
- en: '![](img/00009.gif)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00009.gif)'
- en: We can also set the path where packages can be restored by using the `--packages`
    argument. However, if this is not specified, it uses the `.nuget/packages` folder
    under the system's user folder. For example, the default NuGet folder for Windows
    OS is `{systemdrive}:\Users\{user}\.nuget\packages` and `/home/{user}` for Linux
    OS, respectively.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`--packages`参数设置包的恢复路径。但是，如果未指定此参数，则使用系统用户文件夹下的`.nuget/packages`文件夹。例如，Windows
    OS的默认NuGet文件夹是`{systemdrive}:\Users\{user}\.nuget\packages`，Linux OS分别是`/home/{user}`。
- en: Understanding .NET Standard
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解.NET标准
- en: In the .NET ecosystem, there are many runtimes. We have the .NET Framework,
    which is a full machine-wide framework installed on the Windows operating system
    and provides app models for **Windows Presentation Foundation** (**WPF**), Windows
    Forms, and ASP.NET. Then, we have .NET Core, which is targeted at cross-platform
    operating systems and devices and provides ASP.NET Core, **Universal Windows Platform**
    (**UWP**), and a Mono runtime that is targeted at Xamarin applications and developers
    who can use Mono runtime to develop applications on Xamarin and run on iOS, Android,
    and Windows OS.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET生态系统中，有许多运行时。我们有.NET Framework，这是安装在Windows操作系统上的全面机器范围框架，并为**Windows Presentation
    Foundation**（**WPF**）、Windows Forms和ASP.NET提供应用程序模型。然后，我们有.NET Core，它针对跨平台操作系统和设备，并提供ASP.NET
    Core、**Universal Windows Platform**（**UWP**）和针对Xamarin应用程序的Mono运行时，开发人员可以使用Mono运行时在Xamarin上开发应用程序，并在iOS、Android和Windows
    OS上运行。
- en: 'The following diagram depicts how the .NET Standard Library provides an abstraction
    of .NET Framework, .NET Core, and Xamarin with the common building blocks:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了.NET标准库如何提供.NET Framework、.NET Core和Xamarin的公共构建块的抽象：
- en: '![](img/00010.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: All of these runtimes implement an interface known as .NET Standard, where .NET
    Standard is the specification of .NET APIs that have the implementation for each
    runtime. This makes your code portable across different platforms. This means
    the code created for one runtime can also be executed by another runtime. .NET
    Standard is the next generation of **Portable Class Libraries** (**PCL**) we used
    earlier. Just to recap, PCL is a class library that targets one or more frameworks
    of .NET. When creating a PCL, we can select the target frameworks where this library
    needs to be used, and it minimizes the assemblies and uses only those that are
    common to all frameworks.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些运行时都实现了一个名为.NET标准的接口，其中.NET标准是每个运行时的.NET API规范的实现。这使得您的代码可以在不同的平台上移植。这意味着为一个运行时创建的代码也可以由另一个运行时执行。.NET标准是我们之前使用的**可移植类库**（**PCL**）的下一代。简而言之，PCL是一个针对.NET的一个或多个框架的类库。创建PCL时，我们可以选择需要使用该库的目标框架，并最小化程序集并仅使用所有框架通用的程序集。
- en: 'The .NET Standard is not an API or executable that can be downloaded or installed.
    It is a specification that defines the API that each platform implements. Each
    runtime version implements a specific .NET Standard version. The following table
    shows the versions of .NET Standard each platform implements:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: .NET标准不是可以下载或安装的API或可执行文件。它是一个规范，定义了每个平台实现的API。每个运行时版本实现特定的.NET标准版本。以下表格显示了每个平台实现的.NET标准版本：
- en: '![](img/00011.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: We can see that .NET Core 2.0 implements .NET Standard 2.0 and that .NET Framework
    4.5 implements .NET Standard 1.1., so for example, if we have a class library
    developed on .NET Framework 4.5, this can easily be added into the .NET Core project
    because it implements a greater version of .NET Standard. On the other hand, if
    we wanted to reference the .NET Core assembly into .NET Framework 4.5, we can
    do so by changing the .NET Standard version to 1.1 without recompiling and building
    our project.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到.NET Core 2.0实现了.NET标准2.0，而.NET Framework 4.5实现了.NET标准1.1。因此，例如，如果我们有一个在.NET
    Framework 4.5上开发的类库，这可以很容易地添加到.NET Core项目中，因为它实现了一个更高版本的.NET标准。另一方面，如果我们想要将.NET
    Core程序集引用到.NET Framework 4.5中，我们可以通过将.NET标准版本更改为1.1来实现，而无需重新编译和构建我们的项目。
- en: 'As we learned, the basic idea of .NET Standard is to share code between different
    runtimes, but how it differs from PCL is shown as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所了解的，.NET标准的基本理念是在不同的运行时之间共享代码，但它与PCL的不同之处如下所示：
- en: '| **Portable Class Library (PCL)** | **.NET Standard** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **可移植类库（PCL）** | **.NET标准** |'
- en: '| Represents the Microsoft platform and targets a limited set of platforms
    | Agnostic to platform |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: 代表着微软平台并针对一组有限的平台 | 不受平台限制 |
- en: '| APIs are defined by the platforms you target | Curated set of APIs |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| API由您所针对的平台定义 | 精选的API集 |'
- en: '| They are not linearly versioned | Linearly versioned |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 它们不是线性版本 | 线性版本 |'
- en: '.NET Standard is also mapped to PCL, so if you have an existing PCL library
    that you wanted to convert to .NET Standard, you can reference the following table:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: .NET标准也映射到PCL，因此如果您有一个现有的PCL库，希望将其转换为.NET标准，可以参考以下表格：
- en: '| **PCL Profile** | **.NET Standard** | **PCL Plaforms** |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **PCL配置文件** | **.NET标准** | **PCL平台** |'
- en: '| 7 | 1.1 | .NET Framework 4.5, Windows 8 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 1.1 | .NET Framework 4.5, Windows 8 |'
- en: '| 31 | 1.0 | Windows 8.1, Windows Phone Silverlight 8.1 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 31 | 1.0 | Windows 8.1, Windows Phone Silverlight 8.1 |'
- en: '| 32 | 1.2 | Windows 8.1, Windows Phone 8.1 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 1.2 | Windows 8.1, Windows Phone 8.1 |'
- en: '| 44 | 1.2 | .NET Framework 4.5.1, Windows 8.1 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 44 | 1.2 | .NET Framework 4.5.1, Windows 8.1 |'
- en: '| 49 | 1.0 | .NET Framework 4.5, Windows Phone Silverlight 8 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 49 | 1.0 | .NET Framework 4.5, Windows Phone Silverlight 8 |'
- en: '| 78 | 1.0 | .NET Framework 4.5, Windows 8, Windows Phone Silverlight 8 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 78 | 1.0 | .NET Framework 4.5, Windows 8, Windows Phone Silverlight 8 |'
- en: '| 84 | 1.0 | Windows Phone 8.1, Windows Phone Silverlight 8.1 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 84 | 1.0 | Windows Phone 8.1, Windows Phone Silverlight 8.1 |'
- en: '| 111 | 1.1 | .NET Framework 4.5, Windows 8, Windows Phone 8.1 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 111 | 1.1 | .NET Framework 4.5, Windows 8, Windows Phone 8.1 |'
- en: '| 151 | 1.2 | .NET Framework 4.5.1, Windows 8.1, Windows Phone 8.1 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 151 | 1.2 | .NET Framework 4.5.1, Windows 8.1, Windows Phone 8.1 |'
- en: '| 157 | 1.0 | Windows 8.1, Windows Phone 8.1, Windows Phone Silverlight 8.1
    |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 157 | 1.0 | Windows 8.1, Windows Phone 8.1, Windows Phone Silverlight 8.1
    |'
- en: '| 259 | 1.0 | .NET Framework 4.5, Windows 8, Windows Phone 8.1, Windows Phone
    Silverlight 8 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 259 | 1.0 | .NET Framework 4.5, Windows 8, Windows Phone 8.1, Windows Phone
    Silverlight 8 |'
- en: Considering the preceding table, if we have a PCL that targets .NET Framework
    4.5.1, Windows 8.1, and Windows Phone 8.1 with the PCL profile set to 151, it
    can be converted to the .NET Standard library with version 1.2.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面的表格，如果我们有一个PCL，它的目标是.NET Framework 4.5.1、Windows 8.1和Windows Phone 8.1，PCL配置文件设置为151，它可以转换为版本1.2的.NET标准库。
- en: Versioning of .NET Standard
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET标准的版本控制
- en: Unlike PCL, each version of .NET Standard is linearly versioned and contains
    the APIs for the previous versions and so on. Once the version is shipped, it
    is frozen and cannot be changed, and the application can easily target that version.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与PCL不同，每个.NET标准版本都是线性版本化的，并包含了以前版本的API等。一旦版本发布，它就被冻结，不能更改，并且应用程序可以轻松地针对该版本。
- en: 'The following diagram is a representation of how .NET Standard is versioned.
    The higher the version is, the more APIs will be available, whereas the lower
    the version is, the more platforms will be available:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表是.NET标准版本化的表示。版本越高，可用的API就越多，而版本越低，可用的平台就越多：
- en: '![](img/00012.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00012.jpeg)'
- en: New improvements in .NET Standard 2.0
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET标准2.0的新改进
- en: .NET Core 2.0 is targeted at .NET Standard 2.0 and provides two major benefits.
    This includes the increase in the number of APIs provided from the previous version
    and its compatibility mode, as we will discuss further in this chapter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core 2.0针对.NET标准2.0，并提供了两个主要好处。这包括从上一个版本提供的API数量的增加以及其兼容模式，我们将在本章进一步讨论。
- en: More APIs in .NET Standard 2.0
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET标准2.0中的更多API
- en: More APIs have been added into .NET Standard 2.0 and the number is almost double
    that of the previous .NET Standard, 1.0\. Additionally APIs like DataSet, collections,
    binary serialization, XML schema, and others are now part of .NET Standard 2.0
    specification. This has increased the portability of code from .NET Framework
    to .NET Core.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: .NET标准2.0中添加了更多的API，数量几乎是上一个.NET标准1.0的两倍。此外，像DataSet、集合、二进制序列化、XML模式等API现在都是.NET标准2.0规范的一部分。这增加了从.NET
    Framework到.NET Core的代码可移植性。
- en: 'The following diagram depicts the categorical view of APIs added in each area:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了每个领域中添加的API的分类视图：
- en: '![](img/00013.gif)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.gif)'
- en: Compatibility mode
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 兼容模式
- en: Although more than 33K APIs have been added into .NET Standard 2.0, many of
    the NuGet packages still target .NET Framework, and moving them to .NET Standard
    is not possible, since their dependencies are still not targeted at .NET Standard.
    However, with .NET Standard 2.0, we can still add packages which show a warning
    but don't block adding those packages into our .NET Standard library.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管已经将超过33K个API添加到.NET标准2.0中，但许多NuGet包仍然针对.NET Framework，并且将它们移动到.NET标准是不可能的，因为它们的依赖项仍然没有针对.NET标准。但是，使用.NET标准2.0，我们仍然可以添加显示警告但不会阻止将这些包添加到我们的.NET标准库中的包。
- en: Under the hood, .NET Standard 2.0 uses compatibility shim, which solves the
    third party library compatibility issue and makes it easy in referencing those
    libraries. In the CLR world, the identity of the assembly is part of the type
    identity. This means that when we say `System.Object` in .NET Framework, we are
    referencing `[mscorlib]System.Object` and with .NET Standard, we are referencing
    `[netstandard]System.Object`, so if we are referencing any assembly which is part
    of .NET Framework, it cannot be easily run on .NET Standard and so compatibility
    issues arise. To solve this problem, they have used type forwarding which provides
    a fake `mscorlib` assembly that type forwards all the types to the .NET Standard
    implementation.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，.NET标准2.0使用兼容性shim，解决了第三方库的兼容性问题，并且在引用这些库时变得更加容易。在CLR世界中，程序集的标识是类型标识的一部分。这意味着当我们在.NET
    Framework中说`System.Object`时，我们引用的是`[mscorlib]System.Object`，而在.NET标准中，我们引用的是`[netstandard]System.Object`，因此，如果我们引用任何.NET
    Framework的程序集，它不能轻松地在.NET标准上运行，因此会出现兼容性问题。为了解决这个问题，他们使用了类型转发，提供了一个虚假的`mscorlib`程序集，该程序集将所有类型转发到.NET标准实现。
- en: 'Here is a representation of how the .NET Framework libraries can run in any
    of the .NET Standard implementations using the type forwarding approach:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是.NET Framework库如何在任何.NET标准实现中使用类型转发方法运行的表示：
- en: '![](img/00014.jpeg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: 'On the other hand, if we have a .NET Framework library and we wanted to reference
    a .NET Standard library, it will add the `netstandard` fake assembly and perform
    type forwarding of all the types by using the .NET Framework implementation:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们有一个.NET Framework库，并且想要引用一个.NET标准库，它将添加`netstandard`虚假程序集，并通过使用.NET
    Framework实现对所有类型进行类型转发：
- en: '![](img/00015.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: To suppress warnings, we can add NU1701 for particular NuGet packages whose
    dependencies are not targeting .NET Standard.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了抑制警告，我们可以为特定的NuGet包添加NU1701，这些包的依赖项没有针对.NET标准。
- en: Creating a .NET Standard library
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建.NET标准库
- en: To create a .NET Standard library, you can either use Visual Studio or the .NET
    Core CLI toolset. From Visual Studio, we can just click on the .NET Standard option
    as shown in the following screenshot, and select Class Library (.NET Standard).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建.NET Standard库，可以使用Visual Studio或.NET Core CLI工具集。从Visual Studio，我们只需点击如下屏幕截图中显示的.NET
    Standard选项，然后选择Class Library (.NET Standard)。
- en: 'Once the .NET Standard library is created, we can reference it to any project
    and change the version if needed, depending on which platform we want to reference.
    The version can be changed from the properties panel, as shown in the following
    screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 创建.NET Standard库后，我们可以将其引用到任何项目，并根据需要更改版本，具体取决于我们要引用的平台。版本可以从属性面板更改，如下面的屏幕截图所示：
- en: '![](img/00016.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00016.jpeg)'
- en: What comes with ASP.NET Core 2.0
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 2.0的新功能
- en: ASP.NET Core is one of the most powerful platforms for developing cloud-ready
    and enterprise web applications that run cross-platform. Microsoft has added many
    features with ASP.NET Core 2.0, and that includes new project templates, Razor
    Pages, simplified provisioning of Application Insights, connection pooling, and
    so on.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core是开发云就绪和企业Web应用程序的最强大平台之一，可跨平台运行。Microsoft在ASP.NET Core 2.0中添加了许多功能，包括新的项目模板、Razor页面、简化的Application
    Insights配置、连接池等。
- en: The following are some new improvements for ASP.NET Core 2.0.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是ASP.NET Core 2.0的一些新改进。
- en: ASP.NET Core Razor Pages
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core Razor页面
- en: 'Razor syntax-based pages have been introduced in ASP.NET Core. Now, developers
    can develop applications and write syntax on the HTML with no controller in place.
    Instead, there is a code behind file where other events and logic can be handled.
    The backend page class is inherited from the `PageModel` class and its member
    variables and methods can be accessed using the `Model` object in Razor syntax.
    The following is a simple example that contains the `GetTitle` method defined
    in the `code-behind` class and used in the view page:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core中引入了基于Razor语法的页面。现在，开发人员可以在HTML上开发应用程序并写语法，而无需放置控制器。相反，有一个代码后台文件，可以在其中处理其他事件和逻辑。后端页面类继承自`PageModel`类，可以使用Razor语法中的`Model`对象访问其成员变量和方法。以下是一个简单的示例，其中包含在`code-behind`类中定义的`GetTitle`方法，并在视图页面中使用：
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the `Index.cshtml` file that displays the date by calling the `GetCurrentDate`
    method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Index.cshtml`文件，通过调用`GetCurrentDate`方法显示日期：
- en: '[PRE8]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Automatic Page and View compilation on publishing
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布时自动页面和视图编译
- en: 'On publishing the ASP.NET Core Razor pages project, all the views are compiled
    into one single assembly and the published folder size is comparatively small.
    In case we want view and all the `.cshtml` files to be generated when the publishing
    process takes place, we have to add an entry, which is shown as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布ASP.NET Core Razor页面项目时，所有视图都会编译成一个单一的程序集，发布文件夹的大小相对较小。如果我们希望在发布过程中生成视图和所有`.cshtml`文件，我们必须添加一个条目，如下所示：
- en: '![](img/00017.gif)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00017.gif)'
- en: Razor support for C# 7.1
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Razor对C# 7.1的支持
- en: 'Now, we can use C# 7.1 features such as inferred tuple names, pattern matching
    with generics, and expressions. In order to add this support, we have to add one
    XML tag as follows in our project file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用C# 7.1功能，如推断的元组名称、泛型模式匹配和表达式。为了添加此支持，我们必须在项目文件中添加一个XML标记，如下所示：
- en: '[PRE9]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Simplified configuration for Application Insights
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Application Insights的简化配置
- en: With ASP.NET Core 2.0, you can enable Application Insights with a single click.
    A user can enable Application Insights by just right clicking Project and hitting
    Add | Application Insights Telemetry before going through a simple wizard. This
    allows you to monitor the application and provides complete diagnostics information
    from Azure Application Insights.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core 2.0，您可以通过单击一次启用Application Insights。用户只需右键单击项目，然后单击添加 | Application
    Insights Telemetry，然后通过简单的向导即可启用Application Insights。这允许您监视应用程序，并提供来自Azure Application
    Insights的完整诊断信息。
- en: We can also view the complete telemetry from the Visual Studio 2017 IDE from
    the Application Insights Search window and monitor trends from Application Insights
    Trends. Both of these windows can be opened from the View | Other Windows menu.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从Visual Studio 2017 IDE的Application Insights搜索窗口查看完整的遥测，并从Application Insights趋势监视趋势。这两个窗口都可以从View
    | Other Windows菜单中打开。
- en: Pooling connections in Entity Framework Core 2.0
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Entity Framework Core 2.0中池化连接
- en: With the recent release of Entity Framework Core 2.0, we can pool connections
    by using the `AddDbContextPool` method in the `Startup` class. As we already know,
    in ASP.NET Core, we have to add the `DbContext` object using **Dependency Injection**
    (**DI**) in the `ConfigureServices` method in the `Startup` class, and when it
    is used in the controller, a new instance of the `DbContext` object is injected.
    To optimize performance, Microsoft has provided this `AddDbContextPool` method,
    which first checks for the available database context instance and injects it
    wherever it is needed. On the other hand, if the database context instance is
    not available, a new instance is created and injected.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最近发布的Entity Framework Core 2.0中，我们可以使用`Startup`类中的`AddDbContextPool`方法来池化连接。正如我们已经知道的，在ASP.NET
    Core中，我们必须使用**依赖注入**（**DI**）在`Startup`类的`ConfigureServices`方法中添加`DbContext`对象，并在控制器中使用时，会注入`DbContext`对象的新实例。为了优化性能，Microsoft提供了这个`AddDbContextPool`方法，它首先检查可用的数据库上下文实例，并在需要时注入它。另一方面，如果数据库上下文实例不可用，则会创建并注入一个新实例。
- en: 'The following code shows how `AddDbContext` can be added in the `ConfigureServices`
    method in the `Startup` class:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何在`Startup`类的`ConfigureServices`方法中添加`AddDbContext`：
- en: '[PRE10]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are some more features added to Owned Types, Table splitting, Database
    Scalar Function mapping, and string interpolation that you can refer to from the
    following link: [https://docs.microsoft.com/en-us/ef/core/what-is-new/](https://docs.microsoft.com/en-us/ef/core/what-is-new/).'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Owned Types、表拆分、数据库标量函数映射和字符串插值等功能已添加了一些新特性，您可以从以下链接中查看：[https://docs.microsoft.com/en-us/ef/core/what-is-new/](https://docs.microsoft.com/en-us/ef/core/what-is-new/)。
- en: New features in C# 7.0
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 7.0中的新功能
- en: 'C# is the most popular language in the .NET ecosystem and was first introduced
    with the .NET Framework in 2002\. The current stable version of C# is 7\. The
    following chart shows how C# 7.0 has progressed and what versions were introduced
    in different years:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: C#是.NET生态系统中最流行的语言，最早是在2002年与.NET Framework一起推出的。C#的当前稳定版本是7。以下图表显示了C# 7.0的进展情况以及不同年份引入的版本：
- en: '![](img/00018.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00018.jpeg)'
- en: 'Here are some of the new features that were introduced with C# 7.0:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是C# 7.0引入的一些新功能：
- en: Tuples
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: Pattern matching
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Reference returns
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用返回
- en: Exceptions as expressions
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常作为表达式
- en: Local functions
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地函数
- en: Out variables Literals
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出变量文字
- en: Async Main
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步主函数
- en: Tuples
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: Tuples solve the problem of returning more than one value from a method. Traditionally,
    we can use out variables that are reference variables, and the value is changed
    if they are modified from the calling method. However, without parameters, there
    are some limitations, such as that it cannot be used with `async` methods and
    is not recommended to be used with external services.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 元组解决了从方法返回多个值的问题。传统上，我们可以使用引用变量的输出变量，如果它们从调用方法中修改，则值会更改。但是，没有参数，存在一些限制，例如不能与`async`方法一起使用，不建议与外部服务一起使用。
- en: 'Tuples have the following characteristics:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 元组具有以下特点：
- en: They are value types.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是值类型。
- en: They can be converted to other Tuples.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以转换为其他元组。
- en: Tuple elements are public and mutable.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组元素是公共且可变的。
- en: 'A Tuple is represented as `System.Tuple<T>`, where `T` could be any type. The
    following example shows how a Tuple can be used with the method and how the values
    can be invoked:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 元组表示为`System.Tuple<T>`，其中`T`可以是任何类型。以下示例显示了如何使用元组与方法以及如何调用值：
- en: '[PRE11]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you may have noticed, items are dynamically named and the first item is
    named `Item1`, the second `Item2`, and so on. On the other hand, we can also name
    the items so that the calling party should know about the value, and this can
    be done by adding the parameter name for each parameter in the Tuple, which is
    shown as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，项目是动态命名的，第一个项目被命名为`Item1`，第二个为`Item2`，依此类推。另一方面，我们也可以为项目命名，以便调用方了解值，这可以通过为元组中的每个参数添加参数名来实现，如下所示：
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To learn more about Tuples, please check the following link:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于元组的信息，请查看以下链接：
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/tuples](https://docs.microsoft.com/en-us/dotnet/csharp/tuples).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/csharp/tuples](https://docs.microsoft.com/en-us/dotnet/csharp/tuples)。'
- en: Patterns
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: 'Patterns matching is the process of performing syntactical testing of the value
    to verify whether it matches the certain model. There are three types of patterns:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是执行语法测试的过程，以验证值是否与某个模型匹配。有三种类型的模式：
- en: Constant patterns.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量模式。
- en: Type patterns.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型模式。
- en: Var patterns.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Var模式。
- en: Constant pattern
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量模式
- en: 'A constant pattern is a simple pattern that checks for the constant value.
    Consider the following example: if the `Person` object is null, it will return
    and exit the `body` method.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 常量模式是检查常量值的简单模式。考虑以下示例：如果`Person`对象为空，则返回并退出`body`方法。
- en: 'The `Person` class is as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类如下：'
- en: '[PRE13]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following statement checks for the `person` object with a null constant
    value and returns it if the object is null:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句检查`person`对象是否具有空常量值，并在对象为空时返回它：
- en: '[PRE14]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Type pattern
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型模式
- en: 'The type pattern can be used with an object to verify whether it matches the
    type or suffices the expression based on the conditions specified. Suppose we
    need to check whether the `PersonID` is `int`; assign that `ID` to another variable,
    `i`, and use it in the program, otherwise `return`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 类型模式可用于对象，以验证它是否与类型匹配或是否满足基于指定条件的表达式。假设我们需要检查`PersonID`是否为`int`；将该`ID`分配给另一个变量`i`，并在程序中使用它，否则`return`：
- en: '[PRE15]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can also use multiple logical operators to evaluate more conditions, as
    follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用多个逻辑运算符来评估更多条件，如下所示：
- en: '[PRE16]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding statement checks whether the `Person.ID` is null or not and whether
    the person is older than 20.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句检查`Person.ID`是否为空，以及人是否年龄大于20。
- en: Var pattern
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Var模式
- en: 'The var pattern checks if the `var` is equal to some type. The following example
    shows how the `var` pattern can be used to check for the type and print the `Type`
    name:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: var模式检查`var`是否等于某种类型。以下示例显示了如何使用`var`模式来检查类型并打印`Type`名称：
- en: '[PRE17]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To learn more about patterns, you can refer to the following link: [https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7#pattern-matching](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7#pattern-matching).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于模式的信息，可以参考以下链接：[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7#pattern-matching](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7#pattern-matching)。
- en: Reference returns
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用返回
- en: Reference returns allows a method to return an object as a reference instead
    of its value. We can define the reference return value by adding a `ref` keyword
    before the type in the method signature and when returning the object from the
    method itself.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 引用返回允许方法返回一个对象的引用，而不是它的值。我们可以通过在方法签名中的类型前添加`ref`关键字来定义引用返回值，并在方法本身返回对象时返回它。
- en: 'Here is the signature of the method that allows reference returns:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是允许引用返回的方法的签名：
- en: '[PRE18]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Expression bodied member extended
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式体成员扩展
- en: Expression bodied members were introduced in C# 6.0 where the syntactical expression
    of the method can be written in a simpler way. In C# 7.0, we can use this feature
    with a constructor, a destructor, an exception, and so on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式体成员是在C# 6.0中引入的，其中方法的语法表达可以以更简单的方式编写。在C# 7.0中，我们可以在构造函数、析构函数、异常等中使用此功能。
- en: 'The following example shows how the constructor and destructor syntactic expressions
    can be simplified using expression bodied members:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用表达式体成员简化构造函数和析构函数的语法表达：
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With properties, we can also simplify the syntactic expression, and the following
    is a basic example of how this can be written:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有了属性，我们还可以简化语法表达，以下是如何编写的基本示例：
- en: '[PRE20]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also use an expression bodied syntactic expression with exceptions and
    simplify the expression, which is shown as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用表达式体语法表达异常并简化表达式，如下所示：
- en: '[PRE21]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding example, if the value is null, a new `ArgumentNullException`
    will be thrown.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果值为null，将抛出一个新的`ArgumentNullException`。
- en: Creating Local Functions
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建局部函数
- en: 'Functions that are created within a function are known as Local Functions.
    These are mainly used when defining helper functions that have to be in the scope
    of the function itself. The following example shows how the factorial of the number
    can be obtained by writing a Local Function and calling it recursively:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部创建的函数称为局部函数。这些主要用于定义必须在函数本身范围内的辅助函数。以下示例显示了如何通过编写局部函数并递归调用它来获得数字的阶乘：
- en: '[PRE22]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Out variables
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出变量
- en: With C# 7.0, we can write cleaner code when using `out` variables. As we know,
    to use `out` variables, we have to first declare them. With the new language enhancement,
    we can now just write `out` as a prefix and specify the name of the variable that
    we need that value to be assigned to.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.0中，当使用`out`变量时，我们可以编写更清晰的代码。正如我们所知，要使用`out`变量，我们必须首先声明它们。通过新的语言增强，我们现在可以只需将`out`作为前缀写入，并指定我们需要将该值分配给的变量的名称。
- en: 'To clarify this concept, we will first see the traditional approach, which
    is shown as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清这个概念，我们首先看一下传统的方法，如下所示：
- en: '[PRE23]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And here with C# 7.0, we can simplify the preceding `GetPerson` method, which
    is shown as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.0中，我们可以简化前面的`GetPerson`方法，如下所示：
- en: '[PRE24]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Async Main
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Async Main
- en: As we already know, in .NET Framework, the `Main` method is the main entry point
    from where the application/program is executed by the OS. For example, in ASP.NET
    Core, `Program.cs` is the main class where the `Main` method is defined, which
    creates a `WebHost` object, runs the Kestrel server, and loads up the HTTP pipeline
    as configured in the `Startup` class.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，在.NET Framework中，`Main`方法是应用程序/程序由操作系统执行的主要入口点。例如，在ASP.NET Core中，`Program.cs`是定义`Main`方法的主要类，它创建一个`WebHost`对象，运行Kestrel服务器，并根据`Startup`类中配置的方式加载HTTP管道。
- en: 'In the previous version of C#, the `Main` method had the following signatures:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的C#版本中，`Main`方法具有以下签名：
- en: '[PRE25]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In C# 7.0, we can use Async Main to perform asynchronous operations. The Async/Await
    feature was initially released in .NET Framework 4.5 in order to execute methods
    asynchronously. Today, many APIs provides Async/Await methods to perform asynchronous
    operations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.0中，我们可以使用Async Main执行异步操作。Async/Await功能最初是在.NET Framework 4.5中发布的，以便异步执行方法。如今，许多API提供了Async/Await方法来执行异步操作。
- en: 'Here are some additional signatures of the `Main` method that have been added
    with C# 7.1:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用C# 7.1添加的`Main`方法的一些附加签名：
- en: '[PRE26]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Because of the preceding async signatures, we can now call `async` methods
    from the `Main` entry point itself and use await to perform an asynchronous operation.
    Here is a simple example of ASP.NET Core that calls the `RunAsync` method instead
    of `Run`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的异步签名，现在我们可以从`Main`入口点本身调用`async`方法，并使用await执行异步操作。以下是调用`RunAsync`方法而不是`Run`的ASP.NET
    Core的简单示例：
- en: '[PRE27]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Async Main is a feature of C# 7.1, and to enable this feature in Visual Studio
    2017, you can go to the project properties, click on the Advance button and set
    the Language version as C# latest minor version (latest), which is shown as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Async Main是C# 7.1的一个特性，要在Visual Studio 2017中启用此功能，可以转到项目属性，单击Advance按钮，并将语言版本设置为C#最新的次要版本（latest），如下所示：
- en: '![](img/00019.gif)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00019.gif)'
- en: Writing quality code
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写优质代码
- en: For every performance-efficient application, code quality plays an important
    role. As we already know, Visual Studio is the most popular **Integrated Development
    Environment** (**IDE**) for developing .NET applications, and since Roslyn (.NET
    Compiler SDK) exposes compiler platforms as APIs, many features have been introduced
    that do not only extend the capabilities of Visual Studio, but enhance the development
    experience.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个性能高效的应用程序，代码质量都起着重要作用。正如我们已经知道的，Visual Studio是开发.NET应用程序最流行的**集成开发环境**（**IDE**），由于Roslyn（.NET编译器SDK）公开了编译器平台作为API，许多功能已经被引入，不仅扩展了Visual
    Studio的功能，而且增强了开发体验。
- en: Live Static Code analysis is one of the core features that can be used in Visual
    Studio in developing .NET applications which provides code analysis during development
    while writing code. As this feature uses the Roslyn APIs, many other third-party
    companies have also introduced sets of analyzers that can be used. We can also
    develop our own analyzer for a particular requirement, and it's not a very complicated
    procedure. Let's look at a quick introduction on how we can use Live Static Code
    analysis in our .NET Core project and how it benefits the development experience
    by analyzing code and giving warnings, errors, and potential fixes for them.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 实时静态代码分析是Visual Studio中可以用于开发.NET应用程序的核心功能之一，它在编写代码时提供代码分析。由于此功能使用Roslyn API，许多其他第三方公司也引入了一套可以使用的分析器。我们还可以为特定需求开发自己的分析器，这并不是一个非常复杂的过程。让我们快速介绍一下如何在我们的.NET
    Core项目中使用实时静态代码分析以及它如何通过分析代码并提供警告、错误和潜在修复来增强开发体验。
- en: We can add analyzer as a NuGet package. In NuGet.org, there are many analyzers
    available, and once we add any analyzer into our project, it adds a new *Analyzer*
    node into the *Dependencies* section of the project. We can then customize rules,
    suppress warnings or errors, and so on.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将分析器作为NuGet包添加。在NuGet.org上有许多可用的分析器，一旦我们将任何分析器添加到我们的项目中，它就会在项目的*Dependencies*部分添加一个新的*Analyzer*节点。然后我们可以自定义规则，抑制警告或错误等。
- en: 'Let''s add a new analyzer from Visual Studio in our .NET Core project. If you
    don''t know which analyzer you want to add, you can just type *analyzers* in the
    NuGet Package manager window and it will list all the analyzers for you. We will
    just add the `Microsoft.CodeQuality.Analyzers` analyzer, which contains some decent
    rules:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的.NET Core项目中从Visual Studio添加一个新的分析器。如果你不知道要添加哪个分析器，你可以在NuGet包管理器窗口中只需输入*analyzers*，它就会为你列出所有的分析器。我们将只添加`Microsoft.CodeQuality.Analyzers`分析器，其中包含一些不错的规则：
- en: '![](img/00020.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: 'Once the selected Analyzer is added, a new `Analyzers` node is added into our
    project:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择的分析器被添加，一个新的`Analyzers`节点将被添加到我们的项目中：
- en: '![](img/00021.jpeg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: 'In the preceding picture, we can see that three nodes have been added to the
    `Analyzers` node, and to see/manage the rules, we can expand the subnodes `Microsoft.CodeQuality.Analyzers`
    and `Microsoft.CodeQuality.CSharp.Analyzers`, which is shown as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到`Analyzers`节点已经添加了三个节点，要查看/管理规则，我们可以展开子节点`Microsoft.CodeQuality.Analyzers`和`Microsoft.CodeQuality.CSharp.Analyzers`，如下所示：
- en: '![](img/00022.jpeg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: 'Moreover, we can also change the rule severity by right-clicking on the rule
    and selecting the severity, which is shown as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以通过右键单击规则并选择严重性来更改规则的严重性，如下所示：
- en: '![](img/00023.jpeg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: In the preceding picture, rule CA1008 states that Enums should have a value
    of zero. Let's test this out and see how it works.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，规则CA1008指出枚举应该有一个值为零。让我们测试一下，看看它是如何工作的。
- en: 'Create a simple `Enum` and specify the values, which are shown as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的`Enum`并指定值，如下所示：
- en: '[PRE28]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will notice as soon as you write this code, it will show the following
    error and it will provide potential fixes:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写这段代码时，你会立刻看到以下错误，并提供潜在的修复方法：
- en: '![](img/00024.jpeg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.jpeg)'
- en: 'Finally, here is the fix we can apply, and the error will disappear:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们可以应用的修复方法，错误将消失：
- en: '![](img/00025.jpeg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: 'You can also use one of the popular Visual Studio extensions known as Roslynator,
    which can be downloaded from the following link. It contains more than 190 analyzers
    and refactorings for C# based projects: [https://marketplace.visualstudio.com/items?itemName=josefpihrt.Roslynator](https://marketplace.visualstudio.com/items?itemName=josefpihrt.Roslynator).'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用一个名为Roslynator的流行的Visual Studio扩展程序，可以从以下链接下载。它包含了超过190个适用于基于C#的项目的分析器和重构工具：[https://marketplace.visualstudio.com/items?itemName=josefpihrt.Roslynator](https://marketplace.visualstudio.com/items?itemName=josefpihrt.Roslynator)。
- en: Live Static Code analysis is a great feature that helps developers to write
    quality code that conforms to the best guidelines and practices.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 实时静态代码分析是一个很棒的功能，它帮助开发人员编写符合最佳准则和实践的高质量代码。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the .NET Core Framework and some new improvements
    that are introduced with .NET Core 2.0\. We also looked into the new features
    of C# 7 and how we can write cleaner code and simplify syntactic expressions.
    Finally, we covered the topic of writing quality code and how we can leverage
    with the Code analysis feature provided in Visual Studio 2017 to add analyzers
    into our project which serve our needs. The next chapter will be an in-depth chapter
    about .NET Core that will cover topics around .NET Core internals and performance
    improvements.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了.NET Core框架以及.NET Core 2.0引入的一些新改进。我们还研究了C# 7的新功能，以及如何编写更干净的代码和简化语法表达。最后，我们讨论了编写高质量代码的主题，以及如何利用Visual
    Studio 2017提供的代码分析功能来添加满足我们需求的分析器到我们的项目中。下一章将是一个关于.NET Core的深入章节，将涵盖.NET Core内部和性能改进的主题。
