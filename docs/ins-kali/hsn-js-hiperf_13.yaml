- en: WebAssembly - A Brief Look into Native Code on the Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly - 简要了解Web上的本地代码
- en: The past few chapters have been all about how to leverage JavaScript in the
    modern web landscape. We have looked at frontend development, backend development,
    and even building and deploying applications through **continuous integration
    and continuous deployment** (**CI**/**CD**). Now, we are going to take a step
    back and look at two topics that can help enhance our development with native
    speed code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 过去的几章都是关于如何在现代网络环境中利用JavaScript。我们已经看过前端开发、后端开发，甚至通过持续集成和持续部署（CI/CD）构建和部署应用程序。现在，我们要退一步，看看两个可以帮助我们加快本地速度代码开发的主题。
- en: WebAssembly is a specification for assembly for the web. Assembly is a one-to-one
    mapping for the language that computers understand. WebAssembly, on the other
    hand, is a one-to-one mapping for a virtual computer that can run these instructions.
    In this chapter, we will explore WebAssembly and how we can port native applications
    to the browser.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly是Web上汇编的规范。汇编是计算机理解的语言的一对一映射。另一方面，WebAssembly是一个虚拟计算机的一对一映射，可以运行这些指令。在本章中，我们将探讨WebAssembly以及如何将本地应用程序移植到浏览器中。
- en: 'Overall, we will explore the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 总体上，我们将探讨以下主题：
- en: Understanding WebAssembly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解WebAssembly
- en: Setting up our environment to write WebAssembly
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的环境来编写WebAssembly
- en: Writing WebAssembly modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写WebAssembly模块
- en: Porting C applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移植C应用程序
- en: Taking a look at a major application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看一个主要应用程序
- en: By the end of this chapter, we should be able to develop not only in the WebAssembly
    text format but also in C for the web. We will also be able to turn binary WebAssembly
    into its text format in order to diagnose possible issues with our ported applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，我们应该能够不仅在WebAssembly文本格式中开发，还能够在Web上使用C。我们还将能够将二进制WebAssembly转换为其文本格式，以便诊断我们移植应用程序可能出现的问题。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will need the following tools for this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以下工具来完成本章内容：
- en: An editor, such as VS Code.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑器，比如VS Code。
- en: Access to build and compile programs on our computer. This may mean needing
    administrator privileges in some environments.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的计算机上构建和编译程序。这可能意味着在某些环境中需要管理员权限。
- en: This chapter's code, which can be found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter13).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码可以在[https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter13)找到。
- en: Understanding WebAssembly
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解WebAssembly
- en: 'WebAssembly is a specification for an instruction set that can be run on a
    machine. In our case, this machine is virtual. To comprehend how this translates
    into native speed applications and why the instructions are written the way they
    are, we need to have a basic understanding of how a program functions inside our
    computer. To understand WebAssembly, we will look at the following topics:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly是一种可以在计算机上运行的指令集规范。在我们的情况下，这台计算机是虚拟的。为了理解这是如何转化为本地速度应用程序以及为什么指令被编写成这样，我们需要基本了解程序在计算机内部是如何运行的。为了理解WebAssembly，我们将研究以下主题：
- en: Understanding the flow of a basic program
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解一个基本程序的流程
- en: Setting up our environment to code WebAssembly
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的环境来编写WebAssembly代码
- en: Understanding a program
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解程序
- en: 'Let''s take a look at a very basic C program:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个非常基本的C程序：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This program has an entry point. In our case, it is the `main` function. From
    here, we utilize a function that is declared in the `stdio` header file (a header
    file gives us function declarations so that we don't have to fully import all
    of the code into this file). We utilize the `printf` function to print out `Hello,
    World!` to the console and then we `return` with a `0` to signify that we have
    a successful program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有一个入口点。在我们的情况下，它是`main`函数。从这里，我们利用了在`stdio`头文件中声明的一个函数（头文件给出了函数声明，这样我们就不必完全导入所有代码到这个文件中）。我们利用`printf`函数将`Hello,
    World!`打印到控制台，然后我们用`return`和`0`来表示我们有一个成功的程序。
- en: Since we won't be talking about the C/C++ code that we will be writing in depth,
    for those that are interested, a great resource is [https://www.learn-c.org/](https://www.learn-c.org/).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不会深入讨论我们将要编写的C/C++代码，对于那些感兴趣的人，一个很好的资源是[https://www.learn-c.org/](https://www.learn-c.org/)。
- en: While this is a program in a format that we, as programmers, generally understand, it
    needs to be turned into a format that the computer will actually understand. This
    means it needs to be compiled. This compilation process involves bringing in any
    external files (`stdio`, in this case) and linking them in. This also means we
    need to turn each of our instructions into one or more computer instructions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个我们作为程序员通常理解的程序格式，但它需要被转换成计算机实际理解的格式。这意味着它需要被编译。这个编译过程涉及引入任何外部文件（在这种情况下是`stdio`）并将它们链接在一起。这也意味着我们需要将我们的每个指令转换成一个或多个计算机指令。
- en: Once the process of linking and compilation happens, we will usually get a binary
    file that can be read by our computer. If we opened this file in a byte reader,
    we would see a bunch of hexadecimal numbers. Each of these numbers corresponds
    to the instructions, data points, and so on, that we put in our file.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦链接和编译过程发生，我们通常会得到一个可以被计算机读取的二进制文件。如果我们用一个字节阅读器打开这个文件，我们会看到一堆十六进制数字。这些数字中的每一个对应于我们在文件中放置的指令、数据点等等。
- en: Now, this is just a basic understanding of how a program gets turned into something
    our computer understands and how the binary we created is understood by the computer.
    On most machines, a program runs as a stack of instructions and data. This means
    that it pulls instructions off of the top of the stack one at a time. These instructions
    can be anything from loading this number into a location or adding these two numbers
    together. As it peels these instructions off, it discards them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这只是对程序如何转换为计算机理解的东西以及我们创建的二进制代码如何被计算机理解的基本理解。在大多数机器上，程序作为一堆指令和数据运行。这意味着它一次从堆栈顶部拉出一条指令。这些指令可以是任何东西，从将这个数字加载到一个位置，或者将这两个数字加在一起。当它剥离这些指令时，它会丢弃它们。
- en: We can store various pieces of data local to this stack, or we can store data
    at a global level. Those local to the stack are held on exactly that—the stack.
    Once that stack has been exhausted, we no longer have access to those variables.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将各种数据存储在这个堆栈的本地，或者我们可以在全局级别存储数据。那些存储在堆栈上的数据就是确切地那个——堆栈。一旦那个堆栈被耗尽，我们就再也无法访问那些变量了。
- en: The global ones are put into a location called the **heap**. The heap allows
    us to grab the data from anywhere in our system. Once the stack of our program
    has been exhausted, those heap objects can be left there if our program is still
    running.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 全球的数据被放置在一个叫做**堆**的位置。堆允许我们从系统中的任何地方获取数据。一旦我们的程序的堆栈被耗尽，如果我们的程序仍在运行，那些堆对象可以留在那里。
- en: Finally, we get a stack per function that we write. Because of this, we can
    treat each function as a mini-program. This means it will perform one task or
    a couple of tasks and then it will be exhausted, and we will go back to the stack
    of the function that called us. We can do two things when we exhaust this stack.
    The first thing we can do is go back to the stack of the function that called
    us with no data. Alternatively, we could give some data back (this is the `return`
    statement that we see in most languages).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为我们编写的每个函数得到一个堆栈。因为这个原因，我们可以把每个函数当作一个小程序来对待。这意味着它将执行一个任务或一些任务，然后它将被耗尽，我们将回到调用我们的函数的堆栈。当我们耗尽这个堆栈时，我们可以做两件事。我们可以做的第一件事是回到调用我们的函数的堆栈，没有数据。或者，我们可以返回一些数据（这是我们在大多数语言中看到的`return`语句）。
- en: Here, we can share data through these two mechanisms either by returning values
    from one of our subfunctions or by putting our results onto the heap so that others
    can access them. Putting it on the heap means that it will last for the duration
    of our program, but it also needs to be managed by us, whereas if we return values
    from the stack, it will be cleaned up as soon as the function that called us is
    exhausted. Most of the time, we will use simple data and return it through the
    stack. For complicated data, we will put it on the heap.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以通过这两种机制之一共享数据，要么通过从我们的子函数之一返回值，要么通过将我们的结果放到堆上，以便其他人可以访问它们。把它放在堆上意味着它将持续存在于我们的程序的持续时间，但它也需要我们来管理，而如果我们通过堆栈返回值，它将在调用我们的函数耗尽时立即清理。大多数时候，我们将使用简单的数据，并通过堆栈返回它。对于复杂的数据，我们将把它放在堆上。
- en: 'Before we look at WebAssembly, there''s one final note you should know about:
    if we put data on the heap, we need to tell other parts of our program where to
    find that data. To do this, we pass a pointer to that location. This pointer is
    just an address that tells us where to find this data. We will be utilizing this
    in our WebAssembly code.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看WebAssembly之前，有一件最后需要知道的事情：如果我们把数据放在堆上，我们需要告诉程序的其他部分在哪里找到这些数据。为了做到这一点，我们传递一个指向该位置的指针。这个指针只是一个地址，告诉我们在哪里找到这些数据。我们将在我们的WebAssembly代码中利用这一点。
- en: The topic of computers and how programs work is quite interesting. For those
    of you who are interested, it may be beneficial to take a formal course at a community
    college. For those that like to self-learn, the following resource is of great
    help: [https://www.nand2tetris.org/](https://www.nand2tetris.org/).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机和程序工作的主题是非常有趣的。对于那些感兴趣的人，最好在社区大学参加正式课程。对于那些喜欢自学的人，以下资源非常有帮助：[https://www.nand2tetris.org/](https://www.nand2tetris.org/)。
- en: Now, let's set up our environment so that we can program in WebAssembly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们设置我们的环境，以便我们可以在WebAssembly中编程。
- en: Setting up our environment
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的环境
- en: 'To program in WebAssembly, we need to get the `wat2wasm` program on our machine.
    The best way to do this is to download the repository for the WebAssembly suite
    of programs and get them compiled for our computer. Follow these steps to do so:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在WebAssembly中编程，我们需要在我们的机器上获取`wat2wasm`程序。这样做的最佳方法是下载WebAssembly程序套件的存储库，并将它们编译为我们的计算机。按照以下步骤来做到这一点：
- en: We need to get a program called CMake onto our system. For Linux/OS X, this
    just means going to [https://cmake.org/download/](https://cmake.org/download/)
    and running the installer. For those of you who are on Windows, this is a bit
    lengthier. Go to [https://visualstudio.microsoft.com/vs/](https://visualstudio.microsoft.com/vs/)
    and get Visual Studio. Make sure to get the C/C++ modules for it. With both CMake
    and Visual Studio on our machines, we can now move on and compile the WebAssembly
    suite of tools.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在我们的系统上获取一个叫做CMake的程序。对于Linux/OS X，这意味着只需转到[https://cmake.org/download/](https://cmake.org/download/)并运行安装程序。对于那些在Windows上的人来说，这会有点冗长。前往[https://visualstudio.microsoft.com/vs/](https://visualstudio.microsoft.com/vs/)并获取Visual
    Studio。确保为其获取C/C++模块。有了CMake和Visual Studio在我们的机器上，我们现在可以继续并编译WebAssembly工具套件。
- en: Head to [https://github.com/WebAssembly/wabt](https://github.com/WebAssembly/wabt)
    and clone to an easily accessible location.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://github.com/WebAssembly/wabt](https://github.com/WebAssembly/wabt)并克隆到一个易于访问的位置。
- en: 'Open the CMake GUI tool. It should look similar to the following:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开CMake GUI工具。它应该看起来类似于以下内容：
- en: '![](assets/9ab392d7-69cc-498a-a272-79308dc1ef61.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9ab392d7-69cc-498a-a272-79308dc1ef61.png)'
- en: For the source code, go to the `wabt` folder that we downloaded from GitHub.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于源代码，转到我们从GitHub下载的`wabt`文件夹。
- en: The location of the binaries should be in the `build` directory that we created
    in the `wabt` folder.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制文件的位置应该在我们在`wabt`文件夹中创建的`build`目录中。
- en: With this, we can hit the Configure button. This should populate the panel in
    the middle of the screen.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们可以点击“配置”按钮。这应该会填充屏幕中间的面板。
- en: Now, just hit the Generate button. This should generate the files that we need
    to build our application.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，只需点击“生成”按钮。这应该会生成我们构建应用程序所需的文件。
- en: Finally, we will go into Visual Studio and build the project.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将进入Visual Studio并构建项目。
- en: Open Visual Studio and open the project from the File dropdown at the top left.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio，并从左上角的文件下拉菜单中打开项目。
- en: 'Once the project is in, we can hit Build. This should build all of the binaries
    that we need for working with WebAssembly. The screen should look something like
    this:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目加载后，我们可以点击“构建”。这应该会构建我们在WebAssembly中使用的所有二进制文件。屏幕应该看起来像这样：
- en: '![](assets/87c69289-3dbb-4945-a3ee-2e7e4c3c39f5.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/87c69289-3dbb-4945-a3ee-2e7e4c3c39f5.png)'
- en: If you are having trouble, the repository at [https://github.com/WebAssembly/wabt](https://github.com/WebAssembly/wabt)
    contains some excellent documentation on how to get the build done. The preceding
    instructions try to streamline the build process, but it can be difficult to get
    these projects up and running.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到问题，[https://github.com/WebAssembly/wabt](https://github.com/WebAssembly/wabt)存储库中包含了一些关于如何完成构建的优秀文档。前面的说明试图简化构建过程，但是要让这些项目正常运行可能会有一些困难。
- en: 'Now that we have built out our binaries, let''s make sure that we put them
    on our path so that we have easy access to them. On Windows, we can do the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了我们的二进制文件，让我们确保将它们放在路径上，以便我们可以轻松访问它们。在Windows上，我们可以这样做：
- en: 'Go to the search bar and type `path variables`. The first option should allow
    us to set up our environment variables:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到搜索栏，输入“路径变量”。第一个选项应该允许我们设置环境变量：
- en: '![](assets/a62e5e40-947e-4e13-a041-5c685fb35059.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a62e5e40-947e-4e13-a041-5c685fb35059.png)'
- en: 'Click on the bottom right option called Environment Variables...:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右下方的“环境变量...”选项：
- en: '![](assets/c193fd0a-5ebd-4c31-9681-a211561e2e7d.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c193fd0a-5ebd-4c31-9681-a211561e2e7d.png)'
- en: 'For the bottom box, find the Path variable and click Edit...:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于底部的框，找到路径变量并点击编辑...：
- en: '![](assets/a7c437ca-48db-424f-91f0-2aa27458efd4.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a7c437ca-48db-424f-91f0-2aa27458efd4.png)'
- en: 'Click on New and find the directory where all of the binaries are being held:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“新建”，找到存放所有二进制文件的目录：
- en: '![](assets/13e6a73f-7f8a-47cf-a8ab-c1743ceda4bc.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/13e6a73f-7f8a-47cf-a8ab-c1743ceda4bc.png)'
- en: Once we've done this, we should be able to type `wat2wasm` into our command
    line and get the help documentation for the tool. Now, we are able to compile
    the text format of WebAssembly into a format that our browser expects!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们应该能够在命令行中输入“wat2wasm”并获取工具的帮助文档。现在，我们可以将WebAssembly的文本格式编译成浏览器期望的格式！
- en: Now that we've added the WebAssembly binary toolkit to our system and can compile/decompile
    WebAssembly programs, let's start writing our first program in WebAssembly!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将WebAssembly二进制工具包添加到系统中，并且可以编译/反编译WebAssembly程序，让我们开始编写我们的第一个WebAssembly程序！
- en: Writing WebAssembly modules
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写WebAssembly模块
- en: A WebAssembly module is similar to a JavaScript module. We need to explicitly
    import anything we need from other WebAssembly/JavaScript modules. Whatever we
    write in our WebAssembly module can't be found by another WebAssembly module unless
    we explicitly export it. We can think of it as a JavaScript module – it is a sandboxed
    environment.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: WebAssembly模块类似于JavaScript模块。我们需要明确地从其他WebAssembly/JavaScript模块中导入我们需要的任何内容。我们在WebAssembly模块中编写的任何内容，除非我们明确导出它，否则其他WebAssembly模块无法找到。我们可以将其视为JavaScript模块
    - 它是一个沙盒环境。
- en: 'Let''s start off with the most basic and useless version of a WebAssembly module:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从WebAssembly模块的最基本和无用版本开始：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With this, we can go to the command line and run the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以转到命令行并运行以下命令：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This preceding code will spit out a file with the `wasm` extension. This is
    what we need to pass into the web browser to run WebAssembly. All this shows us
    is that WebAssembly, just like ESNext for JavaScript, wants to have everything
    declared in modules. It is easier to think of it like so, which is what happens
    when loading in JavaScript:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将生成一个带有“wasm”扩展名的文件。这是我们需要传递到Web浏览器以运行WebAssembly的文件。所有这些都告诉我们，WebAssembly和JavaScript的ESNext一样，希望在模块中声明所有内容。更容易将其视为在JavaScript中加载时发生的情况：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means that all of the code loaded in the WebAssembly context can't spill
    into other WebAssembly modules that we set. Now, to load this `wasm` file into
    our browser, we need to utilize the static server that we utilized in [Chapter
    9](d1a2a4d4-8ed1-4d82-a098-835d61c01b86.xhtml), *Practical Example - Building
    a Static Server*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在WebAssembly上下文中加载的所有代码都不能溢出到我们设置的其他WebAssembly模块中。现在，要将此“wasm”文件加载到我们的浏览器中，我们需要利用[第9章](d1a2a4d4-8ed1-4d82-a098-835d61c01b86.xhtml)中使用的静态服务器，*实际示例
    - 构建静态服务器*。
- en: 'Once you''ve loaded this up, follow these steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 加载完毕后，按照以下步骤进行：
- en: 'Create a basic `index.html` file that looks as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基本的`index.html`文件，如下所示：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Inside our `script` element, we will add the following code to load the module:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的“script”元素中，我们将添加以下代码来加载模块：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have loaded our first WebAssembly module into the browser. The API is heavily
    promise-based and due to this, we need to utilize the Fetch interface. Once we've
    fetched the object, it's loaded in the WebAssembly context for the browser, which
    means this object is available to us. This is the WebAssembly module that we have
    just loaded up!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将我们的第一个WebAssembly模块加载到浏览器中。API非常基于Promise，因此我们需要利用Fetch接口。一旦我们获取了对象，它就加载到浏览器的WebAssembly上下文中，这意味着我们可以使用这个对象。这就是我们刚刚加载的WebAssembly模块！
- en: 'Let''s go ahead and make a WebAssembly module that is a bit more useful. Let''s
    take in two numbers and add them together. Follow these steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续制作一个更有用的WebAssembly模块。让我们输入两个数字并将它们相加。按照以下步骤进行：
- en: Create a file called `math.wat`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“math.wat”的文件。
- en: 'Put the following code into the file:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码放入文件中：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Compile this by running `wat2wasm math.wat`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行`wat2wasm math.wat`来编译。
- en: 'Load the new `wasm` file into the browser and add the following to the `then`
    body:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的`wasm`文件加载到浏览器中，并在`then`体中添加以下内容：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Make sure that the static server is running by going into the folder and running
    the `static-server` command.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保静态服务器正在运行，方法是进入文件夹并运行`static-server`命令。
- en: For those that have skipped ahead to this chapter, you can install a static
    server by running `npm install -g static-server`. This will install this static
    server globally. Then, all we need to do is run `static-server` in the folder
    that we want to deploy files from. Now that we've done this, we can hit our `index.html`
    file by going to `localhost:9080`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些直接跳到这一章的人，你可以通过运行`npm install -g static-server`来安装一个静态服务器。这将在全局安装这个静态服务器。然后，我们只需要在要部署文件的文件夹中运行`static-server`。现在我们已经做到了这一点，我们可以通过访问`localhost:9080`来打开我们的`index.html`文件。
- en: If we launch our browser, go to `localhost:9080`, and open up the console, we
    will see that the number 300 has been printed out. We have just written our first
    accessible WebAssembly module!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开浏览器，转到`localhost:9080`，并打开控制台，我们会看到数字300已经被打印出来。我们刚刚编写了我们的第一个可访问的WebAssembly模块！
- en: Let's go over some of the concepts we covered in the preceding code. First,
    we defined a function. We stated that the name of this function is `$add` (all
    variables start with a dollar sign in WebAssembly). Then, we stated that it will
    take two parameters that we called `$p1` and `$p2`. Finally, we will output a
    result; that is, a 32-bit integer.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在前面的代码中涵盖的一些概念。首先，我们定义了一个函数。我们声明这个函数的名称是`$add`（在WebAssembly中，所有变量都以美元符号开头）。然后，我们声明它将接受两个我们称为`$p1`和`$p2`的参数。最后，我们将输出一个结果；也就是一个32位整数。
- en: Now, we take the two parameters and store them on our stack. Finally, we add
    them together and use this as a result. Remember at the beginning of this chapter
    when we talked about how programs are stacks? This showcases the exact same concept.
    We loaded our two variables onto the stack. We popped them off so that we could
    use them in the `add` function, which put a new value onto the stack. Finally,
    we popped that value off of the stack and returned it to the main function body;
    in our case, the module.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将两个参数存储在我们的堆栈上。最后，我们将它们相加并将其作为结果。还记得本章开头我们谈到程序是堆栈的吗？这展示了完全相同的概念。我们将两个变量加载到堆栈上。我们弹出它们，以便我们可以在`add`函数中使用它们，这将在堆栈上放置一个新值。最后，我们从堆栈中弹出该值，并将其返回给主函数体；在我们的情况下，是模块。
- en: Next, we exported the function so that our JavaScript code has access to it.
    This makes sure that our WebAssembly code is held in our sandbox, just like we
    want it to be. Now, as we mentioned previously, the object that is returned is
    the WebAssembly context. We grab the instance and look at the exports that are
    available. In our case, this is the `add` function, which we can now utilize in
    our JavaScript code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们导出了这个函数，以便我们的JavaScript代码可以访问它。这确保了我们的WebAssembly代码被保存在我们的沙盒中，就像我们想要的那样。现在，正如我们之前提到的，返回的对象是WebAssembly上下文。我们获取实例并查看可用的导出项。在我们的情况下，这是`add`函数，现在我们可以在我们的JavaScript代码中使用它。
- en: 'Now that we have learned how we can export WebAssembly modules into the JavaScript
    context, you may be wondering if we can load JavaScript functions into the WebAssembly
    context. We can! Let''s go ahead and add the following code to our `index.html` file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何将WebAssembly模块导出到JavaScript上下文中，你可能会想知道我们是否可以将JavaScript函数加载到WebAssembly上下文中。我们可以！让我们继续向我们的`index.html`文件中添加以下代码：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here, we loaded in the `add` function we took from the JavaScript context and
    created an associated function that has the same function signature that our `add`
    function has in JavaScript. Now, we create a new `add` function called `$add2`
    that has a similar signature. We put our two parameters onto the stack and use
    the new `call` instruction. This instruction allows us to call other functions
    that have been declared in our context:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们加载了从JavaScript上下文中获取的`add`函数，并创建了一个具有与JavaScript中`add`函数相同函数签名的关联函数。现在，我们创建了一个新的`add`函数称为`$add2`，具有类似的签名。我们将两个参数放入堆栈中并使用新的`call`指令。这个指令允许我们调用在我们上下文中声明的其他函数：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, we export this function, just like we did with the other `add` function.
    Now, if we compile our code, go back into our browser, and reload the page, we
    will see that the number 300 is printed out twice.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们导出这个函数，就像我们之前对`add`函数做的那样。现在，如果我们编译我们的代码，回到浏览器，重新加载页面，我们会看到数字300被打印出两次。
- en: Now, we know how to use WebAssembly functions in JavaScript and how to load
    JavaScript functions into WebAssembly. We are close to being able to write a program
    famous for being asked in an JavaScript coding interview. Before we do this, though,
    we will need to look at heap space and utilizing memory between JavaScript and
    WebAssembly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何在JavaScript中使用WebAssembly函数，以及如何将JavaScript函数加载到WebAssembly中。我们即将能够编写一个在JavaScript编程面试中经常被问到的程序。不过，在这之前，我们需要看一下堆空间和在JavaScript和WebAssembly之间利用内存。
- en: Sharing memory between WebAssembly and JavaScript
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WebAssembly和JavaScript之间共享内存
- en: So far, we have been working with one type of variable in WebAssembly. These
    are known as local variables, or stack variables. There is another type that will
    allow us to not only utilize them across our WebAssembly context but also share
    them between our JavaScript and our WebAssembly. But first, we will need to discuss
    the differences between the stack and the heap.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在处理WebAssembly中的一种变量类型。这些被称为本地变量，或者堆栈变量。还有另一种类型，它将允许我们不仅在WebAssembly上下文中使用它们，还可以在JavaScript和WebAssembly之间共享它们。但首先，我们需要讨论堆栈和堆之间的区别。
- en: There is a difference between global/local variables and the stack/heap. For
    now, we are going to keep things simple and treat global variables as if they
    are on the heap and local variables as if they are on the stack. Later, our application
    will have a global state that is not on the heap, but it is best to try to keep
    the idea of the local equivalent to the stack and the global equivalent to the
    heap.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 全局/局部变量和堆/栈之间存在差异。现在，我们将保持简单，将全局变量视为在堆上，将局部变量视为在栈上。稍后，我们的应用程序将具有不在堆上的全局状态，但最好尝试将局部等同于栈，全局等同于堆的概念。
- en: We talked about the stack when we talked about how programs run on a typical
    computer. The best way to think of this is a stack of wood. We will always pull
    from the top and always add to the top. This is the same way in programming. We
    add to the top of the stack and then we pull from those top items. As an example,
    let's take the `add` function that we created.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论程序在典型计算机上运行时，我们谈到了堆栈。最好的想法是将其视为一堆木头。我们总是从顶部取出，总是从顶部添加。这在编程中也是一样的。我们在堆栈顶部添加，然后从顶部取出这些项目。例如，让我们看看我们创建的`add`函数。
- en: We grabbed the two parameters and added them to the stack. First, parameter
    one and then parameter two. When we called `$externalAdd` or even if we called
    the `add` function built into WebAssembly, it takes those two items off the stack
    and replaces them with one item, the result. When we return from a function, we
    take that item off the local function stack and pop it on the top of the stack
    of the context for whoever called us.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们抓取了两个参数并将它们添加到堆栈中。首先是参数一，然后是参数二。当我们调用`$externalAdd`，甚至是调用内置在WebAssembly中的`add`函数时，它会从堆栈中取出这两个项目，并用一个项目替换它们，即结果。当我们从函数返回时，我们会从本地函数堆栈中取出该项目，并将其弹出到调用我们的上下文的堆栈顶部。
- en: A heap is just like what its name implies. We have the blob of things that can
    be grabbed, changed, and replaced from everywhere. Anyone can get to the heap,
    put items into it, and read from it. It's like a heap of clothes – we can search
    through it and find the item we need, or we can just add to it at the end of the
    day.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 堆就像其名字所暗示的那样。我们有一堆可以从任何地方抓取、更改和替换的东西。任何人都可以访问堆，向其中放入项目并从中读取。就像一堆衣服一样 - 我们可以搜索并找到我们需要的项目，或者我们可以在一天结束时向其中添加项目。
- en: The main difference between the two is that the stack will get cleaned up. Any
    variables that we created inside it, once the function returns, are cleaned up.
    On the other hand, the heap stays there. Since anyone has access to it, we have
    to explicitly get rid of it; otherwise, it will be there permanently. In garbage-collected
    environments, the best way to think of this is that our environment doesn't know
    who else has items on it, so it doesn't know what needs to be cleaned up and what
    doesn't.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的主要区别在于栈会被清理。一旦函数返回，我们在其中创建的任何变量都会被清理。另一方面，堆会一直存在。由于任何人都可以访问它，我们必须明确地摆脱它；否则，它将永久存在。在垃圾收集环境中，最好的想法是，我们的环境不知道谁还在上面放了东西，所以它不知道什么需要清理，什么不需要清理。
- en: In WebAssembly, we don't have a garbage-collected environment, so we have to
    recollect the heap once we are done with it in our JavaScript or WebAssembly context.
    In our examples, we won't be doing this, so note that this is something we would
    want to do in a production-style environment. To do this, we could just set the
    `memory` object in JavaScript to `null`. This will let the garbage collector know
    that no one is utilizing it anymore.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在WebAssembly中，我们没有垃圾收集环境，因此我们必须在JavaScript或WebAssembly上下文中完成后重新收集堆。在我们的示例中，我们不会这样做，因此请注意这是我们在生产环境中想要做的事情。为此，我们可以将JavaScript中的`memory`对象设置为`null`。这将让垃圾收集器知道没有人再使用它了。
- en: 'Let''s learn how to share memory between JavaScript and WebAssembly and how
    that is equivalent to the heap. Follow these steps:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何在JavaScript和WebAssembly之间共享内存，以及这如何等同于堆。按照以下步骤进行：
- en: Create a file named `sharing_resources.wat`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sharing_resources.wat`的文件。
- en: 'Put the following code inside the file:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码放入文件中：
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our first function stores the number `100` at memory location `0`. If we were
    storing an arbitrary amount of data, we would have to let whoever called us know
    how much we stored. However, in this case, we always know that it is just one
    number.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个函数将数字`100`存储在内存位置`0`。如果我们要存储任意数量的数据，我们必须让调用我们的人知道我们存储了多少。但是，在这种情况下，我们总是知道只有一个数字。
- en: Our `read` function just reads that value from memory and returns it as a value.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`read`函数只是从内存中读取该值并将其作为一个值返回。
- en: 'Our script section inside the `index.html` file should look something like
    the following:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`index.html`文件中的脚本部分应该如下所示：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The top section should look different. First, we are creating a piece of memory
    that both JavaScript and WebAssembly can share. We are going to create and load
    only one section of memory. In the context of WebAssembly, this is 64 KB worth
    of data.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部部分应该看起来不同。首先，我们正在创建一个JavaScript和WebAssembly都可以共享的内存块。我们将只创建和加载一个内存块。在WebAssembly的上下文中，这是64KB的数据。
- en: Once our WebAssembly has loaded, we store the number and then read it out. Now,
    we can see that we have a global state in WebAssembly, but how would we share
    this with our JavaScript? Well, that starting section of the code tells us how.
    We have access to the memory object, so we should be able to get at it. Let's
    go ahead and change our script a bit so that we can read the memory directly inside
    JavaScript instead of calling a function that does this for us.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的WebAssembly加载完成，我们存储该数字，然后读取它。现在，我们可以看到我们在WebAssembly中有一个全局状态，但是我们如何与JavaScript共享呢？好吧，代码的起始部分告诉了我们如何做。我们可以访问内存对象，所以我们应该能够获取它。让我们继续改变我们的脚本，以便我们可以直接在JavaScript中读取内存，而不是调用一个为我们执行此操作的函数。
- en: 'The following code should do this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码应该可以做到这一点：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can add this to the body after our WebAssembly has loaded:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在WebAssembly加载完成后将其添加到body中：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If we look inside our console, we should see the exact same output! The final
    test is to store something from JavaScript and grab it inside WebAssembly. We
    can achieve this by changing the script to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看控制台，我们应该看到完全相同的输出！最后的测试是从JavaScript中存储一些东西并在WebAssembly中抓取它。我们可以通过将脚本更改为以下内容来实现这一点：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we save this and go back to our console, we should see that the number 200 is
    printed out!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保存这个并返回到控制台，我们应该看到数字200被打印出来！
- en: 'Now, we know how to share memory between two instances and how we can utilize
    this to do some cool stuff. Let''s go ahead and put all of our skills to the test
    and create every programmer''s favorite program: FizzBuzz.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何在两个实例之间共享内存，以及如何利用这一点来做一些很酷的事情。让我们继续测试我们所有的技能，并创建每个程序员最喜欢的程序：FizzBuzz。
- en: Writing FizzBuzz in WebAssembly
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在WebAssembly中编写FizzBuzz
- en: 'FizzBuzz is a programming challenge that requires a user to take in a positive
    number loop from 1 to a chosen number and print out the results based on the following
    criteria:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: FizzBuzz是一个编程挑战，要求用户输入一个正数循环从1到一个选择的数字，并根据以下标准打印结果：
- en: If the number is divisible by 3, then print *Fizz*
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字可以被3整除，则打印*Fizz*
- en: If the number is divisible by 5, then print *Buzz*
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字可以被5整除，则打印*Buzz*
- en: If the number is divisible by 15, then print *FizzBuzz*
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字可以被15整除，则打印*FizzBuzz*
- en: 'Let''s go ahead and kick this off by getting our JavaScript environment ready.
    The following code should look familiar, except for our new logging function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续准备我们的JavaScript环境。以下代码应该看起来很熟悉，除了我们的新日志函数：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function takes in the offset of the memory and the length of the data
    and prints it out. As we mentioned previously, we need to know where the data
    is, as well as its length, to be able to read it from the heap. Now, we can get
    into the heart of the program. Follow these steps to do so:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受内存偏移和数据长度，并将其打印出来。正如我们之前提到的，我们需要知道数据在哪里以及其长度，才能从堆中读取它。现在，我们可以进入程序的核心。按照以下步骤操作：
- en: Create a new file called `fizzbuzz.wat`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fizzbuzz.wat`的新文件。
- en: 'We know that we will need to import both our memory and the `console` function,
    just like we have been importing other functions. We also know that we will be
    creating a function called `fizzbuzz` and that we will be exporting this so that
    our JavaScript context can utilize it:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道我们需要导入我们的内存和`console`函数，就像我们一直在导入其他函数一样。我们还知道我们将创建一个名为`fizzbuzz`的函数，并将其导出，以便我们的JavaScript上下文可以利用它：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The only interesting piece of the preceding code is the `global` section. This
    is a global variable that can be thought of as the stack of our context. It isn't
    on the heap, so the JavaScript context doesn't have access to it. We can also
    see the `mut` keyword in front of the declaration. This tells us that we are going
    to be changing the global variable from the various parts of our WebAsembly code.
    We are going to utilize this so that it holds the length of our print out.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的唯一有趣的部分是`global`部分。这是一个全局变量，可以被视为我们上下文的堆栈。它不在堆上，因此JavaScript上下文无法访问它。我们还可以看到声明前面的`mut`关键字。这告诉我们我们将从WebAsembly代码的各个部分更改全局变量。我们将利用这一点，使其保存我们的打印输出的长度。
- en: 'We will need to check for both conditions of FizzBuzz:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要检查FizzBuzz的两种情况：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Both of our functions will take a number. For the `checkFizz` function, we will
    test to see if it is divisible by 3\. If it is, we will store the word *Fizz*
    in the memory heap where the global variable is and then update that global variable
    to the location after the word *Fizz*. For *Buzz*, we will do the exact same thing,
    except we will test to see if the number is divisible by 5\. If this is `true`,
    we will put *Buzz* in the global pointer location and update it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个函数都将接受一个数字。对于`checkFizz`函数，我们将测试它是否可以被3整除。如果可以，我们将在内存堆中存储单词*Fizz*，然后更新该全局变量为*Fizz*之后的位置。对于*Buzz*，我们将做完全相同的事情，只是我们将测试数字是否可以被5整除。如果是`true`，我们将在全局指针位置放置*Buzz*并更新它。
- en: 'The following is the `checkFizz` function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`checkFizz`函数：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we grab the number that was passed in. Then, we put `3` on the stack and
    run the remainder function. If the result is equal to `0`, then we put the word
    *Fizz* into memory. Now, what's being put into memory may not look like the word
    *Fizz*, but if we look at the UTF8 decimal numbers for each of the letters, we
    will see that that is what we are putting into memory.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们获取传入的数字。然后，我们将`3`放在堆栈上并运行余数函数。如果结果等于`0`，那么我们将单词*Fizz*放入内存中。现在，放入内存的内容可能看起来不像单词*Fizz*，但是如果我们查看每个字母的UTF8十进制数，我们将看到这就是我们放入内存的内容。
- en: If we head back to our JavaScript code, we will see that we are utilizing a
    `TextDecoder`. This allows us to read these byte values and translate them into
    their string equivalent. Since WebAssembly only understands the concept of integers
    and floating-point numbers, this is how we have to deal with it for now.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到JavaScript代码，我们会看到我们正在使用`TextDecoder`。这允许我们读取这些字节值并将它们转换为它们的字符串等价物。由于WebAssembly只理解整数和浮点数的概念，这是我们现在必须处理它的方式。
- en: 'Next is the `checkBuzz` function. It should look similar to the preceding code,
    except for the divisible, which is `5`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`checkBuzz`函数。它应该与前面的代码类似，除了可被`5`整除：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can write `fizzbuzz`. We will take in the integer and then loop from
    `1` to that value running our `checkFizz` and `checkBuzz` functions:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以编写`fizzbuzz`。我们将接受整数，然后从`1`到该值运行我们的`checkFizz`和`checkBuzz`函数：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The loop is fairly simple. `br_if` tests to see whether our `start` variable
    equals what we put in. If it does, it will equal `1` and it will break out of
    the loop. Otherwise, it will increment the `start` variable by one. `(br 0)` is
    what keeps the loop going.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 循环非常简单。`br_if`测试我们的`start`变量是否等于我们输入的值。如果是，它将等于`1`，并且将退出循环。否则，它将递增`start`变量一次。`(br
    0)`是保持循环进行的部分。
- en: 'Once we have finished the loop, we will get our global variable, wherever it
    finished up, and call the `log` function. Let''s compile this and run the following
    test:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 完成循环后，我们将得到我们的全局变量，无论它最终在哪里，然后调用`log`函数。让我们编译并运行以下测试：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'By doing this, we should get the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们应该得到以下输出：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have just written a nontrivial program in pure WebAssembly! By now, you should
    have realized why most people don't write in pure WebAssembly since what should
    have been a simple program took us quite a bit of coding.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在纯WebAssembly中编写了一个非平凡的程序！到目前为止，您应该已经意识到为什么大多数人不会纯粹地编写WebAssembly，因为本应该是一个简单的程序却花了我们相当多的代码。
- en: In the next section, we'll learn how to use a higher-level language, C, to write
    programs for the web.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用更高级的语言C来为Web编写程序。
- en: Writing C/C++ for the web
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Web编写C/C++
- en: So far, we have taken a look at writing the low-level instruction language of
    WebAssembly. While this can be a fun exercise to take on, most of our projects
    will be much grander in scale and we will want to utilize a high-level language
    to accomplish our goals. While there are languages out there that will compile
    to WebAssembly that are similar to JavaScript ([https://github.com/AssemblyScript/assemblyscript](https://github.com/AssemblyScript/assemblyscript)),
    a good chunk of modules will be written while utilizing system languages such
    as C, C++, or Rust. In this section, we will take a look at writing C/C++ code
    for the browser.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经研究了编写WebAssembly的低级指令语言。虽然这可能是一个有趣的练习，但我们大多数项目的规模会更大，我们希望利用高级语言来实现我们的目标。虽然有一些类似于JavaScript的语言会编译成WebAssembly（[https://github.com/AssemblyScript/assemblyscript](https://github.com/AssemblyScript/assemblyscript)），但大部分模块将使用C、C++或Rust等系统语言编写。在本节中，我们将研究为浏览器编写C/C++代码。
- en: The Rust language ([https://www.rust-lang.org/](https://www.rust-lang.org/))
    provides us with a safer alternative to C/C++. While utilizing it may be better
    in the long run, we are going to stick with C/C++ since this is what we will widely
    compile to WebAssembly for the foreseeable future since most programs are currently
    written in it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Rust语言（[https://www.rust-lang.org/](https://www.rust-lang.org/)）为我们提供了一个比C/C++更安全的选择。虽然长远来看使用它可能更好，但我们将坚持使用C/C++，因为在可预见的未来，我们将广泛地将其编译为WebAssembly，因为大多数程序目前都是用它编写的。
- en: 'For us to begin our C/C++ writing adventure, we will need to grab the Emscripten
    SDK to compile to WebAssembly. This can be found at [https://emscripten.org/index.html](https://emscripten.org/index.html).
    We will mostly be following the *Getting started* guide that Emscripten provides.
    Follow these steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始我们的C/C++写作之旅，我们需要获取Emscripten SDK来编译为WebAssembly。这可以在[https://emscripten.org/index.html](https://emscripten.org/index.html)找到。我们将主要遵循Emscripten提供的*入门*指南。按照以下步骤：
- en: 'First, we will clone the Emscripten SDK by running the following command:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将克隆Emscripten SDK，运行以下命令：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Head into the directory by using the following command:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令进入目录：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Pull the latest changes and the following commands:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取最新更改和以下命令：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have the preceding commands to aid us, we are ready to start writing
    C and C++ for the web! Let''s go ahead and start with an easy module:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了前面的命令来帮助我们，我们准备开始为Web编写C和C++！让我们开始一个简单的模块：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This basic C program is everybody''s favorite Hello World program. To compile
    this program, go ahead and run the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本的C程序是大家最喜欢的Hello World程序。要编译这个程序，请运行以下命令：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If everything has been installed correctly, we should get the following two
    files:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切安装正确，我们应该得到以下两个文件：
- en: '`a.out.wasm`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a.out.wasm`'
- en: '`a.out.js`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a.out.js`'
- en: 'With these two files, we can utilize an `index.html` file and load them in,
    like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这两个文件，我们可以利用一个`index.html`文件并加载它们，就像这样：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We should get a printout of **Hello World!** to our console! Let''s go ahead
    and write another C program, just like the previous WebAssembly program we wrote –
    FizzBuzz:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在控制台上得到一个**Hello World!**的输出！让我们继续编写另一个C程序，就像我们之前写的WebAssembly程序一样 - FizzBuzz：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If we compile this and try to run it, we will see that nothing is found. The
    documentation states that it should be on the global `Module` variable, but if
    we check there, we will see that there is no `fizzbuzz` program to be found. Fortunately,
    Emscripten does dead code analysis for us and noticed that our C program doesn't
    have a `main` function and that it doesn't call the `fizzbuzz` function, so it
    eliminated it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译并尝试运行它，我们会发现什么也找不到。文档说明应该在全局`Module`变量上，但如果我们检查那里，我们会发现没有`fizzbuzz`程序。幸运的是，Emscripten为我们进行了死代码分析，并注意到我们的C程序没有`main`函数，也没有调用`fizzbuzz`函数，因此将其消除了。
- en: 'To handle this, we can add an argument to our `emcc` call:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个问题，我们可以在`emcc`调用中添加一个参数：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: All of our functions will have an underscore before them. This helps us and
    the system differentiate what may be created in the JavaScript system and what
    is being created in the C/C++ context.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有的函数都会在它们之前加上下划线。这有助于我们和系统区分在JavaScript系统中可能创建的内容和在C/C++上下文中创建的内容。
- en: 'With this, we can go into the browser and our developer console and type the
    following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以进入浏览器和我们的开发者控制台，输入以下内容：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We should see a printout! We have just compiled our first library function from
    C that can be used in our JavaScript code. Now, what if we want to try something
    a little more difficult? What if we want to run a JavaScript function inside our
    C/C++ code?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到一个输出！我们刚刚编译了我们的第一个可以在JavaScript代码中使用的来自C的库函数。现在，如果我们想尝试一些更困难的东西怎么办？如果我们想在我们的C/C++代码中运行一个JavaScript函数怎么办？
- en: 'To do this, we will have to do the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将不得不执行以下操作：
- en: 'We will need to put an `extern` declaration at the top of our file (Emscripten
    will look in the JS location first, but we can also pass a command-line flag to
    tell it where else to look):'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在文件顶部放置一个`extern`声明（Emscripten首先会在JS位置查找，但我们也可以传递一个命令行标志来告诉它在其他地方查找）：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we will create an `external.js` file that will house our new function:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为`external.js`的文件，用来存放我们的新函数：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we can compile our program with the following line of code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以用以下代码行来编译我们的程序：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: After, we can head back to the browser and see that it prints out 300! Now,
    we know how to use external JavaScript in our C/C++ programs and we can grab our
    C/C++ code from the browser.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以回到浏览器，看到它打印出了300！现在，我们知道如何在我们的C/C++程序中使用外部JavaScript，并且可以从浏览器中获取我们的C/C++代码。
- en: 'All this time, we have been overwriting our files, but is there another way
    for us to handle this? Of course – we can call the `emcc` system with the `emcc
    -o <file_name.js>` flag. Therefore, we can compile our `extern.c` file and call
    it `extern.js` by running the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一直以来，我们一直在覆盖我们的文件，但是有没有其他方法来处理这个问题呢？当然有 - 我们可以使用`emcc -o <file_name.js>`命令来调用`emcc`系统。因此，我们可以通过运行以下命令来编译我们的`extern.c`文件并将其命名为`extern.js`：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Alternatively, we can go to their website: [https://emscripten.org/](https://emscripten.org/).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以去他们的网站：[https://emscripten.org/](https://emscripten.org/)。
- en: Now that we are able to write and compile C code for our browser, we will turn
    our attention to utilizing this power. Let's implement a hamming code generator
    that we can utilize in JavaScript that is written in C and can be compiled to
    WebAssembly.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够为我们的浏览器编写和编译C代码，我们将把注意力转向利用这一功能。让我们实现一个海明码生成器，我们可以在JavaScript中使用，它是用C编写的，并且可以编译成WebAssembly。
- en: Writing a hamming code generator
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写海明码生成器
- en: Now, we are going to write a complicated piece of software. A hamming code generator
    creates a piece of data that should be able to be recovered when it is transmitted
    between two mediums. These mediums could be anything from a computer to another
    computer or even a process to another process (although we should hope that data
    transmission between processes does not get corrupted). The data that we will
    be adding to accomplish this is known as hamming codes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将要编写一段复杂的软件。海明码生成器创建了一段数据，当它在两个媒介之间传输时应该能够被恢复。这些媒介可以是任何东西，从计算机到另一个计算机，甚至是一个进程到另一个进程（尽管我们希望进程之间的数据传输不会被损坏）。我们将要添加的数据被称为海明码。
- en: To write this piece of software, we will need to understand how a hamming code
    is generated and how we can use a verifier to make sure that the data that does
    cross from one medium to another is correct. Specifically, we will be looking
    at the creation of hamming data and the verification process. We won't be looking
    at recovering the data as this is close to the reverse process of creating the
    data.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写这个软件，我们需要了解海明码是如何生成的，以及我们如何使用验证器来确保从一个媒介传输到另一个媒介的数据是正确的。具体来说，我们将研究海明数据的创建和验证过程。我们不会研究数据的恢复，因为这与创建数据的过程几乎相反。
- en: 'To understand how hamming data is created, we will need to look at data at
    the bit level. This means that if we want to transmit the number 100, we need
    to know what that looks like in terms of bits. Bits are the lowest data unit for
    a computer. A bit can only be a 0 or a 1\. As we add more bits together, they
    represent the power of 2\. The following table should help showcase this a bit:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解海明数据是如何创建的，我们需要查看位级别的数据。这意味着如果我们想要传输数字100，我们需要知道它在位上是什么样子的。位是计算机的最低数据单元。一个位只能是0或1。当我们将更多的位加在一起时，它们代表2的幂。以下的表格应该有助于展示这一点：
- en: '| **Bit 3** | **Bit 2** | **Bit 1** | **Bit 0** |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| **位3** | **位2** | **位1** | **位0** |'
- en: '| 8 | 4 | 2 | 1 |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 4 | 2 | 1 |'
- en: '| 2^3 | 2^2 | 2^1 | 2^0 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 2^3 | 2^2 | 2^1 | 2^0 |'
- en: As we can see, each bit location represents the next power of two. If we mix
    and match these bits together, we will find that we can represent all positive
    real numbers. There are also ways to represent negative and even floating-point
    numbers, but we will not be going into that here.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，每个位位置代表下一个2的幂。如果我们混合和匹配这些位，我们会发现我们可以表示所有正实数。还有一些方法可以表示负数甚至浮点数，但我们在这里不会涉及到这些。
- en: For those that are curious, an article on floating-point representation can
    be found here: [https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_representation.html.](https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_representation.html)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些好奇的人，关于浮点表示的文章可以在这里找到：[https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_representation.html.](https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_representation.html)
- en: 'So, if we wanted to see these numbers in their binary form, we could go through
    them one at a time. The following table shows the decimal notation on the left
    and the binary representation on the right (decimal is what we are used to):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们想要以二进制形式看到这些数字，我们可以一个一个地查看它们。下表显示了左边的十进制表示和右边的二进制表示（十进制是我们习惯的）：
- en: '| 0 | 0000 |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0000 |'
- en: '| 1 | 0001 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0001 |'
- en: '| 2 | 0010 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0010 |'
- en: '| 3 | 0011 |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 0011 |'
- en: '| 4 | 0100 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 0100 |'
- en: '| 5 | 0101 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0101 |'
- en: '| 6 | 0110 |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0110 |'
- en: '| 7 | 0111 |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 0111 |'
- en: '| 8 | 1000 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 1000 |'
- en: Hopefully, this clarifies how bits and binary representation works. Now, we
    are going to move on to how hamming codes actually work. Hamming codes work by
    adding what is known as parity bits to special locations in the data transmission
    process. These parity bits will either be a 1 or a 0, depending on the type of
    parity that we select.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这样能澄清位和二进制表示是如何工作的。现在，我们将继续讲解海明码的实际工作原理。海明码通过在数据传输过程中的特定位置添加所谓的奇偶校验位来工作。这些奇偶校验位将根据我们选择的奇偶校验类型，要么是1，要么是0。
- en: The two types of parity that we can choose are even parity and odd parity. Even
    parity means that when we add up all of the bit locations for that parity bit,
    they need to be an even number. If we choose odd parity, we need to add up all
    the bits for that parity location and check to make sure they are odd. Now, we
    need to decide what bits correspond to each parity bit location and even where
    the parity bits go.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择的两种奇偶校验类型是偶校验和奇校验。偶校验意味着当我们为奇偶校验位的所有位位置相加时，它们需要是偶数。如果我们选择奇校验，我们需要为奇校验位置的所有位进行相加，并检查它们是否是奇数。现在，我们需要决定哪些位对应于每个奇偶校验位位置，甚至奇偶校验位的位置。
- en: 'First, we will take a look at where the parity bits go. Parity bits will be
    at the bit location for each power of 2\. Just as we saw in the preceding table,
    we will host our parity bits at the following bit locations: 1, 2, 4, 8, and 16\.
    If we look at the preceding table, we will notice that these correspond to the
    bits where there is only a single bit set.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看奇偶校验位放在哪里。奇偶校验位将位于每个2的幂的位置。就像我们在前面的表格中看到的那样，我们将在以下位位置放置我们的奇偶校验位：1、2、4、8和16。如果我们看前面的表格，我们会注意到这些对应于只有一个位设置的位。
- en: 'Now, we need to decide which data bit locations correspond to our parity bit
    locations. Well, we might be able to guess these based on where the parity bits
    are located. For each data bit, we will look at if they have the corresponding
    parity bit set there. This can be seen in the following table:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要决定哪些数据位位置对应于我们的奇偶校验位位置。嗯，我们可以根据奇偶校验位的位置猜测这些位置。对于每个数据位，我们将查看它们是否在相应的奇偶校验位设置了。这可以在以下表格中看到：
- en: '| **Number (Decimal Format)** | **Is It A Parity Bit?** | **Parity Bits That
    Use This Data** |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| **数字（十进制格式）** | **它是奇偶校验位吗？** | **使用此数据的奇偶校验位** |'
- en: '| 1 | Yes | N/A |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 是 | N/A |'
- en: '| 2 | Yes | N/A |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 是 | N/A |'
- en: '| 3 | No | 1, 2 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 否 | 1, 2 |'
- en: '| 4 | Yes | N/A |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 是 | N/A |'
- en: '| 5 | No | 1, 4 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 否 | 1, 4 |'
- en: '| 6 | No | 2, 4 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 否 | 2, 4 |'
- en: '| 7 | No | 1, 2, 4 |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 否 | 1, 2, 4 |'
- en: '| 8 | Yes | N/A |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 是 | N/A |'
- en: The final piece that we need to know about is how to mesh our data with the
    parity data. The best way to look at this is through an example. Let's take the
    number 100 and turn it into its binary representation. We could do this by hand
    or we could pull up a programmer's calculator, which most operating systems have.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道的最后一件事是如何将我们的数据与奇偶校验数据相结合。最好的方法是通过一个例子来看。让我们以数字100为例，并将其转换为二进制表示。我们可以手工完成这项工作，或者我们可以打开程序员计算器，大多数操作系统都有。
- en: 'If we open up our calculator and type in 100, we should get the following binary
    representation of it: 1100100\. Now, to add our parity bits, we will need to shift
    our data bits based on whether we place a parity bit there or not. Let''s take
    this a step at a time:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开计算器并输入100，我们应该得到它的以下二进制表示：1100100。现在，为了添加我们的奇偶校验位，我们需要根据我们是否在那里放置奇偶校验位来移动我们的数据位。让我们一步一步地来：
- en: Is the first bit used as a parity bit? Yes, so we will place a 0 there and shift
    our data to the left once. We now have 11001000.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一位是否用作奇偶校验位？是的，所以我们将在那里放置一个0，并将我们的数据向左移动一次。现在我们有11001000。
- en: Is the second bit used as a parity bit? Yes, so we will place a 0 there and
    shift our data to the left once. We now have 110010000.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二位是否用作奇偶校验位？是的，所以我们将在那里放置一个0，并将我们的数据向左移动一次。现在我们有110010000。
- en: 'Is the third bit used as a parity bit? No, so we can put our original first
    data bit there, which is a zero. Our data looks the same as before: 110010000.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三位是否用作奇偶校验位？否，所以我们可以把我们原来的第一个数据位放在那里，即0。我们的数据看起来和以前一样：110010000。
- en: Is the fourth bit used as a parity bit? Yes, so we will place a 0 there and
    shift our data to the left once. We now have 1100100000.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第四位是否用作奇偶校验位？是的，所以我们将在那里放置一个0，并将我们的数据向左移动一次。现在我们有1100100000。
- en: 'Is the fifth bit used as a parity bit? No, so we will place our original second
    data bit there, which is a zero. Our data looks the same as before: 1100100000.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第五位是否用作奇偶校验位？否，所以我们将把我们原来的第二个数据位放在那里，即0。我们的数据看起来和以前一样：1100100000。
- en: 'Is the sixth bit used as a parity bit? No, so we will place our original third
    data bit there, which is a one. Our data looks the same as before: 1100100000.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第六位是否用作奇偶校验位？否，所以我们将把我们原来的第三个数据位放在那里，即1。我们的数据看起来和以前一样：1100100000。
- en: 'Is the seventh bit used as a parity bit? No, so we will place our original
    fourth data bit there, which is a zero. Our data looks as follows: 1100100000.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第七位是否用作奇偶校验位？否，所以我们将把我们原来的第四个数据位放在那里，即0。我们的数据看起来如下：1100100000。
- en: 'Is the eight-bit used as a parity bit? Yes, so we will shift our data to the
    left one and place a zero there. Our data looks as follows: 11000100000.'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第八位是否用作奇偶校验位？是的，所以我们将把我们的数据向左移动一位，并在那里放置一个零。我们的数据如下：11000100000。
- en: 'For the rest of the numbers, they stay the same since we have no more parity
    bits to place. Now that we have our data, we have to set our parity bits. We will
    use even parity for our example and the code. The following table showcases the
    final number and the reason why we had to set a parity bit to one or zero:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其余的数字，它们保持不变，因为我们没有更多的奇偶校验位要放置。现在我们有了我们的数据，我们必须设置我们的奇偶校验位。我们将在我们的示例和代码中使用偶校验。以下表格展示了最终数字以及我们必须将奇偶校验位设置为1或零的原因：
- en: '| **Bit Location** | **Binary For Location** | **Do We Set It?** | **Count
    For Parity** |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| **位位置** | **该位置的二进制** | **我们是否设置它？** | **奇偶校验的计数** |'
- en: '| 1 | 00001 | Yes | 1 |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 00001 | 是 | 1 |'
- en: '| 1 | 00010 | Yes | 3 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 00010 | 是 | 3 |'
- en: '| 0 | 00011 | N/A |  |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 00011 | N/A |  |'
- en: '| 1 | 00100 | Yes | 1 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 00100 | 是 | 1 |'
- en: '| 0 | 00101 | N/A |  |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 00101 | N/A |  |'
- en: '| 1 | 00110 | N/A |  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 00110 | N/A |  |'
- en: '| 0 | 00111 | N/A |  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 00111 | N/A |  |'
- en: '| 0 | 01000 | No | 2 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 01000 | 否 | 2 |'
- en: '| 0 | 01001 | N/A |  |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 01001 | N/A |  |'
- en: '| 1 | 01010 | N/A |  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 01010 | N/A |  |'
- en: '| 1 | 01011 | N/A |  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 01011 | N/A |  |'
- en: As shown in the preceding table, we had to set the parity bits for the 1, 2,
    and 4 locations. Let's take a look at the second bit and go through the process.
    We will look for any bit locations where their binary representation has the second-bit
    set. If the bit is set at that location, we will count it. After adding up all
    of these numbers, if they add up to an odd number, we will need to set the parity
    bit location. For the second bit, we can see that the number 6, 10, and 11 locations
    have their second-bit set and that they have a 1 at them. This is why we have
    a count of three, which means we need to set our parity bit to make sure we have
    even parity.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如前表所示，我们需要为1、2和4位置设置奇偶校验位。让我们看看第二位并经历这个过程。我们将寻找任何二进制表示中第二位设置的位位置。如果位在该位置被设置，我们将对其进行计数。在将所有这些数字相加后，如果它们相加得到奇数，我们需要设置奇偶校验位位置。对于第二位，我们可以看到6、10和11位置的数字有第二位设置，并且它们有一个1。这就是为什么我们有三个计数，这意味着我们需要设置奇偶校验位以确保我们有偶校验。
- en: This is a lot of information to take in, and rereading the preceding sections
    may help you understand how we got to this final parity number. If you want to
    find out more, go to [https://www.geeksforgeeks.org/hamming-code-in-computer-network/](https://www.geeksforgeeks.org/hamming-code-in-computer-network/).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多信息要消化，重新阅读前面的部分可能有助于理解我们是如何得到最终的奇偶校验数的。如果想了解更多，请访问[https://www.geeksforgeeks.org/hamming-code-in-computer-network/](https://www.geeksforgeeks.org/hamming-code-in-computer-network/)。
- en: Now, with all of this theory out of the way, let's go ahead and start writing
    our C program to be able to create parity data and also verify it.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，理论都讲完了，让我们开始编写C程序，能够创建奇偶校验数据并进行验证。
- en: 'First, let''s create a file called `hamming.c`. We will create this as a pure
    library file, so we won''t have the `main` function. Now, let''s go ahead and
    stub out our functions just to get an idea of what we want to do. Follow these
    steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为`hamming.c`的文件。我们将把它创建为一个纯库文件，所以我们不会有`main`函数。现在，让我们先梳理一下我们的函数，以便了解我们想要做什么。按照以下步骤进行：
- en: 'To create our data, we will need to read in the data and move the data bits
    to the proper locations, the same way that we did previously. Let''s go ahead
    and call this function `placeBits`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建我们的数据，我们需要读取数据并将数据位移动到正确的位置，就像我们之前做的那样。让我们称这个函数为`placeBits`：
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can see something interesting about the method signature of the `placeBits`function.
    It is taking in an `int*`. For JavaScript developers, this will be a new concept.
    We are passing in the location of the data instead of passing in the data itself.
    This is known as passing by reference. Now, the idea is similar to what it's like
    in JavaScript; that is, if we pass an object, we are passing the reference to
    it. This means that when we make changes to that data, we will see these changes
    in the original function. It is the same concept as the previous one, but we have
    a bit more control over this. If we don't pass by reference, it would pass by
    value, meaning we would get a copy of the preceding data and we wouldn't see the
    changes reflected in our `createData` function.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`placeBits`函数的方法签名有一些有趣。它接受一个`int*`。对于JavaScript开发人员来说，这将是一个新概念。我们传递的是数据的位置，而不是数据本身。这被称为按引用传递。现在，这个想法与JavaScript中的情况类似；也就是说，如果我们传递一个对象，我们传递的是对它的引用。这意味着当我们对数据进行更改时，我们将在原始函数中看到这些更改。这与前面的概念相同，但我们对此有更多的控制。如果我们不按引用传递，它将按值传递，这意味着我们会得到前面数据的副本，并且我们不会看到在`createData`函数中反映出的更改。
- en: 'Now, we need to have a function that figures out if we set the parity bit for
    that location. We will call this `createParity`. It should have a method signature
    that looks like this:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个函数来确定我们是否为该位置设置了奇偶校验位。我们将称之为`createParity`。它的方法签名应该是这样的：
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Again, we are passing in a reference to the data instead of passing the data
    itself.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们传递的是数据的引用，而不是数据本身。
- en: 'For our data checking algorithm, we will be going through each parity bit and
    checking the respective data locations for each. We will call this function `checkAndVerifyData`
    and it will have the following method signature:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的数据检查算法，我们将逐个检查每个奇偶校验位，并检查各自的数据位置。我们将称这个函数为`checkAndVerifyData`，它将具有以下方法签名：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, instead of a Boolean, we will be passing back an `int`, where `-1` means
    that the data is bad and `1` means that the data is good. In basic C, we don't
    have the concept of a Boolean, so we use numbers to represent the concepts of
    true or false (there is a Boolean in the `stdbool` header, but if we look at it,
    it utilizes the concept of `0` being `false` and `1` being `true`, so it still
    utilizes the numbers underneath). We can also make the system more robust by making
    each negative number mean a specific error code. In our case, we will just use
    `-1`, but this can be improved.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将传回一个`int`，而不是一个布尔值，其中`-1`表示数据有问题，`1`表示数据正常。在基本的C中，我们没有布尔值的概念，所以我们使用数字来表示真或假的概念（在`stdbool`头文件中有一个布尔值，但如果我们看一下它，它利用`0`表示`false`和`1`表示`true`的概念，所以它仍然利用了底层的数字）。我们还可以通过使每个负数表示特定的错误代码来使系统更健壮。在我们的情况下，我们只会使用`-1`，但这可以改进。
- en: 'Now, we can begin filling out our functions. First, we will place our data
    in the correct locations and make sure we have room for our parity bits. This
    will look as follows:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始填写我们的函数。首先，我们将把我们的数据放在正确的位置，并确保我们有奇偶校验位的空间。这将如下所示：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: First, we created a constant known as `INT_SIZE`. This allows us to handle different
    types of environments (although WebAssembly is supposed to be a standardized environment
    to work in, this allows us to use this C program elsewhere). We are also utilizing
    three special functions: `ceil`*,* `floor`, and `log2`. All of these can be found
    in the math library that comes with the standard library for C.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为`INT_SIZE`的常量。这允许我们处理不同类型的环境（尽管WebAssembly应该是一个标准化的工作环境，但这使我们可以在其他地方使用这个C程序）。我们还使用了三个特殊函数：`ceil`，`floor`和`log2`。所有这些都可以在标准C库附带的数学库中找到。
- en: 'We get this by importing the header file at the top of our file:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在文件顶部导入头文件来实现这一点：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The iteration process works like so:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代过程如下：
- en: It checks to see if we are at a parity bit section. If we are, we will skip
    it and move on to the next section.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检查是否处于奇偶校验位部分。如果是，我们将跳过它并继续下一部分。
- en: If we are not at a parity bit section, we will take the bit in our data at `dataIterator`.
    This counter keeps count of our location in the data that we passed in. All of
    the preceding operations are bit operations. The `|` tells us we are doing a bitwise
    or, which means that the bit will be set to a `1` if the left-hand side (the parity
    variable), the right-hand side (our equation), or both are `1`; otherwise, it
    will be a `0`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们不处于奇偶校验位部分，我们将获取我们在`dataIterator`处的数据位。这个计数器记录了我们在传入的数据中的位置。所有前面的操作都是位操作。`|`告诉我们我们正在进行按位或操作，这意味着如果左边（奇偶变量）、右边（我们的等式）或两者都是`1`，那么该位将被设置为`1`；否则，它将是`0`。
- en: We do a bitwise AND on our data with the bit set at our `dataIterator`. This
    will let us know if we have a bit set there. Finally, we need to make sure that
    we shift that bit by the number of parity bits that are already set (this is `j
    – dataIterator`).
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们对我们的数据进行按位与运算，与我们的`dataIterator`处设置的位进行比较。这将让我们知道我们是否在那里设置了一个位。最后，我们需要确保将该位移动已设置的奇偶校验位的数量（这是`j
    - dataIterator`）。
- en: If we reach the bottom of this `for` loop, then we check a data bit, so we need
    to increment our `dataIterator`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们到达这个`for`循环的底部，那么我们将检查一个数据位，所以我们需要增加我们的`dataIterator`。
- en: If bit operations are new to you, it would be a good idea to read up on them
    at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果位操作对您来说是新的，最好阅读一下[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)。
- en: 'Now, we can fill in our `createParity` method with the following code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码填充我们的`createParity`方法：
- en: '[PRE41]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This section can be a bit more complicated, but it is doing what we did by
    hand previously:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分可能会更加复杂，但它正在做我们之前手工完成的工作：
- en: First, we are only going to handle a certain amount of bits for our data, so
    we will only use four parity bits. These parity bits correspond to the `0`, `1`,
    `2`, and `4`-bit locations, which are the decimal numbers 1, 2, 4, and 8.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们只处理数据的一定数量的位，所以我们只使用四个奇偶校验位。这些奇偶校验位对应于`0`，`1`，`2`和`4`位位置，即十进制数1，2，4和8。
- en: Next, these bits are located at the `1`, `2`, `4`, and `8`-bit locations, which
    are represented as `1`, `2`, `8`, and `128` in decimal form. This just makes it
    easier if we need to set the parity bit located there.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，这些位位于`1`，`2`，`4`和`8`位位置，分别表示为十进制的`1`，`2`，`8`和`128`。如果需要设置位于那里的奇偶校验位，这将使得更容易。
- en: 'Now, we will loop through each of our parity checks and see if our newly moved
    data has a bit set there:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将循环遍历我们的每个奇偶校验检查，并查看我们新移动的数据是否在那里设置了一个位：
- en: '[PRE42]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We are checking to make sure that the bit we are currently looking at is the
    data bit that we are worried about for that parity bit. If it is, we will add
    to the counter if the data bit is set there. We will do this by utilizing a bitwise
    AND with the data. If we don't get a zero, this means the bit is set, so we will
    add to the counter.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在检查当前查看的位是否是我们担心的奇偶校验位的数据位。如果是，如果数据位设置了，我们将增加计数器。我们将通过使用数据进行按位与来实现这一点。如果我们得到一个非零值，这意味着该位被设置，所以我们将增加计数器。
- en: At the end of this `for` loop, if we don't have even parity, we will need to
    set the parity bit at this location to get even parity.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个`for`循环结束时，如果我们没有偶校验，我们需要设置该位置的奇偶校验位以获得偶校验。
- en: 'Now, let''s compile our program with the following command-line operation:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令行操作编译我们的程序：
- en: '[PRE43]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we need to go to our `index.html` page in the browser and run the following
    command in our developer''s tools:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在浏览器的`index.html`页面中运行以下命令：
- en: '[PRE44]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'By doing this, we should get the following output: `1579`. If we put this decimal
    number into our programmer''s calculator, we will get the following binary representation:
    `11000101011`. If we head back up and check when we did this by hand, we will
    see that we got the exact same thing! This means our hamming data generator is
    working. Now, let''s make the verification tool. Follow these steps to do so:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们应该得到以下输出：`1579`。如果我们将这个十进制数放入我们的程序员计算器中，我们将得到以下二进制表示：`11000101011`。如果我们回头检查我们手工完成的工作，我们会发现我们得到了完全相同的结果！这意味着我们的海明数据生成器正在工作。现在，让我们制作验证工具。按照以下步骤进行操作：
- en: 'Inside our `checkAndVerifyData` method, we will add the following code:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`checkAndVerifyData`方法中，我们将添加以下代码：
- en: '[PRE45]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we have a `verify` variable that will tell us if the data is good or not.
    If it isn't good, it will output our error status, which is a `-1`. Otherwise,
    we'll have run through the data and seen it was good, so we'll return a `1`. Next,
    we'll utilize the parity bits which, as we already know, are held at the decimal
    numbers `1`, `2`, `8`, and `128`. We will loop through these and check our hamming
    data with it by utilizing the `checkRow` method.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个`verify`变量，它将告诉我们数据是否正确。如果不正确，它将输出我们的错误状态，即`-1`。否则，我们将通过数据并看到它是正确的，所以我们将返回`1`。接下来，我们将利用奇偶校验位，正如我们已经知道的那样，它们保存在十进制数字`1`，`2`，`8`和`128`中。我们将循环遍历这些数字，并利用`checkRow`方法检查我们的海明数据。
- en: 'The `checkRow` method will utilize similar concepts to our creation process.
    This looks as follows:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`checkRow`方法将利用与我们创建过程类似的概念。它如下所示：'
- en: '[PRE46]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Again, this should be very similar to our `createParity` method. We will run
    through the number and check to see if this is a parity bit number. If it is,
    we will utilize a bitwise AND operation at the location with a number we know
    has the bit set. If it is not equal to `0`, then the bit is set and we update
    our counter. We will return our counter modded with `2` since this will tell us
    if we have even parity.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该与我们的`createParity`方法非常相似。我们将运行这个数字，并检查这是否是一个奇偶校验位数字。如果是，我们将在该位置使用按位AND操作一个已知具有该位设置的数字。如果不等于`0`，则该位已设置，并更新我们的计数器。我们将返回我们的计数器模`2`，因为这将告诉我们是否有偶校验。
- en: 'This should always return an even number (in our case, `0`). If it doesn''t,
    we instantly error out. Let''s compile this with the following command:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该始终返回一个偶数（在我们的例子中是`0`）。如果不是，我们立即报错。让我们使用以下命令编译这个：
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we can head into our browser and use the number we got from the `createData`
    method. Head into the developer console and run the following command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以进入浏览器，并使用从`createData`方法得到的数字。进入开发者控制台，并运行以下命令：
- en: '[PRE48]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It should print out a `1`, which means that we have good hamming data! Now,
    let''s try it with an example that we haven''t worked out by hand: the number
    `1000`. Run the following commands; we should get the same results:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该打印出`1`，这意味着我们有良好的海明数据！现在，让我们尝试一个我们尚未手动解决的示例：数字`1000`。运行以下命令；我们应该得到相同的结果：
- en: '[PRE49]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now, we have a working hamming data creation method and a verification tool
    all written in C and running in the browser! This should help you understand how
    to port existing applications to the browser, but also how to utilize this powerful
    technology that allows you to run near-native speeds for computationally intensive
    applications.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个在浏览器中运行的C语言编写的工作海明数据创建方法和验证工具！这应该帮助您了解如何将现有应用程序移植到浏览器中，以及如何利用这种强大的技术，使您能够以接近本机速度运行计算密集型应用程序。
- en: The final section of this chapter will take a look at one of the ports that's
    being utilized today, and even take a look at some of the code that goes into
    it. This library is utilized by a lot of application developers and is known as
    SQLite.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一部分将介绍当今正在使用的一个端口，并甚至查看一些涉及其中的代码。这个库被许多应用程序开发人员使用，被称为SQLite。
- en: A look at SQLite in the browser
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在浏览器中查看SQLite
- en: SQLite is an embedded database that's used by thousands of applications. Instead
    of needing a server and a connection system like most databases, SQLite allows
    us to utilize it like any other library. But what's kept us from developing with
    this type of power in the browser has been a way to import this without needing
    native bindings. To utilize it in Node.js, we would need to utilize something
    like node-gyp and then create JavaScript bindings to the underlying C code.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite是一个嵌入式数据库，被成千上万的应用程序使用。与大多数数据库一样，SQLite不需要服务器和连接系统，允许我们像使用其他库一样利用它。但是，阻止我们在浏览器中开发这种强大功能的是一种无需本机绑定即可导入的方法。要在Node.js中使用它，我们需要使用类似node-gyp的东西，然后创建底层C代码的JavaScript绑定。
- en: 'We have a way of utilizing this database in the browser without needing these
    native bindings, thanks to WebAssembly. For a version that has already been compiled
    for us, go to [https://github.com/kripken/sql.js/](https://github.com/kripken/sql.js/)
    and pull the repository into our local system. Let''s go ahead and set up our
    static server to bring in all of the files for us. Follow these steps:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一种在浏览器中利用这个数据库而不需要这些本机绑定的方法，这要感谢WebAssembly。要获取已经为我们编译的版本，请访问[https://github.com/kripken/sql.js/](https://github.com/kripken/sql.js/)，并将存储库拉入我们的本地系统。让我们继续设置我们的静态服务器，为我们带来所有文件。按照以下步骤进行：
- en: Create a new directory called `sqlitetest`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sqlitetest`的新目录。
- en: 'Inside this directory, go ahead and run the following command to clone the
    repository from GitHub:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个目录中，继续运行以下命令，从GitHub克隆存储库：
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'With this, we can create a basic `index.html` file and add the following code
    to it:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们可以创建一个基本的`index.html`文件，并将以下代码添加到其中：
- en: '[PRE51]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If we look inside our developer tools, we will see that we have the SQLite
    library up and running in our browser! Let''s go ahead and create some tables
    and populate them with some data:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看开发者工具，我们会发现SQLite库已经在我们的浏览器中运行起来了！让我们继续创建一些表，并用一些数据填充它们：
- en: 'We are going to create a simple two-table database. These two tables will look
    as follows:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的两表数据库。这两个表将如下所示：
- en: '| id | first_name | last_name | username |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| id | first_name | last_name | username |'
- en: '| <auto_increment> | <text> | <text> | <text> |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| <auto_increment> | <text> | <text> | <text> |'
- en: '| id | customer_id | op | timestamp |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| id | customer_id | op | timestamp |'
- en: '| <auto_increment> | <foreign_key> | <text> | <integer> |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| <auto_increment> | <foreign_key> | <text> | <integer> |'
- en: Essentially, we will be simulating a remote procedure call server where, when
    customers make calls to it, we will log which operation they performed and the
    timestamp that they performed it at.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们将模拟一个远程过程调用服务器，在这个服务器上，当客户进行调用时，我们将记录他们执行的操作和执行操作的时间戳。
- en: 'To make these tables in our SQLite database, we will run the following code:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的SQLite数据库中创建这些表，我们将运行以下代码：
- en: '[PRE52]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, we have a simple two-table database that has everything we need in it to
    get moving.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个简单的两表数据库，里面包含我们需要的一切。
- en: 'Let''s go ahead and populate this with some data for each of the tables. We
    can do this with the following commands:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续为每个表填充一些数据。我们可以使用以下命令来做到这一点：
- en: '[PRE53]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'With this bit of code, we have entered our test data. Now, let''s run the following
    command:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这段代码，我们已经输入了我们的测试数据。现在，让我们运行以下命令：
- en: '[PRE54]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We have successfully run a SQL database in our browser!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功在浏览器中运行了一个SQL数据库！
- en: For more information on how to utilize this, go to [https://github.com/kripken/sql.js/](https://github.com/kripken/sql.js/).
    To get the SQLite reference documentation, go to [https://www.sqlite.org/lang.html](https://www.sqlite.org/lang.html).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何利用此功能的更多信息，请访问[https://github.com/kripken/sql.js/](https://github.com/kripken/sql.js/)。要获取SQLite参考文档，请访问[https://www.sqlite.org/lang.html](https://www.sqlite.org/lang.html)。
- en: 'Now, being able to run a SQL engine in our browser is awesome, but let''s take
    a look at how some of the underlying C code got turned into something that our
    browser understands. If we head to [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)
    and download the latest release, we can pull up the `sqlite3.c` code base. Now
    that we have the code base, let''s look for something that we might be able to
    see in the WebAssembly printout. Follow these steps:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中运行SQL引擎是很棒的，但让我们看看一些基础C代码是如何转换成我们的浏览器能理解的东西的。如果我们前往[https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)并下载最新版本，我们可以打开`sqlite3.c`代码库。现在我们有了代码库，让我们寻找一些可能在WebAssembly输出中看到的东西。按照以下步骤进行：
- en: 'We will utilize the `wasm2wat` tool that we received when we installed the
    wasm binary tools. Head into the `dist` folder of the `sqljs` folder and run the
    following command:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用我们在安装wasm二进制工具时收到的`wasm2wat`工具。进入`sqljs`文件夹的`dist`文件夹并运行以下命令：
- en: '[PRE55]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, we can open that file to see the generated WebAssembly in a human-readable
    fashion. As we can see, it isn't that readable, but near the top, we can see a
    bunch of imports from Emscripten. We should realize that all of these are functions
    that Emscripten provides from their JavaScript API and that they are utilized
    to compile everything to WebAssembly and be usable.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以打开该文件以以人类可读的方式查看生成的WebAssembly。正如我们所看到的，它并不那么易读，但在顶部附近，我们可以看到许多来自Emscripten的导入项。我们应该意识到所有这些都是Emscripten从他们的JavaScript
    API提供的函数，并且它们被用于将所有内容编译为WebAssembly并可用。
- en: 'Next, let''s go to the bottom of the file. We''ll notice that there are a bunch
    of exports that are named. Each of these should correspond to a function found
    in the `c` file. Let''s go ahead and take a look at a semi-simple one: `sqlite3_data_count`.
    It should look as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们转到文件底部。我们会注意到有许多命名的导出项。每个导出项应该对应于`c`文件中找到的一个函数。让我们继续看一个相对简单的函数：`sqlite3_data_count`。它应该如下所示：
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We will see this return type in the C code if the pointer is NULL. If the result
    is NULL, we will return 0\. This is how we can debug C programs that we are porting
    to the web. While this isn't easy, it can help us when we need to do this type
    of debugging.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指针为空，我们将在C代码中看到这种返回类型。如果结果为空，我们将返回0。这是我们在将C程序移植到Web时进行调试的方法。虽然这并不容易，但在需要进行这种调试时，它可以帮助我们。
- en: This chapter covered just a taste of the libraries that have already been ported.
    Every day, more libraries are being ported, as well as languages, that can be
    compiled to WebAssembly.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅涵盖了已经移植的库的一小部分。每天都有更多的库被移植，以及可以编译为WebAssembly的语言。
- en: 'A final note on WebAssembly: while we are still in the very beginnings of this
    technology, we have already seen many advancements. From being able to utilize
    multiple threads to newly supported multiple return values, we are starting to
    see this technology really take off.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 关于WebAssembly的最后说明：虽然我们仍处于这项技术的起步阶段，但我们已经看到了许多进展。从能够利用多个线程到新支持的多返回值，我们开始看到这项技术真正起飞。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to read and write WebAssembly. We also gained
    an understanding of how programs are understood by typical computers. On top of
    this, we wrote a program that is able to utilize this near-native speed. Finally,
    we took a look at an existing WebAssembly program and how that relates to the
    code it was generated from.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何阅读和编写WebAssembly。我们还了解了程序如何被典型计算机理解。除此之外，我们编写了一个能够利用接近本机速度的程序。最后，我们看了一个现有的WebAssembly程序以及它与生成它的代码之间的关系。
- en: By now, we have learned quite a bit about the web development landscape. We
    have looked at coding in the browser and how we can utilize all of the new features
    to create feature-rich web applications. On top of this, we have seen how JavaScript
    can be used as our server-side code utilizing Node.js. Finally, we took a look
    at how to build and deploy our applications. By now, we should be comfortable
    building scalable applications and utilizing many of the modern features to create
    blazing fast applications.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对Web开发领域有了相当多的了解。我们已经研究了在浏览器中编码以及如何利用所有新功能来创建功能丰富的Web应用程序。除此之外，我们已经看到了JavaScript如何作为我们的服务器端代码利用Node.js。最后，我们看了如何构建和部署我们的应用程序。到目前为止，我们应该能够轻松构建可扩展的应用程序，并利用许多现代功能来创建快速的应用程序。
- en: Thank you for reading and I hope that this information helps create the next
    generation of web applications! Keep up with the development of the modern web
    and build the next amazing application!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读，希望这些信息有助于创建下一代Web应用程序！跟上现代Web的发展，构建下一个令人惊叹的应用程序！
- en: Further reading
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For those that are interested, the following link showcases the work that Mozilla
    is doing with WebAsesmbly and how they are really driving the technology forward: [https://hacks.mozilla.org/](https://hacks.mozilla.org/).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些感兴趣的人，以下链接展示了Mozilla在WebAssembly上的工作以及他们如何推动这项技术的发展：[https://hacks.mozilla.org/](https://hacks.mozilla.org/)。
- en: 'Other amazing projects that have been created with WebAssembly can be found
    at the following links:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 其他使用WebAssembly创建的令人惊奇的项目可以在以下链接找到：
- en: '**Blazor**: [https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor](https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor)'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blazor**：[https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor](https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor)'
- en: '**Unity**: [https://blogs.unity3d.com/2018/08/15/webassembly-is-here/](https://blogs.unity3d.com/2018/08/15/webassembly-is-here/)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity**：[https://blogs.unity3d.com/2018/08/15/webassembly-is-here/](https://blogs.unity3d.com/2018/08/15/webassembly-is-here/)'
- en: '**Qt**: [https://doc.qt.io/qt-5/wasm.html](https://doc.qt.io/qt-5/wasm.html)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Qt**：[https://doc.qt.io/qt-5/wasm.html](https://doc.qt.io/qt-5/wasm.html)'
