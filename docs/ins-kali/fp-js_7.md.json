["```js\nclass Polygon {\n  int numSides;\n  function init(n) {\n    numSides = n;\n  }\n}\nclass Rectangle inherits Polygon {\n  int width;\n  int length;\n  function init(w, l) {\n    numSides = 4;\n    width = w;\n    length = l;\n  }\n  function getArea() {\n    return w * l;\n  }\n}\nclass Square inherits Rectangle {\n  function init(s) {\n    numSides = 4;\n    width = s;\n    length = s;\n  }\n}\n```", "```js\nvar Polygon = function(n) {\n  this.numSides = n;\n}\n\nvar Rectangle = function(w, l) {\n  this.width = w;\n  this.length = l;\n}\n\n// the Rectangle's prototype is redefined with Object.create\nRectangle.prototype = Object.create(Polygon.prototype);\n\n// it's important to now restore the constructor attribute\n// otherwise it stays linked to the Polygon\nRectangle.prototype.constructor = Rectangle;\n\n// now we can continue to define the Rectangle class\nRectangle.prototype.numSides = 4;\nRectangle.prototype.getArea = function() {\n  return this.width * this.length;\n}\n\nvar Square = function(w) {\n  this.width = w;\n  this.length = w;\n}\nSquare.prototype = Object.create(Rectangle.prototype);\nSquare.prototype.constructor = Square;\n\nvar s = new Square(5);\nconsole.log( s.getArea() ); // 25\n```", "```js\nvar Maybe = function(){}; \n\nvar None = function(){}; \nNone.prototype = Object.create(Maybe.prototype);\nNone.prototype.constructor = None;\nNone.prototype.toString = function(){return 'None';};\n\nvar Just = function(x){this.x = x;};\nJust.prototype = Object.create(Maybe.prototype);\nJust.prototype.constructor = Just;\nJust.prototype.toString = function(){return \"Just \"+this.x;};\n```", "```js\nFoo.prototype = Object.create(Parent.prototype); // correct\nBar.prototype = Object.create(Parent); // incorrect\nBar.inheritedMethod(); // Error: function is undefined\n```", "```js\nvar Shirt = function(size) {\n  this.size = size;\n};\n\nvar TShirt = function(size) {\n  this.size = size;\n};\nTShirt.prototype = Object.create(Shirt.prototype);\nTShirt.prototype.constructor = TShirt;\nTShirt.prototype.getPrice = function(){\n  if (this.size == 'small') {\n    return 5;\n  }\n  else {\n    return 10;\n  }\n}\n\nvar ExpensiveShirt = function(size) {\n  this.size = size;\n}\nExpensiveShirt.prototype = Object.create(Shirt.prototype);\nExpensiveShirt.prototype.constructor = ExpensiveShirt;\nExpensiveShirt.prototype.getPrice = function() {\n  if (this.size == 'small') {\n    return 20;\n  }\n  else {\n    return 30;\n  }\n}\n```", "```js\nvar Store = function(products) {\n  this.products = products;\n}\nStore.prototype.calculateTotal = function(){\n  return this.products.reduce(function(sum,product) {\n    return sum + product.getPrice();\n  }, 10) * TAX; // start with $10 markup, times global TAX var\n};\n\nvar TAX = 1.08;\nvar p1 = new TShirt('small');\nvar p2 = new ExpensiveShirt('large');\nvar s = new Store([p1,p2]);\nconsole.log(s.calculateTotal()); // Output: 35\n```", "```js\nvar Customer = function(){};\nCustomer.prototype.calculateTotal = function(products) {\n  return products.reduce(function(total, product) {\n    return total + product.getPrice();\n  }, 10) * TAX;\n};\n\nvar RepeatCustomer = function(){};\nRepeatCustomer.prototype = Object.create(Customer.prototype);\nRepeatCustomer.prototype.constructor = RepeatCustomer;\nRepeatCustomer.prototype.calculateTotal = function(products) {\n  return products.reduce(function(total, product) {\n    return total + product.getPrice();\n  }, 5) * TAX;\n};\n\nvar TaxExemptCustomer = function(){};\nTaxExemptCustomer.prototype = Object.create(Customer.prototype);\nTaxExemptCustomer.prototype.constructor = TaxExemptCustomer;\nTaxExemptCustomer.prototype.calculateTotal = function(products) {\n  return products.reduce(function(total, product) {\n    return total + product.getPrice();\n  }, 10);\n};\n```", "```js\nvar Store = function(products) {\n  this.products = products;\n  this.customer = new Customer();\n  // bonus exercise: use Maybes from Chapter 5 instead of a default customer instance\n}\nStore.prototype.setCustomer = function(customer) {\n  this.customer = customer;\n}\nStore.prototype.getTotal = function(){\n  return this.customer.calculateTotal(this.products);\n};\n\nvar p1 = new TShirt('small');\nvar p2 = new ExpensiveShirt('large');\nvar s = new Store([p1,p2]);\nvar c = new TaxExemptCustomer();\ns.setCustomer(c);\ns.getTotal(); // Output: 45\n```", "```js\nvar small = {\n  getPrice: function() {\n    return this.basePrice + 6;   \n  },\n  getDimensions: function() {\n    return [44,63]\n  }\n}\nvar large = {\n  getPrice: function() {\n    return this.basePrice + 10;   \n  },\n  getDimensions: function() {\n    return [64,83]\n  }\n};\n```", "```js\nvar Shirt = function() {\n  this.basePrice = 1;\n};\nShirt.getPrice = function(){\n  return this.basePrice;\n}\nvar TShirt = function() {\n  this.basePrice = 5;\n};\nTShirt.prototype = Object.create(Shirt.prototype);\nTShirt..prototype.constructor = TShirt;\n```", "```js\nShirt.prototype.addMixin = function (mixin) {\n  for (var prop in mixin) {\n    if (mixin.hasOwnProperty(prop)) {\n      this.prototype[prop] = mixin[prop];\n    }\n  }\n};\n```", "```js\nTShirt.addMixin(small);\nvar p1 = new TShirt();\nconsole.log( p1.getPrice() ); // Output: 11\n\nTShirt.addMixin(large);\nvar p2 = new TShirt();\nconsole.log( p2.getPrice() ); // Output: 15\n```", "```js\nconsole.log( p1.getPrice() ); // Output: 15\n```", "```js\nShirt.prototype.plusMixin = function(mixin) {    \n  // create a new object that inherits from the old\n  var newObj = this;\n  newObj.prototype = Object.create(this.prototype);\n  for (var prop in mixin) {\n    if (mixin.hasOwnProperty(prop)) {\n      newObj.prototype[prop] = mixin[prop];\n    }\n  }\n  return newObj;\n};\n\nvar SmallTShirt = Tshirt.plusMixin(small); // creates a new class\nvar smallT = new SmallTShirt();\nconsole.log( smallT.getPrice() );  // Output: 11\n\nvar LargeTShirt = Tshirt.plusMixin(large);\nvar largeT = new LargeTShirt();\nconsole.log( largeT.getPrice() ); // Output: 15\nconsole.log( smallT.getPrice() ); // Output: 11 (not effected by 2nd mixin call)\n```", "```js\n// in the real world there would be way more products and mixins!\nvar productClasses = [ExpensiveShirt, Tshirt]; \nvar mixins = [small, medium, large];\n\n// mix them all together \nproducts = productClasses.reduce(function(previous, current) {\n  var newProduct = mixins.map(function(mxn) {\n    var mixedClass = current.plusMixin(mxn);\n    var temp = new mixedClass();\n    return temp;\n  });\n  return previous.concat(newProduct);\n},[]);\nproducts.forEach(function(o){console.log(o.getPrice())});\n```", "```js\n// the store\nvar Store = function() {\n  productClasses = [ExpensiveShirt, TShirt];\n  productMixins = [small, medium, large];\n  this.products = productClasses.reduce(function(previous, current) {\n    var newObjs = productMixins.map(function(mxn) {\n      var mixedClass = current.plusMixin(mxn);\n      var temp = new mixedClass();\n      return temp;\n    });\n    return previous.concat(newObjs);\n  },[]);\n}\nStore.prototype.displayProducts = function(){\n  this.products.forEach(function(p) {\n    $('ul#products').append('<li>'+p.getTitle()+': $'+p.getPrice()+'</li>');\n  });\n}\n```", "```js\n<ul id=\"products\">\n  <li>small premium shirt: $16</li>\n  <li>medium premium shirt: $18</li>\n  <li>large premium shirt: $20</li>\n  <li>small t-shirt: $11</li>\n  <li>medium t-shirt: $13</li>\n  <li>large t-shirt: $15</li>\n</ul>\n```", "```js\nShirt.prototype.title = 'shirt';\nTShirt.prototype.title = 't-shirt';\nExpensiveShirt.prototype.title = 'premium shirt';\n\n// then the mixins got the extra 'getTitle' function:\nvar small = {\n  ...\n  getTitle: function() {\n    return 'small ' + this.title; // small or medium or large\n  }\n}\n```", "```js\n    var flatten = function(arrays) {\n      return arrays.reduce( function(p,n){\n        return p.concat(n);\n      });\n    };\n\n    var invert = function(arr) {\n      return arr.map(function(x, i, a) {\n        return a[a.length - (i+1)];\n      });\n    };\n    ```", "```js\n    var bind = Function.prototype.call.bind(Function.prototype.bind);\n    var call = bind(Function.prototype.call, Function.prototype.call);\n    var apply = bind(Function.prototype.call, Function.prototype.apply);\n    ```", "```js\n    var checkTypes = function( typeSafeties ) {\n      arrayOf(func)(arr(typeSafeties));\n      var argLength = typeSafeties.length;\n      return function(args) {\n        arr(args);\n        if (args.length != argLength) {\n          throw new TypeError('Expected '+ argLength + ' arguments');\n        }\n        var results = [];\n        for (var i=0; i<argLength; i++) {\n          results[i] = typeSafeties[i](args[i]);\n        }\n        return results;\n      };\n    };\n\n    var homoMorph = function( /* arg1, arg2, ..., argN, output */ ) {\n      var before = checkTypes(arrayOf(func)(Array.prototype.slice.call(arguments, 0, arguments.length-1)));\n      var after = func(arguments[arguments.length-1])\n      return function(middle) {\n        return function(args) {\n          return after(middle.apply(this, before([].slice.apply(arguments))));\n        };\n      };\n    };\n    ```", "```js\n    Function.prototype.compose = function(prevFunc) {\n      var nextFunc = this;\n      return function() {\n        return nextFunc.call(this,prevFunc.apply(this,arguments));\n      };\n    };\n\n    Function.prototype.sequence  = function(prevFunc) {\n      var nextFunc = this;\n      return function() {\n        return prevFunc.call(this,nextFunc.apply(this,arguments));\n      };\n    };\n    ```", "```js\n    Function.prototype.curry = function (numArgs) {\n      var func = this;\n      numArgs = numArgs || func.length;\n      // recursively acquire the arguments\n      function subCurry(prev) {\n        return function (arg) {\n          var args = prev.concat(arg);\n          if (args.length < numArgs) {\n            // recursive case: we still need more args\n            return subCurry(args);\n          }\n          else {\n            // base case: apply the function\n            return func.apply(this, args);\n          }\n        };\n      };\n      return subCurry([]);\n    };\n    ```", "```js\n    // map :: (a -> b) -> [a] -> [b]\n    var map = function(f, a) {\n      return arr(a).map(func(f));\n    }\n\n    // strmap :: (str -> str) -> str -> str\n    var strmap = function(f, s) {\n      return str(s).split('').map(func(f)).join('');\n    }\n\n    // fcompose :: (a -> b)* -> (a -> b)\n    var fcompose = function() {\n      var funcs = arrayOf(func)(arguments);\n      return function() {\n        var argsOfFuncs = arguments;\n        for (var i = funcs.length; i > 0; i -= 1) {\n          argsOfFuncs  = [funcs[i].apply(this, args)];\n        }\n        return args[0];\n      };\n    };\n    ```", "```js\n    var lens = function(get, set) {\n      var f = function (a) {return get(a)};\n      f.get = function (a) {return get(a)}; \n      f.set = set;\n      f.mod = function (f, a) {return set(a, f(get(a)))};\n      return f;\n    };\n\n    // usage:\n    var first = lens(\n      function (a) { return arr(a)[0]; }, // get\n      function (a, b) { return [b].concat(arr(a).slice(1)); } // set\n    );\n    ```", "```js\n    var Maybe = function(){}; \n    Maybe.prototype.orElse = function(y) {\n      if (this instanceof Just) {\n        return this.x;\n      }\n      else {\n        return y;\n      }\n    };\n\n    var None = function(){}; \n    None.prototype = Object.create(Maybe.prototype);\n    None.prototype.toString = function(){return 'None';};\n    var none = function(){return new None()};\n    // and the Just instance, a wrapper for an object with a value\n    var Just = function(x){return this.x = x;};\n    Just.prototype = Object.create(Maybe.prototype);\n    Just.prototype.toString = function(){return \"Just \"+this.x;};\n    var just = function(x) {return new Just(x)};\n    var maybe = function(m){\n      if (m instanceof None) {\n        return m;\n      }\n      else if (m instanceof Just) {\n        return just(m.x);\n      }\n      else {\n        throw new TypeError(\"Error: Just or None expected, \" + m.toString() + \" given.\"); \n      }\n    };\n\n    var maybeOf = function(f){\n      return function(m) {\n        if (m instanceof None) {\n          return m;\n        }\n        else if (m instanceof Just) {\n          return just(f(m.x));\n        }\n        else {\n          throw new TypeError(\"Error: Just or None expected, \" + m.toString() + \" given.\"); \n        }\n      };\n    };\n    ```", "```js\n    Object.prototype.plusMixin = function(mixin) {\n      var newObj = this;\n      newObj.prototype = Object.create(this.prototype);\n      newObj.prototype.constructor = newObj;\n      for (var prop in mixin) {\n        if (mixin.hasOwnProperty(prop)) {\n          newObj.prototype[prop] = mixin[prop];\n        }\n      }\n      return newObj;\n    };\n    ```", "```js\n    function bindFirstArg(func, a) {\n      return function(b) {\n        return func(a, b);\n      };\n    };\n\n    Function.prototype.partialApply = function(){\n      var func = this; \n      args = Array.prototype.slice.call(arguments);\n      return function(){\n        return func.apply(this, args.concat(\n          Array.prototype.slice.call(arguments)\n        ));\n      };\n    };\n\n    Function.prototype.partialApplyRight = function(){\n      var func = this; \n      args = Array.prototype.slice.call(arguments);\n      return function(){\n        return func.apply(\n          this,\n          Array.protype.slice.call(arguments, 0)\n        .concat(args));\n      };\n    };\n    ```", "```js\n    var trampoline = function(f) {\n      while (f && f instanceof Function) {\n        f = f.apply(f.context, f.args);\n      }\n      return f;\n    };\n\n    var thunk = function (fn) {\n      return function() {\n        var args = Array.prototype.slice.apply(arguments);\n        return function() { return fn.apply(this, args); };\n      };\n    };\n    ```", "```js\n    var typeOf = function(type) {\n      return function(x) {\n        if (typeof x === type) {\n          return x;\n        }\n        else {\n          throw new TypeError(\"Error: \"+type+\" expected, \"+typeof x+\" given.\");\n        }\n      };\n    };\n\n    var str = typeOf('string'),\n      num = typeOf('number'),\n      func = typeOf('function'),\n      bool = typeOf('boolean');\n\n    var objectTypeOf = function(name) {\n      return function(o) {\n        if (Object.prototype.toString.call(o) === \"[object \"+name+\"]\") {\n          return o;\n        }\n        else {\n          throw new TypeError(\"Error: '+name+' expected, something else given.\"); \n        }\n      };\n    };\n    var obj = objectTypeOf('Object');\n    var arr = objectTypeOf('Array');\n    var date = objectTypeOf('Date');\n    var div = objectTypeOf('HTMLDivElement');\n\n    // arrayOf :: (a -> b) -> ([a] -> [b])\n    var arrayOf = function(f) {\n      return function(a) {\n        return map(func(f), arr(a));\n      }\n    };\n    ```", "```js\n    var Y = function(F) {\n      return (function (f) {\n        return f(f);\n      }(function (f) {\n        return F(function (x) {\n          return f(f)(x);\n        });\n      }));\n    };\n\n    // Memoizing Y-Combinator:\n    var Ymem = function(F, cache) {\n      if (!cache) {\n        cache = {} ; // Create a new cache.\n      }\n      return function(arg) {\n        if (cache[arg]) {\n          // Answer in cache\n          return cache[arg] ;\n        }\n        // else compute the answer\n        var answer = (F(function(n){\n          return (Ymem(F,cache))(n);\n        }))(arg); // Compute the answer.\n        cache[arg] = answer; // Cache the answer.\n        return answer;\n      };\n    };\n    ```"]