- en: '`# Real-Time Video Call App with WebRTC'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 使用WebRTC进行实时视频通话应用'
- en: Hey! Just to let you know, the JS Meetup was a great success after getting a
    backend developer to complete the serverside of the application. But you did great
    completing the entire frontend of the application. You created a complete Event
    Registration website, which lets users sign up the events, while learning some
    really important concepts, such as building reusable ES6 modules, making AJAX
    requests while handling asynchronous code using Promises, creating beautiful charts
    out of data, and of course, the classic form validation with a validation service.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿！只是想告诉你，JS Meetup在找到后端开发人员完成应用程序的服务器端之后取得了巨大成功。但是你很棒，完成了整个应用程序的前端。你创建了一个完整的活动注册网站，让用户报名参加活动，同时学习了一些非常重要的概念，比如构建可重用的ES6模块，使用Promises处理异步代码进行AJAX请求，从数据创建美丽的图表，当然还有经典的表单验证与验证服务。
- en: The backend code was also written with JavaScript (Node.js), so you might really
    be interested in writing serverside code. But sadly, as I mentioned earlier, Node.js
    is beyond the scope of this book. Actually, you can do some really cool things
    with plain JavaScript, although many people think, "*It needs a lot of server-side
    code!*" Since you will have already read the chapter title - yup! We are going
    to build a real Video Call app in this chapter with *almost zero* server-side
    code. The best part is, just like our other applications, this one is also going
    to be responsive and will work with most mobile browsers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 后端代码也是用JavaScript（Node.js）编写的，所以你可能真的对编写服务器端代码感兴趣。但遗憾的是，正如我之前提到的，Node.js超出了本书的范围。实际上，你可以用纯JavaScript做一些非常酷的事情，尽管很多人认为，“*它需要大量的服务器端代码！*”因为你已经读过本章的标题
    - 是的！我们将在本章中构建一个真正的视频通话应用程序，几乎没有服务器端代码。最好的部分是，就像我们的其他应用程序一样，这个应用程序也将是响应式的，并且将与大多数移动浏览器兼容。
- en: 'Let''s first take a look at the list of concepts we are about to learn in this
    chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下我们将在本章学习的概念清单：
- en: Introduction to WebRTC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebRTC介绍
- en: WebRTC APIs in JavaScript
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript中的WebRTC API
- en: Working with a SimpleWebRTC framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SimpleWebRTC框架进行工作
- en: Building a Video Call app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建视频通话应用程序
- en: 'Apart from these main concepts, there is a lot more to learn in this chapter.
    So, before we start, make sure you have the following hardware:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些主要概念，本章还有很多东西要学习。因此，在我们开始之前，请确保你有以下硬件：
- en: A PC or laptop with webcam and microphone (you might want to use another computer
    to experience a video call in action)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有网络摄像头和麦克风的台式机或笔记本电脑（你可能想使用另一台计算机来体验视频通话的实际效果）
- en: An Android or iPhone device (optional)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓或iPhone设备（可选）
- en: A LAN connection so that all your devices are on the same local network to test
    the application in development (can be either Wi-Fi or wired Ethernet)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局域网连接，以便所有设备都在同一局域网上进行开发应用程序的测试（可以是Wi-Fi或有线以太网）
- en: One of the dependencies used in this project requires you to have Python 2.7.x
    installed in your system. Linux and Mac users have Python pre-installed. Windows
    users can download Python 2.7.x version from [https://www.python.org/downloads/](https://www.python.org/downloads/)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目中使用的一个依赖项要求你的系统中安装了Python 2.7.x。Linux和Mac用户已经预装了Python。Windows用户可以从[https://www.python.org/downloads/](https://www.python.org/downloads/)下载Python
    2.7.x版本。
- en: Introduction to WebRTC
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebRTC介绍
- en: Before we start building the application, it's best to know a few things about
    WebRTC so that you get a good idea about the workings of the app.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建应用程序之前，最好先了解一些关于WebRTC的知识，以便你对应用程序的工作原理有一个很好的了解。
- en: History of WebRTC
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebRTC的历史
- en: Real-time communication capabilities have become a common feature of many of
    the applications we use nowadays. Say you want to chat with your friend or watch
    a live soccer game. Real-time communication is a must for these applications.
    However, having live video calls on a browser in the past was quite a difficult
    task for users, because they had to install plugins into their system for different
    applications to use video calling on the web browser, and with plugins came vulnerabilities,
    hence, regular updates.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实时通信能力已经成为我们现在使用的许多应用程序的常见功能。比如你想和朋友聊天或者观看现场足球比赛。这些应用程序必须具备实时通信功能。然而，在过去在浏览器上进行实时视频通话对用户来说是一项相当困难的任务，因为他们必须为不同的应用程序在Web浏览器上使用视频通话安装插件，而插件会带来漏洞，因此需要定期更新。
- en: To overcome this problem, Google released an open source project in May 2011
    for browser-based real-time communication standards, called WebRTC. The concept
    of WebRTC is simple. It defines a set of standards that should be used across
    all applications so that applications can communicate directly with each other
    (peer-to-peer communication). By implementing WebRTC, there will not be any need
    for plugins anymore, since the communication platform is standardized.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，谷歌于2011年5月发布了一个开源项目，用于基于浏览器的实时通信标准，名为WebRTC。WebRTC的概念很简单。它定义了一套标准，应该在所有应用程序中使用，以便应用程序可以直接相互通信（点对点通信）。通过实现WebRTC，将不再需要插件，因为通信平台是标准化的。
- en: Currently, WebRTC is being standardized by the **World Wide Web Consortium**
    (**W3C**) and the **Internet Engineering Task Force** (**IETF**). WebRTC is actively
    being implemented by most browser vendors and it will also work with native Android
    and iOS applications. If you want to know whether your browser is ready to support
    WebRTC, you can visit: [http://iswebrtcreadyyet.com/](http://iswebrtcreadyyet.com/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，WebRTC正在由**万维网联盟**（**W3C**）和**互联网工程任务组**（**IETF**）进行标准化。WebRTC正在被大多数浏览器供应商积极实施，并且它也将与原生的Android和iOS应用程序一起工作。如果你想知道你的浏览器是否准备支持WebRTC，你可以访问：[http://iswebrtcreadyyet.com/](http://iswebrtcreadyyet.com/)。
- en: 'At the time of writing this book, the browser support status is:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，浏览器支持状态如下：
- en: '![](../images/00022.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00022.jpeg)'
- en: Even though most commonly used browsers support WebRTC, except Safari, there
    are still a lot of issues and bugs with the implementation, hence, it is recommended
    to use a shim such as `adapter.js` ([https://github.com/webrtc/adapter](https://github.com/webrtc/adapter))
    so that the application will not suffer any problems during changes to spec or
    vendor prefixes. We'll see more about this when we look into the JavaScript APIs
    for WebRTC.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数常用的浏览器都支持WebRTC，除了Safari，但实现中仍然存在许多问题和错误，因此建议使用适配器（如`adapter.js`）（[https://github.com/webrtc/adapter](https://github.com/webrtc/adapter)），以便应用程序在规范或供应商前缀发生变化时不会遇到任何问题。当我们研究WebRTC的JavaScript
    API时，我们将更多地了解这一点。
- en: WebRTC is also supported in the mobile versions of Chrome and Firefox; hence,
    you can use video calls even in mobile browsers with no plugins.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: WebRTC也支持Chrome和Firefox的移动版本；因此，即使在没有插件的移动浏览器中，你也可以进行视频通话。
- en: For iPhone users Neither Safari mobile browser or Chrome support WebRTC on the
    iPhone yet. So, you either have to install Firefox or the Bowser app from the
    app store. Link for Bowser: [https://itunes.apple.com/app/bowser/id560478358?mt=8](https://itunes.apple.com/app/bowser/id560478358?mt=8).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iPhone用户，iPhone上的Safari移动浏览器或Chrome尚不支持WebRTC。因此，你必须安装Firefox或来自应用商店的Bowser应用。Bowser的链接：[https://itunes.apple.com/app/bowser/id560478358?mt=8](https://itunes.apple.com/app/bowser/id560478358?mt=8)。
- en: JavaScript WebAPIs
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript WebAPIs
- en: 'So far, we have used a few WebAPIs such as `FileReader`, document (used in
    the `document.querySelector()` methods), `HTMLImageElement` (the `new Image()`
    constructor we used in Meme Creator), and so on. They are not part of the JavaScript
    language, but they are part of the WebAPIs. When running JavaScript in browsers,
    it will be provided with a `window` object that contains all the methods of the
    WebAPIs. The scope of the `window` object is global and the properties and methods
    of the `window` object are also global. This means, if you want to use navigator
    WebAPI, you can either do the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了一些WebAPIs，比如`FileReader`，文档（在`document.querySelector()`方法中使用），`HTMLImageElement`（我们在Meme
    Creator中使用的`new Image()`构造函数），等等。它们不是JavaScript语言的一部分，但它们是WebAPIs的一部分。在浏览器中运行JavaScript时，将提供一个包含所有WebAPIs方法的`window`对象。`window`对象的范围是全局的，`window`对象的属性和方法也是全局的。这意味着，如果你想使用navigator
    WebAPI，你可以这样做：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, you can simply do as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以简单地这样做：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both will work just fine and implement the same methods. However, do note that
    WebAPI (`window` object) is available for JavaScript only when you run JavaScript
    on a browser. If you are using JavaScript on other platforms, such as Node.js
    or React Native, you will not have WebAPIs for use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都可以正常工作并实现相同的方法。但是请注意，WebAPI（`window`对象）仅在浏览器中运行JavaScript时才可用。如果你在其他平台上使用JavaScript，比如Node.js或React
    Native，你将无法使用WebAPIs。
- en: WebAPIs are growing more powerful nowadays and provide JavaScript with the ability
    to do more functions, such as recording video and audio directly from the browser.
    Progressive web applications are one such example, powered by the `ServiceWorker`
    WebAPI.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在WebAPIs变得越来越强大，为JavaScript提供了更多的功能，比如直接从浏览器录制视频和音频。渐进式Web应用程序就是这样的一个例子，由`ServiceWorker`
    WebAPI提供支持。
- en: We are going to use a lot of WebAPIs in this chapter and the upcoming chapters.
    For a full list of the WebAPIs available for JavaScript, visit the following MDN
    page: [https://developer.mozilla.org/en-US/docs/Web/API](https://developer.mozilla.org/en-US/docs/Web/API).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和接下来的章节中，我们将使用大量的WebAPIs。有关JavaScript可用的WebAPIs的完整列表，请访问以下MDN页面：[https://developer.mozilla.org/en-US/docs/Web/API](https://developer.mozilla.org/en-US/docs/Web/API)。
- en: JavaScript WebRTC API
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript WebRTC API
- en: 'Since browsers support WebRTC natively, JavaScript WebAPIs have been created
    by browser vendors so that developers can easily build applications. Currently,
    WebRTC implements the following three APIs that are used by JavaScript:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器原生支持WebRTC，因此浏览器供应商创建了JavaScript WebAPIs，以便开发人员可以轻松构建应用程序。目前，WebRTC实现了以下三个JavaScript使用的API：
- en: MediaStream
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MediaStream
- en: RTCPeerConnection
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RTCPeerConnection
- en: RTCDataChannel
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RTCDataChannel
- en: MediaStream
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MediaStream
- en: MediaStream API is used for getting access to the video and audio devices of
    the user. Generally, browsers will prompt the user as to whether he/she wants
    to allow the website to access the camera and microphone of his/her device. Even
    though the underlying concept for MediaStream API is the same, different browser
    vendors have implemented the API differently.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: MediaStream API用于获取用户的视频和音频设备的访问权限。通常，浏览器会提示用户是否允许网站访问他/她设备的摄像头和麦克风。尽管MediaStream
    API的基本概念是相同的，但不同的浏览器供应商对API的实现方式有所不同。
- en: 'While using the `getUserMedia()` method with `{audio: true}` to access your
    own microphone, *either mute the speakers or mute the HTML video element*. Otherwise,
    *it might cause feedback that can damage your speakers*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '在使用`getUserMedia()`方法时，使用`{audio: true}`来访问你自己的麦克风时，*要么将扬声器静音，要么将HTML视频元素静音*。否则，*可能会导致反馈，损坏你的扬声器*。'
- en: For example, in Chrome, to use MediaStream API, you need to use the `navigator.getUserMedia()`
    method. Also, Chrome allows MediaStream to work only in localhost or HTTPS URLs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Chrome中，要使用MediaStream API，你需要使用`navigator.getUserMedia()`方法。此外，Chrome只允许MediaStream在localhost或HTTPS
    URL中工作。
- en: '`navigator.getUserMedia()` accepts three parameters. The first one is the configuration
    object that tells the browser what the website needs access to. The other two
    are callback functions for success or failure response.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigator.getUserMedia()`接受三个参数。第一个是配置对象，告诉浏览器网站需要访问什么。另外两个是成功或失败响应的回调函数。'
- en: 'Create a simple HTML file, say `chrome.html`, inside an empty directory. Inside
    the HTML file, add the following code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个简单的HTML文件，比如`chrome.html`，放在一个空目录中。在HTML文件中，添加以下代码：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code does the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做了以下几件事：
- en: It will create a reference to the `<video>` element in the `$video` object.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将在`$video`对象中创建对`<video>`元素的引用。
- en: It then checks whether `navigator.getUserMedia` is available. This is done to
    avoid errors when a browser that is not compatible with WebRTC is used.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它检查`navigator.getUserMedia`是否可用。这样做是为了避免在使用不兼容WebRTC的浏览器时出现错误。
- en: 'Then, it calls the `navigator.getUserMedia()` method with the following three
    parameters:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它使用以下三个参数调用`navigator.getUserMedia()`方法：
- en: 'The first parameter specifies what is needed by the website to the browser.
    In our case, both audio and video. Hence, we should pass `{audio: true, video:
    true}`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第一个参数指定网站对浏览器的需求。在我们的例子中，需要音频和视频。因此，我们应该传递`{audio: true, video: true}`。'
- en: The second parameter is the success callback function. The received video and
    audio stream from the user is available in the `stream` object that is passed
    as the parameter to this function. It adds the `srcObject` attribute to the `<video>`
    element with the value as the `stream` object of the received video and audio
    from the user's input device. `$video.onloadedmetadata` will be called when the
    stream is loaded and it will start playing the video, since we added `$video.play()`
    to its callback function.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是成功的回调函数。用户接收的视频和音频流在传递给此函数的`stream`对象中可用。它将`srcObject`属性添加到`<video>`元素，其值为从用户输入设备接收的视频和音频的`stream`对象。当流加载时，将调用`$video.onloadedmetadata`，并且它将开始播放视频，因为我们在其回调函数中添加了`$video.play()`。
- en: The third parameter is called when the user denies permission to the website
    to access the camera or microphone, or some other error occurs and the media stream
    cannot be retrieved. This function has an `error` object as its parameter, which
    contains the error details.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是当用户拒绝网站访问摄像头或麦克风，或者发生其他错误且无法检索媒体流时调用的函数。此函数的参数是一个`error`对象，其中包含错误详细信息。
- en: 'Now, open the file with Chrome in localhost using `http-server`. First, Chrome
    will prompt you to allow access to the device''s camera and microphone. It should
    look as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`http-server`在本地主机中的Chrome中打开文件。首先，Chrome将提示您允许访问设备的摄像头和麦克风。它应该如下所示：
- en: '![](../images/00023.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00023.jpeg)'
- en: If you click Allow, you should see your video streamed through your front camera.
    I have set up a JS fiddle at: [https://jsfiddle.net/1odpck45/](https://jsfiddle.net/1odpck45/),
    with which you can play around with the video stream.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击允许，您应该看到通过前置摄像头传输的视频。我已经在以下网址设置了一个JS fiddle：[https://jsfiddle.net/1odpck45/](https://jsfiddle.net/1odpck45/)，您可以在其中玩弄视频流。
- en: 'Once you click Allow or Block, Chrome will remember this preference for the
    website. To change the website''s permission, you have to click the lock or information
    icon on the left-hand side of the address bar and it will show a menu, as follows,
    from which you can change the permissions again:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您点击允许或阻止，Chrome将记住网站的偏好设置。要更改网站的权限，您必须点击地址栏左侧的锁定或信息图标，它将显示一个菜单，如下所示，您可以再次更改权限：
- en: '![](../images/00024.jpeg)Since we use http-server or the Webpack dev server
    for developments that are running on localhost, we can develop WebRTC apps in
    Chrome. However, if you want to deploy the app in production, you need to deploy
    them with an HTTPS URL. Otherwise, the application won''t work on Chrome.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![](../images/00024.jpeg)由于我们使用http-server或Webpack开发服务器进行开发，这些服务器在本地主机上运行，因此我们可以在Chrome中开发WebRTC应用程序。但是，如果要在生产环境中部署应用程序，则需要使用HTTPS
    URL进行部署。否则，应用程序将无法在Chrome上运行。'
- en: The video we created works great on Chrome, but if you try to run this code
    on a different browser, Firefox, it won't work. This is because Firefox has a
    different implementation of the MediaStream API.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Chrome上创建的视频在Chrome上运行得很好，但是如果您尝试在不同的浏览器Firefox上运行此代码，它将无法运行。这是因为Firefox对MediaStream
    API有不同的实现。
- en: In Firefox, you need to use the `navigator.mediaDevices.getUserMedia()` method
    that returns a Promise. The `stream` object can be used using a `.then().catch()`
    chain.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Firefox中，您需要使用`navigator.mediaDevices.getUserMedia()`方法，该方法返回一个Promise。可以使用`.then().catch()`链使用`stream`对象。
- en: 'The code for Firefox is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox的代码如下：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can run this code in Firefox either by creating a `firefox.html` file in
    the same directory you created the `chrome.html` file or by opening the following
    JS fiddle in your Firefox browser: [https://jsfiddle.net/hc39mL5g/](https://jsfiddle.net/hc39mL5g/).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Firefox中运行此代码，方法是在与您创建`chrome.html`文件相同的目录中创建一个`firefox.html`文件，或者在您的Firefox浏览器中打开以下JS
    fiddle：[https://jsfiddle.net/hc39mL5g/](https://jsfiddle.net/hc39mL5g/)。
- en: Setting up the HTTPS server for production is beyond the scope of this book.
    But, depending on the type of server you want to use, it is fairly simple to find
    the instructions on the internet.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生产环境设置HTTPS服务器超出了本书的范围。但是，根据您想要使用的服务器类型，可以很容易地在互联网上找到说明。
- en: Using Adapter.js library
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Adapter.js库
- en: 'Since the WebRTC implementation varies between browsers, it is recommended
    to use a shim, such as the `adapter.js` library ([https://github.com/webrtc/adapter](https://github.com/webrtc/adapter)),
    which insulates the code from differences in browser implementations. By including
    `adapter.js` library, you can run the WebRTC code written for Chrome in your Firefox
    browser. Try running the following JS fiddle in Firefox, which has the WebRTC
    code that works on Chrome but has `adapter.js` included: [https://jsfiddle.net/1ydwr4tt/](https://jsfiddle.net/1ydwr4tt/).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于WebRTC在不同浏览器之间的实现不同，建议使用适配器（例如`adapter.js`库([https://github.com/webrtc/adapter](https://github.com/webrtc/adapter)））来隔离代码与浏览器实现的差异。通过包含`adapter.js`库，您可以在Firefox浏览器中运行为Chrome编写的WebRTC代码。尝试在Firefox中运行以下JS
    fiddle，其中包含适用于Chrome的WebRTC代码，但包括`adapter.js`：[https://jsfiddle.net/1ydwr4tt/](https://jsfiddle.net/1ydwr4tt/)。
- en: If you are wondering about the `<video>` element, it was introduced in HTML5\.
    To know more about using the video element, visit the w3schools page: [https://www.w3schools.com/html/html5_video.asp](https://www.w3schools.com/html/html5_video.asp)
    or the MDN page: [https://developer.mozilla.org/en/docs/Web/HTML/Element/video](https://developer.mozilla.org/en/docs/Web/HTML/Element/video).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解`<video>`元素，它是在HTML5中引入的。要了解有关使用视频元素的更多信息，请访问w3schools页面：[https://www.w3schools.com/html/html5_video.asp](https://www.w3schools.com/html/html5_video.asp)或MDN页面：[https://developer.mozilla.org/en/docs/Web/HTML/Element/video](https://developer.mozilla.org/en/docs/Web/HTML/Element/video)。
- en: RTCPeerConnection and RTCDataChannel
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RTCPeerConnection和RTCDataChannel
- en: While the MediaStream API is used to retrieve the video and audio stream from
    the user's device, the RTCPeerConnection and RTCDataChannel APIs are used for
    establishing a peer-to-peer connection and transferring data between them. In
    our Video Call app, we are going to use the SimpleWebRTC framework, which will
    abstract these APIs and provide us with a simpler object to establish a connection
    with other devices. Hence, we are not going to look into these two APIs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然MediaStream API用于从用户设备检索视频和音频流，但RTCPeerConnection和RTCDataChannel API用于建立对等连接并在它们之间传输数据。在我们的视频通话应用程序中，我们将使用SimpleWebRTC框架，它将抽象这些API并为我们提供一个更简单的对象来与其他设备建立连接。因此，我们不打算深入研究这两个API。
- en: However, there is one important thing to know while working with WebRTC. Even
    though WebRTC was created to make devices connect with each other directly without
    any servers, it is currently impossible to achieve this, because to connect with
    a device, you need to know where the device is located on the internet, that is,
    the device's IP address on the internet. But, generally, devices will only know
    their local IP address (192.168.1.x type). The public IP address is managed by
    firewall or router. To overcome this issue and send the exact IP address to the
    other device, we need signalling servers, such as **STUN** or **TURN**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用WebRTC时有一件重要的事情要知道。尽管WebRTC是为了使设备直接连接而无需任何服务器而创建的，但目前不可能实现这一点，因为要连接到设备，您需要知道设备在互联网上的位置，即设备在互联网上的IP地址。但是，一般来说，设备只会知道它们的本地IP地址（类似于192.168.1.x）。公共IP地址由防火墙或路由器管理。为了克服这个问题并将确切的IP地址发送给其他设备，我们需要信令服务器，例如**STUN**或**TURN**。
- en: The device will send the request to the STUN server to retrieve its public IP
    Address and send that information to the other devices. This is widely used and
    is applicable for most scenarios. But if the router or the firewall's NAT service
    assigns a different port number to each of the device's connection's or the device's
    local address keeps changing, the data received from the STUN server might not
    be enough, hence, the TURN server must be used. A TURN server acts as a relay
    between the two devices, that is, the device sends data to the TURN server, which
    will relay the data to the other devices. However, the TURN server is not as efficient
    as the STUN server, since it consumes a lot of server-side resources.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 设备将向STUN服务器发送请求，以检索其公共IP地址，并将该信息发送给其他设备。这是广泛使用的，并适用于大多数情况。但是，如果路由器或防火墙的NAT服务为设备的每个连接分配不同的端口号，或者设备的本地地址不断变化，那么从STUN服务器接收的数据可能不足，因此必须使用TURN服务器。TURN服务器充当两个设备之间的中继，即设备将数据发送到TURN服务器，然后TURN服务器将数据中继到其他设备。但是，TURN服务器不像STUN服务器那样高效，因为它消耗了大量服务器端资源。
- en: Usually, an **ICE **implementation is used, which determines whether a STUN
    or TURN server is needed between two devices (it will mostly go with STUN while
    using TURN as the last resort), hence, keeping the connectivity more efficient
    and stable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会使用**ICE**实现，它确定两台设备之间是否需要STUN或TURN服务器（在大多数情况下会选择STUN，而使用TURN作为最后的手段），从而保持连接更有效和稳定。
- en: Real-time communication with WebRTC is quite a large topic to be covered in
    a chapter, but if you are interested in learning more about WebRTC, you can go
    to WebRTC's official website [https://webrtc.org/](https://webrtc.org/) to look
    into some of the various resources available to get started with WebRTC.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WebRTC进行实时通信是一个很大的主题，但如果您有兴趣了解更多关于WebRTC的信息，可以访问WebRTC的官方网站[https://webrtc.org/](https://webrtc.org/)，查看一些可用于开始使用WebRTC的各种资源。
- en: Building the Video Call application
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建视频通话应用程序
- en: 'The app we are going to build in this chapter is a simple video conferencing
    app with which you create a room and then share the room URL to others. Whoever
    clicks on the URL will be able to join the call. For the UI part, we can arrange
    the video of participants in small boxes and, when you click on a participant,
    we can enlarge the video. This type of Video Call app is widely used nowadays.
    Here''s how the app will look on a desktop browser:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中构建的应用程序是一个简单的视频会议应用程序，您可以在其中创建一个房间，然后将房间URL分享给其他人。谁点击URL将能够加入通话。对于UI部分，我们可以将参与者的视频排列在小框中，当您点击参与者时，我们可以放大视频。这种类型的视频通话应用程序现在广泛使用。以下是应用程序在桌面浏览器上的外观：
- en: '![](../images/00025.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00025.jpeg)'
- en: 'The blue box will display your video, while the other boxes are supposed to
    display the videos of the other participants. The row will automatically wrap
    to a new row when the number of participants increases (flex-wrap). In mobile
    devices, we can show the videos in columns instead of rows, since it will be more
    effective for smaller screens. So, for mobiles, the application should look as
    follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝色框将显示您的视频，而其他框应显示其他参与者的视频。当参与者数量增加时，行将自动换行到新行（flex-wrap）。在移动设备上，我们可以将视频显示为列而不是行，因为对于较小的屏幕来说，这样会更有效。因此，对于手机，应用程序应如下所示：
- en: '![](../images/00026.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00026.jpeg)'
- en: The boxes are just placeholders. For real videos, we can use margin/padding
    to give spacing between each video. Also, for sharing the link, we can use a click
    to Copy button, which will be really user-friendly. Now that you have a good understanding
    of what we are going to build, let's get started!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些框只是占位符。对于真实的视频，我们可以使用margin/padding在每个视频之间留出间距。此外，为了分享链接，我们可以使用一个点击复制按钮，这将非常用户友好。现在你已经很好地理解了我们要构建的内容，让我们开始吧！
- en: Initial project setup
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始项目设置
- en: The initial setup isn't much different from what we did in the previous Event
    Registration app. Open up the starter files from `Chapter04` folder in VSCode
    and create a `.env` file. From the `.env.example` file, you should know that,
    for this application, we only need a single environment variable, `NODE_ENV`,
    whose value will be `production` only for the production environment. For development,
    we can simply assign it some other value, such as `dev`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 初始设置与我们在之前的活动注册应用程序中所做的并没有太大的不同。在VSCode的`Chapter04`文件夹中打开起始文件并创建一个`.env`文件。从`.env.example`文件中，你应该知道，对于这个应用程序，我们只需要一个环境变量`NODE_ENV`，其值只在生产环境下为`production`。对于开发，我们可以简单地为其分配其他值，比如`dev`。
- en: Once you have created your `.env` file, open the terminal in VSCode or your
    native terminal (navigate to project root folder) and run `npm install` to install
    all the dependencies for the project. After that, run `npm run webpack` in the
    terminal, which should start the Webpack dev server.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了`.env`文件后，在VSCode的终端或本机终端（导航到项目根文件夹）中运行`npm install`来安装项目的所有依赖项。之后，在终端中运行`npm
    run webpack`，这应该会启动Webpack开发服务器。
- en: Adding styles to the page
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为页面添加样式
- en: You know how to work with the Webpack dev server. So, let's move on to adding
    styles to our page. First, go through the `index.html` file to understand the
    basic structure of the page.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道如何使用Webpack开发服务器。所以，让我们继续添加样式到我们的页面。首先，浏览`index.html`文件，了解页面的基本结构。
- en: 'The body of the page is divided into two sections:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 页面的主体分为两个部分：
- en: Navbar
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航栏
- en: Container
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: 'The container is further divided into three sections:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 容器进一步分为三个部分：
- en: First, `create-room-area`, which contains the input fields needed to create
    a new room with a room name.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先是`create-room-area`，其中包含创建具有房间名称的新房间所需的输入字段。
- en: Second, `info-area`, which contains the information regarding the room (room
    name and room URL). It also has two buttons that are going to be used to copy
    the room URL (currently hidden using the `.hidden` Bootstrap style class).
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次是`info-area`，其中包含有关房间的信息（房间名称和房间URL）。它还有两个按钮，用于复制房间URL（当前使用`.hidden` Bootstrap样式类进行隐藏）。
- en: Finally, `video-area`, which is used to display the videos of all the participants.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后是`video-area`，用于显示所有参与者的视频。
- en: 'First, add the following code in `src/css/styles.css` file to prevent the container
    section from overlapping with the navigation bar:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`src/css/styles.css`文件中添加以下代码，以防止容器部分与导航栏重叠：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With Webpack hot reloading enabled, you should see the CSS changes instantly.
    The `create-room-area` looks just fine with the default Bootstrap styles. So,
    let''s move on to the second section, info-area. To work on `info-area`, temporarily
    remove the `.hidden` class from the HTML. Also, remove `.hidden` from the two
    buttons and add some text in the paragraph element, which will contain the room
    URL. It''d be great if the room URL and the buttons are aligned in a single row.
    To align them, add the following CSS in the `styles.css` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 启用Webpack热重载后，你应该立即看到CSS的更改。`create-room-area`使用默认的Bootstrap样式看起来很好。所以，让我们继续进行第二部分，info-area。要处理`info-area`，暂时从HTML中删除`.hidden`类。还要从两个按钮中删除`.hidden`，并在段落元素中添加一些文本，其中包含房间URL。如果房间URL和按钮在同一行对齐会很好。为了对齐它们，在`styles.css`文件中添加以下CSS：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For `video-area`, the videos need to be arranged in a column for mobile devices,
    while they should be arranged in a row for desktops. Hence, we can use a media
    query to assign different styles to it. Also, for the size of the video element
    (`.video-player`), we can set `max-width` and `max-height` to 25 viewport width
    so that its dimensions will be responsive for all devices. In your `styles.css`
    file, add the following styles:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`video-area`，视频需要在移动设备上以列的形式排列，而在桌面上应以行的形式排列。因此，我们可以使用媒体查询为其分配不同的样式。此外，对于视频元素（`.video-player`）的大小，我们可以将`max-width`和`max-height`设置为25视口宽度，以使其在所有设备上具有响应性的尺寸。在你的`styles.css`文件中，添加以下样式：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's all for the styles needed right now. So, let's start writing the JavaScript
    for the application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所需的样式就是这些。所以，让我们开始编写应用程序的JavaScript。
- en: Building the Video Call app
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建视频通话应用程序
- en: 'Everything''s in place, so let''s start coding. As usual, as we did in the
    previous apps, open your `home.js` file and create your `Home` class with a constructor:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪，让我们开始编码。像以前的应用程序一样，打开你的`home.js`文件并创建你的`Home`类和构造函数：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, create an instance of the `Home` class and assign it to an object, `home`,
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，创建`Home`类的一个实例，并将其分配给一个对象`home`，如下所示：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are going to have a use for the home object later. We now add the `SimpleWebRTC`
    package to our project by running the following command in the terminal from our
    project root folder:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以后会用到home对象。现在，通过在项目根文件夹的终端中运行以下命令，将`SimpleWebRTC`包添加到我们的项目中：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And add the following import statement to the top of your `home.js` file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 并在你的`home.js`文件顶部添加以下导入语句：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As per the `SimpleWebRTC` documentation, we need to create an instance of the
    `SimpleWebRTC` class with some configuration to use it in our application. In
    your `home.js` file, before the `Home` class, add the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`SimpleWebRTC`文档，我们需要创建一个`SimpleWebRTC`类的实例，并进行一些配置以在我们的应用程序中使用它。在你的`home.js`文件中，在`Home`类之前，添加以下代码：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Your application should now ask for permissions to access camera and microphone.
    This is because, behind the scenes, `SimpleWebRTC` has started working on setting
    up everything needed to initiate a video call. If you click Allow, you should
    see your video appear in a small rectangular box. This is what the configurations
    in the object you added in the previous code do:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序现在应该请求权限来访问摄像头和麦克风。这是因为在幕后，`SimpleWebRTC`已经开始设置一切需要启动视频通话的工作。如果您点击“允许”，您应该会看到您的视频出现在一个小矩形框中。这就是您在之前的代码中添加的对象中的配置所做的事情：
- en: '`localVideoEl`: Contains the ID of the element that should contain your local
    video. Here, the `video#localVideo` element from our `index.html` file is going
    to display our own video, hence, it is chosen as its value.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localVideoEl`：包含应该包含您本地视频的元素的ID。在这里，我们的`index.html`文件中的`video#localVideo`元素将显示我们自己的视频，因此选择它作为其值。'
- en: '`remoteVideosEl`: Contains the ID of the container in which the remote videos
    need to be added. We haven''t created that element yet and it''s better to add
    videos later, so just leave it as an empty string.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remoteVideosEl`：包含需要添加远程视频的容器的ID。我们还没有创建该元素，最好稍后再添加视频，所以将其留空。'
- en: '`autoRequestMedia`: Used to prompt the user to give permission to access the
    camera and microphone and needs to be set to `true`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoRequestMedia`：用于提示用户允许访问摄像头和麦克风的权限，需要设置为`true`。'
- en: '`debug`: If true, it will print all the `webrtc` events in the console. I have
    set it to `false`, but set it to true on your system to see the events happening.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`：如果为true，它将在控制台中打印所有的`webrtc`事件。我已将其设置为`false`，但在您的系统上将其设置为true以查看事件发生。'
- en: By default, `SimpleWebRTC` uses the free STUN server provided by Google, which
    is `stun.l.google.com:19302`. This STUN server is enough in most cases, unless
    you are behind some corporate firewall with complex routing protocols. Otherwise,
    you can set up your own ICE configuration with both STUN and TURN servers. For
    that, you need to install signalmaster ([https://github.com/andyet/signalmaster](https://github.com/andyet/signalmaster))
    and add the ICE configuration details to the earlier mentioned constructor. However,
    that is beyond the scope of this book. We'll simply carry on with the default
    configuration.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`SimpleWebRTC`使用由Google提供的免费STUN服务器，即`stun.l.google.com:19302`。在大多数情况下，这个STUN服务器就足够了，除非您身处一些具有复杂路由协议的企业防火墙之后。否则，您可以设置自己的ICE配置，包括STUN和TURN服务器。为此，您需要安装signalmaster（[https://github.com/andyet/signalmaster](https://github.com/andyet/signalmaster)），并将ICE配置详细信息添加到前面提到的构造函数中。然而，这超出了本书的范围。我们将简单地继续使用默认配置。
- en: 'For our first step, we''ll create the class variables and references to the
    DOM elements inside our constructor:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一步，我们将在构造函数中创建类变量和对DOM元素的引用：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That's a lot, but they are all needed for different steps of our application.
    The only variable we created here is `roomName`, which as the name suggests, contains
    the room's name. The others are all references to DOM elements.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这很多，但它们都是我们应用程序不同步骤所需的。我们在这里创建的唯一变量是`roomName`，正如其名称所示，它包含了房间的名称。其他的都是对DOM元素的引用。
- en: Creating a room
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建房间
- en: The first step of this app is to create a room so that other members can join
    a call in the room. As per the current UI design, we need to create the room when
    the user clicks the Create Room button. So, let's register a click event handler
    on that button.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用的第一步是创建一个房间，以便其他成员可以加入房间进行通话。根据当前的UI设计，当用户点击“创建房间”按钮时，我们需要创建房间。因此，让我们在该按钮上注册一个点击事件处理程序。
- en: 'So far, we have been using different methods to handle events:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用不同的方法来处理事件：
- en: In our ToDo list app, we added the `onclick` attribute to the HTML to call JavaScript
    functions `onclick` event.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的待办事项列表应用程序中，我们在HTML中添加了`onclick`属性来调用JavaScript函数的`onclick`事件。
- en: In the Meme Creator, we attached event listeners to each element, where we wanted
    to listen for a specific event to happen (keyup, change, and click events). The
    same goes for the Event Registration form, where we added an event listener to
    listen for the form submit action.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Meme Creator中，我们为每个元素附加了事件侦听器，我们希望监听特定事件的发生（keyup、change和click事件）。在事件注册表单中也是如此，我们添加了一个事件侦听器来监听表单提交操作。
- en: 'There is also another method in which you add a callback function to the event
    property of the reference to the DOM element. In our case, we need to detect a
    click event on the Create Room button. We can handle it as follows:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有另一种方法，即将回调函数添加到DOM元素的引用的事件属性中。在我们的情况下，我们需要检测“创建房间”按钮的点击事件。我们可以这样处理：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, whenever the Create Room button is clicked, it will execute the code written
    inside the preceding function. It is entirely up to you and your requirements
    to decide which event handler to use. Usually, the first method is avoided because
    it will expose your JavaScript code inside HTML and it's difficult to keep track
    of all the JavaScript functions called inside HTML in large projects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当单击“创建房间”按钮时，它将执行前述函数中编写的代码。完全取决于您和您的要求来决定使用哪种事件处理程序。通常，第一种方法会被避免，因为它会将您的JavaScript代码暴露在HTML中，并且在大型项目中难以跟踪HTML中调用的所有JavaScript函数。
- en: If you have a large number of elements, say about 100 rows in a table, attaching
    100 event listeners to each row is inefficient. You can either use the third method
    by attaching a function to the `onclick` method of the reference of each row's
    DOM element or you can attach a single event listener to the row's parent element
    and use that event listener to listen to the events of its children elements.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有大量的元素，比如表格中的100行，为每一行附加100个事件侦听器是低效的。您可以使用第三种方法，通过将函数附加到每行DOM元素的引用的`onclick`方法，或者您可以将单个事件侦听器附加到行的父元素，并使用该事件侦听器来监听其子元素的事件。
- en: For a list of all the DOM events, visit the W3Schools page: [https://www.w3schools.com/jsref/dom_obj_event.asp](https://www.w3schools.com/jsref/dom_obj_event.asp).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有DOM事件的列表，请访问W3Schools页面：[https://www.w3schools.com/jsref/dom_obj_event.asp](https://www.w3schools.com/jsref/dom_obj_event.asp)。
- en: 'In our application, we need to handle a lot of click events. So, let''s create
    a method inside the `Home` class to register all the click events:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们需要处理很多点击事件。因此，让我们在`Home`类中创建一个方法来注册所有的点击事件：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And call this method inside the constructor:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 并在构造函数中调用此方法：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside the `registerClicks()` method, add the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`registerClicks()`方法中，添加以下代码：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There are few things that need to happen when the user clicks the Create Room
    button. They are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户单击“创建房间”按钮时，需要执行一些操作：
- en: Get the room name. But the room name cannot contain any special characters that
    cause problems with the URL
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取房间名称。但是房间名称不能包含任何会导致URL出现问题的特殊字符
- en: Create a room using `SimpleWebRTC`
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SimpleWebRTC`创建一个房间
- en: Redirect the user to a URL created for the room (a URL with the room name as
    query string)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用户重定向到为房间创建的URL（带有房间名称作为查询字符串的URL）
- en: Show the URL that he/she can share with others who need to participate in the
    call
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示他/她可以与其他需要参与通话的人分享的URL
- en: 'You should write the following code inside the `onclick` method you created
    in the preceding code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在您在上述代码中创建的`onclick`方法中编写以下代码：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will get the room name that is typed in the input field and convert it
    into URL-friendly characters using regular expressions. If the room name is not
    empty, we can proceed to the creation of the room in `SimpleWebRTC`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取在输入字段中键入的房间名称，并使用正则表达式将其转换为URL友好的字符。如果房间名称不为空，我们可以继续在`SimpleWebRTC`中创建房间：
- en: '[PRE18]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code does the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: The `if` condition will check whether the room name is not empty (an empty string
    is falsy).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`条件将检查房间名称是否不为空（空字符串为假）。'
- en: '`webrtc.createRoom()` will create the room. It accepts two parameters: the
    first one is the room name string and the second one is a callback function that
    executes when the room is created.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webrtc.createRoom()`将创建房间。它接受两个参数：第一个是房间名称字符串，第二个是在创建房间时执行的回调函数。'
- en: The callback function has the parameters `err` and `name`. Usually, we should
    check whether the process is a success. So, `if(!err) {}` will contain the code
    to execute when the process is a success. `name` is the room name created by `SimpleWebRTC`.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调函数具有参数`err`和`name`。通常，我们应该检查过程是否成功。因此，`if(!err) {}`将包含在过程成功时执行的代码。`name`是由`SimpleWebRTC`创建的房间名称。
- en: 'Inside the `if(!err)` condition, add the following code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if(!err)`条件中，添加以下代码：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `location` object contains information regarding the current URL. `location.pathname`
    is used to set or get the current URL of the web page. So, we can construct a
    URL by appending the room name to it. So, if your current URL is `http://localhost:8080/` then,
    after creating the room, your URL should become `http://localhost:8080/?roomName`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`location`对象包含有关当前URL的信息。`location.pathname`用于设置或获取网页的当前URL。因此，我们可以通过将房间名称附加到其中来构造URL。因此，如果您当前的URL是`http://localhost:8080/`，那么在创建房间后，您的URL应该变为`http://localhost:8080/?roomName`。'
- en: 'To replace the URL without affecting the current page, we can use the `history`
    object provided by the History Web API. The `history` object is used to manipulate
    the browser''s history. If you want to perform the back action that happens when
    the user clicks the browser''s back button, you can do as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换URL而不影响当前页面，我们可以使用History Web API提供的`history`对象。`history`对象用于操作浏览器的历史记录。如果要执行用户单击浏览器后退按钮时发生的后退操作，可以按照以下步骤进行：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Likewise, for going forward, you can do as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要前进，可以按照以下步骤进行：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But what we need in our application is to change the current URL without affecting
    the browser history. That is, we need to change the URL from `http://localhost:8080/`
    to `http://localhost:8080/?roomName` without affecting the back or forward buttons
    of your browser.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们在应用程序中需要做的是在不影响浏览器历史记录的情况下更改当前的URL。也就是说，我们需要将URL从`http://localhost:8080/`更改为`http://localhost:8080/?roomName`，而不影响浏览器的后退或前进按钮。
- en: For such complex actions, you can use the `pushState()` and `replaceState()`
    methods introduced in HTML5 for the history object. `pushState()` creates a new
    history entry on the browser and changes the URL of the page without affecting
    the current page. `replaceState()` does the same, but instead of creating a new
    history entry, it replaces the current entry, making it ideal for our purpose.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样复杂的操作，您可以使用HTML5中引入的`pushState()`和`replaceState()`方法来处理历史对象。`pushState()`在浏览器上创建一个新的历史记录条目，并更改页面的URL，而不影响当前页面。`replaceState()`也是一样，但是它替换当前条目，非常适合我们的目的。
- en: 'Both the `pushState()` and `replaceState()` methods accept three parameters.
    The first one is `state` (a JSON object), the second one is `title` (string),
    and the third one is the new URL. This is how both `pushState()` and `replaceState()`
    works:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`pushState()`和`replaceState()`方法都接受三个参数。第一个是`state`（一个JSON对象），第二个是`title`（字符串），第三个是新的URL。这就是`pushState()`和`replaceState()`的工作原理：'
- en: Every time `pushState()` or `replaceState()` is called, it triggers a `popstate`
    event in the `window` object. The first parameter, state object, is used by the
    callback function of that event. We have no use for it now, so we set it to an
    empty object.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次调用`pushState()`或`replaceState()`时，都会触发`window`对象中的`popstate`事件。第一个参数，状态对象，由该事件的回调函数使用。我们现在用不到它，所以将其设置为空对象。
- en: Currently, most browsers just ignore the second parameter, so we just set it
    to an empty string.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目前，大多数浏览器都会忽略第二个参数，所以我们将其设置为空字符串。
- en: The third parameter URL is what we really need. It changes the browser URL to
    the provided URL string.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数URL是我们真正需要的。它将浏览器的URL更改为提供的URL字符串。
- en: 'Since the room has been created and the URL has been changed, we need to hide
    the `.create-room-area` div and display the `.info-area` div instead. That''s
    why I added the `this.roomCreated()` method. In the `Home` class, create the new
    method:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于房间已创建并且URL已更改，我们需要隐藏`.create-room-area` div并显示`.info-area` div。这就是为什么我添加了`this.roomCreated()`方法。在`Home`类中，创建新方法：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This method will show the information section while hiding the create room section.
    Also, it will change the room name and URL using the `textContent()` method, which
    changes the text that is present in the respective DOM element.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将显示信息部分，同时隐藏创建房间部分。此外，它将使用`textContent()`方法更改房间名称和URL，该方法更改了相应DOM元素中的文本。
- en: 'More information on location objects can be found on the w3schools page: [https://www.w3schools.com/jsref/obj_location.asp](https://www.w3schools.com/jsref/obj_location.asp).More
    information on the history object can be found on the MDN page: [https://developer.mozilla.org/en-US/docs/Web/API/History](https://developer.mozilla.org/en-US/docs/Web/API/History).
    Also, if you want to learn to manipulate the browser history, visit [https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有关位置对象的更多信息可以在w3schools页面上找到：[https://www.w3schools.com/jsref/obj_location.asp](https://www.w3schools.com/jsref/obj_location.asp)。有关历史对象的更多信息可以在MDN页面上找到：[https://developer.mozilla.org/en-US/docs/Web/API/History](https://developer.mozilla.org/en-US/docs/Web/API/History)。此外，如果你想学习如何操纵浏览器历史记录，可以访问[https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API)。
- en: Adding participants to your room
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向你的房间添加参与者
- en: You have an active room and the room URL with which you need to invite others.
    But wouldn't it be easier if you had a click to copy feature to copy the URL?
    That is actually a really nice feature to have. So, before we add participants
    to the room, let's build a click to copy feature.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个活跃的房间和房间URL，你需要邀请其他人。但是如果有一个点击复制功能来复制URL，那不是更方便吗？这实际上是一个非常好的功能。因此，在我们向房间添加参与者之前，让我们构建一个点击复制功能。
- en: Click to copy text
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击复制文本
- en: 'Currently, this is how the info area looks:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，信息区的外观是这样的：
- en: '![](../images/00027.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00027.jpeg)'
- en: 'For the click to copy feature, if you hover the mouse over the room URL, it
    should show a Copy button:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于点击复制功能，如果你将鼠标悬停在房间URL上，它应该显示一个复制按钮：
- en: '![](../images/00028.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00028.jpeg)'
- en: 'If you click the Copy button, it should copy the text and turn into the Copied
    button:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击复制按钮，它应该复制文本并变成已复制按钮：
- en: '![](../images/00029.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00029.jpeg)'
- en: 'For this functionality, we need to add some event listeners. So, inside your
    home class, create a new method `addEventListeners()` and call it inside the constructor:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个功能，我们需要添加一些事件监听器。因此，在你的home类中，创建一个新的方法`addEventListeners()`，并在构造函数中调用它：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The reference to the div containing the copy buttons is stored in the `this.$buttonArea`
    variable. Whenever the mouse enters a div, it will fire a `mouseenter` event.
    When this event happens in `$buttonArea`, we need to remove the `.hidden` class
    from the copy button.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 包含复制按钮的div的引用存储在`this.$buttonArea`变量中。每当鼠标进入div时，它将触发一个`mouseenter`事件。当这个事件发生在`$buttonArea`中时，我们需要从复制按钮中移除`.hidden`类。
- en: 'Inside your `addEventListeners()` method, add the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`addEventListeners()`方法中，添加以下代码：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The page will reload and you will have to create a room again. If you hover
    the mouse pointer over the room URL now, it should make the Copy button visible.
    We also need the button to be hidden when the pointer leaves `div`. Similar to
    `mouseenter`, `div` will fire a `mouseout` event when the pointer leaves it. So,
    once again, add the following code next to the preceding code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 页面将重新加载，你将不得不再次创建一个房间。如果你现在将鼠标指针悬停在房间URL上，它应该会显示复制按钮。当指针离开`div`时，我们还需要隐藏按钮。类似于`mouseenter`，当指针离开`div`时，`div`将触发一个`mouseout`事件。因此，再次在前面的代码旁边添加以下代码：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, once again, try hovering your pointer over the room URL. Surprisingly,
    it doesn't work as expected. It should have done, but it didn't. It is because
    of the `mouseout` event, which also fires when your pointer enters the child elements
    of `$buttonArea`. It considers the child elements as `outside` the `div`. To fix
    this, we need to filter the `event` object that is passed in the callback function
    so that no action happens if the pointer moves `outside` by entering the child
    elements.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次尝试将鼠标指针悬停在房间URL上。令人惊讶的是，它并没有按预期工作。它应该有作用，但它没有。这是因为`mouseout`事件，当你的指针进入`$buttonArea`的子元素时，它也会触发。它将子元素视为`div`的`外部`。为了解决这个问题，我们需要过滤传递给回调函数的`event`对象，这样如果指针通过进入子元素而移动到`外部`，就不会发生任何操作。
- en: 'This one is tricky, but if you print the event object in the console, you will
    see that there are a lot of properties and methods containing all the details
    of the event. The `toElement` property or the `relatedTarget` property will contain
    the element to which the pointer moved to depending on the browser. So, we need
    to check whether the parent of that element is `$buttonArea`. If so, we should
    prevent any actions from happening. To do this, change the preceding code to the
    following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个有点棘手，但是如果你在控制台中打印事件对象，你会看到有很多属性和方法包含了事件的所有细节。`toElement`属性或`relatedTarget`属性将包含指针移动到的元素，具体取决于浏览器。因此，我们需要检查该元素的父元素是否是`$buttonArea`。如果是，我们应该阻止任何操作发生。为了做到这一点，将前面的代码更改为以下内容：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note the line:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这一行：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is a short-circuit evaluation. What it does is, if the first value is
    truthy, it will assign it to the constant `e`. If it is falsy, the OR operator
    will evaluate the second one and assign its value to `e`. You can have any number
    of values declared like this. Say:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个短路评估。它的作用是，如果第一个值为真，它将把它赋给常量`e`。如果它为假，或运算符将评估第二个值，并将其值赋给`e`。你可以声明任意数量的值。比如：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the value of fun will be the first truthy statement on the list, hence,
    its value will be true. `'test'` is also a truthy value but it won't get evaluated,
    since there is a truthy value before it. This type of assignment is commonly used
    and is handy for certain tasks.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，fun的值将是列表中第一个真值语句，因此它的值将为true。`'test'`也是一个真值，但它不会被评估，因为在它之前有一个真值。这种类型的赋值通常被使用，对于某些任务来说非常方便。
- en: Now, the `e` object contains the target element. So, we just need to check whether
    `e` exists (to prevent exceptions) and, if so, whether its parent element or the
    element itself is `$buttonArea`. If it is true, we simply return. This way, the
    callback function stops executing without hiding the copy and copied buttons.
    We hide the copied button too because we are going to make it visible when the
    user clicks the Copy button.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`e`对象包含目标元素。所以，我们只需要检查`e`是否存在（以防止异常），如果存在，是否其父元素或元素本身是`$buttonArea`。如果是真的，我们只需返回。这样，回调函数在不隐藏复制和已复制按钮的情况下停止执行。我们也隐藏已复制按钮，因为当用户点击复制按钮时，我们将使其可见。
- en: 'Try hovering over the room URL again in your application and it should work
    as expected. The last step is to copy the URL when the user clicks on the copy
    button. So, let''s register a click in the `registerClicks()` method we created
    earlier in our `Home` class. Inside the `registerClicks()` method, add the code
    to handle the clicks on the Copy and Copied buttons and create a new method `copyUrl()`
    inside the `Home` class to do the copy action:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在应用程序中再次悬停在房间URL上，应该按预期工作。最后一步是在用户点击复制按钮时复制URL。因此，让我们在我们的`Home`类中早期创建的`registerClicks()`方法中注册点击。在`registerClicks()`方法中，添加处理点击复制和已复制按钮的代码，并在`Home`类中创建一个新方法`copyUrl()`来执行复制操作：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, inside the `registerClicks()` method, clicking on both
    the Copy button and the Copied button will call the `copyUrl()` method of the
    class. We need to add the code to copy text inside the `copyUrl()` method.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在`registerClicks()`方法中，点击复制按钮和已复制按钮都将调用类的`copyUrl()`方法。我们需要在`copyUrl()`方法中添加复制文本的代码。
- en: 'To copy text, first, we need to get a range of nodes (the DOM elements) from
    which we need to copy text. To do so, create a range object and select the `this.$roomUrl`
    node, which contains the text of the room URL. Inside the `copyUrl()` method,
    add the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要复制文本，首先，我们需要从中复制文本的节点（DOM元素）的范围。为此，创建一个范围对象并选择包含房间URL文本的`this.$roomUrl`节点。在`copyUrl()`方法中，添加以下代码：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, the range object contains the element `$roomUrl` as the selected node.
    Then, we need to select the text in the node just as a user usually selects text
    with his/her cursor. The `window` object has the `getSelection()` method, which
    we can use for this purpose. We must remove all the ranges to clear the previous
    selections and then select a new range (which is the range object we created previously).
    Add the following code to the preceding code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，范围对象包含元素`$roomUrl`作为所选节点。然后，我们需要选择节点中的文本，就像用户通常使用光标选择文本一样。`window`对象有`getSelection()`方法，我们可以用于此目的。我们必须删除所有范围以清除先前的选择，然后选择一个新范围（即我们之前创建的范围对象）。在前面的代码中添加以下代码：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we don''t know whether the user''s browser supports executing the
    copy command, so we do the copying inside a `try{} catch(err){}` statement so
    that, if any error occurs, it can be handled in the catch statement. The `document.execCommand(''copy'')`
    method will copy the text in the selected range and return it as a string. Also,
    we need to hide the copy button and display the copied button when, as copy is
    successful. The code to do copying is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不知道用户的浏览器是否支持执行复制命令，所以我们在`try{} catch(err){}`语句中进行复制，以便如果发生任何错误，可以在catch语句中处理。`document.execCommand('copy')`方法将复制所选范围内的文本并将其作为字符串返回。此外，我们需要在复制成功时隐藏复制按钮并显示已复制按钮。复制的代码如下：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After adding the preceding code, create a room in the application and try clicking
    Copy again. It should turn into the Copied button and the room URL text will be
    highlighted, because we selected the text just like how we select it, using the
    cursor with JavaScript. But it would be nice to clear the selection once copying
    is done. So, add this line at the end of the `copyUrl()` method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了前面的代码之后，在应用程序中创建一个房间，然后尝试再次点击复制。它应该变成已复制按钮，并且房间URL文本将被突出显示，因为我们选择了文本，就像我们用JavaScript和光标选择文本一样。但是，一旦复制完成，清除选择会更好。因此，在`copyUrl()`方法的末尾添加这行：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will clear the selection, so next time you click copy, the room URL text
    will not be highlighted. You can then simply paste the selected URL wherever you
    like to share it with others.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将清除选择，所以下次点击复制时，房间URL文本将不会被突出显示。然后，您可以简单地粘贴所选的URL到任何您想要分享的地方。
- en: Joining a room
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入房间
- en: 'Now that you have a link, we need to make a user join the room using that link.
    The process is simple: when the user opens the link, he joins the room and video
    of all the participants is displayed to him. To make a user join a room, `SimpleWebRTC`
    has the `joinRoom(''roomName'')` method, where the room name string is passed
    as a parameter. Once a user is in a room, it will look for the videos of other
    users connected in the room and will fire a `videoAdded` event for each video
    it finds, along with a callback function, which has the video object and the peer
    object of that user.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您有了一个链接，我们需要让用户使用该链接加入房间。这个过程很简单：当用户打开链接时，他会加入房间，并且所有参与者的视频都会显示给他。要让用户加入房间，`SimpleWebRTC`有`joinRoom('roomName')`方法，其中房间名称字符串作为参数传递。一旦用户在房间里，它将寻找房间中连接的其他用户的视频，并为它找到的每个视频触发`videoAdded`事件，以及一个回调函数，其中包含视频对象和该用户的对等对象。
- en: 'Let''s strategize on how the process should work:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们制定一下过程应该如何工作：
- en: First, we need to check whether the URL the user entered contains the room name
    in its query string. That is, if it ends with `'?roomName'`.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要检查用户输入的URL是否在其查询字符串中包含房间名称。也就是说，如果以`'?roomName'`结尾。
- en: If the room name exists, then we should make the user join the room while hiding
    the `.create-room-area` div and displaying the `.info-area` div with the room
    details.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果房间名称存在，那么我们应该让用户加入房间，同时隐藏`.create-room-area` div，并显示`.info-area` div以显示房间详情。
- en: Then, we need to listen for the `videoAdded` events and, if an event is triggered,
    we add the video to `.video-area div`.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们需要监听`videoAdded`事件，如果触发了事件，我们将视频添加到`.video-area div`中。
- en: '`SimpleWebRTC` fires a `readyToCall` event when it has finished loading. It
    also has the `on()` method to listen for the events fired. We can use the `readyToCall`
    event to check for the room name in the URL. This code should be outside the `Home`
    class. So, after the line where you called the `Home` class constructor, add the
    following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleWebRTC`在加载完成后会触发`readyToCall`事件。它还有`on()`方法来监听触发的事件。我们可以使用`readyToCall`事件来检查URL中的房间名称。这段代码应该在`Home`类之外。因此，在调用`Home`类构造函数的那一行之后，添加以下代码：'
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are using the location object to get the URL. First, we need to check whether
    the URL contains the query string using `location.search`. So, we used it in an
    if condition and, if it contains the query string, we can continue the process.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用location对象来获取URL。首先，我们需要检查URL是否包含查询字符串，使用`location.search`。因此，我们在if条件中使用它，如果它包含查询字符串，我们可以继续进行处理。
- en: 'The `split()` method splits the string into an array of substrings divided
    by the value passed to it as the parameter. The URL will be something like as
    follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()`方法将字符串拆分为由传递给它的值分隔的子字符串数组。URL将如下所示：'
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`location.search` will return the query string part of the URL:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`location.search`将返回URL的查询字符串部分：'
- en: '[PRE36]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, `location.search.split(''?'')` will convert the string into an array as
    follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`location.search.split('?')`将把字符串转换为以下数组：
- en: '[PRE37]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We have the room name at the index 1 of the array. Writing like this works,
    but here we can use a short-circuit evaluation. We used an evaluation with the
    OR operator before, where it will take the first truthy value. In this case, we
    can use the AND operator that takes the first falsy value, or the last truthy
    value if there are no falsy values. The preceding code will be simplified into
    the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在数组的索引1处有房间名称。像这样写是可以的，但是在这里我们可以使用短路评估。我们之前使用了OR运算符进行评估，它将获取第一个真值。在这种情况下，我们可以使用AND运算符，它将获取第一个假值，或者如果没有假值，则获取最后一个真值。上述代码将简化为以下形式：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If the URL does not contain the query string, `location.search` will be an empty
    string (`""`), which is a falsy value. Hence, the value of room will be an empty
    string.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果URL不包含查询字符串，`location.search`将是一个空字符串（`""`），这是一个假值。因此，房间的值将是一个空字符串。
- en: If the URL does contain the query string with the room name, then `location.search`
    will return `'?roomName'`, which is a truthy value, so the next statement `location.search.split('?')[1]`
    gets evaluated, which does the split and returns the first index in the array
    (room name). Since it is the last truthy value, the room constant will now contain
    the room name string! We just simplified three lines of code into a single line
    using short-circuit evaluation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果URL包含带有房间名称的查询字符串，那么`location.search`将返回`'?roomName'`，这是一个真值，所以下一个语句`location.search.split('?')[1]`将被评估，它执行分割并返回数组中的第一个索引（房间名称）。由于它是最后一个真值，room常量现在将包含房间名称字符串！我们使用短路评估将三行代码简化为一行代码。
- en: Detailed information on short-circuit evaluation can be found at: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-circuit_evaluation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-circuit_evaluation).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 关于短路评估的详细信息可以在以下网址找到：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-circuit_evaluation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_Operators#Short-circuit_evaluation)。
- en: Setters and getters
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置器和获取器
- en: 'We just need to add one more line to make the user join the room:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要添加一行代码来让用户加入房间：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will add the user to the room, however, once the user is inside the room,
    we need to hide the `.create-room-area` div and display the `.info-area` div.
    These are available in the `roomCreated()` method of the `Home` class. But that
    method depends on the `this.roomName` class variable, which should contain the
    room name. So, we need to update a class variable and call the `class` method
    from outside the class.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用户加入房间，但是一旦用户进入房间，我们需要隐藏`.create-room-area` div并显示`.info-area` div。这些都在`Home`类的`roomCreated()`方法中。但是该方法依赖于`this.roomName`类变量，该变量应该包含房间名称。因此，我们需要更新一个类变量并从类外部调用`class`方法。
- en: Even though we can do it by using the `home` object we created earlier, it would
    make more sense if we could just update the class's room property and it will
    perform the actions automatically. For that, we can use setters. Setters are special
    methods that are used for assigning a new value to the object's property. We have
    used getters and setters several times before. Remember how we get the value of
    the input field?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以使用之前创建的`home`对象来做到这一点，但如果我们只能更新类的room属性并且它将自动执行操作，那将更有意义。为此，我们可以使用设置器。设置器是用于为对象的属性分配新值的特殊方法。我们以前已经多次使用过获取器和设置器。还记得我们如何获取输入字段的值吗？
- en: '[PRE40]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, the value property is a getter. It returns a value from the `$roomNameInput`
    object. However, if we do the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，值属性是一个获取器。它从`$roomNameInput`对象返回一个值。但是，如果我们这样做：
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Then, it will change the value of the input field to `'New Room Name'`. This
    is because the value now acts as a setter and updates a property inside the `$roomNameInput`
    object.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它将把输入字段的值更改为`'New Room Name'`。这是因为值现在充当设置器，并更新了`$roomNameInput`对象内的属性。
- en: 'We will create a setter for our `Home` class to join a room. Creating a setter
    is simple; we simply create a method prefixed with the `set` keyword and the method
    should have *exactly one parameter*. Inside your `Home` class, add the following
    code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的`Home`类创建一个设置器来加入一个房间。创建一个设置器很简单；我们只需创建一个以`set`关键字为前缀的方法，该方法应该有*正好一个参数*。在您的`Home`类中，添加以下代码：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, use the setter (only if the room is not an empty string) in your `readyToCall`
    event handler:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的`readyToCall`事件处理程序中使用设置器（仅当房间不是空字符串时）：
- en: '[PRE43]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once you have added the code, create a room in your Video Call app and then
    copy the URL and paste it in a new tab. It should automatically get the room name
    from the URL and join the room. If you can see the room information, then you
    are good to go. We are nearing the final stage of the application--adding and
    removing videos.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 添加代码后，在视频通话应用中创建一个房间，然后复制URL并粘贴到新标签中。它应该会自动从URL获取房间名称并加入房间。如果您能看到房间信息，那么您就可以开始了。我们正接近应用程序的最后阶段--添加和删除视频。
- en: If and else conditions do not require `{}` curly braces if there is only one
    statement after them. That is, `if (true) console.log('true'); else console.log('false');`
    will work just fine! But it should be avoided, since it is always better to use `if
    else` conditions with `{}` curly braces.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果和else条件后面只有一个语句，不需要`{}`大括号。也就是说，`if (true) console.log('true'); else console.log('false');`将正常工作！但应该避免这样做，因为最好始终使用带有`{}`大括号的`if
    else`条件。
- en: 'To create a getter, you simply prefix the method with `get` instead of `set`,
    but the method should contain *no parameters*and it should *return a value*. Say,
    in your `Home` class, you need to know the room name using getter. Then, you can
    add the following method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个getter，您只需在方法前面加上`get`而不是`set`，但是该方法不应包含*参数*，并且应*返回一个值*。比如，在您的`Home`类中，您需要使用getter知道房间名称。然后，您可以添加以下方法：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you try `console.log(home.room)` outside the class, you should get the value
    stored in the `roomName` class variable.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在类外部使用`console.log(home.room)`，您应该会得到存储在`roomName`类变量中的值。
- en: Adding and removing videos
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和删除视频
- en: Similar to the `readyToCall` event, `SimpleWebRTC` will fire a `videoAdded`
    event for every video it finds in the room with a callback function having the
    video object and the peer object containing the ID (the unique ID of that user).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`readyToCall`事件，`SimpleWebRTC`将为在房间中找到的每个视频触发`videoAdded`事件，具有具有视频对象和包含ID（该用户的唯一ID）的对等对象的回调函数。
- en: To test multiple videos, we are going to open two tabs on the same browser in
    the same system. This might cause feedback to damage your audio devices, so keep
    your volume muted!
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试多个视频，我们将在同一系统的同一浏览器中打开两个标签。这可能会导致反馈损坏您的音频设备，所以保持音量静音！
- en: 'Create a new method inside the `Home` class `addRemoteVideo($video, peer)`,
    as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Home`类中创建一个新方法`addRemoteVideo($video, peer)`，如下所示：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s add another event handler for the `videoAdded` event, just as we did
    for the `readToCall` event:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为`videoAdded`事件添加另一个事件处理程序，就像我们为`readToCall`事件所做的那样：
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Whenever a video gets added, it will call the `addRemoteVideo` method of the
    `Home` class with the video object and the peer object. We have a div `.video-area`,
    which is supposed to contain all the videos. So, we need to construct a new div
    element similar to the one used for the local video, such as:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 每当添加视频时，它将调用`Home`类的`addRemoteVideo`方法，并传入视频对象和对等对象。我们有一个`.video-area`的div，它应该包含所有的视频。因此，我们需要构建一个类似于用于本地视频的新div元素，例如：
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And we should append this element to the `.video-area` div, which is currently
    referenced by `this.$remotes` variable. This is quite simple, just as we added
    the `script` element in the previous chapter. Inside your `addRemoteVideo()` method,
    add the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该将此元素附加到`.video-area` div，它当前由`this.$remotes`变量引用。这很简单，就像我们在上一章中添加`script`元素一样。在您的`addRemoteVideo()`方法中，添加以下代码：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding code does the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码执行以下操作：
- en: First, we create a `div` element using the `document.createElement('div')` method
    and assign it to the `$container` object.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们使用`document.createElement('div')`方法创建一个`div`元素，并将其分配给`$container`对象。
- en: Then, we set the class name of `$container` to `'video-container'` and ID to
    `'container_peerid'`. We can get the peer ID from the peer object we received
    using the `webrtc.getDomId()` method.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将`$container`的类名设置为`'video-container'`，ID设置为`'container_peerid'`。我们可以使用`webrtc.getDomId()`方法从我们收到的对等对象中获取对等ID。
- en: The `$video` object we received is an HTML element just like `$container`. So,
    we assign it the class name `'video-player'`.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们收到的`$video`对象是一个HTML元素，就像`$container`一样。因此，我们将其分配为类名`'video-player'`。
- en: Then, for the last step, we append `$video` as a child inside `$container` and,
    finally, append `$container` as a child inside `this.$remotes`.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，作为最后一步，我们将`$video`作为子元素附加到`$container`中，最后将`$container`作为子元素附加到`this.$remotes`中。
- en: 'This will construct the HTMLs we need with the classes and IDs. When a user
    leaves the room, the `videoRemoved` event will be fired, which is similar to the
    `videoAdded` event. Whenever the user leaves the room, we need to use the peer
    ID to remove the div containing the ID `''container_peerid''`, where `peerid`
    is the ID of the user who left. To do so, add the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用类和ID构造我们需要的HTML。当用户离开房间时，将触发`videoRemoved`事件，这类似于`videoAdded`事件。每当用户离开房间时，我们需要使用对等ID来删除包含ID`'container_peerid'`的div，其中`peerid`是离开的用户的ID。为此，请添加以下代码：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `removeRemoteVideo()` method will find the div containing the remote video
    using the peer ID and will remove it from this `this.$remotes` object using the
    `removeChild()` method.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeRemoteVideo()`方法将使用对等ID查找包含远程视频的div，并使用`removeChild()`方法从`this.$remotes`对象中删除它。'
- en: Time to test our Video Call app. Open the application in Chrome and create the
    room. Copy the room URL and paste it in a new tab (keep your volume muted!). It
    might take a few seconds, but unless STUN didn't work for you, you should see
    two videos in each of the tabs. You are streaming video between the tabs.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候测试我们的视频通话应用了。在Chrome中打开应用程序并创建房间。复制房间URL并粘贴到新标签中（保持音量静音！）。可能需要几秒钟，但除非STUN对您不起作用，否则您应该在每个标签中看到两个视频。您正在在标签之间传输视频。
- en: The first video is your video. If you close one of the tabs, you should see
    that the second video will be removed from the other tab. Before we test this
    app in other devices, there is one more feature that would really look great in
    this app. That is increasing the size of the selected video.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个视频是你的视频。如果你关闭其中一个标签，你会看到第二个视频会从另一个标签中移除。在我们在其他设备上测试这个应用之前，还有一个功能会让这个应用看起来更棒。那就是增加所选视频的大小。
- en: Selecting a video
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择视频
- en: 'Currently, all the videos are small in size. Hence, we need a feature to enlarge
    the videos, such as:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，所有的视频都很小。因此，我们需要一个功能来放大视频，比如：
- en: In desktops, clicking on a video will increase the size of the video and bring
    it to the first spot among the list of videos
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在桌面上，点击视频将增加视频的大小，并将其移动到视频列表的第一个位置
- en: In mobiles, tapping a video will only increase the size of the video
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在手机上，点击视频只会增加视频的大小
- en: 'This sounds fine. To make this happen, let''s add some styles to our `styles.css`
    file:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来不错。为了实现这一点，让我们在我们的`styles.css`文件中添加一些样式：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We have added two sets of styles using media queries. One for mobile (`max-width:
    736px`) and another for desktops (`min-width: 736px`).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '我们使用媒体查询添加了两组样式。一组用于手机（`max-width: 736px`），另一组用于桌面（`min-width: 736px`）。'
- en: 'For every click made in a video, we should add the `.video-selected` class
    to that video and `.container-selected` to the parent div of that video:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每次点击视频，我们应该为该视频添加`.video-selected`类，并为该视频的父div添加`.container-selected`类：
- en: In mobiles, it will increase the size of the video up to 70% of the viewport
    width.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在手机上，它将把视频的大小增加到视口宽度的70%。
- en: 'In desktops, it will increase the size up to 50% of the viewport width and
    also assign `order: -1` to its parent div. This way, since the parent div is part
    of flex, it will become the first item of the flex elements (but other elements
    should not contain order in their styles).'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在桌面上，它将把大小增加到视口宽度的50%，并且还会给其父div分配`order: -1`。这样，由于父div是flex的一部分，它将成为flex元素的第一个项目（但其他元素不应该在其样式中包含order）。'
- en: 'In your `Home` class, add the following method:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`Home`类中，添加以下方法：
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will find the video containing the `.video-selected` class and remove the
    `.video-selected` class from that video and the `.container-selected` class from
    that video's parent div. This is useful because we can call it to clear the selected
    ones before we select another video.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这将找到包含`.video-selected`类的视频，并从该视频和该视频的父div中移除`.video-selected`类和`.container-selected`类。这很有用，因为我们可以在选择另一个视频之前调用它来清除已选择的视频。
- en: 'We can register a click event on the local video inside the `registerClicks()`
    method. Inside the `registerClicks()` method, add the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`registerClicks()`方法中为本地视频注册点击事件。在`registerClicks()`方法中，添加以下代码：
- en: '[PRE52]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will add the required classes to the video element and its parent div.
    For remote videos, we cannot register clicks here because we create those elements
    dynamically. So, we either have to create an event listener or register a click
    event when the remote video elements are created.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为视频元素及其父级div添加所需的类。对于远程视频，我们不能在这里注册点击，因为我们动态创建这些元素。因此，我们要么创建一个事件监听器，要么在创建远程视频元素时注册点击事件。
- en: Creating an event listener for each video is not quite efficient here because
    the videos will be removed when the user leaves, so we will have unwanted event
    listeners running for each video. We will have to remove those event listeners
    using the `removeEventListener()` method or avoid this by creating an event listener
    to the parent div `.video-area` instead of the video elements. Still, this means
    that we need to filter through each of the clicks made inside `.video-area` div
    to check whether that click was made on a video.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里为每个视频创建一个事件监听器并不太有效，因为当用户离开时，视频将被移除，所以我们将有不需要的事件监听器运行在每个视频上。我们将不得不使用`removeEventListener()`方法来移除这些事件监听器，或者通过在父div`.video-area`上创建一个事件监听器来避免这种情况。不过，这意味着我们需要筛选`.video-area`内的每次点击，以检查该点击是否是在视频上进行的。
- en: 'Clearly, it''s simpler to register a click using the `onclick()` method when
    the video element is created. This saves us the trouble of dealing with event
    listeners. Inside your `addRemoteVideo()` method, add this code after the existing
    code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，当视频元素被创建时，使用`onclick()`方法注册点击更简单。这样可以避免处理事件监听器的麻烦。在你的`addRemoteVideo()`方法中，在现有代码之后添加以下代码：
- en: '[PRE53]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now try clicking on a video in Chrome. You should see that the video will increase
    its size and move to the first position on the list. Congratulations! You have
    successfully built your Video Call application! Time to test Video Call in action.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试在Chrome中点击视频。你应该看到视频会增大并移动到列表的第一个位置。恭喜！你已经成功构建了你的视频通话应用！是时候测试视频通话了。
- en: Video Call in action
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视频通话
- en: You got the application ready, so let's test it locally. First, generate the
    production build for your app. You have already done this before in the Event
    Registration app. You need to set `NODE_ENV=production` in your `.env` file.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好应用程序了，所以让我们在本地测试一下。首先，为你的应用生成生产构建。你之前在事件注册应用中已经做过这个了。你需要在你的`.env`文件中设置`NODE_ENV=production`。
- en: After that, in your project root folder, kill Webpack dev server and run the
    `npm run webpack` command. It should generate the production builds for your JS
    and CSS files. The filename will be available in the `dist/manifest.json` file.
    Include those CSS and JS files in your `index.html` page.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在你的项目根目录中，关闭Webpack开发服务器，运行`npm run webpack`命令。它应该会为你的JS和CSS文件生成生产构建。文件名将在`dist/manifest.json`文件中。在你的`index.html`页面中包含这些CSS和JS文件。
- en: Now, run `http-server` in your project root folder. It should print two IP address.
    Open the one starting with 192 in your browser. This IP address is accessible
    to all the devices in your LAN, unless you have blocked the port using a firewall.
    However, Chrome will not display your video! This is because the `getUserMedia()`
    method will only work in localhost and HTTPS URLs. Since our local address is
    using HTTP only, the video will not work.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的项目根文件夹中运行`http-server`。它应该打印出两个IP地址。在浏览器中打开以192开头的那个。这个IP地址对您局域网中的所有设备都是可访问的，除非您使用防火墙阻止了端口。然而，Chrome将无法显示您的视频！这是因为`getUserMedia()`方法只能在本地主机和HTTPS
    URL中工作。由于我们的本地地址只使用HTTP，视频将无法工作。
- en: We can add HTTPS by deploying our WebRTC application on a public server with
    an SSL certificate from a certificate authority. However, for our local development
    environment, we can use a self-signed certificate. An SSL certificate from a certificate
    authority will be trusted by all browsers, but a self-signed certificate will
    not be trusted, hence, a warning will be shown, in which we should manually select
    the option to trust the website on our browser. For this reason, self-signed certificates
    are not suitable for production and should only be used for development purposes.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在公共服务器上部署我们的WebRTC应用程序并使用来自证书颁发机构的SSL证书来添加HTTPS。然而，对于我们的本地开发环境，我们可以使用自签名证书。来自证书颁发机构的SSL证书将受到所有浏览器的信任，但自签名证书将不受信任，因此会显示警告，我们应该在浏览器上手动选择信任该网站的选项。因此，自签名证书不适用于生产，只应用于开发目的。
- en: 'Creating a self-signed certificate is a big process but, luckily, there is
    an `npm` package that can do this in a single line. We need to install this package
    globally, since it is a command-line tool like `http-server`. In your terminal,
    run the following command:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自签名证书是一个复杂的过程，但幸运的是，有一个`npm`包可以在一行命令中完成这个过程。我们需要全局安装这个包，因为它像`http-server`一样是一个命令行工具。在您的终端中运行以下命令：
- en: '[PRE54]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Linux users might have to add `sudo` to their command to install packages globally.
    By default, `http-server` will serve your files from port number `8080`. Say,
    if your current URL is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Linux用户可能需要在他们的命令中添加`sudo`以全局安装软件包。默认情况下，`http-server`将从端口号`8080`提供您的文件。比如，如果您当前的URL如下：
- en: '[PRE55]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, open another terminal and run the following command:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开另一个终端并运行以下命令：
- en: '[PRE56]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here, source is the new port number and target is the port number in which
    http-server is running. You should then open the same IP address with the new
    port number and `https://` prefix in Chrome, as shown in the following code block:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，源是新的端口号，目标是http-server正在运行的端口号。然后，您应该在Chrome中使用新的端口号和`https://`前缀打开相同的IP地址，如下面的代码块所示：
- en: '[PRE57]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you open this page in Chrome, you should receive a warning similar to the
    following screenshot. In that case, select Advanced as shown in the following
    image:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Chrome中打开此页面，您应该会收到类似以下截图的警告。在这种情况下，请选择高级，如下图所示：
- en: '![](../images/00030.jpeg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00030.jpeg)'
- en: 'Once you click Advanced, you will see a page similar to the following image
    where you should click proceed link:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 点击高级后，您将看到一个类似以下图像的页面，您应该点击继续链接：
- en: '![](../images/00031.jpeg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00031.jpeg)'
- en: You can now use this HTTPS URL to open the app in any device that is connected
    to your LAN. Make sure there is enough distance between the devices so that it
    doesn't cause feedback.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用这个HTTPS URL在连接到您的局域网的任何设备上打开应用程序。确保设备之间有足够的距离，以免造成反馈。
- en: Summary
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Hopefully, you had a great time building the Video Call application. In this
    chapter, we did some new things with JavaScript and learned some new concepts,
    such as JavaScript WebRTC APIs and the SimpleWebRTC framework. Along the way,
    we did lot of cool things, such as manipulating browser history, selecting text
    using JavaScript, and working with URLs. Also, we shortened some of our code with short-circuit
    evaluation and learned about setters and getters for manipulating class variables
    in JavaScript.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您在构建视频通话应用程序时度过了愉快的时光。在本章中，我们使用JavaScript做了一些新的事情，并学习了一些新概念，如JavaScript WebRTC
    API和SimpleWebRTC框架。在这个过程中，我们做了很多很酷的事情，比如操纵浏览器历史记录，使用JavaScript选择文本，以及处理URL。此外，我们使用短路评估缩短了一些代码，并学习了在JavaScript中操纵类变量的设置器和获取器。
- en: '`SimpleWebRTC` comes with many other events and actions which allow you to
    do more in the app, such as mute your microphone, mute audio from others, and
    so on. If you are interested, you can check out the SimpleWebRTC home page for
    more examples.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleWebRTC`还带有许多其他事件和操作，允许您在应用程序中执行更多操作，例如静音麦克风，静音其他人的音频等。如果您感兴趣，可以查看SimpleWebRTC主页获取更多示例。'
- en: We know how to create reusable JavaScript modules, which we did in the previous
    chapter. In the next chapter, we are going to take it a step further and build
    our own reusable HTML elements using web components.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道如何创建可重用的JavaScript模块，这是我们在上一章中做的。在下一章中，我们将进一步迈出一步，使用Web组件构建我们自己的可重用的HTML元素。
