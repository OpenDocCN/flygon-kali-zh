["```kt\nAPP_ABI := armeabi armeabi-v7a x86\nAPP_STL := gnustl_static\n```", "```kt\npackage com.packtpub.DroidBlaster\n\nimport android.app.NativeActivity\n\npublic class MyNativeActivity extends NativeActivity {\n     static {\n         System.loadLibrary(\"gnustl_shared\");\n         System.loadLibrary(\"DroidBlaster\");\n     }\n}\n```", "```kt\n        #ifndef _PACKT_RESOURCE_HPP_\n        #define _PACKT_RESOURCE_HPP_\n\n        #include \"Types.hpp\"\n\n        #include <android_native_app_glue.h>\n        #include <fstream>\n        #include <string>\n\n        ...\n        class Resource {\n        public:\n            Resource(android_app* pApplication, const char* pPath);\n\n            const char* getPath() { return mPath.c_str(); };\n\n            status open();\n            void close();\n            status read(void* pBuffer, size_t pCount);\n\n            off_t getLength();\n\n            bool operator==(const Resource& pOther);\n\n        private:\n            std::string mPath;\n            std::ifstream mInputStream;\n        };\n        #endif\n        ```", "```kt\n    #include \"Resource.hpp\"\n\n    #include <sys/stat.h>\n\n    Resource::Resource(android_app* pApplication, const char* pPath):\n        mPath(std::string(\"/sdcard/\") + pPath),\n        mInputStream(){\n    }\n\n    status Resource::open() {\n        mInputStream.open(mPath.c_str(), std::ios::in | std::ios::binary);\n     return mInputStream ? STATUS_OK : STATUS_KO;\n    }\n\n    void Resource::close() {\n        mInputStream.close();\n    }\n\n    status Resource::read(void* pBuffer, size_t pCount) {\n        mInputStream.read((char*)pBuffer, pCount);\n        return (!mInputStream.fail()) ? STATUS_OK : STATUS_KO;\n    }\n    ...\n    ```", "```kt\n    ...\n    off_t Resource::getLength() {\n        struct stat filestatus;\n        if (stat(mPath.c_str(), &filestatus) >= 0) {\n            return filestatus.st_size;\n        } else {\n            return -1;\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    bool Resource::operator==(const Resource& pOther) {\n        return mPath == pOther.mPath;\n    }\n    ```", "```kt\n    #include \"Log.hpp\"\n    #include \"Resource.hpp\"\n    #include \"SoundService.hpp\"\n\n    #include <string>\n    ...\n    status SoundManager::playBGM(Resource& pResource) {\n        SLresult result;\n        Log::info(\"Opening BGM %s\", pResource.getPath());\n\n        // Set-up BGM audio source.\n        SLDataLocator_URI dataLocatorIn;\n        std::string path = pResource.getPath();\n        dataLocatorIn.locatorType = SL_DATALOCATOR_URI;\n        dataLocatorIn.URI = (SLchar*) path.c_str();\n\n        SLDataFormat_MIME dataFormat;\n        dataFormat.formatType    = SL_DATAFORMAT_MIME;\n        ...\n    }\n    ...\n    ```", "```kt\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <manifest \n        package=\"com.packtpub.droidblaster2d\" android:versionCode=\"1\"\n        android:versionName=\"1.0\">\n\n        <uses-permission\n            android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n\n        ...\n    </manifest>\n    ```", "```kt\n    ...\n    #include <android_native_app_glue.h>\n    #include <GLES2/gl2.h>\n    #include <EGL/egl.h>\n\n    #include <map>\n    #include <vector>\n    ...\n    struct TextureProperties {\n        GLuint texture;\n        int32_t width;\n        int32_t height;\n    };\n\n    class GraphicsManager {\n        ...\n        // Graphics resources.\n        std::map<Resource*, TextureProperties> mTextures;\n        std::vector<GLuint> mShaders;\n        std::vector<GLuint> mVertexBuffers;\n\n        std::vector<GraphicsComponent*> mComponents;\n\n        // Rendering resources.\n        ...\n    };\n    #endif\n    ```", "```kt\n    #include \"GraphicsManager.hpp\"\n    #include \"Log.hpp\"\n\n    #include <png.h>\n\n    GraphicsManager::GraphicsManager(android_app* pApplication) :\n        ...\n        mProjectionMatrix(),\n        mTextures(), mShaders(), mVertexBuffers(), mComponents(),\n        mScreenFrameBuffer(0),\n        mRenderFrameBuffer(0), mRenderVertexBuffer(0),\n        ... {\n        Log::info(\"Creating GraphicsManager.\");\n    }\n    ...\n    ```", "```kt\n    ...\n    void GraphicsManager::registerComponent(GraphicsComponent* pComponent)\n    {\n        mComponents.push_back(pComponent);\n    }\n    ...\n    ```", "```kt\n    ...\n    status GraphicsManager::start() {\n        ...\n        mProjectionMatrix[3][3] =  1.0f;\n\n        // Loads graphics components.\n        for (std::vector<GraphicsComponent*>::iterator\n                componentIt = mComponents.begin();\n                componentIt < mComponents.end(); ++componentIt) {\n            if ((*componentIt)->load() != STATUS_OK) return STATUS_KO;\n        }\n        return STATUS_OK;\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    void GraphicsManager::stop() {\n        Log::info(\"Stopping GraphicsManager.\");\n        // Releases textures.\n        std::map<Resource*, TextureProperties>::iterator textureIt;\n        for (textureIt = mTextures.begin(); textureIt != mTextures.end();\n                ++textureIt) {\n            glDeleteTextures(1, &textureIt->second.texture);\n        }\n\n        // Releases shaders.\n        std::vector<GLuint>::iterator shaderIt;\n        for (shaderIt = mShaders.begin(); shaderIt < mShaders.end();\n                ++shaderIt) {\n            glDeleteProgram(*shaderIt);\n        }\n        mShaders.clear();\n\n        // Releases vertex buffers.\n        std::vector<GLuint>::iterator vertexBufferIt;\n        for (vertexBufferIt = mVertexBuffers.begin();\n                vertexBufferIt < mVertexBuffers.end(); ++vertexBufferIt) {\n            glDeleteBuffers(1, &(*vertexBufferIt));\n        }\n        mVertexBuffers.clear();\n\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    status GraphicsManager::update() {\n        // Uses the offscreen FBO for scene rendering.\n        glBindFramebuffer(GL_FRAMEBUFFER, mRenderFrameBuffer);\n        glViewport(0, 0, mRenderWidth, mRenderHeight);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        // Render graphic components.\n        std::vector<GraphicsComponent*>::iterator componentIt;\n        for (componentIt = mComponents.begin();\n                componentIt < mComponents.end(); ++componentIt) {\n            (*componentIt)->draw();\n        }\n\n        // The FBO is rendered and scaled into the screen.\n        glBindFramebuffer(GL_FRAMEBUFFER, mScreenFrameBuffer);\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    TextureProperties* GraphicsManager::loadTexture(Resource& pResource) {\n        // Looks for the texture in cache first.\n        std::map<Resource*, TextureProperties>::iterator textureIt =\n                                               mTextures.find(&pResource);\n        if (textureIt != mTextures.end()) {\n            return &textureIt->second;\n        }\n\n        Log::info(\"Loading texture %s\", pResource.getPath());\n        ...\n        Log::info(\"Texture size: %d x %d\", width, height);\n\n        // Caches the loaded texture.\n        textureProperties = &mTextures[&pResource];\n        textureProperties->texture = texture;\n        textureProperties->width = width;\n        textureProperties->height = height;\n        return textureProperties;\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    GLuint GraphicsManager::loadShader(const char* pVertexShader,\n            const char* pFragmentShader) {\n       ...\n        if (result == GL_FALSE) {\n            glGetProgramInfoLog(shaderProgram, sizeof(log), 0, log);\n            Log::error(\"Shader program error: %s\", log);\n            goto ERROR;\n        }\n\n        mShaders.push_back(shaderProgram);\n        return shaderProgram;\n\n        ...\n    }\n\n    GLuint GraphicsManager::loadVertexBuffer(const void* pVertexBuffer,\n            int32_t pVertexBufferSize) {\n        ...\n        if (glGetError() != GL_NO_ERROR) goto ERROR;\n\n        mVertexBuffers.push_back(vertexBuffer);\n        return vertexBuffer;\n        ...\n    }\n    ```", "```kt\n    ...\n    #ifndef _PACKT_GRAPHICSSPRITEBATCH_HPP_\n    #define _PACKT_GRAPHICSSPRITEBATCH_HPP_\n\n    #include \"GraphicsManager.hpp\"\n    #include \"Sprite.hpp\"\n    #include \"TimeManager.hpp\"\n    #include \"Types.hpp\"\n\n    #include <GLES2/gl2.h>\n    #include <vector>\n\n    class SpriteBatch : public GraphicsComponent {\n        ...\n        TimeManager& mTimeManager;\n        GraphicsManager& mGraphicsManager;\n\n        std::vector<Sprite*> mSprites;\n        std::vector<Sprite::Vertex> mVertices;\n        std::vector<GLushort> mIndexes;\n        GLuint mShaderProgram;\n        GLuint aPosition; GLuint aTexture;\n        GLuint uProjection; GLuint uTexture;\n    };\n    #endif\n    ```", "```kt\n    ...\n    SpriteBatch::SpriteBatch(TimeManager& pTimeManager,\n            GraphicsManager& pGraphicsManager) :\n        mTimeManager(pTimeManager),\n        mGraphicsManager(pGraphicsManager),\n        mSprites(), mVertices(), mIndexes(),\n        mShaderProgram(0),\n        aPosition(-1), aTexture(-1), uProjection(-1), uTexture(-1)\n    {\n        mGraphicsManager.registerComponent(this);\n    }\n\n    SpriteBatch::~SpriteBatch() {\n        std::vector<Sprite*>::iterator spriteIt;\n        for (spriteIt = mSprites.begin(); spriteIt < mSprites.end();\n                ++spriteIt) {\n            delete (*spriteIt);\n        }\n    }\n\n    Sprite* SpriteBatch::registerSprite(Resource& pTextureResource,\n            int32_t pHeight, int32_t pWidth) {\n        int32_t spriteCount = mSprites.size();\n        int32_t index = spriteCount * 4; // Points to 1st vertex.\n\n        // Precomputes the index buffer.\n        mIndexes.push_back(index+0); mIndexes.push_back(index+1);\n        mIndexes.push_back(index+2); mIndexes.push_back(index+2);\n        mIndexes.push_back(index+1); mIndexes.push_back(index+3);\n        for (int i = 0; i < 4; ++i) {\n            mVertices.push_back(Sprite::Vertex());\n        }\n\n        // Appends a new sprite to the sprite array.\n        mSprites.push_back(new Sprite(mGraphicsManager,\n                pTextureResource, pHeight, pWidth));\n        return mSprites.back();\n    }\n    ...\n    ```", "```kt\n    ...\n    status SpriteBatch::load() {\n        ...\n        uTexture = glGetUniformLocation(mShaderProgram, \"u_texture\");\n\n        // Loads sprites.\n        std::vector<Sprite*>::iterator spriteIt;\n        for (spriteIt = mSprites.begin(); spriteIt < mSprites.end();\n                ++spriteIt) {\n            if ((*spriteIt)->load(mGraphicsManager)\n                    != STATUS_OK) goto ERROR;\n        }\n        return STATUS_OK;\n\n    ERROR:\n        Log::error(\"Error loading sprite batch\");\n        return STATUS_KO;\n    }\n\n    void SpriteBatch::draw() {\n        ...\n        // Renders all sprites in batch.\n        const int32_t vertexPerSprite = 4;\n        const int32_t indexPerSprite = 6;\n        float timeStep = mTimeManager.elapsed();\n        int32_t spriteCount = mSprites.size();\n        int32_t currentSprite = 0, firstSprite = 0;\n        while (bool canDraw = (currentSprite < spriteCount)) {\n            Sprite* sprite = mSprites[currentSprite];\n            ...\n        }\n        ...\n    }\n    ```", "```kt\n    #ifndef _PACKT_ASTEROID_HPP_\n    #define _PACKT_ASTEROID_HPP_\n\n    #include \"GraphicsManager.hpp\"\n    #include \"PhysicsManager.hpp\"\n    #include \"TimeManager.hpp\"\n    #include \"Types.hpp\"\n\n    #include <vector>\n\n    class Asteroid {\n    public:\n        ...\n        PhysicsManager& mPhysicsManager;\n\n        std::vector<PhysicsBody*> mBodies;\n        float mMinBound;\n        float mUpperBound; float mLowerBound;\n        float mLeftBound; float mRightBound;\n    };\n    #endif\n    ```", "```kt\n    #include \"Asteroid.hpp\"\n    #include \"Log.hpp\"\n\n    static const float BOUNDS_MARGIN = 128;\n    static const float MIN_VELOCITY = 150.0f, VELOCITY_RANGE = 600.0f;\n\n    Asteroid::Asteroid(android_app* pApplication,\n            TimeManager& pTimeManager, GraphicsManager& pGraphicsManager,\n            PhysicsManager& pPhysicsManager) :\n        mTimeManager(pTimeManager),\n        mGraphicsManager(pGraphicsManager),\n        mPhysicsManager(pPhysicsManager),\n        mBodies(),\n        mMinBound(0.0f),\n        mUpperBound(0.0f), mLowerBound(0.0f),\n        mLeftBound(0.0f), mRightBound(0.0f) {\n    }\n\n    void Asteroid::registerAsteroid(Location& pLocation,\n            int32_t pSizeX, int32_t pSizeY) {\n        mBodies.push_back(mPhysicsManager.loadBody(pLocation,\n                pSizeX, pSizeY));\n    }\n\n    void Asteroid::initialize() {\n        mMinBound = mGraphicsManager.getRenderHeight();\n        mUpperBound = mMinBound * 2;\n        mLowerBound = -BOUNDS_MARGIN;\n        mLeftBound = -BOUNDS_MARGIN;\n        mRightBound = (mGraphicsManager.getRenderWidth() + BOUNDS_MARGIN);\n\n        std::vector<PhysicsBody*>::iterator bodyIt;\n        for (bodyIt = mBodies.begin(); bodyIt < mBodies.end(); ++bodyIt) {\n            spawn(*bodyIt);\n        }\n    }\n\n    void Asteroid::update() {\n        std::vector<PhysicsBody*>::iterator bodyIt;\n        for (bodyIt = mBodies.begin(); bodyIt < mBodies.end(); ++bodyIt) {\n            PhysicsBody* body = *bodyIt;\n            if ((body->location->x < mLeftBound)\n             || (body->location->x > mRightBound)\n             || (body->location->y < mLowerBound)\n             || (body->location->y > mUpperBound)) {\n                spawn(body);\n            }\n        }\n    }\n    ...\n    ```", "```kt\n    LOCAL_PATH:= $(call my-dir)\n\n    LS_CPP=$(subst $(1)/,,$(wildcard $(1)/$(2)/*.cpp))\n\n    BOX2D_CPP:= $(call LS_CPP,$(LOCAL_PATH),Box2D/Collision) \\\n                $(call LS_CPP,$(LOCAL_PATH),Box2D/Collision/Shapes) \\\n                $(call LS_CPP,$(LOCAL_PATH),Box2D/Common) \\\n                $(call LS_CPP,$(LOCAL_PATH),Box2D/Dynamics) \\\n                $(call LS_CPP,$(LOCAL_PATH),Box2D/Dynamics/Contacts) \\\n                $(call LS_CPP,$(LOCAL_PATH),Box2D/Dynamics/Joints) \\\n                $(call LS_CPP,$(LOCAL_PATH),Box2D/Rope)\n    ...\n    ```", "```kt\n        ...\n        include $(CLEAR_VARS)\n\n        LOCAL_MODULE:= box2d_static\n        LOCAL_SRC_FILES:= $(BOX2D_CPP)\n        LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)\n        LOCAL_C_INCLUDES := $(LOCAL_EXPORT_C_INCLUDES)\n        ...\n        Finally, request Box2D module compilation as a static library as follows:\n        ...\n        include $(BUILD_STATIC_LIBRARY)\n        ...\n        Optionally, the same process can be repeated to build a shared version of the same library by selecting a different module name and invoking $(BUILD_SHARED_LIBRARY) instead, as shown in the following:\n        ...\n        include $(CLEAR_VARS)\n\n        LOCAL_MODULE:= box2d_shared\n        LOCAL_SRC_FILES:= $(BOX2D_CPP)\n        LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)\n        LOCAL_C_INCLUDES := $(LOCAL_EXPORT_C_INCLUDES)\n\n        include $(BUILD_SHARED_LIBRARY)\n\n        ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n\n    include $(CLEAR_VARS)\n\n    LS_CPP=$(subst $(1)/,,$(wildcard $(1)/*.cpp))\n    LOCAL_MODULE    := droidblaster\n    LOCAL_SRC_FILES := $(call LS_CPP,$(LOCAL_PATH))\n    LOCAL_LDLIBS    := -landroid -llog -lEGL -lGLESv1_CM -lOpenSLES\n\n    LOCAL_STATIC_LIBRARIES:=android_native_app_glue png \\\n                            box2d_static\n\n    include $(BUILD_SHARED_LIBRARY)\n\n    $(call import-module,android/native_app_glue)\n    $(call import-module,libpng)\n    $(call import-module,box2d)\n    ```", "```kt\n    #ifndef PACKT_PHYSICSMANAGER_HPP\n    #define PACKT_PHYSICSMANAGER_HPP\n\n    #include \"GraphicsManager.hpp\"\n    #include \"TimeManager.hpp\"\n    #include \"Types.hpp\"\n\n    #include <Box2D/Box2D.h>\n    #include <vector>\n\n    #define PHYSICS_SCALE 32.0f\n\n    struct PhysicsCollision {\n        bool collide;\n\n        PhysicsCollision():\n            collide(false)\n        {}\n    };\n    ...\n    ```", "```kt\n        ...\n        class PhysicsManager : private b2ContactListener {\n        public:\n            PhysicsManager(TimeManager& pTimeManager,\n                    GraphicsManager& pGraphicsManager);\n            ~PhysicsManager();\n\n            b2Body* loadBody(Location& pLocation, uint16 pCategory,\n                uint16 pMask, int32_t pSizeX, int32_t pSizeY,\n                float pRestitution);\n            b2MouseJoint* loadTarget(b2Body* pBodyObj);\n            void start();\n            void update();\n\n        private:\n            PhysicsManager(const PhysicsManager&);\n            void operator=(const PhysicsManager&);\n\n            void BeginContact(b2Contact* pContact);\n\n            TimeManager& mTimeManager;\n            GraphicsManager& mGraphicsManager;\n\n            b2World mWorld;\n            std::vector<b2Body*> mBodies;\n            std::vector<Location*> mLocations;\n            b2Body* mBoundsBodyObj;\n        };\n        #endif\n        ```", "```kt\n    #include \"PhysicsManager.hpp\"\n    #include \"Log.hpp\"\n\n    static const int32_t VELOCITY_ITER = 6;\n    static const int32_t POSITION_ITER = 2;\n\n    PhysicsManager::PhysicsManager(TimeManager& pTimeManager,\n            GraphicsManager& pGraphicsManager) :\n      mTimeManager(pTimeManager), mGraphicsManager(pGraphicsManager),\n      mWorld(b2Vec2_zero), mBodies(),\n      mLocations(),\n      mBoundsBodyObj(NULL) {\n        Log::info(\"Creating PhysicsManager.\");\n        mWorld.SetContactListener(this);\n    }\n\n    PhysicsManager::~PhysicsManager() {\n        std::vector<b2Body*>::iterator bodyIt;\n        for (bodyIt = mBodies.begin(); bodyIt < mBodies.end(); ++bodyIt) {\n            delete (PhysicsCollision*) (*bodyIt)->GetUserData();\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    void PhysicsManager::start() {\n        if (mBoundsBodyObj == NULL) {\n            b2BodyDef boundsBodyDef;\n            b2ChainShape boundsShapeDef;\n            float renderWidth = mGraphicsManager.getRenderWidth()\n                                    / PHYSICS_SCALE;\n            float renderHeight = mGraphicsManager.getRenderHeight()\n                                    / PHYSICS_SCALE;\n            b2Vec2 boundaries[4];\n            boundaries[0].Set(0.0f, 0.0f);\n            boundaries[1].Set(renderWidth, 0.0f);\n            boundaries[2].Set(renderWidth, renderHeight);\n            boundaries[3].Set(0.0f, renderHeight);\n            boundsShapeDef.CreateLoop(boundaries, 4);\n\n            mBoundsBodyObj = mWorld.CreateBody(&boundsBodyDef);\n            mBoundsBodyObj->CreateFixture(&boundsShapeDef, 0);\n        }\n    }\n    ```", "```kt\n    b2Body* PhysicsManager::loadBody(Location& pLocation,\n            uint16 pCategory, uint16 pMask, int32_t pSizeX, int32_t pSizeY,\n            float pRestitution) {\n        PhysicsCollision* userData = new PhysicsCollision();\n\n        b2BodyDef mBodyDef;\n        b2Body* mBodyObj;\n        b2CircleShape mShapeDef; b2FixtureDef mFixtureDef;\n\n        mBodyDef.type = b2_dynamicBody;\n        mBodyDef.userData = userData;\n        mBodyDef.awake = true;\n        mBodyDef.fixedRotation = true;\n\n        mShapeDef.m_p = b2Vec2_zero;\n        int32_t diameter = (pSizeX + pSizeY) / 2;\n        mShapeDef.m_radius = diameter / (2.0f * PHYSICS_SCALE);\n        ...\n    ```", "```kt\n        ...\n        mFixtureDef.shape = &mShapeDef;\n        mFixtureDef.density = 1.0f;\n        mFixtureDef.friction = 0.0f;\n        mFixtureDef.restitution = pRestitution;\n        mFixtureDef.filter.categoryBits = pCategory;\n        mFixtureDef.filter.maskBits = pMask;\n        mFixtureDef.userData = userData;\n\n        mBodyObj = mWorld.CreateBody(&mBodyDef);\n        mBodyObj->CreateFixture(&mFixtureDef);\n        mBodyObj->SetUserData(userData);\n        mLocations.push_back(&pLocation);\n        mBodies.push_back(mBodyObj);\n        return mBodyObj;\n    }\n    ...\n    ```", "```kt\n    ...\n    b2MouseJoint* PhysicsManager::loadTarget(b2Body* pBody) {\n        b2BodyDef emptyBodyDef;\n        b2Body* emptyBody = mWorld.CreateBody(&emptyBodyDef);\n\n        b2MouseJointDef mouseJointDef;\n        mouseJointDef.bodyA = emptyBody;\n        mouseJointDef.bodyB = pBody;\n        mouseJointDef.target = b2Vec2(0.0f, 0.0f);\n        mouseJointDef.maxForce = 50.0f * pBody->GetMass();\n        mouseJointDef.dampingRatio = 0.15f;\n        mouseJointDef.frequencyHz = 3.5f;\n\n        return (b2MouseJoint*) mWorld.CreateJoint(&mouseJointDef);\n    }\n    ...\n    ```", "```kt\n        ...\n        void PhysicsManager::update() {\n            // Clears collision flags.\n            int32_t size = mBodies.size();\n            for (int32_t i = 0; i < size; ++i) {\n                PhysicsCollision* physicsCollision =\n                       ((PhysicsCollision*) mBodies[i]->GetUserData());\n                physicsCollision->collide = false;\n            }\n            // Updates simulation.\n            float timeStep = mTimeManager.elapsed();\n            mWorld.Step(timeStep, VELOCITY_ITER, POSITION_ITER);\n\n            // Caches the new state.\n            for (int32_t i = 0; i < size; ++i) {\n                const b2Vec2& position = mBodies[i]->GetPosition();\n                mLocations[i]->x = position.x * PHYSICS_SCALE;\n                mLocations[i]->y = position.y * PHYSICS_SCALE;\n            }\n        }\n        ...\n        ```", "```kt\n    ...\n    void PhysicsManager::BeginContact(b2Contact* pContact) {\n        void* userDataA = pContact->GetFixtureA()->GetUserData();\n        void* userDataB = pContact->GetFixtureB()->GetUserData();\n        if (userDataA != NULL && userDataB != NULL) {\n            ((PhysicsCollision*)userDataA)->collide = true;\n            ((PhysicsCollision*)userDataB)->collide = true;\n        }\n    }\n    ```", "```kt\n    ...\n    class Asteroid {\n        ...\n    private:\n        void spawn(b2Body* pBody);\n\n        TimeManager& mTimeManager;\n        GraphicsManager& mGraphicsManager;\n        PhysicsManager& mPhysicsManager;\n\n        std::vector<b2Body*> mBodies;\n        float mMinBound;\n        float mUpperBound; float mLowerBound;\n        float mLeftBound; float mRightBound;\n    };\n    #endif\n    ```", "```kt\n    #include \"Asteroid.hpp\"\n    #include \"Log.hpp\"\n\n    static const float BOUNDS_MARGIN = 128 / PHYSICS_SCALE;\n    static const float MIN_VELOCITY = 150.0f / PHYSICS_SCALE;\n    static const float VELOCITY_RANGE = 600.0f / PHYSICS_SCALE;\n\n    ...\n    void Asteroid::initialize() {\n        mMinBound = mGraphicsManager.getRenderHeight() / PHYSICS_SCALE;\n        mUpperBound = mMinBound * 2;\n        mLowerBound = -BOUNDS_MARGIN;\n        mLeftBound = -BOUNDS_MARGIN;\n        mRightBound = (mGraphicsManager.getRenderWidth() / PHYSICS_SCALE)\n                          + BOUNDS_MARGIN;\n\n        std::vector<b2Body*>::iterator bodyIt;\n        for (bodyIt = mBodies.begin(); bodyIt < mBodies.end(); ++bodyIt) {\n            spawn(*bodyIt);\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    void Asteroid::registerAsteroid(Location& pLocation,\n            int32_t pSizeX, int32_t pSizeY) {\n        mBodies.push_back(mPhysicsManager.loadBody(pLocation,\n                0X1, 0x2, pSizeX, pSizeY, 2.0f));\n    }\n    ...\n    ```", "```kt\n    ...\n    void Asteroid::update() {\n        std::vector<b2Body*>::iterator bodyIt;\n        for (bodyIt = mBodies.begin(); bodyIt < mBodies.end(); ++bodyIt) {\n            b2Body* body = *bodyIt;\n            if ((body->GetPosition().x < mLeftBound)\n             || (body->GetPosition().x > mRightBound)\n             || (body->GetPosition().y < mLowerBound)\n             || (body->GetPosition().y > mUpperBound)) {\n                spawn(body);\n            }\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    void Asteroid::spawn(b2Body* pBody) {\n        float velocity = -(RAND(VELOCITY_RANGE) + MIN_VELOCITY);\n        float posX = mLeftBound + RAND(mRightBound - mLeftBound);\n        float posY = mMinBound + RAND(mUpperBound - mMinBound);\n        pBody->SetTransform(b2Vec2(posX, posY), 0.0f);\n        pBody->SetLinearVelocity(b2Vec2(0.0f, velocity));\n    }\n    ```", "```kt\n        ...\n        #include \"GraphicsManager.hpp\"\n        #include \"PhysicsManager.hpp\"\n        #include \"SoundManager.hpp\"\n        ...\n\n        class Ship {\n        public:\n            Ship(android_app* pApplication,\n                 GraphicsManager& pGraphicsManager,\n                 SoundManager& pSoundManager);\n\n            void registerShip(Sprite* pGraphics, Sound* pCollisionSound,\n         b2Body* pBody);\n\n            void initialize();\n            void update();\n\n            bool isDestroyed() { return mDestroyed; }\n\n        private:\n            GraphicsManager& mGraphicsManager;\n            SoundManager& mSoundManager;\n            Sprite* mGraphics;\n            Sound* mCollisionSound;\n            b2Body* mBody;\n            bool mDestroyed; int32_t mLives;\n        };\n        #endif\n        ```", "```kt\n    #include \"Log.hpp\"\n    #include \"Ship.hpp\"\n\n    static const float INITAL_X = 0.5f;\n    static const float INITAL_Y = 0.25f;\n    static const int32_t DEFAULT_LIVES = 10;\n\n    static const int32_t SHIP_DESTROY_FRAME_1 = 8;\n    static const int32_t SHIP_DESTROY_FRAME_COUNT = 9;\n    static const float SHIP_DESTROY_ANIM_SPEED = 12.0f;\n\n    Ship::Ship(android_app* pApplication,\n            GraphicsManager& pGraphicsManager,\n            SoundManager& pSoundManager) :\n      mGraphicsManager(pGraphicsManager),\n      mGraphics(NULL),\n      mSoundManager(pSoundManager),\n      mCollisionSound(NULL),\n      mBody(NULL),\n      mDestroyed(false), mLives(0) {\n    }\n\n    void Ship::registerShip(Sprite* pGraphics, Sound* pCollisionSound,\n                            b2Body* pBody) {\n        mGraphics = pGraphics;\n        mCollisionSound = pCollisionSound;\n        mBody = pBody;\n    }\n\n    void Ship::initialize() {\n        mDestroyed = false;\n     mLives = DEFAULT_LIVES;\n\n        b2Vec2 position(\n           mGraphicsManager.getRenderWidth() * INITAL_X / PHYSICS_SCALE,\n           mGraphicsManager.getRenderHeight() * INITAL_Y / PHYSICS_SCALE);\n        mBody->SetTransform(position, 0.0f);\n        mBody->SetActive(true);\n    }\n    ...\n    ```", "```kt\n    ...\n    void Ship::update() {\n        if (mLives >= 0) {\n            if (((PhysicsCollision*) mBody->GetUserData())->collide) {\n                mSoundManager.playSound(mCollisionSound);\n                --mLives;\n                if (mLives < 0) {\n                    Log::info(\"Ship has been destroyed\");\n                    mGraphics->setAnimation(SHIP_DESTROY_FRAME_1,\n                        SHIP_DESTROY_FRAME_COUNT, SHIP_DESTROY_ANIM_SPEED,\n                        false);\n                    mBody->SetActive(false);\n                } else {\n                    Log::info(\"Ship collided\");\n                }\n            }\n        }\n        // Destroyed.\n        else {\n            if (mGraphics->animationEnded()) {\n                mDestroyed = true;\n            }\n        }\n    }\n    ```", "```kt\n        #ifndef _PACKT_MOVEABLEBODY_HPP_\n        #define _PACKT_MOVEABLEBODY_HPP_\n\n        #include \"InputManager.hpp\"\n        #include \"PhysicsManager.hpp\"\n        #include \"Types.hpp\"\n\n        class MoveableBody {\n        public:\n            MoveableBody(android_app* pApplication,\n               InputManager& pInputManager, PhysicsManager& pPhysicsManager);\n\n            b2Body* registerMoveableBody(Location& pLocation,\n                    int32_t pSizeX, int32_t pSizeY);\n\n            void initialize();\n            void update();\n\n        private:\n            PhysicsManager& mPhysicsManager;\n            InputManager& mInputManager;\n\n            b2Body* mBody;\n            b2MouseJoint* mTarget;\n        };\n        #endif\n        ```", "```kt\n    #include \"Log.hpp\"\n    #include \"MoveableBody.hpp\"\n\n    static const float MOVE_SPEED = 10.0f / PHYSICS_SCALE;\n\n    MoveableBody::MoveableBody(android_app* pApplication,\n          InputManager& pInputManager, PhysicsManager& pPhysicsManager) :\n      mInputManager(pInputManager),\n      mPhysicsManager(pPhysicsManager),\n      mBody(NULL), mTarget(NULL) {\n    }\n\n    b2Body* MoveableBody::registerMoveableBody(Location& pLocation,\n            int32_t pSizeX, int32_t pSizeY) {\n        mBody = mPhysicsManager.loadBody(pLocation, 0x2, 0x1, pSizeX,\n                pSizeY, 0.0f);\n        mTarget = mPhysicsManager.loadTarget(mBody);\n        mInputManager.setRefPoint(&pLocation);\n        return mBody;\n    }\n    ...\n    ```", "```kt\n    ...\n    void MoveableBody::initialize() {\n        mBody->SetLinearVelocity(b2Vec2(0.0f, 0.0f));\n    }\n\n    void MoveableBody::update() {\n        b2Vec2 target = mBody->GetPosition() + b2Vec2(\n            mInputManager.getDirectionX() * MOVE_SPEED,\n            mInputManager.getDirectionY() * MOVE_SPEED);\n        mTarget->SetTarget(target);\n    }\n    ```", "```kt\n    ...\n\n    DroidBlaster::DroidBlaster(android_app* pApplication):\n        ... {\n        Log::info(\"Creating DroidBlaster\");\n\n        Sprite* shipGraphics = mSpriteBatch.registerSprite(mShipTexture,\n                SHIP_SIZE, SHIP_SIZE);\n        shipGraphics->setAnimation(SHIP_FRAME_1, SHIP_FRAME_COUNT,\n                SHIP_ANIM_SPEED, true);\n        Sound* collisionSound =\n                mSoundManager.registerSound(mCollisionSound);\n        b2Body* shipBody = mMoveableBody.registerMoveableBody(\n                shipGraphics->location, SHIP_SIZE, SHIP_SIZE);\n        mShip.registerShip(shipGraphics, collisionSound, shipBody);\n\n        // Creates asteroids.\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    status DroidBlaster::onActivate() {\n        Log::info(\"Activating DroidBlaster\");\n        // Starts managers.\n        if (mGraphicsManager.start() != STATUS_OK) return STATUS_KO;\n        if (mSoundManager.start() != STATUS_OK) return STATUS_KO;\n        mInputManager.start();\n        mPhysicsManager.start();\n\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    status DroidBlaster::onStep() {\n        mTimeManager.update();\n        mPhysicsManager.update();\n\n        // Updates modules.\n        mAsteroids.update();\n        mMoveableBody.update();\n        mShip.update();\n\n        if (mShip.isDestroyed()) return STATUS_EXIT;\n        return mGraphicsManager.update();\n    }\n    ...\n    ```", "```kt\nmBodyDef.bullet = true;\n```", "```kt\nmFixtureDef.isSensor = true;\n```", "```kt\n    ...\n    /opt/android-ndk/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86_64/bin/arm-linux-androideabi-g++ -MMD -MP -MF ./obj/local/armeabi/objs/DroidBlaster/Asteroid.o.d -fpic -ffunction-sections -funwind-tables -fstack-protector -no-canonical-prefixes -march=armv5te -mtune=xscale -msoft-float -fno-exceptions -fno-rtti -mthumb -Os -g -DNDEBUG -fomit-frame-pointer -fno-strict-aliasing -finline-limit=64 -I/opt/android-ndk/sources/android/native_app_glue -I/opt/android-ndk/sources/libpng -I/opt/android-ndk/sources/box2d -I/opt/android-ndk/sources/cxx-stl/gnu-libstdc++/4.6/include -I/opt/android-ndk/sources/cxx-stl/gnu-libstdc++/4.6/libs/armeabi/include -I/opt/android-ndk/sources/cxx-stl/gnu-libstdc++/4.6/include/backward -Ijni -DANDROID  -Wa,--noexecstack -Wformat -Werror=format-security      -I/opt/android-ndk/platforms/android-16/arch-arm/usr/include -c  jni/Asteroid.cpp -o ./obj/local/armeabi/objs/DroidBlaster/Asteroid.o\n\n    ...\n    /opt/android-ndk/toolchains/arm-linux-androideabi-4.6/prebuilt/linux-x86_64/bin/arm-linux-androideabi-ar crsD ./obj/local/armeabi/libandroid_native_app_glue.a ./obj/local/armeabi/objs/android_native_app_glue/android_native_app_glue.o\n    ...\n    ```", "```kt\n    import feature ;\n    import os ;\n\n    if [ os.name ] = CYGWIN || [ os.name ] = NT {\n        androidPlatform = windows ;\n    } else if [ os.name ] = LINUX {\n        if [ os.platform ] = X86_64 {\n            androidPlatform = linux-x86_64 ;\n        } else {\n            androidPlatform = linux-x86 ;\n        }\n    } else if [ os.name ] = MACOSX {\n        androidPlatform = darwin-x86 ;\n    }\n    ...\n    ```", "```kt\n    ...\n    modules.poke : NO_BZIP2 : 1 ;\n    ...\n    ```", "```kt\n    ...\n    android_ndk = [ os.environ ANDROID_NDK ] ;\n    using gcc : android4.6_armeabi :\n        $(android_ndk)/toolchains/arm-linux-androideabi-4.6/prebuilt/$(androidPlatform)/bin/arm-linux-androideabi-g++ :\n        <archiver>$(android_ndk)/toolchains/arm-linux-androideabi-4.6/prebuilt/$(androidPlatform)/bin/arm-linux-androideabi-ar\n        <ranlib>$(android_ndk)/toolchains/arm-linux-androideabi-4.6/prebuilt/$(androidPlatform)/bin/arm-linux-androideabi-ranlib\n        <compileflags>--sysroot=$(android_ndk)/platforms/android-16/arch-arm\n        <compileflags>-I$(android_ndk)/sources/cxx-stl/gnu-libstdc++/4.6/include\n        <compileflags>-I$(android_ndk)/sources/cxx-stl/gnu-libstdc++/4.6/libs/armeabi/include\n    ...\n    ```", "```kt\n    ...\n        <compileflags>-fexceptions\n        <compileflags>-frtti\n    ...\n    ```", "```kt\n            <compileflags>-march=armv5te\n            <compileflags>-mthumb\n            <compileflags>-mtune=xscale\n            <compileflags>-msoft-float\n            <compileflags>-fno-strict-aliasing\n            <compileflags>-finline-limit=64\n            <compileflags>-D__arm__\n            <compileflags>-D__ARM_ARCH_5__\n            <compileflags>-D__ARM_ARCH_5T__\n            <compileflags>-D__ARM_ARCH_5E__\n            <compileflags>-D__ARM_ARCH_5TE__\n            <compileflags>-MMD\n            <compileflags>-MP\n            <compileflags>-MF\n            <compileflags>-fpic\n            <compileflags>-ffunction-sections\n            <compileflags>-funwind-tables\n            <compileflags>-fstack-protector\n            <compileflags>-no-canonical-prefixes\n            <compileflags>-Os\n            <compileflags>-fomit-frame-pointer\n            <compileflags>-fno-omit-frame-pointer\n            <compileflags>-DANDROID\n            <compileflags>-D__ANDROID__\n            <compileflags>-DNDEBUG\n            <compileflags>-D__GLIBC__\n            <compileflags>-DBOOST_ASIO_DISABLE_STD_ATOMIC\n            <compileflags>-D_GLIBCXX__PTHREADS\n            <compileflags>-Wa,--noexecstack\n            <compileflags>-Wformat\n            <compileflags>-Werror=format-security\n            <compileflags>-lstdc++\n            <compileflags>-Wno-long-long\n                ;\n        ```", "```kt\n    ./b2 --without-python toolset=gcc-android4.6_armeabi link=static runtime-link=static target-os=linux architecture=arm --stagedir=android-armeabi threading=multi\n\n    ```", "```kt\n        LOCAL_PATH:= $(call my-dir)\n\n        include $(CLEAR_VARS)\n\n        LOCAL_MODULE:= boost_unit_test_framework\n        LOCAL_SRC_FILES:= android-$(TARGET_ARCH_ABI)/lib/libboost_unit_test_framework.a\n        LOCAL_EXPORT_C_INCLUDES := $(LOCAL_PATH)\n\n        include $(PREBUILT_STATIC_LIBRARY)\n        ```", "```kt\n    #include \"Log.hpp\"\n    #include \"TimeManager.hpp\"\n\n    #include <unistd.h>\n\n    #define BOOST_TEST_MODULE DroidBlaster_test_module\n    #include <boost/test/included/unit_test.hpp>\n\n    BOOST_AUTO_TEST_SUITE(suiteTimeManager)\n\n    BOOST_AUTO_TEST_CASE(testTimeManagerTest_elapsed)\n    {\n        TimeManager timeManager;\n        timeManager.reset();\n\n        sleep(1);\n        timeManager.update();\n        BOOST_REQUIRE(timeManager.elapsed() > 0.9f);\n        BOOST_REQUIRE(timeManager.elapsed() < 1.2f);\n\n        sleep(1);\n        timeManager.update();\n        BOOST_REQUIRE(timeManager.elapsed() > 0.9f);\n        BOOST_REQUIRE(timeManager.elapsed() < 1.2f);\n    }\n\n    BOOST_AUTO_TEST_SUITE_END()\n    ```", "```kt\n    APP_ABI := armeabi armeabi-v7a x86\n    APP_STL := gnustl_static\n    APP_CPPFLAGS := -fexceptions \u2013frtti\n\n    ```", "```kt\n    ...\n    include $(BUILD_SHARED_LIBRARY)\n\n    include $(CLEAR_VARS)\n\n    LS_CPP=$(subst $(1)/,,$(wildcard $(1)/*.cpp))\n    LS_CPP_TEST=$(subst $(1)/,,$(wildcard $(1)/../test/*.cpp))\n    LOCAL_MODULE := DroidBlaster_test\n    LOCAL_SRC_FILES := $(call LS_CPP,$(LOCAL_PATH)) \\\n\n    $(call LS_CPP_TEST,$(LOCAL_PATH))\n    LOCAL_LDLIBS := -landroid -llog -lEGL -lGLESv2 -lOpenSLES\n    LOCAL_STATIC_LIBRARIES := android_native_app_glue png box2d_static \\\n        libboost_unit_test_framework\n\n    include $(BUILD_EXECUTABLE)\n\n    $(call import-module,android/native_app_glue)\n    $(call import-module,libpng)\n    $(call import-module,box2d)\n    $(call import-module,boost)\n\n    ```", "```kt\n    adb push libs/armeabi-v7a/droidblaster_test /data/data/\n    adb shell /data/data/droidblaster_test\n\n    ```", "```kt\n...\nNDK_TOOLCHAIN_VERSION := 4.8\nAPP_CPPFLAGS += -std=c++11\nAPP_STL := gnustl_shared\n...\n```", "```kt\nifdef my_var\n    # Do something...\nendif\n```", "```kt\nmy_function=$(<do_something> ${1},${2})\n$(call my_function,myparam)\n```", "```kt\n    my_value   := Android\n    my_message := I am an $(my_value)\n    $(info $(my_message))\n    my_value   := Android eating an apple\n    $(info $(my_message))\n    ```", "```kt\n    $(info Optimization level: $(APP_OPTIM) $(NDK_APP_CFLAGS))\n    ```", "```kt\n    ifndef LOCAL_PATH\n        $(error What a terrible failure! LOCAL_PATH not defined...)\n    endif\n    ```", "```kt\n    ls = $(wildcard $(var_dir))\n    dir_list := . ./jni\n    files := $(foreach var_dir, $(dir_list), $(ls))\n    ```", "```kt\n    log=$(info $(shell date +'%D %R'): $(1))\n    $(call log,My message)\n    ```", "```kt\n    $(info MY_DIR    =$(call my-dir))\n    include $(CLEAR_VARS)\n    $(info MY_DIR    =$(call my-dir))\n    ```"]