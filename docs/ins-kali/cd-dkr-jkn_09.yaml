- en: Advanced Continuous Delivery
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级持续交付
- en: In the last chapter, we covered how server clustering works and how we can use
    it together with Docker and Jenkins. In this chapter, we will see a mixture of
    different aspects that are very important in the Continuous Delivery process but
    have not been described yet.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了服务器集群的工作原理以及如何与Docker和Jenkins一起使用。在本章中，我们将看到一系列不同方面的内容，这些内容在持续交付过程中非常重要，但尚未被描述。
- en: 'This chapter covers the following points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下要点：
- en: Explaining how to approach database changes in the context of Continuous Delivery
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释如何在持续交付的背景下处理数据库更改
- en: Introducing the idea of database migration and related tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍数据库迁移及相关工具的概念
- en: Exploring different approaches to backwards-compatible and backwards-incompatible
    database updates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索向后兼容和不向后兼容的数据库更新的不同方法
- en: Using parallel steps in the Jenkins pipeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jenkins流水线中使用并行步骤
- en: Creating a Jenkins shared library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Jenkins共享库
- en: Presenting a way to roll back production changes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍回滚生产更改的方法
- en: Introducing Continuous Delivery for legacy systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为传统系统引入持续交付
- en: Exploring how to prepare zero-downtime deployments
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索如何准备零停机部署
- en: Presenting Continuous Delivery best practices
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍持续交付的最佳实践
- en: Managing database changes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理数据库更改
- en: 'So far, we have focused on the Continuous Delivery process, which was applied
    to a web service. A simple part of this was that web services are inherently stateless.
    This fact means that they can be easily updated, restarted, cloned in many instances,
    and recreated from the given source code. A web service, however, is usually linked
    to its stateful part, a database that poses new challenges to the delivery process.
    These challenges can be grouped into the following categories:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经专注于应用于Web服务的持续交付过程。其中一个简单的部分是Web服务本质上是无状态的。这意味着它们可以很容易地更新、重新启动、在许多实例中克隆，并且可以从给定的源代码重新创建。然而，Web服务通常与其有状态部分——数据库相关联，这给交付过程带来了新的挑战。这些挑战可以分为以下几类：
- en: '**Compatibility**: The database schema and the data itself must be compatible
    with the web service all the time'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性**：数据库架构和数据本身必须始终与Web服务兼容'
- en: '**Zero-downtime deployment**: In order to achieve zero-downtime deployment,
    we use rolling updates, which means that a database must be compatible with two
    different web service versions at the same time'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零停机部署**：为了实现零停机部署，我们使用滚动更新，这意味着数据库必须同时与两个不同的Web服务版本兼容'
- en: '**Rollback**: A rollback of a database can be difficult, limited, or sometimes
    even impossible because not all operations are reversible (for example, removing
    a column that contains data)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚**：数据库的回滚可能很困难，受限制，有时甚至是不可能的，因为并非所有操作都是可逆的（例如，删除包含数据的列）'
- en: '**Test data**: Database-related changes are difficult to test because we need
    test data that is very similar to production'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试数据**：与数据库相关的更改很难测试，因为我们需要与生产环境非常相似的测试数据'
- en: In this section, I will explain how to address these challenges so that the
    Continuous Delivery process will be as safe as possible.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将解释如何解决这些挑战，以便持续交付过程尽可能安全。
- en: Understanding schema updates
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解模式更新
- en: If you think about the delivery process, it's not really the data itself that
    cause difficulties because we don't usually change the data when we deploy an
    application. The data is something that is collected while the system is live
    in the production; whereas, during deployment, we only change the way we store
    and interpret this data. In other words, in the context of the Continuous Delivery
    process, we are interested in the structure of the database, not exactly in its
    content. This is why this section concerns mainly relational databases (and their
    schemas) and focuses less on other types of storage such as NoSQL databases, where
    there is no structure definition.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你考虑交付过程，实际上并不是数据本身造成了困难，因为当我们部署一个应用程序时，我们通常不会改变数据。数据是在系统在生产环境中运行时收集的；而在部署过程中，我们只是改变了存储和解释这些数据的方式。换句话说，在持续交付过程的背景下，我们对数据库的结构感兴趣，而不是它的内容。这就是为什么这一部分主要涉及关系数据库（及其模式），并且对其他类型的存储，如NoSQL数据库，关注较少，因为它们没有结构定义。
- en: To understand this better, we think of Redis, which we have already used in
    this book. It stored the cached data, so effectively it was a database. Nevertheless,
    it required zero effort from the Continuous Delivery perspective since it didn't
    have any data structure. All it stored was the key-value entries, which does not
    evolve over time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，我们可以想象一下Redis，我们在本书中已经使用过。它存储了缓存数据，因此实际上它是一个数据库。然而，从持续交付的角度来看，它不需要任何努力，因为它没有任何数据结构。它存储的只是键值条目，这些条目随时间不会发生变化。
- en: NoSQL databases usually don't have any restricting schema and therefore simplify
    the Continuous Delivery process because there is no additional schema update step
    required. This is a huge benefit; however, it doesn't necessarily mean that writing
    applications with NoSQL databases is simpler because we have put more effort into
    data validation in the source code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库通常没有任何限制模式，因此简化了持续交付过程，因为不需要额外的模式更新步骤。这是一个巨大的好处；然而，这并不一定意味着使用NoSQL数据库编写应用程序更简单，因为我们在源代码中需要更多的努力来进行数据验证。
- en: Relational databases have static schemas. If we would like to change it, for
    example, to add a new column to the table, we need to write and execute a SQL
    DDL (data definition language) script. Doing this manually for every change requires
    a lot of work and leads to error-prone solutions, in which the operations team
    has to keep in sync the code and the database structure. A much better solution
    is to automatically update the schema in an incremental manner. Such a solution
    is called database migration.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库具有静态模式。如果我们想要更改它，例如向表中添加新列，我们需要编写并执行SQL DDL（数据定义语言）脚本。为每个更改手动执行这个操作需要大量的工作，并且会导致易出错的解决方案，运维团队必须保持代码和数据库结构同步。一个更好的解决方案是以增量方式自动更新模式。这样的解决方案称为数据库迁移。
- en: Introducing database migrations
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入数据库迁移
- en: 'Database schema migration is a process of incremental changes to the relational
    database structure. Let''s have a look at the following diagram to understand
    it better:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库模式迁移是对关系数据库结构进行增量更改的过程。让我们看一下以下图表，以更好地理解它：
- en: '![](assets/bf27905b-b5aa-4f40-a4b0-37eaf35957ca.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bf27905b-b5aa-4f40-a4b0-37eaf35957ca.png)'
- en: The database in the version **v1** has the schema defined by the `V1_init.sql` file.
    Additionally, it stores the metadata related to the migration process, for example,
    its current schema version and the migration changelog. When we want to update
    the schema, we provide the changes in the form of a SQL file, such as `V2_add_table.sql`.
    Then, we need to run the migration tool that executes the given SQL file on the
    database (it also updates the metatables). In effect, the database schema is a
    result of all subsequently executed SQL migration scripts. Next, we will see an
    example of a migration.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 版本**v1**的数据库由`V1_init.sql`文件定义。此外，它还存储与迁移过程相关的元数据，例如当前模式版本和迁移日志。当我们想要更新模式时，我们以SQL文件的形式提供更改，比如`V2_add_table.sql`。然后，我们需要运行迁移工具，它会在数据库上执行给定的SQL文件（还会更新元表）。实际上，数据库模式是所有随后执行的SQL迁移脚本的结果。接下来，我们将看一个迁移的例子。
- en: Migration scripts should be stored in the version control system, usually in
    the same repository as the source code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移脚本应该存储在版本控制系统中，通常与源代码存储在同一个仓库中。
- en: 'Migration tools and the strategies they use can be divided into two categories:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移工具及其使用的策略可以分为两类：
- en: '**Upgrade and downgrade**: This approach, for example, used by the Ruby on
    Rails framework, means that we can migrate up (from v1 to v2) and down (from v2
    to v1). It allows the database schema to roll back, which may sometimes end up
    in data loss (if the migration is logically irreversible).'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**升级和降级**：这种方法，例如Ruby on Rails框架使用的方法，意味着我们可以向上迁移（从v1到v2）和向下迁移（从v2到v1）。它允许数据库模式回滚，这有时可能导致数据丢失（如果迁移在逻辑上是不可逆的）。'
- en: '**Upgrade only**: This approach, for example, used by the Flyway tool, only
    allows us to migrate up (from v1 to v2). In many cases, the database updates are
    not reversible, for example, removing a table from the database. Such a change
    cannot be rolled back because even if we recreate the table, we have already lost
    all the data.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅升级**：这种方法，例如Flyway工具使用的方法，只允许我们向上迁移（从v1到v2）。在许多情况下，数据库更新是不可逆的，例如从数据库中删除表。这样的更改无法回滚，因为即使我们重新创建表，我们已经丢失了所有数据。'
- en: There are many database migration tools available on the market, out of which
    the most popular are Flyway, Liquibase, and Rail Migrations (from the Ruby on
    Rails framework). As a next step to understand how such tools work, we will see
    an example based on the Flyway tool.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有许多数据库迁移工具，其中最流行的是Flyway、Liquibase和Rail Migrations（来自Ruby on Rails框架）。为了了解这些工具的工作原理，我们将以Flyway工具为例进行介绍。
- en: There are also commercial solutions provided for the particular databases, for
    example, Redgate (for SQL Server) and Optim Database Administrator (for DB2).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些商业解决方案专门针对特定的数据库，例如Redgate（用于SQL Server）和Optim Database Administrator（用于DB2）。
- en: Using Flyway
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flyway
- en: 'Let''s use Flyway to create a database schema for the calculator web service.
    The database will store the history of all operations that were executed on the
    service: the first parameter, the second parameter, and the result.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Flyway为计算器Web服务创建数据库模式。数据库将存储在服务上执行的所有操作的历史记录：第一个参数、第二个参数和结果。
- en: 'We show how to use the SQL database and Flyway in three steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示如何在三个步骤中使用SQL数据库和Flyway。
- en: Configuring the Flyway tool to work together with Gradle.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Flyway工具与Gradle一起工作。
- en: Defining the SQL migration script to create the calculation history table.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义SQL迁移脚本以创建计算历史表。
- en: Using the SQL database inside the Spring Boot application code.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Spring Boot应用程序代码中使用SQL数据库。
- en: Configuring Flyway
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Flyway
- en: 'In order to use Flyway together with Gradle, we need to add the following content
    to the `build.gradle` file:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Flyway与Gradle一起使用，我们需要将以下内容添加到`build.gradle`文件中：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s a quick comment on the configuration:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对配置的快速评论：
- en: We used the H2 database, which is an in-memory (and file-based) database
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了H2数据库，这是一个内存（和基于文件的）数据库。
- en: We store the database in the `/tmp/calculator` file
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将数据库存储在`/tmp/calculator`文件中
- en: The default database user is called `sa` (system administrator)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认数据库用户称为`sa`（系统管理员）
- en: In the case of other SQL databases (for example, MySQL), the configuration would
    be very similar. The only difference is in the Gradle dependencies and the JDBC
    connection.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他SQL数据库（例如MySQL），配置将非常相似。唯一的区别在于Gradle依赖项和JDBC连接。
- en: 'After this configuration is applied, we should be able to run the Flyway tool
    by executing the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 应用此配置后，我们应该能够通过执行以下命令来运行Flyway工具：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The command created the database in the file `/tmp/calculator.mv.db`. Obviously,
    it has no schema since we haven't defined anything yet.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令在文件`/tmp/calculator.mv.db`中创建了数据库。显然，由于我们还没有定义任何内容，它没有模式。
- en: Flyway can be used as a command-line tool, via Java API, or as a plugin for
    the popular building tools Gradle, Maven, and Ant.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Flyway可以作为命令行工具、通过Java API或作为流行构建工具Gradle、Maven和Ant的插件来使用。
- en: Defining  the SQL migration script
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义SQL迁移脚本
- en: 'The next step is to define the SQL file that adds the calculation table into
    the database schema. Let''s create the `src/main/resources/db/migration/V1__Create_calculation_table.sql` file
    with the following content:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义SQL文件，将计算表添加到数据库模式中。让我们创建`src/main/resources/db/migration/V1__Create_calculation_table.sql`文件，内容如下：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Note the migration file naming convention, `<version>__<change_description>.sql`.
    The SQL file creates a table with four columns, `ID`, `A`, `B`, `RESULT`. The
    `ID` column is an automatically incremented primary key of the table. Now, we
    are ready to run the Flyway command to apply the migration:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意迁移文件的命名约定，`<version>__<change_description>.sql`。SQL文件创建了一个具有四列`ID`、`A`、`B`、`RESULT`的表。`ID`列是表的自动递增主键。现在，我们准备运行Flyway命令来应用迁移：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The command automatically detected the migration file and executed it on the
    database.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令自动检测到迁移文件并在数据库上执行了它。
- en: The migration files should be always kept in the version control system, usually,
    together with the source code.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移文件应始终保存在版本控制系统中，通常与源代码一起。
- en: Accessing database
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问数据库
- en: We executed our first migration, so the database is prepared. To see the complete
    example, we should also adapt our project so that it would access the database.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行了第一个迁移，因此数据库已准备就绪。为了查看完整的示例，我们还应该调整我们的项目，以便它可以访问数据库。
- en: 'Let''s first configure the Gradle dependencies to use the H2 database from
    the Spring Boot project. We can do this by adding the following lines to the `build.gradle` file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们配置Gradle依赖项以使用Spring Boot项目中的H2数据库。我们可以通过将以下行添加到`build.gradle`文件中来实现这一点：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next step is to set up the database location and the startup behavior in
    the `src/main/resources/application.properties` file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在`src/main/resources/application.properties`文件中设置数据库位置和启动行为：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The second line means that Spring Boot will not try to automatically generate
    the database schema from the source code model. On the contrary, it will only
    validate if the database schema is consistent with the Java model.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行意味着Spring Boot不会尝试从源代码模型自动生成数据库模式。相反，它只会验证数据库模式是否与Java模型一致。
- en: 'Now, let''s create the Java ORM entity model for the calculation in the new
    `src/main/java/com/leszko/calculator/Calculation.java` file:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在新的`src/main/java/com/leszko/calculator/Calculation.java`文件中为计算创建Java
    ORM实体模型：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The entity class represents the database mapping in the Java code. A table is
    expressed as a class and each column as a field. The next step is to create the
    repository for loading and storing the `Calculation` entities.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 实体类在Java代码中表示数据库映射。一个表被表示为一个类，每一列被表示为一个字段。下一步是创建用于加载和存储`Calculation`实体的存储库。
- en: 'Let''s create the `src/main/java/com/leszko/calculator/CalculationRepository.java` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`src/main/java/com/leszko/calculator/CalculationRepository.java`文件：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can use the `Calculation` and `CalculationRepository` classes to
    store the calculation history. Let''s add the following code to the `src/main/java/com/leszko/calculator/CalculatorController.java `file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`Calculation`和`CalculationRepository`类来存储计算历史。让我们将以下代码添加到`src/main/java/com/leszko/calculator/CalculatorController.java`文件中：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, when we start the service and execute the `/sum` endpoint, each summing
    operation is logged into the database.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们启动服务并执行`/sum`端点时，每个求和操作都会记录到数据库中。
- en: If you would like to browse the database content, then you can add `spring.h2.console.enabled=true` to
    the `application.properties` file, and then browse the database via the `/h2-console` endpoint.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想浏览数据库内容，那么您可以将`spring.h2.console.enabled=true`添加到`application.properties`文件中，然后通过`/h2-console`端点浏览数据库。
- en: We explained how the database schema migration works and how to use it inside
    a Spring project, built with Gradle. Now, let's have a look at how it integrates
    within the Continuous Delivery process.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解释了数据库模式迁移的工作原理以及如何在使用Gradle构建的Spring项目中使用它。现在，让我们看看它如何在持续交付过程中集成。
- en: Changing database in Continuous Delivery
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在持续交付中更改数据库
- en: 'The first approach to use database updates inside the Continuous Delivery pipeline
    could be to add a stage within the migration command execution. This simple solution
    would work correctly for many cases; however, it has two significant drawbacks:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续交付管道中使用数据库更新的第一种方法可能是在迁移命令执行中添加一个阶段。这个简单的解决方案对许多情况都能正确工作；然而，它有两个重大缺点：
- en: '**Rollback**: As mentioned before, it''s not always possible to roll back the
    database change (Flyway doesn''t support downgrades at all). Therefore, in the
    case of service rollback, the database becomes incompatible.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚**：如前所述，不总是可能回滚数据库更改（Flyway根本不支持降级）。因此，在服务回滚的情况下，数据库变得不兼容。'
- en: '**Downtime**: The service update and the database update are not executed exactly
    at the same time, which causes downtime.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停机时间**：服务更新和数据库更新并非完全同时执行，这会导致停机时间。'
- en: 'This leads us to two constraints that we will need to address:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致我们需要解决的两个约束：
- en: The database version needs to be compatible with the service version all the
    time
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库版本需要始终与服务版本兼容
- en: The database schema migration is not reversible
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库模式迁移是不可逆的
- en: 'We will address these constraints for two different cases: backwards-compatible
    updates and non-backwards-compatible updates.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将针对两种不同情况解决这些约束：向后兼容的更新和非向后兼容的更新。
- en: Backwards-compatible changes
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向后兼容的更改
- en: 'Backwards-compatible changes are simpler. Let''s look at the following figure
    to see how they work:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 向后兼容的更改更简单。让我们看一下以下图表，看看它们是如何工作的：
- en: '![](assets/32844c8c-5496-4c95-b02a-11a8e511ebd5.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/32844c8c-5496-4c95-b02a-11a8e511ebd5.png)'
- en: Suppose the schema migration `Database v10` is backwards-compatible. If we need
    to roll back the `Service v1.2.8` release, then we deploy `Service v1.2.7`, and
    there is no need to do anything with the database (database migrations are not
    reversible, so we keep `Database v11`). Since the schema update is backwards-compatible,
    `Service v.1.2.7` works perfectly fine with `Database v11`. The same applies if
    we need to roll back to `Service v1.2.6`, and so on. Now, suppose `Database v10` and
    all other migrations are backwards-compatible, then we could roll back to any
    service version and everything would work correctly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设模式迁移“数据库v10”是向后兼容的。如果我们需要回滚“服务v1.2.8”版本，那么我们部署“服务v1.2.7”，并且不需要对数据库做任何操作（数据库迁移是不可逆的，所以我们保留“数据库v11”）。由于模式更新是向后兼容的，“服务v.1.2.7”可以完美地与“数据库v11”配合使用。如果我们需要回滚到“服务v1.2.6”，等等，也是一样的。现在，假设“数据库v10”和所有其他迁移都是向后兼容的，那么我们可以回滚到任何服务版本，一切都会正常工作。
- en: There is also no problem with the downtime. If the database migration is zero-downtime
    itself, then we can execute it first and then use the rolling updates for the
    service.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 停机时间也不是问题。如果数据库迁移本身是零停机的，那么我们可以先执行它，然后对服务使用滚动更新。
- en: 'Let''s look at an example of a backwards-compatible change. We will create
    a schema update that adds a `created_at` column to the calculation table. The
    migration file `src/main/resources/db/migration/V2__Add_created_at_column.sql` looks
    as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个向后兼容更改的例子。我们将创建一个模式更新，向计算表添加一个“created_at”列。迁移文件`src/main/resources/db/migration/V2__Add_created_at_column.sql`如下所示：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Besides the migration script, the calculator service requires a new field in
    the `Calculation` class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了迁移脚本，计算器服务还需要在“Calculation”类中添加一个新字段：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also need to adjust its constructor and then its usage in the `CalculatorController`
    class:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要调整它的构造函数，然后在`CalculatorController`类中使用它：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: After running the service, the calculation history is stored together with the
    `created_at` column. Note that the change is backwards-compatible because even
    if we revert the Java code and leave the `created_at` column in the database,
    everything would work perfectly fine (the reverted code does not address the new
    column at all).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 运行服务后，计算历史记录将与“created_at”列一起存储。请注意，这个更改是向后兼容的，因为即使我们恢复Java代码并保留数据库中的“created_at”列，一切都会正常工作（恢复的代码根本不涉及新列）。
- en: Non-backwards-compatible changes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不向后兼容的更改
- en: Non-backwards-compatible changes are way more difficult. Looking at the previous
    figure, if database change v11 was backwards-incompatible, it would be impossible
    to roll back the service to 1.2.7\. In this case, how can we approach non-backwards-compatible
    database migrations so that rollbacks and zero-downtime deployments would be possible?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不向后兼容的更改要困难得多。看看前面的图，如果数据库更改v11是不向后兼容的，那么将无法将服务回滚到1.2.7版本。在这种情况下，我们如何处理不向后兼容的数据库迁移，以便回滚和零停机部署是可能的呢？
- en: 'To make a long story short, we can address this issue by converting a non-backwards-compatible
    change into a change that is backwards-compatible for a certain period of time.
    In other words, we need to put in the extra effort and split the schema migration
    into two parts:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 长话短说，我们可以通过将不向后兼容的更改转换为在一定时间内向后兼容的更改来解决这个问题。换句话说，我们需要额外努力并将模式迁移分为两部分：
- en: Backwards-compatible update executed now, which usually means keeping some redundant
    data
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在执行的向后兼容更新通常意味着保留一些冗余数据
- en: Non-backwards-compatible update executed after the rollback period time that
    defines how far back we can revert our code
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在回滚期限之后执行的不向后兼容更新定义了我们可以回滚代码的时间范围
- en: 'To illustrate this better, let''s look at the following image:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地说明这一点，让我们看一下以下图片：
- en: '![](assets/91d810e9-805d-403b-a399-d45e6b3b2fe3.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/91d810e9-805d-403b-a399-d45e6b3b2fe3.png)'
- en: 'Let''s think about an example of dropping a column. A proposed method would
    include two steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个删除列的例子。一个提议的方法包括两个步骤：
- en: Stop using the column in the source code (v1.2.5, backwards-compatible update,
    executed first).
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止在源代码中使用该列（v1.2.5，向后兼容的更新，首先执行）。
- en: Drop the column from the database (v11, non-backwards-compatible update, executed
    after the rollback period).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中删除列（v11，不向后兼容的更新，在回滚期之后执行）。
- en: All service versions until `Database v11` can be rolled back to any previous
    version, the services starting from `Service v1.2.8` can be rolled back only within
    the rollback period. Such approach may sound trivial because all we did was delay
    the column removal from the database. However, it addresses both the rollback
    issue and the zero-downtime deployment issue. As a result, it reduces the risk
    associated with the release. If we adjust the rollback period to a reasonable
    amount of time, for example, in the case of multiple releases per day to two weeks,
    then the risk is negligible. We don't usually roll many versions back.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 直到`Database v11`的所有服务版本都可以回滚到任何以前的版本，从`Service v1.2.8`开始的服务只能在回滚期内回滚。这种方法可能听起来很琐碎，因为我们所做的一切只是延迟了从数据库中删除列。但是，它解决了回滚问题和零停机部署问题。因此，它减少了与发布相关的风险。如果我们将回滚期调整为合理的时间，例如，每天多次发布到两周，则风险可以忽略不计。我们通常不会回滚很多版本。
- en: 'Dropping a column was a very simple example. Let''s have a look at a more difficult
    scenario and rename the result column in our calculator service. We present how
    to do this in a few steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 删除列是一个非常简单的例子。让我们看一个更困难的情景，并在我们的计算器服务中重命名结果列。我们将在几个步骤中介绍如何做到这一点：
- en: Adding a new column to the database.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向数据库添加新列。
- en: Changing the code to use both columns.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改代码以使用两列。
- en: Merging the data in both columns.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并两列中的数据。
- en: Removing the old column from the code.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代码中删除旧列。
- en: Dropping the old column from the database.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数据库中删除旧列。
- en: Adding a new column to the database
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向数据库添加新列
- en: 'Let''s say we need to rename the `result` column to `sum`. The first step is
    to add a new column that will be a duplicate. We must create a `src/main/resources/db/migration/V3__Add_sum_column.sql` migration
    file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要将`result`列重命名为`sum`。第一步是添加一个将是重复的新列。我们必须创建一个`src/main/resources/db/migration/V3__Add_sum_column.sql`迁移文件：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As a result, after executing the migration, we have two columns: `result` and
    `sum`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在执行迁移后，我们有两列：`result`和`sum`。
- en: Changing the code to use both columns
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改代码以使用两列
- en: 'The next step is to rename the column in the source code model and to use both
    database columns for the set and get operations. We can change it in the `Calculation` class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在源代码模型中重命名列，并将两个数据库列用于设置和获取操作。我们可以在`Calculation`类中进行更改：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To be 100% accurate, in the `getSum()` method, we should compare something like
    the last modification column date (not exactly necessary to always take the new
    column first).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了100%准确，在`getSum()`方法中，我们应该比较类似最后修改列日期的内容（不一定总是首先使用新列）。
- en: From now on, every time we add a row into the database, the same value is written
    to both the `result` and `sum` columns. While reading `sum`, we first check if
    it exists in the new column, and if not, we read it from the old column.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每当我们向数据库添加一行时，相同的值将被写入`result`和`sum`列。在读取`sum`时，我们首先检查它是否存在于新列中，如果不存在，则从旧列中读取。
- en: The same result can be achieved with the use of database triggers that would
    automatically write the same values into both columns.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用数据库触发器来实现相同的结果，触发器会自动将相同的值写入两列。
- en: All the changes we made so far were backwards-compatible, so we can roll back
    the service anytime we want, to any version we want.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的所有更改都是向后兼容的，因此我们可以随时回滚服务，到任何我们想要的版本。
- en: Merging the data in both columns
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并两个列中的数据
- en: 'This step is usually done after some time when the release is stable. We need
    to copy the data from the old `result` column into the new `sum` column. Let''s
    create a migration file called `V4__Copy_result_into_sum_column.sql`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步通常在发布稳定后的一段时间内完成。我们需要将旧的`result`列中的数据复制到新的`sum`列中。让我们创建一个名为`V4__Copy_result_into_sum_column.sql`的迁移文件：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We still have no limits for the rollback; however, if we need to deploy the
    version before the change in step 2, then this database migration needs to be
    repeated.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然没有回滚的限制；然而，如果我们需要部署在第2步之前的版本，那么这个数据库迁移需要重复执行。
- en: Removing the old column from the code
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从代码中删除旧列
- en: 'At this point, we already have all data in the new column, so we can start
    using it without the old column in the data model. In order to do this, we need
    to remove all code related to `result` in the `Calculation` class so that it would
    look as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经将所有数据存储在新列中，因此我们可以在数据模型中开始使用它，而不需要旧列。为了做到这一点，我们需要删除`Calculation`类中与`result`相关的所有代码，使其如下所示：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: After this operation, we no longer use the `result` column in the code. Note
    that this operation is only backwards-compatible up to step 2\. If we need to
    roll back to step 1, then we could lose the data stored after this step.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在此操作之后，我们不再在代码中使用`result`列。请注意，此操作仅向后兼容到第2步。如果我们需要回滚到第1步，那么我们可能会丢失此步骤之后存储的数据。
- en: Dropping the old column from the database
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从数据库中删除旧列
- en: The last step is to drop the old column from the database. This migration should
    be performed after the rollback period when we are sure we won't need to roll
    back before step 4.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是从数据库中删除旧列。这个迁移应该在回滚期之后执行，当我们确定在第4步之前不需要回滚时。
- en: The rollback period can be very long since we aren't using the column from the
    database anymore. This task can be treated as a cleanup task, so even though it's
    non-backwards-compatible, there is no associated risk.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再使用数据库中的列，回滚期可能会很长。这个任务可以被视为一个清理任务，因此即使它不向后兼容，也没有相关的风险。
- en: 'Let''s add the final migration, `V5__Drop_result_column.sql`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加最终的迁移，`V5__Drop_result_column.sql`：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After this step, we finally completed the column renaming procedure. Note that
    all we did was complicate the operation a little bit, in order to stretch it in
    time. This reduced the risk of backwards-incompatible database changes and allowed
    zero-downtime deployments.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步之后，我们终于完成了列重命名的过程。请注意，我们所做的一切只是稍微复杂了操作，以便将其延长。这减少了向后不兼容的数据库更改的风险，并允许零停机部署。
- en: Separating database updates from code changes
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据库更新与代码更改分开
- en: 'So far, in all figures, we presented that database migrations are run together
    with service releases. In other words, each commit (which implies each release)
    took both database changes and code changes. However, the recommended approach
    is to make a clear separation that a commit to the repository is either a database
    update or a code change. This method is presented in the following image:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在所有的图表中，我们都提到数据库迁移是与服务发布一起运行的。换句话说，每个提交（意味着每个发布）都包括数据库更改和代码更改。然而，推荐的方法是明确分离存储库的提交是数据库更新还是代码更改。这种方法在下图中呈现：
- en: '![](assets/af3ebd96-a96f-4565-84b6-f75ecd859d95.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/af3ebd96-a96f-4565-84b6-f75ecd859d95.png)'
- en: The benefit of database-service change separation is that we get the backwards-compatibility
    check for free. Imagine that the changes v11 and v1.2.7 concern one logical change,
    for example, adding a new column to the database. Then, we first commit database
    v11, so the tests in the Continuous Delivery pipeline check if database v11 works
    correctly with service v.1.2.6\. In other words, they check if database update
    v11 is backwards-compatible. Then, we commit the v1.2.7 change, so the pipeline
    checks if database v11 works fine with service v1.2.7.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库服务变更分离的好处是，我们可以免费获得向后兼容性检查。想象一下，更改v11和v1.2.7涉及到一个逻辑更改，例如，向数据库添加一个新列。然后，我们首先提交数据库v11，这样持续交付流水线中的测试就会检查数据库v11是否与服务v.1.2.6正常工作。换句话说，它们检查数据库更新v11是否向后兼容。然后，我们提交v1.2.7的更改，这样流水线就会检查数据库v11是否与服务v1.2.7正常工作。
- en: The database-code separation does not mean that we must have two separate Jenkins
    pipelines. The pipeline can always execute both, but we should keep it as a good
    practice that a commit is either a database update or a code change.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库-代码分离并不意味着我们必须有两个单独的Jenkins流水线。流水线可以始终同时执行，但我们应该将其作为一个良好的实践，即提交要么是数据库更新，要么是代码更改。
- en: To sum up, the database schema changes should be never done manually. Instead,
    we should always automate them using a migration tool, executed as a part of the
    Continuous Delivery pipeline. We should also avoid non-backwards-compatible database
    updates and the best way to assure this is to commit separately the database and
    code changes into the repository.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，数据库架构的更改不应该手动完成。相反，我们应该始终使用迁移工具自动化它们，作为持续交付流水线的一部分执行。我们还应该避免非向后兼容的数据库更新，确保这一点的最佳方法是将数据库和代码更改分别提交到存储库中。
- en: Avoiding shared database
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免共享数据库
- en: In many systems, we can spot that the database becomes the central point that
    is shared between multiple services. In such a case, any update to the database
    becomes much more challenging because we need to coordinate it between all services.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多系统中，我们可以发现数据库成为了多个服务之间共享的中心点。在这种情况下，对数据库的任何更新都变得更加具有挑战性，因为我们需要在所有服务之间进行协调。
- en: 'For example, imagine we develop an online shop and we have a Customers table
    that contains the following columns: first name, last name, username, password,
    email, and discount. There are three services that are interested in the customer''s
    data:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下我们开发了一个在线商店，我们有一个包含以下列的Customers表：名字，姓氏，用户名，密码，电子邮件和折扣。有三个服务对客户数据感兴趣：
- en: '**Profile manager**: This enables editing user''s data'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个人资料管理器**：这使得用户数据可以进行编辑'
- en: '**Checkout processor**: This processes the checkout (reads username and email)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结账处理器**：这个处理结账（读取用户名和电子邮件）'
- en: '**Discount manager**: This analyzes the customer''s orders and sets the suitable
    discount'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**折扣管理器**：这个分析客户的订单并设置合适的折扣'
- en: 'Let''s look at the following image that presents this situation:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下面的图片，展示了这种情况：
- en: '![](assets/794aa472-8c58-4b68-b172-8b85d838d1b8.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/794aa472-8c58-4b68-b172-8b85d838d1b8.png)'
- en: 'They are dependent on the same database schema. There are at least two issues
    with such an approach:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它们依赖于相同的数据库架构。这种方法至少存在两个问题：
- en: When we want to update the schema, it must be compatible with all three services.
    While all backwards-compatible changes are fine, any non-backwards-compatible
    update becomes way more difficult or even impossible.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要更新架构时，它必须与这三个服务兼容。虽然所有向后兼容的更改都没问题，但任何非向后兼容的更新都变得更加困难甚至不可能。
- en: Each service has a separate delivery cycle and a separate Continuous Delivery
    pipeline. Then, which pipeline should we use for the database schema migrations?
    Unfortunately, there is no good answer to this question.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务都有一个独立的交付周期和独立的持续交付管道。那么，我们应该使用哪个管道进行数据库架构迁移？不幸的是，对于这个问题没有一个好的答案。
- en: 'For the reasons mentioned previously, each service should have its own database
    and the services should communicate via their APIs. Following our example, we
    could apply the following refactoring:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 基于之前提到的原因，每个服务应该有自己的数据库，并且服务应该通过它们的API进行通信。根据我们的例子，我们可以应用以下的重构：
- en: The checkout processor should communicate with the profile manager's API to
    fetch the customer's data
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结账处理器应该与档案管理器的API通信，以获取客户的数据
- en: The discount column should be extracted to a separate database (or schema),
    and the discount manager should take the ownership
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折扣列应该被提取到一个单独的数据库（或架构）中，并且折扣管理器应该负责
- en: 'The refactored version is presented in the following image:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的版本如下图所示：
- en: '![](assets/58088d1d-5613-45b4-9ef1-978ac0372a8f.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/58088d1d-5613-45b4-9ef1-978ac0372a8f.png)'
- en: Such an approach is consistent with the principles of the microservice architecture
    and should always be applied. The communication over APIs is way more flexible
    than the direct database access.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与微服务架构的原则一致，应该始终被应用。通过API的通信比直接访问数据库更加灵活。
- en: In the case of monolithic systems, a database is usually the integration point.
    Since such an approach causes a lot of issues, it's considered as an anti-pattern.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体系统的情况下，数据库通常是集成点。由于这种方法会引起很多问题，被认为是一种反模式。
- en: Preparing test data
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备测试数据
- en: We have already presented database migrations that keep the database schema
    consistent between the environments as a side effect. This is due to the fact
    that if we run the same migration scripts on the development machine, in the staging
    environment, or in the production, then we would always get the result in the
    same schema. However, the data values inside the tables differ. How can we prepare
    the test data so that it would effectively test our system? This is the topic
    of this section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了保持数据库架构一致的数据库迁移，这是一个副作用。这是因为如果我们在开发机器上、在暂存环境中或者在生产环境中运行相同的迁移脚本，我们总是会得到相同的架构结果。然而，表内的数据值是不同的。我们如何准备测试数据，以有效地测试我们的系统？这就是本节的主题。
- en: The answer to this question depends on the type of the test, and it is different
    for unit testing, integration/acceptance testing, and performance testing. Let's
    examine each case.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案取决于测试的类型，对于单元测试、集成/验收测试和性能测试是不同的。让我们分别来看每种情况。
- en: Unit testing
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: In the case of unit testing, we don't use the real database. We either mock
    the test data on the level of the persistence mechanism (repositories, data access
    objects) or we fake the real database with an in-memory database (for example,
    H2 database). Since unit tests are created by developers, the exact data values
    are usually invented by developers and they don't matter much.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试的情况下，我们不使用真实的数据库。我们要么在持久化机制的层面（仓库、数据访问对象）模拟测试数据，要么用内存数据库（例如H2数据库）伪造真实的数据库。由于单元测试是由开发人员创建的，确切的数据值通常是由开发人员虚构的，而且并不重要。
- en: Integration/acceptance testing
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成/验收测试
- en: 'Integration and acceptance tests usually use the test/staging database, which
    should be as similar as possible to the production. One approach, taken by many
    companies, is to snapshot the production data into staging that guarantees that
    it is exactly the same. This approach, however, is treated as an anti-pattern
    for the following reasons:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 集成和验收测试通常使用测试/暂存数据库，该数据库应尽可能与生产环境相似。许多公司采取的一种方法是将生产数据快照到暂存，以确保两者完全相同。然而，出于以下原因，这种方法被视为反模式：
- en: '**Test isolation**: Each test operates on the same database, so the result
    of one test may influence the input of the others'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试隔离**：每个测试都在同一个数据库上操作，因此一个测试的结果可能会影响其他测试的输入'
- en: '**Data security**: Production instances usually store sensitive information
    and are therefore better secured'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据安全性**：生产实例通常存储敏感信息，因此更容易得到保护。'
- en: '**Reproducibility**: After every snapshot, the test data is different, which
    may result in flaky tests'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重现性**：每次快照后，测试数据都是不同的，这可能导致测试不稳定'
- en: For the preceding reasons, the preferred approach is to manually prepare the
    test data by selecting a subset of the production data, together with the customer
    or the business analyst. When the production database grows, it's worth revisiting
    its content to see if there are any reasonable cases that should be added.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 基于上述原因，首选的方法是通过与客户或业务分析师一起手动准备测试数据，选择生产数据的子集。当生产数据库增长时，值得重新审视其内容，看是否有任何应该添加的合理情况。
- en: The best way to add data to the staging database is to use the public API of
    a service. This approach is consistent with acceptance tests, which are usually
    black-box. What's more, using the API guarantees that the data itself is consistent
    and simplifies database refactoring by limiting direct database operations.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据添加到暂存数据库的最佳方法是使用服务的公共API。这种方法与通常是黑盒的验收测试一致。而且，使用API可以保证数据本身的一致性，并通过限制直接数据库操作简化数据库重构。
- en: Performance testing
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测试
- en: Test data for the performance testing is usually similar to acceptance testing.
    One significant difference is the amount of data. In order to test the performance
    correctly, we need to provide sufficient volume of input data, at least as large
    as available on the production (during the peak time). For this purpose, we can
    create data generators, which are usually shared between acceptance and performance
    tests.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试的测试数据通常类似于验收测试。一个重要的区别是数据量。为了正确测试性能，我们需要提供足够数量的输入数据，至少与生产环境（在高峰时段）的数据量一样大。为此，我们可以创建数据生成器，通常在验收和性能测试之间共享。
- en: Pipeline patterns
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道模式
- en: We already know everything that is necessary to start a project and set up the
    Continuous Delivery pipeline with Jenkins and Docker. This section is intended
    to extend this knowledge with a few of the recommended general Jenkins pipeline
    practices.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道启动项目并使用Jenkins和Docker设置持续交付管道所需的一切。本节旨在通过一些推荐的Jenkins管道实践来扩展这些知识。
- en: Parallelizing pipelines
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行化管道
- en: Throughout this book, we have always executed the pipeline sequentially, stage
    by stage, step by step. This approach makes it easy to reason the state and the
    result of the build. If there is first the acceptance test stage and then the
    release stage, it means that the release won't ever happen until the acceptance
    tests are successful. Sequential pipelines are simple to understand and usually
    do not cause any surprises. This is why the first method to solve any problem
    is to do it sequentially.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们总是按顺序执行流水线，一步一步地进行。这种方法使得很容易理清构建的状态和结果。如果首先是验收测试阶段，然后是发布阶段，这意味着在验收测试成功之前，发布永远不会发生。顺序流水线易于理解，通常不会引起任何意外。这就是为什么解决任何问题的第一种方法是按顺序进行。
- en: 'However, in some cases, the stages are time-consuming and it''s worth running
    them in parallel. A very good example is performance tests. They usually take
    a lot of time, so assuming they are independent and isolated, it makes sense to
    run them in parallel. In Jenkins, we can parallelize the pipeline on two different
    levels:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，阶段是耗时的，值得并行运行它们。一个很好的例子是性能测试。它们通常需要很长时间，因此假设它们是独立和隔离的，将它们并行运行是有意义的。在Jenkins中，我们可以在两个不同的级别上并行化流水线：
- en: '**Parallel steps**: Within one stage, parallel processes run on the same agent.
    This method is simple because all Jenkins workspace-related files are located
    on one physical machine, however, as always with the vertical scaling, the resources
    are limited to that single machine.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行步骤**：在一个阶段内，并行进程在同一代理上运行。这种方法很简单，因为所有与Jenkins工作区相关的文件都位于一台物理机器上，但是，与垂直扩展一样，资源仅限于该单一机器。'
- en: '**Parallel stages**: Each stage can be run in parallel on a separate agent
    machine that provides horizontal scaling of resources. We need to take care of
    the file transfer between the environments (using the `stash` Jenkinsfile keyword)
    if a file created in the previous stage is needed on the other physical machine.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行阶段**：每个阶段可以在提供资源水平扩展的单独代理机器上并行运行。如果需要在另一台物理机器上使用前一阶段创建的文件，我们需要注意环境之间的文件传输（使用`stash`
    Jenkinsfile关键字）。'
- en: By the time of writing this book, parallel stages are not available in the declarative
    pipeline. The feature is supposed to be added in Jenkins Blue Ocean v1.3\. In
    the meantime, the only possibility is to use the deprecated feature in the Groovy-based
    scripting pipeline, as described here at [https://jenkins.io/doc/book/pipeline/jenkinsfile/#executing-in-parallel](https://jenkins.io/doc/book/pipeline/jenkinsfile/#executing-in-parallel).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，声明性流水线中并行阶段是不可用的。该功能应该在Jenkins Blue Ocean v1.3中添加。与此同时，唯一的可能性是使用基于Groovy的脚本流水线中的弃用功能，如此处所述：[https://jenkins.io/doc/book/pipeline/jenkinsfile/#executing-in-parallel](https://jenkins.io/doc/book/pipeline/jenkinsfile/#executing-in-parallel)。
- en: 'Let''s look at how it looks in practice. If we would like to run two steps
    in parallel, the Jenkinsfile script should look as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际操作中是什么样子。如果我们想要并行运行两个步骤，Jenkinsfile脚本应该如下所示：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `Stage 1`, with the use of the `parallel` keyword, we execute two parallel
    steps, `one` and `two`. Note that `Stage 2` is executed only after both parallel
    steps are completed. This is why such solutions are perfectly safe to run tests
    in parallel; we can always be sure that the deployment stage is run only after
    all parallelized tests have already passed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`阶段1`中，使用`parallel`关键字，我们执行两个并行步骤，`one`和`two`。请注意，只有在两个并行步骤都完成后，才会执行`阶段2`。这就是为什么这样的解决方案非常安全地并行运行测试；我们始终可以确保只有在所有并行测试都已通过后，才会运行部署阶段。
- en: There is a very useful plugin called `Parallel Test Executor` that helps to
    automatically split tests and run them in parallel. Read more at [https://jenkins.io/doc/pipeline/steps/parallel-test-executor/](https://jenkins.io/doc/pipeline/steps/parallel-test-executor/).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常有用的插件叫做`并行测试执行器`，它可以帮助自动拆分测试并并行运行它们。在[https://jenkins.io/doc/pipeline/steps/parallel-test-executor/](https://jenkins.io/doc/pipeline/steps/parallel-test-executor/)上阅读更多。
- en: 'The preceding description concerned the parallel steps level. The other solution
    would be to use parallel stages and therefore run each stage on a separate agent
    machine. The decision on which type of parallelism to use usually depends on two
    factors:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的描述涉及到并行步骤级别。另一个解决方案是使用并行阶段，因此在单独的代理机器上运行每个阶段。选择使用哪种类型的并行通常取决于两个因素：
- en: How powerful the agent machines are
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理机器的强大程度
- en: How much time the given stage takes
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定阶段需要多少时间
- en: As a general recommendation, unit tests are fine to run in parallel steps, but
    performance tests are usually better off on separate machines.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般建议，单元测试可以并行运行，但性能测试通常最好在单独的机器上运行。
- en: Reusing pipeline components
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重用管道组件
- en: When the Jenkinsfile script grows in size and becomes more complex, we may want
    to reuse its parts between similar pipelines.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当Jenkinsfile脚本变得越来越复杂时，我们可能希望在相似的管道之间重用其部分。
- en: For example, we may want to have separate, but similar, pipelines for different
    environments (dev, QA, prod). Another common example in the microservice world
    is that each service has a very similar Jenkinsfile. Then, how do we write Jenkinsfile
    scripts so that we don't repeat the same code all over again? There are two good
    patterns for this purpose, parameterized build and shared libraries. Let's describe
    them one by one.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能希望为不同的环境（开发、QA、生产）拥有单独但相似的管道。在微服务领域的另一个常见例子是，每个服务都有一个非常相似的Jenkinsfile。那么，我们如何编写Jenkinsfile脚本，以便不重复编写相同的代码？为此有两种好的模式，参数化构建和共享库。让我们逐一描述它们。
- en: Build parameters
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建参数
- en: 'We already mentioned in [Chapter 4](a07d252d-3812-45ad-a567-1c70dae74d9d.xhtml),
    *Continuous Integration Pipeline*, that a pipeline can have input parameters.
    We can use them to provide different use cases with the same pipeline code. As
    an example, let''s create a pipeline parametrized with the environment type:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第4章](a07d252d-3812-45ad-a567-1c70dae74d9d.xhtml)中提到，*持续集成管道*，管道可以有输入参数。我们可以使用它们来为相同的管道代码提供不同的用例。例如，让我们创建一个带有环境类型参数的管道：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The build takes one input parameter, `Environment`. Then, all we do in this
    step is print the parameter. We can also add a condition to execute different
    code for different environments.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 构建需要一个输入参数，`环境`。然后，在这一步中，我们所做的就是打印参数。我们还可以添加一个条件，以执行不同环境的不同代码。
- en: 'With this configuration, when we start the build, we will see a prompt for
    the input parameter, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，当我们开始构建时，我们将看到一个输入参数的提示，如下所示：
- en: '![](assets/d84f40b8-8d26-4581-b262-a063d3a1d1f5.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d84f40b8-8d26-4581-b262-a063d3a1d1f5.png)'
- en: Parametrized build can help reuse the pipeline code for scenarios when it differs
    just a little bit. This feature, however, should not be overused because too many
    conditions can make the Jenkinsfile difficult to understand.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化构建可以帮助重用管道代码，适用于只有少许不同的情况。然而，不应该过度使用这个功能，因为太多的条件会使Jenkinsfile难以理解。
- en: Shared libraries
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享库
- en: The other solution to reuse the pipeline is to extract its parts into a shared
    library.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 重用管道的另一个解决方案是将其部分提取到共享库中。
- en: 'A shared library is a Groovy code that is stored as a separate source-controlled
    project. This code can be later used in many Jenkinsfile scripts as pipeline steps.
    To make it clear, let''s have a look at an example. A shared library technique
    always requires three steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库是作为单独的源代码控制项目存储的Groovy代码。此代码可以稍后用作许多Jenkinsfile脚本的管道步骤。为了明确起见，让我们看一个例子。共享库技术始终需要三个步骤：
- en: Create a shared library project.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个共享库项目。
- en: Configure the shared library in Jenkins.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Jenkins中配置共享库。
- en: Use the shared library in Jenkins file.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Jenkins文件中使用共享库。
- en: Creating a shared library project
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个共享库项目
- en: We start by creating a new Git project, in which we put the shared library code.
    Each Jenkins step is expressed as a Groovy file located in the `vars` directory.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的Git项目，在其中放置共享库代码。每个Jenkins步骤都表示为位于`vars`目录中的Groovy文件。
- en: 'Let''s create a `sayHello` step that takes the `name` parameter and echoes
    a simple message. This should be stored in the `vars/sayHello.groovy` file:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`sayHello`步骤，它接受`name`参数并回显一个简单的消息。这应该存储在`vars/sayHello.groovy`文件中：
- en: '[PRE19]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Human-readable descriptions for shared library steps can be stored in the `*.txt`
    files. In our example, we could add the `vars/sayHello.txt` file with the step
    documentation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库步骤的可读性描述可以存储在`*.txt`文件中。在我们的例子中，我们可以添加带有步骤文档的`vars/sayHello.txt`文件。
- en: When the library code is done, we need to push it to the repository, for example,
    as a new GitHub project.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当库代码完成时，我们需要将其推送到存储库，例如，作为一个新的GitHub项目。
- en: Configure the shared library in Jenkins
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jenkins中配置共享库
- en: 'The next step is to register the shared library in Jenkins. We open Manage
    Jenkins | Configure System, and find the Global Pipeline Libraries section. There,
    we can add the library giving it a name chosen, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在Jenkins中注册共享库。我们打开“管理Jenkins | 配置系统”，找到全局管道库部分。在那里，我们可以添加一个选择的名称的库，如下所示：
- en: '![](assets/d0fac181-7915-4db7-b4c3-5776e527e325.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d0fac181-7915-4db7-b4c3-5776e527e325.png)'
- en: We specified the name under which the library is registered and the library
    repository address. Note that the latest version of the library will be automatically
    downloaded during the pipeline build.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了库注册的名称和库存储库地址。请注意，库的最新版本将在管道构建期间自动下载。
- en: We presented importing the Groovy code as *Global Shared Library*, but there
    are also other alternative solutions. Read more at [https://jenkins.io/doc/book/pipeline/shared-libraries/](https://jenkins.io/doc/book/pipeline/shared-libraries/).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了将Groovy代码导入为*全局共享库*，但也有其他替代解决方案。更多信息请阅读[https://jenkins.io/doc/book/pipeline/shared-libraries/](https://jenkins.io/doc/book/pipeline/shared-libraries/)。
- en: Use shared library in Jenkinsfile
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Jenkinsfile中使用共享库
- en: Finally, we can use the shared library in the Jenkinsfile script.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在Jenkinsfile脚本中使用共享库。
- en: 'Let''s have a look at the example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE20]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If "Load implicitly" hadn't been checked in the Jenkins configuration, then
    we would need to add "`@Library('example') _`" at the beginning of the Jenkinsfile
    script.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Jenkins配置中没有选中“隐式加载”，那么我们需要在Jenkinsfile脚本的开头添加"`@Library('example') _`"。
- en: As you can see, we can use the Groovy code as a pipeline step `sayHello`. Obviously,
    after the pipeline build completes, in the console output, we should see `Hello
    Rafal!`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们可以使用Groovy代码作为管道步骤`sayHello`。显然，在管道构建完成后，在控制台输出中，我们应该看到`Hello Rafal!`。
- en: Shared libraries are not limited to one step. Actually, with the power of the
    Groovy language, they can even act as templates for entire Jenkins pipelines.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 共享库不限于一个步骤。实际上，借助Groovy语言的强大功能，它们甚至可以作为整个Jenkins管道的模板。
- en: Rolling back deployments
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回滚部署
- en: I remember the words of my colleague, a senior architect, <q>You don't need
    more QAs, you need a faster rollback</q>. While this statement is oversimplified
    and the QA team is often of great value, there is a lot of truth in this sentence.
    Think about it; if you introduce a bug in the production but roll it back soon
    after the first user reports an error, then usually nothing bad happens. On the
    other hand, if production errors are rare but no rollback is applied, then the
    process to debug the production usually ends up in long sleepless nights and a
    number of dissatisfied users. This is why we need to think about the rollback
    strategy up front while creating the Jenkins pipeline.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得我的一位资深架构师同事说过：“你不需要更多的质量保证人员，你需要更快的回滚。”尽管这种说法过于简化，而且质量保证团队通常是非常有价值的，但这句话中有很多真理。想想看；如果你在生产环境引入了一个bug，但在第一个用户报告错误后很快回滚，通常不会发生什么坏事。另一方面，如果生产错误很少，但没有进行回滚，那么通常会导致在长时间的失眠夜晚和一些不满意的用户中调试生产过程。这就是为什么我们在创建Jenkins流水线时需要事先考虑回滚策略。
- en: 'In the context of Continuous Delivery, there are two moments when the failure
    can happen:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续交付的背景下，有两个可能发生失败的时刻：
- en: During the release process, in the pipeline execution
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发布过程中，在流水线执行中
- en: After the pipeline build is completed, in production
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流水线构建完成后，在生产环境中
- en: The first scenario is pretty simple and harmless. It concerns a case when the
    application is already deployed to production but the next stage fails, for example,
    the smoke test. Then, all we need to do is execute a script in the `post` pipeline
    section for the `failure` case, which downgrades the production service to the
    older Docker image version. If we use blue-green deployment (as described later
    in this chapter), the risk of any downtime is minimal since we usually execute
    the load-balancer switch as the last pipeline stage, after the smoke test.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况非常简单且无害。它涉及到应用程序已经部署到生产环境，但接下来的阶段失败，例如，冒烟测试失败。那么，我们需要做的就是在“失败”情况的“后”流水线部分执行一个脚本，将生产服务降级到较旧的Docker镜像版本。如果我们使用蓝绿部署（如本章后面描述的），那么任何停机时间的风险都是最小的，因为通常我们会在冒烟测试之后的最后一个流水线阶段执行负载均衡器切换。
- en: The second scenario, when we notice a production bug after the pipeline is successfully
    completed, is more difficult and requires a few comments. Here, the rule is that
    we should always release the rolled back service using exactly the same process
    as the standard release. Otherwise, if we try to do something manually, in a faster
    way, we are asking for trouble. Any nonrepetitive task is risky, especially under
    stress, when the production is out of order.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是，当我们在成功完成流水线后注意到生产bug时，情况更加困难，需要一些评论。在这种情况下，规则是我们应该始终使用与标准发布完全相同的流程来发布回滚的服务。否则，如果我们尝试以更快的方式手动操作，那么我们就是在自找麻烦。任何非重复性的任务都是有风险的，尤其是在压力下，当生产环境处于无序状态时。
- en: As a side note, if the pipeline completes successfully but there is a production
    bug, then it means that our tests are not good enough. So, the first thing after
    rollback is to extend the unit/acceptance test suites with the corresponding scenarios.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果流水线顺利完成但出现了生产bug，那么这意味着我们的测试还不够好。因此，在回滚之后的第一件事是扩展单元/验收测试套件，以涵盖相应的场景。
- en: The most common Continuous Delivery process is one fully automated pipeline
    that starts by checking out the code and ends up with release to the production.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的持续交付流程是一个完全自动化的流水线，从检出代码开始，以发布到生产结束。
- en: 'The following figure presents how this works:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了这是如何工作的：
- en: '![](assets/338a8478-71c8-40cb-9b94-ec25d9d5e0b8.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/338a8478-71c8-40cb-9b94-ec25d9d5e0b8.png)'
- en: We already presented the classic Continuous Delivery pipeline throughout this
    book. If the rollback should use exactly the same process, then all we need to
    do is revert the latest code change from the repository. As a result, the pipeline
    automatically builds, tests, and finally, releases the right version.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经介绍了经典的持续交付管道。如果回滚应该使用完全相同的流程，那么我们需要做的就是从存储库中恢复最新的代码更改。结果，管道会自动构建、测试，最后发布正确的版本。
- en: Repository reverts and emergency fixes should never skip the testing stages
    in the pipeline. Otherwise, we may end up with a release that is still not working
    correctly because of another issue that makes debugging even harder.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库回滚和紧急修复不应跳过管道中的测试阶段。否则，我们可能会因为其他问题导致发布仍然无法正常工作，使得调试变得更加困难。
- en: The solution is very simple and elegant. The only drawback is the downtime that
    we need to spend on the complete pipeline build. This downtime can be avoided
    if we use blue-green deployment or canary releases, in which cases, we only change
    the load balancer setting to address the healthy environment.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案非常简单而优雅。唯一的缺点是我们需要花费时间在完整的管道构建上。如果使用蓝绿部署或金丝雀发布，可以避免这种停机时间，在这种情况下，我们只需更改负载均衡器设置以解决健康环境。
- en: The rollback operation becomes way more complex in the case of orchestrated
    releases, during which many services are deployed at the same time. This is one
    of the reasons why orchestrated releases are treated as an anti-pattern, especially
    in the microservice world. The correct approach is to always maintain backwards
    compatibility, at least for some time (like we presented for the database at the
    beginning of this chapter). Then, it's possible to release each service independently.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在编排发布的情况下，回滚操作变得更加复杂，因为在此期间许多服务同时部署。这是编排发布被视为反模式的原因之一，特别是在微服务世界中。正确的方法是始终保持向后兼容，至少在一段时间内（就像我们在本章开头为数据库所介绍的那样）。然后，可以独立发布每个服务。
- en: Adding manual steps
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加手动步骤
- en: In general, the Continuous Delivery pipelines should be fully automated, triggered
    by a commit to the repository, and end up after the release. Sometimes, however,
    we can't avoid having manual steps. The most common example is the release approval,
    which means that the process is fully automated, but there is a manual step to
    approve the new release. Another common example is manual tests. Some of them
    may exist because we operate on the legacy system; some others may occur when
    a test simply cannot be automated. No matter what the reason is, sometimes there
    is no choice but to add a manual step.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，持续交付管道应该是完全自动化的，由对存储库的提交触发，并在发布后结束。然而，有时我们无法避免出现手动步骤。最常见的例子是发布批准，这意味着流程是完全自动化的，但有一个手动步骤来批准新发布。另一个常见的例子是手动测试。其中一些可能是因为我们在传统系统上操作；另一些可能是因为某些测试根本无法自动化。无论原因是什么，有时除了添加手动步骤别无选择。
- en: 'Jenkins syntax offers a keyword `input` for manual steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins语法提供了一个关键字“input”用于手动步骤：
- en: '[PRE21]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The pipeline will stop execution on the `input` step and wait until it's manually
    approved.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 管道将在“输入”步骤上停止执行，并等待手动批准。
- en: Remember that manual steps quickly become a bottleneck in the delivery process,
    and this is why they should always be treated as a solution that's inferior to
    complete automation.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，手动步骤很快就会成为交付过程中的瓶颈，这就是为什么它们应该始终被视为次于完全自动化的解决方案的原因。
- en: It is sometimes useful to set a timeout for the input in order to avoid waiting
    forever for the manual interaction. After the configured time is elapsed, the
    whole pipeline is aborted.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有时设置输入的超时时间是有用的，以避免无限等待手动交互。在配置的时间过去后，整个管道将被中止。
- en: Release patterns
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布模式
- en: In the last section, we discussed the Jenkins pipeline patterns used to speed
    up the build execution (parallel steps), help with the code reuse (shared libraries),
    limit the risk of production bugs (rollback), and deal with manual approvals (manual
    steps). This section presents the next group of patterns, this time related to
    the release process. They are designed to reduce the risk of updating the production
    to a new software version.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了用于加快构建执行（并行步骤）、帮助代码重用（共享库）、限制生产错误风险（回滚）和处理手动批准（手动步骤）的Jenkins流水线模式。本节介绍了下一组模式，这次与发布过程有关。它们旨在减少将生产环境更新到新软件版本的风险。
- en: 'We already described one of the release patterns, rolling updates, in [Chapter
    8](05fbbfd9-ff58-4ee8-be5d-90cb291f6320.xhtml), *Clustering with Docker Swarm*.
    Here, we present two more: blue-green deployment and canary releases.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在《使用Docker Swarm进行集群化》的[第8章](05fbbfd9-ff58-4ee8-be5d-90cb291f6320.xhtml)中描述了一个发布模式，即滚动更新。在这里，我们介绍另外两种：蓝绿部署和金丝雀发布。
- en: Blue-green deployment
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: 'Blue-green deployment is a technique to reduce the downtime associated with
    the release. It concerns having two identical production environments, one called
    green, the other called blue, as presented in the following figure:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署是一种减少发布相关停机时间的技术。它涉及拥有两个相同的生产环境，一个称为绿色，另一个称为蓝色，如下图所示：
- en: '![](assets/4d853c46-e422-49e2-8c86-ab0a6bb780fa.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4d853c46-e422-49e2-8c86-ab0a6bb780fa.png)'
- en: In the figure, the currently accessible environment is blue. If we want to make
    a new release, then we deploy everything to the green environment and, at the
    end of the release process, change the load balancer to the green environment.
    As a result, a user, all of a sudden, starts using the new version. The next time
    we want to make a release, we make changes to the blue environment and, at the
    end, we change the load balancer to blue. We proceed the same every time, switching
    from one environment to another.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，当前可访问的环境是蓝色的。如果我们想进行新的发布，那么我们将所有内容部署到绿色环境，并在发布过程结束时将负载均衡器切换到绿色环境。结果，用户突然开始使用新版本。下次我们想进行发布时，我们对蓝色环境进行更改，并在最后将负载均衡器切换到蓝色。每次都是这样进行，从一个环境切换到另一个环境。
- en: 'The blue-green deployment technique works correctly with two assumptions: environment
    isolation and no orchestrated releases.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝绿部署技术在两个假设条件下能够正常工作：环境隔离和无编排发布。
- en: 'This solution gives two significant benefits:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案带来了两个重要的好处：
- en: '**Zero downtime**: All the downtime from the user perspective is a moment of
    changing the load balance switch, which is negligible'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零停机时间**：从用户角度来看，所有停机时间都是可以忽略不计的负载平衡切换时刻'
- en: '**Rollback**: In order to roll back one version, it''s enough to change back
    the load balance switch blue-green deployment include:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚**：为了回滚一个版本，只需将负载平衡切换回蓝绿部署包括：'
- en: '**Database**: Schema migrations can be tricky in case of a rollback, so it''s
    worth using the patterns presented at the beginning of this chapter'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：模式迁移在回滚时可能会很棘手，因此值得使用本章开头介绍的模式。'
- en: '**Transactions**: Running database transactions must be handed over to the
    new database'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务**：运行数据库事务必须移交给新数据库'
- en: '**Redundant infrastructure/resources**: We need to have double the resources'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冗余基础设施/资源**：我们需要双倍的资源'
- en: There are techniques and tools to overcome these challenges, so the blue-green
    deployment pattern is highly recommended and widely used in the IT industry.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有技术和工具可以克服这些挑战，因此蓝绿部署模式在IT行业中被高度推荐和广泛使用。
- en: You can read more about the blue-green deployment technique on the excellent
    Martin Fowler's blog [https://martinfowler.com/bliki/BlueGreenDeployment.html](https://martinfowler.com/bliki/BlueGreenDeployment.html).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在优秀的Martin Fowler博客[https://martinfowler.com/bliki/BlueGreenDeployment.html](https://martinfowler.com/bliki/BlueGreenDeployment.html)中阅读有关蓝绿部署技术的更多信息。
- en: Canary release
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 金丝雀发布
- en: 'Canary releasing is a technique to reduce the risk associated with introducing
    a new version of the software. Similar to blue-green deployment, it uses two identical
    environments, as presented in the following figure:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀发布是一种减少引入新软件版本风险的技术。与蓝绿部署类似，它使用两个相同的环境，如下图所示：
- en: '![](assets/14406026-be79-4f9a-bd10-c3c7ede552fc.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/14406026-be79-4f9a-bd10-c3c7ede552fc.png)'
- en: Also, similar to the blue-green deployment technique, the release process starts
    by deploying a new version in the environment that is currently unused. Here,
    however, the similarities end. The load balancer, instead of switching to the
    new environment, is set to link only a selected group of users to the new environment.
    All the rest still use the old version. This way, a new version can be tested
    by some users and in case of a bug, only a small group is affected. After the
    testing period, all users are switched to the new version.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 与蓝绿部署技术类似，发布过程始于在当前未使用的环境中部署新版本。然而，相似之处到此为止。负载均衡器不是切换到新环境，而是仅将选定的用户组链接到新环境。其余所有用户仍然使用旧版本。这样，一些用户可以测试新版本，如果出现错误，只有一小部分用户受到影响。测试期结束后，所有用户都切换到新版本。
- en: 'This approach has some great benefits:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有一些很大的好处：
- en: '**Acceptance and performance testing**: If the acceptance and performance testing
    is difficult to run in the staging environment, then it''s possible to test it
    in production, minimizing the impact on a small group of users.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收和性能测试：如果在暂存环境中难以进行验收和性能测试，那么可以在生产环境中进行测试，最大程度地减少对一小群用户的影响。
- en: '**Simple rollback**: If a new change causes a failure, then rolling back is
    done by switching back all users to the old version.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单回滚：如果新更改导致失败，那么通过将所有用户切换回旧版本来进行回滚。
- en: '**A/B testing**: If we are not sure whether the new version is better than
    the UX or the performance perspective, then it''s possible to compare it with
    the old version.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A/B测试：如果我们不确定新版本在UX或性能方面是否比旧版本更好，那么可以将其与旧版本进行比较。
- en: Canary releasing shares the same drawbacks as blue-green deployment. The additional
    challenge is that we have two production systems running at the same time. Nevertheless,
    canary releasing is an excellent technique used in most companies to help with
    the release and testing.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀发布与蓝绿部署具有相同的缺点。额外的挑战是我们同时运行两个生产系统。尽管如此，金丝雀发布是大多数公司用来帮助发布和测试的一种优秀技术。
- en: You can read more about the canary releasing technique on the excellent Martin
    Fowler's blog [https://martinfowler.com/bliki/CanaryRelease.html](https://martinfowler.com/bliki/CanaryRelease.html).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在优秀的Martin Fowler博客[https://martinfowler.com/bliki/CanaryRelease.html](https://martinfowler.com/bliki/CanaryRelease.html)中阅读有关金丝雀发布技术的更多信息。
- en: Working with legacy systems
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与遗留系统一起工作
- en: All we have described so far applies smoothly to greenfield projects, for which
    setting up a Continuous Delivery pipeline is relatively simple.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所描述的一切都顺利适用于全新项目，为这些项目设置持续交付流水线相对简单。
- en: Legacy systems are, however, way more challenging because they usually depend
    on manual tests and manual deployment steps. In this section, we will walk through
    the recommended scenario to incrementally apply Continuous Delivery to a legacy
    system.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，遗留系统要困难得多，因为它们通常依赖于手动测试和手动部署步骤。在本节中，我们将逐步介绍将持续交付应用于遗留系统的推荐方案。
- en: As a step zero, I recommend reading an excellent book by Michael Feathers, *Working
    Effectively with Legacy Code*. His ideas on how to deal with testing, refactoring,
    and adding new features clear most of the concerns about how to automate the delivery
    process for legacy systems.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第零步，我建议阅读Michael Feathers的一本优秀书籍*Working Effectively with Legacy Code*。他关于如何处理测试、重构和添加新功能的想法清楚地解决了如何为传统系统自动化交付流程的大部分问题。
- en: For many developers, it may be tempting to completely rewrite a legacy system,
    rather than refactor it. While the idea is interesting from a developer's perspective,
    it is usually a bad business decision that results in product failure. You can
    read more about the history of rewriting the Netscape browser in an excellent
    blog post by Joel Spolsky, *Things You Should Never Do,* at [https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多开发人员来说，完全重写传统系统可能比重构更具诱惑力。虽然这个想法从开发人员的角度来看很有趣，但通常这是一个导致产品失败的不良商业决策。您可以在Joel
    Spolsky的博客文章*Things You Should Never Do*中阅读更多关于重写Netscape浏览器的历史，网址为[https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i](https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i)。
- en: 'The way to apply the Continuous Delivery process depends a lot on the current
    project''s automation, the technologies used, the hardware infrastructure, and
    the current release process. Usually, it can be split into three steps:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 应用持续交付流程的方式在很大程度上取决于当前项目的自动化、使用的技术、硬件基础设施和当前发布流程。通常，它可以分为三个步骤：
- en: Automating build and deployment.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动化构建和部署。
- en: Automating tests.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动化测试。
- en: Refactoring and introducing new features.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构和引入新功能。
- en: Let's look at them in detail.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看一下。
- en: Automating build and deployment
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化构建和部署
- en: The first step includes automating the deployment process. The good news is
    that in most legacy systems I have worked with, there was already some automation
    in place, for example, in the form of shell scripts.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步包括自动化部署过程。好消息是，在我所使用的大多数传统系统中，已经存在一些自动化，例如以shell脚本的形式。
- en: 'In any case, the activities for automated deployment includes the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，自动化部署的活动包括以下内容：
- en: '**Build and package**: Some automation usually already exists in the form of
    Makefile, Ant, Maven, any other build tool configuration, or a custom script.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建和打包**：通常已经存在一些自动化，例如Makefile、Ant、Maven、任何其他构建工具配置或自定义脚本。'
- en: '**Database migration**: We need to start managing the database schema in an
    incremental manner. It requires putting the current schema as an initial migration
    and making all the further changes with tools such as Flyway or Liquibase, as
    already described in this chapter.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库迁移**：我们需要以增量方式开始管理数据库架构。这需要将当前架构作为初始迁移，并使用Flyway或Liquibase等工具进行所有进一步的更改，如本章中已经描述的。'
- en: '**Deployment**: Even if the deployment process is fully manual, then there
    is usually a text/wiki page description that needs to be converted into an automated
    script.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：即使部署过程完全手动，通常也有一个需要转换为自动化脚本的文本/维基页面描述。'
- en: '**Repeatable configuration**: In legacy systems, configuration files are usually
    changed manually. We need to extract the configuration and use a configuration
    management tool, as described in [Chapter 6](75a4971b-4eb7-45cb-a3ac-81a7d5ca79b2.xhtml),
    *Configuration Management with Ansible*.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重复配置**：在传统系统中，配置文件通常是手动更改的。我们需要提取配置并使用配置管理工具，如[第6章](75a4971b-4eb7-45cb-a3ac-81a7d5ca79b2.xhtml)中描述的Ansible配置管理。'
- en: After the preceding steps, we can put everything into a deployment pipeline
    and use it as an automated phase after a manual UAT (user acceptance testing)
    cycle.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤之后，我们可以将所有内容放入部署流水线，并将其用作手动UAT（用户验收测试）周期后的自动化阶段。
- en: From the process perspective, it's worth already starting releasing more often.
    For example, if the release is yearly, try to do it quarterly, then monthly. The
    push for that factor will later result in faster-automated delivery adoption.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 从流程的角度来看，已经值得开始更频繁地发布。例如，如果发布是每年一次，尝试将其改为每季度一次，然后每月一次。对这一因素的推动将最终导致更快的自动化交付采用。
- en: Automating tests
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化测试
- en: 'The next step, usually much more difficult, is to prepare the automated tests
    for the system. It requires communicating with the QA team in order to understand
    how they currently test the software so that we can move everything into an automated
    acceptance test suite. This phase requires two steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，通常更加困难，是为系统准备自动化测试。这需要与QA团队沟通，以了解他们目前如何测试软件，以便我们可以将所有内容移入自动验收测试套件。这个阶段需要两个步骤：
- en: '**Acceptance/sanity test suite**: We need to add automated tests that replace
    some of the regression activities of the QA team. Depending on the system, they
    can be provided as a black-box Selenium test or Cucumber test.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收/理智测试套件**：我们需要添加自动化测试，以取代QA团队的一些回归活动。根据系统的不同，它们可以作为黑盒Selenium测试或Cucumber测试提供。'
- en: '**(Virtual) test environments**: At this point, we should be already thinking
    of the environments in which our tests would be run. Usually, the best solution
    to save resources and limit the number of machines required is to virtualize the
    testing environment using Vagrant or Docker.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （虚拟）测试环境：此时，我们应该已经考虑到我们的测试将在哪些环境中运行。通常，为了节省资源并限制所需机器的数量，最好的解决方案是使用Vagrant或Docker虚拟化测试环境。
- en: The ultimate goal is to have an automated acceptance test suite that will replace
    the whole UAT phase from the development cycle. Nevertheless, we can start with
    a sanity test that will shortly check if the system is correct from the regression
    perspective.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最终目标是拥有一个自动化验收测试套件，它将取代开发周期中的整个UAT阶段。然而，我们可以从一个理智的测试开始，它将简要检查系统是否从回归的角度正确。
- en: While adding test scenarios, remember that the test suite should execute in
    reasonable time. For sanity tests, it is usually less than 10 minutes.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加测试场景时，请记住测试套件应该在合理的时间内执行。对于理智测试，通常不到10分钟。
- en: Refactoring and introducing new features
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构和引入新功能
- en: When we have at least the fundamental regression testing suite, we are ready
    to add new features and refactor the old code. It's always better to do it in
    small pieces, step by step because refactoring everything at once usually ends
    up in a chaos that leads to production failures (not clearly related to any particular
    change).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们至少拥有了基本的回归测试套件时，我们就可以开始添加新功能并重构旧代码。最好一步一步地进行，因为一次性重构通常会导致混乱，从而导致生产故障（与任何特定更改都没有明显关系）。
- en: 'This phase usually includes the following activities:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段通常包括以下活动：
- en: '**Refactoring**: The best place to start refactoring the old code is where
    the new features are expected. Starting this way, we are prepared for the new
    feature requests to come.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构**：重构旧代码的最佳地方是新功能预期的地方。以这种方式开始，我们就为新的功能请求做好了准备。'
- en: '**Rewrite**: If we plan to rewrite parts of the old code, we should start from
    the code that is the most difficult to test. This way, we constantly increase
    the code coverage in our project.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重写**：如果我们计划重写部分旧代码，我们应该从最难测试的代码开始。这样，我们不断增加项目中的代码覆盖率。'
- en: '**Introducing new features**: During the new feature implementation, it''s
    worth using the **feature toggle** pattern. Then, in case anything bad happens,
    we can quickly turn off the new feature. Actually, the same pattern should be
    used during refactoring.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引入新功能**：在实施新功能时，值得使用**功能切换**模式。然后，如果发生任何不良情况，我们可以快速关闭新功能。实际上，在重构过程中也应该使用相同的模式。'
- en: 'For this phase, it''s worth reading an excellent book by *Martin Fowler*, *Refactoring:
    Improving the Design of Existing Code*.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，值得阅读*Martin Fowler*的一本优秀书籍，*重构：改善现有代码的设计*。
- en: While touching the old code, it's good to follow the rule to always add a passing
    unit test first, and only then, change the code. With this approach, we can depend
    on automation to check that we don't change the business logic by accident.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在触及旧代码时，最好遵循先添加通过的单元测试的规则，然后再更改代码。通过这种方法，我们可以依赖自动化来检查我们不会意外改变业务逻辑。
- en: Understanding the human element
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解人的因素
- en: While introducing the automated delivery process to a legacy system, it's possible
    you will feel, more than anywhere else, the human factor. In order to automate
    the build process, we need to communicate well with the operations team, and they
    must be willing to share their knowledge. The same story applies to the manual
    QA team; they need to be involved in writing automated tests because only they
    know how to test the software. If you think about it, both the operations and
    QA teams need to contribute to the project that will later automate their work.
    At some point, they may realize that their future in the company is not stable
    and become less helpful. Many companies struggle with introducing the Continuous
    Delivery process because teams do not want to get involved enough.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在向遗留系统引入自动交付过程时，您可能会感到人的因素比其他任何地方都更重要。为了自动化构建过程，我们需要与运维团队进行良好的沟通，他们必须愿意分享他们的知识。同样的情况也适用于手动QA团队；他们需要参与编写自动化测试，因为只有他们知道如何测试软件。如果您仔细想想，运维和QA团队都需要为以后自动化他们的工作做出贡献。在某个时候，他们可能会意识到他们在公司的未来不稳定，并变得不那么乐于助人。许多公司在引入持续交付过程时遇到困难，因为团队不愿意投入足够的精力。
- en: In this section, we discussed how to approach legacy systems and the challenges
    they pose. If you are in progress of converting your project and organization
    into the Continuous Delivery approach, then you may want to have a look at the
    Continuous Delivery Maturity Model, which aims to give structure to the process
    of adopting the automated delivery.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何应对遗留系统以及它们带来的挑战。如果您正在将项目和组织转变为持续交付方法，那么您可能希望查看持续交付成熟度模型，该模型旨在为采用自动交付的过程提供结构。
- en: A good description of the Continuous Delivery Maturity Model can be found at [https://developer.ibm.com/urbancode/docs/continuous-delivery-maturity-model/](https://developer.ibm.com/urbancode/docs/continuous-delivery-maturity-model/).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://developer.ibm.com/urbancode/docs/continuous-delivery-maturity-model/](https://developer.ibm.com/urbancode/docs/continuous-delivery-maturity-model/)找到持续交付成熟度模型的良好描述。
- en: Exercises
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'In this chapter, we have covered various aspects of the Continuous Delivery
    process. Since practice makes perfect, we recommend the following exercises:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经涵盖了持续交付过程的各个方面。由于熟能生巧，我们建议进行以下练习：
- en: 'Use Flyway to create a non-backwards-compatible change in the MySQL database:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Flyway在MySQL数据库中创建一个不向后兼容的更改：
- en: Use the official Docker image, `mysql`, to start the database
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用官方的Docker镜像`mysql`来启动数据库
- en: Configure Flyway with proper database address, username, and password
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正确的数据库地址、用户名和密码配置Flyway
- en: 'Create an initial migration that creates a `users` table with three columns:
    `id`, `email`, and `password`'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个初始迁移，创建一个包含三列的`users`表：`id`、`email`和`password`
- en: Add a sample data to the table
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向表中添加示例数据
- en: Change the `password` column to `hashed_password`, which will store the hashed
    passwords
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`password`列更改为`hashed_password`，用于存储散列密码
- en: Split the non-backwards-compatible change into three migrations as described
    in this chapter
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照本章的描述，将不向后兼容的更改分成三个迁移
- en: You can use MD5 or SHA for hashing
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用MD5或SHA进行散列
- en: Check that, as a result, the database stores no passwords in plain text
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查结果，确保数据库不以明文存储密码
- en: 'Create a Jenkins shared library with steps to build and unit test Gradle projects:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Jenkins共享库，其中包含构建和单元测试Gradle项目的步骤：
- en: Create a separate repository for the library
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为库创建一个单独的存储库
- en: 'Create two files in the library: `gradleBuild.groovy` and `gradleTest.groovy`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在库中创建两个文件：`gradleBuild.groovy`和`gradleTest.groovy`
- en: Write the appropriate `call` methods
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写适当的`call`方法
- en: Add the library to Jenkins
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将库添加到Jenkins
- en: Use the steps from the library in a pipeline
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在流水线中使用库中的步骤
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This chapter was a mixture of various Continuous Delivery aspects that were
    not covered before. The key takeaways from the chapter are as follows:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 本章混合了以前未涉及的各种持续交付方面。本章的主要要点如下：
- en: Databases are an essential part of most applications and should, therefore,
    be included in the Continuous Delivery process.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库是大多数应用程序的重要组成部分，因此应包含在持续交付过程中。
- en: Database schema changes are stored in the version control system and managed
    by database migration tools.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库模式更改存储在版本控制系统中，并由数据库迁移工具管理。
- en: 'There are two types of database schema change: backwards-compatible and backwards-incompatible.
    While the first type is simple, the second requires a bit of overhead (split to
    multiple migrations spread over time).'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库模式更改有两种类型：向后兼容和向后不兼容。虽然第一种类型很简单，但第二种类型需要一些额外的工作（分成多个迁移，分散在时间上）。
- en: A database should not be the central point of the whole system. The preferred
    solution is to provide each service with its own database.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库不应成为整个系统的中心点。首选解决方案是为每个服务提供其自己的数据库。
- en: The delivery process should always be prepared for the rollback scenario.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交付过程应始终准备好回滚场景。
- en: 'Three release patterns should always be considered: rolling updates, blue-green
    deployment, and canary releasing'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终考虑三种发布模式：滚动更新、蓝绿部署和金丝雀发布
- en: Legacy systems can be converted into the Continuous Delivery process in small
    steps rather than all at once.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统系统可以分步骤转换为持续交付过程，而不是一次性全部转换。
- en: Best practices
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Thank you for reading this book. I hope you are ready to introduce the Continuous
    Delivery approach to your IT projects. As the last section of this book, I propose
    a list of the top 10 Continuous Delivery practices. Enjoy!
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢阅读本书。我希望您已经准备好将持续交付方法引入您的IT项目中。作为本书的最后一部分，我提出了前10个持续交付实践清单。祝您愉快！
- en: Practice 1 – own process within the team!
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践1 - 在团队内部拥有流程！
- en: 'Own the entire process within the team, from receiving requirements to monitoring
    the production. As once said: <q>A program running on the developer''s machine
    makes no money.</q> This is why it''s important to have a small DevOps team that
    takes complete ownership of a product. Actually, that is the true meaning of DevOps
    - Development and Operations from the beginning to the end:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 团队内部拥有整个流程，从接收需求到监控生产。正如有人曾经说过：<q>在开发者的机器上运行的程序是赚不到钱的。</q>这就是为什么有一个小的DevOps团队完全拥有产品是很重要的。实际上，这就是DevOps的真正含义
    - 从开始到结束的开发和运营：
- en: 'Own every stage of the Continuous Delivery pipeline: how to build the software,
    what the requirements are in acceptance tests, and how to release the product.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有持续交付管道的每个阶段：如何构建软件，验收测试中的需求以及如何发布产品。
- en: Avoid having a pipeline expert! Every member of the team should be involved
    in creating the pipeline.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免拥有管道专家！团队的每个成员都应参与创建管道。
- en: Find a good way to share the current pipeline state (and the production monitoring)
    among team members. The most effective solution is big screens in the team space.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到一种良好的方式在团队成员之间共享当前管道状态（以及生产监控）。最有效的解决方案是团队空间中的大屏幕。
- en: If a developer, QA, and IT Operations engineer are separate experts, then make
    sure they work together in one agile team. Separate teams based on expertise result
    in taking no responsibility for the product.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果开发人员，质量保证和IT运维工程师是独立的专家，那么确保他们在一个敏捷团队中共同工作。基于专业知识的分开团队会导致对产品不负责任。
- en: Remember that autonomy given to the team results in high job satisfaction and
    exceptional engagement. This leads to great products!
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，给团队自主权会带来高度的工作满意度和异常的参与度。这将带来出色的产品！
- en: Practice 2 – automate everything!
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践2-自动化一切！
- en: 'Automate everything from business requirements (in the form of acceptance tests)
    to the deployment process. Manual descriptions, wiki pages with instruction steps,
    they all quickly become out of date and lead to tribal knowledge that makes the
    process slow, tedious, and unreliable. This, in turn, leads to a need for release
    rehearsals and makes every deployment unique. Don''t go down this path! As a rule,
    if you do anything for the second time, automate it:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化一切，从业务需求（以验收测试的形式）到部署过程。手动描述，带有指导步骤的wiki页面，它们很快就会过时，并导致部落知识，使流程变得缓慢，繁琐和不可靠。这反过来又导致需要发布排练，并使每次部署都变得独特。不要走上这条路！一般来说，如果你做某件事第二次，就自动化它：
- en: Eliminate all manual steps; they are a source of errors! The whole process must
    be repeatable and reliable.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除所有手动步骤；它们是错误的根源！整个过程必须是可重复和可靠的。
- en: Don't ever make any changes directly in production! Use configuration management
    tools instead.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对不要直接在生产环境中进行任何更改！使用配置管理工具代替。
- en: Use precisely the same mechanism to deploy to every environment.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用完全相同的机制部署到每个环境。
- en: Always include an automated smoke test to check if the release completed successfully.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终包括自动化的冒烟测试，以检查发布是否成功完成。
- en: Use database schema migrations to automate database changes.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据库模式迁移来自动化数据库更改。
- en: Use automatic maintenance scripts for backup and cleanup. Don't forget to remove
    unused Docker images!
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动维护脚本进行备份和清理。不要忘记删除未使用的Docker镜像！
- en: Practice 3 – version everything!
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践3-对一切进行版本控制！
- en: 'Version everything: software source code, build scripts, automated tests, configuration
    management files, Continuous Delivery pipelines, monitoring scripts, binaries,
    and documentation. Simply everything. Make your work task-based, where each task
    results in a commit to the repository, no matter whether it''s related to requirement
    gathering, architecture design, configuration, or the software development. A
    task starts on the agile board and ends up in the repository. This way, you maintain
    a single point of truth with the history and reasons for the changes:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 对一切进行版本控制：软件源代码，构建脚本，自动化测试，配置管理文件，持续交付管道，监控脚本，二进制文件和文档。简直就是一切。让你的工作基于任务，每个任务都会导致对存储库的提交，无论是与需求收集，架构设计，配置还是软件开发有关。任务从敏捷看板开始，最终进入存储库。这样，你就可以保持一个真实的历史和更改原因的单一真相：
- en: Be strict about the version control. Everything means everything!
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格控制版本控制。一切都意味着一切！
- en: Keep source code and configuration in the code repository, binaries in the artifact
    repository, and tasks in the agile issue tracking tool.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将源代码和配置存储在代码仓库中，将二进制文件存储在构件仓库中，将任务存储在敏捷问题跟踪工具中。
- en: Develop the Continuous Delivery pipeline as a code.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将持续交付管道作为代码开发。
- en: Use database migrations and store them in a repository.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据库迁移并将其存储在仓库中。
- en: Store documentation in the form of markdown files that can be version-controlled.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以可版本控制的markdown文件形式存储文档。
- en: Practice 4 – use business language for acceptance tests!
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践4 - 使用业务语言进行验收测试！
- en: 'Use business-facing language for acceptance tests to improve the mutual communication
    and the common understanding of the requirements. Work closely with the product
    owner to create what Eric Evan called the *ubiquitous language*, a common dialect
    between the business and technology. Misunderstandings are the root cause of most
    project failures:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用面向业务的语言进行验收测试，以改善双方的沟通和对需求的共同理解。与产品负责人密切合作，创建埃里克·埃文所说的“普遍语言”，即业务和技术之间的共同方言。误解是大多数项目失败的根本原因：
- en: Create a common language and use it inside the project.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个共同的语言，并在项目内使用它。
- en: Use an acceptance testing framework such as Cucumber or FitNesse to help the
    business team understand and get them involved.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接受测试框架，如Cucumber或FitNesse，帮助业务团队理解并参与其中。
- en: Express business values inside acceptance tests and don't forget about them
    during development. It's easy to spend too much time on unrelated topics!
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在验收测试中表达业务价值，并在开发过程中不要忘记它们。很容易在无关的主题上花费太多时间！
- en: Improve and maintain acceptance tests so that they always act as regression
    tests.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进和维护验收测试，使其始终作为回归测试。
- en: Make sure everyone is aware that a passing acceptance test suite means a green
    light from the business to release the software.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每个人都知道，通过验收测试套件意味着业务方同意发布软件。
- en: Practice 5 – be ready to roll back!
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践5 - 准备好回滚！
- en: 'Be ready to roll back; sooner or later you will need to do it. Remember, You
    don''t need more QAs, you need a faster rollback. If anything goes wrong in production,
    the first thing you want to do is to play safe and come back to the last working
    version:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好回滚；迟早你会需要这样做。记住，你不需要更多的质量保证人员，你需要更快的回滚。如果在生产环境出现问题，你想做的第一件事就是确保安全，并回到上一个可用版本：
- en: Develop a rollback strategy and the process of what to do when the system is
    down
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定回滚策略以及系统宕机时的处理流程
- en: Split non-backwards-compatible database changes into compatible ones
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将不兼容的数据库更改拆分为兼容的更改
- en: Always use the same process of delivery for rollbacks and for standard releases
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终使用相同的交付流程进行回滚和标准发布
- en: Consider introducing blue-green deployments or canary releases
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑引入蓝绿部署或金丝雀发布
- en: Don't be afraid of bugs, the user won't leave you if you react quickly!
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要害怕错误，如果你能快速反应，用户不会离开你！
- en: Practice 6 – don't underestimate the impact of people
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践6 - 不要低估人的影响力
- en: 'Don''t underestimate the impact of people. They are usually way more important
    than tools. You won''t automate the delivery if the IT Operations team won''t
    help you. After all, they have the knowledge about the current process. The same
    applies to QAs, business, and everyone involved. Make them important and involved:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 不要低估人的影响力。他们通常比工具更重要。如果IT运维团队不帮助你，你就无法自动化交付。毕竟，他们对当前流程有了解。同样适用于质量保证人员、业务人员和所有相关人员。让他们变得重要并参与其中：
- en: Let QAs and IT operations be a part of the DevOps team. You need their knowledge
    and skills!
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让质量保证人员和IT运维成为DevOps团队的一部分。你需要他们的知识和技能！
- en: Provide training to members that are currently doing manual activities so that
    they can move to automation.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为当前正在进行手动操作的成员提供培训，以便他们可以转向自动化。
- en: Favor informal communication and a flat structure of organization over hierarchy
    and orders. You won't do anything without goodwill!
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更青睐非正式沟通和扁平化的组织结构，而不是等级制度和命令。没有善意，你什么都做不了！
- en: Practice 7 – build in traceability!
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践7 - 构建可追溯性！
- en: 'Build in traceability for the delivery process and working system. There is
    nothing worse than a failure without any log messages. Monitor the number of requests,
    the latency, the load of production servers, the state of the Continuous Delivery
    pipeline, and everything you can think of that could help you to analyze your
    current software. Be proactive! At some point, you will need to check the stats
    and logs:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为交付过程和工作系统构建可追溯性。没有比没有日志消息的失败更糟糕的了。监控请求数量、延迟、生产服务器的负载、持续交付管道的状态，以及您能想到的任何能帮助您分析当前软件的东西。要主动！在某个时候，您将需要检查统计数据和日志：
- en: Log pipeline activities! In the case of failure, notify the team with an informative
    message.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录管道活动！在失败的情况下，用信息丰富的消息通知团队。
- en: Implement proper logging and monitoring of the running system.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施对运行系统的适当记录和监控。
- en: Use specialized tools for system monitoring such as Kibana, Grafana, or Logmatic.io.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kibana、Grafana或Logmatic.io等专业工具进行系统监控。
- en: Integrate production monitoring into your development ecosystem. Consider having
    big screens with the current production stats in the common team space.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将生产监控集成到您的开发生态系统中。考虑在团队共享空间中放置大屏幕，显示当前生产统计数据。
- en: Practice 8 – integrate often!
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践8 - 经常集成！
- en: 'Integrate often, actually, all the time! As someone said: *Continuous is more
    often than you think*. There is nothing more frustrating than resolving merge
    conflicts. Continuous Integration is less about the tool and more about the team
    practice. Integrate the code into one codebase at least a few times a day. Forget
    about long-lasting feature branches and a huge number of local changes. Trunk-base
    development and feature toggles for the win!'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 经常集成，实际上，一直都在！正如有人所说：“持续性比你想象的更频繁”。没有什么比解决合并冲突更令人沮丧的了。持续集成更多关乎团队实践而非工具。每天至少将代码集成到一个代码库中几次。忘掉持续存在的特性分支和大量的本地更改。基于主干的开发和功能切换才是胜利之道！
- en: Use trunk-based development and feature toggles instead of feature branches.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基于主干的开发和功能切换，而不是特性分支。
- en: If you need a branch or local changes, make sure that you integrate with the
    rest of the team at least once a day.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您需要分支或本地更改，请确保您至少每天与团队集成一次。
- en: Always keep the trunk healthy; make sure you run tests before you merge into
    the baseline.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终保持主干的健康；确保在合并到基线之前运行测试。
- en: Run the pipeline after every commit to the repository for a fast feedback cycle.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每次提交到存储库后运行管道，以获得快速反馈循环。
- en: Practice 9 – build binaries only once!
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践9 - 仅构建一次二进制文件！
- en: 'Build binaries only once and run the same one on each of the environments.
    No matter if they are in a form of Docker images or JAR packages, building only
    once eliminates the risk of differences introduced by various environments. It
    also saves time and resources:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 仅构建一次二进制文件，并在每个环境中运行相同的二进制文件。无论它们是Docker镜像还是JAR包的形式，仅构建一次可以消除各种环境引入的差异风险。这也可以节省时间和资源：
- en: Build once and pass the same binary between environments.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅构建一次，并在各个环境之间传递相同的二进制文件。
- en: Use artifact repository to store and version binaries. Don't ever use the source
    code repository for that purpose.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用工件存储库存储和版本化二进制文件。绝对不要使用源代码存储库来做这个目的。
- en: Externalize configurations and use a configuration management tool to introduce
    differences between environments.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部化配置并使用配置管理工具在环境之间引入差异。
- en: Practice 10 – release often!
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践10-经常发布！
- en: Release often, preferably after each commit to the repository. As the saying
    goes, *If it hurts, do it more often.* Releasing as a daily routine makes the
    process predictable and calm. Stay away from being trapped in the rare release
    habit. That will only get worse and you will end up with releasing once a year
    having a three months' preparation period!
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 经常发布，最好是在每次提交到存储库后。俗话说，“如果痛苦，就更频繁地做。”每天发布使过程变得可预测和平静。远离陷入罕见的发布习惯。那只会变得更糟，最终你将以每年一次的频率发布，需要三个月的准备期！
- en: Rephrase your definition of done to *Done means released*. Take ownership of
    the whole process!
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新定义你的完成标准为*完成意味着发布*。承担整个过程的责任！
- en: Use feature toggles to hide (from users) features that are still in progress.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用功能切换来隐藏（对用户）仍在进行中的功能。
- en: Use canary releases and quick rollback to reduce the risk of bugs in the production.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用金丝雀发布和快速回滚来减少生产中的错误风险。
- en: Adopt a zero-downtime deployment strategy to enable frequent releases.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用零停机部署策略以实现频繁发布。
