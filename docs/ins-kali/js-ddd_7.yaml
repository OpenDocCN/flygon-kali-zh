- en: Chapter 7. It's Not All Domain-driven Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。并不全是领域驱动设计
- en: '|   | *If I have seen further, it is by standing on the shoulders of giants.*
    |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *如果我看得更远，那是因为我站在巨人的肩膀上。* |   |'
- en: '|   | --*Newton* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*牛顿* |'
- en: As with most things in developing, and not just when developing software, most
    concepts have been discovered before and most things have been done before, but
    there are those slight variations, or a recombination of ideas, that make old
    concepts more useful or enable new and innovative uses. The practice of developing
    software has been growing and evolving since the beginning. Some time ago, the
    concept of structured programming, the use of functions, subroutines, while and
    for loops, was considered a new concept. Later, object-orientation and functional
    programming took those ideas and added new ones on top to further ease maintainability
    and allow programmers to better express their intentions in the programs they
    write.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数开发中的事物一样，并不仅仅是在开发软件时，大多数概念在之前已经被发现，大多数事情在之前已经完成，但有些微小的变化，或者思想的重新组合，使旧概念更有用，或者实现新的创新用途。软件开发的实践自开始以来一直在不断增长和发展。一段时间以前，结构化编程的概念，使用函数、子程序，以及while和for循环，被认为是一个新概念。后来，面向对象编程和函数式编程吸收了这些想法，并在此基础上添加了新的想法，以进一步简化可维护性，并允许程序员更好地表达他们在编写程序时的意图。
- en: As with those ideas, domain-driven design evolved from a lot of the ideas of
    object-oriented programming, and a lot of them have been mentioned throughout
    the book already. There are more concepts influencing the ideas, and some of them
    are closely related to object-orientation, such as the ideas of aspect-orientation,
    and using plain objects to model a core service-layer in a system. But there are
    also ideas originating from other areas, such as building domain-specific languages.
    Domain-specific languages have been around for a very long time and they are commonly
    seen in the LISP family of languages.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与这些想法一样，领域驱动设计是从面向对象编程的许多想法中发展而来的，书中已经提到了很多这些想法。还有更多影响这些想法的概念，其中一些与面向对象编程密切相关，例如面向方面的思想，以及使用普通对象来模拟系统中的核心服务层。但也有一些来自其他领域的想法，比如构建领域特定语言。领域特定语言已经存在很长时间了，在LISP语言家族中经常见到。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The LISP family knows different forms of DSLs, and most LISP programs can be
    seen as a very lightweight DSL in themselves. Visit [http://en.wikipedia.org/wiki/Lisp_%28programming_language%29](http://en.wikipedia.org/wiki/Lisp_%28programming_language%29)
    for more details.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: LISP家族知道不同形式的DSL，大多数LISP程序本身可以被看作是非常轻量级的DSL。访问[http://en.wikipedia.org/wiki/Lisp_%28programming_language%29](http://en.wikipedia.org/wiki/Lisp_%28programming_language%29)了解更多细节。
- en: Functional programming also added to the ideas of domain-driven design, most
    notably the idea that immutability is a thing to aim for, easing debugging, and
    thinking about the domain in general.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程也为领域驱动设计增添了一些想法，尤其是不可变性是一个值得追求的东西，有助于调试，并且从总体上考虑领域。
- en: 'In the following chapter, you will see in detail what those additional concepts
    are that influence domain-driven design, as well as programming in general. This
    chapter will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将详细了解那些影响领域驱动设计以及一般编程的额外概念。本章将涵盖以下主题：
- en: Understanding the prerequisites for domain-driven design
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解领域驱动设计的先决条件
- en: Getting to know the influences such as object- and aspect-oriented programming,
    programming with plain objects, as well as command-query separation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解影响，如面向对象和面向方面的编程，使用普通对象进行编程，以及命令查询分离
- en: Domain-specific languages
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: Other programming practices such as functional programming and event-based systems
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他编程实践，如函数式编程和基于事件的系统
- en: Matching the domain to the problem
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将领域与问题匹配
- en: Working on an application mostly means thinking about ways to express a given
    problem in a way that a machine can understand and work on it. Domain-driven design
    takes this full circle back and makes sure that the people working on the domain
    understand the machine representation of the problem, and are therefore able to
    reason about it and contribute to it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分应用程序的工作意味着考虑如何以机器能理解和处理的方式表达给定的问题。领域驱动设计将这一切重新回到了起点，并确保在领域上工作的人理解问题的机器表示，因此能够对其进行推理和贡献。
- en: Throughout the book, we have been talking about building a language for humans
    and machines at the same time. Doing this means taking the constructs that JavaScript
    gives us and making them expressive to developers and domain experts alike.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在讨论同时为人类和机器构建一种语言。这意味着采用JavaScript给我们的构造，并使其对开发人员和领域专家都具有表现力。
- en: 'There are many ways to express a problem, and some of them are easier to reason
    about than others. In a very simple case, for example, one could write the sum
    of the numbers of an array like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多表达问题的方式，其中一些比其他方式更容易理解。例如，在一个非常简单的情况下，可以这样写一个数组中数字的总和：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This simple program works by doing a lot of work inside the `for` loop check,
    assigning a current element of the array, an initial starting value for the sum,
    and consequently uses those to implement the sum. To make the loop a little more
    confusing, it uses the property of getting an index outside the array bounds,
    resulting in an undefined, which is false to break out of the loop in the check.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的程序通过在`for`循环检查中做了很多工作来工作，分配数组的当前元素，求和的初始起始值，并因此使用它们来实现求和。为了使循环更加混乱，它使用了获取数组边界之外的索引的属性，导致未定义，这是为了在检查中跳出循环。
- en: Even though this works, it is very hard to reason about what is happening. This
    is due to naming as well as complex constructs being used to express the idea
    of summing up numbers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样做是有效的，但很难理解发生了什么。这是由于命名以及使用复杂的构造来表达求和的概念。
- en: Growing into a domain
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成长为一个领域
- en: 'Thinking about the domain in the previous example, we can see that JavaScript
    already gives us terms to express this domain more clearly, assuming some familiarity
    with mathematical terms, for example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面例子中的领域，我们可以看到JavaScript已经为我们提供了更清晰地表达这个领域的术语，假设对数学术语有一定的了解，例如：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By using the tools available to us, we can slowly grow into the domain concepts
    in general, extending what is already there, and building what needs to be added.
    We now use the built-in reduce function to do the same as the `for` loop did before.
    The `reduce` function takes a function as an argument, which gets passed the result
    so far and the current element, and we also give it a starting point of 0 to get
    the process started. For people familiar with the language, this is much more
    readable and almost instantly understandable as it uses the common concepts of
    how to express operations on arrays.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用我们可用的工具，我们可以逐渐成长为领域概念的一般性，扩展已有的内容，并构建需要添加的内容。我们现在使用内置的reduce函数来执行与以前的“for”循环相同的操作。`reduce`函数将一个函数作为参数，该函数传递到目前为止的结果和当前元素，并且我们还给它一个起始点0来启动该过程。对于熟悉该语言的人来说，这更易读，几乎可以立即理解，因为它使用了如何在数组上表达操作的常见概念。
- en: 'Using the same basic technique, we can leverage the built-in functions to accomplish
    tasks in our domain as well. When we want to calculate the time a transport takes,
    we might want to only consider the working days, so we need to filter weekends,
    and using the built-in function, this can be expressed cleanly:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的基本技术，我们也可以利用内置函数来完成我们领域中的任务。当我们想要计算运输所需的时间时，我们可能只想考虑工作日，因此我们需要过滤周末，使用内置函数，这可以清晰地表达：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We use the filter method to filter out weekends in the days from now, assuming
    it is Monday, and we can then select the arrival day as the position in the array.
    As we move along in our development we can make this even clearer, but using the
    built-in methods to operate already gives the code natural readability.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用filter方法来过滤掉现在的日期中的周末，假设今天是星期一，然后我们可以选择到达日作为数组中的位置。随着我们在开发中的进展，我们可以使这更加清晰，但是使用内置方法来操作已经使代码具有自然的可读性。
- en: Different domains have different merits of expressiveness, and the more understood
    a certain problem is, in general, the better it leads to building a domain design
    around the idea, in case when the general problem's complexity actually leads
    to a domain-driven design.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的领域具有不同的表现优点，通常情况下，对某个问题的理解越深刻，就越有利于围绕这个想法构建领域设计，以便在一般问题的复杂性实际上导致领域驱动设计的情况下。
- en: A good domain for domain-driven design
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 领域驱动设计的良好领域
- en: So far we have been working with the dungeon management system, which manages
    cells and prisoners coming in and out of the dungeon, making the dungeon money
    if they are present. This domain is quite complex as we have seen already, as
    we have just managed the transport of prisoners out of the dungeon so far, allowing
    the dungeon to have enough prisoners at the right time. This is, of course, not
    a real-world example, well obviously, as we have been talking about orcs. The
    example is grounded in a very real-world application, originally based on the
    idea of managing bookings for hotels, with over- and underbooking.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用地牢管理系统，该系统管理着进出地牢的单元格和囚犯，如果囚犯在场，地牢就会赚钱。这个领域非常复杂，正如我们已经看到的那样，因为我们到目前为止只是管理了囚犯从地牢中的运输，使地牢在适当的时间有足够的囚犯。当然，这不是一个真实的例子，显然，因为我们一直在谈论兽人。这个例子是基于一个非常真实的应用程序，最初是基于管理酒店预订的想法，包括超额预订和不足预订。
- en: On inspecting the domain, we can see certain properties that make it a valuable
    domain for domain-driven design. The inherent problem is quite complex and involves
    many different parts to collaborate and model, to build a complete, working system.
    Each part is also commonly subject to change as the system is further optimized
    towards an optimal system, providing maximum profit for the using company.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查领域时，我们可以看到使其成为领域驱动设计有价值的特性。固有问题非常复杂，涉及许多不同的部分进行协作和建模，以构建一个完整的、可工作的系统。随着系统进一步优化为最佳系统，为使用公司提供最大利润，每个部分也经常会发生变化。
- en: What further increases the value of the domain design, in this case, is that
    the users interacting with the system vary widely. Different users need to be
    exposed to different interfaces being wired together. This kind of sharing functionality
    is hard to get right, and having a central core model to model the shared parts
    is a good way to keep the different sub-applications from drifting apart, which
    is a common problem in projects having a common set of domain-specific logic split
    over multiple applications.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，进一步增加领域设计的价值的是，与系统交互的用户差异很大。不同的用户需要暴露给不同的接口，这些接口被连接在一起。这种共享功能很难做到，拥有一个中心核心模型来模拟共享部分是保持不同子应用程序不会分离的好方法，这在将一组特定于领域的逻辑分割到多个应用程序的项目中是一个常见的问题。
- en: The power of object-orientation
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象的力量
- en: Large parts of the concepts we have been leveraging as part of our building
    of the application so far are by no means specific inventions for the concepts
    of domain-driven design. Many familiar with other work around these principles
    of software engineering will have noticed many ideas from other areas. A large
    chunk of ideas are those cultivated by many people over the years as part of object-orientation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在构建应用程序的过程中利用的概念绝不是领域驱动设计概念的特定发明。许多熟悉软件工程原则的人会注意到许多来自其他领域的想法。许多想法是多年来许多人培养出来的对象导向的一部分。
- en: The object-oriented principles so far
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到目前为止的面向对象原则
- en: 'Object-orientation is about the encapsulation of state with functionality.
    The idea is fundamental and we have been using it throughout the book to build
    up our system and compose different parts as objects. JavaScript objects are special
    when it comes to object-orientation, as JavaScript is one of the few languages
    based on prototypical inheritance versus classical inheritance like most other
    object-oriented languages. This means more than a special way to deal with inheritance;
    it also means that JavaScript has a very easy way to deal with objects. Because
    there is no real difference between an instance and a class, the syntax to deal
    with objects is very simple:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象是关于封装状态和功能的。这个概念是基本的，我们在整本书中一直在使用它来构建系统，并将不同的部分组合成对象。当涉及到面向对象时，JavaScript对象是特殊的，因为JavaScript是少数几种基于原型继承而不是传统继承的语言之一，大多数其他面向对象的语言都是传统继承。这意味着不仅仅是处理继承的一种特殊方式；它还意味着JavaScript在处理对象时有一种非常简单的方式：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the most simple way to create objects and is also the most often used
    one in JavaScript.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建对象的最简单方式，也是JavaScript中最常用的方式。
- en: We have used objects to both represent value objects as well as entities, especially
    value objects. A key point to object-oriented programming is the isolation objects
    provide; when building the system we build it up by letting objects interact via
    sending messages to each other. This works particularly well when we are able
    to separate the command from the query messages as we have done. Splitting the
    commands from the queries enables easier testing and better reasoning about the
    code as it splits the things that modify the state (the commands) from idempotent
    operations (the queries that can be executed without causing any side effects).
    Another even more important advantage is that separating queries from commands
    allows us to express the significance of the commands from the domain more clearly.
    When we issue a command to a domain object, it has a significant meaning in the
    domain and should therefore stand on its own as well as being in the ubiquitous
    language established in the project. When issuing a command, we always want to
    express the "why", and bundling this with a query does not allow a name to express
    both.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用对象来表示值对象以及实体，特别是值对象。面向对象编程的一个关键点是对象提供的隔离；在构建系统时，我们通过让对象相互发送消息来构建系统。当我们能够将命令消息与查询消息分开时，这种方法特别有效。将命令与查询分开使得测试更容易，对代码的推理也更好，因为它将修改状态的事物（命令）与幂等操作（可以在不引起任何副作用的情况下执行的查询）分开。另一个更重要的优势是，将查询与命令分开允许我们更清楚地表达命令在领域中的意义。当我们向领域对象发出命令时，它在领域中具有重要意义，因此应该独立存在，并且应该在项目中建立的通用语言中。当发出命令时，我们总是希望表达“为什么”，将查询与命令捆绑在一起不允许名称同时表达两者。
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A common example is the command to update a property on the object, like `updateAddress`,
    which does not tell us the "why" when naming it. `changeDeliveryTarget` makes
    it clearer why this attribute was updated. Mixing these kind of changes in a query
    method is unnatural.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的例子是更新对象属性的命令，比如`updateAddress`，这个命名并没有告诉我们“为什么”更新它。`changeDeliveryTarget`更清楚地说明了为什么更新了这个属性。在查询方法中混合这些类型的更改是不自然的。
- en: 'Prototypical inheritance gives us another great way to model our data, as compared
    to classical inheritance the chains in prototypical inheritance are likely quite
    shallow. The important feature of prototypes is that they allow us to inherit
    dynamically from any object. The following code shows the usage of `Object.create`
    to inherit and extend objects:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 原型继承为我们提供了另一种很好的建模数据的方式，与传统继承相比，原型继承中的链通常相当浅。原型的重要特征是它们允许我们动态地从任何对象继承。以下代码显示了使用`Object.create`来继承和扩展对象的用法：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using the `Object.create` method allows us to easily build from other objects.
    It was not always present in JavaScript, and before we needed to do a lot more
    to get the same effect, but with the `Object.create` method, building objects
    is very natural and it embraces the concept of prototypical inheritance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Object.create`方法允许我们轻松地从其他对象构建。它并不总是存在于JavaScript中，在此之前，我们需要做更多的工作才能达到相同的效果，但是使用`Object.create`方法，构建对象非常自然，并且它符合原型继承的概念。
- en: 'Objects lend themselves very well to model data that flows through the system
    as they are very lightweight and extendable. There are a couple of caveats we
    need to be aware of, as discussed in the previous sections. Especially, the simple
    extension that allows the use of shallow inheritance hierarchies while still using
    polymorphism to resolve control flow. Using polymorphism to control the control
    flow is the common approach in object-orientation to allow objects to encapsulate
    knowledge. When we send a command to an object, we want it to act according to
    its internal knowledge and state, and we don''t care about its specific implementation
    unless we want to send it a specific command. This allows us to have smart objects
    that respond to commands directed at them differently, for example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对象非常适合模拟通过系统的数据流，因为它们非常轻量级且可扩展。正如在前面的部分中讨论的那样，我们需要注意一些注意事项。特别是，简单的扩展允许使用浅继承层次结构，同时仍然使用多态来解决控制流。使用多态来控制控制流是面向对象中常见的方法，它允许对象封装知识。当我们向对象发送命令时，我们希望它根据内部的知识和状态来执行，除非我们想发送特定的命令，否则我们不关心它的具体实现。这使我们能够拥有智能对象，它们对针对它们的命令做出不同的响应，例如：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We again use a basic JavaScript object as the base to build new functionality
    on top. This time, we extend our simple counter with new functionality by implementing
    a jumping counter with a new function, without modifying the underlying counter
    object. This shows the power of easy extensibility—we can just use functionality
    encapsulated in objects that already exist and build upon it without much ceremony.
    This possibility is the source of much of the power of JavaScript, a nice power
    to have but also easily abused.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用基本的JavaScript对象作为基础来构建新功能。这一次，我们通过实现一个新函数来扩展我们简单的计数器的新功能，而不修改基础计数器对象。这展示了易于扩展性的力量——我们可以只使用已经存在的对象中封装的功能，并在其基础上构建，而无需太多仪式。这种可能性是JavaScript的许多力量的来源，这是一个很好的力量，但也很容易被滥用。
- en: This leads to a very simple model of domain models that depend on each other,
    which can be used directly but also extended along the way.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个非常简单的依赖于彼此的领域模型的模型，可以直接使用，也可以在途中进行扩展。
- en: The object-oriented modeling of business domains
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务领域的面向对象建模
- en: The idea of object-orientation to encapsulate the business domain is of great
    benefit in general as it leads to a less coupled system that is easier to understand
    and modify. When we think of objects as things we pass messages to and receive
    answers from, we naturally couple ourselves less to the internal structure of
    the code, as the API becomes a question and answer, as well as a command game.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 封装业务领域的面向对象的想法通常是非常有益的，因为它导致了一个耦合度较低、更容易理解和修改的系统。当我们把对象看作是我们传递消息并接收答案的东西时，我们自然地对代码的内部结构耦合度较低，因为API变成了一个问题和答案，以及一个命令游戏。
- en: 'In a very simple example going back to our dungeon and its orcs, we might want
    to implement a method for fighting an intruder. So we start by implementing an
    orc with a weapon, using a very lightweight object to start with, for example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个非常简单的例子中，回到我们的地牢和其中的兽人，我们可能想要实现一个与入侵者战斗的方法。因此，我们首先通过使用一个非常轻量级的对象来实现一个带武器的兽人，例如：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There is one feature here that is not commonly used but is very powerful: we
    can define getters and setters in JavaScript for objects via the special `get`
    or `set` syntax, allowing us to first of all limit the scope of modifications
    to our properties, but also to allow us to construct more complex properties out
    of other ones. In this case, we abstract the knowledge that a missing weapon means
    the orc is not armed.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个特性并不常用，但非常强大：我们可以通过特殊的`get`或`set`语法在JavaScript中为对象定义getter和setter，这允许我们首先限制对我们的属性的修改范围，同时也允许我们通过其他属性构建更复杂的属性。在这种情况下，我们抽象出了一个缺少武器意味着兽人没有武装的知识。
- en: 'We consider the fight to be its own domain object, so we model it as well:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为战斗是自己的领域对象，因此我们也对其进行建模：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The fight encapsulates the logic that only an armed orc can actually attack
    his opponent during a battle. This is, of course, very simple logic but it might
    grow to be more complex. We will use an object model to abstract away the fact
    of how a fight is handled in the system.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 战斗封装了只有武装的兽人才能在战斗中实际攻击对手的逻辑。当然，这是非常简单的逻辑，但它可能会变得更加复杂。我们将使用一个对象模型来抽象出系统中如何处理战斗的事实。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is always important to keep in mind that creating objects, especially in
    JavaScript, is very cheap. Encapsulating too much knowledge into one object is
    not a good idea and more often than not, it is better to split an object early
    into responsibilities. A good indicator for this is an object that has lots of
    private methods, or methods whose names are closely related.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 始终要记住，创建对象，特别是在JavaScript中，是非常廉价的。将太多的知识封装到一个对象中并不是一个好主意，往往最好的做法是早期将一个对象分解为不同的责任。一个很好的指标是一个对象有很多私有方法，或者方法的名称与其紧密相关。
- en: 'We can now model our fight with the objects:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用对象来对战斗进行建模：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This encapsulates the logic for the fight in its own object and uses the orcs
    to encapsulate logic related to the orcs.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将战斗的逻辑封装在自己的对象中，并使用兽人来封装与兽人相关的逻辑。
- en: The scenarios of pure object-orientation falling short
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯对象导向的场景不足
- en: The basics of object orientation work very well for large parts of modeling
    the domain. Especially in JavaScript with its very lightweight object creation
    and modeling, it lends itself quite nicely to model a domain like we have seen.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的基础在很大程度上非常适合对领域进行建模。特别是在JavaScript中，由于其非常轻量级的对象创建和建模，它非常适合对我们所见过的领域进行建模。
- en: Where object orientation falls short is on the level of transaction management,
    we have certain interaction spanning multiple objects that needs to be managed
    from a higher level. On the other hand, we don't want the details of the transaction
    to leak to all the involved objects. This is where domain-driven design comes
    in with a separation of value objects, entities, and aggregates. In this case,
    aggregates allow workflow management by being the life-cycled manager of other
    collaborators. As we model the domain as composed of sub-domains, even though
    an entity may be shared between different collaborating sub-domains, each sub-domain
    has its own view of the entity. In each sub-domain, an aggregate can control the
    transactions necessary to accomplish the task and make sure the data is in a consistent
    state.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的不足之处在于事务管理的层面，我们有一些跨多个对象的交互需要从更高的层面进行管理。另一方面，我们不希望事务的细节泄漏给所有涉及的对象。这就是领域驱动设计的作用，通过价值对象、实体和聚合的分离来管理工作流。在这种情况下，聚合允许通过成为其他协作者的生命周期管理者来管理工作流。当我们将领域建模为由子领域组成时，即使一个实体可能在不同的协作子领域之间共享，每个子领域也有自己的实体视图。在每个子领域中，聚合可以控制完成任务所需的事务，并确保数据处于一致的状态。
- en: There are, of course, multiple other additions as we have seen throughout the
    book but the addition of a higher-level management for the lower-level details
    of the objects is an important feature, extending object-oriented application
    structures toward domain-driven form object orientation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在整本书中我们已经看到了多个其他的添加，但是对对象的低级细节进行更高级管理的添加是一个重要的特性，将面向对象的应用程序结构扩展到面向领域的形式对象导向。
- en: Influences to keep close
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持紧密联系的影响
- en: Object-orientation is not the only influence on application development we have
    seen throughout the book. Many different techniques can be useful to model domain
    concepts and influence how applications are developed. JavaScript itself is a
    very flexible language and can be used, and sometimes to abused, to do very interesting
    things.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象不是本书中我们所见过的应用程序开发的唯一影响。许多不同的技术可以用于建模领域概念，并影响应用程序的开发方式。JavaScript本身是一种非常灵活的语言，可以用于做很多有趣的事情，有时也会被滥用。
- en: Depending on the situation, different ideas can be good to keep at hand when
    modeling certain aspects or solving certain problems as they occur when building
    the model.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据情况，建模某些方面或解决某些问题时，可以保留不同的想法，这些想法可以很好地应用。
- en: Aspect-oriented programming
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向方面的编程
- en: At its core, most ideas of software development revolve around how it is possible
    to encapsulate logic and state it so it is easily accessible and has a common
    interface that is understandable as well as extensible. Extensibility is a very
    important aspect especially in business software since the requirements need to
    be adjusted to the real world and the software needs to be able to encompass new
    requirements quickly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的大部分思想核心，都围绕着如何封装逻辑和状态，使其易于访问，并具有一个可理解和可扩展的公共接口。可扩展性是一个非常重要的方面，特别是在商业软件中，因为需求需要根据现实世界进行调整，软件需要能够快速包含新的需求。
- en: Aspect-oriented programming sets the idea of aspects of the software development
    in the centre of the program design, and concerns itself especially with how we
    can implement cross-cutting concerns without duplication and in a maintainable
    fashion. Aspects in the case of aspect-oriented programming are all kind of concerns
    that might be shared across different objects.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 面向方面的编程将软件开发的方面的想法置于程序设计的中心，并特别关注如何在不重复和可维护的方式中实现横切关注点。在面向方面的编程的情况下，方面是可能在不同对象之间共享的各种关注点。
- en: The canonical example of aspect-oriented programming is the addition of an audit
    log to the system. The audit log is something that would need to be implemented
    across all the different domain objects, while at the same time not being a core
    concern to the object. Aspect-oriented programming extracts the aspect, in this
    case the audit logging, and applies it to each object that should be treated this
    way. By that means, it makes the aspect a core part of the system, decoupled from
    the business object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 面向方面的编程的典型例子是向系统添加审计日志。审计日志是需要在所有不同的域对象中实现的东西，同时又不是对象的核心关注点。面向方面的编程提取了方面，即审计日志，在这种情况下，并将其应用于应该以这种方式处理的每个对象。通过这种方式，它使方面成为系统的核心部分，与业务对象解耦。
- en: JavaScript, due to its very dynamic nature, can do this very simply and dynamically;
    one solution is to use traits.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript具有非常动态的特性，可以非常简单和动态地实现这一点；一个解决方案是使用特性。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The traits used are based on [https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/](https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所使用的特性基于[https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/](https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins/)。
- en: 'We can now build on the previous example and add `audit` logging to our `Fight`
    object. We can add the calls to the log to the `fight` class directly:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在先前的示例基础上构建，并向我们的`Fight`对象添加`audit`日志。我们可以直接将调用添加到`fight`类中：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To make sure we can either audit the fight or not, we will add a flag and then
    check and log the appropriate calls. This adds quite a lot of plumbing to the
    object as we also now need to depend on a way to inspect, and therefore add a
    dependency, to the `util` library.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们可以审计战斗，我们将添加一个标志，然后检查和记录适当的调用。这会给对象添加相当多的管道，因为我们现在还需要依赖一种检查的方式，并因此向`util`库添加一个依赖。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I consider flag arguments a red flag in most cases as they indicate that multiple
    concerns are mixed in one place, which need to be switched on. Often, it can be
    an indicator of a cross-cutting concern better solved by using aspect-orientation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我认为标志参数是一个警示信号，因为它们表明多个关注点混合在一个地方，需要进行切换。通常，这可能是使用面向方面的方法更好地解决横切关注点的指示器。
- en: 'A better way to add logging to the orc fight is by adding a loggable trait
    to the fight. The trait would be the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 向兽人战斗添加日志的更好方法是向战斗添加一个可记录的特性。该特性将是以下内容：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code wraps each function in a function that first logs its arguments and
    forwards them to the function afterwards. This is possible without touching the
    object at all in an abstract way since JavaScript allows us to enumerate all the
    properties of the object we want to extend via the introspection capabilities.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码将每个函数包装在一个函数中，首先记录其参数，然后将其转发给函数。由于JavaScript允许我们通过内省能力枚举要扩展的对象的所有属性，因此可以以一种抽象的方式实现这一点，而无需触及对象本身。
- en: When applied to an object, the `asLoggable` trait wraps every method of the
    object in a logged method, writing out which function was called on what, and
    with what kind of arguments, and to output more meaningful information, it uses
    the `inspect` library.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于对象时，`asLoggable`特性会将对象的每个方法包装在一个记录方法中，写出调用了什么函数，以及使用了什么类型的参数，并且为了输出更有意义的信息，它使用了`inspect`库。
- en: 'Let''s apply this to the previously constructed code, which means replacing
    the `Fight` object with the `LoggableFight` object:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这应用于先前构建的代码，这意味着用`LoggableFight`对象替换`Fight`对象：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The calls will now be logged and the output will be as follows, but shortened
    for printability:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在调用将被记录，输出将如下，但为了可打印性而缩短：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This addition does not change the overall behavior, but is a pure extension
    to the system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个添加并不改变整体行为，而是对系统的纯扩展。
- en: Extending an object in this way is a very powerful technique but can be quite
    dangerous at the same time. Even though the code is quite simple to create, it
    is not as easy to understand where certain properties of the code come from, and
    a lot depends on the right naming. If we, for example, had just replaced the `Fight`
    object all together, getting rid of the `LoggableFight` object name, there would
    be no indication of why there is suddenly logging applied to the method, and a
    developer tracking down a bug in the code would have a tough time in a big project.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式扩展对象是一种非常强大的技术，但同时也可能非常危险。尽管代码创建起来相当简单，但要理解代码的某些属性来自何处并不容易，很大程度上取决于正确的命名。例如，如果我们完全替换了`Fight`对象，摆脱了`LoggableFight`对象名称，那么就不会有任何迹象表明为什么方法突然应用了日志记录，而在一个大型项目中，跟踪代码中的错误将会让开发人员感到困难。
- en: Command-query separation
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令查询分离
- en: 'While aspect-orientation is about separating concerns at the level of objects,
    command query separation is about separating concerns at the level of methods.
    We have seen before that handling the state is difficult and a value object is
    therefore more simple than an entity. The same is true for methods: sending a
    query to an object means that the object will answer the same query in the same
    way as long as it holds the same state, and the query does not modify the state.
    This makes it very easy to write tests for queries because a simple setup of the
    object, and asserting the output of the method, does the trick.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然面向方面是关于在对象级别上分离关注点，命令查询分离是关于在方法级别上分离关注点。我们之前已经看到处理状态是困难的，因此值对象比实体更简单。对于方法也是如此：向对象发送查询意味着只要对象保持相同的状态，查询就会以相同的方式回答，而且查询不会修改状态。这使得为查询编写测试非常容易，因为简单设置对象，并断言方法的输出就可以了。
- en: Commands can be more complicated, as they modify the state of the object that
    they are sent to. A command in general does not have a return value but should
    only result in a state change for the object. This again makes it easier for us
    to test the result of commands, as we can set up an object, send a command, and
    assert that the appropriate change has been applied, without having to assert
    at the same time that the correct return value has been returned along the way.
    What we need to keep in mind when writing commands is to manage their failure
    states, and depending on the application there are multiple ways to deal with
    this. The simplest way might be raising an exception, or when using `async` commands,
    returning an error to the callback. This allows managing the aggregate, to react
    and either roll back, or handle the problem appropriately. Either way, we don't
    want to return more complex results as this quickly leads down the path of depending
    on data being returned from the command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 命令可能更复杂，因为它们修改了被发送到的对象的状态。一般来说，命令没有返回值，但应该只导致对象的状态发生变化。这使得我们更容易测试命令的结果，因为我们可以设置一个对象，发送一个命令，并断言适当的变化已经被应用，而不必同时断言正确的返回值已经在途中返回。在编写命令时，我们需要牢记的是管理它们的失败状态，根据应用程序的不同，有多种处理方式。最简单的方式可能是引发异常，或者在使用`async`命令时，将错误返回给回调函数。这允许管理聚合，以便对问题做出反应，要么回滚，要么适当地处理问题。无论哪种方式，我们都不希望返回更复杂的结果，因为这很快就会导致依赖从命令返回的数据。
- en: Command-query separation is one of the core principles to keep in mind when
    writing maintainable code that can be tested and extended.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 命令查询分离是编写可维护的、可测试和可扩展的代码时要牢记的核心原则之一。
- en: Plain old objects
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 普通旧对象
- en: 'Along with the separation comes the tendency to make things as simple as possible,
    and the way to go for most applications, especially in JavaScript, is to use the
    simple, plain objects that JavaScript provides. We have multiple ways to construct
    objects in JavaScript, and throughout the book we have been using both the classical
    and more more class-like pattern:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 随着分离的出现，人们倾向于尽可能简化事物，尤其是在JavaScript中，大多数应用程序的最佳选择是使用JavaScript提供的简单、普通对象。我们在JavaScript中构建对象的方式有多种，本书中我们一直在使用经典的和更类似类的模式：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this chapter, we also used the more JavaScript-like pattern using `Object.create`
    and exemplar objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还使用了更类似JavaScript的模式，使用`Object.create`和示例对象。
- en: The important thing to note in all of this is that the code stays away from
    using complex containers to manage the objects, the lifecycle, and more. Using
    plain objects, whatever pattern is used to construct them, means they can be tested
    in isolation and are simple to follow through the application, as well as extensively
    using the patterns of the core language as needed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些中需要注意的重要事情是，代码远离使用复杂的容器来管理对象、生命周期等。使用普通对象，无论使用什么模式来构建它们，意味着它们可以在隔离的情况下进行测试，并且在应用程序中简单地跟踪，同时根据需要广泛地使用核心语言的模式。
- en: Domain-specific languages
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域特定语言
- en: Using specific keywords to describe parts of the domain is one of the main goals
    we set out to achieve in building a system using domain-driven design. Especially
    the LISP community, which has been an influence on JavaScript ([http://readwrite.com/2011/07/22/javascript-was-no-accident](http://readwrite.com/2011/07/22/javascript-was-no-accident)),
    there is a strong tendency to meld the language to the problem. This naturally
    leads to further trying to make the language fit the domain, with the ultimate
    goal of having a language that is perfect for solving the specific problem the
    domain has.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定关键词来描述领域的部分是我们在使用领域驱动设计构建系统时设定的主要目标之一。特别是LISP社区对JavaScript产生了影响，有一种强烈的倾向将语言与问题融合在一起。这自然地导致进一步尝试使语言适应领域，最终目标是拥有一种完美解决特定问题的语言。
- en: This kind of development is referred to as using **Domain-specific Languages**,
    or **DSL** for short. In day-to-day work, there are lots of very DSLs we come
    across, be it CSS to describe the style of a HTML document, or SQL for interfacing
    with the database. The lines when a language is a DSL and when it is a general-purpose
    language are often a bit blurred. SQL, for example, is often considered a "real"
    programming language, so to speak, even though it has the very specific purpose
    of modifying and querying a relational database.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种开发被称为使用**特定领域语言**，简称**DSL**。在日常工作中，我们经常遇到许多DSL，无论是用于描述HTML文档样式的CSS，还是用于与数据库交互的SQL。语言是DSL，还是通用语言的界限通常有些模糊。例如，SQL通常被认为是一种“真正”的编程语言，即使它具有修改和查询关系数据库的非常具体的目的。
- en: A DSL is often defined and implemented on a host language and a library to provide
    the functionality first, and is then further refined by adding a special syntax
    on top. A more recent example of this can be seen in the Ruby world where the
    server administration toolkit Chef started out as a library of functions to control
    the configuration of servers, but as this developed the system became more DSL-like
    and by now, the language to describe configuration is still hosted on Ruby but
    has its own words to describe the specifics of server administration. The power
    of this model is, of course, that the underlying language is still Ruby, a general-purpose
    language, and therefore when the DSL reaches its limits, there is always the possibility
    to extend it using the host language.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: DSL通常是在主机语言和库上定义和实现的，首先提供功能，然后通过添加特殊语法来进一步完善。最近的一个例子可以在Ruby世界中看到，服务器管理工具Chef最初是一组函数库，用于控制服务器配置，但随着系统的发展，它变得更像DSL，到现在为止，描述配置的语言仍然托管在Ruby上，但有自己的词汇来描述服务器管理的具体内容。当然，这种模式的优势在于底层语言仍然是Ruby，一种通用语言，因此当DSL达到极限时，总是可以使用主机语言进行扩展。
- en: Creating DSLs
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建DSL
- en: This kind of model is what we would want to follow in a system in my opinion.
    When building a new application, it is not practical to start designing a DSL
    to solve the—at this point probably still unknown—core problem of the domain.
    But we want to start building a library of words we can use to describe our problem,
    gluing this kind of library together more and more, while filling in the gaps.
    This is how most (good) DSLs evolve. They start as a library and grow until they
    reach a point where it becomes practical to extract the language itself as a core
    domain part.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，这种模式是我们想要在系统中遵循的。在构建新应用程序时，从实际角度来看，开始设计DSL来解决领域的核心问题——在这一点上可能仍然未知——是不切实际的。但我们希望开始构建一个词汇库，用来描述我们的问题，将这种词汇库越来越紧密地粘合在一起，同时填补空白。这就是大多数（好的）DSL的演变方式。它们起初是一个库，然后不断发展，直到达到一个实际上可以将语言本身提取为核心领域部分的程度。
- en: 'JavaScript itself is full of DSLs, as the language design lends itself very
    nicely to the construction of libraries that expose their functionality as a DSL.
    The line, again, is not always clear but as we look at code such as the following,
    we can see a certain DSL-like nature. The following snippet is an example from
    [https://jquery.com/](https://jquery.com/):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript本身充满了DSL，因为语言设计非常适合构建将其功能公开为DSL的库。再次强调，界限并不总是清晰，但当我们看到以下代码时，我们可以看到某种DSL的特性。以下片段是来自[https://jquery.com/](https://jquery.com/)的一个例子：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The code uses the **jQuery** selection engines to define click handlers on elements,
    and trigger actions in them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用**jQuery**选择引擎来定义元素上的点击处理程序，并在其中触发操作。
- en: jQuery has become one of those almost ubiquitous libraries and is almost considered
    essential by some web developers. jQuery first introduced the way to select certain
    page elements by their selector, be it "`#`" for an element ID or "`.`" for elements
    by class. This way of reusing the selector definition from CSS to also select
    elements from the page, and therefore being able with one function—the `$`, to
    create a language to manipulate all kinds of page elements, is the real power
    of jQuery.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery已经成为几乎无处不在的库，并且被一些Web开发人员认为是必不可少的。jQuery首先介绍了通过其选择器选择特定页面元素的方法，无论是通过“#”选择元素ID，还是通过“.”选择类别元素。这种重用CSS中的选择器定义来选择页面元素的方式，因此能够使用一个函数——$，来创建一种语言来操作各种页面元素，这就是jQuery的真正力量。
- en: DSLs in domain-driven design
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 领域驱动设计中的DSL
- en: As we are looking at other DSLs, we should realize that our own approach for
    development hasn't been too far from the power of a true DSL. There is some way
    to go of course, but even the simple examples from the beginning of the chapter
    show where we are going in accordance to naming things right, to be able to grow
    a language we can speak with the domain experts. This is another power of DSLs
    as the goal is to make the language as understandable as possible to people not
    considered the core developers of the system.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看其他领域特定语言时，我们应该意识到我们自己的开发方法并没有离真正领域特定语言的力量太远。当然还有很长的路要走，但即使是本章开头的简单示例也显示了我们在正确命名事物方面的发展，以便能够发展一种我们可以与领域专家交流的语言。这是领域特定语言的另一个优势，因为目标是使语言尽可能易于理解，以便于不被视为系统核心开发人员的人使用。
- en: 'Where jQuery made it possible for web designers to start manipulating their
    web pages with JavaScript, our language in the project should make it possible
    for the business owners to check whether the rules that are supposed to be reflected
    by the system are truly reflected as they are supposed to be. The following code
    shows how we can use our build functions, to clearly show in the code how a prisoner
    transfer is executed:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 就像jQuery使得网页设计师可以开始使用JavaScript操纵他们的网页一样，我们项目中的语言应该使业务所有者能够检查系统应该反映的规则是否真正如他们所期望的那样。以下代码显示了我们如何使用我们的构建函数，清楚地展示了代码如何执行囚犯转移：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Even though a business expert would likely not understand the preceding code
    directly, it allows us to follow through with an explanation. We can explain the
    inputs to the expert saying, "A prisoner transfer involves the prisoner being
    sent, the dungeon the prisoner is sent to and the dungeon the prisoner is coming
    from. We also need notify the dungeon". Walking through the code, we can explain
    the steps along the way:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使业务专家可能不会直接理解前面的代码，但它使我们能够进行解释。我们可以向专家解释输入，说：“囚犯转移涉及到囚犯被送往的地牢，囚犯来自的地牢，我们还需要通知地牢”。通过代码，我们可以解释沿途的步骤：
- en: A prisoner is supposed to be transferred from one dungeon to another.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个囚犯应该被转移到另一个地牢。
- en: We need a keeper and a carriage to perform the transfer.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个看守和一辆马车来执行转移。
- en: If the transfer succeeds, a message is sent to the dungeon.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果转移成功，将向地牢发送一条消息。
- en: These simple-to-follow rules, stated as closely as possible to plain English,
    is what we are aiming for. Even though we might not involve the business experts
    in daily code walkthroughs, it is useful to be able to cross-check the rules as
    close to the code when the need arises, and just to reduce our own mental overhead.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是尽可能接近普通英语的简单易懂的规则。即使我们可能不会在日常代码审查中涉及业务专家，但在需要时能够尽可能接近代码来交叉检查规则是有用的，也能减少我们自己的心智负担。
- en: Drawing knowledge
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取知识
- en: Object orientation and its specific forms are, of course, not the only influence
    we have, and not the only one we should have. Many different ways of developing
    software have been found to be useful and have value in the world of software
    development. Depending on the kind of system we want to build, it is not always
    the best even to model as objects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象和它的特定形式当然不是我们唯一的影响，也不是我们应该拥有的唯一影响。在软件开发领域，已经发现了许多不同的开发软件的方法都是有用的，并且具有价值。根据我们想要构建的系统类型，甚至不总是最好的模拟为对象。
- en: There are very common ways that lend themselves nicely to specific problems,
    be it a more functional approach when faced with the problems of concurrency,
    or a more logical approach when trying to build a rule engine. All these kind
    of ways to approach a problem influence the way we think about a system, and the
    more different approaches there are in our toolbox, the better we can pick one
    that fits.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些非常常见的方法非常适合特定的问题，无论是在面对并发问题时采用更加函数式的方法，还是在尝试构建规则引擎时采用更加逻辑的方法。所有这些方法都会影响我们思考系统的方式，而我们工具箱中有更多不同的方法，我们就能更好地选择适合的方法。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Naturally, certain approaches feel better for an individual; I, for example,
    don't fair well when faced with a purely functional, statically-typed approach
    that, for example, Haskell takes to developing software. I have a hard time expressing
    my thoughts about the problem in such a language. Don't get discouraged by this
    kind of struggle though, because even your day-to-day work might not seem to fit
    the approach, you might come across a problem where it fits perfectly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，某些方法对个人来说感觉更好；例如，我面对纯函数式、静态类型的方法时，例如Haskell用于开发软件时，我很难表达我对问题的想法。不过，不要因为这种挣扎而感到沮丧，因为即使你的日常工作似乎不适合这种方法，你可能会遇到一个完全适合的问题。
- en: For this reason, I think that besides knowing about the approaches that object
    orientation takes to solve problems, close relation to domain-driven design, can't
    be the end all, and an introduction to other ways of thinking can be very helpful
    to draw knowledge from.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我认为除了了解面向对象解决问题的方法之外，与领域驱动设计的密切关系并不是全部，介绍其他思考方式可能非常有帮助，可以从中获取知识。
- en: Functional programming
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式编程
- en: '|   | *Functional programming is a style of programming which models computations
    as the evaluation of expressions.* |   |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| | *函数式编程是一种将计算建模为表达式求值的编程风格。* | |'
- en: '|   | --*[https://wiki.haskell.org/Functional_programming](https://wiki.haskell.org/Functional_programming)*
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| | --*[https://wiki.haskell.org/Functional_programming](https://wiki.haskell.org/Functional_programming)*
    |'
- en: Functional programming has gained a lot of influence over the last years, and
    it has not only gained traction in niche communities, but companies have been
    founded on the idea that functional programming is a way to develop software.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程在过去几年中获得了很大的影响力，它不仅在利基社区中获得了关注，而且一些公司也是基于函数式编程的理念创立的。
- en: Even though it has been around for a long time, a recent surge of interest in
    the ideas of functional programming has been sparked, but problems arise in the
    development of large scale systems needing to serve large numbers of users concurrently,
    and be as bug free as possible. The premise of functional programming is that
    large parts of the development can be done in a purely functional way, avoiding
    mutation of the state as well as passing around functions to be executed on other
    functions, or value objects to be transformed toward the end result.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它已经存在很长时间，但对函数式编程思想的兴趣最近出现了激增，但在开发需要同时为大量用户提供服务并尽可能无错的大规模系统时会出现问题。函数式编程的前提是，开发的大部分工作可以以纯函数式的方式完成，避免状态的变异以及传递函数到其他函数上执行，或者将值对象转换为最终结果。
- en: As our systems become more parallel and have to deal with more concurrent requests,
    the more functional our code is and the more it interacts with immutable data
    structures, the easier to manage this increasingly complex scenario gets. We can
    avoid the need for more complex locking, as well as race conditions that are hard
    to debug.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的系统变得更加并行，并且需要处理更多并发请求，我们的代码越函数式，与不可变数据结构的交互越多，管理这种日益复杂的情况就越容易。我们可以避免对更复杂的锁定的需求，以及难以调试的竞争条件。
- en: Functional programming and JavaScript
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数式编程和JavaScript
- en: JavaScript has had many influences, be it the prototypical inheritance mechanism
    oriented towards the way inheritance is done in the language itself, or the way
    functions are first class citizens as they are in **Scheme**, a LISP dialect.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript受到了许多影响，无论是面向语言本身的原型继承机制，还是函数作为第一类公民的方式，就像**Scheme**，一个LISP方言中一样。
- en: 'This influence from Scheme makes JavaScript somewhat functional even though
    it is, maybe, not the primary focus of the way many people use the language:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可能不是许多人使用该语言的主要关注点，但来自Scheme的这种影响使JavaScript在某种程度上具有函数式特性：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the beginning of this chapter, we already used the `reduce` function on the
    array, and we can now follow this up with a `filter` and `map` to create more
    complex chains of operations. These all work very similarly and abstract away
    the knowledge of how iteration should be handled, but they let you express the
    action to be done. In the case of a map, transforming each element to its square,
    and in the case of a filter, sorting out elements that do not match a certain
    criteria.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们已经在数组上使用了`reduce`函数，现在我们可以继续使用`filter`和`map`来创建更复杂的操作链。这些方法都非常相似，并且抽象了迭代应该如何处理的知识，但它们让你表达要执行的动作。在映射的情况下，将每个元素转换为其平方，而在过滤的情况下，筛选出不符合特定标准的元素。
- en: JavaScript has basic ways to operate on elements in a functional style. Using
    the likes of map, reduce, and filter, we can quickly modify collections, for example,
    and this kind of programming is often used to modify sets of HTML elements in
    a similar style.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有基本的方法以函数式的方式操作元素。使用map、reduce和filter等方法，我们可以快速修改集合，例如，这种编程方式经常用于以类似的方式修改一组HTML元素。
- en: Of course, a program like this could also be written as a `for` loop, but in
    this case the intention gets lost in the setup of the loop as well as the management
    of the loop variables. Functional methods specialized in modifying collections
    are a very effective way to boil the problem down to the core steps and describe
    them as functions to apply, without having to worry about how each element is
    mapped over, selected from the original collection and, probably most importantly,
    where to store the result.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这样的程序也可以写成`for`循环，但在这种情况下，意图会在循环的设置以及循环变量的管理中丢失。专门用于修改集合的函数式方法是将问题简化为核心步骤并将其描述为要应用的函数的非常有效的方法，而无需担心如何映射每个元素，从原始集合中选择元素，以及最重要的是存储结果的位置。
- en: For increased readability, we can name the functions being applied, as required,
    to reduce the mental overhead for the reader having to understand the function
    body. Combined with the higher abstraction level, these collection methods, like
    the previously introduced methods such as `filter` and `reduce`, mean we can quickly
    create very expressive APIs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加可读性，我们可以根据需要命名被应用的函数，以减少读者理解函数体的心智负担。结合更高的抽象级别，这些集合方法，如之前介绍的`filter`和`reduce`等方法，意味着我们可以快速创建非常表达性的API。
- en: Value objects
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值对象
- en: The idea that we don't want to worry about where we store results but simply
    operate on the input and let the language figure out what to do about the intermediate
    results, and how to manage the pass through of the elements, is a core strength
    of functional programming. Even though this is not the case for JavaScript, it
    is easy to see how the preceding code could be optimized by the compiler to pass
    through items in batches, or even operate on the items in separate workers instead
    of letting the main process do all the work.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想担心存储结果的位置，只是简单地操作输入，让语言来处理中间结果以及如何管理元素的传递，这是函数式编程的核心优势。尽管这对于JavaScript来说并非如此，但很容易看出编译器如何优化前面的代码，以批处理方式传递项目，甚至在单独的工作线程上操作项目，而不是让主进程做所有工作。
- en: These kinds of optimizations are easy to do when we don't have to directly deal
    with the problems of concurrency. The main problem of concurrency is the shared
    state between different parts of the program. So the main thing to learn from
    functional approaches is possibly the idea that what we called "value objects"
    before, objects that are only identified by their properties and not their identity,
    are a good thing. We can easily pass them around and modify collections of them
    with functions, and share them with whoever we want, because they can't change.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不必直接处理并发问题时，这些优化很容易实现。并发的主要问题是程序不同部分之间的共享状态。因此，从功能方法中可能学到的主要内容是我们之前所说的“值对象”，即仅通过其属性而不是其身份来识别的对象，是一件好事。我们可以轻松地传递它们并使用函数修改它们的集合，并与任何人分享，因为它们不会改变。
- en: Value objects make dependencies shallow, as they terminate chains we have to
    think about. Once we reach a value object, we can be sure that we just need to
    construct one in case we want to test something. There is no need for mocking,
    stubbing, or anything complicated.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象使依赖关系变得浅显，因为它们终止了我们必须考虑的链条。一旦到达值对象，我们可以确信，如果想要测试某些东西，只需要构造一个。不需要模拟、存根或任何复杂的东西。
- en: Not only are value objects at the core of functional approaches, maybe as much
    as the idea that functions are a first class thing, but they are also there to
    represent the data to pass through the system. As we have seen before, this data
    can flow through, instead of having to stop and be evaluated as a whole. This
    thinking naturally leads to another tool in our tool chest, using events to model
    the state of a system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 值对象不仅是功能方法的核心，也许与函数是第一类事物的想法一样重要，而且它们还用于表示要通过系统传递的数据。正如我们之前所看到的，这些数据可以流动，而不必停下来作为一个整体进行评估。这种思维自然地导致了我们工具箱中的另一个工具，即使用事件来模拟系统的状态。
- en: Events
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: 'The real-world functions through a system of reactions to actions and events.
    If somebody wants me to open the door of my apartment, they will ring the doorbell,
    and if I''m at home, I will react to this and go to open the door. This is a well-defined
    flow of events: first somebody decides they want to trigger me to open the door,
    so they need to discover the service to send the event, in this case the doorbell,
    they then trigger the event by pressing the doorbell. When I hear the ring, I
    first need to check whether the event is actually for me, and in the case of the
    doorbell this depends on whether I''m alone at home or not. After deciding that
    the event is actually for me, I can decide how to react, selecting the appropriate
    handler, so to speak, so I will get up and go to open the door.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的功能是通过对行动和事件的反应系统来实现的。如果有人想让我打开公寓的门，他们会按门铃，如果我在家，我会对此做出反应并去开门。这是一个明确定义的事件流程：首先有人决定触发我打开门，所以他们需要发现发送事件的服务，在这种情况下是门铃，然后按门铃触发事件。当我听到铃声时，我首先需要检查事件是否真的是给我的，对于门铃的情况取决于我是否独自在家。在决定事件确实是给我的之后，我可以决定如何做出反应，选择适当的处理程序，我会起身去开门。
- en: 'At each point of the execution, I can decide how to handle the next step. If
    I am in the shower, for example, I might decide to ignore the event and just continue
    showering. After I''m done, I might check the door later, queuing up the action
    to handle the event. Also in the case of the doorbell, the event is multicast
    to multiple consumers; if, for example, my wife is at home, she can also go to
    open the door. From an event-sender side, we also have multiple options: if I''m
    outside somebody''s house, I can decide to ring the doorbell, but if I don''t
    get a reaction, I can check whether there are other ways to trigger the signal;
    I can, for example, just knock. The following diagram shows the flow of events
    described:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行的每个点上，我可以决定如何处理下一步。例如，如果我在淋浴，我可能决定忽略事件，继续淋浴。完成后，我可能稍后检查门，排队处理事件。同样，在门铃的情况下，事件被多个消费者广播；例如，如果我妻子在家，她也可以去开门。从事件发送方面来看，我们也有多种选择：如果我在别人家外面，我可以决定按门铃，但如果没有反应，我可以检查是否有其他方法触发信号；例如，我可以敲门。以下图表显示了描述的事件流程：
- en: '![Events](graphics/B03704_07_01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Events](graphics/B03704_07_01.jpg)'
- en: This little example shows the very power of modeling a system via small components
    communicating via events. Each component can decide how to respond to an event
    considering its current load or even other events being triggered at the same
    time. Priorities can be implemented by reordering the events either on the sender
    side or on the consumer side to ensure the best responsiveness for the system
    in regards to the agreed-upon service level agreements.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小例子展示了通过小组件之间通过事件通信来建模系统的强大力量。每个组件可以根据其当前负载或同时触发的其他事件来决定如何响应事件。可以通过在发送方或消费方重新排序事件来实现优先级，以确保系统对于约定的服务水平协议具有最佳的响应能力。
- en: 'JavaScript offers this kind of eventing at its core, and NodeJS''s `EventEmitter`
    is a nice abstraction over the core idea, leading to very clear code, for example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在其核心提供了这种事件处理，NodeJS的`EventEmitter`是对核心思想的一个很好的抽象，导致非常清晰的代码，例如：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `EventEmitter` function allows us to add to the functionality commonly known
    from interacting with the document object model in JavaScript to any object we
    need. In the preceding code, we use the `inherits` helper to make our `House`
    be an `EventEmitter`. With this in place, we can act on events and dispatch them
    as seen. We can define events we want other objects to be able to react to, like
    we would react to clicks or hover events.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`函数允许我们向任何需要的对象添加常见的与JavaScript文档对象模型交互的功能。在前面的代码中，我们使用`inherits`助手使我们的`House`成为`EventEmitter`。有了这个，我们可以对事件进行操作并分派它们。我们可以定义我们希望其他对象能够对其做出反应的事件，就像我们对点击或悬停事件做出反应一样。'
- en: Event stores versus entity relational mapping
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件存储与实体关系映射
- en: Depending on what our system is supposed to achieve, it can be important to
    save events. In the case of our doorbell example where I am in the shower, we
    might have the problem that I can not hear the event as well as my decision to
    not respond to it. Depending on the reason the person triggering the event had,
    this can either be acceptable or not.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的系统应该实现的目标，保存事件可能很重要。在我们的门铃示例中，当我在淋浴时，可能会出现我听不到事件的问题，以及我决定不予回应的问题。根据触发事件的人的原因，这可能是可以接受的，也可能不可以接受。
- en: If it were the postman trying to drop off a package and they don't want to wait,
    they can have a short timeout to await a response and if they don't get one, they
    can queue the package delivery again on their side, get back in the van, and try
    again tomorrow. In other circumstances when we want the system delivering the
    event to handle this scenario for us, this is also common, for example, when I
    miss a call, I will get an SMS with the call details, or a voicemail saving the
    event details for me and when I'm ready to handle it I can do so.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是邮递员试图投递包裹，而他们不想等待，他们可以设置一个短暂的超时等待回应，如果他们没有得到回应，他们可以在他们那一端再次排队投递包裹，重新上车，然后明天再试一次。在其他情况下，当我们希望系统传递事件来处理这种情况时，这也很常见，例如，当我错过一个电话时，我会收到一条包含通话详情的短信，或者一条保存事件详情的语音邮件，当我准备处理时，我可以这样做。
- en: In many software systems, we want the event delivery system to abstract away
    as many things as possible. Going all the way to the extreme, it is even possible
    to construct the system purely by storing the events and never actually modifying
    any data, but just generating new events to again be stored. All the system needs
    to know at this point is at which point in time a consumer is in regards to the
    event stream, and it can then replay whatever is needed, obviating the need to
    store modifiable data by mapping entities to a database. The only entity in this
    scenario is the pointer into the event log for each consumer. This is not something
    that is easy to implement as it raises problems due to the only eventually consistent
    nature of such a system. After all, it takes time to send events between systems,
    but it might be worth it for a reasonably complex system to tackle.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多软件系统中，我们希望事件传递系统尽可能地抽象化。甚至可以将系统构建为纯粹通过存储事件而从不实际修改任何数据，只是生成新事件再次存储。在这一点上，系统只需要知道消费者在事件流中的时间点，然后可以重播所需的内容，从而避免了将实体映射到数据库中存储可修改数据的需要。在这种情况下，唯一的实体是每个消费者在事件日志中的指针。由于这种系统只是最终一致性的，因此这并不容易实现，因为它会引发问题。毕竟，在系统之间发送事件需要时间，但对于一个相当复杂的系统来说，解决这个问题可能是值得的。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'A very good example of such a system is **Kafka**, and it is a whole ecosystem
    for modeling, consuming, event creation, and storage, but there are other examples
    for this as well. Martin Kleppman has written about, and presented on this, at
    various occasions, for example, at Spanconf 2014: [https://www.youtube.com/watch?v=b_H4FFE3wP0](https://www.youtube.com/watch?v=b_H4FFE3wP0).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的系统的一个很好的例子是**Kafka**，它是一个用于建模、消费、事件创建和存储的整个生态系统，但也有其他类似的例子。Martin Kleppman在各种场合都写过关于这个的文章，并做过演讲，例如在2014年的Spanconf：[https://www.youtube.com/watch?v=b_H4FFE3wP0](https://www.youtube.com/watch?v=b_H4FFE3wP0)。
- en: Creating a system like this is probably not the simplest or the first choice
    when developing a business application as the requirements for the infrastructure
    to support it are quite high. The more the application has to deal with high availability
    and the more the system starts to be distributed for whatever reason, the more
    reasonable such a system becomes. JavaScript as a language is very well suited
    to event handling, as it is at the core of the domain the language was build for—reacting
    to user events in the browser.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这样的系统可能不是开发业务应用程序时最简单或首选的选择，因为支持它的基础设施的要求相当高。应用程序需要处理高可用性的越多，系统出于任何原因开始分布，这样的系统就变得越来越合理。JavaScript作为一种语言非常适合处理事件，因为它是该语言构建的核心领域——在浏览器中对用户事件做出反应。
- en: Further reading
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Throughout this chapter, there have been a lot of things introduced that are
    not the primary focus but still added a great deal of understanding to the evolvement
    of domain-driven design. Being inspired by workarounds can really improve the
    general software development practices so there is further reading I would recommend.
    To further understand object orientation, and especially to find design patterns
    to use, I recommend the book called *Gang of four*, and *Design Patterns : Elements
    of Reusable Object-Oriented Software*, *Erich Gamma*, *Richard Helm*, *Ralph Johnson*,
    *John Vlissides*, *Pearson Publishing.* Even though the book is old, it still
    represents classic work on object orientation, and establishes a lot of terminology.
    Also *Smalltalk Best Practice Patterns*, *Kent Becks*, *Prentice Hall*, really
    embraces Object-Oriented design, and even though both books are naturally not
    focused on JavaScript, they can still be very helpful in advancing your design
    skills.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，介绍了许多不是主要焦点但仍然增进了对领域驱动设计演变的理解的内容。受到解决方法的启发，可以真正改进一般的软件开发实践，因此我推荐进一步阅读。为了进一步理解面向对象，特别是寻找可用的设计模式，我推荐一本名为《四人帮》的书，以及《设计模式：可复用面向对象软件的元素》，作者是*Erich
    Gamma*, *Richard Helm*, *Ralph Johnson*, *John Vlissides*, *Pearson Publishing.*
    尽管这本书很老，但它仍然代表了面向对象的经典作品，并确立了许多术语。另外，《Smalltalk最佳实践模式》，作者是*Kent Becks*, *Prentice
    Hall*，真正拥抱了面向对象的设计，尽管这两本书自然不是专注于JavaScript，但它们仍然可以在提高您的设计技能方面提供很大帮助。
- en: At the other end of the chapter, we went into some detail on how to get started
    on modeling a flow of events, which is currently a very hot topic. Martin Kleppmann
    has been doing a lot of work around this area, so following his work closely will
    bring you some good insights into how to model growing applications ([https://martin.kleppmann.com/](https://martin.kleppmann.com/)).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的另一端，我们详细介绍了如何开始建模事件流，这是目前非常热门的话题。Martin Kleppmann在这个领域做了很多工作，因此密切关注他的工作将为您带来一些关于如何建模不断增长的应用程序的深刻见解（[https://martin.kleppmann.com/](https://martin.kleppmann.com/)）。
- en: There is obviously a lot more to follow up on, but getting started with the
    mentioned work will naturally lead to a lot more, probably more than is digestible
    in a short amount of time, so I recommend you go and follow this up and follow
    it down the rabbit hole.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 显然还有很多要跟进，但开始进行上述工作自然会导致更多的工作，可能超出短时间内的消化范围，因此我建议您继续跟进并深入研究。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the various ways domain-driven design is influenced
    and can be augmented by related software development patterns. Some patterns are
    closer than others, such as DSLs, and some are more orthogonal such as modeling
    the system as a series of events.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了领域驱动设计受到影响并可以通过相关软件开发模式进行增强的各种方式。有些模式比其他模式更接近，比如DSL，有些则更正交，比如将系统建模为一系列事件。
- en: The important thing is to make sure we don't get stuck in trying to only apply
    the techniques we see in a specific pattern, but look at what is around to make
    sure we use the right tool for the job. At its core, domain-driven design is about
    modeling business software, and while most business software follows similar patterns
    and rules, some internal details might be very well-suited for a functional core
    integrated in the software as a whole, or even the development of a DSL that allows
    not-so-technical business experts to express their rules clearly.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要确保我们不要陷入尝试仅应用特定模式中看到的技术，而是要看看周围的情况，以确保我们使用合适的工具来完成工作。在其核心，领域驱动设计是关于建模商业软件的，虽然大多数商业软件遵循类似的模式和规则，但一些内部细节可能非常适合作为整个软件集成的功能核心，甚至是开发允许非技术业务专家清晰表达其规则的DSL。
- en: In the next chapter, we are going to sum up all the details we came across and
    are going to think about how to work on an ever-changing product like most business
    software is.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将总结我们遇到的所有细节，并思考如何处理像大多数商业软件一样不断变化的产品。
