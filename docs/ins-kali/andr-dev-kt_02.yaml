- en: Laying a Foundation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奠定基础
- en: This chapter is largely devoted to the fundamental building blocks that are
    core elements of the Kotlin programming language. Each one may seem insignificant
    by itself, but combined together, they create really powerful language constructs.
    We will discuss the Kotlin type system that introduces strict null safety and
    smart casts. Also we will see a few new operators in the JVM world, and many improvements
    compared to Java. We will also present new ways to handle application flows and
    deal with equality in a unified way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讨论了构成Kotlin编程语言核心元素的基本构建块。每个构建块本身可能看起来微不足道，但是当它们组合在一起时，它们会创建非常强大的语言结构。我们将讨论引入了严格的空安全和智能转换的Kotlin类型系统。此外，我们还将看到JVM世界中一些新的操作符，以及与Java相比的许多改进。我们还将介绍处理应用程序流程和以统一方式处理相等性的新方法。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Variables, values, and constants
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量、值和常量
- en: Type inference
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型推断
- en: Strict null safety
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格的空安全
- en: Smart casts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能转换
- en: Kotlin data types
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin数据类型
- en: Control structures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制结构
- en: Exceptions handling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Variables
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'In Kotlin, we have two types of variables: `var` or `val` . The first one,
    `var` , is a mutable reference (read-write) that can be updated after initialization.
    The `var` keyword is used to define a variable in Kotlin. It is equivalent to
    a normal (non-final) Java variable. If our variable needs to change at some time,
    we should declare it using the `var` keyword. Let''s look at an example of a variable
    declaration:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们有两种类型的变量：`var`或`val`。第一种`var`是可变引用（读写），可以在初始化后更新。`var`关键字用于定义Kotlin中的变量。它相当于普通（非final）的Java变量。如果我们的变量需要在某个时候更改，我们应该使用`var`关键字进行声明。让我们看一个变量声明的例子：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create fruit variable and initialize it with variable `orange` value
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建水果变量，并用变量`orange`的值进行初始化
- en: Reinitialize fruit variable with with `banana` value
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新初始化水果变量为`banana`的值
- en: The second type of variable is a read-only reference. This type of variable
    cannot be reassigned after initialization.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种类型的变量是只读引用。这种类型的变量在初始化后不能被重新分配。
- en: 'The `val` keyword can contain a custom getter, so technically it can return
    different objects on each access. In other words, we can''t guarantee that the
    reference to the underlying object is immutable:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`val`关键字可以包含自定义的getter，因此在技术上它可以在每次访问时返回不同的对象。换句话说，我们无法保证对底层对象的引用是不可变的：'
- en: '`val random: Int`'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`val random: Int`'
- en: '`get() = Random().nextInt()`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`get() = Random().nextInt()`'
- en: Custom getters will be discussed in more detail in Chapter 4, *Classes and Objects*
    .
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义getter将在第4章“类和对象”中更详细地讨论。
- en: 'The `val` keyword is equivalent of a Java variable with the `final` modifier.
    Using immutable variables is useful, because it makes sure that the variable will
    never be updated by mistake. The concept of *immutability* is also helpful for
    working with multiple threads without worrying about proper data synchronization.
    To declare immutable variables, we will use the `val` keyword:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`val`关键字相当于带有`final`修饰符的Java变量。使用不可变变量很有用，因为它确保变量永远不会被错误地更新。*不可变性*的概念对于在不担心正确的数据同步的情况下处理多个线程也是有帮助的。要声明不可变变量，我们将使用`val`关键字：'
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create fruit variable and initialize it with string `orange` value
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建水果变量，并用字符串`orange`的值进行初始化
- en: Compiler will throw an error, because fruit variable was already initialized
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器会抛出错误，因为水果变量已经被初始化
- en: Kotlin also allows us to define variables and functions at the level of the
    file. We will discuss it further in [Chapter 3](text00073.html) , *Playing with
    Functions* .
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin还允许我们在文件级别定义变量和函数。我们将在[第3章](text00073.html)“玩转函数”中进一步讨论。
- en: 'Notice that the type of the variable reference (`var` , `val` ) relates to
    the reference itself, not the properties of the referenced object. This means
    that when using a read-only reference (`val` ), we will not be able to change
    the reference that is pointing to a particular object instance (we will not be
    able to reassign variable values), but we will still be able to modify properties
    of referenced objects. Let''s see it in action using an array:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，变量引用的类型（`var`，`val`）与引用本身有关，而不是所引用对象的属性。这意味着当使用只读引用（`val`）时，我们将无法更改指向特定对象实例的引用（我们将无法重新分配变量值），但我们仍然可以修改所引用对象的属性。让我们使用数组来看看它的运行情况：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Initialize mutable list
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化可变列表
- en: Compiler will throw an error, because value reference cannot be changed (reassigned)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器会抛出错误，因为值引用不能被改变（重新分配）
- en: Compiler will allow to modify content of the list
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器将允许修改列表的内容
- en: The keyword `val` cannot guarantee that the underlying object is immutable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`val`不能保证底层对象是不可变的。
- en: 'If we really want to make sure that the object will not be modified, we must
    use immutable reference and an immutable object. Fortunately, Kotlin''s standard
    library contains an immutable equivalent of any collection interface (`List` versus
    `MutableList` , `Map` versus `MutableMap` , and so on) and the same is true for
    helper functions that are used to create instance of particular collection:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想确保对象不会被修改，我们必须使用不可变引用和不可变对象。幸运的是，Kotlin的标准库包含了任何集合接口（`List`与`MutableList`，`Map`与`MutableMap`等）的不可变等价物，对于用于创建特定集合实例的辅助函数也是如此：
- en: '| **Variable/value definition** | **Reference can change** | **Object state
    can change** |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| **变量/值定义** | **引用可以改变** | **对象状态可以改变** |'
- en: '| `val = listOf(1,2,3)` | No | No |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `val = listOf(1,2,3)` | 否 | 否'
- en: '| `val = mutableListOf(1,2,3)` | No | Yes |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `val = mutableListOf(1,2,3)` | 否 | 是'
- en: '| `var = listOf(1,2,3)` | Yes | No |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `var = listOf(1,2,3)` | 是 | 否 |'
- en: '| `var = mutableListOf(1,2,3)` | Yes | Yes |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '- `var = mutableListOf(1,2,3)` | 是 | 是'
- en: Type inference
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'As we saw in previous examples, unlike Java, the Kotlin type is defined after
    variable name:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的例子中看到的，与Java不同，Kotlin类型是在变量名之后定义的：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At first glance, this may look strange to Java developers, but this construct
    is a building block of a very important feature of Kotlin called **type inference**
    *.* Type inference means that the compiler can infer type from context (the value
    of an expression assigned to a variable). When variable declaration and initialization
    is performed together (single line), we can omit the type declaration. Let''s
    look at the following variable definition:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这可能看起来对Java开发人员来说很奇怪，但这个构造是Kotlin一个非常重要的特性的基础，称为**类型推断**。类型推断意味着编译器可以从上下文（分配给变量的表达式的值）中推断类型。当变量声明和初始化一起进行（单行）时，我们可以省略类型声明。让我们看一下以下变量定义：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The type of the `title` variable is `String` , but do we really need an implicit
    type declaration to determine variable type? On the right side of the expression,
    we have a string `Kotlin` and we are assigning it to a variable `title` defined
    on the left-hand side of the expression.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`title`变量的类型是`String`，但我们真的需要隐式类型声明来确定变量类型吗？在表达式的右侧，我们有一个字符串`Kotlin`，我们将其赋给了左侧表达式中定义的变量`title`。'
- en: 'We specified a variable type as `String` , but it was obvious, because this
    is the same type as the type of assigned expression (`Kotlin` ). Fortunately,
    this fact is also obvious for the Kotlin compiler, so we can omit type when declaring
    a variable, because the compiler will try to determine the best type for the variable
    from the current context:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了变量类型为`String`，但这是显而易见的，因为这与分配表达式的类型（`Kotlin`）的类型相同。幸运的是，这个事实对于Kotlin编译器来说也是显而易见的，所以当声明变量时我们可以省略类型，因为编译器将尝试从当前上下文中确定变量的最佳类型：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Keep in mind, that type declaration is omitted, but the type of variable is
    still implicitly set to `String` , because Kotlin is a strongly typed language.
    That''s why both of the preceding declarations are the same, and Kotlin compiler
    will still be able to properly validate all future usages of variable. Here is
    an example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，类型声明被省略，但变量的类型仍然隐式设置为`String`，因为Kotlin是一种强类型语言。这就是为什么前面两个声明是相同的，Kotlin编译器仍然能够正确验证变量的所有未来用法。这里有一个例子：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Inferred type was `String` and we are trying to assign `Int`
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推断类型为`String`，我们正在尝试分配`Int`
- en: 'If we want to assign the `Int` (value `12` ) to the title variable then we
    need to specify title type to one that is a `String` and `Int` common type. The
    closest one, up in the type hierarchy is `Any` :'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将`Int`（值`12`）赋给标题变量，那么我们需要指定标题类型为`String`和`Int`的公共类型。在类型层次结构中最接近的一个是`Any`：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Any is an equivalent of the Java object type. It is the root of the Kotlin type
    hierarchy. All classes in Kotlin explicitly inherit from type `Any` , even primitive
    types such as `String` or `Int`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Any是Java对象类型的等价物。它是Kotlin类型层次结构的根。Kotlin中的所有类都明确继承自类型`Any`，甚至是`String`或`Int`等原始类型
- en: '![](img/Image00021.jpg)Any defines three methods: `equals` , `toString` , and
    `hashCode` . Kotlin standard library contains a few extensions for this type.
    We will discuss extensions in [Chapter 7](text00171.html) , *Extension Functions
    and Properties* .'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/Image00021.jpg)Any定义了三个方法：`equals`，`toString`和`hashCode`。Kotlin标准库包含了这种类型的一些扩展。我们将在[第7章](text00171.html)
    *扩展函数和属性*中讨论扩展。'
- en: 'As we can see, *type inference* is not limited to primitive values. Let''s
    look at inferring types directly from functions:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，*类型推断* 不仅限于原始值。让我们直接从函数中推断类型：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding example, the inferred type will be the same as type returned
    by the function. We may guess that it will be `Int` , but it may also be a `Double`
    , `Float` , or some other type. If it''s not obvious from the context what type
    will be inferred we can use place carrot on the variable name and run the Android
    Studio expression type command (for Windows, it is *Shift* + *Ctrl* + *P* , and
    for macOS, it is arrow key + *control* + *P* ). This will display the variable
    type in the tooltip, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，推断的类型将与函数返回的类型相同。我们可能猜测它将是`Int`，但它也可能是`Double`，`Float`或其他类型。如果从上下文中不明显推断出类型，我们可以在变量名上放置插入符号，并运行Android
    Studio的表达式类型命令（对于Windows，是*Shift* + *Ctrl* + *P*，对于macOS，是箭头键+ *control* + *P*）。这将在工具提示中显示变量类型，如下所示：
- en: '![](img/Image00022.gif)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00022.gif)'
- en: 'Type inference works also for generic types:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断也适用于泛型类型：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Assuming that we pass only instances of the `Person` class, the inferred type
    will be `List<Person>` . The `listOf` method is a helper function defined in the
    Kotlin standard library that allow us to create collection. We will discuss this
    subject in [Chapter 7](text00171.html) , *Extension Functions and Properties*
    . Let''s look at more advanced examples that uses the Kotlin standard library
    type called `Pair` , which contains a pair composed of two values:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们只传递`Person`类的实例，推断的类型将是`List<Person>`。`listOf`方法是Kotlin标准库中定义的一个辅助函数，允许我们创建集合。我们将在[第7章](text00171.html)
    *扩展函数和属性*中讨论这个主题。让我们看一些更高级的例子，使用Kotlin标准库类型`Pair`，其中包含由两个值组成的一对：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding example, a `pair` instance is created using the *infix function*
    , which will be discussed in [Chapter 4](text00088.html) , *Classes and Objects*
    , but for now all we need to know is that those two declarations return the same
    type of `Pair` object:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，使用*中缀函数*创建了一个`pair`实例，这将在[第4章](text00088.html) *类和对象*中讨论，但现在我们只需要知道这两个声明返回相同类型的`Pair`对象：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Type inference works also for more complex scenarios such as inferring type
    from inferred type. Let''s use the Kotlin standard library''s `mapOf` function
    and infix the `to` method of the `Pair` class to define `map` . The first item
    in the pair will be used to infer the `map` key type; the second will be used
    to infer the value type:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断也适用于更复杂的情况，例如从推断类型中推断类型。让我们使用Kotlin标准库的`mapOf`函数，并将`Pair`类的`to`方法中缀到定义`map`。对中的第一项将用于推断`map`键类型；第二项将用于推断值类型：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Generic type of `Map<String, Int>` is inferred from type of `Pair<String, Int>`
    , which is inferred from type of parameters passed to `Pair` constructor. We may
    wonder what happens if inferred type of pairs used to create `map` differs? The
    first pair is `Pair<String, Int>` and second is `Pair<String, String>` :'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map<String, Int>`的泛型类型是从传递给`Pair`构造函数的参数的类型推断出来的。我们可能会想知道，如果用于创建`map`的推断类型的对不同会发生什么？第一对是`Pair<String,
    Int>`，第二对是`Pair<String, String>`：'
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding scenario, Kotlin compiler will try to infer common type for
    all pairs. First parameter in both pairs is `String` (`Mount Everest` , `K2` ),
    so naturally `String` will be inferred here. Second parameter of each pair differs
    (`Int` for first pair, `String` for second pair), so Kotlin needs to find the
    closest common type. The `Any` type is chosen, because this is the closest common
    type in upstream type hierarchy:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情景中，Kotlin编译器将尝试为所有对推断出一个公共类型。两对中的第一个参数都是`String`（`Mount Everest`，`K2`），因此在这里自然会推断出`String`。每对的第二个参数不同（第一对为`Int`，第二对为`String`），因此Kotlin需要找到最接近的公共类型。选择`Any`类型，因为这是上游类型层次结构中最接近的公共类型：
- en: '![](img/Image00023.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00023.jpg)'
- en: 'As we can see, type inference does a great job in most cases, but we can still
    choose to explicitly define a data type if we want, for example, we want different
    variable types:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，类型推断在大多数情况下都做得很好，但是我们仍然可以选择显式定义数据类型，例如，我们想要不同的变量类型：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When dealing with integers, the `Int` type is always a default choice, but
    we can still explicitly define different types, for example, `Short` *,* to save
    some precious Android memory:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理整数时，`Int`类型总是默认选择，但是我们仍然可以显式定义不同的类型，例如，`Short`，以节省一些宝贵的Android内存：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'On the other hand, if we need to store larger values, we can define the type
    of the `age` variable as `Long` . We can use explicit type declaration as previously,
    or use *literal constant* :'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们需要存储更大的值，我们可以将`age`变量的类型定义为`Long`。我们可以像以前一样使用显式类型声明，也可以使用*字面常量*：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Those two declarations are equal, and all of them will create variable of type
    `Long` .
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个声明是相等的，它们都将创建类型为`Long`的变量。
- en: 'For now, we know that there are more cases in code where type declaration can
    be omitted to make code syntax more concise. There are however some situations
    where the Kotlin compiler will not be able to infer type due to lack of information
    in context. For example, simple declaration without assignment will make type
    inference impossible:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们知道代码中有更多情况可以省略类型声明，以使代码语法更简洁。然而，有些情况下，由于上下文中缺乏信息，Kotlin编译器将无法推断类型。例如，简单的声明而没有赋值将使类型推断变得不可能：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding example, the variable will be initialized later, so there is
    no way to determine its type. That's why type must be explicitly specified. The
    general rule is that if type of expression is known for the compiler, then type
    can be inferred. Otherwise, it must be explicitly specified. Kotlin plugin in
    Android Studio does a great job because it knows exactly where type cannot be
    inferred and then it is highlighting error. This allows us to display proper error
    messages instantly by IDE when writing the code without the need to complete application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，变量将在稍后初始化，因此无法确定其类型。这就是为什么类型必须明确指定的原因。一般规则是，如果编译器知道表达式的类型，则可以推断类型。否则，必须明确指定。Android
    Studio中的Kotlin插件做得很好，因为它确切地知道类型无法推断的地方，然后会突出显示错误。这使我们能够在编写代码时立即通过IDE显示正确的错误消息，而无需完成应用程序。
- en: Strict null safety
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 严格的空安全
- en: According to **Agile Software Assessment** *(* [http://p3.snf.ch/Project-144126](http://p3.snf.ch/Project-144126)
    *)* research, missing null check is the most frequent pattern of bugs in Java
    systems. The biggest source of errors in Java is `NullPointerExceptions` . It's
    so big, that speaking at a conference in 2009, Sir Tony Hoare apologized for inventing
    the null reference, calling it a *billion-dollar mistake* ([https://en.wikipedia.org/wiki/Tony_Hoare](https://en.wikipedia.org/wiki/Tony_Hoare)
    ).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 根据**敏捷软件评估**（* [http://p3.snf.ch/Project-144126](http://p3.snf.ch/Project-144126)
    *）研究，缺少空检查是Java系统中最常见的错误模式。Java中错误的最大来源是`NullPointerExceptions`。它如此之大，以至于2009年在一次会议上，Tony
    Hoare爵士为发明空引用而道歉，称其为*十亿美元的错误*（[https://en.wikipedia.org/wiki/Tony_Hoare](https://en.wikipedia.org/wiki/Tony_Hoare)）。
- en: To avoid `NullPointerException` , we need to write defensive code that checks
    if an object is null before using it. Many modern programming languages, including
    Kotlin, made steps to convert runtime errors into compile time errors to improve
    programming language safeness. One of the way to do it in Kotlin is by adding
    *nullability safeness mechanisms* to language type systems. This is possible because
    Kotlin type system distinguishes between references that can hold null (nullable
    references) and those that cannot (non-nullable references). This single feature
    of Kotlin allows us to detect many errors related to `NullPointerException` at
    very early stages of development. Compiler together with IDE will prevent many
    `NullPointerException` . In many cases compilation will fail instead of application
    failing at runtime.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免`NullPointerException`，我们需要编写防御性代码，在使用对象之前检查它是否为null。许多现代编程语言，包括Kotlin，都采取了将运行时错误转换为编译时错误的步骤，以提高编程语言的安全性。在Kotlin中实现这一点的一种方法是向语言类型系统添加*空安全机制*。这是可能的，因为Kotlin类型系统区分可以保存null（可空引用）和不可以保存null（非空引用）的引用。Kotlin的这一单一特性使我们能够在开发的早期阶段检测到许多与`NullPointerException`相关的错误。编译器和IDE将阻止许多`NullPointerException`。在许多情况下，编译将失败，而不是应用程序在运行时失败。
- en: 'Strict null safety is part of Kotlin type system. By default, regular types
    cannot be null (can''t store null references), unless they are explicitly allowed.
    To store null references, we must mark variable as nullable (allow it to store
    null references) by adding question mark suffix to variable type declaration.
    Here is an example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 严格的空安全是 Kotlin 类型系统的一部分。默认情况下，常规类型不能为 null（不能存储 null 引用），除非明确允许。要存储 null 引用，我们必须将变量标记为可空（允许存储
    null 引用），方法是在变量类型声明中添加问号后缀。这是一个例子：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compiler will throw error, because this type does not allow null.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器会抛出错误，因为这种类型不允许为 null。
- en: Compiler will allow null assignment, because type is marked as nullable using
    question mark suffix.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器将允许空赋值，因为类型使用问号后缀标记为可空。
- en: 'We are not allowed to call method on a potentially nullable object, unless
    a nullity check is performed before a call:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不允许在可能为 null 的对象上调用方法，除非在调用之前执行了空值检查：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will learn how to deal with the problem in the next section. Every non-nullable
    type in Kotlin has its nullable type equivalent: `Int` has `Int?` , `String` has
    `String?` and so on. The same rule applies for all classes in the Android framework
    (`View` has `View?` ), third-party libraries (`OkHttpClient` has `OkHttpClient?`
    ), and all custom classes defined by developers (`MyCustomClass` has `MyCustomClass?`
    ). This means that every non generic class can be used to define two kinds of
    types, nullable and non-nullable. A non-nullable type is also a subtype of its
    nullable equivalent. For example, `Vehicle` , as well as being a subtype of `Vehicle?`
    , is also a subtype of `Any` *:*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节学习如何处理这个问题。Kotlin 中的每种非空类型都有其对应的可空类型：`Int` 对应 `Int?`，`String` 对应 `String?`
    等等。相同的规则也适用于 Android 框架中的所有类（`View` 对应 `View?`），第三方库（`OkHttpClient` 对应 `OkHttpClient?`），以及开发人员定义的所有自定义类（`MyCustomClass`
    对应 `MyCustomClass?`）。这意味着每个非泛型类都可以用来定义两种类型，可空和非空。非空类型也是其可空对应类型的子类型。例如，`Vehicle`
    除了是 `Vehicle?` 的子类型外，也是 `Any` 的子类型：
- en: '![](img/Image00024.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00024.jpg)'
- en: 'The `Nothing` type is an empty type (uninhabited type), which can''t have an
    instance. We will discuss it in more details in [Chapter 3](text00073.html) ,
    *Playing with Functions* . This type hierarchy is the reason why we can assign
    non-null object (`Vehicle` *)* into a variable typed as nullable (`Vehicle?` *)*
    , but we cannot assign a nullable object (`Vehicle?` *)* into a non-null variable
    (`Vehicle` ):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nothing` 类型是一个空类型（无法实例化的类型），它不能有实例。我们将在 [第 3 章](text00073.html) *Playing with
    Functions* 中详细讨论它。这种类型层次结构是为什么我们可以将非空对象（`Vehicle`）赋值给可空类型的变量（`Vehicle?`），但不能将可空对象（`Vehicle?`）赋值给非空变量（`Vehicle`）的原因：'
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Assignment possible
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以进行赋值
- en: Error because `nullableVehicle` may be a null
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误，因为 `nullableVehicle` 可能为 null
- en: 'We will discuss ways of dealing with nullable types in following sections.
    Now let''s get back to type definitions. When defining *generic types* , there
    are multiple possibilities of defining nullability, so let''s examine various
    collection types by comparing different declarations for generic `ArrayList` containing
    items of type `Int` . Here is a table that is presents the key differences:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中讨论处理可空类型的方法。现在让我们回到类型定义。在定义 *泛型类型* 时，有多种定义可空性的可能性，因此让我们通过比较包含类型为
    `Int` 的泛型 `ArrayList` 的不同声明来检查各种集合类型。下面是一个表格，展示了关键的区别：
- en: '| **Type declaration** | **List itself can be null** | **Element can be null**
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **类型声明** | **列表本身可以为 null** | **元素可以为 null** |'
- en: '| `ArrayList<Int>` | No | No |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `ArrayList<Int>` | 否 | 否 |'
- en: '| `ArrayList<Int>?` | Yes | No |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `ArrayList<Int>?` | 是 | 否 |'
- en: '| `ArrayList<Int?>` | No | Yes |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `ArrayList<Int?>` | 否 | 是 |'
- en: '| `ArrayList<Int?>?` | Yes | Yes |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `ArrayList<Int?>?` | 是 | 是 |'
- en: 'It''s important to understand different ways to specify null type declarations,
    because Kotlin compiler enforces it to avoid `NullPointerExceptions` . This means
    that compiler enforces nullity check before accessing any reference that potentially
    can be null. Now let''s examine common Android/Java error in the `Activity` class''
    `onCreate` method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 理解不同的空类型声明方式很重要，因为 Kotlin 编译器强制执行它以避免 `NullPointerException`。这意味着编译器在访问任何可能为
    null 的引用之前强制执行空值检查。现在让我们来看看 `Activity` 类的 `onCreate` 方法中常见的 Android/Java 错误：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In Java, this code will compile fine and accessing null objects will result
    in application crash at runtime throwing `NullPointerException` . Now let''s examine
    the Kotlin version of the same method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，这段代码将编译正常，访问 null 对象将导致应用在运行时崩溃并抛出 `NullPointerException`。现在让我们来看看相同方法的
    Kotlin 版本：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`savedInstanceState` defined as nullable `Bundle?`'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`savedInstanceState` 定义为可空的 `Bundle?`'
- en: Compiler will throw error
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译器会抛出错误
- en: '*The* `savedInstanceState` type is a platform type that can be interpreted
    by Kotlin as nullable or non-nullable. We will discuss platform types in the following
    sections, but for now we will define `savedInstanceState` as nullable type. We
    are doing so, because we know that `null` will be passed when Activity is created
    for the first time. Instance of `Bundle` will only be passed when an Activity
    is recreated using saved instance state:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`savedInstanceState` 类型是一个平台类型，Kotlin 可以将其解释为可空或非空。我们将在接下来的章节中讨论平台类型，但现在我们将定义
    `savedInstanceState` 为可空类型。我们这样做是因为我们知道在创建 Activity 时会传递 `null`。只有在使用保存的实例状态重新创建
    Activity 时才会传递 `Bundle` 的实例：'
- en: We will discuss functions in [Chapter 3](text00073.html) *, Playing with Functions*
    , but for now, we can already see that the syntax for declaring functions in Kotlin
    is quite similar to Java.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 3 章](text00073.html) *Playing with Functions* 中讨论函数，但现在我们已经可以看到，在 Kotlin
    中声明函数的语法与 Java 非常相似。
- en: 'The most obvious way to fix the preceding error in Kotlin is to check for nullity
    exactly the same way as in Java:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中修复上述错误的最明显的方法是以与 Java 相同的方式检查空值：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding construct presents some boilerplate code, because null-checking
    is a pretty common operation in Java development (especially in the Android framework,
    where most elements are nullable). Fortunately, Kotlin allows a few simpler solutions
    to deal with nullable variables. The first one is the *safe call* operator.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的结构呈现了一些样板代码，因为在Java开发中进行空检查是一种非常常见的操作（特别是在Android框架中，其中大多数元素都是可空的）。幸运的是，Kotlin允许使用一些更简单的解决方案来处理可空变量。第一个是*安全调用*运算符。
- en: Safe call
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全调用
- en: 'The safe call operator is simply a question mark followed by a dot. It''s important
    to understand that safe cast operator will always return a value. If the left-hand
    side of the operator is null, then it will return null, otherwise it will return
    the result of the right-hand side expression:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 安全调用运算符只是一个问号后跟一个点。重要的是要理解，安全转换运算符将始终返回一个值。如果运算符的左侧为null，则它将返回null，否则将返回右侧表达式的结果：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If `savedInstanceState` is `null` *,* then `null` will be returned, otherwise
    the result of evaluating a `savedInstanceState?.getBoolean("locked")` expression
    will be returned. Keep in mind, that a nullable reference call may always returns
    nullable, so the result of the whole expression is nullable `Boolean*?*` . If
    we want to make sure we will get non-nullable Boolean, we can combine the *safe
    call* operator combined with the *elvis* operator, discussed in the next section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`savedInstanceState`是`null`，那么将返回`null`，否则将返回评估`savedInstanceState?.getBoolean("locked")`表达式的结果。请记住，可空引用调用可能始终返回可空值，因此整个表达式的结果是可空`Boolean*?*`。如果我们想确保获得非空布尔值，我们可以结合*安全调用*运算符和*Elvis*运算符，在下一节中讨论。
- en: 'Multiple calls of the *save call* operator can be chained together to avoid
    a nested `if` expression or complex conditions like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将*安全调用*运算符的多个调用链接在一起，以避免嵌套的`if`表达式或像这样的复杂条件：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding chain works like this--`correct` will be accessed only if the
    `answer` value is not null and `answer` is accessed only if the `currentQuestion`
    value is not null. As a result, the expression will return the value returned
    by `correct property` or null if any object in the safe call chain is null.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的链的工作方式如下--只有在`answer`值不为null时才会访问`correct`，只有在`currentQuestion`值不为null时才会访问`answer`。结果，该表达式将返回`correct`属性返回的值，或者如果*安全调用*链中的任何对象为null，则返回null。
- en: Elvis operator
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elvis运算符
- en: 'The elvis operator is represented by a question mark followed by a colon (`?:`
    ) and has such syntax:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Elvis运算符由问号后跟冒号（`?:`）表示，并具有以下语法：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The elvis operator works as follows: if `first operand` is not null, then this
    operand will be returned, otherwise `second operand` will be returned. The elvis
    operator allows us to write very concise code.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Elvis运算符的工作方式如下：如果`第一个操作数`不为null，则将返回该操作数，否则将返回`第二个操作数`。Elvis运算符允许我们编写非常简洁的代码。
- en: 'We can apply the elvis operator to our example to retrieve the variable `locked`
    *,* which will be always non-nullable:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将Elvis运算符应用于我们的示例，以检索变量`locked`，这将始终是非空的：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the preceding example, the elvis operator will return value of `savedInstanceState?.getBoolean("locked")`
    expression if `savedInstanceState` is not null, otherwise it will return false.
    This way we can make sure that the `locked` variable. Thanks to elvis operator
    we can define default value. Also note that the right-hand side expression is
    evaluated only if the left-hand side is null. It is then providing default value
    that will be used when the expression is nullable. Getting back to our quiz example
    from the previous section, we can easily modify the code to always return a non-nullable
    value:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果`savedInstanceState`不为`null`，Elvis运算符将返回`savedInstanceState?.getBoolean("locked")`表达式的值，否则将返回false。这样我们可以确保`locked`变量。借助Elvis运算符，我们可以定义默认值。还要注意，只有在左侧为null时才会评估右侧表达式。然后提供将在表达式为可空时使用的默认值。回到上一节的测验示例，我们可以轻松修改代码以始终返回非空值：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As the result, the expression will return the value returned by the `correct`
    property or `false` if any object in the *safe call* chain is null. This means
    that the value will always be returned, so non-nullable Boolean type is inferred.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，该表达式将返回`correct`属性返回的值，或者如果*安全调用*链中的任何对象为null，则返回`false`。这意味着该值将始终被返回，因此推断出非空布尔类型。
- en: The operator name comes from the famous American singer-songwriter Elvis Presley,
    because his hairstyle is similar to a question mark.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该运算符的名称来自著名的美国歌手兼词曲作家埃尔维斯·普雷斯利，因为他的发型类似于问号。
- en: '![](img/Image00025.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00025.jpg)'
- en: Not null assertion
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非空断言
- en: 'Another tool to deal with nullity is the *not-null assertion* operator. It
    is represented by a double exclamation mark (`!!` ). This operator explicitly
    casts nullable variables to non-nullable variables. Here is a usage example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 处理空值的另一个工具是*非空断言*运算符。它由双感叹号（`!!`）表示。该运算符将可空变量显式转换为非空变量。以下是一个使用示例：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Normally, we would not be able to assign a value from a nullable property `length`
    to a non-nullable variable size*.* However, as a developer, we can assure the
    compiler that this nullable variable will have a value here. If we are right,
    our application will work correctly, but if we are wrong, and the variable has
    a null value, the application will throw `NullPointerException` . Let''s examine
    our activity method `onCreate()` :'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们无法将可空属性`length`的值分配给非空变量`size`。但是，作为开发人员，我们可以向编译器保证，这个可空变量在这里将有一个值。如果我们是对的，我们的应用程序将正常工作，但如果我们错了，并且变量具有空值，应用程序将抛出`NullPointerException`。让我们检查一下我们的活动方法`onCreate()`：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code will compile, but will this code work correctly? As we said
    before, when restoring an activity instance, `savedInstanceState` will be passed
    to the `onCreate` method, so this code will work without exceptions. However,
    when creating an activity instance, the `savedInstanceState` will be null (there
    is no previous instance to restore), so `NullPointerException` will be thrown
    at runtime. This behavior is similar to Java, but the main difference is that
    in Java accessing potentially nullable objects without a nullity check is the
    default behavior, while in Kotlin we have to force it; otherwise, we will get
    a compilation error.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将编译，但这段代码会正确工作吗？正如我们之前所说的，当恢复活动实例时，`savedInstanceState`将被传递给`onCreate`方法，因此这段代码将在没有异常的情况下工作。然而，在创建活动实例时，`savedInstanceState`将为空（没有以前的实例可以恢复），因此将在运行时抛出`NullPointerException`。这种行为类似于Java，但主要区别在于在Java中，访问潜在可空对象而不进行空值检查是默认行为，而在Kotlin中，我们必须强制进行；否则，我们将得到编译错误。
- en: There are only few correct possible applications for usage of this operator,
    so when you use it or see it in code, think about it as potential danger or warning.
    It is suggested that not-null assertion should be used rarely, and in most cases
    should be replaced with safe call or smart cast.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符只有少数正确的可能应用场景，所以当你使用它或在代码中看到它时，要考虑它可能存在的危险或警告。建议很少使用非空断言，并且在大多数情况下应该用安全调用或智能转换来替代。
- en: Combating non-null assertions article presents few useful examples where non-null
    assertion operator is replaced with other, safe Kotlin constructs at [http://bit.ly/2xg5JXt](http://bit.ly/2xg5JXt)
    .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对抗非空断言文章提供了一些有用的例子，其中非空断言运算符被其他安全的Kotlin构造替换，网址为[http://bit.ly/2xg5JXt](http://bit.ly/2xg5JXt)。
- en: Actually in this case there is no point of using not-null assertion operator
    because we can solve our problem in safer way using let.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在这种情况下，使用非空断言运算符是没有意义的，因为我们可以使用`let`以更安全的方式解决我们的问题。
- en: Let
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让
- en: 'Another tool to deal with nullable variables is `let` . This is actually not
    the operator, nor the language special construct. It is a function defined in
    the Kotlin standard library. Let''s see the syntax of `let` combined with the
    *safe call* operator:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 处理可空变量的另一个工具是`let`。这实际上不是运算符，也不是语言的特殊构造。它是在Kotlin标准库中定义的一个函数。让我们看看`let`与*安全调用*运算符结合的语法：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`savedInstanceState` inside let can be accessed using variable'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`let`中的`savedInstanceState`可以使用变量访问'
- en: named it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 命名它。
- en: As mentioned before, the right-hand side expression of the safe call operator
    will be only be evaluated if the left-hand side is not null. In this case, the
    right-hand side is a `let` function that takes another function (lambda) as a
    parameter. Code defined in the block after `let` will be executed if `savedInstanceState`
    is not null. We will learn more about it and how to define such functions later
    in [Chapter 7](text00171.html) , *Extension Functions and Properties* .
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，安全调用运算符的右侧表达式只有在左侧不为空时才会被评估。在这种情况下，右侧是一个接受另一个函数（lambda）作为参数的`let`函数。如果`savedInstanceState`不为空，则将执行`let`后面的代码块。我们将在[第7章](text00171.html)中学习更多关于它以及如何定义这样的函数，*扩展函数和属性*。
- en: Nullability and Java
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空值和Java
- en: We know that Kotlin requires to explicitly define references that can hold null
    values. Java on the other hand, is much more lenient about nullability, so we
    may wonder how Kotlin handles types coming from Java (basically the whole Android
    SDK and libraries written in Java). Whenever possible, Kotlin compiler will determine
    type nullability from the code and represent types as actual nullable or non-nullable
    types using nullability annotations.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道Kotlin要求明确定义可以保存空值的引用。另一方面，Java对空值的处理更为宽松，因此我们可能会想知道Kotlin如何处理来自Java的类型（基本上是整个Android
    SDK和用Java编写的库）。在可能的情况下，Kotlin编译器将从代码中确定类型的空值，并使用空值注解将类型表示为实际的可空或非可空类型。
- en: 'The Kotlin compiler supports several flavors of nullability annotations, including:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin编译器支持多种空值注解，包括：
- en: Android (`com.android.annotations` and `android.support.annotations` )
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android (`com.android.annotations`和`android.support.annotations`)
- en: JetBrains (`@Nullable` and `@NotNull` from the `org.jetbrains.annotations` package)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetBrains (`@Nullable`和`@NotNull`来自`org.jetbrains.annotations`包)
- en: JSR-305 (`Javax.annotation` )
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSR-305 (`Javax.annotation` )
- en: We can find the full list in the Kotlin compiler source code ([https://github.com/JetBrains/kotlin/blob/master/core/descriptor.loader.Java/src/org/jetbrains/kotlin/load/Java/JvmAnnotationNames.kt](https://github.com/JetBrains/kotlin/blob/master/core/descriptor.loader.Java/src/org/jetbrains/kotlin/load/Java/JvmAnnotationNames.kt)
    )
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Kotlin编译器源代码中找到完整的列表([https://github.com/JetBrains/kotlin/blob/master/core/descriptor.loader.Java/src/org/jetbrains/kotlin/load/Java/JvmAnnotationNames.kt](https://github.com/JetBrains/kotlin/blob/master/core/descriptor.loader.Java/src/org/jetbrains/kotlin/load/Java/JvmAnnotationNames.kt))
- en: 'We have seen this previously in Activity''s `onCreate` method, where the `savedInstanceState`
    type was explicitly set to the nullable type `Bundle?` :'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在Activity的`onCreate`方法中看到过这一点，其中`savedInstanceState`的类型被明确设置为可空类型`Bundle?`：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are, however, many situations where it is not possible to determine variable
    nullability. All variables coming from Java can be null except ones annotated
    as non-nullable.. We could treat all of them as nullable and check before each
    access, but this would be impractical. As a solution for this problem, Kotlin
    introduced the concept of *platform types.* Those are types coming from Java types
    with relaxed null checks, meaning that each platform type may be null or not.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有许多情况下无法确定变量的空值。所有来自Java的变量都可以为空，除非标记为非可空。我们可以将它们全部视为可空，并在每次访问之前进行检查，但这是不切实际的。作为这个问题的解决方案，Kotlin引入了*平台类型*的概念。这些是来自Java类型的类型，具有放松的空值检查，这意味着每个平台类型可能是空或非空。
- en: 'Although we cannot declare platform types by ourselves, this special syntax
    exists because the compiler and Android Studio need to display them sometimes.
    We can spot platform types in exception messages or the method parameters list.
    Platform type syntax is just a single exclamation mark suffix in a variable type
    declaration:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不能自己声明平台类型，但这种特殊的语法存在是因为编译器和Android Studio有时需要显示它们。我们可以在异常消息或方法参数列表中发现平台类型。平台类型语法只是在变量类型声明中的一个感叹号后缀：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We could treat each platform type as nullable, but type nullability usually
    depends on context, so sometimes we can treat them as non-nullable variables.
    This pseudo code shows the possible meaning of platform type:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将每种平台类型视为可空的，但类型的可空性通常取决于上下文，因此有时我们可以将它们视为不可空的变量。这个伪代码展示了平台类型的可能含义：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It''s our responsibility as developers to decide how to treat such type, as
    nullable or non-nullable. Let''s consider the usage of the `findViewById` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们有责任决定如何处理这种类型，是可空的还是非可空的。让我们考虑一下`findViewById`方法的用法：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: What will the `findViewById` method actually return? What is the inferred type
    of the `textView` variable? Nullable type (`TestView` ) or not nullable (`TextView?`
    *)* ? By default, the Kotlin compiler knows nothing about the nullability of the
    value returned by the `findViewById` method. This is why inferred type for `TextView`
    has platform type `View!` .
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`findViewById`方法实际上会返回什么？`textView`变量的推断类型是什么？可空类型（`TestView`）还是非可空类型（`TextView?`）？默认情况下，Kotlin编译器对`findViewById`方法返回的值的可空性一无所知。这就是为什么`TextView`的推断类型具有平台类型`View!`。'
- en: 'This is the kind of developer responsibility that we are talking about. We,
    as developers, must decide, because only we know if the layout will have `textView`
    defined in all configurations (portrait, landscape, and so on) or only in some
    of them. If we define proper view inside current layout `findViewById` method
    will return reference to this view, and otherwise it will return null:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的开发者责任。作为开发者，我们必须决定，因为只有我们知道布局是否在所有配置（纵向、横向等）中定义了`textView`，还是只在其中一些配置中定义了。如果我们在当前布局中定义了适当的视图，`findViewById`方法将返回对该视图的引用，否则将返回null：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Assuming that `textView` is present in every layout for each configuration,
    so `textView` can be defined as non-nullable
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`textView`在每个配置的每个布局中都存在，因此`textView`可以定义为非可空的。
- en: Assuming that `textView` is not present in all layout configurations (for example,
    present only in landscape), `textView` must be defined as nullable, otherwise
    the application will throw a `NullPointerException` when trying to assign null
    to a non-nullable variable (when layout without `textView` is loaded)
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设`textView`在所有布局配置中都不存在（例如，只在横向布局中存在），则`textView`必须定义为可空的，否则当加载没有`textView`的布局时，应用程序将抛出`NullPointerException`。
- en: Casts
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: The casting concept is supported by many programming languages. Basically, casting
    is a way to convert an object of one particular type into another type. In Java,
    we need to cast an object explicitly before accessing its members or cast it and
    store it in the variable of the casted type. Kotlin simplifies concept of casting
    and moves it to the next level by introducing *smart casts* .
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 转换概念得到了许多编程语言的支持。基本上，转换是将一个特定类型的对象转换为另一种类型的方法。在Java中，我们需要在访问其成员之前显式地转换对象，或者将其转换并将其存储在转换后的类型的变量中。Kotlin简化了转换的概念，并通过引入*智能转换*将其提升到了下一个级别。
- en: 'In Kotlin, we can perform a few types of casts:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们可以执行几种类型的转换：
- en: Cast objects to different types explicitly (*safe cast* operator)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式地将对象转换为不同类型（*安全转换*操作符）
- en: Cast objects to different types or nullable types to non-nullable types implicitly
    (*smart cast* mechanism)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将对象隐式地转换为不同类型或可空类型转换为非可空类型（*智能转换*机制）
- en: Safe/unsafe cast operator
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全/不安全转换操作符
- en: 'In strongly typed languages, such as Java or Kotlin, we need to convert values
    from one type to another explicitly using the cast operator. A typical casting
    operation is taking an object of one particular type and turning it into another
    object type that is its supertype (upcasting), subtype (downcasting), or interface.
    Let''s start with a small remainder of casting that could be performed in Java:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java或Kotlin等强类型语言中，我们需要使用转换操作符将一个类型的值显式地转换为另一个类型。典型的转换操作是将一个特定类型的对象转换为其超类型（向上转换）、子类型（向下转换）或接口的另一个对象类型。让我们从Java中可以执行的转换的小提示开始：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding example, there is an instance of `ProductFragment` that is
    assigned to a variable storing `Fragment` data type. To be able to store this
    data into the `productFragment` variable that can store only the `ProductFragment`
    data type, so we need to perform an explicit cast. Unlike Java, Kotlin has a special
    `as` keyword representing the *unsafe cast* operator to handle casting:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，有一个`ProductFragment`的实例被分配给存储`Fragment`数据类型的变量。为了能够将这些数据存储到只能存储`ProductFragment`数据类型的`productFragment`变量中，我们需要执行显式转换。与Java不同，Kotlin有一个特殊的`as`关键字，表示*不安全转换*操作符来处理转换：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `ProductFragment` variable is a subtype of `Fragment` , so the preceding
    example will work fine. The problem is that casting to an incompatible type will
    throw the exception `ClassCastException` . That''s why the `as` operator is called
    an unsafe cast operator:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductFragment`变量是`Fragment`的子类型，所以上面的例子将正常工作。问题在于将不兼容的类型转换为另一种类型会抛出异常`ClassCastException`。这就是为什么`as`操作符被称为不安全的转换操作符：'
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To fix this problem, we can use the *safe cast* operator `as?` *.* It is sometimes
    called the **nullable cast** operator. This operator tries to cast a value to
    the specified type, and returns null if the value cannot be casted. Here is an
    example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用*安全转换*操作符`as?`。有时它被称为**可空转换**操作符。该操作符尝试将一个值转换为指定的类型，并在无法转换值时返回null。这是一个例子：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Notice, that usage of the *safe cast* operator requires us to define the `name`
    variable as nullable (`ProductFragment?` instead of `ProductFragment` ). As an
    alternative, we can use the *unsafe cast* operator and nullable type `ProductFragment?`
    , so we can see exactly the type that we are casting to:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用安全转换操作符要求我们将`name`变量定义为可空的（`ProductFragment?`而不是`ProductFragment`）。作为替代，我们可以使用不安全转换操作符和可空类型`ProductFragment?`，这样我们就可以确切地看到我们要转换为的类型：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we would like to have a `productFragment` variable that is non-nullable,
    then we would have to assign a default value using the elvis operator:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个非空的`productFragment`变量，那么我们必须使用Elvis操作符分配一个默认值：
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, the `fragment as? ProductFragment` expression will be evaluated without
    a single error. If this expression returns a non-nullable value (the cast can
    be performed), then this value will be assigned to the `productFragment` variable,
    otherwise a default value (the new instance of `ProductFragment` ) will be assigned
    to the `productFragment` variable. Here is a comparison between these two operators:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`fragment as? ProductFragment`表达式将在没有任何错误的情况下进行评估。如果此表达式返回一个非空值（可以执行转换），则该值将分配给`productFragment`变量，否则将为`productFragment`变量分配一个默认值（`ProductFragment`的新实例）。以下是这两个操作符之间的比较：
- en: 'Unsafe cast `(as)` : Throws `ClassCastException` when casting is impossible'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全转换（`as`）：在转换不可能时抛出`ClassCastException`
- en: 'Safe cast `(as?)` : Returns null when casting impossible'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全转换（`as?`）：在转换不可能时返回null
- en: 'Now, when we understand the difference between *safe cast* and *unsafe cast*
    operators, we can safely retrieve a fragment from the fragment manager:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们了解了安全转换和不安全转换操作符之间的区别，我们可以安全地从片段管理器中检索片段：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The *safe cast* and *unsafe cast* operators are used for casting complex objects.
    When working with primitive types, we can simply use one of the Kotlin standard
    library conversion methods. Most of the objects from the Kotlin standard library
    have standard methods used to simplify common casting to other types. The convention
    is that this kind of functions have prefix to, and the name of the class that
    we want to cast to. In the line in this example, the `Int` type is casted to the
    `String` type using the `toString` method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 安全转换和不安全转换操作符用于转换复杂对象。在使用原始类型时，我们可以简单地使用Kotlin标准库的转换方法之一。Kotlin标准库中的大多数对象都有用于简化常见类型转换的标准方法。约定是这种类型的函数具有前缀to，并且我们要转换为的类的名称。在此示例中，`Int`类型使用`toString`方法转换为`String`类型：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will discuss *primitive types* and their conversions in the primitive data
    types section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在原始数据类型部分讨论原始类型及其转换。
- en: Smart casts
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能转换
- en: '**Smart casting** converts variable of one type to another type, but as opposed
    to safe casting*,* it is done implicitly (we don''t need to use the `as` or `as?`
    cast operator). Smart casts work only when the Kotlin compiler is absolutely sure
    that the variable will not be changed after check. This makes them perfectly safe
    for multithreaded applications. Generally smart casts are available for all immutable
    references (`val` ) and for local mutable references (`var` ). We have two kinds
    of *smart casts* :'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 智能转换将一个类型的变量转换为另一个类型，但与安全转换相反，它是隐式完成的（我们不需要使用`as`或`as?`转换操作符）。智能转换仅在Kotlin编译器绝对确定变量在检查后不会被更改时才有效。这使它们非常适用于多线程应用程序。通常，智能转换适用于所有不可变引用（`val`）和本地可变引用（`var`）。我们有两种智能转换：
- en: Type *smart cast* that cast objects of one type to an object of another type
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型智能转换将一个类型的对象转换为另一个类型的对象
- en: Nullity *smart cast* that cast nullable references to non-nullable
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可空引用转换为非空引用的空值智能转换
- en: Type smart casts
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型智能转换
- en: 'Let''s represent the `Animal` and `Fish` class from the previous section:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们表示上一节中的`Animal`和`Fish`类：
- en: '![](img/Image00026.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00026.jpg)'
- en: 'Let''s assume we want to call the `isHungry` method and we want to check if
    the `animal` is an instance of `Fish` . In Java we would have to do something
    like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想调用`isHungry`方法，并且我们想检查`animal`是否是`Fish`的实例。在Java中，我们必须这样做：
- en: '[PRE45]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The problem with this code is its redundancy. We have to check if `animal`
    instance is `Fish` and then we have to explicitly cast `animal` to `Fish` after
    this check*.* Wouldn''t it be nice if compiler could handle this for us? It turns
    out that the Kotlin compiler is really smart when it comes to casts, so it will
    handle all those redundant casts for us, using the *smart casts* mechanism. Here
    is an example of smart casting:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的问题在于它的冗余性。我们必须检查`animal`实例是否为`Fish`，然后在此检查后明确将`animal`转换为`Fish`。如果编译器能够为我们处理这些冗余的转换，那不是很好吗？事实证明，当涉及到转换时，Kotlin编译器确实很聪明，因此它将使用智能转换机制为我们处理所有这些冗余的转换。这是智能转换的一个例子：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Smart cast in Android Studio**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio中的智能转换
- en: Android Studio will display proper errors if smart casting is not possible,
    so we will know exactly if we can use it. Android Studio marks variables with
    green background when we access a member that required a cast.![](img/Image00027.jpg)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果智能转换不可能，Android Studio将显示适当的错误，因此我们将确切知道是否可以使用它。当我们访问需要转换的成员时，Android Studio会用绿色背景标记变量。![](img/Image00027.jpg)
- en: 'In Kotlin, we don''t have to explicitly cast an `animal` instance to a `Fish`
    , because after the type check, Kotlin compiler will be able to handle casts implicitly.
    Now inside the `if` block, the variable animal is casted to `Fish` . The result
    is then exactly the same as in previous Java example (the Java instance of the
    operator is called is in Kotlin). This is why we can safely call the `isHungry`
    method without any explicit casting. Notice, that in this case, the scope of this
    *smart cast* is limited by the `if` block:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们不必显式将`animal`实例转换为`Fish`，因为在类型检查后，Kotlin编译器将能够隐式处理转换。现在，在`if`块内，变量`animal`被转换为`Fish`。结果与前面的Java示例完全相同（Kotlin中调用操作符的实例与Java中相同）。因此，我们可以安全地调用`isHungry`方法，而无需进行任何显式转换。请注意，在这种情况下，此智能转换的范围受到`if`块的限制：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In this context animal instance is Fish, so we can call `isHungry` method.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，animal实例是Fish，所以我们可以调用`isHungry`方法。
- en: In this context animal instance is still Animal, so we can't call `isHungry`
    method.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，animal实例仍然是Animal，所以我们无法调用`isHungry`方法。
- en: 'There are, however, other cases where the smart cast scope is larger than a
    single block, as like in the following example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有其他情况，智能转换范围大于单个块，就像以下示例中一样：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: From this point, animal will be implicitly converted to non- nullable Fish
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这一点开始，animal将被隐式转换为非空Fish
- en: In the preceding example, the whole method would return from function if `animal`
    is not `Fish` , so the compiler knows that `animal` must be a `Fish` across the
    rest of the code block. Kotlin and Java conditional expressions are evaluated
    lazily.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，如果`animal`不是`Fish`，整个方法将从函数返回，因此编译器知道`animal`在代码块的其余部分必须是`Fish`。Kotlin和Java条件表达式是惰性求值的。
- en: 'It means that in expression `condition1() && condition2()` , method `condition2`
    will be called only when `condition1` returns `true` . This is why we can use
    a *smart casted* type in the right-hand side of the conditional expression:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在表达式`condition1() && condition2()`中，只有当`condition1`返回`true`时才会调用方法`condition2`。这就是为什么我们可以在条件表达式的右侧使用*智能转换*类型：
- en: '[PRE49]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that if the `animal` was not a `Fish` , the second part of the conditional
    expression would not be evaluated at all. When it is evaluated, Kotlin knows that
    `animal` is a `Fish` (smart cast).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果`animal`不是`Fish`，则根本不会评估条件表达式的第二部分。当它被评估时，Kotlin知道`animal`是`Fish`（智能转换）。
- en: Non-nullable smart cast
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非空智能转换
- en: '*Smart casts* also handle other cases, including nullity checks. Let''s assume
    that we have a `view` variable that is marked as nullable, because we don''t know
    wherever or not `findViewById` will return a view or null:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*智能转换*还处理其他情况，包括空值检查。假设我们有一个标记为可空的`view`变量，因为我们不知道`findViewById`是否会返回视图或null：'
- en: '[PRE50]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We could use safe call operator to access `view` methods and properties, but
    in some cases we may want to perform more operations on the same object. In these
    situations smart casting may be a better solution:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用安全调用运算符访问`view`的方法和属性，但在某些情况下，我们可能希望对同一对象执行更多操作。在这些情况下，智能转换可能是更好的解决方案：
- en: '[PRE51]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When performing null checks like this, the compiler automatically casts a nullable
    view (`View*?*` ) to non-nullable (`View` ). This is why we can call the `isShown`
    method inside the `if` block, without using a safe call operator. Outside the
    `if` block, the view is still nullable.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此类空检查时，编译器会自动将可空视图（`View*?*`）转换为非空（`View`）。这就是为什么我们可以在`if`块内调用`isShown`方法，而不使用安全调用运算符。在`if`块之外，视图仍然是可空的。
- en: Each *smart casts* works only with read-only variables, because read-write variable
    may change between the time the check was performed and the time the variable
    is accessed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个*智能转换*只适用于只读变量，因为读写变量可能在执行检查和访问变量之间发生变化。
- en: '*Smart casts* also work with a function''s `return` statements. If we perform
    nullity checks inside the function with a return statement, then the variable
    will also be casted to non-nullable:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*智能转换*也适用于函数的`return`语句。如果我们在函数内部执行空值检查并使用return语句，那么变量也将被转换为非空：'
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this case, Kotlin is absolutely sure that the variable value will not be
    null, because the function would call `return` otherwise. Functions will be discussed
    in more detail in [Chapter 3](text00073.html) *, Playing with Functions* . We
    can make the preceding syntax even simpler by using elvis operator and perform
    a nullity check in a single line*:*
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Kotlin绝对确定变量值不会为空，因为否则函数将调用`return`。函数将在[第3章](text00073.html)*Playing
    with Functions*中更详细地讨论。我们可以使用Elvis运算符使前面的语法更简单，并在一行中执行空值检查：
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Instead of just returning from the function, we may want to be more explicit
    about existing problem and throw an exception. Then we can use elvis operator
    together with the error throw:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 而不仅仅是从函数返回，我们可能希望更明确地说明现有问题并抛出异常。然后我们可以与错误抛出一起使用Elvis运算符：
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As we can see, *smart casts* are a very powerful mechanism that allows us to
    decrease the number of nullity checks. This is why it is heavily exploited by
    Kotlin. Remember the general rule--*smart casts* work only if Kotlin is absolutely
    sure that the variable cannot change after the cast even by another thread.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，*智能转换*是一种非常强大的机制，可以减少空值检查的次数。这就是为什么它被Kotlin大量利用的原因。记住一般规则——*智能转换*只有在Kotlin绝对确定变量即使在另一个线程中也不会在转换后改变时才有效。
- en: Primitive data types
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: 'In Kotlin, everything is an object (reference type, not primitive type). We
    don''t find primitive types, like ones we can use in Java. This reduces code complexity.
    We can call methods and properties on any variable. For example, this is how we
    can convert the `Int` variable to a `Char` :'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，一切都是对象（引用类型，而不是原始类型）。我们找不到像Java中可以使用的原始类型。这减少了代码复杂性。我们可以在任何变量上调用方法和属性。例如，这是我们如何将`Int`变量转换为`Char`：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Usually (whenever it is possible), under the hood types such as `Int` , `Long`
    , or `Char` are optimized (stored as primitive types) but we can still call methods
    on them as on any other objects.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通常（只要可能），底层类型如`Int`、`Long`或`Char`都经过优化（存储为原始类型），但我们仍然可以像在任何其他对象上一样调用它们的方法。
- en: 'By default, Java platform stores numbers as JVM primitive types, but when a
    nullable number reference (for example, `Int?` ) is needed or generics are involved,
    Java uses *boxed representation* . **Boxing** means wrapping a primitive type
    into corresponding boxed primitive type. This means that the instance behaves
    as an object. Examples of Java boxed representations of primitive types are *int
    versus Integer* or a *long versus Long* . Since Kotlin is compiled to JVM bytecode,
    the same is true here:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Java平台将数字存储为JVM原始类型，但当需要可空数字引用（例如`Int?`）或涉及泛型时，Java使用*装箱表示*。**装箱**意味着将原始类型包装成相应的装箱原始类型。这意味着实例的行为就像一个对象。Java原始类型的装箱表示的示例是*int与Integer*或*long与Long*。由于Kotlin编译为JVM字节码，这里也是如此：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Value is stored as primitive type
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值以原始类型存储
- en: Value is stored as boxed integer (composite type)
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 值以装箱整数（复合类型）存储
- en: 'This means that each time we create a number (`Byte` , `Short` , `Int` , `Long`
    , `Double` , `Float` ), or with `Char` , `Boolean` , it will be stored as a primitive
    type unless we declare it as a nullable type (`Byte?` , `Char?` , `Array?` , and
    so on); otherwise, it will be stored as a boxed representation:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次我们创建一个数字（`Byte`，`Short`，`Int`，`Long`，`Double`，`Float`），或者使用`Char`，`Boolean`，它将被存储为原始类型，除非我们将其声明为可空类型（`Byte?`，`Char?`，`Array?`等）；否则，它将被存储为装箱表示：
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`a` is non-nullable, so it is stored as primitive type'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`a`是非空的，因此它以原始类型存储'
- en: '`b` is null so it is stored as boxed representation'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`b`为空，因此它被存储为装箱表示'
- en: '`b` is still stored as boxed representation although it has a value'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`b`仍然以装箱表示存储，尽管它有一个值'
- en: Generic types cannot be parameterized using primitive types, so boxing will
    be performed. It's important to remember that using boxed representation (composite
    type) instead of primary representation can have performance penalties, because
    it will always create memory overhead compared to primitive type representation.
    This may be noticeable for lists and arrays containing a huge number of elements,
    so using primary representation may be crucial for application performance. On
    the other hand, we should not worry about the type of representation when it comes
    to a single variable or even multiple variable declarations, even in the Android
    world, where memory is limited.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 无法使用原始类型对泛型类型进行参数化，因此将执行装箱。重要的是要记住，使用装箱表示（复合类型）而不是主要表示可能会导致性能损失，因为它将始终创建与原始类型表示相比的内存开销。对于包含大量元素的列表和数组，这可能是显而易见的，因此对于应用程序性能来说，使用主要表示可能至关重要。另一方面，当涉及单个变量甚至多个变量声明时，我们不必担心表示的类型，即使在内存有限的Android世界中也是如此。
- en: 'Now let''s discuss the most important Kotlin primitive data types: numbers,
    characters, Booleans, and arrays.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论最重要的Kotlin原始数据类型：数字、字符、布尔值和数组。
- en: Numbers
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: 'Basic Kotlin data types used for numbers are equivalents of Java numeric primitives:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 用于数字的基本Kotlin数据类型等效于Java数值原语：
- en: '![](img/Image00028.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00028.jpg)'
- en: 'Kotlin, however, handles numbers a little bit differently than Java. The first
    difference is that there are no implicit conversions for numbers--smaller types
    are not implicitly converted to bigger types:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Kotlin处理数字的方式与Java有些不同。第一个区别是数字没有隐式转换--较小的类型不会隐式转换为较大的类型：
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This means that we cannot assign a value of type `Int` to the `Long` variable
    without an explicit conversion. As we said, in Kotlin everything is an object,
    so we can call the method and explicitly convert `Int` type to `Long` to fix the
    problem:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不能将`Int`类型的值分配给`Long`变量而不进行显式转换。正如我们所说，在Kotlin中，一切都是对象，所以我们可以调用方法并显式将`Int`类型转换为`Long`来解决问题：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'At first, this may seem like boilerplate code, but in practice this will allow
    us to avoid many errors related to number conversion and save a lot of debugging
    time. This is actually a rare example where Kotlin syntax has more amount of code
    than Java. The Kotlin standard library supports the following conversion methods
    for numbers:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这可能看起来像样板代码，但实际上这将使我们避免许多与数字转换相关的错误，并节省大量调试时间。这实际上是Kotlin语法比Java更多的代码量的一个罕见例子。Kotlin标准库支持以下数字转换方法：
- en: '`toByte()` : Byte'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toByte()`：Byte'
- en: '`toShort()` : Short'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toShort()`：Short'
- en: '`toInt()` : Int'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toInt()`：Int'
- en: '`toLong()` : Long'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toLong()`：Long'
- en: '`toFloat()` : Float'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toFloat()`：Float'
- en: '`toDouble()` : Double'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toDouble()`：Double'
- en: '`toChar()` : Char'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toChar()`：Char'
- en: 'We can, however, explicitly specify a number literal to change the inferred
    variable type:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以显式指定数字文字以更改推断的变量类型：
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The second difference between Kotlin and Java numbers is that number literals
    are slightly different in some cases. There are the following kinds of literal
    constants for integral values:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin和Java数字之间的第二个区别是，某些情况下数字文字略有不同。对于整数值，有以下类型的文字常量：
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Octal literals are not supported. Kotlin also supports a conventional notation
    for floating-point numbers:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持八进制文字。Kotlin还支持浮点数的传统表示法：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Char
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Char
- en: 'Characters in Kotlin are stored in type `Char` . In many ways, characters are
    similar to strings, so we will concentrate on the similarities and differences.
    To define `Char` , we must use a single quote kind of opposite to a `String` where
    we are using double quotes:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中的字符存储在类型`Char`中。在许多方面，字符类似于字符串，因此我们将集中讨论相似之处和不同之处。要定义`Char`，我们必须使用单引号，与`String`相反，我们在其中使用双引号：
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Defines variable of type `Char`
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类型为`Char`的变量
- en: Defines variable of type `String`
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义类型为`String`的变量
- en: 'In both characters and strings, special characters can be escaped using a backslash.
    The following escape sequences are supported:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符和字符串中，可以使用反斜杠来转义特殊字符。支持以下转义序列：
- en: '`\t` : Tabulator'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\t`：制表符'
- en: '`\b` : Backspace'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\b`：退格'
- en: '`\n` : New line'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\n`：换行'
- en: '`\r` : New line'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r`：换行'
- en: '`\''` : Quote'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\''`：引号'
- en: '`\"` : Double quote'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\"`：双引号'
- en: '`\\` : Slash'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\\`：斜杠'
- en: '`\$` : Dollar character'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\$`：美元符号'
- en: '`\u` : Unicode escape sequence'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\u`：Unicode转义序列'
- en: 'Let''s define *Char* containing the Yin Yang unicode character (U+262F):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义包含阴阳Unicode字符（U+262F）的*Char*：
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Arrays
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'In Kotlin, arrays are represented by the `Array` class. To create an array
    in Kotlin, we can use a number of Kotlin standard library functions. The simplest
    one is `arrayOf()` :'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，数组由`Array`类表示。要在Kotlin中创建数组，我们可以使用许多Kotlin标准库函数。最简单的是`arrayOf()`：
- en: '[PRE65]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'By default, this function will create an array of boxed `Int` . If we want
    to have an array containing *Short* or *Long* , then we have to specify array
    type explicitly:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此函数将创建一个装箱`Int`的数组。如果我们想要一个包含*Short*或*Long*的数组，那么我们必须明确指定数组类型：
- en: '[PRE66]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As previously mentioned, using boxed representations may decrease application
    performance. That''s why Kotlin has a few specialized classes representing arrays
    of primitive types to reduce boxing memory overhead: `ShortArray` , `IntArray`
    , `LongArray` , and so on. These classes have no inheritance relation to the `Array`
    class, although they have the same set of methods and properties. To create instances
    of this class we have to use the corresponding factory function:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，使用装箱表示可能会降低应用程序的性能。这就是为什么Kotlin有一些专门表示原始类型数组的类，以减少装箱内存开销：`ShortArray`，`IntArray`，`LongArray`等。这些类与`Array`类没有继承关系，尽管它们具有相同的一组方法和属性。要创建这些类的实例，我们必须使用相应的工厂函数：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'It''s important to notice and keep in mind this subtle difference, because
    those methods look similar, but create different type representations:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意并牢记这个微妙的差别，因为这些方法看起来相似，但创建了不同的类型表示：
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Generic array of boxed Long elements (inferred type: `Array<Long>` )'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型数组的装箱长元素（推断类型：`Array<Long>`）
- en: 'Array containing primitive Long elements (inferred type: `LongArray` )'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含原始长元素的数组（推断类型：`LongArray`）
- en: 'Knowing the exact size of an array will often improve performance, so Kotlin
    has another library function, `arrayOfNulls` , that creates an array of a given
    size filled with null elements:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 知道数组的确切大小通常会提高性能，因此Kotlin还有另一个库函数`arrayOfNulls`，它创建一个给定大小的数组，其中填充了空元素：
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can also fill a predefined size array using the factory function that takes
    the array size as the first parameter and the lambda that can return the initial
    value of each array element given its index as the second parameter:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用将数组大小作为第一个参数并且可以返回每个数组元素的初始值的lambda作为第二个参数的工厂函数来填充预定义大小的数组：
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We will discuss lambdas (anonymous functions) in more detail in [Chapter 5](text00125.html)
    *, Functions as First Class Citizen* . Accessing array elements in Kotlin is done
    the same way as in Java:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](text00125.html)，*函数作为一等公民*中更详细地讨论lambda（匿名函数）。在Kotlin中访问数组元素的方式与Java相同：
- en: '[PRE71]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Element are also indexed the same way as in Java, meaning the first element
    has index 0, second has index 1, and so on. Not everything works the same and
    there are some differences. Main one is that arrays in Kotlin, unlike in Java,
    arrays are invariant. We will discuss *variance* is [Chapter 6](text00153.html)
    , *Generics Are Your Friends* .
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 元素的索引方式也与Java相同，意味着第一个元素的索引为0，第二个元素的索引为1，依此类推。并非所有的东西都一样，也存在一些差异。主要的一个是，Kotlin中的数组与Java不同，Kotlin中的数组是不变的。我们将在[第6章](text00153.html)，*泛型是你的朋友*中讨论*变异*。
- en: The Boolean type
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔类型
- en: 'Boolean is a logic type that has two possible values: `true` and `false` .
    We can also use the nullable Boolean type:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔是一个逻辑类型，有两个可能的值：`true`和`false`。我们还可以使用可空布尔类型：
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Boolean type also supports standard built-in operations that are generally
    available in most modern programming languages:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型还支持通常在大多数现代编程语言中可用的标准内置操作：
- en: '`||` : Logical OR. Returns `true` when any of two predicates return `true`
    .'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`||`：逻辑或。当两个谓词中任何一个返回`true`时返回`true`。'
- en: '`&&` : Logical AND. Returns `true` when both predicates return `true` .'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&`：逻辑与。当两个谓词都返回`true`时返回`true`。'
- en: '`!` : Negation operator. Returns `true` for `false` , and `false` for `true`
    .'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!`：否定运算符。对于`false`返回`true`，对于`true`返回`false`。'
- en: Keep in mind that we can only use not-null Boolean for any type of condition.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们只能对任何类型的条件使用非空布尔值。
- en: Like in Java, in `||` and `&&` , predicates are evaluated lazily, and only when
    needed (*lazy conjunction* ).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java一样，在`||`和`&&`中，谓词是惰性评估的，只有在需要时才会评估（*惰性连接*）。
- en: Composite data types
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合数据类型
- en: Let's discuss more complex types built into Kotlin. Some data types have major
    improvements compared to Java, while others are totally new.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论内置到Kotlin中的更复杂的类型。一些数据类型与Java相比有重大改进，而另一些则是全新的。
- en: Strings
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: Strings in Kotlin behave in a similar way as in Java, but they have a few nice
    improvements.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中的字符串的行为方式与Java类似，但它们有一些很好的改进。
- en: 'To start to access characters at a specified index we can use *indexing* operator
    and access character the same way we access array elements:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始访问指定索引处的字符，我们可以使用*索引*运算符，并以访问数组元素的方式访问字符：
- en: '[PRE73]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We also have access to various extensions defined in Kotlin standard library,
    which make working with strings easier:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以访问Kotlin标准库中定义的各种扩展，这些扩展使得处理字符串更加容易：
- en: '[PRE74]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This is exactly the same String class as in Java, so these methods are not part
    of `String` class. They were defined as extensions. We will learn more about extensions
    in [Chapter 7](text00171.html) , *Extension Functions and Properties* .
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是Java中的`String`类，因此这些方法不是`String`类的一部分。它们被定义为扩展。我们将在[第7章](text00171.html)，*扩展函数和属性*中学习更多关于扩展的知识。
- en: Check the `String` class documentation for a full list of the methods ([https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/)
    ).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`String`类文档以获取方法的完整列表（[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/)）。
- en: String templates
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串模板
- en: 'Building strings is an easy process, but in Java it usually requires long concatenation
    expressions. Let''s jump straight to an example. Here is a string built from multiple
    elements implemented in Java:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 构建字符串是一个简单的过程，但在Java中通常需要长的连接表达式。让我们直接跳到一个例子。这是在Java中实现的由多个元素构建的字符串：
- en: '[PRE75]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In Kotlin, we can greatly simplify the process of string creation by using
    *string templates.* Instead of using concatenation, we can simply place a variable
    inside a string using a dollar character to create a placeholder. During interpolation,
    string placeholders will be replaced with the actual value. Here is an example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们可以通过使用*字符串模板*大大简化字符串创建的过程。我们可以简单地使用一个美元符号将变量放在字符串中，而不是使用连接。在插值期间，字符串占位符将被实际值替换。这里有一个例子：
- en: '[PRE76]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This is as efficient as concatenation, because under the hood the compiled
    code creates a `StringBuilder` and appends all the parts together. String templates
    are not limited to single variables. They can also contain whole expressions between
    `${` , and `}` characters. It can be a function call that will return the value
    or property access as shown in the following snippet:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这与连接一样高效，因为在底层编译代码创建了一个`StringBuilder`并将所有部分附加在一起。字符串模板不仅限于单个变量。它们还可以在`${`和`}`字符之间包含整个表达式。它可以是一个函数调用，将返回值或属性访问，如下面的片段所示：
- en: '[PRE77]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This syntax allows us to create much cleaner code without the need to break
    the string each time a value from a variable or expression is required to construct
    strings.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法允许我们创建更清晰的代码，而无需每次需要从变量或表达式中获取值来构造字符串时都打破字符串。
- en: Ranges
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: 'A range is a way to define a sequence of values. It is denoted by the first
    and last value in the sequence. We can use ranges to store weights, temperatures,
    time, and age. A range is defined using double dots notation (under the hood,
    a range is using the `rangeTo` operator):'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 范围是定义一系列值的一种方式。它由序列中的第一个和最后一个值表示。我们可以使用范围来存储重量、温度、时间和年龄。范围使用双点符号（在底层，范围使用`rangeTo`运算符）来定义：
- en: '[PRE78]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Inferred type is `IntRange` (equivalent of `i >= 1 && i <= 4` )
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推断类型是`IntRange`（相当于`i >= 1 && i <= 4`）
- en: Inferred type is `CharRange` (equivalent of letters from `'b'` to `'g'` )
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推断类型是`CharRange`（相当于从`'b'`到`'g'`的字母）
- en: Notice that we are using single quotes to define the character range.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用单引号来定义字符范围。
- en: 'The `Int` , `Long` , and `Char` type ranges can be used to iterate over next
    values in the `for... each` loop:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`Int`，`Long`和`Char`类型的范围可用于在`for... each`循环中迭代下一个值：'
- en: '[PRE79]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Ranges can be used to check if a value is bigger than a start value and smaller
    than an end value:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 范围可以用来检查一个值是否大于起始值并且小于结束值：
- en: '[PRE80]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'It can be also used this way for other types of range, such as `CharRange`
    :'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以用于其他类型的范围，比如`CharRange`：
- en: '[PRE81]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In Kotlin, ranges are closed (end inclusive). This means that the range ending
    value is included into range:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，范围是闭合的（包括结束）。这意味着范围结束值包括在范围内：
- en: '[PRE82]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Note, that ranges in Kotlin are incremental by default (a step is equal to
    1 by default):'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Kotlin中的范围默认是递增的（默认情况下步长为1）：
- en: '[PRE83]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To iterate in reverse order, we must use a `downTo` function that is setting
    a step to `-1` . Like in this example:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 要以相反的顺序迭代，我们必须使用`downTo`函数，将步长设置为`-1`。就像这个例子：
- en: '[PRE84]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We can also set different steps:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以设置不同的步骤：
- en: '[PRE85]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Notice that in the `3..6` range, the last element was not printed. This is because
    the *stepping index* is moving two steps in each of the loop iterations. So in
    the first iteration it has a value of `3` , in the second iteration a value of
    `5` , and finally, in a third iteration the value would be `7` , so it is ignored,
    because it is outside the range.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`3..6`范围内，最后一个元素没有被打印出来。这是因为*步进索引*在每个循环迭代中移动两步。因此，在第一次迭代中，它的值为`3`，在第二次迭代中，它的值为`5`，最后，在第三次迭代中，值将为`7`，因此它被忽略，因为它在范围之外。
- en: 'A step defined by the `step` function must be positive. If we want to define
    a negative step then we should use the `downTo` function together with the `step`
    function:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由`step`函数定义的步骤必须是正的。如果我们想定义一个负步骤，那么我们应该使用`downTo`函数和`step`函数一起使用：
- en: '[PRE86]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Collections
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: A very important aspect of programming is working with collections. Kotlin offers
    multiple kinds of collections and many improvements compared to Java. We will
    discuss this subject in [Chapter 7](text00171.html) , *Extension Functions and
    Properties* .
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 编程的一个非常重要的方面是使用集合。Kotlin提供了多种类型的集合，并与Java相比有许多改进。我们将在[第7章](text00171.html)中讨论这个主题，*扩展函数和属性*。
- en: Statements versus expressions
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语句与表达式
- en: 'Kotlin utilizes expressions more widely than Java, so it is important to know
    the difference between a *statement* and an *expression* . A program is basically
    a sequence of statements and expressions. Expression produces a value, which can
    be used as part of another expression, variable assignment, or function parameter.
    An expression is a sequence of one or more *operands* (data that is manipulated)
    and zero or more *operators* (a token that represents a specific operation) that
    can be evaluated to a single value:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin比Java更广泛地使用表达式，因此了解*语句*和*表达式*之间的区别很重要。程序基本上是一系列语句和表达式。表达式产生一个值，可以作为另一个表达式、变量赋值或函数参数的一部分使用。表达式是一个或多个*操作数*（被操作的数据）和零个或多个*操作符*（表示特定操作的标记）的序列，可以评估为单个值。
- en: '![](img/Image00029.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00029.jpg)'
- en: 'Let''s review some examples of expressions from Kotlin:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些来自Kotlin的表达式的例子：
- en: '| **Expression (produce a value)** | **Assigned value** | **Expression of type**
    |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| **表达式（产生一个值）** | **分配的值** | **类型的表达式** |'
- en: '| `a = true` | `true` | Boolean |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `a = true` | `true` | 布尔值 |'
- en: '| `a = "foo" + "bar"` | `"foobar"` | String |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `a = "foo" + "bar"` | `"foobar"` | 字符串 |'
- en: '| `a = min(2, 3)` | `2` | Integer |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `a = min(2, 3)` | `2` | 整数 |'
- en: '| `a = computePosition().getX()` | Value returned by `getX` method | Integer
    |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `a = computePosition().getX()` | `getX`方法返回的值 | 整数 |'
- en: Statements, on the other hand, perform an action and cannot be assigned to a
    variable, because they simply don't have a value. Statements can contain language
    keywords that are used to define classes (`class` ), interfaces (`interface` ),
    variables (`val` , `var` ), functions (`fun` ), loop logic (`break` , `continue`
    ) and so on. Expressions can also be treated as a statement when the value returned
    by the expression is ignored (do not assign value to variable, do not return it
    from a function, do not use it as part of other expressions, and so on).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，语句执行一个动作，不能赋值给变量，因为它们根本没有值。语句可以包含用于定义类（`class`），接口（`interface`），变量（`val`，`var`），函数（`fun`），循环逻辑（`break`，`continue`）等的语言关键字。当表达式返回的值被忽略时（不将值赋给变量，不从函数中返回它，不将其用作其他表达式的一部分等），表达式也可以被视为语句。
- en: Kotlin is an expression-oriented language. This means that many constructs that
    are statements in Java are treated as expressions in Kotlin. The first major difference
    is the fact that Java and Kotlin have different ways of treating *control structures*
    . In Java they are treated as statements while in Kotlin all control structures
    are treated as expressions, except for loops. This means that in Kotlin we can
    write very concise syntax using control structures. We will see examples in upcoming
    sections.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin是一种面向表达式的语言。这意味着在Kotlin中，许多在Java中是语句的构造在Kotlin中被视为表达式。第一个主要的区别是Java和Kotlin对待*控制结构*的方式不同。在Java中，它们被视为语句，而在Kotlin中，所有控制结构都被视为表达式，除了循环。这意味着在Kotlin中，我们可以使用控制结构编写非常简洁的语法。我们将在接下来的章节中看到例子。
- en: Control flow
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: Kotlin has many control flow elements known from Java, but they offer a little
    bit more flexibility and in some cases their usage is simplified. Kotlin introduces
    a new control flow construct known as `when` as a replacement for Java `switch...
    case` .
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin有许多来自Java的控制流元素，但它们提供了更灵活的使用方式，在某些情况下，它们的使用更简化了。Kotlin引入了一个称为`when`的新控制流构造，作为Java
    `switch... case`的替代品。
- en: The if statement
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: if语句
- en: 'At its core, Kotlin''s `if` clause works the same way as in Java:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，Kotlin的`if`子句的工作方式与Java相同：
- en: '[PRE87]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The version with the block body is also correct if the block contains single
    statements or expressions:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 带有块体的版本如果块包含单个语句或表达式也是正确的：
- en: '[PRE88]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Java, however, treats `if` as a *statement* while Kotlin treats `if` as an
    *expression* . This is the main difference, and this fact allows us to use more
    concise syntax. We can, for example, pass the result of an `if` expression directly
    as a function argument:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Java将`if`视为*语句*，而Kotlin将`if`视为*表达式*。这是主要区别，这个事实使我们能够使用更简洁的语法。例如，我们可以直接将`if`表达式的结果作为函数参数传递：
- en: '[PRE89]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We can compress our code into single line, because result the `if` expression
    (of type String) is evaluated and then passed to the `println` method. When condition
    `x > 10` is `true` , then first branch (greater) will be returned by this expression,
    otherwise the second branch (smaller) will be returned by this expression. Let''s
    examine another example:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的代码压缩成一行，因为`if`表达式的结果（String类型）被评估，然后传递给`println`方法。当条件`x > 10`为`true`时，这个表达式将返回第一个分支（greater），否则这个表达式将返回第二个分支（smaller）。让我们看另一个例子：
- en: '[PRE90]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In the preceding example, we are using `if` as a statement. But as we know,
    `if` in Kotlin is an expression and the result of the expression can be assigned
    to a variable. This way we can assign the result of the `if` expression to a greeting
    variable directly:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将`if`用作语句。但是我们知道，在Kotlin中，`if`是一个表达式，表达式的结果可以赋值给一个变量。这样我们可以直接将`if`表达式的结果赋值给一个greeting变量：
- en: '[PRE91]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'But sometimes there is a need to place some other code inside the branch of
    the `if` statement. We can still use if as an expression. Then the last line of
    the matching `if` branch will be returned as a result:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时需要在`if`语句的分支中放置一些其他代码。我们仍然可以将`if`用作表达式。然后匹配`if`分支的最后一行将作为结果返回：
- en: '[PRE92]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If we are using `if` as an expression rather than a statement, the expression
    is required to have an `else` branch. The Kotlin version is even better than Java.
    Since the `greeting` variable is defined as non-nullable, the compiler will validate
    the whole `if` expression and it will check that all cases are covered with branch
    conditions. Since `if` is an expression*,* we can use it inside *string template*
    :'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`if`视为表达式而不是语句，则表达式需要有一个`else`分支。Kotlin版本甚至比Java更好。由于`greeting`变量被定义为非空，编译器将验证整个`if`表达式，并检查所有情况是否都有分支条件。由于`if`是一个表达式*，*我们可以在*字符串模板*中使用它：
- en: '[PRE93]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Treating `if` as *expression* gives us a wide range of possibilities previously
    unavailable in Java world.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 将`if`视为*表达式*给我们带来了以前在Java世界中无法实现的广泛可能性。
- en: The when expression
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: when表达式
- en: 'The `when` expression in Kotlin is a multiway branch statement. The `when`
    expression is designed as a more powerful replacement of the Java `switch... case`
    statement. The `when` statement often provides a better alternative than a large
    series of `if... else if` statements, but it provides more concise syntax. Let''s
    look at an example:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中的`when`表达式是一种多路分支语句。`when`表达式被设计为Java `switch... case`语句的更强大的替代品。`when`语句通常提供了比大量的`if...
    else if`语句更好的替代方案，但它提供了更简洁的语法。让我们看一个例子：
- en: '[PRE94]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The `when` expression matches its argument against all branches one after another
    until the condition of some branch is satisfied. This behavior is similar to Java
    `switch... case` , but we do not have to write a redundant `break` statement after
    every branch.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`when`表达式将其参数与所有分支一一匹配，直到满足某个分支的条件。这种行为类似于Java的`switch... case`，但我们不必在每个分支后写冗余的`break`语句。'
- en: 'Similar to the `if` clause, we can use `when` either as a *statement* ignoring
    returned value or as *expression* and assign its value to a variable. If `when`
    is used as an *expression* , the value of the last line of the satisfied branch
    becomes the value of the overall expression. If it is used as a statement, the
    value is simply ignored. As usual, the `else` branch is evaluated if none of the
    previous branches satisfy the condition:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `if` 子句类似，我们可以将 `when` 用作*语句*，忽略返回值，也可以将其用作*表达式*，并将其值赋给变量。如果 `when` 用作*表达式*，则满足分支的最后一行的值成为整体表达式的值。如果它用作语句，则值将被简单地忽略。通常情况下，如果没有一个前面的分支满足条件，`else`
    分支将被评估：
- en: '[PRE95]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Each time a branch has more than one instruction, we must place it inside the
    code block, defined by two braces `{... }` . If `when` is treated as an expression
    (result of evaluating `when` is assigned to variable), the last line of each block
    is treated as return value. We have seen the same behavior with an `if` expression,
    so by now we probably figured out that this is common behavior across many Kotlin
    constructs including lambdas, which will be discussed further across the book.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个分支有多于一条指令时，我们必须将其放在由两个大括号 `{...}` 定义的代码块内。如果 `when` 被视为表达式（`when` 的评估结果被赋值给变量），每个块的最后一行被视为返回值。我们已经看到了
    `if` 表达式的相同行为，所以现在我们可能已经意识到这是 Kotlin 许多构造的共同行为，包括将在本书中进一步讨论的 lambda。
- en: 'If `when` is used as an expression, the `else` branch is mandatory, unless
    the compiler can prove that all possible cases are covered with branch conditions.
    We can also handle many matching arguments in a single branch using commas to
    separate them:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `when` 用作表达式，`else` 分支是强制的，除非编译器可以证明分支条件覆盖了所有可能的情况。我们还可以使用逗号将多个匹配参数放在单个分支中处理：
- en: '[PRE96]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Another nice feature of `when` is the ability to check variable type. We can
    easily validate that value `is` or `!is` of a particular type. Smart casts become
    handy again, because we can access the methods and properties of a matching type
    in a branch block without any extra checks:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`when` 的另一个好特性是检查变量类型的能力。我们可以轻松验证值是否是特定类型的 `is` 或 `!is`。智能转换再次变得方便，因为我们可以在分支块中访问匹配类型的方法和属性，而无需进行任何额外的检查：'
- en: '[PRE97]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In a similar way, we can check whatever range or collection contains a particular
    value. This time we''ll use `is` and `!is` keywords:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以检查范围或集合是否包含特定值。这次我们将使用 `is` 和 `!is` 关键字：
- en: '[PRE98]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Actually, we can put any kind of expression on the right-hand side of the `when`
    branch. It can be a method call or any other expression. Consider the following
    example where the second `when` expression is used for the `else` statement:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以在 `when` 分支的右侧放置任何类型的表达式。它可以是方法调用或任何其他表达式。考虑以下示例，其中第二个 `when` 表达式用于
    `else` 语句：
- en: '[PRE99]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'As we can see, `when` is a very powerful construct allowing more control than
    Java `switch` , but it is even more powerful because it is not limited only to
    checking values for equality. In a way, it can even be used as a replacement for
    an `if... else if` chain. If no argument is supplied to the `when` expression,
    the branch conditions behave as Boolean expressions, and a branch is executed
    when its condition is `true` :'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`when` 是一个非常强大的构造，比 Java 的 `switch` 更具控制力，但它更强大的原因在于它不仅仅局限于检查相等的值。在某种程度上，它甚至可以用作
    `if... else if` 链的替代。如果没有向 `when` 表达式提供参数，分支条件会表现为布尔表达式，当条件为 `true` 时执行分支：
- en: '[PRE100]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'All the presented examples require an `else` branch. Each time when all the
    possible cases are covered, we can omit an `else` branch (exhaustive `when` ).
    Let''s look at the simplest example with Boolean:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 所有呈现的示例都需要一个 `else` 分支。每当所有可能的情况都被覆盖时，我们可以省略 `else` 分支（穷尽 `when`）。让我们看一个布尔值的最简单的例子：
- en: '[PRE101]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Compiler can verify that all possible values are handled, so there is no need
    to specify an `else` branch. The same logic applies to enums and sealed classes
    that will be discussed in [Chapter 4](text00088.html) *, Classes and Objects*
    .
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可以验证所有可能的值都已处理，因此不需要指定 `else` 分支。相同的逻辑适用于将在[第4章](text00088.html)中讨论的枚举和密封类，即*类和对象*。
- en: Checks are performed by the Kotlin compiler, so we have certainty that any case
    will not be missed. This reduces the possibility of a common Java bug where the
    developer forgets to handle all the cases inside the `switch` statement (although
    polymorphism is usually a better solution)*.*
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 编译器执行检查，因此我们可以确定不会漏掉任何情况。这减少了在 `switch` 语句内部开发人员忘记处理所有情况的常见 Java bug
    的可能性（尽管多态通常是更好的解决方案）*。*
- en: Loops
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: 'Loop is a control structure that repeats the same set of instructions until
    a termination condition is met. In Kotlin, loops can iterate through anything
    that provides iterator. Iterator is an interface that has two methods: `hasNext`
    and `next` . It knows how to iterate over a collection, range, string, or any
    entity that can be represented as a sequence of elements.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 循环是一种控制结构，重复相同的指令集，直到满足终止条件。在 Kotlin 中，循环可以迭代任何提供迭代器的内容。迭代器是一个具有两个方法的接口：`hasNext`
    和 `next`。它知道如何迭代集合、范围、字符串或任何可以表示为元素序列的实体。
- en: To iterate through something, we have to supply an `iterator()` method. As `String`
    doesn't have one, so in Kotlin it is defined as an extension function. Extensions
    will be covered in [Chapter 7](text00171.html) , *Extension Functions and Properties*
    .
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 要迭代某些内容，我们必须提供一个 `iterator()` 方法。由于 `String` 没有这个方法，因此在 Kotlin 中它被定义为一个扩展函数。扩展将在[第7章](text00171.html)中介绍，即*扩展函数和属性*。
- en: 'Kotlin provides three kinds of loops: `for` , `while` , and `do... while` .
    All of them work the same as in other programming languages, so we will discuss
    them briefly.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了三种类型的循环：`for`、`while` 和 `do... while`。它们都与其他编程语言中的循环相同，因此我们将简要讨论它们。
- en: The for loop
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for 循环
- en: 'The classic Java `for` loop, where we need to define the iterator explicitly,
    is not present in Kotlin. Here is an example of this kind of loop in Java:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中不存在经典的 Java `for` 循环，需要显式定义迭代器。以下是 Java 中这种类型循环的示例：
- en: '[PRE102]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'To iterate through a collection of items from start to finish, we can simply
    use the `for` loop instead:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 要从头到尾迭代项目集合，我们可以简单地使用`for`循环：
- en: '[PRE103]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'It can also be defined without a block body:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以在没有块体的情况下定义：
- en: '[PRE104]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'If a `collection` is a generic collection, then *item* will be smart casted
    to type corresponding to a generic collection type. In other words, if a collection
    contains elements of type `Int` the item will be smart cased to `Int` :'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`collection`是一个泛型集合，那么*item*将被智能转换为与泛型集合类型相对应的类型。换句话说，如果集合包含`Int`类型的元素，那么item将被智能转换为`Int`：
- en: '[PRE105]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We can also iterate through the collection using its index:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过索引遍历集合：
- en: '[PRE106]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The `array.indices` param returns `IntRange` with all indexes. It is the equivalent
    of (`1.. array.length - 1` *)* . There is also an alternative `withIndex` library
    method that returns a list of the `IndexedValue` property, which contains an index
    and value. This can be destructed into these elements this way:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`array.indices`参数返回带有所有索引的`IntRange`。它相当于(`1.. array.length - 1` *)*。还有一个替代的`withIndex`库方法，它返回一个包含索引和值的`IndexedValue`属性的列表。可以这样解构这些元素：'
- en: '[PRE107]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The construct `(index, value)` is known as a destructive declaration and we
    will discuss it in [Chapter 4](text00088.html) , *Classes and Objects* .
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`(index, value)`结构被称为破坏性声明，我们将在[第4章](text00088.html)，*类和对象*中讨论它。'
- en: The while loop
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: while循环
- en: 'The `while` loop repeats a block, while its conditional expression returns
    `true` :'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环重复一个块，当其条件表达式返回`true`时：'
- en: '[PRE108]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'There is also a `do... while` loop that repeats blocks as long as a *conditional
    expression* is returning `true` :'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`do... while`循环，它会重复块，只要*条件表达式*返回`true`：
- en: '[PRE109]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Kotlin, opposed to Java, can use variables declared inside the `do... while`
    loop as condition.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java相反，Kotlin可以使用在`do... while`循环内声明的变量作为条件。
- en: '[PRE110]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The main difference between both `while` and `do... while` loops is when a conditional
    expression is evaluated. A `while` loop is checking the condition before code
    execution and if it is not true then the code won't be executed. On the other
    hand, a `do... while` loop first executes the body of the loop, and then evaluates
    the conditional expression, so the body will always execute at least once. If
    this expression is `true` , the loop will repeat. Otherwise, the loop terminates.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`和`do... while`循环之间的主要区别在于条件表达式的评估时间。`while`循环在代码执行之前检查条件，如果条件不为真，则代码不会被执行。另一方面，`do...
    while`循环首先执行循环体，然后评估条件表达式，因此循环体至少会执行一次。如果这个表达式为`true`，循环将重复。否则，循环终止。'
- en: Other iterations
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他迭代
- en: There other ways to iterate over collections using built-in standard library
    functions, such as `forEach` . We will cover them in [Chapter 7](text00171.html)
    , *Extension Functions and Properties* .
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他使用内置标准库函数进行集合迭代的方法，比如`forEach`。我们将在[第7章](text00171.html)，*扩展函数和属性*中介绍它们。
- en: Break and continue
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Break and continue
- en: 'All loops in Kotlin support classic `break` and `continue` statements. The
    `continue` statement proceeds to the next iteration of that loop while `break`
    stops the execution of the most inner enclosing loop:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中的所有循环都支持经典的`break`和`continue`语句。`continue`语句继续执行该循环的下一次迭代，而`break`停止最内部封闭循环的执行：
- en: '[PRE111]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now let''s add a `condition` and `break` the iteration when this condition
    is `true` :'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一个`条件`，并在这个条件为`true`时中断迭代：
- en: '[PRE112]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The `break` and `continue` statements are especially useful when dealing with
    nested loops. They may simplify our control flow and significantly decrease the
    amount of performed work to save priceless Android resources. Let''s perform a
    nested iteration and break the outer loop:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`和`continue`语句在处理嵌套循环时特别有用。它们可以简化我们的控制流程，并显著减少执行的工作量，以节省宝贵的Android资源。让我们执行一个嵌套迭代并中断外部循环：'
- en: '[PRE113]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We used a `break` statement to terminate the outer loop at the beginning of
    the third iteration, so the nested loop was also terminated. Notice the usage
    of the `\t` escaped sequence that adds indents on the console. We can also utilize
    the `continue` statement to skip the current iteration of the loop:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`break`语句在第三次迭代开始时终止外部循环，因此嵌套循环也被终止。请注意在控制台上添加缩进的`\t`转义序列的使用。我们还可以利用`continue`语句跳过循环的当前迭代：
- en: '[PRE114]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We skip the iteration of the outer loop when the current value equals to `3`
    .
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 当当前值等于`3`时，我们跳过外部循环的迭代。
- en: 'Both `continue` and `break` statements perform corresponding operations on
    the enclosing loop. There are, however, times when we want to terminate or skip
    iteration of one loop from within another; for example, terminate an outer loop
    iteration from within an inner loop:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`和`break`语句都在封闭循环上执行相应的操作。然而，有时我们希望从一个循环中终止或跳过另一个循环的迭代；例如，从内部循环中终止外部循环的迭代：'
- en: '[PRE115]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Fortunately, both a `continue` statement and `break` statement have two forms--labeled
    and unlabeled. We already saw unlabeled, now we will need labeled to solve our
    problem. Here is an example of how a labeled break might be used:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`continue`语句和`break`语句都有两种形式--有标签和无标签。我们已经看到了无标签，现在我们需要有标签来解决我们的问题。下面是一个使用有标签的break的例子：
- en: '[PRE116]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The `@outer` is the label name. By convention, the label name always starts
    with `*@*` followed by label name. Label is placed before the loop. Labeling the
    loop allows us to use qualified `break` (`break@outer` ), which is a way to stop
    execution of a loop that is referenced by this label. The preceding qualified
    `break` (break with label) jumps to the execution point right after the loop marked
    with that label.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`@outer`是标签名称。按照惯例，标签名称始终以`*@*`开头，后跟标签名称。标签放置在循环之前。给循环加标签允许我们使用有资格的`break`（`break@outer`），这是一种停止引用该标签的循环的执行的方法。前面的有资格的`break`（带标签的break）跳转到标记有该标签的循环之后的执行点。'
- en: 'Placing the `return` statement will break all the loops and return from enclosing
    an anonymous or named function:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 放置`return`语句将中断所有循环并从匿名或命名函数中返回：
- en: '[PRE117]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'After the method call:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 方法调用之后：
- en: '[PRE118]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Exceptions
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: 'Most Java programming guidelines, including the book *Effective Java* , promote
    the concept of validity checks. This means that we should always verify arguments
    or the state of the object and throw an exception if a validity check fails. Java
    exception systems have two kinds of exceptions: checked exceptions and unchecked
    exceptions.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Java编程指南，包括《Effective Java》这本书，都提倡有效性检查的概念。这意味着我们应该始终验证参数或对象的状态，并在有效性检查失败时抛出异常。Java异常系统有两种异常：已检查异常和未检查异常。
- en: 'Unchecked exception means that the developer is not forced to catch exceptions
    by using a `try... catch` block. By default, exceptions go all the way up the
    call stack, so we make decisions where to catch them. If we forget to catch them,
    they will go all the way up the call stack and stop thread execution with a proper
    message (thus they remind us):'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 未检查异常意味着开发人员不必使用`try... catch`块来捕获异常。默认情况下，异常会一直传递到调用堆栈的最上层，因此我们可以决定在哪里捕获它们。如果我们忘记捕获它们，它们将一直传递到调用堆栈的最上层，并以适当的消息停止线程执行（因此它们会提醒我们）：
- en: '![](img/Image00030.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00030.jpg)'
- en: 'Java has a really strong exception system, which in many cases forces developers
    to explicitly mark each function that may throw an exception and explicitly catch
    each exception by surrounding them by `try... catch` blocks (checked exceptions).
    This works great for very small projects, but in real large-scale applications
    this very often leads to the following, verbose code:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: Java有一个非常强大的异常系统，在许多情况下，它迫使开发人员明确标记可能引发异常的每个函数，并通过将它们包围在`try... catch`块中明确捕获每个异常（已检查异常）。这对于非常小的项目效果很好，但在真正的大型应用程序中，这往往会导致冗长的代码：
- en: '[PRE119]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Instead of passing the exception up in the call stack, it is ignored by providing
    an empty catch block, so it won't be handled properly and it will vanish. This
    kind of code may mask critical exceptions and give a false sense of security and
    lead to unexpected problems and difficult to find bugs.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 不是将异常传递到调用堆栈中，而是通过提供一个空的catch块来忽略它，因此它不会被正确处理，而是会消失。这种代码可能掩盖关键异常，并给人一种错误的安全感，导致意外问题和难以找到的错误。
- en: 'Before we discuss how exception handling is done in Kotlin, let''s compare
    both types of exceptions:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论Kotlin中如何处理异常之前，让我们比较一下两种类型的异常：
- en: '| **Code** | **Checked exceptions** | **Unchecked exceptions** |'
  id: totrans-456
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **已检查异常** | **未检查异常** |'
- en: '| Function declaration | We have to specify what exceptions can be thrown by
    functions. | Function declaration does not contain information about all thrown
    exceptions. |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '| 函数声明 | 我们必须指定函数可能抛出的异常。 | 函数声明不包含所有抛出异常的信息。 |'
- en: '| Exception handling | Function that throws exception must to be surrounded
    by a `try... catch` block. | We can catch exception and do something if we want,
    but we aren''t forced to do this. Exception goes up in the call stack. |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| 异常处理 | 抛出异常的函数必须被`try... catch`块包围。 | 我们可以捕获异常并在需要时执行某些操作，但我们不是被迫这样做。异常在调用堆栈中上升。
    |'
- en: 'The biggest difference between Kotlin and Java exception systems is that in
    Kotlin all exceptions are unchecked. This means we never have to surround a method
    with `try... catch` block even if this is a Java method that may throw a cached
    exception. We can still do it, but we are not forced to:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin和Java异常系统之间最大的区别在于，在Kotlin中所有异常都是未检查的。这意味着即使这是一个可能引发已捕获异常的Java方法，我们也永远不必用`try...
    catch`块包围一个方法。我们仍然可以这样做，但我们不是被迫这样做：
- en: '[PRE120]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: This approach removes code verbosity and improves safety because we don't need
    to introduce empty *catch* blocks.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法消除了代码冗余，并提高了安全性，因为我们不需要引入空的*catch*块。
- en: The try... catch block
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`try... catch`块'
- en: 'Kotlin `try... catch` block is the equivalent of the Java `try... catch` block.
    Let''s look at quick example:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的`try... catch`块相当于Java的`try... catch`块。让我们看一个快速的例子：
- en: '[PRE121]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Exceptions are not specified on function signature like in Java.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异常没有像Java那样在函数签名上指定。
- en: We check validity of data and throw `NullPointerException` (notice that no new
    keyword is required when creating an object instance).
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查数据的有效性，并抛出`NullPointerException`（请注意，在创建对象实例时不需要使用new关键字）。
- en: The `try... catch` block is similar construct from Java.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`try... catch`块是Java中的类似结构。'
- en: Handle only this specific exceptions (`AssertionError` exception).
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅处理特定的异常（`AssertionError`异常）。
- en: The `finally` block is always executed.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`finally`块总是被执行。'
- en: There may be zero or more `catch` blocks and `finally` block may be omitted.
    However, at least one `catch` or `finally` block should be present.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有零个或多个`catch`块，`finally`块可以省略。但是，至少应该有一个`catch`或`finally`块存在。
- en: 'In Kotlin, exception handling `try` is an expression, so it can return a value
    and we can assign its value to a variable. The actual assigned value is the last
    expression of the executed block. Let''s check if a particular Android application
    is installed on the device:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，异常处理`try`是一个表达式，因此它可以返回一个值，我们可以将其值分配给一个变量。实际分配的值是执行块的最后一个表达式。让我们检查设备上是否安装了特定的Android应用程序：
- en: '[PRE122]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The `try... catch` block is returning value that is returned by a single expression
    function.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`try... catch`块返回的值是由单个表达式函数返回的值。'
- en: If an application is installed, the `getPackageInfo` method will return a value
    (this value is ignored) and the next line containing `true` expression will be
    executed. This is the last operation performed by a `try` block, so its value
    will be assigned to a variable (`true` ).
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序已安装，`getPackageInfo`方法将返回一个值（此值被忽略），并且将执行包含`true`表达式的下一行。这是`try`块执行的最后一个操作，因此它的值将被分配给一个变量（`true`）。
- en: If an app is not installed, `getPackageInfo` will throw `PackageManager.NameNotFoundException`
    and the `catch` block will be executed. The last line of the `catch` block contains
    a `false` expression, so its value will be assigned to a variable.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序未安装，`getPackageInfo`将抛出`PackageManager.NameNotFoundException`，并且将执行`catch`块的最后一行，其中包含一个`false`表达式，因此它的值将被分配给一个变量。
- en: Compile-time constants
  id: totrans-476
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译时常量
- en: 'Since the `val` variable is read only, in most cases we could treat it as a
    constant. We need to be aware that its initialization may be delayed, so this
    means that there are scenarios where the `val` variable may not be initialized
    at compile time, for example, assigning the result of the method call to a value:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`val`变量是只读的，在大多数情况下我们可以将其视为常量。我们需要意识到它的初始化可能会延迟，这意味着有些情况下`val`变量可能在编译时未被初始化，例如，将方法调用的结果赋给一个值：
- en: '[PRE123]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'This value will be assigned at runtime. There are, however, situations where
    we need to know the value at compile time. The exact value is required when we
    want to pass parameters to annotations. Annotations are processed by an annotation
    processor that runs long before the application is started:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值将在运行时被赋值。然而，有些情况下我们需要在编译时知道这个值。当我们想要向注解传递参数时，需要确切的值。注解是由注解处理器处理的，它在应用程序启动之前就运行了：
- en: '![](img/Image00031.jpg)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00031.jpg)'
- en: 'To make absolutely sure that the value is known at compile time (and thus can
    be processed by an annotation processor), we need to mark it with a `const` modifier.
    Let''s define a custom annotation `MyLogger` with a single parameter defining
    maximum log entries and annotate a `Test` class with it:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保值在编译时是已知的（因此可以被注解处理器处理），我们需要用`const`修饰符标记它。让我们定义一个自定义注解`MyLogger`，并用一个参数定义最大日志条目，并用它注解一个`Test`类：
- en: '[PRE124]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: There are couple limitations regarding usage of `const` that we must be aware
    of. The first limitation is that it must be initialized with values of primitive
    types or `String` type. The second limitation is that it must be declared at the
    top level or as a member of an object. We will discuss objects in [Chapter 4](text00088.html)
    , *Classes and Objects* . The third limitation is that they cannot have a custom
    getter.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用`const`有一些限制我们必须意识到。第一个限制是它必须用原始类型或`String`类型的值进行初始化。第二个限制是它必须在顶层声明或作为对象的成员声明。我们将在[第4章](text00088.html)，*类和对象*中讨论对象。第三个限制是它们不能有自定义的getter。
- en: Delegates
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代表
- en: Kotlin provides first-class support for delegation. It is very useful improvement
    comparing to Java. If fact, there are many applications for delegates in Android
    development, so we have decided to spare a whole chapter on this subject ([Chapter
    8](text00205.html) , *Delegates* ).
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin为委托提供了一流的支持。与Java相比，这是非常有用的改进。事实上，在Android开发中有许多委托的应用，因此我们决定在这个主题上多花一个章节（[第8章](text00205.html)，*代表*）。
- en: Summary
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have discussed the differences between variables, values,
    and consts and discussed basic Kotlin data types including ranges. We also looked
    into a Kotlin type system that enforces strict null safety and ways to deal with
    nullable references using various operators and smart casts. We know that we can
    write more concise code by taking advantage of using type inference and various
    control structures that in Kotlin are treated as expressions. Finally, we discussed
    ways of exception handling.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了变量、值和常量之间的区别，并讨论了基本的Kotlin数据类型，包括范围。我们还研究了一个强制严格的空安全的Kotlin类型系统，以及使用各种操作符和智能转换处理可空引用的方法。我们知道，通过利用类型推断和Kotlin中被视为表达式的各种控制结构，我们可以编写更简洁的代码。最后，我们讨论了异常处理的方法。
- en: In the next chapter, we will learn about functions and present different ways
    of defining them. We will cover concepts such as single-expression functions,
    default arguments and named argument syntax, and discuss various modifiers.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于函数，并介绍不同的定义方式。我们将涵盖单表达式函数、默认参数和命名参数语法等概念，并讨论各种修饰符。
