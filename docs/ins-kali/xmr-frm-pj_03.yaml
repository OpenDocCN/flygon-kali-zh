- en: A Matchmaking App with a Rich UX Using Animations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画创建具有丰富UX的匹配应用程序
- en: In this chapter, we will create the base functionality for a matchmaking app.
    We won't be rating people, however, because of privacy issues. Instead, we will
    download images from a random source on the internet. This project is for anyone
    who wants an introduction to how to write reusable controls. We will also look
    at using animations to make our application feel nicer to use. This app will not
    be an MVVM application, since we want to isolate the creation and usage of a control
    from the slight overhead of MVVM.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为匹配应用程序创建基本功能。但由于隐私问题，我们不会对人们进行评分。相反，我们将从互联网上的随机来源下载图像。这个项目适用于任何想要了解如何编写可重用控件的人。我们还将研究如何使用动画使我们的应用程序更加愉快。这个应用程序不会是一个MVVM应用程序，因为我们想要将控件的创建和使用与MVVM的轻微开销隔离开来。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a custom control
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义控件
- en: How to style the app to look like a photo with descriptive text beneath it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将应用程序样式设置为带有描述性文本的照片
- en: Animations using Xamarin.Forms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Xamarin.Forms进行动画
- en: Subscribing to custom events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅自定义事件
- en: Reusing the custom control over and over again
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反复使用自定义控件
- en: Handling pan gestures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理平移手势
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To be able to complete this project, you will need to have Visual Studio for
    Mac or Windows installed, as well as the necessary Xamarin components. See [Chapter
    1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction to Xamarin*, for
    more details on how to set up your environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此项目，您需要安装Visual Studio for Mac或Windows以及必要的Xamarin组件。有关如何设置您的环境的更多详细信息，请参阅[第1章](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml)*Xamarin简介*。
- en: Project overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'Many of us have been there, faced with the conundrum to swipe left or right.
    All of a sudden, you may find yourself wondering: how does this work? How does
    the swipe magic happen? Well, in this project, we''re going to learn all about
    it. We will start by defining a `MainPage` file, in which the images of our application
    will reside. After that, we will create the image control and gradually add the
    GUI and functionality to it until we have nailed the perfect swiping experience.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中的许多人都曾面临过左右滑动的困境。突然间，您可能会想知道：这是如何工作的？滑动魔术是如何发生的？在这个项目中，我们将学习所有这些。我们将首先定义一个`MainPage`文件，其中我们应用程序的图像将驻留。之后，我们将创建图像控件，并逐渐向其添加GUI和功能，直到我们完美地掌握了完美的滑动体验。
- en: The build time for this project is about 90 minutes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的构建时间约为90分钟。
- en: Creating the matchmaking app
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建匹配应用程序
- en: In this project, we will learn more about creating reusable controls that can
    be added to a XAML page. To keep things simple, we will not be using MVVM, but
    bare-metal Xamarin.Forms without any data binding. What we aim to create is an
    app that allows the user to swipe images, either to the right or the left, just
    like most popular matchmaking applications do.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将学习如何创建可添加到XAML页面的可重用控件。为了保持简单，我们不会使用MVVM，而是使用裸露的Xamarin.Forms，没有任何数据绑定。我们的目标是创建一个允许用户向左或向右滑动图像的应用程序，就像大多数流行的匹配应用程序一样。
- en: Well, let's get started by creating the project!
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们开始创建项目吧！
- en: Creating the project
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: Just as with the to-do list app in [Chapter 2](17d85c89-a26f-440a-9591-a859915936a8.xhtml), *Building
    our First Xamarin.Forms App,* this chapter will start with a clean File | New
    Project approach. We are going to opt for a .NET Standard approach rather than
    a shared code approach in this chapter; please refer back to [Chapter 2](17d85c89-a26f-440a-9591-a859915936a8.xhtml)*,
    Building our First Xamarin.Forms App* to gain more insight into the differences
    between them if you're not sure why we're doing this.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就像[第2章](17d85c89-a26f-440a-9591-a859915936a8.xhtml)中的待办事项应用程序*构建我们的第一个Xamarin.Forms应用*一样，本章将从干净的文件|新建项目方法开始。在本章中，我们将选择.NET标准方法，而不是共享代码方法；如果您不确定为什么要这样做，请参考[第2章](17d85c89-a26f-440a-9591-a859915936a8.xhtml)*构建我们的第一个Xamarin.Forms应用*以更深入地了解它们之间的区别。
- en: Let's get started!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Creating the new project
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新项目
- en: 'Open up Visual Studio and click on File | New| Project:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Visual Studio并单击文件|新建|项目：
- en: '![](img/2c4f5dc4-6442-4bb5-b899-ac02fcd8589a.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c4f5dc4-6442-4bb5-b899-ac02fcd8589a.png)'
- en: 'This will open up the New Project dialog. Expand the Visual C# node and click
    on Cross-Platform. Select the Mobile App (Xamarin.Forms) item from the list. Complete
    the form by naming your project. We will be calling our application `Swiper` in
    this case. Move on to the next dialog by clicking OK:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开新项目对话框。展开Visual C#节点，然后单击跨平台。从列表中选择移动应用程序（Xamarin.Forms）项目。通过为项目命名来完成表单。在这种情况下，我们将称我们的应用程序为`Swiper`。单击确定继续下一个对话框：
- en: '![](img/6dd491eb-f2d5-4c88-b17d-e476c30252a0.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6dd491eb-f2d5-4c88-b17d-e476c30252a0.png)'
- en: 'The next step is to select a project template and a Code Sharing Strategy.
    Select Blank to create a bare minimum Xamarin.Forms app and make sure that the
    Code Sharing Strategy is set to .NET Standard. Finish the setup wizard by clicking
    OK and let Visual Studio scaffold the project for you. This might take a couple
    of minutes:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是选择项目模板和代码共享策略。选择空白以创建最少的Xamarin.Forms应用程序，并确保代码共享策略设置为.NET标准。通过单击确定完成设置向导，让Visual
    Studio为您搭建项目。这可能需要几分钟。
- en: '![](img/c7b99529-fb5f-4e21-9645-2a0355e5a7f4.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7b99529-fb5f-4e21-9645-2a0355e5a7f4.png)'
- en: Just like that, the app is created. Let's move on to updating Xamarin.Forms
    to the latest version.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，应用程序就创建好了。让我们继续更新Xamarin.Forms到最新版本。
- en: Updating the Xamarin.Forms NuGet packages
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Xamarin.Forms NuGet包
- en: 'Currently, the Xamarin.Forms version that your project will be created with
    is most likely a bit old. To rectify this, we need to update the NuGet Packages.
    Please note that you should only update the Xamarin.Forms packages and not the
    Android packages; doing the latter might cause your packages to get out of sync
    with each other, resulting in the app not building at all. To update the NuGet
    packages, perform the following steps:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您的项目将使用的Xamarin.Forms版本很可能有点旧。为了纠正这一点，我们需要更新NuGet包。请注意，您应该只更新Xamarin.Forms包，而不是Android包；做后者可能会导致您的包与彼此不同步，导致应用程序根本无法构建。要更新NuGet包，请执行以下步骤：
- en: Right-click on our Solution in the Solution Explorer**.**
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击解决方案资源管理器中的我们的解决方案。
- en: 'Click Manage NuGet Packages for Solution...:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“管理解决方案的NuGet包...”：
- en: '![](img/06856d6f-77d3-495c-a68b-027bd539551a.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/06856d6f-77d3-495c-a68b-027bd539551a.png)'
- en: 'This will open the NuGet Package Manager in Visual Studio:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Visual Studio中打开NuGet包管理器。
- en: '![](img/e4b51aa2-5c58-477b-91ec-c03889265b91.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4b51aa2-5c58-477b-91ec-c03889265b91.png)'
- en: 'To update Xamarin.Forms to the latest version, perform the following steps:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Xamarin.Forms更新到最新版本，请执行以下步骤：
- en: Click the Updates tab.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“更新”选项卡。
- en: Check Xamarin.Forms and click Update**.**
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查Xamarin.Forms并点击“更新”。
- en: Accept any license agreements.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受任何许可协议。
- en: 'The update takes at most a few minutes. Check the output pane to find information
    about the update. At this point, we can run the app to make sure it works. We
    should see the text Welcome to Xamarin.Forms! in the middle of the screen:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 更新最多需要几分钟。检查输出窗格以找到有关更新的信息。此时，我们可以运行应用程序以确保它正常工作。我们应该在屏幕中央看到“欢迎使用Xamarin.Forms！”的文字：
- en: '![](img/f88d39be-89c8-4780-ac84-18b8c6582c74.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f88d39be-89c8-4780-ac84-18b8c6582c74.png)'
- en: Designing the MainPage  file
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计MainPage文件
- en: A brand new blank Xamarin.Forms app named `Swiper` is created with a single
    page called `MainPage.xaml`. This is located in the .NET Standard Project that
    is referenced by all platform-specific projects. We will need to replace the XAML template
    with a new layout that will contain our `Swiper` control.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个全新的空白Xamarin.Forms应用程序，名为“Swiper”，其中包含一个名为“MainPage.xaml”的页面。这位于由所有特定于平台的项目引用的.NET标准项目中。我们需要用一个新的布局替换XAML模板，该布局将包含我们的“Swiper”控件。
- en: 'Let''s edit the already existing `MainPage.xaml` file by replacing the default
    content with what we need:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过用我们需要的内容替换默认内容来编辑已经存在的“MainPage.xaml”文件：
- en: Open the `MainPage.xaml` file.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“MainPage.xaml”文件。
- en: 'Replace the content of the page with the following XAML code marked in bold:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下加粗标记的XAML代码替换页面的内容：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The XAML within the `ContentPage` node defines two grids in the application.
    A grid is simply a container for other controls. It positions those controls based
    on rows and columns. The outer grid, in this case, defines two rows that will
    cover the entire available area of the screen. The first row is `400` units high
    and the second row, with `height="*"`, uses the rest of the available space.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentPage`节点内的XAML定义了应用程序中的两个网格。网格只是其他控件的容器。它根据行和列来定位这些控件。外部网格在这种情况下定义了两行，将覆盖整个屏幕的可用区域。第一行高度为400个单位，第二行的`height="*"`使用了剩余的可用空间。'
- en: The inner grid, which is defined within the first grid, is assigned to the second
    row with the attribute `Grid.Row="1"`. The row and column indexes are zero-based,
    so `"1"` actually refers to the second row. We will add some content to this grid
    later on in the chapter, but we'll leave it empty for now.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 内部网格，它在第一个网格内定义，并且使用属性“Grid.Row="1"”分配给第二行。行和列索引是从零开始的，所以“1”实际上指的是第二行。我们将在本章后面向这个网格添加一些内容，但现在我们将其保留为空白。
- en: Both grids define their padding. You could enter a single number, meaning that
    all sides will have the same padding, or as in this case, enter two numbers. We
    have entered `0,40`, which means that the left and right sides should have zero
    units of padding and the top and bottom should have `40` units of padding. There
    is also a third option with four digits, which sets the padding of the *left*
    side, the *top*, the *right* side, and the *bottom*, in that specific order.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 两个网格都定义了它们的填充。您可以输入一个数字，表示所有边都有相同的填充，或者像这种情况一样输入两个数字。我们输入了“0,40”，这意味着左右两侧应该有零单位的填充，顶部和底部应该有40个单位的填充。还有第三个选项，使用四个数字，按照特定顺序设置*左*侧、*顶部*、*右*侧和*底部*的填充。
- en: The last thing to notice is that we give the outer grid a name, `x:Name="MainGrid"`.
    This will make it directly accessible from the code-behind defined in the `MainPage.xaml.cs`
    file. Since we are not using MVVM in this example, we will need a way to access
    the grid without data binding.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一件事是，我们给外部网格一个名称，“x:Name="MainGrid"”。这将使它可以直接从“MainPage.xaml.cs”文件中定义的代码后台访问。由于在这个示例中我们没有使用MVVM，我们需要一种方法来访问网格而不使用数据绑定。
- en: Creating the Swiper control
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Swiper控件
- en: The main part of this project involves creating the `Swiper` control. A control
    is a self-contained UI with a code-behind to go with it. It can be added to any
    XAML page as an element or in code in the code-behind file. We will be adding
    the control from code in this project.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的主要部分涉及创建“Swiper”控件。控件是一个自包含的UI，带有相应的代码后台。它可以作为元素添加到任何XAML页面中，也可以在代码后台文件中的代码中添加。在这个项目中，我们将从代码中添加控件。
- en: Creating the control
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控件
- en: 'Creating the `Swiper` control is a straightforward process. We just need to
    make sure that we select the correct item template, which is the Content View:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建“Swiper”控件是一个简单的过程。我们只需要确保选择正确的项模板，即内容视图：
- en: In the .NET Standard library project, create a folder called `Controls`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET标准库项目中，创建一个名为“Controls”的文件夹。
- en: Right-click on the `Controls` folder, select Add, and then click New item....
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“控件”文件夹，选择“添加”，然后点击“新建项...”。
- en: Select Visual C# Items and then Xamarin.Forms in the left pane of the Add New
    Item dialog box.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“添加新项”对话框框的左窗格中选择Visual C#项目，然后选择Xamarin.Forms。
- en: Select the Content View (C#) item. Make sure you don't select the C# version;
    this only creates a `C#` file and not an `XAML` file.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择内容视图（C#）项目。确保不选择C#版本；这只会创建一个`C#`文件，而不是一个`XAML`文件。
- en: Name the control `SwiperControl.xaml`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将控件命名为`SwiperControl.xaml`。
- en: Click Add**:**
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击添加：
- en: '![](img/b193f73c-c111-45c4-ba8c-bcf13b827ac8.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b193f73c-c111-45c4-ba8c-bcf13b827ac8.png)'
- en: 'This adds an XAML file for the UI and a C# code-behind file. It should look
    like the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为UI添加一个XAML文件和一个C#代码后台文件。它应该看起来像下面的截图：
- en: '![](img/2dfdd5eb-85b8-4b27-a121-856276cff123.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2dfdd5eb-85b8-4b27-a121-856276cff123.png)'
- en: Defining the main grid
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义主网格
- en: 'Let''s set the basic structure of the `Swiper` control:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置`Swiper`控件的基本结构：
- en: Open the `SwiperControl.xaml` file.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SwiperControl.xaml`文件。
- en: 'Replace the content with the code marked in bold:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用粗体标记的代码替换内容：
- en: '[PRE1]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This defines a grid with three columns. The leftmost and the rightmost columns
    will take up `100` units of space and the center will occupy the rest of the available
    space. The spaces on the sides will be areas in which we will add labels to highlight
    the choice that the user has made. We've also added three comments that act as
    placeholders for the XAML to come.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个具有三列的网格。最左边和最右边的列将占据`100`个单位的空间，中间将占据其余的可用空间。两侧的空间将是我们将添加标签以突出用户所做选择的区域。我们还添加了三个注释，作为即将到来的XAML的占位符。
- en: Adding a content view for the photo
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为照片添加内容视图
- en: 'We will now extend the `SwiperControl.xaml` file by adding a definition of
    what we want the photo to look like. Our final result will look like the following
    photo. Since we are going to pull images off the internet, we''ll display a loading
    text to make sure that the user gets feedback on what''s going on. To make it
    look like an instantly printed photo, we add some handwritten text under the photo:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过添加定义我们希望照片看起来的XAML来扩展`SwiperControl.xaml`文件。我们的最终结果将看起来像下面的照片。由于我们将从互联网上获取图像，我们将显示一个加载文本，以确保用户了解正在发生什么。为了使其看起来像即时打印的照片，我们在照片下面添加了一些手写文本：
- en: '![](img/fc24bad2-9388-46f0-b350-a800700d8816.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc24bad2-9388-46f0-b350-a800700d8816.png)'
- en: 'The preceding photo is what we would like the photo to look like. To make it
    a reality, we need to add some XAML to the `SwiperControl`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的照片是我们希望照片看起来的样子。为了使其成为现实，我们需要向`SwiperControl`添加一些XAML：
- en: Open up `SwiperControl.xaml`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SwiperControl.xaml`。
- en: 'Add the XAML in bold to the following comment: `<!-- ContentView for photo
    here -->`. Make sure that you do not replace the entire `ContentView` for the
    page; just add this under the comment as follows. The rest of the page should
    be untouched:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将粗体的XAML添加到以下注释中：`<!-- ContentView for photo here -->`。确保不要替换页面的整个`ContentView`；只需在注释下面添加如下。页面的其余部分应保持不变：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A `ContentView` control defines a new area where we can add other controls.
    One very important feature of a `ContentView` is that it only takes one child
    control. Most of the time, we would add one of the layout controls that are available.
    In this case, we'll use a `Grid` control to lay out the control, as shown in the
    preceding code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentView`控件定义了一个新的区域，我们可以在其中添加其他控件。`ContentView`的一个非常重要的特性是它只接受一个子控件。大多数情况下，我们会添加其中一个可用的布局控件。在这种情况下，我们将使用`Grid`控件来布局控件，如前面的代码所示。'
- en: 'The grid defines two rows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 网格定义了两行：
- en: A row for the photo itself, which takes up all the available space when the
    other rows have been allocated space
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于照片本身的行，在分配了其他行的空间后占据所有可用空间
- en: A row for the comment, which will be exactly `40` units in height
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于评论的行，其高度恰好为`40`个单位
- en: The `Grid` itself is set to use a black background and a padding of `1`. This,
    in combination with a `BoxView`, which has a white background, creates the frame
    that we see around the control. The `BoxView` is also set to span both rows of
    the grid (`Grid.RowSpan="2"`), taking up the entire area of the grid, minus the
    padding.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid`本身设置为使用黑色背景和`1`的填充。这与`BoxView`结合使用，`BoxView`具有白色背景，创建了我们在控件周围看到的框架。`BoxView`还设置为跨越网格的两行（`Grid.RowSpan="2"`），占据网格的整个区域，减去填充。'
- en: The `Image` control comes next. It has a background color set to a nice gray
    tone (`#AAAAAA`) and a margin of `40`, which will separate it a bit from the frame
    around it. It also has a hardcoded name (`x:Name="image"`), which will allow us
    to interact with it from the code-behind. The last attribute, called `Aspect`,
    determines what we should do if the image control isn't of the same ratio as the
    source image. In this case, we want to fill the entire image area, but not show
    any blank areas. This effectively crops the image either in height or in width.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Image`控件。它的背景颜色设置为漂亮的灰色（`#AAAAAA`），边距为`40`，这将使其与周围的框架分离一点。它还有一个硬编码的名称（`x:Name="image"`），这将允许我们从代码后台与其交互。最后一个属性叫做`Aspect`，确定如果图像控件与源图像的比例不同，我们应该怎么做。在这种情况下，我们希望填充整个图像区域，但不显示任何空白区域。这实际上会裁剪图像的高度或宽度。
- en: We finish off by adding two labels, which also have hardcoded names for later
    reference.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过添加两个标签来结束，这些标签也有硬编码的名称以供以后参考。
- en: Creating the DescriptionGenerator
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建DescriptionGenerator
- en: 'At the bottom of the image, we see a description. Since we don''t have any
    general descriptions of the images from our upcoming image source, we need to
    create a generator that makes up descriptions. Here''s how we would do it:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像的底部，我们看到了一个描述。由于我们没有来自即将到来的图像源的图像的一般描述，我们需要创建一个生成器来制作描述。下面是我们将如何做：
- en: Create a folder called `Utils` in the .NET Standard project.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在.NET Standard项目中创建一个名为`Utils`的文件夹。
- en: Create a new class called `DescriptionGenerator` in that folder.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中创建一个名为`DescriptionGenerator`的新类。
- en: Add a `using` statement for `System.Linq` (`using System.Linq;`).
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`System.Linq`添加一个`using`语句（`using System.Linq;`）。
- en: 'Add the following code to the class:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This class only has one purpose. It takes one random word from the `_adjectives`
    array and combines it with a random word from the `_other` array. By calling the
    `Generate()` method, we get a fresh new combination. Feel free to enter your own
    words in the arrays. Note that the `Random` instance is a static field. This is
    because if we create new instances of the `Random` class that are too close to
    each other in time, they get seeded with the same value and return the same sequence
    of random numbers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只有一个目的。它从`_adjectives`数组中取一个随机单词，并将其与`_other`数组中的一个随机单词结合起来。通过调用`Generate()`方法，我们得到一个全新的组合。请随意在数组中输入自己的单词。请注意，`Random`实例是一个静态字段。这是因为如果我们在时间上创建了太接近的`Random`类的新实例，它们将以相同的值进行种子化，并返回相同的随机数序列。
- en: Creating a picture class
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个图片类
- en: 'To abstract all the information about the image we want to display, we''ll
    create a class that encapsulates this information. There isn''t much information
    in our `Picture` class, but it is good coding practice to do this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了抽象出我们想要显示的图像的所有信息，我们将创建一个封装了这些信息的类。我们的`Picture`类中没有太多信息，但这是一个很好的编码实践：
- en: Create a new class called `Picture` in the `Utils` folder.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Utils`文件夹中创建一个名为`Picture`的新类。
- en: 'Add the following code to the class:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE4]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Picture` class has two public properties:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Picture`类有两个公共属性：'
- en: The `Uri` of an image, which points to its location on the internet
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的`URI`，指向其在互联网上的位置
- en: The description of that image
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该图像的描述
- en: In the constructor, we create a new **Uniform Resource Identifier** (**URI**),
    which points to a public source of test photos that we can use. The width and
    height are specified in the query string part of the URI. We also append a random
    timestamp to avoid the images being cached by Xamarin.Forms. This generates a
    unique URI each time we request an image.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们创建一个新的**统一资源标识符**（**URI**），它指向一个我们可以使用的测试照片的公共来源。宽度和高度在URI的查询字符串部分中指定。我们还附加了一个随机时间戳，以避免Xamarin.Forms缓存图像。这样每次请求图像时都会生成一个唯一的URI。
- en: We then use the `DescriptionGenerator` class that we created to generate a random
    description for the image.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用我们创建的`DescriptionGenerator`类来为图像生成一个随机描述。
- en: Binding the picture to the control
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图片绑定到控件
- en: Let's begin to wire up the `Swiper` control so that it starts displaying images.
    We need to set the source of an image and then control the visibility of the loading
    label based on the status of the image. Since we are using an image fetched from
    the internet, it might take a couple of seconds to download. This has to be communicated
    to the user to avoid confusion about what is going on.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始连接`Swiper`控件，以便开始显示图像。我们需要设置图像的源，然后根据图像的状态控制加载标签的可见性。由于我们使用的是从互联网获取的图像，可能需要几秒钟才能下载。这必须向用户传达，以避免对正在发生的事情产生困惑。
- en: Setting the source
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置源
- en: We begin by setting the source of the image. The `image` control (referred to
    as `image` in the code) has a `source` property. This property is of the abstract
    type, `ImageSource`. There are a few different types of image sources that you
    can use. The one we are interested in is the `UriImageSource`, which takes a URI,
    downloads the image, and allows the image control to display it.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置图像的源。`image`控件（在代码中称为`image`）有一个`source`属性。这个属性是抽象类型`ImageSource`。有几种不同类型的图像源可以使用。我们感兴趣的是`UriImageSource`，它接受一个URI，下载图像，并允许图像控件显示它。
- en: 'Let''s extend the `Swiper` control to set the source and description:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展`Swiper`控件以设置源和描述：
- en: Open the `Controls/Swiper.Xaml.cs` file (the code-behind for the `Swiper` control).
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/Swiper.Xaml.cs`文件（`Swiper`控件的代码后端）。
- en: Add a using statement for `Swiper.Utils` (`using Swiper.Utils;`).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Swiper.Utils`添加一个使用语句（`using Swiper.Utils;`）。
- en: 'Add the code marked in bold to the constructor:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将加粗标记的代码添加到构造函数中：
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We create a new instance of a `Picture` class and assign the description to
    the `descriptionLabel` in the GUI by setting the text property of that control.
    We then set the source of the image to a new instance of a `UriImageSource` class
    and assign the URI from the picture instance. This will start the download of
    the image from the internet and display it as soon as it is downloaded.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`Picture`类的新实例，并通过设置该控件的文本属性将描述分配给GUI中的`descriptionLabel`。然后，我们将图像的源设置为`UriImageSource`类的新实例，并将URI从图片实例分配给它。这将开始从互联网下载图像，并在下载完成后立即显示它。
- en: Controlling the loading label
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制加载标签
- en: While the image is downloading, we want to show a loading text centered over
    the image. This is already in the XAML file that we created earlier, so what we
    really need to do is hide it once the image is downloaded. We will do this by
    controlling the `IsVisibleProperty` of the `loadingLabel` by setting a binding
    to the `IsLoading` property of the image. Any time the `IsLoading` property is
    changed on the image, the binding changes the `IsVisible` property on the label.
    This is a nice fire-and-forget approach.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像下载时，我们希望在图像上方显示一个居中的加载文本。这已经在我们之前创建的XAML文件中，所以我们真正需要做的是在图像下载完成后隐藏它。我们将通过控制`loadingLabel`的`IsVisibleProperty`来实现这一点，通过将其绑定到图像的`IsLoading`属性。每当图像上的`IsLoading`属性发生变化时，绑定就会改变标签上的`IsVisible`属性。这是一个很好的一劳永逸的方法。
- en: 'Let''s add the code needed to control the loading label:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加控制加载标签所需的代码：
- en: Open the `Swiper.xaml.cs` code-behind file.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Swiper.xaml.cs`代码后端文件。
- en: 'Add the code marked in bold to the constructor:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将加粗标记的代码添加到构造函数中：
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, the `loadingLabel` sets a binding to the `IsVisibleProperty`,
    which actually belongs to the `VisualElement` class that all controls inherit
    from. It tells the `loadingLabel` to listen to changes in the `IsLoading` property
    of whichever object is assigned to the binding context. In this case, this is
    the `image` control.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，`loadingLabel`设置了一个绑定到`IsVisibleProperty`，实际上属于所有控件继承的`VisualElement`类。它告诉`loadingLabel`监听绑定上下文中分配的对象的`IsLoading`属性的变化。在这种情况下，这是`image`控件。
- en: Handling pan gestures
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理平移手势
- en: A core feature of this app is the pan gesture. A pan gesture is when a user
    presses on the control and moves it around the screen. We will also add a random
    rotation to the `Swiper` control to make it look like there are photos in a stack
    when we add multiple images.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的核心功能之一是平移手势。平移手势是指用户按住控件并在屏幕上移动它。当我们添加多个图像时，我们还将为`Swiper`控件添加随机旋转，使其看起来像是堆叠的照片。
- en: 'We start by adding some fields to the `SwiperControl`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先向`SwiperControl`添加一些字段：
- en: Open the `SwiperControl.xaml.cs`  file.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SwiperControl.xaml.cs`文件。
- en: 'Add the following fields in the code to the class:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下字段：
- en: '[PRE7]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first field, `_initialRotation`, stores the initial rotation of the image.
    We will set this in the constructor. The second field is a `static` field containing
    a `Random` object. As you might remember, it's better to create one static random
    object to make sure multiple random objects don't get created with the same seed.
    The seed is based on time, so if we create objects too close in time to each other,
    they get the same random sequence generated, so it wouldn't actually be that random
    at all.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段`_initialRotation`存储图像的初始旋转。我们将在构造函数中设置这个值。第二个字段是一个包含`Random`对象的`static`字段。您可能还记得，最好创建一个静态随机对象，以确保不会使用相同的种子创建多个随机对象。种子是基于时间的，因此如果我们在时间上创建对象太接近，它们会生成相同的随机序列，因此实际上并不会那么随机。
- en: 'The next thing we have to do is create an event handler for the `PanUpdated`
    event that we will bind to at the end of this section:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要做的是为`PanUpdated`事件创建一个事件处理程序，我们将在本节末尾绑定到它：
- en: Open the `SwiperControl.xaml.cs` code-behind file.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SwiperControl.xaml.cs`代码后台文件。
- en: 'Add the `OnPanUpdated` method to the class:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`OnPanUpdated`方法添加到类中：
- en: '[PRE8]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The code is really straightforward. We handle an event that takes a `PanUpdatedEventArgs`
    object as the second argument. This is a standard method of handling events. We
    then have a `switch` clause that checks which status the event refers to.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常简单。我们处理一个事件，该事件将`PanUpdatedEventArgs`对象作为第二个参数。这是处理事件的标准方法。然后我们有一个`switch`子句，检查事件所指的状态。
- en: 'A pan gesture can have three states:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 平移手势可以有三种状态：
- en: '`GestureStatus.Started`: The event is raised once with this state when the
    panning begins'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GestureStatus.Started`: 当开始拖动时，此状态会被触发一次'
- en: '`GestureStatus.Running`:The event is then raised multiple times, once for each
    time you move your finger'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GestureStatus.Running`: 然后会多次触发此事件，每次您移动手指时都会触发一次'
- en: '`GestureStatus.Completed`:The event is raised one last time when you let go'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GestureStatus.Completed`: 当您松开时，事件会最后一次被触发'
- en: 'For each of these states, we call specific methods that handle the different
    states. We''ll continue with adding those methods now:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些状态中的每一个，我们调用处理不同状态的特定方法。现在我们将继续添加这些方法：
- en: Open the `SwiperControl.xaml.cs` code-behind file.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SwiperControl.xaml.cs`代码后台文件。
- en: 'Add these three methods to the class:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这三个方法添加到类中：
- en: '[PRE9]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's start by looking at `PanStarted()`. When the user starts dragging the
    image, we want to add the effect of it raising up a little bit over the surface.
    This is done by scaling the image by 10%. Xamarin.Forms has a set of excellent
    functions to do this. In this case, we call the `ScaleTo()` method on the image
    control (named `Photo`) and tell it to scale to `1.1`, which corresponds to 10%
    of its original size. We also tell it to do this in a duration of `100` ms. This
    call is also awaitable, which means we can wait for the control to finish animating
    before executing the next call. In this case, we are going to use a fire-and-forget
    approach.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`PanStarted()`开始。当用户开始拖动图像时，我们希望添加它在表面上稍微抬起的效果。这是通过将图像缩放10%来实现的。Xamarin.Forms有一组出色的函数来实现这一点。在这种情况下，我们在图像控件（名为`Photo`）上调用`ScaleTo()`方法，并告诉它缩放到`1.1`，这对应于其原始大小的10%。我们还告诉它在`100`毫秒内执行此操作。这个调用也是可等待的，这意味着我们可以在控件完成动画之前等待执行下一个调用。在这种情况下，我们将使用一种忘记并继续的方法。
- en: Next, we have `PanRunning()`, which is called multiple times during the pan
    operation. This takes an argument, which is the `PanUpdatedEventArgs` from the
    event handler that `PanRunning()` is called from. We could also just pass in an
    `X` and a `Y` value as arguments to reduce the coupling of the code. This is something
    that you can experiment with. The method extracts the `X` and `Y` components from
    the `TotalX`/`TotalY` properties of the event and assigns them to the `TranslationX`/`TranslationY`
    properties of the image control. We also adjust the rotation slightly, based on
    how far the image has been moved.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`PanRunning()`，在平移操作期间会多次调用。这个方法接受一个参数，即来自`PanRunning()`事件处理程序的`PanUpdatedEventArgs`。我们也可以只传入`X`和`Y`值作为参数，以减少代码的耦合。这是您可以尝试的一些东西。该方法从事件的`TotalX`/`TotalY`属性中提取`X`和`Y`分量，并将它们分配给图像控件的`TranslationX`/`TranslationY`属性。我们还根据图像移动的距离微调旋转。
- en: The last thing to do is to restore everything to its initial state when the
    image is released. This can be done in `PanCompleted()`. First, we translate (or
    move) the image back to its original local coordinates (`0,0`) in `250` ms. We
    also add an easing function to make it overshoot the target a bit and then animate
    back. We can play around with the different predefined easing functions; these
    are really useful for creating nice animations. We do the same to move the image
    back to its initial rotation. Finally, we scale it back to its original size in
    `250` ms.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的是在释放图像时将所有内容恢复到初始状态。这可以在`PanCompleted()`中完成。首先，我们将图像平移（或移动）回其原始本地坐标（`0,0`）在`250`毫秒内。我们还添加了一个缓动函数，使其略微超出目标，然后再次动画。我们可以尝试使用不同的预定义缓动函数；这些对于创建漂亮的动画非常有用。最后，我们将图像缩放回其原始大小在`250`毫秒内。
- en: 'It''s now time to add the code in the constructor that will wire up the pan
    gesture and set some initial rotation values:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在构造函数中添加代码，以连接平移手势并设置一些初始旋转值：
- en: Open the `SwiperControl.xaml.cs` code-behind file.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SwiperControl.xaml.cs`代码后台文件。
- en: 'Add the code in bold to the constructor. Note that there is more code in the
    constructor, so don''t copy and paste the whole method, just add the bold text:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中添加粗体文本。请注意，构造函数中还有更多代码，所以不要复制和粘贴整个方法，只需添加粗体文本：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All Xamarin.Forms controls have a property called `GestureRecognizers`. There
    are different types of gesture recognizers, such as `TapGestureRecognizer` or `SwipeGestureRecognizer`.
    In our case, we are interested in the `PanGestureRecognizer`. We create a new
    `PanGestureRecognizer` and subscribe to the `PanUpdated` event by hooking it up
    to the `OnPanUpdated()` method we created earlier. We then add it to the `Swiper`
    controls, `GestureRecognizers` collection.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Xamarin.Forms控件都有一个名为`GestureRecognizers`的属性。有不同类型的手势识别器，例如`TapGestureRecognizer`或`SwipeGestureRecognizer`。在我们的情况下，我们对`PanGestureRecognizer`感兴趣。我们创建一个新的`PanGestureRecognizer`，并通过将其连接到我们之前创建的`OnPanUpdated()`方法来订阅`PanUpdated`事件。然后将其添加到`Swiper`控件的`GestureRecognizers`集合中。
- en: We then set an initial rotation of the image and make sure we store it so that
    we can modify the rotation and then rotate it back to the original state.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们设置图像的初始旋转，并确保我们存储它，以便我们可以修改旋转，然后将其旋转回原始状态。
- en: Testing the control
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试控件
- en: 'We now have all the code written to take the control for a test run:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经编写了所有代码来测试控件：
- en: Open `MainPage.xaml.cs.`
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainPage.xaml.cs`。
- en: Add a `using` statement for the `Swiper.Controls` (`using Swiper.Controls;`).
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`using`语句用于`Swiper.Controls`（`using Swiper.Controls;`）。
- en: 'Add the code marked in bold to the constructor:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中添加粗体标记的代码：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If all goes well with the build, we should end up with an image like the following
    one:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建顺利，我们应该得到如下图所示的图像：
- en: '![](img/c04e8f44-09a8-4a7d-9488-46ef907f3e0c.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c04e8f44-09a8-4a7d-9488-46ef907f3e0c.png)'
- en: We can also drag the image around (pan it). Notice the slight lift effect when
    you begin dragging and the rotation of the image based on the amount of translation,
    which is the total movement. If you let go of the image, it animates back in place.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以拖动图像（平移）。注意当您开始拖动时的轻微抬起效果以及基于平移量的图像旋转，即总移动量。如果您放开图像，它会动画回到原位。
- en: Creating decision zones
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建决策区域
- en: 'A matchmaking app is nothing without those special drop-zones on each side
    of the screen. We want to do a few things here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 没有每一侧屏幕上的特殊放置区域，交友应用程序就不完整。我们在这里想做一些事情：
- en: When a user drags an image to either side, text should appear that says *LIKE*
    or *DENY* (the decision zones)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户将图像拖动到任一侧时，应该出现文本，显示*LIKE*或*DENY*（决策区域）
- en: When the users drop an image on a decision zone, the app should remove the image
    from the page
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户将图像放在决策区域时，应用程序应该从页面中删除图像
- en: We will create the zones by adding some XAML to the `SwiperControl.xaml` file
    and then move on to adding the necessary code to make this happen. It is worth
    noting here that the zones are not actually hotspots for dropping the image, but
    rather for displaying labels on top of the control surface. The actual drop-zones
    are calculated and determined based on how far you drag the image.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过向`SwiperControl.xaml`文件添加一些XAML代码来创建这些区域，然后继续添加必要的代码来实现这一点。值得注意的是，这些区域实际上并不是放置图像的热点区域，而是用于在控件表面上显示标签。实际的放置区域是根据您拖动图像的距离来计算和确定的。
- en: Extending the grid
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展网格
- en: The `Swiper` control has three columns defined. We want to add some kind of
    visual feedback to the user if the image is dragged to either side of the page.
    We will do this by adding a `StackLayout` with a `Label` on each side.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swiper`控件有三列定义。如果图像被拖到页面的任一侧，我们希望为用户添加某种视觉反馈。我们将通过在每一侧添加一个带有`Label`的`StackLayout`来实现这一点。'
- en: Adding the StackLayout for liking photos
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用于喜欢照片的StackLayout
- en: 'The first thing to do is to add the `StackLayout` for liking photos on the
    right-hand side of the control:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是在控件的右侧添加用于喜欢照片的`StackLayout`：
- en: Open `Controls/SwiperControl.xaml`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/SwiperControl.xaml`。
- en: 'Add the following code under the comment `<!-- StackLayout for like here -->`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注释`<!-- StackLayout for like here -->`下添加以下代码：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `StackLayout` is the container of what we want to display. It has a name
    and is assigned to be rendered in the third column (it says `Grid.Column="2"` in
    the code due to the zero indexing). The `Opacity` is set to `0`, making it completely
    invisible, and the `Padding` is adjusted to make it move down a bit from the top.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackLayout`是我们要显示的内容的容器。它有一个名称，并且被分配在第三列中（由于从零开始索引，代码中写着`Grid.Column="2"`）。`Opacity`设置为`0`，使其完全不可见，并且`Padding`调整为使其从顶部向下移动一点。'
- en: Inside the `StackLayout`, we'll add a `Label`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StackLayout`内，我们将添加一个`Label`。
- en: Adding the StackLayout for denying photos
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用于拒绝照片的StackLayout
- en: 'The next step is to add the `StackLayout` for denying photos on the left-hand
    side of the control:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在控件的左侧添加用于拒绝照片的`StackLayout`：
- en: Open `Controls/SwiperControl.xaml`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/SwiperControl.xaml`。
- en: 'Add the following code under the comment `<!-- StackLayout for deny here -->`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在注释`<!-- StackLayout for deny here -->`下添加以下代码：
- en: '[PRE13]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The setup for the left-hand side `StackLayout` is the same, except that it should
    be in the first column, which is the default, so there is no need to add a `Grid.Column`
    attribute. We have also specified `HorizontalOptions="End"`, which means that
    the content should be right-justified.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧`StackLayout`的设置与之相同，只是应该在第一列中，这是默认设置，因此不需要添加`Grid.Column`属性。我们还指定了`HorizontalOptions="End"`，这意味着内容应右对齐。
- en: Determining the screen size
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定屏幕大小
- en: To be able to calculate a percentage of how far the user has dragged the image,
    we need to know the size of the control. This is not determined until the control
    is laid out by Xamarin.Forms.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够计算用户拖动图像的百分比，我们需要知道控件的大小。这在Xamarin.Forms布局控件之后才确定。
- en: 'We will override the `OnSizeAllocated()` method and add a field in the class
    called `_screenWidth` to keep track of the current width of the window by following
    these few steps:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重写`OnSizeAllocated()`方法，并在类中添加一个名为`_screenWidth`的字段，以便通过以下几个步骤跟踪窗口的当前宽度：
- en: Open `SwiperControl.xaml.cs`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SwiperControl.xaml.cs`。
- en: 'Add the following code to the file. Put the field at the beginning of the class
    and the `OnSizeAllocated()` method below the constructor:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到文件中。将字段放在类的开头，将`OnSizeAllocated()`方法放在构造函数下面：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `_screenWidth` field is used to store the width as soon as we have resolved
    it. We do this by overriding the `OnSizeAllocated()` method that is called by
    Xamarin.Forms when the size of the control is allocated. This is called multiple
    times. The first time it's called is actually before the width and height have
    been set and before the `MainPage` of the current app is set. At this time, the
    width and height are set to `-1` and the `Application.Current.MainPage` is null.
    We look for this state by null checking `Application.Current.MainPage` and returning
    if it is null. We could also have checked for `-1` values on the width. Either
    method would work. If it does have a value, however, we want to store it in our
    `_screenWidth` field for later use.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`_screenWidth`字段用于在解析后立即存储宽度。我们通过重写`OnSizeAllocated()`方法来实现这一点，该方法在Xamarin.Forms分配控件的大小时调用。这被调用多次。第一次调用实际上是在设置宽度和高度之前以及设置当前应用程序的`MainPage`之前。此时，宽度和高度设置为`-1`，并且`Application.Current.MainPage`为null。我们通过对`Application.Current.MainPage`进行空检查并在其为null时返回来寻找这种状态。我们也可以检查宽度上的`-1`值。任一方法都可以工作。但是，如果它有一个值，我们希望将其存储在我们的`_screenWidth`字段中以供以后使用。'
- en: Xamarin.Forms will call the `OnSizeAllocated()` method any time the frame of
    the app changes. This is most relevant for UWP apps since they are in a window
    that a user can easily change. Android and iOS apps are less likely to get a call
    to this method a second time, since the app will take up the entire screen's real
    estate.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms会在应用程序框架发生变化时调用`OnSizeAllocated()`方法。这对于UWP应用程序来说最为重要，因为它们在用户可以轻松更改的窗口中。Android和iOS应用程序不太可能再次调用此方法，因为应用程序将占据整个屏幕的房地产。
- en: Adding a clamp function
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加夹取函数
- en: 'To be able to calculate the state, we need to clamp a value later on. At the
    time of writing, this function is already in Xamarin.Forms, but it''s marked as
    an internal function, meaning that we shouldn''t really be using it. According
    to the rumors, it will soon be made public in later versions of Xamarin.Forms,
    but for now, we need to redefine it ourselves:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够计算状态，我们需要稍后夹取一个值。在撰写本文时，这个函数已经在Xamarin.Forms中，但它被标记为内部函数，这意味着我们不应该真的使用它。据传言，它将很快在Xamarin.Forms的后续版本中公开，但目前，我们需要重新定义它：
- en: Open `SwiperControl.xaml.cs`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SwiperControl.xaml.cs`。
- en: 'Add the following `static` method to the class:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下`static`方法：
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The method takes a value to clamp, a minimum boundary, and a maximum boundary.
    It returns either the value itself, or the edge value, if it's greater or larger
    than the set boundaries.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个要夹取的值，一个最小边界和一个最大边界。如果值大于或小于设置的边界，则返回值本身或边界值。
- en: Adding code to calculate the state
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加计算状态的代码
- en: To calculate the state of the image, we need to define what our zones are and
    then create a function that takes the current amount of movement and updates the
    opacity of the GUI decision zones based on how far we panned the image.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算图像的状态，我们需要定义我们的区域，然后创建一个函数，该函数接受当前移动量并根据我们平移图像的距离更新GUI决策区域的不透明度。
- en: Defining a method for calculating the state
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个用于计算状态的方法
- en: 'Let''s add the `CalculatePanState()` method to calculate how far we have panned
    the image, and if it should start to affect the GUI, by following these few steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`CalculatePanState()`方法来计算我们已经平移图像的距离，以及它是否应该开始影响GUI，按照以下几个步骤进行：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/SwiperControl.xaml.cs`。
- en: 'Add the properties at the top and the `CalculatePanState()` method anywhere in
    the class, as shown in the following code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性添加到顶部，将`CalculatePanState()`方法添加到类中的任何位置，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We define two values as constants:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将两个值定义为常量：
- en: The `DeadZone`, which defines that 40% (`0.4`) of the available space on either
    side of the center point is a dead zone when panning an image. If we release the
    image in this zone, it simply returns to the center of the screen without any
    action being taken.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeadZone`定义了当平移图像时，中心点两侧可用空间的40%（`0.4`）是死区。如果我们在这个区域释放图像，它将简单地返回到屏幕中心而不采取任何行动。'
- en: The next constant is the `DecisionThreshold`, which defines another 40% (`0.4`)
    of the available space. This is used for interpolating the opacity of the `StackLayout`
    on either side of the layout.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个常量是`DecisionThreshold`，它定义了另外40%（`0.4`）的可用空间。这用于插值`StackLayout`在布局两侧的不透明度。
- en: We then use these values to check the state of the panning action whenever the
    panning changes. If the absolute panning value of `X` (`panX`) is less than the
    dead zone, we return without any action being taken. If not, we calculate how
    far over the dead zone we have passed and how far into the decision zone we are.
    We calculate the opacity values based on this interpolation and clamp the value
    between `-1` and `1`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用这些值来检查平移操作的状态。如果`X`（`panX`）的绝对平移值小于死区，我们将返回而不采取任何行动。如果不是，则我们计算我们已经超过死区的距离以及我们进入决策区的距离。我们根据这个插值计算不透明度值，并将值夹取在`-1`和`1`之间。
- en: Finally, we set the opacity to this value for both `likeStackLayout` and `denyStackLayout`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为`likeStackLayout`和`denyStackLayout`设置透明度为这个值。
- en: Wiring up the pan state check
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接平移状态检查
- en: 'While the image is being panned, we want to update the state:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像被平移时，我们希望更新状态：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/SwiperControl.xaml.cs`。
- en: 'Add the code in bold to the `PanRunning()` method:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`PanRunning()`方法中：
- en: '[PRE17]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This addition to the `PanRunning()` method passes the total amount of movement
    on the *x* axis to the `CalculatePanState()` method to determine if we need to
    adjust the opacity of either the `StackLayout` on the right or the left of the
    control.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`PanRunning()`方法的这个添加将在*x*轴上的总移动量传递给`CalculatePanState()`方法，以确定我们是否需要调整控件左侧或右侧的`StackLayout`的透明度。'
- en: Adding exit logic
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加退出逻辑
- en: So far, all is good, except for the fact that if we drag an image to the edge
    and let go, the text stays. We need to determine when the user stops dragging
    the image, and, if so, whether or not the image is in a decision zone.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好，除了一个问题，即如果我们将图像拖到边缘然后放开，文本会保留。我们需要确定用户何时停止拖动图像，以及图像是否处于决策区。
- en: Checking if the image should exit
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查图像是否应退出
- en: 'We want a simple function that determines if an image has panned far enough
    for it to count as an exit of that image:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望有一个简单的函数来确定一张图片是否已经移动足够远，以便算作该图片的退出：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/SwiperControl.xaml.cs`。
- en: 'Add the `CheckForExitCritera()` method to the class, as shown in the following
    code:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加`CheckForExitCritera()`方法，如下所示：
- en: '[PRE18]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This function calculates whether we have passed over the dead zone and into
    the decision zone. We need to use the `Math.Abs()` method to get the total absolute
    value to compare it against. We could have used a `<` and `>` operator as well,
    but we are using this approach as it is more readable. This is a matter of code
    style and taste—feel free to do it your own way.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数计算我们是否已经越过死区并进入决策区。我们需要使用`Math.Abs()`方法获取总绝对值进行比较。我们也可以使用`<`和`>`运算符，但我们使用这种方法是因为它更可读。这是代码风格和品味的问题，随意按照自己的方式进行。
- en: Removing the image
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除图像
- en: 'If we determine that an image has panned far enough for it to exit, we want
    to animate it off the screen and then remove the image from the page:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确定图像已经移动足够远，使其退出，我们希望将其从屏幕上动画移出，然后从页面中删除图像：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/SwiperControl.xaml.cs`。
- en: 'Add the `Exit()` method to the class, as shown in the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加`Exit()`方法，如下所示：
- en: '[PRE19]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Exit()` method does the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exit()`方法执行以下操作：'
- en: We begin by making sure that this call is done on the UI thread, which is also
    known as the `MainThread`. This is because only the UI thread can do animations.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先确保此调用在UI线程上完成，这也被称为`MainThread`。这是因为只有UI线程才能执行动画。
- en: We also need to run this thread asynchronously, so that we can kill two birds
    with one stone. Since this method is all about animating the image to either side
    of the screen, we need to determine in which direction to animate it.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要异步运行此线程，以便一举两得。由于这个方法是关于将图像动画到屏幕的一侧，我们需要确定在哪个方向进行动画。
- en: We do this by determining if the total translation of the image is positive
    or negative.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过确定图像的总平移是正数还是负数来执行此操作。
- en: We then use this value to await a translation through the `photo.TranslateTo()`
    call.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用这个值通过`photo.TranslateTo()`调用来等待翻译。
- en: We await this call since we don't want the code execution to continue until
    it's done. Once it has finished, we remove the control from the parent's collection
    of children, causing it to disappear from existence forever.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们等待此调用，因为我们不希望代码执行继续，直到完成。完成后，我们将控件从父级的子级集合中移除，导致它永远消失。
- en: Updating PanCompleted
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新PanCompleted
- en: 'The decision on whether the image should disappear or simply return to its
    original state is triggered in the `PanCompleted()` method. Here, we wire up the
    two methods that we created in the previous two sections:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 决定图像是否应消失或仅返回到其原始状态是在`PanCompleted()`方法中触发的。在这里，我们连接了前两节中创建的两种方法：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/SwiperControl.xaml.cs`。
- en: 'Add the code in bold to the `PanCompleted()` method:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PanCompleted()`方法中添加粗体代码：
- en: '[PRE20]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The last step in this section is to use the `CheckForExitCriteria()` method,
    and the `Exit()` method if those criteria are met. If the exit criteria are not
    met, we need to reset the state and the opacity of the `StackLayout` to make everything
    go back to normal.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的最后一步是使用`CheckForExitCriteria()`方法和`Exit()`方法，如果满足退出条件，则执行这些条件。如果不满足退出条件，我们需要重置`StackLayout`的状态和不透明度，使一切恢复正常。
- en: Adding events to the control
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向控件添加事件
- en: The last thing we have left to do in the control itself is to add some events
    that indicate whether the image has been *Liked* or *Denied*. We are going to
    use a clean interface, allowing for a simple use of the control while hiding all
    the implementation details.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在控件本身中我们还剩下最后一件事要做，那就是添加一些事件，指示图像是否已被*喜欢*或*拒绝*。我们将使用一个干净的接口，允许控件的简单使用，同时隐藏所有实现细节。
- en: Declaring two events
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明两个事件
- en: 'To make the control easier to interact with from the application itself, we''ll
    need to add events for `Like` and `Deny`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使控件更容易从应用程序本身进行交互，我们需要为`Like`和`Deny`添加事件：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/SwiperControl.xaml.cs`。
- en: 'Add two event declarations at the beginning of the class, as shown in the following
    code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的开头添加两个事件声明，如下所示：
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These are two standard event declarations with out-of-the-box event handlers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两个带有开箱即用的事件处理程序的标准事件声明。
- en: Raising the events
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发事件
- en: 'We need to add code in the `Exit()` method to raise the events we created earlier:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`Exit()`方法中添加代码来触发我们之前创建的事件：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/SwiperControl.xaml.cs`。
- en: 'Add the code in bold to the `Exit()` method:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Exit()`方法中添加粗体代码：
- en: '[PRE22]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we inject the code to check whether we are liking or disliking an image.
    We then raise the correct event based on this information.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们注入代码来检查我们是喜欢还是不喜欢一张图片。然后根据这些信息触发正确的事件。
- en: Wiring up the Swiper control
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接Swiper控件
- en: We have now reached the final part of the chapter. In this section, we are going
    to wire up the images and make our app a closed-loop app that can be used forever.
    We will add 10 images that we will download from the internet when the app starts
    up. Each time an image is removed, we'll simply add another one.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达本章的最后部分。在本节中，我们将连接图像并使我们的应用成为一个可以永远使用的闭环应用程序。我们将添加10张图像，这些图像将在应用程序启动时从互联网上下载。每次删除一张图像时，我们将简单地添加另一张图像。
- en: Adding images
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加图像
- en: Let's start by creating some code that will be adding the images to the MainView.
    We will first add the initial images, and then create logic for adding a new image
    to the bottom of the stack each time an image is liked or disliked.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一些代码，将图像添加到MainView中。我们将首先添加初始图像，然后创建逻辑，以便在每次喜欢或不喜欢图像时向堆栈底部添加新图像。
- en: Adding initial photos
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加初始照片
- en: 'To make the photos look like they are stacked, we need at least 10 of them:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使照片看起来像是堆叠在一起，我们至少需要10张照片：
- en: Open `MainPage.xaml.cs`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“MainPage.xaml.cs”。
- en: 'Add the `AddInitalPhotos()` method and the `InsertPhotoMethod()` to the class:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“AddInitalPhotos（）”方法和“InsertPhotoMethod（）”添加到类中：
- en: '[PRE23]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we create a method called `AddInitialPhotos()` that will be called upon
    startup. This method simply calls the `InsertPhoto()` method `10` times and adds
    a new `SwiperControl` to the `MainGrid` each time. It inserts the control at the
    first position in the stack, effectively putting it at the bottom of the pile,
    since the collection of controls is rendered from the beginning to the end.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为“AddInitialPhotos（）”的方法，该方法将在启动时调用。该方法简单地调用“InsertPhoto（）”方法10次，并每次向“MainGrid”添加一个新的“SwiperControl”。它将控件插入到堆栈的第一个位置，从而有效地将其放在堆栈底部，因为控件集合是从开始到结束渲染的。
- en: Making the call from the constructor
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从构造函数中进行调用
- en: 'We need to call this method in order for the magic to happen:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调用此方法才能使魔术发生：
- en: Open `MainPage.xaml.cs`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“MainPage.xaml.cs”。
- en: 'Add the code in bold to the constructor and make sure it looks like the following:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将粗体中的代码添加到构造函数中，并确保它看起来像下面这样：
- en: '[PRE24]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There isn't much to say here. After the `MainPage` is initialized, we call the
    method to add 10 random photos that we will download from the internet.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么可说的。在初始化“MainPage”之后，我们调用该方法添加10张我们将从互联网上下载的随机照片。
- en: Adding count labels
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加计数标签
- en: We want to add some values to the app as well. We can do this by adding two
    labels below the collection of `Swiper` controls. Each time a user rates an image,
    we will increment one of two counters and display the result.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望为应用程序添加一些价值观。我们可以通过在“Swiper”控件集合下方添加两个标签来实现这一点。每当用户对图像进行评分时，我们将递增两个计数器中的一个，并显示结果。
- en: 'So, let''s add the XAML needed to display the labels:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们添加XAML以显示标签所需的内容：
- en: Open `MainPage.xaml`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“MainPage.xaml”。
- en: 'Replace the comment `<!-- Placeholder for later -->` with the code marked in
    bold:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用粗体标记的代码替换注释“<!-- Placeholder for later -->”：
- en: '[PRE25]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This code adds a new `Grid` with four auto-height rows. This means that we calculate
    the height of the content of each row and use this for the layout. It is basically
    the same thing as a `StackLayout`, but we wanted to demonstrate a better way of
    doing this.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码添加了一个具有四个自动高度行的新“Grid”。这意味着我们计算每行内容的高度，并将其用于布局。这基本上与“StackLayout”相同，但我们想展示一种更好的方法。
- en: We add a `Label` in each row and name two of them as `likeLabel` and `denyLabel`.
    The two named labels will hold how many images have been liked and how many have
    been denied.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在每行中添加一个“Label”，并将其中两个命名为“likeLabel”和“denyLabel”。这两个命名的标签将保存已喜欢的图像数量以及已拒绝的图像数量。
- en: Subscribing to events
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅事件
- en: The last step is to wire up the `OnLike` and `OnDeny` events and display the
    total count to the user.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是连接“OnLike”和“OnDeny”事件，并向用户显示总计数。
- en: Adding methods to update the GUI and respond to events
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加方法以更新GUI并响应事件
- en: 'We need some code to update the GUI and to keep track of the count:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些代码来更新GUI并跟踪计数：
- en: Open `MainPage.xaml.cs`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“MainPage.xaml.cs”。
- en: 'Add the following code to the class, as shown here:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中，如下所示：
- en: '[PRE26]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The two fields at the top keep track of the number of likes and denies. Since
    they are value-type variables, they default to zero.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的两个字段跟踪喜欢和拒绝的数量。由于它们是值类型变量，它们默认为零。
- en: To make the changes of these labels propagate to the UI, we've created a method
    called `UpdateGui()`. This takes the value of the two aforementioned fields and
    assigns it to the `Text` properties of both labels.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些标签的更改传播到UI，我们创建了一个名为“UpdateGui（）”的方法。这将获取两个前述字段的值，并将其分配给两个标签的“Text”属性。
- en: The two methods that follow are the event handlers that will be handling the `OnLike`
    and `OnDeny` events. They increase the appropriate field, add a new photo, and
    then update the GUI to reflect the change.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个方法是将处理“OnLike”和“OnDeny”事件的事件处理程序。它们增加适当的字段，添加新照片，然后更新GUI以反映更改。
- en: Wiring up events
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接事件
- en: 'Each time a new `SwiperControl` is created, we need to wire up the events:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建新的“SwiperControl”时，我们需要连接事件：
- en: Open `MainPage.xaml.cs.`
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开“MainPage.xaml.cs”。
- en: 'Add the code in bold to the `InsertPhoto()` method:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将粗体中的代码添加到“InsertPhoto（）”方法中：
- en: '[PRE27]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The added code wires up the event handlers that we defined earlier. The events
    really make it easy to interact with our new control. Try it for yourself and
    have a play around with the app that you have created.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的代码连接了我们之前定义的事件处理程序。这些事件确实使与我们的新控件交互变得容易。自己尝试一下，并玩一下您创建的应用程序。
- en: Summary
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Good job! In this chapter, we have learned how to create a reusable, good-looking
    control that can be used in any Xamarin.Forms app. To enhance the **User Experience**
    (**UX**) of the app, we used some animations that give the user more visual feedback. We
    also got creative with the use of XAML to define a GUI of the control that looks
    like a photo with a hand-written description.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！在本章中，我们学习了如何创建一个可重用的外观良好的控件，可用于任何Xamarin.Forms应用程序。为了增强应用程序的用户体验（UX），我们使用了一些动画，为用户提供了更多的视觉反馈。我们还在XAML的使用上有所创意，定义了一个看起来像是带有手写描述的照片的控件的GUI。
- en: After that, we used events to expose the behavior of the control back to the
    `MainPage` to limit the contact surface between your app and the control. Most
    importantly of all, we touched on the subject of `GestureRecognizers`, which can
    make our life much easier when dealing with common gestures.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用事件将控件的行为暴露给“MainPage”，以限制应用程序与控件之间的接触表面。最重要的是，我们涉及了“GestureRecognizers”的主题，这可以在处理常见手势时使我们的生活变得更加轻松。
- en: In the next chapter, we will take a look at how to use track the location of
    a user in the background on an iOS and Android device. To visualize what we are
    tracking, we will use the map component in Xamarin.Forms.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何在iOS和Android设备上后台跟踪用户的位置。为了可视化我们正在跟踪的内容，我们将使用Xamarin.Forms中的地图组件。
