["```js\nnpm install -g @angular/cli\n```", "```js\nng new <project-name>\n```", "```js\nng serve\n```", "```js\nvar friends = [ 'ross', 'rachel', 'adam', 'amy', 'joey'];\n```", "```js\nimport {Injectable} from \"@angular/core\";\n\n@Injectable()\nexport class Trie {\n    tree: any = {};\n\n    constructor() {}\n\n}\n```", "```js\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport {Trie} from \"./utils/trie\";\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule\n  ],\n  providers: [\n      Trie\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```", "```js\nadd(input) {\n    // set to root of tree\n  var currentNode = this.tree;\n\n    // init next value\n  var nextNode = null;\n\n    // take 1st char and trim input\n    // adam for ex becomes a and dam\n  var curChar = input.slice(0,1);\n    input = input.slice(1);\n\n    // find first new character, until then keep trimming input\n  while(currentNode[curChar] && curChar){\n        currentNode = currentNode[curChar];\n\n        // trim input\n  curChar = input.slice(0,1);\n        input = input.slice(1);\n    }\n\n    // while next character is available keep adding new branches and \n    // prune till end\n  while(curChar) {\n        // new reference in each loop   nextNode = {};\n\n        // assign to current tree node\n  currentNode[curChar] = nextNode;\n\n        // hold reference for next loop\n  currentNode = nextNode;\n\n        // prepare for next iteration\n  curChar = input.slice(0,1);\n        input = input.slice(1);\n    }\n}\n```", "```js\nsearch(input) {\n    // get the whole tree\n    var currentNode = this.tree;\n    var curChar = input.slice(0,1);\n\n    // take first character\n    input = input.slice(1);\n\n   // keep extracting the sub-tree based on the current character\n    while(currentNode[curChar] && curChar){\n        currentNode = currentNode[curChar];\n        curChar = input.slice(0,1);\n        input = input.slice(1);\n    }\n\n    // reached the end and no sub-tree found\n    // e.g. no data found\n    if (curChar && !currentNode[curChar]) {\n        return {};\n    }\n\n    // return the node found\n    return currentNode;\n}\n```", "```js\nimport { Component } from '@angular/core';\nimport {Trie} from \"../utils/trie\";\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n    countries = [\"Afghanistan\",\"Albania\",\"Algeria\",...,\"Yemen\",\"Zambia\",\"Zimbabwe\"];\n    searchResp = [];\n\n    constructor(private trie : Trie) {\n        this.countries.forEach((c) => {\n            this.trie.add(c); \n        });\n    }\n\n    search(key) {\n        this.searchResp = this.trie.search(key).remainder;\n    }\n}\n```", "```js\n<pre>{{searchResp}}</pre>\n```", "```js\nadd(input) {\n    // set to root of tree\n  var currentNode = this.tree;\n\n    // init value\n  var nextNode = null;\n\n    // take 1st char and trim input\n  var curChar = input.slice(0,1);\n    input = input.slice(1);\n\n    // find first new character, until then keep triming input\n  while(currentNode[curChar] && curChar){\n        currentNode = currentNode[curChar];\n\n        // update remainder array, this will exist as we added the node\n        earlier\n  currentNode.remainder.push(input);\n\n        // trim input\n  curChar = input.slice(0,1);\n        input = input.slice(1);\n    }\n\n    // while next character is available keep adding new branches and\n    prune till end\n  while(curChar) {\n        // new reference in each loop\n // create remainder array starting with current input // so when adding the node `a` we add to the remainder `dam`\n        and so on  nextNode = {\n            remainder: [input]\n        };\n\n        // assign to current tree node\n  currentNode[curChar] = nextNode;\n\n        // hold reference for next loop\n  currentNode = nextNode;\n\n        // prepare for next iteration\n  curChar = input.slice(0,1);\n        input = input.slice(1);\n    }\n}\n```", "```js\nsearch(input) {\n    var currentNode = this.tree;\n    var curChar = input.slice(0,1);\n\n    input = input.slice(1);\n\n    while(currentNode[curChar] && curChar){\n        currentNode = currentNode[curChar];\n        curChar = input.slice(0,1);\n        input = input.slice(1);\n    }\n\n    if (curChar && !currentNode[curChar]) {\n        return {\n            remainder: [] \n        };\n    }\n\n    return currentNode;\n}\n```", "```js\nimport { Component } from '@angular/core';\nimport {Trie} from \"../utils/trie\";\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n    countries = [\"Afghanistan\",\"Albania\",\"Algeria\",\"Andorra\",\"Angola\",\"Anguilla\",\"Antigua & Barbuda\",\"Argentina\",\"Armenia\",\"Aruba\",\"Australia\",\"Austria\",\"Azerbaijan\",\"Bahamas\",\"Bahrain\",\"Bangladesh\",\"Barbados\",\"Belarus\",\"Belgium\",\"Belize\",\"Benin\",\"Bermuda\",\"Bhutan\",\"Bolivia\",\"Bosnia & Herzegovina\",\"Botswana\",\"Brazil\",\"British Virgin Islands\",\"Brunei\",\"Bulgaria\",\"Burkina Faso\",\"Burundi\",\"Cambodia\",\"Cameroon\",\"Cape Verde\",\"Cayman Islands\",\"Chad\",\"Chile\",\"China\",\"Colombia\",\"Congo\",\"Cook Islands\",\"Costa Rica\",\"Cote D Ivoire\",\"Croatia\",\"Cruise Ship\",\"Cuba\",\"Cyprus\",\"Czech Republic\",\"Denmark\",\"Djibouti\",\"Dominica\",\"Dominican Republic\",\"Ecuador\",\"Egypt\",\"El Salvador\",\"Equatorial Guinea\",\"Estonia\",\"Ethiopia\",\"Falkland Islands\",\"Faroe Islands\",\"Fiji\",\"Finland\",\"France\",\"French Polynesia\",\"French West Indies\",\"Gabon\",\"Gambia\",\"Georgia\",\"Germany\",\"Ghana\",\"Gibraltar\",\"Greece\",\"Greenland\",\"Grenada\",\"Guam\",\"Guatemala\",\"Guernsey\",\"Guinea\",\"Guinea Bissau\",\"Guyana\",\"Haiti\",\"Honduras\",\"Hong Kong\",\"Hungary\",\"Iceland\",\"India\",\"Indonesia\",\"Iran\",\"Iraq\",\"Ireland\",\"Isle of Man\",\"Israel\",\"Italy\",\"Jamaica\",\"Japan\",\"Jersey\",\"Jordan\",\"Kazakhstan\",\"Kenya\",\"Kuwait\",\"Kyrgyz Republic\",\"Laos\",\"Latvia\",\"Lebanon\",\"Lesotho\",\"Liberia\",\"Libya\",\"Liechtenstein\",\"Lithuania\",\"Luxembourg\",\"Macau\",\"Macedonia\",\"Madagascar\",\"Malawi\",\"Malaysia\",\"Maldives\",\"Mali\",\"Malta\",\"Mauritania\",\"Mauritius\",\"Mexico\",\"Moldova\",\"Monaco\",\"Mongolia\",\"Montenegro\",\"Montserrat\",\"Morocco\",\"Mozambique\",\"Namibia\",\"Nepal\",\"Netherlands\",\"Netherlands Antilles\",\"New Caledonia\",\"New Zealand\",\"Nicaragua\",\"Niger\",\"Nigeria\",\"Norway\",\"Oman\",\"Pakistan\",\"Palestine\",\"Panama\",\"Papua New Guinea\",\"Paraguay\",\"Peru\",\"Philippines\",\"Poland\",\"Portugal\",\"Puerto Rico\",\"Qatar\",\"Reunion\",\"Romania\",\"Russia\",\"Rwanda\",\"Saint Pierre & Miquelon\",\"Samoa\",\"San Marino\",\"Satellite\",\"Saudi Arabia\",\"Senegal\",\"Serbia\",\"Seychelles\",\"Sierra Leone\",\"Singapore\",\"Slovakia\",\"Slovenia\",\"South Africa\",\"South Korea\",\"Spain\",\"Sri Lanka\",\"St Kitts & Nevis\",\"St Lucia\",\"St Vincent\",\"St. Lucia\",\"Sudan\",\"Suriname\",\"Swaziland\",\"Sweden\",\"Switzerland\",\"Syria\",\"Taiwan\",\"Tajikistan\",\"Tanzania\",\"Thailand\",\"Timor L'Este\",\"Togo\",\"Tonga\",\"Trinidad & Tobago\",\"Tunisia\",\"Turkey\",\"Turkmenistan\",\"Turks & Caicos\",\"Uganda\",\"Ukraine\",\"United Arab Emirates\",\"United Kingdom\",\"Uruguay\",\"Uzbekistan\",\"Venezuela\",\"Vietnam\",\"Virgin Islands (US)\",\"Yemen\",\"Zambia\",\"Zimbabwe\"];\n    searchResp = [];\n\n    constructor(private trie : Trie) {\n        this.countries.forEach((c) => {\n            this.trie.add(c); \n        });\n    }\n\n    search(key) {\n        this.searchResp = this.trie.search(key).remainder;\n    }\n}\n```", "```js\n\n<input type=\"text\" placeholder=\"search countries\" #searchInp (keyup)=\"search(searchInp.value)\" />\n\n<div *ngFor=\"let resp of searchResp\">\n    <strong>{{searchInp.value}}</strong>{{resp}}\n</div>\n\n<div *ngIf=\"searchInp.value && !searchResp.length\">\n    No results found for {{searchInp.value}}\n</div>\n```", "```js\ntargetEntropy =  -( (9/13) log2 (9/13) ) - ( (4/13) log2 (4/13) );\ntargetEntropy = 0.89049164021;\n```", "```js\n// input attributes and the target values\n\nvar _ = require('lodash');\n\nvar creditScore = ['Excellent', 'Good', 'Average', 'Poor'];\nvar creditAge = ['>10', '>5', '>2', '>=1'];\nvar remarks = ['0', '1', '2', '>=3'];\nvar utilization = ['Low', 'Medium', 'High'];\nvar hardInquiries = ['0', '1', '2', '>=3'];\n\n// expected output structure\n/* {\n \"creditScore\": \"\",\n \"creditAge\": \"\",\n \"remarks\": \"\",\n \"utilization\": \"\",\n \"hardInquiries\": \"\",\n \"approval\": \"\"\n } */\n\nvar all = [];\nvar even = [];\nvar odd = [];\n\n// does not have to be optimal, this is a one time script\n_.forEach(creditScore, function(credit) {\n\n  // generate new object on each loop at top\n\n  var resp = {};\n\n  resp.creditScore = credit;\n\n  _.forEach(creditAge, function(age) {\n\n    resp.creditAge = age;\n\n    _.forEach(remarks, function(remark) {\n\n      resp.remarks = remark;\n\n      _.forEach(utilization, function(util) {\n\n        resp.utilization = util;\n\n        _.forEach(hardInquiries, function(inq) {\n\n          resp.hardInquiries = inq;\n\n          // looping is by reference so persist a copy\n\n          all.push(_.cloneDeep(resp));\n\n        });\n      });\n    });\n  });\n});\n\nfor (var i = 0; i < all.length; i++) {\n\n  // index is even\n  if (i % 2 === 0) {\n\n    // training data set\n    even.push(all[i]);\n\n  } else {\n\n    // prediction data set (input)\n    odd.push(all[i])\n\n  }\n}\n\n// apply our fake algorithm to detect which application is approved\nvar trainingDataWithApprovals = applyApprovals(even);\n\n// apply approval logic so that we know what to expect\nvar predictionDataWithApprovals = applyApprovals(odd);\n\nfunction applyApprovals(data) {\n  return _.map(data, function(d) {\n\n    // Excellent credit score is approved, no questions asked\n\n    if (d.creditScore === 'Excellent') {\n      d.approved = 'Yes';\n      return d;\n    }\n\n    // if credit score is good, then account should have a decent age\n    // not very high utilization, less remarks and less inquiries\n\n    if (d.creditScore === 'Good' &&\n      (d.creditAge != '>=1') &&\n      (d.remarks == '1' || d.remarks == '0') &&\n      d.utilization !== 'High' &&\n      (d.hardInquiries != '>=3')) {\n      d.approved = 'Yes';\n      return d;\n    }\n\n    // if score is average, then age should be high, no remarks, not\n    very high\n    // utilization and little to no inquiries.\n\n    if (d.creditScore === 'Average' &&\n      (d.creditAge == '>5' || d.creditAge == '>10') &&\n      d.remarks == '0' &&\n      d.utilization !== 'High' &&\n      (d.hardInquiries == '1' || d.hardInquiries == '0')) {\n      d.approved = 'Yes';\n      return d;\n    }\n\n    // reject all others including all Poor credit scores\n    d.approved = 'No';\n    return d;\n\n  });\n}\n\nconsole.log(trainingDataWithApprovals);\nconsole.log(predictionDataWithApprovals);\n```", "```js\n// create folder for containing data\nmkdir training-data\n\n// move into the new folder\ncd training-data\n\n// create a new node project (answer the questions and hit return)\nnpm init\n\n// install lodash to use helper methods\nnpm install lodash --save\n\n// create the js file to generate data and copy paste the code above\n// into this file\ntouch data.js\n\n// run the script\nnode data.js\n```", "```js\nimport {Injectable} from \"@angular/core\";\n\n@Injectable()\nexport class ID3 {\n\n    constructor() {\n\n    }\n\n}\n```", "```js\nnpm install lodash --save\n```", "```js\nimport {Injectable} from \"@angular/core\";\nimport { } from \"lodash\";\n\n@Injectable()\nexport class ID3 {\n\n    constructor() {\n\n    }\n\n    public train(trainingData, target, attributes) {\n\n    }\n\n}\n```", "```js\n...\nimport { ID3 } from '../utils/id3';\n...\n\n@NgModule({\n   ...\n    providers: [\n        ID3\n    ],\n    ...\n})\nexport class AppModule { }\n```", "```js\nimport { Component, OnInit } from '@angular/core';\nimport {ID3} from \"../utils/id3\";\nimport {without, keys, filter} from \"lodash\";\nimport {CreditCard} from \"../utils/training-data/credit-card\";\n\n@Component({\n    selector: 'app-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.scss']\n})\nexport class AppComponent implements OnInit {\n    tree;\n    tests: any;\n\n    constructor(private id3: ID3) {\n        this.tree = this.id3.train(\n                         CreditCard.data,\n                         'approved', \n                         without(keys(CreditCard.data[0]),\n                         'approved'));\n    }\n\n    ngOnInit() {\n        this.tests = ... // testing data\n    }\n\n}\n```", "```js\n.split {\n    width: 50%;\n    float: left }\n\ntable, td, th {\n  text-align: center;\n  border: 1px solid black;\n}\n\ntable {\n  border-collapse: collapse;\n  width: 100%;\n}\n\nth {\n  height: 50px;\n}\n\n.true {\n  background: #bcf9bc;\n}\n\n.false {\n  background: #ffa2a7;\n}\n```", "```js\nimport {Injectable} from \"@angular/core\";\nimport { maxBy, uniq, map, filter, without, keys, size, chain, find, countBy } from \"lodash\";\n\n@Injectable()\nexport class ID3 {\n\n    constructor() {\n\n    }\n\n    public train(trainingData, target, attributes) {\n\n        // calculate root node from current list of attributes\n  var currentRootNode = this.getCurrentRootNode(\n                                    trainingData, target, attributes);\n\n    }\n\n    private getCurrentRootNode(trainingData, target, attributes) {\n\n        // get max extropy attribute\n  return maxBy(attributes, (attr) => {\n\n            // calculate information gain at each attribute\n // e.g. 'creditScore', 'creditAge' etc  return this.gain(trainingData, target, attr);\n        });\n    }\n\n    private gain(trainingData, target, attr) {\n        // calculate target branches entropy e.g. approved\n  var targetEntropy = this.entropy(map(trainingData, target));\n\n        // calculate the summation of all branches entropy\n  var sumOfBranchEntropies =\n            chain(trainingData)\n\n                // extract branches for the given attribute\n // e.g creditScore has the branches Excellent, Good, // Average, Poor  .map(attr)\n\n                // make the values unique\n  .uniq()\n\n                // for each unique branch calculate the branch entropy\n // e.g. calculate entropy of Excellent, Good, Average,\n                Poor  .map((branch) => {\n\n                    // extract only the subset training data\n // which belongs to current branch  var branchTrainingData = filter(trainingData, \n                    [attr, branch]);\n\n                    // return (probability of branch) * entropy of\n                    branch\n  return (branchTrainingData.length /\n                    trainingData.length)\n                        * this.entropy(map(branchTrainingData,\n                        target));\n                })\n\n                // add all branch entropies\n // e.g. add entropy of Excellent, Good, Average, Poor  .reduce(this.genericReducer, 0)\n\n                // return the final value\n  .valueOf();\n\n        // return information gain\n        return targetEntropy - sumOfBranchEntropies;\n    }\n\n    private entropy(vals) {\n\n        // take all values\n  return chain(vals)\n\n            // make them unique\n // e.g. an array of Yes and No  .uniq()\n\n            // calculate probability of each\n  .map((x) => this.probability(x, vals))\n\n            // calculate entropy\n  .map((p) => -p * Math.log2(p))\n\n            // reduce the value\n  .reduce(this.genericReducer, 0)\n\n            // return value\n  .valueOf();\n    }\n\n    private probability(val, vals){\n\n        // calculate total number of instances\n // e.g. Yes is 100 out of the 300 values  var instances = filter(vals, (x) => x === val).length;\n\n        // total values passed e.g. 300\n  var total = vals.length;\n\n        // return 1/3\n  return instances/total;\n    }\n\n    private genericReducer(a, b) {\n\n        // add and return\n  return a + b;\n    }\n```", "```js\npublic train(trainingData, target, attributes) {\n    // extract all targets from data set e.g.\n // Yes or No  var allTargets = uniq(map(trainingData, target));\n\n    // only Yes or No is remaining e.g. leaf node found\n  if (allTargets.length == 1){\n        return { leaf: true, value: allTargets[0] };\n    }\n\n    // calculate root node from current list of attributes\n  var currentRootNode = this.getCurrentRootNode(\n                                trainingData, target, attributes);\n\n    // form node for current root\n  var node: any = { name: currentRootNode, leaf: false };\n\n    // remove currentRootNode from list of all attributes\n // e.g. remove creditScore or whatever the root node was // from the entire list of attributes  var remainingAttributes = without(attributes, currentRootNode);\n\n    // get unique branch names for currentRootNode\n // e.g creditScore has the branches Excellent, Good, // Average, Poor  var branches = uniq(map(trainingData, currentRootNode));\n\n    // recursively repeat the process for each branch\n  node.branches = map(branches, (branch) => {\n\n        // take each branch training data\n        // e.g. training data where creditScore is Excellent\n  var branchTrainingData = filter(trainingData, [currentRootNode,\n        branch]);\n\n        // create node for each branch\n  var branch: any = { name: branch, leaf: false };\n\n        // initialize branches for node\n  branch.branches = [];\n\n        // train and push data to subbranch\n  branch.branches.push(this.train(\n branchTrainingData, target, remainingAttributes));\n\n        // return branch as a child of parent node\n  return branch;\n    });\n\n    return node;\n}\n```", "```js\npublic predict(tree, input) {\n    var node = tree;\n\n    // loop over the entire tree\n  while(!node[0].leaf){\n\n        // take node name e.g. creditScore\n  var name = node[0].name;\n\n        // take value from input sample\n  var inputValue = input[name];\n\n        // check if branches for given input exist\n  var childNode = filter(node[0].branches, ['name', inputValue]);\n\n        // if branches exist return branches or default to No\n  node = childNode.length ?\n            childNode[0].branches : [{ leaf: true, value: 'No'}];\n    }\n\n    // return final leaf value\n  return node[0].value;\n}\n```", "```js\n...\n\n    accuracyPct: any;\n\n ngOnInit() {     this.tests = // test data set;\n\n        this.tests.forEach((test) => {\n            test.actual = this.id3.predict([this.tree], test);\n            test.accurate = test.expected === test.actual;\n        });\n\n        this.accuracyPct =  (filter(this.tests, { accurate: true }).length / \n this.tests.length)*100;\n    }\n\n}\n```", "```js\nimport {Component, Input} from '@angular/core';\n\n@Component ({\n    selector: 'tree-view',\n    templateUrl:'./treeview.html',\n    styleUrls: ['./treeview.scss']\n})\nexport class TreeView {\n    @Input() data;\n}\n```", "```js\n<ul *ngFor=\"let node of data\">\n    <li *ngIf=\"node.name\">\n\n <!-- show name when available -->  <span class=\"name\">{{node.name}}</span>\n    </li>\n```", "```js\n <!-- is not root node, render branches recursively -->  <tree-view *ngIf=\"!node.leaf\" [data]=\"node.branches\"></tree-view>\n\n    <!-- if leaf node render node value -->\n  <li *ngIf=\"node.leaf\">\n        <span class=\"leaf {{node.value}}\">{{node.value}}</span>\n    </li>\n</ul>\n```", "```js\nul {\n  list-style: none;\n  line-height: 40px;\n  position: relative;\n\n  &::before{\n    content: \"\";\n    height: calc(100% - 60px);\n    display: block;\n    top: 40px;\n    left: 60px;\n    border-left: 1px solid #333;\n    position: absolute;\n  }\n}\n\nli {\n  position: relative;\n\n  &::before{\n    content: \"\";\n    width: 20px;\n    display: block;\n    top: 50%;\n    left: -20px;\n    border-bottom: 1px solid #333;\n    position: absolute;\n    transform: translateY(-50%);\n  }\n}\n\n.name {\n  padding: 10px;\n  background: #e1f4ff;\n}\n\n.leaf {\n  padding: 10px;\n  position: relative;\n\n  &.Yes {\n    background: #bcf9bc;\n  }\n\n  &.No {\n    background: #ffa2a7;\n  }\n}\n```", "```js\n...\nimport {TreeView} from \"../utils/treeview/treeview\";\n\n@NgModule({\n    declarations: [\n        ...\n        TreeView\n    ],\n   ...\n})\nexport class AppModule { }\n```", "```js\n<div *ngIf=\"tree\">\n    <tree-view [data]=\"[tree]\"></tree-view>\n</div>\n```", "```js\n<div class=\"split\">\n    <div *ngIf=\"tree\">\n        <tree-view [data]=\"[tree]\"></tree-view>\n    </div>\n</div>\n<div class=\"split\">\n    <h3>Overall accuracy {{accuracyPct | number}}%</h3>\n\n    <table>\n        <thead>\n            <th>Credit Score</th>\n            <th>Credit Age</th>\n            <th>Remarks</th>\n            <th>Utilization</th>\n            <th>Hard Inquiries</th>\n            <th>Expected</th>\n            <th>Actual</th>\n            <th>Accurate</th>\n        </thead>\n        <tbody>\n            <tr *ngFor=\"let test of tests\">\n                <td>{{test.creditScore}}</td>\n                <td>{{test.creditAge}}</td>\n                <td>{{test.remarks}}</td>\n                <td>{{test.utilization}}</td>\n                <td>{{test.hardInquiries}}</td>\n                <td>{{test.expected}}</td>\n                <td>{{test.actual}}</td>\n                <td [class]=\"test.accurate\">{{test.accurate}}</td>\n            </tr>\n        </tbody>\n    </table>\n</div>\n```", "```js\n.split {\n    width: 50%;\n    float: left }\n\ntable, td, th {\n  text-align: center;\n  border: 1px solid black;\n}\n\ntable {\n  border-collapse: collapse;\n  width: 100%;\n}\n\nth {\n  height: 50px;\n}\n\n.true {\n  background: #bcf9bc;\n}\n\n.false {\n  background: #ffa2a7;\n}\n```"]