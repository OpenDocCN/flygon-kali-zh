["```\n...\n...\nResources:\n  EcsCapacityPermission:\n Type: AWS::Lambda::Permission\n Properties:\n Action: lambda:InvokeFunction\n FunctionName: !Ref EcsCapacityFunction\n Principal: events.amazonaws.com\n SourceArn: !Sub ${EcsCapacityEvents.Arn}\n EcsCapacityEvents:\n Type: AWS::Events::Rule\n Properties:\n Description: !Sub ${AWS::StackName} ECS Events Rule\n EventPattern:\n source:\n - aws.ecs\n detail-type:\n - ECS Container Instance State Change\n detail:\n clusterArn:\n - !Sub ${ApplicationCluster.Arn}\n Targets:\n - Arn: !Sub ${EcsCapacityFunction.Arn}\n Id: !Sub ${AWS::StackName}-ecs-events\n  LifecycleHook:\n    Type: AWS::AutoScaling::LifecycleHook\n...\n...\n```", "```\n...\n...\nResources:\n  EcsCapacityRole:\n Type: AWS::IAM::Role\n Properties:\n AssumeRolePolicyDocument:\n Version: \"2012-10-17\"\n Statement:\n - Action:\n - sts:AssumeRole\n Effect: Allow\n Principal:\n Service: lambda.amazonaws.com\n Policies:\n - PolicyName: EcsCapacityPermissions\n PolicyDocument:\n Version: \"2012-10-17\"\n Statement:\n - Sid: ManageLambdaLogs\n Effect: Allow\n Action:\n - logs:CreateLogStream\n - logs:PutLogEvents\n Resource: !Sub ${EcsCapacityLogGroup.Arn}\n EcsCapacityFunction:\n Type: AWS::Lambda::Function\n DependsOn:\n - EcsCapacityLogGroup\n Properties:\n Role: !Sub ${EcsCapacityRole.Arn}\n FunctionName: !Sub ${AWS::StackName}-ecsCapacity\n Description: !Sub ${AWS::StackName} ECS Capacity Manager\n Code:\n ZipFile: |\n import json\n def handler(event, context):\n print(\"Received event %s\" % json.dumps(event))\n Runtime: python3.6\n MemorySize: 128\n Timeout: 300\n Handler: index.handler\n  EcsCapacityLogGroup:\n Type: AWS::Logs::LogGroup\n DeletionPolicy: Delete\n Properties:\n LogGroupName: !Sub /aws/lambda/${AWS::StackName}-ecsCapacity\n RetentionInDays: 7\n  EcsCapacityPermission:\n    Type: AWS::Lambda::Permission\n...\n...\n```", "```\n> export AWS_PROFILE=docker-in-aws\n> aws cloudformation deploy --template-file stack.yml \\\n --stack-name todobackend --parameter-overrides $(cat dev.cfg) \\\n --capabilities CAPABILITY_NAMED_IAM\nEnter MFA code for arn:aws:iam::385605022855:mfa/justin.menga:\n\nWaiting for changeset to be created..\nWaiting for stack create/update to complete\nSuccessfully created/updated stack - todobackend\n```", "```\n> aws ecs list-tasks --cluster todobackend-cluster\n{\n    \"taskArns\": [\n        \"arn:aws:ecs:us-east-1:385605022855:task/5754a076-6f5c-47f1-8e73-c7b229315e31\"\n    ]\n}\n> aws ecs stop-task --cluster todobackend-cluster --task 5754a076-6f5c-47f1-8e73-c7b229315e31\n```", "```\n{\n    \"task\": {\n        ...\n        ...\n        \"lastStatus\": \"RUNNING\",\n        \"desiredStatus\": \"STOPPED\",\n        ...\n        ...\n    }\n}\n```", "```\n{\n  ...\n  ...\n  \"clusterArn\":  \"arn:aws:ecs:us-east-1:385605022855:cluster/todobackend-cluster\",      \n  \"containerInstanceArn\":  \"arn:aws:ecs:us-east-1:385605022855:container-instance/d27868d6-79fd-4858-bec6-65720855e0b3\",\n \"ec2InstanceId\":  \"i-0d9bd79d19a843216\",\n  \"registeredResources\": [             \n    { \"name\":  \"CPU\", \"type\":  \"INTEGER\", \"integerValue\":  1024 },\n    {       \"name\":  \"MEMORY\",                 \n       \"type\":  \"INTEGER\",                 \n       \"integerValue\":  993 },\n    { \"name\":  \"PORTS\",                 \n       \"type\":  \"STRINGSET\",                 \n       \"stringSetValue\": [\"22\",\"2376\",\"2375\",\"51678\",\"51679\"]\n    }\n  ],\n  \"remainingResources\": [ \n    { \n      \"name\": \"CPU\", \n      \"type\": \"INTEGER\", \n      \"integerValue\": 774 \n    },\n    { \n       \"name\": \"MEMORY\", \n       \"type\": \"INTEGER\", \n       \"integerValue\": 593 \n    },\n    {\n       \"name\": \"PORTS\", \n       \"type\": \"STRINGSET\", \n       \"stringSetValue\": [\"22\",\"2376\",\"2375\",\"51678\",\"51679\"]\n    }\n  ],\n  ...\n  ...\n}\n```", "```\n...\n...\nResources:\n  ...\n  ...\n  EcsCapacityFunction:\n    Type: AWS::Lambda::Function\n    DependsOn:\n      - EcsCapacityLogGroup\n    Properties:\n      Role: !Sub ${EcsCapacityRole.Arn}\n      FunctionName: !Sub ${AWS::StackName}-ecsCapacity\n      Description: !Sub ${AWS::StackName} ECS Capacity Manager\n      Code:\n ZipFile: |\n import json\n          import boto3\n          ecs = boto3.client('ecs')\n          # Max memory and CPU - you would typically inject these as environment variables\n          CONTAINER_MAX_MEMORY = 400\n          CONTAINER_MAX_CPU = 250\n\n          # Get current CPU\n          def check_cpu(instance):\n            return sum(\n              resource['integerValue']\n              for resource in instance['remainingResources']\n              if resource['name'] == 'CPU'\n            )\n          # Get current memory\n          def check_memory(instance):\n            return sum(\n              resource['integerValue']\n              for resource in instance['remainingResources']\n              if resource['name'] == 'MEMORY'\n            )\n          # Lambda entrypoint\n          def handler(event, context):\n            print(\"Received event %s\" % json.dumps(event))\n\n            # STEP 1 - COLLECT RESOURCE DATA\n            cluster = event['detail']['clusterArn']\n            # The maximum CPU availble for an idle ECS instance\n            instance_max_cpu = next(\n              resource['integerValue']\n              for resource in event['detail']['registeredResources']\n              if resource['name'] == 'CPU')\n            # The maximum memory availble for an idle ECS instance\n            instance_max_memory = next(\n              resource['integerValue']\n              for resource in event['detail']['registeredResources']\n              if resource['name'] == 'MEMORY')\n            # Get current container capacity based upon CPU and memory\n            instance_arns = ecs.list_container_instances(\n              cluster=cluster\n            )['containerInstanceArns']\n            instances = [\n              instance for instance in ecs.describe_container_instances(\n                cluster=cluster,\n                containerInstances=instance_arns\n              )['containerInstances']\n              if instance['status'] == 'ACTIVE'\n            ]\n            cpu_capacity = 0\n            memory_capacity = 0\n            for instance in instances:\n              cpu_capacity += int(check_cpu(instance)/CONTAINER_MAX_CPU)\n              memory_capacity += int(check_memory(instance)/CONTAINER_MAX_MEMORY)\n            print(\"Current container cpu capacity of %s\" % cpu_capacity)\n            print(\"Current container memory capacity of %s\" % memory_capacity)\n\n            # STEP 2 - CALCULATE OVERALL CONTAINER CAPACITY\n            container_capacity = min(cpu_capacity, memory_capacity)\n            print(\"Overall container capacity of %s\" % container_capacity)\n\n            # STEP 3 - CALCULATE IDLE HOST COUNT\n            idle_hosts = min(\n              cpu_capacity / int(instance_max_cpu / CONTAINER_MAX_CPU),\n              memory_capacity / int(instance_max_memory / CONTAINER_MAX_MEMORY)\n            )\n            print(\"Overall idle host capacity of %s\" % idle_hosts)\n      Runtime: python3.6\n      MemorySize: 128\n      Timeout: 300\n      Handler: index.handler\n...\n...\n```", "```\n...\n...\nResources:\n  ...\n  ...\n  EcsCapacityRole:\n    Type: AWS::IAM::Role\n    Properties:\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Action:\n              - sts:AssumeRole\n            Effect: Allow\n            Principal:\n              Service: lambda.amazonaws.com\n      Policies:\n        - PolicyName: EcsCapacityPermissions\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: ListContainerInstances\n Effect: Allow\n Action:\n - ecs:ListContainerInstances\n Resource: !Sub ${ApplicationCluster.Arn}\n - Sid: DescribeContainerInstances\n Effect: Allow\n Action:\n - ecs:DescribeContainerInstances\n Resource: \"*\"\n Condition:\n ArnEquals:\n ecs:cluster: !Sub ${ApplicationCluster.Arn}\n              - Sid: ManageLambdaLogs\n                Effect: Allow\n                Action:\n                - logs:CreateLogStream\n                - logs:PutLogEvents\n                Resource: !Sub ${EcsCapacityLogGroup.Arn}\n  ...\n  ...\n```", "```\n...\n...\nResources:\n  ...\n  ...\n  EcsCapacityFunction:\n    Type: AWS::Lambda::Function\n    DependsOn:\n      - EcsCapacityLogGroup\n    Properties:\n      Role: !Sub ${EcsCapacityRole.Arn}\n      FunctionName: !Sub ${AWS::StackName}-ecsCapacity\n      Description: !Sub ${AWS::StackName} ECS Capacity Manager\n      Code:\n        ZipFile: |\n          import json\n          import boto3\n          import datetime\n          ecs = boto3.client('ecs') cloudwatch = boto3.client('cloudwatch') # Max memory and CPU - you would typically inject these as environment variables\n          CONTAINER_MAX_MEMORY = 400\n          CONTAINER_MAX_CPU = 250          ...\n          ...\n          # Lambda entrypoint\n          def handler(event, context):\n            print(\"Received event %s\" % json.dumps(event))            ...\n            ...# STEP 3 - CALCULATE IDLE HOST COUNT            idle_hosts = min(\n              cpu_capacity / int(instance_max_cpu / CONTAINER_MAX_CPU),\n              memory_capacity / int(instance_max_memory / CONTAINER_MAX_MEMORY)\n            )\n            print(\"Overall idle host capacity of %s\" % idle_hosts)\n\n # STEP 4 - PUBLISH CLOUDWATCH METRICS\n cloudwatch.put_metric_data(\n Namespace='AWS/ECS',\n MetricData=[\n              {\n                'MetricName': 'ContainerCapacity',\n                'Dimensions': [{\n                  'Name': 'ClusterName',\n                  'Value': cluster.split('/')[-1]\n                }],\n                'Timestamp': datetime.datetime.utcnow(),\n                'Value': container_capacity\n              }, \n              {\n 'MetricName': 'IdleHostCapacity',\n 'Dimensions': [{\n 'Name': 'ClusterName',\n 'Value': cluster.split('/')[-1]\n }],\n 'Timestamp': datetime.datetime.utcnow(),\n 'Value': idle_hosts\n }\n            ])\n      Runtime: python3.6\n      MemorySize: 128\n      Timeout: 300\n      Handler: index.handler\n...\n...\n```", "```\n...\n...\nResources:\n  ...\n  ...\n  EcsCapacityRole:\n    Type: AWS::IAM::Role\n    Properties:\n      AssumeRolePolicyDocument:\n        Version: \"2012-10-17\"\n        Statement:\n          - Action:\n              - sts:AssumeRole\n            Effect: Allow\n            Principal:\n              Service: lambda.amazonaws.com\n      Policies:\n        - PolicyName: EcsCapacityPermissions\n          PolicyDocument:\n            Version: \"2012-10-17\"\n            Statement:\n              - Sid: PublishCloudwatchMetrics\n Effect: Allow\n Action:\n - cloudwatch:putMetricData\n Resource: \"*\"\n              - Sid: ListContainerInstances\n                Effect: Allow\n                Action:\n                  - ecs:ListContainerInstances\n                Resource: !Sub ${ApplicationCluster.Arn}\n              - Sid: DescribeContainerInstances\n                Effect: Allow\n                Action:\n                  - ecs:DescribeContainerInstances\n                Resource: \"*\"\n                Condition:\n                  ArnEquals:\n                    ecs:cluster: !Sub ${ApplicationCluster.Arn}\n              - Sid: ManageLambdaLogs\n                Effect: Allow\n                Action:\n                - logs:CreateLogStream\n                - logs:PutLogEvents\n                Resource: !Sub ${EcsCapacityLogGroup.Arn}\n  ...\n  ...\n```", "```\n...\n...\nResources:\n  ...\n  ...\n ContainerCapacityAlarm:\n Type: AWS::CloudWatch::Alarm\n Properties:\n AlarmDescription: ECS Cluster Container Free Capacity\n AlarmActions:\n        - !Ref ApplicationAutoscalingScaleOutPolicy\n Namespace: AWS/ECS\n Dimensions:\n - Name: ClusterName\n Value: !Ref ApplicationCluster\n MetricName: ContainerCapacity\n Statistic: Minimum\n Period: 60\n EvaluationPeriods: 1\n Threshold: 1\n ComparisonOperator: LessThanThreshold\n TreatMissingData: ignore\n IdleHostCapacityAlarm:\n Type: AWS::CloudWatch::Alarm\n Properties:\n AlarmDescription: ECS Cluster Container Free Capacity\n AlarmActions:\n        - !Ref ApplicationAutoscalingScaleInPolicy\n Namespace: AWS/ECS\n Dimensions:\n - Name: ClusterName\n Value: !Ref ApplicationCluster\n MetricName: IdleHostCapacity\n Statistic: Maximum\n Period: 60\n EvaluationPeriods: 1\n Threshold: 1\n ComparisonOperator: GreaterThanThreshold\n TreatMissingData: ignore\n  ...\n  ...\n```", "```\n...\n...\nResources:\n  ...\n  ...\n ApplicationAutoscalingScaleOutPolicy:\n    Type: AWS::AutoScaling::ScalingPolicy\n    Properties:\n      PolicyType: SimpleScaling\n      AdjustmentType: ChangeInCapacity\n      ScalingAdjustment: 1\n      AutoScalingGroupName: !Ref ApplicationAutoscaling\n      Cooldown: 600\n  ApplicationAutoscalingScaleInPolicy:\n    Type: AWS::AutoScaling::ScalingPolicy\n    Properties:\n      PolicyType: SimpleScaling\n      AdjustmentType: ChangeInCapacity\n      ScalingAdjustment: -1\n      AutoScalingGroupName: !Ref ApplicationAutoscaling\n      Cooldown: 600\n  ...\n  ...\n  ApplicationAutoscaling:\n    Type: AWS::AutoScaling::AutoScalingGroup\n    DependsOn:\n      - DmesgLogGroup\n      - MessagesLogGroup\n      - DockerLogGroup\n      - EcsInitLogGroup\n      - EcsAgentLogGroup\n    CreationPolicy:\n      ResourceSignal:\n Count: 1\n        Timeout: PT15M\n    UpdatePolicy:\n      AutoScalingRollingUpdate:\n        SuspendProcesses:\n - HealthCheck\n - ReplaceUnhealthy\n - AZRebalance\n - AlarmNotification\n - ScheduledActions        MinInstancesInService: 1\n        MinSuccessfulInstancesPercent: 100\n        WaitOnResourceSignals: \"true\"\n        PauseTime: PT15M\n    Properties:\n      LaunchConfigurationName: !Ref ApplicationAutoscalingLaunchConfiguration\n      MinSize: 0\n      MaxSize: 4\n DesiredCapacity: 1        ...\n        ...\n\n```", "```\nApplicationDesiredCount=2\nApplicationImageId=ami-ec957491\nApplicationImageTag=5fdbe62\nApplicationSubnets=subnet-a5d3ecee,subnet-324e246f\nVpcId=vpc-f8233a80\n```", "```\nApplicationDesiredCount=1\nApplicationImageId=ami-ec957491\nApplicationImageTag=5fdbe62\nApplicationSubnets=subnet-a5d3ecee,subnet-324e246f\nVpcId=vpc-f8233a80\n```", "```\n...\n...\nResources:\n  ApplicationServiceLowCpuAlarm:\n Type: AWS::CloudWatch::Alarm\n Properties:\n AlarmActions:\n - !Ref ApplicationServiceAutoscalingScaleInPolicy\n AlarmDescription: Todobackend Service Low CPU \n Namespace: AWS/ECS\n Dimensions:\n - Name: ClusterName\n Value: !Ref ApplicationCluster\n - Name: ServiceName\n Value: !Sub ${ApplicationService.Name}\n MetricName: CPUUtilization\n Statistic: Average\n Period: 60\n EvaluationPeriods: 3\n Threshold: 20\n ComparisonOperator: LessThanThreshold\n ApplicationServiceHighCpuAlarm:\n Type: AWS::CloudWatch::Alarm\n Properties:\n AlarmActions:\n - !Ref ApplicationServiceAutoscalingScaleOutPolicy\n AlarmDescription: Todobackend Service High CPU \n Namespace: AWS/ECS\n Dimensions:\n - Name: ClusterName\n Value: !Ref ApplicationCluster\n - Name: ServiceName\n Value: !Sub ${ApplicationService.Name}\n MetricName: CPUUtilization\n Statistic: Average\n Period: 60\n EvaluationPeriods: 3\n Threshold: 40\n ComparisonOperator: GreaterThanThreshold\n  ...\n  ...\n```", "```\n...\n...\nResources:\n ApplicationServiceAutoscalingTarget:\n Type: AWS::ApplicationAutoScaling::ScalableTarget\n Properties:\n ServiceNamespace: ecs\n ResourceId: !Sub service/${ApplicationCluster}/${ApplicationService.Name}\n ScalableDimension: ecs:service:DesiredCount\n MinCapacity: 1\n MaxCapacity: 4\n RoleARN: !Sub ${ApplicationServiceAutoscalingRole.Arn}\n  ...\n  ...\n```", "```\n...\n...\nResources:\n  ApplicationServiceAutoscalingRole:\n Type: AWS::IAM::Role\n Properties:\n AssumeRolePolicyDocument:\n Version: \"2012-10-17\"\n Statement:\n - Action:\n - sts:AssumeRole\n Effect: Allow\n Principal:\n Service: application-autoscaling.amazonaws.com\n Policies:\n - PolicyName: AutoscalingPermissions\n PolicyDocument:\n Version: \"2012-10-17\"\n Statement:\n - Effect: Allow\n Action:\n - application-autoscaling:DescribeScalableTargets\n - application-autoscaling:DescribeScalingActivities\n - application-autoscaling:DescribeScalingPolicies\n - cloudwatch:DescribeAlarms\n - cloudwatch:PutMetricAlarm\n - ecs:DescribeServices\n - ecs:UpdateService\n Resource: \"*\"\n  ApplicationServiceAutoscalingTarget:\n    Type: AWS::ApplicationAutoScaling::ScalableTarget\n  ...\n  ...\n```", "```\n...\n...\nResources:\n  ApplicationServiceAutoscalingScaleInPolicy:\n Type: AWS::ApplicationAutoScaling::ScalingPolicy\n Properties:\n PolicyName: ScaleIn\n PolicyType: StepScaling\n ScalingTargetId: !Ref ApplicationServiceAutoscalingTarget\n StepScalingPolicyConfiguration:\n AdjustmentType: ChangeInCapacity\n Cooldown: 360\n MetricAggregationType: Average\n StepAdjustments:\n - ScalingAdjustment: -1\n MetricIntervalUpperBound: 0\n ApplicationServiceAutoscalingScaleOutPolicy:\nType: AWS::ApplicationAutoScaling::ScalingPolicy\n Properties:\n PolicyName: ScaleOut\n PolicyType: StepScaling\n ScalingTargetId: !Ref ApplicationServiceAutoscalingTarget\n StepScalingPolicyConfiguration:\n AdjustmentType: ChangeInCapacity\n Cooldown: 360\n MetricAggregationType: Average\n StepAdjustments:\n - ScalingAdjustment: 1\n MetricIntervalLowerBound: 0\n```", "```\nApplicationServiceAutoscalingRole:\n    Type: AWS::IAM::Role\n  ...\n  ...\n```"]