- en: '*Chapter 21*: Threads and Starting the Live Drawing App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第21章*：线程和启动Live Drawing应用程序'
- en: In this chapter, we will get started on our next app. This app will be a kid's
    drawing app where the user can draw on the screen with their finger. This drawing
    app will be slightly different, however. The lines that the user draws will comprise
    particle systems that explode into thousands of pieces. We will call the project
    Live Drawing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始我们的下一个应用程序。这个应用程序将是一个儿童绘画应用程序，用户可以用手指在屏幕上绘画。但是，这个绘画应用程序将略有不同。用户绘制的线条将包括成千上万个粒子的粒子系统。我们将称这个项目为Live
    Drawing。
- en: 'To achieve this, we will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将执行以下操作：
- en: Get started with the Live Drawing app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Live Drawing应用程序
- en: Learn about real-time interaction, sometimes called a game loop
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解实时交互，有时被称为游戏循环
- en: Learn about threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解线程
- en: Code a real-time system ready to draw with in the next chapter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个准备在下一章绘制的实时系统
- en: Let's get started.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2021](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2021).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中的代码文件，网址为[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2021](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2021)。
- en: Creating the Live Drawing project
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Live Drawing项目
- en: To get started, create a new project in Android Studio and call it `Live Drawing`.
    Use the **Empty Activity** project.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请在Android Studio中创建一个名为`Live Drawing`的新项目。使用**空活动**项目。
- en: Now we will consider the name of the files and the screen real estate. In this
    project, we will learn something new. It is not always appropriate to use the
    default name for our Activity class. In this project, the Activity class isn't
    going to be the most significant class and `MainActivity` doesn't seem like an
    appropriate name. Let's rename it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将考虑文件的名称和屏幕房地产。在这个项目中，我们将学习一些新东西。对于我们的Activity类，使用默认名称并不总是合适的。在这个项目中，Activity类不会是最重要的类，`MainActivity`似乎不是一个合适的名称。让我们重命名它。
- en: Refactoring MainActivity to LiveDrawingActivity
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将MainActivity重构为LiveDrawingActivity
- en: It is a good practice to use meaningful names for all the different parts of
    our code. For this project, I think `MainActivity` is a bit vague and inconclusive.
    We could make do with it, but let's rename it to something more meaningful. This
    will also let us see how we can use the `MainActivity` filename to `LiveDrawingActivity`,
    Android Studio will change the name of the file as well as some code in the `AndroidManifest.xml`
    file and the `MainActivity.java` (soon to be `LiveDrawingActivity.java`) file.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的代码的所有不同部分使用有意义的名称是一个很好的做法。对于这个项目，我认为`MainActivity`有点模糊和不确定。我们可以将其使用，但让我们将其重命名为更有意义的名称。这也将让我们看到如何将`MainActivity`文件名更改为`LiveDrawingActivity`，Android
    Studio将更改`AndroidManifest.xml`文件和`MainActivity.java`（即将更改为`LiveDrawingActivity.java`）文件中的一些代码。
- en: In the project panel, right-click the `MainActivity` file and select **Refactor**
    | **Rename**. In the pop-up window, change **MainActivity** to **LiveDrawingActivity**.
    Leave all the other options as their defaults and left-click the **Refactor**
    button.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目面板中，右键单击`MainActivity`文件，然后选择**重构** | **重命名**。在弹出窗口中，将**MainActivity**更改为**LiveDrawingActivity**。将所有其他选项保持为默认值，然后单击**重构**按钮。
- en: Notice the filename in the project panel has changed as expected but also multiple
    occurrences of `MainActivity` have been changed to `LiveDrawingActivity` in the
    `AndroidManifest.xml` file as well as an instance in the `LiveDrawingActivity.java`
    file. You can scan these files now to see this if you are interested, but we will
    go into more detail about both files in the upcoming sections anyway.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，项目面板中的文件名已如预期更改，但`AndroidManifest.xml`文件中的多个实例以及`LiveDrawingActivity.java`文件中的多个实例也已更改为`LiveDrawingActivity`。如果您感兴趣，现在可以扫描这些文件以查看这一点，但无论如何，我们将在即将到来的章节中更详细地讨论这两个文件。
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Refactoring is an important tool and understanding that there is more going
    on behind the scenes is vital to avoid confusion.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重构是一个重要的工具，了解幕后发生的更多事情对于避免混淆至关重要。
- en: Locking the game to fullscreen and landscape orientation
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将游戏锁定到全屏和横向方向
- en: We want to use every pixel that the user's Android device has to offer so we
    will make changes to the `AndroidManifest.xml` file, which allows us to use a
    style for our app that hides all the default menus from the user interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用用户Android设备提供的每个像素，因此我们将对`AndroidManifest.xml`文件进行更改，这允许我们为应用程序使用一个样式，隐藏用户界面中的所有默认菜单。
- en: 'Open the `AndroidManifest.xml` file from the `manifests` folder. In the `AndroidManifest.xml`
    file, locate the following line of code: `android:name=".LiveDrawingActivity">.`'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从`manifests`文件夹中打开`AndroidManifest.xml`文件。在`AndroidManifest.xml`文件中，找到以下代码行：`android:name=".LiveDrawingActivity">。`
- en: Place the cursor before the closing `>` shown previously. Tap the *Enter* key
    a couple of times to move the `>` a couple of lines below the rest of the line
    shown previously.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将光标放在先前显示的关闭`>`之前。按*Enter*键几次，将`>`移动到先前显示的其余行下方几行。
- en: Immediately below `".LiveDrawingActivity"` but before the newly positioned `>`,
    type or copy and paste this next line of code to make the game run without the
    default user interface.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在`".LiveDrawingActivity"`下方，但在新定位的`>`之前，键入或复制并粘贴下一行代码，以使游戏在没有默认用户界面的情况下运行。
- en: 'Note that the line of code is shown on two lines because it is too long to
    fit on a printed page, but in Android Studio you should enter it as one line:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码行显示在两行上，因为它太长而无法适应打印页面，但在Android Studio中，您应该将其输入为一行：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is a fiddly set of steps so here I am showing you a bigger range of this
    file with the code we just added highlighted among it for extra context. As mentioned
    previously, I have had to show some lines of code over two lines:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一组繁琐的步骤，所以在这里我向您展示了这个文件的更大范围，其中我们刚刚添加的代码也被突出显示，以提供额外的上下文。如前所述，我不得不将一些代码行显示为两行：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now our app will use all the screen space the device makes available without
    any extra menus. We will also see some new Java code to make our app dominate
    every pixel of the screen.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序将使用设备提供的所有屏幕空间，而不需要任何额外的菜单。我们还将看到一些新的Java代码，使我们的应用程序占据屏幕的每一个像素。
- en: Making some placeholder classes
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一些占位符类
- en: This app consists of Java files only. The Java files with all the code up to
    the end of this chapter can all be found in the [*Chapter 21*](B16773_21_ePub_RK.xhtml#_idTextAnchor366)
    folder of the download bundle.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序只包含Java文件。到本章结束时的所有代码都可以在下载包的[*第21章*](B16773_21_ePub_RK.xhtml#_idTextAnchor366)文件夹中找到。
- en: Next, we will create empty classes that we will code throughout the project
    over the next two chapters. Create a new class called `LiveDrawingView`, a new
    class called `ParticleSystem`, and a new class called `Particle`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一些空类，我们将在接下来的两章项目中编写。创建一个名为`LiveDrawingView`的新类，一个名为`ParticleSystem`的新类，以及一个名为`Particle`的新类。
- en: Let's look ahead a bit.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微展望一下。
- en: Looking ahead at the Live Drawing app
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展望Live Drawing应用程序
- en: As this app is more in-depth and needs to respond in real-time, it is necessary
    to use a slightly more in-depth structure. At first, this seems like a complication
    but in the long run, it can even make our code simpler and easier to understand.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个应用程序更加深入，并且需要实时响应，因此需要使用稍微更深入的结构。起初，这似乎是一个复杂，但从长远来看，它甚至可以使我们的代码更简单、更容易理解。
- en: 'We will have four classes in the Live Drawing app:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Live Drawing应用程序中，我们将有四个类：
- en: '`LiveDrawingActivity`: The `Activity` class provided by the Android API is
    the class that interacts with the operating system. We have already seen how the
    OS interacts with `onCreate` when the user clicks the app icon to start an app.
    Rather than have a class called `MainActivity` that does everything, we will have
    an Activity-based class that just handles the startup and shutdown of our app
    as well as helping a bit with initialization by getting the screen resolution.
    It makes sense that this class will be of type `Activity`. However, as you will
    soon see, we will delegate interacting with touches to another class, the same
    class that will also handle almost every aspect of the app. This will introduce
    us to some interesting concepts that will be new to us.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiveDrawingActivity`：Android API提供的`Activity`类是与操作系统交互的类。我们已经看到了当用户点击应用程序图标启动应用程序时，操作系统是如何与`onCreate`交互的。我们不再使用一个叫做`MainActivity`的类来处理所有事情，而是使用一个基于Activity的类来处理应用程序的启动和关闭，以及通过获取屏幕分辨率来帮助初始化。这个类将是`Activity`类型是有意义的。然而，很快你会看到，我们将委托触摸交互给另一个类，这个类也将处理几乎每个方面的应用程序。这将为我们介绍一些新的有趣的概念。 '
- en: '`LiveDrawingView`: This is the class that will be responsible for doing the
    drawing and creating the real-time environment, which allows the user to interact
    at the same time as their creations are moving and evolving.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiveDrawingView`：这是负责绘图和创建实时环境的类，允许用户在他们的创作移动和发展的同时进行交互。'
- en: '`ParticleSystem`: This is the class that will manage up to thousands of instances
    of the `Particle` class.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParticleSystem`：这个类将管理`Particle`类的成千上万个实例。'
- en: '`Particle`: This class will be the simplest of them all. It will have a location
    onscreen and a heading. It will update itself around 60 times per second when
    prompted to by the `LiveDrawingView` class.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Particle`：这个类将是最简单的。它将在屏幕上有一个位置和一个方向。当`LiveDrawingView`类提示时，它将每秒更新大约60次。'
- en: Now we can start coding.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始编码了。
- en: Coding the LiveDrawingActivity class
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写LiveDrawingActivity类
- en: Let's get started with coding the `Activity` based class. We called this class
    `LiveDrawingActivity` when we refactored `MainActivity`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始编写基于`Activity`的类。当我们重构`MainActivity`时，我们将这个类称为`LiveDrawingActivity`。
- en: 'Replace the contents of the `LiveDrawingActivity` class (excluding the package
    declaration) with the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换`LiveDrawingActivity`类的内容（不包括包声明）：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code shows some errors and we will talk about them shortly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 代码显示了一些错误，我们很快会讨论它们。
- en: 'The first new line of code is this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行新代码是这样的：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This line of code removes the title from the user interface. The screen will
    be completely empty when we run this app.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码从用户界面中移除了标题。当我们运行这个应用程序时，屏幕将完全为空。
- en: 'The code gets the number of pixels (wide and high) for the device in the following
    way. Look again at the next new line of code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码以以下方式获取设备的像素数（宽和高）。再看一下下一行新代码：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We create an object of type `Display` called `display` and initialize it with
    the result of calling both `getWindowManager` then `getDefaultDisplay` methods
    in turn, which are part of the `Activity` class.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`display`的`Display`类型的对象，并用调用`getWindowManager`和`getDefaultDisplay`方法的结果依次初始化它，这些方法都是`Activity`类的一部分。
- en: Then we create a new object called `size` of the `Point` type. We send `size`
    as an argument to the `display.getSize` method. The `Point` type has an `x` and
    `y` member variable, and therefore, so does the `size` object, which after the
    third line of code now holds the width and height (in pixels) of the display.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了一个名为`size`的`Point`类型的新对象。我们将`size`作为参数发送给`display.getSize`方法。`Point`类型有一个`x`和`y`成员变量，因此`size`对象也有，经过第三行代码后，它现在保存了显示器的宽度和高度（以像素为单位）。
- en: Now we have the screen resolution in `x` and `y` variables hidden away in the
    `size` object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将屏幕分辨率隐藏在`size`对象中的`x`和`y`变量中。
- en: 'The next new thing is that we are declaring an instance of our `LiveDrawingView`
    class. Currently, this is an empty class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的新事物是，我们声明了我们的`LiveDrawingView`类的一个实例。目前，这是一个空类：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next in the `onCreate` method, we initialize `mLiveDrawingView` like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`onCreate`方法中，我们像这样初始化`mLiveDrawingView`：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What we are doing is passing three arguments to the `LiveDrawingView` constructor.
    We have obviously not coded a constructor yet and as we know the default constructor
    takes zero arguments. Therefore, this line will cause an error until we fix it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在向`LiveDrawingView`构造函数传递三个参数。显然，我们还没有编写构造函数，我们知道默认构造函数不带参数。因此，在我们修复它之前，这行代码将导致错误。
- en: The arguments passed in are interesting. First, `this`, which is a reference
    to the `LiveDrawingActivity` class. The `LiveDrawingView` class will need to use
    methods that it needs this reference for.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的参数很有趣。首先是`this`，它是对`LiveDrawingActivity`类的引用。`LiveDrawingView`类将需要使用它需要这个引用的方法。
- en: The second and third arguments are the horizontal and vertical screen resolution.
    It makes sense that our app will need these to perform tasks such as detecting
    the edge of the screen and scaling the drawing objects to an appropriate size.
    We will discuss these arguments further when we get to coding the `LiveDrawingView`
    constructor.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个和第三个参数是水平和垂直屏幕分辨率。我们的应用程序需要这些来执行诸如检测屏幕边缘和将绘图对象缩放到适当大小等任务是有意义的。当我们开始编写`LiveDrawingView`构造函数时，我们将进一步讨论这些参数。
- en: 'Next, take a look at the line that follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，看一下接下来的一行：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is where, in the Canvas Demo app, we set the `ImageView` as the content
    for the app. Remember that the `Activity` class's `setContentView` method must
    take a `View` object and `ImageView` is a `View`. This previous line of code seems
    to be suggesting that we will use our `LiveDrawingView` class as the visible content
    for the app. But `LiveDrawingView`, despite its name, isn't a `View`. Not yet
    anyway.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Canvas Demo应用程序中，我们将`ImageView`设置为应用程序的内容。请记住，`Activity`类的`setContentView`方法必须接受一个`View`对象，而`ImageView`是一个`View`。前一行代码似乎在暗示我们将使用我们的`LiveDrawingView`类作为应用程序的可见内容。但是`LiveDrawingView`，尽管名字是这样，但它还不是`View`。至少目前还不是。
- en: We will fix the constructor and the not a `View` problem after we add a few
    more lines of code to `LiveDrawingActivity`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向`LiveDrawingActivity`添加几行代码之后，我们将修复构造函数和不是`View`问题。
- en: Reader challenge
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 读者挑战
- en: Can you guess which OOP concept the solution might be?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到解决方案可能是哪种OOP概念吗？
- en: 'Add these two overridden methods and then we will talk about them. Add them
    below the closing curly brace of the `onCreate` method but before the closing
    curly brace of the `LiveDrawingActivity` class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这两个重写的方法，然后我们将讨论它们。将它们添加到`onCreate`方法的右大括号下面，但在`LiveDrawingActivity`类的右大括号之前添加：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What we have done is to override two more of the methods of the `Activity` class.
    We will see why we need to do this and what we will do inside these methods. The
    point to note here is that by adding these overridden methods, we are giving the
    OS the opportunity to notify us of the user's intentions in two more situations.
    Much as we did when saving and loading our data in the Note to Self app.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是重写`Activity`类的另外两个方法。我们将看到为什么我们需要这样做以及我们将在这些方法内部做什么。这里要注意的一点是，通过添加这些重写的方法，我们给了操作系统在另外两种情况下通知我们用户意图的机会。就像我们在Note
    to Self应用程序中保存和加载数据时所做的那样。
- en: It makes sense at this point to move on to the `LiveDrawingView` class, the
    main class of this app. We will come back to the `LiveDrawingActivity` class near
    the end of the chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，转到`LiveDrawingView`类是有意义的，这是该应用程序的主要类。我们将在本章末回到`LiveDrawingActivity`类。
- en: Coding the LiveDrawingView class
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写LiveDrawingView类
- en: 'The first thing we will do is solve the problem of our `LiveDrawingView` class
    not being of type `View`. Update the class declaration as highlighted, like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是解决`LiveDrawingView`类不是`View`类型的问题。更新类声明如下所示：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will need to import the `android.view.SurfaceView` class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要导入`android.view.SurfaceView`类。
- en: '`SurfaceView` is a descendant of `View` and now `LiveDrawingView` is, by inheritance,
    also a type of `View`. Look again at the `import` statement that has been added.
    This relationship is made clear as highlighted next:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`SurfaceView`是`View`的后代，现在`LiveDrawingView`也是`View`的一种类型，通过继承。再次看看已添加的`import`语句。这种关系如下所示：'
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that it is because of polymorphism that we can send descendants of
    `View` to the `setContentView` method in the `LiveDrawingActivity` class and it
    is because of inheritance that the `LiveDrawingView` class is now a type of `SurfaceView`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，正是由于多态性，我们可以将`View`的后代发送到`LiveDrawingActivity`类中的`setContentView`方法，而正是由于继承，`LiveDrawingView`类现在是`SurfaceView`的一种类型。
- en: There are quite a few descendants of `View` that we could have extended to fix
    this initial problem, but we will see as we continue that the `SurfaceView` class
    has some very specific features that are perfect for real-time-interactive apps
    that made this choice the right one for us.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多`View`的后代可以扩展以解决这个初始问题，但随着我们继续，我们将看到`SurfaceView`类具有一些非常特定的功能，非常适合实时交互应用程序，这使得这个选择对我们来说是正确的。
- en: We still have errors in both this class and the `LiveDrawingActivity` class.
    Both are due to the lack of a suitable constructor method.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个类和`LiveDrawingActivity`类中仍然有错误。这两个错误都是由于缺少合适的构造方法。
- en: 'Here is a screenshot showing the error in the `LiveDrawingView` class since
    we extended `SurfaceView`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一张屏幕截图显示了`LiveDrawingView`类中的错误，因为我们扩展了`SurfaceView`：
- en: '![Figure 21.1 – The error in the LiveDrawingView class'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图21.1 - LiveDrawingView类中的错误'
- en: '](img/Figure_21.1_B16773.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_21.1_B16773.jpg)'
- en: Figure 21.1 – The error in the LiveDrawingView class
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.1 - LiveDrawingView类中的错误
- en: The error in `LiveDrawingActivity` is more obvious; we are calling a method
    that doesn't exist. However, the error shown in the previous screenshot is less
    easily understood. Let's discuss the error in the `LiveDrawingView` class declaration
    now.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveDrawingActivity`中的错误更明显；我们调用了一个不存在的方法。然而，前面截图中显示的错误不太容易理解。现在让我们讨论`LiveDrawingView`类声明中的错误。'
- en: The `LiveDrawingView` class, now it is a `SurfaceView`, must be supplied with
    a constructor because, as mentioned in the OOP chapters, once you have provided
    your own constructor the default (no parameter) one ceases to exist. As the `SurfaceView`
    class implements several different constructors, we must specifically implement
    one of these or write our own. Hence the previous error.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveDrawingView`类，现在是一个`SurfaceView`，必须提供一个构造函数，因为如OOP章节中所述，一旦你提供了自己的构造函数，默认（无参数）构造函数就不复存在了。由于`SurfaceView`类实现了几种不同的构造函数，我们必须明确实现其中的一个或编写我们自己的。因此出现了之前的错误。'
- en: As none of the `SurfaceView` provided constructors are exactly what we need,
    we will provide our own.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有提供的`SurfaceView`构造函数正是我们所需要的，我们将提供我们自己的构造函数。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are wondering how on earth you know what constructors are supplied and
    any other details you need to find out about an Android class, just Google it.
    Type the class name followed by `API`. Google will almost always supply as the
    top result a link to the relevant page on the Android developer''s website. Here
    is a direct link to the `SurfaceView` page: [https://developer.android.com/reference/android/view/SurfaceView.html](https://developer.android.com/reference/android/view/SurfaceView.html).
    Look under the **Public constructors** heading, and you will see that some constructors
    are optionally made available.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道如何知道提供了哪些构造函数和关于Android类的其他细节，只需谷歌一下。输入类名，后跟`API`。谷歌几乎总会提供一个指向Android开发者网站相关页面的链接作为最顶部的结果。这是`SurfaceView`页面的直接链接：[https://developer.android.com/reference/android/view/SurfaceView.html](https://developer.android.com/reference/android/view/SurfaceView.html)。查看**Public
    constructors**标题下，你会看到一些可选的构造函数。
- en: 'The `LiveDrawingActivity` also requires us to create a constructor that matches
    the way we try to initialize it in this line of code from the `LiveDrawingActivity`
    class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveDrawingActivity`还要求我们创建一个构造函数，与我们尝试在`LiveDrawingActivity`类中初始化的方式匹配：'
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's add a constructor that matches the call from `LiveDrawingActivity` that
    passes in `this` and the screen resolution and solve both problems at once.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个构造函数，与从`LiveDrawingActivity`传入`this`和屏幕分辨率的调用匹配，并一次解决两个问题。
- en: Coding the LiveDrawingView class
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写`LiveDrawingView`类
- en: 'Remember that the `LiveDrawingView` class cannot see the variables in the `LiveDrawingActivity`
    class. By using the constructor, `LiveDrawingActivity` is providing `LiveDrawingView`
    with a reference to itself (`this`) as well as the screen size in pixels contained
    in `size.x` and `size.y`. Add this constructor to the `LiveDrawingView.java` file.
    The code must go within the opening and closing curly braces of the class. It
    is a convention but not required to place constructors above other methods but
    after member variable declarations:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`LiveDrawingView`类无法看到`LiveDrawingActivity`类中的变量。通过使用构造函数，`LiveDrawingActivity`提供了对自身（`this`）以及包含在`size.x`和`size.y`中的像素屏幕大小的引用。将此构造函数添加到`LiveDrawingView.java`文件中。代码必须放在类的开头和结尾的大括号内。这是一种约定，但不是必须的，将构造函数放在其他方法之上，但在成员变量声明之后：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Import the `Context` class with this line of code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码导入`Context`类：
- en: '`import android.content.Context;`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`import android.content.Context;`'
- en: Now we have no errors in our `LiveDrawingView` class or the `LiveDrawingActivity`
    class that initializes it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的`LiveDrawingView`类或初始化它的`LiveDrawingActivity`类中没有错误。
- en: At this stage, we could run the app and see that using `LiveDrawingView` as
    the `View` in `setContentView` has worked and we have a beautiful blank screen,
    ready to draw our particle systems on. Try this if you like, but we will be coding
    the `LiveDrawingView` class so that it does something, including adding code to
    the constructor, next.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们可以运行应用程序，看看使用`LiveDrawingView`作为`setContentView`中的`View`是否有效，并且我们有一个美丽的空白屏幕，准备在上面绘制我们的粒子系统。如果你愿意，可以尝试一下，但我们将编写`LiveDrawingView`类，使其做一些事情，包括在构造函数中添加代码，接下来。
- en: We will be returning to this class constantly over the course of this project.
    What we will do right now is get the fundamentals set up ready to add the `ParticleSystem`
    instances after we have coded them in the next chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目的过程中，我们将不断回到这个类。我们现在要做的是准备好基本知识，以便在下一章中编写`ParticleSystem`实例后添加它们。
- en: To achieve this, first, we will add a bunch of member variables, then we will
    add some code inside the constructor to set the class up when it is instantiated/created
    by `LiveDrawingActivity`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，首先我们将添加一堆成员变量，然后我们将在构造函数内部添加一些代码，以便在`LiveDrawingActivity`实例化/创建时设置类。
- en: Following on, we get to code the `draw` method, which will reveal the new steps
    that we need to take to draw on the screen 60 times per second and we will also
    see some familiar code that uses our old friends `Canvas`, `Paint`, and `drawText`
    from the previous chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写`draw`方法，它将揭示我们需要采取的新步骤，以便每秒在屏幕上绘制60次，并且我们还将看到一些熟悉的代码，使用了我们上一章的老朋友`Canvas`、`Paint`和`drawText`。
- en: At this point, we need to discuss some more theory – things such as how we will
    time the animations of the particles and how we lock these timings without interfering
    with the smooth running of Android. These last two topics, the **game loop** and
    **threads**, will then allow us to add the final code of the chapter and witness
    our particle system painting app in action – albeit with just a bit of text.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要讨论更多的理论 - 诸如我们将如何计时粒子的动画以及如何锁定这些时间而不干扰Android的平稳运行等事情。这最后两个主题，**游戏循环**和**线程**，将允许我们添加本章的最终代码，并见证我们的粒子系统绘画应用程序的运行
    - 尽管只有一点点文本。
- en: Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A game loop is a concept that describes allowing virtual systems to update and
    draw themselves at the same time as allowing them to be altered/interacted with
    by the user.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环是一个概念，描述了允许虚拟系统在允许用户改变/交互的同时更新和绘制自己的能力。
- en: Adding the member variables
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加成员变量
- en: 'Add the variables as shown below, after the `LiveDrawingView` declaration but
    before the constructor, then import the necessary extra classes:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 按照下面所示的变量添加到`LiveDrawingView`声明之后但在构造函数之前，然后导入必要的额外类：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following `import` code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下`import`代码：
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Be sure to study the code and then we can talk about it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 确保学习代码，然后我们可以讨论它。
- en: We are using the naming convention of adding `m` before the member variable
    names. As we add local variables in the methods, this will help distinguish them
    from each other.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用在成员变量名之前添加`m`的命名约定。当我们在方法中添加局部变量时，这将有助于区分它们。
- en: Also, notice that all the variables are declared `private`. You could happily
    delete all the `private` access specifiers and the code would still work but as
    we have no need to access any of these variables from outside of this class, it
    is sensible to guarantee it can never happen by declaring them `private`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意所有变量都声明为`private`。你可以愉快地删除所有`private`访问修饰符，代码仍然可以工作，但由于我们没有必要从这个类的外部访问任何这些变量，因此通过声明它们为`private`来保证它永远不会发生是明智的。
- en: The first member variable is `DEBUGGING`. We have declared this as `final` because
    we don't want to change its value during the app's execution. Note that declaring
    it `final` does not preclude us from switching its value manually when we wish
    to switch between debugging and not debugging.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个成员变量是`DEBUGGING`。我们将其声明为`final`，因为我们不希望在应用程序执行期间更改其值。请注意，将其声明为`final`并不妨碍我们在希望在调试和非调试之间切换时手动更改其值。
- en: 'The next three classes we declared instances of will handle the drawing on
    the screen. Notice the new one we have not seen before that I have highlighted:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明的接下来的三个类的实例将处理屏幕上的绘图。请注意我突出显示的新类：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `SurfaceHolder` class is required to enable drawing to take place. It literally
    is the object that *holds* the drawing surface. We will see the methods it allows
    us to use to draw on the screen when we code the `draw` method in a minute.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`SurfaceHolder`类是必需的，以便进行绘图。它实际上是*持有*绘图表面的对象。当我们编写`draw`方法时，我们将看到它允许我们使用的方法来在屏幕上绘制。'
- en: 'The next two variables give us a bit of insight into what we will need to achieve
    our smooth and consistent animation. Here they are again:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个变量让我们对实现平滑和一致的动画有了一些了解。再次列出如下：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `mFPS` variable is of type `long` because it will be holding a huge number.
    Computers measure time in milliseconds since 1970 – more on that when we talk
    about the game loop. But for now, we need to know that monitoring and measuring
    the speed of each frame of animation is how we will make sure that the particles
    move exactly as they should.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`mFPS`变量的类型是`long`，因为它将保存一个巨大的数字。计算机从1970年以来以毫秒为单位来测量时间 - 关于这一点，我们在谈论游戏循环时会详细讨论。但现在，我们需要知道，监控和测量每一帧动画的速度是确保粒子移动正常的关键。'
- en: The first `mFPS` will be reinitialized every frame of animation, around 60 times
    per second. It will be passed into each of the particle system (every frame of
    animation) so that it knows how much time has elapsed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`mFPS`将在每一帧动画中重新初始化，大约每秒60次。它将被传递到每个粒子系统（每一帧动画）中，以便它知道经过了多少时间。
- en: The `MILLIS_IN_SECOND` variable is initialized to `1000`. There are indeed `1000`
    milliseconds in a second. We will use this variable in calculations as it will
    make our code clearer than if we used the literal value `1000`. It is declared
    `final` because the number of milliseconds in a second will obviously never change.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`MILLIS_IN_SECOND`变量初始化为`1000`。一秒钟确实有`1000`毫秒。我们将在计算中使用这个变量，因为它会使我们的代码比使用字面值`1000`更清晰。它声明为`final`，因为一秒钟的毫秒数显然永远不会改变。'
- en: 'The next piece of the code we just added is shown again here for convenience:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加的代码的下一部分为了方便起见再次显示如下：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The variables `mScreenX` and `mScreenY` will hold the horizontal and vertical
    resolution of the screen. Remember that they are being passed in from `LiveDrawingActivity`
    into the constructor.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`mScreenX`和`mScreenY`将保存屏幕的水平和垂直分辨率。请记住，它们是从`LiveDrawingActivity`传递到构造函数中的。
- en: The next two, `mFontSize` and `mMarginSize`, will be initialized based on the
    screen size in pixels, to hold a value in pixels to make the formatting of our
    text neat and more concise than constantly doing calculations for each bit of
    text.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个变量`mFontSize`和`mMarginSize`将根据屏幕大小（以像素为单位）进行初始化，以保存像素值，使我们的文本格式整齐，并且比为每个文本位进行不断的计算更简洁。
- en: Now we can begin to initialize some of these variables in the constructor.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始在构造函数中初始化一些这些变量。
- en: Coding the LiveDrawingView constructor
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写LiveDrawingView构造函数
- en: 'Add the highlighted code to the constructor. Be sure to study the code as well
    and then we can discuss it:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将突出显示的代码添加到构造函数中。确保也学习代码，然后我们可以讨论它：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The code we just added to the constructor begins by using the values passed
    in as parameters (`x` and `y`) to initialize `mScreenX` and `mScreenY`. Our entire
    `LiveDrawingView` class now has access to the screen resolution whenever it needs
    it. Here are the two lines again:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚添加到构造函数的代码首先使用传递的参数值（`x`和`y`）来初始化`mScreenX`和`mScreenY`。我们的整个`LiveDrawingView`类现在可以在需要时访问屏幕分辨率。以下是这两行代码：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we initialize `mFontSize` and `mFontMargin` as a fraction of the screen
    width in pixels. These values are a bit arbitrary, but they work, and we will
    use various multiples of these variables to align text neatly on the screen. Here
    are the two lines of code I am referring to:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将`mFontSize`和`mFontMargin`初始化为屏幕宽度的像素分数。这些值有点随意，但它们有效，并且我们将使用这些变量的各种倍数来使文本在屏幕上整齐对齐。以下是我所指的两行代码：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Moving on, we initialize our `Paint` and `SurfaceHolder` objects. `Paint` uses
    the default constructor as we have done previously but `mHolder` uses the `getHolder`
    method, which is a method of the `SurfaceView` class. The `getHolder` method returns
    a reference that is initialized to `mHolder` so `mHolder` is now that reference.
    In short, `mHolder` is now ready to be used. We have access to this handy method
    because `LiveDrawingView` is a `SurfaceView`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们初始化了我们的`Paint`和`SurfaceHolder`对象。`Paint`使用了默认构造函数，就像我们之前做过的那样，但`mHolder`使用了`getHolder`方法，这是`SurfaceView`类的一个方法。`getHolder`方法返回一个初始化为`mHolder`的引用，所以`mHolder`现在就是那个引用。简而言之，`mHolder`现在已经准备好使用了。我们可以访问这个方便的方法，因为`LiveDrawingView`是一个`SurfaceView`：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will need to do more preparation in the `draw` method before we can use our
    `Paint` and `Canvas` classes as we have done before. We will see exactly what
    very soon. Notice the comments indicating where we will eventually get around
    to initializing the particle systems as well as two control buttons.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们像以前一样使用`Paint`和`Canvas`类之前，我们需要在`draw`方法中做更多的准备工作。我们很快就会看到具体是什么。请注意注释，指示我们最终将初始化粒子系统以及两个控制按钮的位置。
- en: Let's get ready to draw.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备好开始绘制。
- en: Coding the draw method
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写`draw`方法
- en: 'Add the `draw` method shown next immediately after the constructor method.
    There will be a couple of errors in the code. We will deal with them, then we
    will go into detail about how the `draw` method will work in relation to the `SurfaceView`
    class because there are some completely alien-looking lines of code in there as
    well as some familiar ones. This is the code to add:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造方法之后立即添加下面显示的`draw`方法。代码中会有一些错误。我们将处理它们，然后我们将详细介绍`draw`方法在`SurfaceView`类中的工作原理，因为其中有一些看起来完全陌生的代码，以及一些熟悉的代码。这是要添加的代码：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have two errors. One is that the `Color` class needs importing. You can
    fix this in the usual way or add the next line of code manually. Whichever method
    you choose, the following extra line needs to be added to the code at the top
    of the file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个错误。一个是`Color`类需要导入。您可以按照通常的方式修复这个问题，或者手动添加下一行代码。无论您选择哪种方法，以下额外的行需要添加到文件顶部的代码中：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let's deal with the other error.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们处理另一个错误。
- en: Adding the printDebuggingText method
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加`printDebuggingText`方法
- en: The second error is the call to `printDebuggingText`. The method doesn't exist
    yet. Let's add that now.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个错误是调用`printDebuggingText`。这个方法还不存在。让我们现在添加它。
- en: 'Add the code after the `draw` method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在`draw`方法之后添加以下代码：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The previous code uses the local variable `debugSize` to hold a value that is
    half that of the member variable `mFontSize`. This means that as `mFontSize` (which
    is used for the HUD) is initialized dynamically based on the screen resolution,
    `debugSize` will always be half that. The `debugSize` variable is then used to
    set the size of the font before we start drawing the text. The `debugStart` variable
    is just a guess at a good position vertically to start printing the debugging
    text.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码使用局部变量`debugSize`来保存成员变量`mFontSize`的一半。这意味着`mFontSize`（用于HUD）是根据屏幕分辨率动态初始化的，`debugSize`始终是它的一半。然后在开始绘制文本之前，使用`debugSize`变量设置字体的大小。`debugStart`变量只是一个垂直开始打印调试文本的好位置的猜测。
- en: These two values are then used to position a line of text on the screen that
    shows the current frames per second. As this method is called from `draw`, which
    in turn will be called from the game loop, this line of text will be constantly
    refreshed up to 60 times per second.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用这两个值来定位屏幕上显示当前每秒帧数的一行文本。由于这个方法是从`draw`中调用的，而`draw`又将从游戏循环中调用，所以这行文本将每秒刷新60次。
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible that on very high- or very low-resolution screens, you might
    need to experiment with the text size to find something more appropriate for your
    screen.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常高或非常低分辨率的屏幕上，您可能需要尝试不同的文本大小，以找到更适合您屏幕的大小。
- en: Let's explore those new lines of code in the `draw` method and exactly how we
    can use `SurfaceView`, from which our `LiveDrawingView` class is derived, to handle
    all our drawing requirements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索`draw`方法中的这些新代码，以及我们如何可以使用`SurfaceView`来处理所有的绘图需求，`LiveDrawingView`类是从`SurfaceView`派生出来的。
- en: Understanding the draw method and the SurfaceView class
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解`draw`方法和`SurfaceView`类
- en: 'Starting in the middle of the method and working outwards for a change, we
    have a few familiar things such as the calls to the `drawColor`, `setTextSize`,
    and `drawText` methods. We can also see the comment that indicates where we will
    eventually add code to draw the particle systems and the HUD:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从方法的中间开始，逐渐向外工作，我们有一些熟悉的东西，比如调用`drawColor`、`setTextSize`和`drawText`方法。我们还可以看到注释，指示我们最终将添加代码来绘制粒子系统和HUD：
- en: The `drawColor` code clears the screen with a solid color.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drawColor`代码用纯色清除屏幕。'
- en: The `setTextSize` method sets the size of the text for drawing the HUD.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTextSize`方法设置了绘制HUD的文本大小。'
- en: We will code drawing the HUD once we have explored particle systems a little
    more. We will let the player know how many particles and systems their drawing
    comprises.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们更深入地探索了粒子系统，我们将编写绘制HUD的代码。我们将让玩家知道他们的绘图包括多少个粒子和系统。
- en: 'What is totally new, however, is the code at the very start of the `draw` method.
    Here it is again:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，完全新的是`draw`方法的开头的代码。这里是它：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `if` statement contains a call to `getSurface` and chains it with a call
    to `isValid`. If this line returns `true`, it confirms that the area of memory
    that we want to manipulate to represent our frame of drawing is available, and
    the code continues inside the `if` statement.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句包含对`getSurface`的调用，并将其与`isValid`的调用链接在一起。如果这行返回`true`，则确认我们要操作的内存区域以表示我们的绘图帧是可用的，代码将继续在`if`语句内部执行。'
- en: What goes on inside those methods (especially the first) is quite complex. They
    are necessary because all our drawing and other processing (such as moving the
    objects) will take place asynchronously with the code that detects the user input
    and listens to the operating system for messages. This wasn't an issue in the
    previous project because our code just drew a single frame and then sat there
    waiting.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法内部发生了什么（特别是第一个方法）是非常复杂的。它们是必需的，因为我们所有的绘制和其他处理（比如移动对象）都将与检测用户输入的代码和监听操作系统的消息异步进行。这在之前的项目中并不是问题，因为我们的代码只是绘制了一个帧然后等待。
- en: Now we want to execute the code 60 times a second, we are going to need to confirm
    that we have access to the memory – before we access it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们希望每秒执行60次代码，我们需要确认我们可以访问内存 - 在访问之前。
- en: This raises more questions about how this code runs asynchronously. That will
    be answered when we discuss threads shortly. For now, just know that the line
    of code checks if some other part of our code or Android itself is currently using
    the required portion of memory. If it is free, then the code inside the `if` statement
    executes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了更多关于这段代码如何异步运行的问题。这将在我们不久后讨论线程时得到解答。现在，只需知道这行代码检查我们的代码的某个其他部分或 Android 本身是否正在使用所需的内存部分。如果空闲，那么
    `if` 语句内的代码将执行。
- en: Furthermore, the first line of code to execute inside the `if` statement calls
    the `lockCanvas` method so that if another app or Android tries to access the
    memory while our code is accessing it, it won't be able to. Then we do all our
    drawing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 `if` 语句内执行的第一行代码调用了 `lockCanvas` 方法，以便如果另一个应用程序或 Android 尝试在我们的代码访问内存时访问它，它将无法访问。然后我们进行所有的绘制。
- en: 'Finally, in the `draw` method, there is this next line (plus comments) right
    at the end:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `draw` 方法中，最后有这样一行代码（以及注释）：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `unlockCanvasAndPost` method sends our newly decorated `Canvas` object (`mCanvas`)
    for drawing to the screen and releases the lock so that other areas of code can
    use it again – albeit very briefly before the whole process starts again. This
    process happens in every single frame of animation.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`unlockCanvasAndPost` 方法将我们新装饰的 `Canvas` 对象 (`mCanvas`) 发送到屏幕上进行绘制，并释放锁定，以便代码的其他部分可以再次使用它
    - 尽管在整个过程重新开始之前只是非常短暂的时间。这个过程在每一帧动画中都会发生。'
- en: We now understand the code in the `draw` method; however, we still don't have
    the mechanism that calls the `draw` method over and over. In fact, we don't even
    call the `draw` method once. We need to talk about game loops and threads.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在理解了 `draw` 方法中的代码；然而，我们仍然没有调用 `draw` 方法的机制。事实上，我们甚至没有调用一次 `draw` 方法。我们需要讨论游戏循环和线程。
- en: The game loop
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环
- en: What is a game loop anyway? Almost every live drawing/graphics game has a game
    loop. Even games you might suspect do not, such as turn-based games, still need
    to synchronize player input with drawing and AI while following the rules of the
    underlying operating system.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环到底是什么？几乎每个实时绘图/图形游戏都有一个游戏循环。即使你可能怀疑没有游戏循环的游戏，比如回合制游戏，仍然需要将玩家输入与绘图和人工智能同步，同时遵循底层操作系统的规则。
- en: 'There is a constant need to update the objects in the app, perhaps by moving
    them, drawing everything in its current position at the same time as responding
    to user input. A diagram might help:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 需要不断更新应用中的对象，也许是通过移动它们，在同时响应用户输入的同时绘制所有对象的当前位置。一个图表可能会有所帮助：
- en: '![Figure 21.2 – Game loop'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图21.2 – 游戏循环'
- en: '](img/Figure_21.2_B16773.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_21.2_B16773.jpg)'
- en: Figure 21.2 – Game loop
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.2 – 游戏循环
- en: 'Our game loop comprises three main phases:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏循环包括三个主要阶段：
- en: Update all game/drawing objects by moving them, detecting collisions, and processing
    AI such as the particle movements and state changes.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过移动它们、检测碰撞和处理粒子移动和状态变化等方式更新所有游戏/绘图对象。
- en: Based on the just-updated data, draw the frame of animation in its latest state.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于刚刚更新的数据，绘制动画帧的最新状态。
- en: Respond to screen touches from the user.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应用户的屏幕触摸。
- en: We already have a `draw` method for handling that part of the loop. This suggests
    that we will have a method to do all the updating as well. We will soon code the
    outline of an `update` method. In addition, we know that we can respond to screen
    touches although we will need to adapt slightly from all the previous projects
    because we are not working inside an Activity or using conventional UI widgets
    in a layout anymore.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个用于处理循环的 `draw` 方法。这表明我们也将有一个方法来进行所有的更新。我们很快将编写一个 `update` 方法的大纲。此外，我们知道我们可以响应屏幕触摸，尽管我们需要稍微调整之前所有项目的代码，因为我们不再在
    Activity 中工作，也不再在布局中使用传统的 UI 小部件。
- en: There is a further issue in that (as I briefly mentioned) all the updating and
    drawing happens asynchronously to the detection of screen touches and listening
    to the operating system.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个问题，就是（我简要提到过的）所有的更新和绘制都是异步进行的，与屏幕触摸的检测和操作系统的监听是分开的。
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Just to be clear, asynchronous means that it does not occur at the same time.
    Our game code will work by sharing execution time with Android and the user interface.
    The CPU will very quickly switch back and forth between our code and Android/user
    input.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了明确，异步意味着它不会同时发生。我们的游戏代码将通过与 Android 和用户界面共享执行时间来运行。CPU 将在我们的代码和 Android/用户输入之间非常快速地来回切换。
- en: But how exactly will these three phases be looped through? How will we code
    this asynchronous system within which the `update` and `draw` methods can be called
    and how will we make the loop run at the correct speed (frame rate)?
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这三个阶段究竟如何循环执行？我们将如何编写这个异步系统，其中可以调用 `update` 和 `draw` 方法，以及如何使循环以正确的速度（帧率）运行？
- en: As we can probably guess, writing an efficient game loop is not as simple as
    a `while` loop.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可能猜到的那样，编写一个高效的游戏循环并不像一个 `while` 循环那样简单。
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Our game loop will, however, also contain a `while` loop.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的游戏循环也将包含一个 `while` 循环。
- en: We need to consider timing, starting and stopping the loop, as well as not causing
    the OS to become unresponsive because we are monopolizing the entire CPU within
    our loop.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑时机，开始和结束循环，以及不要让操作系统变得无响应，因为我们正在垄断整个CPU在我们的循环中。
- en: But when and how do we call our `draw` method? How do we measure and keep track
    of the frame rate? With these things in mind, our finished game loop can probably
    be better represented by this next diagram. Notice the introduction of the concept
    of **threads**.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们何时以及如何调用我们的`draw`方法？我们如何测量和跟踪帧速率？考虑到这些问题，我们完成的游戏循环可能可以更好地用下一个图表表示。注意引入了**线程**的概念。
- en: '![Figure 21.3 – Finished game loop'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![图21.3 - 完成的游戏循环'
- en: '](img/Figure_21.3_B16773.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_21.3_B16773.jpg)'
- en: Figure 21.3 – Finished game loop
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.3 - 完成的游戏循环
- en: Now we know what we want to achieve, let's learn about threads.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们想要实现什么，让我们学习一下线程。
- en: Threads
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程
- en: So, what is a thread? You can think of threads in programming in the same way
    you do threads in a story. In one thread of a story, we might have the primary
    character battling the enemy on the frontline while in another thread the soldier's
    family is getting by, day to day. Of course, a story doesn't have to have just
    two threads; we could introduce a third thread. Perhaps the story also tells of
    the politicians and military commanders making decisions. And these decisions
    then subtly, or not so subtly, affect what happens in the other threads.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是线程？在编程中，你可以把线程想象成故事中的线索一样。在故事的一个线索中，我们可能有主要角色在前线与敌人作战，而在另一个线索中，士兵的家人正在日复一日地生活。当然，一个故事不一定只有两个线索；我们可以引入第三个线索。也许故事还讲述了政治家和军事指挥官做出决策。这些决策会微妙地或者不那么微妙地影响其他线索中发生的事情。
- en: 'Programming threads are just like this. We create parts/threads in our program
    that control different aspects for us. In Android, threads are especially useful
    when we need to ensure that a task does not interfere with the main (UI) thread
    of the app or if we have a background task that takes a long time to complete
    and must not interrupt the main thread of execution. We introduce threads to represent
    these different aspects because of the following reasons:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 编程线程就像这样。我们在程序中创建部分/线程来控制不同的方面。在Android中，当我们需要确保一个任务不会干扰应用程序的主（UI）线程，或者当我们有一个需要很长时间才能完成并且不能中断主线程执行的后台任务时，线程尤其有用。我们引入线程来代表这些不同的方面，因为有以下原因：
- en: They make sense from an organizational point of view.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从组织的角度来看，它们是有意义的。
- en: They are a proven way of structuring a program that works.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是一种被证明有效的程序结构方式。
- en: The nature of the system we are working on forces us to use them.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们所工作的系统的性质迫使我们使用它们。
- en: In Android, we use threads for all three reasons simultaneously. It makes sense,
    it works, and we must because the design of the Android system requires it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，我们同时出于这三个原因使用线程。这是有意义的，它有效，而且我们必须这样做，因为Android系统的设计要求如此。
- en: Often, we use threads without knowing about it. This happens because we use
    classes that use threads on our behalf. All the animations we coded in [*Chapter
    19*](B16773_19_ePub_RK.xhtml#_idTextAnchor331), *Animations and Interpolations*,
    were all running in threads. Another such example in Android is the `SoundPool`
    class, which loads sound in a thread. We will see or rather hear `SoundPool` in
    action in [*Chapter 23*](B16773_23_ePub_RK.xhtml#_idTextAnchor400)*, Supporting
    Different Versions of Android, Sound Effects, and Spinner Widget*, and we saw
    and will see again that our code doesn't have to handle the aspects of threads
    we are about to learn about because it is all handled internally by the class.
    In this project, however, we need to get a bit more involved.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在不知情的情况下使用线程。这是因为我们使用的类会代表我们使用线程。我们在[*第19章*](B16773_19_ePub_RK.xhtml#_idTextAnchor331)中编写的所有动画，*动画和插值*，都在线程中运行。在Android中的另一个例子是`SoundPool`类，它在一个线程中加载声音。我们将在[*第23章*](B16773_23_ePub_RK.xhtml#_idTextAnchor400)*，支持不同版本的Android，声音效果和Spinner小部件*中看到或听到`SoundPool`的实际效果，我们已经看到并将再次看到，我们的代码不必处理我们即将学习的线程方面，因为这一切都由类内部处理。然而，在这个项目中，我们需要更深入地参与其中。
- en: In real-time systems, think about a thread that is receiving the player's button
    taps for moving left and right at the same time as listening for messages from
    the OS such as calling `onCreate` (and other methods we will see soon) as one
    thread, and another thread that draws all the graphics and calculates all the
    movement.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在实时系统中，考虑一个线程同时接收玩家的按钮点击以左右移动，同时监听来自操作系统的消息，比如调用`onCreate`（以及我们即将看到的其他方法）作为一个线程，另一个线程负责绘制所有图形并计算所有移动。
- en: Problems with threads
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程问题
- en: Programs with multiple threads can have problems. Like the threads of a story
    in which if proper synchronization does not occur, things can go wrong. What if
    our soldier went into battle before the battle or the war even existed? Weird.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 具有多个线程的程序可能会出现问题。就像故事中的线索一样，如果没有适当的同步，事情可能会出错。如果我们的士兵在战斗甚至战争开始之前就进入了战斗，那会怎么样？很奇怪。
- en: Consider that we have a variable `int x` that represents a key piece of data
    that, say, three threads of our program use. What happens if one thread gets slightly
    ahead of itself and makes the data "wrong" for the other two. This problem is
    the problem of **correctness** caused by multiple threads racing to completion
    oblivious—because after all, they are just dumb code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个变量`int x`，它代表程序中三个线程使用的关键数据。如果一个线程稍微超前于自己，并使数据对其他两个线程来说是“错误”的，会发生什么。这个问题是由多个线程竞争完成而引起的**正确性**问题，因为它们毕竟只是愚蠢的代码。
- en: The problem of correctness can be solved by the close oversight of the threads
    and locking. **Locking** means temporarily preventing execution in one thread
    to be sure things are working in a synchronized manner – kind of like freezing
    a soldier from boarding a ship to war until the ship has docked and the gangplank
    has been lowered, avoiding an embarrassing splash.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正确性问题可以通过对线程和锁定的密切监督来解决。**锁定**意味着暂时阻止一个线程的执行，以确保事情以同步的方式工作 - 就像冻结士兵登上战舰直到船靠岸并放下跳板，避免尴尬的溅水。
- en: The other problem with programs with multiple threads is the problem of `int
    x`, but that moment never comes, and eventually, the entire program grinds to
    a halt.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程程序的另一个问题是`int x`的问题，但那一刻从未到来，最终整个程序都停滞了。
- en: You might have noticed that it was the solution to the first problem (correctness)
    that is the cause of the second problem (deadlock).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，第一个问题（正确性）的解决方案是第二个问题（死锁）的原因。
- en: Fortunately, the problem has been solved for us. Just as we use the `Activity`
    class and override `onCreate` to know when we need to create our app, we can also
    use other classes to create and manage our threads. Just as with `Activity`, we
    only need to know how to use them – not exactly how they work.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这个问题已经为我们解决了。就像我们使用`Activity`类并重写`onCreate`来知道何时需要创建我们的应用程序一样，我们也可以使用其他类来创建和管理我们的线程。就像`Activity`一样，我们只需要知道如何使用它们
    - 而不需要知道它们的工作原理。
- en: 'So why did I tell you all this stuff about threads when you didn''t need to
    know, you rightly ask. Simply because we will be writing code that looks different
    and is structured in an unfamiliar manner. If we can do the following, then we
    will have no sweat writing our Java code to create and work within our threads:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当你不需要知道时，我为什么告诉你所有这些关于线程的东西，你是正确的。只是因为我们将编写看起来不同并且以不熟悉的方式结构化的代码。如果我们能做到以下几点，那么我们将毫不费力地编写我们的Java代码来创建和在我们的线程中工作：
- en: Understand the general concept of a thread, which is just the same thing as
    a story thread, which happens almost simultaneously
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解线程的一般概念，这只是一个故事线程的同义词，几乎同时发生
- en: Learn the few rules of using a thread
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用线程的几个规则
- en: There are a few different Android classes that handle threads. Different thread
    classes work best in different situations.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些不同的Android类处理线程。不同的线程类在不同情况下效果最佳。
- en: All we need to remember is that we will be writing parts of our program that
    run at *almost* the same time as each other.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住的是，我们将编写几乎同时运行的程序的部分。
- en: Note
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: What do you mean almost? What is happening is that the CPU switches between
    threads in turn/asynchronous. However, this happens so fast that we will not be
    able to perceive anything but simultaneity/synchronous. Of course, in the story
    thread analogy, people do act entirely synchronously.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你说的“几乎”是什么意思？发生的情况是CPU在线程之间切换，但这几乎是同时/异步发生的。然而，这发生得如此之快，以至于我们除了同时性/同步性之外无法感知任何东西。当然，在故事线程的类比中，人们确实是完全同步行动的。
- en: 'Let''s take a glimpse at what our thread code will look like. Don''t add any
    code to the project just yet. We can declare an object of type `Thread` like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们的线程代码将是什么样子。现在先不要向项目添加任何代码。我们可以这样声明一个`Thread`类型的对象：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Initialize and start it like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化并启动它：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'There is one more conundrum to this thread stuff. Look at the constructor that
    initializes the thread. Here is the line of code again for your convenience:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线程的问题还有一个谜团。看看初始化线程的构造函数。这是代码的一行，以方便您再次查看：
- en: '[PRE29]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Look at the highlighted argument that is passed to the constructor. We pass
    in `this`. Remember that the code is going inside the `LiveDrawingView` class,
    not `LiveDrawingActivity`. We can, therefore, surmise that `this` is a reference
    to a `LiveDrawingView` class (which extends `SurfaceView`).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下传递给构造函数的突出参数。我们传入`this`。请记住，代码将进入`LiveDrawingView`类，而不是`LiveDrawingActivity`。因此，我们可以推断`this`是对`LiveDrawingView`类的引用（它扩展了`SurfaceView`）。
- en: It seems very unlikely that when the nerds at Android HQ wrote the `Thread`
    class they would have been aware that one day we would be writing our `LiveDrawingView`
    class. So how can this work?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android总部的书呆子编写`Thread`类时，他们似乎很难想象有一天我们会编写我们的`LiveDrawingView`类。那么这怎么可能呢？
- en: The `Thread` class needs an entirely different type to be passed into its constructor.
    The `Thread` constructor needs an object of type `Runnable`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread`类需要完全不同的类型传递到它的构造函数中。`Thread`构造函数需要一个`Runnable`类型的对象。'
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can confirm this fact by looking at the `Thread` class on the Android developer''s
    website here: [https://developer.android.com/reference/java/lang/Thread.html#Thread(java.lang.Runnable](https://developer.android.com/reference/java/lang/Thread.html#Thread(java.lang.Runnable)).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看Android开发者网站上的`Thread`类来确认这一事实：[https://developer.android.com/reference/java/lang/Thread.html#Thread(java.lang.Runnable](https://developer.android.com/reference/java/lang/Thread.html#Thread(java.lang.Runnable))。
- en: 'Do you remember we talked about interfaces in [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201),
    *More Object-Oriented Programming*? As a reminder, we can implement an interface
    using the `implements` keyword and the interface name after the class declaration,
    like in this code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您还记得我们在[*第11章*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)中谈到的接口吗，*更多面向对象的编程*？作为提醒，我们可以使用`implements`关键字和类声明后面的接口名称来实现接口，就像在这段代码中一样：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We must then implement the abstract methods of the interface. `Runnable` has
    just one. It is the `run` method.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们必须实现接口的抽象方法。`Runnable`只有一个方法。就是`run`方法。
- en: Note
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can confirm this last fact by looking at the `Runnable` interface on the
    Android developer''s website here: [https://developer.android.com/reference/java/lang/Runnable.html](https://developer.android.com/reference/java/lang/Runnable.html).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看Android开发者网站上的`Runnable`接口来确认这一事实：[https://developer.android.com/reference/java/lang/Runnable.html](https://developer.android.com/reference/java/lang/Runnable.html)。
- en: 'We can then use the Java `@override` keyword to change what happens when the
    operating system allows our thread object to run its code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用Java的`@override`关键字来改变操作系统允许我们的线程对象运行其代码时发生的情况：
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Within the overridden `run` method, we will call two methods: one that we have
    started already, `draw`, and the other is `update`. The `update` method is where
    all our calculations and artificial intelligence will go. The code will look a
    bit like this – don''t add it yet:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写的`run`方法中，我们将调用两个方法：一个是我们已经启动的`draw`，另一个是`update`。`update`方法是我们所有的计算和人工智能的地方。代码看起来会有点像这样——暂时不要添加：
- en: '[PRE32]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When appropriate, we can also stop our thread like this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的时候，我们也可以像这样停止我们的线程：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now everything that is in the `run` method is executing in a separate thread,
    leaving the default or UI thread to listen for touches and system events. We will
    see how the two threads communicate with each other in the drawing project shortly.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`run`方法中的所有内容都在一个单独的线程中执行，使默认或UI线程监听触摸和系统事件。我们很快将看到这两个线程如何相互通信在绘图项目中。
- en: Note that exactly where all these parts of the code will go into our app has
    not been explained because it is so much easier to show you in the real project.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有这些代码的确切位置将进入我们的应用程序尚未解释，因为在真实项目中向您展示会更容易得多。
- en: Implementing the game loop with a thread
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程实现游戏循环
- en: Now we have learned about the game loop and threads, we can put it all together
    to implement our game loop in the Living Drawing project.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了游戏循环和线程，我们可以把它们全部放在一起，在Living Drawing项目中实现我们的游戏循环。
- en: We will add the entire code for the game loop, including writing two methods
    in the `LiveDrawingActivity` class to start and stop the thread, which will control
    the loop.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加整个游戏循环的代码，包括在`LiveDrawingActivity`类中编写两个方法来启动和停止控制循环的线程。
- en: Note
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Can you guess how the Activity based class will start and stop the thread in
    the `LiveDrawingView` class?
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到基于Activity的类将如何在`LiveDrawingView`类中启动和停止线程吗？
- en: Implementing Runnable and providing the run method
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现Runnable并提供run方法
- en: 'Update the class declaration by implementing `Runnable`, just like we discussed
    we would need to and as shown in this next highlighted code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`Runnable`来更新类声明，就像我们之前讨论过的那样，并且如下面的下一个突出显示的代码所示：
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that we have a new error in the code. Hover the mouse pointer over the
    word `Runnable` and you will see a message informing you that we need to implement
    the `run` method, again, just as we discussed during the discussion on interfaces.
    Add the empty `run` method, including the `@override` label as shown in a moment.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们的代码中出现了一个新错误。将鼠标指针悬停在`Runnable`一词上，您将看到一条消息，告诉您我们需要再次实现`run`方法，就像我们在讨论接口时讨论过的那样。按照一会儿的示例添加空的`run`方法，包括`@override`标签。
- en: 'It doesn''t matter where you add it if it is within the `LiveDrawingView` class''s
    curly braces and not inside another method. I added mine right after the constructor
    method because it is near the top and easy to get to. We will be editing this
    quite a bit in this chapter. Add the empty `run` method as shown next:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它在`LiveDrawingView`类的大括号内而不是在另一个方法内，那么添加的位置并不重要。我把我的添加在构造方法之后，因为它靠近顶部，很容易找到。在本章中我们将对其进行相当多的编辑。按照下面的示例添加空的`run`方法：
- en: '[PRE35]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The error is gone and now we can declare and initialize a `Thread` object.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 错误已经消失，现在我们可以声明和初始化一个`Thread`对象。
- en: Coding the thread
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写线程
- en: 'Declare some more member variables and instances, as shown next, underneath
    all our other members in the `LiveDrawingView` class:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LiveDrawingView`类中的所有其他成员下面，声明一些更多的成员变量和实例，如下所示：
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now we can start and stop the thread. Have a think about where we might do this.
    Remember that the app needs to respond to the operating system starting and stopping
    the app.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启动和停止线程。想一想我们可能在哪里做到这一点。记住应用程序需要响应操作系统启动和停止应用程序。
- en: Starting and stopping the thread
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动和停止线程
- en: 'Now we need to start and stop the thread. We have seen the code we need but
    when and where should we do it? Let''s write two methods, one to start and one
    to stop, and then we can consider further when and from where to call these methods.
    Add these two methods inside the `LiveDrawingView` class. If their names sound
    familiar, it is not by chance:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要启动和停止线程。我们已经看到了我们需要的代码，但是什么时候和在哪里应该这样做呢？让我们编写两个方法，一个用于启动，一个用于停止，然后我们可以进一步考虑何时以及从何处调用这些方法。在`LiveDrawingView`类中添加这两个方法。如果它们的名称听起来很熟悉，那并非偶然：
- en: '[PRE37]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: What is happening is slightly given away by the comments – did you read the
    comments? We now have a `pause` and `resume` method, which stop and start the
    `Thread` object using the same code we discussed previously.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正在发生的事情在评论中稍微透露了一些——你读了评论吗？我们现在有了`pause`和`resume`方法，它们使用我们之前讨论过的相同代码来停止和启动`Thread`对象。
- en: Notice the new methods are `public` and therefore accessible from outside the
    class to any other class that has an instance of `LiveDrawingView`. Remember that
    `LiveDrawingActivity` has the fully declared and initialized instance of `LiveDrawingView`?
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新方法是`public`的，因此可以从类外部访问到任何具有`LiveDrawingView`实例的其他类。记住`LiveDrawingActivity`有完全声明和初始化的`LiveDrawingView`实例吗？
- en: Let's use the Android Activity lifecycle to call these two new methods.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Android Activity生命周期来调用这两个新方法。
- en: Using the Activity lifecycle to start and stop the thread
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Activity生命周期来启动和停止线程
- en: 'Update the overridden `onResume` and `onPause` methods in `LiveDrawingActivity`
    as shown next with the highlighted lines of code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`LiveDrawingActivity`中重写的`onResume`和`onPause`方法，如下所示，带有突出显示的代码行：
- en: '[PRE38]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now our thread will be started and stopped when the operating system is resuming
    and pausing our app. Remember that `onResume` is called after `onCreate` the first
    time an app is created, not just after resuming from a pause. The code inside
    `onResume` and `onPause` uses the `mLiveDrawingView` object to call its `resume`
    and `pause` methods, which in turn has the code to start and stop the thread.
    This code then triggers the thread's `run` method to execute. It is in this `run`
    method (in `LiveDrawingView`) that we will code our game loop. Let's do that now.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的线程将在操作系统恢复和暂停我们的应用程序时启动和停止。请记住，`onResume`在应用程序创建后第一次调用`onCreate`之后被调用，而不仅仅是在从暂停中恢复后调用。`onResume`和`onPause`中的代码使用`mLiveDrawingView`对象来调用其`resume`和`pause`方法，这反过来又有代码来启动和停止线程。然后，这段代码触发线程的`run`方法执行。就是在这个`run`方法（在`LiveDrawingView`中）中，我们将编写我们的游戏循环。现在让我们来做这个。
- en: Coding the run method
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写run方法
- en: 'Although our thread is set up and ready to go, nothing happens because the
    `run` method is empty. Code the `run` method as shown next:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的线程已经设置好并准备就绪，但因为`run`方法是空的，所以什么也不会发生。按照下面所示的方式编写`run`方法：
- en: '[PRE39]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice there are two errors in Android Studio. This is because we have not
    written the `update` method yet. Let''s quickly add an empty method (with a comment)
    for it. I added mine after the `run` method:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Android Studio中有两个错误。这是因为我们还没有编写`update`方法。让我们快速添加一个空方法（带有注释）。我在`run`方法之后添加了我的：
- en: '[PRE40]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now let's discuss in detail how the code in the `run` method achieves the aims
    of our game loop by looking at the whole thing a bit at a time.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们详细讨论`run`方法中的代码如何通过逐步查看整个内容来实现我们游戏循环的目标。
- en: 'This first part initiates a `while` loop with the condition `mDrawing` and
    it wraps the rest of the code inside `run` so the thread will need to be started
    (for `run` to be called) and `mDrawing` will need to be true for the `while` loop
    to execute:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一部分初始化了一个`while`循环，条件是`mDrawing`，它包裹在`run`中的其余代码中，所以线程需要被启动（才能调用`run`），并且`mDrawing`需要为`true`才能执行`while`循环：
- en: '[PRE41]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The first line of code inside the `while` loop declares and initializes a local
    variable `frameStartTime` with whatever the current time is. The static method
    `currentTimeMillis` of the `System` class returns this value. If later, we want
    to measure how long a frame has taken, then we need to know what time it started:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环内的第一行代码声明并初始化一个名为`frameStartTime`的局部变量，其值为当前时间。`System`类的静态方法`currentTimeMillis`返回这个值。如果以后我们想要测量一帧花费了多长时间，那么我们需要知道它是什么时候开始的：'
- en: '[PRE42]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, still inside the `while` loop, we check whether the app is paused and
    only if the app is not paused does this next code get executed. If the logic allows
    execution inside this block, then `update` is called:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`while`循环中，我们检查应用程序是否暂停，只有当应用程序没有暂停时，才会执行下面的代码。如果逻辑允许在这个块中执行，那么就会调用`update`：
- en: '[PRE43]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Outside of the previous `if` statement, the `draw` method is called to draw
    all the objects in the just-updated positions. At this point, another local variable
    is declared and initialized with the length of time it took to complete the entire
    frame (updating and drawing). This value is calculated by getting the current
    time, once again with `currentTimeMillis`, and subtracting `frameStartTime` from
    it:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`if`语句之外，调用`draw`方法来绘制所有对象的刚更新的位置。此时，另一个局部变量被声明并初始化为完成整个帧（更新和绘制）所花费的时间长度。这个值是通过再次使用`currentTimeMillis`获取当前时间，并从中减去`frameStartTime`来计算的：
- en: '[PRE44]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The next `if` statement detects whether `timeThisFrame` is greater than zero.
    It is possible for the value to be zero if the thread runs before objects are
    initialized. If you look at the code inside the `if` statement, it calculates
    the frame rate by dividing the elapsed time by `MILLIS_IN_SECOND`. If you divide
    by zero, the app will crash, which is why we do the check.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个`if`语句检测`timeThisFrame`是否大于零。如果线程在对象初始化之前运行，该值可能为零。如果你看一下`if`语句中的代码，它通过将经过的时间除以`MILLIS_IN_SECOND`来计算帧速率。如果除以零，应用程序将崩溃，这就是我们进行检查的原因。
- en: 'Once `mFPS` gets the value assigned to it, we can use it in the next frame
    to pass to the `update` method of all the particles, which we will code in the
    next chapter. They will use the value to make sure they move by precisely the
    correct amount based on their target speed and the length of time the frame has
    taken:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`mFPS`得到分配给它的值，我们就可以在下一帧中使用它传递给所有粒子的`update`方法，我们将在下一章中编写。它们将使用这个值来确保它们根据其目标速度和帧所花费的时间长度精确地移动：
- en: '[PRE45]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The result of the calculation that initializes `mFPS` in each frame is that
    `mFPS` will hold a fraction of 1\. Therefore, when we use this value inside each
    of the particle objects, we will be able to use this calculation:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧中初始化`mFPS`的计算结果是，`mFPS`将保存1的分数。因此，当我们在每个粒子对象中使用这个值时，我们将能够使用这个计算：
- en: '[PRE46]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In order to determine the elapsed time on any given frame, as the frame rate
    fluctuates, `mFPS` will hold a different value and supply the game objects with
    the appropriate number to calculate each move.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定任何给定帧的经过时间，由于帧速率波动，`mFPS`将保存不同的值，并为游戏对象提供适当的数字来计算每次移动。
- en: Running the app
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Click the play button in Android Studio and the hard work and theory of the
    last two chapters will spring to life. Here are the beginnings of our app running
    on a tablet emulator:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中点击播放按钮，最后两章的辛勤工作和理论将会生动地展现出来。这是我们的应用程序在平板模拟器上运行的开端：
- en: '![Figure 21.4 – Running the app'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图21.4 - 运行应用程序'
- en: '](img/Figure_21.4_B16773.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_21.4_B16773.jpg)'
- en: Figure 21.4 – Running the app
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.4 - 运行应用程序
- en: You can see we now have a real-time system created with our game loop and a
    thread. If you run this on a real device, you will easily achieve 60 frames per
    second at this stage.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们现在已经创建了一个实时系统，具有我们的游戏循环和一个线程。如果你在真实设备上运行这个应用程序，你将很容易地在这个阶段实现每秒60帧。
- en: Summary
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This was probably the most technical chapter so far. Threads, game loops, timing,
    using interfaces along with the Activity lifecycle, and so on… it's an awfully
    long list of topics to cram in.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是迄今为止最技术性的一章。线程、游戏循环、计时、使用接口以及Activity生命周期等等……这是一个非常长的主题清单。
- en: If the exact interrelationships between these things are not entirely clear,
    it is not a problem. All you need to know is that when the user starts and stops
    the app, the `LiveDrawingActivity` class will handle starting and stopping the
    thread by calling the `LiveDrawingView` class's `pause` and `resume` methods.
    It achieves this via the overridden `onPause` and `onResume` methods, which are
    called by the OS.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些事物之间的确切相互关系并不完全清楚，那也没关系。你只需要知道，当用户启动和停止应用程序时，`LiveDrawingActivity`类将通过调用`LiveDrawingView`类的`pause`和`resume`方法来处理启动和停止线程。它通过重写的`onPause`和`onResume`方法来实现，这些方法由操作系统调用。
- en: Once the thread is running the code inside, the `run` method executes alongside
    the UI thread that is listening for user input. As we call the `update` and `draw`
    methods from the `run` method at the same time as keeping track of how long each
    frame is taking, our app is ready to rock and roll.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦线程运行起来，`run`方法内的代码将与监听用户输入的UI线程一起执行。当我们同时从`run`方法调用`update`和`draw`方法，并跟踪每帧所需的时间时，我们的应用程序就准备好了。
- en: We just need to allow the user to add some particles to their artwork, which
    we can then update in each call to the `update` method and draw in each call to
    the `draw` method.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要允许用户向他们的艺术品添加一些粒子，然后我们可以在每次调用`update`方法时更新它们，并在每次调用`draw`方法时绘制它们。
- en: In the next chapter, we will be coding, updating, and drawing both the `Particle`
    and the `ParticleSytem` classes. In addition, we will be writing code for the
    user to interact (do some drawing) with the app.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将编写、更新和绘制`Particle`和`ParticleSystem`类。此外，我们将编写用户与应用程序进行交互（进行一些绘图）的代码。
