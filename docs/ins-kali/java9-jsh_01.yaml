- en: Chapter 1. JShell – A Read-Evaluate-Print-Loop for Java 9
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。JShell-用于Java 9的读取-求值-打印-循环
- en: 'In this chapter, we will start our journey toward object-oriented programming
    with Java 9\. You will learn how to launch and work with a new utility introduced
    with Java 9 that will allow us to easily run Java 9 code snippets and print their
    results: JShell. This utility will make it easy for you to learn object-oriented
    programming. We will do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用Java 9进行面向对象编程的旅程。您将学习如何启动并使用Java 9中引入的新实用程序：JShell，它将使您能够轻松运行Java
    9代码片段并打印其结果。我们将执行以下操作：
- en: Get ready for our journey toward **OOP** (**Object-Oriented Programming**) with
    Java 9
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备好使用Java 9进行**面向对象编程**的旅程
- en: Install the required software on Windows, macOS, or Linux
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows，macOS或Linux上安装所需的软件
- en: Understand the benefits of working with a **REPL** (**Read-Evaluate-Print-Loop**)
    utility
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解使用**REPL**（**读取-求值-打印-循环**）实用程序的好处
- en: Check default imports and use auto-complete features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查默认导入并使用自动完成功能
- en: Run Java 9 code in JShell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JShell中运行Java 9代码
- en: Evaluate expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估表达式
- en: Work with variables, methods, and sources
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量，方法和源代码
- en: Edit the source code in our favorite external code editor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们喜欢的外部代码编辑器中编辑源代码
- en: Load source code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载源代码
- en: Getting ready for our journey toward OOP with Java 9
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好使用Java 9进行面向对象编程的旅程
- en: In this book, you will learn to take advantage of all the object-oriented features
    included in the Java programming language version 9, known as Java 9\. Some of
    the examples might be compatible with previous Java versions, such as Java 8,
    Java 7, and Java 6, but it is essential to use Java 9 or later because this version
    is not backwards compatible. We won't write code that is backwards compatible
    with previous Java versions because our main goal is to work with Java 9 or later
    and to use its syntax and all of its new features.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，您将学习如何利用Java编程语言第9版中包含的所有面向对象的特性，即Java 9。一些示例可能与以前的Java版本兼容，例如Java 8，Java
    7和Java 6，但是必须使用Java 9或更高版本，因为该版本不向后兼容。我们不会编写向后兼容以前的Java版本的代码，因为我们的主要目标是使用Java
    9或更高版本，并使用其语法和所有新功能。
- en: Most of the time, we won't use any **IDE** (**Integrated Development Environment**),
    and we will take advantage of JShell and many other utilities included in the
    JDK. However, you can use any IDE that provides a Java 9 REPL to work with all
    the examples. You will understand the benefits of working with a REPL in the next
    sections. You will definitely benefit from an IDE in the last chapter where you
    will explore the new modularity features introduced with Java 9.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们不会使用任何**IDE**（**集成开发环境**），而是利用JShell和JDK中包含的许多其他实用程序。但是，您可以使用任何提供Java
    9 REPL的IDE来使用所有示例。您将在接下来的章节中了解使用REPL的好处。在最后一章中，您将了解到使用Java 9引入的新模块化功能时，IDE将给您带来的好处。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You don't need any previous experience with the Java programming language to
    work with the examples in the book and learn how to model and create object-oriented
    code with Java 9\. If you have some experience with C#, C++, Python, Swift, Objective-C,
    Ruby, or JavaScript, you will be able to easily learn Java's syntax and understand
    the examples. Many modern programming languages have been borrowing features from
    Java and vice versa. Therefore, any knowledge of these languages will be extremely
    useful.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 无需具备Java编程语言的先前经验，即可使用本书中的示例并学习如何使用Java 9建模和创建面向对象的代码。如果您具有一些C＃，C ++，Python，Swift，Objective-C，Ruby或JavaScript的经验，您将能够轻松学习Java的语法并理解示例。许多现代编程语言都从Java中借鉴了功能，反之亦然。因此，对这些语言的任何了解都将非常有用。
- en: In this chapter, we will install the required software on Windows, macOS, or
    Linux. We will understand the benefits of working with a REPL, specifically, JShell,
    to learn object-oriented programming. We will learn how to run Java 9 code in
    the JShell and how to load the source code samples in the REPL. Finally, we will
    learn how to run Java code on Windows, macOS, and Linux from the command line
    or terminal.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在Windows，macOS或Linux上安装所需的软件。我们将了解使用REPL，特别是JShell，学习面向对象编程的好处。我们将学习如何在JShell中运行Java
    9代码以及如何在REPL中加载源代码示例。最后，我们将学习如何在Windows，macOS和Linux上从命令行或终端运行Java代码。
- en: Installing the required software on Windows, macOS, or Linux
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows，macOS或Linux上安装所需的软件
- en: We must download and install the latest version of **JDK 9** (**Java Development
    Kit 9**) for our operating system from [https://jdk9.java.net/download/](https://jdk9.java.net/download/).
    We must accept the license agreement for Java to download the software.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须从[https://jdk9.java.net/download/](https://jdk9.java.net/download/)下载并安装适用于我们操作系统的最新版本的**JDK
    9**（**Java开发工具包9**）。我们必须接受Java的许可协议才能下载软件。
- en: 'As happened with previous versions, JDK 9 is available on many different platforms,
    including but not limited to the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的版本一样，JDK 9可用于许多不同的平台，包括但不限于以下平台：
- en: Windows 32-bit
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 32位
- en: Windows 64-bit
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 64位
- en: macOS 64-bit (formerly known as Mac OS X or simply OS X)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS 64位（以前称为Mac OS X或简称OS X）
- en: Linux 32-bit
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 32位
- en: Linux 64-bit
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 64位
- en: Linux on ARM 32-bit
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux on ARM 32位
- en: Linux on ARM 64-bit
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux on ARM 64位
- en: Once we have completed the installation for the appropriate version of JDK 9
    based on our operating system, we can add the `bin` sub-folder of the folder in
    which JDK 9 has been installed to the `PATH` environment variable. This way, we
    would be able to launch the different utilities from any folder in which we are
    located.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装适用于我们操作系统的JDK 9的适当版本后，我们可以将JDK 9安装文件夹的`bin`子文件夹添加到`PATH`环境变量中。这样，我们就可以从我们所在的任何文件夹启动不同的实用程序。
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If we don't add the `bin` sub-folder of the folder in which JDK 9 has been installed
    to the `PATH` environment variable in our operating system, we will always have
    to use the full path to the `bin` sub-folder when executing the commands. In the
    next instructions to launch the different Java command-line utilities, we will
    assume that we are located in this `bin` sub-folder or that the `PATH` environment
    variable includes it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有将JDK 9安装的文件夹的`bin`子文件夹添加到操作系统的`PATH`环境变量中，那么在执行命令时我们将始终需要使用`bin`子文件夹的完整路径。在启动不同的Java命令行实用程序的下一个说明中，我们将假设我们位于这个`bin`子文件夹中，或者`PATH`环境变量包含它。
- en: 'Once we have installed JDK 9, and added the `bin` folder to the `PATH` environment
    variable, we can run the following command in Windows Command Prompt or in macOS
    or Linux Terminal:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们安装了JDK 9，并将`bin`文件夹添加到`PATH`环境变量中，我们可以在Windows命令提示符或macOS或Linux终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The previous command will display the current version for the primary Java
    compiler included in the JDK that compiles Java source code into Java bytecodes.
    The version number should start with 9, as shown in the next sample output:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令将显示包含在JDK中的主要Java编译器的当前版本，该编译器将Java源代码编译为Java字节码。版本号应该以9开头，如下一个示例输出所示：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If the results of the previous command display a version number that doesn't
    start with 9, we must check whether the installation completed successfully. In
    addition, we have to make sure that the `PATH` environment variable doesn't include
    paths to previous versions of the JDK and that it includes the `bin` folder for
    the recently installed JDK 9.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上一个命令的结果显示的版本号不以9开头，我们必须检查安装是否成功。此外，我们必须确保`PATH`环境变量不包括JDK的旧版本路径，并且包括最近安装的JDK
    9的`bin`文件夹。
- en: 'Now, we are ready to launch JShell. Run the following command in Windows Command
    Prompt or in macOS or Linux Terminal:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备启动JShell。在Windows命令提示符或macOS或Linux终端中运行以下命令：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous command will launch JShell, display a welcome message that includes
    the JDK version being used, and the prompt will change to `jshell>`. Whenever
    we see this prompt, it means we are still in JShell. The following screenshot
    shows JShell running in a Terminal window on macOS.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个命令将启动JShell，显示包括正在使用的JDK版本的欢迎消息，并且提示符将更改为`jshell>`。每当我们看到这个提示时，这意味着我们仍然在JShell中。下面的屏幕截图显示了在macOS的终端窗口中运行的JShell。
- en: '![Installing the required software on Windows, macOS, or Linux](img/00002.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![在Windows、macOS或Linux上安装所需软件](img/00002.jpeg)'
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If we want to leave JShell at any time, we just need to press *Ctrl* + *D* in
    a Mac. Another option is to enter `/exit` and press *Enter*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想随时离开JShell，我们只需要在Mac中按*Ctrl* + *D*。另一个选项是输入`/exit`并按*Enter*。
- en: Understanding the benefits of working with a REPL
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解使用REPL的好处
- en: Java 9 introduced an interactive REPL command-line environment named JShell.
    This tool allows us to execute Java code snippets and get immediate results. We
    can easily write code and see the results of its execution without having to create
    a solution or project. We don't have to wait for the project to finish the build
    process to check the results of executing many lines of code. JShell, as any other
    REPL, facilitates exploratory programming, that is, we can easily and interactively
    try and debug different algorithms and structures.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9引入了一个名为JShell的交互式REPL命令行环境。这个工具允许我们执行Java代码片段并立即获得结果。我们可以轻松编写代码并查看其执行的结果，而无需创建解决方案或项目。我们不必等待项目完成构建过程来检查执行许多行代码的结果。JShell，像任何其他REPL一样，促进了探索性编程，也就是说，我们可以轻松地交互式地尝试和调试不同的算法和结构。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you have worked with other programming languages that provide a REPL or an
    interactive shell such as Python, Scala, Clojure, F#, Ruby, Smalltalk, and Swift
    among many others, you already know the benefits of working with a REPL.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用过其他提供REPL或交互式shell的编程语言，比如Python、Scala、Clojure、F#、Ruby、Smalltalk和Swift等，您已经知道使用REPL的好处。
- en: For example, imagine that we have to interact with an **IoT** (**Internet of
    Things**) library that provides Java bindings. We have to write Java code to use
    the library to control a drone, also known as a **UAV** (**Unmanned Aerial Vehicle**).
    The drone is an IoT device that interacts with many sensors and actuators, including
    digital electronic speed controllers linked to engines, propellers, and servomotors.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们必须与提供Java绑定的IoT（物联网）库进行交互。我们必须编写Java代码来使用该库来控制无人机，也称为无人机（UAV）。无人机是一种与许多传感器和执行器进行交互的物联网设备，包括与发动机、螺旋桨和舵机连接的数字电子调速器。
- en: We want to be able to write a few lines of code to retrieve data from sensors
    and control the actuators. We just need to make sure things work as explained
    in the documentation. We want to make sure that the values read from the altimeter
    change when we move the drone. JShell provides us with the appropriate tool to
    start interacting with the library in a few seconds. We just need to launch JShell,
    load the library, and start writing Java 9 code in the REPL. With previous Java
    versions, we would have needed to create a new project from scratch and write
    some boilerplate code before we could start writing the first lines of code that
    interacted with the library. JShell allows us to start working faster and reduces
    the need to create an entire skeleton to start running Java 9 code. JShell allows
    interactive exploration of **APIs** (**Application Programming Interfaces**) from
    a REPL.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够编写几行代码来从传感器中检索数据并控制执行器。我们只需要确保事情按照文档中的说明进行。我们希望确保从高度计读取的数值在移动无人机时发生变化。JShell为我们提供了一个适当的工具，在几秒钟内开始与库进行交互。我们只需要启动JShell，加载库，并在REPL中开始编写Java
    9代码。使用以前的Java版本，我们需要从头开始创建一个新项目，并在开始编写与库交互的第一行代码之前编写一些样板代码。JShell允许我们更快地开始工作，并减少了创建整个框架以开始运行Java
    9代码的需要。JShell允许从REPL交互式探索API（应用程序编程接口）。
- en: We can enter any Java 9 definition in JShell. For example, we can declare methods,
    classes, and variables. We can also enter Java expressions, statements, or imports.
    Once we have entered the code to declare a method, we can enter a statement that
    uses the previously defined method and see the results of the execution.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在JShell中输入任何Java 9定义。例如，我们可以声明方法、类和变量。我们还可以输入Java表达式、语句或导入。一旦我们输入了声明方法的代码，我们就可以输入一个使用先前定义的方法的语句，并查看执行的结果。
- en: JShell allows us to load source code from a file, and therefore, you will be
    able to load the source code samples included in this book and evaluate them in
    JShell. Whenever we have to work with source code, you will know the folder and
    the file from which you can load it. In addition, JShell allows us to execute
    JShell commands. We will learn about the most useful commands later, in this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JShell允许我们从文件中加载源代码，因此，您将能够加载本书中包含的源代码示例并在JShell中评估它们。每当我们必须处理源代码时，您将知道可以从哪个文件夹和文件中加载它。此外，JShell允许我们执行JShell命令。我们将在本章后面学习最有用的命令。
- en: JShell allows us to call the `System.out.printf` method to easily format output
    we want to print. We will take advantage of this method in our sample code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JShell允许我们调用`System.out.printf`方法轻松格式化我们想要打印的输出。我们将在我们的示例代码中利用这个方法。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: JShell disables some features from Java 9 that aren't useful in the interactive
    REPL. Whenever we have to work with these features in JShell, we will make it
    clear that JShell will disable them and we will explain their effects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: JShell禁用了一些在交互式REPL中没有用处的Java 9功能。每当我们在JShell中使用这些功能时，我们将明确指出JShell将禁用它们，并解释它们的影响。
- en: The semicolon (`;`) is optional at the end of a statement in JShell. However,
    we will always use a semicolon at the end of each statement because we don't want
    to forget that we must use semicolons when we write real-life Java 9 code in projects
    and solutions. We will only omit the semicolon at the end of a statement when
    we enter expressions to be evaluated by JShell.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中，语句末尾的分号(`;`)是可选的。但是，我们将始终在每个语句的末尾使用分号，因为我们不想忘记在编写项目和解决方案中的真实Java 9代码时必须使用分号。当我们输入要由JShell评估的表达式时，我们将省略语句末尾的分号。
- en: For example, the following two lines are equivalent and both of them will print
    `"Object-Oriented Programming rocks with Java 9!"` as a result of their execution
    in JShell. The first line doesn't include a semicolon (`;`) at the end of the
    statement and the second line includes the semicolon (`;`). We will always use
    the semicolon (;) as in the second line, to keep consistency.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下两行是等价的，它们都将在JShell中执行后打印`"Object-Oriented Programming rocks with Java 9!"`。第一行在语句末尾不包括分号(`;`)，第二行包括分号(`;`)。我们将始终使用分号(;)，如第二行中所示，以保持一致性。
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following screenshot shows the results of executing the two lines in JShell
    running on Windows 10:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了在Windows 10上运行的JShell中执行这两行的结果：
- en: '![Understanding the benefits of working with a REPL](img/00003.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![理解使用REPL的好处](img/00003.jpeg)'
- en: In some examples, we will take advantage of the fact that JShell provides us
    networking access. This feature is extremely useful to interact with Web Services.
    However, you have to make sure that you don't have JShell blocked in your firewall
    configuration.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些示例中，我们将利用JShell为我们提供的网络访问功能。这个功能对于与Web服务交互非常有用。但是，您必须确保您的防火墙配置中没有阻止JShell。
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Unluckily, at the time I was writing this book, JShell didn't include syntax
    highlighting features. However, you will learn how to use our favorite editor
    to write and edit code that we can then execute in JShell.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在我写这本书的时候，JShell没有包括语法高亮功能。但是，您将学习如何使用我们喜欢的编辑器来编写和编辑代码，然后在JShell中执行。
- en: Checking default imports and using auto-complete features
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查默认导入并使用自动完成功能
- en: 'By default, JShell provides a set of common imports and we can use the `import`
    statement to import the necessary types from any additional package we might need
    to run our code snippets. We can enter the following command in JShell to list
    all the imports:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，JShell提供一组常见的导入，我们可以使用`import`语句从任何额外的包中导入必要的类型来运行我们的代码片段。我们可以在JShell中输入以下命令来列出所有导入：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following lines show the results of the previous command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了先前命令的结果：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As happens when we write Java code outside of JShell, we don''t need to import
    the types from the `java.lang` package because they are imported by default and
    they aren''t listed when we run the `/imports` command in JShell. Thus, by default,
    JShell provides us access to all the types in the following packages:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在JShell之外编写Java代码时一样，我们不需要从`java.lang`包导入类型，因为它们默认被导入，并且在JShell中运行`/imports`命令时不会列出它们。因此，默认情况下，JShell为我们提供了访问以下包中的所有类型：
- en: '`java.lang`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.lang`'
- en: '`java.io`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.io`'
- en: '`java.math`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.math`'
- en: '`java.net`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.net`'
- en: '`java.nio.file`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.nio.file`'
- en: '`java.util`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util`'
- en: '`java.util.concurrent`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`'
- en: '`java.util.function`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.function`'
- en: '`java.util.prefs`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.prefs`'
- en: '`java.util.regex`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.regex`'
- en: '`java.util.stream`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java.util.stream`'
- en: JShell provides auto-completion features. We just need to press the *Tab* key
    whenever we want to have assistance from the auto-complete feature, as done when
    we work with the Windows Command Prompt or the Terminal in macOS or Linux.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: JShell提供自动完成功能。我们只需要在需要自动完成功能的时候按下*Tab*键，就像在Windows命令提示符或macOS或Linux中的终端中工作时一样。
- en: 'Sometimes, there are too many options that start with the first characters
    we entered. In these cases, JShell provides us with a list of all the available
    options to provide us help. For example, we can enter `S` and press the *Tab*
    key. JShell will list all the types imported from the previously listed packages
    that start with an `S`. The following screenshot shows the results in JShell:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，以我们输入的前几个字符开头的选项太多。在这些情况下，JShell会为我们提供一个包含所有可用选项的列表，以提供帮助。例如，我们可以输入`S`并按*Tab*键。JShell将列出从先前列出的包中导入的以`S`开头的所有类型。以下屏幕截图显示了JShell中的结果：
- en: '![Checking default imports and using auto-complete features](img/00004.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![检查默认导入并使用自动补全功能](img/00004.jpeg)'
- en: We want to enter `System`. Considering the previous list, we will just enter
    `Sys` to make sure that `System` is the only option that starts with `Sys`. Basically,
    we are cheating to understand how auto-completion works in JShell. Enter `Sys`
    and press the *Tab* key. JShell will display `System`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要输入`System`。考虑到前面的列表，我们只需输入`Sys`，以确保`System`是以`Sys`开头的唯一选项。基本上，我们在作弊，以便了解JShell中自动补全的工作原理。输入`Sys`并按下*Tab*键。JShell将显示`System`。
- en: Now, enter a dot (`.`) followed by an `o` (you will have `System.o`) and press
    the *Tab* key. JShell will display `System.out`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在JShell中输入一个点（`.`），然后输入一个`o`（你将得到`System.o`），然后按下*Tab*键。JShell将显示`System.out`。
- en: 'Next, enter a dot (`.`) and press the *Tab* key. JShell will display all the
    public methods declared in `System.out`. After the list, JShell will include `System.out.`
    again to allow us to continue entering our code. The following screenshot shows
    the results in JShell:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入一个点（`.`）并按下*Tab*键。JShell将显示在`System.out`中声明的所有公共方法。在列表之后，JShell将再次包括`System.out.`，以便我们继续输入我们的代码。以下屏幕截图显示了JShell中的结果：
- en: '![Checking default imports and using auto-complete features](img/00005.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![检查默认导入并使用自动补全功能](img/00005.jpeg)'
- en: 'Enter `printl` and press the *Tab* key. JShell will complete to `System.out.println(`,
    that is, it will add an `n` and open parenthesis (`(`). This way, we just have
    to enter the arguments for the method because there was just one method that started
    with `printl`. Enter `"Auto-complete is helpful in JShell");` and press *Enter*.
    The following line shows the complete statement:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`printl`并按下*Tab*键。JShell将自动补全为`System.out.println(`，即它将添加一个`n`和开括号（`(`）。这样，我们只需输入该方法的参数，因为只有一个以`printl`开头的方法。输入`"Auto-complete
    is helpful in JShell");`并按下*Enter*。下一行显示完整的语句：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the results in JShell after running the previous
    line:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述行后，JShell将显示JShell中的结果的屏幕截图：
- en: '![Checking default imports and using auto-complete features](img/00006.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![检查默认导入并使用自动补全功能](img/00006.jpeg)'
- en: Running Java 9 code in JShell
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在JShell中运行Java 9代码
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After we enter the previous lines, JShell will display the next message indicating
    it has created a method named `calculateRectangleArea` with two arguments of `float`
    type:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入上述代码后，JShell将显示下一个消息，指示它已创建了一个名为`calculateRectangleArea`的方法，该方法有两个`float`类型的参数：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice that all the messages written by JShell start with a pipe symbol (`|`).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，JShell写的所有消息都以管道符号（`|`）开头。
- en: 'Enter the following command in JShell to list the current active snippets of
    code that we have typed and executed so far in the current session:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下命令，列出我们在当前会话中迄今为止键入和执行的当前活动代码片段：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Enter the following code in JShell to create a new `float` variable named `width`
    and initialize it with `50`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下代码，创建一个名为`width`的新的`float`变量，并将其初始化为`50`：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After we enter the previous line, JShell will display the next message indicating
    it has created a variable named `width` of `float` type and it assigned the value
    `50.0` to this variable:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入上述行后，JShell将显示下一个消息，指示它已创建了一个名为`width`的`float`类型的变量，并将值`50.0`赋给了这个变量：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Enter the following code in JShell to create a new `float` variable named `height`
    and initialize it with `25`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下代码，创建一个名为`height`的新的`float`变量，并将其初始化为`25`：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After we enter the previous line, JShell will display the next message indicating
    it has created a variable named `height` of the `float` type and it assigned the
    value `25.0` to this variable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入上述行后，JShell将显示下一个消息，指示它已创建了一个名为`height`的`float`类型的变量，并将值`25.0`赋给了这个变量：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Enter `float area = ca` and press the *Tab* key. JShell will complete to `float
    area = calculateRectangleArea(`, that is, it will add `lculateRectangleArea` and
    open parenthesis (`(`). This way, we just have to enter the two arguments for
    the method because there was just one method that started with `ca`. Enter `width,
    height);` and press *Enter*. The following line shows the complete statement:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`float area = ca`并按下*Tab*键。JShell将自动补全为`float area = calculateRectangleArea(`，即它将添加`lculateRectangleArea`和开括号（`(`）。这样，我们只需输入该方法的两个参数，因为只有一个以`ca`开头的方法。输入`width,
    height);`并按下*Enter*。下一行显示完整的语句：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After we enter the previous line, JShell will display the next message indicating
    it has created a variable named `area` of the `float` type and it assigned the
    result of calling the `calculateRectangleArea` method with the previously declared
    `width` and `height` variables as arguments. The method returns `1250.0` as a
    result and it is assigned to the `area` variable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入上述行后，JShell将显示下一个消息，指示它已创建了一个名为`area`的`float`类型的变量，并将调用`calculateRectangleArea`方法并将先前声明的`width`和`height`变量作为参数。该方法返回`1250.0`作为结果，并将其赋给`area`变量。
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Enter the following command in JShell to list the current active snippets of
    code that we have typed and executed so far in the current session:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下命令，列出我们在当前会话中迄今为止键入和执行的当前活动代码片段：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Enter the following code in JShell to display the values for the `width`, `height`,
    and `area` variables with a call to `System.out.printf`. The first `%.2f` in the
    string we pass as a first argument to `System.out.printf` makes the next argument
    after the string (`width`) to be displayed as a floating point number with two
    decimal places. We repeat `%.2f` twice to display the `height` and `area` variables
    as floating point numbers with two decimal places.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下代码，使用`System.out.printf`来显示`width`、`height`和`area`变量的值。我们在作为`System.out.printf`的第一个参数传递的字符串中的第一个`%.2f`使得字符串后面的下一个参数（`width`）以两位小数的浮点数形式显示。我们重复两次`%.2f`来以两位小数的浮点数形式显示`height`和`area`变量。
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After we enter the previous line, JShell will format the output with `System.out.printf`
    and will print the next message followed by the name of a scratch variable:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入上述行后，JShell将使用`System.out.printf`格式化输出，并打印下一个消息，后面跟着一个临时变量的名称：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Evaluating expressions
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估表达式
- en: 'JShell allows us to evaluate any valid Java 9 expression, as we might do when
    we use an IDE and the typical expression evaluation dialog box. Enter the following
    expression in JShell:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: JShell允许我们评估任何有效的Java 9表达式，就像我们在使用IDE和典型的表达式评估对话框时所做的那样。在JShell中输入以下表达式：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After we enter the previous line, JShell will evaluate the expression and it
    will assign the results to a scratch variable whose name starts with `$` and continues
    with a number. JShell displays the scratch variable name, `$6`, the value assigned
    to the variable that indicates the result of evaluating the expression, `1250.0`,
    and the type for the scratch variable, `float`. The next lines show the message
    displayed in JShell after we enter the previous expression:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们输入上一行后，JShell将评估表达式，并将结果分配给一个以`$`开头并后跟一个数字的临时变量。JShell显示临时变量名称`$6`，分配给该变量的值指示表达式评估结果的`1250.0`，以及临时变量的类型`float`。下面的行显示在我们输入上一个表达式后JShell中显示的消息：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After we enter the previous line, JShell will format the output with `System.out.printf`
    and will print the next message:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们输入上一行后，JShell将使用`System.out.printf`格式化输出，并打印下一个消息：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can also use the previously created scratch variable in another expression.
    Enter the following code in JShell to add `10.5` (`float`) to the value of the
    `$6` variable. Make sure you replace `$6` with the scratch variable name that
    JShell generated.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在另一个表达式中使用先前创建的临时变量。在JShell中输入以下代码，将`10.5`（`float`）添加到`$6`变量的值中。确保用JShell生成的临时变量名称替换`$6`。
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After we enter the previous line, JShell will evaluate the expression and it
    will assign the results to a new scratch variable whose name starts with `$` and
    continues with a number. JShell displays the scratch variable name, `$8`, the
    value assigned to the variable that indicates the result of evaluating the expression,
    `1260.5`, and the type for the scratch variable, `float`. The next lines show
    the message displayed in JShell after we enter the previous expression:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们输入上一行后，JShell将评估表达式，并将结果分配给一个新的临时变量，其名称以`$`开头，后跟一个数字。JShell显示临时变量名称`$8`，分配给该变量的值指示表达式评估结果的`1260.5`，以及临时变量的类型`float`。下面的行显示在我们输入上一个表达式后JShell中显示的消息：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As happened before, the name for the scratch variable might be different. For
    example, instead of `$8`, it might be `$9` or `$10`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前发生的情况一样，临时变量的名称可能不同。例如，可能是`$9`或`$10`，而不是`$8`。
- en: Working with variables, methods, and sources
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量、方法和源
- en: 'So far, we have been creating many variables, and JShell created a few scratch
    variables after we entered expressions and they were successfully evaluated. Enter
    the following command in JShell to list the type, name, and value of the current
    active variables that have been created so far in the current session:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了许多变量，而且在我们输入表达式并成功评估后，JShell创建了一些临时变量。在JShell中输入以下命令，列出迄今为止在当前会话中创建的当前活动变量的类型、名称和值：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following lines show the results:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示结果：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Enter the following code in JShell to assign `80.25` (`float`) to the previously
    created `width` variable:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下代码，将`80.25`（`float`）赋给先前创建的`width`变量：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'After we enter the previous line, JShell will display the next message indicating
    it has assigned `80.25` (`float`) to the existing variable named `width` of the
    `float` type:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们输入上一行后，JShell将显示下一个消息，指示它已将`80.25`（`float`）分配给现有的`float`类型变量`width`：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Enter the following code in JShell to assign `40.5` (`float`) to the previously
    created `height` variable:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下代码，将`40.5`（`float`）赋给先前创建的`height`变量：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After we enter the previous line, JShell will display the next message indicating
    it has assigned `40.5` (`float`) to the existing variable named `height` of the
    `float` type:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们输入上一行后，JShell将显示下一个消息，指示它已将`40.5`（`float`）分配给现有的`float`类型变量`height`：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Enter the following command in JShell again to list the type, name, and value
    of the current active variables:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在JShell中输入以下命令，列出当前活动变量的类型、名称和值：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following lines show the results that reflect the new values we have assigned
    to the `width` and `height` variables:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了反映我们已经为`width`和`height`变量分配的新值的结果：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Enter the following code in JShell to create a new method named `calculateRectanglePerimeter`.
    The method receives a `width` variable and a `height` variable for a rectangle
    and returns the result of the multiplication by `2` of the sum of both values
    of the `float` type.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下代码，创建一个名为`calculateRectanglePerimeter`的新方法。该方法接收一个矩形的`width`变量和一个`height`变量，并返回`float`类型的两个值之和乘以`2`的结果。
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After we enter the previous lines, JShell will display the next message indicating
    it has created a method named `calculateRectanglePerimeter` with two arguments
    of the `float` type:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们输入上一行后，JShell将显示下一个消息，指示它已创建一个名为`calculateRectanglePerimeter`的方法，该方法有两个`float`类型的参数：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Enter the following command in JShell to list the name, parameter types, and
    return the type of the current active methods that have been created so far in
    the current session:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下命令，列出迄今为止在当前会话中创建的当前活动方法的名称、参数类型和返回类型：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The following lines show the results.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示结果。
- en: '[PRE44]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Enter the following code in JShell to print the results of calling the recently
    created `calculateRectanglePerimeter` with `width` and `height` as the arguments:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下代码，打印调用最近创建的`calculateRectanglePerimeter`的结果，其中`width`和`height`作为参数：
- en: '[PRE45]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'After we enter the previous line, JShell will call the method and it will assign
    the results to a scratch variable whose name starts with `$` and continues with
    a number. JShell displays the scratch variable name, `$16`, the value assigned
    to the variable that indicates the result returned by the method, `241.5`, and
    the type for the scratch variable, `float`. The next lines show the message displayed
    in JShell after we enter the previous expression that called a method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们输入上一行后，JShell将调用该方法，并将结果分配给一个以`$`开头并带有数字的临时变量。JShell显示了临时变量名`$16`，分配给该变量的值表示方法返回的结果`241.5`，以及临时变量的类型`float`。下面的行显示了在我们输入调用方法的先前表达式后，JShell中显示的消息：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, we want to make changes to the recently created `calculateRectanglePerimeter`
    method. We want to add a line to print the calculated perimeter. Enter the following
    command in JShell to list the source code for the method:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想对最近创建的`calculateRectanglePerimeter`方法进行更改。我们想添加一行来打印计算的周长。在JShell中输入以下命令，列出该方法的源代码：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following lines show the results:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了结果：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Enter the following code in JShell to overwrite the method named `calculateRectanglePerimeter`
    with a new code that prints the received width and height values and then prints
    the calculated perimeter with calls to the `System.out.printf` method that works
    in the same way as the built-in `printf` method. We can copy and paste the pieces
    from the previously listed source code. The changes are highlighted here:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下代码，用新代码覆盖名为`calculateRectanglePerimeter`的方法，该新代码打印接收到的宽度和高度值，然后使用与内置`printf`方法相同的方式工作的`System.out.printf`方法调用打印计算的周长。我们可以从先前列出的源代码中复制和粘贴这些部分。这里突出显示了更改：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'After we enter the previous lines, JShell will display the next messages indicating
    it has modified and overwritten the method named `calculateRectanglePerimeter`
    with two arguments of the `float` type:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们输入上述行后，JShell将显示下一个消息，指示它已修改并覆盖了名为`calculateRectanglePerimeter`的方法，该方法有两个`float`类型的参数：
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Enter the following code in JShell to print out the results of calling the
    recently modified `calculateRectanglePerimeter` with `width` and `height` as the
    arguments:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下代码，以打印调用最近修改的`calculateRectanglePerimeter`方法并将`width`和`height`作为参数的结果：
- en: '[PRE51]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: After we enter the previous line, JShell will call the method and it will assign
    the results to a scratch variable whose name starts with `$` and continues with
    a number. The first lines display the output generated by the three calls to `System.out.printf`
    that we added to the method. Finally, JShell displays the scratch variable name,
    `$19`, the value assigned to the variable that indicates the result returned by
    the method, `241.5`, and the type for the scratch variable, `float`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们输入上一行后，JShell将调用该方法，并将结果分配给一个以`$`开头并带有数字的临时变量。前几行显示了由我们添加到方法中的三次调用`System.out.printf`生成的输出。最后，JShell显示了临时变量名`$19`，分配给该变量的值表示方法返回的结果`241.5`，以及临时变量的类型`float`。
- en: 'The next lines show the messages displayed in JShell after we enter the previous
    expression that called the new version of the method:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的行显示了在我们输入调用方法的先前表达式后，JShell中显示的消息：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Editing the source code in our favorite external code editor
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们喜爱的外部代码编辑器中编辑源代码
- en: We created a new version of the `calculateRectanglePerimeter` method. Now, we
    want to make similar changes to the `calculateRectangleArea` method. However,
    this time, we will take advantage of an editor to make it easier to make changes
    to the existing code.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`calculateRectanglePerimeter`方法的新版本。现在，我们想对`calculateRectangleArea`方法进行类似的更改。但是，这一次，我们将利用编辑器来更轻松地对现有代码进行更改。
- en: 'Enter the following command in JShell to launch the default JShell Edit Pad
    editor to edit the source code for the `calculateRectangleArea` method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下命令，启动默认的JShell编辑面板编辑器，以编辑`calculateRectangleArea`方法的源代码：
- en: '[PRE53]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'JShell will display a dialog box with JShell Edit Pad and the source code for
    the `calculateRectangleArea` method, as shown in the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: JShell将显示一个对话框，其中包含JShell编辑面板和`calculateRectangleArea`方法的源代码，如下面的屏幕截图所示：
- en: '![Editing the source code in our favorite external code editor](img/00007.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![在我们喜爱的外部代码编辑器中编辑源代码](img/00007.jpeg)'
- en: JShell Edit Pad lacks most of the features we enjoy from code editors and we
    cannot even consider it a decent code editor. In fact, it just allows us to easily
    edit the source code without having to copy and paste from the previous listing.
    We will learn how to configure a better editor later.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: JShell编辑面板缺少我们从代码编辑器中喜欢的大多数功能，我们甚至不能认为它是一个体面的代码编辑器。事实上，它只允许我们轻松地编辑源代码，而无需从先前的列表中复制和粘贴。我们将在以后学习如何配置更好的编辑器。
- en: 'Enter the following code in the JShell Edit Pad to overwrite the method named
    `calculateRectangleArea` with a new code that prints the received width and height
    values and then prints the calculated area with calls to the `Sytem.out.printf`
    method. The changes are highlighted here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell编辑面板中输入以下代码，以用新代码覆盖名为`calculateRectangleArea`的方法，该新代码打印接收到的宽度和高度值，然后使用`Sytem.out.printf`方法调用打印计算的面积。这里突出显示了更改：
- en: '[PRE54]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Click on **Accept** and then click on **Exit**. JShell will close the JShell
    Edit Pad and display the next messages indicating it has modified and overwritten
    the method named `calculateRectangleArea` with two arguments of the `float` type:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**接受**，然后点击**退出**。JShell将关闭JShell编辑面板，并显示下一个消息，指示它已修改并覆盖了名为`calculateRectangleArea`的方法，该方法有两个`float`类型的参数：
- en: '[PRE55]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Enter the following code in JShell to print the results of calling the recently
    modified `calculateRectangleArea` method with `width` and `height` as the arguments:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中输入以下代码，以打印调用最近修改的`calculateRectangleArea`方法并将`width`和`height`作为参数的结果：
- en: '[PRE56]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After we enter the previous line, JShell will call the method and it will assign
    the results to a scratch variable whose name starts with `$` and continues with
    a number. The first lines display the output generated by the three calls to `System.out.printf`
    that we added to the method. Finally, JShell displays the scratch variable name,
    `$24`, the value assigned to the variable that indicates the result returned by
    the method, `3250.125`, and the type for the scratch variable, `float`. The next
    lines show the messages displayed in JShell after we enter the previous expression
    that called the new version of the method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 输入上述行后，JShell将调用该方法，并将结果赋给一个以“$”开头并带有数字的临时变量。前几行显示了通过对该方法添加的三次“System.out.printf”调用生成的输出。最后，JShell显示了临时变量名“$24”，指示方法返回的结果的值“3250.125”，以及临时变量的类型“float”。接下来的几行显示了在输入调用方法的新版本的前一个表达式后，JShell显示的消息：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The good news is that JShell allows us to easily configure any external editor
    to edit the code snippets. We just need to grab the complete path to the editor
    we want to use and run a command in JShell to configure the editor we want to
    launch whenever we use the `/edit` command.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，JShell允许我们轻松配置任何外部编辑器来编辑代码片段。我们只需要获取要使用的编辑器的完整路径，并在JShell中运行一个命令来配置我们想要在使用“/edit”命令时启动的编辑器。
- en: 'For example, in Windows, the default installation path for the popular Sublime
    Text 3 code editor is `C:\Program Files\Sublime Text 3\sublime_text.exe`. If we
    want to use this editor to edit code snippets in JShell, we must run the `/set
    editor` command followed by the path enclosed in double quotes. We have to make
    sure that we replace the backslash (`\`) with double backslashes (`\\`) in the
    path string. For the previously explained path, we must run the following command:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Windows中，流行的Sublime Text 3代码编辑器的默认安装路径是“C:\Program Files\Sublime Text 3\sublime_text.exe”。如果我们想要使用此编辑器在JShell中编辑代码片段，必须运行“/set
    editor”命令，后跟用双引号括起来的路径。我们必须确保在路径字符串中用双反斜杠（\\）替换反斜杠（\）。对于先前解释的路径，我们必须运行以下命令：
- en: '[PRE58]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After we enter the previous command, JShell will display a message indicating
    to us that the editor was set to the specified path:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 输入上述命令后，JShell将显示一条消息，指示编辑器已设置为指定路径：
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'After we change the editor, we can enter the following command in JShell to
    launch the new editor to make changes to the source code for the `calculateRectangleArea`
    method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 更改编辑器后，我们可以在JShell中输入以下命令，以启动新编辑器对“calculateRectangleArea”方法的源代码进行更改：
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'JShell will launch Sublime Text 3 or any other editor that we might have specified
    and will load a temporary file with the source code for the `calculateRectangleArea`
    method, as shown in the following screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: JShell将启动Sublime Text 3或我们可能指定的任何其他编辑器，并将加载一个临时文件，其中包含“calculateRectangleArea”方法的源代码，如下截图所示：
- en: '![Editing the source code in our favorite external code editor](img/00008.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![在我们喜欢的外部代码编辑器中编辑源代码](img/00008.jpeg)'
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If we save the changes, JShell will automatically overwrite the method as we
    did when we used the default editor: JShell Edit Pad. After we make the necessary
    edits, we must close the editor to continue running Java code or JShell commands
    in JShell.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保存更改，JShell将自动覆盖该方法，就像我们使用默认编辑器JShell Edit Pad时所做的那样。进行必要的编辑后，我们必须关闭编辑器，以继续在JShell中运行Java代码或JShell命令。
- en: In any of the platforms, JShell will create a temporary file with the `.edit`
    extension. Thus, we can configure our favorite editor to use Java syntax highlighting
    whenever we open files with the `.edit` extension.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何平台上，JShell都会创建一个带有“.edit”扩展名的临时文件。因此，我们可以配置我们喜欢的编辑器，以便在打开带“.edit”扩展名的文件时使用Java语法高亮显示。
- en: In macOS or Linux, paths are different than in Windows, and therefore, the necessary
    steps are different. For example, in macOS, in order to launch the popular Sublime
    Text 3 code editor when it is installed in the default path, we must run `/Applications/Sublime
    Text.app/Contents/SharedSupport/bin/subl`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS或Linux中，路径与Windows中的不同，因此必要的步骤也不同。例如，在macOS中，为了在默认路径中安装流行的Sublime Text
    3代码编辑器时启动它，我们必须运行“/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl”。
- en: 'If we want to use this editor to edit code snippets in JShell, we must run
    the `/set editor` command followed by the complete path enclosed in double quotes.
    For the previously explained path, we must run the following command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用此编辑器在JShell中编辑代码片段，必须运行“/set editor”命令，后跟完整路径，路径需用双引号括起来。对于先前解释的路径，我们必须运行以下命令：
- en: '[PRE61]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'After we enter the previous command, JShell will display a message indicating
    to us that the editor was set to the specified path:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 输入上述命令后，JShell将显示一条消息，指示编辑器已设置为指定路径：
- en: '[PRE62]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'After we change the editor, we can enter the following command in JShell to
    launch the new editor to make changes to the source code for the `calculateRectangleArea`
    method:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 更改编辑器后，我们可以在JShell中输入以下命令，以启动新编辑器对“calculateRectangleArea”方法的源代码进行更改：
- en: '[PRE63]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'JShell will launch Sublime Text 3 on macOS or any other editor that we might
    have specified and will load a temporary file with the source code for the `calculateRectangleArea`
    method, as shown in the following screenshot:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: JShell将在macOS上启动Sublime Text 3或我们可能指定的任何其他编辑器，并将加载一个临时文件，其中包含“calculateRectangleArea”方法的源代码，如下截图所示：
- en: '![Editing the source code in our favorite external code editor](img/00009.jpeg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![在我们喜欢的外部代码编辑器中编辑源代码](img/00009.jpeg)'
- en: Loading source code
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载源代码
- en: Of course, we don't have to enter the source code for each example. Auto-completion
    features are useful, but we will take advantage of a command that allows us to
    load source code from a file in JShell.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不必为每个示例输入源代码。自动补全功能很有用，但我们将利用一个命令，允许我们在JShell中从文件加载源代码。
- en: 'Press *Ctrl* + *D* to exit the current JShell session. Run the following command
    in the Windows Command Prompt or in a macOS or Linux Terminal to launch JShell
    again with a verbose feedback:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *D*退出当前的JShell会话。在Windows命令提示符中或macOS或Linux终端中运行以下命令，以启动具有详细反馈的JShell：
- en: '[PRE64]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following lines show code that declares the latest versions of the `calculateRectanglePerimeter`
    and `calculateRectangleArea` methods. Then, the code declares and initializes
    two variables of the `float` type: `width` and `height`. Finally, the last two
    lines call the previously defined methods with `width` and `height` as their arguments.
    The code file for the sample is included in the `java_9_oop_chapter_01_01` folder,
    in the `example01_01.java` file.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了声明`calculateRectanglePerimeter`和`calculateRectangleArea`方法的最新版本的代码。然后，代码声明并初始化了两个`float`类型的变量：`width`和`height`。最后，最后两行调用了先前定义的方法，并将`width`和`height`作为它们的参数。示例的代码文件包含在`java_9_oop_chapter_01_01`文件夹中的`example01_01.java`文件中。
- en: '[PRE65]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If the root folder for the source code in macOS or Linux is `~/Documents/Java9`,
    you can run the following command to load and execute the previously shown source
    code in JShell:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果macOS或Linux中源代码的根文件夹是`~/Documents/Java9`，您可以运行以下命令在JShell中加载和执行先前显示的源代码：
- en: '[PRE68]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'After we enter the previous command followed by the path based on our configuration
    and our operating system, JShell will load and execute the previously shown source
    code and will display the output generated after running the loaded code snippet.
    The following lines show the output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入先前的命令后，根据我们的配置和操作系统，JShell将加载和执行先前显示的源代码，并在运行加载的代码片段后显示生成的输出。以下行显示了输出：
- en: '[PRE69]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, enter the following command in JShell to list the current, active snippets
    of code, loaded from the source file, that have been executed in the current session
    so far:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在JShell中输入以下命令，以列出到目前为止在当前会话中执行的来自源文件的当前活动代码片段：
- en: '[PRE70]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following lines show the results. Notice that JShell prefaces the different
    method definitions and expressions with different snippet ids because the loaded
    source code behaves in the same way as if we were entering one snippet after the
    other:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了结果。请注意，JShell使用不同的片段ID为不同的方法定义和表达式添加前缀，因为加载的源代码的行为方式与我们逐个输入片段一样：
- en: '[PRE71]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Tip
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure you use the previously explained `/open` command followed by the path
    and the file name for the code file that you want to load and execute in JShell
    whenever you find source code in the book. This way, you won't have to enter each
    code snippet and you will be able to check the results of executing the code in
    JShell.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在找到书中的源代码时，使用先前解释的`/open`命令，后跟代码文件的路径和文件名，以便在JShell中加载和执行代码文件。这样，您就不必输入每个代码片段，而且可以检查在JShell中执行代码的结果。
- en: Test your knowledge
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'JShell is:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JShell是：
- en: A Java 9 REPL.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 9 REPL。
- en: An equivalent of `javac` in previous JDK versions.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以前的JDK版本中等同于`javac`。
- en: A Java 9 bytecode decompiler.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 9字节码反编译器。
- en: 'REPL means:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: REPL的意思是：
- en: Run-Expand-Process-Loop.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行-扩展-处理-循环。
- en: Read-Evaluate-Process-Lock.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取-评估-处理-锁。
- en: Read-Evaluate-Print-Loop.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取-评估-打印-循环。
- en: 'Which of the following commands lists all the variables created in the current
    JShell session:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令列出了当前JShell会话中创建的所有变量：
- en: '`/variables`'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/variables`'
- en: '`/vars`'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/vars`'
- en: '`/list-all-variables`'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/list-all-variables`'
- en: 'Which of the following commands lists all the methods created in the current
    JShell session:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令列出了当前JShell会话中创建的所有方法：
- en: '`/methods`'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/methods`'
- en: '`/meth`'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/meth`'
- en: '`/list-all-methods`'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/list-all-methods`'
- en: 'Which of the following commands lists the source code evaluated so far in the
    current JShell session:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个命令列出了当前JShell会话中迄今为止评估的源代码：
- en: '`/source`'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/source`'
- en: '`/list`'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/list`'
- en: '`/list-source`'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`/list-source`'
- en: Summary
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we started our journey toward object-oriented programming
    with Java 9\. We learned how to launch and work with the new utility introduced
    with Java 9 that allows us to easily run Java 9 code snippets and print its results:
    JShell.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了使用Java 9进行面向对象编程的旅程。我们学会了如何启动和使用Java 9中引入的新实用程序，该实用程序允许我们轻松运行Java
    9代码片段并打印其结果：JShell。
- en: We learned the necessary steps to install JDK 9 and we understood the benefits
    of working with a REPL. We learned to use JShell to run Java 9 code and evaluate
    expressions. We also learned many of its useful commands and features. We will
    use them in the forthcoming chapters when we will start working with object-oriented
    code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了安装JDK 9所需的步骤，并了解了使用REPL的好处。我们学会了使用JShell来运行Java 9代码和评估表达式。我们还学会了许多有用的命令和功能。在接下来的章节中，当我们开始使用面向对象的代码时，我们将使用它们。
- en: Now that we have learned to work with JShell, we will learn how to recognize
    real-world elements and translate them into the different components of the object-oriented
    paradigm supported in Java 9, which is what we are going to discuss in the next
    chapter.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用JShell，我们将学会如何识别现实世界的元素，并将它们转化为Java 9中支持的面向对象范式的不同组件，这是我们将在下一章中讨论的内容。
