- en: Chapter 5. Friends of Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。Docker的朋友
- en: Up until now, we have been busy learning all about Docker. One major factor
    influencing the lifetime of open source projects is the community around it. The
    creators of Docker, Docker Inc. (the offshoot of **dotCloud)**, take care of developing
    and maintaining Docker and its sister projects such as libcontainer, libchan,
    swarm, and so on (the complete list can be found at [github.com/docker](http://github.com/docker)).
    However, like any other open source project, the development is open (in GitHub),
    and they accept pull requests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直忙于学习有关Docker的一切。影响开源项目寿命的一个主要因素是其周围的社区。Docker的创建者Docker Inc.（**dotCloud**的分支）负责开发和维护Docker及其姊妹项目，如libcontainer、libchan、swarm等（完整列表可在[github.com/docker](http://github.com/docker)找到）。然而，像任何其他开源项目一样，开发是公开的（在GitHub上），他们接受拉取请求。
- en: The industry has embraced Docker as well. Bigwigs such as Google, Amazon, Microsoft,
    eBay, and RedHat actively use and contribute to Docker. Most popular IaaS solutions
    such as Amazon Web Services, Google Compute Cloud, and so on support creating
    images preloaded with and optimized for Docker. Many start-ups are betting their
    fortunes on Docker as well. CoreOS, Drone.io, and Shippable are some of the start-ups
    that are modeled such that they provide services based around Docker. So you can
    rest assured that it's not going away any time soon.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 行业也接受了Docker。像谷歌、亚马逊、微软、eBay和RedHat这样的大公司积极使用和贡献Docker。大多数流行的IaaS解决方案，如亚马逊网络服务、谷歌计算云等，都支持创建预加载和优化为Docker的镜像。许多初创公司也在Docker上押注他们的财富。CoreOS、Drone.io和Shippable是一些初创公司，它们提供基于Docker的服务。因此，您可以放心，它不会很快消失。
- en: In this chapter, we will discuss some of the projects surrounding Docker and
    how to use them. We will also be looking at projects you may already be familiar
    with that can facilitate your Docker workflow (and make your life a lot easier).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论围绕Docker的一些项目以及如何使用它们。我们还将看看您可能已经熟悉的项目，这些项目可以促进您的Docker工作流程（并使您的生活变得更加轻松）。
- en: Firstly, we will talk about using Chef and Puppet recipes with Docker. Many
    of you might already be using these tools in your workflow. This section will
    help you integrate Docker with your current workflow, and ease you into the Docker
    ecosystem.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将讨论如何使用Chef和Puppet配方与Docker。你们中的许多人可能已经在工作流程中使用这些工具。本节将帮助您将Docker与当前工作流程集成，并使您逐步进入Docker生态系统。
- en: Next, we will try to set up an **apt-cacher** so that our Docker builds won't
    spend a lot of time fetching frequently used packages all the way from Canonical
    server. This will considerably reduce the time it takes to build images from Dockerfiles.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将尝试设置一个**apt-cacher**，这样我们的Docker构建就不会花费大量时间从Canonical服务器获取经常使用的软件包。这将大大减少使用Dockerfile构建镜像所需的时间。
- en: One of the things that gave Docker so much hype in the early stages was how
    easy some things that have been known to be hard seemed so easy when implemented
    with Docker. One such project is **Dokku**, a 100-line bash script that sets up
    a **mini**-**Heroku** like PaaS. We will set up our own PaaS using Dokku in this
    chapter. The very last thing we will be covering in this book is deploying a highly
    available service using CoreOS and Fleet.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期阶段，给Docker带来如此大的关注的一件事是，一些本来被认为很难的事情在Docker实现时似乎变得很容易。其中一个项目是**Dokku**，一个100行的bash脚本，可以设置一个类似于**mini**-**Heroku**的PaaS。在本章中，我们将使用Dokku设置我们自己的PaaS。本书中我们将讨论的最后一件事是使用CoreOS和Fleet部署高可用服务。
- en: 'In short, in this final leg of our journey, we will be looking at the following
    topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在我们旅程的最后一段，我们将讨论以下主题：
- en: Using Docker with Chef and Puppet
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker与Chef和Puppet
- en: Setting up an apt-cacher
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个apt-cacher
- en: Setting up your own mini-Heroku
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置您自己的mini-Heroku
- en: Setting up a highly available service
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个高可用的服务
- en: Using Docker with Chef and Puppet
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker与Chef和Puppet
- en: When businesses started moving into the cloud, scaling became a whole lot easier
    as one could go from a single machine to hundreds without breaking a sweat. But
    this also meant configuring and maintaining these machines. Configuration management
    tools such as Chef and Puppet arose from the need to automate deploying applications
    in public/private clouds. Today, Chef and Puppet are used every day by start-ups
    and corporates all over the world to manage their cloud environments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当企业开始进入云时，扩展变得更加容易，因为可以从一台单机扩展到数百台而不费吹灰之力。但这也意味着需要配置和维护这些机器。配置管理工具，如Chef和Puppet，是为了自动部署公共/私有云中的应用而产生的需求。如今，Chef和Puppet每天都被全球各地的初创公司和企业用来管理他们的云环境。
- en: Using Docker with Chef
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker与Chef
- en: 'Chef''s website states the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Chef的网站上写着：
- en: '*"Chef turns infrastructure into code. With Chef, you can automate how you
    build, deploy, and manage your infrastructure. Your infrastructure becomes as
    versionable, testable, and repeatable as application code."*'
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"Chef将基础设施转化为代码。使用Chef，您可以自动化构建、部署和管理基础设施。您的基础设施变得像应用代码一样可版本化、可测试和可重复。"*'
- en: Now, assuming that you have already set up Chef and are familiar with the Chef
    workflow, let's see how to use Docker with Chef using the chef-docker cookbook.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设您已经设置好了Chef，并熟悉了Chef的工作流程，让我们看看如何使用chef-docker食谱在Chef中使用Docker。
- en: You can install this cookbook with any of the cookbook dependency managers.
    The installation instructions for each of Berkshelf, Librarian, and Knife are
    available at the Chef community site for the cookbook ([https://supermarket.getchef.com/cookbooks/docker](https://supermarket.getchef.com/cookbooks/docker)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用任何食谱依赖管理器安装此食谱。有关Berkshelf、Librarian和Knife的安装说明可在该食谱的Chef社区网站上找到（[https://supermarket.getchef.com/cookbooks/docker](https://supermarket.getchef.com/cookbooks/docker)）。
- en: Installing and configuring Docker
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和配置Docker
- en: Installing Docker is simple. Just add the `recipe[docker]` command to your run-list
    (the list of configuration settings). An example is worth a million words, so
    let's see how to write a Chef recipe to run the `code.it` file (our sample project)
    on Docker.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker很简单。只需将`recipe[docker]`命令添加到运行列表（配置设置列表）即可。举个例子，让我们看看如何编写一个Chef配方来在Docker上运行`code.it`文件（我们的示例项目）。
- en: Writing a Chef recipe to run Code.it on Docker
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写一个Chef配方，在Docker上运行Code.it
- en: 'The following Chef recipe starts a container based on `code.it`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Chef配方基于`code.it`启动一个容器：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first non-comment statement includes the Chef-Docker recipe. The `docker_image
    'shrikrishna/code.it'` statement is equivalent to running the `$ docker pull shrikrishna/code.it`
    command in the console. The block of statements at the end of the recipe is equivalent
    to running the `$ docker run --d -p '8000:8000' -e 'NODE_PORT=8000' -v '/var/log/code.it:/var/log/code.it'
    shrikrishna/code.it` command.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个非注释语句包括Chef-Docker配方。`docker_image 'shrikrishna/code.it'`语句相当于在控制台中运行`$ docker
    pull shrikrishna/code.it`命令。配方末尾的语句块相当于运行`$ docker run --d -p '8000:8000' -e 'NODE_PORT=8000'
    -v '/var/log/code.it:/var/log/code.it' shrikrishna/code.it`命令。
- en: Using Docker with Puppet
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker与Puppet
- en: 'PuppetLabs''s website states the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: PuppetLabs的网站上写着：
- en: '*"Puppet is a configuration management system that allows you to define the
    state of your IT infrastructure, then automatically enforces the correct state.
    Whether you''re managing just a few servers or thousands of physical and virtual
    machines, Puppet automates tasks that sysadmins often do manually, freeing up
    time and mental space so sysadmins can work on the projects that deliver greater
    business value."*'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Puppet是一个配置管理系统，允许您定义IT基础架构的状态，然后自动强制执行正确的状态。无论您是管理几台服务器还是成千上万台物理和虚拟机，Puppet都会自动化系统管理员经常手动执行的任务，从而节省时间和精力，使系统管理员可以专注于提供更大商业价值的项目。”
- en: 'Puppet''s equivalent of Chef cookbooks are modules. There is a well-supported
    module available for Docker. Its installation is carried out by running this command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet的等效于Chef cookbooks的模块。有一个为Docker提供支持的模块可用。通过运行以下命令来安装它：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Writing a Puppet manifest to run Code.it on Docker
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写一个Puppet清单来在Docker上运行Code.it
- en: 'The following Puppet manifest starts a `code.it` container:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Puppet清单启动了一个`code.it`容器：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first non-comment statement includes the `docker` module. The `docker::image
    {'shrikrishna/code.it':}` statement is equivalent to running the `$ docker pull
    shrikrishna/code.it` command in the console. The block of statements at the end
    of the recipe is equivalent to running the `$ docker run --d -p '8000:8000' -e
    'NODE_PORT=8000' -v '/var/log/code.it:/var/log/code.it' shrikrishna/code.it node
    /srv/app.js` command.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个非注释语句包括`docker`模块。`docker::image {'shrikrishna/code.it':}`语句相当于在控制台中运行`$
    docker pull shrikrishna/code.it`命令。在配方末尾的语句块相当于运行`$ docker run --d -p '8000:8000'
    -e 'NODE_PORT=8000' -v '/var/log/code.it:/var/log/code.it' shrikrishna/code.it
    node /srv/app.js`命令。
- en: Setting up an apt-cacher
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置apt-cacher
- en: When you have multiple Docker servers, or when you are building multiple unrelated
    Docker images, you might find that you have to download packages every time. This
    can be prevented by having a caching proxy in-between the servers and clients.
    It caches packages as you install them. If you attempt to install a package that
    is already cached, it is served from the proxy server itself, thus reducing the
    latency in fetching packages and greatly speeding up the build process.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有多个Docker服务器，或者当您正在构建多个不相关的Docker镜像时，您可能会发现每次都必须下载软件包。这可以通过在服务器和客户端之间设置缓存代理来防止。它在您安装软件包时缓存软件包。如果您尝试安装已经缓存的软件包，它将从代理服务器本身提供，从而减少获取软件包的延迟，大大加快构建过程。
- en: 'Let''s write a Dockerfile that sets up an apt-caching server as a caching proxy
    server:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个Dockerfile来设置一个apt缓存服务器作为缓存代理服务器：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This Dockerfile installs the `apt-cacher-ng` package in the image and exposes
    port `3142` (for the target containers to use).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Dockerfile在镜像中安装了`apt-cacher-ng`软件包，并暴露端口`3142`（供目标容器使用）。
- en: 'Build the image using this command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此命令构建镜像：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then run it, binding the exposed port:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行它，绑定暴露的端口：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To see the logs, run the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看日志，请运行以下命令：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using the apt-cacher while building your Dockerfiles
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在构建Dockerfiles时使用apt-cacher
- en: 'So we have set up an apt-cacher. We now have to use it in our Dockerfiles:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们已经设置了一个apt-cacher。现在我们必须在我们的Dockerfiles中使用它：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the second instruction, replace the `<host's-docker0-ip-here>` command with
    your Docker host's IP address (at the `docker0` interface). While building this
    Dockerfile, if it encounters any `apt-get install` installation command for a
    package that has already been installed before (either for this image or for any
    other image), instead of using Docker's or Canonical package repositories, it
    will fetch the packages from the local proxy server, thus speeding up package
    installations in the build process. If the package being installed is not present
    in the cache, then it is fetched from Canonical repositories and saved in the
    cache.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二条指令中，用您的Docker主机的IP地址（在`docker0`接口处）替换`<host's-docker0-ip-here>`命令。在构建这个Dockerfile时，如果遇到任何已经安装过的软件包的`apt-get
    install`安装命令（无论是为了这个镜像还是其他镜像），它将从本地代理服务器获取软件包，从而加快构建过程中的软件包安装速度。如果要安装的软件包不在缓存中，则从Canonical仓库获取并保存在缓存中。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: An apt-cacher will only work for Debian-based containers (such as Ubuntu) that
    use the Apt package management tool.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: apt-cacher只对使用Apt软件包管理工具的基于Debian的容器（如Ubuntu）有效。
- en: Setting up your own mini-Heroku
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置您自己的迷你Heroku
- en: Now let's do something cool. For the uninitiated, Heroku is a cloud PaaS, which
    means that all you need to do upon building an application is to push it to Heroku
    and it will get deployed on [https://www.herokuapp.com](https://www.herokuapp.com).
    You don't need to worry how or where your application runs. As long as the PaaS
    supports your technology stack, you can just develop locally and push the application
    to the service to have it running live on the public Internet.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们做一些酷炫的事情。对于初学者来说，Heroku是一个云PaaS，这意味着您在构建应用程序时只需要将其推送到Heroku，它就会部署在[https://www.herokuapp.com](https://www.herokuapp.com)上。您不需要担心应用程序运行的方式或位置。只要PaaS支持您的技术栈，您就可以在本地开发并将应用程序推送到服务上，让其在公共互联网上实时运行。
- en: There are a lot of PaaS providers apart from Heroku. Some popular providers
    are Google App Engine, Red Hat Cloud, and Cloud Foundry. Docker was developed
    by one such PaaS provider—dotCloud. Almost every PaaS works by running the applications
    in predefined sandboxed environments, and this is something Docker excels at.
    Today, Docker has made setting up a PaaS easier, if not simple. The project that
    proved this was Dokku. Dokku shares the usage pattern and terminologies (such
    as `buildpacks`, `slug` `builder` scripts) with Heroku, which makes it easier
    to use. In this section, we will be setting up a mini-PaaS using Dokku and pushing
    our `code.it` application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Heroku之外，还有许多PaaS提供商。一些流行的提供商包括Google App Engine、Red Hat Cloud和Cloud Foundry。Docker是由一个这样的PaaS提供商dotCloud开发的。几乎每个PaaS都通过在预定义的沙盒环境中运行应用程序来工作，而这正是Docker擅长的。如今，Docker已经使得设置PaaS变得更加容易，如果不是简单的话。证明这一点的项目是Dokku。Dokku与Heroku共享使用模式和术语（如`buildpacks`、`slug`
    `builder`脚本），这使得它更容易使用。在本节中，我们将使用Dokku设置一个迷你PaaS，并推送我们的`code.it`应用程序。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The next steps should be done on either a **Virtual** **Private** **Server**
    (**VPS**) or a virtual machine. The host you are working from should have git
    and SSH set up.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤应该在虚拟专用服务器（VPS）或虚拟机上完成。您正在使用的主机应该已经设置好了git和SSH。
- en: Installing Dokku using a bootstrapper script
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用bootstrapper脚本安装Dokku
- en: 'There is a `bootstrapper` script that will set up Dokku. Run this command inside
    the VPS/virtual machine:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`bootstrapper`脚本可以设置Dokku。在VPS/虚拟机内运行此命令：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Users on version 12.04 will need to run the `$ apt-get install -y python-software-properties`
    command before running the preceding `bootstrapper` script.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 12.04版本的用户需要在运行上述`bootstrapper`脚本之前运行`$ apt-get install -y python-software-properties`命令。
- en: The `bootstrapper` script will download all the dependencies and set up Dokku.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`bootstrapper`脚本将下载所有依赖项并设置Dokku。'
- en: Installing Dokku using Vagrant
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Vagrant安装Dokku
- en: 'Step 1: Clone Dokku:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤1：克隆Dokku：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Step 2: Set up SSH hosts in your `/etc/hosts` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤2：在您的`/etc/hosts`文件中设置SSH主机：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Step 3: Set up SSH Config in `~/.ssh/config`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤3：在`~/.ssh/config`中设置SSH配置
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Step 4: Create a VM'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤4：创建虚拟机
- en: 'Here are some optional ENV arguments to set up:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可选的ENV参数设置：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Step 5 : Copy your SSH key using this command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤5：使用此命令复制您的SSH密钥：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Paste your SSH key in the dokku-installer at `http://dokku.app` (which points
    to `10.0.0.2` as assigned in the `/etc/hosts` file). Change the **Hostname** field
    on the **Dokku Setup** screen to your domain and then check the box that says
    **Use** **virtualhost** **naming**. Then, click on **Finish** **Setup** to install
    your key. You'll be directed to application deployment instructions from here.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`http://dokku.app`的dokku-installer中粘贴您的SSH密钥（指向`/etc/hosts`文件中分配的`10.0.0.2`）。在**Dokku设置**屏幕上更改**主机名**字段为您的域名，然后选中**使用虚拟主机命名**的复选框。然后，单击**完成设置**以安装您的密钥。您将从这里被引导到应用程序部署说明。
- en: You are now ready to deploy an app or install plugins.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经准备好部署应用程序或安装插件。
- en: Configuring a hostname and adding the public key
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置主机名并添加公钥
- en: Our PaaS will be routing subdomains to applications deployed with the same name.
    This means that the machine where Dokku has been set up must be visible to your
    local setup as well as to the machine where Dokku runs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的PaaS将子域路由到使用相同名称部署的应用程序。这意味着设置了Dokku的机器必须对您的本地设置以及运行Dokku的机器可见。
- en: Set up a wildcard domain that points to the Dokku host. After running the `bootstrapper`
    script, check whether the `/home/dokku/VHOST` file in the Dokku host is set to
    this domain. It will only be created if the hostname can be resolved by the dig
    tool.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个通配符域，指向Dokku主机。运行`bootstrapper`脚本后，检查Dokku主机中的`/home/dokku/VHOST`文件是否设置为此域。只有当dig工具可以解析主机名时，它才会被创建。
- en: 'In this example, I have set my Dokku hostname to `dokku.app` by adding the
    following configuration to my `/etc/hosts` file (of the local host):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我已将我的Dokku主机名设置为`dokku.app`，方法是将以下配置添加到我的本地主机的`/etc/hosts`文件中：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'I have also set up an SSH port forwarding rule in the `~/.ssh/config` file
    (of the local host):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我还在本地主机的`~/.ssh/config`文件中设置了SSH端口转发规则：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: According to Wikipedia, **Domain** **Information** **Groper** (**dig**) is a
    network administration command-line tool used to query DNS name servers. This
    means that given a URL, dig will return the IP address of the server that the
    URL points to.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，**域名信息检索器**（**dig**）是一个用于查询DNS名称服务器的网络管理命令行工具。这意味着给定一个URL，dig将返回URL指向的服务器的IP地址。
- en: If the `/home/dokku/VHOST` file hasn't been automatically created, you will
    have to manually create it and set it to your preferred domain name. If this file
    is missing when you deploy your application, Dokku will publish the application
    with a port name instead of the subdomain.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`/home/dokku/VHOST`文件没有自动创建，您将需要手动创建它并将其设置为您喜欢的域名。如果在部署应用程序时缺少此文件，Dokku将使用端口名称而不是子域名发布应用程序。
- en: 'The last thing to do is to upload your public `ssh` key to the Dokku host and
    associate it with a username. To do so, run this command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是将您的公共`ssh`密钥上传到Dokku主机并将其与用户名关联起来。要这样做，请运行此命令：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding command, replace the `dokku.app` name with your domain name
    and `shrikrishna` with your name.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，将`dokku.app`名称替换为您的域名，将`shrikrishna`替换为您的名称。
- en: Great! Now that we're up and ready, it's time to deploy our application.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在我们已经准备好了，是时候部署我们的应用程序了。
- en: Deploying an application
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: 'We now have a PaaS of our own where we can deploy our applications. Let''s
    deploy the `code.it` file there. You can also try deploying your own application
    there:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了自己的PaaS，可以在那里部署我们的应用程序。让我们在那里部署`code.it`文件。您也可以尝试在那里部署您自己的应用程序：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That's it! We now have a working application in our PaaS. For more details about
    Dokku, you can check out its GitHub repository page at [https://github.com/progrium/dokku](https://github.com/progrium/dokku).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们现在在我们的PaaS中有一个可用的应用程序。有关Dokku的更多详细信息，您可以查看其GitHub存储库页面[https://github.com/progrium/dokku](https://github.com/progrium/dokku)。
- en: If you want a production-ready PaaS, you must look up Deis at [http://deis.io/](http://deis.io/),
    which provides multi-host and multi-tenancy support.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要一个生产就绪的PaaS，您必须查找Deis [http://deis.io/](http://deis.io/)，它提供多主机和多租户支持。
- en: Setting up a highly available service
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立一个高可用的服务
- en: 'While Dokku is great to deploy occasional side projects, it may not be suitable
    for larger projects. A large-scale deployment essentially has the following requirements:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Dokku非常适合部署偶尔的副业，但对于较大的项目可能不太合适。大规模部署基本上具有以下要求：
- en: '**Horizontally** **scalable**: There is only so much that can be done with
    a single instance of a server. As the load increases, an organization on the hockey
    stick growth curve will find itself having to balance the load among a cluster
    of servers. In the earlier days, this meant having to design data centers. Today,
    this means adding more instances to the cloud.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平可扩展**：单个服务器实例只能做这么多。随着负载的增加，处于快速增长曲线上的组织将发现自己必须在一组服务器之间平衡负载。在早期，这意味着必须设计数据中心。今天，这意味着向云中添加更多实例。'
- en: '**Fault** **tolerant**: Just as road accidents occur even when there are extensive
    traffic rules in place to avoid them, crashes might occur even after you take
    extensive measures to prevent them, but a crash in one of the instances must not
    create service downtime. A well-designed architecture will handle failure conditions
    and will make another server available to take the place of the server that crashed.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容错**：即使有广泛的交通规则来避免交通事故，事故也可能发生，但即使您采取了广泛的措施来防止事故，一个实例的崩溃也不应该导致服务停机。良好设计的架构将处理故障条件，并使另一个服务器可用以取代崩溃的服务器。'
- en: '**Modular**: While this may not seem so, modularity is a defining feature of
    a large-scale deployment. A modular architecture makes it flexible and future-proof
    (because a modular architecture will accommodate newer components as the scope
    and the reach of the organization grow).'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：虽然这可能看起来不是这样，但模块化是大规模部署的一个定义特征。模块化架构使其灵活且具有未来可塑性（因为模块化架构将随着组织的范围和影响力的增长而容纳新的组件）。'
- en: This is by no means an exhaustive list, but it marks the amount of effort it
    takes to build and deploy a highly available service. However, as we have seen
    until now, Docker is used in a single host, and there are no tools available in
    it (until now) to manage a cluster of instances running Docker.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不是一个详尽的清单，但它标志着构建和部署高可用服务所需的努力。然而，正如我们到目前为止所看到的，Docker仅用于单个主机，并且（直到现在）没有可用于管理运行Docker的一组实例的工具。
- en: This is where CoreOS comes in. It is a minimal operating system built with the
    single intention of being the building block in large-scale deployments of services
    on Docker. It comes with a highly available key-value config store called `etcd`,
    which is used for configuration management and service discovery (discovering
    where each of the other components is located in the cluster). The `etcd` service
    was explored in [Chapter 4](ch04.html "Chapter 4. Automation and Best Practices"),
    *Automation and Best Practices*. It also comes with fleet, a tool that leverages
    `etcd` to provide a way to perform actions on the entire cluster as opposed to
    doing so on individual instances.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是CoreOS的用武之地。它是一个精简的操作系统，旨在成为Docker大规模部署服务的构建模块。它配备了一个高可用的键值配置存储，称为`etcd`，用于配置管理和服务发现（发现集群中其他组件的位置）。`etcd`服务在[第4章](ch04.html
    "第4章 自动化和最佳实践")中进行了探讨，*自动化和最佳实践*。它还配备了fleet，这是一个利用`etcd`提供的一种在整个集群上执行操作的工具，而不是在单个实例上执行操作。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can think of fleet as an extension of the `systemd` suite that operates
    at the cluster level instead of the machine level. The `systemd` suite is a single-machine
    init system whereas fleet is a cluster init system. You can find out more about
    fleet at [https://coreos.com/using-coreos/clustering/](https://coreos.com/using-coreos/clustering/).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将fleet视为在集群级别而不是机器级别运行的`systemd`套件的扩展。`systemd`套件是单机初始化系统，而fleet是集群初始化系统。您可以在[https://coreos.com/using-coreos/clustering/](https://coreos.com/using-coreos/clustering/)了解更多关于fleet的信息。
- en: In this section, we will try to deploy our standard example, `code.it`, on a
    three-node CoreOS cluster in our local host. This is a representative example
    and an actual multi-host deployment will take a lot more work, but this serves
    as a good starting point. It also helps us appreciate the great work that has
    been done over the years, both in terms of hardware and software, to make it possible,
    even easy, to deploy a high-availability service, a task that had until only a
    few years ago been only possible in huge data centers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试在本地主机上的三节点CoreOS集群上部署我们的标准示例`code.it`。这是一个代表性的示例，实际的多主机部署将需要更多的工作，但这是一个很好的起点。这也帮助我们欣赏多年来在硬件和软件方面所做的伟大工作，使得部署高可用服务成为可能，甚至变得容易，而这在几年前只有在大型数据中心才可能。
- en: Installing dependencies
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装依赖项
- en: 'Running the preceding example requires the following dependencies:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述示例需要以下依赖项：
- en: '**VirtualBox**: VirtualBox is a popular type of virtual machine management
    software. Installation executables for your platform can be downloaded from [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**VirtualBox**：VirtualBox是一种流行的虚拟机管理软件。您可以从[https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads)下载适用于您平台的安装可执行文件。'
- en: '**Vagrant**: Vagrant is an open source tool that can be considered a virtual
    machine equivalent for Docker. It can be downloaded from [https://www.vagrantup.com/downloads.html](https://www.vagrantup.com/downloads.html).'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Vagrant**：Vagrant是一个开源工具，可以被视为Docker的虚拟机等效物。它可以从[https://www.vagrantup.com/downloads.html](https://www.vagrantup.com/downloads.html)下载。'
- en: '**Fleetctl**: Fleet is, in short, a distributed init system, which means that
    it will allow us to manage services in a cluster level. Fleetctl is a CLI client
    to interface to run the fleet commands. To install fleetctl, run the following
    commands:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Fleetctl**：Fleet简而言之是一个分布式初始化系统，这意味着它将允许我们在集群级别管理服务。Fleetctl是一个CLI客户端，用于运行fleet命令。要安装fleetctl，请运行以下命令：'
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Getting and configuring the Vagrantfile
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取并配置Vagrantfile
- en: 'Vagrantfiles are the Vagrant equivalent of Dockerfiles. A Vagrantfile contains
    details such as the base virtual machine to get, the setup commands to run, the
    number of instances of the virtual machine image to start, and so on. CoreOS has
    a repository that contains the Vagrantfile that can be used to download and use
    CoreOS within virtual machines. This is the ideal way to try out CoreOS''s features
    in a development environment:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrantfiles是Dockerfiles的Vagrant等价物。Vagrantfile包含诸如获取基本虚拟机、运行设置命令、启动虚拟机镜像实例数量等详细信息。CoreOS有一个包含Vagrantfile的存储库，可用于下载和在虚拟机中使用CoreOS。这是在开发环境中尝试CoreOS功能的理想方式：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding command clones the `coreos-vagrant` repository, which contains
    the Vagrantfile that downloads and starts CoreOS-based virtual machines.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令克隆了包含Vagrantfile的`coreos-vagrant`存储库，该文件下载并启动基于CoreOS的虚拟机。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Vagrant is a piece of free and open source software used to create and configure
    virtual development environments. It can be seen as a wrapper around virtualization
    software such as VirtualBox, KVM, or VMware, and around configuration management
    software such as Chef, Salt, or Puppet. You can download Vagrant from [https://www.vagrantup.com/downloads.html](https://www.vagrantup.com/downloads.html).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Vagrant是一款免费开源软件，用于创建和配置虚拟开发环境。它可以被视为围绕虚拟化软件（如VirtualBox、KVM或VMware）和配置管理软件（如Chef、Salt或Puppet）的包装器。您可以从[https://www.vagrantup.com/downloads.html](https://www.vagrantup.com/downloads.html)下载Vagrant。
- en: Before starting the virtual machines though, we have some configuring to do.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在启动虚拟机之前，我们需要进行一些配置。
- en: Getting discovery tokens
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取发现令牌
- en: Each CoreOS host runs an instance of the `etcd` service to coordinate the services
    running in that machine and to communicate with services running in other machines
    in the cluster. For this to happen, the `etcd` instances themselves need to discover
    each other.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每个CoreOS主机都运行`etcd`服务的一个实例，以协调在该机器上运行的服务，并与集群中其他机器上运行的服务进行通信。为了实现这一点，`etcd`实例本身需要相互发现。
- en: 'A discovery service ([https://discovery.etcd.io](https://discovery.etcd.io))
    has been built by the CoreOS team, which provides a free service to help the `etcd`
    instances communicate with each other by storing peer information. It works by
    providing a unique token that identifies the cluster. Each `etcd` instance in
    the cluster identifies every other `etcd` instance with this token using the discovery
    service. Generating a token is easy and is done by sending a `GET` request to
    [discovery.etcd.io/new](http://discovery.etcd.io/new):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: CoreOS团队构建了一个发现服务（[https://discovery.etcd.io](https://discovery.etcd.io)），它提供了一个免费服务，帮助`etcd`实例通过存储对等信息相互通信。它通过提供一个唯一标识集群的令牌来工作。集群中的每个`etcd`实例都使用此令牌通过发现服务识别其他`etcd`实例。生成令牌很容易，只需通过`GET`请求发送到[discovery.etcd.io/new](http://discovery.etcd.io/new)即可。
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now open the file named `user-data.sample` in the `coreos-vagrant` directory
    and find the commented-out line that holds the `discovery` configuration option
    under the `etcd` service. Uncomment it and provide the token that is returned
    from the previously run `curl` command. Once this is done, rename the file to
    `user-data`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`coreos-vagrant`目录中名为`user-data.sample`的文件，并找到包含`etcd`服务下的`discovery`配置选项的注释行。取消注释并提供先前运行的`curl`命令返回的令牌。完成后，将文件重命名为`user-data`。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `user-data` file is used to set configuration parameters for the `cloud-config`
    program in CoreOS instances. Cloud-config is inspired by the `cloud-config` file
    from the `cloud-init` project, which defines itself as the DE-facto multi-distribution
    package that handles early initialization of a cloud instance (`cloud-init` docs).
    In short, it helps configure the various parameters such as ports to be opened,
    and in the case of CoreOS, the `etcd` configurations, and so on. You can find
    out more at:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`user-data`文件用于为CoreOS实例中的`cloud-config`程序设置配置参数。Cloud-config受`cloud-init`项目中的`cloud-config`文件的启发，后者定义自己为处理云实例的早期初始化的事实多发行包（`cloud-init`文档）。简而言之，它有助于配置各种参数，如要打开的端口，在CoreOS的情况下，`etcd`配置等。您可以在以下网址找到更多信息：'
- en: '[https://coreos.com/docs/cluster-management/setup/cloudinit-cloud-config/](https://coreos.com/docs/cluster-management/setup/cloudinit-cloud-config/)
    and [http://cloudinit.readthedocs.org/en/latest/index.html](http://cloudinit.readthedocs.org/en/latest/index.html).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://coreos.com/docs/cluster-management/setup/cloudinit-cloud-config/](https://coreos.com/docs/cluster-management/setup/cloudinit-cloud-config/)和[http://cloudinit.readthedocs.org/en/latest/index.html](http://cloudinit.readthedocs.org/en/latest/index.html)。'
- en: 'The following is an example of the code of CoreOS:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是CoreOS代码的示例：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You will have to generate a new token each time you run the cluster. Simply
    reusing the token will not work.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行集群时，您都需要生成一个新的令牌。简单地重用令牌将不起作用。
- en: Setting the number of instances
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置实例数量
- en: In the `coreos-vagrant` directory, there is another file called `config.rb.sample`.
    Find the commented line in this file that reads `$num_instances=1`. Uncomment
    it and set the value to `3`. This will make Vagrant spawn three instances of CoreOS.
    Now save the file as `config.rb`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`coreos-vagrant`目录中，还有另一个名为`config.rb.sample`的文件。找到该文件中的注释行，其中写着`$num_instances=1`。取消注释并将值设置为`3`。这将使Vagrant生成三个CoreOS实例。现在将文件保存为`config.rb`。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `cnfig.rb` file holds the configurations for the Vagrant environment and
    the number of machines in the cluster.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`cnfig.rb`文件保存了Vagrant环境的配置以及集群中的机器数量。'
- en: 'The following is the code example for Vagrant instances:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Vagrant实例的代码示例：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Spawning instances and verifying health
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成实例并验证健康
- en: 'Now that we have the configurations ready, it''s time to see a cluster running
    in your local machine:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好配置，是时候在本地机器上看到一个运行的集群了：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After the machines are created, you can SSH into them to try out the following
    commands, but you will need to add `ssh` keys to your SSH agent. Doing so will
    allow you to forward your SSH session to other nodes in the cluster. To add the
    keys, run the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完机器后，您可以SSH登录到它们，尝试以下命令，但您需要将`ssh`密钥添加到您的SSH代理中。这样做将允许您将SSH会话转发到集群中的其他节点。要添加密钥，请运行以下命令：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now let''s verify that the machines are up and ask fleet to list the machines
    running in the cluster:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们验证一下机器是否正常运行，并要求fleet列出集群中正在运行的机器：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Starting the service
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动服务
- en: To run a service in your newly started cluster, you will have to write the `unit-files`
    files. Unit files are configuration files that list the services that must be
    run in each machine and some rules on how to manage these services.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要在新启动的集群中运行服务，您将需要编写`unit-files`文件。单元文件是列出必须在每台机器上运行的服务以及如何管理这些服务的一些规则的配置文件。
- en: 'Create three files named `code.it.1.service`, `code.it.2.service`, and `code.it.3.service`.
    Populate them with the following configurations:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 创建三个名为`code.it.1.service`、`code.it.2.service`和`code.it.3.service`的文件。用以下配置填充它们：
- en: '`code.it.1.service`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`code.it.1.service`'
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`code.it.2.service`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`code.it.2.service`'
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`code.it.3.service`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`code.it.3.service`'
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You might have noticed a pattern in these files. The `ExecStart` parameter holds
    the command that must be executed in order to start the service. In our case,
    this means running the `code.it` container. `ExecStartPost` is the command that
    is executed once the `ExecStart` parameter succeeds. In our case, the service's
    availability is registered in the `etcd` service. Conversely, the `ExecStop` command
    will stop the service, and the `ExecStopPost` command executes once the `ExecStop`
    command succeeds, which in this case means removing the service's availability
    from the `etcd` service.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到这些文件中的模式。`ExecStart`参数保存了必须执行的命令，以启动服务。在我们的情况下，这意味着运行`code.it`容器。`ExecStartPost`是在`ExecStart`参数成功后执行的命令。在我们的情况下，服务的可用性被注册在`etcd`服务中。相反，`ExecStop`命令将停止服务，而`ExecStopPost`命令在`ExecStop`命令成功后执行，这在这种情况下意味着从`etcd`服务中删除服务的可用性。
- en: '`X-Fleet` is a CoreOS-specific syntax that tells fleet that two services cannot
    run on the same machine (as they would conflict while trying to bind to the same
    port). Now that all the blocks are in place, it''s time to submit the jobs to
    the cluster:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`X-Fleet`是CoreOS特有的语法，告诉fleet两个服务不能在同一台机器上运行（因为它们在尝试绑定到相同端口时会发生冲突）。现在所有的块都就位了，是时候将作业提交到集群了：'
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s verify that the services have been submitted to the cluster:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证服务是否已提交到集群：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The machine column is empty and the active status is not set. This means our
    services haven''t started yet. Let''s start them:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 机器列为空，活动状态未设置。这意味着我们的服务尚未启动。让我们启动它们：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s verify that they are running by executing the `$ fleetctl list-units`
    file again:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过再次执行`$ fleetctl list-units`文件来验证它们是否正在运行：
- en: '[PRE32]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Congratulations! You have just set up your very own cluster! Now head over to
    `172.17.8.101`, `172.17.8.102`, or `172.17.8.103` in a web browser and see the
    `code.it` application running!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚建立了自己的集群！现在在Web浏览器中转到`172.17.8.101`、`172.17.8.102`或`172.17.8.103`，看看`code.it`应用程序正在运行！
- en: We have only set up a cluster of machines running a highly available service
    in this example. If we add a load balancer that maintains a connection with the
    `etcd` service to route requests to available machines, we will have a complete
    end-to-end production level service running in our systems. But doing so would
    veer off the topic, so is left as an exercise for you.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是建立了一个运行高可用服务的机器集群。如果我们添加一个负载均衡器，它与`etcd`服务保持连接，将请求路由到可用的机器，我们将在我们的系统中运行一个完整的端到端生产级服务。但这样做会偏离主题，所以留给你作为练习。
- en: With this, we come to the end. Docker is still under active development, and
    so are the projects like CoreOS, Deis, Flynn, and so on. So, although we have
    seen great stuff coming out over the past few months, what is coming is going
    to be even better. We are living in exciting times. So, let's make the best of
    it and build stuff that makes this world a better place to live in. Happy shipping!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我们来到了尽头。Docker仍在积极发展，像CoreOS、Deis、Flynn等项目也是如此。因此，尽管我们在过去几个月看到了很棒的东西，但即将到来的将会更好。我们生活在激动人心的时代。因此，让我们充分利用它，构建能让这个世界变得更美好的东西。祝愉快！
- en: Summary
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use Docker with Chef and Puppet. Then we
    set up an apt-cacher to speed up package downloads. Next, we set up our own mini
    PaaS with Dokku. In the end, we set up a high-availability service using CoreOS
    and Fleet. Congratulations! Together, we have gained the necessary knowledge of
    Docker to build our containers, "dockerize" our applications and even run clusters.
    Our journey ends here. But for you, dear reader, a new journey has just begun.
    This book was meant to lay the groundwork to help you build the next big thing
    using Docker. I wish you all the success in the world. If you liked this book,
    give me a hoot at `@srikrishnaholla` on Twitter. If you didn't like it, let me
    know how I can make it better.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Docker与Chef和Puppet。然后我们设置了一个apt-cacher来加快软件包的下载速度。接下来，我们用Dokku搭建了自己的迷你PaaS。最后，我们使用CoreOS和Fleet搭建了一个高可用性的服务。恭喜！我们一起获得了使用Docker构建容器、"dockerize"我们的应用甚至运行集群所需的知识。我们的旅程到此结束了。但是对于你，亲爱的读者，一个新的旅程刚刚开始。这本书旨在奠定基础，帮助你使用Docker构建下一个大事件。我祝你世界上一切成功。如果你喜欢这本书，在Twitter上给我发消息`@srikrishnaholla`。如果你不喜欢，也请告诉我如何改进。
