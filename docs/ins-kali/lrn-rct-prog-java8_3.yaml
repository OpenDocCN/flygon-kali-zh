- en: Chapter 3. Creating and Connecting Observables, Observers, and Subjects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。创建和连接 Observables、Observers 和 Subjects
- en: RxJava's `Observable` instances are the building blocks of reactive applications,
    and this advantage of RxJava is beneficial. If we have a source `Observable` instance,
    we could chain logic to it and *subscribe* for the result. All we need is this
    initial `Observable` instance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava 的 `Observable` 实例是响应式应用程序的构建模块，这是 RxJava 的优势。如果我们有一个源 `Observable` 实例，我们可以将逻辑链接到它并订阅结果。我们只需要这个初始的
    `Observable` 实例。
- en: In the browser or in a desktop application, user input is already represented
    by events that we can handle and forward through `Observable` instances. But it
    would be great to turn all of our data changes or actions into `Observable` instances,
    not just user input. For example, when we read data from a file, it would be neat
    to look at every line read or every sequence of bytes as a message that can be
    emitted through an `Observable` instance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器或桌面应用程序中，用户输入已经被表示为我们可以处理并通过 `Observable` 实例转发的事件。但是将所有数据更改或操作转换为 `Observable`
    实例会很好，而不仅仅是用户输入。例如，当我们从文件中读取数据时，将每一行读取或每个字节序列视为可以通过 `Observable` 实例发出的消息将会很好。
- en: We'll look in detail at how different data sources can be transformed into `Observable`
    instances; it doesn't matter if they are external (files or user input) or internal
    (collections or scalars). What's more, we'll learn about the various types of
    `Observable` instances, depending on their behavior. Another important thing that
    we'll learn is how and when to unsubscribe from `Observable` instances and how
    to use subscriptions and `Observer` instances. Additionally, we'll present Subject
    type and its usage.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细了解如何将不同的数据源转换为 `Observable` 实例；无论它们是外部的（文件或用户输入）还是内部的（集合或标量）都无关紧要。此外，我们将了解各种类型的
    `Observable` 实例，取决于它们的行为。另一个重要的是我们将学习如何何时取消订阅 `Observable` 实例以及如何使用订阅和 `Observer`
    实例。此外，我们还将介绍 Subject 类型及其用法。
- en: 'In this chapter, we will learn about:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: '`Observable` factory methods—`just`, `from`, `create`, and others'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable` 工厂方法——`just`、`from`、`create` 等'
- en: Observers and subscribers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者和订阅者
- en: Hot and cold observables; connectable observables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热和冷 Observable；可连接的 Observable
- en: What subjects are and when to use them
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题是什么以及何时使用它们
- en: '`Observable` creation'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable` 创建'
- en: There are a lot of ways to create `Observable` instances from different sources.
    In principle, an `Observable` instance could be created using the `Observable.create(OnSubscribe<T>)`
    method, but there are many simple methods, implemented with the idea of making
    our life better. Let's look at some of them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多种方法可以从不同的来源创建 `Observable` 实例。原则上，可以使用 `Observable.create(OnSubscribe<T>)`
    方法创建 `Observable` 实例，但是有许多简单的方法，旨在让我们的生活更美好。让我们来看看其中一些。
- en: The Observable.from method
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable.from 方法
- en: 'The `Observable.from` method can create an `Observable` instance from different
    Java structures. For example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.from` 方法可以从不同的 Java 结构创建 `Observable` 实例。例如：'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This piece of code creates an `Observable` instance from a `List` instance.
    When the `subscribe` method is called on the `Observable` instance, all of the
    elements contained in the source list are emitted to the subscribing method. For
    every call to the `subscribe()` method, the whole collection is emitted from the
    beginning, element by element:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从 `List` 实例创建了一个 `Observable` 实例。当在 `Observable` 实例上调用 `subscribe` 方法时，源列表中包含的所有元素都将被发射到订阅方法中。对于每次调用
    `subscribe()` 方法，整个集合都会从头开始逐个元素发射：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will print the colors twice with different formatting.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以不同的格式两次打印颜色。
- en: 'The true signature of this version of the `from` method is `final static <T>
    Observable<T> from(Iterable<? extends T> iterable)`. This means that an instance
    from any class, implementing the `Iterable` interface can be passed to this method.
    These include any Java collection, for example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 `from` 方法的真正签名是 `final static <T> Observable<T> from(Iterable<? extends
    T> iterable)`。这意味着可以将实现 `Iterable` 接口的任何类的实例传递给这个方法。这些包括任何 Java 集合，例如：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This turns the contents of a folder to events to which we can subscribe. That's
    possible because the `DirectoryStream` parameter is an `Iterable` instance. Note
    that on every call to the `subscribe` method of this `Observable` instance, its
    `Iterable` source's `iterator()` method is called to obtain a new `Iterator` instance
    to be used to traverse the data from the beginning. With this example, a `java.lang.IllegalStateException`
    exception will be thrown on the second call to the `subscribe()` method, because
    the `iterator()` method of the `DirectoryStream` parameter can be called only
    once.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把文件夹的内容转换为我们可以订阅的事件。这是可能的，因为 `DirectoryStream` 参数是一个 `Iterable` 实例。请注意，对于此
    `Observable` 实例的每次调用 `subscribe` 方法，它的 `Iterable` 源的 `iterator()` 方法都会被调用以获取一个新的
    `Iterator` 实例，用于从头开始遍历数据。使用此示例，第二次调用 `subscribe()` 方法时将抛出 `java.lang.IllegalStateException`
    异常，因为 `DirectoryStream` 参数的 `iterator()` 方法只能被调用一次。
- en: 'Another overload of the `from` method used to create `Observable` instances
    from arrays is `public final static <T> Observable<T> from(T[] array)`, and an
    example of using `Observable` instances is as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从数组创建 `Observable` 实例的 `from` 方法的另一个重载是 `public final static <T> Observable<T>
    from(T[] array)`，使用 `Observable` 实例的示例如下：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Observable.from()` method is very useful for creating the `Observable`
    instances from collections or arrays. But there are cases when we need to create
    the `Observable` instance from a single object; for these, the `Observable.just()`
    method can be used.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.from()` 方法非常有用，可以从集合或数组创建 `Observable` 实例。但是有些情况下，我们需要从单个对象创建 `Observable`
    实例；对于这些情况，可以使用 `Observable.just()` 方法。'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for the examples of using the `Observable.from()` method can
    be viewed and downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesWithFrom.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesWithFrom.java).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Observable.from()`方法的示例的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesWithFrom.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesWithFrom.java)中查看和下载。
- en: The Observable.just method
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable.just方法
- en: The `just()` method emits its parameter(s) as `OnNext` notifications, and after
    that, it emits an `OnCompleted` notification.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`just()`方法将其参数作为`OnNext`通知发出，然后发出`OnCompleted`通知。'
- en: 'For example, one letter:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个字母：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or a sequence of letters:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 或者一系列字母：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first piece of code prints `S` and a new line, and the second prints the
    letters on a single line and adds a new line on completion. The method allows
    up to nine arbitrary values (objects of the same type) to be observed through
    reactive means. For example, say we have this simple `User` class:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段代码打印`S`和一个换行，第二段代码打印字母并在完成时添加一个换行。该方法允许通过响应式手段观察最多九个任意值（相同类型的对象）。例如，假设我们有这个简单的`User`类：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can print the full name of a `User` instance like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样打印`User`实例的全名：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is not very practical but showcases putting data in the `Observable` instance
    context and taking advantage of the `map()` method. Everything can become an event.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是非常实用，但展示了将数据放入`Observable`实例上下文并利用`map()`方法的方法。一切都可以成为一个事件。
- en: There are a few more convenient factory methods, usable in all kinds of situations.
    Let's take a look at them in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些更方便的工厂方法，可在各种情况下使用。让我们在下一节中看看它们。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code of the example of the `Observable.just()` method can be viewed/downloaded
    at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesUsingJust.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesUsingJust.java).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.just()`方法示例的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesUsingJust.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesUsingJust.java)中查看/下载。'
- en: Other Observable factory methods
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Observable工厂方法
- en: Here, we will inspect a few methods that can be used in combination with transforming
    operators such as flatMap or combining operators such as `.zip` file (more about
    this in the next chapter).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将检查一些可以与转换操作符（如flatMap）或组合操作符（如`.zip`文件）结合使用的方法（有关更多信息，请参见下一章）。
- en: 'In order to examine their results, we will use the following method for creating
    subscriptions:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查它们的结果，我们将使用以下方法创建订阅：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The idea of the preceding method is to *subscribe* to an `Observable` instance
    and label it with a name. On *OnNext*, it prints the value prefixed with the name;
    on *OnError*, it prints the error together with the name; and on *OnCompleted*,
    it prints `'ended!'` prefixed with the name. This helps us debug the results.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的想法是*订阅*一个`Observable`实例并用名称标记它。在*OnNext*时，它打印带有名称前缀的值；在*OnError*时，它与名称一起打印错误；在*OnCompleted*时，它打印带有名称前缀的`'ended!'`。这有助于我们调试结果。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code of the preceding method can be found at [https://github.com/meddle0x53/learning-rxjava/blob/4a2598aa0835235e6ef3bc3371a3c19896161628/src/main/java/com/packtpub/reactive/common/Helpers.java#L25](https://github.com/meddle0x53/learning-rxjava/blob/4a2598aa0835235e6ef3bc3371a3c19896161628/src/main/java/com/packtpub/reactive/common/Helpers.java#L25).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 前面方法的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/4a2598aa0835235e6ef3bc3371a3c19896161628/src/main/java/com/packtpub/reactive/common/Helpers.java#L25](https://github.com/meddle0x53/learning-rxjava/blob/4a2598aa0835235e6ef3bc3371a3c19896161628/src/main/java/com/packtpub/reactive/common/Helpers.java#L25)找到。
- en: 'Here is the code introducing the new factory methods:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是介绍新工厂方法的代码：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s what''s happening in the code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码中发生的情况：
- en: '`Observable<Long> Observable.interval(long, TimeUnit, [Scheduler])`: This method
    creates an `Observable` instance that will emit sequential numbers at given intervals.
    It can be used to implement periodic polling, or continuous status logging, by
    just ignoring the number emitted and emitting useful messages. What''s special
    about this method is that it''s running on a *computation thread* by default.
    We can change that by passing a third argument to the method—a `Scheduler` instance
    (more about `Scheduler` instances in [Chapter 6](ch06.html "Chapter 6. Using Concurrency
    and Parallelism with Schedulers"), *Using Concurrency and Parallelism with Schedulers*).'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable<Long> Observable.interval(long, TimeUnit, [Scheduler])`：此方法创建一个`Observable`实例，将以给定间隔发出顺序数字。它可用于实现周期性轮询，或通过仅忽略发出的数字并发出有用消息来实现连续状态记录。该方法的特殊之处在于，默认情况下在*计算线程*上运行。我们可以通过向方法传递第三个参数——`Scheduler`实例（有关`Scheduler`实例的更多信息，请参见[第6章](ch06.html
    "第6章。使用调度程序进行并发和并行处理"), *使用调度程序进行并发和并行处理*）来更改这一点。'
- en: '`Observable<Long> Observable.timer(long, long, TimeUnit, [Scheduler])`: The
    `interval()` method begins emitting numbers only after it has waited for the specified
    time interval to pass. What if we want to tell it at what time exactly to begin
    working? We can do this using this `timer()` method. Its first argument is the
    starting time, and the second and the third are for interval setup. Again, it
    is executed on the *computation thread* by default, and again, this is configurable.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable<Long> Observable.timer(long, long, TimeUnit, [Scheduler])`：`interval()`方法仅在等待指定时间间隔后开始发出数字。如果我们想要告诉它在何时开始工作，可以使用此`timer()`方法。它的第一个参数是开始时间，第二个和第三个是间隔设置。同样，默认情况下在*计算线程*上执行，同样，这是可配置的。'
- en: '`Observable<Long> Observable.timer(long, TimeUnit, [Scheduler])`: This one
    just emits the output `''0''` after a given amount of time on the *computation
    thread* (by default). After that, it emits a *completed* notification.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable<Long> Observable.timer(long, TimeUnit, [Scheduler])`：这个在*计算线程*（默认情况下）上在一定时间后只发出输出`''0''`。之后，它发出一个*completed*通知。'
- en: '`<T> Observable<T> Observable.error(Throwable)`: This emits just the error
    passed to it as an *OnError* notification. This is similar to the ''`throw`''
    keyword in the classical, imperative Java world.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<T> Observable<T> Observable.error(Throwable)`：这只会将传递给它的错误作为*OnError*通知发出。这类似于经典的命令式Java世界中的`throw`关键字。'
- en: '`<T> Observable<T> Observable.empty()`: This one emits no items, but it emits
    a `OnCompleted` notification immediately.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<T> Observable<T> Observable.empty()`：这个不发出任何项目，但立即发出一个`OnCompleted`通知。'
- en: '`<T> Observable<T> Observable.never()`: This does nothing. It sends no notifications
    to its `Observer` instances, and even the `OnCompleted` notification is not sent.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<T> Observable<T> Observable.never()`：这个什么都不做。它不向其`Observer`实例发送任何通知，甚至`OnCompleted`通知也不发送。'
- en: '`Observable<Integer>` `Observable.range(int, int, [Scheduler])`: This method
    sends sequential numbers beginning with the first parameter passed. The second
    parameter is the number of the emissions.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable<Integer>` `Observable.range(int, int, [Scheduler])`：此方法从传递的第一个参数开始发送顺序数字。第二个参数是发射的数量。'
- en: 'This program will print the following output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序将打印以下输出：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the `interval Observable` instance doesn't send the *OnCompleted*
    notification. The program ends after two seconds and the `interval Observable`
    instance begins emitting after 500 milliseconds, every 500 milliseconds; thus,
    it emits three *OnNext* notifications. The `timed interval Observable` instance
    begins emitting immediately after its creation and emits every second; thus, we've
    got two notifications from it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`interval Observable`实例不会发送*OnCompleted*通知。程序在两秒后结束，`interval Observable`实例在500毫秒后开始发出，每500毫秒发出一次；因此，它发出了三个*OnNext*通知。`timed
    interval Observable`实例在创建后立即开始发出，每秒发出一次；因此，我们从中得到了两个通知。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code of the preceding example can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesUsingVariousFactoryMethods.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesUsingVariousFactoryMethods.java).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesUsingVariousFactoryMethods.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/CreatingObservablesUsingVariousFactoryMethods.java)上查看/下载。
- en: All of these methods are implemented using the `Observable.create()` method.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都是使用`Observable.create()`方法实现的。
- en: The Observable.create method
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Observable.create方法
- en: 'Let''s look at the signature of the method first:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下该方法的签名：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It takes a parameter of type `OnSubscribe`. This interface extends the `Action1<Subscriber<?
    super T>>` interface; in other words, this type has only one method, taking one
    argument of type `Subscriber<T>` and returning nothing. This function will be
    called every time the `Observable.subscribe()` method is invoked. Its argument,
    an instance of the `Subscriber` class, is in fact the observer, subscribing to
    the `Observable` instance (here, the `Subscriber` class and Observer interface
    have the same role). We'll be talking about them later in this chapter). We can
    invoke the `onNext()`, `onError()`, and `onCompleted()` methods on it, implementing
    our own custom behavior.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个`OnSubscribe`类型的参数。这个接口扩展了`Action1<Subscriber<? super T>>`接口；换句话说，这种类型只有一个方法，接受一个`Subscriber<T>`类型的参数并返回空。每次调用`Observable.subscribe()`方法时，都会调用此函数。它的参数，`Subscriber`类的一个实例，实际上是观察者，订阅`Observable`实例（这里，`Subscriber`类和Observer接口扮演相同的角色）。我们将在本章后面讨论它们。我们可以在其上调用`onNext()`、`onError()`和`onCompleted()`方法，实现我们自己的自定义行为。
- en: 'It''s easier to comprehend this with an example. Let''s implement a simple
    version of the `Observable.from(Iterabale<T>)` method:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个例子更容易理解。让我们实现`Observable.from(Iterabale<T>)`方法的一个简单版本：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The method takes an `Iterable<T>` parameter as an argument and returns an `Observable<T>`
    parameter. The behavior is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法以一个`Iterable<T>`参数作为参数，并返回一个`Observable<T>`参数。行为如下：
- en: When an `Observer/Subscriber` instance subscribes to the resulting `Observable`
    instance, an `Iterator` instance is retrieved from the `Iterable` source. The
    `Subscriber` class actually implements the `Observer` interface. It is an abstract
    class, and the `on*` methods are not implemented by it.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一个`Observer/Subscriber`实例订阅生成的`Observable`实例时，会从`Iterable`源中检索一个`Iterator`实例。`Subscriber`类实际上实现了`Observer`接口。它是一个抽象类，`on*`方法不是由它实现的。
- en: While there are elements, they are emitted as `OnNext` notifications.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当有元素时，它们作为`OnNext`通知被发送。
- en: And when all the elements are emitted, an `OnCompleted` notification is dispatched.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当所有元素都被发出时，将发送一个`OnCompleted`通知。
- en: If at any time an error occurs, an `OnError` notification is dispatched with
    the error.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在任何时候发生错误，将会发送一个`OnError`通知与错误。
- en: This is a very simple and naive implementation of the behavior of the `Observable.from(Iterable<T>)`
    method. The Reactive Sum described in the first and second chapters is another
    example of the power of the `Observable.create` method (used by `CreateObservable.from()`).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Observable.from(Iterable<T>)`方法行为的一个非常简单和天真的实现。第一章和第二章中描述的Reactive Sum是`Observable.create`方法的另一个例子（由`CreateObservable.from()`使用）。
- en: But as we saw, the logic passed to the `create()` method is triggered when the
    `Observable.subscribe()` method is invoked on the `Observable` instance. Until
    now, we were creating `Observable` instances and *subscribing* to them with this
    method. It is time to look at it in detail.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如我们所看到的，传递给`create()`方法的逻辑是在`Observable.subscribe()`方法在`Observable`实例上被调用时触发的。到目前为止，我们一直在创建`Observable`实例并使用这种方法*订阅*它们。现在是时候仔细看一下了。
- en: Subscribing and unsubscribing
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订阅和取消订阅
- en: 'The `Observable.subscribe()` method has many overloads as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Observable.subscribe()方法有许多重载，如下所示：
- en: '`subscribe()`: This one ignores all the emissions from the `Observable` instance
    and throws an `OnErrorNotImplementedException` exception if there is an `OnError`
    notification. This can be used to only trigger the `OnSubscribe.call` behavior.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe()`: 这个方法忽略来自Observable实例的所有发射，并且如果有OnError通知，则抛出一个OnErrorNotImplementedException异常。这可以用来触发`OnSubscribe.call`行为。'
- en: '`subscribe(Action1<? super T>)`: This only subscribes to `onNext()` method-triggered
    updates. It ignores the `OnCompleted` notification and throws an `OnErrorNotImplementedException`
    exception if there is an `OnError` notification. It is not a good choice for real
    production code, because it is hard to guarantee that no errors will be thrown.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe(Action1<? super T>)`: 这只订阅`onNext()`方法触发的更新。它忽略`OnCompleted`通知，并且如果有`OnError`通知，则抛出一个OnErrorNotImplementedException异常。这不是真正的生产代码的好选择，因为很难保证不会抛出错误。'
- en: '`subscribe(Action1<? super T>, Action1<Throwable>)`: This is the same as preceding
    one, but the second parameter is called if there is an `OnError` notification.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe(Action1<? super T>, Action1<Throwable>)`: 这与前一个方法相同，但如果有`OnError`通知，则调用第二个参数。'
- en: '`subscribe(Action1<? super T>,Action1<Throwable>, Action0)`: This is the same
    as the preceding one, but the third parameter is called on `OnCompleted` notification.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe(Action1<? super T>,Action1<Throwable>, Action0)`: 这与前一个方法相同，但第三个参数在`OnCompleted`通知时被调用。'
- en: '`subscribe(Observer<? super T>)`: This uses its `Observer` parameter''s `onNext/onError/onCompleted`
    methods to observe the notifications from the `Observable` instance. We used this
    in the first chapter while implementing "The Reactive Sum".'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe(Observer<? super T>)`: 这使用其Observer参数的`onNext/onError/onCompleted`方法来观察Observable实例发出的通知。我们在第一章中实现"响应式求和"时使用了这个方法。'
- en: '`subscribe(Subscriber<? super T>)`: This is the same as the preceding one,
    but the `Subscriber` implementation of the `Observer` interface is used to observe
    notifications. The `Subscriber` class provides advanced functionality, such as
    unsubscription (cancellation) and backpressure (flow control). Actually, all the
    preceding methods call this one; that''s why we will be referring to it when talking
    about `Observable.subscribe` from now on. The method ensures that the `Subscriber`
    instance passed sees an `Observable` instance, complying with the following **Rx
    contract**:'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe(Subscriber<? super T>)`: 这与前一个方法相同，但使用Observer接口的Subscriber实现来观察通知。Subscriber类提供了高级功能，如取消订阅（取消）和背压（流量控制）。实际上，所有前面的方法都调用这个方法；这就是为什么我们从现在开始谈论`Observable.subscribe`时将引用它。该方法确保传递的Subscriber实例看到一个Observable实例，符合以下**Rx
    contract**：'
- en: '*"Messages sent to instances of the Observer interface follow the following
    syntax:*'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"发送到Observer接口实例的消息遵循以下语法：*'
- en: '>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*onNext* (onCompleted | onError)?*'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*onNext* (onCompleted | onError)?*'
- en: '>'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*This syntax allows observable sequences to send any number (0 or more) of
    `OnNext()` method messages to the Subscriber, optionally followed by a single
    success (`onCompleted`) or failure (`onError`) message. The single message indicating
    that an observable sequence has finished ensures that consumers of the observable
    sequence can deterministically establish that it is safe to perform cleanup operations.
    A single failure further ensures that abort semantics can be maintained for operators
    that work on multiple observable sequences".*'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这种语法允许可观察序列向Subscriber发送任意数量（0个或更多个）的`OnNext()`方法消息，可选地跟随单个成功（`onCompleted`）或失败（`onError`）消息。指示可观察序列已完成的单个消息确保可观察序列的消费者可以确定地建立安全执行清理操作。单个失败进一步确保可以维护对多个可观察序列进行操作的操作符的中止语义。*'
- en: – part of RxJava's JavaDoc.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '- RxJava的JavaDoc的一部分。'
- en: This is done internally by using a wrapper around the passed `Subscriber` instance—`SafeSubscriber`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过在传递的Subscriber实例周围使用一个包装器——SafeSubscriber来内部完成的。
- en: '`unsafeSubscribe(Subscriber<? super T>)`: This is the same as the preceding
    one but without the **Rx contract** protection. It is meant to help implement
    custom operators (see [Chapter 8](ch08.html "Chapter 8. Resource Management and
    Extending RxJava"), *Resource Management and Extending RxJava*) without the additional
    overhead of the `subscribe()` method''s protections; using this method to observe
    an `Observable` instance in general code is discouraged.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unsafeSubscribe(Subscriber<? super T>)`: 这与前一个方法相同，但没有**Rx contract**保护。它旨在帮助实现自定义操作符（参见[第8章](ch08.html
    "第8章。资源管理和扩展RxJava")，“资源管理和扩展RxJava”），而不会增加`subscribe()`方法的额外开销；在一般代码中使用这种方法观察Observable实例是不鼓励的。'
- en: All of these methods return results of type `Subscription` that can be used
    for *unsubscribing* from the notifications emitted by the `Observable` instance.
    Unsubscribing usually cleans up internal resources associated with a subscription;
    for example, if we implement an HTTP request with the `Observable.create()` method
    and want to cancel it by a particular time, or we have an `Observable` instance
    emitting a sequence of numbers/words/arbitrary data infinitely and want to stop
    that.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法返回Subscription类型的结果，可以用于从Observable实例发出的通知中*取消订阅*。取消订阅通常会清理与订阅相关的内部资源；例如，如果我们使用`Observable.create()`方法实现一个HTTP请求，并希望在特定时间取消它，或者我们有一个发射无限序列的数字/单词/任意数据的Observable实例，并希望停止它。
- en: 'The `Subscription` interface has two methods:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Subscription接口有两个方法：
- en: '`void unsubscribe()`: This is used for *unsubscribing*.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void unsubscribe()`: 这用于*取消订阅*。'
- en: '`boolean isUnsubscribed()`: This is used to check whether the `Subscription`
    instance is already *unsubscribed*.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boolean isUnsubscribed()`: 这用于检查Subscription实例是否已经*取消订阅*。'
- en: 'The instance of the `Subscriber` class, passed to the `Observable.create()`
    method''s `OnSubscribe()` method, implements the `Subscription` interface. So,
    while coding the behavior of the `Observable` instance, *unsubscribing* and checking
    whether `Subscriber` is subscribed can be done. Let''s update our `Observable<T>
    fromIterable(Iterable<T>)` method implementation to react on *unsubscribing*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`Observable.create()`方法的`OnSubscribe()`方法的`Subscriber`类的实例实现了`Subscription`接口。因此，在编写`Observable`实例的行为时，可以进行*取消订阅*和检查`Subscriber`是否已订阅。让我们更新我们的`Observable<T>
    fromIterable(Iterable<T>)`方法的实现以对*取消订阅*做出反应：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The new thing here is that the `Subscription.isUnsubscribed()` method is used
    to determine whether the data emission should be terminated. We check whether
    the `Subscriber` is already *unsubscribed* on every iteration, because it can
    *unsubscribe* at any time and we won't need to emit anything after that. After
    everything is emitted, if the Subscriber is already *unsubscribed*, the `onCompleted()`
    method is skipped. If there is an exception , it is only emitted as an `OnError`
    notification if the `Subscriber` instance is still *subscribed*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 新的地方在于`Subscription.isUnsubscribed()`方法用于确定是否应终止数据发射。我们在每次迭代时检查`Subscriber`是否已*取消订阅*，因为它可以随时*取消订阅*，之后我们将不需要再发出任何内容。在发出所有内容之后，如果Subscriber已经*取消订阅*，则会跳过`onCompleted()`方法。如果有异常，则只有在`Subscriber`实例仍然*订阅*时才会作为`OnError`通知发出。
- en: 'Let''s look at how *unsubscribing* works:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看*取消订阅*是如何工作的：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here''s what''s happening in this example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个例子中发生的事情：
- en: The data source is a huge file because we need something that takes some time
    to be iterated.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据源是一个巨大的文件，因为我们需要一些需要一些时间来迭代的东西。
- en: All the subscriptions to the `Observable` instance will take place on another
    *thread* because we will want to *unsubscribe* on the main thread.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Observable`实例的所有订阅将在另一个*线程*上进行，因为我们希望在主线程上*取消订阅*。'
- en: The `subscribePrint()` method defined in this chapter is used, but it is modified
    to return the `Subscription`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本章中定义的`subscribePrint()`方法被使用，但已修改为返回`Subscription`。
- en: The subscription is used to *unsubscribe* from the `Observable` instance, so
    the whole file won't be printed and there are markers showing when the *unsubscription*
    is executed.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 订阅用于从`Observable`实例*取消订阅*，因此整个文件不会被打印，并且会显示*取消订阅*执行的标记。
- en: 'The output will be something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于这样：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So most of the file's content is skipped. Note that it is possible for something
    to be emitted right after *unsubscribing*; for example, if the `Subscriber` instance
    *unsubscribes* right after the check for *unsubscribing* and the program is already
    executing the body of the `if` statement, checking whether the user is unsubscribed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分文件内容被跳过。请注意，可能会在*取消订阅*后立即发出某些内容；例如，如果`Subscriber`实例在检查*取消订阅*后立即*取消订阅*，并且程序已经执行`if`语句的主体，则会发出内容。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code of the preceding example can be downloaded/viewed at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/ObservableCreateExample.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/ObservableCreateExample.java).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/ObservableCreateExample.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/ObservableCreateExample.java)中下载/查看。
- en: Another thing to note is that the `Subscriber` instances have a `void add(Subscription
    s)` method. Every subscription passed to it will be automatically *unsubscribed*
    when the `Subscriber` is *unsubscribed*. This way, we can add additional actions
    to the `Subscriber` instance; for example, actions that should be executed at
    *unsubscribing* (similar to the try—finally construction in Java). This is how
    *unsubscribing* works. In [Chapter 8](ch08.html "Chapter 8. Resource Management
    and Extending RxJava"), *Resource Management and Extending RxJava*, we'll be dealing
    with resource management. We'll learn how `Observable` instances can be attached
    to `Subscriber` instances through a `Subscription` wrapper, and how calling *unsubscribe*
    will release any allocated resources.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的一点是，`Subscriber`实例有一个`void add(Subscription s)`方法。当`Subscriber`*取消订阅*时，传递给它的每个订阅将自动*取消订阅*。这样，我们可以向`Subscriber`实例添加额外的操作；例如，在*取消订阅*时应执行的操作（类似于Java中的try-finally结构）。这就是*取消订阅*的工作原理。在[第8章](ch08.html
    "第8章。资源管理和扩展RxJava")中，我们将处理资源管理。我们将学习如何通过`Subscription`包装器将`Observable`实例附加到`Subscriber`实例，并且调用*取消订阅*将释放任何分配的资源。
- en: The next topic we'll be covering in this chapter is related to subscribing behavior.
    We will be talking about hot and cold `Observable` instances.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论与订阅行为相关的下一个主题。我们将谈论热和冷的`Observable`实例。
- en: Hot and cold Observable instances
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 热和冷的Observable实例
- en: Looking at the previous examples implemented using the `Observable.create()`,
    `Observable.just()`, and `Observable.from()` methods, we can say that until someone
    subscribes to them, they are inactive and don't emit anything. However, each time
    someone subscribes, they start emitting their notifications. For example, if we
    subscribe three times to an `Observable.from(Iterable)` object, the `Iterable`
    instance will be iterated *three* times. The `Observable` instances behaving like
    that are called cold Observable instances.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 查看使用`Observable.create()`、`Observable.just()`和`Observable.from()`方法实现的先前示例时，我们可以说在有人订阅它们之前，它们是不活动的，不会发出任何内容。但是，每次有人订阅时，它们就开始发出它们的通知。例如，如果我们对`Observable.from(Iterable)`对象进行三次订阅，`Iterable`实例将被迭代*三*次。像这样行为的`Observable`实例被称为冷的Observable实例。
- en: All of the factory methods we've been using in this chapter return cold Observables.
    Cold Observables produce notifications on demand, and for every Subscriber, they
    produce *independent* notifications.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们一直在使用的所有工厂方法返回冷的Observables。冷的Observables按需产生通知，并且对于每个Subscriber，它们产生*独立*的通知。
- en: There are `Observable` instances which, when they start emitting notifications,
    it doesn't matter if there are subscriptions to them or not. They continue emitting
    them until completion. All the subscribers receive the same notifications, and
    by default, when a Subscriber *subscribes*, it doesn't receive the notifications
    emitted before that. These are hot Observable instances.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有些`Observable`实例在开始发出通知时，无论是否有订阅，都会继续发出通知，直到完成。所有订阅者都会收到相同的通知，默认情况下，当一个订阅者*订阅*时，它不会收到之前发出的通知。这些是热
    Observable实例。
- en: We can say that cold Observables generate notifications for each subscriber
    and hot Observables are always running, broadcasting notifications to all of their
    subscribers. Think of a hot Observable as a radio station. All of the listeners
    that are listening to it at this moment listen to the same song. A cold Observable
    is a music CD. Many people can buy it and listen to it independently.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，冷 Observables为每个订阅者生成通知，而热 Observables始终在运行，向所有订阅者广播通知。把热 Observable想象成一个广播电台。此刻收听它的所有听众都在听同一首歌。冷
    Observable就像一张音乐CD。许多人可以购买并独立听取它。
- en: As we mentioned, there are a lot of examples in this book that use cold Observables.
    What about hot Observable instances? If you remember when we implemented 'The
    Reactive Sum' in the first chapter, we had an `Observable` instance that was emitting
    every line the user had typed in the standard input stream. This one was hot,
    and we forked two `Observable` instances from it, one for the collector `a` and
    one for `b`. They received the same input lines and filtered only the ones they
    were interested in. This input `Observable` instance was implemented using a special
    type of `Observable`, called `ConnectableObservable`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们提到的，本书中有很多使用冷 Observables的例子。那么热 Observable实例呢？如果你还记得我们在第一章中实现'响应式求和'时，我们有一个`Observable`实例，它会发出用户在标准输入流中输入的每一行。这个是热的，并且我们从中派生了两个`Observable`实例，一个用于收集器`a`，一个用于`b`。它们接收相同的输入行，并且只过滤出它们感兴趣的行。这个输入`Observable`实例是使用一种特殊类型的`Observable`实现的，称为`ConnectableObservable`。
- en: The ConnectableObservable class
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConnectableObservable类
- en: 'These `Observable` instances are inactive until their `connect()` method is
    called. After that, they become hot Observables. The `ConnectableObservable` instance
    can be created from any `Observable` instance by calling its `publish()` method.
    In other words, the `publish()` method can turn any cold Observable into a hot
    one. Let''s look at this example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`Observable`实例在调用它们的`connect()`方法之前是不活跃的。之后，它们就变成了热 Observables。可以通过调用其`publish()`方法从任何`Observable`实例创建`ConnectableObservable`实例。换句话说，`publish()`方法可以将任何冷
    Observable转换为热 Observable。让我们看一个例子：
- en: '[PRE16]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Nothing will happen until the `connect()` method is called. After that, we'll
    see the same sequential numbers outputted twice—once for each Subscriber. The
    third Subscriber will join the other two, printing the numbers emitted after the
    first 500 milliseconds, but it won't print the numbers emitted before its subscription.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`connect()`方法之前什么都不会发生。之后，我们将看到相同的顺序数字输出两次——每个订阅者一次。第三个订阅者将加入其他两个，打印在第一个500毫秒后发出的数字，但它不会打印其订阅之前发出的数字。
- en: 'What if we want to receive *all the* notifications that have been emitted before
    our subscription and then to continue receiving the incoming ones? That can be
    accomplished by calling the `replay()` method instead of the `publish()` method.
    It creates a `ConnectableObservable` instance from the source `Observable` instance
    with this little twist: all the subscribers, whenever they subscribe, will receive
    *all the* notifications (the previous notifications will arrive in order and synchronously).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在我们的订阅之前接收*所有*已发出的通知，然后继续接收即将到来的通知，可以通过调用`replay()`方法而不是`publish()`方法来实现。它从源`Observable`实例创建一个`ConnectableObservable`实例，有一个小变化：所有订阅者在订阅时都会收到*所有*通知（之前的通知将按顺序同步到达）。
- en: 'There is a way to activate an `Observable` instance to become hot without calling
    the `connect()` method. It can be activated *on the first subscription* to it
    and deactivated when every `Subscriber` instance *unsubscribes*. Such an `Observable`
    instance can be created from a `ConnectableObservable` instance by calling the
    `refCount()` method on it (the name of the method comes from ''reference count'';
    it counts the `Subscriber` instances subscribed to the `Observable` instance created
    by it). Here is the preceding example implemented using the `refCount()` method:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种方法可以激活`Observable`实例，使其在不调用`connect()`方法的情况下变为热 Observable。它可以在*第一次订阅*时激活，并在每个`Subscriber`实例*取消订阅*时停用。可以通过在`ConnectableObservable`实例上调用`refCount()`方法（方法的名称来自'引用计数'；它计算订阅到由它创建的`Observable`实例的`Subscriber`实例数量）从`ConnectableObservable`实例创建这样的`Observable`实例。以下是使用`refCount()`方法实现的前面的例子：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `Observable` instance will be deactivated when `sub2` *unsubscribes*. If
    someone *subscribes* to it after that, it will begin emitting the sequence from
    the beginning. This is what's happening with `sub3`. There is a `share()` method,
    which is an alias for the `publish().refCount()` call.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`sub2` *取消订阅*后，`Observable`实例将停用。如果此后有人*订阅*它，它将从头开始发出序列。这就是`sub3`的情况。还有一个`share()`方法，它是`publish().refCount()`调用的别名。'
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code of the preceding example can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/UsingConnectableObservables.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/UsingConnectableObservables.java).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面例子的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/UsingConnectableObservables.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/UsingConnectableObservables.java)上查看/下载。
- en: 'There is one other way to create a hot Observable: using a `Subject` instance.
    We will introduce them in the next and last section of this chapter.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种创建热 Observable的方法：使用`Subject`实例。我们将在本章的下一节和最后一节介绍它们。
- en: The Subject instances
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Subject实例
- en: The `Subject` instances are both `Observable` instances and `Observer` instances.
    Like `Observable` instances, they can have multiple `Observer` instances, receiving
    the same notifications. That's why they can be used to turn cold `Observable`
    instances into hot ones. Like `Observer` instances, they give us access to their
    `onNext()`, `onError()`, or `onCompleted()` methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject`实例既是`Observable`实例又是`Observer`实例。与`Observable`实例一样，它们可以有多个`Observer`实例，接收相同的通知。这就是为什么它们可以用来将冷的`Observable`实例转换为热的实例。与`Observer`实例一样，它们让我们访问它们的`onNext()`、`onError()`或`onCompleted()`方法。'
- en: 'Let''s look at an implementation of the preceding hot *interval* examples,
    using a `Subject` instance:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下使用`Subject`实例实现前面的热间隔示例：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The example is slightly different now:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在示例略有不同：
- en: The interval `Observable` instance is created the same way as before.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 间隔`Observable`实例的创建方式与以前相同。
- en: Here, we create a `PublishSubject` instance—a `Subject` instance that emits
    to an `Observer` instance only those items that are emitted by the source `Observable`
    instance subsequent to the time of the subscription. This behavior is similar
    to that of the `ConnectableObservable` instance created by the `publish()` method.
    The new `Subject` instance is subscribed to the interval `Observable` instance
    , created by the interval factory method, which is possible because the `Subject`
    class implements the `Observer` interface. Also, note that the `Subject` signature
    has two generic types—one for the type of notifications the `Subject` instance
    will receive and another for the type of the notifications it will emit. The `PublishSubject`
    class has the same type for its input and output *notifications*.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`PublishSubject`实例 - 一个`Subject`实例，只向订阅后由源“Observable”实例发出的项目发出。这种行为类似于使用`publish()`方法创建的`ConnectableObservable`实例。新的`Subject`实例订阅了由间隔工厂方法创建的间隔`Observable`实例，这是可能的，因为`Subject`类实现了`Observer`接口。还要注意，`Subject`签名有两种泛型类型
    - 一种是`Subject`实例将接收的通知类型，另一种是它将发出的通知类型。`PublishSubject`类的输入和输出通知类型相同。
- en: Note that it is possible to create a `PublishSubject` instance without subscribing
    to a source `Observable` instance. It will emit only the notifications passed
    to its `onNext()` and `onError()` methods and will complete when calling its `onCompleted()`
    method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可以创建一个`PublishSubject`实例而不订阅源“Observable”实例。它只会发出传递给其`onNext()`和`onError()`方法的通知，并在调用其`onCompleted()`方法时完成。
- en: We can subscribe to the `Subject` instance; it is an `Observable` instance after
    all.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以订阅`Subject`实例；毕竟它是一个`Observable`实例。
- en: We can emit a custom notification at any time. It will be *broadcast* to all
    the subscribers of the subject. We can even call the `onCompleted()` method and
    close the notification stream.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以随时发出自定义通知。它将广播给主题的所有订阅者。我们甚至可以调用`onCompleted()`方法并关闭通知流。
- en: The third Subscriber will only receive notifications emitted after it subscribes.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个订阅者只会收到订阅后发出的通知。
- en: When everything *unsubscribes*, the `Subject` instance will continue emitting.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当一切都取消订阅时，“Subject”实例将继续发出。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example's source code can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/SubjectsDemonstration.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/SubjectsDemonstration.java).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的源代码可在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/SubjectsDemonstration.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/SubjectsDemonstration.java)上查看/下载。
- en: 'There are four types of subjects that come with RxJava:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava有四种类型的主题：
- en: '`PublishSubject`: This is the one we saw in the previous example, behaving
    like `ConnectableObservable`, created using the `publish()` method.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublishSubject`：这是我们在前面的示例中看到的，行为类似于使用`publish()`方法创建的`ConnectableObservable`。'
- en: '`ReplaySubject`: This emits to any observer all of the items that were emitted
    by the source `Observable` instance, regardless of when the observer subscribes.
    So, it behaves like `ConnectableObservable`, created using the `replay()` method.
    The `ReplaySubject` class has many factory methods. The default one caches everything;
    keep this in mind, because it can eat up memory. There are **factory methods**
    for creating it with size-bound and/or time-bound buffers. As with the `PublishSubject`
    class, this one can be used without a source `Observable` instance. All of the
    notifications emitted using its `onNext()`, `onError()`, and `onCompleted()` methods
    will be emitted to every Subscriber, even if it is subscribed after invoking the
    `on*` methods.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReplaySubject`：这会向任何观察者发出源“Observable”实例发出的所有项目，无论观察者何时订阅。因此，它的行为类似于使用`replay()`方法创建的`ConnectableObservable`。`ReplaySubject`类有许多工厂方法。默认的工厂方法会缓存所有内容；请记住这一点，因为它可能会占用内存。有用于使用大小限制和/或时间限制缓冲区创建它的工厂方法。与`PublishSubject`类一样，这个可以在没有源“Observable”实例的情况下使用。使用其`onNext()`、`onError()`和`onCompleted()`方法发出的所有通知都将发送给每个订阅者，即使在调用`on*`方法后订阅。'
- en: '`BehaviorSubject`: When an observer subscribes to it, it emits the item most
    recently emitted by the source `Observable` instance (or a seed/default value
    if none have yet been emitted) and then continues to emit any other items emitted
    later by the source `Observable` instance. The `BehaviorSubject` class is almost
    like the `ReplaySubjects` class with a buffer size of one. The `BehaviorSubject`
    class can be used to implement a stateful reactive instance—a reactive property.
    Again, a source `Observable` instance is not needed.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BehaviorSubject`：当观察者订阅它时，它会发出源“Observable”实例最近发出的项目（如果尚未发出任何项目，则发出种子/默认值），然后继续发出源“Observable”实例后来发出的任何其他项目。`BehaviorSubject`类几乎与具有缓冲区大小为一的`ReplaySubjects`类相似。`BehaviorSubject`类可用于实现有状态的响应实例
    - 一个响应属性。再次强调，不需要源“Observable”实例。'
- en: '`AsyncSubject`: This emits the last value (and only that) emitted by the source
    `Observable` instance, and only after the source `Observable` instance completes.
    If the source `Observable` instance does not emit any values, the `AsyncSubject`
    instance also completes without emitting any values. This is something like a
    *promise* in RxJava''s world. A source `Observable` instance is not needed; the
    value, the error, or the `OnCompleted` notification can be passed to it by invoking
    the `on*` methods.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncSubject`：这会发出源`Observable`实例发出的最后一个值（仅此一个），并且只有在源`Observable`实例完成后才会发出。如果源`Observable`实例没有发出任何值，`AsyncSubject`实例也会在不发出任何值的情况下完成。这在RxJava的世界中有点像*promise*。不需要源`Observable`实例；可以通过调用`on*`方法将值、错误或`OnCompleted`通知传递给它。'
- en: Using subjects may seem a cool way to solve various problems, but you should
    avoid using them. Or, at least implement them and their behavior in a method that
    returns a result of type `Observable`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主题可能看起来是解决各种问题的一种很酷的方式，但你应该避免使用它们。或者，至少要在返回`Observable`类型的结果的方法中实现它们和它们的行为。
- en: The danger with the `Subject` instance is that they give access to the `onNext()`,
    `onError()`, and `onCompleted()` methods, and your logic can get messy (they need
    to be called following the Rx contract, cited earlier in this chapter). They can
    be misused very easily.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject`实例的危险在于它们提供了`onNext()`，`onError()`和`onCompleted()`方法的访问权限，你的逻辑可能会变得混乱（它们需要遵循本章前面引用的Rx合同）。它们很容易被滥用。'
- en: Opt for using the `ConnecatableObservable` instance (that is, via the `publish()`
    method) over the `Subject`, when you need to create a hot Observable from a cold
    one.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要从冷Observable创建热Observable时，选择使用`ConnecatableObservable`实例（即通过`publish()`方法）而不是`Subject`。
- en: 'But let''s look at one good use of a `Subject` instance—the aforementioned
    *reactive properties*. Again, we are going to implement *''The Reactive Sum''*,
    but this time it will be quite different. Here is the class defining it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们看一个`Subject`实例的一个很好的用法——前面提到的*反应性属性*。同样，我们将实现*'The Reactive Sum'*，但这次会有很大不同。以下是定义它的类：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This class has three double properties: two settable properties, `a` and `b`,
    and their *sum*, `c`. When `a` or `b` changes, `c` is *automatically updated*
    to their sum. There is a special method that we can use to track the changes to
    `c`. So how does it work?'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有三个双精度属性：两个可设置的属性`a`和`b`，以及它们的*和*，`c`。当`a`或`b`改变时，`c`会*自动更新*为它们的和。我们可以使用一种特殊的方法来跟踪`c`的变化。那它是如何工作的呢？
- en: '`ReactiveSum` is a normal Java class, defining three private fields of type
    `BehaviorSubject<Double>`, representing the variables `a`, `b`, and `c`, and with
    default values of zero.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ReactiveSum`是一个普通的Java类，定义了三个`BehaviorSubject<Double>`类型的私有字段，表示变量`a`，`b`和`c`，默认值为零。'
- en: In the constructor, we subscribe `c` to depend on both `a` and `b` and to be
    equal to their sum, again, using `combineLatest()` method.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，我们订阅`c`依赖于`a`和`b`，并且等于它们的和，再次使用`combineLatest()`方法。
- en: The properties `a` and `b` have getters and setters. The getters return their
    current value—the last received value. The setters *emit* the passed value to
    their `Subject` instance, making it the last one.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性`a`和`b`有getter和setter。getter返回它们当前的值——最后接收到的值。setter将传递的值*发出*到它们的`Subject`实例，使其成为最后一个。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `getValue()` method of the `BehaviorSubject` parameter is used for retrieving
    it. It is available at RxJava 1.0.5.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`BehaviorSubject`参数的`getValue()`方法用于检索它。它在RxJava 1.0.5中可用。'
- en: The property `c` is read-only, so it has only a getter, but it can be listened
    to. This can be done with the `obsC()` method, which returns it as an `Observable`
    instance. Remember, when you use subjects, to always encapsulate them in types
    or methods and return the observables to the outside world.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性`c`是只读的，所以它只有一个getter，但可以被监听。这可以通过`obsC()`方法来实现，它将其作为`Observable`实例返回。记住，当你使用主题时，要始终将它们封装在类型或方法中，并将可观察对象返回给外部世界。
- en: 'This `ReactiveSum` class can be used like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ReactiveSum`类可以这样使用：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will output the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first value is *emitted* on the `subscribe` `()` method (remember the `BehaviorSubject`
    instances always *emit* their last value on subscribing), and the other two will
    automatically be *emitted* on setting `a` or `b`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个值在`subscribe` `()`方法上*发出*（记住`BehaviorSubject`实例总是在订阅时*发出*它们的最后一个值），其他两个将在设置`a`或`b`时自动*发出*。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for the preceding example can be viewed/downloaded at [https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/ReactiveSumV3.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/ReactiveSumV3.java).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例的源代码可以在[https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/ReactiveSumV3.java](https://github.com/meddle0x53/learning-rxjava/blob/master/src/main/java/com/packtpub/reactive/chapter03/ReactiveSumV3.java)上查看/下载。
- en: '*Reactive properties* can be used for implementing bindings and counters, so
    they are very useful for desktop or browser applications. But this example is
    far from any functional paradigm.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*反应性属性*可用于实现绑定和计数器，因此它们对于桌面或浏览器应用程序非常有用。但这个例子远离了任何功能范式。'
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've learned many ways of creating different kinds of `Observable`
    instances and other related instances (`Observer`, `Subscriber`, `Subscription`,
    and `Subject`). We've been creating them from timers, values, collections, and
    external sources such as files. Using this knowledge as a base, we can begin building
    logic, by chaining operations to them. Many of the factory methods introduced
    here we'll be coming back in the next chapters. For example, we will be building
    different behaviors using the `Observable.create` method.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了许多创建不同类型的`Observable`实例和其他相关实例（`Observer`，`Subscriber`，`Subscription`和`Subject`）的方法。我们已经从计时器，值，集合和文件等外部来源创建了它们。利用这些知识作为基础，我们可以开始通过对它们进行操作来构建逻辑。这里介绍的许多工厂方法将在接下来的章节中再次出现。例如，我们将使用`Observable.create`方法构建不同的行为。
- en: In the next chapter, we'll introduce various **operators**, which will give
    us the power to write real logic using the `Observable` instances. We have already
    mentioned some of them, such as `map()` and `filter()`, but the time has come
    to look at them in depth.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍各种**操作符**，这将赋予我们使用`Observable`实例编写真正逻辑的能力。我们已经提到了其中一些，比如`map()`和`filter()`，但现在是时候深入研究它们了。
