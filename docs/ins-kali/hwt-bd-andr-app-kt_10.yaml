- en: 10\. Android Architecture Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. Android架构组件
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn about the key components of the Android Jetpack
    libraries and what benefits they bring to the standard Android framework. You
    will also learn how to structure your code and give different responsibilities
    to your classes with the help of Jetpack components. Finally, you'll improve the
    test coverage of your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解Android Jetpack库的关键组件以及它们为标准Android框架带来的好处。您还将学习如何使用Jetpack组件来构建代码并为您的类分配不同的责任。最后，您将提高代码的测试覆盖率。
- en: By the end of this chapter, you'll be able to create applications that handle
    the life cycles of activities and fragments with ease. You'll also know more about
    how to persist data on an Android device using Room, as well as how to use ViewModels
    to separate your logic from your Views.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的学习，您将能够轻松处理活动和片段的生命周期。您还将了解如何使用Room在Android设备上持久保存数据，以及如何使用ViewModels将逻辑与视图分离。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'In the previous chapters, you learned how to write unit tests. The question
    is: what can you unit test? Can you unit test activities and fragments? They are
    pretty hard to unit test on your machine because of the way they are built. Testing
    would be easier if you could move the code away from activities and fragments.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您学会了如何编写单元测试。问题是：您可以对什么进行单元测试？您可以对活动和片段进行单元测试吗？由于它们的构建方式，它们在您的机器上很难进行单元测试。如果您可以将代码从活动和片段中移出来，测试将会更容易。
- en: Also, consider the situation where you are building an application that supports
    different orientations, such as landscape and portrait, and supports multiple
    languages. What tends to happen in these scenarios by default is that when the
    user rotates the screen, the activities and fragments are recreated for the new
    display orientation. Now, imagine that happens while your application is in the
    middle of processing data. You have to keep track of the data you are processing,
    you have to keep track of what the user was doing to interact with your screens,
    and you have to avoid causing a context leak.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，考虑一下您正在构建一个支持不同方向（如横向和纵向）和支持多种语言的应用程序的情况。在这些情景中，默认情况下会发生的情况是，当用户旋转屏幕时，活动和片段会为新的显示方向重新创建。现在，想象一下这发生在您的应用程序正在处理数据的中间。您必须跟踪您正在处理的数据，您必须跟踪用户正在做什么来与您的屏幕交互，并且您必须避免造成上下文泄漏。
- en: Note
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A context leak occurs when your destroyed activity cannot be garbage collected
    because it is referenced in a component with a longer life cycle – like a thread
    that is currently processing your data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文泄漏是指您销毁的活动由于在生命周期更长的组件中引用而无法进行垃圾回收 - 比如当前正在处理数据的线程。
- en: In many situations, you would have to resort to using `onSaveInstanceState`
    in order to save the current state of your activity/fragment, and then in `onCreate`
    or `onRestoreInstanceState`, you would need to restore the state of your activity/fragment.
    This would add extra complexity to your code and would also make it repetitive,
    especially if the processing code is going to be part of your activity or fragment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，您将不得不使用`onSaveInstanceState`来保存活动/片段的当前状态，然后在`onCreate`或`onRestoreInstanceState`中，您需要恢复活动/片段的状态。这将给您的代码增加额外的复杂性，也会使其重复，特别是如果处理代码将成为您的活动或片段的一部分。
- en: These scenarios are where `ViewModel` and `LiveData` come in. `ViewModels` are
    components built with the express goal of holding data in case of life cycle changes.
    They also separate the logic from the Views, which makes them very easy to unit
    test. `LiveData` is a component used to hold data and notify observers when changes
    occur while taking their life cycle into account. In simpler terms, the fragment
    only deals with the Views, `ViewModel` does the heavy lifting, and `LiveData`
    deals with delivering the results to the fragment, but only when the fragment
    is there and ready.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些情景是`ViewModel`和`LiveData`发挥作用的地方。`ViewModels`是专门用于在生命周期发生变化时保存数据的组件。它们还将逻辑与视图分离，这使它们非常容易进行单元测试。`LiveData`是一个组件，用于保存数据并在发生更改时通知观察者，同时考虑它们的生命周期。简单来说，片段只处理视图，`ViewModel`负责繁重的工作，`LiveData`负责将结果传递给片段，但只有在片段准备好时才会这样做。
- en: If you've ever used WhatsApp or a similar messaging app and you've turned off
    the internet, you'll have noticed that you are still able to use the application.
    The reason for this is because the messages are stored locally on your device.
    This is achieved through the use of a database file called **SQLite** in most
    cases. The Android Framework already allows you to use this feature for your application.
    This requires a lot of boilerplate code in order to read and write data. Every
    time you want to interact with the local storage, you must write a SQL query.
    When you read the SQLite data, you must convert it into a Java/Kotlin object.
    All of this requires a lot of code, time, and unit testing. What if someone else
    handles the SQLite connection and all you have to do is focus on the code part?
    This is where **Room** comes in. This is a library that is a wrapper over SQLite.
    All you need to do is define how your data should be saved and let the library
    take care of the rest.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用WhatsApp或类似的消息应用，并关闭了互联网，您会注意到您仍然能够使用该应用程序。原因是因为消息被本地存储在您的设备上。在大多数情况下，这是通过使用名为**SQLite**的数据库文件实现的。Android框架已经允许您为您的应用程序使用此功能。这需要大量样板代码来读取和写入数据。每次您想要与本地存储交互时，您必须编写SQL查询。当您读取SQLite数据时，您必须将其转换为Java/Kotlin对象。所有这些都需要大量的代码、时间和单元测试。如果有人处理SQLite连接，而您只需专注于代码部分呢？这就是**Room**的作用。这是一个包装在SQLite上的库。您只需要定义数据应该如何保存，然后让库来处理其余部分。
- en: Let's say you want your activity to know when there is an internet connection
    and when the internet drops. You can use something called `BroadcastReceiver`
    for this. A slight problem with this is that every time you register a `BroadcastReceiver`
    in an activity, you have to unregister it when the activity is destroyed. You
    can use `Lifecycle` to observe the state of your activity, thereby allowing your
    receiver to be registered in the desired state and unregistered in the complementary
    one (for example, `RESUMED-PAUSED`, `STARTED-STOPPED`, or `CREATED-DESTROYED`).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望您的活动在有互联网连接和互联网断开时知道。您可以使用称为BroadcastReceiver的东西。这样做的一个小问题是，每次在活动中注册BroadcastReceiver时，您都必须在活动销毁时注销它。您可以使用Lifecycle来观察活动的状态，从而允许您的接收器在所需状态下注册，并在补充状态下注销（例如，RESUMED-PAUSED，STARTED-STOPPED或CREATED-DESTROYED）。
- en: '`ViewModels`, `LiveData`, and `Room` are all part of the Android architecture
    components, which are part of the Android Jetpack libraries. The architecture
    components are designed to help developers structure their code, write testable
    components, and help reduce boilerplate code. Other architecture components include
    `Databinding` (which binds views with models or `ViewModels`, allowing the data
    to be directly set in the Views), `WorkManager` (which allows developers to handle
    background work with ease), `Navigation` (which allows developers to create visual
    navigation graphs and specify relationships between activities and fragments),
    and `Paging` (which allows developers to load paginated data, which helps in situations
    where infinite scrolling is required).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModels，LiveData和Room都是Android架构组件的一部分，它们是Android Jetpack库的一部分。架构组件旨在帮助开发人员构建其代码，编写可测试的组件，并帮助减少样板代码。其他架构组件包括数据绑定（将视图与模型或ViewModel绑定，允许数据直接设置在视图中）、WorkManager（允许开发人员轻松处理后台工作）、导航（允许开发人员创建可视化导航图并指定活动和片段之间的关系）和分页（允许开发人员加载分页数据，在需要无限滚动的情况下有所帮助）。
- en: ViewModel and LiveData
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ViewModel和LiveData
- en: Both `ViewModel` and `LiveData` represent specialized implementations of the
    life cycle mechanisms. They come in handy in situations where you want to keep
    your data saved when the screen rotates and when you want your data to be displayed
    only when the Views are available, thus avoiding one of the most common issues
    developers face – a `NullPointerException` – when trying to update a View. A good
    use of this is when you want to display the live score of your favorite team's
    game and the current minute of the game.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel和LiveData都代表生命周期机制的专门实现。它们在希望在屏幕旋转时保持数据保存以及在希望数据仅在视图可用时显示时非常有用，从而避免开发人员面临的最常见问题之一——NullPointerException——当尝试更新视图时。一个很好的用法是当您希望显示您最喜爱球队比赛的实时比分和比赛的当前分钟数时。
- en: ViewModel
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ViewModel
- en: The `ViewModel` component is responsible for holding and processing data required
    by the UI. It has the benefit of surviving configuration changes that destroy
    and recreate fragments and activities, which allows it to retain the data that
    can then be used to re-populate the UI. It will be eventually destroyed when the
    activity or fragment will be destroyed without being recreated or when the application
    process is terminated. This allows `ViewModel` to serve its responsibility and
    to be garbage collected when it is no longer necessary. The only method `ViewModel`
    has is the `onCleared()` method, which is called when `ViewModel` terminates.
    You can overwrite this method to terminate ongoing tasks and deallocate resources
    that will no longer be required.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel组件负责保存和处理UI所需的数据。它的好处是在销毁和重新创建片段和活动的配置更改时能够存活，从而保留数据，然后用于重新填充UI。当活动或片段在不重新创建或应用程序进程终止时，它最终会被销毁。这使得ViewModel能够履行其责任，并在不再需要时进行垃圾回收。ViewModel唯一的方法是onCleared()方法，当ViewModel终止时会调用该方法。您可以重写此方法以终止正在进行的任务并释放不再需要的资源。
- en: Migrating data processing from the activities into the `ViewModel`s helps in
    creating better and faster unit tests. Testing an activity requires an Android
    test that will be executed on a device. Activities also have states, which means
    that your test should get the activity into the proper state for the assertions
    to work. A `ViewModel` can be unit tested locally on your development machine
    and can be stateless, which means that your data processing logic can be tested
    individually.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据处理从活动迁移到ViewModel有助于创建更好和更快的单元测试。测试活动需要在设备上执行的Android测试。活动还具有状态，这意味着您的测试应该将活动置于适当的状态以使断言起作用。ViewModel可以在开发机器上进行本地单元测试，并且可以是无状态的，这意味着您的数据处理逻辑可以单独进行测试。
- en: One of the most important features of ViewModels is that they allow communication
    between fragments. To communicate between fragments without a `ViewModel`, you
    would have to make your fragment communicate with the activity, which will then
    call the fragment you wish to communicate with. To achieve this with ViewModels,
    you can just attach them to the parent activity and use the same `ViewModel` in
    the fragment you wish to communicate with. This will reduce the boilerplate code
    that was required previously.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel最重要的功能之一是它允许片段之间进行通信。要在没有ViewModel的情况下在片段之间进行通信，您必须使您的片段与活动进行通信，然后再调用您希望进行通信的片段。通过ViewModel实现这一点，您可以将它们附加到父活动并在希望进行通信的片段中使用相同的ViewModel。这将减少以前所需的样板代码。
- en: 'In the following diagram, you can see that a `ViewModel` can be created at
    any point in an activity''s life cycle (in practice they are normally initialized
    in the `onCreate` for Activities and `onCreateView` or `onViewCreated` for Fragments
    because these represent the points where the views are created and ready to be
    updated), and that once created, it will live as long as the activity does:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，您可以看到`ViewModel`可以在活动的生命周期中的任何时刻创建（实际上，它们通常在`onCreate`中初始化活动和`onCreateView`或`onViewCreated`中初始化fragment，因为这些代表了视图创建和准备更新的时刻），一旦创建，它将与活动一样长久存在：
- en: '![Figure 10.1: The life cycle of an activity compared to the ViewModel life
    cycle'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1：活动的生命周期与ViewModel生命周期的比较'
- en: '](img/B15216_10_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_10_01.jpg)'
- en: 'Figure 10.1: The life cycle of an activity compared to the ViewModel life cycle'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：活动的生命周期与ViewModel生命周期的比较
- en: 'The following diagram shows how `ViewModel` connects to a fragment:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了`ViewModel`如何连接到一个fragment：
- en: '![Figure 10.2: The life cycle of a fragment compared to the ViewModel life
    cycle'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2：片段的生命周期与ViewModel生命周期的比较'
- en: '](img/B15216_10_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_10_02.jpg)'
- en: 'Figure 10.2: The life cycle of a fragment compared to the ViewModel life cycle'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：片段的生命周期与ViewModel生命周期的比较
- en: LiveData
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LiveData
- en: '`LiveData` is a life cycle-aware component that permits updates to your UI,
    but only if the UI is in an active state (for example, if the activity or fragment
    is in the `STARTED` or `RESUMED` state). To monitor changes on your `LiveData`,
    you need an observer combined with a `LifecycleOwner`. When the activity is set
    to an active state, the observers will be notified when changes occur. If the
    activity is recreated, then the observer will be destroyed and a new one will
    be reattached. Once this happens, the last value of `LiveData` will be emitted
    to allow us to restore the state. Activities and fragments are `LifecycleOwners`,
    but fragments have a separate `LifecycleOwner` for the View states. Fragments
    have this particular `LifecycleOwner` due to their behavior in the fragment `BackStack`.
    When fragments are replaced within the back stack, they are not fully destroyed;
    only their Views are. Some of the common callbacks that developers use to trigger
    processing logic are `onViewCreated()`, `onActivityResumed()`, and `onCreateView()`.
    If we were to register observers on `LiveData` in these methods, we might end
    up with scenarios where multiple observers will be created every time our fragment
    pops back onto the screen.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveData`是一个生命周期感知组件，允许更新UI，但只有在UI处于活动状态时才会更新（例如，如果活动或片段处于`STARTED`或`RESUMED`状态）。要监视`LiveData`的更改，您需要一个与`LifecycleOwner`结合的观察者。当活动设置为活动状态时，观察者将在更改发生时收到通知。如果活动被重新创建，那么观察者将被销毁并重新附加。一旦发生这种情况，`LiveData`的最后一个值将被发出，以便我们恢复状态。活动和片段都是`LifecycleOwners`，但片段有一个单独的`LifecycleOwner`用于视图状态。片段有这个特殊的`LifecycleOwner`是因为它们在片段`BackStack`中的行为。当片段在返回堆栈中被替换时，它们并不完全被销毁；只有它们的视图被销毁。开发人员用来触发处理逻辑的一些常见回调是`onViewCreated()`、`onActivityResumed()`和`onCreateView()`。如果我们在这些方法中在`LiveData`上注册观察者，我们可能会遇到多个观察者在片段再次出现在屏幕上时被创建的情况。'
- en: 'When updating a `LiveData` model, we are presented with two options: `setValue()`
    and `postValue()`. `setValue()` will deliver the result immediately and is meant
    to be called only on the UI thread. On the other hand, `postValue()` can be called
    on any thread. When `postValue()` is called, `LiveData` will schedule an update
    of the value on the UI thread and update the value when the UI thread becomes
    free.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新`LiveData`模型时，我们有两个选项：`setValue()`和`postValue()`。`setValue()`会立即传递结果，并且只应在UI线程上调用。另一方面，`postValue()`可以在任何线程上调用。当调用`postValue()`时，`LiveData`将安排在UI线程上更新值，并在UI线程空闲时更新值。
- en: In the `LiveData` class, these methods are protected, which means that there
    are subclasses that allow us to change the data. `MutableLiveData` makes the methods
    public, which gives us a simple solution for observing data in most cases. `MediatorLiveData`
    is a specialized implementation of `LiveData` that allows us to merge multiple
    `LiveData` objects into one (this is useful in situations where our data is kept
    in different repositories and we want to show a combined result). `TransformLiveData`
    is another specialized implementation that allows us to convert from one object
    into another (this helps us in situations where we're grabbing data from one repository
    and we want to request data from another repository that depends on the previous
    data, as well as in situations where we want to apply extra logic to a result
    from a repository). `Custom LiveData` allows us to create our own `LiveData` implementations
    (usually when we periodically receive updates, such as the odds in a sports betting
    app, stock market updates, and Facebook and Twitter feeds).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LiveData`类中，这些方法是受保护的，这意味着有子类允许我们更改数据。`MutableLiveData`使方法公开，这为我们提供了在大多数情况下观察数据的简单解决方案。`MediatorLiveData`是`LiveData`的专门实现，允许我们将多个`LiveData`对象合并为一个（这在我们的数据保存在不同存储库并且我们想要显示组合结果的情况下非常有用）。`TransformLiveData`是另一个专门的实现，允许我们将一个对象转换为另一个对象（这在我们从一个存储库中获取数据并且我们想要从另一个依赖于先前数据的存储库中请求数据的情况下有所帮助，以及在我们想要对存储库的结果应用额外逻辑的情况下有所帮助）。`Custom
    LiveData`允许我们创建自己的`LiveData`实现（通常在我们定期接收更新的情况下，比如体育博彩应用中的赔率、股市更新以及Facebook和Twitter的动态）。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is a common practice to use `LiveData` in a `ViewModel`. Holding `LiveData`
    in the fragment or activity will cause losses in data when configuration changes
    occur.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewModel`中使用`LiveData`是一种常见做法。在fragment或activity中持有`LiveData`会导致在配置更改发生时丢失数据。
- en: 'The following diagram shows how `LiveData` is connected to the life cycle of
    a `LifecycleOwner`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了`LiveData`如何与`LifecycleOwner`的生命周期连接：
- en: '![Figure 10.3: The relationship between LiveData and life cycle'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3：LiveData与生命周期之间的关系'
- en: observers with LifecycleOwners
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与LifecycleOwners的观察者
- en: '](img/B15216_10_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_10_03.jpg)'
- en: 'Figure 10.3: The relationship between LiveData and life cycle observers with
    LifecycleOwners'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：LiveData与生命周期所有者和生命周期观察者之间的关系
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We can register multiple observers on a `LiveData` and each observer can be
    registered for a different `LifecycleOwner`. In this situation, a `LiveData` will
    become inactive, but only when all the observers are inactive.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`LiveData`上注册多个观察者，并且每个观察者可以为不同的`LifecycleOwner`注册。在这种情况下，`LiveData`将变为非活动状态，但只有当所有观察者都处于非活动状态时。
- en: 'Exercise 10.01: Creating a Layout with Configuration Changes'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.01：创建具有配置更改的布局
- en: 'You have been tasked with building an app that has one screen that is split
    into two vertically when in portrait mode and horizontally when in landscape mode.
    The first half contains some text and below it is a button. The second half contains
    only text. When the screen is opened, the text in both halves displays `Total:
    0`. When the button is clicked, the text will change to `Total: 1`. When clicked
    again, the text will change to `Total: 2`, and so on. When the device is rotated,
    the last total will be displayed on the new orientation.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '您的任务是构建一个应用程序，当在纵向模式下时，屏幕分为两个部分，纵向分割，当在横向模式下时，屏幕分为两个部分，横向分割。第一部分包含一些文本，下面是一个按钮。第二部分只包含文本。打开屏幕时，两个部分的文本都显示`Total:
    0`。点击按钮后，文本将更改为`Total: 1`。再次点击后，文本将更改为`Total: 2`，依此类推。当设备旋转时，最后的总数将显示在新的方向上。'
- en: 'In order to solve this task, we will define the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个任务，我们将定义以下内容：
- en: An activity that will hold two fragments – one layout for portrait and another
    layout for landscape.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含两个片段的活动-一个用于纵向，另一个用于横向。
- en: One fragment with one layout containing `TextView` and a button.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含`TextView`和一个按钮的布局的片段。
- en: One fragment with one layout containing `TextView`.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含`TextView`的布局的片段。
- en: One `ViewModel` that will be shared between the two fragments.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将在两个片段之间共享的`ViewModel`。
- en: One `LiveData` that will hold the total.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将保存总数的`LiveData`。
- en: 'Let''s begin by setting up our configurations:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置我们的配置开始：
- en: Create a new project called `ViewModelLiveData` and add an empty activity called
    `SplitActivity`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ViewModelLiveData`的新项目，并添加一个名为`SplitActivity`的空活动。
- en: 'In the root `build.gradle` file, add the `google()` repository:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在根`build.gradle`文件中，添加`google()`存储库：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will allow Gradle (the build system) to know where to locate the Android
    Jetpack libraries, which are developed by Google.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许Gradle（构建系统）知道在哪里定位由Google开发的Android Jetpack库。
- en: 'Let''s add the `ViewModel` and `LiveData` libraries to `app/build.gradle`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`ViewModel`和`LiveData`库添加到`app/build.gradle`中：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will bring both the `ViewModel` and `LiveData` code into our project.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`ViewModel`和`LiveData`代码都引入我们的项目。
- en: 'Create and define `SplitFragmentOne`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建和定义`SplitFragmentOne`：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the `fragment_split_`one`.xml` file to the `res/layout` folder:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`fragment_split_`one`.xml`文件添加到`res/layout`文件夹中：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s create and define `SplitFragmentTwo`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建并定义`SplitFragmentTwo`：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the `fragment_split_two.xml` file to the `res/layout` folder:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`fragment_split_two.xml`文件添加到`res/layout`文件夹中：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Define `SplitActivity`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`SplitActivity`：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the `activity_split.xml` file in the `res/layout` folder:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/layout`文件夹中创建`activity_split.xml`文件：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, let''s create a `layout-land` folder in the `res` folder. Then, in the
    `layout-land` folder, we''ll create an `activity_split.xml` file with the following
    layout:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`res`文件夹中创建一个`layout-land`文件夹。然后，在`layout-land`文件夹中，我们将创建一个名为`activity_split.xml`的文件，其中包含以下布局：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following strings should be added to `res/strings.xml`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下字符串应添加到`res/strings.xml`中：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Make sure that `ActivitySplit` is present in the `AndroidManifest.xml` file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保`ActivitySplit`存在于`AndroidManifest.xml`文件中：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If this is the only activity in your manifest, then make sure to add the launcher
    `intent-filter` tags so that the system knows which activity it should open when
    your app is installed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是您清单中唯一的活动，请确保添加启动器`intent-filter`标签，以便系统知道在安装应用程序时应打开哪个活动：
- en: '`<intent-filter> <action android:name="android.intent.action.MAIN" /> <category
    android:name="android.intent.category.LAUNCHER" /></intent-filter>`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`<intent-filter> <action android:name="android.intent.action.MAIN" /> <category
    android:name="android.intent.category.LAUNCHER" /></intent-filter>`'
- en: 'Now, let''s run the project. After it''s run, you can rotate the device and
    see that the screens are oriented according to the specifications. The `Total`
    is set to 0 and clicking on the button will do nothing:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个项目。运行后，您可以旋转设备，看到屏幕根据规格定向。`Total`设置为0，点击按钮不会有任何反应：
- en: '![Figure 10.4: Output of Exercise 10.01'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4：练习10.01的输出'
- en: '](img/B15216_10_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_10_04.jpg)'
- en: 'Figure 10.4: Output of Exercise 10.01'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：练习10.01的输出
- en: We will need to build the logic required for adding 1 every time the button
    is clicked. That logic will need to be testable as well. We can build a `ViewModel`
    and attach it to each fragment. This will make the logic testable and it will
    also solve the issues with the life cycle.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要构建所需的逻辑，以便每次单击按钮时都添加1。该逻辑也需要是可测试的。我们可以构建一个`ViewModel`并将其附加到每个片段。这将使逻辑可测试，并且还将解决生命周期的问题。
- en: 'Exercise 10.02: Adding a ViewModel'
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.02：添加ViewModel
- en: 'We now need to implement the logic for connecting our `ViewModel` to the button
    click and ensuring that the value is kept across configuration changes, such as
    rotations. Let''s get started:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现将我们的`ViewModel`与按钮点击连接起来的逻辑，并确保该值在配置更改（如旋转）时保持不变。让我们开始吧：
- en: 'Create a `TotalsViewModel` that looks like this:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`TotalsViewModel`，如下所示：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that we extended from the `ViewModel` class, which is part of the life
    cycle library. In the `ViewModel` class, we defined one method that increases
    the value of the total and returns the updated value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们是从`ViewModel`类扩展的，这是生命周期库的一部分。在`ViewModel`类中，我们定义了一个增加总数并返回更新值的方法。
- en: 'Now, add the `updateText` and `prepareViewModel` methods to the `SplitFragment1`
    fragment:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`updateText`和`prepareViewModel`方法添加到`SplitFragment1`片段中：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `prepareViewModel()` function, let''s start adding our `ViewModel`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`prepareViewModel()`函数中，让我们开始添加我们的`ViewModel`：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is how the `ViewModel` instance is accessed. `ViewModelProvider(this)`
    will make `TotalsViewModel` be bound to the life cycle of the fragment. `.get(TotalsViewModel::class.java)`
    will retrieve the instance of `TotalsViewModel` that we defined previously. If
    the fragment is being created for the first time, it will produce a new instance,
    while if the fragment is recreated after a rotation, it will provide the previously
    created instance. The reason we pass the class as an argument is because a fragment
    or activity can have multiple ViewModels and the class serves as an identifier
    for the type of `ViewModel` we want.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是访问`ViewModel`实例的方式。`ViewModelProvider(this)`将使`TotalsViewModel`绑定到fragment的生命周期。`.get(TotalsViewModel::class.java)`将检索我们之前定义的`TotalsViewModel`的实例。如果fragment是第一次创建，它将产生一个新实例，而如果fragment在旋转后重新创建，它将提供先前创建的实例。我们将类作为参数传递的原因是因为一个fragment或activity可以有多个ViewModels，而类作为我们想要的`ViewModel`类型的标识符。
- en: 'Now, set the last known value on the view:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在视图上设置最后已知的值：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Update the View when the button is clicked:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击按钮时更新视图：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, run the app, press the button, and rotate the screen to see what happens:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行应用程序，按下按钮，旋转屏幕，看看会发生什么：
- en: '![Figure 10.5: Output of Exercise 10.02'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.5：练习10.02的输出'
- en: '](img/B15216_10_05.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_10_05.jpg)'
- en: 'Figure 10.5: Output of Exercise 10.02'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5：练习10.02的输出
- en: As you press the button, you will see the total increase, and when you rotate
    the display, the value is kept constant. If you press the back button and reopen
    the activity, you will notice that the total is set to 0\. We will need to notify
    the other fragment that the value has changed. We can do this by using an interface
    and letting the activity know so that the activity can alert `SplitFragmentOne`.
    Alternatively, we can attach our `ViewModel` to the activity, which will allow
    us to share it between fragments.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当您按下按钮时，您会看到总数增加，当您旋转显示时，值保持不变。如果您按下返回按钮并重新打开activity，您会注意到总数被设置为0。我们需要通知另一个fragment值已更改。我们可以通过使用接口并让activity知道来实现这一点，以便activity可以通知`SplitFragmentOne`。或者，我们可以将我们的`ViewModel`附加到activity，这将允许我们在fragments之间共享它。
- en: 'Exercise 10.03: Sharing our ViewModel between the Fragments'
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.03：在fragments之间共享我们的ViewModel
- en: 'We need to access `TotalsViewModel` in `SplitFragmentOne` and attach our `ViewModel`
    to the activity. Let''s get started:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`SplitFragmentOne`中访问`TotalsViewModel`并将我们的`ViewModel`附加到activity。让我们开始吧：
- en: 'Add the same `ViewModel` we used previously to our `SplitFragmentTwo`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们之前使用的相同`ViewModel`添加到`SplitFragmentTwo`中：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s modify our fragments. In both fragments, we need to find and change
    the following code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改我们的fragments。在两个fragments中，我们需要找到并更改以下代码：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will change it to the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其更改为以下内容：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s run the application:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行应用程序：
- en: '![Figure 10.6: Output of Exercise 10.03'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.6：练习10.03的输出'
- en: '](img/B15216_10_06.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_10_06.jpg)'
- en: 'Figure 10.6: Output of Exercise 10.03'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6：练习10.03的输出
- en: Again, here, we can observe something interesting. When the button is clicked,
    we don't see any changes in our second fragment, but we do see the total. This
    means that the fragments communicate, but not in real time. We can solve this
    through `LiveData`. By observing `LiveData` in both fragments, we can update each
    of the fragments' `TextView` classes when the value changes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在这里，我们可以观察到一些有趣的东西。当点击按钮时，我们在第二个fragment中看不到任何变化，但我们确实看到了总数。这意味着fragments之间进行了通信，但不是实时的。我们可以通过`LiveData`来解决这个问题。通过在两个fragments中观察`LiveData`，我们可以在值发生变化时更新每个fragment的`TextView`类。
- en: Note
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using ViewModels to communicate between fragments will only work when the fragments
    are placed in the same activity.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ViewModels在fragments之间进行通信只有在fragments放置在同一个activity中时才有效。
- en: 'Exercise 10.04: Adding LiveData'
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.04：添加LiveData
- en: Now, we need to ensure that our fragments communicate in real time with each
    other. We can use `LiveData` to achieve this. This way, every time one fragment
    makes a change, the other fragment will be notified about the change and will
    make the necessary adjustments.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要确保我们的fragments实时地相互通信。我们可以使用`LiveData`来实现这一点。这样，每当一个fragment进行更改时，另一个fragment将收到关于更改的通知并进行必要的调整。
- en: 'Perform the following steps to achieve this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来实现这一点：
- en: 'Our `TotalsViewModel` should be modified so that it supports `LiveData`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的`TotalsViewModel`应该被修改以支持`LiveData`：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we created a `MutableLiveData`, a subclass of `LiveData` that allows us
    to change the value of the data. When `ViewModel` is created, we set the default
    value of `0`, and then when we increase the total, we post the previous value
    plus 1\. We also created the `getTotal()` method, which returns a `LiveData` class
    that can be observed but not modified from the fragment.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`MutableLiveData`，它是`LiveData`的子类，允许我们更改数据的值。当创建`ViewModel`时，我们将`0`的默认值设置为`0`，然后当我们增加总数时，我们发布先前的值加1。我们还创建了`getTotal()`方法，它返回一个可以从fragment中观察但不能修改的`LiveData`类。
- en: 'Now, we need to modify our fragments so that they adjust to the new `ViewModel`.
    For `SplitFragmentOne`, we do the following:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要修改我们的fragments，使它们适应新的`ViewModel`。对于`SplitFragmentOne`，我们执行以下操作：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For `SplitFragmentTwo`, we do the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`SplitFragmentTwo`，我们执行以下操作：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `LifecycleOwner` parameter for the `observe` method is called `viewLifecycleOwner`.
    This is inherited from the `fragment` class and it helps when we are observing
    data while the View that the fragment manages is being rendered. In our example,
    swapping `viewLifecycleOwner` with `this` would've caused no impact. But if our
    fragment would've been part of a back stack feature, then there would've been
    the risk of creating multiple observers, which would've lead to being notified
    multiple times for the same dataset.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`observe`方法的`LifecycleOwner`参数称为`viewLifecycleOwner`。这是从`fragment`类继承的，当我们在观察数据时，它有助于在渲染fragment管理的视图时进行观察。在我们的示例中，将`viewLifecycleOwner`替换为`this`不会造成影响。但如果我们的fragment是后退堆栈功能的一部分，那么就会有创建多个观察者的风险，这将导致对相同数据集多次通知。'
- en: 'Now, let''s write a test for our new `ViewModel`. We will name it `TotalsViewModelTest`
    and place it in the `test` package, not `androidTest`. This is because we want
    this test to execute on our workstation, not the device:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的新`ViewModel`编写一个测试。我们将其命名为`TotalsViewModelTest`，并将其放在`test`包中，而不是`androidTest`。这是因为我们希望这个测试在我们的工作站上执行，而不是在设备上：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding test, before testing begins, we assert that the initial value
    of `LiveData` is set to 0\. Then, we write a small test in which we increase the
    total five times and we assert that the final value is `5`. Let''s run the test
    and see what happens:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的测试中，在测试开始之前，我们断言`LiveData`的初始值设置为0。然后，我们编写了一个小测试，其中我们将总数增加了五次，并断言最终值为`5`。让我们运行测试，看看会发生什么：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A message similar to the preceding one will appear. This is because of how
    `LiveData` is implemented. Internally, it uses Handlers and Loopers, which are
    part of the Android framework, thus preventing us from executing the test. Luckily,
    there is a way around this. We will need the following configuration in our Gradle
    file for our test:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会出现类似于前面的消息。这是因为`LiveData`的实现方式。在内部，它使用处理程序和循环器，这是Android框架的一部分，因此阻止我们执行测试。幸运的是，有一个解决方法。我们需要在Gradle文件中为我们的测试添加以下配置：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This adds a testing library to our testing code, not our application code.
    Now, let''s add the following line to our code, above the instantiation of the
    `ViewModel` class:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将向我们的测试代码添加一个测试库，而不是我们的应用程序代码。现在，让我们在代码中添加以下行，位于`ViewModel`类的实例化之前：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'What we have done here is added a `TestRule` that says that every time a `LiveData`
    has its value changed, it will make the change instantly and will avoid using
    the Android Framework components. Every test we will write in this class will
    be impacted by this rule, thus giving us the freedom to play with the `LiveData`
    class for each new test method. If we run the test again, we will see the following:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里所做的是添加了一个`TestRule`，它表示每当`LiveData`的值发生变化时，它将立即进行更改，并避免使用Android框架组件。我们将在这个类中编写的每个测试都受到这个规则的影响，从而使我们有自由为每个新的测试方法使用`LiveData`类。如果我们再次运行测试，我们将看到以下内容：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Does this mean that our new rule didn''t work? Not exactly. If you look in
    your `TotalsViewModels` class, you''ll see this:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是否意味着我们的新规则没有起作用？并非完全如此。如果您查看`TotalsViewModels`类，您会看到这个：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This means that because we created the `ViewModel` class outside of the scope
    of the rule, the rule will not apply. We can do two things to avoid this scenario:
    we can change our code to handle a null value that will be sent when we first
    subscribe to the `LiveData` class, or we can adjust our test so that we put the
    `ViewModel` class in the scope of the rule. Let''s go with the second approach
    and change how we create our `ViewModel` class in the test. It should look something
    like this:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着因为我们在规则范围之外创建了`ViewModel`类，所以规则不适用。我们可以做两件事来避免这种情况：我们可以更改我们的代码以处理当我们首次订阅`LiveData`类时发送的空值，或者我们可以调整我们的测试，以便将`ViewModel`类放在规则的范围内。让我们采用第二种方法，并更改测试中创建`ViewModel`类的方式。它应该看起来像这样：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s run the test again and see what happens:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次运行测试，看看会发生什么：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'See if you can spot where the error in the test is, fix it, and then rerun
    it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 看看您能否找到测试中的错误，修复它，然后重新运行它：
- en: '![Figure 10.7: Output of Exercise 10.04'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.7：练习10.04的输出'
- en: '](img/B15216_10_07.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_10_07.jpg)'
- en: 'Figure 10.7: Output of Exercise 10.04'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7：练习10.04的输出
- en: 'The same output in landscape mode will look as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 横向模式下的相同输出如下所示：
- en: '![Figure 10.8: Output of Exercise 10.04 in landscape mode'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.8：横向模式下练习10.04的输出'
- en: '](img/B15216_10_08.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_10_08.jpg)'
- en: 'Figure 10.8: Output of Exercise 10.04 in landscape mode'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8：横向模式下练习10.04的输出
- en: 'By looking at the preceding example, we can see how using a combination of
    the `LiveData` and `ViewModel` approaches helped us solve our problem while taking
    into account the particularities of the Android operating system:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看前面的例子，我们可以看到使用`LiveData`和`ViewModel`方法的结合如何帮助我们解决了问题，同时考虑了Android操作系统的特殊性：
- en: '`ViewModel` helped us hold the data across device orientation change and it
    solved the issue of communicating between fragments.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModel`帮助我们在设备方向更改时保持数据，并解决了在片段之间通信的问题。'
- en: '`LiveData` helped us retrieve the most up-to-date information that we''ve processed
    while taking into account the fragment''s life cycle.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LiveData`帮助我们在考虑片段生命周期的同时检索我们处理过的最新信息。'
- en: The combination of the two helped us delegate our processing logic in an efficient
    way, allowing us to unit test this processing logic.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这两者的结合帮助我们以高效的方式委托我们的处理逻辑，使我们能够对这个处理逻辑进行单元测试。
- en: Room
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Room
- en: 'The Room persistence library acts as a wrapper between your application code
    and the SQLite storage. You can think of SQLite as a database that runs without
    its own server and saves all the application data in an internal file that''s
    only accessible by your application (if the device is not rooted). Room will sit
    between the application code and the SQLite Android Framework, and it will handle
    the necessary Create, Read, Update, and Delete (CRUD) operations while exposing
    an abstraction that your application can use to define the data and how you want
    the data to be handled. This abstraction comes in the form of the following objects:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Room持久性库充当您的应用程序代码和SQLite存储之间的包装器。您可以将SQLite视为一个在没有自己服务器的情况下运行的数据库，并将所有应用程序数据保存在一个只能由您的应用程序访问的内部文件中（如果设备未被root）。Room将位于应用程序代码和SQLite
    Android框架之间，并将处理必要的创建、读取、更新和删除（CRUD）操作，同时公开一个抽象，您的应用程序可以使用该抽象来定义数据以及您希望处理数据的方式。这种抽象以以下对象的形式出现：
- en: '**Entities**: You can specify how you want your data to be stored and the relationships
    between your data.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**：您可以指定数据存储方式以及数据之间的关系。'
- en: '**Data Access Object** (**DAO**): The operations that can be done on your data.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据访问对象**（**DAO**）：可以对数据执行的操作。'
- en: '**Database**: You can specify the configurations that your database should
    have (the name of the database and migration scenarios).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库：您可以指定数据库应具有的配置（数据库名称和迁移方案）。
- en: 'These can be seen in the following diagram:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以在以下图表中看到：
- en: '![Figure 10.9: Relationship between your application and Room components'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.9：您的应用程序与Room组件之间的关系'
- en: '](img/B15216_10_09.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_10_09.jpg)'
- en: 'Figure 10.9: Relationship between your application and Room components'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9：您的应用程序与Room组件之间的关系
- en: In the preceding diagram, we can see how the Room components interact with each
    other. It's easier to visualize this with an example. Let's assume you want to
    make a messaging app and store each message in your local storage. In this case,
    `Entity` would be a `Message` object that will have an ID, and will contain the
    contents of the message, the sender, the time, status, and so on. In order to
    access messages from the local storage, you will need a `MessageDao`, which will
    contain methods such as `insertMessage()`, `getMessagesFromUser()`, `deleteMessage()`,
    and `updateMessage()`. Since it's a messaging application, you will need a `Contact`
    entity to hold information about the senders and receivers of a message. The `Contact`
    entity would contain information such as name, last online time, phone number,
    email, and so on. In order to access the contact information, you would need a
    `ContactDao` interface, which will contain `createUser()`, `updateUser()`, `deleteUser()`,
    and `getAllUsers()`. Both entities will create a matching table in SQLite that
    contains the fields we defined inside the entity classes as columns. In order
    to achieve this, we'll have to create a `MessagingDatabase` in which we will reference
    both of these entities.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，我们可以看到Room组件如何相互交互。通过一个例子更容易将其可视化。假设您想制作一个消息应用程序并将每条消息存储在本地存储中。在这种情况下，`Entity`将是一个包含ID的`Message`对象，它将包含消息的内容、发送者、时间、状态等。为了从本地存储中访问消息，您将需要一个`MessageDao`，其中将包含诸如`insertMessage()`、`getMessagesFromUser()`、`deleteMessage()`和`updateMessage()`等方法。由于这是一个消息应用程序，您将需要一个`Contact`实体来保存消息的发送者和接收者的信息。`Contact`实体将包含诸如姓名、最后在线时间、电话号码、电子邮件等信息。为了访问联系人信息，您将需要一个`ContactDao`接口，其中将包含`createUser()`、`updateUser()`、`deleteUser()`和`getAllUsers()`。两个实体将在SQLite中创建一个匹配的表，其中包含我们在实体类中定义的字段作为列。为了实现这一点，我们将不得不创建一个`MessagingDatabase`，在其中我们将引用这两个实体。
- en: In a world without Room or similar DAO libraries, we would need to use the Android
    Framework's SQLite components. This typically involves code when setting up our
    database, such as a query to create a table and applying similar queries for every
    table we would have. Every time we would query a table for data, we would need
    to convert the resulting object into a Java or Kotlin one. Then, for every object
    we updated or created, we would need to perform a conversion in the other direction
    and invoke the appropriate method. Room removes all this boilerplate code, allowing
    us to focus on our app's requirements.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有Room或类似的DAO库的世界中，我们需要使用Android框架的SQLite组件。这通常涉及到设置数据库时的代码，比如创建表的查询，并为每个表应用类似的查询。每次我们查询表中的数据时，我们都需要将结果对象转换为Java或Kotlin对象。然后，对于我们更新或创建的每个对象，我们都需要进行相反方向的转换并调用适当的方法。Room消除了所有这些样板代码，使我们能够专注于应用程序的需求。
- en: By default, Room does not allow any operations on the UI thread to enforce the
    Android standards related to input-output operations. In order to make asynchronous
    calls to access data, Room is compatible with a number of libraries and frameworks,
    such as Kotlin coroutines, RxJava, and `LiveData`, on top of its default definitions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Room不允许在UI线程上执行任何操作，以强制执行与输入输出操作相关的Android标准。为了进行异步调用以访问数据，Room与许多库和框架兼容，例如Kotlin协程、RxJava和`LiveData`，在其默认定义之上。
- en: Entities
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体
- en: 'Entities serve two purposes: to define the structure of tables and to hold
    the data from a table row. Let''s use our scenario of the messaging app and define
    two entities: one for the user and one for the message. The `User` entity will
    contain information about who sent the messages, while the `Message` entity will
    contain information about the contents of a message, the time it was sent, and
    a reference to the sender of the message. The following code snippet provides
    an example of how entities are defined with Room:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 实体有两个目的：定义表的结构和保存表行的数据。让我们使用消息应用程序的场景，并定义两个实体：一个用于用户，一个用于消息。`User`实体将包含有关谁发送消息的信息，而`Message`实体将包含有关消息内容、发送时间以及消息发送者的引用的信息。以下代码片段提供了如何使用Room定义实体的示例：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see, entities are just *data classes* with annotations that will
    tell Room how the tables should be built in SQLite. The annotations we used are
    as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，实体只是带有注释的*数据类*，这些注释将告诉Room如何在SQLite中构建表。我们使用的注释如下：
- en: The `@Entity` annotation defines the table. By default, the table name will
    be the name of the class. We can change the name of the table through the `tableName`
    method in the `Entity` annotation. This is useful in situations where we want
    our code obfuscated but wish to keep the consistency of the SQLite structure.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Entity`注释定义了表。默认情况下，表名将是类的名称。我们可以通过`Entity`注释中的`tableName`方法更改表的名称。在我们希望我们的代码被混淆但希望保持SQLite结构的一致性的情况下，这是有用的。'
- en: '`@ColumnInfo` defines configurations for a certain column. The most common
    one is the name of the column. We can also specify a default value, the SQLite
    type of the field, and whether the field should be indexed.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ColumnInfo`定义了特定列的配置。最常见的是列的名称。我们还可以指定默认值、字段的SQLite类型以及字段是否应该被索引。'
- en: '`@PrimaryKey` indicates what in our entity will make it unique. Every entity
    should have at least one primary key. If your primary key is an integer or a long,
    then we can add the `autogenerate` field. This means that every entity that gets
    inserted into the `Primary Key` field is automatically generated by SQLite. Usually,
    this is done by incrementing the previous ID. If you wish to define multiple fields
    as primary keys, then you can adjust the `@Entity` annotation to accommodate this;
    such as the following:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@PrimaryKey`指示我们的实体中将使其唯一的内容。每个实体应该至少有一个主键。如果您的主键是整数或长整数，那么我们可以添加`autogenerate`字段。这意味着每个插入到`Primary
    Key`字段的实体都将由SQLite自动生成。通常，这是通过递增前一个ID来完成的。如果您希望将多个字段定义为主键，那么可以调整`@Entity`注释以适应此情况；例如以下内容：'
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s assume that our messaging application wants to send locations. Locations
    have latitude, longitude, and name. We can add them to the `Message` class, but
    that would increase the complexity of the class. What we can do is create another
    entity and reference the ID in our class. The problem with this approach is that
    we would then query the `Location` entity every time we query the `Message` entity.
    Room has a third approach through the `@Embedded` annotation. Now, let''s look
    at the updated `Message` entity:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的消息应用程序想要发送位置。位置有纬度、经度和名称。我们可以将它们添加到`Message`类中，但这会增加类的复杂性。我们可以创建另一个实体并在我们的类中引用ID。这种方法的问题是，我们每次查询`Message`实体时都会查询`Location`实体。Room通过`@Embedded`注释提供了第三种方法。现在，让我们看看更新后的`Message`实体：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What this code does is add three columns (`lat`, `long`, and `location_name`)
    to the messages table. This allows us to avoid having objects with a large number
    of fields while keeping the consistency of our tables.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用是向消息表添加三列（`lat`、`long`和`location_name`）。这样可以避免对象具有大量字段，同时保持表的一致性。
- en: 'If we look at our entities, we''ll see that they exist independent of each
    other. The `Message` entity has a `userId` field, but there''s nothing preventing
    us from adding messages from invalid users. This may lead to situations where
    we collect data without any purpose. If we want to delete a particular user, along
    with their messages, then we have to do so manually. Room provides us with a way
    to define this relationship through a `ForeignKey`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看我们的实体，我们会发现它们是相互独立的。`Message`实体有一个`userId`字段，但没有任何阻止我们从无效用户添加消息。这可能导致我们收集没有任何目的的数据。如果我们想要删除特定用户以及他们的消息，那么我们必须手动执行。Room提供了一种通过`ForeignKey`定义这种关系的方法：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding example, we added the `foreignKeys` field and created a new
    `ForeignKey` to the `User` entity, while for the parent column, we defined the
    `user_id` field in the `User` class and for the child column, the `user` field
    in the `Message` class. Every time we add a message to the table, there needs
    to be a `User` entry in the `users` table. If we try to delete a user and there
    are any messages from that user that still exist, then, by default, this will
    not work because of the dependencies. However, we can tell Room to do a cascade
    delete, which will erase the user and the associated messages.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们添加了`foreignKeys`字段，并为`User`实体创建了一个新的`ForeignKey`，而对于父列，我们在`User`类中定义了`user_id`字段，对于子列，在`Message`类中定义了`user`字段。每次我们向表中添加消息时，`users`表中都需要有一个`User`条目。如果我们尝试删除一个用户，而仍然存在来自该用户的任何消息，那么默认情况下，这将不起作用，因为存在依赖关系。但是，我们可以告诉Room执行级联删除，这将删除用户和相关的消息。
- en: DAO
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DAO
- en: If entities specify how we define and hold our data, then DAOs specify what
    to do with that data. A DAO class is a place where we define our CRUD operations.
    Ideally, each entity should have a corresponding DAO, but there are situations
    where crossovers occur (usually, this happens when we have to deal with JOINs
    between two tables).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实体指定了我们如何定义和保存我们的数据，那么DAOs指定了对该数据的操作。DAO类是我们定义CRUD操作的地方。理想情况下，每个实体应该有一个对应的DAO，但也有一些情况发生了交叉（通常是在我们需要处理两个表之间的JOIN时发生）。
- en: 'Continuing with our previous example, let''s build some corresponding DAOs
    for our entity:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们之前的例子，让我们为我们的实体构建一些相应的DAOs。
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the case of our messages, we have defined the following functions: insert
    one or more messages, update one or more messages, delete one or more messages,
    and retrieve all the messages from a certain user that are older than a particular
    time. For our users, we can insert one user, update one user, delete one user,
    and retrieve all the users.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的消息，我们已经定义了以下函数：插入一个或多个消息，更新一个或多个消息，删除一个或多个消息，以及检索某个用户在特定时间之前的所有消息。对于我们的用户，我们可以插入一个用户，更新一个用户，删除一个用户，并检索所有用户。
- en: If you look at our `Insert` methods, you'll see we have defined that in the
    case of a conflict (when we try to insert something with an ID that already exists),
    it will replace the existing entry. The `Update` field has a similar configuration,
    but in our case, we have chosen the default. This means that nothing will happen
    if the update cannot occur.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查看我们的`Insert`方法，您会看到我们已经定义了在冲突的情况下（当我们尝试插入已经存在的ID的内容时），它将替换现有条目。`Update`字段具有类似的配置，但在我们的情况下，我们选择了默认值。这意味着如果更新无法发生，将不会发生任何事情。
- en: 'The `@Query` annotation stands out from all the others. This is where we use
    SQLite code to define how our read operations work. `SELECT *` means we want to
    read all the data for every row in the table, which will populate all our entities''
    fields. The `WHERE` clause indicates a restriction that we want to apply to our
    query. We can also define a method like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Query`注释与其他所有注释不同。这是我们使用SQLite代码定义读取操作的地方。`SELECT *`表示我们要读取表中每一行的所有数据，这将填充所有我们实体的字段。`WHERE`子句表示我们要应用于查询的限制。我们也可以定义一个方法如下：'
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This allows us to filter messages from multiple users.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以过滤来自多个用户的消息。
- en: 'We can define a new class like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个新类如下：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, we can define the following query:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义以下查询：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will allow us to extract information from certain columns at a time, not
    the entire row.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们一次从某些列中提取信息，而不是整行。
- en: 'Now, let''s say that you want to add the user information of the sender to
    every message. Here, we''ll need to use a similar approach to the one we used
    previously:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想要将发送者的用户信息添加到每条消息中。在这里，我们需要使用与之前相似的方法：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'By using the new data class, we can define this query:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用新的数据类，我们可以定义这个查询：
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now, we have the user information for every message we want to display. This
    will come in handy in scenarios such as group chats, where we should display the
    name of the sender of every message.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为要显示的每条消息都有了用户信息。这在诸如群聊之类的场景中会很有用，我们应该显示每条消息的发送者姓名。
- en: Setting Up the Database
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置数据库
- en: 'What we have so far is a bunch of DAOs and entities. Now, it''s time to put
    them together. First, let''s define our database:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一堆DAO和实体。现在是将它们放在一起的时候了。首先，让我们定义我们的数据库：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the `@Database` annotation, we specify what entities go in our database,
    and we also specify our version. Then, for every DAO, we define an abstract method
    in our `RoomDatabase`. This allows the build system to build a subclass of our
    class in which it provides the implementations for these methods. The build system
    will also create the tables related to our entities.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@Database`注解中，我们指定了哪些实体放入我们的数据库，还指定了我们的版本。然后，对于每个DAO，我们在`RoomDatabase`中定义了一个抽象方法。这允许构建系统构建我们类的子类，在其中为这些方法提供实现。构建系统还将创建与我们实体相关的表。
- en: The `getDatabase` method in the companion object is used to illustrate how we
    create an instance of the `ChatDatabase` class. Ideally, there should be one instance
    of the database for our application due to the complexity involved in building
    a new database object. This can be better achieved through a dependency injection framework.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 伴生对象中的`getDatabase`方法用于说明我们如何创建`ChatDatabase`类的实例。理想情况下，由于构建新数据库对象涉及的复杂性，我们的应用程序应该只有一个数据库实例。这可以通过依赖注入框架更好地实现。
- en: 'Let''s assume you''ve released your chat application. Your database is currently
    version 1, but your users are complaining that the message status feature is missing.
    You decide to add this feature in the next release. This involves changing the
    structure of the database, which can impact databases that have already built
    their structures. Luckily, Room offers something called a migration. In the migration,
    we can define how our database changed between versions 1 and 2\. So, let''s look
    at our example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经发布了你的聊天应用程序。你的数据库当前是版本1，但你的用户抱怨说消息状态功能缺失。你决定在下一个版本中添加这个功能。这涉及改变数据库的结构，可能会影响已经构建其结构的数据库。幸运的是，Room提供了一种叫做迁移的东西。在迁移中，我们可以定义我们的数据库在版本1和2之间的变化。所以，让我们看看我们的例子：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we added the status flag to the `Message` entity.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向`Message`实体添加了状态标志。
- en: 'Now, let''s look at our `ChatDatabase`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的`ChatDatabase`：
- en: '[PRE42]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In our database, we've increased the version to 2 and added a migration between
    versions 1 and 2\. Here, we added the status column to the table. We'll add this
    migration when we build the database. Once we've released the new code, when the
    updated app is opened and the code to build the database is executed, it will
    compare the version on the stored data with the one specified in our class and
    it will notice a difference. Then, it will execute the migrations we specified
    until it reaches the latest version. This allows us to maintain an application
    for years without impacting the user's experience.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的数据库中，我们将版本增加到2，并在版本1和2之间添加了迁移。在这里，我们向表中添加了状态列。当我们构建数据库时，我们将添加此迁移。一旦我们发布了新代码，当打开更新后的应用程序并执行构建数据库的代码时，它将比较存储数据上的版本与我们类中指定的版本，并注意到差异。然后，它将执行我们指定的迁移，直到达到最新版本。这使我们能够在多年内维护应用程序，而不影响用户的体验。
- en: 'If you look at our `Message` class, you may have noticed that we defined the
    time as a Long. In Java and Kotlin, we have the `Date` object, which may be more
    useful than the timestamp of the message. Luckily, Room has a solution for this
    in the form of TypeConverters. The following table shows what data types we can
    use in our code and the SQLite equivalent. Complex data types need to be brought
    down to these levels using TypeConverters:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看我们的`Message`类，你可能已经注意到我们将时间定义为Long。在Java和Kotlin中，我们有`Date`对象，这可能比消息的时间戳更有用。幸运的是，Room在TypeConverters中有解决方案。以下表格显示了我们可以在我们的代码中使用的数据类型和SQLite等效。需要使用TypeConverters将复杂数据类型降至这些级别：
- en: '![Figure 10.10: Relationship between Kotlin/Java data types and the SQLite
    data types'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.10：Kotlin/Java数据类型与SQLite数据类型之间的关系'
- en: '](img/B15216_10_10.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_10_10.jpg)'
- en: 'Figure 10.10: Relationship between Kotlin/Java data types and the SQLite data
    types'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10：Kotlin/Java数据类型与SQLite数据类型之间的关系
- en: 'Here, we''ve modified the `lastOnline` field so that it''s of the `Date` type:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们修改了`lastOnline`字段，使其为`Date`类型：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, we''ve defined a couple of methods that convert a `Date` object into
    a `Long` and vice versa. The `@TypeConverter` annotation helps Room identify where
    the conversion takes place:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一对方法，将`Date`对象转换为`Long`，反之亦然。`@TypeConverter`注解帮助Room识别转换发生的位置：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we''ll add our converter to Room through the `@TypeConverters` annotation:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过`@TypeConverters`注解将我们的转换器添加到Room中：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the next section, we will look at some third-party frameworks.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一些第三方框架。
- en: Third-Party Frameworks
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方框架
- en: 'Room works well with third-party frameworks such as LiveData, RxJava, and coroutines.
    This solves two issues: multi-threading and observing data changes.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Room与LiveData、RxJava和协程等第三方框架很好地配合。这解决了多线程和观察数据变化的两个问题。
- en: '`LiveData` will make the `@Query` annotated methods in your DAOs reactive,
    which means that if new data is added, `LiveData` will notify the observers of
    this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveData`将使DAO中的`@Query`注解方法具有反应性，这意味着如果添加了新数据，`LiveData`将通知观察者：'
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Kotlin coroutines complement `LiveData` by making the `@Insert`, `@Delete`,
    and `@Update` methods asynchronous:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin协程通过使`@Insert`、`@Delete`和`@Update`方法异步化来补充`LiveData`：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`@Query` methods reactive through components such as `Publisher`, `Observable`,
    or `Flowable` and making the rest of the methods asynchronous through `Completable`,
    `Single`, or `Maybe`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Query`方法通过`Publisher`、`Observable`或`Flowable`等组件变得响应式，并通过`Completable`、`Single`或`Maybe`等使其余的方法异步化：'
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Executors and threads** come with the Java framework and can be a useful
    solution to solve threading issues with Room if none of the aforementioned third-party
    integrations are part of your project. Your DAO classes will not suffer from any
    modifications; however, you will need the components that access your DAOs to
    adjust and use either an executor or a thread:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行器和线程**是Java框架自带的，如果你的项目中没有前面提到的第三方集成，它们可以是解决Room中线程问题的有用解决方案。你的DAO类不会受到任何修改的影响；然而，你需要访问DAO的组件来调整并使用执行器或线程：'
- en: '[PRE49]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'An example of accessing the DAO is as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 访问DAO的一个例子如下：
- en: '[PRE50]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The preceding example will create a new thread and start it every time we want
    to retrieve the list of users. There are two major issues with this code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子将创建一个新的线程，并在每次我们想要检索用户列表时启动它。这段代码有两个主要问题：
- en: Thread creation is an expensive operation
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程创建是一个昂贵的操作
- en: The code is hard to test
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码很难测试
- en: The solution to the first issue can be solved with `ThreadPools` and `Executors`.
    The Java framework offers a robust set of options when it comes to `ThreadPools`.
    A thread pool is a component that is responsible for thread creation and destruction
    and allows the developer to specify the number of threads in the pool. Multiple
    threads in a thread pool will ensure that multiple tasks can be executed concurrently.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题的解决方案可以通过`ThreadPools`和`Executors`来解决。Java框架在`ThreadPools`方面提供了强大的选项。线程池是一个负责线程创建和销毁的组件，并允许开发人员指定池中的线程数量。线程池中的多个线程将确保可以同时执行多个任务。
- en: 'We can rewrite the preceding code as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将上面的代码重写如下：
- en: '[PRE51]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding example, we defined an executor that will use a pool of 1 thread.
    When we want to access the list of users, we move the query inside the executor,
    and when the data is loaded, our callback lambda will be invoked.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们定义了一个使用1个线程池的执行器。当我们想要访问用户列表时，我们将查询放在执行器内部，当数据加载时，我们的回调lambda将被调用。
- en: 'Exercise 10.05: Making a Little Room'
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.05：做一个小小的Room
- en: You have been hired by a news agency to build a news application. The application
    will display a list of articles written by journalists. An article can be written
    by one or more journalists, and each journalist can write one or more articles.
    The data information for each article includes the article's title, content, and
    date. The journalist's information includes their first name, last name, and job
    title. You will need to build a Room database that holds this information so it
    can be tested.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你被一家新闻机构聘用来构建一个新闻应用程序。该应用程序将显示由记者撰写的文章列表。一篇文章可以由一个或多个记者撰写，每个记者可以撰写一篇或多篇文章。每篇文章的数据信息包括文章的标题、内容和日期。记者的信息包括他们的名字、姓氏和职称。你需要构建一个Room数据库来保存这些信息以便进行测试。
- en: 'Before we start, let''s look at the relationship between the entities. In the
    chat application example, we defined the rule that one user can send one or multiple
    messages. This relationship is known as a one-to-many relationship. That relationship
    is implemented as a reference between one entity to another (the user was defined
    in the message table in order to be connected to the sender). In this case, we
    have a many-to-many relationship. In order to implement a many-to-many relationship,
    we need to create an entity that''s holding references that will link the other
    two entities. Let''s get started:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们看一下实体之间的关系。在聊天应用程序的例子中，我们定义了一个用户可以发送一个或多个消息的规则。这种关系被称为一对多关系。这种关系被实现为一个实体对另一个实体的引用（用户在消息表中被定义，以便与发送者连接）。在这种情况下，我们有一个多对多的关系。为了实现多对多的关系，我们需要创建一个实体，它持有将连接另外两个实体的引用。让我们开始吧：
- en: 'Let''s start by adding the annotation processing plugin to `app/build.gradle`.
    This will read the annotations used by Room and generate the code necessary for
    interacting with the database:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先在`app/build.gradle`中添加注解处理插件。这将读取Room使用的注解，并生成与数据库交互所需的代码：
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, let''s add the Room libraries in `app/build.gradle`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`app/build.gradle`中添加Room库：
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The first line defines the library version, the second line brings in the Room
    library for Java and Kotlin, and the last line is for the Kotlin annotation processor.
    This allows the build system to generate boilerplate code from the Room annotations.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行定义了库版本，第二行引入了Java和Kotlin的Room库，最后一行是Kotlin注解处理器。这允许构建系统从Room注解中生成样板代码。
- en: 'Let''s define our entities:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义我们的实体：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, define the entity that connects the journalist to the article and the
    appropriate constraints:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义连接记者和文章以及适当的约束的实体：
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding code, we defined our connecting entity. As you can see, we
    haven't defined an ID for uniqueness, but both the article and the journalist,
    when used together, will be unique. We also defined foreign keys for each of the
    other entities referred to by our entity.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们定义了我们的连接实体。正如你所看到的，我们没有为唯一性定义ID，但是当文章和记者一起使用时，它们将是唯一的。我们还为我们的实体引用的每个其他实体定义了外键。
- en: 'Create the `ArticleDao` DAO:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ArticleDao` DAO：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, create the `JournalistDao` data access object:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建`JournalistDao`数据访问对象：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create the `JoinedArticleJournalistDao` DAO:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`JoinedArticleJournalistDao` DAO：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Let's analyze our code a little bit. For the articles and journalists, we have
    the ability to add, insert, delete, and update queries. For articles, we have
    the ability to extract all of the articles but also extract articles from a certain
    author. We also have the option to extract all the journalists that wrote an article.
    This is done through a JOIN with our intermediary entity. For that entity, we
    define the options to insert (which will link an article to a journalist) and
    delete (which will remove that link).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微分析一下我们的代码。对于文章和记者，我们有添加、插入、删除和更新查询的能力。对于文章，我们有提取所有文章的能力，还可以从特定作者提取文章。我们还有选项来提取写过文章的所有记者。这是通过与我们的中间实体进行JOIN来完成的。对于该实体，我们定义了插入选项（将文章链接到记者）和删除选项（将删除该链接）。
- en: 'Finally, let''s define our `Database` class:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们定义我们的`Database`类：
- en: '[PRE59]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We avoided defining the `getInstance` method here because we won't be calling
    the database anywhere. But if we don't do that, how will we know if it works?
    The answer to this is that we'll test it. This won't be a test that will run on
    your machine but one that will run on the device. This means that we will create
    it in the `androidTest` folder.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免在这里定义`getInstance`方法，因为我们不会在任何地方调用数据库。但如果我们不这样做，我们怎么知道它是否有效？答案是我们将测试它。这不会是在您的计算机上运行的测试，而是在设备上运行的测试。这意味着我们将在`androidTest`文件夹中创建它。
- en: 'Let''s start by setting up the test data. Here, we will add some articles and
    journalists to the database:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从设置测试数据开始。在这里，我们将向数据库中添加一些文章和记者：
- en: '[PRE60]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s test whether the data is updated:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试数据是否已更新：
- en: '[PRE61]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, let''s test clearing the data:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们测试清除数据：
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, we have defined a few examples of how to test a Room database. What's
    interesting is how we build the database. Our database is an in-memory database.
    This means that all the data will be kept as long as the test is run and will
    be discarded afterward. This allows us to start with a clean slate for each new
    state and avoids the consequences of each of our testing sessions affecting each
    other. In our test, we've set up five articles and ten journalists. The first
    article was written by the top two journalists, while the second article was written
    by the first journalist. The rest of the articles have no authors. By doing this,
    we can test our update and delete methods. For the delete method, we can test
    our foreign key relationship as well. In the test, we can see that if we delete
    article 1, it will delete the relationship between the article and the journalists
    that wrote it. When testing your database, you should add the scenarios that your
    app will use. Feel free to add other testing scenarios and improve the preceding
    tests in your own database.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一些测试Room数据库的示例。有趣的是我们如何构建数据库。我们的数据库是一个内存数据库。这意味着只要测试运行，所有数据都将被保留，并在之后被丢弃。这使我们可以为每个新状态从零开始，并避免每个测试会话的后果相互影响。在我们的测试中，我们设置了五篇文章和十位记者。第一篇文章是由前两位记者写的，而第二篇文章是由第一位记者写的。其余的文章没有作者。通过这样做，我们可以测试我们的更新和删除方法。对于删除方法，我们还可以测试我们的外键关系。在测试中，我们可以看到，如果我们删除文章1，它将删除文章和写作它的记者之间的关系。在测试数据库时，您应该添加您的应用程序将使用的场景。请随意添加其他测试场景，并改进您自己数据库中的先前测试。
- en: Customizing Life Cycles
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义生命周期
- en: 'Previously, we discussed `LiveData` and how it can be observed through a `LifecycleOwner`.
    We can use LifecycleOwners to subscribe to a `LifecycleObserver` so that it will
    monitor when the state of an owner changes. This is useful in situations where
    you would want to trigger certain functions when certain life cycle callbacks
    are invoked; for example, requesting locations, starting/stopping videos, and
    monitoring connectivity changes from your activity/fragment. We can achieve this
    with the use of a `LifecycleObserver`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了`LiveData`以及如何通过`LifecycleOwner`观察它。我们可以使用LifecycleOwners订阅`LifecycleObserver`，以便它将监视所有者状态的变化。这在您希望在调用特定生命周期回调时触发某些函数的情况下非常有用；例如，从您的活动/片段请求位置、启动/停止视频以及监视连接更改。我们可以通过使用`LifecycleObserver`来实现这一点。
- en: '[PRE63]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the preceding code, we have defined a class that implements the `LifecycleObserver`
    interface and defined a method that will be called when the life cycle goes into
    the `ON_START` event. The `@OnLifecycleEvent` annotation will be used by the build
    system to generate boilerplate code that will invoke the annotation it is used
    for.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们定义了一个实现`LifecycleObserver`接口的类，并定义了一个在生命周期进入`ON_START`事件时将被调用的方法。`@OnLifecycleEvent`注解将被构建系统用于生成调用它所用于的注解的样板代码。
- en: 'What we need to do next is register our observer in the activity/fragment:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在活动/片段中注册我们的观察者：
- en: '[PRE64]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding code, we registered the observer on a `Lifecycle` object. The
    `Lifecycle` object is inherited from the parent activity class through the `getLifecycle()`
    method.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们在`Lifecycle`对象上注册了观察者。`Lifecycle`对象是通过`getLifecycle()`方法从父活动类继承的。
- en: Note
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`LiveData` are specialized uses of this principle. In the `LiveData` scenario,
    you would have multiple LifecycleOwners subscribing to a single `LiveData`. Here,
    you can just subscribe new owners for the same `LifecycleOwner`.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`LiveData`是这一原则的专门用途。在`LiveData`场景中，您可以有多个LifecycleOwners订阅单个`LiveData`。在这里，您可以为相同的`LifecycleOwner`订阅新的所有者。'
- en: 'Exercise 10.06: Reinventing the Wheel'
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.06：重新发明轮子
- en: 'In this exercise, we will implement a custom `LifecycleOwner` that triggers
    the `Lifecycle.Event.ON_START` event in `ToastyLifecycleObserver` when the activity
    starts. Let''s get started by creating a new Android Studio Project with an empty
    activity named SplitActivity:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将实现一个自定义的`LifecycleOwner`，当活动启动时，它将触发`ToastyLifecycleObserver`中的`Lifecycle.Event.ON_START`事件。让我们开始创建一个名为SplitActivity的空活动的新Android
    Studio项目：
- en: 'Let''s start by adding the observer to our activity:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从将观察者添加到我们的活动开始：
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If you run the code and open the activity, rotate the device, put the app in
    the background, and resume the app, you will see the `Started` toast.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行代码并打开活动，旋转设备，将应用程序置于后台，然后恢复应用程序，您将看到`Started`提示。
- en: 'Now, define a new activity that will reinvent the wheel and make it worse:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，定义一个新的活动，将重新发明轮子并使其变得更糟：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the `AndroidManifest.xml` file you can replace the SplitActivity with LifecycleActivity
    and it will look something like this
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AndroidManifest.xml`文件中，您可以用LifecycleActivity替换SplitActivity，效果会是这样的
- en: '[PRE67]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: If we run the preceding code, we will see that a toast will appear every time
    an activity is started.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，我们将看到每次启动活动时都会出现一个提示。
- en: '![Figure 10.11: Output of Exercise 10.06'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.11：练习10.06的输出'
- en: '](img/B15216_10_11.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_10_11.jpg)'
- en: 'Figure 10.11: Output of Exercise 10.06'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11：练习10.06的输出
- en: Notice that this is triggered without overriding the `onStart()` method from
    the `Activity` class. You can further experiment with the `LifecycleObserver`
    class to trigger the toast in other states of the `Activity` class.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是在不覆盖`Activity`类的`onStart()`方法的情况下触发的。您可以进一步尝试使用`LifecycleObserver`类来触发`Activity`类的其他状态中的提示。
- en: Now, let's analyze the code for our new activity. Notice that we've extended
    the activity and not the `AppCompatActivity` class. This is because the `AppCompatActivity`
    class already contains the `LifecycleRegistry` logic. In our new activity, we
    defined a `LifecycleRegistry`, which will be responsible for adding our observers
    and changing the states. Then, we implemented the `LifecycleOwner` interface and
    in the `getLifecycle()` method, we return `LifecycleRegistry`. Then, for each
    of our callbacks, we can change the state of the registry. In the `onCreate()`
    method, we set the registry in the `CREATED` state (which will trigger the `ON_CREATE`
    event on the LifecycleObservers) and then we registered our `LifecycleObserver`.
    In order to achieve our task, we sent the `STARTED` event in the `onStop()` method.
    If we run the preceding example and minimize our activity, we should see our `Started`
    toast.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析一下我们新活动的代码。请注意，我们扩展了活动而不是`AppCompatActivity`类。这是因为`AppCompatActivity`类已经包含了`LifecycleRegistry`逻辑。在我们的新活动中，我们定义了一个`LifecycleRegistry`，它将负责添加我们的观察者和改变状态。然后，我们实现了`LifecycleOwner`接口，并在`getLifecycle()`方法中返回`LifecycleRegistry`。然后，对于我们的每个回调，我们可以改变注册表的状态。在`onCreate()`方法中，我们将注册表设置为`CREATED`状态（这将触发`LifecycleObservers`上的`ON_CREATE`事件），然后我们注册了我们的`LifecycleObserver`。为了实现我们的任务，我们在`onStop()`方法中发送了`STARTED`事件。如果我们运行上述示例并最小化我们的活动，我们应该会看到我们的`Started`提示。
- en: 'Activity 10.01: Shopping Notes App'
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动10.01：购物笔记应用
- en: 'You want to keep track of your shopping items, so you decide to build an app
    in which you can save the items you wish to buy during your next trip to the store.
    The requirements for this are as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您想跟踪您的购物物品，因此决定构建一个应用程序，您可以在其中保存您希望在下次去商店时购买的物品。此需求如下：
- en: 'The UI will be split into two: top/bottom in portrait mode and left/right in
    landscape mode. The UI will look similar to what is shown in the following screenshot.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI将分为两部分：纵向模式为上/下，横向模式为左/右。UI将类似于以下截图所示。
- en: The first half will display the number of notes, a text field, and a button.
    Every time the button is pressed, a note will be added with the text that was
    placed in the text field.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一半将显示笔记的数量、文本字段和按钮。每次按下按钮时，将使用放置在文本字段中的文本添加一个笔记。
- en: The second half will display the list of notes.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二半将显示笔记列表。
- en: For each half, you will have a View model that will hold the relevant data.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每一半，您将拥有一个将保存相关数据的视图模型。
- en: You should define a repository that will be used on top of the Room database
    to access your data.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该定义一个存储库，它将在Room数据库之上使用以访问您的数据。
- en: You should also define a Room database that will hold your notes.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还应该定义一个Room数据库，用于保存您的笔记。
- en: 'The note entity will have the following attributes: id, text:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记实体将具有以下属性：id、text：
- en: '![Figure 10.12: Example of a possible output for Activity 10.01'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.12：活动10.01可能的输出示例'
- en: '](img/B15216_10_12.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B15216_10_12.jpg)'
- en: 'Figure 10.12: Example of a possible output for Activity 10.01'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12：活动10.01可能的输出示例
- en: 'Perform the following steps to complete this activity:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Start with Room integration by creating the `Entity`, `Dao`, and `Database`
    methods. For `Dao`, the `@Query` annotated methods can directly return a `LiveData`
    object so that if the data changes, the observers can be directly notified.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建`Entity`、`Dao`和`Database`方法开始Room集成。对于`Dao`，`@Query`注释的方法可以直接返回`LiveData`对象，以便如果数据发生更改，观察者可以直接收到通知。
- en: Define a template of our repository in the form of an interface.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以接口形式定义我们的存储库的模板。
- en: Implement the repository. The repository will have one reference to the `Dao`
    object we defined previously. The code for inserting the data will need to be
    moved to a separate thread. Create the `NotesApplication` class to provide one
    instance of the repository that will be used across the application. Make sure
    to update the `<application>` tag in the `AndroidManifest.xml` file to add your
    new application class.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现存储库。存储库将有一个对我们之前定义的`Dao`对象的引用。插入数据的代码需要移动到一个单独的线程。创建`NotesApplication`类以提供将在整个应用程序中使用的存储库的一个实例。确保更新`AndroidManifest.xml`文件中的`<application>`标签，以添加您的新应用程序类。
- en: 'Unit test the repository and define `ViewModels`, as follows:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对存储库进行单元测试并定义`ViewModels`，如下所示：
- en: Define `NoteListViewModel` and the associated test. This will have a reference
    to the repository and return the list of notes.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`NoteListViewModel`和相关测试。这将引用存储库并返回笔记列表。
- en: Define `CountNotesViewModel` and the associated test. `CountViewModel` will
    have a reference to the repository and return the total number of notes as a `LiveData`.
    It will also be responsible for inserting new notes.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`CountNotesViewModel`和相关测试。`CountViewModel`将引用存储库并返回`LiveData`的笔记总数。它还将负责插入新的笔记。
- en: Define `CountNotesFragment` and the associated `fragment_count_notes.xml` layout.
    In the layout, define a `TextView` that will display the total number, an `EditText`
    for the name of the new notes, and a button that will insert the note that was
    introduced in `EditText`.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`CountNotesFragment`及其关联的`fragment_count_notes.xml`布局。在布局中，定义一个将显示总数的`TextView`，一个用于新笔记名称的`EditText`，以及一个将插入`EditText`中引入的笔记的按钮。
- en: Define an adapter for the list of notes called `NoteListAdapter` and an associated
    layout file for the rows called `view_note_item.xml`.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为笔记列表定义一个适配器，名为`NoteListAdapter`，并为行定义一个关联的布局文件，名为`view_note_item.xml`。
- en: Define the associated layout file, called `fragment_note_list.xml`, which will
    contain a `RecyclerView`. The layout will be used by `NoteListFragment`, which
    will connect `NoteListAdapter` to `RecyclerView`. It will also observe the data
    from `NoteListViewModel` and update the adapter.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义关联的布局文件，名为`fragment_note_list.xml`，其中将包含一个`RecyclerView`。该布局将被`NoteListFragment`使用，它将连接`NoteListAdapter`到`RecyclerView`。它还将观察来自`NoteListViewModel`的数据并更新适配器。
- en: Define `NotesActivity` with an associated layout for landscape mode and portrait
    mode.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为横向模式和纵向模式定义`NotesActivity`及其关联的布局。
- en: Make sure you have all the necessary data in `strings.xml`.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你在`strings.xml`中有所有必要的数据。
- en: Note
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to this activity can be found at: http://packt.live/3sKj1cp'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在以下网址找到：http://packt.live/3sKj1cp
- en: Summary
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we analyzed the building blocks required to build a maintainable
    application. We also looked into one of the most common issues that developers
    come across when using the Android Framework, which is maintaining the states
    of objects during life cycle changes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了构建可维护应用程序所需的基本组件。我们还研究了在使用Android框架时开发人员经常遇到的最常见问题之一，即在生命周期更改期间维护对象的状态。
- en: We started by analyzing `ViewModels` and how they solve the issue of holding
    data during orientation changes. We added `LiveData` to `ViewModels` to show how
    the two complement each other.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先分析了`ViewModels`以及它们如何解决在方向更改期间保存数据的问题。我们将`LiveData`添加到`ViewModels`中，以展示它们如何互补。
- en: We then moved on to Room to show how we can persist data with minimal effort
    and without a lot of SQLite boilerplate code. We also explored one-to-many and
    many-to-many relationships, as well as how to migrate data and break down complex
    objects into primitives for storage.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向Room，展示了如何在不需要大量SQLite样板代码的情况下轻松持久化数据。我们还探讨了一对多和多对多关系，以及如何迁移数据并将复杂对象分解为存储的基本类型。
- en: After that, we reinvented the `Lifecycle` wheel in order to show how `LifecycleOwners`
    and `LifecycleObservers` interact.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们重新发明了`Lifecycle`轮，以展示`LifecycleOwners`和`LifecycleObservers`如何交互。
- en: We also built our first repository, which we will expand upon in the following
    chapters when other data sources are added into the mix.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还建立了我们的第一个存储库，在接下来的章节中，当其他数据源被添加到其中时，我们将对其进行扩展。
- en: The activity we completed in this chapter serves as an example of what direction
    Android apps are heading in. However, this was not a complete example due to the
    numerous frameworks and libraries that you will discover that give developers
    the flexibility to go in different directions.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完成的活动作为Android应用程序发展方向的一个示例。然而，由于您将发现许多框架和库，这并不是一个完整的示例，这些框架和库将为开发人员提供灵活性，使他们能够朝不同的方向发展。
- en: 'The information you''ve learned about in this chapter will serve you well for
    the next one, which will expand on the concept of repositories. This will allow
    you to save data that''s been obtained from a server into a room database. The
    concept of persisting data will also be expanded on as you will explore other
    ways to persist data, such as through `SharedPreferences` and files. Our focus
    will be on certain types of files: media files obtained from the camera of the
    device.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中学到的信息将为下一章服务，下一章将扩展存储库的概念。这将允许您将从服务器获取的数据保存到Room数据库中。持久化数据的概念也将得到扩展，您将探索通过`SharedPreferences`和文件等其他持久化数据的方式。我们将重点放在某些类型的文件上：从设备相机获取的媒体文件。
