- en: Chapter 3. Handling Inputs and Outputs with GPIOs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。使用GPIO处理输入和输出
- en: In the last chapter, you prepared your development PC and BBBAndroid system
    for the development of hardware-interfacing Android apps. Now that your development
    environment is set up and ready to go, you will begin exploring your very first
    app that is capable of direct communication with hardware connected to the BBB.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您为开发硬件接口Android应用程序准备了开发PC和BBBAndroid系统。现在您的开发环境已经设置好，准备就绪，您将开始探索您的第一个能够直接与连接到BBB的硬件进行通信的应用程序。
- en: '**General**-**Purpose Input/Output** (**GPIO**) is one of the most basic interfaces
    in digital electronics. In the examples within this chapter, you will be working
    with GPIOs to receive digital input signals from the outside world and send digital
    output signals back in response. While this is a small start, it is the first
    step in developing and understanding hardware-interfacing apps that are much more
    complex. GPIOs can be used to implement complex and powerful interfacing logic.
    We will discuss both the hardware and software sides of GPIO interfacing and explain
    how calling Java methods in Android apps can interface with low-level hardware-interfacing
    code.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用**-**目的输入/输出**（**GPIO**）是数字电子学中最基本的接口之一。在本章的示例中，您将使用GPIO从外部世界接收数字输入信号，并发送数字输出信号作为响应。虽然这只是一个小的开始，但这是开发和理解更复杂的硬件接口应用程序的第一步。GPIO可以用于实现复杂和强大的接口逻辑。我们将讨论GPIO接口的硬件和软件两方面，并解释在Android应用中调用Java方法如何与低级硬件接口代码进行接口。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding GPIOs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解GPIO
- en: Building a GPIO interface circuit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建GPIO接口电路
- en: Including PacktHAL within your apps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用程序中包括PacktHAL
- en: Exploring the GPIO example app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索GPIO示例应用程序
- en: Understanding GPIOs
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解GPIO
- en: At its most basic level, communication between two pieces of hardware requires
    the transmission of data back and forth between them. In computer systems, this
    data is represented as voltage levels sent over a wire that connects the devices
    together. The patterns and levels of voltage back and forth form a communication
    protocol that the devices use to transmit data between each other.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的层面上，两个硬件设备之间的通信需要在它们之间来回传输数据。在计算机系统中，这些数据被表示为通过连接设备的导线发送的电压级别。来回的电压模式和级别形成了设备用于在彼此之间传输数据的通信协议。
- en: GPIO is the most basic interfacing option offered by microcontrollers and microprocessors.
    Some pins of the BBB's processor are allocated as GPIOs that act as an *input*
    (monitoring voltage on the wire to receive data) or an *output* (placing a particular
    voltage on the wire to send data). The BBB has dozens of available GPIO pins,
    which makes GPIO a flexible and simple way for Android apps to interact with the
    outside world without requiring fancy device drivers or extra interfacing hardware.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO是微控制器和微处理器提供的最基本的接口选项。BBB处理器的一些引脚被分配为GPIO，可以作为*输入*（监视导线上的电压以接收数据）或*输出*（在导线上放置特定电压以发送数据）。BBB有数十个可用的GPIO引脚，这使得GPIO成为Android应用与外部世界交互的灵活简单的方式，而无需花哨的设备驱动程序或额外的接口硬件。
- en: Nuts and bolts of GPIO
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPIO的要点
- en: Digital logic operates on the concept that there are two discrete voltage levels
    that represent an *on/high* state and an *off/low* state. By toggling between
    these two states, binary bits of data are transmitted between devices. The BBB
    uses the voltage of 3.3 V for its high level and a voltage of 0 V (connected to
    a ground) for the low level. This voltage scheme is known as a *3.3 V logic level*,
    and it is commonly used for single-board computers such as the BeagleBoard and
    Raspberry Pi. Many microcontrollers (many Arduinos, for example) use a 5 V logic
    level instead.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 数字逻辑是基于两个离散电压级别代表*开/高*状态和*关/低*状态的概念。通过在这两种状态之间切换，二进制数据位在设备之间传输。BBB使用3.3V的电压作为高电平，0V的电压（接地）作为低电平。这种电压方案被称为*3.3V逻辑电平*，通常用于BeagleBoard和Raspberry
    Pi等单板计算机。许多微控制器（例如许多Arduino）使用5V逻辑电平。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Never apply more than 3.3 V to any BBB pin!**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**永远不要将超过3.3V的电压应用到任何BBB引脚上！**'
- en: Applying greater than 3.3 V to a BBB GPIO can fry the BBB's processor, so always
    make sure that you only work with a maximum of 3.3 V when designing the GPIO interface
    circuitry for the BBB. Pins P9.3/4 supply 3.3 V, and pins P9.5/6 supply 5 V. It
    is very simple to accidentally connect a breadboard wire to the pins supplying
    5 V when you intended to use the 3.3 V pins. To help avoid this mistake, try covering
    the P9.5/6 pins with a piece of tape. This prevents you from accidentally inserting
    a breadboard wire into these pins.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将大于3.3V的电压应用到BBB的GPIO可能会烧毁BBB的处理器，因此请确保在设计BBB的GPIO接口电路时只使用最大3.3V。引脚P9.3/4提供3.3V，引脚P9.5/6提供5V。当你打算使用3.3V引脚时，很容易意外地将面包板导线连接到提供5V的引脚。为了避免这种错误，可以尝试用一小块胶带覆盖P9.5/6引脚。这可以防止你意外地将面包板导线插入这些引脚。
- en: The BBB's processor has four banks of GPIOs, with 32 individual GPIOs in each
    bank. With only 92 pins available on the P8/9 connectors, it is not possible to
    give every GPIO access to the outside world. In fact, the BBB's System Reference
    Manual shows that it is only possible to mux about 65 unique GPIOs to P8/P9 at
    the same time, even if every other feature being muxed to P8/9 was disabled. There
    are a few other GPIOs that are used internally for tasks such as lighting and
    blinking the BBB's LEDs, but you should consider yourself restricted to only using
    the GPIOs that are accessible via P8/P9 and that do not conflict with any of the
    standard BBB features.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: BBB的处理器有四个GPIO组，每个组有32个独立的GPIO。在P8/9连接器上只有92个引脚可用，不可能让每个GPIO都能访问外部世界。事实上，BBB的系统参考手册显示，即使将所有其他功能都禁用，也只能将大约65个唯一的GPIO复用到P8/P9上。还有一些其他用于诸如点亮和闪烁BBB
    LED等任务的GPIO，但你应该考虑自己只能使用通过P8/P9访问且不与任何标准BBB功能冲突的GPIO。
- en: GPIO access methods under Android
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android下的GPIO访问方法
- en: 'There are two basic approaches to interacting with GPIOs on the BBB: **file
    I/O** and **memory-mapping**. With the file I/O, you pass GPIO requests through
    a kernel driver by reading and writing to GPIO files in the filesystem. With memory-mapping,
    you map the GPIO control resistors into memory and then read and write these mapped
    memory locations to directly manipulate the control resistors. As both of these
    methods are made possible by the Linux kernel, they will both work just as well
    under Android as they do under Linux.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在BBB上与GPIO交互有两种基本方法：**文件I/O**和**内存映射**。通过文件I/O，您可以通过在文件系统中读写GPIO文件来将GPIO请求传递给内核驱动程序。通过内存映射，您可以将GPIO控制电阻器映射到内存中，然后读写这些映射的内存位置以直接操作控制电阻器。由于这两种方法都是由Linux内核实现的，因此它们在Android下的工作方式与在Linux下一样。
- en: Pros and cons of the file I/O method
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件I/O方法的优缺点
- en: The file I/O method can be performed by any process that has the proper permissions
    to read/write the GPIO device files. However, like any file I/O operation, this
    can be quite slow.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 文件I/O方法可以由具有适当权限的任何进程执行，以读/写GPIO设备文件。但是，像任何文件I/O操作一样，这可能会非常慢。
- en: Pros and cons of the memory-mapping method
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存映射方法的优缺点
- en: The memory-mapping method allows you to directly access the resistors that control
    the GPIOs. Memory-mapping is very fast (about 1000 times faster than file I/O!),
    but only processes with root permissions can use it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射方法允许您直接访问控制GPIO的电阻器。内存映射非常快（大约比文件I/O快1000倍！），但只有具有root权限的进程才能使用它。
- en: As your apps are unable to execute with root permissions without some serious
    permission changes, you will be unable to use memory-mapping to access GPIOs.
    This effectively restricts you to only using file I/O for your apps.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的应用程序无法在没有一些严重的权限更改的情况下以root权限执行，因此您将无法使用内存映射来访问GPIO。这实际上将限制您只能为应用程序使用文件I/O。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: PacktHAL implements both memory-mapping and file I/O for GPIO access. If you
    are interested in the low-level details of how both of these approaches work,
    examine the `jni/gpio.c` file in `PacktHAL.tgz`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: PacktHAL实现了内存映射和文件I/O以进行GPIO访问。如果您对这两种方法的工作原理感兴趣，请查看`PacktHAL.tgz`中的`jni/gpio.c`文件。
- en: Preparing Android for GPIO use
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为GPIO使用准备Android
- en: In [Chapter 2](part0019_split_000.html#page "Chapter 2. Interfacing with Android"),
    *Interfacing with Android*, you used `adb` to push two prebuilt files from PacktHAL
    to your Android system. These two files, `BB-PACKTPUB-00A0.dtbo` and `init.{ro.hardware}.rc`,
    configure your Android system to enable specific GPIOs and allow your apps to
    access them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0019_split_000.html#page "Chapter 2. Interfacing with Android")*与Android接口*中，您使用`adb`将两个预构建文件从PacktHAL推送到Android系统。这两个文件，`BB-PACKTPUB-00A0.dtbo`和`init.{ro.hardware}.rc`，配置了您的Android系统以启用特定的GPIO，并允许您的应用程序访问它们。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that when we talk about the `init.{ro.hardware}.rc` file, we are referring
    to the `init.genericam33xx(flatteneddevice.tr` file in the root directory of the
    Android filesystem.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论`init.{ro.hardware}.rc`文件时，我们指的是Android文件系统根目录中的`init.genericam33xx(flatteneddevice.tr`文件。
- en: 'The `BB-PACKTPUB-00A0.dtbo` file is a Device Tree overlay that muxes the BBB
    to support all of the examples in this book. As far as GPIOs are concerned, this
    overlay muxes the P9.11 and P9.13 pins into GPIOs. In the `PacktHAL.tgz` file,
    the source code for the overlay is located in the `cape/BB-PACKTPUB-00A0.dts`
    file. The code responsible for muxing the two GPIOs is located in the `bb_gpio_pins`
    node within `fragment@0`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`BB-PACKTPUB-00A0.dtbo`文件是一个设备树叠加，将BBB复用为支持本书中所有示例的设备。就GPIO而言，此叠加将P9.11和P9.13引脚复用为GPIO。在`PacktHAL.tgz`文件中，叠加的源代码位于`cape/BB-PACKTPUB-00A0.dts`文件中。负责复用这两个GPIO的代码位于`fragment@0`中的`bb_gpio_pins`节点中：'
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The details of the hex values used in the `bb_gpio_pins` node are beyond the
    scope of this book. However, the general idea is that they specify which pin is
    of interest, which mode the pin should be muxed to, a few details about pull-up/pull-down
    resistors, whether it is an input or an output pin, and whether any skewing adjustments
    should be made to the signal.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`bb_gpio_pins`节点中使用的十六进制值的详细信息超出了本书的范围。但是，一般的想法是它们指定了感兴趣的引脚，引脚应该被复用到的模式，关于上拉/下拉电阻器的一些细节，它是输入引脚还是输出引脚，以及是否应该对信号进行任何偏移调整。'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The details of what skew is and how to adjust for it are beyond the scope of
    this book. If you would like to learn more about skewing, we suggest the Wikipedia
    page on the subject as a good starting point ([http://en.wikipedia.org/wiki/Clock_skew](http://en.wikipedia.org/wiki/Clock_skew)).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 偏移是什么以及如何调整它的详细信息超出了本书的范围。如果您想了解更多关于偏移的信息，我们建议您从维基百科上关于这个主题的页面开始（[http://en.wikipedia.org/wiki/Clock_skew](http://en.wikipedia.org/wiki/Clock_skew)）。
- en: At boot, this overlay is loaded by the `init.{ro.hardware}.rc` file. The kernel
    then knows which pins are treated as GPIOs. After loading the overlay, the `init.{ro.hardware}.rc`
    file then executes a few commands that explicitly "unlock" these GPIO files for
    use by apps by *exporting* them. Exporting a GPIO pin creates a series of files
    in the `/sys` filesystem that can be read and written to interact with that GPIO
    pin.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动时，此叠加由`init.{ro.hardware}.rc`文件加载。然后内核知道哪些引脚被视为GPIO。加载叠加后，`init.{ro.hardware}.rc`文件执行一些命令，显式地“解锁”这些GPIO文件，以便应用程序通过*导出*它们来使用。导出GPIO引脚会在`/sys`文件系统中创建一系列文件，可以通过这些文件与GPIO引脚进行交互。
- en: 'By exporting a GPIO pin and then changing the permissions of the proper files
    in the `/sys` filesystem via `chmod`, any process can read from or write to GPIOs.
    This is exactly what the commands in the `init.{ro.hardware}.rc` file do to allow
    Android apps to interface with GPIOs. The following portion of the `init.{ro.hardware}.rc`
    file performs the export and `chmod` operations:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导出GPIO引脚，然后通过`chmod`更改`/sys`文件系统中的适当文件的权限，任何进程都可以从GPIO读取或写入。这正是`init.{ro.hardware}.rc`文件中的命令允许Android应用程序与GPIO进行接口的操作。`init.{ro.hardware}.rc`文件的以下部分执行导出和`chmod`操作：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each GPIO has a specific integer identifier that is determined by the bank the
    GPIO belongs to and its position within that bank. In our case, the GPIO muxed
    to P9.11 is the 30th GPIO in bank 0, and P9.13 is the 31st GPIO in bank 0\. This
    makes their integer identifiers 30 and 31, respectively.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每个GPIO都有一个特定的整数标识符，由GPIO所属的银行和其在该银行内的位置确定。在我们的情况下，复用到P9.11的GPIO是银行0中的第30个GPIO，P9.13是银行0中的第31个GPIO。这使它们的整数标识符分别为30和31。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GPIO pins 30 and 31 are only available via the `/sys` filesystem because
    they were explicitly exported via the `write` commands in the `init.{ro.hardware}.rc`
    file. Other GPIO pins will not be available via the filesystem unless they are
    also explicitly exported in the same fashion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO引脚30和31仅通过`/sys`文件系统可用，因为它们是通过`init.{ro.hardware}.rc`文件中的`write`命令显式导出的。其他GPIO引脚将不会通过文件系统可用，除非它们也以同样的方式显式导出。
- en: This is a very insecure way of allowing GPIO access because it opens up the
    GPIOs for use by processes that we might not want to have direct access to them.
    For experimentation and prototyping, this is not a problem. However, you certainly
    should not do this in a commercial system. Unless you develop a proper, privileged
    Android manager to handle the GPIO resources, you must allow *all* processes to
    access the GPIO files unless you tailor the permissions to only be usable by apps
    belonging to a specific user or group. As each app is assigned its own user, you
    would have to chown the GPIOs to the proper user and group after you install the
    app's `.apk` file onto the system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常不安全的允许GPIO访问的方式，因为它使GPIO对我们可能不希望直接访问它们的进程开放。对于实验和原型设计，这不是问题。但是，在商业系统中，您绝对不应该这样做。除非您开发一个适当的特权Android管理器来处理GPIO资源，否则您必须允许*所有*进程访问GPIO文件，除非您将权限定制为仅可由属于特定用户或组的应用程序使用。由于每个应用程序都被分配了自己的用户，因此在将应用程序的`.apk`文件安装到系统后，您必须将GPIO的所有权分配给适当的用户和组。
- en: Building a GPIO-interfacing circuit
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建GPIO接口电路
- en: Before you begin developing software that communicates using GPIOs, you must
    first construct a hardware circuit for the GPIOs to interface with. For this chapter,
    you will build a simple circuit that consists of a 1k ohm resistor, an LED, and
    a pushbutton switch. Part numbers and suppliers for these components were listed
    in [Chapter 1](part0014_split_000.html#page "Chapter 1. Introduction to Android
    and the BeagleBone Black"), *Introduction to Android and the BeagleBone Black*.
    Before getting started, be sure that you have all of the proper parts and remove
    all power sources from your BBB (unplug the power supply and USB cables) prior
    to connecting anything to the BBB's P8/P9 connector.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始开发使用GPIO进行通信的软件之前，您必须首先构建一个硬件电路以便与GPIO进行接口。在本章中，您将构建一个简单的电路，其中包括一个1k欧姆电阻、一个LED和一个按钮开关。这些组件的零件号和供应商在[第1章](part0014_split_000.html#page
    "第1章。Android和BeagleBone Black简介")*Android和BeagleBone Black简介*中列出。在开始之前，请确保您拥有所有正确的零件，并在连接任何东西到BBB的P8/P9连接器之前，从BBB上断开所有电源（拔掉电源和USB电缆）。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Don''t disassemble your circuit!**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要拆卸您的电路！**'
- en: The GPIO circuit in this chapter is part of a much larger circuit used in [Chapter
    6](part0041_split_000.html#page "Chapter 6. Creating a Complete Interfacing Solution"),
    *Creating a Complete Interfacing Solution*. If you build the circuit as it is
    positioned in the following diagram (towards the top of the breadboard), you can
    simply leave the GPIO components and wires in place as you build the remaining
    circuits in this book. This way, it will already be constructed and working when
    you reach [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating a Complete
    Interfacing Solution").
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的GPIO电路是[第6章](part0041_split_000.html#page "第6章。创建完整的接口解决方案")*创建完整的接口解决方案*中使用的一个更大电路的一部分。如果您按照以下图表中的位置构建电路（靠近面包板的顶部），您可以在构建本书中的其余电路时将GPIO组件和导线留在原位。这样，当您到达[第6章](part0041_split_000.html#page
    "第6章。创建完整的接口解决方案")时，它已经被构建并且在工作了。
- en: Constructing the circuit
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建电路
- en: 'The circuit that you will build interfaces with the following four BBB''s pins:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您将构建的电路与以下四个BBB引脚进行接口：
- en: P9.1 (ground)
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P9.1（地）
- en: P9.3 (3.3 V)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P9.3（3.3 V）
- en: P9.11 (GPIO)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P9.11（GPIO）
- en: P9.13 (GPIO)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: P9.13（GPIO）
- en: The P9.11 pin is configured as an output GPIO, and it drives the LED. The P9.13
    pin is configured as an input GPIO, and it sets its state depending upon the input
    voltage that is applied to it. Both GPIO pins are configured by the `BB-PACKTPUB-00A0.dtbo`
    overlay to use an internal pull-up resistor. If you are not familiar with what
    a pull-up resistor is, don't worry. For the purposes of these examples, it simply
    means that the logic level of the GPIOs will not "float" between on and off if
    nothing is attached to the GPIO pins. Instead, the logic level will be "pulled-up"
    to the on state.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: P9.11引脚配置为输出GPIO，并驱动LED。P9.13引脚配置为输入GPIO，并根据施加在其上的输入电压设置其状态。这两个GPIO引脚由`BB-PACKTPUB-00A0.dtbo`叠加配置为使用内部上拉电阻。如果您不熟悉上拉电阻是什么，不用担心。在这些示例中，它只是意味着如果没有任何东西连接到GPIO引脚，GPIO的逻辑电平不会在开和关之间“浮动”。相反，逻辑电平将被“上拉”到开状态。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Interested in learning more about what a pull-up resistor is and how it works?
    We suggest that you check out this online tutorial on pull-up and pull-down resistors,
    available at [http://www.resistorguide.com/pull-up-resistor_pull-down-resistor](http://www.resistorguide.com/pull-up-resistor_pull-down-resistor).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解下拉电阻是什么以及它是如何工作的吗？我们建议您查看这个关于上拉和下拉电阻的在线教程，网址为[http://www.resistorguide.com/pull-up-resistor_pull-down-resistor](http://www.resistorguide.com/pull-up-resistor_pull-down-resistor)。
- en: Breadboards typically have two vertical buses on either side that run almost
    the entire length of the breadboard. These buses are used to provide convenient
    access to power and ground signals for any components inserted into the breadboard.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 面包板通常在两侧有两个垂直母线，几乎贯穿整个面包板的长度。这些母线用于为插入面包板的任何组件提供方便的电源和地面信号访问。
- en: '![Constructing the circuit](img/00010.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![构建电路](img/00010.jpeg)'
- en: The complete GPIO-interfacing circuit
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的GPIO接口电路
- en: 'Now we can start constructing our circuit:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始构建我们的电路：
- en: Connect the BBB's ground (P9.1) and 3.3 V (P9.3) signals to the two vertical
    buses on the breadboard. The ground bus is the vertical bus towards the center
    of the breadboard. The 3.3 V bus is the vertical bus towards the edge of the breadboard.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将BBB的地线（P9.1）和3.3V（P9.3）信号连接到面包板的两个垂直母线。地线母线是朝向面包板中心的垂直母线。3.3V母线是朝向面包板边缘的垂直母线。
- en: Next, connect the anode, or the positive lead, of the LED to P9.11\. LEDs have
    a polarity, so current will only flow through them in one direction. Current flows
    from the longer lead (the anode) of the LED to the shorter lead (the cathode).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将LED的阳极或正极引脚连接到P9.11。LED具有极性，因此电流只会在一个方向上流过。电流从LED的长引脚（阳极）流向短引脚（阴极）。
- en: If the LED's leads have been cut to the same length and you are unable to tell
    which lead is which, feel around the edge of the LED's plastic casing. The edge
    of the casing is flat on the cathode side and rounded on the anode side. As long
    as the cathode is connected to the ground and the anode is connected to the GPIO
    pin, the LED will work properly.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果LED的引脚已经剪短到相同的长度，并且您无法分辨哪根引脚是哪根引脚，请在LED的塑料外壳边缘摸索。外壳的边缘在阴极侧是平的，在阳极侧是圆的。只要阴极连接到地，阳极连接到GPIO引脚，LED就会正常工作。
- en: You must limit the current drawn by the LED to ensure that you do not damage
    the GPIO pin, so place a 1K ohm resistor between the LED's cathode lead and the
    ground signal. Resistors do not have a polarity like LEDs do, so the direction
    that you connect it to the breadboard will not matter.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LED的电流必须限制，以确保不损坏GPIO引脚，因此在LED的阴极引脚和地信号之间放置一个1K欧姆的电阻。电阻没有像LED那样的极性，因此连接到面包板的方向并不重要。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you wish to learn more about using a current-limiting resistor with an LED,
    such as selecting the right resistor for the task, we suggest that you read the
    tutorial from SparkFun, available at [https://www.sparkfun.com/tutorials/219](https://www.sparkfun.com/tutorials/219).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望了解如何使用LED的限流电阻，例如选择适合任务的正确电阻，我们建议您阅读SparkFun的教程，网址是[https://www.sparkfun.com/tutorials/219](https://www.sparkfun.com/tutorials/219)。
- en: Now that the LED and resistor have been connected to the BBB, you must connect
    the pushbutton switch. Different switches have different numbers of leads, but
    the switch that we suggested for your use has a total of four leads. These leads
    form two pairs of two leads each. The two leads in each pair are always electrically
    connected to each other, but one pair will only be electrically connected to the
    other pair when the button is being pressed. Two sides of the switch are smooth,
    and the other two sides have two protruding leads on each side. The two protruding
    leads on a single side of the switch belong to different pairs of leads. Pick
    one side of the switch with two leads on it and connect one lead to P9.13 and
    the other lead to the breadboard's ground bus.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在LED和电阻已连接到BBB，您必须连接按钮开关。不同的开关具有不同数量的引脚，但我们建议您使用的开关总共有四个引脚。这些引脚形成两对两个引脚的引脚。每对中的两个引脚始终电气连接在一起，但只有在按下按钮时，一对引脚才会与另一对引脚电气连接。开关的两侧是光滑的，另外两侧每侧有两个突出的引脚。开关一侧的两个突出引脚属于不同的引脚对。选择开关一侧有两个引脚的一侧，将一个引脚连接到P9.13，另一个引脚连接到面包板的地线。
- en: Your circuit is now complete. Double-check your wiring against the diagram of
    the complete GPIO-interfacing circuit to ensure that everything is connected properly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您的电路现在已经完成。仔细检查您的接线，确保一切连接正确，与完整的GPIO接口电路图相符。
- en: Checking your wiring
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查您的接线
- en: Once you have completed the wiring of the GPIO circuit, you should test it to
    ensure that it works properly. Luckily, you can do this easily by shelling into
    the BBB and working with the exported GPIO pin files. We will assume that you
    are using `adb` to shell into the Android system, but using the FTDI to access
    the console shell will work in exactly the same way.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成GPIO电路的布线后，应该测试以确保其正常工作。幸运的是，您可以通过进入BBB并使用导出的GPIO引脚文件来轻松完成这项工作。我们假设您正在使用`adb`进入Android系统，但使用FTDI访问控制台shell将以完全相同的方式工作。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**How do I use the FTDI cable?**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**我如何使用FTDI电缆？**'
- en: If you have never used an FTDI cable to communicate with your BBB, there is
    a page on the [www.elinux.org](http://www.elinux.org) wiki (maintained by the
    BeagleBoard.org staff) that can help you get started, which is [http://elinux.org/Beagleboard:Terminal_Shells](http://elinux.org/Beagleboard:Terminal_Shells).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从未使用FTDI电缆与BBB通信，可以在[www.elinux.org](http://www.elinux.org)维基（由BeagleBoard.org工作人员维护）上找到帮助您入门的页面，网址是[http://elinux.org/Beagleboard:Terminal_Shells](http://elinux.org/Beagleboard:Terminal_Shells)。
- en: In this book, we will only be using the USB cable and ADB shell to access the
    BBB. However, learning how to use the FTDI to monitor and troubleshoot your BBB
    can really come in handy.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将仅使用USB电缆和ADB shell来访问BBB。但是，学习如何使用FTDI来监视和排除BBB问题确实非常方便。
- en: 'Connect power to your BBB and then use the USB cable to connect the BBB to
    your development system. After shelling into the BBB, begin testing your GPIO
    circuit using the following steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 给BBB供电，然后使用USB电缆将BBB连接到开发系统。进入BBB后，开始使用以下步骤测试您的GPIO电路：
- en: 'Change into the directory for the GPIO pin muxed to P9.11 (GPIO pin 30):'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到GPIO引脚复用到P9.11（GPIO引脚30）的目录：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use the `echo` command to turn the LED on by forcing the state of this GPIO
    to 1:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`echo`命令将LED打开，强制将此GPIO的状态设置为1：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The LED will now be turned on. Use the `echo` command to turn the LED off by
    forcing the state of this GPIO to 0:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LED现在将被打开。使用`echo`命令将LED关闭，强制将此GPIO的状态设置为0：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The LED will now be turned off. Change into the directory for the GPIO pin
    muxed to P9.13 (the GPIO pin 31):'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LED现在将被关闭。切换到GPIO引脚复用到P9.13（GPIO引脚31）的目录：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use the `cat` command to check the current state of the pushbutton switch.
    When executing this command, make sure that you are not pushing the button:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`命令检查当前的按钮开关状态。执行此命令时，请确保您没有按下按钮：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, execute the following `cat` command while holding down the button. You
    should type the entire command, press the button, and then hit the *Enter* key
    to enter the command while still holding the button down:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在按住按钮时执行以下`cat`命令。您应该输入整个命令，按下按钮，然后按*Enter*键输入命令，同时保持按下按钮：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The pushbutton values look reversed because of how the circuit is wired. The
    pull-up resistor on P9.13 will pull the value of the GPIO to `1` when the button
    is not pressed. When the button is pressed, the P9.13 pin becomes connected to
    the ground signal and changes the GPIO to `0`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电路的布线方式，按钮的值看起来是相反的。P9.13上的上拉电阻在按钮未按下时将GPIO的值拉到`1`。当按下按钮时，P9.13引脚连接到地信号并将GPIO更改为`0`。
- en: If you saw the LED turn on and off and the correct values were returned when
    the switch was pressed and released, you have correctly wired the circuit. If
    the LED did not light up, make sure that you have not accidentally swapped the
    anode and cathode leads of the LED. If the switch always returns a value of 0,
    make sure that you have connected the correct pair of leads on the switch to the
    ground signal bus and P9.13.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到LED在按下和释放开关时打开和关闭，并且返回了正确的值，那么您已经正确地连接了电路。如果LED没有亮起，请确保您没有意外交换LED的阳极和阴极引线。如果开关始终返回值为0，请确保您已将开关上的正确引线连接到地信号总线和P9.13。
- en: Including PacktHAL within your apps
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的应用程序中包含PacktHAL
- en: Before diving into using PacktHAL to interface with GPIOs, you must understand
    how to include PacktHAL support in your apps. We will walk you through the process
    of adding the PacktHAL code into your app and then building it. PacktHAL will
    be packaged with your app in the`.apk` app as a shared library. The source code
    for the library exists within the app's project directory, but it is built separately
    from the Java code of the app. You must manually build the PacktHAL shared library
    before your app can include it within the `.apk` app and use it.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入使用PacktHAL与GPIO进行接口之前，您必须了解如何在应用程序中包含PacktHAL支持。我们将带您完成将PacktHAL代码添加到您的应用程序中，然后构建它的过程。PacktHAL将作为共享库打包到您的应用程序中的`.apk`应用程序中。库的源代码存在于应用程序项目目录中，但与应用程序的Java代码分开构建。在您的应用程序可以将其包含在`.apk`应用程序中并使用它之前，您必须手动构建PacktHAL共享库。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We include a prebuilt version of the PacktHAL library in each of the example
    app projects included with this book, so you can jump into building and running
    the example apps right away without worrying about the details of building PacktHAL.
    Once you begin creating your own custom apps and modifying PacktHAL for your own
    hardware projects, you will need to understand how to build PacktHAL from source.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中包含的每个示例应用程序项目中都包含了PacktHAL库的预构建版本，因此您可以立即开始构建和运行示例应用程序，而不必担心构建PacktHAL的细节。一旦您开始创建自己的自定义应用程序并修改PacktHAL以用于自己的硬件项目，您将需要了解如何从源代码构建PacktHAL。
- en: Understanding the Java Native Interface
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解Java本机接口
- en: Android apps are written in Java, but the functions in PacktHAL are written
    in C native code. Native code is the code that is compiled into a native binary,
    such as a shared library or executable, and then executed directly by the Android
    OS. Native code is built using the compiler toolchain supplied within the Android
    NDK. Native binaries are not as portable as the "build once, run anywhere" bytecode
    of Android apps, but they can be used for low-level interfacing in ways that Java
    code cannot. Unlike Java bytecode, which is executable on any platform that has
    a proper virtual machine, native code is compiled for one specific hardware architecture
    (such as ARM, x86, or PowerPC) and can be executed only on that architecture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序是用Java编写的，但PacktHAL中的函数是用C本地代码编写的。本地代码是编译成本地二进制代码的代码，例如共享库或可执行文件，然后由Android
    OS直接执行。本地代码是使用Android NDK中提供的编译器工具链构建的。本地二进制代码不像Android应用程序的“构建一次，随处运行”的字节码那样具有可移植性，但它们可以用于低级接口，这是Java代码无法做到的。与Java字节码不同，Java字节码可以在具有适当虚拟机的任何平台上执行，本地代码是为一种特定的硬件架构（例如ARM、x86或PowerPC）编译的，并且只能在该架构上执行。
- en: Functions implemented in native code are called from an app's Java code via
    the **Java Native Interface** (**JNI**). JNI is a popular interfacing mechanism
    that Java applications use to interact with native C/C++ code. Among other features,
    JNI is used to *translate* Java datatypes into C datatypes and vice versa.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地代码中实现的函数通过**Java本机接口**（**JNI**）从应用程序的Java代码中调用。JNI是Java应用程序用于与本地C/C++代码交互的一种流行的接口机制。除其他功能外，JNI用于*转换*Java数据类型为C数据类型，反之亦然。
- en: For example, consider the Java `String` type. While Java has a `String` implementation,
    there is no equivalent type in C. The string must be suitably converted to a compatible
    type before it can be used by the C code. Each Java type is represented in C by
    a series of equivalent types, such as `jint`, `jstring`, and `jboolean`, which
    are defined in the standard `jni.h` header file that is supplied by the Android
    NDK.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑Java的`String`类型。虽然Java有`String`实现，但在C中没有等效的类型。在C代码中使用之前，字符串必须适当转换为兼容的类型。每种Java类型在C中都由一系列等效类型表示，例如`jint`、`jstring`和`jboolean`，这些类型在Android
    NDK提供的标准`jni.h`头文件中定义。
- en: Creating a new app project that uses PacktHAL
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个使用PacktHAL的新应用程序项目
- en: 'The following steps demonstrate how you can create a new custom app that includes
    PacktHAL:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了如何创建一个包含PacktHAL的新自定义应用程序：
- en: Launch the Eclipse ADT and select the menu option **File**, then **New**, then
    **Android Application Project**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Eclipse ADT，选择菜单选项**文件**，然后**新建**，然后**Android应用程序项目**。
- en: 'In the **New Android Application** dialog, enter `myapp` into the **Application
    Name** field. This will automatically populate the **Project Name** and **Application
    Name** fields. Change the **Minimum Required SDK**, **Target SDK**, and **Compile
    With** fields to **API 19: Android 4.4**. The theme field can be left alone or
    changed to whichever theme you would like for your app. When finished, click on
    the **Next** button.![Creating a new app project that uses PacktHAL](img/00011.jpeg)'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在**新建Android应用**对话框中，将`myapp`输入到**应用程序名称**字段中。这将自动填充**项目名称**和**应用程序名称**字段。将**最低要求的SDK**、**目标SDK**和**编译使用**字段更改为**API
    19: Android 4.4**。主题字段可以保持不变，也可以更改为您希望应用程序使用的任何主题。完成后，点击**下一步**按钮。![创建一个使用PacktHAL的新应用项目](img/00011.jpeg)'
- en: The New Android Application screen
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 新建Android应用程序屏幕
- en: Proceed through the successive dialog screens, retaining the default settings
    for each screen, until you click on the **Finish** button on the final screen.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照连续的对话框屏幕，保留每个屏幕的默认设置，直到您在最后一个屏幕上点击**完成**按钮。
- en: 'The name of the default activity created for your new app is `MainActivity`.
    After creating the new project, the folder structure of your new `myapp` project
    will reside in the `myapp` (`$PROJECT`) directory and have a directory structure
    similar to the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为新应用程序创建的默认活动的名称是`MainActivity`。创建新项目后，新的`myapp`项目的文件夹结构将驻留在`myapp`（`$PROJECT`）目录中，并且具有类似以下的目录结构：
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After creating the app for the first time, several new folders will be created
    to hold the various intermediary files created during the build process. Once
    you have created your app, you must add the PacktHAL code to it and compile it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次创建应用程序后，将创建几个新文件夹，用于保存构建过程中创建的各种中间文件。创建应用程序后，您必须将PacktHAL代码添加到其中并进行编译。
- en: Building PacktHAL under Windows
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Windows下构建PacktHAL
- en: 'PacktHAL must be built into a library and included within your app''s project
    codebase to be used by your app. Assuming that you decompressed and untarred the
    `PacktHAL.tgz` file in `c:\`, you can copy the PacktHAL code into your app''s
    project directory (`$PROJECT`) using the following process:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: PacktHAL必须构建为库，并包含在您的应用程序项目代码库中，以供应用程序使用。假设您在`c:\`中解压并解压了`PacktHAL.tgz`文件，您可以使用以下过程将PacktHAL代码复制到您的应用程序项目目录（`$PROJECT`）中：
- en: Open a file explorer window and browse to the `$PROJECT` directory.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件资源管理器窗口，浏览到`$PROJECT`目录。
- en: Open a second file explorer window and browse to `c:\PacktHAL`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开第二个文件资源管理器窗口，浏览到`c:\PacktHAL`。
- en: Right-click on the `jni` directory in the `c:\PacktHAL` directory and select
    **Copy** from the context menu.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`c:\PacktHAL`目录中的`jni`目录，然后从上下文菜单中选择**复制**。
- en: Right-click anywhere convenient on white space within the `$PROJECT` directory
    window and then select **Paste** from the context menu.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`$PROJECT`目录窗口中的任何方便的空白处右键单击，然后从上下文菜单中选择**粘贴**。
- en: 'Now that the `jni\` directory exists in your `$PROJECT` directory, you can
    build PacktHAL using the Android NDK. Assuming that you installed the Android
    NDK in `c:\android-ndk`, you can build PacktHAL using the following process:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`$PROJECT`目录中存在`jni\`目录，您可以使用Android NDK构建PacktHAL。假设您在`c:\android-ndk`中安装了Android
    NDK，您可以使用以下过程构建PacktHAL：
- en: 'Launch `cmd.exe` for a command prompt window. Using the command prompt, change
    into the `$PROJECT` directory:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`cmd.exe`以打开命令提示符窗口。使用命令提示符，进入`$PROJECT`目录：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Build the PacktHAL library using the Android NDK:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Android NDK构建PacktHAL库：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The PacktHAL library is now built and present in your project as the file `$PROJECT\libs\armeabi\libpacktHAL.so`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: PacktHAL库现在已构建并存在于您的项目中，作为文件`$PROJECT\libs\armeabi\libpacktHAL.so`。
- en: Building PacktHAL under Linux
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Linux下构建PacktHAL
- en: 'PacktHAL must be built into a library and included within your app''s project
    codebase to be used by your app. Assuming that you decompressed and untarred the
    `PacktHAL.tgz` file in your `$HOME` directory, you can copy the PacktHAL code
    into your app''s project directory (`$PROJECT`) using the following commands:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: PacktHAL必须构建为库，并包含在您的应用程序项目代码库中，以供应用程序使用。假设您在您的`$HOME`目录中解压并解压了`PacktHAL.tgz`文件，您可以使用以下命令将PacktHAL代码复制到您的应用程序项目目录（`$PROJECT`）中：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that the `jni` directory exists in your `$PROJECT` directory, you can build
    PacktHAL using the Android NDK. Assuming that you installed the Android NDK in
    `$HOME/android-ndk`, you can build PacktHAL using the following process:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`$PROJECT`目录中存在`jni`目录，您可以使用Android NDK构建PacktHAL。假设您在`$HOME/android-ndk`中安装了Android
    NDK，您可以使用以下过程构建PacktHAL：
- en: 'Change into the `$PROJECT/jni` directory:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`$PROJECT/jni`目录：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Build the PacktHAL library using the Android NDK:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Android NDK构建PacktHAL库：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The PacktHAL library is now built and present in your project as the `$PROJECT/libs/armeabi/libpacktHAL.so`
    file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: PacktHAL库现在已构建并存在于您的项目中，作为`$PROJECT/libs/armeabi/libpacktHAL.so`文件。
- en: Exploring the GPIO example app
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索GPIO示例应用程序
- en: In this section, you will examine the example Android app that performs GPIO
    interfacing on BBB. The purpose of this application is to demonstrate how to use
    PacktHAL to perform GPIO read and write processes from within an actual app. PacktHAL
    provides a set of interfacing functions that you will use to work with GPIOs from
    within your Android apps. These functions allow you to read the values of input
    GPIOs and set the values of output GPIOs. The low-level details of the hardware
    interfacing are implemented in PacktHAL, so you can quickly and easily get your
    apps interacting with GPIOs.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将检查示例Android应用程序，在BBB上执行GPIO接口。此应用程序的目的是演示如何使用PacktHAL从实际应用程序中执行GPIO读取和写入过程。PacktHAL提供了一组接口函数，您将使用这些函数从Android应用程序中处理GPIO。这些函数允许您读取输入GPIO的值并设置输出GPIO的值。硬件接口的低级细节在PacktHAL中实现，因此您可以快速轻松地使您的应用程序与GPIO进行交互。
- en: Before digging through the GPIO app's code, you must install the code to your
    development system and install the app to your Android system. The source code
    for the app, as well as a precompiled `.apk` package, are located in the `chapter3.tgz`
    file, which is available for download from the book's website.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究GPIO应用的代码之前，您必须将代码安装到您的开发系统，并将应用安装到您的Android系统。应用的源代码以及预编译的`.apk`包位于`chapter3.tgz`文件中，可以从该书籍网站下载。
- en: Installing the app and source under Windows
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Windows下安装应用和源代码
- en: Once you have downloaded the `chapter3.tgz` file, you must decompress and untar
    it. We will assume that you have copied `chapter3.tgz` to the root directory of
    `c:\` after downloading it and will decompress it from there. We will refer to
    your workspace directory as `$WORKSPACE`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您下载了`chapter3.tgz`文件，您必须解压和解打包它。我们假设您在下载后将`chapter3.tgz`复制到了`c:\`的根目录，并将从那里解压它。我们将把您的工作区目录称为`$WORKSPACE`。
- en: 'We will assume that your `adb.exe` binary is in your current path. If it is
    not, call `adb` by using the full path to the `adb.exe` binary:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您的`adb.exe`二进制文件在当前路径中。如果不是，请使用`adb.exe`二进制文件的完整路径来调用`adb`：
- en: Open a file explorer window and navigate to the directory.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件资源管理器窗口并导航到该目录。
- en: Right-click on the `chapter3.tgz` file in file explorer and select **Extract
    Here**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件资源管理器中右键单击`chapter3.tgz`文件，然后选择**在此处提取**。
- en: 'A directory named `c:\gpio` now exists, and it contains all of the files for
    the GPIO example app. You must import this project into your Eclipse ADT workspace:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在存在一个名为`c:\gpio`的目录，其中包含GPIO示例应用的所有文件。您必须将此项目导入到您的Eclipse ADT工作区中：
- en: Launch Eclipse ADT.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Eclipse ADT。
- en: Open the **File** menu and select **Import**.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**文件**菜单，选择**导入**。
- en: On the **Import** dialog, expand the **Android** folder and highlight **Existing
    Android Code Into Workspace**. The **Next** button at the bottom of the dialog
    will become active. Click on it to continue.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导入**对话框中，展开**Android**文件夹并突出显示**将现有Android代码导入工作区**。对话框底部的**下一步**按钮将变为活动状态。单击它继续。
- en: On the **Import Projects** dialog, type `c:\gpio` in the **Root Directory**
    text field. Then, click on the **Refresh** button. The **gpio** project will appear
    on the list of projects to import.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导入项目**对话框中，在**根目录**文本字段中键入`c:\gpio`，然后单击**刷新**按钮。**gpio**项目将出现在要导入的项目列表中。
- en: Click on the **Select All** button, then select the checkbox for **Copy projects
    into workspace**.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**全选**按钮，然后选择**将项目复制到工作区**复选框。
- en: Click on the **Finish** button to import the `gpio` app project into your workspace
    and copy the `c:\gpio` directory into your `$WORKSPACE` directory.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**完成**按钮将`gpio`应用项目导入工作区，并将`c:\gpio`目录复制到您的`$WORKSPACE`目录中。
- en: 'All of the project files for the GPIO app are now located in that `gpio` directory.
    A prebuilt `.apk` package for the app is provided in the `$WORKSPACE\gpio\bin`
    directory. You can install this `.apk` package directly to your Android system
    using `adb`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO应用的所有项目文件现在都位于`gpio`目录中。应用的预构建`.apk`包位于`$WORKSPACE\gpio\bin`目录中。您可以使用`adb`将这个`.apk`包直接安装到您的Android系统中：
- en: 'Launch `cmd.exe` for a command prompt window. Using the command prompt, change
    into the `$WORKSPACE\gpio\bin` directory:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`cmd.exe`以打开命令提示符窗口。使用命令提示符，切换到`$WORKSPACE\gpio\bin`目录：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Verify that `adb` can see your BBB using the `adb devices` command:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`adb`是否能够使用`adb devices`命令看到您的BBB：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Install `gpio.apk` to your Android system via the `install` command in `adb`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`adb`的`install`命令将`gpio.apk`安装到您的Android系统中：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you have already installed the `gpio.apk` app once and are now receiving
    the failure message of `INSTALL_FAILED_ALREADY_EXISTS`, use `adb` to reinstall
    `gpio.apk`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经安装了`gpio.apk`应用一次，现在收到了`INSTALL_FAILED_ALREADY_EXISTS`的失败消息，请使用`adb`重新安装`gpio.apk`：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `gpio.apk` app is now installed on your Android system, and the app's source
    is now installed in your Eclipse ADT workspace.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpio.apk`应用现在已安装到您的Android系统，并且应用的源代码现在已安装到您的Eclipse ADT工作区。'
- en: Installing the app and source under Linux
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Linux下安装应用和源代码
- en: Once you have downloaded the `chapter3.tgz` file, you must decompress and untar
    it. We will assume that you have copied `chapter3.tgz` to your `$HOME` directory
    after downloading it and will decompress it from there. We will refer to your
    workspace directory as `$WORKSPACE`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您下载了`chapter3.tgz`文件，您必须解压和解打包它。我们假设您在下载后将`chapter3.tgz`复制到了您的`$HOME`目录，并将从那里解压它。我们将把您的工作区目录称为`$WORKSPACE`。
- en: 'Use the Linux `tar` command to decompress and untar the `chapter3.tgz` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Linux的`tar`命令来解压和解打包`chapter3.tgz`文件：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A directory named `gpio` now exists in your `$HOME` directory, and it contains
    all of the files for the gpio example app. You must import this project into your
    Eclipse ADT workspace as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的`$HOME`目录中存在一个名为`gpio`的目录，其中包含gpio示例应用的所有文件。您必须按以下方式将此项目导入到您的Eclipse ADT工作区中：
- en: Launch Eclipse ADT.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Eclipse ADT。
- en: Open the **File** menu and select **Import**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**文件**菜单，选择**导入**。
- en: On the **Import** dialog, expand the `Android` folder and highlight **Existing
    Android Code Into Workspace**. The **Next** button at the bottom of the dialog
    will become active. Click on it to continue.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导入**对话框中，展开`Android`文件夹并突出显示**将现有Android代码导入工作区**。对话框底部的**下一步**按钮将变为活动状态。单击它继续。
- en: On the **Import Projects** dialog, type `$HOME/gpio` (substituting in the full
    path for `$HOME`) in the **Root Directory** text field. Then, click on the **Refresh**
    button. The **gpio** project will appear on the list of projects to import.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**导入项目**对话框中，在**根目录**文本字段中键入`$HOME/gpio`（用`$HOME`的完整路径替换），然后单击**刷新**按钮。**gpio**项目将出现在要导入的项目列表中。
- en: Click on the **Select All** button, then select the checkbox for **Copy projects
    into workspace**.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**全选**按钮，然后选择**将项目复制到工作区**复选框。
- en: Click on the **Finish** button to import the gpio app project into your workspace
    and copy the `$HOME/gpio` directory into your `$WORKSPACE` directory.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**完成**按钮将gpio应用项目导入您的工作区，并将`$HOME/gpio`目录复制到您的`$WORKSPACE`目录中。
- en: 'All of the project files for the app are now located in the `$WORKSPACE/gpio`
    directory. A prebuilt `.apk` package for the gpio project is provided in the `gpio/bin`
    directory. You can install this `.apk` package directly to your Android system
    using `adb`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序的所有项目文件都位于`$WORKSPACE/gpio`目录中。`gpio`项目的预构建`.apk`包位于`gpio/bin`目录中。您可以使用`adb`将此`.apk`包直接安装到您的Android系统中：
- en: 'Change into the `bin` directory of the `gpio` project:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`gpio`项目的`bin`目录：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Verify that `adb` can see your BBB using the `adb devices` command:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`adb devices`命令验证`adb`是否可以看到您的BBB：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Install `gpio.apk` to your Android system via the `install` command in `adb`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`adb`中的`install`命令将`gpio.apk`安装到您的Android系统：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you have already installed the `gpio.apk` app once and are now receiving
    the failure message of `INSTALL_FAILED_ALREADY_EXISTS`, use `adb` to reinstall
    `gpio.apk`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您已经安装了`gpio.apk`应用程序一次，并且现在收到`INSTALL_FAILED_ALREADY_EXISTS`的失败消息，请使用`adb`重新安装`gpio.apk`：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `gpio.apk` app is now installed on your Android system, and the app's source
    is now installed in your Eclipse ADT workspace.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`gpio.apk`应用程序现在已安装在您的Android系统上，并且应用程序的源代码现已安装在您的Eclipse ADT工作区中。'
- en: The app's user interface
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序的用户界面
- en: Launch the `gpio` app on the Android system to see the app's (UI). If you are
    using a touchscreen cape, you can simply touch the gpio app icon on the screen
    to launch the app and interact with its UI. If you are using the HDMI for video,
    connect a USB mouse to the BBB's USB port and use the mouse to click on the gpio
    app icon to launch the app.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android系统上启动`gpio`应用程序以查看应用程序的（UI）。如果您使用触摸屏cape，您可以简单地触摸屏幕上的gpio应用程序图标来启动应用程序并与其UI交互。如果您使用HDMI进行视频，将USB鼠标连接到BBB的USB端口，并使用鼠标单击gpio应用程序图标来启动应用程序。
- en: The app uses a very simple UI to interact with the GPIOs. As it is so simple,
    the only activity that the app has is default `MainActivity`. The UI consists
    of only three buttons and text view.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序使用非常简单的UI与GPIO交互。因为它非常简单，所以应用程序只有默认的`MainActivity`活动。UI仅包括三个按钮和文本视图。
- en: '![The app''s user interface](img/00012.jpeg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序的用户界面](img/00012.jpeg)'
- en: The GPIO sample app screen
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO示例应用程序屏幕
- en: The **Poll Button State** button checks the current state of the pushbutton
    switch and updates the value of the **Button State** text view to report that
    state. The switch state will be reported as **UNKNOWN** until the **Poll Button
    State** button is pressed for the first time. The **Turn light on** button will
    turn on the LED if it is not already on, and the **Turn light off** button will
    turn the LED off.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮询按钮状态**按钮检查按钮开关的当前状态，并更新**按钮状态**文本视图的值以报告该状态。在第一次按下**轮询按钮状态**按钮之前，开关状态将报告为**UNKNOWN**。**打开灯**按钮将打开LED（如果尚未打开），**关闭灯**按钮将关闭LED。'
- en: 'The text view has an ID associated with it in `res/layout/activity_main.xml`
    so that the app can update the text view''s value programmatically:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 文本视图在`res/layout/activity_main.xml`中与一个ID相关联，以便应用程序可以以编程方式更新文本视图的值：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Each of the three buttons have an `onClick()` handler defined:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个按钮都有一个定义的`onClick()`处理程序：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Each `onClick()` handler will trigger one of the PacktHAL GPIO functions to
    read the state of a GPIO or write a new state to a GPIO.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`onClick()`处理程序将触发PacktHAL GPIO函数中的一个来读取GPIO的状态或向GPIO写入新状态。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you need a refresher on the fine details of the various Android UI elements,
    there are several resources available online that can help you. We recommend that
    you start with the official Android Developer website at [http://developer.android.com/guide/topics/ui/index.html](http://developer.android.com/guide/topics/ui/index.html).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要复习各种Android UI元素的细节，有几种在线资源可以帮助您。我们建议您从官方的Android开发者网站开始[http://developer.android.com/guide/topics/ui/index.html](http://developer.android.com/guide/topics/ui/index.html)。
- en: Calling the PacktHAL functions
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用PacktHAL函数
- en: 'The GPIO interface functionality in PacktHAL is implemented in four C functions:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: PacktHAL中的GPIO接口功能是通过四个C函数实现的：
- en: '`openGPIO()`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openGPIO()`'
- en: '`readGPIO()`'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readGPIO()`'
- en: '`writeGPIO()`'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writeGPIO()`'
- en: '`closeGPIO()`'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closeGPIO()`'
- en: 'The prototypes for these functions are located in the `jni/PacktHAL.h` header
    file within the app''s project:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的原型位于应用程序项目中的`jni/PacktHAL.h`头文件中：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ideally, you would load the PacktHAL shared library into your app and then simply
    call the library functions directly to control the GPIOs. The example app actually
    *does* load the PacktHAL library via a `System.loadLibrary()` call, but then things
    become less straightforward because these C functions cannot be called directly.
    You must specify Java methods that, when called, actually call the C functions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您应该将PacktHAL共享库加载到您的应用程序中，然后直接调用库函数来控制GPIO。实际上，示例应用程序通过`System.loadLibrary()`调用加载了PacktHAL库，但随后变得不那么直接，因为这些C函数不能直接调用。您必须指定Java方法，当调用时实际上调用C函数。
- en: 'The `MainActivity` class specifies four methods with the `native` keyword to
    call the PacktHAL C functions in `MainActivity.java`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity`类指定了四个带有`native`关键字的方法，以调用`MainActivity.java`中的PacktHAL C函数：'
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These four Java methods specified in `MainActivity` are not actually a direct
    mapping to the C functions of the same name in PacktHAL. Notice that the GPIO
    methods in `MainActivity` are all `private native` within the scope of the class.
    Any method defined with the `native` keyword will attempt to call a native *JNI
    wrapper function* when it is invoked. However, the naming of the invoked JNI wrapper
    function follows some very specific rules that represent the scope of its Java-side
    method. The following figure shows how these JNI wrapper functions finally call
    the GPIO-interfacing functions inside of PacktHAL:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity`中指定的这四个Java方法实际上并不是直接映射到PacktHAL中同名的C函数。请注意，`MainActivity`中的GPIO方法都是类范围内的`private
    native`。任何使用`native`关键字定义的方法在被调用时都会尝试调用本地的*JNI包装函数*。但是，所调用的JNI包装函数的命名遵循一些非常具体的规则，这些规则代表了其Java端方法的范围。以下图显示了这些JNI包装函数如何最终调用PacktHAL中的GPIO接口函数：'
- en: '![Calling the PacktHAL functions](img/00013.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![调用PacktHAL函数](img/00013.jpeg)'
- en: The MainActivity methods and the PacktHAL GPIO-interfacing functions that they
    call
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: MainActivity方法和它们调用的PacktHAL GPIO接口函数
- en: Each `native` method in the `MainActivity` class with the name `name()` will
    use JNI to call a JNI wrapper function with the name `Java_com_packt_gpio_MainActivity_name()`.
    The name of this wrapper function is determined by replacing each `.` in the fully
    qualified name of the app with an underscore. The `Java_` prefix of the function
    name tells Android that the function is being called via a method in a Java class.
    There are a few exceptions to this JNI naming convention, but this general rule
    will get you through most cases.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity`类中的每个带有名称`name()`的`native`方法都将使用JNI调用一个名为`Java_com_packt_gpio_MainActivity_name()`的JNI包装函数。此包装函数的名称是通过将应用程序的完全限定名称中的每个`.`替换为下划线来确定的。函数名称的`Java_`前缀告诉Android该函数是通过Java类中的方法调用的。这个JNI命名约定有一些例外，但这个一般规则将帮助您处理大多数情况。'
- en: Tip
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Do I need to know all about JNI to make my own Android interfacing projects?**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**我需要了解所有关于JNI才能制作自己的Android接口项目吗？**'
- en: Not really. Using JNI can be quite confusing, and many, many books and tutorials
    have been dedicated to describing it in great detail. For now, don't worry about
    not knowing everything that there is to know about JNI. When you have spent some
    time experimenting with hardware interfacing under Android, you can revisit this
    topic and learn more of the fine details of how JNI works. In this book, we will
    focus on showing you just enough information about JNI to get you started.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 不是真的。使用JNI可能会非常令人困惑，许多书籍和教程都致力于详细描述它。现在，不要担心不知道有关JNI的所有信息。当您花费一些时间在Android下进行硬件接口实验后，您可以重新访问这个主题，并了解更多有关JNI工作细节的详细信息。在本书中，我们将重点介绍有关JNI的足够信息，让您开始。
- en: 'As an example, our Java `openGPIO()` method in the `MainActivity` class for
    the `com.packtpub.gpio` example app uses JNI to call the wrapper C function `Java_com_packtpub_gpio_MainActivity_openGPIO()`.
    This is a little confusing, but still very manageable. PacktHAL implements these
    JNI wrapper C functions in the `jni/packt_native_gpio.c` file. Looking at this
    source file, you can see where the `Java_com_packtpub_gpio_MainActivity_openGPIO()`
    function in PacktHAL calls the `openGPIO()` C function in PacktHAL:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们的Java `MainActivity`类中的`openGPIO()`方法用于`com.packtpub.gpio`示例应用程序，使用JNI调用包装C函数`Java_com_packtpub_gpio_MainActivity_openGPIO()`。这有点令人困惑，但仍然非常可管理。PacktHAL在`jni/packt_native_gpio.c`文件中实现了这些JNI包装C函数。查看这个源文件，您可以看到PacktHAL中的`Java_com_packtpub_gpio_MainActivity_openGPIO()`函数调用PacktHAL中的`openGPIO()`C函数：
- en: '[PRE27]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Why not just do away with the separate `openGPIO()` C function and place all
    of the hardware interface code inside `Java_com_packt_gpio_MainActivity_openGPIO()`?
    Functions such as `openGPIO()` in PacktHAL will usually not change once you have
    them working properly, and you can use these same functions under both Linux and
    Android. Wrapper functions such as `Java_com_packt_gpio_MainActivity_openGPIO()`
    will change their name and implementation details based upon how and where they
    are invoked from an app's Java code. It is better to isolate functionality that
    will not change in its own function. This avoids your accidentally breaking something
    when customizing or renaming the functions invoked via JNI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不直接取消单独的`openGPIO()`C函数，并将所有硬件接口代码放在`Java_com_packt_gpio_MainActivity_openGPIO()`中？例如，PacktHAL中的`openGPIO()`函数通常在正确工作后不会改变，并且您可以在Linux和Android下使用相同的函数。像`Java_com_packt_gpio_MainActivity_openGPIO()`这样的包装函数将根据从应用程序的Java代码中调用它们的方式和位置更改其名称和实现细节。最好将不会更改的功能隔离在自己的函数中。这样可以避免在自定义或重命名通过JNI调用的函数时意外破坏某些功能。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just remember that a Java method in your app, such as `openGPIO()` in the `MainActivity`
    class, makes a JNI call to invoke a PacktHAL C function with a long, mangled name
    like `Java_com_packt_gpio_MainActivity_openGPIO()`. The JNI wrapper function will
    then call one of the PacktHAL C functions, for example, `openGPIO()`, that actually
    controls the hardware. From the app developer's point of view, once you sort out
    the JNI wrapper function details, it is almost like calling the C function that
    controls the hardware directly from the Java app code!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，您应用程序中的Java方法，例如`MainActivity`类中的`openGPIO()`，会通过JNI调用来调用一个长而混乱的名称的PacktHAL
    C函数，例如`Java_com_packt_gpio_MainActivity_openGPIO()`。然后，JNI包装函数将调用PacktHAL C函数之一，例如`openGPIO()`，实际上控制硬件。从应用程序开发人员的角度来看，一旦解决了JNI包装函数的细节，几乎就像直接从Java应用程序代码调用控制硬件的C函数一样！
- en: Using the PacktHAL GPIO functions
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PacktHAL GPIO函数
- en: Now that you have seen how the PacktHAL GPIO functions are called from Java,
    you will see what each of these functions does and how you can use them.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了PacktHAL GPIO函数是如何从Java中调用的，您将看到每个这些函数的作用以及如何使用它们。
- en: The `openGPIO()` function initializes your app's access to GPIOs. This function
    offers you two different methods for GPIO interfacing, of which you select one
    method using `openGPIO()` function's `useMmap` parameter. The two methods are
    file I/O (by setting `useMmap` to 0) and memory-mapping (by setting `useMmap`
    to any non-zero number). To change from one interfacing method to the other, you
    must call `closeGPIO()` to shut down the GPIO portion of PacktHAL and then call
    `openGPIO()` again with a different value for `useMmap`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`openGPIO()`函数初始化您的应用程序对GPIO的访问。该函数为您提供了两种不同的GPIO接口方法，您可以使用`openGPIO()`函数的`useMmap`参数选择其中一种方法。这两种方法分别是文件I/O（通过将`useMmap`设置为0）和内存映射（通过将`useMmap`设置为任何非零数）。要从一种接口方法切换到另一种方法，您必须调用`closeGPIO()`关闭PacktHAL的GPIO部分，然后再次调用`openGPIO()`，并为`useMmap`使用不同的值。'
- en: Processes must run as `root` to use memory- mapping to directly access the GPIO
    control resistors. As apps cannot run as root, the JNI wrapper function always
    passes `0` as the `useMmap` argument to `openGPIO()` to force the use of file
    I/O to interact with GPIOs. The `openGPIO()` method in the `MainActivity` class
    does not accept any arguments because of this.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 进程必须以`root`身份运行，才能使用内存映射直接访问GPIO控制电阻。由于应用程序无法以root身份运行，JNI包装函数始终将`0`作为`useMmap`参数传递给`openGPIO()`，以强制使用文件I/O与GPIO进行交互。由于这个原因，`MainActivity`类中的`openGPIO()`方法不接受任何参数。
- en: 'The example app calls the `openGPIO()` method from the `onCreate()` method
    of the `MainActivity` class:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序从`MainActivity`类的`onCreate()`方法中调用`openGPIO()`方法：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The complementary call to the `closeGPIO()` method is made by the `onDestroy()`
    method of the `MainActivity` class:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`closeGPIO()`方法的补充调用是在`MainActivity`类的`onDestroy()`方法中进行的：'
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `readGPIO()` method reads the state of a particular input GPIO. Both the
    PacktHAL `readGPIO()` function and the `readGPIO()` method in `MainActivity` take
    the same two parameters. The first parameter is a connector number on the BBB
    (8 or 9), and the second parameter is a pin location on that connector (1 through
    42). The `readGPIO()` method is called from within the `onClick()` handler of
    the `PollStatus` button:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`readGPIO()`方法读取特定输入GPIO的状态。PacktHAL `readGPIO()`函数和`MainActivity`中的`readGPIO()`方法都接受相同的两个参数。第一个参数是BBB上的连接器编号（8或9），第二个参数是该连接器上的引脚位置（1到42）。`readGPIO()`方法是在`PollStatus`按钮的`onClick()`处理程序中调用的：'
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In `onClickPollStatus()`, the `readGPIO()` method call is reading the state
    of the GPIO pin P9.13\. This is the GPIO pin that you connected to the pushbutton
    switch. If the switch is pressed when the `readGPIO()` method is called, `true`
    is returned. Otherwise, `false` is returned.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onClickPollStatus()`中，`readGPIO()`方法调用读取了GPIO引脚P9.13的状态。这是您连接到按钮开关的GPIO引脚。如果在调用`readGPIO()`方法时按下按钮开关，则返回`true`。否则，返回`false`。
- en: 'The `writeGPIO()` method is used to set the state of an output GPIO. Both the
    PacktHAL `writeGPIO()` function and the `writeGPIO()` method in `MainActivity`
    take three parameters. The first parameter is the connector number on the BBB
    (8 or 9), the second parameter is a pin location on that connector (1 through
    42), and the third parameter is the value to set (0 or 1). The `writeGPIO()` method
    is called from within the `onClick` handlers of the `LightOn` and `LightOff` buttons:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeGPIO()`方法用于设置输出GPIO的状态。PacktHAL `writeGPIO()`函数和`MainActivity`中的`writeGPIO()`方法都接受三个参数。第一个参数是BBB上的连接器编号（8或9），第二个参数是该连接器上的引脚位置（1到42），第三个参数是要设置的值（0或1）。`writeGPIO()`方法是在`LightOn`和`LightOff`按钮的`onClick`处理程序中调用的：'
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In both of these `onClick()` handlers, the GPIO being set is P9.11\. This is
    the GPIO pin that you connected to the LED. The `onClickButtonLightOn()` method
    sets the GPIO to 1, turning the LED on. Likewise, the `onClickButtonLightOff()`
    method sets the GPIO to 0, turning the LED off.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个`onClick()`处理程序中，被设置的GPIO是P9.11。这是您连接到LED的GPIO引脚。`onClickButtonLightOn()`方法将GPIO设置为1，打开LED。同样，`onClickButtonLightOff()`方法将GPIO设置为0，关闭LED。
- en: Tip
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Are you ready for a challenge?**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**您准备好接受挑战了吗？**'
- en: Now that you have seen all of the pieces of the gpio app, why not change it
    to add new functionality? For a challenge, try changing the app to use only a
    single button that toggles the state of the LED. If the LED is currently off,
    pressing the button will turn it on and vice versa. We have provided one possible
    implementation of this in the `chapter3_challenge.tgz` file, which is available
    for download from the book's website.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经看到了gpio应用程序的所有部分，为什么不改变它以添加新功能呢？作为挑战，尝试更改应用程序，只使用一个按钮来切换LED的状态。如果LED当前处于关闭状态，按下按钮将打开它，反之亦然。我们在书籍网站提供了`chapter3_challenge.tgz`文件，其中提供了这种可能的实现方式，供您下载。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced you to GPIOs and how they work. You constructed
    a circuit that uses GPIOs for both input and output, and then you did some basic
    testing on the circuit to ensure that the circuit was constructed properly and
    that the kernel is able to interact with the circuit via the filesystem. You also
    learned about the portions of the PacktHAL `init.{ro.hardware}.rc` file and `BB-PACKTPUB-00A0.dtbo`
    Device Tree overlay that are responsible for configuring GPIOs and making them
    available for your app's use.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了GPIO以及它们的工作原理。您构建了一个电路，该电路使用GPIO进行输入和输出，然后对电路进行了一些基本测试，以确保电路被正确构建，并且内核能够通过文件系统与电路进行交互。您还了解了PacktHAL
    `init.{ro.hardware}.rc`文件和`BB-PACKTPUB-00A0.dtbo`设备树叠加的部分，这些部分负责配置GPIO并使其可供应用程序使用。
- en: We showed you how to add PacktHAL into a newly created app project and how to
    build PacktHAL using the Android NDK. Then, you learned how JNI integrates PacktHAL
    into your Java app via JNI wrapper functions and explored how each GPIO function
    of PacktHAL is called and used from within an app.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向您展示了如何将PacktHAL添加到新创建的应用程序项目中，以及如何使用Android NDK构建PacktHAL。然后，您学习了JNI如何通过JNI包装函数将PacktHAL集成到您的Java应用程序中，并探索了如何从应用程序中调用和使用PacktHAL的每个GPIO函数。
- en: In the next chapter, you will learn how to integrate I2C bus devices into your
    apps and begin interacting with hardware that is much more sophisticated than
    the basic on/off logic of GPIOs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何将I2C总线设备集成到您的应用程序中，并开始与比基本的GPIO开关逻辑更复杂的硬件进行交互。
