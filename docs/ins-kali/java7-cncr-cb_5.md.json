["```java\n    If (problem size > default size){\n      tasks=divide(task);\n      execute(tasks);\n    } else {\n      resolve problem using another algorithm;\n    }\n    ```", "```java\n    public class Product {\n    ```", "```java\n      private String name;\n      private double price;\n    ```", "```java\n      public String getName() {\n        return name;\n      }\n\n      public void setName(String name) {\n        this.name = name;\n      }\n\n      public double getPrice() {\n        return price;\n      }\n\n      public void setPrice(double price) {\n        this.price = price;\n      }\n    ```", "```java\n    public class ProductListGenerator {\n    ```", "```java\n      public List<Product> generate (int size) {\n    ```", "```java\n        List<Product> ret=new ArrayList<Product>();\n    ```", "```java\n        for (int i=0; i<size; i++){\n          Product product=new Product();\n          product.setName(\"Product \"+i);\n          product.setPrice(10);\n          ret.add(product);\n        }\n        return ret;\n      }\n    ```", "```java\n    public class Task extends RecursiveAction {\n    ```", "```java\n      private static final long serialVersionUID = 1L;\n    ```", "```java\n      private List<Product> products;\n    ```", "```java\n      private int first;\n      private int last;\n    ```", "```java\n      private double increment;\n    ```", "```java\n      public Task (List<Product> products, int first, int last, double increment) {\n        this.products=products;\n        this.first=first;\n        this.last=last;\n        this.increment=increment;\n      }\n    ```", "```java\n      @Override\n      protected void compute() {\n    ```", "```java\n        if (last-first<10) {\n          updatePrices();\n    ```", "```java\n        } else {\n          int middle=(last+first)/2;\n          System.out.printf(\"Task: Pending tasks: %s\\n\",getQueuedTaskCount());\n          Task t1=new Task(products, first,middle+1, increment);\n          Task t2=new Task(products, middle+1,last, increment);\n          invokeAll(t1, t2);  \n        }\n    ```", "```java\n      private void updatePrices() {\n        for (int i=first; i<last; i++){\n          Product product=products.get(i);\n          product.setPrice(product.getPrice()*(1+increment));\n        }\n      }\n    ```", "```java\n    public class Main {\n      public static void main(String[] args) {\n    ```", "```java\n        ProductListGenerator generator=new ProductListGenerator();\n        List<Product> products=generator.generate(10000);\n    ```", "```java\n          Task task=new Task(products, 0, products.size(), 0.20);\n    ```", "```java\n        ForkJoinPool pool=new ForkJoinPool();\n    ```", "```java\n        pool.execute(task);\n    ```", "```java\n        do {\n          System.out.printf(\"Main: Thread Count: %d\\n\",pool.getActiveThreadCount());\n          System.out.printf(\"Main: Thread Steal: %d\\n\",pool.getStealCount());\n          System.out.printf(\"Main: Parallelism: %d\\n\",pool.getParallelism());\n          try {\n            TimeUnit.MILLISECONDS.sleep(5);\n          } catch (InterruptedException e) {\n            e.printStackTrace();\n          }\n        } while (!task.isDone());\n    ```", "```java\n        pool.shutdown();\n    ```", "```java\n        if (task.isCompletedNormally()){\n          System.out.printf(\"Main: The process has completed normally.\\n\");\n        }\n    ```", "```java\n        for (int i=0; i<products.size(); i++){\n          Product product=products.get(i);\n          if (product.getPrice()!=12) {\n            System.out.printf(\"Product %s: %f\\n\",product.getName(),product.getPrice());\n          }\n        }\n    ```", "```java\n        System.out.println(\"Main: End of the program.\\n\");\n    ```", "```java\nIf (problem size > size){\n  tasks=Divide(task);\n  execute(tasks);\n  groupResults()\n  return result;\n} else {\n  resolve problem;\n  return result;\n}\n```", "```java\n    public class Document {\n    ```", "```java\n    private String words[]={\"the\",\"hello\",\"goodbye\",\"packt\", \"java\",\"thread\",\"pool\",\"random\",\"class\",\"main\"};\n    ```", "```java\n      public String[][] generateDocument(int numLines, int numWords, String word){\n    ```", "```java\n        int counter=0;\n        String document[][]=new String[numLines][numWords];\n        Random random=new Random();\n    ```", "```java\n        for (int i=0; i<numLines; i++){\n          for (int j=0; j<numWords; j++) {\n            int index=random.nextInt(words.length);\n            document[i][j]=words[index];\n            if (document[i][j].equals(word)){\n              counter++;\n            }\n          }\n        }\n    ```", "```java\n        System.out.println(\"DocumentMock: The word appears \"+ counter+\" times in the document\");\n        return document;\n    ```", "```java\n    public class DocumentTask extends RecursiveTask<Integer> {\n    ```", "```java\n      private String document[][];\n      private int start, end;\n      private String word;\n    ```", "```java\n      public DocumentTask (String document[][], int start, int end, String word){\n        this.document=document;\n        this.start=start;\n        this.end=end;\n        this.word=word;\n      }\n    ```", "```java\n      @Override\n      protected Integer compute() {\n          int result;\n        if (end-start<10){\n          result=processLines(document, start, end, word);\n    ```", "```java\n        } else {\n          int mid=(start+end)/2;\n          DocumentTask task1=new DocumentTask(document,start,mid,word);\n          DocumentTask task2=new DocumentTask(document,mid,end,word);\n          invokeAll(task1,task2);\n    ```", "```java\n          try {\n            result=groupResults(task1.get(),task2.get());\n          } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n          }\n        }\n        return result;\n    ```", "```java\n      private Integer processLines(String[][] document, int start, int end,String word) {\n    ```", "```java\n        List<LineTask> tasks=new ArrayList<LineTask>();  \n        for (int i=start; i<end; i++){\n          LineTask task=new LineTask(document[i], 0, document[i].length, word);\n          tasks.add(task);\n        }\n    ```", "```java\n        invokeAll(tasks);\n    ```", "```java\n        int result=0;\n        for (int i=0; i<tasks.size(); i++) {\n          LineTask task=tasks.get(i);\n          try {\n            result=result+task.get();\n          } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n          }\n        }\n        return new Integer(result);\n    ```", "```java\n      private Integer groupResults(Integer number1, Integer number2) {\n        Integer result;\n        result=number1+number2;\n        return result;\n      }\n    ```", "```java\n    public class LineTask extends RecursiveTask<Integer>{\n    ```", "```java\n      private static final long serialVersionUID = 1L;\n      private String line[];\n      private int start, end;\n      private String word;\n    ```", "```java\n      public LineTask(String line[], int start, int end, String word) {\n        this.line=line;\n        this.start=start;\n        this.end=end;\n        this.word=word;\n      }\n    ```", "```java\n      @Override\n      protected Integer compute() {\n        Integer result=null;\n        if (end-start<100) {\n          result=count(line, start, end, word);\n    ```", "```java\n        } else {\n          int mid=(start+end)/2;\n          LineTask task1=new LineTask(line, start, mid, word);\n          LineTask task2=new LineTask(line, mid, end, word);\n          invokeAll(task1, task2);\n    ```", "```java\n          try {\n            result=groupResults(task1.get(),task2.get());\n          } catch (InterruptedException | ExecutionException e) {\n            e.printStackTrace();\n          }\n        }\n        return result;\n    ```", "```java\n      private Integer count(String[] line, int start, int end, String word) {\n    ```", "```java\n        int counter;\n        counter=0;\n        for (int i=start; i<end; i++){\n          if (line[i].equals(word)){\n            counter++;\n          }\n        }\n    ```", "```java\n        try {\n          Thread.sleep(10);\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n    ```", "```java\n        return counter;\n    ```", "```java\n      private Integer groupResults(Integer number1, Integer number2) {\n        Integer result;\n        result=number1+number2;\n        return result;\n      }\n    ```", "```java\n    public class Main{\n      public static void main(String[] args) {\n    ```", "```java\n        DocumentMock mock=new DocumentMock();\n        String[][] document=mock.generateDocument(100, 1000, \"the\");\n    ```", "```java\n        DocumentTask task=new DocumentTask(document, 0, 100, \"the\");\n    ```", "```java\n        ForkJoinPool pool=new ForkJoinPool();\n        pool.execute(task);\n    ```", "```java\n        do {\n          System.out.printf(\"******************************************\\n\");\n          System.out.printf(\"Main: Parallelism: %d\\n\",pool.getParallelism());\n          System.out.printf(\"Main: Active Threads: %d\\n\",pool.getActiveThreadCount());\n          System.out.printf(\"Main: Task Count: %d\\n\",pool.getQueuedTaskCount());\n          System.out.printf(\"Main: Steal Count: %d\\n\",pool.getStealCount());\n          System.out.printf(\"******************************************\\n\");\n          try {\n            TimeUnit.SECONDS.sleep(1);\n          } catch (InterruptedException e) {\n            e.printStackTrace();\n          }\n        } while (!task.isDone());\n    ```", "```java\n        pool.shutdown();\n    ```", "```java\n        try {\n          pool.awaitTermination(1, TimeUnit.DAYS);\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n    ```", "```java\n        try {\n          System.out.printf(\"Main: The word appears %d in the document\",task.get());\n        } catch (InterruptedException | ExecutionException e) {\n          e.printStackTrace();\n        }\n    ```", "```java\n    public class FolderProcessor extends RecursiveTask<List<String>> {\n    ```", "```java\n      private static final long serialVersionUID = 1L;\n    ```", "```java\n      private String path;\n    ```", "```java\n      private String extension;\n    ```", "```java\n      public FolderProcessor (String path, String extension) {\n        this.path=path;\n        this.extension=extension;\n      }\n    ```", "```java\n      @Override\n      protected List<String> compute() {\n    ```", "```java\n        List<String> list=new ArrayList<>();\n    ```", "```java\n        List<FolderProcessor> tasks=new ArrayList<>();\n    ```", "```java\n        File file=new File(path);\n        File content[] = file.listFiles();\n    ```", "```java\n        if (content != null) {\n          for (int i = 0; i < content.length; i++) {\n            if (content[i].isDirectory()) {\n              FolderProcessor task=new FolderProcessor(content[i].getAbsolutePath(), extension);\n              task.fork();\n              tasks.add(task);\n    ```", "```java\n            } else {\n              if (checkFile(content[i].getName())){\n                list.add(content[i].getAbsolutePath());\n              }\n            }\n          }\n    ```", "```java\n          if (tasks.size()>50) {\n            System.out.printf(\"%s: %d tasks ran.\\n\",file.getAbsolutePath(),tasks.size());\n          }\n\n    ```", "```java\n          addResultsFromTasks(list,tasks);\n    ```", "```java\n        return list;\n    ```", "```java\n      private void addResultsFromTasks(List<String> list,\n          List<FolderProcessor> tasks) {\n        for (FolderProcessor item: tasks) {\n          list.addAll(item.join());\n        }\n      }\n    ```", "```java\n      private boolean checkFile(String name) {\n         return name.endsWith(extension);\n      }\n    ```", "```java\n    public class Main {\n      public static void main(String[] args) {\n    ```", "```java\n        ForkJoinPool pool=new ForkJoinPool();\n    ```", "```java\n        FolderProcessor system=new FolderProcessor(\"C:\\\\Windows\", \"log\");\n        FolderProcessor apps=new \n    FolderProcessor(\"C:\\\\Program Files\",\"log\");\n        FolderProcessor documents=new FolderProcessor(\"C:\\\\Documents And Settings\",\"log\");\n    ```", "```java\n        pool.execute(system);\n        pool.execute(apps);\n        pool.execute(documents);\n    ```", "```java\n        do {\n          System.out.printf(\"******************************************\\n\");\n          System.out.printf(\"Main: Parallelism: %d\\n\",pool.getParallelism());\n          System.out.printf(\"Main: Active Threads: %d\\n\",pool.getActiveThreadCount());\n          System.out.printf(\"Main: Task Count: %d\\n\",pool.getQueuedTaskCount());\n          System.out.printf(\"Main: Steal Count: %d\\n\",pool.getStealCount());\n          System.out.printf(\"******************************************\\n\");\n          try {\n            TimeUnit.SECONDS.sleep(1);\n          } catch (InterruptedException e) {\n            e.printStackTrace();\n          }\n        } while ((!system.isDone())||(!apps.isDone())||(!documents.isDone()));\n    ```", "```java\n        pool.shutdown();\n    ```", "```java\n        List<String> results;\n\n        results=system.join();\n        System.out.printf(\"System: %d files found.\\n\",results.size());\n\n        results=apps.join();\n        System.out.printf(\"Apps: %d files found.\\n\",results.size());\n\n        results=documents.join();\n        System.out.printf(\"Documents: %d files found.\\n\",results.size());\n    ```", "```java\n    public class Task extends RecursiveTask<Integer> {\n    ```", "```java\n      private int array[];\n    ```", "```java\n      private int start, end;\n    ```", "```java\n      public Task(int array[], int start, int end){\n        this.array=array;\n        this.start=start;\n        this.end=end;\n      }\n    ```", "```java\n      @Override\n      protected Integer compute() {\n        System.out.printf(\"Task: Start from %d to %d\\n\",start,end); \n    ```", "```java\n        if (end-start<10) {\n          if ((3>start)&&(3<end)){\n            throw new RuntimeException(\"This task throws an\"+ \"Exception: Task from  \"+start+\" to \"+end);\n          }      \n          try {\n            TimeUnit.SECONDS.sleep(1);\n          } catch (InterruptedException e) {\n            e.printStackTrace();\n          }\n    ```", "```java\n        } else {\n          int mid=(end+start)/2;\n          Task task1=new Task(array,start,mid);\n          Task task2=new Task(array,mid,end);\n          invokeAll(task1, task2);\n        }\n    ```", "```java\n        System.out.printf(\"Task: End form %d to %d\\n\",start,end);\n    ```", "```java\n        return 0;\n    ```", "```java\n    public class Main {\n      public static void main(String[] args) {\n    ```", "```java\n        int array[]=new int[100];\n    ```", "```java\n        Task task=new Task(array,0,100);\n    ```", "```java\n        ForkJoinPool pool=new ForkJoinPool();\n    ```", "```java\n        pool.execute(task);\n    ```", "```java\n        pool.shutdown();\n    ```", "```java\n        try {\n          pool.awaitTermination(1, TimeUnit.DAYS);\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n    ```", "```java\n        if (task.isCompletedAbnormally()) {\n          System.out.printf(\"Main: An exception has ocurred\\n\");\n          System.out.printf(\"Main: %s\\n\",task.getException());\n        }\n        System.out.printf(\"Main: Result: %d\",task.join());\n    ```", "```java\nTask: Starting form 0 to 100\nTask: Starting form 0 to 50\nTask: Starting form 0 to 25\nTask: Starting form 0 to 12\nTask: Starting form 0 to 6\n```", "```java\nException e=new Exception(\"This task throws an Exception: \"+ \"Task from  \"+start+\" to \"+end);\ncompleteExceptionally(e);\n```", "```java\n    public class ArrayGenerator {\n      public int[] generateArray(int size) {\n        int array[]=new int[size];\n        Random random=new Random();\n        for (int i=0; i<size; i++){\n          array[i]=random.nextInt(10);\n        }\n        return array;\n      }\n    ```", "```java\n    public class TaskManager {\n    ```", "```java\n      private List<ForkJoinTask<Integer>> tasks;\n    ```", "```java\n      public TaskManager(){\n        tasks=new ArrayList<>();\n      }\n    ```", "```java\n      public void addTask(ForkJoinTask<Integer> task){\n        tasks.add(task);\n      }\n    ```", "```java\n      public void cancelTasks(ForkJoinTask<Integer> cancelTask){\n        for (ForkJoinTask<Integer> task  :tasks) {\n          if (task!=cancelTask) {\n            task.cancel(true);\n            ((SearchNumberTask)task).writeCancelMessage();\n          }\n        }\n      }\n    ```", "```java\n    public class SearchNumberTask extends RecursiveTask<Integer> {\n    ```", "```java\n      private int numbers[];\n    ```", "```java\n      private int start, end;\n    ```", "```java\n      private int number;\n    ```", "```java\n      private TaskManager manager;\n    ```", "```java\n      private final static int NOT_FOUND=-1;\n    ```", "```java\n      public Task(int numbers[], int start, int end, int number, TaskManager manager){\n        this.numbers=numbers;\n        this.start=start;\n        this.end=end;\n        this.number=number;\n        this.manager=manager;\n      }\n    ```", "```java\n      @Override\n      protected Integer compute() {\n        System.out.println(\"Task: \"+start+\":\"+end);\n    ```", "```java\n        int ret;\n        if (end-start>10) {\n          ret=launchTasks();\n    ```", "```java\n        } else {\n          ret=lookForNumber();\n        }\n    ```", "```java\n        return ret;\n    ```", "```java\n      private int lookForNumber() {\n    ```", "```java\n        for (int i=start; i<end; i++){\n          if (array[i]==number) {\n            System.out.printf(\"Task: Number %d found in position %d\\n\",number,i);\n            manager.cancelTasks(this);\n            return i;\n          }\n    ```", "```java\n          try {\n            TimeUnit.SECONDS.sleep(1);\n          } catch (InterruptedException e) {\n            e.printStackTrace();\n          }\n        }\n    ```", "```java\n        return NOT_FOUND;\n      }\n    ```", "```java\n      private int launchTasks() {\n        int mid=(start+end)/2;\n\n        Task task1=new Task(array,start,mid,number,manager);\n        Task task2=new Task(array,mid,end,number,manager);\n    ```", "```java\n        manager.addTask(task1);\n        manager.addTask(task2);\n    ```", "```java\n        task1.fork();\n        task2.fork();\n    ```", "```java\n        int returnValue;\n\n        returnValue=task1.join();\n        if (returnValue!=-1) {\n          return returnValue;\n        }\n\n        returnValue=task2.join();\n        return returnValue;\n    ```", "```java\n      public void writeCancelMessage(){\n        System.out.printf(\"Task: Canceled task from %d to %d\",start,end);\n      }\n    ```", "```java\n    public class Main {\n      public static void main(String[] args) {\n    ```", "```java\n        ArrayGenerator generator=new ArrayGenerator();\n        int array[]=generator.generateArray(1000);\n    ```", "```java\n        TaskManager manager=new TaskManager();\n    ```", "```java\n        ForkJoinPool pool=new ForkJoinPool();\n    ```", "```java\n        Task task=new Task(array,0,1000,5,manager);\n    ```", "```java\n        pool.execute(task);\n    ```", "```java\n        pool.shutdown();\n    ```", "```java\n        try {\n          pool.awaitTermination(1, TimeUnit.DAYS);\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n    ```", "```java\n        System.out.printf(\"Main: The program has finished\\n\");\n    ```"]