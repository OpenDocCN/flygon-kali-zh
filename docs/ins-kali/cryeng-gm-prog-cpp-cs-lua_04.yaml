- en: Chapter 4. Game Rules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 游戏规则
- en: Actors and entities are integral parts of the game, but game rules are what
    tie them together. The game rules system manages all initial player events, such
    as OnConnect, OnDisconnect, and OnEnteredGame.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 角色和实体是游戏的组成部分，但游戏规则是将它们联系在一起的东西。游戏规则系统管理所有初始玩家事件，如OnConnect、OnDisconnect和OnEnteredGame。
- en: Using the game rules system, we can create custom game flow to control and tie
    our gameplay mechanics together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用游戏规则系统，我们可以创建自定义游戏流程来控制和联系我们的游戏机制。
- en: 'In this chapter we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn the basic concept of a game mode
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习游戏模式的基本概念
- en: Create our `IGameRules` implementation in C++
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在C++中创建我们的`IGameRules`实现
- en: Write game rules scripts in Lua and C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用Lua和C#编写游戏规则脚本
- en: Introduction to game rules
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏规则简介
- en: When thinking of a game, we typically direct our thoughts to game mechanics
    such as the handling of deaths and end game conditions. Based on what we've learned
    in the previous chapters, we can't really accomplish this due to every entity
    and actor not affecting a grander scheme.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑游戏时，我们通常会将思绪引向游戏机制，如处理死亡和游戏结束条件。根据我们在前几章中学到的知识，由于每个实体和角色都不影响更大的方案，我们实际上无法实现这一点。
- en: Game rules do exactly what the name implies; control the rules of the game.
    A rule can be simple, like a rule for what happens when one actor shoots the other,
    or more complex, for example, start and end rounds.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏规则确切地做了其名称所暗示的事情；控制游戏的规则。规则可以很简单，比如一个角色射击另一个角色时会发生什么，或者更复杂，例如开始和结束回合。
- en: 'The CryENGINE game rules implementation revolves around two very similar sounding
    types that are still quite different:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CryENGINE游戏规则实现围绕着两种听起来非常相似但实际上有很大不同的类型：
- en: '**Game rules**: This implementation is done via the `IGameRules` interface
    in C++, and it handles callbacks such as `OnClientConnect` and `OnClientDisconnect`.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏规则**：这是通过C++中的`IGameRules`接口实现的，它处理诸如`OnClientConnect`和`OnClientDisconnect`之类的回调。'
- en: '**Game mode**: This is reliant on the game rules implementation, but extends
    it with game conditions such as actor spawning and kill conditions. For example,
    we could have two game modes; SinglePlayer and DeathMatch, both which rely on
    the default behavior provided by the `IGameRules` implementation, but each adding
    additional functionality, such as support for multiple players.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游戏模式**：这依赖于游戏规则实现，但通过添加额外的功能（如支持多个玩家）扩展了游戏规则实现的默认行为。例如，我们可以有两种游戏模式；单人游戏和死亡竞赛，它们都依赖于`IGameRules`实现提供的默认行为，但每种游戏模式都添加了额外的功能。'
- en: IGameRules interface – game rules
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IGameRules接口 - 游戏规则
- en: At the end of [Chapter 3](ch03.html "Chapter 3. Creating and Utilizing Custom
    Entities"), *Creating and Utilizing Custom Entities*, we learned about game object
    extensions. We'll be using that knowledge in this chapter to implement `IGameRules`,
    a game object extension used to initialize the game context and tie gameplay mechanics
    together.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章 创建和利用自定义实体")结束时，我们学习了游戏对象扩展。在本章中，我们将利用这些知识来实现`IGameRules`，这是一个游戏对象扩展，用于初始化游戏上下文并将游戏机制联系在一起。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always keep in mind that the currently active game mode is an entity. This can
    sometimes be abused by requesting entity events. For example, a common hack in
    the Crytek game, Crysis, revolved around sending a bullet or kill event on the
    game mode. This essentially "killed" the game rules entity and resulted in a hard
    server crash.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 始终记住当前活动的游戏模式是一个实体。这有时可以通过请求实体事件来滥用。例如，在Crytek游戏Crysis中，一个常见的黑客技巧是围绕在游戏模式上发送子弹或杀死事件。这实质上“杀死”了游戏规则实体，并导致服务器严重崩溃。
- en: The `IGameRules` implementation is commonly responsible for the most basic behavior
    of your game modes, and forwards everything else to its C# or Lua script.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`IGameRules`实现通常负责游戏模式的最基本行为，并将其他所有内容转发到其C#或Lua脚本。'
- en: Scripting – game modes
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本 - 游戏模式
- en: After registering our `IGameRules` implementation, we'll need to register a
    game mode that utilizes it. This is done using the `IGameRulesSystem::RegisterGameRules`
    function (commonly done inside `IGame::Init`).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册我们的`IGameRules`实现之后，我们需要注册一个使用它的游戏模式。这是使用`IGameRulesSystem::RegisterGameRules`函数完成的（通常在`IGame::Init`中完成）。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After having processed the previous snippet, the game rules system will be aware
    of our game mode. When the `sv_gamerules` console variable is changed to `MyGameMode`,
    the system will create a new entity and activate its game object extension called
    `GameRules` (registered in the previous section).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理了前面的片段之后，游戏规则系统将意识到我们的游戏模式。当`sv_gamerules`控制台变量更改为`MyGameMode`时，系统将创建一个新的实体，并激活其名为`GameRules`的游戏对象扩展（在前一节中注册）。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The console variable `sv_gamerules` is set to the value of `sv_gamerulesdefault`
    on CryENGINE startup, unless running on a dedicated server.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`sv_gamerules`控制台变量在CryENGINE启动时设置为`sv_gamerulesdefault`的值，除非在专用服务器上运行。'
- en: At this point, the game will automatically search for a Lua script named after
    your game mode in `Scripts/GameRules/`. For the previous snippet, it would find
    and load `Scripts/GameRules/MyGameMode.lua`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，游戏将自动搜索名为你的游戏模式的Lua脚本，位于`Scripts/GameRules/`中。对于前面的片段，它会找到并加载`Scripts/GameRules/MyGameMode.lua`。
- en: By using scripts, the game rules implementation can forward game events (such
    as new player connections) to Lua or C#, allowing each game mode to specialize
    behavior depending on its internal logic.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用脚本，游戏规则实现可以将游戏事件（如新玩家连接）转发到Lua或C#，允许每个游戏模式根据其内部逻辑专门化行为。
- en: Loading a level
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载关卡
- en: When a level is loaded using the map console command, the game framework searches
    for the level inside `Game/Levels`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用地图控制台命令加载关卡时，游戏框架会在`Game/Levels`中搜索关卡。
- en: 'By using `IGameRulesSystem::AddGameRulesLevelLocation`, we can add subdirectories
    within `Game/Levels` which will be searched when looking for a new level. For
    example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`IGameRulesSystem::AddGameRulesLevelLocation`，我们可以在`Game/Levels`中添加子目录，当寻找新关卡时将会搜索这些子目录。例如：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When loading a level with `sv_gamerules` set to `MyGameMode`, the game framework
    will now search in the `Levels/MGM_Levels/` directory for the level directory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载一个将 `sv_gamerules` 设置为 `MyGameMode` 的关卡时，游戏框架现在会在 `Levels/MGM_Levels/` 目录中搜索关卡目录。
- en: This allows game mode specific levels to be moved to subdirectories within the
    `Game/Levels` directory, making it much easier to sort levels by game mode.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许游戏模式特定的关卡被移动到 `Game/Levels` 目录中的子目录中，这样可以更容易地按游戏模式对关卡进行排序。
- en: Implementing the game rules interface
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现游戏规则接口
- en: Now that we know the basic workings of the game rules system, we can give creating
    a custom `IGameRules` implementation a shot.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了游戏规则系统的基本工作原理，我们可以尝试创建一个自定义的 `IGameRules` 实现。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before we start, consider whether you actually need a custom `IGameRules` implementation
    for your game. The default GameDLL that ships with `CGameRules`, is an `IGameRules`
    implementation specialized for **First-Person Shooters** (**FPS**). If your game
    premise is similar to a FPS, or if you can reuse existing functionality that might
    be preferrable to writing an implementation from scratch.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，请考虑你是否真的需要为你的游戏创建一个自定义的 `IGameRules` 实现。随游戏一起提供的默认 GameDLL 是专门为**第一人称射击游戏**（**FPS**）专门化的
    `IGameRules` 实现。如果你的游戏前提类似于 FPS，或者你可以重用现有功能，那么可能更好地编写一个实现。
- en: To start, we'll need to create two new files; `GameRules.cpp` and `GameRules.h`.When
    you're done, open `GameRules.h` and create a new class. We'll be naming ours as
    `CGameRules`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建两个新文件；`GameRules.cpp` 和 `GameRules.h`。完成后，打开 `GameRules.h` 并创建一个新的类。我们将命名为
    `CGameRules`。
- en: 'After the class is in place, we have to derive from `IGameRules`. As we mentioned
    before, game rules are handled as game object extensions. We''ll therefore have
    to use the `CGameObjectExtensionHelper` template class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类就位后，我们必须从 `IGameRules` 派生。如前所述，游戏规则被处理为游戏对象扩展。因此，我们必须使用 `CGameObjectExtensionHelper`
    模板类：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The third and optional `CGameObjectExtensionHelper` parameter defines how many
    RMIs this game object support. We'll cover it further in [Chapter 8](ch08.html
    "Chapter 8. Multiplayer and Networking"), *Multiplayer and Networking*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个可选的 `CGameObjectExtensionHelper` 参数定义了这个游戏对象支持多少个 RMIs。我们将在[第8章](ch08.html
    "第8章。多人游戏和网络") *多人游戏和网络*中进一步讨论它。
- en: 'With the class present, we can start implementing all the pure virtual methods
    defined in the `IGameRules` and `IGameObjectExtension` structs. As with entities,
    we can implement dummies that return either nothing, nullptr, zero, false or an
    empty string. The methods that need to be handled separately are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个类，我们可以开始实现 `IGameRules` 和 `IGameObjectExtension` 结构中定义的所有纯虚方法。与实体一样，我们可以实现返回空、nullptr、零、false
    或空字符串的虚拟方法。需要单独处理的方法如下：
- en: '| Function name | Description |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 函数名 | 描述 |'
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `IGameObjectExtension::Init` | Called to initialize the game object extension.
    Should call `IGameRulesSystem::SetCurrentGameRules(this)` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `IGameObjectExtension::Init` | 用于初始化游戏对象扩展。应该调用 `IGameRulesSystem::SetCurrentGameRules(this)`
    |'
- en: '| `IGameRules::OnClientConnect` | Called on the server when a new client connects,
    has to create a new actor using `IActorSystem::CreateActor` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `IGameRules::OnClientConnect` | 当新客户端连接时在服务器上调用，必须使用 `IActorSystem::CreateActor`
    创建一个新的角色 |'
- en: '| `IGameRules::OnClientDisconnect` | Called on the server when a client disconnects,
    has to contain a call to `IActorSystem::RemoveActor` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `IGameRules::OnClientDisconnect` | 当客户端断开连接时在服务器上调用，必须包含对 `IActorSystem::RemoveActor`
    的调用 |'
- en: '| `IGameObjectExtension::Release / Destructor` | The `Release` function should
    delete the extension instance and call `IGameRulesSystem::SetCurrentGameRules(nullptr)`
    via its the destructor |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `IGameObjectExtension::Release / 析构函数` | `Release` 函数应该删除扩展实例，并通过其析构函数调用
    `IGameRulesSystem::SetCurrentGameRules(nullptr)` |'
- en: Registering the game object extension
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册游戏对象扩展
- en: When you're done, register the game rules implementation by using the `REGISTER_FACTORY`
    macro.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，使用 `REGISTER_FACTORY` 宏注册游戏规则实现。
- en: 'Game object extensions have to be registered early in the game initialization
    process, and therefore most commonly done in the `IGame::Init` function (via `GameFactory.cpp`
    in the default GameDLL):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏对象扩展必须在游戏初始化过程中尽早注册，因此通常在 `IGame::Init` 函数中完成（通过默认 GameDLL 中的 `GameFactory.cpp`）：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Creating custom game modes
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义游戏模式
- en: To get started, we'll need to register our first game mode.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要注册我们的第一个游戏模式。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the difference between the `IGameRules` implementation, and the game mode
    itself. The game mode is dependent on the `IGameRules` implementation, and is
    registered separately.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `IGameRules` 实现和游戏模式本身之间的区别。游戏模式依赖于 `IGameRules` 实现，并且需要单独注册。
- en: 'To register custom game modes, CryENGINE exposes the `IGameRulesSystem::RegisterGameRules`
    function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册自定义游戏模式，CryENGINE 提供了 `IGameRulesSystem::RegisterGameRules` 函数：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The previous code will create a game mode called `MyGameMode`, which depends
    on the `GameRules` game object extension we registered earlier.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将创建一个名为 `MyGameMode` 的游戏模式，它依赖于我们之前注册的 `GameRules` 游戏对象扩展。
- en: When a map is loaded with `sv_gamerules` set to `MyGameMode`, the game rules
    entity will be created and assigned the name `MyGameMode`. After spawning, the
    `IGameRules` extension we created earlier will be constructed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载一个将 `sv_gamerules` 设置为 `MyGameMode` 的地图时，游戏规则实体将被创建并分配名称 `MyGameMode`。生成后，我们之前创建的
    `IGameRules` 扩展将被构造。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are simply creating a copy or subclass of an existing game mode, for
    example, the default `DeathMatch.lua` script that derives from `SinglePlayer.lua`,
    you'll need to register the `DeathMatch` game mode separately.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是创建一个现有游戏模式的副本或子类，例如从 `SinglePlayer.lua` 派生的默认 `DeathMatch.lua` 脚本，你需要单独注册
    `DeathMatch` 游戏模式。
- en: Scripting
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本
- en: Game modes are typically heavily scripting-oriented, with game flow such as
    spawning, killing, and reviving being delegated to a secondary language such as
    Lua or C#.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏模式通常是面向脚本的，游戏流程如生成、杀死和复活通常委托给 Lua 或 C# 等第二语言。
- en: Lua scripting
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lua 脚本
- en: 'As Lua scripts are integrated into the CryENGINE, we don''t need to do any
    additional loading for it to work. To access your script table (based on the Lua
    file named the same as your game mode in `Game/Scripts/GameRules`):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Lua脚本已集成到CryENGINE中，我们无需进行任何额外的加载即可使其工作。要访问您的脚本表（基于与您的游戏模式同名的Lua文件在`Game/Scripts/GameRules`中）：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Invoking methods
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用方法
- en: 'To invoke methods on your script table, see the `IScriptSystem BeginCall` and
    `EndCall` functions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的脚本表上调用方法，请参阅`IScriptSystem BeginCall`和`EndCall`函数：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When executing the previous code, we''ll be able to execute Lua code in a function
    named `MyMethod` contained inside our game mode''s script table. An example of
    the table can be seen as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码时，我们将能够在我们游戏模式的脚本表中包含的名为`MyMethod`的函数中执行Lua代码。表的示例如下所示：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Invoking methods with parameters
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用带参数的方法
- en: 'To provide your Lua method with parameters, use `IScriptSystem::PushFuncParam`
    between the beginning and end of your script call:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要为您的Lua方法提供参数，请在脚本调用的开始和结束之间使用`IScriptSystem::PushFuncParam`：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`IScriptSystem::PushFuncParam` is a template function that attempts to create
    a `ScriptAnyValue` object with the provided value. If the default `ScriptAnyValue`
    constructors don''t support your type, a compiler error will appear.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`IScriptSystem::PushFuncParam`是一个模板函数，尝试使用提供的值创建一个`ScriptAnyValue`对象。如果默认的`ScriptAnyValue`构造函数不支持您的类型，将出现编译器错误。'
- en: 'Congratulations, you have now called a Lua function with a string parameter:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您现在已经使用字符串参数调用了Lua函数：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Getting values returned from Lua
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Lua获取返回值
- en: You can also get return values from Lua functions by passing an additional parameter
    to `IScriptSystem::EndCall`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过向`IScriptSystem::EndCall`传递一个额外的参数来从Lua函数中获取返回值。
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Getting table values
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取表值
- en: 'Sometimes it might be necessary to get values directly from Lua tables, this
    can be done using `IScriptTable::GetValue`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时直接从Lua表中获取值可能是必要的，可以使用`IScriptTable::GetValue`来实现：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The previous code will search for a variable called `bMyBool` in the script,
    and if successful, set its value to the native `bValue` variable.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在脚本中搜索名为`bMyBool`的变量，如果成功，则将其值设置为本机`bValue`变量。
- en: CryMono scripting
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CryMono脚本
- en: 'To create an instance of a CryMono script in your `IGameObjectExtension::Init`
    implementation, see `IMonoScriptSystem::InstantiateScript`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`IGameObjectExtension::Init`实现中创建CryMono脚本的实例，请参阅`IMonoScriptSystem::InstantiateScript`：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code will find a CryMono class with the current game mode's name, and return
    a new instance of it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将查找一个具有当前游戏模式名称的CryMono类，并返回一个新的实例。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is no need to use both Lua and CryMono game rules scripts simultaneously.
    Decide which is best for your use case.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 无需同时使用Lua和CryMono游戏规则脚本。决定哪种对您的用例最好。
- en: Calling methods
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用方法
- en: 'Now that you have your class instance, you can invoke one of its functions
    using the `IMonoObject::CallMethod` helper:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了类实例，可以使用`IMonoObject::CallMethod`助手调用其中一个函数：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code will search for a method named `OnClientConnect` with matching arguments,
    and invoke it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将搜索具有匹配参数的名为`OnClientConnect`的方法，并调用它：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Return values
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回值
- en: '`IMonoObject::CallMethod` returns a `mono::object` type by default, which represents
    a boxed managed object. To get the native value, we''ll have to unbox it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMonoObject::CallMethod`默认返回一个`mono::object`类型，表示一个装箱的托管对象。要获取本机值，我们需要将其解包：'
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Properties
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'To get the value of a property in your managed object, have a look at `IMonoObject::GetPropertyValue`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取托管对象的属性值，请查看`IMonoObject::GetPropertyValue`：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It is also possible to set property values directly:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以直接设置属性值：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Fields
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字段
- en: It is also possible to get and set the values of fields in the same way you
    would with properties, but using the `IMonoObject` methods, `GetFieldValue` and
    `SetFieldValue`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过使用`IMonoObject`方法`GetFieldValue`和`SetFieldValue`以与属性相同的方式获取和设置字段的值。
- en: Creating a basic game mode in C#
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在C#中创建基本游戏模式
- en: Now that we have the basic knowledge required to create a mini-game, why not
    do so? To start off, we'll aim towards creating a very basic system for spawning
    actors and entities.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了创建迷你游戏所需的基本知识，为什么不开始呢？首先，我们将致力于创建一个非常基本的用于生成演员和实体的系统。
- en: Defining our intention
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义我们的意图
- en: 'To start, let''s clarify exactly what we want to do:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们明确我们想要做什么：
- en: Spawn our actor.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成我们的演员。
- en: Assign our actor to one of the two possible teams.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的演员分配给两个可能的团队之一。
- en: Check when an actor enters the opposite team's `Headquarters` entity, and end
    it.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查当演员进入对方的`Headquarters`实体时，并结束它。
- en: Creating the actor
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建演员
- en: 'The first thing we need to do is spawn our actor, which can''t be done before
    we have one. To do this, we''ll need to create a `MyActor.cs` file somewhere in
    the `Game/Scripts` directory and then add the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是生成我们的演员，这在我们拥有演员之前是无法完成的。为此，我们需要在`Game/Scripts`目录中的某个地方创建一个`MyActor.cs`文件，然后添加以下代码：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code snippet is the bare minimum required for an actor to be registered.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段是注册演员所需的最低限度。
- en: We should also update our actor's view, to make sure the player sees something
    when entering the game.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该更新我们演员的视图，以确保玩家进入游戏时能看到一些东西。
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The previous code will simply set the camera to use the player entities' position
    and rotation, with a field of view of 60.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将简单地将摄像机设置为使用玩家实体的位置和旋转，视野为60。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about creating actors and views, refer to [Chapter 5](ch05.html
    "Chapter 5. Creating Custom Actors"), *Creating Custom Actors*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于创建演员和视图的信息，请参阅[第5章](ch05.html "第5章。创建自定义演员")，*创建自定义演员*。
- en: 'Now that we have our actor, we can move on to creating the game mode:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了我们的演员，我们可以继续创建游戏模式：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As with all CryMono types found in the `Game/Scripts/` directory, our game mode
    will be automatically registered on CryENGINE startup, shortly after the call
    to `IGameFramework::Init`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与`Game/Scripts/`目录中找到的所有CryMono类型一样，我们的游戏模式将在CryENGINE启动后不久自动注册，即在调用`IGameFramework::Init`之后。
- en: 'Before moving on to creating game-specific logic, we''ll have to make sure
    our actor is created when the actor connects. To do so, we implement an `OnClientConnect`
    method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续创建特定于游戏的逻辑之前，我们必须确保我们的角色在连接时被创建。为此，我们实现一个`OnClientConnect`方法：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, as script functions aren''t automated, we''ll need to modify our `IGameRules`
    implementation''s `OnClientConnect` method to make sure we receive this callback
    in C#:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于脚本函数不是自动化的，我们需要修改我们的`IGameRules`实现的`OnClientConnect`方法，以确保我们在C#中接收到这个回调：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, when a new player connects to the server, our `IGameRules` implementation
    will call `ReachTheHeadquarters.OnClientConnect`, which in turn creates a new
    actor of type `MyActor`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当新玩家连接到服务器时，我们的`IGameRules`实现将调用`ReachTheHeadquarters.OnClientConnect`，这将创建一个新的`MyActor`类型的角色。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that the game mode's `OnClientConnect` is called very early, right
    at the point when a new client is connecting to the server. If an actor has not
    been created for the specified `channelId` after `OnClientConnect` exits, the
    game will throw a fatal error.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，游戏模式的`OnClientConnect`在非常早期就被调用，就在新客户端连接到服务器时。如果在`OnClientConnect`退出后没有为指定的`channelId`创建角色，游戏将抛出致命错误。
- en: Spawning the actor
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成角色
- en: 'The actor will now be created when the client connects, but what about actually
    repositioning the actor to a **SpawnPoint** ? To start, create a new `SpawnPoint.cs`
    file somewhere in the `Scripts` directory:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端连接时，角色现在将被创建，但是如何将角色重新定位到一个**SpawnPoint**呢？首先，在`Scripts`目录中的某个地方创建一个新的`SpawnPoint.cs`文件：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This entity should now appear in **RollupBar** after you restart the Editor.
    We'll be calling the `spawnPoint.Spawn` function to spawn our actor.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在重新启动编辑器后，这个实体现在应该出现在**RollupBar**中。我们将调用`spawnPoint.Spawn`函数来生成我们的角色。
- en: 'To start, we''ll need to open our `ReachTheHeadquarters` class and add a new
    `OnClientEnteredGame` function:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要打开我们的`ReachTheHeadquarters`类，并添加一个新的`OnClientEnteredGame`函数：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This function will be called when the client enters the game. In Launcher mode
    this typically happens when the player has finished loading, whereas in Editor
    it is called when the player switches into **pure game mode** following *Ctrl*
    + *G*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将在客户端进入游戏时被调用。在启动器模式下，这通常发生在玩家完成加载后，而在编辑器中，它是在玩家按下*Ctrl* + *G*后切换到**纯游戏模式**时调用的。
- en: At its current state, we'll first get the `MyActor` instance of our player,
    and then spawn at a randomly selected `SpawnPoint`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前状态下，我们首先会获取我们玩家的`MyActor`实例，然后在随机选择的`SpawnPoint`处生成。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget to call your script's `OnClientEnteredGame` function from your
    `IGameRules` implementation!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记从你的`IGameRules`实现中调用你的脚本的`OnClientEnteredGame`函数！
- en: Handling disconnections
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理断开连接
- en: 'We''ll also have to make sure the actor is removed when the player disconnects:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保玩家断开连接时角色被移除：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Don't forget to call the `OnClientConnect` function from your `IGameRules` implementation!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记从你的`IGameRules`实现中调用`OnClientConnect`函数！
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Failure to remove the player after disconnection will result in the actor persisting
    in the game world, and more severe issues can appear due to the associated player
    no longer having a connection to the server.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在断开连接后未能移除玩家将导致角色在游戏世界中持续存在，并且由于相关玩家不再与服务器连接，可能会出现更严重的问题。
- en: Assigning the player to a team
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将玩家分配到一个队伍
- en: Now that players can connect and spawn, let's implement a basic teams system
    to keep track of which team each player belongs to.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家可以连接和生成了，让我们实现一个基本的队伍系统，以跟踪每个玩家所属的队伍。
- en: 'First off, let''s add a new `Teams` property to our game mode:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向我们的游戏模式添加一个新的`Teams`属性：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code simply determines which teams our game mode allows for, in our case
    `Red` and `Blue`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码简单地确定了我们的游戏模式允许的队伍，即`红队`和`蓝队`。
- en: 'Now, let''s also add a new property to our `MyActor` class, to determine which
    team the actor belongs to:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们还向我们的`MyActor`类添加一个新属性，以确定角色所属的队伍：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Great! However, we'll also need to add the same snippet to the `SpawnPoint`
    entity to avoid spawning players of the same team next to each other.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！然而，我们还需要将相同的片段添加到`SpawnPoint`实体中，以避免生成相同队伍的玩家相邻。
- en: Once you have done this, open the `ReachTheHeadquarters` game mode class and
    navigate to the `OnClientEnteredGame` function we created earlier. What we want
    to do is expand the `SpawnPoint` selection to only use ones belonging to the player's
    team.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，打开`ReachTheHeadquarters`游戏模式类，并导航到我们之前创建的`OnClientEnteredGame`函数。我们要做的是扩展`SpawnPoint`选择，只使用属于玩家队伍的生成点。
- en: 'Have a look at the following snippet:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下片段：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, replace this snippet with the following one:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用以下代码替换这个片段：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will automatically remove all SpawnPoints in which the `Team` property
    is not equal to that of the player.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动删除所有`Team`属性与玩家不相等的生成点。
- en: 'But wait, we also have to assign the player to a team! To do so, add the following
    before getting the SpawnPoints:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，我们还需要把玩家分配到一个队伍！为了做到这一点，在获取生成点之前添加以下内容：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When a player enters the game, we'll select a random team to assign them to.
    If you want, why not expand this to make sure teams are always balanced? For example,
    don't allow a new player to join team Red if it already has two more players than
    Blue.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家进入游戏时，我们将随机选择一个队伍分配给他们。如果你愿意，为什么不扩展这一点，以确保队伍始终保持平衡？例如，如果红队比蓝队多两名玩家，就不允许新玩家加入红队。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before moving on, feel free to play around with the current setup. You should
    be able to spawn in game!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，随意玩弄当前的设置。你应该能够在游戏中生成！
- en: Implementing Headquarters
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现总部
- en: Finally, let's move on to creating our end game condition; Headquarters. In
    simple terms, each team will have one `Headquarters` entity, and when a player
    enters the headquarters of the opposite team, that player's team wins the game.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们继续创建我们的游戏结束条件；总部。简单来说，每个队伍都会有一个`总部`实体，当玩家进入对方队伍的总部时，该玩家的队伍就赢得了比赛。
- en: Adding the end game event
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加游戏结束事件
- en: 'Before creating the `Headquarters` entity, let''s add a new `EndGame` function
    to our `ReachTheHeadquarters` class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`Headquarters`实体之前，让我们在`ReachTheHeadquarters`类中添加一个新的`EndGame`函数：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We'll call this from the `Headquarters` entity, in order to notify the game
    mode that the game should be ended.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`Headquarters`实体中调用此函数，以通知游戏模式游戏应该结束。
- en: Creating the Headquarters entity
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建总部实体
- en: 'Now, we need to create our `Headquarters` entity (see the following code snippet).
    The entity will be placed in each level via Sandbox, once per team. We''ll expose
    three Editor properties; `Team`, `Minimum`, and `Maximum`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建我们的`Headquarters`实体（请参阅以下代码片段）。该实体将通过Sandbox放置在每个级别中，每个队伍一次。我们将公开三个编辑器属性；`Team`，`Minimum`和`Maximum`：
- en: '`Team`: This determines which team the `Headquarters` instance belongs to,
    in our case either Blue or Red'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Team`：确定`Headquarters`实例属于哪个队伍，在我们的例子中是蓝队或红队'
- en: '`Minimum`: This specifies the minimum size of the trigger area'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Minimum`：指定触发区域的最小大小'
- en: '`Maximum`: This specifies the maximum size of the trigger area'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Maximum`：指定触发区域的最大大小'
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Great! Now we just have to expand the `OnEnterArea` method to notify our game
    mode when the game should end:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们只需要扩展`OnEnterArea`方法，在游戏结束时通知我们的游戏模式：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `Headquarters` entity will now notify the game mode when an entity of the
    opposite team enters it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Headquarters`实体现在将在对立队伍的实体进入时通知游戏模式。'
- en: Detour – trigger bounds and entity areas
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 绕道 - 触发器边界和实体区域
- en: Entities can receive area callbacks by registering an area. This can be done
    by linking the entity to a shape entity or by creating a trigger proxy manually.
    In C# you can create a proxy manually by setting the `EntityBase.TriggerBounds`
    property as we have done in the previous code snippet.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 实体可以通过注册区域接收区域回调。这可以通过将实体链接到形状实体或手动创建触发器代理来完成。在C#中，您可以通过设置`EntityBase.TriggerBounds`属性来手动创建代理，就像我们在之前的代码片段中所做的那样。
- en: When an entity is positioned inside or close to the area, it will start receiving
    events on that entity. This allows specific entities to be created that can track
    when and where players enter specific areas, to trigger specialized gameplay logic.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当实体位于或靠近该区域时，它将开始接收该实体上的事件。这允许创建特定实体，可以跟踪玩家何时以及何地进入特定区域，以触发专门的游戏逻辑。
- en: 'See the following table for a list of available area callbacks, receivable
    via entity events in C++ and virtual functions in the C# `Entity` class:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅以下表格，了解可通过C++实体事件和C# `Entity`类中的虚拟函数接收的可用区域回调列表：
- en: '| Callback name | Description |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 回调名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `OnEnterArea` | Called when an entity has entered the area linked to this
    entity |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: 当一个实体进入与该实体链接的区域时调用`OnEnterArea`。
- en: '| `OnLeaveArea` | Triggered when an entity present inside the area linked to
    this entity has left |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `OnLeaveArea` | 当存在于与该实体链接的区域内的实体离开时触发 |'
- en: '| `OnEnterNearArea` | Triggers when an entity moves near the area linked to
    this entity |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `OnEnterNearArea` | 当实体靠近与该实体链接的区域时触发 |'
- en: '| `OnMoveNearArea` | Called when an entity moves near the area linked to this
    entity |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `OnMoveNearArea` | 当实体靠近与该实体链接的区域时调用 |'
- en: '| `OnLeaveNearArea` | Called when an entity leaves the area near to the area
    linked to this entity |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `OnLeaveNearArea` | 当实体离开与该实体链接的附近区域时调用 |'
- en: '| `OnMoveInsideArea` | Triggered when an entity is repositioned inside the
    area linked to this entity |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `OnMoveInsideArea` | 当实体重新定位到与该实体链接的区域内时触发 |'
- en: Populating the level
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充级别
- en: The basic sample is now complete, but requires some tweaks to get it working!
    First, we'll need to create a new level and place `Headquarters` for each team.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 基本示例现在已经完成，但需要一些调整才能使其正常工作！首先，我们需要创建一个新级别，并为每个队伍放置`Headquarters`。
- en: 'To start, open the Sandbox Editor and create a new level by navigating to **File**
    | **New**:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开Sandbox编辑器，并通过导航到**文件** | **新建**来创建一个新级别：
- en: '![Populating the level](img/5909_04_01.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![Populating the level](img/5909_04_01.jpg)'
- en: This brings up the **New Level** dialog, in which we can set the level name
    and terrain settings.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将弹出**新级别**对话框，在其中我们可以设置级别名称和地形设置。
- en: After clicking on **OK**, your level will be created and then loaded. Once done,
    it's time to start adding the necessary gameplay elements to our level!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**确定**后，您的级别将被创建，然后加载。完成后，现在是时候开始向我们的级别添加必要的游戏元素了！
- en: 'To start, open **RollupBar** and spawn the **Headquarters** entity by dragging
    it into the viewport:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开**RollupBar**并通过将其拖入视口中生成**Headquarters**实体：
- en: '![Populating the level](img/5909_04_02.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![Populating the level](img/5909_04_02.jpg)'
- en: Once spawned, we have to set the Editor properties we created in the **Headquarters**
    class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 生成后，我们必须设置在**Headquarters**类中创建的编辑器属性。
- en: Set **Team** to **Red** and **Maximum** to **10,10,10**. This informs the class
    of which team `Headquarters` belongs to, and the maximum size of the area which
    we'll be querying to detect whether another player has entered it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将**Team**设置为**红色**，**Maximum**设置为**10,10,10**。这会告诉类`Headquarters`属于哪个队伍，并且我们将查询以检测另一个玩家是否进入了该区域的最大大小。
- en: '![Populating the level](img/5909_04_03.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Populating the level](img/5909_04_03.jpg)'
- en: Once you have done this, spawn another **Headquarters** entity (or copy the
    existing one) and follow the same process, except this time set the **Team** property
    to **Blue**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，生成另一个**Headquarters**实体（或复制现有实体），然后按照相同的过程进行操作，只是这次将**Team**属性设置为**蓝色**。
- en: 'Now, we just have to spawn one SpawnPoint entity per team and we''re ready
    to go! Open **RollupBar** again and go to **Others** | **SpawnPoint** :'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要为每个队伍生成一个SpawnPoint实体，然后我们就可以开始了！再次打开**RollupBar**，然后转到**其他** | **SpawnPoint**：
- en: '![Populating the level](img/5909_04_04.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![Populating the level](img/5909_04_04.jpg)'
- en: 'Now, drag the entity onto the viewport to spawn it in the same way you did
    to spawn **Headquarters**. Once spawned, set the **Team** property to **Red**
    and then repeat the process for the Blue team:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将实体拖放到视口中，以与生成**Headquarters**相同的方式生成它。生成后，将**Team**属性设置为**红色**，然后为蓝队重复该过程：
- en: '![Populating the level](img/5909_04_05.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![Populating the level](img/5909_04_05.jpg)'
- en: Done! You should now be able to enter the game using *Ctrl* + *G* or by navigating
    to **Game** | **Switch to Game**. However, as we haven't added any type of player
    movement, the players won't be able to navigate towards the enemy headquarters
    to end the game.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！现在你应该能够使用 *Ctrl* + *G* 进入游戏，或者通过导航到 **游戏** | **切换到游戏**。然而，由于我们还没有添加任何类型的玩家移动，玩家将无法朝着敌方总部移动以结束游戏。
- en: To learn how to handle player input and movement, refer to the next chapter,
    [Chapter 5](ch05.html "Chapter 5. Creating Custom Actors"), *Creating Custom Actors*.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何处理玩家输入和移动，请参考下一章，[第5章](ch05.html "第5章 创建自定义角色")，*创建自定义角色*。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned the basic behavior of the game rules system,
    and created our own `IGameRules` implementation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了游戏规则系统的基本行为，并创建了自己的`IGameRules`实现。
- en: After having registered your own game mode, and created the `Headquarters` sample
    in C#, you should have a good understanding of the game rules system.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册了自己的游戏模式并在C#中创建了`Headquarters`示例之后，你应该对游戏规则系统有了很好的理解。
- en: We've created our first game mode, and can now move onto the next chapter. Keep
    in mind the purpose of game rules in future chapters, so you can tie together
    all the game mechanics that need to be created in a game.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了第一个游戏模式，现在可以继续下一章了。记住未来章节中游戏规则的目的，这样你就可以将需要在游戏中创建的所有游戏机制联系在一起。
- en: Not satisfied with game rules yet? Why not try and create a basic rule-set for
    your game in a scripting language of your choice, or perhaps extend the sample
    we created previously. In the next chapter, we will see how to create custom actors.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对游戏规则还不满意？为什么不尝试在你选择的脚本语言中创建一个基本的游戏规则集，或者扩展我们之前创建的示例。在下一章中，我们将看到如何创建自定义角色。
