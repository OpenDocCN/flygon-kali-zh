- en: Introduction to Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes简介
- en: In this chapter, we will start to learn about Kubernetes, the most popular and
    widely used container orchestrator at the time of writing this book. Since the
    subjects on container orchestrators in general and Kubernetes itself are too big
    to be covered in one chapter, I will focus on introducing the areas that I have
    found to be the most important when I used Kubernetes over the last few years.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始学习Kubernetes，这是撰写本书时最受欢迎和广泛使用的容器编排器。由于一般容器编排器和Kubernetes本身的主题太大，无法在一章中涵盖，因此我将重点介绍我在过去几年中使用Kubernetes时发现最重要的领域。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing Kubernetes concepts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Kubernetes概念
- en: Introducing Kubernetes API objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Kubernetes API对象
- en: Introducing Kubernetes runtime components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Kubernetes运行时组件
- en: Creating a local Kubernetes cluster
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建本地Kubernetes集群
- en: Trying out a sample deployment and getting used to the `kubectl` Kubernetes
    CLI tool
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试一个示例部署，并熟悉`kubectl` Kubernetes CLI工具
- en: Managing a Kubernetes cluster
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理Kubernetes集群
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To work with Kubernetes locally, we will use Minikube running on VirtualBox.
    We will also use the Kubernetes CLI tool known as `kubectl` a lot. `kubectl` comes
    with Docker for macOS, but unfortunately with a version that''s too old (at least
    as of when this chapter was written). Therefore, we need to install a newer version.
    In total, we need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本地使用Kubernetes，我们将使用在VirtualBox上运行的Minikube。我们还将大量使用被称为`kubectl`的Kubernetes
    CLI工具。`kubectl`随Docker for macOS一起提供，但不幸的是，版本太旧（至少在撰写本章时是这样）。因此，我们需要安装更新版本。总之，我们需要以下内容：
- en: Minikube version 1.2 or later
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minikube版本1.2或更高
- en: kubectl version 1.15 or later
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: kubectl版本1.15或更高
- en: VirtualBox version 6.0 or later
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VirtualBox版本6.0或更高
- en: 'These tools can be installed using Homebrew with the following commands:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Homebrew和以下命令安装这些工具：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After installing `kubectl`, run the following command to ensure that the newer
    version of `kubectl` is used:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`kubectl`后，运行以下命令以确保使用新版本的`kubectl`：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The installation of VirtualBox will ask you to rely on the system extensions
    that come with VirtualBox:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安装VirtualBox将要求您依赖于VirtualBox附带的系统扩展：
- en: '![](img/d6ccf0f8-41b0-4145-8956-2f97719b5556.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d6ccf0f8-41b0-4145-8956-2f97719b5556.png)'
- en: 'Click on the OK button and then on the Allow button in the next dialog window:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“确定”按钮，然后在下一个对话框中单击“允许”按钮。
- en: '![](img/23dd883f-5cb1-4078-be74-65f77336496c.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23dd883f-5cb1-4078-be74-65f77336496c.png)'
- en: 'Conclude the tool''s installation by verifying the versions of the installed
    tools with the following commands:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令验证已安装工具的版本，以完成工具的安装：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Expect a response such as the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 期望得到以下类似的响应：
- en: '![](img/860bf0d5-1a10-4dc4-9a58-95c7651f5921.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/860bf0d5-1a10-4dc4-9a58-95c7651f5921.png)'
- en: The source code for this chapter can be found in this book's GitHub repository: [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter15](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter15).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在本书的GitHub存储库中找到：[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter15](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter15)。
- en: 'To be able to run the commands that are described in this book, you need to
    download the source code to a folder and set up an environment variable, `$BOOK_HOME`,
    that points to that folder. Some sample commands are as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够运行本书中描述的命令，您需要将源代码下载到一个文件夹，并设置一个指向该文件夹的环境变量`$BOOK_HOME`。一些示例命令如下：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All the source code examples in this chapter come from the source code in `$BOOK_HOME/Chapter15`
    and have been tested using Kubernetes 1.15.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有源代码示例均来自`$BOOK_HOME/Chapter15`中的源代码，并已经使用Kubernetes 1.15进行了测试。
- en: Introducing Kubernetes concepts
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Kubernetes概念
- en: At a high level, as a container orchestrator, Kubernetes makes a cluster of
    servers (physical or virtual) that run containers appear as one big logical server
    running containers. As an operator, we declare a desired state to the Kubernetes
    cluster by creating objects using the Kubernetes API. Kubernetes continuously
    compares the desired state with the current state. If it detects differences,
    it takes actions to ensure that the current state is the same as the desired state.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，作为容器编排器，Kubernetes使运行容器的服务器集群（物理或虚拟）看起来像一个运行容器的大逻辑服务器。作为操作员，我们通过使用Kubernetes
    API创建对象来向Kubernetes集群声明所需的状态。Kubernetes不断比较所需状态和当前状态。如果检测到差异，它会采取行动以确保当前状态与所需状态相同。
- en: One of the main purposes of a Kubernetes cluster is to deploy and run containers,
    but also to support zero-downtime rolling upgrades using techniques such as green/blue
    and canary deployments. Kubernetes can schedule containers, that is, **pods** that
    contain one or more co-located containers, to the available nodes in the cluster.
    To be able to monitor the health of running containers, Kubernetes assumes that
    containers implement a **liveness** **probe**. If a liveness probe reports an
    unhealthy container, Kubernetes will restart the container. Containers can be
    scaled in the cluster manually or automatically using a horizontal autoscaler.
    To optimize the use of the available hardware resources in a cluster, for example,
    memory and CPU, containers can be configured with **quotas** that specify how
    much resources a container needs. On the other hand, limits regarding how much
    a group of containers is allowed to consume can be specified on a **namespace**
    level. Namespaces will be introduced as we proceed through this chapter. This
    is of extra importance if several teams share a common Kubernetes cluster.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群的主要目的之一是部署和运行容器，同时支持使用绿/蓝和金丝雀部署等技术进行零停机滚动升级。Kubernetes可以调度容器，也就是包含一个或多个共同容器的**pod**，到集群中可用的节点上。为了能够监视正在运行的容器的健康状况，Kubernetes假设容器实现了**活跃探针**。如果活跃探针报告一个不健康的容器，Kubernetes将重新启动该容器。容器可以在集群中手动或自动地进行扩展，使用水平自动缩放器。为了优化集群中可用的硬件资源的使用，例如内存和CPU，容器可以配置**配额**，指定容器需要多少资源。另一方面，可以在**命名空间**级别上指定关于允许一组容器消耗多少资源的限制。随着我们在本章中的进行，将介绍命名空间。如果多个团队共享一个常见的Kubernetes集群，这一点尤为重要。
- en: Another main purpose of Kubernetes is to provide service discovery of the running
    pods and its containers. Kubernetes `Service` objects can be defined for services
    discovery and will also load balance incoming requests over the available pods.
    `Service` objects can be exposed externally of a Kubernetes cluster. However,
    as we will see, an Ingress object is, in many cases, better suited to handling
    externally incoming traffic to a group of services. To help Kubernetes find out
    whether a container is ready to accept incoming requests, a container can implement
    a **readiness probe**.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的另一个主要目的是提供正在运行的pod及其容器的服务发现。可以为服务发现定义Kubernetes `Service`对象，并且还将负载均衡传入的请求到可用的pod上。`Service`对象可以在Kubernetes集群的外部暴露。然而，正如我们将看到的，Ingress对象在许多情况下更适合处理传入到一组服务的外部流量。为了帮助Kubernetes找出容器是否准备好接受传入的请求，容器可以实现**就绪探针**。
- en: Internally, a Kubernetes cluster provides one big flat IP network where each
    pod gets its own IP address and can reach all the other pods, independent of what
    node they run on. To support multiple network vendors, Kubernetes allows the use
    of network plugins that comply with the **Container Network Interface** (**CNI**) specification
    ([https://github.com/containernetworking/cni](https://github.com/containernetworking/cni)).
    Pods are not isolated by default, that is, they accept all incoming requests.
    CNI plugins that support the use of network policy definitions can be used to
    lock down access to pods, for example, only allowing traffic from pods in the
    same namespace.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Kubernetes集群提供一个大的扁平IP网络，每个pod都有自己的IP地址，并且可以访问所有其他pod，独立于它们运行在哪个节点上。为了支持多个网络供应商，Kubernetes允许使用符合**容器网络接口**（**CNI**）规范的网络插件（[https://github.com/containernetworking/cni](https://github.com/containernetworking/cni)）。默认情况下，pod并不是隔离的，也就是说，它们接受所有传入的请求。支持使用网络策略定义的CNI插件可以用于限制对pod的访问，例如，只允许来自同一命名空间中的pod的流量。
- en: To allow multiple teams to work on the same Kubernetes cluster in a safe way, **Role-Based
    Access Control** (**RBAC**, [https://kubernetes.io/docs/reference/access-authn-authz/rbac](https://kubernetes.io/docs/reference/access-authn-authz/rbac)/)
    can be applied. For example, administrators can be authorized to access resources
    on a cluster level, while the access of team members can be locked down to resources
    that are created in a namespace owned by the teams.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让多个团队以安全的方式在同一个Kubernetes集群上工作，可以应用**基于角色的访问控制**（**RBAC**，[https://kubernetes.io/docs/reference/access-authn-authz/rbac](https://kubernetes.io/docs/reference/access-authn-authz/rbac)/）。例如，管理员可以被授权访问集群级别的资源，而团队成员的访问权限可以被限制在由团队拥有的命名空间中创建的资源上。
- en: In total, these concepts provide a platform for running containers that is scalable,
    secure, highly available, and resilient.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这些概念为运行容器提供了一个可扩展、安全、高可用和有弹性的平台。
- en: Let's look a bit more into API objects that are available in Kubernetes and
    after that, what runtime components make up a Kubernetes cluster.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解Kubernetes中可用的API对象，以及组成Kubernetes集群的运行时组件。
- en: Introducing Kubernetes API objects
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Kubernetes API对象
- en: 'Kubernetes defines an API that is used to manage different types of *objects* or
    *resources*, as they are also known as. Some of the most commonly used types, or *kinds*, as
    they are referred to in the API, are as follows in my experience:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes定义了一个API，用于管理不同类型的*对象*或*资源*，它们也被称为。在我的经验中，一些最常用的类型或*种类*，在API中被称为如下：
- en: '**Node:** A node represents a server, virtual or physical, in the cluster.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点：**节点代表集群中的服务器，虚拟或物理。'
- en: '**Pod:** A pod represents the smallest possible deployable component in Kubernetes,
    consisting of one or more co-located containers. Typically, a pod consists of
    one container, but there are use cases for extending the functionality of the
    main container by running the second container in a pod. In [Chapter 18](422649a4-94bc-48ae-b92b-e3894c014962.xhtml),
    *Using a Service Mesh to Improve Observability and Management*, a second container
    will be used in the pods, running a sidecar that makes the main container join
    the service mesh.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod**：Pod代表Kubernetes中最小的可部署组件，由一个或多个共同定位的容器组成。通常，一个Pod包含一个容器，但也有通过在Pod中运行第二个容器来扩展主容器功能的用例。在[第18章](422649a4-94bc-48ae-b92b-e3894c014962.xhtml)中，*使用服务网格改善可观察性和管理*，将在Pod中使用第二个容器，运行一个使主容器加入服务网格的边车。'
- en: '**Deployment**: Deployment is used to deploy and upgrade pods. The deployment
    objects hand over the responsibility of creating and monitoring the pods to a
    ReplicaSet. When creating a deployment for the first time, the work performed
    by the deployment object is no much more than creating the ReplicaSet object.
    When performing a rolling upgrade of deployment, the role of the deployment object
    is more involved.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deployment**：Deployment用于部署和升级Pods。部署对象将创建和监视Pods的责任交给了一个ReplicaSet。首次创建部署时，部署对象执行的工作不仅仅是创建ReplicaSet对象。在执行部署的滚动升级时，部署对象的角色更加复杂。'
- en: '**ReplicaSet**: A ReplicaSet is used to ensure that a specified number of pods
    are running at all times. If a pod is deleted, it will be replaced with a new
    pod by the ReplicaSet.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ReplicaSet**：ReplicaSet用于确保指定数量的Pod始终在运行。如果删除了一个Pod，ReplicaSet将用一个新的Pod来替换它。'
- en: '**Service**: A service is a stable network endpoint that you can use to connect
    to one or multiple pods. A service is assigned an IP address and a DNS name in
    the internal network of the Kubernetes cluster. The IP address of the service
    will stay the same for the lifetime of the service. Requests that are sent to
    a service will be forwarded to one of the available pods using round-robin-based
    load balancing. By default, a service is only exposed inside the cluster using
    a cluster IP address. It is also possible to expose a service outside the cluster,
    either on a dedicated port on each node in the cluster or – even better – through
    an external load balancer that is aware of Kubernetes, that is, it can automatically
    provision a public IP address and/or DNS name for the service. Cloud providers
    that offer Kubernetes as a service, in general, support this type of load balancer.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Service**：Service是一个稳定的网络端点，您可以用它来连接一个或多个Pod。Service在Kubernetes集群的内部网络中被分配一个IP地址和DNS名称。服务的IP地址将在服务的生命周期内保持不变。发送到服务的请求将使用基于轮询的负载平衡转发到可用的Pod之一。默认情况下，服务仅使用集群IP地址在集群内部公开。还可以将服务暴露到集群外部，可以在集群中的每个节点上使用专用端口，或者更好的是通过了解Kubernetes的外部负载均衡器来暴露服务，它可以自动为服务提供公共IP地址和/或DNS名称。通常支持这种类型负载均衡器的云提供商提供Kubernetes作为服务。'
- en: '**Ingress*:*** Ingress can manage external access to services in a Kubernetes
    cluster, typically using HTTP. For example, it can route traffic to the underlying
    services based on URL paths or HTTP headers such as the hostname. Instead of exposing
    a number of services externally, either using node ports or through load balancers,
    it is, in general, more convenient to set up an Ingress in front of the services.
    To handle the actual communication defined by the Ingress objects, an Ingress
    controller must be running in the cluster. We will see an example of an Ingress
    controller as we proceed.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ingress**：Ingress可以管理Kubernetes集群中服务的外部访问，通常使用HTTP。例如，它可以根据URL路径或HTTP标头（如主机名）将流量路由到底层服务。通常情况下，设置Ingress在服务前面比使用节点端口或负载均衡器外部暴露一些服务更方便。要处理Ingress对象定义的实际通信，必须在集群中运行Ingress控制器。随着我们的进行，我们将看到Ingress控制器的一个示例。'
- en: '**Namespace**: A namespace is used to group and, on some levels, isolate resources
    in a Kubernetes cluster. The names of resources must be unique in their namespaces,
    but not between namespaces.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间**：命名空间用于在Kubernetes集群中对资源进行分组，并在某些级别上进行隔离。资源的名称在其命名空间中必须是唯一的，但在不同的命名空间之间可以重复。'
- en: '**ConfigMap**: ConfigMap is used to store configuration that''s used by containers.
    ConfigMaps can be mapped into a running container as environment variables or
    files.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConfigMap**：ConfigMap用于存储容器使用的配置。ConfigMaps可以映射到运行中的容器作为环境变量或文件。'
- en: '**Secret: **This is used to store sensitive data used by containers, such as
    credentials. Secrets can be made available to containers in the same way as ConfigMaps.
    Anyone with full access to the API server can access the values of created secrets,
    so they are not as safe as the name might imply.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Secret**：用于存储容器使用的敏感数据，如凭据。Secrets可以像ConfigMaps一样提供给容器使用。任何具有对API服务器的完全访问权限的人都可以访问创建的secrets的值，因此它们并不像名称所暗示的那样安全。'
- en: '**DaemonSet**: This ensures that one pod is running on each node in a set of
    nodes in the cluster. In [Chapter 19](7a733f89-e54e-48d2-9a03-d7d2f72157ac.xhtml),
    *Centralized Logging with the EFK Stack*, we will see an example of a log collector,
    Fluentd, that will run on each worker node.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DaemonSet**：这确保在集群中一组节点上的每个节点上都运行一个Pod。在[第19章](7a733f89-e54e-48d2-9a03-d7d2f72157ac.xhtml)中，*使用EFK堆栈进行集中式日志记录*，我们将看到一个日志收集器Fluentd的示例，它将在每个工作节点上运行。'
- en: For a full list of resource objects that the Kubernetes API covers in v1.15,
    see [https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Kubernetes API在v1.15中涵盖的资源对象的完整列表，请参阅[https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/)。
- en: 'The following diagram summarizes the Kubernetes resources that are involved
    in handling incoming requests:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了处理传入请求所涉及的Kubernetes资源。
- en: '![](img/cdf2a486-253b-4f11-abc7-2ee25e3694e6.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cdf2a486-253b-4f11-abc7-2ee25e3694e6.png)'
- en: 'In the preceding diagram, we can see the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到以下内容：
- en: Two deployments, **Deployment A** and **Deployment B**, have been deployed to
    a cluster with two nodes, **Node 1** and **Node ****2**.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个部署**部署A**和**部署B**已经部署到了一个有两个节点**节点1**和**节点2**的集群中。
- en: '**Deployment A** contains two pods, **Pod A1** and **Pod** **A2**.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署A**包含两个pod，**Pod A1**和**Pod A2**。'
- en: '**Deployment B** contains one **Pod** **B1**.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署B**包含一个**Pod B1**。'
- en: '**Pod A1** is scheduled to **Node 1**.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod A1**被调度到**节点1**。'
- en: '**Pod A2** and **Pod B1** are scheduled to **Node 2**.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod A2**和**Pod B1**被调度到**节点2**。'
- en: Each deployment has a corresponding service deployed, **Service A** and **Service B**,
    and they are available on all nodes.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个部署都有一个相应的服务部署，**服务A**和**服务B**，它们在所有节点上都可用。
- en: An Ingress is defined to route incoming requests to the two services.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了一个Ingress来将传入的请求路由到两个服务。
- en: A client typically sends requests to the cluster via an external load balancer.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端通常通过外部负载均衡器向集群发送请求。
- en: These objects are not, by themselves, running components; instead, they are
    definitions of different types of desired states. To reflect the desired state
    in the cluster's current state, Kubernetes comes with an architecture consisting
    of a number of runtime components, as described in the next section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象本身并不是运行组件；相反，它们是不同类型期望状态的定义。为了反映集群当前状态中的期望状态，Kubernetes具有由多个运行时组件组成的架构，如下一节所述。
- en: Introducing Kubernetes runtime components
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Kubernetes运行时组件
- en: 'A Kubernetes cluster contains two types of nodes: master nodes and worker nodes.
    Master nodes manage the cluster, while the main purpose of worker nodes is to
    run the actual workload, for example, the containers we deploy in the cluster.
    Kubernetes is built up by a number of runtime components. The most important components
    are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes集群包含两种类型的节点：主节点和工作节点。主节点管理集群，而工作节点的主要目的是运行实际的工作负载，例如我们在集群中部署的容器。Kubernetes由多个运行时组件构建。最重要的组件如下：
- en: 'There are components that run on master nodes, constituting the control plane:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主节点上运行的组件构成了控制平面：
- en: '`api-server`, the entry point to the control plane. This exposes a RESTful
    API, which, for example, the Kubernetes CLI tool known as `kubectl` uses.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`api-server`，控制平面的入口点。这暴露了一个RESTful API，例如Kubernetes CLI工具`kubectl`使用。'
- en: '`etcd`, a highly available and distributed key/value store, used as a database
    for all cluster data.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd`，一个高可用和分布式的键值存储，用作所有集群数据的数据库。'
- en: A controller manager, which contains a number of controllers that continuously evaluate
    the desired state versus the current state for the objects defined in the `etcd`
    database.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个控制器管理器，其中包含一些控制器，不断地评估`etcd`数据库中定义的对象的期望状态与当前状态。
- en: Whenever the desired or the current state changes, a controller that's responsible
    for that type of state takes actions to move the current state to the desired
    state. For example, a replication controller that's responsible for managing pods
    will react if a new pod is added through the API server or a running pod dies
    and ensures that new pods are started. Another example of a controller is the
    node controller. It is responsible for acting if a node becomes unavailable, ensuring
    that pods running on a failing node are rescheduled on other nodes in the cluster.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当期望状态或当前状态发生变化时，负责该类型状态的控制器会采取行动，将当前状态移动到期望状态。例如，负责管理pod的复制控制器会在通过API服务器添加新的pod或运行的pod死亡时做出反应，并确保启动新的pod。另一个控制器的例子是节点控制器。它负责在节点不可用时采取行动，确保在集群中的其他节点上重新调度运行在失败节点上的pod。
- en: A **Scheduler**, which is responsible for assigning newly created pods to a
    node with available capacity, for example, in terms of memory and CPU. Affinity
    rules can be used to control how pods are assigned to nodes. For example, pods
    that perform a lot of disks I/O can be assigned to a group of worker nodes that
    have fast SSD disks. Anti-affinity rules can be defined to separate pods, for
    example, to avoid scheduling pods from the same deployment to the same worker
    node.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**调度器**，负责将新创建的pod分配给具有可用容量的节点，例如在内存和CPU方面。可以使用亲和规则来控制如何将pod分配给节点。例如，执行大量磁盘I/O的pod可以分配给具有快速SSD磁盘的一组工作节点。可以定义反亲和规则来分隔pod，例如避免将来自同一部署的pod调度到同一工作节点。
- en: 'Components that run on all the nodes that constitute the data plane are as
    follows:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构成数据平面的所有节点上运行的组件如下：
- en: '`kubelet`, a node agent that executes as a process directly in the nodes operating
    system and not as a container. It is responsible for that the containers that
    are up and running in the pods being assigned to the node where `kubelet` runs.
    It acts as a conduit between the `api-server` and the container runtime on its
    node.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubelet`，一个作为进程直接在节点操作系统中执行而不是作为容器的节点代理。它负责确保在运行`kubelet`的节点上分配给节点的pod中正在运行的容器。它充当`api-server`和其节点上的容器运行时之间的通道。'
- en: '`kube-proxy`, a network proxy that enables the service concept in Kubernetes
    and is capable of forwarding requests to the appropriate pods, typically in a
    round-robin fashion if more than one pod is available for the specific service. `kube-proxy`
    is deployed as a DaemonSet.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kube-proxy`，一个网络代理，使得Kubernetes中的服务概念成为可能，并且能够以轮询的方式将请求转发到适当的pod，如果特定服务有多个pod可用的话。`kube-proxy`被部署为一个DaemonSet。'
- en: '**Con****tainer** **runtime**, which is the software that runs containers on
    the node. Typically, this is Docker, but any implementation of the Kubernetes **Container
    Runtime Interface** (**CRI**) can be used, for example, `cri-o` ([https://cri-o.io](https://cri-o.io)), `containerd` ([https://containerd.io/](https://containerd.io/)),
    or `rktlet` ([https://github.com/kubernetes-incubator/rktlet](https://github.com/kubernetes-incubator/rktlet)).'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器运行时**，这是在节点上运行容器的软件。通常情况下，这是Docker，但可以使用任何实现了Kubernetes容器运行时接口（CRI）的实现，例如`cri-o`（[https://cri-o.io](https://cri-o.io)）、`containerd`（[https://containerd.io/](https://containerd.io)）或`rktlet`（[https://github.com/kubernetes-incubator/rktlet](https://github.com/kubernetes-incubator/rktlet)）。'
- en: '**Kubernetes DNS**, which is a DNS server that''s used in the cluster''s internal
    network. Services and pods are assigned a DNS name, and pods are configured to
    use this DNS server to resolve the internal DNS names. The DNS server is deployed
    as a deployment object and a service object.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes DNS**是集群内部网络中使用的DNS服务器。服务和pod被分配一个DNS名称，并配置pod使用此DNS服务器来解析内部DNS名称。DNS服务器部署为部署对象和服务对象。'
- en: 'The following diagram summarizes the Kubernetes runtime components:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了Kubernetes运行时组件：
- en: '![](img/6d8bfda7-c2b2-4b85-b4d7-5f30250bc9b9.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d8bfda7-c2b2-4b85-b4d7-5f30250bc9b9.png)'
- en: Now that we understand the Kubernetes runtime components and what they support
    and run on, let's move on to creating a Kubernetes cluster with Minikube.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了Kubernetes运行时组件及其支持和运行的内容，让我们继续使用Minikube创建一个Kubernetes集群。
- en: Creating a Kubernetes cluster using Minikube
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Minikube创建Kubernetes集群
- en: Now, we are ready to create a Kubernetes cluster! We will use Minikube to create
    a local single-node cluster running on VirtualBox.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备创建一个Kubernetes集群！我们将使用Minikube在VirtualBox上创建一个本地单节点集群。
- en: Before creating the Kubernetes cluster, we need to learn a bit about Minikube
    profiles, the Kubernetes CLI tool known as `kubectl`, and its use of contexts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Kubernetes集群之前，我们需要了解一些关于Minikube配置文件、名为`kubectl`的Kubernetes CLI工具以及其上下文使用的知识。
- en: Working with Minikube profiles
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Minikube配置文件
- en: 'In order to run multiple Kubernetes clusters locally, Minikube comes with the
    concept of profiles. For example, if you want to work with multiple versions of
    Kubernetes, you can create multiple Kubernetes clusters using Minikube. Each cluster
    will be assigned a separate Minikube profile. Most of the Minikube commands accept
    a `--profile` flag (or `-p` for short) that can be used to specify which of the Kubernetes
    clusters the command shall be applied to. If you plan to work with one specific
    profile for a while, a more convenient alternative exists, where you specify the
    current profile with the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本地运行多个Kubernetes集群，Minikube提供了配置文件的概念。例如，如果您想使用多个版本的Kubernetes，可以使用Minikube创建多个Kubernetes集群。每个集群将被分配一个单独的Minikube配置文件。大多数Minikube命令接受`--profile`标志（或简写为`-p`），可用于指定命令应用于哪个Kubernetes集群。如果您计划在一段时间内使用一个特定的配置文件，还有一个更方便的选择，可以使用以下命令指定当前配置文件：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding command will set the `my-profile` profile as the current profile.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将将`my-profile`配置文件设置为当前配置文件。
- en: 'To get the current profile, run the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取当前配置文件，请运行以下命令：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If no profile is specified, neither using the `minikube profile` command nor
    the `--profile` switch, a default profile named `minikube` will be used.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定配置文件，无论是使用`minikube profile`命令还是`--profile`开关，都将使用名为`minikube`的默认配置文件。
- en: Information regarding existing profiles can be found in the `~/.minikube/profiles` folder.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有关现有配置文件的信息可以在`~/.minikube/profiles`文件夹中找到。
- en: Working with Kubernetes CLI, kubectl
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes CLI，kubectl
- en: '`kubectl` is the Kubernetes CLI tool. Once a cluster has been set up, this
    is usually the only tool you need to manage the cluster!'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`是Kubernetes CLI工具。一旦集群设置好，这通常是您管理集群所需的唯一工具！'
- en: For managing the API objects we described earlier in this chapter, the `kubectl
    apply` command is the only command you need to know about. It is a declarative
    command; that is, as an operator, we ask Kubernetes to apply the object definition
    we give to the command. It is then up to Kubernetes to figure out what actually
    needs to be done.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们在本章中描述的API对象的管理，`kubectl apply`命令是您需要了解的唯一命令。这是一个声明性命令；也就是说，作为操作员，我们要求Kubernetes应用我们给出的对象定义。然后由Kubernetes来确定实际需要做什么。
- en: Another example of a declarative command that's hopefully familiar to many readers
    of this book is a `SQL SELECT` statement that joins information from several database
    tables. We only declare the expected result in the SQL query, and it is up to
    the database query optimizer to figure out in what order the tables shall be accessed
    and what indexes to use to retrieve the data in the most efficient way.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的许多读者可能熟悉的另一个声明性命令的例子是`SQL SELECT`语句，它从多个数据库表中获取信息。我们只在SQL查询中声明期望的结果，由数据库查询优化器来确定表的访问顺序和检索数据的最有效方式。
- en: In some cases, imperative statements that explicitly tell Kubernetes what to
    do are preferred. One example is the `kubectl delete` command, where we explicitly
    tell Kubernetes to delete some API objects. Creating a namespace object can also
    be conveniently done with an explicit `kubectl create namespace` command.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，更喜欢使用明确告诉Kubernetes要做什么的命令。一个例子是`kubectl delete`命令，我们明确告诉Kubernetes删除一些API对象。创建命名空间对象也可以方便地使用明确的`kubectl
    create namespace`命令完成。
- en: Repetitive usage of the imperative statements will make them fail, for example,
    deleting the same API object twice using `kubectl delete` or creating the same
    namespace twice using `kubectl create`. A declarative command, that is, using
    `kubectl apply`, will not fail on repetitive usage—it will simply state that there
    is no change and exit without taking any action.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 重复使用命令式语句将使它们失败，例如使用`kubectl delete`两次删除相同的API对象，或者使用`kubectl create`两次创建相同的命名空间。声明性命令，即使用`kubectl
    apply`，在重复使用时不会失败——它只会简单地声明没有变化并退出而不采取任何行动。
- en: 'Some commonly used commands for retrieving information about a Kubernetes cluster
    are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常用的用于检索有关Kubernetes集群信息的命令如下：
- en: '`kubectl get` shows information about the specified API object.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl get`显示有关指定API对象的信息。'
- en: '`kubectl describe` gives more detail about the specified API object.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl describe`提供有关指定API对象的更多详细信息。'
- en: '`kubectl logs` display log output from containers.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`kubectl logs`显示容器的日志输出。
- en: We will see a lot of examples of these and other `kubectl` commands in this
    and the upcoming chapters!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和接下来的章节中，我们将看到许多这些和其他`kubectl`命令的示例！
- en: If in doubt about how to use the `kubectl` tool, the `kubectl help` and `kubectl
    <command> --help` commands are always available and provide very useful information
    on how to use the `kubectl` tool.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对如何使用`kubectl`工具感到困惑，`kubectl help`和`kubectl <command> --help`命令始终可用，并提供有关如何使用`kubectl`工具的非常有用的信息。
- en: Working with kubectl contexts
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用kubectl上下文
- en: 'To be able to work with more than one Kubernetes cluster, using either Minikube
    locally or Kubernetes clusters set up on-premises servers or in the cloud, `kubectl`
    comes with the concept of contexts. A context is a combination of the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够使用多个Kubernetes集群，无论是在本地使用Minikube还是在云中或本地服务器上设置的Kubernetes集群，`kubectl`都提供了上下文的概念。上下文是以下内容的组合：
- en: A Kubernetes cluster
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes集群
- en: Authentication information for a user
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的身份验证信息
- en: A default namespace
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认命名空间
- en: By default, contexts are saved in the `~/.kube/config` file, but the file can
    be changed using the `KUBECONFIG` environment variable. In this book, we will
    use the default location, so we will unset `KUBECONFIG` using the `unset KUBECONFIG` command.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，上下文保存在`~/.kube/config`文件中，但可以使用`KUBECONFIG`环境变量进行更改。在本书中，我们将使用默认位置，因此我们将使用`unset
    KUBECONFIG`命令取消`KUBECONFIG`的设置。
- en: When a Kubernetes cluster is created in Minikube, a context is created with
    the same name as the Minikube profile and is then set as the current context.
    So, `kubectl` commands that are issued after the cluster is created in Minikube
    will be sent to that cluster.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Minikube中创建Kubernetes集群时，将创建一个与Minikube配置文件相同名称的上下文，然后将其设置为当前上下文。因此，在Minikube中创建集群后发出的`kubectl`命令将被发送到该集群。
- en: 'To list the available contexts, run the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出可用的上下文，请运行以下命令：
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is a sample response:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例响应：
- en: '![](img/9f432d73-d57a-4227-bdf6-880fe1b7a39a.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f432d73-d57a-4227-bdf6-880fe1b7a39a.png)'
- en: The wildcard, `*`, in the first column, mark the current context.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列中的通配符`*`标记当前上下文。
- en: You will only see the `handson-spring-boot-cloud` context in the preceding response
    once the cluster has been created, which we will describe here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦集群创建完成，您将只在上述响应中看到`handson-spring-boot-cloud`上下文，我们将在此处进行描述。
- en: 'If you want to switch the current context to another context, that is, work
    with another Kubernetes cluster, run the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将当前上下文切换到另一个上下文，即使用另一个Kubernetes集群，请运行以下命令：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, the current context will be changed to `my-cluster`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，当前上下文将更改为`my-cluster`。
- en: To update a context, for example, switching the default namespace used by `kubectl`,
    use the `kubectl config set-context` command.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新上下文，例如切换`kubectl`使用的默认命名空间，请使用`kubectl config set-context`命令。
- en: 'For example, to change the default namespace of the current context to `my-namespace`,
    use the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将当前上下文的默认命名空间更改为`my-namespace`，请使用以下命令：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding command, `kubectl config current-context` is used to get the
    name of the current context.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，使用`kubectl config current-context`来获取当前上下文的名称。
- en: Creating a Kubernetes cluster
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Kubernetes集群
- en: 'To create a Kubernetes cluster using Minikube, we need to run a few commands:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Minikube创建Kubernetes集群，我们需要运行一些命令：
- en: Unset the `KUBECONFIG` environment variable to ensure that the `kubectl` context
    is created in the default config file, `~/.kube/config`.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消`KUBECONFIG`环境变量的设置，以确保`kubectl`上下文被创建在默认配置文件`~/.kube/config`中。
- en: Specify the Minikube profile to be used for the cluster. We will use `handson-spring-boot-cloud` as
    the profile name.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定要用于集群的Minikube配置文件。我们将使用`handson-spring-boot-cloud`作为配置文件名称。
- en: Create the cluster using the `minikube start` command, where we can also specify
    how much hardware resources we want to allocate to the cluster. To be able to
    complete the examples in the remaining chapters of this book, allocate at least
    10 GB of memory, that is, 10,240 MB, to the cluster.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`minikube start`命令创建集群，我们还可以指定要分配给集群的硬件资源量。为了能够完成本书剩余章节中的示例，请至少为集群分配10GB内存，即10240MB。
- en: After the cluster has been created, we will use the add-on manager in Minikube
    to enable an Ingress controller and a metrics server that comes out of the box
    with Minikube. The Ingress controller and the metrics will be used in the next
    two chapters.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建集群后，我们将使用Minikube中的附加管理器来启用出厂自带的Ingress控制器和度量服务器。接下来的两章将使用Ingress控制器和度量服务器。
- en: Before you create a Kubernetes cluster using Minikube, it might be a good idea
    to shut down Docker for macOS to avoid running out of memory.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Minikube创建Kubernetes集群之前，最好关闭Docker for macOS，以避免内存耗尽。
- en: 'Run the following commands to create the Kubernetes cluster:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令创建Kubernetes集群：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After the preceding commands complete, you should be able to communicate with
    the cluster. Try the `kubectl get nodes` command. It should respond with something
    that looks similar to the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令完成后，您应该能够与集群通信。尝试`kubectl get nodes`命令。它应该会响应类似于以下内容的内容：
- en: '![](img/da7ecf41-9129-4e4a-8eb1-c37936e83aa6.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da7ecf41-9129-4e4a-8eb1-c37936e83aa6.png)'
- en: 'Once created, the cluster will initialize itself in the background, starting
    up a number of system pods in the `kube-system` namespace. We can monitor its
    progress by issuing the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，集群将在后台初始化自身，在`kube-system`命名空间中启动一些系统pod。我们可以通过发出以下命令来监视其进度：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once the startup is complete, the preceding command should report the status
    for all pods as `Running` and the READY count should be `1/1`, meaning that a
    single container in each pod is up and running:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 启动完成后，上述命令应报告所有pod的状态为`Running`，READY计数应为`1/1`，这意味着每个pod中有一个容器正在运行：
- en: '![](img/91deb3a4-1969-4c58-a0bf-6c7bab49fd86.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/91deb3a4-1969-4c58-a0bf-6c7bab49fd86.png)'
- en: We are now ready for some action!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好开始行动了！
- en: Trying out a sample deployment
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试一个示例部署
- en: 'Let''s see how we can do the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做以下事情：
- en: Deploy a simple web server based on NGINX in our Kubernetes cluster.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的Kubernetes集群中部署基于NGINX的简单Web服务器。
- en: 'Apply some changes to the deployment:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对部署进行一些更改：
- en: Delete a pod and verify that the ReplicaSet creates a new one.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个pod并验证ReplicaSet创建一个新的。
- en: Scale the web server to three pods to verify that the ReplicaSet fills the gap.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将web服务器扩展到三个pod以验证ReplicaSet填补了空缺。
- en: Route external traffic to it using a service with a node port.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个带有节点端口的服务来将外部流量路由到它。
- en: 'First, create a namespace, `first-attempts`, and update the `kubectl` context
    to use this namespace by default:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个命名空间`first-attempts`，并更新`kubectl`上下文以默认使用这个命名空间：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can now create a deployment of NGINX in the namespace using the `kubernetes/first-attempts/nginx-deployment.yaml` file.
    This file looks as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`kubernetes/first-attempts/nginx-deployment.yaml`文件在命名空间中创建一个NGINX的部署。该文件如下所示：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: The `kind` and `apiVersion` attributes are used to specify that we are declaring
    a deployment object.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`和`apiVersion`属性用于指定我们正在声明一个部署对象。'
- en: The `metadata` section is used to describe the deployment object, for example,
    when we give it a name of `nginx-deploy`.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`部分用于描述部署对象，例如，当我们给它一个名字`nginx-deploy`时。'
- en: 'Next comes a `spec` section that defines our desired state of the deployment
    object:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是一个`spec`部分，它定义了我们对部署对象的期望状态：
- en: '`replicas: 1` specifies we want to have one pod up and running.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replicas: 1`指定我们要有一个正在运行的pod。'
- en: A `selector` section that specifies how the deployment will find the pods it
    manages. In this case, the deployment will look for pods that have the `app` label
    set to `nginx-app`.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`selector`部分，指定了部署将如何找到它管理的pod。在这种情况下，部署将寻找具有设置为`nginx-app`的`app`标签的pod。
- en: 'The `template` section is used to specify how pods shall be created:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`部分用于指定如何创建pod：'
- en: 'The `metadata` section specifies the `label`, `app: nginx-app`, which is used
    to identify the pods, thereby matching the selector.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`部分指定了`label`，`app: nginx-app`，用于识别pod，从而匹配选择器。'
- en: The `spec` section specifies details for the creation of the single container
    in the pod, that is, `name` and `image` and what `ports` it uses.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`部分指定了在pod中创建单个容器的详细信息，即`name`和`image`以及它使用的`ports`。'
- en: 'Create the deployment with the following commands:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建部署：
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s see what we got with the `kubectl get all` command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用`kubectl get all`命令得到了什么：
- en: '![](img/b598f9f8-8904-434f-8927-9e2ff0860e89.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b598f9f8-8904-434f-8927-9e2ff0860e89.png)'
- en: As expected, we got a deployment, ReplicaSet, and pod object. After a short
    while, which mainly depends on the time it takes to download the NGINX Docker
    image, the pod will be up and running, and the desired state will be equal to
    the current state!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们得到了一个部署、ReplicaSet和pod对象。在短时间内，主要取决于下载NGINX Docker镜像所需的时间，pod将启动并运行，期望状态将等于当前状态！
- en: 'Change the current state by deleting the pod with the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令删除pod来改变当前状态：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the pod has a random name (`nginx-deploy-59b8c5f7cd-mt6pg` in the preceding
    example), the pod is selected based on the `app` label, which is set to `nginx-app` in
    the pod.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于pod有一个随机的名字（在前面的示例中为`nginx-deploy-59b8c5f7cd-mt6pg`），所以pod是基于`app`标签进行选择的，该标签在pod中设置为`nginx-app`。
- en: Running a subsequent `kubectl get all` command will reveal that the difference
    between the desired and current state was detected and handled by the ReplicaSet
    in just a few seconds, that is, a new pod was launched almost immediately.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 运行后续的`kubectl get all`命令将会显示，ReplicaSet在几秒钟内检测到期望状态和当前状态之间的差异，并立即处理，也就是说，几乎立即启动了一个新的pod。
- en: Change the desired state by setting the number of desired pods to three replicas
    in the `kubernetes/first-attempts/nginx-deployment.yaml` deployment file. Apply
    the change in the desired state by simply repeating the `kubectl apply` command,
    as we mentioned previously.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`kubernetes/first-attempts/nginx-deployment.yaml`部署文件中将期望的pod数量设置为三个副本来改变期望状态。通过简单重复`kubectl
    apply`命令来应用期望状态的改变，正如我们之前提到的。
- en: 'Quickly run the `kubectl get all` command a couple of times to monitor how
    Kubernetes takes action to ensure that the current state meets the new desired
    state. After a few seconds, two new NGINX pods will be up and running. The desired
    state is, again, equal to the current state with three running NGINX pods. Expect
    a response that looks similar to the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 快速运行`kubectl get all`命令几次，以监视Kubernetes采取行动以确保当前状态满足新的期望状态。几秒钟后，两个新的NGINX pod将启动并运行。期望状态再次等于当前状态，有三个运行中的NGINX
    pod。期望得到类似以下的响应：
- en: '![](img/45d803cd-745b-4d3f-9d25-79df6eadfeb1.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/45d803cd-745b-4d3f-9d25-79df6eadfeb1.png)'
- en: 'To enable external communication with the web servers, create a service using
    the `kubernetes/first-attempts/nginx-service.yaml` file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使web服务器能够与外部通信，使用`kubernetes/first-attempts/nginx-service.yaml`文件创建一个服务：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s explain the preceding source code in more detail:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地解释前面的源代码：
- en: The `kind` and `apiVersion` attributes are used to specify that we are declaring
    a `Service` object.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`和`apiVersion`属性用于指定我们正在声明一个`Service`对象。'
- en: The `metadata` section is used to describe the `Service` object, for example,
    to give it a name: `nginx-service`.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`部分用于描述`Service`对象，例如，给它一个名字：`nginx-service`。'
- en: 'Next comes a `spec` section, which defines the desired state of the `Service` object:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是一个`spec`部分，它定义了`Service`对象的期望状态：
- en: With the `type` field, we specify that we want `NodePort`, that is, something
    that's accessible externally on a dedicated port on each node in the cluster. This
    means that an external caller can reach the pods using this port on any of the
    nodes in the cluster, independent of which nodes the pods actually run on.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`type`字段，我们指定我们想要`NodePort`，也就是在集群中每个节点上的专用端口上可以从外部访问的东西。这意味着外部调用者可以使用集群中任何节点上的这个端口来访问pod，而不管pod实际运行在哪些节点上。
- en: 'The selector is used by the service to find available pods, which, in our case,
    is pods labeled with `app: nginx-app`.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '选择器被服务用来找到可用的pod，也就是我们的情况下，带有`app: nginx-app`标签的pod。'
- en: 'Finally, `ports` are declared as follows:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`ports`声明如下：
- en: '`port: 80` specifies on which port the services will be accessible on, that
    is, internally in the cluster.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port: 80`指定了服务在集群内部可访问的端口。'
- en: '`nodePort: 30080` specifies on what port the service will be externally accessible
    on using any of the nodes in the cluster. By default, a node port must be in the
    range of `30000` to `32767`.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nodePort: 30080`指定了服务在集群中的任何节点上外部可访问的端口。默认情况下，节点端口必须在`30000`到`32767`的范围内。'
- en: '`targetPort: 80` specifies the port in the pod where the requests shall be
    forwarded to.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetPort: 80`指定了请求应转发到的pod中的端口。'
- en: This port range is used to minimize the risk of colliding with other ports in
    use. In a production system, a load balancer is typically placed in front of the
    Kubernetes cluster, shielding the external users both from the knowledge of these
    ports and the IP numbers of the nodes in the Kubernetes cluster. See [Chapter
    18](422649a4-94bc-48ae-b92b-e3894c014962.xhtml), *Using a Service Mesh to Improve
    Observability and Management*, the *Setting up port forwarding required by Istio*
    section, for more on the usage of a `LoadBalanced` Kubernetes service.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此端口范围用于最小化与正在使用的其他端口发生冲突的风险。在生产系统中，通常会在Kubernetes集群前面放置一个负载均衡器，使外部用户既不知道这些端口的知识，也不知道Kubernetes集群中节点的IP号。有关使用`LoadBalanced`
    Kubernetes服务的更多信息，请参见[第18章](422649a4-94bc-48ae-b92b-e3894c014962.xhtml)，*使用服务网格改进可观察性和管理*，*设置Istio所需的端口转发*部分。
- en: 'Create the service with the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建服务：
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To see what we got, run the `kubectl get svc` command. Expect a response such
    as the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们得到了什么，运行`kubectl get svc`命令。预计会得到以下响应：
- en: '![](img/987abb3e-e317-4cb1-8169-63a163c2ac1c.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/987abb3e-e317-4cb1-8169-63a163c2ac1c.png)'
- en: '`kubectl` supports short names for many of the API objects as an alternative
    to their full name. For example, `svc` was used in the preceding command instead
    of the full name, `service`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl`支持许多API对象的短名称，作为它们的全名的替代。例如，上述命令中使用了`svc`，而不是全名`service`。'
- en: 'To try this out, we need to know the IP address of the single node in our cluster.
    We can get that by issuing the `minikube ip` command. In my case, it is `192.168.99.116`.
    With this IP address and the node port `30080`, we can direct our web browser
    to the deployed web server. In my case, the address is `http://192.168.99.116:30080`.
    Expect a response such as the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个，我们需要知道集群中单个节点的IP地址。我们可以通过发出`minikube ip`命令来获取。在我的情况下，它是`192.168.99.116`。有了这个IP地址和节点端口`30080`，我们可以将我们的Web浏览器指向部署的Web服务器。在我的情况下，地址是`http://192.168.99.116:30080`。预计会得到以下响应：
- en: '![](img/2f710472-8b21-4b04-ba91-1496388ec643.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f710472-8b21-4b04-ba91-1496388ec643.png)'
- en: Great! But what about the internal cluster IP address and port?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！但内部集群IP地址和端口呢？
- en: One way to verify this is to launch a small pod inside the cluster that we can
    use to run `curl` from the inside, that is, we are able to use the internal cluster
    IP address and port. We don't need to use the IP address; instead, we can use
    a DNS name that is created for the service in the internal DNS server. The short
    name of the DNS name is the same as the name of the service, that is, `nginx-service`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 验证的一种方法是在集群内启动一个小的pod，我们可以使用它来从内部运行`curl`，也就是说，我们能够使用内部集群IP地址和端口。我们不需要使用IP地址；相反，我们可以使用为内部DNS服务器中的服务创建的DNS名称。DNS名称的短名称与服务的名称相同，即`nginx-service`。
- en: 'Run the following command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding command looks a bit complex, but it will only do the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令看起来有点复杂，但它只会执行以下操作：
- en: Create a pod with a small container based on the `tutum/curl:alpine` Docker
    image, which contains the `curl` command.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用基于`tutum/curl:alpine` Docker镜像的小容器创建一个pod，其中包含`curl`命令。
- en: Run the `curl -s 'http://nginx-service:80'` command inside the container and
    redirect the output to the Terminal using the `-i` option.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内运行`curl -s 'http://nginx-service:80'`命令，并使用`-i`选项将输出重定向到终端。
- en: Delete the pod using the `--rm` option.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--rm`选项删除pod。
- en: 'Expect the output from the preceding command to contain the following information
    (we are only showing parts of the response here):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 预计上述命令的输出包含以下信息（这里只显示部分响应）：
- en: '![](img/da13fcf8-bed7-49e3-ac2a-5013a5d3621f.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da13fcf8-bed7-49e3-ac2a-5013a5d3621f.png)'
- en: This means that the web server is also accessible internally in the cluster!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Web服务器在集群内部也是可访问的！
- en: This is basically all we need to know to be able to deploy our system landscape.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是我们需要知道的一切，以便能够部署我们的系统架构。
- en: 'Wrap this up by removing the namespace containing the `nginx` deployment:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除包含`nginx`部署的命名空间来结束这一切：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Before we end this introductory chapter on Kubernetes, we need to learn how
    to manage our Kubernetes cluster.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这一关于Kubernetes的介绍性章节之前，我们需要学习如何管理我们的Kubernetes集群。
- en: Managing a Kubernetes cluster
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理Kubernetes集群
- en: A running Kubernetes cluster consumes a lot of resources, mostly memory. So,
    when we are done working with a Kubernetes cluster in Minikube, we must be able
    to hibernate it in order to release the resources allocated to it. We also need
    to know how to resume the cluster when we want to continue working with it. Eventually,
    we must also be able to permanently remove the cluster when we don't want to keep
    it on disk anymore.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的Kubernetes集群消耗大量资源，主要是内存。因此，当我们在Minikube中完成对Kubernetes集群的工作时，我们必须能够将其休眠以释放分配给它的资源。我们还需要知道如何在想要继续使用它时恢复集群。最终，当我们不想再将其保留在磁盘上时，我们还必须能够永久删除集群。
- en: Minikube comes with a `stop` command that can be used to hibernate a Kubernetes
    cluster. The `start` command we used to initially create the Kubernetes cluster
    can also be used to resume the cluster from its hibernated state. To permanently
    remove a cluster, we can use the `delete` command from Minikube.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube带有一个`stop`命令，可用于将Kubernetes集群休眠。我们最初用于创建Kubernetes集群的`start`命令也可以用于从休眠状态恢复集群。要永久删除集群，可以使用Minikube的`delete`命令。
- en: Hibernating and resuming a Kubernetes cluster
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 休眠和恢复Kubernetes集群
- en: 'Run the following command to hibernate (that is, `stop`) the Kubernetes cluster:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来休眠（即`停止`）Kubernetes集群：
- en: '[PRE19]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the following command to resume (that is, `start`) the Kubernetes cluster
    again:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以再次恢复（即`启动`）Kubernetes集群：
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When resuming an already existing cluster, the `start` command ignores switches
    that were used when you were creating the cluster.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复已存在的集群时，`start`命令会忽略在创建集群时使用的开关。
- en: 'After resuming the Kubernetes cluster, the `kubectl` context will be updated
    to use this cluster with the currently used namespace set to `default`. If you
    are working with another namespace, for example, the `hands-on` namespace that
    we will use in the upcoming chapter, that is, [Chapter 16](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml), *Deploying
    Our Microservices to Kubernetes*, you can update the `kubectl` context with the
    following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复Kubernetes集群后，`kubectl`上下文将更新为使用当前使用的命名空间设置为`default`的集群。如果您正在使用另一个命名空间，例如我们将在即将到来的第16章中使用的`hands-on`命名空间，即[第16章](ebeb41b4-eea4-4d73-89ba-6788e2e68bac.xhtml)，*将我们的微服务部署到Kubernetes*，您可以使用以下命令更新`kubectl`上下文：
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Subsequent `kubectl` commands will be applied to the `hands-on` namespace when
    applicable.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的`kubectl`命令将在适用时应用于`hands-on`命名空间。
- en: Terminating a Kubernetes cluster
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止Kubernetes集群
- en: 'Run the following command to terminate a Kubernetes cluster:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以终止Kubernetes集群：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can actually run the `delete` command without specifying the profile, but
    I find it safer to be explicit regarding the profile when it comes to the `delete`
    command. Otherwise, you may accidentally delete the wrong Kubernetes cluster!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以在不指定配置文件的情况下运行`delete`命令，但是我发现在涉及`delete`命令时，明确指定配置文件更安全。否则，您可能会意外删除错误的Kubernetes集群！
- en: 'Neither the Minikube profile definition under `~/.minikube/profiles/` nor the
    `kubectl` context in `~/.kube/config` is deleted by this command. If they are
    no longer required, they can be deleted with the following commands:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令不会删除`~/.minikube/profiles/`下的Minikube配置文件定义，也不会删除`~/.kube/config`中的`kubectl`上下文。如果它们不再需要，可以使用以下命令进行删除：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `kubectl config delete-context` command will warn you about deleting the
    active context, but that's okay.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl config delete-context`命令将警告您删除活动上下文，但这没关系。'
- en: We've successfully learned how to manage a Kubernetes cluster that runs in Minikube.
    We now know how to suspend and resume a cluster and, when no longer needed, we
    know how to permanently remove it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功学会了如何管理在Minikube中运行的Kubernetes集群。我们现在知道如何暂停和恢复集群，并且在不再需要时，我们知道如何永久删除它。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have been introduced to Kubernetes as a container orchestrator.
    Kubernetes makes a cluster of servers that run containers appear as one big logical
    server. As an operator, we declare a desired state to the cluster and Kubernetes
    continuously compares the desired state with the current state. If it detects
    differences, it takes actions to ensure that the current state is the same as
    the desired state.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了Kubernetes作为容器编排器。Kubernetes使运行容器的服务器集群看起来像一个大的逻辑服务器。作为操作员，我们向集群声明所需的状态，Kubernetes不断地将所需的状态与当前状态进行比较。如果它检测到差异，它会采取行动以确保当前状态与所需状态相同。
- en: The desired state is declared by creating resources using the Kubernetes API
    server. The controller manager in Kubernetes and its controllers react to the
    various resources that were created by the API server and takes actions to ensure
    that the current state meets the new desired state. The scheduler assigns nodes
    to newly created containers, that is, pods that contain one or more containers.
    On each node, an agent, `kubelet`, runs and ensures that the pods that were scheduled
    to its node are up and running. `kube-proxy` acts as a network proxy, enabling
    a service abstraction by forwarding requests that are sent to the service to available
    pods in the cluster. External requests can be handled either by a service that
    specifies a node port that's available on all of the nodes in the cluster or through
    a dedicated Ingress resource.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的状态是通过使用Kubernetes API服务器创建资源来声明的。Kubernetes中的控制器管理器及其控制器会对API服务器创建的各种资源做出反应，并采取行动以确保当前状态满足新的所需状态。调度程序将节点分配给新创建的容器，即包含一个或多个容器的pod。在每个节点上，代理`kubelet`运行并确保已计划到其节点的pod正在运行。`kube-proxy`充当网络代理，通过将发送到服务的请求转发到集群中可用的pod来实现服务抽象。外部请求可以通过指定在集群的所有节点上都可用的节点端口的服务或通过专用Ingress资源来处理。
- en: We have also tried out Kubernetes by creating a local single-node cluster using
    Minikube and VirtualBox. Using the Kubernetes CLI tool known as `kubectl`, we
    deployed a simple web server based on NGINX. We tried out resilience capabilities
    by deleting the web server, and we observed it being recreated automatically and
    scaled it by requesting three pods running on the web server. Finally, we created
    a service with a node port and verified that we could access it both externally
    and from the inside of the cluster.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还尝试了使用Minikube和VirtualBox创建本地单节点集群来尝试Kubernetes。使用称为`kubectl`的Kubernetes CLI工具，我们部署了一个基于NGINX的简单Web服务器。我们通过删除Web服务器来尝试其弹性能力，并观察到它被自动重新创建，并通过请求在Web服务器上运行的三个pod来进行扩展。最后，我们创建了一个带有节点端口的服务，并验证我们可以从集群的内部和外部访问它。
- en: Finally, we learned how to manage a Kubernetes cluster running in Minikube on
    VirtualBox in terms of how to hibernate, resume, and terminate a Kubernetes cluster.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学会了如何管理在VirtualBox上运行的Minikube中的Kubernetes集群，包括如何休眠、恢复和终止Kubernetes集群。
- en: We are now ready to deploy our system landscape from the earlier chapters in
    Kubernetes. Head over to the next chapter to find out how to do this!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备在Kubernetes中部署前几章中的系统架构。前往下一章以了解如何执行此操作！
- en: Questions
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What happens if you run the same `kubectl create` command twice?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行相同的`kubectl create`命令两次会发生什么？
- en: What happens if you run the same `kubectl apply` command twice?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您运行相同的`kubectl apply`命令两次会发生什么？
- en: In terms of questions *1* and *2*, why do they act differently the second time
    they are run?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就问题*1*和*2*而言，为什么它们第二次运行时表现不同？
- en: What is the purpose of a ReplicaSet, and what other resource creates a ReplicaSet?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ReplicaSet的目的是什么，还有哪些资源会创建ReplicaSet？
- en: What is the purpose of `etcd` in a Kubernetes cluster?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kubernetes集群中，`etcd`的目的是什么？
- en: How can a container find out the IP address of another container that runs in
    the same pod?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器如何找到运行在同一Pod中的另一个容器的IP地址？
- en: What happens if you create two deployments with the same name but in different
    namespaces?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在不同的命名空间中创建了两个具有相同名称的部署，会发生什么？
- en: What can you make the creation of two services with the same name fail if they
    are created in two different namespaces?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在两个不同的命名空间中创建了两个具有相同名称的服务，您如何使其创建失败？
