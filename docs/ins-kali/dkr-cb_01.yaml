- en: Chapter 1. Introduction and Installation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。介绍和安装
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Verifying the requirements for Docker installation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证Docker安装的要求
- en: Installing Docker
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Docker
- en: Pulling an image and running a container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取镜像并运行容器
- en: Adding a nonroot user to administer Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Docker添加非root用户进行管理
- en: Setting up the Docker host with Docker Machine
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Machine设置Docker主机
- en: Finding help with the Docker command line
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker命令行查找帮助
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: At the very start of the IT revolution, most applications were deployed directly
    on physical hardware, over the host OS. Because of that single user space, runtime
    was shared between applications. The deployment was stable, hardware-centric,
    and had a long maintenance cycle. It was mostly managed by an IT department and
    gave a lot less flexibility to developers. In such cases, hardware resources were
    regularly underutilized.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在IT革命的最初阶段，大多数应用程序是直接部署在物理硬件上，通过主机操作系统。由于单一用户空间，运行时在应用程序之间共享。部署是稳定的，以硬件为中心，并且具有长时间的维护周期。大多由IT部门管理，并且给开发人员提供了更少的灵活性。在这种情况下，硬件资源经常被低效利用。
- en: 'The following diagram depicts such a setup:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了这样的设置：
- en: '![Introduction](../Images/image00262.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction](../Images/image00262.jpeg)'
- en: Traditional application deployment ([https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf](https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf))
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 传统应用程序部署（[https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf](https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf)）
- en: 'To overcome the limitations set by traditional deployment, virtualization was
    invented. With hypervisors such as KVM, XEN, ESX, Hyper-V, and so on, we emulated
    the hardware for virtual machines (VMs) and deployed a guest OS on each virtual
    machine. VMs can have a different OS than their host; that means we are responsible
    for managing the patches, security, and performance of that VM. With virtualization,
    applications are isolated at VM level and defined by the life cycle of VMs. This
    gives better return on investment and higher flexibility at the cost of increased
    complexity and redundancy. The following diagram depicts a typical virtualized
    environment:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服传统部署设置的限制，虚拟化被发明了。使用诸如KVM、XEN、ESX、Hyper-V等的hypervisor，我们模拟了虚拟机（VM）的硬件，并在每个虚拟机上部署了一个客户操作系统。VM可以具有与其主机不同的操作系统；这意味着我们负责管理该VM的补丁、安全性和性能。通过虚拟化，应用程序在VM级别上被隔离，并由VM的生命周期定义。这在投资回报和灵活性方面提供了更好的回报，但增加了复杂性和冗余成本。以下图表描述了典型的虚拟化环境：
- en: '![Introduction](../Images/image00263.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction](../Images/image00263.jpeg)'
- en: Application deployment in a virtualized environment ([https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf](https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf))
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟化环境中的应用程序部署（[https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf](https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf)）
- en: After virtualization, we are now moving towards more application-centric IT.
    We have removed the hypervisor layer to reduce hardware emulation and complexity.
    The applications are packaged with their runtime environment and are deployed
    using containers. OpenVZ, Solaris Zones, and LXC are a few examples of container
    technology. Containers are less flexible compared to VMs; for example, we cannot
    run Microsoft Windows on a Linux OS. Containers are also considered less secure
    than VMs, because with containers, everything runs on the host OS. If a container
    gets compromised, then it might be possible to get full access to the host OS.
    It can be a bit too complex to set up, manage, and automate. These are a few reasons
    why we have not seen the mass adoption of containers in the last few years, even
    though we had the technology.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟化之后，我们现在正朝着更加应用中心化的IT发展。我们已经移除了虚拟机监视器层，以减少硬件仿真和复杂性。应用程序与其运行时环境一起打包，并使用容器进行部署。OpenVZ，Solaris
    Zones和LXC是容器技术的一些例子。与虚拟机相比，容器的灵活性较低；例如，我们无法在Linux操作系统上运行Microsoft Windows。与虚拟机相比，容器也被认为不太安全，因为在容器中，一切都在主机操作系统上运行。如果容器受到损害，那么可能会完全访问主机操作系统。设置、管理和自动化可能会变得有点复杂。这些是我们在过去几年中没有看到容器大规模采用的一些原因，尽管我们已经有了这项技术。
- en: '![Introduction](../Images/image00264.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction](../Images/image00264.jpeg)'
- en: Application deployment with containers ([https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf](https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf))
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器进行应用部署（[https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf](https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf)）
- en: With Docker, containers suddenly became first-class citizens. All big corporations
    such as Google, Microsoft, Red Hat, IBM, and others are now working to make containers
    mainstream.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Docker，容器突然成为了一等公民。所有大公司，如Google，Microsoft，Red Hat，IBM等，现在都在努力使容器成为主流。
- en: Docker was started as an internal project by Solomon Hykes, who is the current
    CTO of Docker, Inc., at dotCloud. It was released as open source in March 2013
    under the Apache 2.0 license. With dotCloud's platform as a service experience,
    the founders and engineers of Docker were aware of the challenges of running containers.
    So with Docker, they developed a standard way to manage containers.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是由Solomon Hykes在dotCloud内部项目启动的，他目前是Docker，Inc.的首席技术官。它于2013年3月以Apache
    2.0许可证的形式开源发布。通过dotCloud的平台即服务经验，Docker的创始人和工程师们意识到了运行容器的挑战。因此，他们开发了一种管理容器的标准方式。
- en: 'Docker uses Linux''s underlying kernel features which enable containerization.
    The following diagram depicts the execution drivers and kernel features used by
    Docker. We''ll talk about execution drivers later. Let''s look at some of the
    major kernel features that Docker uses:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用了Linux的底层内核功能来实现容器化。以下图表描述了Docker使用的执行驱动程序和内核功能。我们稍后会讨论执行驱动程序。让我们先看一些Docker使用的主要内核功能：
- en: '![Introduction](../Images/image00265.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Introduction](../Images/image00265.jpeg)'
- en: The execution drivers and kernel features used by Docker ([http://blog.docker.com/wp-content/uploads/2014/03/docker-execdriver-diagram.png](http://blog.docker.com/wp-content/uploads/2014/03/docker-execdriver-diagram.png))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用的执行驱动程序和内核功能（[http://blog.docker.com/wp-content/uploads/2014/03/docker-execdriver-diagram.png](http://blog.docker.com/wp-content/uploads/2014/03/docker-execdriver-diagram.png)）
- en: Namespaces
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: Namespaces are the building blocks of a container. There are different types
    of namespaces and each one of them isolates applications from each other. They
    are created using the clone system call. One can also attach to existing namespaces.
    Some of the namespaces used by Docker have been explained in the following sections.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是容器的构建模块。有不同类型的命名空间，每个命名空间都将应用程序相互隔离。它们是使用克隆系统调用创建的。也可以附加到现有的命名空间。Docker使用的一些命名空间在以下部分进行了解释。
- en: The pid namespace
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pid命名空间
- en: The `pid` namespace allows each container to have its own process numbering.
    Each `pid` forms its own process hierarchy. A parent namespace can see the children
    namespaces and affect them, but a child can neither see the parent namespace nor
    affect it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`pid`命名空间允许每个容器拥有自己的进程编号。每个`pid`形成自己的进程层次结构。父命名空间可以看到子命名空间并影响它们，但子命名空间既不能看到父命名空间也不能影响它。'
- en: 'If there are two levels of hierarchy, then at the top level, we would see a
    process running inside the child namespace with a different PID. So, a process
    running in a child namespace would have two PIDs: one in the child namespace and
    the other in the parent namespace. For example, if we run a program on the container
    (`container.sh`), then we can see the corresponding program on the host as well.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有两个层次结构，那么在顶层，我们将看到在子命名空间中运行的进程具有不同的PID。因此，在子命名空间中运行的进程将具有两个PID：一个在子命名空间中，另一个在父命名空间中。例如，如果我们在容器上运行一个程序（`container.sh`），那么我们也可以在主机上看到相应的程序。
- en: 'On the container:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内：
- en: '![The pid namespace](../Images/image00266.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![pid命名空间](../Images/image00266.jpeg)'
- en: 'On the host:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上：
- en: '![The pid namespace](../Images/image00267.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![pid命名空间](../Images/image00267.jpeg)'
- en: The net namespace
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: net命名空间
- en: With the `pid` namespace, we can run the same program multiple times in different
    isolated environments; for example, we can run different instances of Apache on
    different containers. But without the `net` namespace, we would not be able to
    listen on port 80 on each one of them. The `net` namespace allows us to have different
    network interfaces on each container, which solves the problem I mentioned earlier.
    Loopback interfaces would be different in each container as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`pid`命名空间，我们可以在不同的隔离环境中多次运行相同的程序；例如，我们可以在不同的容器上运行Apache的不同实例。但是没有`net`命名空间，我们将无法在每个容器上监听端口80。`net`命名空间允许我们在每个容器上拥有不同的网络接口，从而解决了我之前提到的问题。回环接口在每个容器中也会有所不同。
- en: To enable networking in containers, we can create pairs of special interfaces
    in two different `net` namespaces and allow them to talk to each other. One end
    of the special interface resides inside the container and the other in the host
    system. Generally, the interface inside the container is named `eth0`, and in
    the host system, it is given a random name such as `vethcf1a`. These special interfaces
    are then linked through a bridge (`docker0`) on the host to enable communication
    between containers and route packets.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在容器中启用网络，我们可以在两个不同的`net`命名空间中创建一对特殊接口，并允许它们彼此通信。特殊接口的一端位于容器内，另一端位于主机系统中。通常，容器内的接口被命名为`eth0`，在主机系统中，它被赋予一个随机名称，如`vethcf1a`。然后，通过主机上的桥接器（`docker0`）将这些特殊接口连接起来，以实现容器之间的通信和数据包路由。
- en: 'Inside the container, you would see something like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内，你会看到类似以下的东西：
- en: '![The net namespace](../Images/image00268.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![net命名空间](../Images/image00268.jpeg)'
- en: 'And in the host, it would look like the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上，它看起来像是这样：
- en: '![The net namespace](../Images/image00269.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![net命名空间](../Images/image00269.jpeg)'
- en: Also, each `net` namespace has its own routing table and firewall rules.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个`net`命名空间都有自己的路由表和防火墙规则。
- en: The ipc namespace
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ipc命名空间
- en: '**Inter Process Communication** (**ipc**) provides semaphores, message queues,
    and shared memory segments. It is not widely used these days but some programs
    still depend on it.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**进程间通信**（**ipc**）提供信号量、消息队列和共享内存段。这些天它并不被广泛使用，但一些程序仍然依赖它。'
- en: If the `ipc` resource created by one container is consumed by another container,
    then the application running on the first container could fail. With the `ipc`
    namespace, processes running in one namespace cannot access resources from another
    namespace.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个容器创建的`ipc`资源被另一个容器消耗，那么运行在第一个容器上的应用程序可能会失败。有了`ipc`命名空间，运行在一个命名空间中的进程无法访问另一个命名空间的资源。
- en: The mnt namespace
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mnt命名空间
- en: With just a chroot, one can inspect the relative paths of the system from a
    chrooted directory/namespace. The `mnt` namespace takes the idea of a chroot to
    the next level. With the `mnt` namespace, a container can have its own set of
    mounted filesystems and root directories. Processes in one `mnt` namespace cannot
    see the mounted filesystems of another `mnt` namespace.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 只需一个chroot，就可以检查来自chroot目录/命名空间的系统的相对路径。`mnt`命名空间将chroot的概念提升到了下一个级别。有了`mnt`命名空间，容器可以拥有自己的一组挂载的文件系统和根目录。一个`mnt`命名空间中的进程无法看到另一个`mnt`命名空间的挂载文件系统。
- en: The uts namespace
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: uts命名空间
- en: With the `uts` namespace, we can have different hostnames for each container.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`uts`命名空间，我们可以为每个容器设置不同的主机名。
- en: The user namespace
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户命名空间
- en: With `user` namespace support, we can have users who have a nonzero ID on the
    host but can have a zero ID inside the container. This is because the `user` namespace
    allows per namespace mappings of users and groups IDs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`user`命名空间支持，我们可以在主机上拥有非零ID的用户，但在容器内可以拥有零ID。这是因为`user`命名空间允许用户和组ID的每个命名空间映射。
- en: There are ways to share namespaces between the host and container and container
    and container. We'll see how to do that in subsequent chapters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以在主机和容器之间以及容器和容器之间共享命名空间。我们将在后续章节中看到如何做到这一点。
- en: Cgroups
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cgroups
- en: '**Control Groups** (**cgroups**) provide resource limitations and accounting
    for containers. From the Linux Kernel documentation:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制组**（**cgroups**）为容器提供资源限制和计量。来自Linux内核文档：'
- en: '*Control Groups provide a mechanism for aggregating/partitioning sets of tasks,
    and all their future children, into hierarchical groups with specialized behaviour.*'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*控制组提供了一种聚合/分区任务集的机制，并将所有未来的子任务分成具有特定行为的分层组。*'
- en: In simple terms, they can be compared to the `ulimit` shell command or the `setrlimit`
    system call. Instead of setting the resource limit to a single process, cgroups
    allow the limiting of resources to a group of processes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，它们可以与`ulimit` shell命令或`setrlimit`系统调用进行比较。cgroups允许将资源限制设置为一组进程，而不是单个进程。
- en: 'Control groups are split into different subsystems, such as CPU, CPU sets,
    memory block I/O, and so on. Each subsystem can be used independently or can be
    grouped with others. The features that cgroups provide are:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 控制组分为不同的子系统，如CPU、CPU集、内存块I/O等。每个子系统可以独立使用，也可以与其他子系统分组。cgroups提供的功能包括：
- en: '**Resource limiting**: For example, one cgroup can be bound to specific CPUs,
    so all processes in that group would run off given CPUs only'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源限制**：例如，一个cgroup可以绑定到特定的CPU，因此该组中的所有进程只能在给定的CPU上运行'
- en: '**Prioritization**: Some groups may get a larger share of CPUs'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优先级**：一些组可能会获得更多的CPU份额'
- en: '**Accounting**: You can measure the resource usage of different subsystems
    for billing'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计量**：您可以测量不同子系统的资源使用情况以进行计费'
- en: '**Control**: Freezing and restarting groups'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制**：冻结和重新启动组'
- en: 'Some of the subsystems that can be managed by cgroups are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可以由cgroups管理的子系统如下：
- en: '**blkio**: It sets I/O access to and from block devices such as disk, SSD,
    and so on'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**blkio**：它设置对块设备（如磁盘、SSD等）的I/O访问'
- en: '**Cpu**: It limits access to CPU'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cpu**：它限制对CPU的访问'
- en: '**Cpuacct**: It generates CPU resource utilization'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cpuacct**：它生成CPU资源利用率'
- en: '**Cpuset**: It assigns the CPUs on a multicore system to tasks in a cgroup'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cpuset**：它将多核系统上的CPU分配给cgroup中的任务'
- en: '**Devices**: It devises access to a set of tasks in a cgroup'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Devices**：它为cgroup中的一组任务提供访问'
- en: '**Freezer**: It suspends or resumes tasks in a cgroup'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Freezer**：它暂停或恢复cgroup中的任务'
- en: '**Memory**: It sets limits on memory use by tasks in a cgroup'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Memory**：它设置cgroup中任务的内存使用限制'
- en: 'There are multiple ways to control work with cgroups. Two of the most popular
    ones are accessing the cgroup virtual filesystem manually and accessing it with
    the `libcgroup` library. To use `libcgroup` in fedora, run the following command
    to install the required packages:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以控制cgroups的工作。最流行的两种方法是手动访问cgroup虚拟文件系统和使用`libcgroup`库访问它。要在fedora中使用`libcgroup`，运行以下命令安装所需的软件包：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once installed, you can get the list of subsystems and their mount point in
    the pseudo filesystem with the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，您可以使用以下命令在伪文件系统中获取子系统及其挂载点的列表：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Cgroups](../Images/image00270.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Cgroups](../Images/image00270.jpeg)'
- en: 'Although we haven''t looked at the actual commands yet, let''s assume that
    we are running a few containers and want to get the cgroup entries for a container.
    To get those, we first need to get the container ID and then use the `lscgroup`
    command to get the cgroup entries of a container, which we can get from the following
    command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们还没有看实际的命令，但让我们假设我们正在运行一些容器，并且想要获取容器的cgroup条目。要获取这些条目，我们首先需要获取容器ID，然后使用`lscgroup`命令获取容器的cgroup条目，可以从以下命令中获取：
- en: '![Cgroups](../Images/image00271.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![Cgroups](../Images/image00271.jpeg)'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more details, visit [https://docs.docker.com/articles/runmetrics/](https://docs.docker.com/articles/runmetrics/).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息，请访问[https://docs.docker.com/articles/runmetrics/](https://docs.docker.com/articles/runmetrics/)。
- en: The Union filesystem
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联合文件系统
- en: The Union filesystem allows the files and directories of separate filesystems,
    known as layers, to be transparently overlaid to create a new virtual filesystem.
    While starting a container, Docker overlays all the layers attached to an image
    and creates a read-only filesystem. On top of that, Docker creates a read/write
    layer which is used by the container's runtime environment. Look at the *Pulling
    an image and running a container* recipe of this chapter for more details. Docker
    can use several Union filesystem variants, including AUFS, Btrfs, vfs, and DeviceMapper.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 联合文件系统允许透明地叠加分开的文件系统（称为层）的文件和目录，以创建一个新的虚拟文件系统。在启动容器时，Docker叠加附加到图像的所有层，并创建一个只读文件系统。在此基础上，Docker创建一个读/写层，容器的运行时环境使用它。有关更多详细信息，请参阅本章的*拉取图像并运行容器*部分。Docker可以使用多种联合文件系统变体，包括AUFS、Btrfs、vfs和DeviceMapper。
- en: Docker can work with different execution drivers, such as `libcontainer`, `lxc`,
    and `libvirt` to manage containers. The default execution driver is `libcontainer`,
    which comes with Docker out of the box. It can manipulate namespaces, control
    groups, capabilities, and so on for Docker.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Docker可以与不同的执行驱动程序一起工作，例如`libcontainer`、`lxc`和`libvirt`来管理容器。默认的执行驱动程序是`libcontainer`，它是Docker的默认驱动程序。它可以为Docker操作命名空间、控制组、能力等。
- en: Verifying the requirements for Docker installation
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证Docker安装的要求
- en: Docker is supported on many Linux platforms, such as RHEL, Ubuntu, Fedora, CentOS,
    Debian, Arch Linux, and so on. It is also supported on many cloud platforms, such
    as Amazon EC2, Rackspace Cloud, and Google Compute Engine. With the help of a
    virtual environment, Boot2Docker, it can also run on OS X and Microsoft Windows.
    A while back, Microsoft announced that it would add native support to Docker on
    its next Microsoft Windows release.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持许多Linux平台，如RHEL、Ubuntu、Fedora、CentOS、Debian、Arch Linux等。它也支持许多云平台，如Amazon
    EC2、Rackspace Cloud和Google Compute Engine。借助虚拟环境Boot2Docker，它也可以在OS X和Microsoft
    Windows上运行。不久前，微软宣布将在其下一个Microsoft Windows版本中添加对Docker的本机支持。
- en: In this recipe, let's verify the requirements for Docker installation. We will
    check on the system with Fedora 21 installation, though the same steps should
    work on Ubuntu as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这篇文章中，让我们验证Docker安装的要求。我们将在安装了Fedora 21的系统上进行检查，尽管相同的步骤也适用于Ubuntu。
- en: Getting ready
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Log in as root on the system with Fedora 21 installed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以root用户登录安装了Fedora 21的系统。
- en: How to do it…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Perform the following steps:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Docker is not supported on 32-bit architecture. To check the architecture on
    your system, run the following command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker不支持32位架构。要检查系统架构，请运行以下命令：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Docker is supported on kernel 3.8 or later. It has been back ported on some
    of the kernel 2.6, such as RHEL 6.5 and above. To check the kernel version, run
    the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker支持内核3.8或更高版本。它已经被后移至一些内核2.6，如RHEL 6.5及以上版本。要检查内核版本，请运行以下命令：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Running kernel should support an appropriate storage backend. Some of these
    are VFS, DeviceMapper, AUFS, Btrfs, and OverlayFS.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行的内核应支持适当的存储后端。其中一些是VFS、DeviceMapper、AUFS、Btrfs和OverlayFS。
- en: 'Mostly, the default storage backend or driver is devicemapper, which uses the
    device-mapper thin provisioning module to implement layers. It should be installed
    by default on the majority of Linux platforms. To check for device-mapper, you
    can run the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，默认的存储后端或驱动程序是devicemapper，它使用设备映射器薄配置模块来实现层。它应该默认安装在大多数Linux平台上。要检查设备映射器，您可以运行以下命令：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In most distributions, AUFS would require a modified kernel.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数发行版中，AUFS需要一个修改过的内核。
- en: 'Support for cgroups and namespaces are in kernel for sometime and should be
    enabled by default. To check for their presence, you can look at the corresponding
    configuration file of the kernel you are running. For example, on Fedora, I can
    do something like the following:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于cgroups和命名空间的支持已经在内核中有一段时间了，并且应该默认启用。要检查它们的存在，您可以查看正在运行的内核的相应配置文件。例如，在Fedora上，我可以做类似以下的事情：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: With the preceding commands, we verified the requirements for Docker installation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的命令，我们验证了Docker安装的要求。
- en: See also
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Installation document on the Docker website at [https://docs.docker.com/installation/](https://docs.docker.com/installation/)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker网站的安装文档中[https://docs.docker.com/installation/](https://docs.docker.com/installation/)
- en: Installing Docker
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: As there are many distributions which support Docker, we'll just look at the
    installation steps on Fedora 21 in this recipe. For others, you can refer to the
    installation instructions mentioned in the *See also* section of this recipe.
    Using Docker Machine, we can set up Docker hosts on local systems, on cloud providers,
    and other environments very easily. We'll cover that in a different recipe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有许多发行版支持Docker，我们将在这篇文章中只看一下Fedora 21上的安装步骤。对于其他发行版，您可以参考本文的*另请参阅*部分中提到的安装说明。使用Docker
    Machine，我们可以在本地系统、云提供商和其他环境上轻松设置Docker主机。我们将在另一篇文章中介绍这个。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Check for the prerequisites mentioned in the previous recipe.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 检查前面一篇文章中提到的先决条件。
- en: How to do it…
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Install Docker using yum:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用yum安装Docker：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding command will install Docker and all the packages required by it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将安装Docker及其所需的所有软件包。
- en: There's more…
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The default Docker daemon configuration file is located at `/etc/sysconfig/docker`,
    which is used while starting the daemon. Here are some basic operations:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的Docker守护程序配置文件位于`/etc/sysconfig/docker`，在启动守护程序时使用。以下是一些基本操作：
- en: 'To start the service:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动服务：
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To verify the installation:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证安装：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To update the package:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新软件包：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To enable the service start at boot time:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用开机启动服务：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To stop the service:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止服务：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The installation document is on the Docker website at [https://docs.docker.com/installation/](https://docs.docker.com/installation/)
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装文档位于Docker网站上的[https://docs.docker.com/installation/](https://docs.docker.com/installation/)
- en: Pulling an image and running a container
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拉取镜像并运行容器
- en: I am borrowing this recipe from the next chapter to introduce some concepts.
    Don't worry if you don't find all the explanation in this recipe. We'll cover
    all the topics in detail later in this chapter or in the next few chapters. For
    now, let's pull an image and run it. We'll also get familiar with Docker architecture
    and its components in this recipe.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我从下一章借用了这个配方来介绍一些概念。如果您在这个配方中找不到所有的解释，不要担心。我们将在本章节或接下来的几章中详细讨论所有的主题。现在，让我们拉取一个镜像并运行它。在这个配方中，我们还将熟悉Docker架构及其组件。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Get access to a system with Docker installed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 获取安装了Docker的系统访问权限。
- en: How to do it…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'To pull an image, run the following command:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要拉取一个镜像，请运行以下命令：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'List the existing images by using the following command:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令列出现有的镜像：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '![How to do it…](../Images/image00272.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到...](../Images/image00272.jpeg)'
- en: Create a container using the pulled image and list the containers as:![How to
    do it…](../Images/image00273.jpeg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用拉取的镜像创建一个容器，并列出容器为：![如何做到...](../Images/image00273.jpeg)
- en: How it works…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Docker has client-server architecture. Its binary consists of the Docker client
    and server daemon, and it can reside in the same host. The client can communicate
    via sockets or the RESTful API to either a local or remote Docker daemon. The
    Docker daemon builds, runs, and distributes containers. As shown in the following
    diagram, the Docker client sends the command to the Docker daemon running on the
    host machine. The Docker daemon also connects to either the public or local index
    to get the images requested by the client:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Docker具有客户端-服务器架构。其二进制文件包括Docker客户端和服务器守护程序，并且可以驻留在同一台主机上。客户端可以通过套接字或RESTful
    API与本地或远程Docker守护程序通信。Docker守护程序构建、运行和分发容器。如下图所示，Docker客户端将命令发送到运行在主机上的Docker守护程序。Docker守护程序还连接到公共或本地索引，以获取客户端请求的镜像：
- en: '![How it works…](../Images/image00274.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](../Images/image00274.jpeg)'
- en: Docker client-server architecture ([https://docs.docker.com/introduction/understanding-docker/](https://docs.docker.com/introduction/understanding-docker/))
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Docker客户端-服务器架构 ([https://docs.docker.com/introduction/understanding-docker/](https://docs.docker.com/introduction/understanding-docker/))
- en: So in our case, the Docker client sends a request to the daemon running on the
    local system, which then connects to the public Docker Index and downloads the
    image. Once downloaded, we can run it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的情况下，Docker客户端向在本地系统上运行的守护程序发送请求，然后守护程序连接到公共Docker索引并下载镜像。一旦下载完成，我们就可以运行它。
- en: There's more…
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Let''s explore some keywords we encountered earlier in this recipe:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些我们在这个配方中遇到的关键词：
- en: '**Images**: Docker images are read-only templates and they give us containers
    during runtime. There is the notion of a base image and layers on top of it. For
    example, we can have a base image of Fedora or Ubuntu and then we can install
    packages or make modifications over the base image to create a new layer. The
    base image and new layer can be treated as a new image. For example, in following
    figure, **Debian** is the base image and **emacs** and **Apache** are the two
    layers added on top of it. They are highly portable and can be shared easily:![There''s
    more…](../Images/image00275.jpeg)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像**：Docker图像是只读模板，在运行时它们为我们提供容器。有一个基本图像和在其上的层的概念。例如，我们可以有一个基本图像的Fedora或Ubuntu，然后我们可以安装软件包或对基本图像进行修改以创建一个新的层。基本图像和新层可以被视为一个新的图像。例如，在下图中，**Debian**是基本图像，**emacs**和**Apache**是添加在其上的两个层。它们非常易于移植，并且可以轻松共享：![更多信息...](../Images/image00275.jpeg)'
- en: Docker Image layers ([http://docs.docker.com/terms/images/docker-filesystems-multilayer.png](http://docs.docker.com/terms/images/docker-filesystems-multilayer.png))
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Docker图像层([http://docs.docker.com/terms/images/docker-filesystems-multilayer.png](http://docs.docker.com/terms/images/docker-filesystems-multilayer.png))
- en: Layers are transparently laid on top of the base image to create a single coherent
    filesystem.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 层被透明地放在基本图像的顶部，以创建一个统一的文件系统。
- en: '**Registries**: A registry holds Docker images. It can be public or private
    from where you can download or upload images. The public Docker registry is called
    **Docker Hub**, which we will cover later.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册表**：注册表保存Docker图像。它可以是公共的或私有的，您可以从中下载或上传图像。公共Docker注册表称为**Docker Hub**，我们稍后会介绍。'
- en: '**Index**: An index manages user accounts, permissions, search, tagging, and
    all that nice stuff that''s in the public web interface of the Docker registry.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**索引**：索引管理用户帐户、权限、搜索、标记以及Docker注册表公共Web界面中的所有好东西。'
- en: '**Containers**: Containers are running images that are created by combining
    the base image and the layers on top of it. They contain everything needed to
    run an application. As shown in preceding diagram, a temporary layer is also added
    while starting the container, which would get discarded if not committed after
    the container is stopped and deleted. If committed, then it would create another
    layer.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：容器是由基本图像和在其上的层组合创建的运行图像。它们包含运行应用程序所需的一切。如前图所示，在启动容器时还会添加一个临时层，如果在停止和删除容器后未提交，则会被丢弃。如果提交，则会创建另一个层。'
- en: '**Repository**: Different versions of an image can be managed by multiple tags,
    which are saved with different GUID. A repository is a collection of images tracked
    by GUIDs.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**：一个图像的不同版本可以通过多个标签进行管理，这些标签保存在不同的GUID中。仓库是由GUID跟踪的图像集合。'
- en: See also
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The documentation on the Docker website at [http://docs.docker.com/introduction/understanding-docker/](http://docs.docker.com/introduction/understanding-docker/)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档[http://docs.docker.com/introduction/understanding-docker/](http://docs.docker.com/introduction/understanding-docker/)
- en: With Docker 1.6, the Docker community and Microsoft Windows released a Docker
    native client for Windows [http://azure.microsoft.com/blog/2015/04/16/docker-client-for-windows-is-now-available](http://azure.microsoft.com/blog/2015/04/16/docker-client-for-windows-is-now-available)
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker 1.6，Docker社区和微软Windows发布了Windows的Docker本机客户端[http://azure.microsoft.com/blog/2015/04/16/docker-client-for-windows-is-now-available](http://azure.microsoft.com/blog/2015/04/16/docker-client-for-windows-is-now-available)
- en: Adding a nonroot user to administer Docker
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加非root用户以管理Docker
- en: For ease of use, we can allow a nonroot user to administer Docker by adding
    them to a Docker group.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便使用，我们可以允许非root用户通过将其添加到Docker组来管理Docker。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: 'Create the Docker group if it is not there already:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还没有，创建Docker组：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the user to whom you want to give permission to administer Docker:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建要授予管理Docker权限的用户：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Run the following command to allow the newly created user to administer Docker:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以允许新创建的用户管理Docker：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The preceding command will add a user to the Docker group. The added user will
    thus be able to perform all Docker operations. This can be the security risk.
    Visit [Chapter 9](part0092.xhtml#aid-2NNJO2 "Chapter 9. Docker Security"), *Docker
    Security* for more details.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将向Docker组添加一个用户。添加的用户因此可以执行所有Docker操作。这可能存在安全风险。请访问[第9章](part0092.xhtml#aid-2NNJO2
    "第9章。Docker安全")，*Docker安全*了解更多详情。
- en: Setting up the Docker host with Docker Machine
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Machine设置Docker主机
- en: Earlier this year, Docker released Orchestration tools ([https://blog.docker.com/2015/02/orchestrating-docker-with-machine-swarm-and-compose/](https://blog.docker.com/2015/02/orchestrating-docker-with-machine-swarm-and-compose/))
    and Machine, Swarm, and Compose deploy containers seamlessly. In this recipe,
    we'll cover Docker Machine and look at the others in later chapters. Using the
    Docker Machine tool ([https://github.com/docker/machine/](https://github.com/docker/machine/)),
    you can set up Docker hosts locally on cloud with one command. It is currently
    in beta mode and not recommended for production use. It supports environments
    such as VirtualBox, OpenStack, Google, Digital Ocean, and others. For a complete
    list, you can visit [https://github.com/docker/machine/tree/master/drivers](https://github.com/docker/machine/tree/master/drivers).
    Let's use this tool and set up a host in Google Cloud.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 今年早些时候，Docker发布了编排工具（[https://blog.docker.com/2015/02/orchestrating-docker-with-machine-swarm-and-compose/](https://blog.docker.com/2015/02/orchestrating-docker-with-machine-swarm-and-compose/)）和Machine、Swarm和Compose可以无缝部署容器。在这个配方中，我们将介绍Docker
    Machine，并在以后的章节中查看其他内容。使用Docker Machine工具（[https://github.com/docker/machine/](https://github.com/docker/machine/)），您可以使用一个命令在本地云上设置Docker主机。它目前处于测试模式，不建议用于生产。它支持诸如VirtualBox、OpenStack、Google、Digital
    Ocean等环境。有关完整列表，您可以访问[https://github.com/docker/machine/tree/master/drivers](https://github.com/docker/machine/tree/master/drivers)。让我们使用这个工具在Google
    Cloud中设置一个主机。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will be using Docker Machine just for this recipe. Recipes mentioned in this
    or other chapters may or may not work on the host set up by Docker Machine.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仅在本配方中使用Docker Machine。本章或其他章节中提到的配方可能在Docker Machine设置的主机上工作或不工作。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Docker Machine does not appear with the default installation. You need to download
    it from its GitHub releases link ([https://github.com/docker/machine/releases](https://github.com/docker/machine/releases)).
    Please check the latest version and distribution before downloading. As a root
    user, download the binary and make it executable:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Machine不会出现在默认安装中。您需要从其GitHub发布链接（[https://github.com/docker/machine/releases](https://github.com/docker/machine/releases)）下载它。请在下载之前检查最新版本和分发。作为root用户，下载二进制文件并使其可执行：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you don''t have an account on **Google Compute Engine** (**GCE**), then
    you can sign up for a free trial ([https://cloud.google.com/compute/docs/signup](https://cloud.google.com/compute/docs/signup))
    to try this recipe. I am assuming that you have a project on GCE and have the
    Google Cloud SDK installed on the system on which you downloaded Docker Machine
    binary. If not, then you can follow these steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在**Google Compute Engine**（**GCE**）上没有帐户，那么您可以注册免费试用（[https://cloud.google.com/compute/docs/signup](https://cloud.google.com/compute/docs/signup)）来尝试这个配方。我假设您在GCE上有一个项目，并且在下载Docker
    Machine二进制文件的系统上安装了Google Cloud SDK。如果没有，那么您可以按照以下步骤操作：
- en: 'Set up the Google Cloud SDK on your local system:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地系统上设置Google Cloud SDK：
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Create a project on GCE ([https://console.developers.google.com/project](https://console.developers.google.com/project))
    and get its project ID. Please note that the project name and its ID are different.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GCE上创建一个项目（[https://console.developers.google.com/project](https://console.developers.google.com/project)）并获取其项目ID。请注意，项目名称和其ID是不同的。
- en: Go to the project home page and under the **APIs & auth** section, select **APIs**,
    and enable Google **Compute Engine API**.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到项目主页，在**API和身份验证**部分下，选择**API**，并启用Google **Compute Engine API**。
- en: How to do it…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Assign the project ID we collected to a variable, `GCE_PROJECT`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们收集到的项目ID分配给变量`GCE_PROJECT`：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the following command and enter the code which is provided on the popped
    up web browser:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令并输入弹出的网页浏览器上提供的代码：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'List the existing hosts managed by Docker Machine:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出Docker Machine管理的现有主机：
- en: '[PRE21]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![How to do it…](../Images/image00276.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](../Images/image00276.jpeg)'
- en: You can manage multiple hosts with Docker Machine. The `*` indicates the active
    one.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Docker Machine管理多个主机。`*`表示活动主机。
- en: 'To display the commands to set up the environment for the Docker client:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示设置Docker客户端环境的命令：
- en: '[PRE22]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![How to do it…](../Images/image00277.jpeg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](../Images/image00277.jpeg)'
- en: So, if you point the Docker client with the preceding environment variables,
    we would connect to the Docker daemon running on the GCE.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果使用前面的环境变量指向Docker客户端，我们将连接到在GCE上运行的Docker守护程序。
- en: 'And to point the Docker client to use our newly created machine, run the following
    command:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并且要指定Docker客户端使用我们新创建的机器，请运行以下命令：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From now on, all the Docker commands will run on the machine we provisioned
    on GCE, until the preceding environment variables are set.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，所有Docker命令都将在我们在GCE上预配的机器上运行，直到设置前面的环境变量。
- en: How it works…
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Docker Machine connects to the cloud provider and sets up a Linux VM with Docker
    Engine. It creates a `.docker/machine/` directory under the current user's home
    directory to save the configuration.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Machine连接到云提供商并设置带有Docker Engine的Linux VM。它在当前用户的主目录下创建一个`.docker/machine/`目录以保存配置。
- en: There's more…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Docker Machine provides management commands, such as `create`, `start`, `stop`,
    `restart`, `kill`, `remove`, `ssh`, and others to manage machines. For detailed
    options, look for the help option of Docker Machine:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Machine提供管理命令，如`create`、`start`、`stop`、`restart`、`kill`、`remove`、`ssh`和其他命令来管理机器。有关详细选项，请查找Docker
    Machine的帮助选项：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can use the `--driver/-d` option to create choosing one of the many endpoints
    available for deployment. For example, to set up the environment with VirtualBox,
    run the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`--driver/-d`选项来选择部署的许多端点之一。例如，要使用VirtualBox设置环境，请运行以下命令：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![There''s more…](../Images/image00278.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](../Images/image00278.jpeg)'
- en: Here, `dev` is the machine name. By default, the latest deployed machine becomes
    primary.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`dev`是机器名称。默认情况下，最新部署的机器将成为主机。
- en: See also
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Documentation on the Docker website at [https://docs.docker.com/machine/](https://docs.docker.com/machine/)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档[https://docs.docker.com/machine/](https://docs.docker.com/machine/)
- en: Guide to setting up Docker on Google Compute Engine at [https://docs.docker.com/installation/google/](https://docs.docker.com/installation/google/)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://docs.docker.com/installation/google/](https://docs.docker.com/installation/google/)上设置Docker在Google
    Compute Engine上的指南
- en: Finding help with the Docker command line
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker命令行查找帮助
- en: Docker commands are well documented and can be referred to whenever needed.
    Lots of documentation is available online as well, but it might differ from the
    documentation for the Docker version you are running.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Docker命令有很好的文档，可以在需要时进行参考。在线文档也有很多，但可能与您正在运行的Docker版本的文档不同。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Install Docker on your system.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的系统上安装Docker。
- en: How to do it…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'On a Linux-based system, you can use the `man` command to find help as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基于Linux的系统上，您可以使用`man`命令查找帮助，如下所示：
- en: '[PRE26]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Subcommand-specific help can also be found with any of the following commands:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以使用以下任何命令找到特定子命令的帮助：
- en: '[PRE27]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: How it works…
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The `man` command uses the `man` pages installed by the Docker package to show
    help.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`man`命令使用Docker软件包安装的`man`页面显示帮助信息。'
- en: See also
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Documentation on the Docker website at [http://docs.docker.com/reference/commandline/cli/](http://docs.docker.com/reference/commandline/cli/)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档位于[http://docs.docker.com/reference/commandline/cli/](http://docs.docker.com/reference/commandline/cli/)
